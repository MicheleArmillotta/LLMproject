[
  {
    "function_name": "xit_iso9660_fs(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/isofs/inode.c",
    "lines": "1546-1553",
    "snippet": "tatic void __exit exit_iso9660_fs(void)\n{\n        unregister_filesystem(&iso9660_fs_type);\n#ifdef CONFIG_ZISOFS\n\tzisofs_cleanup();\n#endif\n\tdestroy_inodecache();\n}",
    "includes": [
      "include \"zisofs.h\"",
      "include \"isofs.h\"\n#",
      "include <linux/user_namespace.h>",
      "include <linux/mpage.h>\n#",
      "include <linux/parser.h>\n#",
      "include <linux/cdrom.h>\n#",
      "include <linux/statfs.h>\n#",
      "include <linux/ctype.h>\n#",
      "include <linux/nls.h>\n#",
      "include <linux/slab.h>\n#",
      "include <linux/module.h>",
      "include <linux/init.h>\n#"
    ],
    "macros_used": [],
    "globals_used": [
      "tatic struct file_system_type iso9660_fs_type = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"iso9660\",\n\t.mount\t\t= isofs_mount,\n\t.kill_sb\t= kill_block_super,\n\t.fs_flags\t= FS_REQUIRES_DEV,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "estroy_inodecache(",
          "args": [],
          "line": 1552
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isofs_cleanup(",
          "args": [],
          "line": 1550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nregister_filesystem(",
          "args": [
            "iso9660_fs_type)"
          ],
          "line": 1548
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"zisofs.h\"\ninclude \"isofs.h\"\n#\ninclude <linux/user_namespace.h>\ninclude <linux/mpage.h>\n#\ninclude <linux/parser.h>\n#\ninclude <linux/cdrom.h>\n#\ninclude <linux/statfs.h>\n#\ninclude <linux/ctype.h>\n#\ninclude <linux/nls.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/module.h>\ninclude <linux/init.h>\n#\n\ntatic struct file_system_type iso9660_fs_type = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"iso9660\",\n\t.mount\t\t= isofs_mount,\n\t.kill_sb\t= kill_block_super,\n\t.fs_flags\t= FS_REQUIRES_DEV,\n};\n\ntatic void __exit exit_iso9660_fs(void)\n{\n        unregister_filesystem(&iso9660_fs_type);\n#ifdef CONFIG_ZISOFS\n\tzisofs_cleanup();\n#endif\n\tdestroy_inodecache();\n}"
  },
  {
    "function_name": "nit_iso9660_fs(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/isofs/inode.c",
    "lines": "1522-1544",
    "snippet": "tatic int __init init_iso9660_fs(void)\n{\n\tint err = init_inodecache();\n\tif (err)\n\t\tgoto out;\n#ifdef CONFIG_ZISOFS\n\terr = zisofs_init();\n\tif (err)\n\t\tgoto out1;\n#endif\n\terr = register_filesystem(&iso9660_fs_type);\n\tif (err)\n\t\tgoto out2;\n\treturn 0;\nout2:\n#ifdef CONFIG_ZISOFS\n\tzisofs_cleanup();\nout1:\n#endif\n\tdestroy_inodecache();\nout:\n\treturn err;\n}",
    "includes": [
      "include \"zisofs.h\"",
      "include \"isofs.h\"\n#",
      "include <linux/user_namespace.h>",
      "include <linux/mpage.h>\n#",
      "include <linux/parser.h>\n#",
      "include <linux/cdrom.h>\n#",
      "include <linux/statfs.h>\n#",
      "include <linux/ctype.h>\n#",
      "include <linux/nls.h>\n#",
      "include <linux/slab.h>\n#",
      "include <linux/module.h>",
      "include <linux/init.h>\n#"
    ],
    "macros_used": [],
    "globals_used": [
      "tatic struct file_system_type iso9660_fs_type = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"iso9660\",\n\t.mount\t\t= isofs_mount,\n\t.kill_sb\t= kill_block_super,\n\t.fs_flags\t= FS_REQUIRES_DEV,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "estroy_inodecache(",
          "args": [],
          "line": 1541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "egister_filesystem(",
          "args": [
            "iso9660_fs_type)"
          ],
          "line": 1532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isofs_init(",
          "args": [],
          "line": 1528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nit_inodecache(",
          "args": [],
          "line": 1524
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"zisofs.h\"\ninclude \"isofs.h\"\n#\ninclude <linux/user_namespace.h>\ninclude <linux/mpage.h>\n#\ninclude <linux/parser.h>\n#\ninclude <linux/cdrom.h>\n#\ninclude <linux/statfs.h>\n#\ninclude <linux/ctype.h>\n#\ninclude <linux/nls.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/module.h>\ninclude <linux/init.h>\n#\n\ntatic struct file_system_type iso9660_fs_type = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"iso9660\",\n\t.mount\t\t= isofs_mount,\n\t.kill_sb\t= kill_block_super,\n\t.fs_flags\t= FS_REQUIRES_DEV,\n};\n\ntatic int __init init_iso9660_fs(void)\n{\n\tint err = init_inodecache();\n\tif (err)\n\t\tgoto out;\n#ifdef CONFIG_ZISOFS\n\terr = zisofs_init();\n\tif (err)\n\t\tgoto out1;\n#endif\n\terr = register_filesystem(&iso9660_fs_type);\n\tif (err)\n\t\tgoto out2;\n\treturn 0;\nout2:\n#ifdef CONFIG_ZISOFS\n\tzisofs_cleanup();\nout1:\n#endif\n\tdestroy_inodecache();\nout:\n\treturn err;\n}"
  },
  {
    "function_name": "sofs_mount(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/isofs/inode.c",
    "lines": "1503-1510",
    "snippet": "tatic struct dentry *isofs_mount(struct file_system_type *fs_type,\n\tint flags, const char *dev_name, void *data)\n{\n\t/* We don't support read-write mounts */\n\tif (!(flags & MS_RDONLY))\n\t\treturn ERR_PTR(-EACCES);\n\treturn mount_bdev(fs_type, flags, dev_name, data, isofs_fill_super);\n}",
    "includes": [
      "include \"zisofs.h\"",
      "include \"isofs.h\"\n#",
      "include <linux/user_namespace.h>",
      "include <linux/mpage.h>\n#",
      "include <linux/parser.h>\n#",
      "include <linux/cdrom.h>\n#",
      "include <linux/statfs.h>\n#",
      "include <linux/ctype.h>\n#",
      "include <linux/nls.h>\n#",
      "include <linux/slab.h>\n#",
      "include <linux/module.h>",
      "include <linux/init.h>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ount_bdev(",
          "args": [
            "s_type,",
            "lags,",
            "ev_name,",
            "ata,",
            "sofs_fill_super)"
          ],
          "line": 1509
        },
        "resolved": true,
        "details": {
          "function_name": "ount_bdev(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/super.c",
          "lines": "949-1023",
          "snippet": "truct dentry *mount_bdev(struct file_system_type *fs_type,\n\tint flags, const char *dev_name, void *data,\n\tint (*fill_super)(struct super_block *, void *, int))\n{\n\tstruct block_device *bdev;\n\tstruct super_block *s;\n\tfmode_t mode = FMODE_READ | FMODE_EXCL;\n\tint error = 0;\n\n\tif (!(flags & MS_RDONLY))\n\t\tmode |= FMODE_WRITE;\n\n\tbdev = blkdev_get_by_path(dev_name, mode, fs_type);\n\tif (IS_ERR(bdev))\n\t\treturn ERR_CAST(bdev);\n\n\t/*\n\t * once the super is inserted into the list by sget, s_umount\n\t * will protect the lockfs code from trying to start a snapshot\n\t * while we are mounting\n\t */\n\tmutex_lock(&bdev->bd_fsfreeze_mutex);\n\tif (bdev->bd_fsfreeze_count > 0) {\n\t\tmutex_unlock(&bdev->bd_fsfreeze_mutex);\n\t\terror = -EBUSY;\n\t\tgoto error_bdev;\n\t}\n\ts = sget(fs_type, test_bdev_super, set_bdev_super, flags | MS_NOSEC,\n\t\t bdev);\n\tmutex_unlock(&bdev->bd_fsfreeze_mutex);\n\tif (IS_ERR(s))\n\t\tgoto error_s;\n\n\tif (s->s_root) {\n\t\tif ((flags ^ s->s_flags) & MS_RDONLY) {\n\t\t\tdeactivate_locked_super(s);\n\t\t\terror = -EBUSY;\n\t\t\tgoto error_bdev;\n\t\t}\n\n\t\t/*\n\t\t * s_umount nests inside bd_mutex during\n\t\t * __invalidate_device().  blkdev_put() acquires\n\t\t * bd_mutex and can't be called under s_umount.  Drop\n\t\t * s_umount temporarily.  This is safe as we're\n\t\t * holding an active reference.\n\t\t */\n\t\tup_write(&s->s_umount);\n\t\tblkdev_put(bdev, mode);\n\t\tdown_write(&s->s_umount);\n\t} else {\n\t\tchar b[BDEVNAME_SIZE];\n\n\t\ts->s_mode = mode;\n\t\tstrlcpy(s->s_id, bdevname(bdev, b), sizeof(s->s_id));\n\t\tsb_set_blocksize(s, block_size(bdev));\n\t\terror = fill_super(s, data, flags & MS_SILENT ? 1 : 0);\n\t\tif (error) {\n\t\t\tdeactivate_locked_super(s);\n\t\t\tgoto error;\n\t\t}\n\n\t\ts->s_flags |= MS_ACTIVE;\n\t\tbdev->bd_super = s;\n\t}\n\n\treturn dget(s->s_root);\n\nerror_s:\n\terror = PTR_ERR(s);\nerror_bdev:\n\tblkdev_put(bdev, mode);\nerror:\n\treturn ERR_PTR(error);\n}",
          "includes": [
            "include \"internal.h\"",
            "include <linux/lockdep.h>\n#",
            "include <linux/fsnotify.h>\n#",
            "include <linux/cleancache.h>\n#",
            "include <linux/rculist_bl.h>\n#",
            "include <linux/backing-dev.h>\n#",
            "include <linux/mutex.h>\n#",
            "include <linux/idr.h>\n#",
            "include <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#",
            "include <linux/security.h>\n#",
            "include <linux/mount.h>\n#",
            "include <linux/blkdev.h>\n#",
            "include <linux/slab.h>\n#",
            "include <linux/export.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"internal.h\"\ninclude <linux/lockdep.h>\n#\ninclude <linux/fsnotify.h>\n#\ninclude <linux/cleancache.h>\n#\ninclude <linux/rculist_bl.h>\n#\ninclude <linux/backing-dev.h>\n#\ninclude <linux/mutex.h>\n#\ninclude <linux/idr.h>\n#\ninclude <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#\ninclude <linux/security.h>\n#\ninclude <linux/mount.h>\n#\ninclude <linux/blkdev.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/export.h>\n#\n\ntruct dentry *mount_bdev(struct file_system_type *fs_type,\n\tint flags, const char *dev_name, void *data,\n\tint (*fill_super)(struct super_block *, void *, int))\n{\n\tstruct block_device *bdev;\n\tstruct super_block *s;\n\tfmode_t mode = FMODE_READ | FMODE_EXCL;\n\tint error = 0;\n\n\tif (!(flags & MS_RDONLY))\n\t\tmode |= FMODE_WRITE;\n\n\tbdev = blkdev_get_by_path(dev_name, mode, fs_type);\n\tif (IS_ERR(bdev))\n\t\treturn ERR_CAST(bdev);\n\n\t/*\n\t * once the super is inserted into the list by sget, s_umount\n\t * will protect the lockfs code from trying to start a snapshot\n\t * while we are mounting\n\t */\n\tmutex_lock(&bdev->bd_fsfreeze_mutex);\n\tif (bdev->bd_fsfreeze_count > 0) {\n\t\tmutex_unlock(&bdev->bd_fsfreeze_mutex);\n\t\terror = -EBUSY;\n\t\tgoto error_bdev;\n\t}\n\ts = sget(fs_type, test_bdev_super, set_bdev_super, flags | MS_NOSEC,\n\t\t bdev);\n\tmutex_unlock(&bdev->bd_fsfreeze_mutex);\n\tif (IS_ERR(s))\n\t\tgoto error_s;\n\n\tif (s->s_root) {\n\t\tif ((flags ^ s->s_flags) & MS_RDONLY) {\n\t\t\tdeactivate_locked_super(s);\n\t\t\terror = -EBUSY;\n\t\t\tgoto error_bdev;\n\t\t}\n\n\t\t/*\n\t\t * s_umount nests inside bd_mutex during\n\t\t * __invalidate_device().  blkdev_put() acquires\n\t\t * bd_mutex and can't be called under s_umount.  Drop\n\t\t * s_umount temporarily.  This is safe as we're\n\t\t * holding an active reference.\n\t\t */\n\t\tup_write(&s->s_umount);\n\t\tblkdev_put(bdev, mode);\n\t\tdown_write(&s->s_umount);\n\t} else {\n\t\tchar b[BDEVNAME_SIZE];\n\n\t\ts->s_mode = mode;\n\t\tstrlcpy(s->s_id, bdevname(bdev, b), sizeof(s->s_id));\n\t\tsb_set_blocksize(s, block_size(bdev));\n\t\terror = fill_super(s, data, flags & MS_SILENT ? 1 : 0);\n\t\tif (error) {\n\t\t\tdeactivate_locked_super(s);\n\t\t\tgoto error;\n\t\t}\n\n\t\ts->s_flags |= MS_ACTIVE;\n\t\tbdev->bd_super = s;\n\t}\n\n\treturn dget(s->s_root);\n\nerror_s:\n\terror = PTR_ERR(s);\nerror_bdev:\n\tblkdev_put(bdev, mode);\nerror:\n\treturn ERR_PTR(error);\n}"
        }
      },
      {
        "call_info": {
          "callee": "RR_PTR(",
          "args": [
            "EACCES)"
          ],
          "line": 1508
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"zisofs.h\"\ninclude \"isofs.h\"\n#\ninclude <linux/user_namespace.h>\ninclude <linux/mpage.h>\n#\ninclude <linux/parser.h>\n#\ninclude <linux/cdrom.h>\n#\ninclude <linux/statfs.h>\n#\ninclude <linux/ctype.h>\n#\ninclude <linux/nls.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/module.h>\ninclude <linux/init.h>\n#\n\ntatic struct dentry *isofs_mount(struct file_system_type *fs_type,\n\tint flags, const char *dev_name, void *data)\n{\n\t/* We don't support read-write mounts */\n\tif (!(flags & MS_RDONLY))\n\t\treturn ERR_PTR(-EACCES);\n\treturn mount_bdev(fs_type, flags, dev_name, data, isofs_fill_super);\n}"
  },
  {
    "function_name": "_isofs_iget(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/isofs/inode.c",
    "lines": "1466-1501",
    "snippet": "truct inode *__isofs_iget(struct super_block *sb,\n\t\t\t   unsigned long block,\n\t\t\t   unsigned long offset,\n\t\t\t   int relocated)\n{\n\tunsigned long hashval;\n\tstruct inode *inode;\n\tstruct isofs_iget5_callback_data data;\n\tlong ret;\n\n\tif (offset >= 1ul << sb->s_blocksize_bits)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tdata.block = block;\n\tdata.offset = offset;\n\n\thashval = (block << sb->s_blocksize_bits) | offset;\n\n\tinode = iget5_locked(sb, hashval, &isofs_iget5_test,\n\t\t\t\t&isofs_iget5_set, &data);\n\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (inode->i_state & I_NEW) {\n\t\tret = isofs_read_inode(inode, relocated);\n\t\tif (ret < 0) {\n\t\t\tiget_failed(inode);\n\t\t\tinode = ERR_PTR(ret);\n\t\t} else {\n\t\t\tunlock_new_inode(inode);\n\t\t}\n\t}\n\n\treturn inode;\n}",
    "includes": [
      "include \"zisofs.h\"",
      "include \"isofs.h\"\n#",
      "include <linux/user_namespace.h>",
      "include <linux/mpage.h>\n#",
      "include <linux/parser.h>\n#",
      "include <linux/cdrom.h>\n#",
      "include <linux/statfs.h>\n#",
      "include <linux/ctype.h>\n#",
      "include <linux/nls.h>\n#",
      "include <linux/slab.h>\n#",
      "include <linux/module.h>",
      "include <linux/init.h>\n#"
    ],
    "macros_used": [],
    "globals_used": [
      "tatic int isofs_read_inode(struct inode *, int relocated);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "nlock_new_inode(",
          "args": [
            "node)"
          ],
          "line": 1496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RR_PTR(",
          "args": [
            "et)"
          ],
          "line": 1494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_failed(",
          "args": [
            "node)"
          ],
          "line": 1493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sofs_read_inode(",
          "args": [
            "node,",
            "elocated)"
          ],
          "line": 1491
        },
        "resolved": true,
        "details": {
          "function_name": "sofs_read_inode(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/isofs/inode.c",
          "lines": "1242-1436",
          "snippet": "tatic int isofs_read_inode(struct inode *inode, int relocated)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct isofs_sb_info *sbi = ISOFS_SB(sb);\n\tunsigned long bufsize = ISOFS_BUFFER_SIZE(inode);\n\tunsigned long block;\n\tint high_sierra = sbi->s_high_sierra;\n\tstruct buffer_head *bh = NULL;\n\tstruct iso_directory_record *de;\n\tstruct iso_directory_record *tmpde = NULL;\n\tunsigned int de_len;\n\tunsigned long offset;\n\tstruct iso_inode_info *ei = ISOFS_I(inode);\n\tint ret = -EIO;\n\n\tblock = ei->i_iget5_block;\n\tbh = sb_bread(inode->i_sb, block);\n\tif (!bh)\n\t\tgoto out_badread;\n\n\toffset = ei->i_iget5_offset;\n\n\tde = (struct iso_directory_record *) (bh->b_data + offset);\n\tde_len = *(unsigned char *) de;\n\n\tif (offset + de_len > bufsize) {\n\t\tint frag1 = bufsize - offset;\n\n\t\ttmpde = kmalloc(de_len, GFP_KERNEL);\n\t\tif (tmpde == NULL) {\n\t\t\tprintk(KERN_INFO \"%s: out of memory\\n\", __func__);\n\t\t\tret = -ENOMEM;\n\t\t\tgoto fail;\n\t\t}\n\t\tmemcpy(tmpde, bh->b_data + offset, frag1);\n\t\tbrelse(bh);\n\t\tbh = sb_bread(inode->i_sb, ++block);\n\t\tif (!bh)\n\t\t\tgoto out_badread;\n\t\tmemcpy((char *)tmpde+frag1, bh->b_data, de_len - frag1);\n\t\tde = tmpde;\n\t}\n\n\tinode->i_ino = isofs_get_ino(ei->i_iget5_block,\n\t\t\t\t\tei->i_iget5_offset,\n\t\t\t\t\tISOFS_BUFFER_BITS(inode));\n\n\t/* Assume it is a normal-format file unless told otherwise */\n\tei->i_file_format = isofs_file_normal;\n\n\tif (de->flags[-high_sierra] & 2) {\n\t\tif (sbi->s_dmode != ISOFS_INVALID_MODE)\n\t\t\tinode->i_mode = S_IFDIR | sbi->s_dmode;\n\t\telse\n\t\t\tinode->i_mode = S_IFDIR | S_IRUGO | S_IXUGO;\n\t\tset_nlink(inode, 1);\t/*\n\t\t\t\t\t * Set to 1.  We know there are 2, but\n\t\t\t\t\t * the find utility tries to optimize\n\t\t\t\t\t * if it is 2, and it screws up.  It is\n\t\t\t\t\t * easier to give 1 which tells find to\n\t\t\t\t\t * do it the hard way.\n\t\t\t\t\t */\n\t} else {\n\t\tif (sbi->s_fmode != ISOFS_INVALID_MODE) {\n\t\t\tinode->i_mode = S_IFREG | sbi->s_fmode;\n\t\t} else {\n\t\t\t/*\n\t\t\t * Set default permissions: r-x for all.  The disc\n\t\t\t * could be shared with DOS machines so virtually\n\t\t\t * anything could be a valid executable.\n\t\t\t */\n\t\t\tinode->i_mode = S_IFREG | S_IRUGO | S_IXUGO;\n\t\t}\n\t\tset_nlink(inode, 1);\n\t}\n\tinode->i_uid = sbi->s_uid;\n\tinode->i_gid = sbi->s_gid;\n\tinode->i_blocks = 0;\n\n\tei->i_format_parm[0] = 0;\n\tei->i_format_parm[1] = 0;\n\tei->i_format_parm[2] = 0;\n\n\tei->i_section_size = isonum_733(de->size);\n\tif (de->flags[-high_sierra] & 0x80) {\n\t\tret = isofs_read_level3_size(inode);\n\t\tif (ret < 0)\n\t\t\tgoto fail;\n\t\tret = -EIO;\n\t} else {\n\t\tei->i_next_section_block = 0;\n\t\tei->i_next_section_offset = 0;\n\t\tinode->i_size = isonum_733(de->size);\n\t}\n\n\t/*\n\t * Some dipshit decided to store some other bit of information\n\t * in the high byte of the file length.  Truncate size in case\n\t * this CDROM was mounted with the cruft option.\n\t */\n\n\tif (sbi->s_cruft)\n\t\tinode->i_size &= 0x00ffffff;\n\n\tif (de->interleave[0]) {\n\t\tprintk(KERN_DEBUG \"ISOFS: Interleaved files not (yet) supported.\\n\");\n\t\tinode->i_size = 0;\n\t}\n\n\t/* I have no idea what file_unit_size is used for, so\n\t   we will flag it for now */\n\tif (de->file_unit_size[0] != 0) {\n\t\tprintk(KERN_DEBUG \"ISOFS: File unit size != 0 for ISO file (%ld).\\n\",\n\t\t\tinode->i_ino);\n\t}\n\n\t/* I have no idea what other flag bits are used for, so\n\t   we will flag it for now */\n#ifdef DEBUG\n\tif((de->flags[-high_sierra] & ~2)!= 0){\n\t\tprintk(KERN_DEBUG \"ISOFS: Unusual flag settings for ISO file \"\n\t\t\t\t\"(%ld %x).\\n\",\n\t\t\tinode->i_ino, de->flags[-high_sierra]);\n\t}\n#endif\n\n\tinode->i_mtime.tv_sec =\n\tinode->i_atime.tv_sec =\n\tinode->i_ctime.tv_sec = iso_date(de->date, high_sierra);\n\tinode->i_mtime.tv_nsec =\n\tinode->i_atime.tv_nsec =\n\tinode->i_ctime.tv_nsec = 0;\n\n\tei->i_first_extent = (isonum_733(de->extent) +\n\t\t\tisonum_711(de->ext_attr_length));\n\n\t/* Set the number of blocks for stat() - should be done before RR */\n\tinode->i_blocks = (inode->i_size + 511) >> 9;\n\n\t/*\n\t * Now test for possible Rock Ridge extensions which will override\n\t * some of these numbers in the inode structure.\n\t */\n\n\tif (!high_sierra) {\n\t\tparse_rock_ridge_inode(de, inode, relocated);\n\t\t/* if we want uid/gid set, override the rock ridge setting */\n\t\tif (sbi->s_uid_set)\n\t\t\tinode->i_uid = sbi->s_uid;\n\t\tif (sbi->s_gid_set)\n\t\t\tinode->i_gid = sbi->s_gid;\n\t}\n\t/* Now set final access rights if overriding rock ridge setting */\n\tif (S_ISDIR(inode->i_mode) && sbi->s_overriderockperm &&\n\t    sbi->s_dmode != ISOFS_INVALID_MODE)\n\t\tinode->i_mode = S_IFDIR | sbi->s_dmode;\n\tif (S_ISREG(inode->i_mode) && sbi->s_overriderockperm &&\n\t    sbi->s_fmode != ISOFS_INVALID_MODE)\n\t\tinode->i_mode = S_IFREG | sbi->s_fmode;\n\n\t/* Install the inode operations vector */\n\tif (S_ISREG(inode->i_mode)) {\n\t\tinode->i_fop = &generic_ro_fops;\n\t\tswitch (ei->i_file_format) {\n#ifdef CONFIG_ZISOFS\n\t\tcase isofs_file_compressed:\n\t\t\tinode->i_data.a_ops = &zisofs_aops;\n\t\t\tbreak;\n#endif\n\t\tdefault:\n\t\t\tinode->i_data.a_ops = &isofs_aops;\n\t\t\tbreak;\n\t\t}\n\t} else if (S_ISDIR(inode->i_mode)) {\n\t\tinode->i_op = &isofs_dir_inode_operations;\n\t\tinode->i_fop = &isofs_dir_operations;\n\t} else if (S_ISLNK(inode->i_mode)) {\n\t\tinode->i_op = &page_symlink_inode_operations;\n\t\tinode->i_data.a_ops = &isofs_symlink_aops;\n\t} else\n\t\t/* XXX - parse_rock_ridge_inode() had already set i_rdev. */\n\t\tinit_special_inode(inode, inode->i_mode, inode->i_rdev);\n\n\tret = 0;\nout:\n\tkfree(tmpde);\n\tif (bh)\n\t\tbrelse(bh);\n\treturn ret;\n\nout_badread:\n\tprintk(KERN_WARNING \"ISOFS: unable to read i-node block\\n\");\nfail:\n\tgoto out;\n}",
          "includes": [
            "include \"zisofs.h\"",
            "include \"isofs.h\"\n#",
            "include <linux/user_namespace.h>",
            "include <linux/mpage.h>\n#",
            "include <linux/parser.h>\n#",
            "include <linux/cdrom.h>\n#",
            "include <linux/statfs.h>\n#",
            "include <linux/ctype.h>\n#",
            "include <linux/nls.h>\n#",
            "include <linux/slab.h>\n#",
            "include <linux/module.h>",
            "include <linux/init.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [
            "tatic int isofs_read_inode(struct inode *, int relocated);",
            "tatic const struct address_space_operations isofs_aops = {\n\t.readpage = isofs_readpage,\n\t.readpages = isofs_readpages,\n\t.bmap = _isofs_bmap\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "include \"zisofs.h\"\ninclude \"isofs.h\"\n#\ninclude <linux/user_namespace.h>\ninclude <linux/mpage.h>\n#\ninclude <linux/parser.h>\n#\ninclude <linux/cdrom.h>\n#\ninclude <linux/statfs.h>\n#\ninclude <linux/ctype.h>\n#\ninclude <linux/nls.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/module.h>\ninclude <linux/init.h>\n#\n\ntatic int isofs_read_inode(struct inode *, int relocated);\ntatic const struct address_space_operations isofs_aops = {\n\t.readpage = isofs_readpage,\n\t.readpages = isofs_readpages,\n\t.bmap = _isofs_bmap\n};\n\ntatic int isofs_read_inode(struct inode *inode, int relocated)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct isofs_sb_info *sbi = ISOFS_SB(sb);\n\tunsigned long bufsize = ISOFS_BUFFER_SIZE(inode);\n\tunsigned long block;\n\tint high_sierra = sbi->s_high_sierra;\n\tstruct buffer_head *bh = NULL;\n\tstruct iso_directory_record *de;\n\tstruct iso_directory_record *tmpde = NULL;\n\tunsigned int de_len;\n\tunsigned long offset;\n\tstruct iso_inode_info *ei = ISOFS_I(inode);\n\tint ret = -EIO;\n\n\tblock = ei->i_iget5_block;\n\tbh = sb_bread(inode->i_sb, block);\n\tif (!bh)\n\t\tgoto out_badread;\n\n\toffset = ei->i_iget5_offset;\n\n\tde = (struct iso_directory_record *) (bh->b_data + offset);\n\tde_len = *(unsigned char *) de;\n\n\tif (offset + de_len > bufsize) {\n\t\tint frag1 = bufsize - offset;\n\n\t\ttmpde = kmalloc(de_len, GFP_KERNEL);\n\t\tif (tmpde == NULL) {\n\t\t\tprintk(KERN_INFO \"%s: out of memory\\n\", __func__);\n\t\t\tret = -ENOMEM;\n\t\t\tgoto fail;\n\t\t}\n\t\tmemcpy(tmpde, bh->b_data + offset, frag1);\n\t\tbrelse(bh);\n\t\tbh = sb_bread(inode->i_sb, ++block);\n\t\tif (!bh)\n\t\t\tgoto out_badread;\n\t\tmemcpy((char *)tmpde+frag1, bh->b_data, de_len - frag1);\n\t\tde = tmpde;\n\t}\n\n\tinode->i_ino = isofs_get_ino(ei->i_iget5_block,\n\t\t\t\t\tei->i_iget5_offset,\n\t\t\t\t\tISOFS_BUFFER_BITS(inode));\n\n\t/* Assume it is a normal-format file unless told otherwise */\n\tei->i_file_format = isofs_file_normal;\n\n\tif (de->flags[-high_sierra] & 2) {\n\t\tif (sbi->s_dmode != ISOFS_INVALID_MODE)\n\t\t\tinode->i_mode = S_IFDIR | sbi->s_dmode;\n\t\telse\n\t\t\tinode->i_mode = S_IFDIR | S_IRUGO | S_IXUGO;\n\t\tset_nlink(inode, 1);\t/*\n\t\t\t\t\t * Set to 1.  We know there are 2, but\n\t\t\t\t\t * the find utility tries to optimize\n\t\t\t\t\t * if it is 2, and it screws up.  It is\n\t\t\t\t\t * easier to give 1 which tells find to\n\t\t\t\t\t * do it the hard way.\n\t\t\t\t\t */\n\t} else {\n\t\tif (sbi->s_fmode != ISOFS_INVALID_MODE) {\n\t\t\tinode->i_mode = S_IFREG | sbi->s_fmode;\n\t\t} else {\n\t\t\t/*\n\t\t\t * Set default permissions: r-x for all.  The disc\n\t\t\t * could be shared with DOS machines so virtually\n\t\t\t * anything could be a valid executable.\n\t\t\t */\n\t\t\tinode->i_mode = S_IFREG | S_IRUGO | S_IXUGO;\n\t\t}\n\t\tset_nlink(inode, 1);\n\t}\n\tinode->i_uid = sbi->s_uid;\n\tinode->i_gid = sbi->s_gid;\n\tinode->i_blocks = 0;\n\n\tei->i_format_parm[0] = 0;\n\tei->i_format_parm[1] = 0;\n\tei->i_format_parm[2] = 0;\n\n\tei->i_section_size = isonum_733(de->size);\n\tif (de->flags[-high_sierra] & 0x80) {\n\t\tret = isofs_read_level3_size(inode);\n\t\tif (ret < 0)\n\t\t\tgoto fail;\n\t\tret = -EIO;\n\t} else {\n\t\tei->i_next_section_block = 0;\n\t\tei->i_next_section_offset = 0;\n\t\tinode->i_size = isonum_733(de->size);\n\t}\n\n\t/*\n\t * Some dipshit decided to store some other bit of information\n\t * in the high byte of the file length.  Truncate size in case\n\t * this CDROM was mounted with the cruft option.\n\t */\n\n\tif (sbi->s_cruft)\n\t\tinode->i_size &= 0x00ffffff;\n\n\tif (de->interleave[0]) {\n\t\tprintk(KERN_DEBUG \"ISOFS: Interleaved files not (yet) supported.\\n\");\n\t\tinode->i_size = 0;\n\t}\n\n\t/* I have no idea what file_unit_size is used for, so\n\t   we will flag it for now */\n\tif (de->file_unit_size[0] != 0) {\n\t\tprintk(KERN_DEBUG \"ISOFS: File unit size != 0 for ISO file (%ld).\\n\",\n\t\t\tinode->i_ino);\n\t}\n\n\t/* I have no idea what other flag bits are used for, so\n\t   we will flag it for now */\n#ifdef DEBUG\n\tif((de->flags[-high_sierra] & ~2)!= 0){\n\t\tprintk(KERN_DEBUG \"ISOFS: Unusual flag settings for ISO file \"\n\t\t\t\t\"(%ld %x).\\n\",\n\t\t\tinode->i_ino, de->flags[-high_sierra]);\n\t}\n#endif\n\n\tinode->i_mtime.tv_sec =\n\tinode->i_atime.tv_sec =\n\tinode->i_ctime.tv_sec = iso_date(de->date, high_sierra);\n\tinode->i_mtime.tv_nsec =\n\tinode->i_atime.tv_nsec =\n\tinode->i_ctime.tv_nsec = 0;\n\n\tei->i_first_extent = (isonum_733(de->extent) +\n\t\t\tisonum_711(de->ext_attr_length));\n\n\t/* Set the number of blocks for stat() - should be done before RR */\n\tinode->i_blocks = (inode->i_size + 511) >> 9;\n\n\t/*\n\t * Now test for possible Rock Ridge extensions which will override\n\t * some of these numbers in the inode structure.\n\t */\n\n\tif (!high_sierra) {\n\t\tparse_rock_ridge_inode(de, inode, relocated);\n\t\t/* if we want uid/gid set, override the rock ridge setting */\n\t\tif (sbi->s_uid_set)\n\t\t\tinode->i_uid = sbi->s_uid;\n\t\tif (sbi->s_gid_set)\n\t\t\tinode->i_gid = sbi->s_gid;\n\t}\n\t/* Now set final access rights if overriding rock ridge setting */\n\tif (S_ISDIR(inode->i_mode) && sbi->s_overriderockperm &&\n\t    sbi->s_dmode != ISOFS_INVALID_MODE)\n\t\tinode->i_mode = S_IFDIR | sbi->s_dmode;\n\tif (S_ISREG(inode->i_mode) && sbi->s_overriderockperm &&\n\t    sbi->s_fmode != ISOFS_INVALID_MODE)\n\t\tinode->i_mode = S_IFREG | sbi->s_fmode;\n\n\t/* Install the inode operations vector */\n\tif (S_ISREG(inode->i_mode)) {\n\t\tinode->i_fop = &generic_ro_fops;\n\t\tswitch (ei->i_file_format) {\n#ifdef CONFIG_ZISOFS\n\t\tcase isofs_file_compressed:\n\t\t\tinode->i_data.a_ops = &zisofs_aops;\n\t\t\tbreak;\n#endif\n\t\tdefault:\n\t\t\tinode->i_data.a_ops = &isofs_aops;\n\t\t\tbreak;\n\t\t}\n\t} else if (S_ISDIR(inode->i_mode)) {\n\t\tinode->i_op = &isofs_dir_inode_operations;\n\t\tinode->i_fop = &isofs_dir_operations;\n\t} else if (S_ISLNK(inode->i_mode)) {\n\t\tinode->i_op = &page_symlink_inode_operations;\n\t\tinode->i_data.a_ops = &isofs_symlink_aops;\n\t} else\n\t\t/* XXX - parse_rock_ridge_inode() had already set i_rdev. */\n\t\tinit_special_inode(inode, inode->i_mode, inode->i_rdev);\n\n\tret = 0;\nout:\n\tkfree(tmpde);\n\tif (bh)\n\t\tbrelse(bh);\n\treturn ret;\n\nout_badread:\n\tprintk(KERN_WARNING \"ISOFS: unable to read i-node block\\n\");\nfail:\n\tgoto out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "RR_PTR(",
          "args": [
            "ENOMEM)"
          ],
          "line": 1488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get5_locked(",
          "args": [
            "b,",
            "ashval,",
            "isofs_iget5_test,",
            "isofs_iget5_set,",
            "data)"
          ],
          "line": 1484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RR_PTR(",
          "args": [
            "EINVAL)"
          ],
          "line": 1477
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"zisofs.h\"\ninclude \"isofs.h\"\n#\ninclude <linux/user_namespace.h>\ninclude <linux/mpage.h>\n#\ninclude <linux/parser.h>\n#\ninclude <linux/cdrom.h>\n#\ninclude <linux/statfs.h>\n#\ninclude <linux/ctype.h>\n#\ninclude <linux/nls.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/module.h>\ninclude <linux/init.h>\n#\n\ntatic int isofs_read_inode(struct inode *, int relocated);\n\ntruct inode *__isofs_iget(struct super_block *sb,\n\t\t\t   unsigned long block,\n\t\t\t   unsigned long offset,\n\t\t\t   int relocated)\n{\n\tunsigned long hashval;\n\tstruct inode *inode;\n\tstruct isofs_iget5_callback_data data;\n\tlong ret;\n\n\tif (offset >= 1ul << sb->s_blocksize_bits)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tdata.block = block;\n\tdata.offset = offset;\n\n\thashval = (block << sb->s_blocksize_bits) | offset;\n\n\tinode = iget5_locked(sb, hashval, &isofs_iget5_test,\n\t\t\t\t&isofs_iget5_set, &data);\n\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (inode->i_state & I_NEW) {\n\t\tret = isofs_read_inode(inode, relocated);\n\t\tif (ret < 0) {\n\t\t\tiget_failed(inode);\n\t\t\tinode = ERR_PTR(ret);\n\t\t} else {\n\t\t\tunlock_new_inode(inode);\n\t\t}\n\t}\n\n\treturn inode;\n}"
  },
  {
    "function_name": "sofs_iget5_set(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/isofs/inode.c",
    "lines": "1452-1460",
    "snippet": "tatic int isofs_iget5_set(struct inode *ino, void *data)\n{\n\tstruct iso_inode_info *i = ISOFS_I(ino);\n\tstruct isofs_iget5_callback_data *d =\n\t\t(struct isofs_iget5_callback_data*)data;\n\ti->i_iget5_block = d->block;\n\ti->i_iget5_offset = d->offset;\n\treturn 0;\n}",
    "includes": [
      "include \"zisofs.h\"",
      "include \"isofs.h\"\n#",
      "include <linux/user_namespace.h>",
      "include <linux/mpage.h>\n#",
      "include <linux/parser.h>\n#",
      "include <linux/cdrom.h>\n#",
      "include <linux/statfs.h>\n#",
      "include <linux/ctype.h>\n#",
      "include <linux/nls.h>\n#",
      "include <linux/slab.h>\n#",
      "include <linux/module.h>",
      "include <linux/init.h>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "SOFS_I(",
          "args": [
            "no)"
          ],
          "line": 1454
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"zisofs.h\"\ninclude \"isofs.h\"\n#\ninclude <linux/user_namespace.h>\ninclude <linux/mpage.h>\n#\ninclude <linux/parser.h>\n#\ninclude <linux/cdrom.h>\n#\ninclude <linux/statfs.h>\n#\ninclude <linux/ctype.h>\n#\ninclude <linux/nls.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/module.h>\ninclude <linux/init.h>\n#\n\ntatic int isofs_iget5_set(struct inode *ino, void *data)\n{\n\tstruct iso_inode_info *i = ISOFS_I(ino);\n\tstruct isofs_iget5_callback_data *d =\n\t\t(struct isofs_iget5_callback_data*)data;\n\ti->i_iget5_block = d->block;\n\ti->i_iget5_offset = d->offset;\n\treturn 0;\n}"
  },
  {
    "function_name": "sofs_iget5_test(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/isofs/inode.c",
    "lines": "1443-1450",
    "snippet": "tatic int isofs_iget5_test(struct inode *ino, void *data)\n{\n\tstruct iso_inode_info *i = ISOFS_I(ino);\n\tstruct isofs_iget5_callback_data *d =\n\t\t(struct isofs_iget5_callback_data*)data;\n\treturn (i->i_iget5_block == d->block)\n\t\t&& (i->i_iget5_offset == d->offset);\n}",
    "includes": [
      "include \"zisofs.h\"",
      "include \"isofs.h\"\n#",
      "include <linux/user_namespace.h>",
      "include <linux/mpage.h>\n#",
      "include <linux/parser.h>\n#",
      "include <linux/cdrom.h>\n#",
      "include <linux/statfs.h>\n#",
      "include <linux/ctype.h>\n#",
      "include <linux/nls.h>\n#",
      "include <linux/slab.h>\n#",
      "include <linux/module.h>",
      "include <linux/init.h>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "SOFS_I(",
          "args": [
            "no)"
          ],
          "line": 1445
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"zisofs.h\"\ninclude \"isofs.h\"\n#\ninclude <linux/user_namespace.h>\ninclude <linux/mpage.h>\n#\ninclude <linux/parser.h>\n#\ninclude <linux/cdrom.h>\n#\ninclude <linux/statfs.h>\n#\ninclude <linux/ctype.h>\n#\ninclude <linux/nls.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/module.h>\ninclude <linux/init.h>\n#\n\ntatic int isofs_iget5_test(struct inode *ino, void *data)\n{\n\tstruct iso_inode_info *i = ISOFS_I(ino);\n\tstruct isofs_iget5_callback_data *d =\n\t\t(struct isofs_iget5_callback_data*)data;\n\treturn (i->i_iget5_block == d->block)\n\t\t&& (i->i_iget5_offset == d->offset);\n}"
  },
  {
    "function_name": "sofs_read_inode(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/isofs/inode.c",
    "lines": "1242-1436",
    "snippet": "tatic int isofs_read_inode(struct inode *inode, int relocated)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct isofs_sb_info *sbi = ISOFS_SB(sb);\n\tunsigned long bufsize = ISOFS_BUFFER_SIZE(inode);\n\tunsigned long block;\n\tint high_sierra = sbi->s_high_sierra;\n\tstruct buffer_head *bh = NULL;\n\tstruct iso_directory_record *de;\n\tstruct iso_directory_record *tmpde = NULL;\n\tunsigned int de_len;\n\tunsigned long offset;\n\tstruct iso_inode_info *ei = ISOFS_I(inode);\n\tint ret = -EIO;\n\n\tblock = ei->i_iget5_block;\n\tbh = sb_bread(inode->i_sb, block);\n\tif (!bh)\n\t\tgoto out_badread;\n\n\toffset = ei->i_iget5_offset;\n\n\tde = (struct iso_directory_record *) (bh->b_data + offset);\n\tde_len = *(unsigned char *) de;\n\n\tif (offset + de_len > bufsize) {\n\t\tint frag1 = bufsize - offset;\n\n\t\ttmpde = kmalloc(de_len, GFP_KERNEL);\n\t\tif (tmpde == NULL) {\n\t\t\tprintk(KERN_INFO \"%s: out of memory\\n\", __func__);\n\t\t\tret = -ENOMEM;\n\t\t\tgoto fail;\n\t\t}\n\t\tmemcpy(tmpde, bh->b_data + offset, frag1);\n\t\tbrelse(bh);\n\t\tbh = sb_bread(inode->i_sb, ++block);\n\t\tif (!bh)\n\t\t\tgoto out_badread;\n\t\tmemcpy((char *)tmpde+frag1, bh->b_data, de_len - frag1);\n\t\tde = tmpde;\n\t}\n\n\tinode->i_ino = isofs_get_ino(ei->i_iget5_block,\n\t\t\t\t\tei->i_iget5_offset,\n\t\t\t\t\tISOFS_BUFFER_BITS(inode));\n\n\t/* Assume it is a normal-format file unless told otherwise */\n\tei->i_file_format = isofs_file_normal;\n\n\tif (de->flags[-high_sierra] & 2) {\n\t\tif (sbi->s_dmode != ISOFS_INVALID_MODE)\n\t\t\tinode->i_mode = S_IFDIR | sbi->s_dmode;\n\t\telse\n\t\t\tinode->i_mode = S_IFDIR | S_IRUGO | S_IXUGO;\n\t\tset_nlink(inode, 1);\t/*\n\t\t\t\t\t * Set to 1.  We know there are 2, but\n\t\t\t\t\t * the find utility tries to optimize\n\t\t\t\t\t * if it is 2, and it screws up.  It is\n\t\t\t\t\t * easier to give 1 which tells find to\n\t\t\t\t\t * do it the hard way.\n\t\t\t\t\t */\n\t} else {\n\t\tif (sbi->s_fmode != ISOFS_INVALID_MODE) {\n\t\t\tinode->i_mode = S_IFREG | sbi->s_fmode;\n\t\t} else {\n\t\t\t/*\n\t\t\t * Set default permissions: r-x for all.  The disc\n\t\t\t * could be shared with DOS machines so virtually\n\t\t\t * anything could be a valid executable.\n\t\t\t */\n\t\t\tinode->i_mode = S_IFREG | S_IRUGO | S_IXUGO;\n\t\t}\n\t\tset_nlink(inode, 1);\n\t}\n\tinode->i_uid = sbi->s_uid;\n\tinode->i_gid = sbi->s_gid;\n\tinode->i_blocks = 0;\n\n\tei->i_format_parm[0] = 0;\n\tei->i_format_parm[1] = 0;\n\tei->i_format_parm[2] = 0;\n\n\tei->i_section_size = isonum_733(de->size);\n\tif (de->flags[-high_sierra] & 0x80) {\n\t\tret = isofs_read_level3_size(inode);\n\t\tif (ret < 0)\n\t\t\tgoto fail;\n\t\tret = -EIO;\n\t} else {\n\t\tei->i_next_section_block = 0;\n\t\tei->i_next_section_offset = 0;\n\t\tinode->i_size = isonum_733(de->size);\n\t}\n\n\t/*\n\t * Some dipshit decided to store some other bit of information\n\t * in the high byte of the file length.  Truncate size in case\n\t * this CDROM was mounted with the cruft option.\n\t */\n\n\tif (sbi->s_cruft)\n\t\tinode->i_size &= 0x00ffffff;\n\n\tif (de->interleave[0]) {\n\t\tprintk(KERN_DEBUG \"ISOFS: Interleaved files not (yet) supported.\\n\");\n\t\tinode->i_size = 0;\n\t}\n\n\t/* I have no idea what file_unit_size is used for, so\n\t   we will flag it for now */\n\tif (de->file_unit_size[0] != 0) {\n\t\tprintk(KERN_DEBUG \"ISOFS: File unit size != 0 for ISO file (%ld).\\n\",\n\t\t\tinode->i_ino);\n\t}\n\n\t/* I have no idea what other flag bits are used for, so\n\t   we will flag it for now */\n#ifdef DEBUG\n\tif((de->flags[-high_sierra] & ~2)!= 0){\n\t\tprintk(KERN_DEBUG \"ISOFS: Unusual flag settings for ISO file \"\n\t\t\t\t\"(%ld %x).\\n\",\n\t\t\tinode->i_ino, de->flags[-high_sierra]);\n\t}\n#endif\n\n\tinode->i_mtime.tv_sec =\n\tinode->i_atime.tv_sec =\n\tinode->i_ctime.tv_sec = iso_date(de->date, high_sierra);\n\tinode->i_mtime.tv_nsec =\n\tinode->i_atime.tv_nsec =\n\tinode->i_ctime.tv_nsec = 0;\n\n\tei->i_first_extent = (isonum_733(de->extent) +\n\t\t\tisonum_711(de->ext_attr_length));\n\n\t/* Set the number of blocks for stat() - should be done before RR */\n\tinode->i_blocks = (inode->i_size + 511) >> 9;\n\n\t/*\n\t * Now test for possible Rock Ridge extensions which will override\n\t * some of these numbers in the inode structure.\n\t */\n\n\tif (!high_sierra) {\n\t\tparse_rock_ridge_inode(de, inode, relocated);\n\t\t/* if we want uid/gid set, override the rock ridge setting */\n\t\tif (sbi->s_uid_set)\n\t\t\tinode->i_uid = sbi->s_uid;\n\t\tif (sbi->s_gid_set)\n\t\t\tinode->i_gid = sbi->s_gid;\n\t}\n\t/* Now set final access rights if overriding rock ridge setting */\n\tif (S_ISDIR(inode->i_mode) && sbi->s_overriderockperm &&\n\t    sbi->s_dmode != ISOFS_INVALID_MODE)\n\t\tinode->i_mode = S_IFDIR | sbi->s_dmode;\n\tif (S_ISREG(inode->i_mode) && sbi->s_overriderockperm &&\n\t    sbi->s_fmode != ISOFS_INVALID_MODE)\n\t\tinode->i_mode = S_IFREG | sbi->s_fmode;\n\n\t/* Install the inode operations vector */\n\tif (S_ISREG(inode->i_mode)) {\n\t\tinode->i_fop = &generic_ro_fops;\n\t\tswitch (ei->i_file_format) {\n#ifdef CONFIG_ZISOFS\n\t\tcase isofs_file_compressed:\n\t\t\tinode->i_data.a_ops = &zisofs_aops;\n\t\t\tbreak;\n#endif\n\t\tdefault:\n\t\t\tinode->i_data.a_ops = &isofs_aops;\n\t\t\tbreak;\n\t\t}\n\t} else if (S_ISDIR(inode->i_mode)) {\n\t\tinode->i_op = &isofs_dir_inode_operations;\n\t\tinode->i_fop = &isofs_dir_operations;\n\t} else if (S_ISLNK(inode->i_mode)) {\n\t\tinode->i_op = &page_symlink_inode_operations;\n\t\tinode->i_data.a_ops = &isofs_symlink_aops;\n\t} else\n\t\t/* XXX - parse_rock_ridge_inode() had already set i_rdev. */\n\t\tinit_special_inode(inode, inode->i_mode, inode->i_rdev);\n\n\tret = 0;\nout:\n\tkfree(tmpde);\n\tif (bh)\n\t\tbrelse(bh);\n\treturn ret;\n\nout_badread:\n\tprintk(KERN_WARNING \"ISOFS: unable to read i-node block\\n\");\nfail:\n\tgoto out;\n}",
    "includes": [
      "include \"zisofs.h\"",
      "include \"isofs.h\"\n#",
      "include <linux/user_namespace.h>",
      "include <linux/mpage.h>\n#",
      "include <linux/parser.h>\n#",
      "include <linux/cdrom.h>\n#",
      "include <linux/statfs.h>\n#",
      "include <linux/ctype.h>\n#",
      "include <linux/nls.h>\n#",
      "include <linux/slab.h>\n#",
      "include <linux/module.h>",
      "include <linux/init.h>\n#"
    ],
    "macros_used": [],
    "globals_used": [
      "tatic int isofs_read_inode(struct inode *, int relocated);",
      "tatic const struct address_space_operations isofs_aops = {\n\t.readpage = isofs_readpage,\n\t.readpages = isofs_readpages,\n\t.bmap = _isofs_bmap\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rintk(",
          "args": [
            "ERN_WARNING \"ISOFS: unable to read i-node block\\n\")"
          ],
          "line": 1433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "relse(",
          "args": [
            "h)"
          ],
          "line": 1429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free(",
          "args": [
            "mpde)"
          ],
          "line": 1427
        },
        "resolved": true,
        "details": {
          "function_name": "in_free(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/scan.c",
          "lines": "51-60",
          "snippet": "tatic inline int min_free(struct jffs2_sb_info *c)\n{\n\tuint32_t min = 2 * sizeof(struct jffs2_raw_inode);\n#ifdef CONFIG_JFFS2_FS_WRITEBUFFER\n\tif (!jffs2_can_mark_obsolete(c) && min < c->wbuf_pagesize)\n\t\treturn c->wbuf_pagesize;\n#endif\n\treturn min;\n\n}",
          "includes": [
            "include \"debug.h\"",
            "include \"summary.h\"\n#",
            "include \"nodelist.h\"\n#",
            "include <linux/compiler.h>\n#",
            "include <linux/crc32.h>\n#",
            "include <linux/pagemap.h>\n#",
            "include <linux/mtd/mtd.h>\n#",
            "include <linux/slab.h>\n#",
            "include <linux/sched.h>\n#",
            "include <linux/kernel.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"debug.h\"\ninclude \"summary.h\"\n#\ninclude \"nodelist.h\"\n#\ninclude <linux/compiler.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/pagemap.h>\n#\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/sched.h>\n#\ninclude <linux/kernel.h>\n#\n\ntatic inline int min_free(struct jffs2_sb_info *c)\n{\n\tuint32_t min = 2 * sizeof(struct jffs2_raw_inode);\n#ifdef CONFIG_JFFS2_FS_WRITEBUFFER\n\tif (!jffs2_can_mark_obsolete(c) && min < c->wbuf_pagesize)\n\t\treturn c->wbuf_pagesize;\n#endif\n\treturn min;\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "nit_special_inode(",
          "args": [
            "node,",
            "node->i_mode,",
            "node->i_rdev)"
          ],
          "line": 1423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ISLNK(",
          "args": [
            "node->i_mode)"
          ],
          "line": 1418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ISDIR(",
          "args": [
            "node->i_mode)"
          ],
          "line": 1415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ISREG(",
          "args": [
            "node->i_mode)"
          ],
          "line": 1403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ISREG(",
          "args": [
            "node->i_mode)"
          ],
          "line": 1398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ISDIR(",
          "args": [
            "node->i_mode)"
          ],
          "line": 1395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arse_rock_ridge_inode(",
          "args": [
            "e,",
            "node,",
            "elocated)"
          ],
          "line": 1387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sonum_711(",
          "args": [
            "e->ext_attr_length)"
          ],
          "line": 1376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sonum_733(",
          "args": [
            "e->extent)"
          ],
          "line": 1375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "so_date(",
          "args": [
            "e->date,",
            "igh_sierra)"
          ],
          "line": 1370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rintk(",
          "args": [
            "ERN_DEBUG \"ISOFS: Unusual flag settings for ISO file \"\n\t\t\t\t\"(%ld %x).\\n\",",
            "node->i_ino,",
            "e->flags[-high_sierra])"
          ],
          "line": 1362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rintk(",
          "args": [
            "ERN_DEBUG \"ISOFS: File unit size != 0 for ISO file (%ld).\\n\",",
            "node->i_ino)"
          ],
          "line": 1354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rintk(",
          "args": [
            "ERN_DEBUG \"ISOFS: Interleaved files not (yet) supported.\\n\")"
          ],
          "line": 1347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sonum_733(",
          "args": [
            "e->size)"
          ],
          "line": 1334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sofs_read_level3_size(",
          "args": [
            "node)"
          ],
          "line": 1327
        },
        "resolved": true,
        "details": {
          "function_name": "sofs_read_level3_size(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/isofs/inode.c",
          "lines": "1139-1240",
          "snippet": "tatic int isofs_read_level3_size(struct inode *inode)\n{\n\tunsigned long bufsize = ISOFS_BUFFER_SIZE(inode);\n\tint high_sierra = ISOFS_SB(inode->i_sb)->s_high_sierra;\n\tstruct buffer_head *bh = NULL;\n\tunsigned long block, offset, block_saved, offset_saved;\n\tint i = 0;\n\tint more_entries = 0;\n\tstruct iso_directory_record *tmpde = NULL;\n\tstruct iso_inode_info *ei = ISOFS_I(inode);\n\n\tinode->i_size = 0;\n\n\t/* The first 16 blocks are reserved as the System Area.  Thus,\n\t * no inodes can appear in block 0.  We use this to flag that\n\t * this is the last section. */\n\tei->i_next_section_block = 0;\n\tei->i_next_section_offset = 0;\n\n\tblock = ei->i_iget5_block;\n\toffset = ei->i_iget5_offset;\n\n\tdo {\n\t\tstruct iso_directory_record *de;\n\t\tunsigned int de_len;\n\n\t\tif (!bh) {\n\t\t\tbh = sb_bread(inode->i_sb, block);\n\t\t\tif (!bh)\n\t\t\t\tgoto out_noread;\n\t\t}\n\t\tde = (struct iso_directory_record *) (bh->b_data + offset);\n\t\tde_len = *(unsigned char *) de;\n\n\t\tif (de_len == 0) {\n\t\t\tbrelse(bh);\n\t\t\tbh = NULL;\n\t\t\t++block;\n\t\t\toffset = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\tblock_saved = block;\n\t\toffset_saved = offset;\n\t\toffset += de_len;\n\n\t\t/* Make sure we have a full directory entry */\n\t\tif (offset >= bufsize) {\n\t\t\tint slop = bufsize - offset + de_len;\n\t\t\tif (!tmpde) {\n\t\t\t\ttmpde = kmalloc(256, GFP_KERNEL);\n\t\t\t\tif (!tmpde)\n\t\t\t\t\tgoto out_nomem;\n\t\t\t}\n\t\t\tmemcpy(tmpde, de, slop);\n\t\t\toffset &= bufsize - 1;\n\t\t\tblock++;\n\t\t\tbrelse(bh);\n\t\t\tbh = NULL;\n\t\t\tif (offset) {\n\t\t\t\tbh = sb_bread(inode->i_sb, block);\n\t\t\t\tif (!bh)\n\t\t\t\t\tgoto out_noread;\n\t\t\t\tmemcpy((void *)tmpde+slop, bh->b_data, offset);\n\t\t\t}\n\t\t\tde = tmpde;\n\t\t}\n\n\t\tinode->i_size += isonum_733(de->size);\n\t\tif (i == 1) {\n\t\t\tei->i_next_section_block = block_saved;\n\t\t\tei->i_next_section_offset = offset_saved;\n\t\t}\n\n\t\tmore_entries = de->flags[-high_sierra] & 0x80;\n\n\t\ti++;\n\t\tif (i > 100)\n\t\t\tgoto out_toomany;\n\t} while (more_entries);\nout:\n\tkfree(tmpde);\n\tif (bh)\n\t\tbrelse(bh);\n\treturn 0;\n\nout_nomem:\n\tif (bh)\n\t\tbrelse(bh);\n\treturn -ENOMEM;\n\nout_noread:\n\tprintk(KERN_INFO \"ISOFS: unable to read i-node block %lu\\n\", block);\n\tkfree(tmpde);\n\treturn -EIO;\n\nout_toomany:\n\tprintk(KERN_INFO \"%s: More than 100 file sections ?!?, aborting...\\n\"\n\t\t\"isofs_read_level3_size: inode=%lu\\n\",\n\t\t__func__, inode->i_ino);\n\tgoto out;\n}",
          "includes": [
            "include \"zisofs.h\"",
            "include \"isofs.h\"\n#",
            "include <linux/user_namespace.h>",
            "include <linux/mpage.h>\n#",
            "include <linux/parser.h>\n#",
            "include <linux/cdrom.h>\n#",
            "include <linux/statfs.h>\n#",
            "include <linux/ctype.h>\n#",
            "include <linux/nls.h>\n#",
            "include <linux/slab.h>\n#",
            "include <linux/module.h>",
            "include <linux/init.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"zisofs.h\"\ninclude \"isofs.h\"\n#\ninclude <linux/user_namespace.h>\ninclude <linux/mpage.h>\n#\ninclude <linux/parser.h>\n#\ninclude <linux/cdrom.h>\n#\ninclude <linux/statfs.h>\n#\ninclude <linux/ctype.h>\n#\ninclude <linux/nls.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/module.h>\ninclude <linux/init.h>\n#\n\ntatic int isofs_read_level3_size(struct inode *inode)\n{\n\tunsigned long bufsize = ISOFS_BUFFER_SIZE(inode);\n\tint high_sierra = ISOFS_SB(inode->i_sb)->s_high_sierra;\n\tstruct buffer_head *bh = NULL;\n\tunsigned long block, offset, block_saved, offset_saved;\n\tint i = 0;\n\tint more_entries = 0;\n\tstruct iso_directory_record *tmpde = NULL;\n\tstruct iso_inode_info *ei = ISOFS_I(inode);\n\n\tinode->i_size = 0;\n\n\t/* The first 16 blocks are reserved as the System Area.  Thus,\n\t * no inodes can appear in block 0.  We use this to flag that\n\t * this is the last section. */\n\tei->i_next_section_block = 0;\n\tei->i_next_section_offset = 0;\n\n\tblock = ei->i_iget5_block;\n\toffset = ei->i_iget5_offset;\n\n\tdo {\n\t\tstruct iso_directory_record *de;\n\t\tunsigned int de_len;\n\n\t\tif (!bh) {\n\t\t\tbh = sb_bread(inode->i_sb, block);\n\t\t\tif (!bh)\n\t\t\t\tgoto out_noread;\n\t\t}\n\t\tde = (struct iso_directory_record *) (bh->b_data + offset);\n\t\tde_len = *(unsigned char *) de;\n\n\t\tif (de_len == 0) {\n\t\t\tbrelse(bh);\n\t\t\tbh = NULL;\n\t\t\t++block;\n\t\t\toffset = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\tblock_saved = block;\n\t\toffset_saved = offset;\n\t\toffset += de_len;\n\n\t\t/* Make sure we have a full directory entry */\n\t\tif (offset >= bufsize) {\n\t\t\tint slop = bufsize - offset + de_len;\n\t\t\tif (!tmpde) {\n\t\t\t\ttmpde = kmalloc(256, GFP_KERNEL);\n\t\t\t\tif (!tmpde)\n\t\t\t\t\tgoto out_nomem;\n\t\t\t}\n\t\t\tmemcpy(tmpde, de, slop);\n\t\t\toffset &= bufsize - 1;\n\t\t\tblock++;\n\t\t\tbrelse(bh);\n\t\t\tbh = NULL;\n\t\t\tif (offset) {\n\t\t\t\tbh = sb_bread(inode->i_sb, block);\n\t\t\t\tif (!bh)\n\t\t\t\t\tgoto out_noread;\n\t\t\t\tmemcpy((void *)tmpde+slop, bh->b_data, offset);\n\t\t\t}\n\t\t\tde = tmpde;\n\t\t}\n\n\t\tinode->i_size += isonum_733(de->size);\n\t\tif (i == 1) {\n\t\t\tei->i_next_section_block = block_saved;\n\t\t\tei->i_next_section_offset = offset_saved;\n\t\t}\n\n\t\tmore_entries = de->flags[-high_sierra] & 0x80;\n\n\t\ti++;\n\t\tif (i > 100)\n\t\t\tgoto out_toomany;\n\t} while (more_entries);\nout:\n\tkfree(tmpde);\n\tif (bh)\n\t\tbrelse(bh);\n\treturn 0;\n\nout_nomem:\n\tif (bh)\n\t\tbrelse(bh);\n\treturn -ENOMEM;\n\nout_noread:\n\tprintk(KERN_INFO \"ISOFS: unable to read i-node block %lu\\n\", block);\n\tkfree(tmpde);\n\treturn -EIO;\n\nout_toomany:\n\tprintk(KERN_INFO \"%s: More than 100 file sections ?!?, aborting...\\n\"\n\t\t\"isofs_read_level3_size: inode=%lu\\n\",\n\t\t__func__, inode->i_ino);\n\tgoto out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sonum_733(",
          "args": [
            "e->size)"
          ],
          "line": 1325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "et_nlink(",
          "args": [
            "node,",
            ")"
          ],
          "line": 1315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "et_nlink(",
          "args": [
            "node,",
            ")"
          ],
          "line": 1297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sofs_get_ino(",
          "args": [
            "i->i_iget5_block,",
            "i->i_iget5_offset,",
            "SOFS_BUFFER_BITS(inode))"
          ],
          "line": 1285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SOFS_BUFFER_BITS(",
          "args": [
            "node)"
          ],
          "line": 1287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "emcpy(",
          "args": [
            "char *)tmpde+frag1,",
            "h->b_data,",
            "e_len - frag1)"
          ],
          "line": 1281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "b_bread(",
          "args": [
            "node->i_sb,",
            "+block)"
          ],
          "line": 1278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "relse(",
          "args": [
            "h)"
          ],
          "line": 1277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "emcpy(",
          "args": [
            "mpde,",
            "h->b_data + offset,",
            "rag1)"
          ],
          "line": 1276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rintk(",
          "args": [
            "ERN_INFO \"%s: out of memory\\n\",",
            "_func__)"
          ],
          "line": 1272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc(",
          "args": [
            "e_len,",
            "FP_KERNEL)"
          ],
          "line": 1270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "b_bread(",
          "args": [
            "node->i_sb,",
            "lock)"
          ],
          "line": 1258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SOFS_I(",
          "args": [
            "node)"
          ],
          "line": 1254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SOFS_BUFFER_SIZE(",
          "args": [
            "node)"
          ],
          "line": 1246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SOFS_SB(",
          "args": [
            "b)"
          ],
          "line": 1245
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"zisofs.h\"\ninclude \"isofs.h\"\n#\ninclude <linux/user_namespace.h>\ninclude <linux/mpage.h>\n#\ninclude <linux/parser.h>\n#\ninclude <linux/cdrom.h>\n#\ninclude <linux/statfs.h>\n#\ninclude <linux/ctype.h>\n#\ninclude <linux/nls.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/module.h>\ninclude <linux/init.h>\n#\n\ntatic int isofs_read_inode(struct inode *, int relocated);\ntatic const struct address_space_operations isofs_aops = {\n\t.readpage = isofs_readpage,\n\t.readpages = isofs_readpages,\n\t.bmap = _isofs_bmap\n};\n\ntatic int isofs_read_inode(struct inode *inode, int relocated)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct isofs_sb_info *sbi = ISOFS_SB(sb);\n\tunsigned long bufsize = ISOFS_BUFFER_SIZE(inode);\n\tunsigned long block;\n\tint high_sierra = sbi->s_high_sierra;\n\tstruct buffer_head *bh = NULL;\n\tstruct iso_directory_record *de;\n\tstruct iso_directory_record *tmpde = NULL;\n\tunsigned int de_len;\n\tunsigned long offset;\n\tstruct iso_inode_info *ei = ISOFS_I(inode);\n\tint ret = -EIO;\n\n\tblock = ei->i_iget5_block;\n\tbh = sb_bread(inode->i_sb, block);\n\tif (!bh)\n\t\tgoto out_badread;\n\n\toffset = ei->i_iget5_offset;\n\n\tde = (struct iso_directory_record *) (bh->b_data + offset);\n\tde_len = *(unsigned char *) de;\n\n\tif (offset + de_len > bufsize) {\n\t\tint frag1 = bufsize - offset;\n\n\t\ttmpde = kmalloc(de_len, GFP_KERNEL);\n\t\tif (tmpde == NULL) {\n\t\t\tprintk(KERN_INFO \"%s: out of memory\\n\", __func__);\n\t\t\tret = -ENOMEM;\n\t\t\tgoto fail;\n\t\t}\n\t\tmemcpy(tmpde, bh->b_data + offset, frag1);\n\t\tbrelse(bh);\n\t\tbh = sb_bread(inode->i_sb, ++block);\n\t\tif (!bh)\n\t\t\tgoto out_badread;\n\t\tmemcpy((char *)tmpde+frag1, bh->b_data, de_len - frag1);\n\t\tde = tmpde;\n\t}\n\n\tinode->i_ino = isofs_get_ino(ei->i_iget5_block,\n\t\t\t\t\tei->i_iget5_offset,\n\t\t\t\t\tISOFS_BUFFER_BITS(inode));\n\n\t/* Assume it is a normal-format file unless told otherwise */\n\tei->i_file_format = isofs_file_normal;\n\n\tif (de->flags[-high_sierra] & 2) {\n\t\tif (sbi->s_dmode != ISOFS_INVALID_MODE)\n\t\t\tinode->i_mode = S_IFDIR | sbi->s_dmode;\n\t\telse\n\t\t\tinode->i_mode = S_IFDIR | S_IRUGO | S_IXUGO;\n\t\tset_nlink(inode, 1);\t/*\n\t\t\t\t\t * Set to 1.  We know there are 2, but\n\t\t\t\t\t * the find utility tries to optimize\n\t\t\t\t\t * if it is 2, and it screws up.  It is\n\t\t\t\t\t * easier to give 1 which tells find to\n\t\t\t\t\t * do it the hard way.\n\t\t\t\t\t */\n\t} else {\n\t\tif (sbi->s_fmode != ISOFS_INVALID_MODE) {\n\t\t\tinode->i_mode = S_IFREG | sbi->s_fmode;\n\t\t} else {\n\t\t\t/*\n\t\t\t * Set default permissions: r-x for all.  The disc\n\t\t\t * could be shared with DOS machines so virtually\n\t\t\t * anything could be a valid executable.\n\t\t\t */\n\t\t\tinode->i_mode = S_IFREG | S_IRUGO | S_IXUGO;\n\t\t}\n\t\tset_nlink(inode, 1);\n\t}\n\tinode->i_uid = sbi->s_uid;\n\tinode->i_gid = sbi->s_gid;\n\tinode->i_blocks = 0;\n\n\tei->i_format_parm[0] = 0;\n\tei->i_format_parm[1] = 0;\n\tei->i_format_parm[2] = 0;\n\n\tei->i_section_size = isonum_733(de->size);\n\tif (de->flags[-high_sierra] & 0x80) {\n\t\tret = isofs_read_level3_size(inode);\n\t\tif (ret < 0)\n\t\t\tgoto fail;\n\t\tret = -EIO;\n\t} else {\n\t\tei->i_next_section_block = 0;\n\t\tei->i_next_section_offset = 0;\n\t\tinode->i_size = isonum_733(de->size);\n\t}\n\n\t/*\n\t * Some dipshit decided to store some other bit of information\n\t * in the high byte of the file length.  Truncate size in case\n\t * this CDROM was mounted with the cruft option.\n\t */\n\n\tif (sbi->s_cruft)\n\t\tinode->i_size &= 0x00ffffff;\n\n\tif (de->interleave[0]) {\n\t\tprintk(KERN_DEBUG \"ISOFS: Interleaved files not (yet) supported.\\n\");\n\t\tinode->i_size = 0;\n\t}\n\n\t/* I have no idea what file_unit_size is used for, so\n\t   we will flag it for now */\n\tif (de->file_unit_size[0] != 0) {\n\t\tprintk(KERN_DEBUG \"ISOFS: File unit size != 0 for ISO file (%ld).\\n\",\n\t\t\tinode->i_ino);\n\t}\n\n\t/* I have no idea what other flag bits are used for, so\n\t   we will flag it for now */\n#ifdef DEBUG\n\tif((de->flags[-high_sierra] & ~2)!= 0){\n\t\tprintk(KERN_DEBUG \"ISOFS: Unusual flag settings for ISO file \"\n\t\t\t\t\"(%ld %x).\\n\",\n\t\t\tinode->i_ino, de->flags[-high_sierra]);\n\t}\n#endif\n\n\tinode->i_mtime.tv_sec =\n\tinode->i_atime.tv_sec =\n\tinode->i_ctime.tv_sec = iso_date(de->date, high_sierra);\n\tinode->i_mtime.tv_nsec =\n\tinode->i_atime.tv_nsec =\n\tinode->i_ctime.tv_nsec = 0;\n\n\tei->i_first_extent = (isonum_733(de->extent) +\n\t\t\tisonum_711(de->ext_attr_length));\n\n\t/* Set the number of blocks for stat() - should be done before RR */\n\tinode->i_blocks = (inode->i_size + 511) >> 9;\n\n\t/*\n\t * Now test for possible Rock Ridge extensions which will override\n\t * some of these numbers in the inode structure.\n\t */\n\n\tif (!high_sierra) {\n\t\tparse_rock_ridge_inode(de, inode, relocated);\n\t\t/* if we want uid/gid set, override the rock ridge setting */\n\t\tif (sbi->s_uid_set)\n\t\t\tinode->i_uid = sbi->s_uid;\n\t\tif (sbi->s_gid_set)\n\t\t\tinode->i_gid = sbi->s_gid;\n\t}\n\t/* Now set final access rights if overriding rock ridge setting */\n\tif (S_ISDIR(inode->i_mode) && sbi->s_overriderockperm &&\n\t    sbi->s_dmode != ISOFS_INVALID_MODE)\n\t\tinode->i_mode = S_IFDIR | sbi->s_dmode;\n\tif (S_ISREG(inode->i_mode) && sbi->s_overriderockperm &&\n\t    sbi->s_fmode != ISOFS_INVALID_MODE)\n\t\tinode->i_mode = S_IFREG | sbi->s_fmode;\n\n\t/* Install the inode operations vector */\n\tif (S_ISREG(inode->i_mode)) {\n\t\tinode->i_fop = &generic_ro_fops;\n\t\tswitch (ei->i_file_format) {\n#ifdef CONFIG_ZISOFS\n\t\tcase isofs_file_compressed:\n\t\t\tinode->i_data.a_ops = &zisofs_aops;\n\t\t\tbreak;\n#endif\n\t\tdefault:\n\t\t\tinode->i_data.a_ops = &isofs_aops;\n\t\t\tbreak;\n\t\t}\n\t} else if (S_ISDIR(inode->i_mode)) {\n\t\tinode->i_op = &isofs_dir_inode_operations;\n\t\tinode->i_fop = &isofs_dir_operations;\n\t} else if (S_ISLNK(inode->i_mode)) {\n\t\tinode->i_op = &page_symlink_inode_operations;\n\t\tinode->i_data.a_ops = &isofs_symlink_aops;\n\t} else\n\t\t/* XXX - parse_rock_ridge_inode() had already set i_rdev. */\n\t\tinit_special_inode(inode, inode->i_mode, inode->i_rdev);\n\n\tret = 0;\nout:\n\tkfree(tmpde);\n\tif (bh)\n\t\tbrelse(bh);\n\treturn ret;\n\nout_badread:\n\tprintk(KERN_WARNING \"ISOFS: unable to read i-node block\\n\");\nfail:\n\tgoto out;\n}"
  },
  {
    "function_name": "sofs_read_level3_size(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/isofs/inode.c",
    "lines": "1139-1240",
    "snippet": "tatic int isofs_read_level3_size(struct inode *inode)\n{\n\tunsigned long bufsize = ISOFS_BUFFER_SIZE(inode);\n\tint high_sierra = ISOFS_SB(inode->i_sb)->s_high_sierra;\n\tstruct buffer_head *bh = NULL;\n\tunsigned long block, offset, block_saved, offset_saved;\n\tint i = 0;\n\tint more_entries = 0;\n\tstruct iso_directory_record *tmpde = NULL;\n\tstruct iso_inode_info *ei = ISOFS_I(inode);\n\n\tinode->i_size = 0;\n\n\t/* The first 16 blocks are reserved as the System Area.  Thus,\n\t * no inodes can appear in block 0.  We use this to flag that\n\t * this is the last section. */\n\tei->i_next_section_block = 0;\n\tei->i_next_section_offset = 0;\n\n\tblock = ei->i_iget5_block;\n\toffset = ei->i_iget5_offset;\n\n\tdo {\n\t\tstruct iso_directory_record *de;\n\t\tunsigned int de_len;\n\n\t\tif (!bh) {\n\t\t\tbh = sb_bread(inode->i_sb, block);\n\t\t\tif (!bh)\n\t\t\t\tgoto out_noread;\n\t\t}\n\t\tde = (struct iso_directory_record *) (bh->b_data + offset);\n\t\tde_len = *(unsigned char *) de;\n\n\t\tif (de_len == 0) {\n\t\t\tbrelse(bh);\n\t\t\tbh = NULL;\n\t\t\t++block;\n\t\t\toffset = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\tblock_saved = block;\n\t\toffset_saved = offset;\n\t\toffset += de_len;\n\n\t\t/* Make sure we have a full directory entry */\n\t\tif (offset >= bufsize) {\n\t\t\tint slop = bufsize - offset + de_len;\n\t\t\tif (!tmpde) {\n\t\t\t\ttmpde = kmalloc(256, GFP_KERNEL);\n\t\t\t\tif (!tmpde)\n\t\t\t\t\tgoto out_nomem;\n\t\t\t}\n\t\t\tmemcpy(tmpde, de, slop);\n\t\t\toffset &= bufsize - 1;\n\t\t\tblock++;\n\t\t\tbrelse(bh);\n\t\t\tbh = NULL;\n\t\t\tif (offset) {\n\t\t\t\tbh = sb_bread(inode->i_sb, block);\n\t\t\t\tif (!bh)\n\t\t\t\t\tgoto out_noread;\n\t\t\t\tmemcpy((void *)tmpde+slop, bh->b_data, offset);\n\t\t\t}\n\t\t\tde = tmpde;\n\t\t}\n\n\t\tinode->i_size += isonum_733(de->size);\n\t\tif (i == 1) {\n\t\t\tei->i_next_section_block = block_saved;\n\t\t\tei->i_next_section_offset = offset_saved;\n\t\t}\n\n\t\tmore_entries = de->flags[-high_sierra] & 0x80;\n\n\t\ti++;\n\t\tif (i > 100)\n\t\t\tgoto out_toomany;\n\t} while (more_entries);\nout:\n\tkfree(tmpde);\n\tif (bh)\n\t\tbrelse(bh);\n\treturn 0;\n\nout_nomem:\n\tif (bh)\n\t\tbrelse(bh);\n\treturn -ENOMEM;\n\nout_noread:\n\tprintk(KERN_INFO \"ISOFS: unable to read i-node block %lu\\n\", block);\n\tkfree(tmpde);\n\treturn -EIO;\n\nout_toomany:\n\tprintk(KERN_INFO \"%s: More than 100 file sections ?!?, aborting...\\n\"\n\t\t\"isofs_read_level3_size: inode=%lu\\n\",\n\t\t__func__, inode->i_ino);\n\tgoto out;\n}",
    "includes": [
      "include \"zisofs.h\"",
      "include \"isofs.h\"\n#",
      "include <linux/user_namespace.h>",
      "include <linux/mpage.h>\n#",
      "include <linux/parser.h>\n#",
      "include <linux/cdrom.h>\n#",
      "include <linux/statfs.h>\n#",
      "include <linux/ctype.h>\n#",
      "include <linux/nls.h>\n#",
      "include <linux/slab.h>\n#",
      "include <linux/module.h>",
      "include <linux/init.h>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rintk(",
          "args": [
            "ERN_INFO \"%s: More than 100 file sections ?!?, aborting...\\n\"\n\t\t\"isofs_read_level3_size: inode=%lu\\n\",",
            "_func__,",
            "node->i_ino)"
          ],
          "line": 1236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free(",
          "args": [
            "mpde)"
          ],
          "line": 1232
        },
        "resolved": true,
        "details": {
          "function_name": "in_free(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/scan.c",
          "lines": "51-60",
          "snippet": "tatic inline int min_free(struct jffs2_sb_info *c)\n{\n\tuint32_t min = 2 * sizeof(struct jffs2_raw_inode);\n#ifdef CONFIG_JFFS2_FS_WRITEBUFFER\n\tif (!jffs2_can_mark_obsolete(c) && min < c->wbuf_pagesize)\n\t\treturn c->wbuf_pagesize;\n#endif\n\treturn min;\n\n}",
          "includes": [
            "include \"debug.h\"",
            "include \"summary.h\"\n#",
            "include \"nodelist.h\"\n#",
            "include <linux/compiler.h>\n#",
            "include <linux/crc32.h>\n#",
            "include <linux/pagemap.h>\n#",
            "include <linux/mtd/mtd.h>\n#",
            "include <linux/slab.h>\n#",
            "include <linux/sched.h>\n#",
            "include <linux/kernel.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"debug.h\"\ninclude \"summary.h\"\n#\ninclude \"nodelist.h\"\n#\ninclude <linux/compiler.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/pagemap.h>\n#\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/sched.h>\n#\ninclude <linux/kernel.h>\n#\n\ntatic inline int min_free(struct jffs2_sb_info *c)\n{\n\tuint32_t min = 2 * sizeof(struct jffs2_raw_inode);\n#ifdef CONFIG_JFFS2_FS_WRITEBUFFER\n\tif (!jffs2_can_mark_obsolete(c) && min < c->wbuf_pagesize)\n\t\treturn c->wbuf_pagesize;\n#endif\n\treturn min;\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "rintk(",
          "args": [
            "ERN_INFO \"ISOFS: unable to read i-node block %lu\\n\",",
            "lock)"
          ],
          "line": 1231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "relse(",
          "args": [
            "h)"
          ],
          "line": 1227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "relse(",
          "args": [
            "h)"
          ],
          "line": 1222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sonum_733(",
          "args": [
            "e->size)"
          ],
          "line": 1207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "emcpy(",
          "args": [
            "void *)tmpde+slop,",
            "h->b_data,",
            "ffset)"
          ],
          "line": 1202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "b_bread(",
          "args": [
            "node->i_sb,",
            "lock)"
          ],
          "line": 1199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "relse(",
          "args": [
            "h)"
          ],
          "line": 1196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "emcpy(",
          "args": [
            "mpde,",
            "e,",
            "lop)"
          ],
          "line": 1193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc(",
          "args": [
            "56,",
            "FP_KERNEL)"
          ],
          "line": 1189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "relse(",
          "args": [
            "h)"
          ],
          "line": 1174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "b_bread(",
          "args": [
            "node->i_sb,",
            "lock)"
          ],
          "line": 1166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SOFS_I(",
          "args": [
            "node)"
          ],
          "line": 1148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SOFS_SB(",
          "args": [
            "node->i_sb)"
          ],
          "line": 1142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SOFS_BUFFER_SIZE(",
          "args": [
            "node)"
          ],
          "line": 1141
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"zisofs.h\"\ninclude \"isofs.h\"\n#\ninclude <linux/user_namespace.h>\ninclude <linux/mpage.h>\n#\ninclude <linux/parser.h>\n#\ninclude <linux/cdrom.h>\n#\ninclude <linux/statfs.h>\n#\ninclude <linux/ctype.h>\n#\ninclude <linux/nls.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/module.h>\ninclude <linux/init.h>\n#\n\ntatic int isofs_read_level3_size(struct inode *inode)\n{\n\tunsigned long bufsize = ISOFS_BUFFER_SIZE(inode);\n\tint high_sierra = ISOFS_SB(inode->i_sb)->s_high_sierra;\n\tstruct buffer_head *bh = NULL;\n\tunsigned long block, offset, block_saved, offset_saved;\n\tint i = 0;\n\tint more_entries = 0;\n\tstruct iso_directory_record *tmpde = NULL;\n\tstruct iso_inode_info *ei = ISOFS_I(inode);\n\n\tinode->i_size = 0;\n\n\t/* The first 16 blocks are reserved as the System Area.  Thus,\n\t * no inodes can appear in block 0.  We use this to flag that\n\t * this is the last section. */\n\tei->i_next_section_block = 0;\n\tei->i_next_section_offset = 0;\n\n\tblock = ei->i_iget5_block;\n\toffset = ei->i_iget5_offset;\n\n\tdo {\n\t\tstruct iso_directory_record *de;\n\t\tunsigned int de_len;\n\n\t\tif (!bh) {\n\t\t\tbh = sb_bread(inode->i_sb, block);\n\t\t\tif (!bh)\n\t\t\t\tgoto out_noread;\n\t\t}\n\t\tde = (struct iso_directory_record *) (bh->b_data + offset);\n\t\tde_len = *(unsigned char *) de;\n\n\t\tif (de_len == 0) {\n\t\t\tbrelse(bh);\n\t\t\tbh = NULL;\n\t\t\t++block;\n\t\t\toffset = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\tblock_saved = block;\n\t\toffset_saved = offset;\n\t\toffset += de_len;\n\n\t\t/* Make sure we have a full directory entry */\n\t\tif (offset >= bufsize) {\n\t\t\tint slop = bufsize - offset + de_len;\n\t\t\tif (!tmpde) {\n\t\t\t\ttmpde = kmalloc(256, GFP_KERNEL);\n\t\t\t\tif (!tmpde)\n\t\t\t\t\tgoto out_nomem;\n\t\t\t}\n\t\t\tmemcpy(tmpde, de, slop);\n\t\t\toffset &= bufsize - 1;\n\t\t\tblock++;\n\t\t\tbrelse(bh);\n\t\t\tbh = NULL;\n\t\t\tif (offset) {\n\t\t\t\tbh = sb_bread(inode->i_sb, block);\n\t\t\t\tif (!bh)\n\t\t\t\t\tgoto out_noread;\n\t\t\t\tmemcpy((void *)tmpde+slop, bh->b_data, offset);\n\t\t\t}\n\t\t\tde = tmpde;\n\t\t}\n\n\t\tinode->i_size += isonum_733(de->size);\n\t\tif (i == 1) {\n\t\t\tei->i_next_section_block = block_saved;\n\t\t\tei->i_next_section_offset = offset_saved;\n\t\t}\n\n\t\tmore_entries = de->flags[-high_sierra] & 0x80;\n\n\t\ti++;\n\t\tif (i > 100)\n\t\t\tgoto out_toomany;\n\t} while (more_entries);\nout:\n\tkfree(tmpde);\n\tif (bh)\n\t\tbrelse(bh);\n\treturn 0;\n\nout_nomem:\n\tif (bh)\n\t\tbrelse(bh);\n\treturn -ENOMEM;\n\nout_noread:\n\tprintk(KERN_INFO \"ISOFS: unable to read i-node block %lu\\n\", block);\n\tkfree(tmpde);\n\treturn -EIO;\n\nout_toomany:\n\tprintk(KERN_INFO \"%s: More than 100 file sections ?!?, aborting...\\n\"\n\t\t\"isofs_read_level3_size: inode=%lu\\n\",\n\t\t__func__, inode->i_ino);\n\tgoto out;\n}"
  },
  {
    "function_name": "isofs_bmap(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/isofs/inode.c",
    "lines": "1128-1131",
    "snippet": "tatic sector_t _isofs_bmap(struct address_space *mapping, sector_t block)\n{\n\treturn generic_block_bmap(mapping,block,isofs_get_block);\n}",
    "includes": [
      "include \"zisofs.h\"",
      "include \"isofs.h\"\n#",
      "include <linux/user_namespace.h>",
      "include <linux/mpage.h>\n#",
      "include <linux/parser.h>\n#",
      "include <linux/cdrom.h>\n#",
      "include <linux/statfs.h>\n#",
      "include <linux/ctype.h>\n#",
      "include <linux/nls.h>\n#",
      "include <linux/slab.h>\n#",
      "include <linux/module.h>",
      "include <linux/init.h>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "eneric_block_bmap(",
          "args": [
            "apping,",
            "lock,",
            "sofs_get_block)"
          ],
          "line": 1130
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"zisofs.h\"\ninclude \"isofs.h\"\n#\ninclude <linux/user_namespace.h>\ninclude <linux/mpage.h>\n#\ninclude <linux/parser.h>\n#\ninclude <linux/cdrom.h>\n#\ninclude <linux/statfs.h>\n#\ninclude <linux/ctype.h>\n#\ninclude <linux/nls.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/module.h>\ninclude <linux/init.h>\n#\n\ntatic sector_t _isofs_bmap(struct address_space *mapping, sector_t block)\n{\n\treturn generic_block_bmap(mapping,block,isofs_get_block);\n}"
  },
  {
    "function_name": "sofs_readpages(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/isofs/inode.c",
    "lines": "1122-1126",
    "snippet": "tatic int isofs_readpages(struct file *file, struct address_space *mapping,\n\t\t\tstruct list_head *pages, unsigned nr_pages)\n{\n\treturn mpage_readpages(mapping, pages, nr_pages, isofs_get_block);\n}",
    "includes": [
      "include \"zisofs.h\"",
      "include \"isofs.h\"\n#",
      "include <linux/user_namespace.h>",
      "include <linux/mpage.h>\n#",
      "include <linux/parser.h>\n#",
      "include <linux/cdrom.h>\n#",
      "include <linux/statfs.h>\n#",
      "include <linux/ctype.h>\n#",
      "include <linux/nls.h>\n#",
      "include <linux/slab.h>\n#",
      "include <linux/module.h>",
      "include <linux/init.h>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "page_readpages(",
          "args": [
            "apping,",
            "ages,",
            "r_pages,",
            "sofs_get_block)"
          ],
          "line": 1125
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"zisofs.h\"\ninclude \"isofs.h\"\n#\ninclude <linux/user_namespace.h>\ninclude <linux/mpage.h>\n#\ninclude <linux/parser.h>\n#\ninclude <linux/cdrom.h>\n#\ninclude <linux/statfs.h>\n#\ninclude <linux/ctype.h>\n#\ninclude <linux/nls.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/module.h>\ninclude <linux/init.h>\n#\n\ntatic int isofs_readpages(struct file *file, struct address_space *mapping,\n\t\t\tstruct list_head *pages, unsigned nr_pages)\n{\n\treturn mpage_readpages(mapping, pages, nr_pages, isofs_get_block);\n}"
  },
  {
    "function_name": "sofs_readpage(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/isofs/inode.c",
    "lines": "1117-1120",
    "snippet": "tatic int isofs_readpage(struct file *file, struct page *page)\n{\n\treturn mpage_readpage(page, isofs_get_block);\n}",
    "includes": [
      "include \"zisofs.h\"",
      "include \"isofs.h\"\n#",
      "include <linux/user_namespace.h>",
      "include <linux/mpage.h>\n#",
      "include <linux/parser.h>\n#",
      "include <linux/cdrom.h>\n#",
      "include <linux/statfs.h>\n#",
      "include <linux/ctype.h>\n#",
      "include <linux/nls.h>\n#",
      "include <linux/slab.h>\n#",
      "include <linux/module.h>",
      "include <linux/init.h>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "page_readpage(",
          "args": [
            "age,",
            "sofs_get_block)"
          ],
          "line": 1119
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"zisofs.h\"\ninclude \"isofs.h\"\n#\ninclude <linux/user_namespace.h>\ninclude <linux/mpage.h>\n#\ninclude <linux/parser.h>\n#\ninclude <linux/cdrom.h>\n#\ninclude <linux/statfs.h>\n#\ninclude <linux/ctype.h>\n#\ninclude <linux/nls.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/module.h>\ninclude <linux/init.h>\n#\n\ntatic int isofs_readpage(struct file *file, struct page *page)\n{\n\treturn mpage_readpage(page, isofs_get_block);\n}"
  },
  {
    "function_name": "sofs_bread(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/isofs/inode.c",
    "lines": "1109-1115",
    "snippet": "truct buffer_head *isofs_bread(struct inode *inode, sector_t block)\n{\n\tsector_t blknr = isofs_bmap(inode, block);\n\tif (!blknr)\n\t\treturn NULL;\n\treturn sb_bread(inode->i_sb, blknr);\n}",
    "includes": [
      "include \"zisofs.h\"",
      "include \"isofs.h\"\n#",
      "include <linux/user_namespace.h>",
      "include <linux/mpage.h>\n#",
      "include <linux/parser.h>\n#",
      "include <linux/cdrom.h>\n#",
      "include <linux/statfs.h>\n#",
      "include <linux/ctype.h>\n#",
      "include <linux/nls.h>\n#",
      "include <linux/slab.h>\n#",
      "include <linux/module.h>",
      "include <linux/init.h>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "b_bread(",
          "args": [
            "node->i_sb,",
            "lknr)"
          ],
          "line": 1114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sofs_bmap(",
          "args": [
            "node,",
            "lock)"
          ],
          "line": 1111
        },
        "resolved": true,
        "details": {
          "function_name": "isofs_bmap(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/isofs/inode.c",
          "lines": "1128-1131",
          "snippet": "tatic sector_t _isofs_bmap(struct address_space *mapping, sector_t block)\n{\n\treturn generic_block_bmap(mapping,block,isofs_get_block);\n}",
          "includes": [
            "include \"zisofs.h\"",
            "include \"isofs.h\"\n#",
            "include <linux/user_namespace.h>",
            "include <linux/mpage.h>\n#",
            "include <linux/parser.h>\n#",
            "include <linux/cdrom.h>\n#",
            "include <linux/statfs.h>\n#",
            "include <linux/ctype.h>\n#",
            "include <linux/nls.h>\n#",
            "include <linux/slab.h>\n#",
            "include <linux/module.h>",
            "include <linux/init.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"zisofs.h\"\ninclude \"isofs.h\"\n#\ninclude <linux/user_namespace.h>\ninclude <linux/mpage.h>\n#\ninclude <linux/parser.h>\n#\ninclude <linux/cdrom.h>\n#\ninclude <linux/statfs.h>\n#\ninclude <linux/ctype.h>\n#\ninclude <linux/nls.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/module.h>\ninclude <linux/init.h>\n#\n\ntatic sector_t _isofs_bmap(struct address_space *mapping, sector_t block)\n{\n\treturn generic_block_bmap(mapping,block,isofs_get_block);\n}"
        }
      }
    ],
    "contextual_snippet": "include \"zisofs.h\"\ninclude \"isofs.h\"\n#\ninclude <linux/user_namespace.h>\ninclude <linux/mpage.h>\n#\ninclude <linux/parser.h>\n#\ninclude <linux/cdrom.h>\n#\ninclude <linux/statfs.h>\n#\ninclude <linux/ctype.h>\n#\ninclude <linux/nls.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/module.h>\ninclude <linux/init.h>\n#\n\ntruct buffer_head *isofs_bread(struct inode *inode, sector_t block)\n{\n\tsector_t blknr = isofs_bmap(inode, block);\n\tif (!blknr)\n\t\treturn NULL;\n\treturn sb_bread(inode->i_sb, blknr);\n}"
  },
  {
    "function_name": "sofs_bmap(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/isofs/inode.c",
    "lines": "1096-1107",
    "snippet": "tatic int isofs_bmap(struct inode *inode, sector_t block)\n{\n\tstruct buffer_head dummy;\n\tint error;\n\n\tdummy.b_state = 0;\n\tdummy.b_blocknr = -1000;\n\terror = isofs_get_block(inode, block, &dummy, 0);\n\tif (!error)\n\t\treturn dummy.b_blocknr;\n\treturn 0;\n}",
    "includes": [
      "include \"zisofs.h\"",
      "include \"isofs.h\"\n#",
      "include <linux/user_namespace.h>",
      "include <linux/mpage.h>\n#",
      "include <linux/parser.h>\n#",
      "include <linux/cdrom.h>\n#",
      "include <linux/statfs.h>\n#",
      "include <linux/ctype.h>\n#",
      "include <linux/nls.h>\n#",
      "include <linux/slab.h>\n#",
      "include <linux/module.h>",
      "include <linux/init.h>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sofs_get_block(",
          "args": [
            "node,",
            "lock,",
            "dummy,",
            ")"
          ],
          "line": 1103
        },
        "resolved": true,
        "details": {
          "function_name": "sofs_get_block(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/isofs/inode.c",
          "lines": "1082-1094",
          "snippet": "tatic int isofs_get_block(struct inode *inode, sector_t iblock,\n\t\t    struct buffer_head *bh_result, int create)\n{\n\tint ret;\n\n\tif (create) {\n\t\tprintk(KERN_DEBUG \"%s: Kernel tries to allocate a block\\n\", __func__);\n\t\treturn -EROFS;\n\t}\n\n\tret = isofs_get_blocks(inode, iblock, &bh_result, 1);\n\treturn ret < 0 ? ret : 0;\n}",
          "includes": [
            "include \"zisofs.h\"",
            "include \"isofs.h\"\n#",
            "include <linux/user_namespace.h>",
            "include <linux/mpage.h>\n#",
            "include <linux/parser.h>\n#",
            "include <linux/cdrom.h>\n#",
            "include <linux/statfs.h>\n#",
            "include <linux/ctype.h>\n#",
            "include <linux/nls.h>\n#",
            "include <linux/slab.h>\n#",
            "include <linux/module.h>",
            "include <linux/init.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"zisofs.h\"\ninclude \"isofs.h\"\n#\ninclude <linux/user_namespace.h>\ninclude <linux/mpage.h>\n#\ninclude <linux/parser.h>\n#\ninclude <linux/cdrom.h>\n#\ninclude <linux/statfs.h>\n#\ninclude <linux/ctype.h>\n#\ninclude <linux/nls.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/module.h>\ninclude <linux/init.h>\n#\n\ntatic int isofs_get_block(struct inode *inode, sector_t iblock,\n\t\t    struct buffer_head *bh_result, int create)\n{\n\tint ret;\n\n\tif (create) {\n\t\tprintk(KERN_DEBUG \"%s: Kernel tries to allocate a block\\n\", __func__);\n\t\treturn -EROFS;\n\t}\n\n\tret = isofs_get_blocks(inode, iblock, &bh_result, 1);\n\treturn ret < 0 ? ret : 0;\n}"
        }
      }
    ],
    "contextual_snippet": "include \"zisofs.h\"\ninclude \"isofs.h\"\n#\ninclude <linux/user_namespace.h>\ninclude <linux/mpage.h>\n#\ninclude <linux/parser.h>\n#\ninclude <linux/cdrom.h>\n#\ninclude <linux/statfs.h>\n#\ninclude <linux/ctype.h>\n#\ninclude <linux/nls.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/module.h>\ninclude <linux/init.h>\n#\n\ntatic int isofs_bmap(struct inode *inode, sector_t block)\n{\n\tstruct buffer_head dummy;\n\tint error;\n\n\tdummy.b_state = 0;\n\tdummy.b_blocknr = -1000;\n\terror = isofs_get_block(inode, block, &dummy, 0);\n\tif (!error)\n\t\treturn dummy.b_blocknr;\n\treturn 0;\n}"
  },
  {
    "function_name": "sofs_get_block(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/isofs/inode.c",
    "lines": "1082-1094",
    "snippet": "tatic int isofs_get_block(struct inode *inode, sector_t iblock,\n\t\t    struct buffer_head *bh_result, int create)\n{\n\tint ret;\n\n\tif (create) {\n\t\tprintk(KERN_DEBUG \"%s: Kernel tries to allocate a block\\n\", __func__);\n\t\treturn -EROFS;\n\t}\n\n\tret = isofs_get_blocks(inode, iblock, &bh_result, 1);\n\treturn ret < 0 ? ret : 0;\n}",
    "includes": [
      "include \"zisofs.h\"",
      "include \"isofs.h\"\n#",
      "include <linux/user_namespace.h>",
      "include <linux/mpage.h>\n#",
      "include <linux/parser.h>\n#",
      "include <linux/cdrom.h>\n#",
      "include <linux/statfs.h>\n#",
      "include <linux/ctype.h>\n#",
      "include <linux/nls.h>\n#",
      "include <linux/slab.h>\n#",
      "include <linux/module.h>",
      "include <linux/init.h>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sofs_get_blocks(",
          "args": [
            "node,",
            "block,",
            "bh_result,",
            ")"
          ],
          "line": 1092
        },
        "resolved": true,
        "details": {
          "function_name": "sofs_get_blocks(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/isofs/inode.c",
          "lines": "991-1077",
          "snippet": "nt isofs_get_blocks(struct inode *inode, sector_t iblock,\n\t\t     struct buffer_head **bh, unsigned long nblocks)\n{\n\tunsigned long b_off = iblock;\n\tunsigned offset, sect_size;\n\tunsigned int firstext;\n\tunsigned long nextblk, nextoff;\n\tint section, rv, error;\n\tstruct iso_inode_info *ei = ISOFS_I(inode);\n\n\terror = -EIO;\n\trv = 0;\n\tif (iblock != b_off) {\n\t\tprintk(KERN_DEBUG \"%s: block number too large\\n\", __func__);\n\t\tgoto abort;\n\t}\n\n\n\toffset = 0;\n\tfirstext = ei->i_first_extent;\n\tsect_size = ei->i_section_size >> ISOFS_BUFFER_BITS(inode);\n\tnextblk = ei->i_next_section_block;\n\tnextoff = ei->i_next_section_offset;\n\tsection = 0;\n\n\twhile (nblocks) {\n\t\t/* If we are *way* beyond the end of the file, print a message.\n\t\t * Access beyond the end of the file up to the next page boundary\n\t\t * is normal, however because of the way the page cache works.\n\t\t * In this case, we just return 0 so that we can properly fill\n\t\t * the page with useless information without generating any\n\t\t * I/O errors.\n\t\t */\n\t\tif (b_off > ((inode->i_size + PAGE_CACHE_SIZE - 1) >> ISOFS_BUFFER_BITS(inode))) {\n\t\t\tprintk(KERN_DEBUG \"%s: block >= EOF (%lu, %llu)\\n\",\n\t\t\t\t__func__, b_off,\n\t\t\t\t(unsigned long long)inode->i_size);\n\t\t\tgoto abort;\n\t\t}\n\n\t\t/* On the last section, nextblk == 0, section size is likely to\n\t\t * exceed sect_size by a partial block, and access beyond the\n\t\t * end of the file will reach beyond the section size, too.\n\t\t */\n\t\twhile (nextblk && (b_off >= (offset + sect_size))) {\n\t\t\tstruct inode *ninode;\n\n\t\t\toffset += sect_size;\n\t\t\tninode = isofs_iget(inode->i_sb, nextblk, nextoff);\n\t\t\tif (IS_ERR(ninode)) {\n\t\t\t\terror = PTR_ERR(ninode);\n\t\t\t\tgoto abort;\n\t\t\t}\n\t\t\tfirstext  = ISOFS_I(ninode)->i_first_extent;\n\t\t\tsect_size = ISOFS_I(ninode)->i_section_size >> ISOFS_BUFFER_BITS(ninode);\n\t\t\tnextblk   = ISOFS_I(ninode)->i_next_section_block;\n\t\t\tnextoff   = ISOFS_I(ninode)->i_next_section_offset;\n\t\t\tiput(ninode);\n\n\t\t\tif (++section > 100) {\n\t\t\t\tprintk(KERN_DEBUG \"%s: More than 100 file sections ?!?\"\n\t\t\t\t\t\" aborting...\\n\", __func__);\n\t\t\t\tprintk(KERN_DEBUG \"%s: block=%lu firstext=%u sect_size=%u \"\n\t\t\t\t\t\"nextblk=%lu nextoff=%lu\\n\", __func__,\n\t\t\t\t\tb_off, firstext, (unsigned) sect_size,\n\t\t\t\t\tnextblk, nextoff);\n\t\t\t\tgoto abort;\n\t\t\t}\n\t\t}\n\n\t\tif (*bh) {\n\t\t\tmap_bh(*bh, inode->i_sb, firstext + b_off - offset);\n\t\t} else {\n\t\t\t*bh = sb_getblk(inode->i_sb, firstext+b_off-offset);\n\t\t\tif (!*bh)\n\t\t\t\tgoto abort;\n\t\t}\n\t\tbh++;\t/* Next buffer head */\n\t\tb_off++;\t/* Next buffer offset */\n\t\tnblocks--;\n\t\trv++;\n\t}\n\n\terror = 0;\nabort:\n\treturn rv != 0 ? rv : error;\n}",
          "includes": [
            "include \"zisofs.h\"",
            "include \"isofs.h\"\n#",
            "include <linux/user_namespace.h>",
            "include <linux/mpage.h>\n#",
            "include <linux/parser.h>\n#",
            "include <linux/cdrom.h>\n#",
            "include <linux/statfs.h>\n#",
            "include <linux/ctype.h>\n#",
            "include <linux/nls.h>\n#",
            "include <linux/slab.h>\n#",
            "include <linux/module.h>",
            "include <linux/init.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"zisofs.h\"\ninclude \"isofs.h\"\n#\ninclude <linux/user_namespace.h>\ninclude <linux/mpage.h>\n#\ninclude <linux/parser.h>\n#\ninclude <linux/cdrom.h>\n#\ninclude <linux/statfs.h>\n#\ninclude <linux/ctype.h>\n#\ninclude <linux/nls.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/module.h>\ninclude <linux/init.h>\n#\n\nnt isofs_get_blocks(struct inode *inode, sector_t iblock,\n\t\t     struct buffer_head **bh, unsigned long nblocks)\n{\n\tunsigned long b_off = iblock;\n\tunsigned offset, sect_size;\n\tunsigned int firstext;\n\tunsigned long nextblk, nextoff;\n\tint section, rv, error;\n\tstruct iso_inode_info *ei = ISOFS_I(inode);\n\n\terror = -EIO;\n\trv = 0;\n\tif (iblock != b_off) {\n\t\tprintk(KERN_DEBUG \"%s: block number too large\\n\", __func__);\n\t\tgoto abort;\n\t}\n\n\n\toffset = 0;\n\tfirstext = ei->i_first_extent;\n\tsect_size = ei->i_section_size >> ISOFS_BUFFER_BITS(inode);\n\tnextblk = ei->i_next_section_block;\n\tnextoff = ei->i_next_section_offset;\n\tsection = 0;\n\n\twhile (nblocks) {\n\t\t/* If we are *way* beyond the end of the file, print a message.\n\t\t * Access beyond the end of the file up to the next page boundary\n\t\t * is normal, however because of the way the page cache works.\n\t\t * In this case, we just return 0 so that we can properly fill\n\t\t * the page with useless information without generating any\n\t\t * I/O errors.\n\t\t */\n\t\tif (b_off > ((inode->i_size + PAGE_CACHE_SIZE - 1) >> ISOFS_BUFFER_BITS(inode))) {\n\t\t\tprintk(KERN_DEBUG \"%s: block >= EOF (%lu, %llu)\\n\",\n\t\t\t\t__func__, b_off,\n\t\t\t\t(unsigned long long)inode->i_size);\n\t\t\tgoto abort;\n\t\t}\n\n\t\t/* On the last section, nextblk == 0, section size is likely to\n\t\t * exceed sect_size by a partial block, and access beyond the\n\t\t * end of the file will reach beyond the section size, too.\n\t\t */\n\t\twhile (nextblk && (b_off >= (offset + sect_size))) {\n\t\t\tstruct inode *ninode;\n\n\t\t\toffset += sect_size;\n\t\t\tninode = isofs_iget(inode->i_sb, nextblk, nextoff);\n\t\t\tif (IS_ERR(ninode)) {\n\t\t\t\terror = PTR_ERR(ninode);\n\t\t\t\tgoto abort;\n\t\t\t}\n\t\t\tfirstext  = ISOFS_I(ninode)->i_first_extent;\n\t\t\tsect_size = ISOFS_I(ninode)->i_section_size >> ISOFS_BUFFER_BITS(ninode);\n\t\t\tnextblk   = ISOFS_I(ninode)->i_next_section_block;\n\t\t\tnextoff   = ISOFS_I(ninode)->i_next_section_offset;\n\t\t\tiput(ninode);\n\n\t\t\tif (++section > 100) {\n\t\t\t\tprintk(KERN_DEBUG \"%s: More than 100 file sections ?!?\"\n\t\t\t\t\t\" aborting...\\n\", __func__);\n\t\t\t\tprintk(KERN_DEBUG \"%s: block=%lu firstext=%u sect_size=%u \"\n\t\t\t\t\t\"nextblk=%lu nextoff=%lu\\n\", __func__,\n\t\t\t\t\tb_off, firstext, (unsigned) sect_size,\n\t\t\t\t\tnextblk, nextoff);\n\t\t\t\tgoto abort;\n\t\t\t}\n\t\t}\n\n\t\tif (*bh) {\n\t\t\tmap_bh(*bh, inode->i_sb, firstext + b_off - offset);\n\t\t} else {\n\t\t\t*bh = sb_getblk(inode->i_sb, firstext+b_off-offset);\n\t\t\tif (!*bh)\n\t\t\t\tgoto abort;\n\t\t}\n\t\tbh++;\t/* Next buffer head */\n\t\tb_off++;\t/* Next buffer offset */\n\t\tnblocks--;\n\t\trv++;\n\t}\n\n\terror = 0;\nabort:\n\treturn rv != 0 ? rv : error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rintk(",
          "args": [
            "ERN_DEBUG \"%s: Kernel tries to allocate a block\\n\",",
            "_func__)"
          ],
          "line": 1088
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"zisofs.h\"\ninclude \"isofs.h\"\n#\ninclude <linux/user_namespace.h>\ninclude <linux/mpage.h>\n#\ninclude <linux/parser.h>\n#\ninclude <linux/cdrom.h>\n#\ninclude <linux/statfs.h>\n#\ninclude <linux/ctype.h>\n#\ninclude <linux/nls.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/module.h>\ninclude <linux/init.h>\n#\n\ntatic int isofs_get_block(struct inode *inode, sector_t iblock,\n\t\t    struct buffer_head *bh_result, int create)\n{\n\tint ret;\n\n\tif (create) {\n\t\tprintk(KERN_DEBUG \"%s: Kernel tries to allocate a block\\n\", __func__);\n\t\treturn -EROFS;\n\t}\n\n\tret = isofs_get_blocks(inode, iblock, &bh_result, 1);\n\treturn ret < 0 ? ret : 0;\n}"
  },
  {
    "function_name": "sofs_get_blocks(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/isofs/inode.c",
    "lines": "991-1077",
    "snippet": "nt isofs_get_blocks(struct inode *inode, sector_t iblock,\n\t\t     struct buffer_head **bh, unsigned long nblocks)\n{\n\tunsigned long b_off = iblock;\n\tunsigned offset, sect_size;\n\tunsigned int firstext;\n\tunsigned long nextblk, nextoff;\n\tint section, rv, error;\n\tstruct iso_inode_info *ei = ISOFS_I(inode);\n\n\terror = -EIO;\n\trv = 0;\n\tif (iblock != b_off) {\n\t\tprintk(KERN_DEBUG \"%s: block number too large\\n\", __func__);\n\t\tgoto abort;\n\t}\n\n\n\toffset = 0;\n\tfirstext = ei->i_first_extent;\n\tsect_size = ei->i_section_size >> ISOFS_BUFFER_BITS(inode);\n\tnextblk = ei->i_next_section_block;\n\tnextoff = ei->i_next_section_offset;\n\tsection = 0;\n\n\twhile (nblocks) {\n\t\t/* If we are *way* beyond the end of the file, print a message.\n\t\t * Access beyond the end of the file up to the next page boundary\n\t\t * is normal, however because of the way the page cache works.\n\t\t * In this case, we just return 0 so that we can properly fill\n\t\t * the page with useless information without generating any\n\t\t * I/O errors.\n\t\t */\n\t\tif (b_off > ((inode->i_size + PAGE_CACHE_SIZE - 1) >> ISOFS_BUFFER_BITS(inode))) {\n\t\t\tprintk(KERN_DEBUG \"%s: block >= EOF (%lu, %llu)\\n\",\n\t\t\t\t__func__, b_off,\n\t\t\t\t(unsigned long long)inode->i_size);\n\t\t\tgoto abort;\n\t\t}\n\n\t\t/* On the last section, nextblk == 0, section size is likely to\n\t\t * exceed sect_size by a partial block, and access beyond the\n\t\t * end of the file will reach beyond the section size, too.\n\t\t */\n\t\twhile (nextblk && (b_off >= (offset + sect_size))) {\n\t\t\tstruct inode *ninode;\n\n\t\t\toffset += sect_size;\n\t\t\tninode = isofs_iget(inode->i_sb, nextblk, nextoff);\n\t\t\tif (IS_ERR(ninode)) {\n\t\t\t\terror = PTR_ERR(ninode);\n\t\t\t\tgoto abort;\n\t\t\t}\n\t\t\tfirstext  = ISOFS_I(ninode)->i_first_extent;\n\t\t\tsect_size = ISOFS_I(ninode)->i_section_size >> ISOFS_BUFFER_BITS(ninode);\n\t\t\tnextblk   = ISOFS_I(ninode)->i_next_section_block;\n\t\t\tnextoff   = ISOFS_I(ninode)->i_next_section_offset;\n\t\t\tiput(ninode);\n\n\t\t\tif (++section > 100) {\n\t\t\t\tprintk(KERN_DEBUG \"%s: More than 100 file sections ?!?\"\n\t\t\t\t\t\" aborting...\\n\", __func__);\n\t\t\t\tprintk(KERN_DEBUG \"%s: block=%lu firstext=%u sect_size=%u \"\n\t\t\t\t\t\"nextblk=%lu nextoff=%lu\\n\", __func__,\n\t\t\t\t\tb_off, firstext, (unsigned) sect_size,\n\t\t\t\t\tnextblk, nextoff);\n\t\t\t\tgoto abort;\n\t\t\t}\n\t\t}\n\n\t\tif (*bh) {\n\t\t\tmap_bh(*bh, inode->i_sb, firstext + b_off - offset);\n\t\t} else {\n\t\t\t*bh = sb_getblk(inode->i_sb, firstext+b_off-offset);\n\t\t\tif (!*bh)\n\t\t\t\tgoto abort;\n\t\t}\n\t\tbh++;\t/* Next buffer head */\n\t\tb_off++;\t/* Next buffer offset */\n\t\tnblocks--;\n\t\trv++;\n\t}\n\n\terror = 0;\nabort:\n\treturn rv != 0 ? rv : error;\n}",
    "includes": [
      "include \"zisofs.h\"",
      "include \"isofs.h\"\n#",
      "include <linux/user_namespace.h>",
      "include <linux/mpage.h>\n#",
      "include <linux/parser.h>\n#",
      "include <linux/cdrom.h>\n#",
      "include <linux/statfs.h>\n#",
      "include <linux/ctype.h>\n#",
      "include <linux/nls.h>\n#",
      "include <linux/slab.h>\n#",
      "include <linux/module.h>",
      "include <linux/init.h>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "b_getblk(",
          "args": [
            "node->i_sb,",
            "irstext+b_off-offset)"
          ],
          "line": 1064
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ap_bh(",
          "args": [
            "bh,",
            "node->i_sb,",
            "irstext + b_off - offset)"
          ],
          "line": 1062
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rintk(",
          "args": [
            "ERN_DEBUG \"%s: block=%lu firstext=%u sect_size=%u \"\n\t\t\t\t\t\"nextblk=%lu nextoff=%lu\\n\",",
            "_func__,",
            "_off,",
            "irstext,",
            "unsigned) sect_size,",
            "extblk,",
            "extoff)"
          ],
          "line": 1053
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rintk(",
          "args": [
            "ERN_DEBUG \"%s: More than 100 file sections ?!?\"\n\t\t\t\t\t\" aborting...\\n\",",
            "_func__)"
          ],
          "line": 1051
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put(",
          "args": [
            "inode)"
          ],
          "line": 1048
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SOFS_I(",
          "args": [
            "inode)"
          ],
          "line": 1047
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SOFS_I(",
          "args": [
            "inode)"
          ],
          "line": 1046
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SOFS_BUFFER_BITS(",
          "args": [
            "inode)"
          ],
          "line": 1045
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SOFS_I(",
          "args": [
            "inode)"
          ],
          "line": 1045
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SOFS_I(",
          "args": [
            "inode)"
          ],
          "line": 1044
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TR_ERR(",
          "args": [
            "inode)"
          ],
          "line": 1041
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ERR(",
          "args": [
            "inode)"
          ],
          "line": 1040
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sofs_iget(",
          "args": [
            "node->i_sb,",
            "extblk,",
            "extoff)"
          ],
          "line": 1039
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rintk(",
          "args": [
            "ERN_DEBUG \"%s: block >= EOF (%lu, %llu)\\n\",",
            "_func__,",
            "_off,",
            "unsigned long long)inode->i_size)"
          ],
          "line": 1025
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SOFS_BUFFER_BITS(",
          "args": [
            "node)"
          ],
          "line": 1024
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SOFS_BUFFER_BITS(",
          "args": [
            "node)"
          ],
          "line": 1011
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rintk(",
          "args": [
            "ERN_DEBUG \"%s: block number too large\\n\",",
            "_func__)"
          ],
          "line": 1004
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SOFS_I(",
          "args": [
            "node)"
          ],
          "line": 999
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"zisofs.h\"\ninclude \"isofs.h\"\n#\ninclude <linux/user_namespace.h>\ninclude <linux/mpage.h>\n#\ninclude <linux/parser.h>\n#\ninclude <linux/cdrom.h>\n#\ninclude <linux/statfs.h>\n#\ninclude <linux/ctype.h>\n#\ninclude <linux/nls.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/module.h>\ninclude <linux/init.h>\n#\n\nnt isofs_get_blocks(struct inode *inode, sector_t iblock,\n\t\t     struct buffer_head **bh, unsigned long nblocks)\n{\n\tunsigned long b_off = iblock;\n\tunsigned offset, sect_size;\n\tunsigned int firstext;\n\tunsigned long nextblk, nextoff;\n\tint section, rv, error;\n\tstruct iso_inode_info *ei = ISOFS_I(inode);\n\n\terror = -EIO;\n\trv = 0;\n\tif (iblock != b_off) {\n\t\tprintk(KERN_DEBUG \"%s: block number too large\\n\", __func__);\n\t\tgoto abort;\n\t}\n\n\n\toffset = 0;\n\tfirstext = ei->i_first_extent;\n\tsect_size = ei->i_section_size >> ISOFS_BUFFER_BITS(inode);\n\tnextblk = ei->i_next_section_block;\n\tnextoff = ei->i_next_section_offset;\n\tsection = 0;\n\n\twhile (nblocks) {\n\t\t/* If we are *way* beyond the end of the file, print a message.\n\t\t * Access beyond the end of the file up to the next page boundary\n\t\t * is normal, however because of the way the page cache works.\n\t\t * In this case, we just return 0 so that we can properly fill\n\t\t * the page with useless information without generating any\n\t\t * I/O errors.\n\t\t */\n\t\tif (b_off > ((inode->i_size + PAGE_CACHE_SIZE - 1) >> ISOFS_BUFFER_BITS(inode))) {\n\t\t\tprintk(KERN_DEBUG \"%s: block >= EOF (%lu, %llu)\\n\",\n\t\t\t\t__func__, b_off,\n\t\t\t\t(unsigned long long)inode->i_size);\n\t\t\tgoto abort;\n\t\t}\n\n\t\t/* On the last section, nextblk == 0, section size is likely to\n\t\t * exceed sect_size by a partial block, and access beyond the\n\t\t * end of the file will reach beyond the section size, too.\n\t\t */\n\t\twhile (nextblk && (b_off >= (offset + sect_size))) {\n\t\t\tstruct inode *ninode;\n\n\t\t\toffset += sect_size;\n\t\t\tninode = isofs_iget(inode->i_sb, nextblk, nextoff);\n\t\t\tif (IS_ERR(ninode)) {\n\t\t\t\terror = PTR_ERR(ninode);\n\t\t\t\tgoto abort;\n\t\t\t}\n\t\t\tfirstext  = ISOFS_I(ninode)->i_first_extent;\n\t\t\tsect_size = ISOFS_I(ninode)->i_section_size >> ISOFS_BUFFER_BITS(ninode);\n\t\t\tnextblk   = ISOFS_I(ninode)->i_next_section_block;\n\t\t\tnextoff   = ISOFS_I(ninode)->i_next_section_offset;\n\t\t\tiput(ninode);\n\n\t\t\tif (++section > 100) {\n\t\t\t\tprintk(KERN_DEBUG \"%s: More than 100 file sections ?!?\"\n\t\t\t\t\t\" aborting...\\n\", __func__);\n\t\t\t\tprintk(KERN_DEBUG \"%s: block=%lu firstext=%u sect_size=%u \"\n\t\t\t\t\t\"nextblk=%lu nextoff=%lu\\n\", __func__,\n\t\t\t\t\tb_off, firstext, (unsigned) sect_size,\n\t\t\t\t\tnextblk, nextoff);\n\t\t\t\tgoto abort;\n\t\t\t}\n\t\t}\n\n\t\tif (*bh) {\n\t\t\tmap_bh(*bh, inode->i_sb, firstext + b_off - offset);\n\t\t} else {\n\t\t\t*bh = sb_getblk(inode->i_sb, firstext+b_off-offset);\n\t\t\tif (!*bh)\n\t\t\t\tgoto abort;\n\t\t}\n\t\tbh++;\t/* Next buffer head */\n\t\tb_off++;\t/* Next buffer offset */\n\t\tnblocks--;\n\t\trv++;\n\t}\n\n\terror = 0;\nabort:\n\treturn rv != 0 ? rv : error;\n}"
  },
  {
    "function_name": "sofs_statfs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/isofs/inode.c",
    "lines": "967-984",
    "snippet": "tatic int isofs_statfs (struct dentry *dentry, struct kstatfs *buf)\n{\n\tstruct super_block *sb = dentry->d_sb;\n\tu64 id = huge_encode_dev(sb->s_bdev->bd_dev);\n\n\tbuf->f_type = ISOFS_SUPER_MAGIC;\n\tbuf->f_bsize = sb->s_blocksize;\n\tbuf->f_blocks = (ISOFS_SB(sb)->s_nzones\n\t\t<< (ISOFS_SB(sb)->s_log_zone_size - sb->s_blocksize_bits));\n\tbuf->f_bfree = 0;\n\tbuf->f_bavail = 0;\n\tbuf->f_files = ISOFS_SB(sb)->s_ninodes;\n\tbuf->f_ffree = 0;\n\tbuf->f_fsid.val[0] = (u32)id;\n\tbuf->f_fsid.val[1] = (u32)(id >> 32);\n\tbuf->f_namelen = NAME_MAX;\n\treturn 0;\n}",
    "includes": [
      "include \"zisofs.h\"",
      "include \"isofs.h\"\n#",
      "include <linux/user_namespace.h>",
      "include <linux/mpage.h>\n#",
      "include <linux/parser.h>\n#",
      "include <linux/cdrom.h>\n#",
      "include <linux/statfs.h>\n#",
      "include <linux/ctype.h>\n#",
      "include <linux/nls.h>\n#",
      "include <linux/slab.h>\n#",
      "include <linux/module.h>",
      "include <linux/init.h>\n#"
    ],
    "macros_used": [],
    "globals_used": [
      "tatic int isofs_statfs (struct dentry *, struct kstatfs *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "u32)",
          "args": [
            "d >> 32)"
          ],
          "line": 981
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SOFS_SB(",
          "args": [
            "b)"
          ],
          "line": 978
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SOFS_SB(",
          "args": [
            "b)"
          ],
          "line": 975
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SOFS_SB(",
          "args": [
            "b)"
          ],
          "line": 974
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uge_encode_dev(",
          "args": [
            "b->s_bdev->bd_dev)"
          ],
          "line": 970
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"zisofs.h\"\ninclude \"isofs.h\"\n#\ninclude <linux/user_namespace.h>\ninclude <linux/mpage.h>\n#\ninclude <linux/parser.h>\n#\ninclude <linux/cdrom.h>\n#\ninclude <linux/statfs.h>\n#\ninclude <linux/ctype.h>\n#\ninclude <linux/nls.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/module.h>\ninclude <linux/init.h>\n#\n\ntatic int isofs_statfs (struct dentry *, struct kstatfs *);\n\ntatic int isofs_statfs (struct dentry *dentry, struct kstatfs *buf)\n{\n\tstruct super_block *sb = dentry->d_sb;\n\tu64 id = huge_encode_dev(sb->s_bdev->bd_dev);\n\n\tbuf->f_type = ISOFS_SUPER_MAGIC;\n\tbuf->f_bsize = sb->s_blocksize;\n\tbuf->f_blocks = (ISOFS_SB(sb)->s_nzones\n\t\t<< (ISOFS_SB(sb)->s_log_zone_size - sb->s_blocksize_bits));\n\tbuf->f_bfree = 0;\n\tbuf->f_bavail = 0;\n\tbuf->f_files = ISOFS_SB(sb)->s_ninodes;\n\tbuf->f_ffree = 0;\n\tbuf->f_fsid.val[0] = (u32)id;\n\tbuf->f_fsid.val[1] = (u32)(id >> 32);\n\tbuf->f_namelen = NAME_MAX;\n\treturn 0;\n}"
  },
  {
    "function_name": "sofs_fill_super(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/isofs/inode.c",
    "lines": "571-965",
    "snippet": "tatic int isofs_fill_super(struct super_block *s, void *data, int silent)\n{\n\tstruct buffer_head *bh = NULL, *pri_bh = NULL;\n\tstruct hs_primary_descriptor *h_pri = NULL;\n\tstruct iso_primary_descriptor *pri = NULL;\n\tstruct iso_supplementary_descriptor *sec = NULL;\n\tstruct iso_directory_record *rootp;\n\tstruct inode *inode;\n\tstruct iso9660_options opt;\n\tstruct isofs_sb_info *sbi;\n\tunsigned long first_data_zone;\n\tint joliet_level = 0;\n\tint iso_blknum, block;\n\tint orig_zonesize;\n\tint table, error = -EINVAL;\n\tunsigned int vol_desc_start;\n\n\tsave_mount_options(s, data);\n\n\tsbi = kzalloc(sizeof(*sbi), GFP_KERNEL);\n\tif (!sbi)\n\t\treturn -ENOMEM;\n\ts->s_fs_info = sbi;\n\n\tif (!parse_options((char *)data, &opt))\n\t\tgoto out_freesbi;\n\n\t/*\n\t * First of all, get the hardware blocksize for this device.\n\t * If we don't know what it is, or the hardware blocksize is\n\t * larger than the blocksize the user specified, then use\n\t * that value.\n\t */\n\t/*\n\t * What if bugger tells us to go beyond page size?\n\t */\n\topt.blocksize = sb_min_blocksize(s, opt.blocksize);\n\n\tsbi->s_high_sierra = 0; /* default is iso9660 */\n\n\tvol_desc_start = (opt.sbsector != -1) ?\n\t\topt.sbsector : isofs_get_last_session(s,opt.session);\n\n\tfor (iso_blknum = vol_desc_start+16;\n\t\tiso_blknum < vol_desc_start+100; iso_blknum++) {\n\t\tstruct hs_volume_descriptor *hdp;\n\t\tstruct iso_volume_descriptor  *vdp;\n\n\t\tblock = iso_blknum << (ISOFS_BLOCK_BITS - s->s_blocksize_bits);\n\t\tif (!(bh = sb_bread(s, block)))\n\t\t\tgoto out_no_read;\n\n\t\tvdp = (struct iso_volume_descriptor *)bh->b_data;\n\t\thdp = (struct hs_volume_descriptor *)bh->b_data;\n\n\t\t/*\n\t\t * Due to the overlapping physical location of the descriptors,\n\t\t * ISO CDs can match hdp->id==HS_STANDARD_ID as well. To ensure\n\t\t * proper identification in this case, we first check for ISO.\n\t\t */\n\t\tif (strncmp (vdp->id, ISO_STANDARD_ID, sizeof vdp->id) == 0) {\n\t\t\tif (isonum_711(vdp->type) == ISO_VD_END)\n\t\t\t\tbreak;\n\t\t\tif (isonum_711(vdp->type) == ISO_VD_PRIMARY) {\n\t\t\t\tif (pri == NULL) {\n\t\t\t\t\tpri = (struct iso_primary_descriptor *)vdp;\n\t\t\t\t\t/* Save the buffer in case we need it ... */\n\t\t\t\t\tpri_bh = bh;\n\t\t\t\t\tbh = NULL;\n\t\t\t\t}\n\t\t\t}\n#ifdef CONFIG_JOLIET\n\t\t\telse if (isonum_711(vdp->type) == ISO_VD_SUPPLEMENTARY) {\n\t\t\t\tsec = (struct iso_supplementary_descriptor *)vdp;\n\t\t\t\tif (sec->escape[0] == 0x25 && sec->escape[1] == 0x2f) {\n\t\t\t\t\tif (opt.joliet) {\n\t\t\t\t\t\tif (sec->escape[2] == 0x40)\n\t\t\t\t\t\t\tjoliet_level = 1;\n\t\t\t\t\t\telse if (sec->escape[2] == 0x43)\n\t\t\t\t\t\t\tjoliet_level = 2;\n\t\t\t\t\t\telse if (sec->escape[2] == 0x45)\n\t\t\t\t\t\t\tjoliet_level = 3;\n\n\t\t\t\t\t\tprintk(KERN_DEBUG \"ISO 9660 Extensions: \"\n\t\t\t\t\t\t\t\"Microsoft Joliet Level %d\\n\",\n\t\t\t\t\t\t\tjoliet_level);\n\t\t\t\t\t}\n\t\t\t\t\tgoto root_found;\n\t\t\t\t} else {\n\t\t\t\t/* Unknown supplementary volume descriptor */\n\t\t\t\tsec = NULL;\n\t\t\t\t}\n\t\t\t}\n#endif\n\t\t} else {\n\t\t\tif (strncmp (hdp->id, HS_STANDARD_ID, sizeof hdp->id) == 0) {\n\t\t\t\tif (isonum_711(hdp->type) != ISO_VD_PRIMARY)\n\t\t\t\t\tgoto out_freebh;\n\n\t\t\t\tsbi->s_high_sierra = 1;\n\t\t\t\topt.rock = 0;\n\t\t\t\th_pri = (struct hs_primary_descriptor *)vdp;\n\t\t\t\tgoto root_found;\n\t\t\t}\n\t\t}\n\n\t\t/* Just skip any volume descriptors we don't recognize */\n\n\t\tbrelse(bh);\n\t\tbh = NULL;\n\t}\n\t/*\n\t * If we fall through, either no volume descriptor was found,\n\t * or else we passed a primary descriptor looking for others.\n\t */\n\tif (!pri)\n\t\tgoto out_unknown_format;\n\tbrelse(bh);\n\tbh = pri_bh;\n\tpri_bh = NULL;\n\nroot_found:\n\n\tif (joliet_level && (pri == NULL || !opt.rock)) {\n\t\t/* This is the case of Joliet with the norock mount flag.\n\t\t * A disc with both Joliet and Rock Ridge is handled later\n\t\t */\n\t\tpri = (struct iso_primary_descriptor *) sec;\n\t}\n\n\tif(sbi->s_high_sierra){\n\t\trootp = (struct iso_directory_record *) h_pri->root_directory_record;\n\t\tsbi->s_nzones = isonum_733(h_pri->volume_space_size);\n\t\tsbi->s_log_zone_size = isonum_723(h_pri->logical_block_size);\n\t\tsbi->s_max_size = isonum_733(h_pri->volume_space_size);\n\t} else {\n\t\tif (!pri)\n\t\t\tgoto out_freebh;\n\t\trootp = (struct iso_directory_record *) pri->root_directory_record;\n\t\tsbi->s_nzones = isonum_733(pri->volume_space_size);\n\t\tsbi->s_log_zone_size = isonum_723(pri->logical_block_size);\n\t\tsbi->s_max_size = isonum_733(pri->volume_space_size);\n\t}\n\n\tsbi->s_ninodes = 0; /* No way to figure this out easily */\n\n\torig_zonesize = sbi->s_log_zone_size;\n\t/*\n\t * If the zone size is smaller than the hardware sector size,\n\t * this is a fatal error.  This would occur if the disc drive\n\t * had sectors that were 2048 bytes, but the filesystem had\n\t * blocks that were 512 bytes (which should only very rarely\n\t * happen.)\n\t */\n\tif (orig_zonesize < opt.blocksize)\n\t\tgoto out_bad_size;\n\n\t/* RDE: convert log zone size to bit shift */\n\tswitch (sbi->s_log_zone_size) {\n\tcase  512: sbi->s_log_zone_size =  9; break;\n\tcase 1024: sbi->s_log_zone_size = 10; break;\n\tcase 2048: sbi->s_log_zone_size = 11; break;\n\n\tdefault:\n\t\tgoto out_bad_zone_size;\n\t}\n\n\ts->s_magic = ISOFS_SUPER_MAGIC;\n\n\t/*\n\t * With multi-extent files, file size is only limited by the maximum\n\t * size of a file system, which is 8 TB.\n\t */\n\ts->s_maxbytes = 0x80000000000LL;\n\n\t/* Set this for reference. Its not currently used except on write\n\t   which we don't have .. */\n\n\tfirst_data_zone = isonum_733(rootp->extent) +\n\t\t\t  isonum_711(rootp->ext_attr_length);\n\tsbi->s_firstdatazone = first_data_zone;\n#ifndef BEQUIET\n\tprintk(KERN_DEBUG \"ISOFS: Max size:%ld   Log zone size:%ld\\n\",\n\t\tsbi->s_max_size, 1UL << sbi->s_log_zone_size);\n\tprintk(KERN_DEBUG \"ISOFS: First datazone:%ld\\n\", sbi->s_firstdatazone);\n\tif(sbi->s_high_sierra)\n\t\tprintk(KERN_DEBUG \"ISOFS: Disc in High Sierra format.\\n\");\n#endif\n\n\t/*\n\t * If the Joliet level is set, we _may_ decide to use the\n\t * secondary descriptor, but can't be sure until after we\n\t * read the root inode. But before reading the root inode\n\t * we may need to change the device blocksize, and would\n\t * rather release the old buffer first. So, we cache the\n\t * first_data_zone value from the secondary descriptor.\n\t */\n\tif (joliet_level) {\n\t\tpri = (struct iso_primary_descriptor *) sec;\n\t\trootp = (struct iso_directory_record *)\n\t\t\tpri->root_directory_record;\n\t\tfirst_data_zone = isonum_733(rootp->extent) +\n\t\t\t\tisonum_711(rootp->ext_attr_length);\n\t}\n\n\t/*\n\t * We're all done using the volume descriptor, and may need\n\t * to change the device blocksize, so release the buffer now.\n\t */\n\tbrelse(pri_bh);\n\tbrelse(bh);\n\n\t/*\n\t * Force the blocksize to 512 for 512 byte sectors.  The file\n\t * read primitives really get it wrong in a bad way if we don't\n\t * do this.\n\t *\n\t * Note - we should never be setting the blocksize to something\n\t * less than the hardware sector size for the device.  If we\n\t * do, we would end up having to read larger buffers and split\n\t * out portions to satisfy requests.\n\t *\n\t * Note2- the idea here is that we want to deal with the optimal\n\t * zonesize in the filesystem.  If we have it set to something less,\n\t * then we have horrible problems with trying to piece together\n\t * bits of adjacent blocks in order to properly read directory\n\t * entries.  By forcing the blocksize in this way, we ensure\n\t * that we will never be required to do this.\n\t */\n\tsb_set_blocksize(s, orig_zonesize);\n\n\tsbi->s_nls_iocharset = NULL;\n\n#ifdef CONFIG_JOLIET\n\tif (joliet_level && opt.utf8 == 0) {\n\t\tchar *p = opt.iocharset ? opt.iocharset : CONFIG_NLS_DEFAULT;\n\t\tsbi->s_nls_iocharset = load_nls(p);\n\t\tif (! sbi->s_nls_iocharset) {\n\t\t\t/* Fail only if explicit charset specified */\n\t\t\tif (opt.iocharset)\n\t\t\t\tgoto out_freesbi;\n\t\t\tsbi->s_nls_iocharset = load_nls_default();\n\t\t}\n\t}\n#endif\n\ts->s_op = &isofs_sops;\n\ts->s_export_op = &isofs_export_ops;\n\tsbi->s_mapping = opt.map;\n\tsbi->s_rock = (opt.rock ? 2 : 0);\n\tsbi->s_rock_offset = -1; /* initial offset, will guess until SP is found*/\n\tsbi->s_cruft = opt.cruft;\n\tsbi->s_hide = opt.hide;\n\tsbi->s_showassoc = opt.showassoc;\n\tsbi->s_uid = opt.uid;\n\tsbi->s_gid = opt.gid;\n\tsbi->s_uid_set = opt.uid_set;\n\tsbi->s_gid_set = opt.gid_set;\n\tsbi->s_utf8 = opt.utf8;\n\tsbi->s_nocompress = opt.nocompress;\n\tsbi->s_overriderockperm = opt.overriderockperm;\n\t/*\n\t * It would be incredibly stupid to allow people to mark every file\n\t * on the disk as suid, so we merely allow them to set the default\n\t * permissions.\n\t */\n\tif (opt.fmode != ISOFS_INVALID_MODE)\n\t\tsbi->s_fmode = opt.fmode & 0777;\n\telse\n\t\tsbi->s_fmode = ISOFS_INVALID_MODE;\n\tif (opt.dmode != ISOFS_INVALID_MODE)\n\t\tsbi->s_dmode = opt.dmode & 0777;\n\telse\n\t\tsbi->s_dmode = ISOFS_INVALID_MODE;\n\n\t/*\n\t * Read the root inode, which _may_ result in changing\n\t * the s_rock flag. Once we have the final s_rock value,\n\t * we then decide whether to use the Joliet descriptor.\n\t */\n\tinode = isofs_iget(s, sbi->s_firstdatazone, 0);\n\tif (IS_ERR(inode))\n\t\tgoto out_no_root;\n\n\t/*\n\t * Fix for broken CDs with Rock Ridge and empty ISO root directory but\n\t * correct Joliet root directory.\n\t */\n\tif (sbi->s_rock == 1 && joliet_level &&\n\t\t\t\trootdir_empty(s, sbi->s_firstdatazone)) {\n\t\tprintk(KERN_NOTICE\n\t\t\t\"ISOFS: primary root directory is empty. \"\n\t\t\t\"Disabling Rock Ridge and switching to Joliet.\");\n\t\tsbi->s_rock = 0;\n\t}\n\n\t/*\n\t * If this disk has both Rock Ridge and Joliet on it, then we\n\t * want to use Rock Ridge by default.  This can be overridden\n\t * by using the norock mount option.  There is still one other\n\t * possibility that is not taken into account: a Rock Ridge\n\t * CD with Unicode names.  Until someone sees such a beast, it\n\t * will not be supported.\n\t */\n\tif (sbi->s_rock == 1) {\n\t\tjoliet_level = 0;\n\t} else if (joliet_level) {\n\t\tsbi->s_rock = 0;\n\t\tif (sbi->s_firstdatazone != first_data_zone) {\n\t\t\tsbi->s_firstdatazone = first_data_zone;\n\t\t\tprintk(KERN_DEBUG\n\t\t\t\t\"ISOFS: changing to secondary root\\n\");\n\t\t\tiput(inode);\n\t\t\tinode = isofs_iget(s, sbi->s_firstdatazone, 0);\n\t\t\tif (IS_ERR(inode))\n\t\t\t\tgoto out_no_root;\n\t\t}\n\t}\n\n\tif (opt.check == 'u') {\n\t\t/* Only Joliet is case insensitive by default */\n\t\tif (joliet_level)\n\t\t\topt.check = 'r';\n\t\telse\n\t\t\topt.check = 's';\n\t}\n\tsbi->s_joliet_level = joliet_level;\n\n\t/* Make sure the root inode is a directory */\n\tif (!S_ISDIR(inode->i_mode)) {\n\t\tprintk(KERN_WARNING\n\t\t\t\"isofs_fill_super: root inode is not a directory. \"\n\t\t\t\"Corrupted media?\\n\");\n\t\tgoto out_iput;\n\t}\n\n\ttable = 0;\n\tif (joliet_level)\n\t\ttable += 2;\n\tif (opt.check == 'r')\n\t\ttable++;\n\n\tif (table)\n\t\ts->s_d_op = &isofs_dentry_ops[table - 1];\n\n\t/* get the root dentry */\n\ts->s_root = d_make_root(inode);\n\tif (!(s->s_root)) {\n\t\terror = -ENOMEM;\n\t\tgoto out_no_inode;\n\t}\n\n\tkfree(opt.iocharset);\n\n\treturn 0;\n\n\t/*\n\t * Display error messages and free resources.\n\t */\nout_iput:\n\tiput(inode);\n\tgoto out_no_inode;\nout_no_root:\n\terror = PTR_ERR(inode);\n\tif (error != -ENOMEM)\n\t\tprintk(KERN_WARNING \"%s: get root inode failed\\n\", __func__);\nout_no_inode:\n#ifdef CONFIG_JOLIET\n\tunload_nls(sbi->s_nls_iocharset);\n#endif\n\tgoto out_freesbi;\nout_no_read:\n\tprintk(KERN_WARNING \"%s: bread failed, dev=%s, iso_blknum=%d, block=%d\\n\",\n\t\t__func__, s->s_id, iso_blknum, block);\n\tgoto out_freebh;\nout_bad_zone_size:\n\tprintk(KERN_WARNING \"ISOFS: Bad logical zone size %ld\\n\",\n\t\tsbi->s_log_zone_size);\n\tgoto out_freebh;\nout_bad_size:\n\tprintk(KERN_WARNING \"ISOFS: Logical zone size(%d) < hardware blocksize(%u)\\n\",\n\t\torig_zonesize, opt.blocksize);\n\tgoto out_freebh;\nout_unknown_format:\n\tif (!silent)\n\t\tprintk(KERN_WARNING \"ISOFS: Unable to identify CD-ROM format.\\n\");\n\nout_freebh:\n\tbrelse(bh);\n\tbrelse(pri_bh);\nout_freesbi:\n\tkfree(opt.iocharset);\n\tkfree(sbi);\n\ts->s_fs_info = NULL;\n\treturn error;\n}",
    "includes": [
      "include \"zisofs.h\"",
      "include \"isofs.h\"\n#",
      "include <linux/user_namespace.h>",
      "include <linux/mpage.h>\n#",
      "include <linux/parser.h>\n#",
      "include <linux/cdrom.h>\n#",
      "include <linux/statfs.h>\n#",
      "include <linux/ctype.h>\n#",
      "include <linux/nls.h>\n#",
      "include <linux/slab.h>\n#",
      "include <linux/module.h>",
      "include <linux/init.h>\n#"
    ],
    "macros_used": [],
    "globals_used": [
      "tatic const struct super_operations isofs_sops = {\n\t.alloc_inode\t= isofs_alloc_inode,\n\t.destroy_inode\t= isofs_destroy_inode,\n\t.put_super\t= isofs_put_super,\n\t.statfs\t\t= isofs_statfs,\n\t.remount_fs\t= isofs_remount,\n\t.show_options\t= generic_show_options,\n};",
      "tatic const struct dentry_operations isofs_dentry_ops[] = {\n\t{\n\t\t.d_hash\t\t= isofs_hashi,\n\t\t.d_compare\t= isofs_dentry_cmpi,\n\t},\n#ifdef CONFIG_JOLIET\n\t{\n\t\t.d_hash\t\t= isofs_hash_ms,\n\t\t.d_compare\t= isofs_dentry_cmp_ms,\n\t},\n\t{\n\t\t.d_hash\t\t= isofs_hashi_ms,\n\t\t.d_compare\t= isofs_dentry_cmpi_ms,\n\t},\n#endif\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free(",
          "args": [
            "bi)"
          ],
          "line": 962
        },
        "resolved": true,
        "details": {
          "function_name": "in_free(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/scan.c",
          "lines": "51-60",
          "snippet": "tatic inline int min_free(struct jffs2_sb_info *c)\n{\n\tuint32_t min = 2 * sizeof(struct jffs2_raw_inode);\n#ifdef CONFIG_JFFS2_FS_WRITEBUFFER\n\tif (!jffs2_can_mark_obsolete(c) && min < c->wbuf_pagesize)\n\t\treturn c->wbuf_pagesize;\n#endif\n\treturn min;\n\n}",
          "includes": [
            "include \"debug.h\"",
            "include \"summary.h\"\n#",
            "include \"nodelist.h\"\n#",
            "include <linux/compiler.h>\n#",
            "include <linux/crc32.h>\n#",
            "include <linux/pagemap.h>\n#",
            "include <linux/mtd/mtd.h>\n#",
            "include <linux/slab.h>\n#",
            "include <linux/sched.h>\n#",
            "include <linux/kernel.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"debug.h\"\ninclude \"summary.h\"\n#\ninclude \"nodelist.h\"\n#\ninclude <linux/compiler.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/pagemap.h>\n#\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/sched.h>\n#\ninclude <linux/kernel.h>\n#\n\ntatic inline int min_free(struct jffs2_sb_info *c)\n{\n\tuint32_t min = 2 * sizeof(struct jffs2_raw_inode);\n#ifdef CONFIG_JFFS2_FS_WRITEBUFFER\n\tif (!jffs2_can_mark_obsolete(c) && min < c->wbuf_pagesize)\n\t\treturn c->wbuf_pagesize;\n#endif\n\treturn min;\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "relse(",
          "args": [
            "ri_bh)"
          ],
          "line": 959
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "relse(",
          "args": [
            "h)"
          ],
          "line": 958
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rintk(",
          "args": [
            "ERN_WARNING \"ISOFS: Unable to identify CD-ROM format.\\n\")"
          ],
          "line": 955
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rintk(",
          "args": [
            "ERN_WARNING \"ISOFS: Logical zone size(%d) < hardware blocksize(%u)\\n\",",
            "rig_zonesize,",
            "pt.blocksize)"
          ],
          "line": 950
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rintk(",
          "args": [
            "ERN_WARNING \"ISOFS: Bad logical zone size %ld\\n\",",
            "bi->s_log_zone_size)"
          ],
          "line": 946
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rintk(",
          "args": [
            "ERN_WARNING \"%s: bread failed, dev=%s, iso_blknum=%d, block=%d\\n\",",
            "_func__,",
            "->s_id,",
            "so_blknum,",
            "lock)"
          ],
          "line": 942
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nload_nls(",
          "args": [
            "bi->s_nls_iocharset)"
          ],
          "line": 938
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rintk(",
          "args": [
            "ERN_WARNING \"%s: get root inode failed\\n\",",
            "_func__)"
          ],
          "line": 935
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TR_ERR(",
          "args": [
            "node)"
          ],
          "line": 933
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put(",
          "args": [
            "node)"
          ],
          "line": 930
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_make_root(",
          "args": [
            "node)"
          ],
          "line": 916
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rintk(",
          "args": [
            "ERN_WARNING\n\t\t\t\"isofs_fill_super: root inode is not a directory. \"\n\t\t\t\"Corrupted media?\\n\")"
          ],
          "line": 900
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ISDIR(",
          "args": [
            "node->i_mode)"
          ],
          "line": 899
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ERR(",
          "args": [
            "node)"
          ],
          "line": 884
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sofs_iget(",
          "args": [
            ",",
            "bi->s_firstdatazone,",
            ")"
          ],
          "line": 883
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put(",
          "args": [
            "node)"
          ],
          "line": 882
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rintk(",
          "args": [
            "ERN_DEBUG\n\t\t\t\t\"ISOFS: changing to secondary root\\n\")"
          ],
          "line": 880
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rintk(",
          "args": [
            "ERN_NOTICE\n\t\t\t\"ISOFS: primary root directory is empty. \"\n\t\t\t\"Disabling Rock Ridge and switching to Joliet.\")"
          ],
          "line": 860
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ootdir_empty(",
          "args": [
            ",",
            "bi->s_firstdatazone)"
          ],
          "line": 859
        },
        "resolved": true,
        "details": {
          "function_name": "ootdir_empty(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/isofs/inode.c",
          "lines": "544-563",
          "snippet": "tatic bool rootdir_empty(struct super_block *sb, unsigned long block)\n{\n\tint offset = 0, files = 0, de_len;\n\tstruct iso_directory_record *de;\n\tstruct buffer_head *bh;\n\n\tbh = sb_bread(sb, block);\n\tif (!bh)\n\t\treturn true;\n\twhile (files < 3) {\n\t\tde = (struct iso_directory_record *) (bh->b_data + offset);\n\t\tde_len = *(unsigned char *) de;\n\t\tif (de_len == 0)\n\t\t\tbreak;\n\t\tfiles++;\n\t\toffset += de_len;\n\t}\n\tbrelse(bh);\n\treturn files < 3;\n}",
          "includes": [
            "include \"zisofs.h\"",
            "include \"isofs.h\"\n#",
            "include <linux/user_namespace.h>",
            "include <linux/mpage.h>\n#",
            "include <linux/parser.h>\n#",
            "include <linux/cdrom.h>\n#",
            "include <linux/statfs.h>\n#",
            "include <linux/ctype.h>\n#",
            "include <linux/nls.h>\n#",
            "include <linux/slab.h>\n#",
            "include <linux/module.h>",
            "include <linux/init.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"zisofs.h\"\ninclude \"isofs.h\"\n#\ninclude <linux/user_namespace.h>\ninclude <linux/mpage.h>\n#\ninclude <linux/parser.h>\n#\ninclude <linux/cdrom.h>\n#\ninclude <linux/statfs.h>\n#\ninclude <linux/ctype.h>\n#\ninclude <linux/nls.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/module.h>\ninclude <linux/init.h>\n#\n\ntatic bool rootdir_empty(struct super_block *sb, unsigned long block)\n{\n\tint offset = 0, files = 0, de_len;\n\tstruct iso_directory_record *de;\n\tstruct buffer_head *bh;\n\n\tbh = sb_bread(sb, block);\n\tif (!bh)\n\t\treturn true;\n\twhile (files < 3) {\n\t\tde = (struct iso_directory_record *) (bh->b_data + offset);\n\t\tde_len = *(unsigned char *) de;\n\t\tif (de_len == 0)\n\t\t\tbreak;\n\t\tfiles++;\n\t\toffset += de_len;\n\t}\n\tbrelse(bh);\n\treturn files < 3;\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ERR(",
          "args": [
            "node)"
          ],
          "line": 851
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sofs_iget(",
          "args": [
            ",",
            "bi->s_firstdatazone,",
            ")"
          ],
          "line": 850
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "oad_nls_default(",
          "args": [],
          "line": 812
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "oad_nls(",
          "args": [
            ")"
          ],
          "line": 807
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "b_set_blocksize(",
          "args": [
            ",",
            "rig_zonesize)"
          ],
          "line": 800
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "relse(",
          "args": [
            "h)"
          ],
          "line": 781
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "relse(",
          "args": [
            "ri_bh)"
          ],
          "line": 780
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sonum_711(",
          "args": [
            "ootp->ext_attr_length)"
          ],
          "line": 773
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sonum_733(",
          "args": [
            "ootp->extent)"
          ],
          "line": 772
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rintk(",
          "args": [
            "ERN_DEBUG \"ISOFS: Disc in High Sierra format.\\n\")"
          ],
          "line": 757
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rintk(",
          "args": [
            "ERN_DEBUG \"ISOFS: First datazone:%ld\\n\",",
            "bi->s_firstdatazone)"
          ],
          "line": 755
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rintk(",
          "args": [
            "ERN_DEBUG \"ISOFS: Max size:%ld   Log zone size:%ld\\n\",",
            "bi->s_max_size,",
            "UL << sbi->s_log_zone_size)"
          ],
          "line": 753
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sonum_711(",
          "args": [
            "ootp->ext_attr_length)"
          ],
          "line": 750
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sonum_733(",
          "args": [
            "ootp->extent)"
          ],
          "line": 749
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sonum_733(",
          "args": [
            "ri->volume_space_size)"
          ],
          "line": 712
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sonum_723(",
          "args": [
            "ri->logical_block_size)"
          ],
          "line": 711
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sonum_733(",
          "args": [
            "ri->volume_space_size)"
          ],
          "line": 710
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sonum_733(",
          "args": [
            "_pri->volume_space_size)"
          ],
          "line": 705
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sonum_723(",
          "args": [
            "_pri->logical_block_size)"
          ],
          "line": 704
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sonum_733(",
          "args": [
            "_pri->volume_space_size)"
          ],
          "line": 703
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "relse(",
          "args": [
            "h)"
          ],
          "line": 688
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "relse(",
          "args": [
            "h)"
          ],
          "line": 679
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sonum_711(",
          "args": [
            "dp->type)"
          ],
          "line": 667
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trncmp",
          "args": [
            "dp->id,",
            "S_STANDARD_ID,",
            "izeof hdp->id)"
          ],
          "line": 666
        },
        "resolved": true,
        "details": {
          "function_name": "UniStrncmp_le",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifs_unicode.h",
          "lines": "256-266",
          "snippet": "static inline int\nUniStrncmp_le(const wchar_t *ucs1, const wchar_t *ucs2, size_t n)\n{\n\tif (!n)\n\t\treturn 0;\t/* Null strings are equal */\n\twhile ((*ucs1 == __le16_to_cpu(*ucs2)) && *ucs1 && --n) {\n\t\tucs1++;\n\t\tucs2++;\n\t}\n\treturn (int) *ucs1 - (int) __le16_to_cpu(*ucs2);\n}",
          "includes": [
            "#include <linux/nls.h>",
            "#include <linux/types.h>",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nls.h>\n#include <linux/types.h>\n#include <asm/byteorder.h>\n\nstatic inline int\nUniStrncmp_le(const wchar_t *ucs1, const wchar_t *ucs2, size_t n)\n{\n\tif (!n)\n\t\treturn 0;\t/* Null strings are equal */\n\twhile ((*ucs1 == __le16_to_cpu(*ucs2)) && *ucs1 && --n) {\n\t\tucs1++;\n\t\tucs2++;\n\t}\n\treturn (int) *ucs1 - (int) __le16_to_cpu(*ucs2);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rintk(",
          "args": [
            "ERN_DEBUG \"ISO 9660 Extensions: \"\n\t\t\t\t\t\t\t\"Microsoft Joliet Level %d\\n\",",
            "oliet_level)"
          ],
          "line": 654
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sonum_711(",
          "args": [
            "dp->type)"
          ],
          "line": 634
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sonum_711(",
          "args": [
            "dp->type)"
          ],
          "line": 632
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "b_bread(",
          "args": [
            ",",
            "lock)"
          ],
          "line": 620
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sofs_get_last_session(",
          "args": [
            ",",
            "pt.session)"
          ],
          "line": 612
        },
        "resolved": true,
        "details": {
          "function_name": "sofs_get_last_session(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/isofs/inode.c",
          "lines": "495-535",
          "snippet": "tatic unsigned int isofs_get_last_session(struct super_block *sb, s32 session)\n{\n\tstruct cdrom_multisession ms_info;\n\tunsigned int vol_desc_start;\n\tstruct block_device *bdev = sb->s_bdev;\n\tint i;\n\n\tvol_desc_start=0;\n\tms_info.addr_format=CDROM_LBA;\n\tif(session >= 0 && session <= 99) {\n\t\tstruct cdrom_tocentry Te;\n\t\tTe.cdte_track=session;\n\t\tTe.cdte_format=CDROM_LBA;\n\t\ti = ioctl_by_bdev(bdev, CDROMREADTOCENTRY, (unsigned long) &Te);\n\t\tif (!i) {\n\t\t\tprintk(KERN_DEBUG \"ISOFS: Session %d start %d type %d\\n\",\n\t\t\t\tsession, Te.cdte_addr.lba,\n\t\t\t\tTe.cdte_ctrl&CDROM_DATA_TRACK);\n\t\t\tif ((Te.cdte_ctrl&CDROM_DATA_TRACK) == 4)\n\t\t\t\treturn Te.cdte_addr.lba;\n\t\t}\n\n\t\tprintk(KERN_ERR \"ISOFS: Invalid session number or type of track\\n\");\n\t}\n\ti = ioctl_by_bdev(bdev, CDROMMULTISESSION, (unsigned long) &ms_info);\n\tif (session > 0)\n\t\tprintk(KERN_ERR \"ISOFS: Invalid session number\\n\");\n#if 0\n\tprintk(KERN_DEBUG \"isofs.inode: CDROMMULTISESSION: rc=%d\\n\",i);\n\tif (i==0) {\n\t\tprintk(KERN_DEBUG \"isofs.inode: XA disk: %s\\n\",ms_info.xa_flag?\"yes\":\"no\");\n\t\tprintk(KERN_DEBUG \"isofs.inode: vol_desc_start = %d\\n\", ms_info.addr.lba);\n\t}\n#endif\n\tif (i==0)\n#if WE_OBEY_THE_WRITTEN_STANDARDS\n\t\tif (ms_info.xa_flag) /* necessary for a valid ms_info.addr */\n#endif\n\t\t\tvol_desc_start=ms_info.addr.lba;\n\treturn vol_desc_start;\n}",
          "includes": [
            "include \"zisofs.h\"",
            "include \"isofs.h\"\n#",
            "include <linux/user_namespace.h>",
            "include <linux/mpage.h>\n#",
            "include <linux/parser.h>\n#",
            "include <linux/cdrom.h>\n#",
            "include <linux/statfs.h>\n#",
            "include <linux/ctype.h>\n#",
            "include <linux/nls.h>\n#",
            "include <linux/slab.h>\n#",
            "include <linux/module.h>",
            "include <linux/init.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"zisofs.h\"\ninclude \"isofs.h\"\n#\ninclude <linux/user_namespace.h>\ninclude <linux/mpage.h>\n#\ninclude <linux/parser.h>\n#\ninclude <linux/cdrom.h>\n#\ninclude <linux/statfs.h>\n#\ninclude <linux/ctype.h>\n#\ninclude <linux/nls.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/module.h>\ninclude <linux/init.h>\n#\n\ntatic unsigned int isofs_get_last_session(struct super_block *sb, s32 session)\n{\n\tstruct cdrom_multisession ms_info;\n\tunsigned int vol_desc_start;\n\tstruct block_device *bdev = sb->s_bdev;\n\tint i;\n\n\tvol_desc_start=0;\n\tms_info.addr_format=CDROM_LBA;\n\tif(session >= 0 && session <= 99) {\n\t\tstruct cdrom_tocentry Te;\n\t\tTe.cdte_track=session;\n\t\tTe.cdte_format=CDROM_LBA;\n\t\ti = ioctl_by_bdev(bdev, CDROMREADTOCENTRY, (unsigned long) &Te);\n\t\tif (!i) {\n\t\t\tprintk(KERN_DEBUG \"ISOFS: Session %d start %d type %d\\n\",\n\t\t\t\tsession, Te.cdte_addr.lba,\n\t\t\t\tTe.cdte_ctrl&CDROM_DATA_TRACK);\n\t\t\tif ((Te.cdte_ctrl&CDROM_DATA_TRACK) == 4)\n\t\t\t\treturn Te.cdte_addr.lba;\n\t\t}\n\n\t\tprintk(KERN_ERR \"ISOFS: Invalid session number or type of track\\n\");\n\t}\n\ti = ioctl_by_bdev(bdev, CDROMMULTISESSION, (unsigned long) &ms_info);\n\tif (session > 0)\n\t\tprintk(KERN_ERR \"ISOFS: Invalid session number\\n\");\n#if 0\n\tprintk(KERN_DEBUG \"isofs.inode: CDROMMULTISESSION: rc=%d\\n\",i);\n\tif (i==0) {\n\t\tprintk(KERN_DEBUG \"isofs.inode: XA disk: %s\\n\",ms_info.xa_flag?\"yes\":\"no\");\n\t\tprintk(KERN_DEBUG \"isofs.inode: vol_desc_start = %d\\n\", ms_info.addr.lba);\n\t}\n#endif\n\tif (i==0)\n#if WE_OBEY_THE_WRITTEN_STANDARDS\n\t\tif (ms_info.xa_flag) /* necessary for a valid ms_info.addr */\n#endif\n\t\t\tvol_desc_start=ms_info.addr.lba;\n\treturn vol_desc_start;\n}"
        }
      },
      {
        "call_info": {
          "callee": "b_min_blocksize(",
          "args": [
            ",",
            "pt.blocksize)"
          ],
          "line": 607
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arse_options(",
          "args": [
            "char *)data,",
            "opt)"
          ],
          "line": 595
        },
        "resolved": true,
        "details": {
          "function_name": "arse_options(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/isofs/inode.c",
          "lines": "339-475",
          "snippet": "tatic int parse_options(char *options, struct iso9660_options *popt)\n{\n\tchar *p;\n\tint option;\n\n\tpopt->map = 'n';\n\tpopt->rock = 1;\n\tpopt->joliet = 1;\n\tpopt->cruft = 0;\n\tpopt->hide = 0;\n\tpopt->showassoc = 0;\n\tpopt->check = 'u';\t\t/* unset */\n\tpopt->nocompress = 0;\n\tpopt->blocksize = 1024;\n\tpopt->fmode = popt->dmode = ISOFS_INVALID_MODE;\n\tpopt->uid_set = 0;\n\tpopt->gid_set = 0;\n\tpopt->gid = GLOBAL_ROOT_GID;\n\tpopt->uid = GLOBAL_ROOT_UID;\n\tpopt->iocharset = NULL;\n\tpopt->utf8 = 0;\n\tpopt->overriderockperm = 0;\n\tpopt->session=-1;\n\tpopt->sbsector=-1;\n\tif (!options)\n\t\treturn 1;\n\n\twhile ((p = strsep(&options, \",\")) != NULL) {\n\t\tint token;\n\t\tsubstring_t args[MAX_OPT_ARGS];\n\t\tunsigned n;\n\n\t\tif (!*p)\n\t\t\tcontinue;\n\n\t\ttoken = match_token(p, tokens, args);\n\t\tswitch (token) {\n\t\tcase Opt_norock:\n\t\t\tpopt->rock = 0;\n\t\t\tbreak;\n\t\tcase Opt_nojoliet:\n\t\t\tpopt->joliet = 0;\n\t\t\tbreak;\n\t\tcase Opt_hide:\n\t\t\tpopt->hide = 1;\n\t\t\tbreak;\n\t\tcase Opt_unhide:\n\t\tcase Opt_showassoc:\n\t\t\tpopt->showassoc = 1;\n\t\t\tbreak;\n\t\tcase Opt_cruft:\n\t\t\tpopt->cruft = 1;\n\t\t\tbreak;\n\t\tcase Opt_utf8:\n\t\t\tpopt->utf8 = 1;\n\t\t\tbreak;\n#ifdef CONFIG_JOLIET\n\t\tcase Opt_iocharset:\n\t\t\tpopt->iocharset = match_strdup(&args[0]);\n\t\t\tbreak;\n#endif\n\t\tcase Opt_map_a:\n\t\t\tpopt->map = 'a';\n\t\t\tbreak;\n\t\tcase Opt_map_o:\n\t\t\tpopt->map = 'o';\n\t\t\tbreak;\n\t\tcase Opt_map_n:\n\t\t\tpopt->map = 'n';\n\t\t\tbreak;\n\t\tcase Opt_session:\n\t\t\tif (match_int(&args[0], &option))\n\t\t\t\treturn 0;\n\t\t\tn = option;\n\t\t\tif (n > 99)\n\t\t\t\treturn 0;\n\t\t\tpopt->session = n + 1;\n\t\t\tbreak;\n\t\tcase Opt_sb:\n\t\t\tif (match_int(&args[0], &option))\n\t\t\t\treturn 0;\n\t\t\tpopt->sbsector = option;\n\t\t\tbreak;\n\t\tcase Opt_check_r:\n\t\t\tpopt->check = 'r';\n\t\t\tbreak;\n\t\tcase Opt_check_s:\n\t\t\tpopt->check = 's';\n\t\t\tbreak;\n\t\tcase Opt_ignore:\n\t\t\tbreak;\n\t\tcase Opt_uid:\n\t\t\tif (match_int(&args[0], &option))\n\t\t\t\treturn 0;\n\t\t\tpopt->uid = make_kuid(current_user_ns(), option);\n\t\t\tif (!uid_valid(popt->uid))\n\t\t\t\treturn 0;\n\t\t\tpopt->uid_set = 1;\n\t\t\tbreak;\n\t\tcase Opt_gid:\n\t\t\tif (match_int(&args[0], &option))\n\t\t\t\treturn 0;\n\t\t\tpopt->gid = make_kgid(current_user_ns(), option);\n\t\t\tif (!gid_valid(popt->gid))\n\t\t\t\treturn 0;\n\t\t\tpopt->gid_set = 1;\n\t\t\tbreak;\n\t\tcase Opt_mode:\n\t\t\tif (match_int(&args[0], &option))\n\t\t\t\treturn 0;\n\t\t\tpopt->fmode = option;\n\t\t\tbreak;\n\t\tcase Opt_dmode:\n\t\t\tif (match_int(&args[0], &option))\n\t\t\t\treturn 0;\n\t\t\tpopt->dmode = option;\n\t\t\tbreak;\n\t\tcase Opt_overriderockperm:\n\t\t\tpopt->overriderockperm = 1;\n\t\t\tbreak;\n\t\tcase Opt_block:\n\t\t\tif (match_int(&args[0], &option))\n\t\t\t\treturn 0;\n\t\t\tn = option;\n\t\t\tif (n != 512 && n != 1024 && n != 2048)\n\t\t\t\treturn 0;\n\t\t\tpopt->blocksize = n;\n\t\t\tbreak;\n\t\tcase Opt_nocompress:\n\t\t\tpopt->nocompress = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}",
          "includes": [
            "include \"zisofs.h\"",
            "include \"isofs.h\"\n#",
            "include <linux/user_namespace.h>",
            "include <linux/mpage.h>\n#",
            "include <linux/parser.h>\n#",
            "include <linux/cdrom.h>\n#",
            "include <linux/statfs.h>\n#",
            "include <linux/ctype.h>\n#",
            "include <linux/nls.h>\n#",
            "include <linux/slab.h>\n#",
            "include <linux/module.h>",
            "include <linux/init.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [
            "tatic const match_table_t tokens = {\n\t{Opt_norock, \"norock\"},\n\t{Opt_nojoliet, \"nojoliet\"},\n\t{Opt_unhide, \"unhide\"},\n\t{Opt_hide, \"hide\"},\n\t{Opt_showassoc, \"showassoc\"},\n\t{Opt_cruft, \"cruft\"},\n\t{Opt_utf8, \"utf8\"},\n\t{Opt_iocharset, \"iocharset=%s\"},\n\t{Opt_map_a, \"map=acorn\"},\n\t{Opt_map_a, \"map=a\"},\n\t{Opt_map_n, \"map=normal\"},\n\t{Opt_map_n, \"map=n\"},\n\t{Opt_map_o, \"map=off\"},\n\t{Opt_map_o, \"map=o\"},\n\t{Opt_session, \"session=%u\"},\n\t{Opt_sb, \"sbsector=%u\"},\n\t{Opt_check_r, \"check=relaxed\"},\n\t{Opt_check_r, \"check=r\"},\n\t{Opt_check_s, \"check=strict\"},\n\t{Opt_check_s, \"check=s\"},\n\t{Opt_uid, \"uid=%u\"},\n\t{Opt_gid, \"gid=%u\"},\n\t{Opt_mode, \"mode=%u\"},\n\t{Opt_dmode, \"dmode=%u\"},\n\t{Opt_overriderockperm, \"overriderockperm\"},\n\t{Opt_block, \"block=%u\"},\n\t{Opt_ignore, \"conv=binary\"},\n\t{Opt_ignore, \"conv=b\"},\n\t{Opt_ignore, \"conv=text\"},\n\t{Opt_ignore, \"conv=t\"},\n\t{Opt_ignore, \"conv=mtext\"},\n\t{Opt_ignore, \"conv=m\"},\n\t{Opt_ignore, \"conv=auto\"},\n\t{Opt_ignore, \"conv=a\"},\n\t{Opt_nocompress, \"nocompress\"},\n\t{Opt_err, NULL}\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "include \"zisofs.h\"\ninclude \"isofs.h\"\n#\ninclude <linux/user_namespace.h>\ninclude <linux/mpage.h>\n#\ninclude <linux/parser.h>\n#\ninclude <linux/cdrom.h>\n#\ninclude <linux/statfs.h>\n#\ninclude <linux/ctype.h>\n#\ninclude <linux/nls.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/module.h>\ninclude <linux/init.h>\n#\n\ntatic const match_table_t tokens = {\n\t{Opt_norock, \"norock\"},\n\t{Opt_nojoliet, \"nojoliet\"},\n\t{Opt_unhide, \"unhide\"},\n\t{Opt_hide, \"hide\"},\n\t{Opt_showassoc, \"showassoc\"},\n\t{Opt_cruft, \"cruft\"},\n\t{Opt_utf8, \"utf8\"},\n\t{Opt_iocharset, \"iocharset=%s\"},\n\t{Opt_map_a, \"map=acorn\"},\n\t{Opt_map_a, \"map=a\"},\n\t{Opt_map_n, \"map=normal\"},\n\t{Opt_map_n, \"map=n\"},\n\t{Opt_map_o, \"map=off\"},\n\t{Opt_map_o, \"map=o\"},\n\t{Opt_session, \"session=%u\"},\n\t{Opt_sb, \"sbsector=%u\"},\n\t{Opt_check_r, \"check=relaxed\"},\n\t{Opt_check_r, \"check=r\"},\n\t{Opt_check_s, \"check=strict\"},\n\t{Opt_check_s, \"check=s\"},\n\t{Opt_uid, \"uid=%u\"},\n\t{Opt_gid, \"gid=%u\"},\n\t{Opt_mode, \"mode=%u\"},\n\t{Opt_dmode, \"dmode=%u\"},\n\t{Opt_overriderockperm, \"overriderockperm\"},\n\t{Opt_block, \"block=%u\"},\n\t{Opt_ignore, \"conv=binary\"},\n\t{Opt_ignore, \"conv=b\"},\n\t{Opt_ignore, \"conv=text\"},\n\t{Opt_ignore, \"conv=t\"},\n\t{Opt_ignore, \"conv=mtext\"},\n\t{Opt_ignore, \"conv=m\"},\n\t{Opt_ignore, \"conv=auto\"},\n\t{Opt_ignore, \"conv=a\"},\n\t{Opt_nocompress, \"nocompress\"},\n\t{Opt_err, NULL}\n};\n\ntatic int parse_options(char *options, struct iso9660_options *popt)\n{\n\tchar *p;\n\tint option;\n\n\tpopt->map = 'n';\n\tpopt->rock = 1;\n\tpopt->joliet = 1;\n\tpopt->cruft = 0;\n\tpopt->hide = 0;\n\tpopt->showassoc = 0;\n\tpopt->check = 'u';\t\t/* unset */\n\tpopt->nocompress = 0;\n\tpopt->blocksize = 1024;\n\tpopt->fmode = popt->dmode = ISOFS_INVALID_MODE;\n\tpopt->uid_set = 0;\n\tpopt->gid_set = 0;\n\tpopt->gid = GLOBAL_ROOT_GID;\n\tpopt->uid = GLOBAL_ROOT_UID;\n\tpopt->iocharset = NULL;\n\tpopt->utf8 = 0;\n\tpopt->overriderockperm = 0;\n\tpopt->session=-1;\n\tpopt->sbsector=-1;\n\tif (!options)\n\t\treturn 1;\n\n\twhile ((p = strsep(&options, \",\")) != NULL) {\n\t\tint token;\n\t\tsubstring_t args[MAX_OPT_ARGS];\n\t\tunsigned n;\n\n\t\tif (!*p)\n\t\t\tcontinue;\n\n\t\ttoken = match_token(p, tokens, args);\n\t\tswitch (token) {\n\t\tcase Opt_norock:\n\t\t\tpopt->rock = 0;\n\t\t\tbreak;\n\t\tcase Opt_nojoliet:\n\t\t\tpopt->joliet = 0;\n\t\t\tbreak;\n\t\tcase Opt_hide:\n\t\t\tpopt->hide = 1;\n\t\t\tbreak;\n\t\tcase Opt_unhide:\n\t\tcase Opt_showassoc:\n\t\t\tpopt->showassoc = 1;\n\t\t\tbreak;\n\t\tcase Opt_cruft:\n\t\t\tpopt->cruft = 1;\n\t\t\tbreak;\n\t\tcase Opt_utf8:\n\t\t\tpopt->utf8 = 1;\n\t\t\tbreak;\n#ifdef CONFIG_JOLIET\n\t\tcase Opt_iocharset:\n\t\t\tpopt->iocharset = match_strdup(&args[0]);\n\t\t\tbreak;\n#endif\n\t\tcase Opt_map_a:\n\t\t\tpopt->map = 'a';\n\t\t\tbreak;\n\t\tcase Opt_map_o:\n\t\t\tpopt->map = 'o';\n\t\t\tbreak;\n\t\tcase Opt_map_n:\n\t\t\tpopt->map = 'n';\n\t\t\tbreak;\n\t\tcase Opt_session:\n\t\t\tif (match_int(&args[0], &option))\n\t\t\t\treturn 0;\n\t\t\tn = option;\n\t\t\tif (n > 99)\n\t\t\t\treturn 0;\n\t\t\tpopt->session = n + 1;\n\t\t\tbreak;\n\t\tcase Opt_sb:\n\t\t\tif (match_int(&args[0], &option))\n\t\t\t\treturn 0;\n\t\t\tpopt->sbsector = option;\n\t\t\tbreak;\n\t\tcase Opt_check_r:\n\t\t\tpopt->check = 'r';\n\t\t\tbreak;\n\t\tcase Opt_check_s:\n\t\t\tpopt->check = 's';\n\t\t\tbreak;\n\t\tcase Opt_ignore:\n\t\t\tbreak;\n\t\tcase Opt_uid:\n\t\t\tif (match_int(&args[0], &option))\n\t\t\t\treturn 0;\n\t\t\tpopt->uid = make_kuid(current_user_ns(), option);\n\t\t\tif (!uid_valid(popt->uid))\n\t\t\t\treturn 0;\n\t\t\tpopt->uid_set = 1;\n\t\t\tbreak;\n\t\tcase Opt_gid:\n\t\t\tif (match_int(&args[0], &option))\n\t\t\t\treturn 0;\n\t\t\tpopt->gid = make_kgid(current_user_ns(), option);\n\t\t\tif (!gid_valid(popt->gid))\n\t\t\t\treturn 0;\n\t\t\tpopt->gid_set = 1;\n\t\t\tbreak;\n\t\tcase Opt_mode:\n\t\t\tif (match_int(&args[0], &option))\n\t\t\t\treturn 0;\n\t\t\tpopt->fmode = option;\n\t\t\tbreak;\n\t\tcase Opt_dmode:\n\t\t\tif (match_int(&args[0], &option))\n\t\t\t\treturn 0;\n\t\t\tpopt->dmode = option;\n\t\t\tbreak;\n\t\tcase Opt_overriderockperm:\n\t\t\tpopt->overriderockperm = 1;\n\t\t\tbreak;\n\t\tcase Opt_block:\n\t\t\tif (match_int(&args[0], &option))\n\t\t\t\treturn 0;\n\t\t\tn = option;\n\t\t\tif (n != 512 && n != 1024 && n != 2048)\n\t\t\t\treturn 0;\n\t\t\tpopt->blocksize = n;\n\t\t\tbreak;\n\t\tcase Opt_nocompress:\n\t\t\tpopt->nocompress = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "zalloc(",
          "args": [
            "izeof(*sbi),",
            "FP_KERNEL)"
          ],
          "line": 590
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ave_mount_options(",
          "args": [
            ",",
            "ata)"
          ],
          "line": 588
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"zisofs.h\"\ninclude \"isofs.h\"\n#\ninclude <linux/user_namespace.h>\ninclude <linux/mpage.h>\n#\ninclude <linux/parser.h>\n#\ninclude <linux/cdrom.h>\n#\ninclude <linux/statfs.h>\n#\ninclude <linux/ctype.h>\n#\ninclude <linux/nls.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/module.h>\ninclude <linux/init.h>\n#\n\ntatic const struct super_operations isofs_sops = {\n\t.alloc_inode\t= isofs_alloc_inode,\n\t.destroy_inode\t= isofs_destroy_inode,\n\t.put_super\t= isofs_put_super,\n\t.statfs\t\t= isofs_statfs,\n\t.remount_fs\t= isofs_remount,\n\t.show_options\t= generic_show_options,\n};\ntatic const struct dentry_operations isofs_dentry_ops[] = {\n\t{\n\t\t.d_hash\t\t= isofs_hashi,\n\t\t.d_compare\t= isofs_dentry_cmpi,\n\t},\n#ifdef CONFIG_JOLIET\n\t{\n\t\t.d_hash\t\t= isofs_hash_ms,\n\t\t.d_compare\t= isofs_dentry_cmp_ms,\n\t},\n\t{\n\t\t.d_hash\t\t= isofs_hashi_ms,\n\t\t.d_compare\t= isofs_dentry_cmpi_ms,\n\t},\n#endif\n};\n\ntatic int isofs_fill_super(struct super_block *s, void *data, int silent)\n{\n\tstruct buffer_head *bh = NULL, *pri_bh = NULL;\n\tstruct hs_primary_descriptor *h_pri = NULL;\n\tstruct iso_primary_descriptor *pri = NULL;\n\tstruct iso_supplementary_descriptor *sec = NULL;\n\tstruct iso_directory_record *rootp;\n\tstruct inode *inode;\n\tstruct iso9660_options opt;\n\tstruct isofs_sb_info *sbi;\n\tunsigned long first_data_zone;\n\tint joliet_level = 0;\n\tint iso_blknum, block;\n\tint orig_zonesize;\n\tint table, error = -EINVAL;\n\tunsigned int vol_desc_start;\n\n\tsave_mount_options(s, data);\n\n\tsbi = kzalloc(sizeof(*sbi), GFP_KERNEL);\n\tif (!sbi)\n\t\treturn -ENOMEM;\n\ts->s_fs_info = sbi;\n\n\tif (!parse_options((char *)data, &opt))\n\t\tgoto out_freesbi;\n\n\t/*\n\t * First of all, get the hardware blocksize for this device.\n\t * If we don't know what it is, or the hardware blocksize is\n\t * larger than the blocksize the user specified, then use\n\t * that value.\n\t */\n\t/*\n\t * What if bugger tells us to go beyond page size?\n\t */\n\topt.blocksize = sb_min_blocksize(s, opt.blocksize);\n\n\tsbi->s_high_sierra = 0; /* default is iso9660 */\n\n\tvol_desc_start = (opt.sbsector != -1) ?\n\t\topt.sbsector : isofs_get_last_session(s,opt.session);\n\n\tfor (iso_blknum = vol_desc_start+16;\n\t\tiso_blknum < vol_desc_start+100; iso_blknum++) {\n\t\tstruct hs_volume_descriptor *hdp;\n\t\tstruct iso_volume_descriptor  *vdp;\n\n\t\tblock = iso_blknum << (ISOFS_BLOCK_BITS - s->s_blocksize_bits);\n\t\tif (!(bh = sb_bread(s, block)))\n\t\t\tgoto out_no_read;\n\n\t\tvdp = (struct iso_volume_descriptor *)bh->b_data;\n\t\thdp = (struct hs_volume_descriptor *)bh->b_data;\n\n\t\t/*\n\t\t * Due to the overlapping physical location of the descriptors,\n\t\t * ISO CDs can match hdp->id==HS_STANDARD_ID as well. To ensure\n\t\t * proper identification in this case, we first check for ISO.\n\t\t */\n\t\tif (strncmp (vdp->id, ISO_STANDARD_ID, sizeof vdp->id) == 0) {\n\t\t\tif (isonum_711(vdp->type) == ISO_VD_END)\n\t\t\t\tbreak;\n\t\t\tif (isonum_711(vdp->type) == ISO_VD_PRIMARY) {\n\t\t\t\tif (pri == NULL) {\n\t\t\t\t\tpri = (struct iso_primary_descriptor *)vdp;\n\t\t\t\t\t/* Save the buffer in case we need it ... */\n\t\t\t\t\tpri_bh = bh;\n\t\t\t\t\tbh = NULL;\n\t\t\t\t}\n\t\t\t}\n#ifdef CONFIG_JOLIET\n\t\t\telse if (isonum_711(vdp->type) == ISO_VD_SUPPLEMENTARY) {\n\t\t\t\tsec = (struct iso_supplementary_descriptor *)vdp;\n\t\t\t\tif (sec->escape[0] == 0x25 && sec->escape[1] == 0x2f) {\n\t\t\t\t\tif (opt.joliet) {\n\t\t\t\t\t\tif (sec->escape[2] == 0x40)\n\t\t\t\t\t\t\tjoliet_level = 1;\n\t\t\t\t\t\telse if (sec->escape[2] == 0x43)\n\t\t\t\t\t\t\tjoliet_level = 2;\n\t\t\t\t\t\telse if (sec->escape[2] == 0x45)\n\t\t\t\t\t\t\tjoliet_level = 3;\n\n\t\t\t\t\t\tprintk(KERN_DEBUG \"ISO 9660 Extensions: \"\n\t\t\t\t\t\t\t\"Microsoft Joliet Level %d\\n\",\n\t\t\t\t\t\t\tjoliet_level);\n\t\t\t\t\t}\n\t\t\t\t\tgoto root_found;\n\t\t\t\t} else {\n\t\t\t\t/* Unknown supplementary volume descriptor */\n\t\t\t\tsec = NULL;\n\t\t\t\t}\n\t\t\t}\n#endif\n\t\t} else {\n\t\t\tif (strncmp (hdp->id, HS_STANDARD_ID, sizeof hdp->id) == 0) {\n\t\t\t\tif (isonum_711(hdp->type) != ISO_VD_PRIMARY)\n\t\t\t\t\tgoto out_freebh;\n\n\t\t\t\tsbi->s_high_sierra = 1;\n\t\t\t\topt.rock = 0;\n\t\t\t\th_pri = (struct hs_primary_descriptor *)vdp;\n\t\t\t\tgoto root_found;\n\t\t\t}\n\t\t}\n\n\t\t/* Just skip any volume descriptors we don't recognize */\n\n\t\tbrelse(bh);\n\t\tbh = NULL;\n\t}\n\t/*\n\t * If we fall through, either no volume descriptor was found,\n\t * or else we passed a primary descriptor looking for others.\n\t */\n\tif (!pri)\n\t\tgoto out_unknown_format;\n\tbrelse(bh);\n\tbh = pri_bh;\n\tpri_bh = NULL;\n\nroot_found:\n\n\tif (joliet_level && (pri == NULL || !opt.rock)) {\n\t\t/* This is the case of Joliet with the norock mount flag.\n\t\t * A disc with both Joliet and Rock Ridge is handled later\n\t\t */\n\t\tpri = (struct iso_primary_descriptor *) sec;\n\t}\n\n\tif(sbi->s_high_sierra){\n\t\trootp = (struct iso_directory_record *) h_pri->root_directory_record;\n\t\tsbi->s_nzones = isonum_733(h_pri->volume_space_size);\n\t\tsbi->s_log_zone_size = isonum_723(h_pri->logical_block_size);\n\t\tsbi->s_max_size = isonum_733(h_pri->volume_space_size);\n\t} else {\n\t\tif (!pri)\n\t\t\tgoto out_freebh;\n\t\trootp = (struct iso_directory_record *) pri->root_directory_record;\n\t\tsbi->s_nzones = isonum_733(pri->volume_space_size);\n\t\tsbi->s_log_zone_size = isonum_723(pri->logical_block_size);\n\t\tsbi->s_max_size = isonum_733(pri->volume_space_size);\n\t}\n\n\tsbi->s_ninodes = 0; /* No way to figure this out easily */\n\n\torig_zonesize = sbi->s_log_zone_size;\n\t/*\n\t * If the zone size is smaller than the hardware sector size,\n\t * this is a fatal error.  This would occur if the disc drive\n\t * had sectors that were 2048 bytes, but the filesystem had\n\t * blocks that were 512 bytes (which should only very rarely\n\t * happen.)\n\t */\n\tif (orig_zonesize < opt.blocksize)\n\t\tgoto out_bad_size;\n\n\t/* RDE: convert log zone size to bit shift */\n\tswitch (sbi->s_log_zone_size) {\n\tcase  512: sbi->s_log_zone_size =  9; break;\n\tcase 1024: sbi->s_log_zone_size = 10; break;\n\tcase 2048: sbi->s_log_zone_size = 11; break;\n\n\tdefault:\n\t\tgoto out_bad_zone_size;\n\t}\n\n\ts->s_magic = ISOFS_SUPER_MAGIC;\n\n\t/*\n\t * With multi-extent files, file size is only limited by the maximum\n\t * size of a file system, which is 8 TB.\n\t */\n\ts->s_maxbytes = 0x80000000000LL;\n\n\t/* Set this for reference. Its not currently used except on write\n\t   which we don't have .. */\n\n\tfirst_data_zone = isonum_733(rootp->extent) +\n\t\t\t  isonum_711(rootp->ext_attr_length);\n\tsbi->s_firstdatazone = first_data_zone;\n#ifndef BEQUIET\n\tprintk(KERN_DEBUG \"ISOFS: Max size:%ld   Log zone size:%ld\\n\",\n\t\tsbi->s_max_size, 1UL << sbi->s_log_zone_size);\n\tprintk(KERN_DEBUG \"ISOFS: First datazone:%ld\\n\", sbi->s_firstdatazone);\n\tif(sbi->s_high_sierra)\n\t\tprintk(KERN_DEBUG \"ISOFS: Disc in High Sierra format.\\n\");\n#endif\n\n\t/*\n\t * If the Joliet level is set, we _may_ decide to use the\n\t * secondary descriptor, but can't be sure until after we\n\t * read the root inode. But before reading the root inode\n\t * we may need to change the device blocksize, and would\n\t * rather release the old buffer first. So, we cache the\n\t * first_data_zone value from the secondary descriptor.\n\t */\n\tif (joliet_level) {\n\t\tpri = (struct iso_primary_descriptor *) sec;\n\t\trootp = (struct iso_directory_record *)\n\t\t\tpri->root_directory_record;\n\t\tfirst_data_zone = isonum_733(rootp->extent) +\n\t\t\t\tisonum_711(rootp->ext_attr_length);\n\t}\n\n\t/*\n\t * We're all done using the volume descriptor, and may need\n\t * to change the device blocksize, so release the buffer now.\n\t */\n\tbrelse(pri_bh);\n\tbrelse(bh);\n\n\t/*\n\t * Force the blocksize to 512 for 512 byte sectors.  The file\n\t * read primitives really get it wrong in a bad way if we don't\n\t * do this.\n\t *\n\t * Note - we should never be setting the blocksize to something\n\t * less than the hardware sector size for the device.  If we\n\t * do, we would end up having to read larger buffers and split\n\t * out portions to satisfy requests.\n\t *\n\t * Note2- the idea here is that we want to deal with the optimal\n\t * zonesize in the filesystem.  If we have it set to something less,\n\t * then we have horrible problems with trying to piece together\n\t * bits of adjacent blocks in order to properly read directory\n\t * entries.  By forcing the blocksize in this way, we ensure\n\t * that we will never be required to do this.\n\t */\n\tsb_set_blocksize(s, orig_zonesize);\n\n\tsbi->s_nls_iocharset = NULL;\n\n#ifdef CONFIG_JOLIET\n\tif (joliet_level && opt.utf8 == 0) {\n\t\tchar *p = opt.iocharset ? opt.iocharset : CONFIG_NLS_DEFAULT;\n\t\tsbi->s_nls_iocharset = load_nls(p);\n\t\tif (! sbi->s_nls_iocharset) {\n\t\t\t/* Fail only if explicit charset specified */\n\t\t\tif (opt.iocharset)\n\t\t\t\tgoto out_freesbi;\n\t\t\tsbi->s_nls_iocharset = load_nls_default();\n\t\t}\n\t}\n#endif\n\ts->s_op = &isofs_sops;\n\ts->s_export_op = &isofs_export_ops;\n\tsbi->s_mapping = opt.map;\n\tsbi->s_rock = (opt.rock ? 2 : 0);\n\tsbi->s_rock_offset = -1; /* initial offset, will guess until SP is found*/\n\tsbi->s_cruft = opt.cruft;\n\tsbi->s_hide = opt.hide;\n\tsbi->s_showassoc = opt.showassoc;\n\tsbi->s_uid = opt.uid;\n\tsbi->s_gid = opt.gid;\n\tsbi->s_uid_set = opt.uid_set;\n\tsbi->s_gid_set = opt.gid_set;\n\tsbi->s_utf8 = opt.utf8;\n\tsbi->s_nocompress = opt.nocompress;\n\tsbi->s_overriderockperm = opt.overriderockperm;\n\t/*\n\t * It would be incredibly stupid to allow people to mark every file\n\t * on the disk as suid, so we merely allow them to set the default\n\t * permissions.\n\t */\n\tif (opt.fmode != ISOFS_INVALID_MODE)\n\t\tsbi->s_fmode = opt.fmode & 0777;\n\telse\n\t\tsbi->s_fmode = ISOFS_INVALID_MODE;\n\tif (opt.dmode != ISOFS_INVALID_MODE)\n\t\tsbi->s_dmode = opt.dmode & 0777;\n\telse\n\t\tsbi->s_dmode = ISOFS_INVALID_MODE;\n\n\t/*\n\t * Read the root inode, which _may_ result in changing\n\t * the s_rock flag. Once we have the final s_rock value,\n\t * we then decide whether to use the Joliet descriptor.\n\t */\n\tinode = isofs_iget(s, sbi->s_firstdatazone, 0);\n\tif (IS_ERR(inode))\n\t\tgoto out_no_root;\n\n\t/*\n\t * Fix for broken CDs with Rock Ridge and empty ISO root directory but\n\t * correct Joliet root directory.\n\t */\n\tif (sbi->s_rock == 1 && joliet_level &&\n\t\t\t\trootdir_empty(s, sbi->s_firstdatazone)) {\n\t\tprintk(KERN_NOTICE\n\t\t\t\"ISOFS: primary root directory is empty. \"\n\t\t\t\"Disabling Rock Ridge and switching to Joliet.\");\n\t\tsbi->s_rock = 0;\n\t}\n\n\t/*\n\t * If this disk has both Rock Ridge and Joliet on it, then we\n\t * want to use Rock Ridge by default.  This can be overridden\n\t * by using the norock mount option.  There is still one other\n\t * possibility that is not taken into account: a Rock Ridge\n\t * CD with Unicode names.  Until someone sees such a beast, it\n\t * will not be supported.\n\t */\n\tif (sbi->s_rock == 1) {\n\t\tjoliet_level = 0;\n\t} else if (joliet_level) {\n\t\tsbi->s_rock = 0;\n\t\tif (sbi->s_firstdatazone != first_data_zone) {\n\t\t\tsbi->s_firstdatazone = first_data_zone;\n\t\t\tprintk(KERN_DEBUG\n\t\t\t\t\"ISOFS: changing to secondary root\\n\");\n\t\t\tiput(inode);\n\t\t\tinode = isofs_iget(s, sbi->s_firstdatazone, 0);\n\t\t\tif (IS_ERR(inode))\n\t\t\t\tgoto out_no_root;\n\t\t}\n\t}\n\n\tif (opt.check == 'u') {\n\t\t/* Only Joliet is case insensitive by default */\n\t\tif (joliet_level)\n\t\t\topt.check = 'r';\n\t\telse\n\t\t\topt.check = 's';\n\t}\n\tsbi->s_joliet_level = joliet_level;\n\n\t/* Make sure the root inode is a directory */\n\tif (!S_ISDIR(inode->i_mode)) {\n\t\tprintk(KERN_WARNING\n\t\t\t\"isofs_fill_super: root inode is not a directory. \"\n\t\t\t\"Corrupted media?\\n\");\n\t\tgoto out_iput;\n\t}\n\n\ttable = 0;\n\tif (joliet_level)\n\t\ttable += 2;\n\tif (opt.check == 'r')\n\t\ttable++;\n\n\tif (table)\n\t\ts->s_d_op = &isofs_dentry_ops[table - 1];\n\n\t/* get the root dentry */\n\ts->s_root = d_make_root(inode);\n\tif (!(s->s_root)) {\n\t\terror = -ENOMEM;\n\t\tgoto out_no_inode;\n\t}\n\n\tkfree(opt.iocharset);\n\n\treturn 0;\n\n\t/*\n\t * Display error messages and free resources.\n\t */\nout_iput:\n\tiput(inode);\n\tgoto out_no_inode;\nout_no_root:\n\terror = PTR_ERR(inode);\n\tif (error != -ENOMEM)\n\t\tprintk(KERN_WARNING \"%s: get root inode failed\\n\", __func__);\nout_no_inode:\n#ifdef CONFIG_JOLIET\n\tunload_nls(sbi->s_nls_iocharset);\n#endif\n\tgoto out_freesbi;\nout_no_read:\n\tprintk(KERN_WARNING \"%s: bread failed, dev=%s, iso_blknum=%d, block=%d\\n\",\n\t\t__func__, s->s_id, iso_blknum, block);\n\tgoto out_freebh;\nout_bad_zone_size:\n\tprintk(KERN_WARNING \"ISOFS: Bad logical zone size %ld\\n\",\n\t\tsbi->s_log_zone_size);\n\tgoto out_freebh;\nout_bad_size:\n\tprintk(KERN_WARNING \"ISOFS: Logical zone size(%d) < hardware blocksize(%u)\\n\",\n\t\torig_zonesize, opt.blocksize);\n\tgoto out_freebh;\nout_unknown_format:\n\tif (!silent)\n\t\tprintk(KERN_WARNING \"ISOFS: Unable to identify CD-ROM format.\\n\");\n\nout_freebh:\n\tbrelse(bh);\n\tbrelse(pri_bh);\nout_freesbi:\n\tkfree(opt.iocharset);\n\tkfree(sbi);\n\ts->s_fs_info = NULL;\n\treturn error;\n}"
  },
  {
    "function_name": "ootdir_empty(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/isofs/inode.c",
    "lines": "544-563",
    "snippet": "tatic bool rootdir_empty(struct super_block *sb, unsigned long block)\n{\n\tint offset = 0, files = 0, de_len;\n\tstruct iso_directory_record *de;\n\tstruct buffer_head *bh;\n\n\tbh = sb_bread(sb, block);\n\tif (!bh)\n\t\treturn true;\n\twhile (files < 3) {\n\t\tde = (struct iso_directory_record *) (bh->b_data + offset);\n\t\tde_len = *(unsigned char *) de;\n\t\tif (de_len == 0)\n\t\t\tbreak;\n\t\tfiles++;\n\t\toffset += de_len;\n\t}\n\tbrelse(bh);\n\treturn files < 3;\n}",
    "includes": [
      "include \"zisofs.h\"",
      "include \"isofs.h\"\n#",
      "include <linux/user_namespace.h>",
      "include <linux/mpage.h>\n#",
      "include <linux/parser.h>\n#",
      "include <linux/cdrom.h>\n#",
      "include <linux/statfs.h>\n#",
      "include <linux/ctype.h>\n#",
      "include <linux/nls.h>\n#",
      "include <linux/slab.h>\n#",
      "include <linux/module.h>",
      "include <linux/init.h>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "relse(",
          "args": [
            "h)"
          ],
          "line": 561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "b_bread(",
          "args": [
            "b,",
            "lock)"
          ],
          "line": 550
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"zisofs.h\"\ninclude \"isofs.h\"\n#\ninclude <linux/user_namespace.h>\ninclude <linux/mpage.h>\n#\ninclude <linux/parser.h>\n#\ninclude <linux/cdrom.h>\n#\ninclude <linux/statfs.h>\n#\ninclude <linux/ctype.h>\n#\ninclude <linux/nls.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/module.h>\ninclude <linux/init.h>\n#\n\ntatic bool rootdir_empty(struct super_block *sb, unsigned long block)\n{\n\tint offset = 0, files = 0, de_len;\n\tstruct iso_directory_record *de;\n\tstruct buffer_head *bh;\n\n\tbh = sb_bread(sb, block);\n\tif (!bh)\n\t\treturn true;\n\twhile (files < 3) {\n\t\tde = (struct iso_directory_record *) (bh->b_data + offset);\n\t\tde_len = *(unsigned char *) de;\n\t\tif (de_len == 0)\n\t\t\tbreak;\n\t\tfiles++;\n\t\toffset += de_len;\n\t}\n\tbrelse(bh);\n\treturn files < 3;\n}"
  },
  {
    "function_name": "sofs_get_last_session(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/isofs/inode.c",
    "lines": "495-535",
    "snippet": "tatic unsigned int isofs_get_last_session(struct super_block *sb, s32 session)\n{\n\tstruct cdrom_multisession ms_info;\n\tunsigned int vol_desc_start;\n\tstruct block_device *bdev = sb->s_bdev;\n\tint i;\n\n\tvol_desc_start=0;\n\tms_info.addr_format=CDROM_LBA;\n\tif(session >= 0 && session <= 99) {\n\t\tstruct cdrom_tocentry Te;\n\t\tTe.cdte_track=session;\n\t\tTe.cdte_format=CDROM_LBA;\n\t\ti = ioctl_by_bdev(bdev, CDROMREADTOCENTRY, (unsigned long) &Te);\n\t\tif (!i) {\n\t\t\tprintk(KERN_DEBUG \"ISOFS: Session %d start %d type %d\\n\",\n\t\t\t\tsession, Te.cdte_addr.lba,\n\t\t\t\tTe.cdte_ctrl&CDROM_DATA_TRACK);\n\t\t\tif ((Te.cdte_ctrl&CDROM_DATA_TRACK) == 4)\n\t\t\t\treturn Te.cdte_addr.lba;\n\t\t}\n\n\t\tprintk(KERN_ERR \"ISOFS: Invalid session number or type of track\\n\");\n\t}\n\ti = ioctl_by_bdev(bdev, CDROMMULTISESSION, (unsigned long) &ms_info);\n\tif (session > 0)\n\t\tprintk(KERN_ERR \"ISOFS: Invalid session number\\n\");\n#if 0\n\tprintk(KERN_DEBUG \"isofs.inode: CDROMMULTISESSION: rc=%d\\n\",i);\n\tif (i==0) {\n\t\tprintk(KERN_DEBUG \"isofs.inode: XA disk: %s\\n\",ms_info.xa_flag?\"yes\":\"no\");\n\t\tprintk(KERN_DEBUG \"isofs.inode: vol_desc_start = %d\\n\", ms_info.addr.lba);\n\t}\n#endif\n\tif (i==0)\n#if WE_OBEY_THE_WRITTEN_STANDARDS\n\t\tif (ms_info.xa_flag) /* necessary for a valid ms_info.addr */\n#endif\n\t\t\tvol_desc_start=ms_info.addr.lba;\n\treturn vol_desc_start;\n}",
    "includes": [
      "include \"zisofs.h\"",
      "include \"isofs.h\"\n#",
      "include <linux/user_namespace.h>",
      "include <linux/mpage.h>\n#",
      "include <linux/parser.h>\n#",
      "include <linux/cdrom.h>\n#",
      "include <linux/statfs.h>\n#",
      "include <linux/ctype.h>\n#",
      "include <linux/nls.h>\n#",
      "include <linux/slab.h>\n#",
      "include <linux/module.h>",
      "include <linux/init.h>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rintk(",
          "args": [
            "ERN_DEBUG \"isofs.inode: vol_desc_start = %d\\n\",",
            "s_info.addr.lba)"
          ],
          "line": 526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rintk(",
          "args": [
            "ERN_DEBUG \"isofs.inode: XA disk: %s\\n\",",
            "s_info.xa_flag?\"yes\":\"no\")"
          ],
          "line": 525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rintk(",
          "args": [
            "ERN_DEBUG \"isofs.inode: CDROMMULTISESSION: rc=%d\\n\",",
            ")"
          ],
          "line": 523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rintk(",
          "args": [
            "ERN_ERR \"ISOFS: Invalid session number\\n\")"
          ],
          "line": 521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "octl_by_bdev(",
          "args": [
            "dev,",
            "DROMMULTISESSION,",
            "unsigned long) &ms_info)"
          ],
          "line": 519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rintk(",
          "args": [
            "ERN_ERR \"ISOFS: Invalid session number or type of track\\n\")"
          ],
          "line": 517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rintk(",
          "args": [
            "ERN_DEBUG \"ISOFS: Session %d start %d type %d\\n\",",
            "ession,",
            "e.cdte_addr.lba,",
            "e.cdte_ctrl&CDROM_DATA_TRACK)"
          ],
          "line": 510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "octl_by_bdev(",
          "args": [
            "dev,",
            "DROMREADTOCENTRY,",
            "unsigned long) &Te)"
          ],
          "line": 508
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"zisofs.h\"\ninclude \"isofs.h\"\n#\ninclude <linux/user_namespace.h>\ninclude <linux/mpage.h>\n#\ninclude <linux/parser.h>\n#\ninclude <linux/cdrom.h>\n#\ninclude <linux/statfs.h>\n#\ninclude <linux/ctype.h>\n#\ninclude <linux/nls.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/module.h>\ninclude <linux/init.h>\n#\n\ntatic unsigned int isofs_get_last_session(struct super_block *sb, s32 session)\n{\n\tstruct cdrom_multisession ms_info;\n\tunsigned int vol_desc_start;\n\tstruct block_device *bdev = sb->s_bdev;\n\tint i;\n\n\tvol_desc_start=0;\n\tms_info.addr_format=CDROM_LBA;\n\tif(session >= 0 && session <= 99) {\n\t\tstruct cdrom_tocentry Te;\n\t\tTe.cdte_track=session;\n\t\tTe.cdte_format=CDROM_LBA;\n\t\ti = ioctl_by_bdev(bdev, CDROMREADTOCENTRY, (unsigned long) &Te);\n\t\tif (!i) {\n\t\t\tprintk(KERN_DEBUG \"ISOFS: Session %d start %d type %d\\n\",\n\t\t\t\tsession, Te.cdte_addr.lba,\n\t\t\t\tTe.cdte_ctrl&CDROM_DATA_TRACK);\n\t\t\tif ((Te.cdte_ctrl&CDROM_DATA_TRACK) == 4)\n\t\t\t\treturn Te.cdte_addr.lba;\n\t\t}\n\n\t\tprintk(KERN_ERR \"ISOFS: Invalid session number or type of track\\n\");\n\t}\n\ti = ioctl_by_bdev(bdev, CDROMMULTISESSION, (unsigned long) &ms_info);\n\tif (session > 0)\n\t\tprintk(KERN_ERR \"ISOFS: Invalid session number\\n\");\n#if 0\n\tprintk(KERN_DEBUG \"isofs.inode: CDROMMULTISESSION: rc=%d\\n\",i);\n\tif (i==0) {\n\t\tprintk(KERN_DEBUG \"isofs.inode: XA disk: %s\\n\",ms_info.xa_flag?\"yes\":\"no\");\n\t\tprintk(KERN_DEBUG \"isofs.inode: vol_desc_start = %d\\n\", ms_info.addr.lba);\n\t}\n#endif\n\tif (i==0)\n#if WE_OBEY_THE_WRITTEN_STANDARDS\n\t\tif (ms_info.xa_flag) /* necessary for a valid ms_info.addr */\n#endif\n\t\t\tvol_desc_start=ms_info.addr.lba;\n\treturn vol_desc_start;\n}"
  },
  {
    "function_name": "arse_options(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/isofs/inode.c",
    "lines": "339-475",
    "snippet": "tatic int parse_options(char *options, struct iso9660_options *popt)\n{\n\tchar *p;\n\tint option;\n\n\tpopt->map = 'n';\n\tpopt->rock = 1;\n\tpopt->joliet = 1;\n\tpopt->cruft = 0;\n\tpopt->hide = 0;\n\tpopt->showassoc = 0;\n\tpopt->check = 'u';\t\t/* unset */\n\tpopt->nocompress = 0;\n\tpopt->blocksize = 1024;\n\tpopt->fmode = popt->dmode = ISOFS_INVALID_MODE;\n\tpopt->uid_set = 0;\n\tpopt->gid_set = 0;\n\tpopt->gid = GLOBAL_ROOT_GID;\n\tpopt->uid = GLOBAL_ROOT_UID;\n\tpopt->iocharset = NULL;\n\tpopt->utf8 = 0;\n\tpopt->overriderockperm = 0;\n\tpopt->session=-1;\n\tpopt->sbsector=-1;\n\tif (!options)\n\t\treturn 1;\n\n\twhile ((p = strsep(&options, \",\")) != NULL) {\n\t\tint token;\n\t\tsubstring_t args[MAX_OPT_ARGS];\n\t\tunsigned n;\n\n\t\tif (!*p)\n\t\t\tcontinue;\n\n\t\ttoken = match_token(p, tokens, args);\n\t\tswitch (token) {\n\t\tcase Opt_norock:\n\t\t\tpopt->rock = 0;\n\t\t\tbreak;\n\t\tcase Opt_nojoliet:\n\t\t\tpopt->joliet = 0;\n\t\t\tbreak;\n\t\tcase Opt_hide:\n\t\t\tpopt->hide = 1;\n\t\t\tbreak;\n\t\tcase Opt_unhide:\n\t\tcase Opt_showassoc:\n\t\t\tpopt->showassoc = 1;\n\t\t\tbreak;\n\t\tcase Opt_cruft:\n\t\t\tpopt->cruft = 1;\n\t\t\tbreak;\n\t\tcase Opt_utf8:\n\t\t\tpopt->utf8 = 1;\n\t\t\tbreak;\n#ifdef CONFIG_JOLIET\n\t\tcase Opt_iocharset:\n\t\t\tpopt->iocharset = match_strdup(&args[0]);\n\t\t\tbreak;\n#endif\n\t\tcase Opt_map_a:\n\t\t\tpopt->map = 'a';\n\t\t\tbreak;\n\t\tcase Opt_map_o:\n\t\t\tpopt->map = 'o';\n\t\t\tbreak;\n\t\tcase Opt_map_n:\n\t\t\tpopt->map = 'n';\n\t\t\tbreak;\n\t\tcase Opt_session:\n\t\t\tif (match_int(&args[0], &option))\n\t\t\t\treturn 0;\n\t\t\tn = option;\n\t\t\tif (n > 99)\n\t\t\t\treturn 0;\n\t\t\tpopt->session = n + 1;\n\t\t\tbreak;\n\t\tcase Opt_sb:\n\t\t\tif (match_int(&args[0], &option))\n\t\t\t\treturn 0;\n\t\t\tpopt->sbsector = option;\n\t\t\tbreak;\n\t\tcase Opt_check_r:\n\t\t\tpopt->check = 'r';\n\t\t\tbreak;\n\t\tcase Opt_check_s:\n\t\t\tpopt->check = 's';\n\t\t\tbreak;\n\t\tcase Opt_ignore:\n\t\t\tbreak;\n\t\tcase Opt_uid:\n\t\t\tif (match_int(&args[0], &option))\n\t\t\t\treturn 0;\n\t\t\tpopt->uid = make_kuid(current_user_ns(), option);\n\t\t\tif (!uid_valid(popt->uid))\n\t\t\t\treturn 0;\n\t\t\tpopt->uid_set = 1;\n\t\t\tbreak;\n\t\tcase Opt_gid:\n\t\t\tif (match_int(&args[0], &option))\n\t\t\t\treturn 0;\n\t\t\tpopt->gid = make_kgid(current_user_ns(), option);\n\t\t\tif (!gid_valid(popt->gid))\n\t\t\t\treturn 0;\n\t\t\tpopt->gid_set = 1;\n\t\t\tbreak;\n\t\tcase Opt_mode:\n\t\t\tif (match_int(&args[0], &option))\n\t\t\t\treturn 0;\n\t\t\tpopt->fmode = option;\n\t\t\tbreak;\n\t\tcase Opt_dmode:\n\t\t\tif (match_int(&args[0], &option))\n\t\t\t\treturn 0;\n\t\t\tpopt->dmode = option;\n\t\t\tbreak;\n\t\tcase Opt_overriderockperm:\n\t\t\tpopt->overriderockperm = 1;\n\t\t\tbreak;\n\t\tcase Opt_block:\n\t\t\tif (match_int(&args[0], &option))\n\t\t\t\treturn 0;\n\t\t\tn = option;\n\t\t\tif (n != 512 && n != 1024 && n != 2048)\n\t\t\t\treturn 0;\n\t\t\tpopt->blocksize = n;\n\t\t\tbreak;\n\t\tcase Opt_nocompress:\n\t\t\tpopt->nocompress = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}",
    "includes": [
      "include \"zisofs.h\"",
      "include \"isofs.h\"\n#",
      "include <linux/user_namespace.h>",
      "include <linux/mpage.h>\n#",
      "include <linux/parser.h>\n#",
      "include <linux/cdrom.h>\n#",
      "include <linux/statfs.h>\n#",
      "include <linux/ctype.h>\n#",
      "include <linux/nls.h>\n#",
      "include <linux/slab.h>\n#",
      "include <linux/module.h>",
      "include <linux/init.h>\n#"
    ],
    "macros_used": [],
    "globals_used": [
      "tatic const match_table_t tokens = {\n\t{Opt_norock, \"norock\"},\n\t{Opt_nojoliet, \"nojoliet\"},\n\t{Opt_unhide, \"unhide\"},\n\t{Opt_hide, \"hide\"},\n\t{Opt_showassoc, \"showassoc\"},\n\t{Opt_cruft, \"cruft\"},\n\t{Opt_utf8, \"utf8\"},\n\t{Opt_iocharset, \"iocharset=%s\"},\n\t{Opt_map_a, \"map=acorn\"},\n\t{Opt_map_a, \"map=a\"},\n\t{Opt_map_n, \"map=normal\"},\n\t{Opt_map_n, \"map=n\"},\n\t{Opt_map_o, \"map=off\"},\n\t{Opt_map_o, \"map=o\"},\n\t{Opt_session, \"session=%u\"},\n\t{Opt_sb, \"sbsector=%u\"},\n\t{Opt_check_r, \"check=relaxed\"},\n\t{Opt_check_r, \"check=r\"},\n\t{Opt_check_s, \"check=strict\"},\n\t{Opt_check_s, \"check=s\"},\n\t{Opt_uid, \"uid=%u\"},\n\t{Opt_gid, \"gid=%u\"},\n\t{Opt_mode, \"mode=%u\"},\n\t{Opt_dmode, \"dmode=%u\"},\n\t{Opt_overriderockperm, \"overriderockperm\"},\n\t{Opt_block, \"block=%u\"},\n\t{Opt_ignore, \"conv=binary\"},\n\t{Opt_ignore, \"conv=b\"},\n\t{Opt_ignore, \"conv=text\"},\n\t{Opt_ignore, \"conv=t\"},\n\t{Opt_ignore, \"conv=mtext\"},\n\t{Opt_ignore, \"conv=m\"},\n\t{Opt_ignore, \"conv=auto\"},\n\t{Opt_ignore, \"conv=a\"},\n\t{Opt_nocompress, \"nocompress\"},\n\t{Opt_err, NULL}\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "atch_int(",
          "args": [
            "args[0],",
            "option)"
          ],
          "line": 460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atch_int(",
          "args": [
            "args[0],",
            "option)"
          ],
          "line": 452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atch_int(",
          "args": [
            "args[0],",
            "option)"
          ],
          "line": 447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "id_valid(",
          "args": [
            "opt->gid)"
          ],
          "line": 442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ake_kgid(",
          "args": [
            "urrent_user_ns(),",
            "ption)"
          ],
          "line": 441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "urrent_user_ns(",
          "args": [],
          "line": 441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atch_int(",
          "args": [
            "args[0],",
            "option)"
          ],
          "line": 439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "id_valid(",
          "args": [
            "opt->uid)"
          ],
          "line": 434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ake_kuid(",
          "args": [
            "urrent_user_ns(),",
            "ption)"
          ],
          "line": 433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "urrent_user_ns(",
          "args": [],
          "line": 433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atch_int(",
          "args": [
            "args[0],",
            "option)"
          ],
          "line": 431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atch_int(",
          "args": [
            "args[0],",
            "option)"
          ],
          "line": 418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atch_int(",
          "args": [
            "args[0],",
            "option)"
          ],
          "line": 410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atch_strdup(",
          "args": [
            "args[0])"
          ],
          "line": 397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atch_token(",
          "args": [
            ",",
            "okens,",
            "rgs)"
          ],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trsep(",
          "args": [
            "options,",
            ",\")"
          ],
          "line": 366
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"zisofs.h\"\ninclude \"isofs.h\"\n#\ninclude <linux/user_namespace.h>\ninclude <linux/mpage.h>\n#\ninclude <linux/parser.h>\n#\ninclude <linux/cdrom.h>\n#\ninclude <linux/statfs.h>\n#\ninclude <linux/ctype.h>\n#\ninclude <linux/nls.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/module.h>\ninclude <linux/init.h>\n#\n\ntatic const match_table_t tokens = {\n\t{Opt_norock, \"norock\"},\n\t{Opt_nojoliet, \"nojoliet\"},\n\t{Opt_unhide, \"unhide\"},\n\t{Opt_hide, \"hide\"},\n\t{Opt_showassoc, \"showassoc\"},\n\t{Opt_cruft, \"cruft\"},\n\t{Opt_utf8, \"utf8\"},\n\t{Opt_iocharset, \"iocharset=%s\"},\n\t{Opt_map_a, \"map=acorn\"},\n\t{Opt_map_a, \"map=a\"},\n\t{Opt_map_n, \"map=normal\"},\n\t{Opt_map_n, \"map=n\"},\n\t{Opt_map_o, \"map=off\"},\n\t{Opt_map_o, \"map=o\"},\n\t{Opt_session, \"session=%u\"},\n\t{Opt_sb, \"sbsector=%u\"},\n\t{Opt_check_r, \"check=relaxed\"},\n\t{Opt_check_r, \"check=r\"},\n\t{Opt_check_s, \"check=strict\"},\n\t{Opt_check_s, \"check=s\"},\n\t{Opt_uid, \"uid=%u\"},\n\t{Opt_gid, \"gid=%u\"},\n\t{Opt_mode, \"mode=%u\"},\n\t{Opt_dmode, \"dmode=%u\"},\n\t{Opt_overriderockperm, \"overriderockperm\"},\n\t{Opt_block, \"block=%u\"},\n\t{Opt_ignore, \"conv=binary\"},\n\t{Opt_ignore, \"conv=b\"},\n\t{Opt_ignore, \"conv=text\"},\n\t{Opt_ignore, \"conv=t\"},\n\t{Opt_ignore, \"conv=mtext\"},\n\t{Opt_ignore, \"conv=m\"},\n\t{Opt_ignore, \"conv=auto\"},\n\t{Opt_ignore, \"conv=a\"},\n\t{Opt_nocompress, \"nocompress\"},\n\t{Opt_err, NULL}\n};\n\ntatic int parse_options(char *options, struct iso9660_options *popt)\n{\n\tchar *p;\n\tint option;\n\n\tpopt->map = 'n';\n\tpopt->rock = 1;\n\tpopt->joliet = 1;\n\tpopt->cruft = 0;\n\tpopt->hide = 0;\n\tpopt->showassoc = 0;\n\tpopt->check = 'u';\t\t/* unset */\n\tpopt->nocompress = 0;\n\tpopt->blocksize = 1024;\n\tpopt->fmode = popt->dmode = ISOFS_INVALID_MODE;\n\tpopt->uid_set = 0;\n\tpopt->gid_set = 0;\n\tpopt->gid = GLOBAL_ROOT_GID;\n\tpopt->uid = GLOBAL_ROOT_UID;\n\tpopt->iocharset = NULL;\n\tpopt->utf8 = 0;\n\tpopt->overriderockperm = 0;\n\tpopt->session=-1;\n\tpopt->sbsector=-1;\n\tif (!options)\n\t\treturn 1;\n\n\twhile ((p = strsep(&options, \",\")) != NULL) {\n\t\tint token;\n\t\tsubstring_t args[MAX_OPT_ARGS];\n\t\tunsigned n;\n\n\t\tif (!*p)\n\t\t\tcontinue;\n\n\t\ttoken = match_token(p, tokens, args);\n\t\tswitch (token) {\n\t\tcase Opt_norock:\n\t\t\tpopt->rock = 0;\n\t\t\tbreak;\n\t\tcase Opt_nojoliet:\n\t\t\tpopt->joliet = 0;\n\t\t\tbreak;\n\t\tcase Opt_hide:\n\t\t\tpopt->hide = 1;\n\t\t\tbreak;\n\t\tcase Opt_unhide:\n\t\tcase Opt_showassoc:\n\t\t\tpopt->showassoc = 1;\n\t\t\tbreak;\n\t\tcase Opt_cruft:\n\t\t\tpopt->cruft = 1;\n\t\t\tbreak;\n\t\tcase Opt_utf8:\n\t\t\tpopt->utf8 = 1;\n\t\t\tbreak;\n#ifdef CONFIG_JOLIET\n\t\tcase Opt_iocharset:\n\t\t\tpopt->iocharset = match_strdup(&args[0]);\n\t\t\tbreak;\n#endif\n\t\tcase Opt_map_a:\n\t\t\tpopt->map = 'a';\n\t\t\tbreak;\n\t\tcase Opt_map_o:\n\t\t\tpopt->map = 'o';\n\t\t\tbreak;\n\t\tcase Opt_map_n:\n\t\t\tpopt->map = 'n';\n\t\t\tbreak;\n\t\tcase Opt_session:\n\t\t\tif (match_int(&args[0], &option))\n\t\t\t\treturn 0;\n\t\t\tn = option;\n\t\t\tif (n > 99)\n\t\t\t\treturn 0;\n\t\t\tpopt->session = n + 1;\n\t\t\tbreak;\n\t\tcase Opt_sb:\n\t\t\tif (match_int(&args[0], &option))\n\t\t\t\treturn 0;\n\t\t\tpopt->sbsector = option;\n\t\t\tbreak;\n\t\tcase Opt_check_r:\n\t\t\tpopt->check = 'r';\n\t\t\tbreak;\n\t\tcase Opt_check_s:\n\t\t\tpopt->check = 's';\n\t\t\tbreak;\n\t\tcase Opt_ignore:\n\t\t\tbreak;\n\t\tcase Opt_uid:\n\t\t\tif (match_int(&args[0], &option))\n\t\t\t\treturn 0;\n\t\t\tpopt->uid = make_kuid(current_user_ns(), option);\n\t\t\tif (!uid_valid(popt->uid))\n\t\t\t\treturn 0;\n\t\t\tpopt->uid_set = 1;\n\t\t\tbreak;\n\t\tcase Opt_gid:\n\t\t\tif (match_int(&args[0], &option))\n\t\t\t\treturn 0;\n\t\t\tpopt->gid = make_kgid(current_user_ns(), option);\n\t\t\tif (!gid_valid(popt->gid))\n\t\t\t\treturn 0;\n\t\t\tpopt->gid_set = 1;\n\t\t\tbreak;\n\t\tcase Opt_mode:\n\t\t\tif (match_int(&args[0], &option))\n\t\t\t\treturn 0;\n\t\t\tpopt->fmode = option;\n\t\t\tbreak;\n\t\tcase Opt_dmode:\n\t\t\tif (match_int(&args[0], &option))\n\t\t\t\treturn 0;\n\t\t\tpopt->dmode = option;\n\t\t\tbreak;\n\t\tcase Opt_overriderockperm:\n\t\t\tpopt->overriderockperm = 1;\n\t\t\tbreak;\n\t\tcase Opt_block:\n\t\t\tif (match_int(&args[0], &option))\n\t\t\t\treturn 0;\n\t\t\tn = option;\n\t\t\tif (n != 512 && n != 1024 && n != 2048)\n\t\t\t\treturn 0;\n\t\t\tpopt->blocksize = n;\n\t\t\tbreak;\n\t\tcase Opt_nocompress:\n\t\t\tpopt->nocompress = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}"
  },
  {
    "function_name": "sofs_dentry_cmpi_ms(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/isofs/inode.c",
    "lines": "285-290",
    "snippet": "tatic int\nisofs_dentry_cmpi_ms(const struct dentry *parent, const struct dentry *dentry,\n\t\tunsigned int len, const char *str, const struct qstr *name)\n{\n\treturn isofs_dentry_cmp_common(len, str, name, 1, 1);\n}",
    "includes": [
      "include \"zisofs.h\"",
      "include \"isofs.h\"\n#",
      "include <linux/user_namespace.h>",
      "include <linux/mpage.h>\n#",
      "include <linux/parser.h>\n#",
      "include <linux/cdrom.h>\n#",
      "include <linux/statfs.h>\n#",
      "include <linux/ctype.h>\n#",
      "include <linux/nls.h>\n#",
      "include <linux/slab.h>\n#",
      "include <linux/module.h>",
      "include <linux/init.h>\n#"
    ],
    "macros_used": [],
    "globals_used": [
      "tatic int isofs_hashi(const struct dentry *parent, struct qstr *qstr);",
      "tatic int isofs_dentry_cmpi(const struct dentry *parent,\n\t\tconst struct dentry *dentry,\n\t\tunsigned int len, const char *str, const struct qstr *name);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sofs_dentry_cmp_common(",
          "args": [
            "en,",
            "tr,",
            "ame,",
            ",",
            ")"
          ],
          "line": 289
        },
        "resolved": true,
        "details": {
          "function_name": "sofs_dentry_cmp_common(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/isofs/inode.c",
          "lines": "204-229",
          "snippet": "tatic int isofs_dentry_cmp_common(\n\t\tunsigned int len, const char *str,\n\t\tconst struct qstr *name, int ms, int ci)\n{\n\tint alen, blen;\n\n\t/* A filename cannot end in '.' or we treat it like it has none */\n\talen = name->len;\n\tblen = len;\n\tif (ms) {\n\t\twhile (alen && name->name[alen-1] == '.')\n\t\t\talen--;\n\t\twhile (blen && str[blen-1] == '.')\n\t\t\tblen--;\n\t}\n\tif (alen == blen) {\n\t\tif (ci) {\n\t\t\tif (strncasecmp(name->name, str, alen) == 0)\n\t\t\t\treturn 0;\n\t\t} else {\n\t\t\tif (strncmp(name->name, str, alen) == 0)\n\t\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}",
          "includes": [
            "include \"zisofs.h\"",
            "include \"isofs.h\"\n#",
            "include <linux/user_namespace.h>",
            "include <linux/mpage.h>\n#",
            "include <linux/parser.h>\n#",
            "include <linux/cdrom.h>\n#",
            "include <linux/statfs.h>\n#",
            "include <linux/ctype.h>\n#",
            "include <linux/nls.h>\n#",
            "include <linux/slab.h>\n#",
            "include <linux/module.h>",
            "include <linux/init.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [
            "tatic int isofs_hashi(const struct dentry *parent, struct qstr *qstr);",
            "tatic int isofs_dentry_cmpi(const struct dentry *parent,\n\t\tconst struct dentry *dentry,\n\t\tunsigned int len, const char *str, const struct qstr *name);"
          ],
          "called_functions": [],
          "contextual_snippet": "include \"zisofs.h\"\ninclude \"isofs.h\"\n#\ninclude <linux/user_namespace.h>\ninclude <linux/mpage.h>\n#\ninclude <linux/parser.h>\n#\ninclude <linux/cdrom.h>\n#\ninclude <linux/statfs.h>\n#\ninclude <linux/ctype.h>\n#\ninclude <linux/nls.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/module.h>\ninclude <linux/init.h>\n#\n\ntatic int isofs_hashi(const struct dentry *parent, struct qstr *qstr);\ntatic int isofs_dentry_cmpi(const struct dentry *parent,\n\t\tconst struct dentry *dentry,\n\t\tunsigned int len, const char *str, const struct qstr *name);\n\ntatic int isofs_dentry_cmp_common(\n\t\tunsigned int len, const char *str,\n\t\tconst struct qstr *name, int ms, int ci)\n{\n\tint alen, blen;\n\n\t/* A filename cannot end in '.' or we treat it like it has none */\n\talen = name->len;\n\tblen = len;\n\tif (ms) {\n\t\twhile (alen && name->name[alen-1] == '.')\n\t\t\talen--;\n\t\twhile (blen && str[blen-1] == '.')\n\t\t\tblen--;\n\t}\n\tif (alen == blen) {\n\t\tif (ci) {\n\t\t\tif (strncasecmp(name->name, str, alen) == 0)\n\t\t\t\treturn 0;\n\t\t} else {\n\t\t\tif (strncmp(name->name, str, alen) == 0)\n\t\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}"
        }
      }
    ],
    "contextual_snippet": "include \"zisofs.h\"\ninclude \"isofs.h\"\n#\ninclude <linux/user_namespace.h>\ninclude <linux/mpage.h>\n#\ninclude <linux/parser.h>\n#\ninclude <linux/cdrom.h>\n#\ninclude <linux/statfs.h>\n#\ninclude <linux/ctype.h>\n#\ninclude <linux/nls.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/module.h>\ninclude <linux/init.h>\n#\n\ntatic int isofs_hashi(const struct dentry *parent, struct qstr *qstr);\ntatic int isofs_dentry_cmpi(const struct dentry *parent,\n\t\tconst struct dentry *dentry,\n\t\tunsigned int len, const char *str, const struct qstr *name);\n\ntatic int\nisofs_dentry_cmpi_ms(const struct dentry *parent, const struct dentry *dentry,\n\t\tunsigned int len, const char *str, const struct qstr *name)\n{\n\treturn isofs_dentry_cmp_common(len, str, name, 1, 1);\n}"
  },
  {
    "function_name": "sofs_dentry_cmp_ms(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/isofs/inode.c",
    "lines": "278-283",
    "snippet": "tatic int\nisofs_dentry_cmp_ms(const struct dentry *parent, const struct dentry *dentry,\n\t\tunsigned int len, const char *str, const struct qstr *name)\n{\n\treturn isofs_dentry_cmp_common(len, str, name, 1, 0);\n}",
    "includes": [
      "include \"zisofs.h\"",
      "include \"isofs.h\"\n#",
      "include <linux/user_namespace.h>",
      "include <linux/mpage.h>\n#",
      "include <linux/parser.h>\n#",
      "include <linux/cdrom.h>\n#",
      "include <linux/statfs.h>\n#",
      "include <linux/ctype.h>\n#",
      "include <linux/nls.h>\n#",
      "include <linux/slab.h>\n#",
      "include <linux/module.h>",
      "include <linux/init.h>\n#"
    ],
    "macros_used": [],
    "globals_used": [
      "tatic int isofs_hashi(const struct dentry *parent, struct qstr *qstr);",
      "tatic int isofs_dentry_cmpi(const struct dentry *parent,\n\t\tconst struct dentry *dentry,\n\t\tunsigned int len, const char *str, const struct qstr *name);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sofs_dentry_cmp_common(",
          "args": [
            "en,",
            "tr,",
            "ame,",
            ",",
            ")"
          ],
          "line": 282
        },
        "resolved": true,
        "details": {
          "function_name": "sofs_dentry_cmp_common(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/isofs/inode.c",
          "lines": "204-229",
          "snippet": "tatic int isofs_dentry_cmp_common(\n\t\tunsigned int len, const char *str,\n\t\tconst struct qstr *name, int ms, int ci)\n{\n\tint alen, blen;\n\n\t/* A filename cannot end in '.' or we treat it like it has none */\n\talen = name->len;\n\tblen = len;\n\tif (ms) {\n\t\twhile (alen && name->name[alen-1] == '.')\n\t\t\talen--;\n\t\twhile (blen && str[blen-1] == '.')\n\t\t\tblen--;\n\t}\n\tif (alen == blen) {\n\t\tif (ci) {\n\t\t\tif (strncasecmp(name->name, str, alen) == 0)\n\t\t\t\treturn 0;\n\t\t} else {\n\t\t\tif (strncmp(name->name, str, alen) == 0)\n\t\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}",
          "includes": [
            "include \"zisofs.h\"",
            "include \"isofs.h\"\n#",
            "include <linux/user_namespace.h>",
            "include <linux/mpage.h>\n#",
            "include <linux/parser.h>\n#",
            "include <linux/cdrom.h>\n#",
            "include <linux/statfs.h>\n#",
            "include <linux/ctype.h>\n#",
            "include <linux/nls.h>\n#",
            "include <linux/slab.h>\n#",
            "include <linux/module.h>",
            "include <linux/init.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [
            "tatic int isofs_hashi(const struct dentry *parent, struct qstr *qstr);",
            "tatic int isofs_dentry_cmpi(const struct dentry *parent,\n\t\tconst struct dentry *dentry,\n\t\tunsigned int len, const char *str, const struct qstr *name);"
          ],
          "called_functions": [],
          "contextual_snippet": "include \"zisofs.h\"\ninclude \"isofs.h\"\n#\ninclude <linux/user_namespace.h>\ninclude <linux/mpage.h>\n#\ninclude <linux/parser.h>\n#\ninclude <linux/cdrom.h>\n#\ninclude <linux/statfs.h>\n#\ninclude <linux/ctype.h>\n#\ninclude <linux/nls.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/module.h>\ninclude <linux/init.h>\n#\n\ntatic int isofs_hashi(const struct dentry *parent, struct qstr *qstr);\ntatic int isofs_dentry_cmpi(const struct dentry *parent,\n\t\tconst struct dentry *dentry,\n\t\tunsigned int len, const char *str, const struct qstr *name);\n\ntatic int isofs_dentry_cmp_common(\n\t\tunsigned int len, const char *str,\n\t\tconst struct qstr *name, int ms, int ci)\n{\n\tint alen, blen;\n\n\t/* A filename cannot end in '.' or we treat it like it has none */\n\talen = name->len;\n\tblen = len;\n\tif (ms) {\n\t\twhile (alen && name->name[alen-1] == '.')\n\t\t\talen--;\n\t\twhile (blen && str[blen-1] == '.')\n\t\t\tblen--;\n\t}\n\tif (alen == blen) {\n\t\tif (ci) {\n\t\t\tif (strncasecmp(name->name, str, alen) == 0)\n\t\t\t\treturn 0;\n\t\t} else {\n\t\t\tif (strncmp(name->name, str, alen) == 0)\n\t\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}"
        }
      }
    ],
    "contextual_snippet": "include \"zisofs.h\"\ninclude \"isofs.h\"\n#\ninclude <linux/user_namespace.h>\ninclude <linux/mpage.h>\n#\ninclude <linux/parser.h>\n#\ninclude <linux/cdrom.h>\n#\ninclude <linux/statfs.h>\n#\ninclude <linux/ctype.h>\n#\ninclude <linux/nls.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/module.h>\ninclude <linux/init.h>\n#\n\ntatic int isofs_hashi(const struct dentry *parent, struct qstr *qstr);\ntatic int isofs_dentry_cmpi(const struct dentry *parent,\n\t\tconst struct dentry *dentry,\n\t\tunsigned int len, const char *str, const struct qstr *name);\n\ntatic int\nisofs_dentry_cmp_ms(const struct dentry *parent, const struct dentry *dentry,\n\t\tunsigned int len, const char *str, const struct qstr *name)\n{\n\treturn isofs_dentry_cmp_common(len, str, name, 1, 0);\n}"
  },
  {
    "function_name": "sofs_hashi_ms(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/isofs/inode.c",
    "lines": "272-276",
    "snippet": "tatic int\nisofs_hashi_ms(const struct dentry *dentry, struct qstr *qstr)\n{\n\treturn isofs_hashi_common(qstr, 1);\n}",
    "includes": [
      "include \"zisofs.h\"",
      "include \"isofs.h\"\n#",
      "include <linux/user_namespace.h>",
      "include <linux/mpage.h>\n#",
      "include <linux/parser.h>\n#",
      "include <linux/cdrom.h>\n#",
      "include <linux/statfs.h>\n#",
      "include <linux/ctype.h>\n#",
      "include <linux/nls.h>\n#",
      "include <linux/slab.h>\n#",
      "include <linux/module.h>",
      "include <linux/init.h>\n#"
    ],
    "macros_used": [],
    "globals_used": [
      "tatic int isofs_hashi(const struct dentry *parent, struct qstr *qstr);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sofs_hashi_common(",
          "args": [
            "str,",
            ")"
          ],
          "line": 275
        },
        "resolved": true,
        "details": {
          "function_name": "sofs_hashi_common(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/isofs/inode.c",
          "lines": "176-199",
          "snippet": "tatic int\nisofs_hashi_common(struct qstr *qstr, int ms)\n{\n\tconst char *name;\n\tint len;\n\tchar c;\n\tunsigned long hash;\n\n\tlen = qstr->len;\n\tname = qstr->name;\n\tif (ms) {\n\t\twhile (len && name[len-1] == '.')\n\t\t\tlen--;\n\t}\n\n\thash = init_name_hash();\n\twhile (len--) {\n\t\tc = tolower(*name++);\n\t\thash = partial_name_hash(c, hash);\n\t}\n\tqstr->hash = end_name_hash(hash);\n\n\treturn 0;\n}",
          "includes": [
            "include \"zisofs.h\"",
            "include \"isofs.h\"\n#",
            "include <linux/user_namespace.h>",
            "include <linux/mpage.h>\n#",
            "include <linux/parser.h>\n#",
            "include <linux/cdrom.h>\n#",
            "include <linux/statfs.h>\n#",
            "include <linux/ctype.h>\n#",
            "include <linux/nls.h>\n#",
            "include <linux/slab.h>\n#",
            "include <linux/module.h>",
            "include <linux/init.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [
            "tatic int isofs_hashi(const struct dentry *parent, struct qstr *qstr);",
            "tatic int isofs_dentry_cmpi(const struct dentry *parent,\n\t\tconst struct dentry *dentry,\n\t\tunsigned int len, const char *str, const struct qstr *name);"
          ],
          "called_functions": [],
          "contextual_snippet": "include \"zisofs.h\"\ninclude \"isofs.h\"\n#\ninclude <linux/user_namespace.h>\ninclude <linux/mpage.h>\n#\ninclude <linux/parser.h>\n#\ninclude <linux/cdrom.h>\n#\ninclude <linux/statfs.h>\n#\ninclude <linux/ctype.h>\n#\ninclude <linux/nls.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/module.h>\ninclude <linux/init.h>\n#\n\ntatic int isofs_hashi(const struct dentry *parent, struct qstr *qstr);\ntatic int isofs_dentry_cmpi(const struct dentry *parent,\n\t\tconst struct dentry *dentry,\n\t\tunsigned int len, const char *str, const struct qstr *name);\n\ntatic int\nisofs_hashi_common(struct qstr *qstr, int ms)\n{\n\tconst char *name;\n\tint len;\n\tchar c;\n\tunsigned long hash;\n\n\tlen = qstr->len;\n\tname = qstr->name;\n\tif (ms) {\n\t\twhile (len && name[len-1] == '.')\n\t\t\tlen--;\n\t}\n\n\thash = init_name_hash();\n\twhile (len--) {\n\t\tc = tolower(*name++);\n\t\thash = partial_name_hash(c, hash);\n\t}\n\tqstr->hash = end_name_hash(hash);\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "include \"zisofs.h\"\ninclude \"isofs.h\"\n#\ninclude <linux/user_namespace.h>\ninclude <linux/mpage.h>\n#\ninclude <linux/parser.h>\n#\ninclude <linux/cdrom.h>\n#\ninclude <linux/statfs.h>\n#\ninclude <linux/ctype.h>\n#\ninclude <linux/nls.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/module.h>\ninclude <linux/init.h>\n#\n\ntatic int isofs_hashi(const struct dentry *parent, struct qstr *qstr);\n\ntatic int\nisofs_hashi_ms(const struct dentry *dentry, struct qstr *qstr)\n{\n\treturn isofs_hashi_common(qstr, 1);\n}"
  },
  {
    "function_name": "sofs_hash_ms(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/isofs/inode.c",
    "lines": "266-270",
    "snippet": "tatic int\nisofs_hash_ms(const struct dentry *dentry, struct qstr *qstr)\n{\n\treturn isofs_hash_common(qstr, 1);\n}",
    "includes": [
      "include \"zisofs.h\"",
      "include \"isofs.h\"\n#",
      "include <linux/user_namespace.h>",
      "include <linux/mpage.h>\n#",
      "include <linux/parser.h>\n#",
      "include <linux/cdrom.h>\n#",
      "include <linux/statfs.h>\n#",
      "include <linux/ctype.h>\n#",
      "include <linux/nls.h>\n#",
      "include <linux/slab.h>\n#",
      "include <linux/module.h>",
      "include <linux/init.h>\n#"
    ],
    "macros_used": [],
    "globals_used": [
      "tatic int isofs_hashi(const struct dentry *parent, struct qstr *qstr);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sofs_hash_common(",
          "args": [
            "str,",
            ")"
          ],
          "line": 269
        },
        "resolved": true,
        "details": {
          "function_name": "sofs_hash_common(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/isofs/inode.c",
          "lines": "248-264",
          "snippet": "tatic int\nisofs_hash_common(struct qstr *qstr, int ms)\n{\n\tconst char *name;\n\tint len;\n\n\tlen = qstr->len;\n\tname = qstr->name;\n\tif (ms) {\n\t\twhile (len && name[len-1] == '.')\n\t\t\tlen--;\n\t}\n\n\tqstr->hash = full_name_hash(name, len);\n\n\treturn 0;\n}",
          "includes": [
            "include \"zisofs.h\"",
            "include \"isofs.h\"\n#",
            "include <linux/user_namespace.h>",
            "include <linux/mpage.h>\n#",
            "include <linux/parser.h>\n#",
            "include <linux/cdrom.h>\n#",
            "include <linux/statfs.h>\n#",
            "include <linux/ctype.h>\n#",
            "include <linux/nls.h>\n#",
            "include <linux/slab.h>\n#",
            "include <linux/module.h>",
            "include <linux/init.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [
            "tatic int isofs_hashi(const struct dentry *parent, struct qstr *qstr);",
            "tatic int isofs_dentry_cmpi(const struct dentry *parent,\n\t\tconst struct dentry *dentry,\n\t\tunsigned int len, const char *str, const struct qstr *name);"
          ],
          "called_functions": [],
          "contextual_snippet": "include \"zisofs.h\"\ninclude \"isofs.h\"\n#\ninclude <linux/user_namespace.h>\ninclude <linux/mpage.h>\n#\ninclude <linux/parser.h>\n#\ninclude <linux/cdrom.h>\n#\ninclude <linux/statfs.h>\n#\ninclude <linux/ctype.h>\n#\ninclude <linux/nls.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/module.h>\ninclude <linux/init.h>\n#\n\ntatic int isofs_hashi(const struct dentry *parent, struct qstr *qstr);\ntatic int isofs_dentry_cmpi(const struct dentry *parent,\n\t\tconst struct dentry *dentry,\n\t\tunsigned int len, const char *str, const struct qstr *name);\n\ntatic int\nisofs_hash_common(struct qstr *qstr, int ms)\n{\n\tconst char *name;\n\tint len;\n\n\tlen = qstr->len;\n\tname = qstr->name;\n\tif (ms) {\n\t\twhile (len && name[len-1] == '.')\n\t\t\tlen--;\n\t}\n\n\tqstr->hash = full_name_hash(name, len);\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "include \"zisofs.h\"\ninclude \"isofs.h\"\n#\ninclude <linux/user_namespace.h>\ninclude <linux/mpage.h>\n#\ninclude <linux/parser.h>\n#\ninclude <linux/cdrom.h>\n#\ninclude <linux/statfs.h>\n#\ninclude <linux/ctype.h>\n#\ninclude <linux/nls.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/module.h>\ninclude <linux/init.h>\n#\n\ntatic int isofs_hashi(const struct dentry *parent, struct qstr *qstr);\n\ntatic int\nisofs_hash_ms(const struct dentry *dentry, struct qstr *qstr)\n{\n\treturn isofs_hash_common(qstr, 1);\n}"
  },
  {
    "function_name": "sofs_hash_common(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/isofs/inode.c",
    "lines": "248-264",
    "snippet": "tatic int\nisofs_hash_common(struct qstr *qstr, int ms)\n{\n\tconst char *name;\n\tint len;\n\n\tlen = qstr->len;\n\tname = qstr->name;\n\tif (ms) {\n\t\twhile (len && name[len-1] == '.')\n\t\t\tlen--;\n\t}\n\n\tqstr->hash = full_name_hash(name, len);\n\n\treturn 0;\n}",
    "includes": [
      "include \"zisofs.h\"",
      "include \"isofs.h\"\n#",
      "include <linux/user_namespace.h>",
      "include <linux/mpage.h>\n#",
      "include <linux/parser.h>\n#",
      "include <linux/cdrom.h>\n#",
      "include <linux/statfs.h>\n#",
      "include <linux/ctype.h>\n#",
      "include <linux/nls.h>\n#",
      "include <linux/slab.h>\n#",
      "include <linux/module.h>",
      "include <linux/init.h>\n#"
    ],
    "macros_used": [],
    "globals_used": [
      "tatic int isofs_hashi(const struct dentry *parent, struct qstr *qstr);",
      "tatic int isofs_dentry_cmpi(const struct dentry *parent,\n\t\tconst struct dentry *dentry,\n\t\tunsigned int len, const char *str, const struct qstr *name);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ull_name_hash(",
          "args": [
            "ame,",
            "en)"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"zisofs.h\"\ninclude \"isofs.h\"\n#\ninclude <linux/user_namespace.h>\ninclude <linux/mpage.h>\n#\ninclude <linux/parser.h>\n#\ninclude <linux/cdrom.h>\n#\ninclude <linux/statfs.h>\n#\ninclude <linux/ctype.h>\n#\ninclude <linux/nls.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/module.h>\ninclude <linux/init.h>\n#\n\ntatic int isofs_hashi(const struct dentry *parent, struct qstr *qstr);\ntatic int isofs_dentry_cmpi(const struct dentry *parent,\n\t\tconst struct dentry *dentry,\n\t\tunsigned int len, const char *str, const struct qstr *name);\n\ntatic int\nisofs_hash_common(struct qstr *qstr, int ms)\n{\n\tconst char *name;\n\tint len;\n\n\tlen = qstr->len;\n\tname = qstr->name;\n\tif (ms) {\n\t\twhile (len && name[len-1] == '.')\n\t\t\tlen--;\n\t}\n\n\tqstr->hash = full_name_hash(name, len);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "sofs_dentry_cmpi(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/isofs/inode.c",
    "lines": "237-242",
    "snippet": "tatic int\nisofs_dentry_cmpi(const struct dentry *parent, const struct dentry *dentry,\n\t\tunsigned int len, const char *str, const struct qstr *name)\n{\n\treturn isofs_dentry_cmp_common(len, str, name, 0, 1);\n}",
    "includes": [
      "include \"zisofs.h\"",
      "include \"isofs.h\"\n#",
      "include <linux/user_namespace.h>",
      "include <linux/mpage.h>\n#",
      "include <linux/parser.h>\n#",
      "include <linux/cdrom.h>\n#",
      "include <linux/statfs.h>\n#",
      "include <linux/ctype.h>\n#",
      "include <linux/nls.h>\n#",
      "include <linux/slab.h>\n#",
      "include <linux/module.h>",
      "include <linux/init.h>\n#"
    ],
    "macros_used": [],
    "globals_used": [
      "tatic int isofs_hashi(const struct dentry *parent, struct qstr *qstr);",
      "tatic int isofs_dentry_cmpi(const struct dentry *parent,\n\t\tconst struct dentry *dentry,\n\t\tunsigned int len, const char *str, const struct qstr *name);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sofs_dentry_cmp_common(",
          "args": [
            "en,",
            "tr,",
            "ame,",
            ",",
            ")"
          ],
          "line": 241
        },
        "resolved": true,
        "details": {
          "function_name": "sofs_dentry_cmp_common(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/isofs/inode.c",
          "lines": "204-229",
          "snippet": "tatic int isofs_dentry_cmp_common(\n\t\tunsigned int len, const char *str,\n\t\tconst struct qstr *name, int ms, int ci)\n{\n\tint alen, blen;\n\n\t/* A filename cannot end in '.' or we treat it like it has none */\n\talen = name->len;\n\tblen = len;\n\tif (ms) {\n\t\twhile (alen && name->name[alen-1] == '.')\n\t\t\talen--;\n\t\twhile (blen && str[blen-1] == '.')\n\t\t\tblen--;\n\t}\n\tif (alen == blen) {\n\t\tif (ci) {\n\t\t\tif (strncasecmp(name->name, str, alen) == 0)\n\t\t\t\treturn 0;\n\t\t} else {\n\t\t\tif (strncmp(name->name, str, alen) == 0)\n\t\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}",
          "includes": [
            "include \"zisofs.h\"",
            "include \"isofs.h\"\n#",
            "include <linux/user_namespace.h>",
            "include <linux/mpage.h>\n#",
            "include <linux/parser.h>\n#",
            "include <linux/cdrom.h>\n#",
            "include <linux/statfs.h>\n#",
            "include <linux/ctype.h>\n#",
            "include <linux/nls.h>\n#",
            "include <linux/slab.h>\n#",
            "include <linux/module.h>",
            "include <linux/init.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [
            "tatic int isofs_hashi(const struct dentry *parent, struct qstr *qstr);",
            "tatic int isofs_dentry_cmpi(const struct dentry *parent,\n\t\tconst struct dentry *dentry,\n\t\tunsigned int len, const char *str, const struct qstr *name);"
          ],
          "called_functions": [],
          "contextual_snippet": "include \"zisofs.h\"\ninclude \"isofs.h\"\n#\ninclude <linux/user_namespace.h>\ninclude <linux/mpage.h>\n#\ninclude <linux/parser.h>\n#\ninclude <linux/cdrom.h>\n#\ninclude <linux/statfs.h>\n#\ninclude <linux/ctype.h>\n#\ninclude <linux/nls.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/module.h>\ninclude <linux/init.h>\n#\n\ntatic int isofs_hashi(const struct dentry *parent, struct qstr *qstr);\ntatic int isofs_dentry_cmpi(const struct dentry *parent,\n\t\tconst struct dentry *dentry,\n\t\tunsigned int len, const char *str, const struct qstr *name);\n\ntatic int isofs_dentry_cmp_common(\n\t\tunsigned int len, const char *str,\n\t\tconst struct qstr *name, int ms, int ci)\n{\n\tint alen, blen;\n\n\t/* A filename cannot end in '.' or we treat it like it has none */\n\talen = name->len;\n\tblen = len;\n\tif (ms) {\n\t\twhile (alen && name->name[alen-1] == '.')\n\t\t\talen--;\n\t\twhile (blen && str[blen-1] == '.')\n\t\t\tblen--;\n\t}\n\tif (alen == blen) {\n\t\tif (ci) {\n\t\t\tif (strncasecmp(name->name, str, alen) == 0)\n\t\t\t\treturn 0;\n\t\t} else {\n\t\t\tif (strncmp(name->name, str, alen) == 0)\n\t\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}"
        }
      }
    ],
    "contextual_snippet": "include \"zisofs.h\"\ninclude \"isofs.h\"\n#\ninclude <linux/user_namespace.h>\ninclude <linux/mpage.h>\n#\ninclude <linux/parser.h>\n#\ninclude <linux/cdrom.h>\n#\ninclude <linux/statfs.h>\n#\ninclude <linux/ctype.h>\n#\ninclude <linux/nls.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/module.h>\ninclude <linux/init.h>\n#\n\ntatic int isofs_hashi(const struct dentry *parent, struct qstr *qstr);\ntatic int isofs_dentry_cmpi(const struct dentry *parent,\n\t\tconst struct dentry *dentry,\n\t\tunsigned int len, const char *str, const struct qstr *name);\n\ntatic int\nisofs_dentry_cmpi(const struct dentry *parent, const struct dentry *dentry,\n\t\tunsigned int len, const char *str, const struct qstr *name)\n{\n\treturn isofs_dentry_cmp_common(len, str, name, 0, 1);\n}"
  },
  {
    "function_name": "sofs_hashi(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/isofs/inode.c",
    "lines": "231-235",
    "snippet": "tatic int\nisofs_hashi(const struct dentry *dentry, struct qstr *qstr)\n{\n\treturn isofs_hashi_common(qstr, 0);\n}",
    "includes": [
      "include \"zisofs.h\"",
      "include \"isofs.h\"\n#",
      "include <linux/user_namespace.h>",
      "include <linux/mpage.h>\n#",
      "include <linux/parser.h>\n#",
      "include <linux/cdrom.h>\n#",
      "include <linux/statfs.h>\n#",
      "include <linux/ctype.h>\n#",
      "include <linux/nls.h>\n#",
      "include <linux/slab.h>\n#",
      "include <linux/module.h>",
      "include <linux/init.h>\n#"
    ],
    "macros_used": [],
    "globals_used": [
      "tatic int isofs_hashi(const struct dentry *parent, struct qstr *qstr);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sofs_hashi_common(",
          "args": [
            "str,",
            ")"
          ],
          "line": 234
        },
        "resolved": true,
        "details": {
          "function_name": "sofs_hashi_common(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/isofs/inode.c",
          "lines": "176-199",
          "snippet": "tatic int\nisofs_hashi_common(struct qstr *qstr, int ms)\n{\n\tconst char *name;\n\tint len;\n\tchar c;\n\tunsigned long hash;\n\n\tlen = qstr->len;\n\tname = qstr->name;\n\tif (ms) {\n\t\twhile (len && name[len-1] == '.')\n\t\t\tlen--;\n\t}\n\n\thash = init_name_hash();\n\twhile (len--) {\n\t\tc = tolower(*name++);\n\t\thash = partial_name_hash(c, hash);\n\t}\n\tqstr->hash = end_name_hash(hash);\n\n\treturn 0;\n}",
          "includes": [
            "include \"zisofs.h\"",
            "include \"isofs.h\"\n#",
            "include <linux/user_namespace.h>",
            "include <linux/mpage.h>\n#",
            "include <linux/parser.h>\n#",
            "include <linux/cdrom.h>\n#",
            "include <linux/statfs.h>\n#",
            "include <linux/ctype.h>\n#",
            "include <linux/nls.h>\n#",
            "include <linux/slab.h>\n#",
            "include <linux/module.h>",
            "include <linux/init.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [
            "tatic int isofs_hashi(const struct dentry *parent, struct qstr *qstr);",
            "tatic int isofs_dentry_cmpi(const struct dentry *parent,\n\t\tconst struct dentry *dentry,\n\t\tunsigned int len, const char *str, const struct qstr *name);"
          ],
          "called_functions": [],
          "contextual_snippet": "include \"zisofs.h\"\ninclude \"isofs.h\"\n#\ninclude <linux/user_namespace.h>\ninclude <linux/mpage.h>\n#\ninclude <linux/parser.h>\n#\ninclude <linux/cdrom.h>\n#\ninclude <linux/statfs.h>\n#\ninclude <linux/ctype.h>\n#\ninclude <linux/nls.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/module.h>\ninclude <linux/init.h>\n#\n\ntatic int isofs_hashi(const struct dentry *parent, struct qstr *qstr);\ntatic int isofs_dentry_cmpi(const struct dentry *parent,\n\t\tconst struct dentry *dentry,\n\t\tunsigned int len, const char *str, const struct qstr *name);\n\ntatic int\nisofs_hashi_common(struct qstr *qstr, int ms)\n{\n\tconst char *name;\n\tint len;\n\tchar c;\n\tunsigned long hash;\n\n\tlen = qstr->len;\n\tname = qstr->name;\n\tif (ms) {\n\t\twhile (len && name[len-1] == '.')\n\t\t\tlen--;\n\t}\n\n\thash = init_name_hash();\n\twhile (len--) {\n\t\tc = tolower(*name++);\n\t\thash = partial_name_hash(c, hash);\n\t}\n\tqstr->hash = end_name_hash(hash);\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "include \"zisofs.h\"\ninclude \"isofs.h\"\n#\ninclude <linux/user_namespace.h>\ninclude <linux/mpage.h>\n#\ninclude <linux/parser.h>\n#\ninclude <linux/cdrom.h>\n#\ninclude <linux/statfs.h>\n#\ninclude <linux/ctype.h>\n#\ninclude <linux/nls.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/module.h>\ninclude <linux/init.h>\n#\n\ntatic int isofs_hashi(const struct dentry *parent, struct qstr *qstr);\n\ntatic int\nisofs_hashi(const struct dentry *dentry, struct qstr *qstr)\n{\n\treturn isofs_hashi_common(qstr, 0);\n}"
  },
  {
    "function_name": "sofs_dentry_cmp_common(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/isofs/inode.c",
    "lines": "204-229",
    "snippet": "tatic int isofs_dentry_cmp_common(\n\t\tunsigned int len, const char *str,\n\t\tconst struct qstr *name, int ms, int ci)\n{\n\tint alen, blen;\n\n\t/* A filename cannot end in '.' or we treat it like it has none */\n\talen = name->len;\n\tblen = len;\n\tif (ms) {\n\t\twhile (alen && name->name[alen-1] == '.')\n\t\t\talen--;\n\t\twhile (blen && str[blen-1] == '.')\n\t\t\tblen--;\n\t}\n\tif (alen == blen) {\n\t\tif (ci) {\n\t\t\tif (strncasecmp(name->name, str, alen) == 0)\n\t\t\t\treturn 0;\n\t\t} else {\n\t\t\tif (strncmp(name->name, str, alen) == 0)\n\t\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}",
    "includes": [
      "include \"zisofs.h\"",
      "include \"isofs.h\"\n#",
      "include <linux/user_namespace.h>",
      "include <linux/mpage.h>\n#",
      "include <linux/parser.h>\n#",
      "include <linux/cdrom.h>\n#",
      "include <linux/statfs.h>\n#",
      "include <linux/ctype.h>\n#",
      "include <linux/nls.h>\n#",
      "include <linux/slab.h>\n#",
      "include <linux/module.h>",
      "include <linux/init.h>\n#"
    ],
    "macros_used": [],
    "globals_used": [
      "tatic int isofs_hashi(const struct dentry *parent, struct qstr *qstr);",
      "tatic int isofs_dentry_cmpi(const struct dentry *parent,\n\t\tconst struct dentry *dentry,\n\t\tunsigned int len, const char *str, const struct qstr *name);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trncmp(",
          "args": [
            "ame->name,",
            "tr,",
            "len)"
          ],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trncasecmp(",
          "args": [
            "ame->name,",
            "tr,",
            "len)"
          ],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"zisofs.h\"\ninclude \"isofs.h\"\n#\ninclude <linux/user_namespace.h>\ninclude <linux/mpage.h>\n#\ninclude <linux/parser.h>\n#\ninclude <linux/cdrom.h>\n#\ninclude <linux/statfs.h>\n#\ninclude <linux/ctype.h>\n#\ninclude <linux/nls.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/module.h>\ninclude <linux/init.h>\n#\n\ntatic int isofs_hashi(const struct dentry *parent, struct qstr *qstr);\ntatic int isofs_dentry_cmpi(const struct dentry *parent,\n\t\tconst struct dentry *dentry,\n\t\tunsigned int len, const char *str, const struct qstr *name);\n\ntatic int isofs_dentry_cmp_common(\n\t\tunsigned int len, const char *str,\n\t\tconst struct qstr *name, int ms, int ci)\n{\n\tint alen, blen;\n\n\t/* A filename cannot end in '.' or we treat it like it has none */\n\talen = name->len;\n\tblen = len;\n\tif (ms) {\n\t\twhile (alen && name->name[alen-1] == '.')\n\t\t\talen--;\n\t\twhile (blen && str[blen-1] == '.')\n\t\t\tblen--;\n\t}\n\tif (alen == blen) {\n\t\tif (ci) {\n\t\t\tif (strncasecmp(name->name, str, alen) == 0)\n\t\t\t\treturn 0;\n\t\t} else {\n\t\t\tif (strncmp(name->name, str, alen) == 0)\n\t\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}"
  },
  {
    "function_name": "sofs_hashi_common(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/isofs/inode.c",
    "lines": "176-199",
    "snippet": "tatic int\nisofs_hashi_common(struct qstr *qstr, int ms)\n{\n\tconst char *name;\n\tint len;\n\tchar c;\n\tunsigned long hash;\n\n\tlen = qstr->len;\n\tname = qstr->name;\n\tif (ms) {\n\t\twhile (len && name[len-1] == '.')\n\t\t\tlen--;\n\t}\n\n\thash = init_name_hash();\n\twhile (len--) {\n\t\tc = tolower(*name++);\n\t\thash = partial_name_hash(c, hash);\n\t}\n\tqstr->hash = end_name_hash(hash);\n\n\treturn 0;\n}",
    "includes": [
      "include \"zisofs.h\"",
      "include \"isofs.h\"\n#",
      "include <linux/user_namespace.h>",
      "include <linux/mpage.h>\n#",
      "include <linux/parser.h>\n#",
      "include <linux/cdrom.h>\n#",
      "include <linux/statfs.h>\n#",
      "include <linux/ctype.h>\n#",
      "include <linux/nls.h>\n#",
      "include <linux/slab.h>\n#",
      "include <linux/module.h>",
      "include <linux/init.h>\n#"
    ],
    "macros_used": [],
    "globals_used": [
      "tatic int isofs_hashi(const struct dentry *parent, struct qstr *qstr);",
      "tatic int isofs_dentry_cmpi(const struct dentry *parent,\n\t\tconst struct dentry *dentry,\n\t\tunsigned int len, const char *str, const struct qstr *name);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "nd_name_hash(",
          "args": [
            "ash)"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "artial_name_hash(",
          "args": [
            ",",
            "ash)"
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "olower(",
          "args": [
            "name++)"
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nit_name_hash(",
          "args": [],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"zisofs.h\"\ninclude \"isofs.h\"\n#\ninclude <linux/user_namespace.h>\ninclude <linux/mpage.h>\n#\ninclude <linux/parser.h>\n#\ninclude <linux/cdrom.h>\n#\ninclude <linux/statfs.h>\n#\ninclude <linux/ctype.h>\n#\ninclude <linux/nls.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/module.h>\ninclude <linux/init.h>\n#\n\ntatic int isofs_hashi(const struct dentry *parent, struct qstr *qstr);\ntatic int isofs_dentry_cmpi(const struct dentry *parent,\n\t\tconst struct dentry *dentry,\n\t\tunsigned int len, const char *str, const struct qstr *name);\n\ntatic int\nisofs_hashi_common(struct qstr *qstr, int ms)\n{\n\tconst char *name;\n\tint len;\n\tchar c;\n\tunsigned long hash;\n\n\tlen = qstr->len;\n\tname = qstr->name;\n\tif (ms) {\n\t\twhile (len && name[len-1] == '.')\n\t\t\tlen--;\n\t}\n\n\thash = init_name_hash();\n\twhile (len--) {\n\t\tc = tolower(*name++);\n\t\thash = partial_name_hash(c, hash);\n\t}\n\tqstr->hash = end_name_hash(hash);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "sofs_remount(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/isofs/inode.c",
    "lines": "114-120",
    "snippet": "tatic int isofs_remount(struct super_block *sb, int *flags, char *data)\n{\n\tsync_filesystem(sb);\n\tif (!(*flags & MS_RDONLY))\n\t\treturn -EROFS;\n\treturn 0;\n}",
    "includes": [
      "include \"zisofs.h\"",
      "include \"isofs.h\"\n#",
      "include <linux/user_namespace.h>",
      "include <linux/mpage.h>\n#",
      "include <linux/parser.h>\n#",
      "include <linux/cdrom.h>\n#",
      "include <linux/statfs.h>\n#",
      "include <linux/ctype.h>\n#",
      "include <linux/nls.h>\n#",
      "include <linux/slab.h>\n#",
      "include <linux/module.h>",
      "include <linux/init.h>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ync_filesystem(",
          "args": [
            "b)"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"zisofs.h\"\ninclude \"isofs.h\"\n#\ninclude <linux/user_namespace.h>\ninclude <linux/mpage.h>\n#\ninclude <linux/parser.h>\n#\ninclude <linux/cdrom.h>\n#\ninclude <linux/statfs.h>\n#\ninclude <linux/ctype.h>\n#\ninclude <linux/nls.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/module.h>\ninclude <linux/init.h>\n#\n\ntatic int isofs_remount(struct super_block *sb, int *flags, char *data)\n{\n\tsync_filesystem(sb);\n\tif (!(*flags & MS_RDONLY))\n\t\treturn -EROFS;\n\treturn 0;\n}"
  },
  {
    "function_name": "estroy_inodecache(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/isofs/inode.c",
    "lines": "104-112",
    "snippet": "tatic void destroy_inodecache(void)\n{\n\t/*\n\t * Make sure all delayed rcu free inodes are flushed before we\n\t * destroy cache.\n\t */\n\trcu_barrier();\n\tkmem_cache_destroy(isofs_inode_cachep);\n}",
    "includes": [
      "include \"zisofs.h\"",
      "include \"isofs.h\"\n#",
      "include <linux/user_namespace.h>",
      "include <linux/mpage.h>\n#",
      "include <linux/parser.h>\n#",
      "include <linux/cdrom.h>\n#",
      "include <linux/statfs.h>\n#",
      "include <linux/ctype.h>\n#",
      "include <linux/nls.h>\n#",
      "include <linux/slab.h>\n#",
      "include <linux/module.h>",
      "include <linux/init.h>\n#"
    ],
    "macros_used": [],
    "globals_used": [
      "tatic struct kmem_cache *isofs_inode_cachep;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mem_cache_destroy(",
          "args": [
            "sofs_inode_cachep)"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cu_barrier(",
          "args": [],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"zisofs.h\"\ninclude \"isofs.h\"\n#\ninclude <linux/user_namespace.h>\ninclude <linux/mpage.h>\n#\ninclude <linux/parser.h>\n#\ninclude <linux/cdrom.h>\n#\ninclude <linux/statfs.h>\n#\ninclude <linux/ctype.h>\n#\ninclude <linux/nls.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/module.h>\ninclude <linux/init.h>\n#\n\ntatic struct kmem_cache *isofs_inode_cachep;\n\ntatic void destroy_inodecache(void)\n{\n\t/*\n\t * Make sure all delayed rcu free inodes are flushed before we\n\t * destroy cache.\n\t */\n\trcu_barrier();\n\tkmem_cache_destroy(isofs_inode_cachep);\n}"
  },
  {
    "function_name": "nit_inodecache(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/isofs/inode.c",
    "lines": "92-102",
    "snippet": "tatic int __init init_inodecache(void)\n{\n\tisofs_inode_cachep = kmem_cache_create(\"isofs_inode_cache\",\n\t\t\t\t\tsizeof(struct iso_inode_info),\n\t\t\t\t\t0, (SLAB_RECLAIM_ACCOUNT|\n\t\t\t\t\tSLAB_MEM_SPREAD),\n\t\t\t\t\tinit_once);\n\tif (isofs_inode_cachep == NULL)\n\t\treturn -ENOMEM;\n\treturn 0;\n}",
    "includes": [
      "include \"zisofs.h\"",
      "include \"isofs.h\"\n#",
      "include <linux/user_namespace.h>",
      "include <linux/mpage.h>\n#",
      "include <linux/parser.h>\n#",
      "include <linux/cdrom.h>\n#",
      "include <linux/statfs.h>\n#",
      "include <linux/ctype.h>\n#",
      "include <linux/nls.h>\n#",
      "include <linux/slab.h>\n#",
      "include <linux/module.h>",
      "include <linux/init.h>\n#"
    ],
    "macros_used": [],
    "globals_used": [
      "tatic struct kmem_cache *isofs_inode_cachep;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mem_cache_create(",
          "args": [
            "isofs_inode_cache\",",
            "izeof(struct iso_inode_info),",
            ",",
            "SLAB_RECLAIM_ACCOUNT|\n\t\t\t\t\tSLAB_MEM_SPREAD),",
            "nit_once)"
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"zisofs.h\"\ninclude \"isofs.h\"\n#\ninclude <linux/user_namespace.h>\ninclude <linux/mpage.h>\n#\ninclude <linux/parser.h>\n#\ninclude <linux/cdrom.h>\n#\ninclude <linux/statfs.h>\n#\ninclude <linux/ctype.h>\n#\ninclude <linux/nls.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/module.h>\ninclude <linux/init.h>\n#\n\ntatic struct kmem_cache *isofs_inode_cachep;\n\ntatic int __init init_inodecache(void)\n{\n\tisofs_inode_cachep = kmem_cache_create(\"isofs_inode_cache\",\n\t\t\t\t\tsizeof(struct iso_inode_info),\n\t\t\t\t\t0, (SLAB_RECLAIM_ACCOUNT|\n\t\t\t\t\tSLAB_MEM_SPREAD),\n\t\t\t\t\tinit_once);\n\tif (isofs_inode_cachep == NULL)\n\t\treturn -ENOMEM;\n\treturn 0;\n}"
  },
  {
    "function_name": "nit_once(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/isofs/inode.c",
    "lines": "85-90",
    "snippet": "tatic void init_once(void *foo)\n{\n\tstruct iso_inode_info *ei = foo;\n\n\tinode_init_once(&ei->vfs_inode);\n}",
    "includes": [
      "include \"zisofs.h\"",
      "include \"isofs.h\"\n#",
      "include <linux/user_namespace.h>",
      "include <linux/mpage.h>\n#",
      "include <linux/parser.h>\n#",
      "include <linux/cdrom.h>\n#",
      "include <linux/statfs.h>\n#",
      "include <linux/ctype.h>\n#",
      "include <linux/nls.h>\n#",
      "include <linux/slab.h>\n#",
      "include <linux/module.h>",
      "include <linux/init.h>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "node_init_once(",
          "args": [
            "ei->vfs_inode)"
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"zisofs.h\"\ninclude \"isofs.h\"\n#\ninclude <linux/user_namespace.h>\ninclude <linux/mpage.h>\n#\ninclude <linux/parser.h>\n#\ninclude <linux/cdrom.h>\n#\ninclude <linux/statfs.h>\n#\ninclude <linux/ctype.h>\n#\ninclude <linux/nls.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/module.h>\ninclude <linux/init.h>\n#\n\ntatic void init_once(void *foo)\n{\n\tstruct iso_inode_info *ei = foo;\n\n\tinode_init_once(&ei->vfs_inode);\n}"
  },
  {
    "function_name": "sofs_destroy_inode(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/isofs/inode.c",
    "lines": "80-83",
    "snippet": "tatic void isofs_destroy_inode(struct inode *inode)\n{\n\tcall_rcu(&inode->i_rcu, isofs_i_callback);\n}",
    "includes": [
      "include \"zisofs.h\"",
      "include \"isofs.h\"\n#",
      "include <linux/user_namespace.h>",
      "include <linux/mpage.h>\n#",
      "include <linux/parser.h>\n#",
      "include <linux/cdrom.h>\n#",
      "include <linux/statfs.h>\n#",
      "include <linux/ctype.h>\n#",
      "include <linux/nls.h>\n#",
      "include <linux/slab.h>\n#",
      "include <linux/module.h>",
      "include <linux/init.h>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "all_rcu(",
          "args": [
            "inode->i_rcu,",
            "sofs_i_callback)"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"zisofs.h\"\ninclude \"isofs.h\"\n#\ninclude <linux/user_namespace.h>\ninclude <linux/mpage.h>\n#\ninclude <linux/parser.h>\n#\ninclude <linux/cdrom.h>\n#\ninclude <linux/statfs.h>\n#\ninclude <linux/ctype.h>\n#\ninclude <linux/nls.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/module.h>\ninclude <linux/init.h>\n#\n\ntatic void isofs_destroy_inode(struct inode *inode)\n{\n\tcall_rcu(&inode->i_rcu, isofs_i_callback);\n}"
  },
  {
    "function_name": "sofs_i_callback(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/isofs/inode.c",
    "lines": "74-78",
    "snippet": "tatic void isofs_i_callback(struct rcu_head *head)\n{\n\tstruct inode *inode = container_of(head, struct inode, i_rcu);\n\tkmem_cache_free(isofs_inode_cachep, ISOFS_I(inode));\n}",
    "includes": [
      "include \"zisofs.h\"",
      "include \"isofs.h\"\n#",
      "include <linux/user_namespace.h>",
      "include <linux/mpage.h>\n#",
      "include <linux/parser.h>\n#",
      "include <linux/cdrom.h>\n#",
      "include <linux/statfs.h>\n#",
      "include <linux/ctype.h>\n#",
      "include <linux/nls.h>\n#",
      "include <linux/slab.h>\n#",
      "include <linux/module.h>",
      "include <linux/init.h>\n#"
    ],
    "macros_used": [],
    "globals_used": [
      "tatic struct kmem_cache *isofs_inode_cachep;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mem_cache_free(",
          "args": [
            "sofs_inode_cachep,",
            "SOFS_I(inode))"
          ],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SOFS_I(",
          "args": [
            "node)"
          ],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ontainer_of(",
          "args": [
            "ead,",
            "truct node,",
            "_rcu)"
          ],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"zisofs.h\"\ninclude \"isofs.h\"\n#\ninclude <linux/user_namespace.h>\ninclude <linux/mpage.h>\n#\ninclude <linux/parser.h>\n#\ninclude <linux/cdrom.h>\n#\ninclude <linux/statfs.h>\n#\ninclude <linux/ctype.h>\n#\ninclude <linux/nls.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/module.h>\ninclude <linux/init.h>\n#\n\ntatic struct kmem_cache *isofs_inode_cachep;\n\ntatic void isofs_i_callback(struct rcu_head *head)\n{\n\tstruct inode *inode = container_of(head, struct inode, i_rcu);\n\tkmem_cache_free(isofs_inode_cachep, ISOFS_I(inode));\n}"
  },
  {
    "function_name": "sofs_alloc_inode(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/isofs/inode.c",
    "lines": "65-72",
    "snippet": "tatic struct inode *isofs_alloc_inode(struct super_block *sb)\n{\n\tstruct iso_inode_info *ei;\n\tei = kmem_cache_alloc(isofs_inode_cachep, GFP_KERNEL);\n\tif (!ei)\n\t\treturn NULL;\n\treturn &ei->vfs_inode;\n}",
    "includes": [
      "include \"zisofs.h\"",
      "include \"isofs.h\"\n#",
      "include <linux/user_namespace.h>",
      "include <linux/mpage.h>\n#",
      "include <linux/parser.h>\n#",
      "include <linux/cdrom.h>\n#",
      "include <linux/statfs.h>\n#",
      "include <linux/ctype.h>\n#",
      "include <linux/nls.h>\n#",
      "include <linux/slab.h>\n#",
      "include <linux/module.h>",
      "include <linux/init.h>\n#"
    ],
    "macros_used": [],
    "globals_used": [
      "tatic struct kmem_cache *isofs_inode_cachep;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mem_cache_alloc(",
          "args": [
            "sofs_inode_cachep,",
            "FP_KERNEL)"
          ],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"zisofs.h\"\ninclude \"isofs.h\"\n#\ninclude <linux/user_namespace.h>\ninclude <linux/mpage.h>\n#\ninclude <linux/parser.h>\n#\ninclude <linux/cdrom.h>\n#\ninclude <linux/statfs.h>\n#\ninclude <linux/ctype.h>\n#\ninclude <linux/nls.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/module.h>\ninclude <linux/init.h>\n#\n\ntatic struct kmem_cache *isofs_inode_cachep;\n\ntatic struct inode *isofs_alloc_inode(struct super_block *sb)\n{\n\tstruct iso_inode_info *ei;\n\tei = kmem_cache_alloc(isofs_inode_cachep, GFP_KERNEL);\n\tif (!ei)\n\t\treturn NULL;\n\treturn &ei->vfs_inode;\n}"
  },
  {
    "function_name": "sofs_put_super(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/isofs/inode.c",
    "lines": "47-58",
    "snippet": "tatic void isofs_put_super(struct super_block *sb)\n{\n\tstruct isofs_sb_info *sbi = ISOFS_SB(sb);\n\n#ifdef CONFIG_JOLIET\n\tunload_nls(sbi->s_nls_iocharset);\n#endif\n\n\tkfree(sbi);\n\tsb->s_fs_info = NULL;\n\treturn;\n}",
    "includes": [
      "include \"zisofs.h\"",
      "include \"isofs.h\"\n#",
      "include <linux/user_namespace.h>",
      "include <linux/mpage.h>\n#",
      "include <linux/parser.h>\n#",
      "include <linux/cdrom.h>\n#",
      "include <linux/statfs.h>\n#",
      "include <linux/ctype.h>\n#",
      "include <linux/nls.h>\n#",
      "include <linux/slab.h>\n#",
      "include <linux/module.h>",
      "include <linux/init.h>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free(",
          "args": [
            "bi)"
          ],
          "line": 55
        },
        "resolved": true,
        "details": {
          "function_name": "in_free(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/scan.c",
          "lines": "51-60",
          "snippet": "tatic inline int min_free(struct jffs2_sb_info *c)\n{\n\tuint32_t min = 2 * sizeof(struct jffs2_raw_inode);\n#ifdef CONFIG_JFFS2_FS_WRITEBUFFER\n\tif (!jffs2_can_mark_obsolete(c) && min < c->wbuf_pagesize)\n\t\treturn c->wbuf_pagesize;\n#endif\n\treturn min;\n\n}",
          "includes": [
            "include \"debug.h\"",
            "include \"summary.h\"\n#",
            "include \"nodelist.h\"\n#",
            "include <linux/compiler.h>\n#",
            "include <linux/crc32.h>\n#",
            "include <linux/pagemap.h>\n#",
            "include <linux/mtd/mtd.h>\n#",
            "include <linux/slab.h>\n#",
            "include <linux/sched.h>\n#",
            "include <linux/kernel.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"debug.h\"\ninclude \"summary.h\"\n#\ninclude \"nodelist.h\"\n#\ninclude <linux/compiler.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/pagemap.h>\n#\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/sched.h>\n#\ninclude <linux/kernel.h>\n#\n\ntatic inline int min_free(struct jffs2_sb_info *c)\n{\n\tuint32_t min = 2 * sizeof(struct jffs2_raw_inode);\n#ifdef CONFIG_JFFS2_FS_WRITEBUFFER\n\tif (!jffs2_can_mark_obsolete(c) && min < c->wbuf_pagesize)\n\t\treturn c->wbuf_pagesize;\n#endif\n\treturn min;\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "nload_nls(",
          "args": [
            "bi->s_nls_iocharset)"
          ],
          "line": 52
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SOFS_SB(",
          "args": [
            "b)"
          ],
          "line": 49
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"zisofs.h\"\ninclude \"isofs.h\"\n#\ninclude <linux/user_namespace.h>\ninclude <linux/mpage.h>\n#\ninclude <linux/parser.h>\n#\ninclude <linux/cdrom.h>\n#\ninclude <linux/statfs.h>\n#\ninclude <linux/ctype.h>\n#\ninclude <linux/nls.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/module.h>\ninclude <linux/init.h>\n#\n\ntatic void isofs_put_super(struct super_block *sb)\n{\n\tstruct isofs_sb_info *sbi = ISOFS_SB(sb);\n\n#ifdef CONFIG_JOLIET\n\tunload_nls(sbi->s_nls_iocharset);\n#endif\n\n\tkfree(sbi);\n\tsb->s_fs_info = NULL;\n\treturn;\n}"
  }
]