[
  {
    "function_name": "debugfs_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/debugfs/inode.c",
    "lines": "719-734",
    "snippet": "static int __init debugfs_init(void)\n{\n\tint retval;\n\n\tdebug_kobj = kobject_create_and_add(\"debug\", kernel_kobj);\n\tif (!debug_kobj)\n\t\treturn -EINVAL;\n\n\tretval = register_filesystem(&debug_fs_type);\n\tif (retval)\n\t\tkobject_put(debug_kobj);\n\telse\n\t\tdebugfs_registered = true;\n\n\treturn retval;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/magic.h>",
      "#include <linux/parser.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/string.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/kobject.h>",
      "#include <linux/init.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool debugfs_registered;",
      "static struct file_system_type debug_fs_type = {\n\t.owner =\tTHIS_MODULE,\n\t.name =\t\t\"debugfs\",\n\t.mount =\tdebug_mount,\n\t.kill_sb =\tkill_litter_super,\n};",
      "static struct kobject *debug_kobj;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kobject_put",
          "args": [
            "debug_kobj"
          ],
          "line": 729
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "register_filesystem",
          "args": [
            "&debug_fs_type"
          ],
          "line": 727
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_filesystem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/filesystems.c",
          "lines": "101-120",
          "snippet": "int unregister_filesystem(struct file_system_type * fs)\n{\n\tstruct file_system_type ** tmp;\n\n\twrite_lock(&file_systems_lock);\n\ttmp = &file_systems;\n\twhile (*tmp) {\n\t\tif (fs == *tmp) {\n\t\t\t*tmp = fs->next;\n\t\t\tfs->next = NULL;\n\t\t\twrite_unlock(&file_systems_lock);\n\t\t\tsynchronize_rcu();\n\t\t\treturn 0;\n\t\t}\n\t\ttmp = &(*tmp)->next;\n\t}\n\twrite_unlock(&file_systems_lock);\n\n\treturn -EINVAL;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kmod.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct file_system_type *file_systems;",
            "static DEFINE_RWLOCK(file_systems_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kmod.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n\nstatic struct file_system_type *file_systems;\nstatic DEFINE_RWLOCK(file_systems_lock);\n\nint unregister_filesystem(struct file_system_type * fs)\n{\n\tstruct file_system_type ** tmp;\n\n\twrite_lock(&file_systems_lock);\n\ttmp = &file_systems;\n\twhile (*tmp) {\n\t\tif (fs == *tmp) {\n\t\t\t*tmp = fs->next;\n\t\t\tfs->next = NULL;\n\t\t\twrite_unlock(&file_systems_lock);\n\t\t\tsynchronize_rcu();\n\t\t\treturn 0;\n\t\t}\n\t\ttmp = &(*tmp)->next;\n\t}\n\twrite_unlock(&file_systems_lock);\n\n\treturn -EINVAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kobject_create_and_add",
          "args": [
            "\"debug\"",
            "kernel_kobj"
          ],
          "line": 723
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/parser.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fsnotify.h>\n#include <linux/debugfs.h>\n#include <linux/namei.h>\n#include <linux/kobject.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic bool debugfs_registered;\nstatic struct file_system_type debug_fs_type = {\n\t.owner =\tTHIS_MODULE,\n\t.name =\t\t\"debugfs\",\n\t.mount =\tdebug_mount,\n\t.kill_sb =\tkill_litter_super,\n};\nstatic struct kobject *debug_kobj;\n\nstatic int __init debugfs_init(void)\n{\n\tint retval;\n\n\tdebug_kobj = kobject_create_and_add(\"debug\", kernel_kobj);\n\tif (!debug_kobj)\n\t\treturn -EINVAL;\n\n\tretval = register_filesystem(&debug_fs_type);\n\tif (retval)\n\t\tkobject_put(debug_kobj);\n\telse\n\t\tdebugfs_registered = true;\n\n\treturn retval;\n}"
  },
  {
    "function_name": "debugfs_initialized",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/debugfs/inode.c",
    "lines": "710-713",
    "snippet": "bool debugfs_initialized(void)\n{\n\treturn debugfs_registered;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/magic.h>",
      "#include <linux/parser.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/string.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/kobject.h>",
      "#include <linux/init.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool debugfs_registered;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/parser.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fsnotify.h>\n#include <linux/debugfs.h>\n#include <linux/namei.h>\n#include <linux/kobject.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic bool debugfs_registered;\n\nbool debugfs_initialized(void)\n{\n\treturn debugfs_registered;\n}"
  },
  {
    "function_name": "debugfs_rename",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/debugfs/inode.c",
    "lines": "663-704",
    "snippet": "struct dentry *debugfs_rename(struct dentry *old_dir, struct dentry *old_dentry,\n\t\tstruct dentry *new_dir, const char *new_name)\n{\n\tint error;\n\tstruct dentry *dentry = NULL, *trap;\n\tconst char *old_name;\n\n\ttrap = lock_rename(new_dir, old_dir);\n\t/* Source or destination directories don't exist? */\n\tif (!old_dir->d_inode || !new_dir->d_inode)\n\t\tgoto exit;\n\t/* Source does not exist, cyclic rename, or mountpoint? */\n\tif (!old_dentry->d_inode || old_dentry == trap ||\n\t    d_mountpoint(old_dentry))\n\t\tgoto exit;\n\tdentry = lookup_one_len(new_name, new_dir, strlen(new_name));\n\t/* Lookup failed, cyclic rename or target exists? */\n\tif (IS_ERR(dentry) || dentry == trap || dentry->d_inode)\n\t\tgoto exit;\n\n\told_name = fsnotify_oldname_init(old_dentry->d_name.name);\n\n\terror = simple_rename(old_dir->d_inode, old_dentry, new_dir->d_inode,\n\t\tdentry);\n\tif (error) {\n\t\tfsnotify_oldname_free(old_name);\n\t\tgoto exit;\n\t}\n\td_move(old_dentry, dentry);\n\tfsnotify_move(old_dir->d_inode, new_dir->d_inode, old_name,\n\t\td_is_dir(old_dentry),\n\t\tNULL, old_dentry);\n\tfsnotify_oldname_free(old_name);\n\tunlock_rename(new_dir, old_dir);\n\tdput(dentry);\n\treturn old_dentry;\nexit:\n\tif (dentry && !IS_ERR(dentry))\n\t\tdput(dentry);\n\tunlock_rename(new_dir, old_dir);\n\treturn NULL;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/magic.h>",
      "#include <linux/parser.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/string.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/kobject.h>",
      "#include <linux/init.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_rename",
          "args": [
            "new_dir",
            "old_dir"
          ],
          "line": 702
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_rename",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "2537-2544",
          "snippet": "void unlock_rename(struct dentry *p1, struct dentry *p2)\n{\n\tmutex_unlock(&p1->d_inode->i_mutex);\n\tif (p1 != p2) {\n\t\tmutex_unlock(&p2->d_inode->i_mutex);\n\t\tmutex_unlock(&p1->d_inode->i_sb->s_vfs_rename_mutex);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nvoid unlock_rename(struct dentry *p1, struct dentry *p2)\n{\n\tmutex_unlock(&p1->d_inode->i_mutex);\n\tif (p1 != p2) {\n\t\tmutex_unlock(&p2->d_inode->i_mutex);\n\t\tmutex_unlock(&p1->d_inode->i_sb->s_vfs_rename_mutex);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "dentry"
          ],
          "line": 701
        },
        "resolved": true,
        "details": {
          "function_name": "dput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "726-762",
          "snippet": "void dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "dentry"
          ],
          "line": 700
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fsnotify_oldname_free",
          "args": [
            "old_name"
          ],
          "line": 695
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fsnotify_move",
          "args": [
            "old_dir->d_inode",
            "new_dir->d_inode",
            "old_name",
            "d_is_dir(old_dentry)",
            "NULL",
            "old_dentry"
          ],
          "line": 692
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_is_dir",
          "args": [
            "old_dentry"
          ],
          "line": 693
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_move",
          "args": [
            "old_dentry",
            "dentry"
          ],
          "line": 691
        },
        "resolved": true,
        "details": {
          "function_name": "d_move",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "2634-2639",
          "snippet": "void d_move(struct dentry *dentry, struct dentry *target)\n{\n\twrite_seqlock(&rename_lock);\n\t__d_move(dentry, target, false);\n\twrite_sequnlock(&rename_lock);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SEQLOCK(rename_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\n__cacheline_aligned_in_smp DEFINE_SEQLOCK(rename_lock);\n\nvoid d_move(struct dentry *dentry, struct dentry *target)\n{\n\twrite_seqlock(&rename_lock);\n\t__d_move(dentry, target, false);\n\twrite_sequnlock(&rename_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fsnotify_oldname_free",
          "args": [
            "old_name"
          ],
          "line": 688
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "simple_rename",
          "args": [
            "old_dir->d_inode",
            "old_dentry",
            "new_dir->d_inode",
            "dentry"
          ],
          "line": 685
        },
        "resolved": true,
        "details": {
          "function_name": "simple_rename",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/libfs.c",
          "lines": "328-352",
          "snippet": "int simple_rename(struct inode *old_dir, struct dentry *old_dentry,\n\t\tstruct inode *new_dir, struct dentry *new_dentry)\n{\n\tstruct inode *inode = old_dentry->d_inode;\n\tint they_are_dirs = d_is_dir(old_dentry);\n\n\tif (!simple_empty(new_dentry))\n\t\treturn -ENOTEMPTY;\n\n\tif (new_dentry->d_inode) {\n\t\tsimple_unlink(new_dir, new_dentry);\n\t\tif (they_are_dirs) {\n\t\t\tdrop_nlink(new_dentry->d_inode);\n\t\t\tdrop_nlink(old_dir);\n\t\t}\n\t} else if (they_are_dirs) {\n\t\tdrop_nlink(old_dir);\n\t\tinc_nlink(new_dir);\n\t}\n\n\told_dir->i_ctime = old_dir->i_mtime = new_dir->i_ctime =\n\t\tnew_dir->i_mtime = inode->i_ctime = CURRENT_TIME;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nint simple_rename(struct inode *old_dir, struct dentry *old_dentry,\n\t\tstruct inode *new_dir, struct dentry *new_dentry)\n{\n\tstruct inode *inode = old_dentry->d_inode;\n\tint they_are_dirs = d_is_dir(old_dentry);\n\n\tif (!simple_empty(new_dentry))\n\t\treturn -ENOTEMPTY;\n\n\tif (new_dentry->d_inode) {\n\t\tsimple_unlink(new_dir, new_dentry);\n\t\tif (they_are_dirs) {\n\t\t\tdrop_nlink(new_dentry->d_inode);\n\t\t\tdrop_nlink(old_dir);\n\t\t}\n\t} else if (they_are_dirs) {\n\t\tdrop_nlink(old_dir);\n\t\tinc_nlink(new_dir);\n\t}\n\n\told_dir->i_ctime = old_dir->i_mtime = new_dir->i_ctime =\n\t\tnew_dir->i_mtime = inode->i_ctime = CURRENT_TIME;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fsnotify_oldname_init",
          "args": [
            "old_dentry->d_name.name"
          ],
          "line": 683
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "dentry"
          ],
          "line": 680
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lookup_one_len",
          "args": [
            "new_name",
            "new_dir",
            "strlen(new_name)"
          ],
          "line": 678
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_one_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "2145-2184",
          "snippet": "struct dentry *lookup_one_len(const char *name, struct dentry *base, int len)\n{\n\tstruct qstr this;\n\tunsigned int c;\n\tint err;\n\n\tWARN_ON_ONCE(!mutex_is_locked(&base->d_inode->i_mutex));\n\n\tthis.name = name;\n\tthis.len = len;\n\tthis.hash = full_name_hash(name, len);\n\tif (!len)\n\t\treturn ERR_PTR(-EACCES);\n\n\tif (unlikely(name[0] == '.')) {\n\t\tif (len < 2 || (len == 2 && name[1] == '.'))\n\t\t\treturn ERR_PTR(-EACCES);\n\t}\n\n\twhile (len--) {\n\t\tc = *(const unsigned char *)name++;\n\t\tif (c == '/' || c == '\\0')\n\t\t\treturn ERR_PTR(-EACCES);\n\t}\n\t/*\n\t * See if the low-level filesystem might want\n\t * to use its own hash..\n\t */\n\tif (base->d_flags & DCACHE_OP_HASH) {\n\t\tint err = base->d_op->d_hash(base, &this);\n\t\tif (err < 0)\n\t\t\treturn ERR_PTR(err);\n\t}\n\n\terr = inode_permission(base->d_inode, MAY_EXEC);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\treturn __lookup_hash(&this, base, 0);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nstruct dentry *lookup_one_len(const char *name, struct dentry *base, int len)\n{\n\tstruct qstr this;\n\tunsigned int c;\n\tint err;\n\n\tWARN_ON_ONCE(!mutex_is_locked(&base->d_inode->i_mutex));\n\n\tthis.name = name;\n\tthis.len = len;\n\tthis.hash = full_name_hash(name, len);\n\tif (!len)\n\t\treturn ERR_PTR(-EACCES);\n\n\tif (unlikely(name[0] == '.')) {\n\t\tif (len < 2 || (len == 2 && name[1] == '.'))\n\t\t\treturn ERR_PTR(-EACCES);\n\t}\n\n\twhile (len--) {\n\t\tc = *(const unsigned char *)name++;\n\t\tif (c == '/' || c == '\\0')\n\t\t\treturn ERR_PTR(-EACCES);\n\t}\n\t/*\n\t * See if the low-level filesystem might want\n\t * to use its own hash..\n\t */\n\tif (base->d_flags & DCACHE_OP_HASH) {\n\t\tint err = base->d_op->d_hash(base, &this);\n\t\tif (err < 0)\n\t\t\treturn ERR_PTR(err);\n\t}\n\n\terr = inode_permission(base->d_inode, MAY_EXEC);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\treturn __lookup_hash(&this, base, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "new_name"
          ],
          "line": 678
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_mountpoint",
          "args": [
            "old_dentry"
          ],
          "line": 676
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/parser.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fsnotify.h>\n#include <linux/debugfs.h>\n#include <linux/namei.h>\n#include <linux/kobject.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstruct dentry *debugfs_rename(struct dentry *old_dir, struct dentry *old_dentry,\n\t\tstruct dentry *new_dir, const char *new_name)\n{\n\tint error;\n\tstruct dentry *dentry = NULL, *trap;\n\tconst char *old_name;\n\n\ttrap = lock_rename(new_dir, old_dir);\n\t/* Source or destination directories don't exist? */\n\tif (!old_dir->d_inode || !new_dir->d_inode)\n\t\tgoto exit;\n\t/* Source does not exist, cyclic rename, or mountpoint? */\n\tif (!old_dentry->d_inode || old_dentry == trap ||\n\t    d_mountpoint(old_dentry))\n\t\tgoto exit;\n\tdentry = lookup_one_len(new_name, new_dir, strlen(new_name));\n\t/* Lookup failed, cyclic rename or target exists? */\n\tif (IS_ERR(dentry) || dentry == trap || dentry->d_inode)\n\t\tgoto exit;\n\n\told_name = fsnotify_oldname_init(old_dentry->d_name.name);\n\n\terror = simple_rename(old_dir->d_inode, old_dentry, new_dir->d_inode,\n\t\tdentry);\n\tif (error) {\n\t\tfsnotify_oldname_free(old_name);\n\t\tgoto exit;\n\t}\n\td_move(old_dentry, dentry);\n\tfsnotify_move(old_dir->d_inode, new_dir->d_inode, old_name,\n\t\td_is_dir(old_dentry),\n\t\tNULL, old_dentry);\n\tfsnotify_oldname_free(old_name);\n\tunlock_rename(new_dir, old_dir);\n\tdput(dentry);\n\treturn old_dentry;\nexit:\n\tif (dentry && !IS_ERR(dentry))\n\t\tdput(dentry);\n\tunlock_rename(new_dir, old_dir);\n\treturn NULL;\n}"
  },
  {
    "function_name": "debugfs_remove_recursive",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/debugfs/inode.c",
    "lines": "580-641",
    "snippet": "void debugfs_remove_recursive(struct dentry *dentry)\n{\n\tstruct dentry *child, *parent;\n\n\tif (IS_ERR_OR_NULL(dentry))\n\t\treturn;\n\n\tparent = dentry->d_parent;\n\tif (!parent || !parent->d_inode)\n\t\treturn;\n\n\tparent = dentry;\n down:\n\tmutex_lock(&parent->d_inode->i_mutex);\n loop:\n\t/*\n\t * The parent->d_subdirs is protected by the d_lock. Outside that\n\t * lock, the child can be unlinked and set to be freed which can\n\t * use the d_u.d_child as the rcu head and corrupt this list.\n\t */\n\tspin_lock(&parent->d_lock);\n\tlist_for_each_entry(child, &parent->d_subdirs, d_child) {\n\t\tif (!debugfs_positive(child))\n\t\t\tcontinue;\n\n\t\t/* perhaps simple_empty(child) makes more sense */\n\t\tif (!list_empty(&child->d_subdirs)) {\n\t\t\tspin_unlock(&parent->d_lock);\n\t\t\tmutex_unlock(&parent->d_inode->i_mutex);\n\t\t\tparent = child;\n\t\t\tgoto down;\n\t\t}\n\n\t\tspin_unlock(&parent->d_lock);\n\n\t\tif (!__debugfs_remove(child, parent))\n\t\t\tsimple_release_fs(&debugfs_mount, &debugfs_mount_count);\n\n\t\t/*\n\t\t * The parent->d_lock protects agaist child from unlinking\n\t\t * from d_subdirs. When releasing the parent->d_lock we can\n\t\t * no longer trust that the next pointer is valid.\n\t\t * Restart the loop. We'll skip this one with the\n\t\t * debugfs_positive() check.\n\t\t */\n\t\tgoto loop;\n\t}\n\tspin_unlock(&parent->d_lock);\n\n\tmutex_unlock(&parent->d_inode->i_mutex);\n\tchild = parent;\n\tparent = parent->d_parent;\n\tmutex_lock(&parent->d_inode->i_mutex);\n\n\tif (child != dentry)\n\t\t/* go up */\n\t\tgoto loop;\n\n\tif (!__debugfs_remove(child, parent))\n\t\tsimple_release_fs(&debugfs_mount, &debugfs_mount_count);\n\tmutex_unlock(&parent->d_inode->i_mutex);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/magic.h>",
      "#include <linux/parser.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/string.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/kobject.h>",
      "#include <linux/init.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct vfsmount *debugfs_mount;",
      "static int debugfs_mount_count;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&parent->d_inode->i_mutex"
          ],
          "line": 640
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "simple_release_fs",
          "args": [
            "&debugfs_mount",
            "&debugfs_mount_count"
          ],
          "line": 639
        },
        "resolved": true,
        "details": {
          "function_name": "simple_release_fs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/libfs.c",
          "lines": "564-573",
          "snippet": "void simple_release_fs(struct vfsmount **mount, int *count)\n{\n\tstruct vfsmount *mnt;\n\tspin_lock(&pin_fs_lock);\n\tmnt = *mount;\n\tif (!--*count)\n\t\t*mount = NULL;\n\tspin_unlock(&pin_fs_lock);\n\tmntput(mnt);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(pin_fs_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nstatic DEFINE_SPINLOCK(pin_fs_lock);\n\nvoid simple_release_fs(struct vfsmount **mount, int *count)\n{\n\tstruct vfsmount *mnt;\n\tspin_lock(&pin_fs_lock);\n\tmnt = *mount;\n\tif (!--*count)\n\t\t*mount = NULL;\n\tspin_unlock(&pin_fs_lock);\n\tmntput(mnt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__debugfs_remove",
          "args": [
            "child",
            "parent"
          ],
          "line": 638
        },
        "resolved": true,
        "details": {
          "function_name": "__debugfs_remove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/debugfs/inode.c",
          "lines": "518-533",
          "snippet": "static int __debugfs_remove(struct dentry *dentry, struct dentry *parent)\n{\n\tint ret = 0;\n\n\tif (debugfs_positive(dentry)) {\n\t\tdget(dentry);\n\t\tif (S_ISDIR(dentry->d_inode->i_mode))\n\t\t\tret = simple_rmdir(parent->d_inode, dentry);\n\t\telse\n\t\t\tsimple_unlink(parent->d_inode, dentry);\n\t\tif (!ret)\n\t\t\td_delete(dentry);\n\t\tdput(dentry);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/magic.h>",
            "#include <linux/parser.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/string.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/kobject.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/parser.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fsnotify.h>\n#include <linux/debugfs.h>\n#include <linux/namei.h>\n#include <linux/kobject.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int __debugfs_remove(struct dentry *dentry, struct dentry *parent)\n{\n\tint ret = 0;\n\n\tif (debugfs_positive(dentry)) {\n\t\tdget(dentry);\n\t\tif (S_ISDIR(dentry->d_inode->i_mode))\n\t\t\tret = simple_rmdir(parent->d_inode, dentry);\n\t\telse\n\t\t\tsimple_unlink(parent->d_inode, dentry);\n\t\tif (!ret)\n\t\t\td_delete(dentry);\n\t\tdput(dentry);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&parent->d_inode->i_mutex"
          ],
          "line": 632
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&parent->d_inode->i_mutex"
          ],
          "line": 629
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&parent->d_lock"
          ],
          "line": 627
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&parent->d_inode->i_mutex"
          ],
          "line": 608
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&child->d_subdirs"
          ],
          "line": 606
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "debugfs_positive",
          "args": [
            "child"
          ],
          "line": 602
        },
        "resolved": true,
        "details": {
          "function_name": "debugfs_positive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/debugfs/inode.c",
          "lines": "47-50",
          "snippet": "static inline int debugfs_positive(struct dentry *dentry)\n{\n\treturn dentry->d_inode && !d_unhashed(dentry);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/magic.h>",
            "#include <linux/parser.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/string.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/kobject.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/parser.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fsnotify.h>\n#include <linux/debugfs.h>\n#include <linux/namei.h>\n#include <linux/kobject.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic inline int debugfs_positive(struct dentry *dentry)\n{\n\treturn dentry->d_inode && !d_unhashed(dentry);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "child",
            "&parent->d_subdirs",
            "d_child"
          ],
          "line": 601
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&parent->d_lock"
          ],
          "line": 600
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&parent->d_inode->i_mutex"
          ],
          "line": 593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR_OR_NULL",
          "args": [
            "dentry"
          ],
          "line": 584
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/parser.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fsnotify.h>\n#include <linux/debugfs.h>\n#include <linux/namei.h>\n#include <linux/kobject.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic struct vfsmount *debugfs_mount;\nstatic int debugfs_mount_count;\n\nvoid debugfs_remove_recursive(struct dentry *dentry)\n{\n\tstruct dentry *child, *parent;\n\n\tif (IS_ERR_OR_NULL(dentry))\n\t\treturn;\n\n\tparent = dentry->d_parent;\n\tif (!parent || !parent->d_inode)\n\t\treturn;\n\n\tparent = dentry;\n down:\n\tmutex_lock(&parent->d_inode->i_mutex);\n loop:\n\t/*\n\t * The parent->d_subdirs is protected by the d_lock. Outside that\n\t * lock, the child can be unlinked and set to be freed which can\n\t * use the d_u.d_child as the rcu head and corrupt this list.\n\t */\n\tspin_lock(&parent->d_lock);\n\tlist_for_each_entry(child, &parent->d_subdirs, d_child) {\n\t\tif (!debugfs_positive(child))\n\t\t\tcontinue;\n\n\t\t/* perhaps simple_empty(child) makes more sense */\n\t\tif (!list_empty(&child->d_subdirs)) {\n\t\t\tspin_unlock(&parent->d_lock);\n\t\t\tmutex_unlock(&parent->d_inode->i_mutex);\n\t\t\tparent = child;\n\t\t\tgoto down;\n\t\t}\n\n\t\tspin_unlock(&parent->d_lock);\n\n\t\tif (!__debugfs_remove(child, parent))\n\t\t\tsimple_release_fs(&debugfs_mount, &debugfs_mount_count);\n\n\t\t/*\n\t\t * The parent->d_lock protects agaist child from unlinking\n\t\t * from d_subdirs. When releasing the parent->d_lock we can\n\t\t * no longer trust that the next pointer is valid.\n\t\t * Restart the loop. We'll skip this one with the\n\t\t * debugfs_positive() check.\n\t\t */\n\t\tgoto loop;\n\t}\n\tspin_unlock(&parent->d_lock);\n\n\tmutex_unlock(&parent->d_inode->i_mutex);\n\tchild = parent;\n\tparent = parent->d_parent;\n\tmutex_lock(&parent->d_inode->i_mutex);\n\n\tif (child != dentry)\n\t\t/* go up */\n\t\tgoto loop;\n\n\tif (!__debugfs_remove(child, parent))\n\t\tsimple_release_fs(&debugfs_mount, &debugfs_mount_count);\n\tmutex_unlock(&parent->d_inode->i_mutex);\n}"
  },
  {
    "function_name": "debugfs_remove",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/debugfs/inode.c",
    "lines": "548-565",
    "snippet": "void debugfs_remove(struct dentry *dentry)\n{\n\tstruct dentry *parent;\n\tint ret;\n\n\tif (IS_ERR_OR_NULL(dentry))\n\t\treturn;\n\n\tparent = dentry->d_parent;\n\tif (!parent || !parent->d_inode)\n\t\treturn;\n\n\tmutex_lock(&parent->d_inode->i_mutex);\n\tret = __debugfs_remove(dentry, parent);\n\tmutex_unlock(&parent->d_inode->i_mutex);\n\tif (!ret)\n\t\tsimple_release_fs(&debugfs_mount, &debugfs_mount_count);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/magic.h>",
      "#include <linux/parser.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/string.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/kobject.h>",
      "#include <linux/init.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct vfsmount *debugfs_mount;",
      "static int debugfs_mount_count;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "simple_release_fs",
          "args": [
            "&debugfs_mount",
            "&debugfs_mount_count"
          ],
          "line": 564
        },
        "resolved": true,
        "details": {
          "function_name": "simple_release_fs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/libfs.c",
          "lines": "564-573",
          "snippet": "void simple_release_fs(struct vfsmount **mount, int *count)\n{\n\tstruct vfsmount *mnt;\n\tspin_lock(&pin_fs_lock);\n\tmnt = *mount;\n\tif (!--*count)\n\t\t*mount = NULL;\n\tspin_unlock(&pin_fs_lock);\n\tmntput(mnt);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(pin_fs_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nstatic DEFINE_SPINLOCK(pin_fs_lock);\n\nvoid simple_release_fs(struct vfsmount **mount, int *count)\n{\n\tstruct vfsmount *mnt;\n\tspin_lock(&pin_fs_lock);\n\tmnt = *mount;\n\tif (!--*count)\n\t\t*mount = NULL;\n\tspin_unlock(&pin_fs_lock);\n\tmntput(mnt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&parent->d_inode->i_mutex"
          ],
          "line": 562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__debugfs_remove",
          "args": [
            "dentry",
            "parent"
          ],
          "line": 561
        },
        "resolved": true,
        "details": {
          "function_name": "__debugfs_remove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/debugfs/inode.c",
          "lines": "518-533",
          "snippet": "static int __debugfs_remove(struct dentry *dentry, struct dentry *parent)\n{\n\tint ret = 0;\n\n\tif (debugfs_positive(dentry)) {\n\t\tdget(dentry);\n\t\tif (S_ISDIR(dentry->d_inode->i_mode))\n\t\t\tret = simple_rmdir(parent->d_inode, dentry);\n\t\telse\n\t\t\tsimple_unlink(parent->d_inode, dentry);\n\t\tif (!ret)\n\t\t\td_delete(dentry);\n\t\tdput(dentry);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/magic.h>",
            "#include <linux/parser.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/string.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/kobject.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/parser.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fsnotify.h>\n#include <linux/debugfs.h>\n#include <linux/namei.h>\n#include <linux/kobject.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int __debugfs_remove(struct dentry *dentry, struct dentry *parent)\n{\n\tint ret = 0;\n\n\tif (debugfs_positive(dentry)) {\n\t\tdget(dentry);\n\t\tif (S_ISDIR(dentry->d_inode->i_mode))\n\t\t\tret = simple_rmdir(parent->d_inode, dentry);\n\t\telse\n\t\t\tsimple_unlink(parent->d_inode, dentry);\n\t\tif (!ret)\n\t\t\td_delete(dentry);\n\t\tdput(dentry);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&parent->d_inode->i_mutex"
          ],
          "line": 560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR_OR_NULL",
          "args": [
            "dentry"
          ],
          "line": 553
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/parser.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fsnotify.h>\n#include <linux/debugfs.h>\n#include <linux/namei.h>\n#include <linux/kobject.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic struct vfsmount *debugfs_mount;\nstatic int debugfs_mount_count;\n\nvoid debugfs_remove(struct dentry *dentry)\n{\n\tstruct dentry *parent;\n\tint ret;\n\n\tif (IS_ERR_OR_NULL(dentry))\n\t\treturn;\n\n\tparent = dentry->d_parent;\n\tif (!parent || !parent->d_inode)\n\t\treturn;\n\n\tmutex_lock(&parent->d_inode->i_mutex);\n\tret = __debugfs_remove(dentry, parent);\n\tmutex_unlock(&parent->d_inode->i_mutex);\n\tif (!ret)\n\t\tsimple_release_fs(&debugfs_mount, &debugfs_mount_count);\n}"
  },
  {
    "function_name": "__debugfs_remove",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/debugfs/inode.c",
    "lines": "518-533",
    "snippet": "static int __debugfs_remove(struct dentry *dentry, struct dentry *parent)\n{\n\tint ret = 0;\n\n\tif (debugfs_positive(dentry)) {\n\t\tdget(dentry);\n\t\tif (S_ISDIR(dentry->d_inode->i_mode))\n\t\t\tret = simple_rmdir(parent->d_inode, dentry);\n\t\telse\n\t\t\tsimple_unlink(parent->d_inode, dentry);\n\t\tif (!ret)\n\t\t\td_delete(dentry);\n\t\tdput(dentry);\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/magic.h>",
      "#include <linux/parser.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/string.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/kobject.h>",
      "#include <linux/init.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "dentry"
          ],
          "line": 530
        },
        "resolved": true,
        "details": {
          "function_name": "dput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "726-762",
          "snippet": "void dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_delete",
          "args": [
            "dentry"
          ],
          "line": 529
        },
        "resolved": true,
        "details": {
          "function_name": "d_delete",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "2350-2379",
          "snippet": "void d_delete(struct dentry * dentry)\n{\n\tstruct inode *inode;\n\tint isdir = 0;\n\t/*\n\t * Are we the only user?\n\t */\nagain:\n\tspin_lock(&dentry->d_lock);\n\tinode = dentry->d_inode;\n\tisdir = S_ISDIR(inode->i_mode);\n\tif (dentry->d_lockref.count == 1) {\n\t\tif (!spin_trylock(&inode->i_lock)) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tcpu_relax();\n\t\t\tgoto again;\n\t\t}\n\t\tdentry->d_flags &= ~DCACHE_CANT_MOUNT;\n\t\tdentry_unlink_inode(dentry);\n\t\tfsnotify_nameremove(dentry, isdir);\n\t\treturn;\n\t}\n\n\tif (!d_unhashed(dentry))\n\t\t__d_drop(dentry);\n\n\tspin_unlock(&dentry->d_lock);\n\n\tfsnotify_nameremove(dentry, isdir);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid d_delete(struct dentry * dentry)\n{\n\tstruct inode *inode;\n\tint isdir = 0;\n\t/*\n\t * Are we the only user?\n\t */\nagain:\n\tspin_lock(&dentry->d_lock);\n\tinode = dentry->d_inode;\n\tisdir = S_ISDIR(inode->i_mode);\n\tif (dentry->d_lockref.count == 1) {\n\t\tif (!spin_trylock(&inode->i_lock)) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tcpu_relax();\n\t\t\tgoto again;\n\t\t}\n\t\tdentry->d_flags &= ~DCACHE_CANT_MOUNT;\n\t\tdentry_unlink_inode(dentry);\n\t\tfsnotify_nameremove(dentry, isdir);\n\t\treturn;\n\t}\n\n\tif (!d_unhashed(dentry))\n\t\t__d_drop(dentry);\n\n\tspin_unlock(&dentry->d_lock);\n\n\tfsnotify_nameremove(dentry, isdir);\n}"
        }
      },
      {
        "call_info": {
          "callee": "simple_unlink",
          "args": [
            "parent->d_inode",
            "dentry"
          ],
          "line": 527
        },
        "resolved": true,
        "details": {
          "function_name": "simple_unlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/libfs.c",
          "lines": "305-313",
          "snippet": "int simple_unlink(struct inode *dir, struct dentry *dentry)\n{\n\tstruct inode *inode = dentry->d_inode;\n\n\tinode->i_ctime = dir->i_ctime = dir->i_mtime = CURRENT_TIME;\n\tdrop_nlink(inode);\n\tdput(dentry);\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nint simple_unlink(struct inode *dir, struct dentry *dentry)\n{\n\tstruct inode *inode = dentry->d_inode;\n\n\tinode->i_ctime = dir->i_ctime = dir->i_mtime = CURRENT_TIME;\n\tdrop_nlink(inode);\n\tdput(dentry);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "simple_rmdir",
          "args": [
            "parent->d_inode",
            "dentry"
          ],
          "line": 525
        },
        "resolved": true,
        "details": {
          "function_name": "simple_rmdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/libfs.c",
          "lines": "316-325",
          "snippet": "int simple_rmdir(struct inode *dir, struct dentry *dentry)\n{\n\tif (!simple_empty(dentry))\n\t\treturn -ENOTEMPTY;\n\n\tdrop_nlink(dentry->d_inode);\n\tsimple_unlink(dir, dentry);\n\tdrop_nlink(dir);\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nint simple_rmdir(struct inode *dir, struct dentry *dentry)\n{\n\tif (!simple_empty(dentry))\n\t\treturn -ENOTEMPTY;\n\n\tdrop_nlink(dentry->d_inode);\n\tsimple_unlink(dir, dentry);\n\tdrop_nlink(dir);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "dentry->d_inode->i_mode"
          ],
          "line": 524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dget",
          "args": [
            "dentry"
          ],
          "line": 523
        },
        "resolved": true,
        "details": {
          "function_name": "dget_parent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "777-814",
          "snippet": "struct dentry *dget_parent(struct dentry *dentry)\n{\n\tint gotref;\n\tstruct dentry *ret;\n\n\t/*\n\t * Do optimistic parent lookup without any\n\t * locking.\n\t */\n\trcu_read_lock();\n\tret = ACCESS_ONCE(dentry->d_parent);\n\tgotref = lockref_get_not_zero(&ret->d_lockref);\n\trcu_read_unlock();\n\tif (likely(gotref)) {\n\t\tif (likely(ret == ACCESS_ONCE(dentry->d_parent)))\n\t\t\treturn ret;\n\t\tdput(ret);\n\t}\n\nrepeat:\n\t/*\n\t * Don't need rcu_dereference because we re-check it was correct under\n\t * the lock.\n\t */\n\trcu_read_lock();\n\tret = dentry->d_parent;\n\tspin_lock(&ret->d_lock);\n\tif (unlikely(ret != dentry->d_parent)) {\n\t\tspin_unlock(&ret->d_lock);\n\t\trcu_read_unlock();\n\t\tgoto repeat;\n\t}\n\trcu_read_unlock();\n\tBUG_ON(!ret->d_lockref.count);\n\tret->d_lockref.count++;\n\tspin_unlock(&ret->d_lock);\n\treturn ret;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstruct dentry *dget_parent(struct dentry *dentry)\n{\n\tint gotref;\n\tstruct dentry *ret;\n\n\t/*\n\t * Do optimistic parent lookup without any\n\t * locking.\n\t */\n\trcu_read_lock();\n\tret = ACCESS_ONCE(dentry->d_parent);\n\tgotref = lockref_get_not_zero(&ret->d_lockref);\n\trcu_read_unlock();\n\tif (likely(gotref)) {\n\t\tif (likely(ret == ACCESS_ONCE(dentry->d_parent)))\n\t\t\treturn ret;\n\t\tdput(ret);\n\t}\n\nrepeat:\n\t/*\n\t * Don't need rcu_dereference because we re-check it was correct under\n\t * the lock.\n\t */\n\trcu_read_lock();\n\tret = dentry->d_parent;\n\tspin_lock(&ret->d_lock);\n\tif (unlikely(ret != dentry->d_parent)) {\n\t\tspin_unlock(&ret->d_lock);\n\t\trcu_read_unlock();\n\t\tgoto repeat;\n\t}\n\trcu_read_unlock();\n\tBUG_ON(!ret->d_lockref.count);\n\tret->d_lockref.count++;\n\tspin_unlock(&ret->d_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "debugfs_positive",
          "args": [
            "dentry"
          ],
          "line": 522
        },
        "resolved": true,
        "details": {
          "function_name": "debugfs_positive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/debugfs/inode.c",
          "lines": "47-50",
          "snippet": "static inline int debugfs_positive(struct dentry *dentry)\n{\n\treturn dentry->d_inode && !d_unhashed(dentry);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/magic.h>",
            "#include <linux/parser.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/string.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/kobject.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/parser.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fsnotify.h>\n#include <linux/debugfs.h>\n#include <linux/namei.h>\n#include <linux/kobject.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic inline int debugfs_positive(struct dentry *dentry)\n{\n\treturn dentry->d_inode && !d_unhashed(dentry);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/parser.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fsnotify.h>\n#include <linux/debugfs.h>\n#include <linux/namei.h>\n#include <linux/kobject.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int __debugfs_remove(struct dentry *dentry, struct dentry *parent)\n{\n\tint ret = 0;\n\n\tif (debugfs_positive(dentry)) {\n\t\tdget(dentry);\n\t\tif (S_ISDIR(dentry->d_inode->i_mode))\n\t\t\tret = simple_rmdir(parent->d_inode, dentry);\n\t\telse\n\t\t\tsimple_unlink(parent->d_inode, dentry);\n\t\tif (!ret)\n\t\t\td_delete(dentry);\n\t\tdput(dentry);\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "debugfs_create_symlink",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/debugfs/inode.c",
    "lines": "490-515",
    "snippet": "struct dentry *debugfs_create_symlink(const char *name, struct dentry *parent,\n\t\t\t\t      const char *target)\n{\n\tstruct dentry *dentry;\n\tstruct inode *inode;\n\tchar *link = kstrdup(target, GFP_KERNEL);\n\tif (!link)\n\t\treturn NULL;\n\n\tdentry = start_creating(name, parent);\n\tif (IS_ERR(dentry)) {\n\t\tkfree(link);\n\t\treturn NULL;\n\t}\n\n\tinode = debugfs_get_inode(dentry->d_sb);\n\tif (unlikely(!inode)) {\n\t\tkfree(link);\n\t\treturn failed_creating(dentry);\n\t}\n\tinode->i_mode = S_IFLNK | S_IRWXUGO;\n\tinode->i_op = &debugfs_link_operations;\n\tinode->i_private = link;\n\td_instantiate(dentry, inode);\n\treturn end_creating(dentry);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/magic.h>",
      "#include <linux/parser.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/string.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/kobject.h>",
      "#include <linux/init.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "end_creating",
          "args": [
            "dentry"
          ],
          "line": 514
        },
        "resolved": true,
        "details": {
          "function_name": "end_creating",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/debugfs/inode.c",
          "lines": "289-293",
          "snippet": "static struct dentry *end_creating(struct dentry *dentry)\n{\n\tmutex_unlock(&dentry->d_parent->d_inode->i_mutex);\n\treturn dentry;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/magic.h>",
            "#include <linux/parser.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/string.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/kobject.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/parser.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fsnotify.h>\n#include <linux/debugfs.h>\n#include <linux/namei.h>\n#include <linux/kobject.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic struct dentry *end_creating(struct dentry *dentry)\n{\n\tmutex_unlock(&dentry->d_parent->d_inode->i_mutex);\n\treturn dentry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_instantiate",
          "args": [
            "dentry",
            "inode"
          ],
          "line": 513
        },
        "resolved": true,
        "details": {
          "function_name": "d_instantiate_no_diralias",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1839-1854",
          "snippet": "int d_instantiate_no_diralias(struct dentry *entry, struct inode *inode)\n{\n\tBUG_ON(!hlist_unhashed(&entry->d_u.d_alias));\n\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode) && !hlist_empty(&inode->i_dentry)) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tiput(inode);\n\t\treturn -EBUSY;\n\t}\n\t__d_instantiate(entry, inode);\n\tspin_unlock(&inode->i_lock);\n\tsecurity_d_instantiate(entry, inode);\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nint d_instantiate_no_diralias(struct dentry *entry, struct inode *inode)\n{\n\tBUG_ON(!hlist_unhashed(&entry->d_u.d_alias));\n\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode) && !hlist_empty(&inode->i_dentry)) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tiput(inode);\n\t\treturn -EBUSY;\n\t}\n\t__d_instantiate(entry, inode);\n\tspin_unlock(&inode->i_lock);\n\tsecurity_d_instantiate(entry, inode);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "failed_creating",
          "args": [
            "dentry"
          ],
          "line": 508
        },
        "resolved": true,
        "details": {
          "function_name": "failed_creating",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/debugfs/inode.c",
          "lines": "281-287",
          "snippet": "static struct dentry *failed_creating(struct dentry *dentry)\n{\n\tmutex_unlock(&dentry->d_parent->d_inode->i_mutex);\n\tdput(dentry);\n\tsimple_release_fs(&debugfs_mount, &debugfs_mount_count);\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/magic.h>",
            "#include <linux/parser.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/string.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/kobject.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct vfsmount *debugfs_mount;",
            "static int debugfs_mount_count;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/parser.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fsnotify.h>\n#include <linux/debugfs.h>\n#include <linux/namei.h>\n#include <linux/kobject.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic struct vfsmount *debugfs_mount;\nstatic int debugfs_mount_count;\n\nstatic struct dentry *failed_creating(struct dentry *dentry)\n{\n\tmutex_unlock(&dentry->d_parent->d_inode->i_mutex);\n\tdput(dentry);\n\tsimple_release_fs(&debugfs_mount, &debugfs_mount_count);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "link"
          ],
          "line": 507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!inode"
          ],
          "line": 506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debugfs_get_inode",
          "args": [
            "dentry->d_sb"
          ],
          "line": 505
        },
        "resolved": true,
        "details": {
          "function_name": "debugfs_get_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/debugfs/inode.c",
          "lines": "37-45",
          "snippet": "static struct inode *debugfs_get_inode(struct super_block *sb)\n{\n\tstruct inode *inode = new_inode(sb);\n\tif (inode) {\n\t\tinode->i_ino = get_next_ino();\n\t\tinode->i_atime = inode->i_mtime = inode->i_ctime = CURRENT_TIME;\n\t}\n\treturn inode;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/magic.h>",
            "#include <linux/parser.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/string.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/kobject.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/parser.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fsnotify.h>\n#include <linux/debugfs.h>\n#include <linux/namei.h>\n#include <linux/kobject.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic struct inode *debugfs_get_inode(struct super_block *sb)\n{\n\tstruct inode *inode = new_inode(sb);\n\tif (inode) {\n\t\tinode->i_ino = get_next_ino();\n\t\tinode->i_atime = inode->i_mtime = inode->i_ctime = CURRENT_TIME;\n\t}\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "link"
          ],
          "line": 501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "dentry"
          ],
          "line": 500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "start_creating",
          "args": [
            "name",
            "parent"
          ],
          "line": 499
        },
        "resolved": true,
        "details": {
          "function_name": "start_creating",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/debugfs/inode.c",
          "lines": "250-279",
          "snippet": "static struct dentry *start_creating(const char *name, struct dentry *parent)\n{\n\tstruct dentry *dentry;\n\tint error;\n\n\tpr_debug(\"debugfs: creating file '%s'\\n\",name);\n\n\terror = simple_pin_fs(&debug_fs_type, &debugfs_mount,\n\t\t\t      &debugfs_mount_count);\n\tif (error)\n\t\treturn ERR_PTR(error);\n\n\t/* If the parent is not specified, we create it in the root.\n\t * We need the root dentry to do this, which is in the super\n\t * block. A pointer to that is in the struct vfsmount that we\n\t * have around.\n\t */\n\tif (!parent)\n\t\tparent = debugfs_mount->mnt_root;\n\n\tmutex_lock(&parent->d_inode->i_mutex);\n\tdentry = lookup_one_len(name, parent, strlen(name));\n\tif (!IS_ERR(dentry) && dentry->d_inode) {\n\t\tdput(dentry);\n\t\tdentry = ERR_PTR(-EEXIST);\n\t}\n\tif (IS_ERR(dentry))\n\t\tmutex_unlock(&parent->d_inode->i_mutex);\n\treturn dentry;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/magic.h>",
            "#include <linux/parser.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/string.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/kobject.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct vfsmount *debugfs_mount;",
            "static int debugfs_mount_count;",
            "static struct file_system_type debug_fs_type = {\n\t.owner =\tTHIS_MODULE,\n\t.name =\t\t\"debugfs\",\n\t.mount =\tdebug_mount,\n\t.kill_sb =\tkill_litter_super,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/parser.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fsnotify.h>\n#include <linux/debugfs.h>\n#include <linux/namei.h>\n#include <linux/kobject.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic struct vfsmount *debugfs_mount;\nstatic int debugfs_mount_count;\nstatic struct file_system_type debug_fs_type = {\n\t.owner =\tTHIS_MODULE,\n\t.name =\t\t\"debugfs\",\n\t.mount =\tdebug_mount,\n\t.kill_sb =\tkill_litter_super,\n};\n\nstatic struct dentry *start_creating(const char *name, struct dentry *parent)\n{\n\tstruct dentry *dentry;\n\tint error;\n\n\tpr_debug(\"debugfs: creating file '%s'\\n\",name);\n\n\terror = simple_pin_fs(&debug_fs_type, &debugfs_mount,\n\t\t\t      &debugfs_mount_count);\n\tif (error)\n\t\treturn ERR_PTR(error);\n\n\t/* If the parent is not specified, we create it in the root.\n\t * We need the root dentry to do this, which is in the super\n\t * block. A pointer to that is in the struct vfsmount that we\n\t * have around.\n\t */\n\tif (!parent)\n\t\tparent = debugfs_mount->mnt_root;\n\n\tmutex_lock(&parent->d_inode->i_mutex);\n\tdentry = lookup_one_len(name, parent, strlen(name));\n\tif (!IS_ERR(dentry) && dentry->d_inode) {\n\t\tdput(dentry);\n\t\tdentry = ERR_PTR(-EEXIST);\n\t}\n\tif (IS_ERR(dentry))\n\t\tmutex_unlock(&parent->d_inode->i_mutex);\n\treturn dentry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kstrdup",
          "args": [
            "target",
            "GFP_KERNEL"
          ],
          "line": 495
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/parser.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fsnotify.h>\n#include <linux/debugfs.h>\n#include <linux/namei.h>\n#include <linux/kobject.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstruct dentry *debugfs_create_symlink(const char *name, struct dentry *parent,\n\t\t\t\t      const char *target)\n{\n\tstruct dentry *dentry;\n\tstruct inode *inode;\n\tchar *link = kstrdup(target, GFP_KERNEL);\n\tif (!link)\n\t\treturn NULL;\n\n\tdentry = start_creating(name, parent);\n\tif (IS_ERR(dentry)) {\n\t\tkfree(link);\n\t\treturn NULL;\n\t}\n\n\tinode = debugfs_get_inode(dentry->d_sb);\n\tif (unlikely(!inode)) {\n\t\tkfree(link);\n\t\treturn failed_creating(dentry);\n\t}\n\tinode->i_mode = S_IFLNK | S_IRWXUGO;\n\tinode->i_op = &debugfs_link_operations;\n\tinode->i_private = link;\n\td_instantiate(dentry, inode);\n\treturn end_creating(dentry);\n}"
  },
  {
    "function_name": "debugfs_create_automount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/debugfs/inode.c",
    "lines": "443-464",
    "snippet": "struct dentry *debugfs_create_automount(const char *name,\n\t\t\t\t\tstruct dentry *parent,\n\t\t\t\t\tstruct vfsmount *(*f)(void *),\n\t\t\t\t\tvoid *data)\n{\n\tstruct dentry *dentry = start_creating(name, parent);\n\tstruct inode *inode;\n\n\tif (IS_ERR(dentry))\n\t\treturn NULL;\n\n\tinode = debugfs_get_inode(dentry->d_sb);\n\tif (unlikely(!inode))\n\t\treturn failed_creating(dentry);\n\n\tinode->i_mode = S_IFDIR | S_IRWXU | S_IRUGO | S_IXUGO;\n\tinode->i_flags |= S_AUTOMOUNT;\n\tinode->i_private = data;\n\tdentry->d_fsdata = (void *)f;\n\td_instantiate(dentry, inode);\n\treturn end_creating(dentry);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/magic.h>",
      "#include <linux/parser.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/string.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/kobject.h>",
      "#include <linux/init.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "end_creating",
          "args": [
            "dentry"
          ],
          "line": 463
        },
        "resolved": true,
        "details": {
          "function_name": "end_creating",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/debugfs/inode.c",
          "lines": "289-293",
          "snippet": "static struct dentry *end_creating(struct dentry *dentry)\n{\n\tmutex_unlock(&dentry->d_parent->d_inode->i_mutex);\n\treturn dentry;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/magic.h>",
            "#include <linux/parser.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/string.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/kobject.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/parser.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fsnotify.h>\n#include <linux/debugfs.h>\n#include <linux/namei.h>\n#include <linux/kobject.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic struct dentry *end_creating(struct dentry *dentry)\n{\n\tmutex_unlock(&dentry->d_parent->d_inode->i_mutex);\n\treturn dentry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_instantiate",
          "args": [
            "dentry",
            "inode"
          ],
          "line": 462
        },
        "resolved": true,
        "details": {
          "function_name": "d_instantiate_no_diralias",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1839-1854",
          "snippet": "int d_instantiate_no_diralias(struct dentry *entry, struct inode *inode)\n{\n\tBUG_ON(!hlist_unhashed(&entry->d_u.d_alias));\n\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode) && !hlist_empty(&inode->i_dentry)) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tiput(inode);\n\t\treturn -EBUSY;\n\t}\n\t__d_instantiate(entry, inode);\n\tspin_unlock(&inode->i_lock);\n\tsecurity_d_instantiate(entry, inode);\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nint d_instantiate_no_diralias(struct dentry *entry, struct inode *inode)\n{\n\tBUG_ON(!hlist_unhashed(&entry->d_u.d_alias));\n\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode) && !hlist_empty(&inode->i_dentry)) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tiput(inode);\n\t\treturn -EBUSY;\n\t}\n\t__d_instantiate(entry, inode);\n\tspin_unlock(&inode->i_lock);\n\tsecurity_d_instantiate(entry, inode);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "failed_creating",
          "args": [
            "dentry"
          ],
          "line": 456
        },
        "resolved": true,
        "details": {
          "function_name": "failed_creating",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/debugfs/inode.c",
          "lines": "281-287",
          "snippet": "static struct dentry *failed_creating(struct dentry *dentry)\n{\n\tmutex_unlock(&dentry->d_parent->d_inode->i_mutex);\n\tdput(dentry);\n\tsimple_release_fs(&debugfs_mount, &debugfs_mount_count);\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/magic.h>",
            "#include <linux/parser.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/string.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/kobject.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct vfsmount *debugfs_mount;",
            "static int debugfs_mount_count;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/parser.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fsnotify.h>\n#include <linux/debugfs.h>\n#include <linux/namei.h>\n#include <linux/kobject.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic struct vfsmount *debugfs_mount;\nstatic int debugfs_mount_count;\n\nstatic struct dentry *failed_creating(struct dentry *dentry)\n{\n\tmutex_unlock(&dentry->d_parent->d_inode->i_mutex);\n\tdput(dentry);\n\tsimple_release_fs(&debugfs_mount, &debugfs_mount_count);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!inode"
          ],
          "line": 455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debugfs_get_inode",
          "args": [
            "dentry->d_sb"
          ],
          "line": 454
        },
        "resolved": true,
        "details": {
          "function_name": "debugfs_get_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/debugfs/inode.c",
          "lines": "37-45",
          "snippet": "static struct inode *debugfs_get_inode(struct super_block *sb)\n{\n\tstruct inode *inode = new_inode(sb);\n\tif (inode) {\n\t\tinode->i_ino = get_next_ino();\n\t\tinode->i_atime = inode->i_mtime = inode->i_ctime = CURRENT_TIME;\n\t}\n\treturn inode;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/magic.h>",
            "#include <linux/parser.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/string.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/kobject.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/parser.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fsnotify.h>\n#include <linux/debugfs.h>\n#include <linux/namei.h>\n#include <linux/kobject.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic struct inode *debugfs_get_inode(struct super_block *sb)\n{\n\tstruct inode *inode = new_inode(sb);\n\tif (inode) {\n\t\tinode->i_ino = get_next_ino();\n\t\tinode->i_atime = inode->i_mtime = inode->i_ctime = CURRENT_TIME;\n\t}\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "dentry"
          ],
          "line": 451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "start_creating",
          "args": [
            "name",
            "parent"
          ],
          "line": 448
        },
        "resolved": true,
        "details": {
          "function_name": "start_creating",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/debugfs/inode.c",
          "lines": "250-279",
          "snippet": "static struct dentry *start_creating(const char *name, struct dentry *parent)\n{\n\tstruct dentry *dentry;\n\tint error;\n\n\tpr_debug(\"debugfs: creating file '%s'\\n\",name);\n\n\terror = simple_pin_fs(&debug_fs_type, &debugfs_mount,\n\t\t\t      &debugfs_mount_count);\n\tif (error)\n\t\treturn ERR_PTR(error);\n\n\t/* If the parent is not specified, we create it in the root.\n\t * We need the root dentry to do this, which is in the super\n\t * block. A pointer to that is in the struct vfsmount that we\n\t * have around.\n\t */\n\tif (!parent)\n\t\tparent = debugfs_mount->mnt_root;\n\n\tmutex_lock(&parent->d_inode->i_mutex);\n\tdentry = lookup_one_len(name, parent, strlen(name));\n\tif (!IS_ERR(dentry) && dentry->d_inode) {\n\t\tdput(dentry);\n\t\tdentry = ERR_PTR(-EEXIST);\n\t}\n\tif (IS_ERR(dentry))\n\t\tmutex_unlock(&parent->d_inode->i_mutex);\n\treturn dentry;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/magic.h>",
            "#include <linux/parser.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/string.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/kobject.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct vfsmount *debugfs_mount;",
            "static int debugfs_mount_count;",
            "static struct file_system_type debug_fs_type = {\n\t.owner =\tTHIS_MODULE,\n\t.name =\t\t\"debugfs\",\n\t.mount =\tdebug_mount,\n\t.kill_sb =\tkill_litter_super,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/parser.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fsnotify.h>\n#include <linux/debugfs.h>\n#include <linux/namei.h>\n#include <linux/kobject.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic struct vfsmount *debugfs_mount;\nstatic int debugfs_mount_count;\nstatic struct file_system_type debug_fs_type = {\n\t.owner =\tTHIS_MODULE,\n\t.name =\t\t\"debugfs\",\n\t.mount =\tdebug_mount,\n\t.kill_sb =\tkill_litter_super,\n};\n\nstatic struct dentry *start_creating(const char *name, struct dentry *parent)\n{\n\tstruct dentry *dentry;\n\tint error;\n\n\tpr_debug(\"debugfs: creating file '%s'\\n\",name);\n\n\terror = simple_pin_fs(&debug_fs_type, &debugfs_mount,\n\t\t\t      &debugfs_mount_count);\n\tif (error)\n\t\treturn ERR_PTR(error);\n\n\t/* If the parent is not specified, we create it in the root.\n\t * We need the root dentry to do this, which is in the super\n\t * block. A pointer to that is in the struct vfsmount that we\n\t * have around.\n\t */\n\tif (!parent)\n\t\tparent = debugfs_mount->mnt_root;\n\n\tmutex_lock(&parent->d_inode->i_mutex);\n\tdentry = lookup_one_len(name, parent, strlen(name));\n\tif (!IS_ERR(dentry) && dentry->d_inode) {\n\t\tdput(dentry);\n\t\tdentry = ERR_PTR(-EEXIST);\n\t}\n\tif (IS_ERR(dentry))\n\t\tmutex_unlock(&parent->d_inode->i_mutex);\n\treturn dentry;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/parser.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fsnotify.h>\n#include <linux/debugfs.h>\n#include <linux/namei.h>\n#include <linux/kobject.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstruct dentry *debugfs_create_automount(const char *name,\n\t\t\t\t\tstruct dentry *parent,\n\t\t\t\t\tstruct vfsmount *(*f)(void *),\n\t\t\t\t\tvoid *data)\n{\n\tstruct dentry *dentry = start_creating(name, parent);\n\tstruct inode *inode;\n\n\tif (IS_ERR(dentry))\n\t\treturn NULL;\n\n\tinode = debugfs_get_inode(dentry->d_sb);\n\tif (unlikely(!inode))\n\t\treturn failed_creating(dentry);\n\n\tinode->i_mode = S_IFDIR | S_IRWXU | S_IRUGO | S_IXUGO;\n\tinode->i_flags |= S_AUTOMOUNT;\n\tinode->i_private = data;\n\tdentry->d_fsdata = (void *)f;\n\td_instantiate(dentry, inode);\n\treturn end_creating(dentry);\n}"
  },
  {
    "function_name": "debugfs_create_dir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/debugfs/inode.c",
    "lines": "407-429",
    "snippet": "struct dentry *debugfs_create_dir(const char *name, struct dentry *parent)\n{\n\tstruct dentry *dentry = start_creating(name, parent);\n\tstruct inode *inode;\n\n\tif (IS_ERR(dentry))\n\t\treturn NULL;\n\n\tinode = debugfs_get_inode(dentry->d_sb);\n\tif (unlikely(!inode))\n\t\treturn failed_creating(dentry);\n\n\tinode->i_mode = S_IFDIR | S_IRWXU | S_IRUGO | S_IXUGO;\n\tinode->i_op = &simple_dir_inode_operations;\n\tinode->i_fop = &simple_dir_operations;\n\n\t/* directory inodes start off with i_nlink == 2 (for \".\" entry) */\n\tinc_nlink(inode);\n\td_instantiate(dentry, inode);\n\tinc_nlink(dentry->d_parent->d_inode);\n\tfsnotify_mkdir(dentry->d_parent->d_inode, dentry);\n\treturn end_creating(dentry);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/magic.h>",
      "#include <linux/parser.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/string.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/kobject.h>",
      "#include <linux/init.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "end_creating",
          "args": [
            "dentry"
          ],
          "line": 428
        },
        "resolved": true,
        "details": {
          "function_name": "end_creating",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/debugfs/inode.c",
          "lines": "289-293",
          "snippet": "static struct dentry *end_creating(struct dentry *dentry)\n{\n\tmutex_unlock(&dentry->d_parent->d_inode->i_mutex);\n\treturn dentry;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/magic.h>",
            "#include <linux/parser.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/string.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/kobject.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/parser.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fsnotify.h>\n#include <linux/debugfs.h>\n#include <linux/namei.h>\n#include <linux/kobject.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic struct dentry *end_creating(struct dentry *dentry)\n{\n\tmutex_unlock(&dentry->d_parent->d_inode->i_mutex);\n\treturn dentry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fsnotify_mkdir",
          "args": [
            "dentry->d_parent->d_inode",
            "dentry"
          ],
          "line": 427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inc_nlink",
          "args": [
            "dentry->d_parent->d_inode"
          ],
          "line": 426
        },
        "resolved": true,
        "details": {
          "function_name": "inc_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "327-335",
          "snippet": "void inc_nlink(struct inode *inode)\n{\n\tif (unlikely(inode->i_nlink == 0)) {\n\t\tWARN_ON(!(inode->i_state & I_LINKABLE));\n\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\t}\n\n\tinode->__i_nlink++;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid inc_nlink(struct inode *inode)\n{\n\tif (unlikely(inode->i_nlink == 0)) {\n\t\tWARN_ON(!(inode->i_state & I_LINKABLE));\n\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\t}\n\n\tinode->__i_nlink++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_instantiate",
          "args": [
            "dentry",
            "inode"
          ],
          "line": 425
        },
        "resolved": true,
        "details": {
          "function_name": "d_instantiate_no_diralias",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1839-1854",
          "snippet": "int d_instantiate_no_diralias(struct dentry *entry, struct inode *inode)\n{\n\tBUG_ON(!hlist_unhashed(&entry->d_u.d_alias));\n\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode) && !hlist_empty(&inode->i_dentry)) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tiput(inode);\n\t\treturn -EBUSY;\n\t}\n\t__d_instantiate(entry, inode);\n\tspin_unlock(&inode->i_lock);\n\tsecurity_d_instantiate(entry, inode);\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nint d_instantiate_no_diralias(struct dentry *entry, struct inode *inode)\n{\n\tBUG_ON(!hlist_unhashed(&entry->d_u.d_alias));\n\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode) && !hlist_empty(&inode->i_dentry)) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tiput(inode);\n\t\treturn -EBUSY;\n\t}\n\t__d_instantiate(entry, inode);\n\tspin_unlock(&inode->i_lock);\n\tsecurity_d_instantiate(entry, inode);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "failed_creating",
          "args": [
            "dentry"
          ],
          "line": 417
        },
        "resolved": true,
        "details": {
          "function_name": "failed_creating",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/debugfs/inode.c",
          "lines": "281-287",
          "snippet": "static struct dentry *failed_creating(struct dentry *dentry)\n{\n\tmutex_unlock(&dentry->d_parent->d_inode->i_mutex);\n\tdput(dentry);\n\tsimple_release_fs(&debugfs_mount, &debugfs_mount_count);\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/magic.h>",
            "#include <linux/parser.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/string.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/kobject.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct vfsmount *debugfs_mount;",
            "static int debugfs_mount_count;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/parser.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fsnotify.h>\n#include <linux/debugfs.h>\n#include <linux/namei.h>\n#include <linux/kobject.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic struct vfsmount *debugfs_mount;\nstatic int debugfs_mount_count;\n\nstatic struct dentry *failed_creating(struct dentry *dentry)\n{\n\tmutex_unlock(&dentry->d_parent->d_inode->i_mutex);\n\tdput(dentry);\n\tsimple_release_fs(&debugfs_mount, &debugfs_mount_count);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!inode"
          ],
          "line": 416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debugfs_get_inode",
          "args": [
            "dentry->d_sb"
          ],
          "line": 415
        },
        "resolved": true,
        "details": {
          "function_name": "debugfs_get_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/debugfs/inode.c",
          "lines": "37-45",
          "snippet": "static struct inode *debugfs_get_inode(struct super_block *sb)\n{\n\tstruct inode *inode = new_inode(sb);\n\tif (inode) {\n\t\tinode->i_ino = get_next_ino();\n\t\tinode->i_atime = inode->i_mtime = inode->i_ctime = CURRENT_TIME;\n\t}\n\treturn inode;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/magic.h>",
            "#include <linux/parser.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/string.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/kobject.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/parser.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fsnotify.h>\n#include <linux/debugfs.h>\n#include <linux/namei.h>\n#include <linux/kobject.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic struct inode *debugfs_get_inode(struct super_block *sb)\n{\n\tstruct inode *inode = new_inode(sb);\n\tif (inode) {\n\t\tinode->i_ino = get_next_ino();\n\t\tinode->i_atime = inode->i_mtime = inode->i_ctime = CURRENT_TIME;\n\t}\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "dentry"
          ],
          "line": 412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "start_creating",
          "args": [
            "name",
            "parent"
          ],
          "line": 409
        },
        "resolved": true,
        "details": {
          "function_name": "start_creating",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/debugfs/inode.c",
          "lines": "250-279",
          "snippet": "static struct dentry *start_creating(const char *name, struct dentry *parent)\n{\n\tstruct dentry *dentry;\n\tint error;\n\n\tpr_debug(\"debugfs: creating file '%s'\\n\",name);\n\n\terror = simple_pin_fs(&debug_fs_type, &debugfs_mount,\n\t\t\t      &debugfs_mount_count);\n\tif (error)\n\t\treturn ERR_PTR(error);\n\n\t/* If the parent is not specified, we create it in the root.\n\t * We need the root dentry to do this, which is in the super\n\t * block. A pointer to that is in the struct vfsmount that we\n\t * have around.\n\t */\n\tif (!parent)\n\t\tparent = debugfs_mount->mnt_root;\n\n\tmutex_lock(&parent->d_inode->i_mutex);\n\tdentry = lookup_one_len(name, parent, strlen(name));\n\tif (!IS_ERR(dentry) && dentry->d_inode) {\n\t\tdput(dentry);\n\t\tdentry = ERR_PTR(-EEXIST);\n\t}\n\tif (IS_ERR(dentry))\n\t\tmutex_unlock(&parent->d_inode->i_mutex);\n\treturn dentry;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/magic.h>",
            "#include <linux/parser.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/string.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/kobject.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct vfsmount *debugfs_mount;",
            "static int debugfs_mount_count;",
            "static struct file_system_type debug_fs_type = {\n\t.owner =\tTHIS_MODULE,\n\t.name =\t\t\"debugfs\",\n\t.mount =\tdebug_mount,\n\t.kill_sb =\tkill_litter_super,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/parser.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fsnotify.h>\n#include <linux/debugfs.h>\n#include <linux/namei.h>\n#include <linux/kobject.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic struct vfsmount *debugfs_mount;\nstatic int debugfs_mount_count;\nstatic struct file_system_type debug_fs_type = {\n\t.owner =\tTHIS_MODULE,\n\t.name =\t\t\"debugfs\",\n\t.mount =\tdebug_mount,\n\t.kill_sb =\tkill_litter_super,\n};\n\nstatic struct dentry *start_creating(const char *name, struct dentry *parent)\n{\n\tstruct dentry *dentry;\n\tint error;\n\n\tpr_debug(\"debugfs: creating file '%s'\\n\",name);\n\n\terror = simple_pin_fs(&debug_fs_type, &debugfs_mount,\n\t\t\t      &debugfs_mount_count);\n\tif (error)\n\t\treturn ERR_PTR(error);\n\n\t/* If the parent is not specified, we create it in the root.\n\t * We need the root dentry to do this, which is in the super\n\t * block. A pointer to that is in the struct vfsmount that we\n\t * have around.\n\t */\n\tif (!parent)\n\t\tparent = debugfs_mount->mnt_root;\n\n\tmutex_lock(&parent->d_inode->i_mutex);\n\tdentry = lookup_one_len(name, parent, strlen(name));\n\tif (!IS_ERR(dentry) && dentry->d_inode) {\n\t\tdput(dentry);\n\t\tdentry = ERR_PTR(-EEXIST);\n\t}\n\tif (IS_ERR(dentry))\n\t\tmutex_unlock(&parent->d_inode->i_mutex);\n\treturn dentry;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/parser.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fsnotify.h>\n#include <linux/debugfs.h>\n#include <linux/namei.h>\n#include <linux/kobject.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstruct dentry *debugfs_create_dir(const char *name, struct dentry *parent)\n{\n\tstruct dentry *dentry = start_creating(name, parent);\n\tstruct inode *inode;\n\n\tif (IS_ERR(dentry))\n\t\treturn NULL;\n\n\tinode = debugfs_get_inode(dentry->d_sb);\n\tif (unlikely(!inode))\n\t\treturn failed_creating(dentry);\n\n\tinode->i_mode = S_IFDIR | S_IRWXU | S_IRUGO | S_IXUGO;\n\tinode->i_op = &simple_dir_inode_operations;\n\tinode->i_fop = &simple_dir_operations;\n\n\t/* directory inodes start off with i_nlink == 2 (for \".\" entry) */\n\tinc_nlink(inode);\n\td_instantiate(dentry, inode);\n\tinc_nlink(dentry->d_parent->d_inode);\n\tfsnotify_mkdir(dentry->d_parent->d_inode, dentry);\n\treturn end_creating(dentry);\n}"
  },
  {
    "function_name": "debugfs_create_file_size",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/debugfs/inode.c",
    "lines": "376-386",
    "snippet": "struct dentry *debugfs_create_file_size(const char *name, umode_t mode,\n\t\t\t\t\tstruct dentry *parent, void *data,\n\t\t\t\t\tconst struct file_operations *fops,\n\t\t\t\t\tloff_t file_size)\n{\n\tstruct dentry *de = debugfs_create_file(name, mode, parent, data, fops);\n\n\tif (de)\n\t\tde->d_inode->i_size = file_size;\n\treturn de;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/magic.h>",
      "#include <linux/parser.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/string.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/kobject.h>",
      "#include <linux/init.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "debugfs_create_file",
          "args": [
            "name",
            "mode",
            "parent",
            "data",
            "fops"
          ],
          "line": 381
        },
        "resolved": true,
        "details": {
          "function_name": "debugfs_create_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/debugfs/inode.c",
          "lines": "321-346",
          "snippet": "struct dentry *debugfs_create_file(const char *name, umode_t mode,\n\t\t\t\t   struct dentry *parent, void *data,\n\t\t\t\t   const struct file_operations *fops)\n{\n\tstruct dentry *dentry;\n\tstruct inode *inode;\n\n\tif (!(mode & S_IFMT))\n\t\tmode |= S_IFREG;\n\tBUG_ON(!S_ISREG(mode));\n\tdentry = start_creating(name, parent);\n\n\tif (IS_ERR(dentry))\n\t\treturn NULL;\n\n\tinode = debugfs_get_inode(dentry->d_sb);\n\tif (unlikely(!inode))\n\t\treturn failed_creating(dentry);\n\n\tinode->i_mode = mode;\n\tinode->i_fop = fops ? fops : &debugfs_file_operations;\n\tinode->i_private = data;\n\td_instantiate(dentry, inode);\n\tfsnotify_create(dentry->d_parent->d_inode, dentry);\n\treturn end_creating(dentry);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/magic.h>",
            "#include <linux/parser.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/string.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/kobject.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/parser.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fsnotify.h>\n#include <linux/debugfs.h>\n#include <linux/namei.h>\n#include <linux/kobject.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstruct dentry *debugfs_create_file(const char *name, umode_t mode,\n\t\t\t\t   struct dentry *parent, void *data,\n\t\t\t\t   const struct file_operations *fops)\n{\n\tstruct dentry *dentry;\n\tstruct inode *inode;\n\n\tif (!(mode & S_IFMT))\n\t\tmode |= S_IFREG;\n\tBUG_ON(!S_ISREG(mode));\n\tdentry = start_creating(name, parent);\n\n\tif (IS_ERR(dentry))\n\t\treturn NULL;\n\n\tinode = debugfs_get_inode(dentry->d_sb);\n\tif (unlikely(!inode))\n\t\treturn failed_creating(dentry);\n\n\tinode->i_mode = mode;\n\tinode->i_fop = fops ? fops : &debugfs_file_operations;\n\tinode->i_private = data;\n\td_instantiate(dentry, inode);\n\tfsnotify_create(dentry->d_parent->d_inode, dentry);\n\treturn end_creating(dentry);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/parser.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fsnotify.h>\n#include <linux/debugfs.h>\n#include <linux/namei.h>\n#include <linux/kobject.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstruct dentry *debugfs_create_file_size(const char *name, umode_t mode,\n\t\t\t\t\tstruct dentry *parent, void *data,\n\t\t\t\t\tconst struct file_operations *fops,\n\t\t\t\t\tloff_t file_size)\n{\n\tstruct dentry *de = debugfs_create_file(name, mode, parent, data, fops);\n\n\tif (de)\n\t\tde->d_inode->i_size = file_size;\n\treturn de;\n}"
  },
  {
    "function_name": "debugfs_create_file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/debugfs/inode.c",
    "lines": "321-346",
    "snippet": "struct dentry *debugfs_create_file(const char *name, umode_t mode,\n\t\t\t\t   struct dentry *parent, void *data,\n\t\t\t\t   const struct file_operations *fops)\n{\n\tstruct dentry *dentry;\n\tstruct inode *inode;\n\n\tif (!(mode & S_IFMT))\n\t\tmode |= S_IFREG;\n\tBUG_ON(!S_ISREG(mode));\n\tdentry = start_creating(name, parent);\n\n\tif (IS_ERR(dentry))\n\t\treturn NULL;\n\n\tinode = debugfs_get_inode(dentry->d_sb);\n\tif (unlikely(!inode))\n\t\treturn failed_creating(dentry);\n\n\tinode->i_mode = mode;\n\tinode->i_fop = fops ? fops : &debugfs_file_operations;\n\tinode->i_private = data;\n\td_instantiate(dentry, inode);\n\tfsnotify_create(dentry->d_parent->d_inode, dentry);\n\treturn end_creating(dentry);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/magic.h>",
      "#include <linux/parser.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/string.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/kobject.h>",
      "#include <linux/init.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "end_creating",
          "args": [
            "dentry"
          ],
          "line": 345
        },
        "resolved": true,
        "details": {
          "function_name": "end_creating",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/debugfs/inode.c",
          "lines": "289-293",
          "snippet": "static struct dentry *end_creating(struct dentry *dentry)\n{\n\tmutex_unlock(&dentry->d_parent->d_inode->i_mutex);\n\treturn dentry;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/magic.h>",
            "#include <linux/parser.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/string.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/kobject.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/parser.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fsnotify.h>\n#include <linux/debugfs.h>\n#include <linux/namei.h>\n#include <linux/kobject.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic struct dentry *end_creating(struct dentry *dentry)\n{\n\tmutex_unlock(&dentry->d_parent->d_inode->i_mutex);\n\treturn dentry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fsnotify_create",
          "args": [
            "dentry->d_parent->d_inode",
            "dentry"
          ],
          "line": 344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_instantiate",
          "args": [
            "dentry",
            "inode"
          ],
          "line": 343
        },
        "resolved": true,
        "details": {
          "function_name": "d_instantiate_no_diralias",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1839-1854",
          "snippet": "int d_instantiate_no_diralias(struct dentry *entry, struct inode *inode)\n{\n\tBUG_ON(!hlist_unhashed(&entry->d_u.d_alias));\n\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode) && !hlist_empty(&inode->i_dentry)) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tiput(inode);\n\t\treturn -EBUSY;\n\t}\n\t__d_instantiate(entry, inode);\n\tspin_unlock(&inode->i_lock);\n\tsecurity_d_instantiate(entry, inode);\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nint d_instantiate_no_diralias(struct dentry *entry, struct inode *inode)\n{\n\tBUG_ON(!hlist_unhashed(&entry->d_u.d_alias));\n\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode) && !hlist_empty(&inode->i_dentry)) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tiput(inode);\n\t\treturn -EBUSY;\n\t}\n\t__d_instantiate(entry, inode);\n\tspin_unlock(&inode->i_lock);\n\tsecurity_d_instantiate(entry, inode);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "failed_creating",
          "args": [
            "dentry"
          ],
          "line": 338
        },
        "resolved": true,
        "details": {
          "function_name": "failed_creating",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/debugfs/inode.c",
          "lines": "281-287",
          "snippet": "static struct dentry *failed_creating(struct dentry *dentry)\n{\n\tmutex_unlock(&dentry->d_parent->d_inode->i_mutex);\n\tdput(dentry);\n\tsimple_release_fs(&debugfs_mount, &debugfs_mount_count);\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/magic.h>",
            "#include <linux/parser.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/string.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/kobject.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct vfsmount *debugfs_mount;",
            "static int debugfs_mount_count;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/parser.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fsnotify.h>\n#include <linux/debugfs.h>\n#include <linux/namei.h>\n#include <linux/kobject.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic struct vfsmount *debugfs_mount;\nstatic int debugfs_mount_count;\n\nstatic struct dentry *failed_creating(struct dentry *dentry)\n{\n\tmutex_unlock(&dentry->d_parent->d_inode->i_mutex);\n\tdput(dentry);\n\tsimple_release_fs(&debugfs_mount, &debugfs_mount_count);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!inode"
          ],
          "line": 337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debugfs_get_inode",
          "args": [
            "dentry->d_sb"
          ],
          "line": 336
        },
        "resolved": true,
        "details": {
          "function_name": "debugfs_get_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/debugfs/inode.c",
          "lines": "37-45",
          "snippet": "static struct inode *debugfs_get_inode(struct super_block *sb)\n{\n\tstruct inode *inode = new_inode(sb);\n\tif (inode) {\n\t\tinode->i_ino = get_next_ino();\n\t\tinode->i_atime = inode->i_mtime = inode->i_ctime = CURRENT_TIME;\n\t}\n\treturn inode;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/magic.h>",
            "#include <linux/parser.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/string.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/kobject.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/parser.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fsnotify.h>\n#include <linux/debugfs.h>\n#include <linux/namei.h>\n#include <linux/kobject.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic struct inode *debugfs_get_inode(struct super_block *sb)\n{\n\tstruct inode *inode = new_inode(sb);\n\tif (inode) {\n\t\tinode->i_ino = get_next_ino();\n\t\tinode->i_atime = inode->i_mtime = inode->i_ctime = CURRENT_TIME;\n\t}\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "dentry"
          ],
          "line": 333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "start_creating",
          "args": [
            "name",
            "parent"
          ],
          "line": 331
        },
        "resolved": true,
        "details": {
          "function_name": "start_creating",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/debugfs/inode.c",
          "lines": "250-279",
          "snippet": "static struct dentry *start_creating(const char *name, struct dentry *parent)\n{\n\tstruct dentry *dentry;\n\tint error;\n\n\tpr_debug(\"debugfs: creating file '%s'\\n\",name);\n\n\terror = simple_pin_fs(&debug_fs_type, &debugfs_mount,\n\t\t\t      &debugfs_mount_count);\n\tif (error)\n\t\treturn ERR_PTR(error);\n\n\t/* If the parent is not specified, we create it in the root.\n\t * We need the root dentry to do this, which is in the super\n\t * block. A pointer to that is in the struct vfsmount that we\n\t * have around.\n\t */\n\tif (!parent)\n\t\tparent = debugfs_mount->mnt_root;\n\n\tmutex_lock(&parent->d_inode->i_mutex);\n\tdentry = lookup_one_len(name, parent, strlen(name));\n\tif (!IS_ERR(dentry) && dentry->d_inode) {\n\t\tdput(dentry);\n\t\tdentry = ERR_PTR(-EEXIST);\n\t}\n\tif (IS_ERR(dentry))\n\t\tmutex_unlock(&parent->d_inode->i_mutex);\n\treturn dentry;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/magic.h>",
            "#include <linux/parser.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/string.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/kobject.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct vfsmount *debugfs_mount;",
            "static int debugfs_mount_count;",
            "static struct file_system_type debug_fs_type = {\n\t.owner =\tTHIS_MODULE,\n\t.name =\t\t\"debugfs\",\n\t.mount =\tdebug_mount,\n\t.kill_sb =\tkill_litter_super,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/parser.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fsnotify.h>\n#include <linux/debugfs.h>\n#include <linux/namei.h>\n#include <linux/kobject.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic struct vfsmount *debugfs_mount;\nstatic int debugfs_mount_count;\nstatic struct file_system_type debug_fs_type = {\n\t.owner =\tTHIS_MODULE,\n\t.name =\t\t\"debugfs\",\n\t.mount =\tdebug_mount,\n\t.kill_sb =\tkill_litter_super,\n};\n\nstatic struct dentry *start_creating(const char *name, struct dentry *parent)\n{\n\tstruct dentry *dentry;\n\tint error;\n\n\tpr_debug(\"debugfs: creating file '%s'\\n\",name);\n\n\terror = simple_pin_fs(&debug_fs_type, &debugfs_mount,\n\t\t\t      &debugfs_mount_count);\n\tif (error)\n\t\treturn ERR_PTR(error);\n\n\t/* If the parent is not specified, we create it in the root.\n\t * We need the root dentry to do this, which is in the super\n\t * block. A pointer to that is in the struct vfsmount that we\n\t * have around.\n\t */\n\tif (!parent)\n\t\tparent = debugfs_mount->mnt_root;\n\n\tmutex_lock(&parent->d_inode->i_mutex);\n\tdentry = lookup_one_len(name, parent, strlen(name));\n\tif (!IS_ERR(dentry) && dentry->d_inode) {\n\t\tdput(dentry);\n\t\tdentry = ERR_PTR(-EEXIST);\n\t}\n\tif (IS_ERR(dentry))\n\t\tmutex_unlock(&parent->d_inode->i_mutex);\n\treturn dentry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!S_ISREG(mode)"
          ],
          "line": 330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "mode"
          ],
          "line": 330
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/parser.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fsnotify.h>\n#include <linux/debugfs.h>\n#include <linux/namei.h>\n#include <linux/kobject.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstruct dentry *debugfs_create_file(const char *name, umode_t mode,\n\t\t\t\t   struct dentry *parent, void *data,\n\t\t\t\t   const struct file_operations *fops)\n{\n\tstruct dentry *dentry;\n\tstruct inode *inode;\n\n\tif (!(mode & S_IFMT))\n\t\tmode |= S_IFREG;\n\tBUG_ON(!S_ISREG(mode));\n\tdentry = start_creating(name, parent);\n\n\tif (IS_ERR(dentry))\n\t\treturn NULL;\n\n\tinode = debugfs_get_inode(dentry->d_sb);\n\tif (unlikely(!inode))\n\t\treturn failed_creating(dentry);\n\n\tinode->i_mode = mode;\n\tinode->i_fop = fops ? fops : &debugfs_file_operations;\n\tinode->i_private = data;\n\td_instantiate(dentry, inode);\n\tfsnotify_create(dentry->d_parent->d_inode, dentry);\n\treturn end_creating(dentry);\n}"
  },
  {
    "function_name": "end_creating",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/debugfs/inode.c",
    "lines": "289-293",
    "snippet": "static struct dentry *end_creating(struct dentry *dentry)\n{\n\tmutex_unlock(&dentry->d_parent->d_inode->i_mutex);\n\treturn dentry;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/magic.h>",
      "#include <linux/parser.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/string.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/kobject.h>",
      "#include <linux/init.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&dentry->d_parent->d_inode->i_mutex"
          ],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/parser.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fsnotify.h>\n#include <linux/debugfs.h>\n#include <linux/namei.h>\n#include <linux/kobject.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic struct dentry *end_creating(struct dentry *dentry)\n{\n\tmutex_unlock(&dentry->d_parent->d_inode->i_mutex);\n\treturn dentry;\n}"
  },
  {
    "function_name": "failed_creating",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/debugfs/inode.c",
    "lines": "281-287",
    "snippet": "static struct dentry *failed_creating(struct dentry *dentry)\n{\n\tmutex_unlock(&dentry->d_parent->d_inode->i_mutex);\n\tdput(dentry);\n\tsimple_release_fs(&debugfs_mount, &debugfs_mount_count);\n\treturn NULL;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/magic.h>",
      "#include <linux/parser.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/string.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/kobject.h>",
      "#include <linux/init.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct vfsmount *debugfs_mount;",
      "static int debugfs_mount_count;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "simple_release_fs",
          "args": [
            "&debugfs_mount",
            "&debugfs_mount_count"
          ],
          "line": 285
        },
        "resolved": true,
        "details": {
          "function_name": "simple_release_fs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/libfs.c",
          "lines": "564-573",
          "snippet": "void simple_release_fs(struct vfsmount **mount, int *count)\n{\n\tstruct vfsmount *mnt;\n\tspin_lock(&pin_fs_lock);\n\tmnt = *mount;\n\tif (!--*count)\n\t\t*mount = NULL;\n\tspin_unlock(&pin_fs_lock);\n\tmntput(mnt);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(pin_fs_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nstatic DEFINE_SPINLOCK(pin_fs_lock);\n\nvoid simple_release_fs(struct vfsmount **mount, int *count)\n{\n\tstruct vfsmount *mnt;\n\tspin_lock(&pin_fs_lock);\n\tmnt = *mount;\n\tif (!--*count)\n\t\t*mount = NULL;\n\tspin_unlock(&pin_fs_lock);\n\tmntput(mnt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "dentry"
          ],
          "line": 284
        },
        "resolved": true,
        "details": {
          "function_name": "dput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "726-762",
          "snippet": "void dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&dentry->d_parent->d_inode->i_mutex"
          ],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/parser.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fsnotify.h>\n#include <linux/debugfs.h>\n#include <linux/namei.h>\n#include <linux/kobject.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic struct vfsmount *debugfs_mount;\nstatic int debugfs_mount_count;\n\nstatic struct dentry *failed_creating(struct dentry *dentry)\n{\n\tmutex_unlock(&dentry->d_parent->d_inode->i_mutex);\n\tdput(dentry);\n\tsimple_release_fs(&debugfs_mount, &debugfs_mount_count);\n\treturn NULL;\n}"
  },
  {
    "function_name": "start_creating",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/debugfs/inode.c",
    "lines": "250-279",
    "snippet": "static struct dentry *start_creating(const char *name, struct dentry *parent)\n{\n\tstruct dentry *dentry;\n\tint error;\n\n\tpr_debug(\"debugfs: creating file '%s'\\n\",name);\n\n\terror = simple_pin_fs(&debug_fs_type, &debugfs_mount,\n\t\t\t      &debugfs_mount_count);\n\tif (error)\n\t\treturn ERR_PTR(error);\n\n\t/* If the parent is not specified, we create it in the root.\n\t * We need the root dentry to do this, which is in the super\n\t * block. A pointer to that is in the struct vfsmount that we\n\t * have around.\n\t */\n\tif (!parent)\n\t\tparent = debugfs_mount->mnt_root;\n\n\tmutex_lock(&parent->d_inode->i_mutex);\n\tdentry = lookup_one_len(name, parent, strlen(name));\n\tif (!IS_ERR(dentry) && dentry->d_inode) {\n\t\tdput(dentry);\n\t\tdentry = ERR_PTR(-EEXIST);\n\t}\n\tif (IS_ERR(dentry))\n\t\tmutex_unlock(&parent->d_inode->i_mutex);\n\treturn dentry;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/magic.h>",
      "#include <linux/parser.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/string.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/kobject.h>",
      "#include <linux/init.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct vfsmount *debugfs_mount;",
      "static int debugfs_mount_count;",
      "static struct file_system_type debug_fs_type = {\n\t.owner =\tTHIS_MODULE,\n\t.name =\t\t\"debugfs\",\n\t.mount =\tdebug_mount,\n\t.kill_sb =\tkill_litter_super,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&parent->d_inode->i_mutex"
          ],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "dentry"
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EEXIST"
          ],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "dentry"
          ],
          "line": 273
        },
        "resolved": true,
        "details": {
          "function_name": "dput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "726-762",
          "snippet": "void dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "dentry"
          ],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lookup_one_len",
          "args": [
            "name",
            "parent",
            "strlen(name)"
          ],
          "line": 271
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_one_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "2145-2184",
          "snippet": "struct dentry *lookup_one_len(const char *name, struct dentry *base, int len)\n{\n\tstruct qstr this;\n\tunsigned int c;\n\tint err;\n\n\tWARN_ON_ONCE(!mutex_is_locked(&base->d_inode->i_mutex));\n\n\tthis.name = name;\n\tthis.len = len;\n\tthis.hash = full_name_hash(name, len);\n\tif (!len)\n\t\treturn ERR_PTR(-EACCES);\n\n\tif (unlikely(name[0] == '.')) {\n\t\tif (len < 2 || (len == 2 && name[1] == '.'))\n\t\t\treturn ERR_PTR(-EACCES);\n\t}\n\n\twhile (len--) {\n\t\tc = *(const unsigned char *)name++;\n\t\tif (c == '/' || c == '\\0')\n\t\t\treturn ERR_PTR(-EACCES);\n\t}\n\t/*\n\t * See if the low-level filesystem might want\n\t * to use its own hash..\n\t */\n\tif (base->d_flags & DCACHE_OP_HASH) {\n\t\tint err = base->d_op->d_hash(base, &this);\n\t\tif (err < 0)\n\t\t\treturn ERR_PTR(err);\n\t}\n\n\terr = inode_permission(base->d_inode, MAY_EXEC);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\treturn __lookup_hash(&this, base, 0);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nstruct dentry *lookup_one_len(const char *name, struct dentry *base, int len)\n{\n\tstruct qstr this;\n\tunsigned int c;\n\tint err;\n\n\tWARN_ON_ONCE(!mutex_is_locked(&base->d_inode->i_mutex));\n\n\tthis.name = name;\n\tthis.len = len;\n\tthis.hash = full_name_hash(name, len);\n\tif (!len)\n\t\treturn ERR_PTR(-EACCES);\n\n\tif (unlikely(name[0] == '.')) {\n\t\tif (len < 2 || (len == 2 && name[1] == '.'))\n\t\t\treturn ERR_PTR(-EACCES);\n\t}\n\n\twhile (len--) {\n\t\tc = *(const unsigned char *)name++;\n\t\tif (c == '/' || c == '\\0')\n\t\t\treturn ERR_PTR(-EACCES);\n\t}\n\t/*\n\t * See if the low-level filesystem might want\n\t * to use its own hash..\n\t */\n\tif (base->d_flags & DCACHE_OP_HASH) {\n\t\tint err = base->d_op->d_hash(base, &this);\n\t\tif (err < 0)\n\t\t\treturn ERR_PTR(err);\n\t}\n\n\terr = inode_permission(base->d_inode, MAY_EXEC);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\treturn __lookup_hash(&this, base, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "name"
          ],
          "line": 271
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&parent->d_inode->i_mutex"
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "error"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "simple_pin_fs",
          "args": [
            "&debug_fs_type",
            "&debugfs_mount",
            "&debugfs_mount_count"
          ],
          "line": 257
        },
        "resolved": true,
        "details": {
          "function_name": "simple_pin_fs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/libfs.c",
          "lines": "543-561",
          "snippet": "int simple_pin_fs(struct file_system_type *type, struct vfsmount **mount, int *count)\n{\n\tstruct vfsmount *mnt = NULL;\n\tspin_lock(&pin_fs_lock);\n\tif (unlikely(!*mount)) {\n\t\tspin_unlock(&pin_fs_lock);\n\t\tmnt = vfs_kern_mount(type, MS_KERNMOUNT, type->name, NULL);\n\t\tif (IS_ERR(mnt))\n\t\t\treturn PTR_ERR(mnt);\n\t\tspin_lock(&pin_fs_lock);\n\t\tif (!*mount)\n\t\t\t*mount = mnt;\n\t}\n\tmntget(*mount);\n\t++*count;\n\tspin_unlock(&pin_fs_lock);\n\tmntput(mnt);\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(pin_fs_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nstatic DEFINE_SPINLOCK(pin_fs_lock);\n\nint simple_pin_fs(struct file_system_type *type, struct vfsmount **mount, int *count)\n{\n\tstruct vfsmount *mnt = NULL;\n\tspin_lock(&pin_fs_lock);\n\tif (unlikely(!*mount)) {\n\t\tspin_unlock(&pin_fs_lock);\n\t\tmnt = vfs_kern_mount(type, MS_KERNMOUNT, type->name, NULL);\n\t\tif (IS_ERR(mnt))\n\t\t\treturn PTR_ERR(mnt);\n\t\tspin_lock(&pin_fs_lock);\n\t\tif (!*mount)\n\t\t\t*mount = mnt;\n\t}\n\tmntget(*mount);\n\t++*count;\n\tspin_unlock(&pin_fs_lock);\n\tmntput(mnt);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"debugfs: creating file '%s'\\n\"",
            "name"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/parser.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fsnotify.h>\n#include <linux/debugfs.h>\n#include <linux/namei.h>\n#include <linux/kobject.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic struct vfsmount *debugfs_mount;\nstatic int debugfs_mount_count;\nstatic struct file_system_type debug_fs_type = {\n\t.owner =\tTHIS_MODULE,\n\t.name =\t\t\"debugfs\",\n\t.mount =\tdebug_mount,\n\t.kill_sb =\tkill_litter_super,\n};\n\nstatic struct dentry *start_creating(const char *name, struct dentry *parent)\n{\n\tstruct dentry *dentry;\n\tint error;\n\n\tpr_debug(\"debugfs: creating file '%s'\\n\",name);\n\n\terror = simple_pin_fs(&debug_fs_type, &debugfs_mount,\n\t\t\t      &debugfs_mount_count);\n\tif (error)\n\t\treturn ERR_PTR(error);\n\n\t/* If the parent is not specified, we create it in the root.\n\t * We need the root dentry to do this, which is in the super\n\t * block. A pointer to that is in the struct vfsmount that we\n\t * have around.\n\t */\n\tif (!parent)\n\t\tparent = debugfs_mount->mnt_root;\n\n\tmutex_lock(&parent->d_inode->i_mutex);\n\tdentry = lookup_one_len(name, parent, strlen(name));\n\tif (!IS_ERR(dentry) && dentry->d_inode) {\n\t\tdput(dentry);\n\t\tdentry = ERR_PTR(-EEXIST);\n\t}\n\tif (IS_ERR(dentry))\n\t\tmutex_unlock(&parent->d_inode->i_mutex);\n\treturn dentry;\n}"
  },
  {
    "function_name": "debug_mount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/debugfs/inode.c",
    "lines": "235-240",
    "snippet": "static struct dentry *debug_mount(struct file_system_type *fs_type,\n\t\t\tint flags, const char *dev_name,\n\t\t\tvoid *data)\n{\n\treturn mount_single(fs_type, flags, data, debug_fill_super);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/magic.h>",
      "#include <linux/parser.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/string.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/kobject.h>",
      "#include <linux/init.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mount_single",
          "args": [
            "fs_type",
            "flags",
            "data",
            "debug_fill_super"
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/parser.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fsnotify.h>\n#include <linux/debugfs.h>\n#include <linux/namei.h>\n#include <linux/kobject.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic struct dentry *debug_mount(struct file_system_type *fs_type,\n\t\t\tint flags, const char *dev_name,\n\t\t\tvoid *data)\n{\n\treturn mount_single(fs_type, flags, data, debug_fill_super);\n}"
  },
  {
    "function_name": "debug_fill_super",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/debugfs/inode.c",
    "lines": "199-233",
    "snippet": "static int debug_fill_super(struct super_block *sb, void *data, int silent)\n{\n\tstatic struct tree_descr debug_files[] = {{\"\"}};\n\tstruct debugfs_fs_info *fsi;\n\tint err;\n\n\tsave_mount_options(sb, data);\n\n\tfsi = kzalloc(sizeof(struct debugfs_fs_info), GFP_KERNEL);\n\tsb->s_fs_info = fsi;\n\tif (!fsi) {\n\t\terr = -ENOMEM;\n\t\tgoto fail;\n\t}\n\n\terr = debugfs_parse_options(data, &fsi->mount_opts);\n\tif (err)\n\t\tgoto fail;\n\n\terr  =  simple_fill_super(sb, DEBUGFS_MAGIC, debug_files);\n\tif (err)\n\t\tgoto fail;\n\n\tsb->s_op = &debugfs_super_operations;\n\tsb->s_d_op = &debugfs_dops;\n\n\tdebugfs_apply_options(sb);\n\n\treturn 0;\n\nfail:\n\tkfree(fsi);\n\tsb->s_fs_info = NULL;\n\treturn err;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/magic.h>",
      "#include <linux/parser.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/string.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/kobject.h>",
      "#include <linux/init.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct super_operations debugfs_super_operations = {\n\t.statfs\t\t= simple_statfs,\n\t.remount_fs\t= debugfs_remount,\n\t.show_options\t= debugfs_show_options,\n\t.evict_inode\t= debugfs_evict_inode,\n};",
      "static const struct dentry_operations debugfs_dops = {\n\t.d_delete = always_delete_dentry,\n\t.d_automount = debugfs_automount,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "fsi"
          ],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debugfs_apply_options",
          "args": [
            "sb"
          ],
          "line": 225
        },
        "resolved": true,
        "details": {
          "function_name": "debugfs_apply_options",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/debugfs/inode.c",
          "lines": "124-137",
          "snippet": "static int debugfs_apply_options(struct super_block *sb)\n{\n\tstruct debugfs_fs_info *fsi = sb->s_fs_info;\n\tstruct inode *inode = sb->s_root->d_inode;\n\tstruct debugfs_mount_opts *opts = &fsi->mount_opts;\n\n\tinode->i_mode &= ~S_IALLUGO;\n\tinode->i_mode |= opts->mode;\n\n\tinode->i_uid = opts->uid;\n\tinode->i_gid = opts->gid;\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/magic.h>",
            "#include <linux/parser.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/string.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/kobject.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/parser.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fsnotify.h>\n#include <linux/debugfs.h>\n#include <linux/namei.h>\n#include <linux/kobject.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int debugfs_apply_options(struct super_block *sb)\n{\n\tstruct debugfs_fs_info *fsi = sb->s_fs_info;\n\tstruct inode *inode = sb->s_root->d_inode;\n\tstruct debugfs_mount_opts *opts = &fsi->mount_opts;\n\n\tinode->i_mode &= ~S_IALLUGO;\n\tinode->i_mode |= opts->mode;\n\n\tinode->i_uid = opts->uid;\n\tinode->i_gid = opts->gid;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "simple_fill_super",
          "args": [
            "sb",
            "DEBUGFS_MAGIC",
            "debug_files"
          ],
          "line": 218
        },
        "resolved": true,
        "details": {
          "function_name": "simple_fill_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/libfs.c",
          "lines": "477-538",
          "snippet": "int simple_fill_super(struct super_block *s, unsigned long magic,\n\t\t      struct tree_descr *files)\n{\n\tstruct inode *inode;\n\tstruct dentry *root;\n\tstruct dentry *dentry;\n\tint i;\n\n\ts->s_blocksize = PAGE_CACHE_SIZE;\n\ts->s_blocksize_bits = PAGE_CACHE_SHIFT;\n\ts->s_magic = magic;\n\ts->s_op = &simple_super_operations;\n\ts->s_time_gran = 1;\n\n\tinode = new_inode(s);\n\tif (!inode)\n\t\treturn -ENOMEM;\n\t/*\n\t * because the root inode is 1, the files array must not contain an\n\t * entry at index 1\n\t */\n\tinode->i_ino = 1;\n\tinode->i_mode = S_IFDIR | 0755;\n\tinode->i_atime = inode->i_mtime = inode->i_ctime = CURRENT_TIME;\n\tinode->i_op = &simple_dir_inode_operations;\n\tinode->i_fop = &simple_dir_operations;\n\tset_nlink(inode, 2);\n\troot = d_make_root(inode);\n\tif (!root)\n\t\treturn -ENOMEM;\n\tfor (i = 0; !files->name || files->name[0]; i++, files++) {\n\t\tif (!files->name)\n\t\t\tcontinue;\n\n\t\t/* warn if it tries to conflict with the root inode */\n\t\tif (unlikely(i == 1))\n\t\t\tprintk(KERN_WARNING \"%s: %s passed in a files array\"\n\t\t\t\t\"with an index of 1!\\n\", __func__,\n\t\t\t\ts->s_type->name);\n\n\t\tdentry = d_alloc_name(root, files->name);\n\t\tif (!dentry)\n\t\t\tgoto out;\n\t\tinode = new_inode(s);\n\t\tif (!inode) {\n\t\t\tdput(dentry);\n\t\t\tgoto out;\n\t\t}\n\t\tinode->i_mode = S_IFREG | files->mode;\n\t\tinode->i_atime = inode->i_mtime = inode->i_ctime = CURRENT_TIME;\n\t\tinode->i_fop = files->ops;\n\t\tinode->i_ino = i;\n\t\td_add(dentry, inode);\n\t}\n\ts->s_root = root;\n\treturn 0;\nout:\n\td_genocide(root);\n\tshrink_dcache_parent(root);\n\tdput(root);\n\treturn -ENOMEM;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "const struct file_operations simple_dir_operations = {\n\t.open\t\t= dcache_dir_open,\n\t.release\t= dcache_dir_close,\n\t.llseek\t\t= dcache_dir_lseek,\n\t.read\t\t= generic_read_dir,\n\t.iterate\t= dcache_readdir,\n\t.fsync\t\t= noop_fsync,\n};",
            "const struct inode_operations simple_dir_inode_operations = {\n\t.lookup\t\t= simple_lookup,\n};",
            "static const struct super_operations simple_super_operations = {\n\t.statfs\t\t= simple_statfs,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nconst struct file_operations simple_dir_operations = {\n\t.open\t\t= dcache_dir_open,\n\t.release\t= dcache_dir_close,\n\t.llseek\t\t= dcache_dir_lseek,\n\t.read\t\t= generic_read_dir,\n\t.iterate\t= dcache_readdir,\n\t.fsync\t\t= noop_fsync,\n};\nconst struct inode_operations simple_dir_inode_operations = {\n\t.lookup\t\t= simple_lookup,\n};\nstatic const struct super_operations simple_super_operations = {\n\t.statfs\t\t= simple_statfs,\n};\n\nint simple_fill_super(struct super_block *s, unsigned long magic,\n\t\t      struct tree_descr *files)\n{\n\tstruct inode *inode;\n\tstruct dentry *root;\n\tstruct dentry *dentry;\n\tint i;\n\n\ts->s_blocksize = PAGE_CACHE_SIZE;\n\ts->s_blocksize_bits = PAGE_CACHE_SHIFT;\n\ts->s_magic = magic;\n\ts->s_op = &simple_super_operations;\n\ts->s_time_gran = 1;\n\n\tinode = new_inode(s);\n\tif (!inode)\n\t\treturn -ENOMEM;\n\t/*\n\t * because the root inode is 1, the files array must not contain an\n\t * entry at index 1\n\t */\n\tinode->i_ino = 1;\n\tinode->i_mode = S_IFDIR | 0755;\n\tinode->i_atime = inode->i_mtime = inode->i_ctime = CURRENT_TIME;\n\tinode->i_op = &simple_dir_inode_operations;\n\tinode->i_fop = &simple_dir_operations;\n\tset_nlink(inode, 2);\n\troot = d_make_root(inode);\n\tif (!root)\n\t\treturn -ENOMEM;\n\tfor (i = 0; !files->name || files->name[0]; i++, files++) {\n\t\tif (!files->name)\n\t\t\tcontinue;\n\n\t\t/* warn if it tries to conflict with the root inode */\n\t\tif (unlikely(i == 1))\n\t\t\tprintk(KERN_WARNING \"%s: %s passed in a files array\"\n\t\t\t\t\"with an index of 1!\\n\", __func__,\n\t\t\t\ts->s_type->name);\n\n\t\tdentry = d_alloc_name(root, files->name);\n\t\tif (!dentry)\n\t\t\tgoto out;\n\t\tinode = new_inode(s);\n\t\tif (!inode) {\n\t\t\tdput(dentry);\n\t\t\tgoto out;\n\t\t}\n\t\tinode->i_mode = S_IFREG | files->mode;\n\t\tinode->i_atime = inode->i_mtime = inode->i_ctime = CURRENT_TIME;\n\t\tinode->i_fop = files->ops;\n\t\tinode->i_ino = i;\n\t\td_add(dentry, inode);\n\t}\n\ts->s_root = root;\n\treturn 0;\nout:\n\td_genocide(root);\n\tshrink_dcache_parent(root);\n\tdput(root);\n\treturn -ENOMEM;\n}"
        }
      },
      {
        "call_info": {
          "callee": "debugfs_parse_options",
          "args": [
            "data",
            "&fsi->mount_opts"
          ],
          "line": 214
        },
        "resolved": true,
        "details": {
          "function_name": "debugfs_parse_options",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/debugfs/inode.c",
          "lines": "76-122",
          "snippet": "static int debugfs_parse_options(char *data, struct debugfs_mount_opts *opts)\n{\n\tsubstring_t args[MAX_OPT_ARGS];\n\tint option;\n\tint token;\n\tkuid_t uid;\n\tkgid_t gid;\n\tchar *p;\n\n\topts->mode = DEBUGFS_DEFAULT_MODE;\n\n\twhile ((p = strsep(&data, \",\")) != NULL) {\n\t\tif (!*p)\n\t\t\tcontinue;\n\n\t\ttoken = match_token(p, tokens, args);\n\t\tswitch (token) {\n\t\tcase Opt_uid:\n\t\t\tif (match_int(&args[0], &option))\n\t\t\t\treturn -EINVAL;\n\t\t\tuid = make_kuid(current_user_ns(), option);\n\t\t\tif (!uid_valid(uid))\n\t\t\t\treturn -EINVAL;\n\t\t\topts->uid = uid;\n\t\t\tbreak;\n\t\tcase Opt_gid:\n\t\t\tif (match_int(&args[0], &option))\n\t\t\t\treturn -EINVAL;\n\t\t\tgid = make_kgid(current_user_ns(), option);\n\t\t\tif (!gid_valid(gid))\n\t\t\t\treturn -EINVAL;\n\t\t\topts->gid = gid;\n\t\t\tbreak;\n\t\tcase Opt_mode:\n\t\t\tif (match_octal(&args[0], &option))\n\t\t\t\treturn -EINVAL;\n\t\t\topts->mode = option & S_IALLUGO;\n\t\t\tbreak;\n\t\t/*\n\t\t * We might like to report bad mount options here;\n\t\t * but traditionally debugfs has ignored all mount options\n\t\t */\n\t\t}\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/magic.h>",
            "#include <linux/parser.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/string.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/kobject.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define DEBUGFS_DEFAULT_MODE\t0700"
          ],
          "globals_used": [
            "static const match_table_t tokens = {\n\t{Opt_uid, \"uid=%u\"},\n\t{Opt_gid, \"gid=%u\"},\n\t{Opt_mode, \"mode=%o\"},\n\t{Opt_err, NULL}\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/parser.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fsnotify.h>\n#include <linux/debugfs.h>\n#include <linux/namei.h>\n#include <linux/kobject.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\n#define DEBUGFS_DEFAULT_MODE\t0700\n\nstatic const match_table_t tokens = {\n\t{Opt_uid, \"uid=%u\"},\n\t{Opt_gid, \"gid=%u\"},\n\t{Opt_mode, \"mode=%o\"},\n\t{Opt_err, NULL}\n};\n\nstatic int debugfs_parse_options(char *data, struct debugfs_mount_opts *opts)\n{\n\tsubstring_t args[MAX_OPT_ARGS];\n\tint option;\n\tint token;\n\tkuid_t uid;\n\tkgid_t gid;\n\tchar *p;\n\n\topts->mode = DEBUGFS_DEFAULT_MODE;\n\n\twhile ((p = strsep(&data, \",\")) != NULL) {\n\t\tif (!*p)\n\t\t\tcontinue;\n\n\t\ttoken = match_token(p, tokens, args);\n\t\tswitch (token) {\n\t\tcase Opt_uid:\n\t\t\tif (match_int(&args[0], &option))\n\t\t\t\treturn -EINVAL;\n\t\t\tuid = make_kuid(current_user_ns(), option);\n\t\t\tif (!uid_valid(uid))\n\t\t\t\treturn -EINVAL;\n\t\t\topts->uid = uid;\n\t\t\tbreak;\n\t\tcase Opt_gid:\n\t\t\tif (match_int(&args[0], &option))\n\t\t\t\treturn -EINVAL;\n\t\t\tgid = make_kgid(current_user_ns(), option);\n\t\t\tif (!gid_valid(gid))\n\t\t\t\treturn -EINVAL;\n\t\t\topts->gid = gid;\n\t\t\tbreak;\n\t\tcase Opt_mode:\n\t\t\tif (match_octal(&args[0], &option))\n\t\t\t\treturn -EINVAL;\n\t\t\topts->mode = option & S_IALLUGO;\n\t\t\tbreak;\n\t\t/*\n\t\t * We might like to report bad mount options here;\n\t\t * but traditionally debugfs has ignored all mount options\n\t\t */\n\t\t}\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct debugfs_fs_info)",
            "GFP_KERNEL"
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "save_mount_options",
          "args": [
            "sb",
            "data"
          ],
          "line": 205
        },
        "resolved": true,
        "details": {
          "function_name": "save_mount_options",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "1189-1193",
          "snippet": "void save_mount_options(struct super_block *sb, char *options)\n{\n\tBUG_ON(sb->s_options);\n\trcu_assign_pointer(sb->s_options, kstrdup(options, GFP_KERNEL));\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nvoid save_mount_options(struct super_block *sb, char *options)\n{\n\tBUG_ON(sb->s_options);\n\trcu_assign_pointer(sb->s_options, kstrdup(options, GFP_KERNEL));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/parser.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fsnotify.h>\n#include <linux/debugfs.h>\n#include <linux/namei.h>\n#include <linux/kobject.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic const struct super_operations debugfs_super_operations = {\n\t.statfs\t\t= simple_statfs,\n\t.remount_fs\t= debugfs_remount,\n\t.show_options\t= debugfs_show_options,\n\t.evict_inode\t= debugfs_evict_inode,\n};\nstatic const struct dentry_operations debugfs_dops = {\n\t.d_delete = always_delete_dentry,\n\t.d_automount = debugfs_automount,\n};\n\nstatic int debug_fill_super(struct super_block *sb, void *data, int silent)\n{\n\tstatic struct tree_descr debug_files[] = {{\"\"}};\n\tstruct debugfs_fs_info *fsi;\n\tint err;\n\n\tsave_mount_options(sb, data);\n\n\tfsi = kzalloc(sizeof(struct debugfs_fs_info), GFP_KERNEL);\n\tsb->s_fs_info = fsi;\n\tif (!fsi) {\n\t\terr = -ENOMEM;\n\t\tgoto fail;\n\t}\n\n\terr = debugfs_parse_options(data, &fsi->mount_opts);\n\tif (err)\n\t\tgoto fail;\n\n\terr  =  simple_fill_super(sb, DEBUGFS_MAGIC, debug_files);\n\tif (err)\n\t\tgoto fail;\n\n\tsb->s_op = &debugfs_super_operations;\n\tsb->s_d_op = &debugfs_dops;\n\n\tdebugfs_apply_options(sb);\n\n\treturn 0;\n\nfail:\n\tkfree(fsi);\n\tsb->s_fs_info = NULL;\n\treturn err;\n}"
  },
  {
    "function_name": "debugfs_automount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/debugfs/inode.c",
    "lines": "187-192",
    "snippet": "static struct vfsmount *debugfs_automount(struct path *path)\n{\n\tstruct vfsmount *(*f)(void *);\n\tf = (struct vfsmount *(*)(void *))path->dentry->d_fsdata;\n\treturn f(path->dentry->d_inode->i_private);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/magic.h>",
      "#include <linux/parser.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/string.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/kobject.h>",
      "#include <linux/init.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "f",
          "args": [
            "path->dentry->d_inode->i_private"
          ],
          "line": 191
        },
        "resolved": true,
        "details": {
          "function_name": "debugfs_remove_recursive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/debugfs/inode.c",
          "lines": "580-641",
          "snippet": "void debugfs_remove_recursive(struct dentry *dentry)\n{\n\tstruct dentry *child, *parent;\n\n\tif (IS_ERR_OR_NULL(dentry))\n\t\treturn;\n\n\tparent = dentry->d_parent;\n\tif (!parent || !parent->d_inode)\n\t\treturn;\n\n\tparent = dentry;\n down:\n\tmutex_lock(&parent->d_inode->i_mutex);\n loop:\n\t/*\n\t * The parent->d_subdirs is protected by the d_lock. Outside that\n\t * lock, the child can be unlinked and set to be freed which can\n\t * use the d_u.d_child as the rcu head and corrupt this list.\n\t */\n\tspin_lock(&parent->d_lock);\n\tlist_for_each_entry(child, &parent->d_subdirs, d_child) {\n\t\tif (!debugfs_positive(child))\n\t\t\tcontinue;\n\n\t\t/* perhaps simple_empty(child) makes more sense */\n\t\tif (!list_empty(&child->d_subdirs)) {\n\t\t\tspin_unlock(&parent->d_lock);\n\t\t\tmutex_unlock(&parent->d_inode->i_mutex);\n\t\t\tparent = child;\n\t\t\tgoto down;\n\t\t}\n\n\t\tspin_unlock(&parent->d_lock);\n\n\t\tif (!__debugfs_remove(child, parent))\n\t\t\tsimple_release_fs(&debugfs_mount, &debugfs_mount_count);\n\n\t\t/*\n\t\t * The parent->d_lock protects agaist child from unlinking\n\t\t * from d_subdirs. When releasing the parent->d_lock we can\n\t\t * no longer trust that the next pointer is valid.\n\t\t * Restart the loop. We'll skip this one with the\n\t\t * debugfs_positive() check.\n\t\t */\n\t\tgoto loop;\n\t}\n\tspin_unlock(&parent->d_lock);\n\n\tmutex_unlock(&parent->d_inode->i_mutex);\n\tchild = parent;\n\tparent = parent->d_parent;\n\tmutex_lock(&parent->d_inode->i_mutex);\n\n\tif (child != dentry)\n\t\t/* go up */\n\t\tgoto loop;\n\n\tif (!__debugfs_remove(child, parent))\n\t\tsimple_release_fs(&debugfs_mount, &debugfs_mount_count);\n\tmutex_unlock(&parent->d_inode->i_mutex);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/magic.h>",
            "#include <linux/parser.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/string.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/kobject.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct vfsmount *debugfs_mount;",
            "static int debugfs_mount_count;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/parser.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fsnotify.h>\n#include <linux/debugfs.h>\n#include <linux/namei.h>\n#include <linux/kobject.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic struct vfsmount *debugfs_mount;\nstatic int debugfs_mount_count;\n\nvoid debugfs_remove_recursive(struct dentry *dentry)\n{\n\tstruct dentry *child, *parent;\n\n\tif (IS_ERR_OR_NULL(dentry))\n\t\treturn;\n\n\tparent = dentry->d_parent;\n\tif (!parent || !parent->d_inode)\n\t\treturn;\n\n\tparent = dentry;\n down:\n\tmutex_lock(&parent->d_inode->i_mutex);\n loop:\n\t/*\n\t * The parent->d_subdirs is protected by the d_lock. Outside that\n\t * lock, the child can be unlinked and set to be freed which can\n\t * use the d_u.d_child as the rcu head and corrupt this list.\n\t */\n\tspin_lock(&parent->d_lock);\n\tlist_for_each_entry(child, &parent->d_subdirs, d_child) {\n\t\tif (!debugfs_positive(child))\n\t\t\tcontinue;\n\n\t\t/* perhaps simple_empty(child) makes more sense */\n\t\tif (!list_empty(&child->d_subdirs)) {\n\t\t\tspin_unlock(&parent->d_lock);\n\t\t\tmutex_unlock(&parent->d_inode->i_mutex);\n\t\t\tparent = child;\n\t\t\tgoto down;\n\t\t}\n\n\t\tspin_unlock(&parent->d_lock);\n\n\t\tif (!__debugfs_remove(child, parent))\n\t\t\tsimple_release_fs(&debugfs_mount, &debugfs_mount_count);\n\n\t\t/*\n\t\t * The parent->d_lock protects agaist child from unlinking\n\t\t * from d_subdirs. When releasing the parent->d_lock we can\n\t\t * no longer trust that the next pointer is valid.\n\t\t * Restart the loop. We'll skip this one with the\n\t\t * debugfs_positive() check.\n\t\t */\n\t\tgoto loop;\n\t}\n\tspin_unlock(&parent->d_lock);\n\n\tmutex_unlock(&parent->d_inode->i_mutex);\n\tchild = parent;\n\tparent = parent->d_parent;\n\tmutex_lock(&parent->d_inode->i_mutex);\n\n\tif (child != dentry)\n\t\t/* go up */\n\t\tgoto loop;\n\n\tif (!__debugfs_remove(child, parent))\n\t\tsimple_release_fs(&debugfs_mount, &debugfs_mount_count);\n\tmutex_unlock(&parent->d_inode->i_mutex);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/parser.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fsnotify.h>\n#include <linux/debugfs.h>\n#include <linux/namei.h>\n#include <linux/kobject.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic struct vfsmount *debugfs_automount(struct path *path)\n{\n\tstruct vfsmount *(*f)(void *);\n\tf = (struct vfsmount *(*)(void *))path->dentry->d_fsdata;\n\treturn f(path->dentry->d_inode->i_private);\n}"
  },
  {
    "function_name": "debugfs_evict_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/debugfs/inode.c",
    "lines": "172-178",
    "snippet": "static void debugfs_evict_inode(struct inode *inode)\n{\n\ttruncate_inode_pages_final(&inode->i_data);\n\tclear_inode(inode);\n\tif (S_ISLNK(inode->i_mode))\n\t\tkfree(inode->i_private);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/magic.h>",
      "#include <linux/parser.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/string.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/kobject.h>",
      "#include <linux/init.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "inode->i_private"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISLNK",
          "args": [
            "inode->i_mode"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_inode",
          "args": [
            "inode"
          ],
          "line": 175
        },
        "resolved": true,
        "details": {
          "function_name": "clear_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "488-505",
          "snippet": "void clear_inode(struct inode *inode)\n{\n\tmight_sleep();\n\t/*\n\t * We have to cycle tree_lock here because reclaim can be still in the\n\t * process of removing the last page (in __delete_from_page_cache())\n\t * and we must not free mapping under it.\n\t */\n\tspin_lock_irq(&inode->i_data.tree_lock);\n\tBUG_ON(inode->i_data.nrpages);\n\tBUG_ON(inode->i_data.nrshadows);\n\tspin_unlock_irq(&inode->i_data.tree_lock);\n\tBUG_ON(!list_empty(&inode->i_data.private_list));\n\tBUG_ON(!(inode->i_state & I_FREEING));\n\tBUG_ON(inode->i_state & I_CLEAR);\n\t/* don't need i_lock here, no concurrent mods to i_state */\n\tinode->i_state = I_FREEING | I_CLEAR;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid clear_inode(struct inode *inode)\n{\n\tmight_sleep();\n\t/*\n\t * We have to cycle tree_lock here because reclaim can be still in the\n\t * process of removing the last page (in __delete_from_page_cache())\n\t * and we must not free mapping under it.\n\t */\n\tspin_lock_irq(&inode->i_data.tree_lock);\n\tBUG_ON(inode->i_data.nrpages);\n\tBUG_ON(inode->i_data.nrshadows);\n\tspin_unlock_irq(&inode->i_data.tree_lock);\n\tBUG_ON(!list_empty(&inode->i_data.private_list));\n\tBUG_ON(!(inode->i_state & I_FREEING));\n\tBUG_ON(inode->i_state & I_CLEAR);\n\t/* don't need i_lock here, no concurrent mods to i_state */\n\tinode->i_state = I_FREEING | I_CLEAR;\n}"
        }
      },
      {
        "call_info": {
          "callee": "truncate_inode_pages_final",
          "args": [
            "&inode->i_data"
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/parser.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fsnotify.h>\n#include <linux/debugfs.h>\n#include <linux/namei.h>\n#include <linux/kobject.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void debugfs_evict_inode(struct inode *inode)\n{\n\ttruncate_inode_pages_final(&inode->i_data);\n\tclear_inode(inode);\n\tif (S_ISLNK(inode->i_mode))\n\t\tkfree(inode->i_private);\n}"
  },
  {
    "function_name": "debugfs_show_options",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/debugfs/inode.c",
    "lines": "155-170",
    "snippet": "static int debugfs_show_options(struct seq_file *m, struct dentry *root)\n{\n\tstruct debugfs_fs_info *fsi = root->d_sb->s_fs_info;\n\tstruct debugfs_mount_opts *opts = &fsi->mount_opts;\n\n\tif (!uid_eq(opts->uid, GLOBAL_ROOT_UID))\n\t\tseq_printf(m, \",uid=%u\",\n\t\t\t   from_kuid_munged(&init_user_ns, opts->uid));\n\tif (!gid_eq(opts->gid, GLOBAL_ROOT_GID))\n\t\tseq_printf(m, \",gid=%u\",\n\t\t\t   from_kgid_munged(&init_user_ns, opts->gid));\n\tif (opts->mode != DEBUGFS_DEFAULT_MODE)\n\t\tseq_printf(m, \",mode=%o\", opts->mode);\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/magic.h>",
      "#include <linux/parser.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/string.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/kobject.h>",
      "#include <linux/init.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define DEBUGFS_DEFAULT_MODE\t0700"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\",mode=%o\"",
            "opts->mode"
          ],
          "line": 167
        },
        "resolved": true,
        "details": {
          "function_name": "seq_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "416-426",
          "snippet": "int seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tint ret;\n\tva_list args;\n\n\tva_start(args, f);\n\tret = seq_vprintf(m, f, args);\n\tva_end(args);\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tint ret;\n\tva_list args;\n\n\tva_start(args, f);\n\tret = seq_vprintf(m, f, args);\n\tva_end(args);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "from_kgid_munged",
          "args": [
            "&init_user_ns",
            "opts->gid"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gid_eq",
          "args": [
            "opts->gid",
            "GLOBAL_ROOT_GID"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "from_kuid_munged",
          "args": [
            "&init_user_ns",
            "opts->uid"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uid_eq",
          "args": [
            "opts->uid",
            "GLOBAL_ROOT_UID"
          ],
          "line": 160
        },
        "resolved": true,
        "details": {
          "function_name": "uuid_equal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/uuid.c",
          "lines": "59-63",
          "snippet": "int\nuuid_equal(uuid_t *uuid1, uuid_t *uuid2)\n{\n\treturn memcmp(uuid1, uuid2, sizeof(uuid_t)) ? 0 : 1;\n}",
          "includes": [
            "#include <xfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <xfs.h>\n\nint\nuuid_equal(uuid_t *uuid1, uuid_t *uuid2)\n{\n\treturn memcmp(uuid1, uuid2, sizeof(uuid_t)) ? 0 : 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/parser.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fsnotify.h>\n#include <linux/debugfs.h>\n#include <linux/namei.h>\n#include <linux/kobject.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\n#define DEBUGFS_DEFAULT_MODE\t0700\n\nstatic int debugfs_show_options(struct seq_file *m, struct dentry *root)\n{\n\tstruct debugfs_fs_info *fsi = root->d_sb->s_fs_info;\n\tstruct debugfs_mount_opts *opts = &fsi->mount_opts;\n\n\tif (!uid_eq(opts->uid, GLOBAL_ROOT_UID))\n\t\tseq_printf(m, \",uid=%u\",\n\t\t\t   from_kuid_munged(&init_user_ns, opts->uid));\n\tif (!gid_eq(opts->gid, GLOBAL_ROOT_GID))\n\t\tseq_printf(m, \",gid=%u\",\n\t\t\t   from_kgid_munged(&init_user_ns, opts->gid));\n\tif (opts->mode != DEBUGFS_DEFAULT_MODE)\n\t\tseq_printf(m, \",mode=%o\", opts->mode);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "debugfs_remount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/debugfs/inode.c",
    "lines": "139-153",
    "snippet": "static int debugfs_remount(struct super_block *sb, int *flags, char *data)\n{\n\tint err;\n\tstruct debugfs_fs_info *fsi = sb->s_fs_info;\n\n\tsync_filesystem(sb);\n\terr = debugfs_parse_options(data, &fsi->mount_opts);\n\tif (err)\n\t\tgoto fail;\n\n\tdebugfs_apply_options(sb);\n\nfail:\n\treturn err;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/magic.h>",
      "#include <linux/parser.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/string.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/kobject.h>",
      "#include <linux/init.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "debugfs_apply_options",
          "args": [
            "sb"
          ],
          "line": 149
        },
        "resolved": true,
        "details": {
          "function_name": "debugfs_apply_options",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/debugfs/inode.c",
          "lines": "124-137",
          "snippet": "static int debugfs_apply_options(struct super_block *sb)\n{\n\tstruct debugfs_fs_info *fsi = sb->s_fs_info;\n\tstruct inode *inode = sb->s_root->d_inode;\n\tstruct debugfs_mount_opts *opts = &fsi->mount_opts;\n\n\tinode->i_mode &= ~S_IALLUGO;\n\tinode->i_mode |= opts->mode;\n\n\tinode->i_uid = opts->uid;\n\tinode->i_gid = opts->gid;\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/magic.h>",
            "#include <linux/parser.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/string.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/kobject.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/parser.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fsnotify.h>\n#include <linux/debugfs.h>\n#include <linux/namei.h>\n#include <linux/kobject.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int debugfs_apply_options(struct super_block *sb)\n{\n\tstruct debugfs_fs_info *fsi = sb->s_fs_info;\n\tstruct inode *inode = sb->s_root->d_inode;\n\tstruct debugfs_mount_opts *opts = &fsi->mount_opts;\n\n\tinode->i_mode &= ~S_IALLUGO;\n\tinode->i_mode |= opts->mode;\n\n\tinode->i_uid = opts->uid;\n\tinode->i_gid = opts->gid;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "debugfs_parse_options",
          "args": [
            "data",
            "&fsi->mount_opts"
          ],
          "line": 145
        },
        "resolved": true,
        "details": {
          "function_name": "debugfs_parse_options",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/debugfs/inode.c",
          "lines": "76-122",
          "snippet": "static int debugfs_parse_options(char *data, struct debugfs_mount_opts *opts)\n{\n\tsubstring_t args[MAX_OPT_ARGS];\n\tint option;\n\tint token;\n\tkuid_t uid;\n\tkgid_t gid;\n\tchar *p;\n\n\topts->mode = DEBUGFS_DEFAULT_MODE;\n\n\twhile ((p = strsep(&data, \",\")) != NULL) {\n\t\tif (!*p)\n\t\t\tcontinue;\n\n\t\ttoken = match_token(p, tokens, args);\n\t\tswitch (token) {\n\t\tcase Opt_uid:\n\t\t\tif (match_int(&args[0], &option))\n\t\t\t\treturn -EINVAL;\n\t\t\tuid = make_kuid(current_user_ns(), option);\n\t\t\tif (!uid_valid(uid))\n\t\t\t\treturn -EINVAL;\n\t\t\topts->uid = uid;\n\t\t\tbreak;\n\t\tcase Opt_gid:\n\t\t\tif (match_int(&args[0], &option))\n\t\t\t\treturn -EINVAL;\n\t\t\tgid = make_kgid(current_user_ns(), option);\n\t\t\tif (!gid_valid(gid))\n\t\t\t\treturn -EINVAL;\n\t\t\topts->gid = gid;\n\t\t\tbreak;\n\t\tcase Opt_mode:\n\t\t\tif (match_octal(&args[0], &option))\n\t\t\t\treturn -EINVAL;\n\t\t\topts->mode = option & S_IALLUGO;\n\t\t\tbreak;\n\t\t/*\n\t\t * We might like to report bad mount options here;\n\t\t * but traditionally debugfs has ignored all mount options\n\t\t */\n\t\t}\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/magic.h>",
            "#include <linux/parser.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/string.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/kobject.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define DEBUGFS_DEFAULT_MODE\t0700"
          ],
          "globals_used": [
            "static const match_table_t tokens = {\n\t{Opt_uid, \"uid=%u\"},\n\t{Opt_gid, \"gid=%u\"},\n\t{Opt_mode, \"mode=%o\"},\n\t{Opt_err, NULL}\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/parser.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fsnotify.h>\n#include <linux/debugfs.h>\n#include <linux/namei.h>\n#include <linux/kobject.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\n#define DEBUGFS_DEFAULT_MODE\t0700\n\nstatic const match_table_t tokens = {\n\t{Opt_uid, \"uid=%u\"},\n\t{Opt_gid, \"gid=%u\"},\n\t{Opt_mode, \"mode=%o\"},\n\t{Opt_err, NULL}\n};\n\nstatic int debugfs_parse_options(char *data, struct debugfs_mount_opts *opts)\n{\n\tsubstring_t args[MAX_OPT_ARGS];\n\tint option;\n\tint token;\n\tkuid_t uid;\n\tkgid_t gid;\n\tchar *p;\n\n\topts->mode = DEBUGFS_DEFAULT_MODE;\n\n\twhile ((p = strsep(&data, \",\")) != NULL) {\n\t\tif (!*p)\n\t\t\tcontinue;\n\n\t\ttoken = match_token(p, tokens, args);\n\t\tswitch (token) {\n\t\tcase Opt_uid:\n\t\t\tif (match_int(&args[0], &option))\n\t\t\t\treturn -EINVAL;\n\t\t\tuid = make_kuid(current_user_ns(), option);\n\t\t\tif (!uid_valid(uid))\n\t\t\t\treturn -EINVAL;\n\t\t\topts->uid = uid;\n\t\t\tbreak;\n\t\tcase Opt_gid:\n\t\t\tif (match_int(&args[0], &option))\n\t\t\t\treturn -EINVAL;\n\t\t\tgid = make_kgid(current_user_ns(), option);\n\t\t\tif (!gid_valid(gid))\n\t\t\t\treturn -EINVAL;\n\t\t\topts->gid = gid;\n\t\t\tbreak;\n\t\tcase Opt_mode:\n\t\t\tif (match_octal(&args[0], &option))\n\t\t\t\treturn -EINVAL;\n\t\t\topts->mode = option & S_IALLUGO;\n\t\t\tbreak;\n\t\t/*\n\t\t * We might like to report bad mount options here;\n\t\t * but traditionally debugfs has ignored all mount options\n\t\t */\n\t\t}\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sync_filesystem",
          "args": [
            "sb"
          ],
          "line": 144
        },
        "resolved": true,
        "details": {
          "function_name": "sync_filesystem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sync.c",
          "lines": "47-67",
          "snippet": "int sync_filesystem(struct super_block *sb)\n{\n\tint ret;\n\n\t/*\n\t * We need to be protected against the filesystem going from\n\t * r/o to r/w or vice versa.\n\t */\n\tWARN_ON(!rwsem_is_locked(&sb->s_umount));\n\n\t/*\n\t * No point in syncing out anything if the filesystem is read-only.\n\t */\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn 0;\n\n\tret = __sync_filesystem(sb, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\treturn __sync_filesystem(sb, 1);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/backing-dev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/linkage.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/namei.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/backing-dev.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/linkage.h>\n#include <linux/syscalls.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/kernel.h>\n\nint sync_filesystem(struct super_block *sb)\n{\n\tint ret;\n\n\t/*\n\t * We need to be protected against the filesystem going from\n\t * r/o to r/w or vice versa.\n\t */\n\tWARN_ON(!rwsem_is_locked(&sb->s_umount));\n\n\t/*\n\t * No point in syncing out anything if the filesystem is read-only.\n\t */\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn 0;\n\n\tret = __sync_filesystem(sb, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\treturn __sync_filesystem(sb, 1);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/parser.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fsnotify.h>\n#include <linux/debugfs.h>\n#include <linux/namei.h>\n#include <linux/kobject.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int debugfs_remount(struct super_block *sb, int *flags, char *data)\n{\n\tint err;\n\tstruct debugfs_fs_info *fsi = sb->s_fs_info;\n\n\tsync_filesystem(sb);\n\terr = debugfs_parse_options(data, &fsi->mount_opts);\n\tif (err)\n\t\tgoto fail;\n\n\tdebugfs_apply_options(sb);\n\nfail:\n\treturn err;\n}"
  },
  {
    "function_name": "debugfs_apply_options",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/debugfs/inode.c",
    "lines": "124-137",
    "snippet": "static int debugfs_apply_options(struct super_block *sb)\n{\n\tstruct debugfs_fs_info *fsi = sb->s_fs_info;\n\tstruct inode *inode = sb->s_root->d_inode;\n\tstruct debugfs_mount_opts *opts = &fsi->mount_opts;\n\n\tinode->i_mode &= ~S_IALLUGO;\n\tinode->i_mode |= opts->mode;\n\n\tinode->i_uid = opts->uid;\n\tinode->i_gid = opts->gid;\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/magic.h>",
      "#include <linux/parser.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/string.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/kobject.h>",
      "#include <linux/init.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/parser.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fsnotify.h>\n#include <linux/debugfs.h>\n#include <linux/namei.h>\n#include <linux/kobject.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int debugfs_apply_options(struct super_block *sb)\n{\n\tstruct debugfs_fs_info *fsi = sb->s_fs_info;\n\tstruct inode *inode = sb->s_root->d_inode;\n\tstruct debugfs_mount_opts *opts = &fsi->mount_opts;\n\n\tinode->i_mode &= ~S_IALLUGO;\n\tinode->i_mode |= opts->mode;\n\n\tinode->i_uid = opts->uid;\n\tinode->i_gid = opts->gid;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "debugfs_parse_options",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/debugfs/inode.c",
    "lines": "76-122",
    "snippet": "static int debugfs_parse_options(char *data, struct debugfs_mount_opts *opts)\n{\n\tsubstring_t args[MAX_OPT_ARGS];\n\tint option;\n\tint token;\n\tkuid_t uid;\n\tkgid_t gid;\n\tchar *p;\n\n\topts->mode = DEBUGFS_DEFAULT_MODE;\n\n\twhile ((p = strsep(&data, \",\")) != NULL) {\n\t\tif (!*p)\n\t\t\tcontinue;\n\n\t\ttoken = match_token(p, tokens, args);\n\t\tswitch (token) {\n\t\tcase Opt_uid:\n\t\t\tif (match_int(&args[0], &option))\n\t\t\t\treturn -EINVAL;\n\t\t\tuid = make_kuid(current_user_ns(), option);\n\t\t\tif (!uid_valid(uid))\n\t\t\t\treturn -EINVAL;\n\t\t\topts->uid = uid;\n\t\t\tbreak;\n\t\tcase Opt_gid:\n\t\t\tif (match_int(&args[0], &option))\n\t\t\t\treturn -EINVAL;\n\t\t\tgid = make_kgid(current_user_ns(), option);\n\t\t\tif (!gid_valid(gid))\n\t\t\t\treturn -EINVAL;\n\t\t\topts->gid = gid;\n\t\t\tbreak;\n\t\tcase Opt_mode:\n\t\t\tif (match_octal(&args[0], &option))\n\t\t\t\treturn -EINVAL;\n\t\t\topts->mode = option & S_IALLUGO;\n\t\t\tbreak;\n\t\t/*\n\t\t * We might like to report bad mount options here;\n\t\t * but traditionally debugfs has ignored all mount options\n\t\t */\n\t\t}\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/magic.h>",
      "#include <linux/parser.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/string.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/kobject.h>",
      "#include <linux/init.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define DEBUGFS_DEFAULT_MODE\t0700"
    ],
    "globals_used": [
      "static const match_table_t tokens = {\n\t{Opt_uid, \"uid=%u\"},\n\t{Opt_gid, \"gid=%u\"},\n\t{Opt_mode, \"mode=%o\"},\n\t{Opt_err, NULL}\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "match_octal",
          "args": [
            "&args[0]",
            "&option"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gid_valid",
          "args": [
            "gid"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "make_kgid",
          "args": [
            "current_user_ns()",
            "option"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_user_ns",
          "args": [],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "match_int",
          "args": [
            "&args[0]",
            "&option"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uid_valid",
          "args": [
            "uid"
          ],
          "line": 97
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_uuid_valid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/sys.c",
          "lines": "73-82",
          "snippet": "static int gfs2_uuid_valid(const u8 *uuid)\n{\n\tint i;\n\n\tfor (i = 0; i < 16; i++) {\n\t\tif (uuid[i])\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"recovery.h\"",
            "#include \"glops.h\"",
            "#include \"util.h\"",
            "#include \"quota.h\"",
            "#include \"glock.h\"",
            "#include \"super.h\"",
            "#include \"sys.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/genhd.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/kobject.h>",
            "#include <linux/module.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"recovery.h\"\n#include \"glops.h\"\n#include \"util.h\"\n#include \"quota.h\"\n#include \"glock.h\"\n#include \"super.h\"\n#include \"sys.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/genhd.h>\n#include <linux/gfs2_ondisk.h>\n#include <asm/uaccess.h>\n#include <linux/kobject.h>\n#include <linux/module.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n\nstatic int gfs2_uuid_valid(const u8 *uuid)\n{\n\tint i;\n\n\tfor (i = 0; i < 16; i++) {\n\t\tif (uuid[i])\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "make_kuid",
          "args": [
            "current_user_ns()",
            "option"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_user_ns",
          "args": [],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "match_int",
          "args": [
            "&args[0]",
            "&option"
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "match_token",
          "args": [
            "p",
            "tokens",
            "args"
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strsep",
          "args": [
            "&data",
            "\",\""
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/parser.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fsnotify.h>\n#include <linux/debugfs.h>\n#include <linux/namei.h>\n#include <linux/kobject.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\n#define DEBUGFS_DEFAULT_MODE\t0700\n\nstatic const match_table_t tokens = {\n\t{Opt_uid, \"uid=%u\"},\n\t{Opt_gid, \"gid=%u\"},\n\t{Opt_mode, \"mode=%o\"},\n\t{Opt_err, NULL}\n};\n\nstatic int debugfs_parse_options(char *data, struct debugfs_mount_opts *opts)\n{\n\tsubstring_t args[MAX_OPT_ARGS];\n\tint option;\n\tint token;\n\tkuid_t uid;\n\tkgid_t gid;\n\tchar *p;\n\n\topts->mode = DEBUGFS_DEFAULT_MODE;\n\n\twhile ((p = strsep(&data, \",\")) != NULL) {\n\t\tif (!*p)\n\t\t\tcontinue;\n\n\t\ttoken = match_token(p, tokens, args);\n\t\tswitch (token) {\n\t\tcase Opt_uid:\n\t\t\tif (match_int(&args[0], &option))\n\t\t\t\treturn -EINVAL;\n\t\t\tuid = make_kuid(current_user_ns(), option);\n\t\t\tif (!uid_valid(uid))\n\t\t\t\treturn -EINVAL;\n\t\t\topts->uid = uid;\n\t\t\tbreak;\n\t\tcase Opt_gid:\n\t\t\tif (match_int(&args[0], &option))\n\t\t\t\treturn -EINVAL;\n\t\t\tgid = make_kgid(current_user_ns(), option);\n\t\t\tif (!gid_valid(gid))\n\t\t\t\treturn -EINVAL;\n\t\t\topts->gid = gid;\n\t\t\tbreak;\n\t\tcase Opt_mode:\n\t\t\tif (match_octal(&args[0], &option))\n\t\t\t\treturn -EINVAL;\n\t\t\topts->mode = option & S_IALLUGO;\n\t\t\tbreak;\n\t\t/*\n\t\t * We might like to report bad mount options here;\n\t\t * but traditionally debugfs has ignored all mount options\n\t\t */\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "debugfs_positive",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/debugfs/inode.c",
    "lines": "47-50",
    "snippet": "static inline int debugfs_positive(struct dentry *dentry)\n{\n\treturn dentry->d_inode && !d_unhashed(dentry);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/magic.h>",
      "#include <linux/parser.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/string.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/kobject.h>",
      "#include <linux/init.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "d_unhashed",
          "args": [
            "dentry"
          ],
          "line": 49
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/parser.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fsnotify.h>\n#include <linux/debugfs.h>\n#include <linux/namei.h>\n#include <linux/kobject.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic inline int debugfs_positive(struct dentry *dentry)\n{\n\treturn dentry->d_inode && !d_unhashed(dentry);\n}"
  },
  {
    "function_name": "debugfs_get_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/debugfs/inode.c",
    "lines": "37-45",
    "snippet": "static struct inode *debugfs_get_inode(struct super_block *sb)\n{\n\tstruct inode *inode = new_inode(sb);\n\tif (inode) {\n\t\tinode->i_ino = get_next_ino();\n\t\tinode->i_atime = inode->i_mtime = inode->i_ctime = CURRENT_TIME;\n\t}\n\treturn inode;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/magic.h>",
      "#include <linux/parser.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/string.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/kobject.h>",
      "#include <linux/init.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_next_ino",
          "args": [],
          "line": 41
        },
        "resolved": true,
        "details": {
          "function_name": "get_next_ino",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "828-845",
          "snippet": "unsigned int get_next_ino(void)\n{\n\tunsigned int *p = &get_cpu_var(last_ino);\n\tunsigned int res = *p;\n\n#ifdef CONFIG_SMP\n\tif (unlikely((res & (LAST_INO_BATCH-1)) == 0)) {\n\t\tstatic atomic_t shared_last_ino;\n\t\tint next = atomic_add_return(LAST_INO_BATCH, &shared_last_ino);\n\n\t\tres = next - LAST_INO_BATCH;\n\t}\n#endif\n\n\t*p = ++res;\n\tput_cpu_var(last_ino);\n\treturn res;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [
            "#define LAST_INO_BATCH 1024"
          ],
          "globals_used": [
            "static DEFINE_PER_CPU(unsigned int, last_ino);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\n#define LAST_INO_BATCH 1024\n\nstatic DEFINE_PER_CPU(unsigned int, last_ino);\n\nunsigned int get_next_ino(void)\n{\n\tunsigned int *p = &get_cpu_var(last_ino);\n\tunsigned int res = *p;\n\n#ifdef CONFIG_SMP\n\tif (unlikely((res & (LAST_INO_BATCH-1)) == 0)) {\n\t\tstatic atomic_t shared_last_ino;\n\t\tint next = atomic_add_return(LAST_INO_BATCH, &shared_last_ino);\n\n\t\tres = next - LAST_INO_BATCH;\n\t}\n#endif\n\n\t*p = ++res;\n\tput_cpu_var(last_ino);\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "new_inode",
          "args": [
            "sb"
          ],
          "line": 39
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_new_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "924-933",
          "snippet": "void unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/parser.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fsnotify.h>\n#include <linux/debugfs.h>\n#include <linux/namei.h>\n#include <linux/kobject.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic struct inode *debugfs_get_inode(struct super_block *sb)\n{\n\tstruct inode *inode = new_inode(sb);\n\tif (inode) {\n\t\tinode->i_ino = get_next_ino();\n\t\tinode->i_atime = inode->i_mtime = inode->i_ctime = CURRENT_TIME;\n\t}\n\treturn inode;\n}"
  }
]