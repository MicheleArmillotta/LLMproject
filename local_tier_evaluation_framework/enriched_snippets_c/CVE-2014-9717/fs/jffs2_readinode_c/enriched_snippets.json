[
  {
    "function_name": "2_do_clear_inode(str",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/readinode.c",
    "lines": "1412-1451",
    "snippet": "jffs2_do_clear_inode(struct jffs2_sb_info *c, struct jffs2_inode_info *f)\n{\n\tstruct jffs2_full_dirent *fd, *fds;\n\tint deleted;\n\n\tjffs2_xattr_delete_inode(c, f->inocache);\n\tmutex_lock(&f->sem);\n\tdeleted = f->inocache && !f->inocache->pino_nlink;\n\n\tif (f->inocache && f->inocache->state != INO_STATE_CHECKING)\n\t\tjffs2_set_inocache_state(c, f->inocache, INO_STATE_CLEARING);\n\n\tif (f->metadata) {\n\t\tif (deleted)\n\t\t\tjffs2_mark_node_obsolete(c, f->metadata->raw);\n\t\tjffs2_free_full_dnode(f->metadata);\n\t}\n\n\tjffs2_kill_fragtree(&f->fragtree, deleted?c:NULL);\n\n\tif (f->target) {\n\t\tkfree(f->target);\n\t\tf->target = NULL;\n\t}\n\n\tfds = f->dents;\n\twhile(fds) {\n\t\tfd = fds;\n\t\tfds = fd->next;\n\t\tjffs2_free_full_dirent(fd);\n\t}\n\n\tif (f->inocache && f->inocache->state != INO_STATE_CHECKING) {\n\t\tjffs2_set_inocache_state(c, f->inocache, INO_STATE_CHECKEDABSENT);\n\t\tif (f->inocache->nodes == (void *)f->inocache)\n\t\t\tjffs2_del_ino_cache(c, f->inocache);\n\t}\n\n\tmutex_unlock(&f->sem);\n}",
    "includes": [
      "include \"nodelist.h\"",
      "include <linux/compiler.h>\n#",
      "include <linux/mtd/mtd.h>\n#",
      "include <linux/pagemap.h>\n#",
      "include <linux/crc32.h>\n#",
      "include <linux/fs.h>\n#",
      "include <linux/slab.h>\n#",
      "include <linux/sched.h>\n#",
      "include <linux/kernel.h>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "x_unlock(&f-",
          "args": [
            "sem);\n}"
          ],
          "line": 1450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "2_del_ino_cache(c,",
          "args": [
            "-",
            "nocache);"
          ],
          "line": 1447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "2_set_inocache_state(c,",
          "args": [
            "-",
            "nocache, IN",
            "STATE_CHECKEDABSENT);"
          ],
          "line": 1445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "2_free_full_dirent(fd)",
          "args": [],
          "line": 1441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e(f->",
          "args": [
            "arget);"
          ],
          "line": 1433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "2_kill_fragtree(&f-",
          "args": [
            "fragtree, de",
            "ted?c:NULL);"
          ],
          "line": 1430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "2_free_full_dnode(f->",
          "args": [
            "etadata);"
          ],
          "line": 1427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "2_mark_node_obsolete(c,",
          "args": [
            "-",
            "etadata->raw);"
          ],
          "line": 1426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "2_set_inocache_state(c,",
          "args": [
            "-",
            "nocache, IN",
            "STATE_CLEARING);"
          ],
          "line": 1422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "x_lock(&f-",
          "args": [
            "sem);"
          ],
          "line": 1418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "2_xattr_delete_inode(c,",
          "args": [
            "-",
            "nocache);"
          ],
          "line": 1417
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"nodelist.h\"\ninclude <linux/compiler.h>\n#\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/pagemap.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/fs.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/sched.h>\n#\ninclude <linux/kernel.h>\n#\n\njffs2_do_clear_inode(struct jffs2_sb_info *c, struct jffs2_inode_info *f)\n{\n\tstruct jffs2_full_dirent *fd, *fds;\n\tint deleted;\n\n\tjffs2_xattr_delete_inode(c, f->inocache);\n\tmutex_lock(&f->sem);\n\tdeleted = f->inocache && !f->inocache->pino_nlink;\n\n\tif (f->inocache && f->inocache->state != INO_STATE_CHECKING)\n\t\tjffs2_set_inocache_state(c, f->inocache, INO_STATE_CLEARING);\n\n\tif (f->metadata) {\n\t\tif (deleted)\n\t\t\tjffs2_mark_node_obsolete(c, f->metadata->raw);\n\t\tjffs2_free_full_dnode(f->metadata);\n\t}\n\n\tjffs2_kill_fragtree(&f->fragtree, deleted?c:NULL);\n\n\tif (f->target) {\n\t\tkfree(f->target);\n\t\tf->target = NULL;\n\t}\n\n\tfds = f->dents;\n\twhile(fds) {\n\t\tfd = fds;\n\t\tfds = fd->next;\n\t\tjffs2_free_full_dirent(fd);\n\t}\n\n\tif (f->inocache && f->inocache->state != INO_STATE_CHECKING) {\n\t\tjffs2_set_inocache_state(c, f->inocache, INO_STATE_CHECKEDABSENT);\n\t\tif (f->inocache->nodes == (void *)f->inocache)\n\t\t\tjffs2_del_ino_cache(c, f->inocache);\n\t}\n\n\tmutex_unlock(&f->sem);\n}"
  },
  {
    "function_name": "2_do_crccheck_inode(str",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/readinode.c",
    "lines": "1389-1410",
    "snippet": "jffs2_do_crccheck_inode(struct jffs2_sb_info *c, struct jffs2_inode_cache *ic)\n{\n\tstruct jffs2_raw_inode n;\n\tstruct jffs2_inode_info *f = kzalloc(sizeof(*f), GFP_KERNEL);\n\tint ret;\n\n\tif (!f)\n\t\treturn -ENOMEM;\n\n\tmutex_init(&f->sem);\n\tmutex_lock(&f->sem);\n\tf->inocache = ic;\n\n\tret = jffs2_do_read_inode_internal(c, f, &n);\n\tif (!ret) {\n\t\tmutex_unlock(&f->sem);\n\t\tjffs2_do_clear_inode(c, f);\n\t}\n\tjffs2_xattr_do_crccheck_inode(c, ic);\n\tkfree (f);\n\treturn ret;\n}\n\nvo",
    "includes": [
      "include \"nodelist.h\"",
      "include <linux/compiler.h>\n#",
      "include <linux/mtd/mtd.h>\n#",
      "include <linux/pagemap.h>\n#",
      "include <linux/crc32.h>\n#",
      "include <linux/fs.h>\n#",
      "include <linux/slab.h>\n#",
      "include <linux/sched.h>\n#",
      "include <linux/kernel.h>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "e (f)",
          "args": [],
          "line": 1408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "2_xattr_do_crccheck_inode(c,",
          "args": [
            "c"
          ],
          "line": 1407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "2_do_clear_inode(c,",
          "args": [
            ")"
          ],
          "line": 1405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "x_unlock(&f-",
          "args": [
            "sem);"
          ],
          "line": 1404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "2_do_read_inode_internal(c,",
          "args": [
            ",",
            "n"
          ],
          "line": 1402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "x_lock(&f-",
          "args": [
            "sem);"
          ],
          "line": 1399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "x_init(&f-",
          "args": [
            "sem);"
          ],
          "line": 1398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "loc(siz",
          "args": [
            "of(*f), GF",
            "KERNEL);"
          ],
          "line": 1392
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"nodelist.h\"\ninclude <linux/compiler.h>\n#\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/pagemap.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/fs.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/sched.h>\n#\ninclude <linux/kernel.h>\n#\n\njffs2_do_crccheck_inode(struct jffs2_sb_info *c, struct jffs2_inode_cache *ic)\n{\n\tstruct jffs2_raw_inode n;\n\tstruct jffs2_inode_info *f = kzalloc(sizeof(*f), GFP_KERNEL);\n\tint ret;\n\n\tif (!f)\n\t\treturn -ENOMEM;\n\n\tmutex_init(&f->sem);\n\tmutex_lock(&f->sem);\n\tf->inocache = ic;\n\n\tret = jffs2_do_read_inode_internal(c, f, &n);\n\tif (!ret) {\n\t\tmutex_unlock(&f->sem);\n\t\tjffs2_do_clear_inode(c, f);\n\t}\n\tjffs2_xattr_do_crccheck_inode(c, ic);\n\tkfree (f);\n\treturn ret;\n}\n\nvo"
  },
  {
    "function_name": "2_do_read_inode(str",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/readinode.c",
    "lines": "1325-1387",
    "snippet": "jffs2_do_read_inode(struct jffs2_sb_info *c, struct jffs2_inode_info *f,\n\t\t\tuint32_t ino, struct jffs2_raw_inode *latest_node)\n{\n\tdbg_readinode(\"read inode #%u\\n\", ino);\n\n retry_inocache:\n\tspin_lock(&c->inocache_lock);\n\tf->inocache = jffs2_get_ino_cache(c, ino);\n\n\tif (f->inocache) {\n\t\t/* Check its state. We may need to wait before we can use it */\n\t\tswitch(f->inocache->state) {\n\t\tcase INO_STATE_UNCHECKED:\n\t\tcase INO_STATE_CHECKEDABSENT:\n\t\t\tf->inocache->state = INO_STATE_READING;\n\t\t\tbreak;\n\n\t\tcase INO_STATE_CHECKING:\n\t\tcase INO_STATE_GC:\n\t\t\t/* If it's in either of these states, we need\n\t\t\t   to wait for whoever's got it to finish and\n\t\t\t   put it back. */\n\t\t\tdbg_readinode(\"waiting for ino #%u in state %d\\n\", ino, f->inocache->state);\n\t\t\tsleep_on_spinunlock(&c->inocache_wq, &c->inocache_lock);\n\t\t\tgoto retry_inocache;\n\n\t\tcase INO_STATE_READING:\n\t\tcase INO_STATE_PRESENT:\n\t\t\t/* Eep. This should never happen. It can\n\t\t\thappen if Linux calls read_inode() again\n\t\t\tbefore clear_inode() has finished though. */\n\t\t\tJFFS2_ERROR(\"Eep. Trying to read_inode #%u when it's already in state %d!\\n\", ino, f->inocache->state);\n\t\t\t/* Fail. That's probably better than allowing it to succeed */\n\t\t\tf->inocache = NULL;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tBUG();\n\t\t}\n\t}\n\tspin_unlock(&c->inocache_lock);\n\n\tif (!f->inocache && ino == 1) {\n\t\t/* Special case - no root inode on medium */\n\t\tf->inocache = jffs2_alloc_inode_cache();\n\t\tif (!f->inocache) {\n\t\t\tJFFS2_ERROR(\"cannot allocate inocache for root inode\\n\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tdbg_readinode(\"creating inocache for root inode\\n\");\n\t\tmemset(f->inocache, 0, sizeof(struct jffs2_inode_cache));\n\t\tf->inocache->ino = f->inocache->pino_nlink = 1;\n\t\tf->inocache->nodes = (struct jffs2_raw_node_ref *)f->inocache;\n\t\tf->inocache->state = INO_STATE_READING;\n\t\tjffs2_add_ino_cache(c, f->inocache);\n\t}\n\tif (!f->inocache) {\n\t\tJFFS2_ERROR(\"requestied to read an nonexistent ino %u\\n\", ino);\n\t\treturn -ENOENT;\n\t}\n\n\treturn jffs2_do_read_inode_internal(c, f, latest_node);\n}\n\nin",
    "includes": [
      "include \"nodelist.h\"",
      "include <linux/compiler.h>\n#",
      "include <linux/mtd/mtd.h>\n#",
      "include <linux/pagemap.h>\n#",
      "include <linux/crc32.h>\n#",
      "include <linux/fs.h>\n#",
      "include <linux/slab.h>\n#",
      "include <linux/sched.h>\n#",
      "include <linux/kernel.h>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "2_do_read_inode_internal(c,",
          "args": [
            ",",
            "a",
            "st_node);\n}"
          ],
          "line": 1386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "2_ERROR(\"re",
          "args": [
            "uestied to read an nonexistent ino %u\\n\", in",
            ";"
          ],
          "line": 1382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "2_add_ino_cache(c,",
          "args": [
            "-",
            "nocache);"
          ],
          "line": 1379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "et(f->",
          "args": [
            "nocache, 0,",
            "i",
            "of(struct jffs2_inode_cache));"
          ],
          "line": 1375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "readinode(\"cr",
          "args": [
            "ating inocache for root inode\\n\");"
          ],
          "line": 1374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "2_ERROR(\"ca",
          "args": [
            "not allocate inocache for root inode\\n\");"
          ],
          "line": 1371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "2_alloc_inode_cache();",
          "args": [],
          "line": 1369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_unlock(&c-",
          "args": [
            "inocache_lock);"
          ],
          "line": 1365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ");",
          "args": [],
          "line": 1362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "2_ERROR(\"Ee",
          "args": [
            ". Trying to read_inode #%u when it's already in state %d!\\n\", in",
            "f-",
            "nocache->state);"
          ],
          "line": 1356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p_on_spinunlock(&c-",
          "args": [
            "inocache_wq, &c",
            "inocache_lock);"
          ],
          "line": 1348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "readinode(\"wa",
          "args": [
            "ting for ino #%u in state %d\\n\", in",
            "f-",
            "nocache->state);"
          ],
          "line": 1347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "2_get_ino_cache(c,",
          "args": [
            "n",
            ";"
          ],
          "line": 1332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_lock(&c-",
          "args": [
            "inocache_lock);"
          ],
          "line": 1331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "readinode(\"re",
          "args": [
            "d inode #%u\\n\", in",
            ";"
          ],
          "line": 1328
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"nodelist.h\"\ninclude <linux/compiler.h>\n#\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/pagemap.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/fs.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/sched.h>\n#\ninclude <linux/kernel.h>\n#\n\njffs2_do_read_inode(struct jffs2_sb_info *c, struct jffs2_inode_info *f,\n\t\t\tuint32_t ino, struct jffs2_raw_inode *latest_node)\n{\n\tdbg_readinode(\"read inode #%u\\n\", ino);\n\n retry_inocache:\n\tspin_lock(&c->inocache_lock);\n\tf->inocache = jffs2_get_ino_cache(c, ino);\n\n\tif (f->inocache) {\n\t\t/* Check its state. We may need to wait before we can use it */\n\t\tswitch(f->inocache->state) {\n\t\tcase INO_STATE_UNCHECKED:\n\t\tcase INO_STATE_CHECKEDABSENT:\n\t\t\tf->inocache->state = INO_STATE_READING;\n\t\t\tbreak;\n\n\t\tcase INO_STATE_CHECKING:\n\t\tcase INO_STATE_GC:\n\t\t\t/* If it's in either of these states, we need\n\t\t\t   to wait for whoever's got it to finish and\n\t\t\t   put it back. */\n\t\t\tdbg_readinode(\"waiting for ino #%u in state %d\\n\", ino, f->inocache->state);\n\t\t\tsleep_on_spinunlock(&c->inocache_wq, &c->inocache_lock);\n\t\t\tgoto retry_inocache;\n\n\t\tcase INO_STATE_READING:\n\t\tcase INO_STATE_PRESENT:\n\t\t\t/* Eep. This should never happen. It can\n\t\t\thappen if Linux calls read_inode() again\n\t\t\tbefore clear_inode() has finished though. */\n\t\t\tJFFS2_ERROR(\"Eep. Trying to read_inode #%u when it's already in state %d!\\n\", ino, f->inocache->state);\n\t\t\t/* Fail. That's probably better than allowing it to succeed */\n\t\t\tf->inocache = NULL;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tBUG();\n\t\t}\n\t}\n\tspin_unlock(&c->inocache_lock);\n\n\tif (!f->inocache && ino == 1) {\n\t\t/* Special case - no root inode on medium */\n\t\tf->inocache = jffs2_alloc_inode_cache();\n\t\tif (!f->inocache) {\n\t\t\tJFFS2_ERROR(\"cannot allocate inocache for root inode\\n\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tdbg_readinode(\"creating inocache for root inode\\n\");\n\t\tmemset(f->inocache, 0, sizeof(struct jffs2_inode_cache));\n\t\tf->inocache->ino = f->inocache->pino_nlink = 1;\n\t\tf->inocache->nodes = (struct jffs2_raw_node_ref *)f->inocache;\n\t\tf->inocache->state = INO_STATE_READING;\n\t\tjffs2_add_ino_cache(c, f->inocache);\n\t}\n\tif (!f->inocache) {\n\t\tJFFS2_ERROR(\"requestied to read an nonexistent ino %u\\n\", ino);\n\t\treturn -ENOENT;\n\t}\n\n\treturn jffs2_do_read_inode_internal(c, f, latest_node);\n}\n\nin"
  },
  {
    "function_name": "2_do_read_inode_internal(str",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/readinode.c",
    "lines": "1125-1322",
    "snippet": "ic int jffs2_do_read_inode_internal(struct jffs2_sb_info *c,\n\t\t\t\t\tstruct jffs2_inode_info *f,\n\t\t\t\t\tstruct jffs2_raw_inode *latest_node)\n{\n\tstruct jffs2_readinode_info rii;\n\tuint32_t crc, new_size;\n\tsize_t retlen;\n\tint ret;\n\n\tdbg_readinode(\"ino #%u pino/nlink is %d\\n\", f->inocache->ino,\n\t\t      f->inocache->pino_nlink);\n\n\tmemset(&rii, 0, sizeof(rii));\n\n\t/* Grab all nodes relevant to this ino */\n\tret = jffs2_get_inode_nodes(c, f, &rii);\n\n\tif (ret) {\n\t\tJFFS2_ERROR(\"cannot read nodes for ino %u, returned error is %d\\n\", f->inocache->ino, ret);\n\t\tif (f->inocache->state == INO_STATE_READING)\n\t\t\tjffs2_set_inocache_state(c, f->inocache, INO_STATE_CHECKEDABSENT);\n\t\treturn ret;\n\t}\n\n\tret = jffs2_build_inode_fragtree(c, f, &rii);\n\tif (ret) {\n\t\tJFFS2_ERROR(\"Failed to build final fragtree for inode #%u: error %d\\n\",\n\t\t\t    f->inocache->ino, ret);\n\t\tif (f->inocache->state == INO_STATE_READING)\n\t\t\tjffs2_set_inocache_state(c, f->inocache, INO_STATE_CHECKEDABSENT);\n\t\tjffs2_free_tmp_dnode_info_list(&rii.tn_root);\n\t\t/* FIXME: We could at least crc-check them all */\n\t\tif (rii.mdata_tn) {\n\t\t\tjffs2_free_full_dnode(rii.mdata_tn->fn);\n\t\t\tjffs2_free_tmp_dnode_info(rii.mdata_tn);\n\t\t\trii.mdata_tn = NULL;\n\t\t}\n\t\treturn ret;\n\t}\n\n\tif (rii.mdata_tn) {\n\t\tif (rii.mdata_tn->fn->raw == rii.latest_ref) {\n\t\t\tf->metadata = rii.mdata_tn->fn;\n\t\t\tjffs2_free_tmp_dnode_info(rii.mdata_tn);\n\t\t} else {\n\t\t\tjffs2_kill_tn(c, rii.mdata_tn);\n\t\t}\n\t\trii.mdata_tn = NULL;\n\t}\n\n\tf->dents = rii.fds;\n\n\tjffs2_dbg_fragtree_paranoia_check_nolock(f);\n\n\tif (unlikely(!rii.latest_ref)) {\n\t\t/* No data nodes for this inode. */\n\t\tif (f->inocache->ino != 1) {\n\t\t\tJFFS2_WARNING(\"no data nodes found for ino #%u\\n\", f->inocache->ino);\n\t\t\tif (!rii.fds) {\n\t\t\t\tif (f->inocache->state == INO_STATE_READING)\n\t\t\t\t\tjffs2_set_inocache_state(c, f->inocache, INO_STATE_CHECKEDABSENT);\n\t\t\t\treturn -EIO;\n\t\t\t}\n\t\t\tJFFS2_NOTICE(\"but it has children so we fake some modes for it\\n\");\n\t\t}\n\t\tlatest_node->mode = cpu_to_jemode(S_IFDIR|S_IRUGO|S_IWUSR|S_IXUGO);\n\t\tlatest_node->version = cpu_to_je32(0);\n\t\tlatest_node->atime = latest_node->ctime = latest_node->mtime = cpu_to_je32(0);\n\t\tlatest_node->isize = cpu_to_je32(0);\n\t\tlatest_node->gid = cpu_to_je16(0);\n\t\tlatest_node->uid = cpu_to_je16(0);\n\t\tif (f->inocache->state == INO_STATE_READING)\n\t\t\tjffs2_set_inocache_state(c, f->inocache, INO_STATE_PRESENT);\n\t\treturn 0;\n\t}\n\n\tret = jffs2_flash_read(c, ref_offset(rii.latest_ref), sizeof(*latest_node), &retlen, (void *)latest_node);\n\tif (ret || retlen != sizeof(*latest_node)) {\n\t\tJFFS2_ERROR(\"failed to read from flash: error %d, %zd of %zd bytes read\\n\",\n\t\t\tret, retlen, sizeof(*latest_node));\n\t\t/* FIXME: If this fails, there seems to be a memory leak. Find it. */\n\t\tmutex_unlock(&f->sem);\n\t\tjffs2_do_clear_inode(c, f);\n\t\treturn ret?ret:-EIO;\n\t}\n\n\tcrc = crc32(0, latest_node, sizeof(*latest_node)-8);\n\tif (crc != je32_to_cpu(latest_node->node_crc)) {\n\t\tJFFS2_ERROR(\"CRC failed for read_inode of inode %u at physical location 0x%x\\n\",\n\t\t\tf->inocache->ino, ref_offset(rii.latest_ref));\n\t\tmutex_unlock(&f->sem);\n\t\tjffs2_do_clear_inode(c, f);\n\t\treturn -EIO;\n\t}\n\n\tswitch(jemode_to_cpu(latest_node->mode) & S_IFMT) {\n\tcase S_IFDIR:\n\t\tif (rii.mctime_ver > je32_to_cpu(latest_node->version)) {\n\t\t\t/* The times in the latest_node are actually older than\n\t\t\t   mctime in the latest dirent. Cheat. */\n\t\t\tlatest_node->ctime = latest_node->mtime = cpu_to_je32(rii.latest_mctime);\n\t\t}\n\t\tbreak;\n\n\n\tcase S_IFREG:\n\t\t/* If it was a regular file, truncate it to the latest node's isize */\n\t\tnew_size = jffs2_truncate_fragtree(c, &f->fragtree, je32_to_cpu(latest_node->isize));\n\t\tif (new_size != je32_to_cpu(latest_node->isize)) {\n\t\t\tJFFS2_WARNING(\"Truncating ino #%u to %d bytes failed because it only had %d bytes to start with!\\n\",\n\t\t\t\t      f->inocache->ino, je32_to_cpu(latest_node->isize), new_size);\n\t\t\tlatest_node->isize = cpu_to_je32(new_size);\n\t\t}\n\t\tbreak;\n\n\tcase S_IFLNK:\n\t\t/* Hack to work around broken isize in old symlink code.\n\t\t   Remove this when dwmw2 comes to his senses and stops\n\t\t   symlinks from being an entirely gratuitous special\n\t\t   case. */\n\t\tif (!je32_to_cpu(latest_node->isize))\n\t\t\tlatest_node->isize = latest_node->dsize;\n\n\t\tif (f->inocache->state != INO_STATE_CHECKING) {\n\t\t\t/* Symlink's inode data is the target path. Read it and\n\t\t\t * keep in RAM to facilitate quick follow symlink\n\t\t\t * operation. */\n\t\t\tuint32_t csize = je32_to_cpu(latest_node->csize);\n\t\t\tif (csize > JFFS2_MAX_NAME_LEN) {\n\t\t\t\tmutex_unlock(&f->sem);\n\t\t\t\tjffs2_do_clear_inode(c, f);\n\t\t\t\treturn -ENAMETOOLONG;\n\t\t\t}\n\t\t\tf->target = kmalloc(csize + 1, GFP_KERNEL);\n\t\t\tif (!f->target) {\n\t\t\t\tJFFS2_ERROR(\"can't allocate %u bytes of memory for the symlink target path cache\\n\", csize);\n\t\t\t\tmutex_unlock(&f->sem);\n\t\t\t\tjffs2_do_clear_inode(c, f);\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\n\t\t\tret = jffs2_flash_read(c, ref_offset(rii.latest_ref) + sizeof(*latest_node),\n\t\t\t\t\t       csize, &retlen, (char *)f->target);\n\n\t\t\tif (ret || retlen != csize) {\n\t\t\t\tif (retlen != csize)\n\t\t\t\t\tret = -EIO;\n\t\t\t\tkfree(f->target);\n\t\t\t\tf->target = NULL;\n\t\t\t\tmutex_unlock(&f->sem);\n\t\t\t\tjffs2_do_clear_inode(c, f);\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\tf->target[csize] = '\\0';\n\t\t\tdbg_readinode(\"symlink's target '%s' cached\\n\", f->target);\n\t\t}\n\n\t\t/* fall through... */\n\n\tcase S_IFBLK:\n\tcase S_IFCHR:\n\t\t/* Certain inode types should have only one data node, and it's\n\t\t   kept as the metadata node */\n\t\tif (f->metadata) {\n\t\t\tJFFS2_ERROR(\"Argh. Special inode #%u with mode 0%o had metadata node\\n\",\n\t\t\t       f->inocache->ino, jemode_to_cpu(latest_node->mode));\n\t\t\tmutex_unlock(&f->sem);\n\t\t\tjffs2_do_clear_inode(c, f);\n\t\t\treturn -EIO;\n\t\t}\n\t\tif (!frag_first(&f->fragtree)) {\n\t\t\tJFFS2_ERROR(\"Argh. Special inode #%u with mode 0%o has no fragments\\n\",\n\t\t\t       f->inocache->ino, jemode_to_cpu(latest_node->mode));\n\t\t\tmutex_unlock(&f->sem);\n\t\t\tjffs2_do_clear_inode(c, f);\n\t\t\treturn -EIO;\n\t\t}\n\t\t/* ASSERT: f->fraglist != NULL */\n\t\tif (frag_next(frag_first(&f->fragtree))) {\n\t\t\tJFFS2_ERROR(\"Argh. Special inode #%u with mode 0x%x had more than one node\\n\",\n\t\t\t       f->inocache->ino, jemode_to_cpu(latest_node->mode));\n\t\t\t/* FIXME: Deal with it - check crc32, check for duplicate node, check times and discard the older one */\n\t\t\tmutex_unlock(&f->sem);\n\t\t\tjffs2_do_clear_inode(c, f);\n\t\t\treturn -EIO;\n\t\t}\n\t\t/* OK. We're happy */\n\t\tf->metadata = frag_first(&f->fragtree)->node;\n\t\tjffs2_free_node_frag(frag_first(&f->fragtree));\n\t\tf->fragtree = RB_ROOT;\n\t\tbreak;\n\t}\n\tif (f->inocache->state == INO_STATE_READING)\n\t\tjffs2_set_inocache_state(c, f->inocache, INO_STATE_PRESENT);\n\n\treturn 0;\n}\n\n/*",
    "includes": [
      "include \"nodelist.h\"",
      "include <linux/compiler.h>\n#",
      "include <linux/mtd/mtd.h>\n#",
      "include <linux/pagemap.h>\n#",
      "include <linux/crc32.h>\n#",
      "include <linux/fs.h>\n#",
      "include <linux/slab.h>\n#",
      "include <linux/sched.h>\n#",
      "include <linux/kernel.h>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "2_set_inocache_state(c,",
          "args": [
            "-",
            "nocache, IN",
            "STATE_PRESENT);"
          ],
          "line": 1319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "2_free_node_frag(fra",
          "args": [
            "_first(&f->fragtree));"
          ],
          "line": 1314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_first(&f-",
          "args": [
            "fragtree));"
          ],
          "line": 1314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_first(&f-",
          "args": [
            "fragtree)->n"
          ],
          "line": 1313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "2_do_clear_inode(c,",
          "args": [
            ")"
          ],
          "line": 1309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "x_unlock(&f-",
          "args": [
            "sem);"
          ],
          "line": 1308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "2_ERROR(\"Ar",
          "args": [
            "h. Special inode #%u with mode 0x%x had more than one node\\n\",",
            "nocache->ino, je",
            "de_to_cpu(latest_node->mode));"
          ],
          "line": 1305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "de_to_cpu(lat",
          "args": [
            "st_node->mode));"
          ],
          "line": 1306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_next(fra",
          "args": [
            "_first(&f->fragtree))) {"
          ],
          "line": 1304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_first(&f-",
          "args": [
            "fragtree)))"
          ],
          "line": 1304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "2_do_clear_inode(c,",
          "args": [
            ")"
          ],
          "line": 1300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "x_unlock(&f-",
          "args": [
            "sem);"
          ],
          "line": 1299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "2_ERROR(\"Ar",
          "args": [
            "h. Special inode #%u with mode 0%o has no fragments\\n\",",
            "nocache->ino, je",
            "de_to_cpu(latest_node->mode));"
          ],
          "line": 1297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "de_to_cpu(lat",
          "args": [
            "st_node->mode));"
          ],
          "line": 1298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_first(&f-",
          "args": [
            "fragtree)) {"
          ],
          "line": 1296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "2_do_clear_inode(c,",
          "args": [
            ")"
          ],
          "line": 1293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "x_unlock(&f-",
          "args": [
            "sem);"
          ],
          "line": 1292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "2_ERROR(\"Ar",
          "args": [
            "h. Special inode #%u with mode 0%o had metadata node\\n\",",
            "nocache->ino, je",
            "de_to_cpu(latest_node->mode));"
          ],
          "line": 1290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "de_to_cpu(lat",
          "args": [
            "st_node->mode));"
          ],
          "line": 1291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "readinode(\"sy",
          "args": [
            "link's target '%s' cached\\n\", f-",
            "arget);"
          ],
          "line": 1280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "2_do_clear_inode(c,",
          "args": [
            ")"
          ],
          "line": 1275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "x_unlock(&f-",
          "args": [
            "sem);"
          ],
          "line": 1274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e(f->",
          "args": [
            "arget);"
          ],
          "line": 1272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "2_flash_read(c,",
          "args": [
            "e",
            "offset(rii.latest_ref) + sizeof(*latest_node),",
            "e, &r",
            "len, (c",
            "r *)f->target);"
          ],
          "line": 1266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "offset(rii",
          "args": [
            "latest_ref) +"
          ],
          "line": 1266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "2_do_clear_inode(c,",
          "args": [
            ")"
          ],
          "line": 1262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "x_unlock(&f-",
          "args": [
            "sem);"
          ],
          "line": 1261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "2_ERROR(\"ca",
          "args": [
            "'t allocate %u bytes of memory for the symlink target path cache\\n\", cs",
            "e);"
          ],
          "line": 1260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "loc(csi",
          "args": [
            "e + 1, GF",
            "KERNEL);"
          ],
          "line": 1258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "2_do_clear_inode(c,",
          "args": [
            ")"
          ],
          "line": 1255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "x_unlock(&f-",
          "args": [
            "sem);"
          ],
          "line": 1254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_to_cpu(lat",
          "args": [
            "st_node->csize);"
          ],
          "line": 1252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_to_cpu(lat",
          "args": [
            "st_node->isize))"
          ],
          "line": 1245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "to_je32(new",
          "args": [
            "size);"
          ],
          "line": 1236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "2_WARNING(\"Tr",
          "args": [
            "ncating ino #%u to %d bytes failed because it only had %d bytes to start with!\\n\",",
            "nocache->ino, je",
            "_to_cpu(latest_node->isize), ne",
            "size);"
          ],
          "line": 1234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_to_cpu(lat",
          "args": [
            "st_node->isize), n"
          ],
          "line": 1235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_to_cpu(lat",
          "args": [
            "st_node->isize)) {"
          ],
          "line": 1233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "2_truncate_fragtree(c,",
          "args": [
            "f",
            "fragtree, je",
            "_to_cpu(latest_node->isize));"
          ],
          "line": 1232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_to_cpu(lat",
          "args": [
            "st_node->isize));"
          ],
          "line": 1232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "to_je32(rii",
          "args": [
            "latest_mctime);"
          ],
          "line": 1225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_to_cpu(lat",
          "args": [
            "st_node->version)) {"
          ],
          "line": 1222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "de_to_cpu(lat",
          "args": [
            "st_node->mode) &"
          ],
          "line": 1220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "2_do_clear_inode(c,",
          "args": [
            ")"
          ],
          "line": 1216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "x_unlock(&f-",
          "args": [
            "sem);"
          ],
          "line": 1215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "2_ERROR(\"CR",
          "args": [
            "failed for read_inode of inode %u at physical location 0x%x\\n\",",
            "nocache->ino, re",
            "offset(rii.latest_ref));"
          ],
          "line": 1213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "offset(rii",
          "args": [
            "latest_ref));"
          ],
          "line": 1214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_to_cpu(lat",
          "args": [
            "st_node->node_crc)) {"
          ],
          "line": 1212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "2(0,",
          "args": [
            "a",
            "st_node, si",
            "of(*latest_node)-8);"
          ],
          "line": 1211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "2_do_clear_inode(c,",
          "args": [
            ")"
          ],
          "line": 1207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "x_unlock(&f-",
          "args": [
            "sem);"
          ],
          "line": 1206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "2_ERROR(\"fa",
          "args": [
            "led to read from flash: error %d, %zd of %zd bytes read\\n\",",
            "re",
            "en, si",
            "of(*latest_node));"
          ],
          "line": 1203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "2_flash_read(c,",
          "args": [
            "e",
            "offset(rii.latest_ref), si",
            "of(*latest_node), &r",
            "len, (v",
            "d *)latest_node);"
          ],
          "line": 1201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "offset(rii",
          "args": [
            "latest_ref), s"
          ],
          "line": 1201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "2_set_inocache_state(c,",
          "args": [
            "-",
            "nocache, IN",
            "STATE_PRESENT);"
          ],
          "line": 1197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "to_je16(0);",
          "args": [],
          "line": 1195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "to_je16(0);",
          "args": [],
          "line": 1194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "to_je32(0);",
          "args": [],
          "line": 1193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "to_je32(0);",
          "args": [],
          "line": 1192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "to_je32(0);",
          "args": [],
          "line": 1191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "to_jemode(S_I",
          "args": [
            "DIR|S_IRUGO|S_IWUSR|S_IXUGO);"
          ],
          "line": 1190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "2_NOTICE(\"bu",
          "args": [
            "it has children so we fake some modes for it\\n\");"
          ],
          "line": 1188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "2_set_inocache_state(c,",
          "args": [
            "-",
            "nocache, IN",
            "STATE_CHECKEDABSENT);"
          ],
          "line": 1185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "2_WARNING(\"no",
          "args": [
            "data nodes found for ino #%u\\n\", f-",
            "nocache->ino);"
          ],
          "line": 1182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kely(!ri",
          "args": [
            ".latest_ref)) {"
          ],
          "line": 1179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "2_dbg_fragtree_paranoia_check_nolock(f);",
          "args": [],
          "line": 1177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "2_kill_tn(c,",
          "args": [
            "i",
            "mdata_tn);"
          ],
          "line": 1170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "2_free_tmp_dnode_info(rii",
          "args": [
            "mdata_tn);"
          ],
          "line": 1168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "2_free_tmp_dnode_info(rii",
          "args": [
            "mdata_tn);"
          ],
          "line": 1159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "2_free_full_dnode(rii",
          "args": [
            "mdata_tn->fn);"
          ],
          "line": 1158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "2_free_tmp_dnode_info_list(&ri",
          "args": [
            ".tn_root);"
          ],
          "line": 1155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "2_set_inocache_state(c,",
          "args": [
            "-",
            "nocache, IN",
            "STATE_CHECKEDABSENT);"
          ],
          "line": 1154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "2_ERROR(\"Fa",
          "args": [
            "led to build final fragtree for inode #%u: error %d\\n\",",
            "nocache->ino, re",
            ";"
          ],
          "line": 1151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "2_build_inode_fragtree(c,",
          "args": [
            ",",
            "r",
            ");"
          ],
          "line": 1149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "2_set_inocache_state(c,",
          "args": [
            "-",
            "nocache, IN",
            "STATE_CHECKEDABSENT);"
          ],
          "line": 1145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "2_ERROR(\"ca",
          "args": [
            "not read nodes for ino %u, returned error is %d\\n\", f-",
            "nocache->ino, re",
            ";"
          ],
          "line": 1143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "2_get_inode_nodes(c,",
          "args": [
            ",",
            "r",
            ");"
          ],
          "line": 1140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "et(&ri",
          "args": [
            ", 0,",
            "i",
            "of(rii));"
          ],
          "line": 1137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "readinode(\"in",
          "args": [
            "#%u pino/nlink is %d\\n\", f-",
            "nocache->ino,",
            "nocache->pino_nlink);"
          ],
          "line": 1134
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"nodelist.h\"\ninclude <linux/compiler.h>\n#\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/pagemap.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/fs.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/sched.h>\n#\ninclude <linux/kernel.h>\n#\n\nic int jffs2_do_read_inode_internal(struct jffs2_sb_info *c,\n\t\t\t\t\tstruct jffs2_inode_info *f,\n\t\t\t\t\tstruct jffs2_raw_inode *latest_node)\n{\n\tstruct jffs2_readinode_info rii;\n\tuint32_t crc, new_size;\n\tsize_t retlen;\n\tint ret;\n\n\tdbg_readinode(\"ino #%u pino/nlink is %d\\n\", f->inocache->ino,\n\t\t      f->inocache->pino_nlink);\n\n\tmemset(&rii, 0, sizeof(rii));\n\n\t/* Grab all nodes relevant to this ino */\n\tret = jffs2_get_inode_nodes(c, f, &rii);\n\n\tif (ret) {\n\t\tJFFS2_ERROR(\"cannot read nodes for ino %u, returned error is %d\\n\", f->inocache->ino, ret);\n\t\tif (f->inocache->state == INO_STATE_READING)\n\t\t\tjffs2_set_inocache_state(c, f->inocache, INO_STATE_CHECKEDABSENT);\n\t\treturn ret;\n\t}\n\n\tret = jffs2_build_inode_fragtree(c, f, &rii);\n\tif (ret) {\n\t\tJFFS2_ERROR(\"Failed to build final fragtree for inode #%u: error %d\\n\",\n\t\t\t    f->inocache->ino, ret);\n\t\tif (f->inocache->state == INO_STATE_READING)\n\t\t\tjffs2_set_inocache_state(c, f->inocache, INO_STATE_CHECKEDABSENT);\n\t\tjffs2_free_tmp_dnode_info_list(&rii.tn_root);\n\t\t/* FIXME: We could at least crc-check them all */\n\t\tif (rii.mdata_tn) {\n\t\t\tjffs2_free_full_dnode(rii.mdata_tn->fn);\n\t\t\tjffs2_free_tmp_dnode_info(rii.mdata_tn);\n\t\t\trii.mdata_tn = NULL;\n\t\t}\n\t\treturn ret;\n\t}\n\n\tif (rii.mdata_tn) {\n\t\tif (rii.mdata_tn->fn->raw == rii.latest_ref) {\n\t\t\tf->metadata = rii.mdata_tn->fn;\n\t\t\tjffs2_free_tmp_dnode_info(rii.mdata_tn);\n\t\t} else {\n\t\t\tjffs2_kill_tn(c, rii.mdata_tn);\n\t\t}\n\t\trii.mdata_tn = NULL;\n\t}\n\n\tf->dents = rii.fds;\n\n\tjffs2_dbg_fragtree_paranoia_check_nolock(f);\n\n\tif (unlikely(!rii.latest_ref)) {\n\t\t/* No data nodes for this inode. */\n\t\tif (f->inocache->ino != 1) {\n\t\t\tJFFS2_WARNING(\"no data nodes found for ino #%u\\n\", f->inocache->ino);\n\t\t\tif (!rii.fds) {\n\t\t\t\tif (f->inocache->state == INO_STATE_READING)\n\t\t\t\t\tjffs2_set_inocache_state(c, f->inocache, INO_STATE_CHECKEDABSENT);\n\t\t\t\treturn -EIO;\n\t\t\t}\n\t\t\tJFFS2_NOTICE(\"but it has children so we fake some modes for it\\n\");\n\t\t}\n\t\tlatest_node->mode = cpu_to_jemode(S_IFDIR|S_IRUGO|S_IWUSR|S_IXUGO);\n\t\tlatest_node->version = cpu_to_je32(0);\n\t\tlatest_node->atime = latest_node->ctime = latest_node->mtime = cpu_to_je32(0);\n\t\tlatest_node->isize = cpu_to_je32(0);\n\t\tlatest_node->gid = cpu_to_je16(0);\n\t\tlatest_node->uid = cpu_to_je16(0);\n\t\tif (f->inocache->state == INO_STATE_READING)\n\t\t\tjffs2_set_inocache_state(c, f->inocache, INO_STATE_PRESENT);\n\t\treturn 0;\n\t}\n\n\tret = jffs2_flash_read(c, ref_offset(rii.latest_ref), sizeof(*latest_node), &retlen, (void *)latest_node);\n\tif (ret || retlen != sizeof(*latest_node)) {\n\t\tJFFS2_ERROR(\"failed to read from flash: error %d, %zd of %zd bytes read\\n\",\n\t\t\tret, retlen, sizeof(*latest_node));\n\t\t/* FIXME: If this fails, there seems to be a memory leak. Find it. */\n\t\tmutex_unlock(&f->sem);\n\t\tjffs2_do_clear_inode(c, f);\n\t\treturn ret?ret:-EIO;\n\t}\n\n\tcrc = crc32(0, latest_node, sizeof(*latest_node)-8);\n\tif (crc != je32_to_cpu(latest_node->node_crc)) {\n\t\tJFFS2_ERROR(\"CRC failed for read_inode of inode %u at physical location 0x%x\\n\",\n\t\t\tf->inocache->ino, ref_offset(rii.latest_ref));\n\t\tmutex_unlock(&f->sem);\n\t\tjffs2_do_clear_inode(c, f);\n\t\treturn -EIO;\n\t}\n\n\tswitch(jemode_to_cpu(latest_node->mode) & S_IFMT) {\n\tcase S_IFDIR:\n\t\tif (rii.mctime_ver > je32_to_cpu(latest_node->version)) {\n\t\t\t/* The times in the latest_node are actually older than\n\t\t\t   mctime in the latest dirent. Cheat. */\n\t\t\tlatest_node->ctime = latest_node->mtime = cpu_to_je32(rii.latest_mctime);\n\t\t}\n\t\tbreak;\n\n\n\tcase S_IFREG:\n\t\t/* If it was a regular file, truncate it to the latest node's isize */\n\t\tnew_size = jffs2_truncate_fragtree(c, &f->fragtree, je32_to_cpu(latest_node->isize));\n\t\tif (new_size != je32_to_cpu(latest_node->isize)) {\n\t\t\tJFFS2_WARNING(\"Truncating ino #%u to %d bytes failed because it only had %d bytes to start with!\\n\",\n\t\t\t\t      f->inocache->ino, je32_to_cpu(latest_node->isize), new_size);\n\t\t\tlatest_node->isize = cpu_to_je32(new_size);\n\t\t}\n\t\tbreak;\n\n\tcase S_IFLNK:\n\t\t/* Hack to work around broken isize in old symlink code.\n\t\t   Remove this when dwmw2 comes to his senses and stops\n\t\t   symlinks from being an entirely gratuitous special\n\t\t   case. */\n\t\tif (!je32_to_cpu(latest_node->isize))\n\t\t\tlatest_node->isize = latest_node->dsize;\n\n\t\tif (f->inocache->state != INO_STATE_CHECKING) {\n\t\t\t/* Symlink's inode data is the target path. Read it and\n\t\t\t * keep in RAM to facilitate quick follow symlink\n\t\t\t * operation. */\n\t\t\tuint32_t csize = je32_to_cpu(latest_node->csize);\n\t\t\tif (csize > JFFS2_MAX_NAME_LEN) {\n\t\t\t\tmutex_unlock(&f->sem);\n\t\t\t\tjffs2_do_clear_inode(c, f);\n\t\t\t\treturn -ENAMETOOLONG;\n\t\t\t}\n\t\t\tf->target = kmalloc(csize + 1, GFP_KERNEL);\n\t\t\tif (!f->target) {\n\t\t\t\tJFFS2_ERROR(\"can't allocate %u bytes of memory for the symlink target path cache\\n\", csize);\n\t\t\t\tmutex_unlock(&f->sem);\n\t\t\t\tjffs2_do_clear_inode(c, f);\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\n\t\t\tret = jffs2_flash_read(c, ref_offset(rii.latest_ref) + sizeof(*latest_node),\n\t\t\t\t\t       csize, &retlen, (char *)f->target);\n\n\t\t\tif (ret || retlen != csize) {\n\t\t\t\tif (retlen != csize)\n\t\t\t\t\tret = -EIO;\n\t\t\t\tkfree(f->target);\n\t\t\t\tf->target = NULL;\n\t\t\t\tmutex_unlock(&f->sem);\n\t\t\t\tjffs2_do_clear_inode(c, f);\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\tf->target[csize] = '\\0';\n\t\t\tdbg_readinode(\"symlink's target '%s' cached\\n\", f->target);\n\t\t}\n\n\t\t/* fall through... */\n\n\tcase S_IFBLK:\n\tcase S_IFCHR:\n\t\t/* Certain inode types should have only one data node, and it's\n\t\t   kept as the metadata node */\n\t\tif (f->metadata) {\n\t\t\tJFFS2_ERROR(\"Argh. Special inode #%u with mode 0%o had metadata node\\n\",\n\t\t\t       f->inocache->ino, jemode_to_cpu(latest_node->mode));\n\t\t\tmutex_unlock(&f->sem);\n\t\t\tjffs2_do_clear_inode(c, f);\n\t\t\treturn -EIO;\n\t\t}\n\t\tif (!frag_first(&f->fragtree)) {\n\t\t\tJFFS2_ERROR(\"Argh. Special inode #%u with mode 0%o has no fragments\\n\",\n\t\t\t       f->inocache->ino, jemode_to_cpu(latest_node->mode));\n\t\t\tmutex_unlock(&f->sem);\n\t\t\tjffs2_do_clear_inode(c, f);\n\t\t\treturn -EIO;\n\t\t}\n\t\t/* ASSERT: f->fraglist != NULL */\n\t\tif (frag_next(frag_first(&f->fragtree))) {\n\t\t\tJFFS2_ERROR(\"Argh. Special inode #%u with mode 0x%x had more than one node\\n\",\n\t\t\t       f->inocache->ino, jemode_to_cpu(latest_node->mode));\n\t\t\t/* FIXME: Deal with it - check crc32, check for duplicate node, check times and discard the older one */\n\t\t\tmutex_unlock(&f->sem);\n\t\t\tjffs2_do_clear_inode(c, f);\n\t\t\treturn -EIO;\n\t\t}\n\t\t/* OK. We're happy */\n\t\tf->metadata = frag_first(&f->fragtree)->node;\n\t\tjffs2_free_node_frag(frag_first(&f->fragtree));\n\t\tf->fragtree = RB_ROOT;\n\t\tbreak;\n\t}\n\tif (f->inocache->state == INO_STATE_READING)\n\t\tjffs2_set_inocache_state(c, f->inocache, INO_STATE_PRESENT);\n\n\treturn 0;\n}\n\n/*"
  },
  {
    "function_name": "2_get_inode_nodes(str",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/readinode.c",
    "lines": "961-1123",
    "snippet": "ic int jffs2_get_inode_nodes(struct jffs2_sb_info *c, struct jffs2_inode_info *f,\n\t\t\t\t struct jffs2_readinode_info *rii)\n{\n\tstruct jffs2_raw_node_ref *ref, *valid_ref;\n\tunsigned char *buf = NULL;\n\tunion jffs2_node_union *node;\n\tsize_t retlen;\n\tint len, err;\n\n\trii->mctime_ver = 0;\n\n\tdbg_readinode(\"ino #%u\\n\", f->inocache->ino);\n\n\t/* FIXME: in case of NOR and available ->point() this\n\t * needs to be fixed. */\n\tlen = sizeof(union jffs2_node_union) + c->wbuf_pagesize;\n\tbuf = kmalloc(len, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tspin_lock(&c->erase_completion_lock);\n\tvalid_ref = jffs2_first_valid_node(f->inocache->nodes);\n\tif (!valid_ref && f->inocache->ino != 1)\n\t\tJFFS2_WARNING(\"Eep. No valid nodes for ino #%u.\\n\", f->inocache->ino);\n\twhile (valid_ref) {\n\t\t/* We can hold a pointer to a non-obsolete node without the spinlock,\n\t\t   but _obsolete_ nodes may disappear at any time, if the block\n\t\t   they're in gets erased. So if we mark 'ref' obsolete while we're\n\t\t   not holding the lock, it can go away immediately. For that reason,\n\t\t   we find the next valid node first, before processing 'ref'.\n\t\t*/\n\t\tref = valid_ref;\n\t\tvalid_ref = jffs2_first_valid_node(ref->next_in_ino);\n\t\tspin_unlock(&c->erase_completion_lock);\n\n\t\tcond_resched();\n\n\t\t/*\n\t\t * At this point we don't know the type of the node we're going\n\t\t * to read, so we do not know the size of its header. In order\n\t\t * to minimize the amount of flash IO we assume the header is\n\t\t * of size = JFFS2_MIN_NODE_HEADER.\n\t\t */\n\t\tlen = JFFS2_MIN_NODE_HEADER;\n\t\tif (jffs2_is_writebuffered(c)) {\n\t\t\tint end, rem;\n\n\t\t\t/*\n\t\t\t * We are about to read JFFS2_MIN_NODE_HEADER bytes,\n\t\t\t * but this flash has some minimal I/O unit. It is\n\t\t\t * possible that we'll need to read more soon, so read\n\t\t\t * up to the next min. I/O unit, in order not to\n\t\t\t * re-read the same min. I/O unit twice.\n\t\t\t */\n\t\t\tend = ref_offset(ref) + len;\n\t\t\trem = end % c->wbuf_pagesize;\n\t\t\tif (rem)\n\t\t\t\tend += c->wbuf_pagesize - rem;\n\t\t\tlen = end - ref_offset(ref);\n\t\t}\n\n\t\tdbg_readinode(\"read %d bytes at %#08x(%d).\\n\", len, ref_offset(ref), ref_flags(ref));\n\n\t\t/* FIXME: point() */\n\t\terr = jffs2_flash_read(c, ref_offset(ref), len, &retlen, buf);\n\t\tif (err) {\n\t\t\tJFFS2_ERROR(\"can not read %d bytes from 0x%08x, error code: %d.\\n\", len, ref_offset(ref), err);\n\t\t\tgoto free_out;\n\t\t}\n\n\t\tif (retlen < len) {\n\t\t\tJFFS2_ERROR(\"short read at %#08x: %zu instead of %d.\\n\", ref_offset(ref), retlen, len);\n\t\t\terr = -EIO;\n\t\t\tgoto free_out;\n\t\t}\n\n\t\tnode = (union jffs2_node_union *)buf;\n\n\t\t/* No need to mask in the valid bit; it shouldn't be invalid */\n\t\tif (je32_to_cpu(node->u.hdr_crc) != crc32(0, node, sizeof(node->u)-4)) {\n\t\t\tJFFS2_NOTICE(\"Node header CRC failed at %#08x. {%04x,%04x,%08x,%08x}\\n\",\n\t\t\t\t     ref_offset(ref), je16_to_cpu(node->u.magic),\n\t\t\t\t     je16_to_cpu(node->u.nodetype),\n\t\t\t\t     je32_to_cpu(node->u.totlen),\n\t\t\t\t     je32_to_cpu(node->u.hdr_crc));\n\t\t\tjffs2_dbg_dump_node(c, ref_offset(ref));\n\t\t\tjffs2_mark_node_obsolete(c, ref);\n\t\t\tgoto cont;\n\t\t}\n\t\tif (je16_to_cpu(node->u.magic) != JFFS2_MAGIC_BITMASK) {\n\t\t\t/* Not a JFFS2 node, whinge and move on */\n\t\t\tJFFS2_NOTICE(\"Wrong magic bitmask 0x%04x in node header at %#08x.\\n\",\n\t\t\t\t     je16_to_cpu(node->u.magic), ref_offset(ref));\n\t\t\tjffs2_mark_node_obsolete(c, ref);\n\t\t\tgoto cont;\n\t\t}\n\n\t\tswitch (je16_to_cpu(node->u.nodetype)) {\n\n\t\tcase JFFS2_NODETYPE_DIRENT:\n\n\t\t\tif (JFFS2_MIN_NODE_HEADER < sizeof(struct jffs2_raw_dirent) &&\n\t\t\t    len < sizeof(struct jffs2_raw_dirent)) {\n\t\t\t\terr = read_more(c, ref, sizeof(struct jffs2_raw_dirent), &len, buf);\n\t\t\t\tif (unlikely(err))\n\t\t\t\t\tgoto free_out;\n\t\t\t}\n\n\t\t\terr = read_direntry(c, ref, &node->d, retlen, rii);\n\t\t\tif (unlikely(err))\n\t\t\t\tgoto free_out;\n\n\t\t\tbreak;\n\n\t\tcase JFFS2_NODETYPE_INODE:\n\n\t\t\tif (JFFS2_MIN_NODE_HEADER < sizeof(struct jffs2_raw_inode) &&\n\t\t\t    len < sizeof(struct jffs2_raw_inode)) {\n\t\t\t\terr = read_more(c, ref, sizeof(struct jffs2_raw_inode), &len, buf);\n\t\t\t\tif (unlikely(err))\n\t\t\t\t\tgoto free_out;\n\t\t\t}\n\n\t\t\terr = read_dnode(c, ref, &node->i, len, rii);\n\t\t\tif (unlikely(err))\n\t\t\t\tgoto free_out;\n\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tif (JFFS2_MIN_NODE_HEADER < sizeof(struct jffs2_unknown_node) &&\n\t\t\t    len < sizeof(struct jffs2_unknown_node)) {\n\t\t\t\terr = read_more(c, ref, sizeof(struct jffs2_unknown_node), &len, buf);\n\t\t\t\tif (unlikely(err))\n\t\t\t\t\tgoto free_out;\n\t\t\t}\n\n\t\t\terr = read_unknown(c, ref, &node->u);\n\t\t\tif (unlikely(err))\n\t\t\t\tgoto free_out;\n\n\t\t}\n\tcont:\n\t\tspin_lock(&c->erase_completion_lock);\n\t}\n\n\tspin_unlock(&c->erase_completion_lock);\n\tkfree(buf);\n\n\tf->highest_version = rii->highest_version;\n\n\tdbg_readinode(\"nodes of inode #%u were read, the highest version is %u, latest_mctime %u, mctime_ver %u.\\n\",\n\t\t      f->inocache->ino, rii->highest_version, rii->latest_mctime,\n\t\t      rii->mctime_ver);\n\treturn 0;\n\n free_out:\n\tjffs2_free_tmp_dnode_info_list(&rii->tn_root);\n\tjffs2_free_full_dirent_list(rii->fds);\n\trii->fds = NULL;\n\tkfree(buf);\n\treturn err;\n}\n\nst",
    "includes": [
      "include \"nodelist.h\"",
      "include <linux/compiler.h>\n#",
      "include <linux/mtd/mtd.h>\n#",
      "include <linux/pagemap.h>\n#",
      "include <linux/crc32.h>\n#",
      "include <linux/fs.h>\n#",
      "include <linux/slab.h>\n#",
      "include <linux/sched.h>\n#",
      "include <linux/kernel.h>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "e(buf",
          "args": [
            ";"
          ],
          "line": 1121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "2_free_full_dirent_list(rii",
          "args": [
            ">fds);"
          ],
          "line": 1119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "2_free_tmp_dnode_info_list(&ri",
          "args": [
            "->tn_root);"
          ],
          "line": 1118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "readinode(\"no",
          "args": [
            "es of inode #%u were read, the highest version is %u, latest_mctime %u, mctime_ver %u.\\n\",",
            "nocache->ino, ri",
            ">highest_version, ri",
            ">latest_mctime,",
            ">mctime_ver);"
          ],
          "line": 1112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e(buf",
          "args": [
            ";"
          ],
          "line": 1108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_unlock(&c-",
          "args": [
            "erase_completion_lock);"
          ],
          "line": 1107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_lock(&c-",
          "args": [
            "erase_completion_lock);"
          ],
          "line": 1104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kely(err",
          "args": [
            ")"
          ],
          "line": 1099
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_unknown(c,",
          "args": [
            "e",
            "&n",
            "e->u);"
          ],
          "line": 1098
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kely(err",
          "args": [
            ")"
          ],
          "line": 1094
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_more(c,",
          "args": [
            "e",
            "si",
            "of(struct jffs2_unknown_node), &l",
            ", bu",
            ";"
          ],
          "line": 1093
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kely(err",
          "args": [
            ")"
          ],
          "line": 1085
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_dnode(c,",
          "args": [
            "e",
            "&n",
            "e->i, le",
            "ri",
            ";"
          ],
          "line": 1084
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kely(err",
          "args": [
            ")"
          ],
          "line": 1080
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_more(c,",
          "args": [
            "e",
            "si",
            "of(struct jffs2_raw_inode), &l",
            ", bu",
            ";"
          ],
          "line": 1079
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kely(err",
          "args": [
            ")"
          ],
          "line": 1070
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_direntry(c,",
          "args": [
            "e",
            "&n",
            "e->d, re",
            "en, ri",
            ";"
          ],
          "line": 1069
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kely(err",
          "args": [
            ")"
          ],
          "line": 1065
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_more(c,",
          "args": [
            "e",
            "si",
            "of(struct jffs2_raw_dirent), &l",
            ", bu",
            ";"
          ],
          "line": 1064
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_to_cpu(nod",
          "args": [
            "->u.nodetype)) {"
          ],
          "line": 1058
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "2_mark_node_obsolete(c,",
          "args": [
            "e",
            ";"
          ],
          "line": 1054
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "2_NOTICE(\"Wr",
          "args": [
            "ng magic bitmask 0x%04x in node header at %#08x.\\n\",",
            "_to_cpu(node->u.magic), re",
            "offset(ref));"
          ],
          "line": 1052
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "offset(ref",
          "args": [
            ");"
          ],
          "line": 1053
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_to_cpu(nod",
          "args": [
            "->u.magic), r"
          ],
          "line": 1053
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_to_cpu(nod",
          "args": [
            "->u.magic) !="
          ],
          "line": 1050
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "2_mark_node_obsolete(c,",
          "args": [
            "e",
            ";"
          ],
          "line": 1047
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "2_dbg_dump_node(c,",
          "args": [
            "e",
            "offset(ref));"
          ],
          "line": 1046
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "offset(ref",
          "args": [
            ");"
          ],
          "line": 1046
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "2_NOTICE(\"No",
          "args": [
            "e header CRC failed at %#08x. {%04x,%04x,%08x,%08x}\\n\",",
            "offset(ref), je",
            "_to_cpu(node->u.magic),",
            "_to_cpu(node->u.nodetype),",
            "_to_cpu(node->u.totlen),",
            "_to_cpu(node->u.hdr_crc));"
          ],
          "line": 1041
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_to_cpu(nod",
          "args": [
            "->u.hdr_crc));"
          ],
          "line": 1045
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_to_cpu(nod",
          "args": [
            "->u.totlen),"
          ],
          "line": 1044
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_to_cpu(nod",
          "args": [
            "->u.nodetype),"
          ],
          "line": 1043
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_to_cpu(nod",
          "args": [
            "->u.magic),"
          ],
          "line": 1042
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "offset(ref",
          "args": [
            ", j"
          ],
          "line": 1042
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "2(0,",
          "args": [
            "o",
            ", si",
            "of(node->u)-4)) {"
          ],
          "line": 1040
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_to_cpu(nod",
          "args": [
            "->u.hdr_crc) !="
          ],
          "line": 1040
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "2_ERROR(\"sh",
          "args": [
            "rt read at %#08x: %zu instead of %d.\\n\", re",
            "offset(ref), re",
            "en, le",
            ";"
          ],
          "line": 1032
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "offset(ref",
          "args": [
            ", r"
          ],
          "line": 1032
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "2_ERROR(\"ca",
          "args": [
            "not read %d bytes from 0x%08x, error code: %d.\\n\", le",
            "re",
            "offset(ref), er",
            ";"
          ],
          "line": 1027
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "offset(ref",
          "args": [
            ", e"
          ],
          "line": 1027
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "2_flash_read(c,",
          "args": [
            "e",
            "offset(ref), le",
            "&r",
            "len, bu",
            ";"
          ],
          "line": 1025
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "offset(ref",
          "args": [
            ", l"
          ],
          "line": 1025
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "readinode(\"re",
          "args": [
            "d %d bytes at %#08x(%d).\\n\", le",
            "re",
            "offset(ref), re",
            "flags(ref));"
          ],
          "line": 1022
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flags(ref",
          "args": [
            ");"
          ],
          "line": 1022
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "offset(ref",
          "args": [
            ", r"
          ],
          "line": 1022
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "offset(ref",
          "args": [
            ";"
          ],
          "line": 1019
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "offset(ref",
          "args": [
            "+"
          ],
          "line": 1015
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "2_is_writebuffered(c))",
          "args": [
            "{"
          ],
          "line": 1005
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_resched();",
          "args": [],
          "line": 996
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_unlock(&c-",
          "args": [
            "erase_completion_lock);"
          ],
          "line": 994
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "2_first_valid_node(ref",
          "args": [
            ">next_in_ino);"
          ],
          "line": 993
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "2_WARNING(\"Ee",
          "args": [
            ". No valid nodes for ino #%u.\\n\", f-",
            "nocache->ino);"
          ],
          "line": 984
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "2_first_valid_node(f->",
          "args": [
            "nocache->nodes);"
          ],
          "line": 982
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_lock(&c-",
          "args": [
            "erase_completion_lock);"
          ],
          "line": 981
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "loc(len",
          "args": [
            "GF",
            "KERNEL);"
          ],
          "line": 977
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "readinode(\"in",
          "args": [
            "#%u\\n\", f-",
            "nocache->ino);"
          ],
          "line": 972
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"nodelist.h\"\ninclude <linux/compiler.h>\n#\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/pagemap.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/fs.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/sched.h>\n#\ninclude <linux/kernel.h>\n#\n\nic int jffs2_get_inode_nodes(struct jffs2_sb_info *c, struct jffs2_inode_info *f,\n\t\t\t\t struct jffs2_readinode_info *rii)\n{\n\tstruct jffs2_raw_node_ref *ref, *valid_ref;\n\tunsigned char *buf = NULL;\n\tunion jffs2_node_union *node;\n\tsize_t retlen;\n\tint len, err;\n\n\trii->mctime_ver = 0;\n\n\tdbg_readinode(\"ino #%u\\n\", f->inocache->ino);\n\n\t/* FIXME: in case of NOR and available ->point() this\n\t * needs to be fixed. */\n\tlen = sizeof(union jffs2_node_union) + c->wbuf_pagesize;\n\tbuf = kmalloc(len, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tspin_lock(&c->erase_completion_lock);\n\tvalid_ref = jffs2_first_valid_node(f->inocache->nodes);\n\tif (!valid_ref && f->inocache->ino != 1)\n\t\tJFFS2_WARNING(\"Eep. No valid nodes for ino #%u.\\n\", f->inocache->ino);\n\twhile (valid_ref) {\n\t\t/* We can hold a pointer to a non-obsolete node without the spinlock,\n\t\t   but _obsolete_ nodes may disappear at any time, if the block\n\t\t   they're in gets erased. So if we mark 'ref' obsolete while we're\n\t\t   not holding the lock, it can go away immediately. For that reason,\n\t\t   we find the next valid node first, before processing 'ref'.\n\t\t*/\n\t\tref = valid_ref;\n\t\tvalid_ref = jffs2_first_valid_node(ref->next_in_ino);\n\t\tspin_unlock(&c->erase_completion_lock);\n\n\t\tcond_resched();\n\n\t\t/*\n\t\t * At this point we don't know the type of the node we're going\n\t\t * to read, so we do not know the size of its header. In order\n\t\t * to minimize the amount of flash IO we assume the header is\n\t\t * of size = JFFS2_MIN_NODE_HEADER.\n\t\t */\n\t\tlen = JFFS2_MIN_NODE_HEADER;\n\t\tif (jffs2_is_writebuffered(c)) {\n\t\t\tint end, rem;\n\n\t\t\t/*\n\t\t\t * We are about to read JFFS2_MIN_NODE_HEADER bytes,\n\t\t\t * but this flash has some minimal I/O unit. It is\n\t\t\t * possible that we'll need to read more soon, so read\n\t\t\t * up to the next min. I/O unit, in order not to\n\t\t\t * re-read the same min. I/O unit twice.\n\t\t\t */\n\t\t\tend = ref_offset(ref) + len;\n\t\t\trem = end % c->wbuf_pagesize;\n\t\t\tif (rem)\n\t\t\t\tend += c->wbuf_pagesize - rem;\n\t\t\tlen = end - ref_offset(ref);\n\t\t}\n\n\t\tdbg_readinode(\"read %d bytes at %#08x(%d).\\n\", len, ref_offset(ref), ref_flags(ref));\n\n\t\t/* FIXME: point() */\n\t\terr = jffs2_flash_read(c, ref_offset(ref), len, &retlen, buf);\n\t\tif (err) {\n\t\t\tJFFS2_ERROR(\"can not read %d bytes from 0x%08x, error code: %d.\\n\", len, ref_offset(ref), err);\n\t\t\tgoto free_out;\n\t\t}\n\n\t\tif (retlen < len) {\n\t\t\tJFFS2_ERROR(\"short read at %#08x: %zu instead of %d.\\n\", ref_offset(ref), retlen, len);\n\t\t\terr = -EIO;\n\t\t\tgoto free_out;\n\t\t}\n\n\t\tnode = (union jffs2_node_union *)buf;\n\n\t\t/* No need to mask in the valid bit; it shouldn't be invalid */\n\t\tif (je32_to_cpu(node->u.hdr_crc) != crc32(0, node, sizeof(node->u)-4)) {\n\t\t\tJFFS2_NOTICE(\"Node header CRC failed at %#08x. {%04x,%04x,%08x,%08x}\\n\",\n\t\t\t\t     ref_offset(ref), je16_to_cpu(node->u.magic),\n\t\t\t\t     je16_to_cpu(node->u.nodetype),\n\t\t\t\t     je32_to_cpu(node->u.totlen),\n\t\t\t\t     je32_to_cpu(node->u.hdr_crc));\n\t\t\tjffs2_dbg_dump_node(c, ref_offset(ref));\n\t\t\tjffs2_mark_node_obsolete(c, ref);\n\t\t\tgoto cont;\n\t\t}\n\t\tif (je16_to_cpu(node->u.magic) != JFFS2_MAGIC_BITMASK) {\n\t\t\t/* Not a JFFS2 node, whinge and move on */\n\t\t\tJFFS2_NOTICE(\"Wrong magic bitmask 0x%04x in node header at %#08x.\\n\",\n\t\t\t\t     je16_to_cpu(node->u.magic), ref_offset(ref));\n\t\t\tjffs2_mark_node_obsolete(c, ref);\n\t\t\tgoto cont;\n\t\t}\n\n\t\tswitch (je16_to_cpu(node->u.nodetype)) {\n\n\t\tcase JFFS2_NODETYPE_DIRENT:\n\n\t\t\tif (JFFS2_MIN_NODE_HEADER < sizeof(struct jffs2_raw_dirent) &&\n\t\t\t    len < sizeof(struct jffs2_raw_dirent)) {\n\t\t\t\terr = read_more(c, ref, sizeof(struct jffs2_raw_dirent), &len, buf);\n\t\t\t\tif (unlikely(err))\n\t\t\t\t\tgoto free_out;\n\t\t\t}\n\n\t\t\terr = read_direntry(c, ref, &node->d, retlen, rii);\n\t\t\tif (unlikely(err))\n\t\t\t\tgoto free_out;\n\n\t\t\tbreak;\n\n\t\tcase JFFS2_NODETYPE_INODE:\n\n\t\t\tif (JFFS2_MIN_NODE_HEADER < sizeof(struct jffs2_raw_inode) &&\n\t\t\t    len < sizeof(struct jffs2_raw_inode)) {\n\t\t\t\terr = read_more(c, ref, sizeof(struct jffs2_raw_inode), &len, buf);\n\t\t\t\tif (unlikely(err))\n\t\t\t\t\tgoto free_out;\n\t\t\t}\n\n\t\t\terr = read_dnode(c, ref, &node->i, len, rii);\n\t\t\tif (unlikely(err))\n\t\t\t\tgoto free_out;\n\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tif (JFFS2_MIN_NODE_HEADER < sizeof(struct jffs2_unknown_node) &&\n\t\t\t    len < sizeof(struct jffs2_unknown_node)) {\n\t\t\t\terr = read_more(c, ref, sizeof(struct jffs2_unknown_node), &len, buf);\n\t\t\t\tif (unlikely(err))\n\t\t\t\t\tgoto free_out;\n\t\t\t}\n\n\t\t\terr = read_unknown(c, ref, &node->u);\n\t\t\tif (unlikely(err))\n\t\t\t\tgoto free_out;\n\n\t\t}\n\tcont:\n\t\tspin_lock(&c->erase_completion_lock);\n\t}\n\n\tspin_unlock(&c->erase_completion_lock);\n\tkfree(buf);\n\n\tf->highest_version = rii->highest_version;\n\n\tdbg_readinode(\"nodes of inode #%u were read, the highest version is %u, latest_mctime %u, mctime_ver %u.\\n\",\n\t\t      f->inocache->ino, rii->highest_version, rii->latest_mctime,\n\t\t      rii->mctime_ver);\n\treturn 0;\n\n free_out:\n\tjffs2_free_tmp_dnode_info_list(&rii->tn_root);\n\tjffs2_free_full_dirent_list(rii->fds);\n\trii->fds = NULL;\n\tkfree(buf);\n\treturn err;\n}\n\nst"
  },
  {
    "function_name": "d_more(st",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/readinode.c",
    "lines": "920-954",
    "snippet": "tic int read_more(struct jffs2_sb_info *c, struct jffs2_raw_node_ref *ref,\n\t\t     int needed_len, int *rdlen, unsigned char *buf)\n{\n\tint err, to_read = needed_len - *rdlen;\n\tsize_t retlen;\n\tuint32_t offs;\n\n\tif (jffs2_is_writebuffered(c)) {\n\t\tint rem = to_read % c->wbuf_pagesize;\n\n\t\tif (rem)\n\t\t\tto_read += c->wbuf_pagesize - rem;\n\t}\n\n\t/* We need to read more data */\n\toffs = ref_offset(ref) + *rdlen;\n\n\tdbg_readinode(\"read more %d bytes\\n\", to_read);\n\n\terr = jffs2_flash_read(c, offs, to_read, &retlen, buf + *rdlen);\n\tif (err) {\n\t\tJFFS2_ERROR(\"can not read %d bytes from 0x%08x, \"\n\t\t\t\"error code: %d.\\n\", to_read, offs, err);\n\t\treturn err;\n\t}\n\n\tif (retlen < to_read) {\n\t\tJFFS2_ERROR(\"short read at %#08x: %zu instead of %d.\\n\",\n\t\t\t\toffs, retlen, to_read);\n\t\treturn -EIO;\n\t}\n\n\t*rdlen += to_read;\n\treturn 0;\n}\n\n/",
    "includes": [
      "include \"nodelist.h\"",
      "include <linux/compiler.h>\n#",
      "include <linux/mtd/mtd.h>\n#",
      "include <linux/pagemap.h>\n#",
      "include <linux/crc32.h>\n#",
      "include <linux/fs.h>\n#",
      "include <linux/slab.h>\n#",
      "include <linux/sched.h>\n#",
      "include <linux/kernel.h>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "S2_ERROR(\"s",
          "args": [
            "ort read at %#08x: %zu instead of %d.\\n\",",
            "s, r",
            "len, t",
            "read);"
          ],
          "line": 947
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S2_ERROR(\"c",
          "args": [
            "n not read %d bytes from 0x%08x, \"\n\t\t\t\"error code: %d.\\n\", t",
            "read, o",
            "s, e",
            ");"
          ],
          "line": 941
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "s2_flash_read(c,",
          "args": [
            "o",
            "s, t",
            "read, &",
            "tlen, b",
            "+ *rdlen);"
          ],
          "line": 939
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_readinode(\"r",
          "args": [
            "ad more %d bytes\\n\", t",
            "read);"
          ],
          "line": 937
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_offset(re",
          "args": [
            ") +"
          ],
          "line": 935
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "s2_is_writebuffered(c)",
          "args": [],
          "line": 927
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"nodelist.h\"\ninclude <linux/compiler.h>\n#\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/pagemap.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/fs.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/sched.h>\n#\ninclude <linux/kernel.h>\n#\n\ntic int read_more(struct jffs2_sb_info *c, struct jffs2_raw_node_ref *ref,\n\t\t     int needed_len, int *rdlen, unsigned char *buf)\n{\n\tint err, to_read = needed_len - *rdlen;\n\tsize_t retlen;\n\tuint32_t offs;\n\n\tif (jffs2_is_writebuffered(c)) {\n\t\tint rem = to_read % c->wbuf_pagesize;\n\n\t\tif (rem)\n\t\t\tto_read += c->wbuf_pagesize - rem;\n\t}\n\n\t/* We need to read more data */\n\toffs = ref_offset(ref) + *rdlen;\n\n\tdbg_readinode(\"read more %d bytes\\n\", to_read);\n\n\terr = jffs2_flash_read(c, offs, to_read, &retlen, buf + *rdlen);\n\tif (err) {\n\t\tJFFS2_ERROR(\"can not read %d bytes from 0x%08x, \"\n\t\t\t\"error code: %d.\\n\", to_read, offs, err);\n\t\treturn err;\n\t}\n\n\tif (retlen < to_read) {\n\t\tJFFS2_ERROR(\"short read at %#08x: %zu instead of %d.\\n\",\n\t\t\t\toffs, retlen, to_read);\n\t\treturn -EIO;\n\t}\n\n\t*rdlen += to_read;\n\treturn 0;\n}\n\n/"
  },
  {
    "function_name": "d_unknown(st",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/readinode.c",
    "lines": "868-911",
    "snippet": "tic inline int read_unknown(struct jffs2_sb_info *c, struct jffs2_raw_node_ref *ref, struct jffs2_unknown_node *un)\n{\n\t/* We don't mark unknown nodes as REF_UNCHECKED */\n\tif (ref_flags(ref) == REF_UNCHECKED) {\n\t\tJFFS2_ERROR(\"REF_UNCHECKED but unknown node at %#08x\\n\",\n\t\t\t    ref_offset(ref));\n\t\tJFFS2_ERROR(\"Node is {%04x,%04x,%08x,%08x}. Please report this error.\\n\",\n\t\t\t    je16_to_cpu(un->magic), je16_to_cpu(un->nodetype),\n\t\t\t    je32_to_cpu(un->totlen), je32_to_cpu(un->hdr_crc));\n\t\tjffs2_mark_node_obsolete(c, ref);\n\t\treturn 0;\n\t}\n\n\tun->nodetype = cpu_to_je16(JFFS2_NODE_ACCURATE | je16_to_cpu(un->nodetype));\n\n\tswitch(je16_to_cpu(un->nodetype) & JFFS2_COMPAT_MASK) {\n\n\tcase JFFS2_FEATURE_INCOMPAT:\n\t\tJFFS2_ERROR(\"unknown INCOMPAT nodetype %#04X at %#08x\\n\",\n\t\t\t    je16_to_cpu(un->nodetype), ref_offset(ref));\n\t\t/* EEP */\n\t\tBUG();\n\t\tbreak;\n\n\tcase JFFS2_FEATURE_ROCOMPAT:\n\t\tJFFS2_ERROR(\"unknown ROCOMPAT nodetype %#04X at %#08x\\n\",\n\t\t\t    je16_to_cpu(un->nodetype), ref_offset(ref));\n\t\tBUG_ON(!(c->flags & JFFS2_SB_FLAG_RO));\n\t\tbreak;\n\n\tcase JFFS2_FEATURE_RWCOMPAT_COPY:\n\t\tJFFS2_NOTICE(\"unknown RWCOMPAT_COPY nodetype %#04X at %#08x\\n\",\n\t\t\t     je16_to_cpu(un->nodetype), ref_offset(ref));\n\t\tbreak;\n\n\tcase JFFS2_FEATURE_RWCOMPAT_DELETE:\n\t\tJFFS2_NOTICE(\"unknown RWCOMPAT_DELETE nodetype %#04X at %#08x\\n\",\n\t\t\t     je16_to_cpu(un->nodetype), ref_offset(ref));\n\t\tjffs2_mark_node_obsolete(c, ref);\n\t\treturn 0;\n\t}\n\n\treturn 0;\n}\n\n/",
    "includes": [
      "include \"nodelist.h\"",
      "include <linux/compiler.h>\n#",
      "include <linux/mtd/mtd.h>\n#",
      "include <linux/pagemap.h>\n#",
      "include <linux/crc32.h>\n#",
      "include <linux/fs.h>\n#",
      "include <linux/slab.h>\n#",
      "include <linux/sched.h>\n#",
      "include <linux/kernel.h>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "s2_mark_node_obsolete(c,",
          "args": [
            "r",
            ");"
          ],
          "line": 906
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S2_NOTICE(\"u",
          "args": [
            "known RWCOMPAT_DELETE nodetype %#04X at %#08x\\n\",",
            "6_to_cpu(un->nodetype), r",
            "_offset(ref));"
          ],
          "line": 904
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_offset(re",
          "args": [
            "));"
          ],
          "line": 905
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "6_to_cpu(un",
          "args": [
            ">nodetype),"
          ],
          "line": 905
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S2_NOTICE(\"u",
          "args": [
            "known RWCOMPAT_COPY nodetype %#04X at %#08x\\n\",",
            "6_to_cpu(un->nodetype), r",
            "_offset(ref));"
          ],
          "line": 899
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_offset(re",
          "args": [
            "));"
          ],
          "line": 900
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "6_to_cpu(un",
          "args": [
            ">nodetype),"
          ],
          "line": 900
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ON(!(",
          "args": [
            "->flags & JFFS2_SB_FLAG_RO));"
          ],
          "line": 895
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S2_ERROR(\"u",
          "args": [
            "known ROCOMPAT nodetype %#04X at %#08x\\n\",",
            "6_to_cpu(un->nodetype), r",
            "_offset(ref));"
          ],
          "line": 893
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_offset(re",
          "args": [
            "));"
          ],
          "line": 894
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "6_to_cpu(un",
          "args": [
            ">nodetype),"
          ],
          "line": 894
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "();",
          "args": [],
          "line": 889
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S2_ERROR(\"u",
          "args": [
            "known INCOMPAT nodetype %#04X at %#08x\\n\",",
            "6_to_cpu(un->nodetype), r",
            "_offset(ref));"
          ],
          "line": 886
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_offset(re",
          "args": [
            "));"
          ],
          "line": 887
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "6_to_cpu(un",
          "args": [
            ">nodetype),"
          ],
          "line": 887
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "6_to_cpu(un",
          "args": [
            ">nodetype) &"
          ],
          "line": 883
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_to_je16(JF",
          "args": [
            "S2_NODE_ACCURATE | je16_to_cpu(un->nodetype));"
          ],
          "line": 881
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "6_to_cpu(un",
          "args": [
            ">nodetype));"
          ],
          "line": 881
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "s2_mark_node_obsolete(c,",
          "args": [
            "r",
            ");"
          ],
          "line": 877
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S2_ERROR(\"N",
          "args": [
            "de is {%04x,%04x,%08x,%08x}. Please report this error.\\n\",",
            "6_to_cpu(un->magic), j",
            "6_to_cpu(un->nodetype),",
            "2_to_cpu(un->totlen), j",
            "2_to_cpu(un->hdr_crc));"
          ],
          "line": 874
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "2_to_cpu(un",
          "args": [
            ">hdr_crc));"
          ],
          "line": 876
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "2_to_cpu(un",
          "args": [
            ">totlen),"
          ],
          "line": 876
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "6_to_cpu(un",
          "args": [
            ">nodetype),"
          ],
          "line": 875
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "6_to_cpu(un",
          "args": [
            ">magic),"
          ],
          "line": 875
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S2_ERROR(\"R",
          "args": [
            "F_UNCHECKED but unknown node at %#08x\\n\",",
            "_offset(ref));"
          ],
          "line": 872
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_offset(re",
          "args": [
            "));"
          ],
          "line": 873
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_flags(re",
          "args": [
            ") ="
          ],
          "line": 871
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"nodelist.h\"\ninclude <linux/compiler.h>\n#\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/pagemap.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/fs.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/sched.h>\n#\ninclude <linux/kernel.h>\n#\n\ntic inline int read_unknown(struct jffs2_sb_info *c, struct jffs2_raw_node_ref *ref, struct jffs2_unknown_node *un)\n{\n\t/* We don't mark unknown nodes as REF_UNCHECKED */\n\tif (ref_flags(ref) == REF_UNCHECKED) {\n\t\tJFFS2_ERROR(\"REF_UNCHECKED but unknown node at %#08x\\n\",\n\t\t\t    ref_offset(ref));\n\t\tJFFS2_ERROR(\"Node is {%04x,%04x,%08x,%08x}. Please report this error.\\n\",\n\t\t\t    je16_to_cpu(un->magic), je16_to_cpu(un->nodetype),\n\t\t\t    je32_to_cpu(un->totlen), je32_to_cpu(un->hdr_crc));\n\t\tjffs2_mark_node_obsolete(c, ref);\n\t\treturn 0;\n\t}\n\n\tun->nodetype = cpu_to_je16(JFFS2_NODE_ACCURATE | je16_to_cpu(un->nodetype));\n\n\tswitch(je16_to_cpu(un->nodetype) & JFFS2_COMPAT_MASK) {\n\n\tcase JFFS2_FEATURE_INCOMPAT:\n\t\tJFFS2_ERROR(\"unknown INCOMPAT nodetype %#04X at %#08x\\n\",\n\t\t\t    je16_to_cpu(un->nodetype), ref_offset(ref));\n\t\t/* EEP */\n\t\tBUG();\n\t\tbreak;\n\n\tcase JFFS2_FEATURE_ROCOMPAT:\n\t\tJFFS2_ERROR(\"unknown ROCOMPAT nodetype %#04X at %#08x\\n\",\n\t\t\t    je16_to_cpu(un->nodetype), ref_offset(ref));\n\t\tBUG_ON(!(c->flags & JFFS2_SB_FLAG_RO));\n\t\tbreak;\n\n\tcase JFFS2_FEATURE_RWCOMPAT_COPY:\n\t\tJFFS2_NOTICE(\"unknown RWCOMPAT_COPY nodetype %#04X at %#08x\\n\",\n\t\t\t     je16_to_cpu(un->nodetype), ref_offset(ref));\n\t\tbreak;\n\n\tcase JFFS2_FEATURE_RWCOMPAT_DELETE:\n\t\tJFFS2_NOTICE(\"unknown RWCOMPAT_DELETE nodetype %#04X at %#08x\\n\",\n\t\t\t     je16_to_cpu(un->nodetype), ref_offset(ref));\n\t\tjffs2_mark_node_obsolete(c, ref);\n\t\treturn 0;\n\t}\n\n\treturn 0;\n}\n\n/"
  },
  {
    "function_name": "d_dnode(st",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/readinode.c",
    "lines": "693-859",
    "snippet": "tic inline int read_dnode(struct jffs2_sb_info *c, struct jffs2_raw_node_ref *ref,\n\t\t\t     struct jffs2_raw_inode *rd, int rdlen,\n\t\t\t     struct jffs2_readinode_info *rii)\n{\n\tstruct jffs2_tmp_dnode_info *tn;\n\tuint32_t len, csize;\n\tint ret = 0;\n\tuint32_t crc;\n\n\t/* Obsoleted. This cannot happen, surely? dwmw2 20020308 */\n\tBUG_ON(ref_obsolete(ref));\n\n\tcrc = crc32(0, rd, sizeof(*rd) - 8);\n\tif (unlikely(crc != je32_to_cpu(rd->node_crc))) {\n\t\tJFFS2_NOTICE(\"node CRC failed on dnode at %#08x: read %#08x, calculated %#08x\\n\",\n\t\t\t     ref_offset(ref), je32_to_cpu(rd->node_crc), crc);\n\t\tjffs2_mark_node_obsolete(c, ref);\n\t\treturn 0;\n\t}\n\n\ttn = jffs2_alloc_tmp_dnode_info();\n\tif (!tn) {\n\t\tJFFS2_ERROR(\"failed to allocate tn (%zu bytes).\\n\", sizeof(*tn));\n\t\treturn -ENOMEM;\n\t}\n\n\ttn->partial_crc = 0;\n\tcsize = je32_to_cpu(rd->csize);\n\n\t/* If we've never checked the CRCs on this node, check them now */\n\tif (ref_flags(ref) == REF_UNCHECKED) {\n\n\t\t/* Sanity checks */\n\t\tif (unlikely(je32_to_cpu(rd->offset) > je32_to_cpu(rd->isize)) ||\n\t\t    unlikely(PAD(je32_to_cpu(rd->csize) + sizeof(*rd)) != PAD(je32_to_cpu(rd->totlen)))) {\n\t\t\tJFFS2_WARNING(\"inode node header CRC is corrupted at %#08x\\n\", ref_offset(ref));\n\t\t\tjffs2_dbg_dump_node(c, ref_offset(ref));\n\t\t\tjffs2_mark_node_obsolete(c, ref);\n\t\t\tgoto free_out;\n\t\t}\n\n\t\tif (jffs2_is_writebuffered(c) && csize != 0) {\n\t\t\t/* At this point we are supposed to check the data CRC\n\t\t\t * of our unchecked node. But thus far, we do not\n\t\t\t * know whether the node is valid or obsolete. To\n\t\t\t * figure this out, we need to walk all the nodes of\n\t\t\t * the inode and build the inode fragtree. We don't\n\t\t\t * want to spend time checking data of nodes which may\n\t\t\t * later be found to be obsolete. So we put off the full\n\t\t\t * data CRC checking until we have read all the inode\n\t\t\t * nodes and have started building the fragtree.\n\t\t\t *\n\t\t\t * The fragtree is being built starting with nodes\n\t\t\t * having the highest version number, so we'll be able\n\t\t\t * to detect whether a node is valid (i.e., it is not\n\t\t\t * overlapped by a node with higher version) or not.\n\t\t\t * And we'll be able to check only those nodes, which\n\t\t\t * are not obsolete.\n\t\t\t *\n\t\t\t * Of course, this optimization only makes sense in case\n\t\t\t * of NAND flashes (or other flashes with\n\t\t\t * !jffs2_can_mark_obsolete()), since on NOR flashes\n\t\t\t * nodes are marked obsolete physically.\n\t\t\t *\n\t\t\t * Since NAND flashes (or other flashes with\n\t\t\t * jffs2_is_writebuffered(c)) are anyway read by\n\t\t\t * fractions of c->wbuf_pagesize, and we have just read\n\t\t\t * the node header, it is likely that the starting part\n\t\t\t * of the node data is also read when we read the\n\t\t\t * header. So we don't mind to check the CRC of the\n\t\t\t * starting part of the data of the node now, and check\n\t\t\t * the second part later (in jffs2_check_node_data()).\n\t\t\t * Of course, we will not need to re-read and re-check\n\t\t\t * the NAND page which we have just read. This is why we\n\t\t\t * read the whole NAND page at jffs2_get_inode_nodes(),\n\t\t\t * while we needed only the node header.\n\t\t\t */\n\t\t\tunsigned char *buf;\n\n\t\t\t/* 'buf' will point to the start of data */\n\t\t\tbuf = (unsigned char *)rd + sizeof(*rd);\n\t\t\t/* len will be the read data length */\n\t\t\tlen = min_t(uint32_t, rdlen - sizeof(*rd), csize);\n\t\t\ttn->partial_crc = crc32(0, buf, len);\n\n\t\t\tdbg_readinode(\"Calculates CRC (%#08x) for %d bytes, csize %d\\n\", tn->partial_crc, len, csize);\n\n\t\t\t/* If we actually calculated the whole data CRC\n\t\t\t * and it is wrong, drop the node. */\n\t\t\tif (len >= csize && unlikely(tn->partial_crc != je32_to_cpu(rd->data_crc))) {\n\t\t\t\tJFFS2_NOTICE(\"wrong data CRC in data node at 0x%08x: read %#08x, calculated %#08x.\\n\",\n\t\t\t\t\tref_offset(ref), tn->partial_crc, je32_to_cpu(rd->data_crc));\n\t\t\t\tjffs2_mark_node_obsolete(c, ref);\n\t\t\t\tgoto free_out;\n\t\t\t}\n\n\t\t} else if (csize == 0) {\n\t\t\t/*\n\t\t\t * We checked the header CRC. If the node has no data, adjust\n\t\t\t * the space accounting now. For other nodes this will be done\n\t\t\t * later either when the node is marked obsolete or when its\n\t\t\t * data is checked.\n\t\t\t */\n\t\t\tstruct jffs2_eraseblock *jeb;\n\n\t\t\tdbg_readinode(\"the node has no data.\\n\");\n\t\t\tjeb = &c->blocks[ref->flash_offset / c->sector_size];\n\t\t\tlen = ref_totlen(c, jeb, ref);\n\n\t\t\tspin_lock(&c->erase_completion_lock);\n\t\t\tjeb->used_size += len;\n\t\t\tjeb->unchecked_size -= len;\n\t\t\tc->used_size += len;\n\t\t\tc->unchecked_size -= len;\n\t\t\tref->flash_offset = ref_offset(ref) | REF_NORMAL;\n\t\t\tspin_unlock(&c->erase_completion_lock);\n\t\t}\n\t}\n\n\ttn->fn = jffs2_alloc_full_dnode();\n\tif (!tn->fn) {\n\t\tJFFS2_ERROR(\"alloc fn failed\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto free_out;\n\t}\n\n\ttn->version = je32_to_cpu(rd->version);\n\ttn->fn->ofs = je32_to_cpu(rd->offset);\n\ttn->data_crc = je32_to_cpu(rd->data_crc);\n\ttn->csize = csize;\n\ttn->fn->raw = ref;\n\ttn->overlapped = 0;\n\n\tif (tn->version > rii->highest_version)\n\t\trii->highest_version = tn->version;\n\n\t/* There was a bug where we wrote hole nodes out with\n\t   csize/dsize swapped. Deal with it */\n\tif (rd->compr == JFFS2_COMPR_ZERO && !je32_to_cpu(rd->dsize) && csize)\n\t\ttn->fn->size = csize;\n\telse // normal case...\n\t\ttn->fn->size = je32_to_cpu(rd->dsize);\n\n\tdbg_readinode2(\"dnode @%08x: ver %u, offset %#04x, dsize %#04x, csize %#04x\\n\",\n\t\t       ref_offset(ref), je32_to_cpu(rd->version),\n\t\t       je32_to_cpu(rd->offset), je32_to_cpu(rd->dsize), csize);\n\n\tret = jffs2_add_tn_to_tree(c, rii, tn);\n\n\tif (ret) {\n\t\tjffs2_free_full_dnode(tn->fn);\n\tfree_out:\n\t\tjffs2_free_tmp_dnode_info(tn);\n\t\treturn ret;\n\t}\n#ifdef JFFS2_DBG_READINODE2_MESSAGES\n\tdbg_readinode2(\"After adding ver %d:\\n\", je32_to_cpu(rd->version));\n\ttn = tn_first(&rii->tn_root);\n\twhile (tn) {\n\t\tdbg_readinode2(\"%p: v %d r 0x%x-0x%x ov %d\\n\",\n\t\t\t       tn, tn->version, tn->fn->ofs,\n\t\t\t       tn->fn->ofs+tn->fn->size, tn->overlapped);\n\t\ttn = tn_next(tn);\n\t}\n#endif\n\treturn 0;\n}\n\n/",
    "includes": [
      "include \"nodelist.h\"",
      "include <linux/compiler.h>\n#",
      "include <linux/mtd/mtd.h>\n#",
      "include <linux/pagemap.h>\n#",
      "include <linux/crc32.h>\n#",
      "include <linux/fs.h>\n#",
      "include <linux/slab.h>\n#",
      "include <linux/sched.h>\n#",
      "include <linux/kernel.h>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "next(tn",
          "args": [
            ";"
          ],
          "line": 855
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_readinode2(\"%",
          "args": [
            ": v %d r 0x%x-0x%x ov %d\\n\",",
            "t",
            ">version, t",
            ">fn->ofs,",
            ">fn->ofs+tn->fn->size, t",
            ">overlapped);"
          ],
          "line": 852
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "first(&r",
          "args": [
            "i->tn_root);"
          ],
          "line": 850
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_readinode2(\"A",
          "args": [
            "ter adding ver %d:\\n\", j",
            "2_to_cpu(rd->version));"
          ],
          "line": 849
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "2_to_cpu(rd",
          "args": [
            ">version));"
          ],
          "line": 849
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "s2_free_tmp_dnode_info(tn",
          "args": [
            ";"
          ],
          "line": 845
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "s2_free_full_dnode(tn",
          "args": [
            ">fn);"
          ],
          "line": 843
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "s2_add_tn_to_tree(c,",
          "args": [
            "r",
            ", t",
            ";"
          ],
          "line": 840
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_readinode2(\"d",
          "args": [
            "ode @%08x: ver %u, offset %#04x, dsize %#04x, csize %#04x\\n\",",
            "_offset(ref), j",
            "2_to_cpu(rd->version),",
            "2_to_cpu(rd->offset), j",
            "2_to_cpu(rd->dsize), c",
            "ze);"
          ],
          "line": 836
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "2_to_cpu(rd",
          "args": [
            ">dsize),"
          ],
          "line": 838
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "2_to_cpu(rd",
          "args": [
            ">offset),"
          ],
          "line": 838
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "2_to_cpu(rd",
          "args": [
            ">version),"
          ],
          "line": 837
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_offset(re",
          "args": [
            "),"
          ],
          "line": 837
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "2_to_cpu(rd",
          "args": [
            ">dsize);"
          ],
          "line": 834
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "2_to_cpu(rd",
          "args": [
            ">dsize) &"
          ],
          "line": 831
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "2_to_cpu(rd",
          "args": [
            ">data_crc);"
          ],
          "line": 821
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "2_to_cpu(rd",
          "args": [
            ">offset);"
          ],
          "line": 820
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "2_to_cpu(rd",
          "args": [
            ">version);"
          ],
          "line": 819
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S2_ERROR(\"a",
          "args": [
            "loc fn failed\\n\");"
          ],
          "line": 814
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "s2_alloc_full_dnode();",
          "args": [],
          "line": 812
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "n_unlock(&c",
          "args": [
            ">erase_completion_lock);"
          ],
          "line": 808
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_offset(re",
          "args": [
            ") |"
          ],
          "line": 807
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "n_lock(&c",
          "args": [
            ">erase_completion_lock);"
          ],
          "line": 802
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_totlen(c,",
          "args": [
            "j",
            ", r",
            ");"
          ],
          "line": 800
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_readinode(\"t",
          "args": [
            "e node has no data.\\n\");"
          ],
          "line": 798
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "s2_mark_node_obsolete(c,",
          "args": [
            "r",
            ");"
          ],
          "line": 785
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S2_NOTICE(\"w",
          "args": [
            "ong data CRC in data node at 0x%08x: read %#08x, calculated %#08x.\\n\",",
            "_offset(ref), t",
            ">partial_crc, j",
            "2_to_cpu(rd->data_crc));"
          ],
          "line": 783
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "2_to_cpu(rd",
          "args": [
            ">data_crc));"
          ],
          "line": 784
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_offset(re",
          "args": [
            "),"
          ],
          "line": 784
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ikely(tn",
          "args": [
            ">partial_crc != je32_to_cpu(rd->data_crc)))"
          ],
          "line": 782
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "2_to_cpu(rd",
          "args": [
            ">data_crc)))"
          ],
          "line": 782
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_readinode(\"C",
          "args": [
            "lculates CRC (%#08x) for %d bytes, csize %d\\n\", t",
            ">partial_crc, l",
            ", c",
            "ze);"
          ],
          "line": 778
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "32(0,",
          "args": [
            "b",
            ", l",
            ");"
          ],
          "line": 776
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_t(ui",
          "args": [
            "t32_t, r",
            "en - sizeof(*rd), c",
            "ze);"
          ],
          "line": 775
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "s2_is_writebuffered(c)",
          "args": [
            "&"
          ],
          "line": 734
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "s2_mark_node_obsolete(c,",
          "args": [
            "r",
            ");"
          ],
          "line": 730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "s2_dbg_dump_node(c,",
          "args": [
            "r",
            "_offset(ref));"
          ],
          "line": 729
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_offset(re",
          "args": [
            "));"
          ],
          "line": 729
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S2_WARNING(\"i",
          "args": [
            "ode node header CRC is corrupted at %#08x\\n\", r",
            "_offset(ref));"
          ],
          "line": 728
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_offset(re",
          "args": [
            "));"
          ],
          "line": 728
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ikely(PA",
          "args": [
            "(je32_to_cpu(rd->csize) + sizeof(*rd)) != PAD(je32_to_cpu(rd->totlen))))"
          ],
          "line": 727
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "(je",
          "args": [
            "2_to_cpu(rd->totlen))))"
          ],
          "line": 727
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "2_to_cpu(rd",
          "args": [
            ">totlen)))"
          ],
          "line": 727
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "(je",
          "args": [
            "2_to_cpu(rd->csize) + sizeof(*rd)) !"
          ],
          "line": 727
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "2_to_cpu(rd",
          "args": [
            ">csize) +"
          ],
          "line": 727
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ikely(je",
          "args": [
            "2_to_cpu(rd->offset) > je32_to_cpu(rd->isize)) |"
          ],
          "line": 726
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "2_to_cpu(rd",
          "args": [
            ">isize))"
          ],
          "line": 726
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "2_to_cpu(rd",
          "args": [
            ">offset) >"
          ],
          "line": 726
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_flags(re",
          "args": [
            ") ="
          ],
          "line": 723
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "2_to_cpu(rd",
          "args": [
            ">csize);"
          ],
          "line": 720
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S2_ERROR(\"f",
          "args": [
            "iled to allocate tn (%zu bytes).\\n\", s",
            "eof(*tn));"
          ],
          "line": 715
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "s2_alloc_tmp_dnode_info();",
          "args": [],
          "line": 713
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "s2_mark_node_obsolete(c,",
          "args": [
            "r",
            ");"
          ],
          "line": 709
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S2_NOTICE(\"n",
          "args": [
            "de CRC failed on dnode at %#08x: read %#08x, calculated %#08x\\n\",",
            "_offset(ref), j",
            "2_to_cpu(rd->node_crc), c",
            ");"
          ],
          "line": 707
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "2_to_cpu(rd",
          "args": [
            ">node_crc),"
          ],
          "line": 708
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_offset(re",
          "args": [
            "),"
          ],
          "line": 708
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ikely(cr",
          "args": [
            "!= je32_to_cpu(rd->node_crc)))"
          ],
          "line": 706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "2_to_cpu(rd",
          "args": [
            ">node_crc)))"
          ],
          "line": 706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "32(0,",
          "args": [
            "r",
            "s",
            "eof(*rd) - 8);"
          ],
          "line": 705
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ON(re",
          "args": [
            "_obsolete(ref));"
          ],
          "line": 703
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_obsolete(re",
          "args": [
            "));"
          ],
          "line": 703
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"nodelist.h\"\ninclude <linux/compiler.h>\n#\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/pagemap.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/fs.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/sched.h>\n#\ninclude <linux/kernel.h>\n#\n\ntic inline int read_dnode(struct jffs2_sb_info *c, struct jffs2_raw_node_ref *ref,\n\t\t\t     struct jffs2_raw_inode *rd, int rdlen,\n\t\t\t     struct jffs2_readinode_info *rii)\n{\n\tstruct jffs2_tmp_dnode_info *tn;\n\tuint32_t len, csize;\n\tint ret = 0;\n\tuint32_t crc;\n\n\t/* Obsoleted. This cannot happen, surely? dwmw2 20020308 */\n\tBUG_ON(ref_obsolete(ref));\n\n\tcrc = crc32(0, rd, sizeof(*rd) - 8);\n\tif (unlikely(crc != je32_to_cpu(rd->node_crc))) {\n\t\tJFFS2_NOTICE(\"node CRC failed on dnode at %#08x: read %#08x, calculated %#08x\\n\",\n\t\t\t     ref_offset(ref), je32_to_cpu(rd->node_crc), crc);\n\t\tjffs2_mark_node_obsolete(c, ref);\n\t\treturn 0;\n\t}\n\n\ttn = jffs2_alloc_tmp_dnode_info();\n\tif (!tn) {\n\t\tJFFS2_ERROR(\"failed to allocate tn (%zu bytes).\\n\", sizeof(*tn));\n\t\treturn -ENOMEM;\n\t}\n\n\ttn->partial_crc = 0;\n\tcsize = je32_to_cpu(rd->csize);\n\n\t/* If we've never checked the CRCs on this node, check them now */\n\tif (ref_flags(ref) == REF_UNCHECKED) {\n\n\t\t/* Sanity checks */\n\t\tif (unlikely(je32_to_cpu(rd->offset) > je32_to_cpu(rd->isize)) ||\n\t\t    unlikely(PAD(je32_to_cpu(rd->csize) + sizeof(*rd)) != PAD(je32_to_cpu(rd->totlen)))) {\n\t\t\tJFFS2_WARNING(\"inode node header CRC is corrupted at %#08x\\n\", ref_offset(ref));\n\t\t\tjffs2_dbg_dump_node(c, ref_offset(ref));\n\t\t\tjffs2_mark_node_obsolete(c, ref);\n\t\t\tgoto free_out;\n\t\t}\n\n\t\tif (jffs2_is_writebuffered(c) && csize != 0) {\n\t\t\t/* At this point we are supposed to check the data CRC\n\t\t\t * of our unchecked node. But thus far, we do not\n\t\t\t * know whether the node is valid or obsolete. To\n\t\t\t * figure this out, we need to walk all the nodes of\n\t\t\t * the inode and build the inode fragtree. We don't\n\t\t\t * want to spend time checking data of nodes which may\n\t\t\t * later be found to be obsolete. So we put off the full\n\t\t\t * data CRC checking until we have read all the inode\n\t\t\t * nodes and have started building the fragtree.\n\t\t\t *\n\t\t\t * The fragtree is being built starting with nodes\n\t\t\t * having the highest version number, so we'll be able\n\t\t\t * to detect whether a node is valid (i.e., it is not\n\t\t\t * overlapped by a node with higher version) or not.\n\t\t\t * And we'll be able to check only those nodes, which\n\t\t\t * are not obsolete.\n\t\t\t *\n\t\t\t * Of course, this optimization only makes sense in case\n\t\t\t * of NAND flashes (or other flashes with\n\t\t\t * !jffs2_can_mark_obsolete()), since on NOR flashes\n\t\t\t * nodes are marked obsolete physically.\n\t\t\t *\n\t\t\t * Since NAND flashes (or other flashes with\n\t\t\t * jffs2_is_writebuffered(c)) are anyway read by\n\t\t\t * fractions of c->wbuf_pagesize, and we have just read\n\t\t\t * the node header, it is likely that the starting part\n\t\t\t * of the node data is also read when we read the\n\t\t\t * header. So we don't mind to check the CRC of the\n\t\t\t * starting part of the data of the node now, and check\n\t\t\t * the second part later (in jffs2_check_node_data()).\n\t\t\t * Of course, we will not need to re-read and re-check\n\t\t\t * the NAND page which we have just read. This is why we\n\t\t\t * read the whole NAND page at jffs2_get_inode_nodes(),\n\t\t\t * while we needed only the node header.\n\t\t\t */\n\t\t\tunsigned char *buf;\n\n\t\t\t/* 'buf' will point to the start of data */\n\t\t\tbuf = (unsigned char *)rd + sizeof(*rd);\n\t\t\t/* len will be the read data length */\n\t\t\tlen = min_t(uint32_t, rdlen - sizeof(*rd), csize);\n\t\t\ttn->partial_crc = crc32(0, buf, len);\n\n\t\t\tdbg_readinode(\"Calculates CRC (%#08x) for %d bytes, csize %d\\n\", tn->partial_crc, len, csize);\n\n\t\t\t/* If we actually calculated the whole data CRC\n\t\t\t * and it is wrong, drop the node. */\n\t\t\tif (len >= csize && unlikely(tn->partial_crc != je32_to_cpu(rd->data_crc))) {\n\t\t\t\tJFFS2_NOTICE(\"wrong data CRC in data node at 0x%08x: read %#08x, calculated %#08x.\\n\",\n\t\t\t\t\tref_offset(ref), tn->partial_crc, je32_to_cpu(rd->data_crc));\n\t\t\t\tjffs2_mark_node_obsolete(c, ref);\n\t\t\t\tgoto free_out;\n\t\t\t}\n\n\t\t} else if (csize == 0) {\n\t\t\t/*\n\t\t\t * We checked the header CRC. If the node has no data, adjust\n\t\t\t * the space accounting now. For other nodes this will be done\n\t\t\t * later either when the node is marked obsolete or when its\n\t\t\t * data is checked.\n\t\t\t */\n\t\t\tstruct jffs2_eraseblock *jeb;\n\n\t\t\tdbg_readinode(\"the node has no data.\\n\");\n\t\t\tjeb = &c->blocks[ref->flash_offset / c->sector_size];\n\t\t\tlen = ref_totlen(c, jeb, ref);\n\n\t\t\tspin_lock(&c->erase_completion_lock);\n\t\t\tjeb->used_size += len;\n\t\t\tjeb->unchecked_size -= len;\n\t\t\tc->used_size += len;\n\t\t\tc->unchecked_size -= len;\n\t\t\tref->flash_offset = ref_offset(ref) | REF_NORMAL;\n\t\t\tspin_unlock(&c->erase_completion_lock);\n\t\t}\n\t}\n\n\ttn->fn = jffs2_alloc_full_dnode();\n\tif (!tn->fn) {\n\t\tJFFS2_ERROR(\"alloc fn failed\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto free_out;\n\t}\n\n\ttn->version = je32_to_cpu(rd->version);\n\ttn->fn->ofs = je32_to_cpu(rd->offset);\n\ttn->data_crc = je32_to_cpu(rd->data_crc);\n\ttn->csize = csize;\n\ttn->fn->raw = ref;\n\ttn->overlapped = 0;\n\n\tif (tn->version > rii->highest_version)\n\t\trii->highest_version = tn->version;\n\n\t/* There was a bug where we wrote hole nodes out with\n\t   csize/dsize swapped. Deal with it */\n\tif (rd->compr == JFFS2_COMPR_ZERO && !je32_to_cpu(rd->dsize) && csize)\n\t\ttn->fn->size = csize;\n\telse // normal case...\n\t\ttn->fn->size = je32_to_cpu(rd->dsize);\n\n\tdbg_readinode2(\"dnode @%08x: ver %u, offset %#04x, dsize %#04x, csize %#04x\\n\",\n\t\t       ref_offset(ref), je32_to_cpu(rd->version),\n\t\t       je32_to_cpu(rd->offset), je32_to_cpu(rd->dsize), csize);\n\n\tret = jffs2_add_tn_to_tree(c, rii, tn);\n\n\tif (ret) {\n\t\tjffs2_free_full_dnode(tn->fn);\n\tfree_out:\n\t\tjffs2_free_tmp_dnode_info(tn);\n\t\treturn ret;\n\t}\n#ifdef JFFS2_DBG_READINODE2_MESSAGES\n\tdbg_readinode2(\"After adding ver %d:\\n\", je32_to_cpu(rd->version));\n\ttn = tn_first(&rii->tn_root);\n\twhile (tn) {\n\t\tdbg_readinode2(\"%p: v %d r 0x%x-0x%x ov %d\\n\",\n\t\t\t       tn, tn->version, tn->fn->ofs,\n\t\t\t       tn->fn->ofs+tn->fn->size, tn->overlapped);\n\t\ttn = tn_next(tn);\n\t}\n#endif\n\treturn 0;\n}\n\n/"
  },
  {
    "function_name": "d_direntry(st",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/readinode.c",
    "lines": "586-684",
    "snippet": "tic inline int read_direntry(struct jffs2_sb_info *c, struct jffs2_raw_node_ref *ref,\n\t\t\t\tstruct jffs2_raw_dirent *rd, size_t read,\n\t\t\t\tstruct jffs2_readinode_info *rii)\n{\n\tstruct jffs2_full_dirent *fd;\n\tuint32_t crc;\n\n\t/* Obsoleted. This cannot happen, surely? dwmw2 20020308 */\n\tBUG_ON(ref_obsolete(ref));\n\n\tcrc = crc32(0, rd, sizeof(*rd) - 8);\n\tif (unlikely(crc != je32_to_cpu(rd->node_crc))) {\n\t\tJFFS2_NOTICE(\"header CRC failed on dirent node at %#08x: read %#08x, calculated %#08x\\n\",\n\t\t\t     ref_offset(ref), je32_to_cpu(rd->node_crc), crc);\n\t\tjffs2_mark_node_obsolete(c, ref);\n\t\treturn 0;\n\t}\n\n\t/* If we've never checked the CRCs on this node, check them now */\n\tif (ref_flags(ref) == REF_UNCHECKED) {\n\t\tstruct jffs2_eraseblock *jeb;\n\t\tint len;\n\n\t\t/* Sanity check */\n\t\tif (unlikely(PAD((rd->nsize + sizeof(*rd))) != PAD(je32_to_cpu(rd->totlen)))) {\n\t\t\tJFFS2_ERROR(\"illegal nsize in node at %#08x: nsize %#02x, totlen %#04x\\n\",\n\t\t\t\t    ref_offset(ref), rd->nsize, je32_to_cpu(rd->totlen));\n\t\t\tjffs2_mark_node_obsolete(c, ref);\n\t\t\treturn 0;\n\t\t}\n\n\t\tjeb = &c->blocks[ref->flash_offset / c->sector_size];\n\t\tlen = ref_totlen(c, jeb, ref);\n\n\t\tspin_lock(&c->erase_completion_lock);\n\t\tjeb->used_size += len;\n\t\tjeb->unchecked_size -= len;\n\t\tc->used_size += len;\n\t\tc->unchecked_size -= len;\n\t\tref->flash_offset = ref_offset(ref) | dirent_node_state(rd);\n\t\tspin_unlock(&c->erase_completion_lock);\n\t}\n\n\tfd = jffs2_alloc_full_dirent(rd->nsize + 1);\n\tif (unlikely(!fd))\n\t\treturn -ENOMEM;\n\n\tfd->raw = ref;\n\tfd->version = je32_to_cpu(rd->version);\n\tfd->ino = je32_to_cpu(rd->ino);\n\tfd->type = rd->type;\n\n\tif (fd->version > rii->highest_version)\n\t\trii->highest_version = fd->version;\n\n\t/* Pick out the mctime of the latest dirent */\n\tif(fd->version > rii->mctime_ver && je32_to_cpu(rd->mctime)) {\n\t\trii->mctime_ver = fd->version;\n\t\trii->latest_mctime = je32_to_cpu(rd->mctime);\n\t}\n\n\t/*\n\t * Copy as much of the name as possible from the raw\n\t * dirent we've already read from the flash.\n\t */\n\tif (read > sizeof(*rd))\n\t\tmemcpy(&fd->name[0], &rd->name[0],\n\t\t       min_t(uint32_t, rd->nsize, (read - sizeof(*rd)) ));\n\n\t/* Do we need to copy any more of the name directly from the flash? */\n\tif (rd->nsize + sizeof(*rd) > read) {\n\t\t/* FIXME: point() */\n\t\tint err;\n\t\tint already = read - sizeof(*rd);\n\n\t\terr = jffs2_flash_read(c, (ref_offset(ref)) + read,\n\t\t\t\trd->nsize - already, &read, &fd->name[already]);\n\t\tif (unlikely(read != rd->nsize - already) && likely(!err))\n\t\t\treturn -EIO;\n\n\t\tif (unlikely(err)) {\n\t\t\tJFFS2_ERROR(\"read remainder of name: error %d\\n\", err);\n\t\t\tjffs2_free_full_dirent(fd);\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\n\tfd->nhash = full_name_hash(fd->name, rd->nsize);\n\tfd->next = NULL;\n\tfd->name[rd->nsize] = '\\0';\n\n\t/*\n\t * Wheee. We now have a complete jffs2_full_dirent structure, with\n\t * the name in it and everything. Link it into the list\n\t */\n\tjffs2_add_fd_to_list(c, fd, &rii->fds);\n\n\treturn 0;\n}\n\n/",
    "includes": [
      "include \"nodelist.h\"",
      "include <linux/compiler.h>\n#",
      "include <linux/mtd/mtd.h>\n#",
      "include <linux/pagemap.h>\n#",
      "include <linux/crc32.h>\n#",
      "include <linux/fs.h>\n#",
      "include <linux/slab.h>\n#",
      "include <linux/sched.h>\n#",
      "include <linux/kernel.h>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "s2_add_fd_to_list(c,",
          "args": [
            "f",
            "&",
            "i->fds);"
          ],
          "line": 681
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "l_name_hash(fd",
          "args": [
            ">name, r",
            ">nsize);"
          ],
          "line": 673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "s2_free_full_dirent(fd",
          "args": [
            ";"
          ],
          "line": 668
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S2_ERROR(\"r",
          "args": [
            "ad remainder of name: error %d\\n\", e",
            ");"
          ],
          "line": 667
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ikely(er",
          "args": [
            "))"
          ],
          "line": 666
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ely(!e",
          "args": [
            "r))"
          ],
          "line": 663
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ikely(re",
          "args": [
            "d != rd->nsize - already) &"
          ],
          "line": 663
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "s2_flash_read(c,",
          "args": [
            "(",
            "f_offset(ref)) + read,",
            ">nsize - already, &",
            "ad, &",
            "->name[already]);"
          ],
          "line": 661
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_offset(re",
          "args": [
            "))"
          ],
          "line": 661
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpy(&f",
          "args": [
            "->name[0], &",
            "->name[0],",
            "_t(uint32_t, rd->nsize, (read - sizeof(*rd)) ));"
          ],
          "line": 652
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_t(ui",
          "args": [
            "t32_t, r",
            ">nsize, (",
            "ad - sizeof(*rd)) ))"
          ],
          "line": 653
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "2_to_cpu(rd",
          "args": [
            ">mctime);"
          ],
          "line": 644
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "2_to_cpu(rd",
          "args": [
            ">mctime))"
          ],
          "line": 642
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "2_to_cpu(rd",
          "args": [
            ">ino);"
          ],
          "line": 635
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "2_to_cpu(rd",
          "args": [
            ">version);"
          ],
          "line": 634
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ikely(!f",
          "args": [
            "))"
          ],
          "line": 630
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "s2_alloc_full_dirent(rd",
          "args": [
            ">nsize + 1);"
          ],
          "line": 629
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "n_unlock(&c",
          "args": [
            ">erase_completion_lock);"
          ],
          "line": 626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ent_node_state(rd",
          "args": [
            ";"
          ],
          "line": 625
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_offset(re",
          "args": [
            ") |"
          ],
          "line": 625
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "n_lock(&c",
          "args": [
            ">erase_completion_lock);"
          ],
          "line": 620
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_totlen(c,",
          "args": [
            "j",
            ", r",
            ");"
          ],
          "line": 618
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "s2_mark_node_obsolete(c,",
          "args": [
            "r",
            ");"
          ],
          "line": 613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S2_ERROR(\"i",
          "args": [
            "legal nsize in node at %#08x: nsize %#02x, totlen %#04x\\n\",",
            "_offset(ref), r",
            ">nsize, j",
            "2_to_cpu(rd->totlen));"
          ],
          "line": 611
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "2_to_cpu(rd",
          "args": [
            ">totlen));"
          ],
          "line": 612
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_offset(re",
          "args": [
            "),"
          ],
          "line": 612
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ikely(PA",
          "args": [
            "((rd->nsize + sizeof(*rd))) != PAD(je32_to_cpu(rd->totlen))))"
          ],
          "line": 610
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "(je",
          "args": [
            "2_to_cpu(rd->totlen))))"
          ],
          "line": 610
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "2_to_cpu(rd",
          "args": [
            ">totlen)))"
          ],
          "line": 610
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "((r",
          "args": [
            "->nsize + sizeof(*rd))) !"
          ],
          "line": 610
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_flags(re",
          "args": [
            ") ="
          ],
          "line": 605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "s2_mark_node_obsolete(c,",
          "args": [
            "r",
            ");"
          ],
          "line": 600
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S2_NOTICE(\"h",
          "args": [
            "ader CRC failed on dirent node at %#08x: read %#08x, calculated %#08x\\n\",",
            "_offset(ref), j",
            "2_to_cpu(rd->node_crc), c",
            ");"
          ],
          "line": 598
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "2_to_cpu(rd",
          "args": [
            ">node_crc),"
          ],
          "line": 599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_offset(re",
          "args": [
            "),"
          ],
          "line": 599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ikely(cr",
          "args": [
            "!= je32_to_cpu(rd->node_crc)))"
          ],
          "line": 597
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "2_to_cpu(rd",
          "args": [
            ">node_crc)))"
          ],
          "line": 597
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "32(0,",
          "args": [
            "r",
            "s",
            "eof(*rd) - 8);"
          ],
          "line": 596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ON(re",
          "args": [
            "_obsolete(ref));"
          ],
          "line": 594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_obsolete(re",
          "args": [
            "));"
          ],
          "line": 594
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"nodelist.h\"\ninclude <linux/compiler.h>\n#\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/pagemap.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/fs.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/sched.h>\n#\ninclude <linux/kernel.h>\n#\n\ntic inline int read_direntry(struct jffs2_sb_info *c, struct jffs2_raw_node_ref *ref,\n\t\t\t\tstruct jffs2_raw_dirent *rd, size_t read,\n\t\t\t\tstruct jffs2_readinode_info *rii)\n{\n\tstruct jffs2_full_dirent *fd;\n\tuint32_t crc;\n\n\t/* Obsoleted. This cannot happen, surely? dwmw2 20020308 */\n\tBUG_ON(ref_obsolete(ref));\n\n\tcrc = crc32(0, rd, sizeof(*rd) - 8);\n\tif (unlikely(crc != je32_to_cpu(rd->node_crc))) {\n\t\tJFFS2_NOTICE(\"header CRC failed on dirent node at %#08x: read %#08x, calculated %#08x\\n\",\n\t\t\t     ref_offset(ref), je32_to_cpu(rd->node_crc), crc);\n\t\tjffs2_mark_node_obsolete(c, ref);\n\t\treturn 0;\n\t}\n\n\t/* If we've never checked the CRCs on this node, check them now */\n\tif (ref_flags(ref) == REF_UNCHECKED) {\n\t\tstruct jffs2_eraseblock *jeb;\n\t\tint len;\n\n\t\t/* Sanity check */\n\t\tif (unlikely(PAD((rd->nsize + sizeof(*rd))) != PAD(je32_to_cpu(rd->totlen)))) {\n\t\t\tJFFS2_ERROR(\"illegal nsize in node at %#08x: nsize %#02x, totlen %#04x\\n\",\n\t\t\t\t    ref_offset(ref), rd->nsize, je32_to_cpu(rd->totlen));\n\t\t\tjffs2_mark_node_obsolete(c, ref);\n\t\t\treturn 0;\n\t\t}\n\n\t\tjeb = &c->blocks[ref->flash_offset / c->sector_size];\n\t\tlen = ref_totlen(c, jeb, ref);\n\n\t\tspin_lock(&c->erase_completion_lock);\n\t\tjeb->used_size += len;\n\t\tjeb->unchecked_size -= len;\n\t\tc->used_size += len;\n\t\tc->unchecked_size -= len;\n\t\tref->flash_offset = ref_offset(ref) | dirent_node_state(rd);\n\t\tspin_unlock(&c->erase_completion_lock);\n\t}\n\n\tfd = jffs2_alloc_full_dirent(rd->nsize + 1);\n\tif (unlikely(!fd))\n\t\treturn -ENOMEM;\n\n\tfd->raw = ref;\n\tfd->version = je32_to_cpu(rd->version);\n\tfd->ino = je32_to_cpu(rd->ino);\n\tfd->type = rd->type;\n\n\tif (fd->version > rii->highest_version)\n\t\trii->highest_version = fd->version;\n\n\t/* Pick out the mctime of the latest dirent */\n\tif(fd->version > rii->mctime_ver && je32_to_cpu(rd->mctime)) {\n\t\trii->mctime_ver = fd->version;\n\t\trii->latest_mctime = je32_to_cpu(rd->mctime);\n\t}\n\n\t/*\n\t * Copy as much of the name as possible from the raw\n\t * dirent we've already read from the flash.\n\t */\n\tif (read > sizeof(*rd))\n\t\tmemcpy(&fd->name[0], &rd->name[0],\n\t\t       min_t(uint32_t, rd->nsize, (read - sizeof(*rd)) ));\n\n\t/* Do we need to copy any more of the name directly from the flash? */\n\tif (rd->nsize + sizeof(*rd) > read) {\n\t\t/* FIXME: point() */\n\t\tint err;\n\t\tint already = read - sizeof(*rd);\n\n\t\terr = jffs2_flash_read(c, (ref_offset(ref)) + read,\n\t\t\t\trd->nsize - already, &read, &fd->name[already]);\n\t\tif (unlikely(read != rd->nsize - already) && likely(!err))\n\t\t\treturn -EIO;\n\n\t\tif (unlikely(err)) {\n\t\t\tJFFS2_ERROR(\"read remainder of name: error %d\\n\", err);\n\t\t\tjffs2_free_full_dirent(fd);\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\n\tfd->nhash = full_name_hash(fd->name, rd->nsize);\n\tfd->next = NULL;\n\tfd->name[rd->nsize] = '\\0';\n\n\t/*\n\t * Wheee. We now have a complete jffs2_full_dirent structure, with\n\t * the name in it and everything. Link it into the list\n\t */\n\tjffs2_add_fd_to_list(c, fd, &rii->fds);\n\n\treturn 0;\n}\n\n/"
  },
  {
    "function_name": "s2_first_valid_node(st",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/readinode.c",
    "lines": "568-577",
    "snippet": "tic struct jffs2_raw_node_ref *jffs2_first_valid_node(struct jffs2_raw_node_ref *ref)\n{\n\twhile (ref && ref->next_in_ino) {\n\t\tif (!ref_obsolete(ref))\n\t\t\treturn ref;\n\t\tdbg_noderef(\"node at 0x%08x is obsoleted. Ignoring.\\n\", ref_offset(ref));\n\t\tref = ref->next_in_ino;\n\t}\n\treturn NULL;\n}\n\n/",
    "includes": [
      "include \"nodelist.h\"",
      "include <linux/compiler.h>\n#",
      "include <linux/mtd/mtd.h>\n#",
      "include <linux/pagemap.h>\n#",
      "include <linux/crc32.h>\n#",
      "include <linux/fs.h>\n#",
      "include <linux/slab.h>\n#",
      "include <linux/sched.h>\n#",
      "include <linux/kernel.h>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_noderef(\"n",
          "args": [
            "de at 0x%08x is obsoleted. Ignoring.\\n\", r",
            "_offset(ref));"
          ],
          "line": 573
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_offset(re",
          "args": [
            "));"
          ],
          "line": 573
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_obsolete(re",
          "args": [
            "))"
          ],
          "line": 571
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"nodelist.h\"\ninclude <linux/compiler.h>\n#\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/pagemap.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/fs.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/sched.h>\n#\ninclude <linux/kernel.h>\n#\n\ntic struct jffs2_raw_node_ref *jffs2_first_valid_node(struct jffs2_raw_node_ref *ref)\n{\n\twhile (ref && ref->next_in_ino) {\n\t\tif (!ref_obsolete(ref))\n\t\t\treturn ref;\n\t\tdbg_noderef(\"node at 0x%08x is obsoleted. Ignoring.\\n\", ref_offset(ref));\n\t\tref = ref->next_in_ino;\n\t}\n\treturn NULL;\n}\n\n/"
  },
  {
    "function_name": "s2_free_full_dirent_list(st",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/readinode.c",
    "lines": "556-565",
    "snippet": "tic void jffs2_free_full_dirent_list(struct jffs2_full_dirent *fd)\n{\n\tstruct jffs2_full_dirent *next;\n\n\twhile (fd) {\n\t\tnext = fd->next;\n\t\tjffs2_free_full_dirent(fd);\n\t\tfd = next;\n\t}\n}\n\n/",
    "includes": [
      "include \"nodelist.h\"",
      "include <linux/compiler.h>\n#",
      "include <linux/mtd/mtd.h>\n#",
      "include <linux/pagemap.h>\n#",
      "include <linux/crc32.h>\n#",
      "include <linux/fs.h>\n#",
      "include <linux/slab.h>\n#",
      "include <linux/sched.h>\n#",
      "include <linux/kernel.h>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "s2_free_full_dirent(fd",
          "args": [
            ";"
          ],
          "line": 562
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"nodelist.h\"\ninclude <linux/compiler.h>\n#\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/pagemap.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/fs.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/sched.h>\n#\ninclude <linux/kernel.h>\n#\n\ntic void jffs2_free_full_dirent_list(struct jffs2_full_dirent *fd)\n{\n\tstruct jffs2_full_dirent *next;\n\n\twhile (fd) {\n\t\tnext = fd->next;\n\t\tjffs2_free_full_dirent(fd);\n\t\tfd = next;\n\t}\n}\n\n/"
  },
  {
    "function_name": "s2_free_tmp_dnode_info_list(st",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/readinode.c",
    "lines": "544-554",
    "snippet": "tic void jffs2_free_tmp_dnode_info_list(struct rb_root *list)\n{\n\tstruct jffs2_tmp_dnode_info *tn, *next;\n\n\trbtree_postorder_for_each_entry_safe(tn, next, list, rb) {\n\t\t\tjffs2_free_full_dnode(tn->fn);\n\t\t\tjffs2_free_tmp_dnode_info(tn);\n\t}\n\n\t*list = RB_ROOT;\n}\n\ns",
    "includes": [
      "include \"nodelist.h\"",
      "include <linux/compiler.h>\n#",
      "include <linux/mtd/mtd.h>\n#",
      "include <linux/pagemap.h>\n#",
      "include <linux/crc32.h>\n#",
      "include <linux/fs.h>\n#",
      "include <linux/slab.h>\n#",
      "include <linux/sched.h>\n#",
      "include <linux/kernel.h>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "s2_free_tmp_dnode_info(tn",
          "args": [
            ";"
          ],
          "line": 550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "s2_free_full_dnode(tn",
          "args": [
            ">fn);"
          ],
          "line": 549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ree_postorder_for_each_entry_safe(tn",
          "args": [
            "n",
            "t, l",
            "t, r",
            "{"
          ],
          "line": 548
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"nodelist.h\"\ninclude <linux/compiler.h>\n#\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/pagemap.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/fs.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/sched.h>\n#\ninclude <linux/kernel.h>\n#\n\ntic void jffs2_free_tmp_dnode_info_list(struct rb_root *list)\n{\n\tstruct jffs2_tmp_dnode_info *tn, *next;\n\n\trbtree_postorder_for_each_entry_safe(tn, next, list, rb) {\n\t\t\tjffs2_free_full_dnode(tn->fn);\n\t\t\tjffs2_free_tmp_dnode_info(tn);\n\t}\n\n\t*list = RB_ROOT;\n}\n\ns"
  },
  {
    "function_name": "s2_build_inode_fragtree(st",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/readinode.c",
    "lines": "451-542",
    "snippet": "tic int jffs2_build_inode_fragtree(struct jffs2_sb_info *c,\n\t\t\t\t      struct jffs2_inode_info *f,\n\t\t\t\t      struct jffs2_readinode_info *rii)\n{\n\tstruct jffs2_tmp_dnode_info *pen, *last, *this;\n\tstruct rb_root ver_root = RB_ROOT;\n\tuint32_t high_ver = 0;\n\n\tif (rii->mdata_tn) {\n\t\tdbg_readinode(\"potential mdata is ver %d at %p\\n\", rii->mdata_tn->version, rii->mdata_tn);\n\t\thigh_ver = rii->mdata_tn->version;\n\t\trii->latest_ref = rii->mdata_tn->fn->raw;\n\t}\n#ifdef JFFS2_DBG_READINODE_MESSAGES\n\tthis = tn_last(&rii->tn_root);\n\twhile (this) {\n\t\tdbg_readinode(\"tn %p ver %d range 0x%x-0x%x ov %d\\n\", this, this->version, this->fn->ofs,\n\t\t\t      this->fn->ofs+this->fn->size, this->overlapped);\n\t\tthis = tn_prev(this);\n\t}\n#endif\n\tpen = tn_last(&rii->tn_root);\n\twhile ((last = pen)) {\n\t\tpen = tn_prev(last);\n\n\t\teat_last(&rii->tn_root, &last->rb);\n\t\tver_insert(&ver_root, last);\n\n\t\tif (unlikely(last->overlapped)) {\n\t\t\tif (pen)\n\t\t\t\tcontinue;\n\t\t\t/*\n\t\t\t * We killed a node which set the overlapped\n\t\t\t * flags during the scan. Fix it up.\n\t\t\t */\n\t\t\tlast->overlapped = 0;\n\t\t}\n\n\t\t/* Now we have a bunch of nodes in reverse version\n\t\t   order, in the tree at ver_root. Most of the time,\n\t\t   there'll actually be only one node in the 'tree',\n\t\t   in fact. */\n\t\tthis = tn_last(&ver_root);\n\n\t\twhile (this) {\n\t\t\tstruct jffs2_tmp_dnode_info *vers_next;\n\t\t\tint ret;\n\t\t\tvers_next = tn_prev(this);\n\t\t\teat_last(&ver_root, &this->rb);\n\t\t\tif (check_tn_node(c, this)) {\n\t\t\t\tdbg_readinode(\"node ver %d, 0x%x-0x%x failed CRC\\n\",\n\t\t\t\t\t     this->version, this->fn->ofs,\n\t\t\t\t\t     this->fn->ofs+this->fn->size);\n\t\t\t\tjffs2_kill_tn(c, this);\n\t\t\t} else {\n\t\t\t\tif (this->version > high_ver) {\n\t\t\t\t\t/* Note that this is different from the other\n\t\t\t\t\t   highest_version, because this one is only\n\t\t\t\t\t   counting _valid_ nodes which could give the\n\t\t\t\t\t   latest inode metadata */\n\t\t\t\t\thigh_ver = this->version;\n\t\t\t\t\trii->latest_ref = this->fn->raw;\n\t\t\t\t}\n\t\t\t\tdbg_readinode(\"Add %p (v %d, 0x%x-0x%x, ov %d) to fragtree\\n\",\n\t\t\t\t\t     this, this->version, this->fn->ofs,\n\t\t\t\t\t     this->fn->ofs+this->fn->size, this->overlapped);\n\n\t\t\t\tret = jffs2_add_full_dnode_to_inode(c, f, this->fn);\n\t\t\t\tif (ret) {\n\t\t\t\t\t/* Free the nodes in vers_root; let the caller\n\t\t\t\t\t   deal with the rest */\n\t\t\t\t\tJFFS2_ERROR(\"Add node to tree failed %d\\n\", ret);\n\t\t\t\t\twhile (1) {\n\t\t\t\t\t\tvers_next = tn_prev(this);\n\t\t\t\t\t\tif (check_tn_node(c, this))\n\t\t\t\t\t\t\tjffs2_mark_node_obsolete(c, this->fn->raw);\n\t\t\t\t\t\tjffs2_free_full_dnode(this->fn);\n\t\t\t\t\t\tjffs2_free_tmp_dnode_info(this);\n\t\t\t\t\t\tthis = vers_next;\n\t\t\t\t\t\tif (!this)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\teat_last(&ver_root, &vers_next->rb);\n\t\t\t\t\t}\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\t\t\t\tjffs2_free_tmp_dnode_info(this);\n\t\t\t}\n\t\t\tthis = vers_next;\n\t\t}\n\t}\n\treturn 0;\n}\n\ns",
    "includes": [
      "include \"nodelist.h\"",
      "include <linux/compiler.h>\n#",
      "include <linux/mtd/mtd.h>\n#",
      "include <linux/pagemap.h>\n#",
      "include <linux/crc32.h>\n#",
      "include <linux/fs.h>\n#",
      "include <linux/slab.h>\n#",
      "include <linux/sched.h>\n#",
      "include <linux/kernel.h>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "s2_free_tmp_dnode_info(th",
          "args": [
            "s);"
          ],
          "line": 536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_last(&v",
          "args": [
            "r_root, &",
            "rs_next->rb);"
          ],
          "line": 532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "s2_free_tmp_dnode_info(th",
          "args": [
            "s);"
          ],
          "line": 528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "s2_free_full_dnode(th",
          "args": [
            "s->fn);"
          ],
          "line": 527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "s2_mark_node_obsolete(c,",
          "args": [
            "t",
            "s->fn->raw);"
          ],
          "line": 526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ck_tn_node(c,",
          "args": [
            "t",
            "s))"
          ],
          "line": 525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prev(th",
          "args": [
            "s);"
          ],
          "line": 524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S2_ERROR(\"A",
          "args": [
            "d node to tree failed %d\\n\", r",
            ");"
          ],
          "line": 522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "s2_add_full_dnode_to_inode(c,",
          "args": [
            "f",
            "t",
            "s->fn);"
          ],
          "line": 518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_readinode(\"A",
          "args": [
            "d %p (v %d, 0x%x-0x%x, ov %d) to fragtree\\n\",",
            "s, t",
            "s->version, t",
            "s->fn->ofs,",
            "s->fn->ofs+this->fn->size, t",
            "s->overlapped);"
          ],
          "line": 514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "s2_kill_tn(c,",
          "args": [
            "t",
            "s);"
          ],
          "line": 504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_readinode(\"n",
          "args": [
            "de ver %d, 0x%x-0x%x failed CRC\\n\",",
            "s->version, t",
            "s->fn->ofs,",
            "s->fn->ofs+this->fn->size);"
          ],
          "line": 501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ck_tn_node(c,",
          "args": [
            "t",
            "s))"
          ],
          "line": 500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_last(&v",
          "args": [
            "r_root, &",
            "is->rb);"
          ],
          "line": 499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prev(th",
          "args": [
            "s);"
          ],
          "line": 498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "last(&v",
          "args": [
            "r_root);"
          ],
          "line": 493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ikely(la",
          "args": [
            "t->overlapped))"
          ],
          "line": 479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_insert(&v",
          "args": [
            "r_root, l",
            "t);"
          ],
          "line": 477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_last(&r",
          "args": [
            "i->tn_root, &",
            "st->rb);"
          ],
          "line": 476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prev(la",
          "args": [
            "t);"
          ],
          "line": 474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "last(&r",
          "args": [
            "i->tn_root);"
          ],
          "line": 472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prev(th",
          "args": [
            "s);"
          ],
          "line": 469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_readinode(\"t",
          "args": [
            "%p ver %d range 0x%x-0x%x ov %d\\n\", t",
            "s, t",
            "s->version, t",
            "s->fn->ofs,",
            "s->fn->ofs+this->fn->size, t",
            "s->overlapped);"
          ],
          "line": 467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "last(&r",
          "args": [
            "i->tn_root);"
          ],
          "line": 465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_readinode(\"p",
          "args": [
            "tential mdata is ver %d at %p\\n\", r",
            "->mdata_tn->version, r",
            "->mdata_tn);"
          ],
          "line": 460
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"nodelist.h\"\ninclude <linux/compiler.h>\n#\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/pagemap.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/fs.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/sched.h>\n#\ninclude <linux/kernel.h>\n#\n\ntic int jffs2_build_inode_fragtree(struct jffs2_sb_info *c,\n\t\t\t\t      struct jffs2_inode_info *f,\n\t\t\t\t      struct jffs2_readinode_info *rii)\n{\n\tstruct jffs2_tmp_dnode_info *pen, *last, *this;\n\tstruct rb_root ver_root = RB_ROOT;\n\tuint32_t high_ver = 0;\n\n\tif (rii->mdata_tn) {\n\t\tdbg_readinode(\"potential mdata is ver %d at %p\\n\", rii->mdata_tn->version, rii->mdata_tn);\n\t\thigh_ver = rii->mdata_tn->version;\n\t\trii->latest_ref = rii->mdata_tn->fn->raw;\n\t}\n#ifdef JFFS2_DBG_READINODE_MESSAGES\n\tthis = tn_last(&rii->tn_root);\n\twhile (this) {\n\t\tdbg_readinode(\"tn %p ver %d range 0x%x-0x%x ov %d\\n\", this, this->version, this->fn->ofs,\n\t\t\t      this->fn->ofs+this->fn->size, this->overlapped);\n\t\tthis = tn_prev(this);\n\t}\n#endif\n\tpen = tn_last(&rii->tn_root);\n\twhile ((last = pen)) {\n\t\tpen = tn_prev(last);\n\n\t\teat_last(&rii->tn_root, &last->rb);\n\t\tver_insert(&ver_root, last);\n\n\t\tif (unlikely(last->overlapped)) {\n\t\t\tif (pen)\n\t\t\t\tcontinue;\n\t\t\t/*\n\t\t\t * We killed a node which set the overlapped\n\t\t\t * flags during the scan. Fix it up.\n\t\t\t */\n\t\t\tlast->overlapped = 0;\n\t\t}\n\n\t\t/* Now we have a bunch of nodes in reverse version\n\t\t   order, in the tree at ver_root. Most of the time,\n\t\t   there'll actually be only one node in the 'tree',\n\t\t   in fact. */\n\t\tthis = tn_last(&ver_root);\n\n\t\twhile (this) {\n\t\t\tstruct jffs2_tmp_dnode_info *vers_next;\n\t\t\tint ret;\n\t\t\tvers_next = tn_prev(this);\n\t\t\teat_last(&ver_root, &this->rb);\n\t\t\tif (check_tn_node(c, this)) {\n\t\t\t\tdbg_readinode(\"node ver %d, 0x%x-0x%x failed CRC\\n\",\n\t\t\t\t\t     this->version, this->fn->ofs,\n\t\t\t\t\t     this->fn->ofs+this->fn->size);\n\t\t\t\tjffs2_kill_tn(c, this);\n\t\t\t} else {\n\t\t\t\tif (this->version > high_ver) {\n\t\t\t\t\t/* Note that this is different from the other\n\t\t\t\t\t   highest_version, because this one is only\n\t\t\t\t\t   counting _valid_ nodes which could give the\n\t\t\t\t\t   latest inode metadata */\n\t\t\t\t\thigh_ver = this->version;\n\t\t\t\t\trii->latest_ref = this->fn->raw;\n\t\t\t\t}\n\t\t\t\tdbg_readinode(\"Add %p (v %d, 0x%x-0x%x, ov %d) to fragtree\\n\",\n\t\t\t\t\t     this, this->version, this->fn->ofs,\n\t\t\t\t\t     this->fn->ofs+this->fn->size, this->overlapped);\n\n\t\t\t\tret = jffs2_add_full_dnode_to_inode(c, f, this->fn);\n\t\t\t\tif (ret) {\n\t\t\t\t\t/* Free the nodes in vers_root; let the caller\n\t\t\t\t\t   deal with the rest */\n\t\t\t\t\tJFFS2_ERROR(\"Add node to tree failed %d\\n\", ret);\n\t\t\t\t\twhile (1) {\n\t\t\t\t\t\tvers_next = tn_prev(this);\n\t\t\t\t\t\tif (check_tn_node(c, this))\n\t\t\t\t\t\t\tjffs2_mark_node_obsolete(c, this->fn->raw);\n\t\t\t\t\t\tjffs2_free_full_dnode(this->fn);\n\t\t\t\t\t\tjffs2_free_tmp_dnode_info(this);\n\t\t\t\t\t\tthis = vers_next;\n\t\t\t\t\t\tif (!this)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\teat_last(&ver_root, &vers_next->rb);\n\t\t\t\t\t}\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\t\t\t\tjffs2_free_tmp_dnode_info(this);\n\t\t\t}\n\t\t\tthis = vers_next;\n\t\t}\n\t}\n\treturn 0;\n}\n\ns"
  },
  {
    "function_name": "_insert(st",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/readinode.c",
    "lines": "424-442",
    "snippet": "tic void ver_insert(struct rb_root *ver_root, struct jffs2_tmp_dnode_info *tn)\n{\n\tstruct rb_node **link = &ver_root->rb_node;\n\tstruct rb_node *parent = NULL;\n\tstruct jffs2_tmp_dnode_info *this_tn;\n\n\twhile (*link) {\n\t\tparent = *link;\n\t\tthis_tn = rb_entry(parent, struct jffs2_tmp_dnode_info, rb);\n\n\t\tif (tn->version > this_tn->version)\n\t\t\tlink = &parent->rb_left;\n\t\telse\n\t\t\tlink = &parent->rb_right;\n\t}\n\tdbg_readinode(\"Link new node at %p (root is %p)\\n\", link, ver_root);\n\trb_link_node(&tn->rb, parent, link);\n\trb_insert_color(&tn->rb, ver_root);\n}\n\n/",
    "includes": [
      "include \"nodelist.h\"",
      "include <linux/compiler.h>\n#",
      "include <linux/mtd/mtd.h>\n#",
      "include <linux/pagemap.h>\n#",
      "include <linux/crc32.h>\n#",
      "include <linux/fs.h>\n#",
      "include <linux/slab.h>\n#",
      "include <linux/sched.h>\n#",
      "include <linux/kernel.h>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "insert_color(&t",
          "args": [
            "->rb, v",
            "_root);"
          ],
          "line": 441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "link_node(&t",
          "args": [
            "->rb, p",
            "ent, l",
            "k);"
          ],
          "line": 440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_readinode(\"L",
          "args": [
            "nk new node at %p (root is %p)\\n\", l",
            "k, v",
            "_root);"
          ],
          "line": 439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "entry(pa",
          "args": [
            "ent, s",
            "uct jfs2_tmp_dnode_info, r",
            ";"
          ],
          "line": 432
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"nodelist.h\"\ninclude <linux/compiler.h>\n#\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/pagemap.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/fs.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/sched.h>\n#\ninclude <linux/kernel.h>\n#\n\ntic void ver_insert(struct rb_root *ver_root, struct jffs2_tmp_dnode_info *tn)\n{\n\tstruct rb_node **link = &ver_root->rb_node;\n\tstruct rb_node *parent = NULL;\n\tstruct jffs2_tmp_dnode_info *this_tn;\n\n\twhile (*link) {\n\t\tparent = *link;\n\t\tthis_tn = rb_entry(parent, struct jffs2_tmp_dnode_info, rb);\n\n\t\tif (tn->version > this_tn->version)\n\t\t\tlink = &parent->rb_left;\n\t\telse\n\t\t\tlink = &parent->rb_right;\n\t}\n\tdbg_readinode(\"Link new node at %p (root is %p)\\n\", link, ver_root);\n\trb_link_node(&tn->rb, parent, link);\n\trb_insert_color(&tn->rb, ver_root);\n}\n\n/"
  },
  {
    "function_name": "_last(st",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/readinode.c",
    "lines": "402-420",
    "snippet": "tic void eat_last(struct rb_root *root, struct rb_node *node)\n{\n\tstruct rb_node *parent = rb_parent(node);\n\tstruct rb_node **link;\n\n\t/* LAST! */\n\tBUG_ON(node->rb_right);\n\n\tif (!parent)\n\t\tlink = &root->rb_node;\n\telse if (node == parent->rb_left)\n\t\tlink = &parent->rb_left;\n\telse\n\t\tlink = &parent->rb_right;\n\n\t*link = node->rb_left;\n\tif (node->rb_left)\n\t\tnode->rb_left->__rb_parent_color = node->__rb_parent_color;\n}\n\n/",
    "includes": [
      "include \"nodelist.h\"",
      "include <linux/compiler.h>\n#",
      "include <linux/mtd/mtd.h>\n#",
      "include <linux/pagemap.h>\n#",
      "include <linux/crc32.h>\n#",
      "include <linux/fs.h>\n#",
      "include <linux/slab.h>\n#",
      "include <linux/sched.h>\n#",
      "include <linux/kernel.h>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_ON(no",
          "args": [
            "e->rb_right);"
          ],
          "line": 408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parent(no",
          "args": [
            "e);"
          ],
          "line": 404
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"nodelist.h\"\ninclude <linux/compiler.h>\n#\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/pagemap.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/fs.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/sched.h>\n#\ninclude <linux/kernel.h>\n#\n\ntic void eat_last(struct rb_root *root, struct rb_node *node)\n{\n\tstruct rb_node *parent = rb_parent(node);\n\tstruct rb_node **link;\n\n\t/* LAST! */\n\tBUG_ON(node->rb_right);\n\n\tif (!parent)\n\t\tlink = &root->rb_node;\n\telse if (node == parent->rb_left)\n\t\tlink = &parent->rb_left;\n\telse\n\t\tlink = &parent->rb_right;\n\n\t*link = node->rb_left;\n\tif (node->rb_left)\n\t\tnode->rb_left->__rb_parent_color = node->__rb_parent_color;\n}\n\n/"
  },
  {
    "function_name": "ffs2_add_tn_to_tree(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/readinode.c",
    "lines": "218-394",
    "snippet": "tatic int jffs2_add_tn_to_tree(struct jffs2_sb_info *c,\n\t\t\t\tstruct jffs2_readinode_info *rii,\n\t\t\t\tstruct jffs2_tmp_dnode_info *tn)\n{\n\tuint32_t fn_end = tn->fn->ofs + tn->fn->size;\n\tstruct jffs2_tmp_dnode_info *this, *ptn;\n\n\tdbg_readinode(\"insert fragment %#04x-%#04x, ver %u at %08x\\n\", tn->fn->ofs, fn_end, tn->version, ref_offset(tn->fn->raw));\n\n\t/* If a node has zero dsize, we only have to keep it if it might be the\n\t   node with highest version -- i.e. the one which will end up as f->metadata.\n\t   Note that such nodes won't be REF_UNCHECKED since there are no data to\n\t   check anyway. */\n\tif (!tn->fn->size) {\n\t\tif (rii->mdata_tn) {\n\t\t\tif (rii->mdata_tn->version < tn->version) {\n\t\t\t\t/* We had a candidate mdata node already */\n\t\t\t\tdbg_readinode(\"kill old mdata with ver %d\\n\", rii->mdata_tn->version);\n\t\t\t\tjffs2_kill_tn(c, rii->mdata_tn);\n\t\t\t} else {\n\t\t\t\tdbg_readinode(\"kill new mdata with ver %d (older than existing %d\\n\",\n\t\t\t\t\t      tn->version, rii->mdata_tn->version);\n\t\t\t\tjffs2_kill_tn(c, tn);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\trii->mdata_tn = tn;\n\t\tdbg_readinode(\"keep new mdata with ver %d\\n\", tn->version);\n\t\treturn 0;\n\t}\n\n\t/* Find the earliest node which _may_ be relevant to this one */\n\tthis = jffs2_lookup_tn(&rii->tn_root, tn->fn->ofs);\n\tif (this) {\n\t\t/* If the node is coincident with another at a lower address,\n\t\t   back up until the other node is found. It may be relevant */\n\t\twhile (this->overlapped) {\n\t\t\tptn = tn_prev(this);\n\t\t\tif (!ptn) {\n\t\t\t\t/*\n\t\t\t\t * We killed a node which set the overlapped\n\t\t\t\t * flags during the scan. Fix it up.\n\t\t\t\t */\n\t\t\t\tthis->overlapped = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tthis = ptn;\n\t\t}\n\t\tdbg_readinode(\"'this' found %#04x-%#04x (%s)\\n\", this->fn->ofs, this->fn->ofs + this->fn->size, this->fn ? \"data\" : \"hole\");\n\t}\n\n\twhile (this) {\n\t\tif (this->fn->ofs > fn_end)\n\t\t\tbreak;\n\t\tdbg_readinode(\"Ponder this ver %d, 0x%x-0x%x\\n\",\n\t\t\t      this->version, this->fn->ofs, this->fn->size);\n\n\t\tif (this->version == tn->version) {\n\t\t\t/* Version number collision means REF_PRISTINE GC. Accept either of them\n\t\t\t   as long as the CRC is correct. Check the one we have already...  */\n\t\t\tif (!check_tn_node(c, this)) {\n\t\t\t\t/* The one we already had was OK. Keep it and throw away the new one */\n\t\t\t\tdbg_readinode(\"Like old node. Throw away new\\n\");\n\t\t\t\tjffs2_kill_tn(c, tn);\n\t\t\t\treturn 0;\n\t\t\t} else {\n\t\t\t\t/* Who cares if the new one is good; keep it for now anyway. */\n\t\t\t\tdbg_readinode(\"Like new node. Throw away old\\n\");\n\t\t\t\trb_replace_node(&this->rb, &tn->rb, &rii->tn_root);\n\t\t\t\tjffs2_kill_tn(c, this);\n\t\t\t\t/* Same overlapping from in front and behind */\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\tif (this->version < tn->version &&\n\t\t    this->fn->ofs >= tn->fn->ofs &&\n\t\t    this->fn->ofs + this->fn->size <= fn_end) {\n\t\t\t/* New node entirely overlaps 'this' */\n\t\t\tif (check_tn_node(c, tn)) {\n\t\t\t\tdbg_readinode(\"new node bad CRC\\n\");\n\t\t\t\tjffs2_kill_tn(c, tn);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\t/* ... and is good. Kill 'this' and any subsequent nodes which are also overlapped */\n\t\t\twhile (this && this->fn->ofs + this->fn->size <= fn_end) {\n\t\t\t\tstruct jffs2_tmp_dnode_info *next = tn_next(this);\n\t\t\t\tif (this->version < tn->version) {\n\t\t\t\t\ttn_erase(this, &rii->tn_root);\n\t\t\t\t\tdbg_readinode(\"Kill overlapped ver %d, 0x%x-0x%x\\n\",\n\t\t\t\t\t\t      this->version, this->fn->ofs,\n\t\t\t\t\t\t      this->fn->ofs+this->fn->size);\n\t\t\t\t\tjffs2_kill_tn(c, this);\n\t\t\t\t}\n\t\t\t\tthis = next;\n\t\t\t}\n\t\t\tdbg_readinode(\"Done killing overlapped nodes\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\tif (this->version > tn->version &&\n\t\t    this->fn->ofs <= tn->fn->ofs &&\n\t\t    this->fn->ofs+this->fn->size >= fn_end) {\n\t\t\t/* New node entirely overlapped by 'this' */\n\t\t\tif (!check_tn_node(c, this)) {\n\t\t\t\tdbg_readinode(\"Good CRC on old node. Kill new\\n\");\n\t\t\t\tjffs2_kill_tn(c, tn);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\t/* ... but 'this' was bad. Replace it... */\n\t\t\tdbg_readinode(\"Bad CRC on old overlapping node. Kill it\\n\");\n\t\t\ttn_erase(this, &rii->tn_root);\n\t\t\tjffs2_kill_tn(c, this);\n\t\t\tbreak;\n\t\t}\n\n\t\tthis = tn_next(this);\n\t}\n\n\t/* We neither completely obsoleted nor were completely\n\t   obsoleted by an earlier node. Insert into the tree */\n\t{\n\t\tstruct rb_node *parent;\n\t\tstruct rb_node **link = &rii->tn_root.rb_node;\n\t\tstruct jffs2_tmp_dnode_info *insert_point = NULL;\n\n\t\twhile (*link) {\n\t\t\tparent = *link;\n\t\t\tinsert_point = rb_entry(parent, struct jffs2_tmp_dnode_info, rb);\n\t\t\tif (tn->fn->ofs > insert_point->fn->ofs)\n\t\t\t\tlink = &insert_point->rb.rb_right;\n\t\t\telse if (tn->fn->ofs < insert_point->fn->ofs ||\n\t\t\t\t tn->fn->size < insert_point->fn->size)\n\t\t\t\tlink = &insert_point->rb.rb_left;\n\t\t\telse\n\t\t\t\tlink = &insert_point->rb.rb_right;\n\t\t}\n\t\trb_link_node(&tn->rb, &insert_point->rb, link);\n\t\trb_insert_color(&tn->rb, &rii->tn_root);\n\t}\n\n\t/* If there's anything behind that overlaps us, note it */\n\tthis = tn_prev(tn);\n\tif (this) {\n\t\twhile (1) {\n\t\t\tif (this->fn->ofs + this->fn->size > tn->fn->ofs) {\n\t\t\t\tdbg_readinode(\"Node is overlapped by %p (v %d, 0x%x-0x%x)\\n\",\n\t\t\t\t\t      this, this->version, this->fn->ofs,\n\t\t\t\t\t      this->fn->ofs+this->fn->size);\n\t\t\t\ttn->overlapped = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!this->overlapped)\n\t\t\t\tbreak;\n\n\t\t\tptn = tn_prev(this);\n\t\t\tif (!ptn) {\n\t\t\t\t/*\n\t\t\t\t * We killed a node which set the overlapped\n\t\t\t\t * flags during the scan. Fix it up.\n\t\t\t\t */\n\t\t\t\tthis->overlapped = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tthis = ptn;\n\t\t}\n\t}\n\n\t/* If the new node overlaps anything ahead, note it */\n\tthis = tn_next(tn);\n\twhile (this && this->fn->ofs < fn_end) {\n\t\tthis->overlapped = 1;\n\t\tdbg_readinode(\"Node ver %d, 0x%x-0x%x is overlapped\\n\",\n\t\t\t      this->version, this->fn->ofs,\n\t\t\t      this->fn->ofs+this->fn->size);\n\t\tthis = tn_next(this);\n\t}\n\treturn 0;\n}",
    "includes": [
      "include \"nodelist.h\"",
      "include <linux/compiler.h>\n#",
      "include <linux/mtd/mtd.h>\n#",
      "include <linux/pagemap.h>\n#",
      "include <linux/crc32.h>\n#",
      "include <linux/fs.h>\n#",
      "include <linux/slab.h>\n#",
      "include <linux/sched.h>\n#",
      "include <linux/kernel.h>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "n_next(",
          "args": [
            "his)"
          ],
          "line": 391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bg_readinode(",
          "args": [
            "Node ver %d, 0x%x-0x%x is overlapped\\n\",",
            "his->version,",
            "his->fn->ofs,",
            "his->fn->ofs+this->fn->size)"
          ],
          "line": 388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "n_next(",
          "args": [
            "n)"
          ],
          "line": 385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "n_prev(",
          "args": [
            "his)"
          ],
          "line": 371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bg_readinode(",
          "args": [
            "Node is overlapped by %p (v %d, 0x%x-0x%x)\\n\",",
            "his,",
            "his->version,",
            "his->fn->ofs,",
            "his->fn->ofs+this->fn->size)"
          ],
          "line": 362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "n_prev(",
          "args": [
            "n)"
          ],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "b_insert_color(",
          "args": [
            "tn->rb,",
            "rii->tn_root)"
          ],
          "line": 354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "b_link_node(",
          "args": [
            "tn->rb,",
            "insert_point->rb,",
            "ink)"
          ],
          "line": 353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "b_entry(",
          "args": [
            "arent,",
            "truct ffs2_tmp_dnode_info,",
            "b)"
          ],
          "line": 344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "n_next(",
          "args": [
            "his)"
          ],
          "line": 332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_kill_tn(",
          "args": [
            ",",
            "his)"
          ],
          "line": 328
        },
        "resolved": true,
        "details": {
          "function_name": "ffs2_kill_tn(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/readinode.c",
          "lines": "199-204",
          "snippet": "tatic void jffs2_kill_tn(struct jffs2_sb_info *c, struct jffs2_tmp_dnode_info *tn)\n{\n\tjffs2_mark_node_obsolete(c, tn->fn->raw);\n\tjffs2_free_full_dnode(tn->fn);\n\tjffs2_free_tmp_dnode_info(tn);\n}",
          "includes": [
            "include \"nodelist.h\"",
            "include <linux/compiler.h>\n#",
            "include <linux/mtd/mtd.h>\n#",
            "include <linux/pagemap.h>\n#",
            "include <linux/crc32.h>\n#",
            "include <linux/fs.h>\n#",
            "include <linux/slab.h>\n#",
            "include <linux/sched.h>\n#",
            "include <linux/kernel.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"nodelist.h\"\ninclude <linux/compiler.h>\n#\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/pagemap.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/fs.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/sched.h>\n#\ninclude <linux/kernel.h>\n#\n\ntatic void jffs2_kill_tn(struct jffs2_sb_info *c, struct jffs2_tmp_dnode_info *tn)\n{\n\tjffs2_mark_node_obsolete(c, tn->fn->raw);\n\tjffs2_free_full_dnode(tn->fn);\n\tjffs2_free_tmp_dnode_info(tn);\n}"
        }
      },
      {
        "call_info": {
          "callee": "n_erase(",
          "args": [
            "his,",
            "rii->tn_root)"
          ],
          "line": 327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bg_readinode(",
          "args": [
            "Bad CRC on old overlapping node. Kill it\\n\")"
          ],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bg_readinode(",
          "args": [
            "Good CRC on old node. Kill new\\n\")"
          ],
          "line": 321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "heck_tn_node(",
          "args": [
            ",",
            "his)"
          ],
          "line": 320
        },
        "resolved": true,
        "details": {
          "function_name": "heck_tn_node(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/readinode.c",
          "lines": "150-173",
          "snippet": "tatic int check_tn_node(struct jffs2_sb_info *c, struct jffs2_tmp_dnode_info *tn)\n{\n\tint ret;\n\n\tBUG_ON(ref_obsolete(tn->fn->raw));\n\n\t/* We only check the data CRC of unchecked nodes */\n\tif (ref_flags(tn->fn->raw) != REF_UNCHECKED)\n\t\treturn 0;\n\n\tdbg_readinode(\"check node %#04x-%#04x, phys offs %#08x\\n\",\n\t\t      tn->fn->ofs, tn->fn->ofs + tn->fn->size, ref_offset(tn->fn->raw));\n\n\tret = check_node_data(c, tn);\n\tif (unlikely(ret < 0)) {\n\t\tJFFS2_ERROR(\"check_node_data() returned error: %d.\\n\",\n\t\t\tret);\n\t} else if (unlikely(ret > 0)) {\n\t\tdbg_readinode(\"CRC error, mark it obsolete.\\n\");\n\t\tjffs2_mark_node_obsolete(c, tn->fn->raw);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "include \"nodelist.h\"",
            "include <linux/compiler.h>\n#",
            "include <linux/mtd/mtd.h>\n#",
            "include <linux/pagemap.h>\n#",
            "include <linux/crc32.h>\n#",
            "include <linux/fs.h>\n#",
            "include <linux/slab.h>\n#",
            "include <linux/sched.h>\n#",
            "include <linux/kernel.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"nodelist.h\"\ninclude <linux/compiler.h>\n#\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/pagemap.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/fs.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/sched.h>\n#\ninclude <linux/kernel.h>\n#\n\ntatic int check_tn_node(struct jffs2_sb_info *c, struct jffs2_tmp_dnode_info *tn)\n{\n\tint ret;\n\n\tBUG_ON(ref_obsolete(tn->fn->raw));\n\n\t/* We only check the data CRC of unchecked nodes */\n\tif (ref_flags(tn->fn->raw) != REF_UNCHECKED)\n\t\treturn 0;\n\n\tdbg_readinode(\"check node %#04x-%#04x, phys offs %#08x\\n\",\n\t\t      tn->fn->ofs, tn->fn->ofs + tn->fn->size, ref_offset(tn->fn->raw));\n\n\tret = check_node_data(c, tn);\n\tif (unlikely(ret < 0)) {\n\t\tJFFS2_ERROR(\"check_node_data() returned error: %d.\\n\",\n\t\t\tret);\n\t} else if (unlikely(ret > 0)) {\n\t\tdbg_readinode(\"CRC error, mark it obsolete.\\n\");\n\t\tjffs2_mark_node_obsolete(c, tn->fn->raw);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bg_readinode(",
          "args": [
            "Done killing overlapped nodes\\n\")"
          ],
          "line": 313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bg_readinode(",
          "args": [
            "Kill overlapped ver %d, 0x%x-0x%x\\n\",",
            "his->version,",
            "his->fn->ofs,",
            "his->fn->ofs+this->fn->size)"
          ],
          "line": 306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "n_erase(",
          "args": [
            "his,",
            "rii->tn_root)"
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "n_next(",
          "args": [
            "his)"
          ],
          "line": 303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bg_readinode(",
          "args": [
            "new node bad CRC\\n\")"
          ],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "b_replace_node(",
          "args": [
            "this->rb,",
            "tn->rb,",
            "rii->tn_root)"
          ],
          "line": 286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bg_readinode(",
          "args": [
            "Like new node. Throw away old\\n\")"
          ],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bg_readinode(",
          "args": [
            "Like old node. Throw away new\\n\")"
          ],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bg_readinode(",
          "args": [
            "Ponder this ver %d, 0x%x-0x%x\\n\",",
            "his->version,",
            "his->fn->ofs,",
            "his->fn->size)"
          ],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bg_readinode(",
          "args": [
            "'this' found %#04x-%#04x (%s)\\n\",",
            "his->fn->ofs,",
            "his->fn->ofs + this->fn->size,",
            "his->fn ? \"data\" : \"hole\")"
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "n_prev(",
          "args": [
            "his)"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_lookup_tn(",
          "args": [
            "rii->tn_root,",
            "n->fn->ofs)"
          ],
          "line": 250
        },
        "resolved": true,
        "details": {
          "function_name": "ffs2_lookup_tn(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/readinode.c",
          "lines": "175-196",
          "snippet": "tatic struct jffs2_tmp_dnode_info *jffs2_lookup_tn(struct rb_root *tn_root, uint32_t offset)\n{\n\tstruct rb_node *next;\n\tstruct jffs2_tmp_dnode_info *tn = NULL;\n\n\tdbg_readinode(\"root %p, offset %d\\n\", tn_root, offset);\n\n\tnext = tn_root->rb_node;\n\n\twhile (next) {\n\t\ttn = rb_entry(next, struct jffs2_tmp_dnode_info, rb);\n\n\t\tif (tn->fn->ofs < offset)\n\t\t\tnext = tn->rb.rb_right;\n\t\telse if (tn->fn->ofs >= offset)\n\t\t\tnext = tn->rb.rb_left;\n\t\telse\n\t\t\tbreak;\n\t}\n\n\treturn tn;\n}",
          "includes": [
            "include \"nodelist.h\"",
            "include <linux/compiler.h>\n#",
            "include <linux/mtd/mtd.h>\n#",
            "include <linux/pagemap.h>\n#",
            "include <linux/crc32.h>\n#",
            "include <linux/fs.h>\n#",
            "include <linux/slab.h>\n#",
            "include <linux/sched.h>\n#",
            "include <linux/kernel.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"nodelist.h\"\ninclude <linux/compiler.h>\n#\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/pagemap.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/fs.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/sched.h>\n#\ninclude <linux/kernel.h>\n#\n\ntatic struct jffs2_tmp_dnode_info *jffs2_lookup_tn(struct rb_root *tn_root, uint32_t offset)\n{\n\tstruct rb_node *next;\n\tstruct jffs2_tmp_dnode_info *tn = NULL;\n\n\tdbg_readinode(\"root %p, offset %d\\n\", tn_root, offset);\n\n\tnext = tn_root->rb_node;\n\n\twhile (next) {\n\t\ttn = rb_entry(next, struct jffs2_tmp_dnode_info, rb);\n\n\t\tif (tn->fn->ofs < offset)\n\t\t\tnext = tn->rb.rb_right;\n\t\telse if (tn->fn->ofs >= offset)\n\t\t\tnext = tn->rb.rb_left;\n\t\telse\n\t\t\tbreak;\n\t}\n\n\treturn tn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bg_readinode(",
          "args": [
            "keep new mdata with ver %d\\n\",",
            "n->version)"
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bg_readinode(",
          "args": [
            "kill new mdata with ver %d (older than existing %d\\n\",",
            "n->version,",
            "ii->mdata_tn->version)"
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bg_readinode(",
          "args": [
            "kill old mdata with ver %d\\n\",",
            "ii->mdata_tn->version)"
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bg_readinode(",
          "args": [
            "insert fragment %#04x-%#04x, ver %u at %08x\\n\",",
            "n->fn->ofs,",
            "n_end,",
            "n->version,",
            "ef_offset(tn->fn->raw))"
          ],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ef_offset(",
          "args": [
            "n->fn->raw)"
          ],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"nodelist.h\"\ninclude <linux/compiler.h>\n#\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/pagemap.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/fs.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/sched.h>\n#\ninclude <linux/kernel.h>\n#\n\ntatic int jffs2_add_tn_to_tree(struct jffs2_sb_info *c,\n\t\t\t\tstruct jffs2_readinode_info *rii,\n\t\t\t\tstruct jffs2_tmp_dnode_info *tn)\n{\n\tuint32_t fn_end = tn->fn->ofs + tn->fn->size;\n\tstruct jffs2_tmp_dnode_info *this, *ptn;\n\n\tdbg_readinode(\"insert fragment %#04x-%#04x, ver %u at %08x\\n\", tn->fn->ofs, fn_end, tn->version, ref_offset(tn->fn->raw));\n\n\t/* If a node has zero dsize, we only have to keep it if it might be the\n\t   node with highest version -- i.e. the one which will end up as f->metadata.\n\t   Note that such nodes won't be REF_UNCHECKED since there are no data to\n\t   check anyway. */\n\tif (!tn->fn->size) {\n\t\tif (rii->mdata_tn) {\n\t\t\tif (rii->mdata_tn->version < tn->version) {\n\t\t\t\t/* We had a candidate mdata node already */\n\t\t\t\tdbg_readinode(\"kill old mdata with ver %d\\n\", rii->mdata_tn->version);\n\t\t\t\tjffs2_kill_tn(c, rii->mdata_tn);\n\t\t\t} else {\n\t\t\t\tdbg_readinode(\"kill new mdata with ver %d (older than existing %d\\n\",\n\t\t\t\t\t      tn->version, rii->mdata_tn->version);\n\t\t\t\tjffs2_kill_tn(c, tn);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\trii->mdata_tn = tn;\n\t\tdbg_readinode(\"keep new mdata with ver %d\\n\", tn->version);\n\t\treturn 0;\n\t}\n\n\t/* Find the earliest node which _may_ be relevant to this one */\n\tthis = jffs2_lookup_tn(&rii->tn_root, tn->fn->ofs);\n\tif (this) {\n\t\t/* If the node is coincident with another at a lower address,\n\t\t   back up until the other node is found. It may be relevant */\n\t\twhile (this->overlapped) {\n\t\t\tptn = tn_prev(this);\n\t\t\tif (!ptn) {\n\t\t\t\t/*\n\t\t\t\t * We killed a node which set the overlapped\n\t\t\t\t * flags during the scan. Fix it up.\n\t\t\t\t */\n\t\t\t\tthis->overlapped = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tthis = ptn;\n\t\t}\n\t\tdbg_readinode(\"'this' found %#04x-%#04x (%s)\\n\", this->fn->ofs, this->fn->ofs + this->fn->size, this->fn ? \"data\" : \"hole\");\n\t}\n\n\twhile (this) {\n\t\tif (this->fn->ofs > fn_end)\n\t\t\tbreak;\n\t\tdbg_readinode(\"Ponder this ver %d, 0x%x-0x%x\\n\",\n\t\t\t      this->version, this->fn->ofs, this->fn->size);\n\n\t\tif (this->version == tn->version) {\n\t\t\t/* Version number collision means REF_PRISTINE GC. Accept either of them\n\t\t\t   as long as the CRC is correct. Check the one we have already...  */\n\t\t\tif (!check_tn_node(c, this)) {\n\t\t\t\t/* The one we already had was OK. Keep it and throw away the new one */\n\t\t\t\tdbg_readinode(\"Like old node. Throw away new\\n\");\n\t\t\t\tjffs2_kill_tn(c, tn);\n\t\t\t\treturn 0;\n\t\t\t} else {\n\t\t\t\t/* Who cares if the new one is good; keep it for now anyway. */\n\t\t\t\tdbg_readinode(\"Like new node. Throw away old\\n\");\n\t\t\t\trb_replace_node(&this->rb, &tn->rb, &rii->tn_root);\n\t\t\t\tjffs2_kill_tn(c, this);\n\t\t\t\t/* Same overlapping from in front and behind */\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\tif (this->version < tn->version &&\n\t\t    this->fn->ofs >= tn->fn->ofs &&\n\t\t    this->fn->ofs + this->fn->size <= fn_end) {\n\t\t\t/* New node entirely overlaps 'this' */\n\t\t\tif (check_tn_node(c, tn)) {\n\t\t\t\tdbg_readinode(\"new node bad CRC\\n\");\n\t\t\t\tjffs2_kill_tn(c, tn);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\t/* ... and is good. Kill 'this' and any subsequent nodes which are also overlapped */\n\t\t\twhile (this && this->fn->ofs + this->fn->size <= fn_end) {\n\t\t\t\tstruct jffs2_tmp_dnode_info *next = tn_next(this);\n\t\t\t\tif (this->version < tn->version) {\n\t\t\t\t\ttn_erase(this, &rii->tn_root);\n\t\t\t\t\tdbg_readinode(\"Kill overlapped ver %d, 0x%x-0x%x\\n\",\n\t\t\t\t\t\t      this->version, this->fn->ofs,\n\t\t\t\t\t\t      this->fn->ofs+this->fn->size);\n\t\t\t\t\tjffs2_kill_tn(c, this);\n\t\t\t\t}\n\t\t\t\tthis = next;\n\t\t\t}\n\t\t\tdbg_readinode(\"Done killing overlapped nodes\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\tif (this->version > tn->version &&\n\t\t    this->fn->ofs <= tn->fn->ofs &&\n\t\t    this->fn->ofs+this->fn->size >= fn_end) {\n\t\t\t/* New node entirely overlapped by 'this' */\n\t\t\tif (!check_tn_node(c, this)) {\n\t\t\t\tdbg_readinode(\"Good CRC on old node. Kill new\\n\");\n\t\t\t\tjffs2_kill_tn(c, tn);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\t/* ... but 'this' was bad. Replace it... */\n\t\t\tdbg_readinode(\"Bad CRC on old overlapping node. Kill it\\n\");\n\t\t\ttn_erase(this, &rii->tn_root);\n\t\t\tjffs2_kill_tn(c, this);\n\t\t\tbreak;\n\t\t}\n\n\t\tthis = tn_next(this);\n\t}\n\n\t/* We neither completely obsoleted nor were completely\n\t   obsoleted by an earlier node. Insert into the tree */\n\t{\n\t\tstruct rb_node *parent;\n\t\tstruct rb_node **link = &rii->tn_root.rb_node;\n\t\tstruct jffs2_tmp_dnode_info *insert_point = NULL;\n\n\t\twhile (*link) {\n\t\t\tparent = *link;\n\t\t\tinsert_point = rb_entry(parent, struct jffs2_tmp_dnode_info, rb);\n\t\t\tif (tn->fn->ofs > insert_point->fn->ofs)\n\t\t\t\tlink = &insert_point->rb.rb_right;\n\t\t\telse if (tn->fn->ofs < insert_point->fn->ofs ||\n\t\t\t\t tn->fn->size < insert_point->fn->size)\n\t\t\t\tlink = &insert_point->rb.rb_left;\n\t\t\telse\n\t\t\t\tlink = &insert_point->rb.rb_right;\n\t\t}\n\t\trb_link_node(&tn->rb, &insert_point->rb, link);\n\t\trb_insert_color(&tn->rb, &rii->tn_root);\n\t}\n\n\t/* If there's anything behind that overlaps us, note it */\n\tthis = tn_prev(tn);\n\tif (this) {\n\t\twhile (1) {\n\t\t\tif (this->fn->ofs + this->fn->size > tn->fn->ofs) {\n\t\t\t\tdbg_readinode(\"Node is overlapped by %p (v %d, 0x%x-0x%x)\\n\",\n\t\t\t\t\t      this, this->version, this->fn->ofs,\n\t\t\t\t\t      this->fn->ofs+this->fn->size);\n\t\t\t\ttn->overlapped = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!this->overlapped)\n\t\t\t\tbreak;\n\n\t\t\tptn = tn_prev(this);\n\t\t\tif (!ptn) {\n\t\t\t\t/*\n\t\t\t\t * We killed a node which set the overlapped\n\t\t\t\t * flags during the scan. Fix it up.\n\t\t\t\t */\n\t\t\t\tthis->overlapped = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tthis = ptn;\n\t\t}\n\t}\n\n\t/* If the new node overlaps anything ahead, note it */\n\tthis = tn_next(tn);\n\twhile (this && this->fn->ofs < fn_end) {\n\t\tthis->overlapped = 1;\n\t\tdbg_readinode(\"Node ver %d, 0x%x-0x%x is overlapped\\n\",\n\t\t\t      this->version, this->fn->ofs,\n\t\t\t      this->fn->ofs+this->fn->size);\n\t\tthis = tn_next(this);\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "ffs2_kill_tn(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/readinode.c",
    "lines": "199-204",
    "snippet": "tatic void jffs2_kill_tn(struct jffs2_sb_info *c, struct jffs2_tmp_dnode_info *tn)\n{\n\tjffs2_mark_node_obsolete(c, tn->fn->raw);\n\tjffs2_free_full_dnode(tn->fn);\n\tjffs2_free_tmp_dnode_info(tn);\n}",
    "includes": [
      "include \"nodelist.h\"",
      "include <linux/compiler.h>\n#",
      "include <linux/mtd/mtd.h>\n#",
      "include <linux/pagemap.h>\n#",
      "include <linux/crc32.h>\n#",
      "include <linux/fs.h>\n#",
      "include <linux/slab.h>\n#",
      "include <linux/sched.h>\n#",
      "include <linux/kernel.h>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ffs2_free_tmp_dnode_info(",
          "args": [
            "n)"
          ],
          "line": 203
        },
        "resolved": true,
        "details": {
          "function_name": "ffs2_free_tmp_dnode_info(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/malloc.c",
          "lines": "187-191",
          "snippet": "oid jffs2_free_tmp_dnode_info(struct jffs2_tmp_dnode_info *x)\n{\n\tdbg_memalloc(\"%p\\n\", x);\n\tkmem_cache_free(tmp_dnode_info_slab, x);\n}",
          "includes": [
            "include \"nodelist.h\"",
            "include <linux/jffs2.h>\n#",
            "include <linux/init.h>\n#",
            "include <linux/slab.h>\n#",
            "include <linux/kernel.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [
            "tatic struct kmem_cache *tmp_dnode_info_slab;"
          ],
          "called_functions": [],
          "contextual_snippet": "include \"nodelist.h\"\ninclude <linux/jffs2.h>\n#\ninclude <linux/init.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/kernel.h>\n#\n\ntatic struct kmem_cache *tmp_dnode_info_slab;\n\noid jffs2_free_tmp_dnode_info(struct jffs2_tmp_dnode_info *x)\n{\n\tdbg_memalloc(\"%p\\n\", x);\n\tkmem_cache_free(tmp_dnode_info_slab, x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ffs2_free_full_dnode(",
          "args": [
            "n->fn)"
          ],
          "line": 202
        },
        "resolved": true,
        "details": {
          "function_name": "ffs2_free_full_dnode(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/malloc.c",
          "lines": "144-148",
          "snippet": "oid jffs2_free_full_dnode(struct jffs2_full_dnode *x)\n{\n\tdbg_memalloc(\"%p\\n\", x);\n\tkmem_cache_free(full_dnode_slab, x);\n}",
          "includes": [
            "include \"nodelist.h\"",
            "include <linux/jffs2.h>\n#",
            "include <linux/init.h>\n#",
            "include <linux/slab.h>\n#",
            "include <linux/kernel.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [
            "tatic struct kmem_cache *full_dnode_slab;"
          ],
          "called_functions": [],
          "contextual_snippet": "include \"nodelist.h\"\ninclude <linux/jffs2.h>\n#\ninclude <linux/init.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/kernel.h>\n#\n\ntatic struct kmem_cache *full_dnode_slab;\n\noid jffs2_free_full_dnode(struct jffs2_full_dnode *x)\n{\n\tdbg_memalloc(\"%p\\n\", x);\n\tkmem_cache_free(full_dnode_slab, x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ffs2_mark_node_obsolete(",
          "args": [
            ",",
            "n->fn->raw)"
          ],
          "line": 201
        },
        "resolved": true,
        "details": {
          "function_name": "ffs2_mark_node_obsolete(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/nodemgmt.c",
          "lines": "579-835",
          "snippet": "oid jffs2_mark_node_obsolete(struct jffs2_sb_info *c, struct jffs2_raw_node_ref *ref)\n{\n\tstruct jffs2_eraseblock *jeb;\n\tint blocknr;\n\tstruct jffs2_unknown_node n;\n\tint ret, addedsize;\n\tsize_t retlen;\n\tuint32_t freed_len;\n\n\tif(unlikely(!ref)) {\n\t\tpr_notice(\"EEEEEK. jffs2_mark_node_obsolete called with NULL node\\n\");\n\t\treturn;\n\t}\n\tif (ref_obsolete(ref)) {\n\t\tjffs2_dbg(1, \"%s(): called with already obsolete node at 0x%08x\\n\",\n\t\t\t  __func__, ref_offset(ref));\n\t\treturn;\n\t}\n\tblocknr = ref->flash_offset / c->sector_size;\n\tif (blocknr >= c->nr_blocks) {\n\t\tpr_notice(\"raw node at 0x%08x is off the end of device!\\n\",\n\t\t\t  ref->flash_offset);\n\t\tBUG();\n\t}\n\tjeb = &c->blocks[blocknr];\n\n\tif (jffs2_can_mark_obsolete(c) && !jffs2_is_readonly(c) &&\n\t    !(c->flags & (JFFS2_SB_FLAG_SCANNING | JFFS2_SB_FLAG_BUILDING))) {\n\t\t/* Hm. This may confuse static lock analysis. If any of the above\n\t\t   three conditions is false, we're going to return from this\n\t\t   function without actually obliterating any nodes or freeing\n\t\t   any jffs2_raw_node_refs. So we don't need to stop erases from\n\t\t   happening, or protect against people holding an obsolete\n\t\t   jffs2_raw_node_ref without the erase_completion_lock. */\n\t\tmutex_lock(&c->erase_free_sem);\n\t}\n\n\tspin_lock(&c->erase_completion_lock);\n\n\tfreed_len = ref_totlen(c, jeb, ref);\n\n\tif (ref_flags(ref) == REF_UNCHECKED) {\n\t\tD1(if (unlikely(jeb->unchecked_size < freed_len)) {\n\t\t\t\tpr_notice(\"raw unchecked node of size 0x%08x freed from erase block %d at 0x%08x, but unchecked_size was already 0x%08x\\n\",\n\t\t\t\t\t  freed_len, blocknr,\n\t\t\t\t\t  ref->flash_offset, jeb->used_size);\n\t\t\tBUG();\n\t\t})\n\t\t\tjffs2_dbg(1, \"Obsoleting previously unchecked node at 0x%08x of len %x\\n\",\n\t\t\t\t  ref_offset(ref), freed_len);\n\t\tjeb->unchecked_size -= freed_len;\n\t\tc->unchecked_size -= freed_len;\n\t} else {\n\t\tD1(if (unlikely(jeb->used_size < freed_len)) {\n\t\t\t\tpr_notice(\"raw node of size 0x%08x freed from erase block %d at 0x%08x, but used_size was already 0x%08x\\n\",\n\t\t\t\t\t  freed_len, blocknr,\n\t\t\t\t\t  ref->flash_offset, jeb->used_size);\n\t\t\tBUG();\n\t\t})\n\t\t\tjffs2_dbg(1, \"Obsoleting node at 0x%08x of len %#x: \",\n\t\t\t\t  ref_offset(ref), freed_len);\n\t\tjeb->used_size -= freed_len;\n\t\tc->used_size -= freed_len;\n\t}\n\n\t// Take care, that wasted size is taken into concern\n\tif ((jeb->dirty_size || ISDIRTY(jeb->wasted_size + freed_len)) && jeb != c->nextblock) {\n\t\tjffs2_dbg(1, \"Dirtying\\n\");\n\t\taddedsize = freed_len;\n\t\tjeb->dirty_size += freed_len;\n\t\tc->dirty_size += freed_len;\n\n\t\t/* Convert wasted space to dirty, if not a bad block */\n\t\tif (jeb->wasted_size) {\n\t\t\tif (on_list(&jeb->list, &c->bad_used_list)) {\n\t\t\t\tjffs2_dbg(1, \"Leaving block at %08x on the bad_used_list\\n\",\n\t\t\t\t\t  jeb->offset);\n\t\t\t\taddedsize = 0; /* To fool the refiling code later */\n\t\t\t} else {\n\t\t\t\tjffs2_dbg(1, \"Converting %d bytes of wasted space to dirty in block at %08x\\n\",\n\t\t\t\t\t  jeb->wasted_size, jeb->offset);\n\t\t\t\taddedsize += jeb->wasted_size;\n\t\t\t\tjeb->dirty_size += jeb->wasted_size;\n\t\t\t\tc->dirty_size += jeb->wasted_size;\n\t\t\t\tc->wasted_size -= jeb->wasted_size;\n\t\t\t\tjeb->wasted_size = 0;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tjffs2_dbg(1, \"Wasting\\n\");\n\t\taddedsize = 0;\n\t\tjeb->wasted_size += freed_len;\n\t\tc->wasted_size += freed_len;\n\t}\n\tref->flash_offset = ref_offset(ref) | REF_OBSOLETE;\n\n\tjffs2_dbg_acct_sanity_check_nolock(c, jeb);\n\tjffs2_dbg_acct_paranoia_check_nolock(c, jeb);\n\n\tif (c->flags & JFFS2_SB_FLAG_SCANNING) {\n\t\t/* Flash scanning is in progress. Don't muck about with the block\n\t\t   lists because they're not ready yet, and don't actually\n\t\t   obliterate nodes that look obsolete. If they weren't\n\t\t   marked obsolete on the flash at the time they _became_\n\t\t   obsolete, there was probably a reason for that. */\n\t\tspin_unlock(&c->erase_completion_lock);\n\t\t/* We didn't lock the erase_free_sem */\n\t\treturn;\n\t}\n\n\tif (jeb == c->nextblock) {\n\t\tjffs2_dbg(2, \"Not moving nextblock 0x%08x to dirty/erase_pending list\\n\",\n\t\t\t  jeb->offset);\n\t} else if (!jeb->used_size && !jeb->unchecked_size) {\n\t\tif (jeb == c->gcblock) {\n\t\t\tjffs2_dbg(1, \"gcblock at 0x%08x completely dirtied. Clearing gcblock...\\n\",\n\t\t\t\t  jeb->offset);\n\t\t\tc->gcblock = NULL;\n\t\t} else {\n\t\t\tjffs2_dbg(1, \"Eraseblock at 0x%08x completely dirtied. Removing from (dirty?) list...\\n\",\n\t\t\t\t  jeb->offset);\n\t\t\tlist_del(&jeb->list);\n\t\t}\n\t\tif (jffs2_wbuf_dirty(c)) {\n\t\t\tjffs2_dbg(1, \"...and adding to erasable_pending_wbuf_list\\n\");\n\t\t\tlist_add_tail(&jeb->list, &c->erasable_pending_wbuf_list);\n\t\t} else {\n\t\t\tif (jiffies & 127) {\n\t\t\t\t/* Most of the time, we just erase it immediately. Otherwise we\n\t\t\t\t   spend ages scanning it on mount, etc. */\n\t\t\t\tjffs2_dbg(1, \"...and adding to erase_pending_list\\n\");\n\t\t\t\tlist_add_tail(&jeb->list, &c->erase_pending_list);\n\t\t\t\tc->nr_erasing_blocks++;\n\t\t\t\tjffs2_garbage_collect_trigger(c);\n\t\t\t} else {\n\t\t\t\t/* Sometimes, however, we leave it elsewhere so it doesn't get\n\t\t\t\t   immediately reused, and we spread the load a bit. */\n\t\t\t\tjffs2_dbg(1, \"...and adding to erasable_list\\n\");\n\t\t\t\tlist_add_tail(&jeb->list, &c->erasable_list);\n\t\t\t}\n\t\t}\n\t\tjffs2_dbg(1, \"Done OK\\n\");\n\t} else if (jeb == c->gcblock) {\n\t\tjffs2_dbg(2, \"Not moving gcblock 0x%08x to dirty_list\\n\",\n\t\t\t  jeb->offset);\n\t} else if (ISDIRTY(jeb->dirty_size) && !ISDIRTY(jeb->dirty_size - addedsize)) {\n\t\tjffs2_dbg(1, \"Eraseblock at 0x%08x is freshly dirtied. Removing from clean list...\\n\",\n\t\t\t  jeb->offset);\n\t\tlist_del(&jeb->list);\n\t\tjffs2_dbg(1, \"...and adding to dirty_list\\n\");\n\t\tlist_add_tail(&jeb->list, &c->dirty_list);\n\t} else if (VERYDIRTY(c, jeb->dirty_size) &&\n\t\t   !VERYDIRTY(c, jeb->dirty_size - addedsize)) {\n\t\tjffs2_dbg(1, \"Eraseblock at 0x%08x is now very dirty. Removing from dirty list...\\n\",\n\t\t\t  jeb->offset);\n\t\tlist_del(&jeb->list);\n\t\tjffs2_dbg(1, \"...and adding to very_dirty_list\\n\");\n\t\tlist_add_tail(&jeb->list, &c->very_dirty_list);\n\t} else {\n\t\tjffs2_dbg(1, \"Eraseblock at 0x%08x not moved anywhere. (free 0x%08x, dirty 0x%08x, used 0x%08x)\\n\",\n\t\t\t  jeb->offset, jeb->free_size, jeb->dirty_size,\n\t\t\t  jeb->used_size);\n\t}\n\n\tspin_unlock(&c->erase_completion_lock);\n\n\tif (!jffs2_can_mark_obsolete(c) || jffs2_is_readonly(c) ||\n\t\t(c->flags & JFFS2_SB_FLAG_BUILDING)) {\n\t\t/* We didn't lock the erase_free_sem */\n\t\treturn;\n\t}\n\n\t/* The erase_free_sem is locked, and has been since before we marked the node obsolete\n\t   and potentially put its eraseblock onto the erase_pending_list. Thus, we know that\n\t   the block hasn't _already_ been erased, and that 'ref' itself hasn't been freed yet\n\t   by jffs2_free_jeb_node_refs() in erase.c. Which is nice. */\n\n\tjffs2_dbg(1, \"obliterating obsoleted node at 0x%08x\\n\",\n\t\t  ref_offset(ref));\n\tret = jffs2_flash_read(c, ref_offset(ref), sizeof(n), &retlen, (char *)&n);\n\tif (ret) {\n\t\tpr_warn(\"Read error reading from obsoleted node at 0x%08x: %d\\n\",\n\t\t\tref_offset(ref), ret);\n\t\tgoto out_erase_sem;\n\t}\n\tif (retlen != sizeof(n)) {\n\t\tpr_warn(\"Short read from obsoleted node at 0x%08x: %zd\\n\",\n\t\t\tref_offset(ref), retlen);\n\t\tgoto out_erase_sem;\n\t}\n\tif (PAD(je32_to_cpu(n.totlen)) != PAD(freed_len)) {\n\t\tpr_warn(\"Node totlen on flash (0x%08x) != totlen from node ref (0x%08x)\\n\",\n\t\t\tje32_to_cpu(n.totlen), freed_len);\n\t\tgoto out_erase_sem;\n\t}\n\tif (!(je16_to_cpu(n.nodetype) & JFFS2_NODE_ACCURATE)) {\n\t\tjffs2_dbg(1, \"Node at 0x%08x was already marked obsolete (nodetype 0x%04x)\\n\",\n\t\t\t  ref_offset(ref), je16_to_cpu(n.nodetype));\n\t\tgoto out_erase_sem;\n\t}\n\t/* XXX FIXME: This is ugly now */\n\tn.nodetype = cpu_to_je16(je16_to_cpu(n.nodetype) & ~JFFS2_NODE_ACCURATE);\n\tret = jffs2_flash_write(c, ref_offset(ref), sizeof(n), &retlen, (char *)&n);\n\tif (ret) {\n\t\tpr_warn(\"Write error in obliterating obsoleted node at 0x%08x: %d\\n\",\n\t\t\tref_offset(ref), ret);\n\t\tgoto out_erase_sem;\n\t}\n\tif (retlen != sizeof(n)) {\n\t\tpr_warn(\"Short write in obliterating obsoleted node at 0x%08x: %zd\\n\",\n\t\t\tref_offset(ref), retlen);\n\t\tgoto out_erase_sem;\n\t}\n\n\t/* Nodes which have been marked obsolete no longer need to be\n\t   associated with any inode. Remove them from the per-inode list.\n\n\t   Note we can't do this for NAND at the moment because we need\n\t   obsolete dirent nodes to stay on the lists, because of the\n\t   horridness in jffs2_garbage_collect_deletion_dirent(). Also\n\t   because we delete the inocache, and on NAND we need that to\n\t   stay around until all the nodes are actually erased, in order\n\t   to stop us from giving the same inode number to another newly\n\t   created inode. */\n\tif (ref->next_in_ino) {\n\t\tstruct jffs2_inode_cache *ic;\n\t\tstruct jffs2_raw_node_ref **p;\n\n\t\tspin_lock(&c->erase_completion_lock);\n\n\t\tic = jffs2_raw_ref_to_ic(ref);\n\t\tfor (p = &ic->nodes; (*p) != ref; p = &((*p)->next_in_ino))\n\t\t\t;\n\n\t\t*p = ref->next_in_ino;\n\t\tref->next_in_ino = NULL;\n\n\t\tswitch (ic->class) {\n#ifdef CONFIG_JFFS2_FS_XATTR\n\t\t\tcase RAWNODE_CLASS_XATTR_DATUM:\n\t\t\t\tjffs2_release_xattr_datum(c, (struct jffs2_xattr_datum *)ic);\n\t\t\t\tbreak;\n\t\t\tcase RAWNODE_CLASS_XATTR_REF:\n\t\t\t\tjffs2_release_xattr_ref(c, (struct jffs2_xattr_ref *)ic);\n\t\t\t\tbreak;\n#endif\n\t\t\tdefault:\n\t\t\t\tif (ic->nodes == (void *)ic && ic->pino_nlink == 0)\n\t\t\t\t\tjffs2_del_ino_cache(c, ic);\n\t\t\t\tbreak;\n\t\t}\n\t\tspin_unlock(&c->erase_completion_lock);\n\t}\n\n out_erase_sem:\n\tmutex_unlock(&c->erase_free_sem);\n}",
          "includes": [
            "include \"debug.h\"",
            "include \"nodelist.h\"\n#",
            "include <linux/sched.h> /* For cond_resched() */\n#",
            "include <linux/compiler.h>\n#",
            "include <linux/mtd/mtd.h>\n#",
            "include <linux/kernel.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"debug.h\"\ninclude \"nodelist.h\"\n#\ninclude <linux/sched.h> /* For cond_resched() */\n#\ninclude <linux/compiler.h>\n#\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/kernel.h>\n#\n\noid jffs2_mark_node_obsolete(struct jffs2_sb_info *c, struct jffs2_raw_node_ref *ref)\n{\n\tstruct jffs2_eraseblock *jeb;\n\tint blocknr;\n\tstruct jffs2_unknown_node n;\n\tint ret, addedsize;\n\tsize_t retlen;\n\tuint32_t freed_len;\n\n\tif(unlikely(!ref)) {\n\t\tpr_notice(\"EEEEEK. jffs2_mark_node_obsolete called with NULL node\\n\");\n\t\treturn;\n\t}\n\tif (ref_obsolete(ref)) {\n\t\tjffs2_dbg(1, \"%s(): called with already obsolete node at 0x%08x\\n\",\n\t\t\t  __func__, ref_offset(ref));\n\t\treturn;\n\t}\n\tblocknr = ref->flash_offset / c->sector_size;\n\tif (blocknr >= c->nr_blocks) {\n\t\tpr_notice(\"raw node at 0x%08x is off the end of device!\\n\",\n\t\t\t  ref->flash_offset);\n\t\tBUG();\n\t}\n\tjeb = &c->blocks[blocknr];\n\n\tif (jffs2_can_mark_obsolete(c) && !jffs2_is_readonly(c) &&\n\t    !(c->flags & (JFFS2_SB_FLAG_SCANNING | JFFS2_SB_FLAG_BUILDING))) {\n\t\t/* Hm. This may confuse static lock analysis. If any of the above\n\t\t   three conditions is false, we're going to return from this\n\t\t   function without actually obliterating any nodes or freeing\n\t\t   any jffs2_raw_node_refs. So we don't need to stop erases from\n\t\t   happening, or protect against people holding an obsolete\n\t\t   jffs2_raw_node_ref without the erase_completion_lock. */\n\t\tmutex_lock(&c->erase_free_sem);\n\t}\n\n\tspin_lock(&c->erase_completion_lock);\n\n\tfreed_len = ref_totlen(c, jeb, ref);\n\n\tif (ref_flags(ref) == REF_UNCHECKED) {\n\t\tD1(if (unlikely(jeb->unchecked_size < freed_len)) {\n\t\t\t\tpr_notice(\"raw unchecked node of size 0x%08x freed from erase block %d at 0x%08x, but unchecked_size was already 0x%08x\\n\",\n\t\t\t\t\t  freed_len, blocknr,\n\t\t\t\t\t  ref->flash_offset, jeb->used_size);\n\t\t\tBUG();\n\t\t})\n\t\t\tjffs2_dbg(1, \"Obsoleting previously unchecked node at 0x%08x of len %x\\n\",\n\t\t\t\t  ref_offset(ref), freed_len);\n\t\tjeb->unchecked_size -= freed_len;\n\t\tc->unchecked_size -= freed_len;\n\t} else {\n\t\tD1(if (unlikely(jeb->used_size < freed_len)) {\n\t\t\t\tpr_notice(\"raw node of size 0x%08x freed from erase block %d at 0x%08x, but used_size was already 0x%08x\\n\",\n\t\t\t\t\t  freed_len, blocknr,\n\t\t\t\t\t  ref->flash_offset, jeb->used_size);\n\t\t\tBUG();\n\t\t})\n\t\t\tjffs2_dbg(1, \"Obsoleting node at 0x%08x of len %#x: \",\n\t\t\t\t  ref_offset(ref), freed_len);\n\t\tjeb->used_size -= freed_len;\n\t\tc->used_size -= freed_len;\n\t}\n\n\t// Take care, that wasted size is taken into concern\n\tif ((jeb->dirty_size || ISDIRTY(jeb->wasted_size + freed_len)) && jeb != c->nextblock) {\n\t\tjffs2_dbg(1, \"Dirtying\\n\");\n\t\taddedsize = freed_len;\n\t\tjeb->dirty_size += freed_len;\n\t\tc->dirty_size += freed_len;\n\n\t\t/* Convert wasted space to dirty, if not a bad block */\n\t\tif (jeb->wasted_size) {\n\t\t\tif (on_list(&jeb->list, &c->bad_used_list)) {\n\t\t\t\tjffs2_dbg(1, \"Leaving block at %08x on the bad_used_list\\n\",\n\t\t\t\t\t  jeb->offset);\n\t\t\t\taddedsize = 0; /* To fool the refiling code later */\n\t\t\t} else {\n\t\t\t\tjffs2_dbg(1, \"Converting %d bytes of wasted space to dirty in block at %08x\\n\",\n\t\t\t\t\t  jeb->wasted_size, jeb->offset);\n\t\t\t\taddedsize += jeb->wasted_size;\n\t\t\t\tjeb->dirty_size += jeb->wasted_size;\n\t\t\t\tc->dirty_size += jeb->wasted_size;\n\t\t\t\tc->wasted_size -= jeb->wasted_size;\n\t\t\t\tjeb->wasted_size = 0;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tjffs2_dbg(1, \"Wasting\\n\");\n\t\taddedsize = 0;\n\t\tjeb->wasted_size += freed_len;\n\t\tc->wasted_size += freed_len;\n\t}\n\tref->flash_offset = ref_offset(ref) | REF_OBSOLETE;\n\n\tjffs2_dbg_acct_sanity_check_nolock(c, jeb);\n\tjffs2_dbg_acct_paranoia_check_nolock(c, jeb);\n\n\tif (c->flags & JFFS2_SB_FLAG_SCANNING) {\n\t\t/* Flash scanning is in progress. Don't muck about with the block\n\t\t   lists because they're not ready yet, and don't actually\n\t\t   obliterate nodes that look obsolete. If they weren't\n\t\t   marked obsolete on the flash at the time they _became_\n\t\t   obsolete, there was probably a reason for that. */\n\t\tspin_unlock(&c->erase_completion_lock);\n\t\t/* We didn't lock the erase_free_sem */\n\t\treturn;\n\t}\n\n\tif (jeb == c->nextblock) {\n\t\tjffs2_dbg(2, \"Not moving nextblock 0x%08x to dirty/erase_pending list\\n\",\n\t\t\t  jeb->offset);\n\t} else if (!jeb->used_size && !jeb->unchecked_size) {\n\t\tif (jeb == c->gcblock) {\n\t\t\tjffs2_dbg(1, \"gcblock at 0x%08x completely dirtied. Clearing gcblock...\\n\",\n\t\t\t\t  jeb->offset);\n\t\t\tc->gcblock = NULL;\n\t\t} else {\n\t\t\tjffs2_dbg(1, \"Eraseblock at 0x%08x completely dirtied. Removing from (dirty?) list...\\n\",\n\t\t\t\t  jeb->offset);\n\t\t\tlist_del(&jeb->list);\n\t\t}\n\t\tif (jffs2_wbuf_dirty(c)) {\n\t\t\tjffs2_dbg(1, \"...and adding to erasable_pending_wbuf_list\\n\");\n\t\t\tlist_add_tail(&jeb->list, &c->erasable_pending_wbuf_list);\n\t\t} else {\n\t\t\tif (jiffies & 127) {\n\t\t\t\t/* Most of the time, we just erase it immediately. Otherwise we\n\t\t\t\t   spend ages scanning it on mount, etc. */\n\t\t\t\tjffs2_dbg(1, \"...and adding to erase_pending_list\\n\");\n\t\t\t\tlist_add_tail(&jeb->list, &c->erase_pending_list);\n\t\t\t\tc->nr_erasing_blocks++;\n\t\t\t\tjffs2_garbage_collect_trigger(c);\n\t\t\t} else {\n\t\t\t\t/* Sometimes, however, we leave it elsewhere so it doesn't get\n\t\t\t\t   immediately reused, and we spread the load a bit. */\n\t\t\t\tjffs2_dbg(1, \"...and adding to erasable_list\\n\");\n\t\t\t\tlist_add_tail(&jeb->list, &c->erasable_list);\n\t\t\t}\n\t\t}\n\t\tjffs2_dbg(1, \"Done OK\\n\");\n\t} else if (jeb == c->gcblock) {\n\t\tjffs2_dbg(2, \"Not moving gcblock 0x%08x to dirty_list\\n\",\n\t\t\t  jeb->offset);\n\t} else if (ISDIRTY(jeb->dirty_size) && !ISDIRTY(jeb->dirty_size - addedsize)) {\n\t\tjffs2_dbg(1, \"Eraseblock at 0x%08x is freshly dirtied. Removing from clean list...\\n\",\n\t\t\t  jeb->offset);\n\t\tlist_del(&jeb->list);\n\t\tjffs2_dbg(1, \"...and adding to dirty_list\\n\");\n\t\tlist_add_tail(&jeb->list, &c->dirty_list);\n\t} else if (VERYDIRTY(c, jeb->dirty_size) &&\n\t\t   !VERYDIRTY(c, jeb->dirty_size - addedsize)) {\n\t\tjffs2_dbg(1, \"Eraseblock at 0x%08x is now very dirty. Removing from dirty list...\\n\",\n\t\t\t  jeb->offset);\n\t\tlist_del(&jeb->list);\n\t\tjffs2_dbg(1, \"...and adding to very_dirty_list\\n\");\n\t\tlist_add_tail(&jeb->list, &c->very_dirty_list);\n\t} else {\n\t\tjffs2_dbg(1, \"Eraseblock at 0x%08x not moved anywhere. (free 0x%08x, dirty 0x%08x, used 0x%08x)\\n\",\n\t\t\t  jeb->offset, jeb->free_size, jeb->dirty_size,\n\t\t\t  jeb->used_size);\n\t}\n\n\tspin_unlock(&c->erase_completion_lock);\n\n\tif (!jffs2_can_mark_obsolete(c) || jffs2_is_readonly(c) ||\n\t\t(c->flags & JFFS2_SB_FLAG_BUILDING)) {\n\t\t/* We didn't lock the erase_free_sem */\n\t\treturn;\n\t}\n\n\t/* The erase_free_sem is locked, and has been since before we marked the node obsolete\n\t   and potentially put its eraseblock onto the erase_pending_list. Thus, we know that\n\t   the block hasn't _already_ been erased, and that 'ref' itself hasn't been freed yet\n\t   by jffs2_free_jeb_node_refs() in erase.c. Which is nice. */\n\n\tjffs2_dbg(1, \"obliterating obsoleted node at 0x%08x\\n\",\n\t\t  ref_offset(ref));\n\tret = jffs2_flash_read(c, ref_offset(ref), sizeof(n), &retlen, (char *)&n);\n\tif (ret) {\n\t\tpr_warn(\"Read error reading from obsoleted node at 0x%08x: %d\\n\",\n\t\t\tref_offset(ref), ret);\n\t\tgoto out_erase_sem;\n\t}\n\tif (retlen != sizeof(n)) {\n\t\tpr_warn(\"Short read from obsoleted node at 0x%08x: %zd\\n\",\n\t\t\tref_offset(ref), retlen);\n\t\tgoto out_erase_sem;\n\t}\n\tif (PAD(je32_to_cpu(n.totlen)) != PAD(freed_len)) {\n\t\tpr_warn(\"Node totlen on flash (0x%08x) != totlen from node ref (0x%08x)\\n\",\n\t\t\tje32_to_cpu(n.totlen), freed_len);\n\t\tgoto out_erase_sem;\n\t}\n\tif (!(je16_to_cpu(n.nodetype) & JFFS2_NODE_ACCURATE)) {\n\t\tjffs2_dbg(1, \"Node at 0x%08x was already marked obsolete (nodetype 0x%04x)\\n\",\n\t\t\t  ref_offset(ref), je16_to_cpu(n.nodetype));\n\t\tgoto out_erase_sem;\n\t}\n\t/* XXX FIXME: This is ugly now */\n\tn.nodetype = cpu_to_je16(je16_to_cpu(n.nodetype) & ~JFFS2_NODE_ACCURATE);\n\tret = jffs2_flash_write(c, ref_offset(ref), sizeof(n), &retlen, (char *)&n);\n\tif (ret) {\n\t\tpr_warn(\"Write error in obliterating obsoleted node at 0x%08x: %d\\n\",\n\t\t\tref_offset(ref), ret);\n\t\tgoto out_erase_sem;\n\t}\n\tif (retlen != sizeof(n)) {\n\t\tpr_warn(\"Short write in obliterating obsoleted node at 0x%08x: %zd\\n\",\n\t\t\tref_offset(ref), retlen);\n\t\tgoto out_erase_sem;\n\t}\n\n\t/* Nodes which have been marked obsolete no longer need to be\n\t   associated with any inode. Remove them from the per-inode list.\n\n\t   Note we can't do this for NAND at the moment because we need\n\t   obsolete dirent nodes to stay on the lists, because of the\n\t   horridness in jffs2_garbage_collect_deletion_dirent(). Also\n\t   because we delete the inocache, and on NAND we need that to\n\t   stay around until all the nodes are actually erased, in order\n\t   to stop us from giving the same inode number to another newly\n\t   created inode. */\n\tif (ref->next_in_ino) {\n\t\tstruct jffs2_inode_cache *ic;\n\t\tstruct jffs2_raw_node_ref **p;\n\n\t\tspin_lock(&c->erase_completion_lock);\n\n\t\tic = jffs2_raw_ref_to_ic(ref);\n\t\tfor (p = &ic->nodes; (*p) != ref; p = &((*p)->next_in_ino))\n\t\t\t;\n\n\t\t*p = ref->next_in_ino;\n\t\tref->next_in_ino = NULL;\n\n\t\tswitch (ic->class) {\n#ifdef CONFIG_JFFS2_FS_XATTR\n\t\t\tcase RAWNODE_CLASS_XATTR_DATUM:\n\t\t\t\tjffs2_release_xattr_datum(c, (struct jffs2_xattr_datum *)ic);\n\t\t\t\tbreak;\n\t\t\tcase RAWNODE_CLASS_XATTR_REF:\n\t\t\t\tjffs2_release_xattr_ref(c, (struct jffs2_xattr_ref *)ic);\n\t\t\t\tbreak;\n#endif\n\t\t\tdefault:\n\t\t\t\tif (ic->nodes == (void *)ic && ic->pino_nlink == 0)\n\t\t\t\t\tjffs2_del_ino_cache(c, ic);\n\t\t\t\tbreak;\n\t\t}\n\t\tspin_unlock(&c->erase_completion_lock);\n\t}\n\n out_erase_sem:\n\tmutex_unlock(&c->erase_free_sem);\n}"
        }
      }
    ],
    "contextual_snippet": "include \"nodelist.h\"\ninclude <linux/compiler.h>\n#\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/pagemap.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/fs.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/sched.h>\n#\ninclude <linux/kernel.h>\n#\n\ntatic void jffs2_kill_tn(struct jffs2_sb_info *c, struct jffs2_tmp_dnode_info *tn)\n{\n\tjffs2_mark_node_obsolete(c, tn->fn->raw);\n\tjffs2_free_full_dnode(tn->fn);\n\tjffs2_free_tmp_dnode_info(tn);\n}"
  },
  {
    "function_name": "ffs2_lookup_tn(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/readinode.c",
    "lines": "175-196",
    "snippet": "tatic struct jffs2_tmp_dnode_info *jffs2_lookup_tn(struct rb_root *tn_root, uint32_t offset)\n{\n\tstruct rb_node *next;\n\tstruct jffs2_tmp_dnode_info *tn = NULL;\n\n\tdbg_readinode(\"root %p, offset %d\\n\", tn_root, offset);\n\n\tnext = tn_root->rb_node;\n\n\twhile (next) {\n\t\ttn = rb_entry(next, struct jffs2_tmp_dnode_info, rb);\n\n\t\tif (tn->fn->ofs < offset)\n\t\t\tnext = tn->rb.rb_right;\n\t\telse if (tn->fn->ofs >= offset)\n\t\t\tnext = tn->rb.rb_left;\n\t\telse\n\t\t\tbreak;\n\t}\n\n\treturn tn;\n}",
    "includes": [
      "include \"nodelist.h\"",
      "include <linux/compiler.h>\n#",
      "include <linux/mtd/mtd.h>\n#",
      "include <linux/pagemap.h>\n#",
      "include <linux/crc32.h>\n#",
      "include <linux/fs.h>\n#",
      "include <linux/slab.h>\n#",
      "include <linux/sched.h>\n#",
      "include <linux/kernel.h>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "b_entry(",
          "args": [
            "ext,",
            "truct ffs2_tmp_dnode_info,",
            "b)"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bg_readinode(",
          "args": [
            "root %p, offset %d\\n\",",
            "n_root,",
            "ffset)"
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"nodelist.h\"\ninclude <linux/compiler.h>\n#\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/pagemap.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/fs.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/sched.h>\n#\ninclude <linux/kernel.h>\n#\n\ntatic struct jffs2_tmp_dnode_info *jffs2_lookup_tn(struct rb_root *tn_root, uint32_t offset)\n{\n\tstruct rb_node *next;\n\tstruct jffs2_tmp_dnode_info *tn = NULL;\n\n\tdbg_readinode(\"root %p, offset %d\\n\", tn_root, offset);\n\n\tnext = tn_root->rb_node;\n\n\twhile (next) {\n\t\ttn = rb_entry(next, struct jffs2_tmp_dnode_info, rb);\n\n\t\tif (tn->fn->ofs < offset)\n\t\t\tnext = tn->rb.rb_right;\n\t\telse if (tn->fn->ofs >= offset)\n\t\t\tnext = tn->rb.rb_left;\n\t\telse\n\t\t\tbreak;\n\t}\n\n\treturn tn;\n}"
  },
  {
    "function_name": "heck_tn_node(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/readinode.c",
    "lines": "150-173",
    "snippet": "tatic int check_tn_node(struct jffs2_sb_info *c, struct jffs2_tmp_dnode_info *tn)\n{\n\tint ret;\n\n\tBUG_ON(ref_obsolete(tn->fn->raw));\n\n\t/* We only check the data CRC of unchecked nodes */\n\tif (ref_flags(tn->fn->raw) != REF_UNCHECKED)\n\t\treturn 0;\n\n\tdbg_readinode(\"check node %#04x-%#04x, phys offs %#08x\\n\",\n\t\t      tn->fn->ofs, tn->fn->ofs + tn->fn->size, ref_offset(tn->fn->raw));\n\n\tret = check_node_data(c, tn);\n\tif (unlikely(ret < 0)) {\n\t\tJFFS2_ERROR(\"check_node_data() returned error: %d.\\n\",\n\t\t\tret);\n\t} else if (unlikely(ret > 0)) {\n\t\tdbg_readinode(\"CRC error, mark it obsolete.\\n\");\n\t\tjffs2_mark_node_obsolete(c, tn->fn->raw);\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "include \"nodelist.h\"",
      "include <linux/compiler.h>\n#",
      "include <linux/mtd/mtd.h>\n#",
      "include <linux/pagemap.h>\n#",
      "include <linux/crc32.h>\n#",
      "include <linux/fs.h>\n#",
      "include <linux/slab.h>\n#",
      "include <linux/sched.h>\n#",
      "include <linux/kernel.h>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ffs2_mark_node_obsolete(",
          "args": [
            ",",
            "n->fn->raw)"
          ],
          "line": 169
        },
        "resolved": true,
        "details": {
          "function_name": "ffs2_mark_node_obsolete(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/nodemgmt.c",
          "lines": "579-835",
          "snippet": "oid jffs2_mark_node_obsolete(struct jffs2_sb_info *c, struct jffs2_raw_node_ref *ref)\n{\n\tstruct jffs2_eraseblock *jeb;\n\tint blocknr;\n\tstruct jffs2_unknown_node n;\n\tint ret, addedsize;\n\tsize_t retlen;\n\tuint32_t freed_len;\n\n\tif(unlikely(!ref)) {\n\t\tpr_notice(\"EEEEEK. jffs2_mark_node_obsolete called with NULL node\\n\");\n\t\treturn;\n\t}\n\tif (ref_obsolete(ref)) {\n\t\tjffs2_dbg(1, \"%s(): called with already obsolete node at 0x%08x\\n\",\n\t\t\t  __func__, ref_offset(ref));\n\t\treturn;\n\t}\n\tblocknr = ref->flash_offset / c->sector_size;\n\tif (blocknr >= c->nr_blocks) {\n\t\tpr_notice(\"raw node at 0x%08x is off the end of device!\\n\",\n\t\t\t  ref->flash_offset);\n\t\tBUG();\n\t}\n\tjeb = &c->blocks[blocknr];\n\n\tif (jffs2_can_mark_obsolete(c) && !jffs2_is_readonly(c) &&\n\t    !(c->flags & (JFFS2_SB_FLAG_SCANNING | JFFS2_SB_FLAG_BUILDING))) {\n\t\t/* Hm. This may confuse static lock analysis. If any of the above\n\t\t   three conditions is false, we're going to return from this\n\t\t   function without actually obliterating any nodes or freeing\n\t\t   any jffs2_raw_node_refs. So we don't need to stop erases from\n\t\t   happening, or protect against people holding an obsolete\n\t\t   jffs2_raw_node_ref without the erase_completion_lock. */\n\t\tmutex_lock(&c->erase_free_sem);\n\t}\n\n\tspin_lock(&c->erase_completion_lock);\n\n\tfreed_len = ref_totlen(c, jeb, ref);\n\n\tif (ref_flags(ref) == REF_UNCHECKED) {\n\t\tD1(if (unlikely(jeb->unchecked_size < freed_len)) {\n\t\t\t\tpr_notice(\"raw unchecked node of size 0x%08x freed from erase block %d at 0x%08x, but unchecked_size was already 0x%08x\\n\",\n\t\t\t\t\t  freed_len, blocknr,\n\t\t\t\t\t  ref->flash_offset, jeb->used_size);\n\t\t\tBUG();\n\t\t})\n\t\t\tjffs2_dbg(1, \"Obsoleting previously unchecked node at 0x%08x of len %x\\n\",\n\t\t\t\t  ref_offset(ref), freed_len);\n\t\tjeb->unchecked_size -= freed_len;\n\t\tc->unchecked_size -= freed_len;\n\t} else {\n\t\tD1(if (unlikely(jeb->used_size < freed_len)) {\n\t\t\t\tpr_notice(\"raw node of size 0x%08x freed from erase block %d at 0x%08x, but used_size was already 0x%08x\\n\",\n\t\t\t\t\t  freed_len, blocknr,\n\t\t\t\t\t  ref->flash_offset, jeb->used_size);\n\t\t\tBUG();\n\t\t})\n\t\t\tjffs2_dbg(1, \"Obsoleting node at 0x%08x of len %#x: \",\n\t\t\t\t  ref_offset(ref), freed_len);\n\t\tjeb->used_size -= freed_len;\n\t\tc->used_size -= freed_len;\n\t}\n\n\t// Take care, that wasted size is taken into concern\n\tif ((jeb->dirty_size || ISDIRTY(jeb->wasted_size + freed_len)) && jeb != c->nextblock) {\n\t\tjffs2_dbg(1, \"Dirtying\\n\");\n\t\taddedsize = freed_len;\n\t\tjeb->dirty_size += freed_len;\n\t\tc->dirty_size += freed_len;\n\n\t\t/* Convert wasted space to dirty, if not a bad block */\n\t\tif (jeb->wasted_size) {\n\t\t\tif (on_list(&jeb->list, &c->bad_used_list)) {\n\t\t\t\tjffs2_dbg(1, \"Leaving block at %08x on the bad_used_list\\n\",\n\t\t\t\t\t  jeb->offset);\n\t\t\t\taddedsize = 0; /* To fool the refiling code later */\n\t\t\t} else {\n\t\t\t\tjffs2_dbg(1, \"Converting %d bytes of wasted space to dirty in block at %08x\\n\",\n\t\t\t\t\t  jeb->wasted_size, jeb->offset);\n\t\t\t\taddedsize += jeb->wasted_size;\n\t\t\t\tjeb->dirty_size += jeb->wasted_size;\n\t\t\t\tc->dirty_size += jeb->wasted_size;\n\t\t\t\tc->wasted_size -= jeb->wasted_size;\n\t\t\t\tjeb->wasted_size = 0;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tjffs2_dbg(1, \"Wasting\\n\");\n\t\taddedsize = 0;\n\t\tjeb->wasted_size += freed_len;\n\t\tc->wasted_size += freed_len;\n\t}\n\tref->flash_offset = ref_offset(ref) | REF_OBSOLETE;\n\n\tjffs2_dbg_acct_sanity_check_nolock(c, jeb);\n\tjffs2_dbg_acct_paranoia_check_nolock(c, jeb);\n\n\tif (c->flags & JFFS2_SB_FLAG_SCANNING) {\n\t\t/* Flash scanning is in progress. Don't muck about with the block\n\t\t   lists because they're not ready yet, and don't actually\n\t\t   obliterate nodes that look obsolete. If they weren't\n\t\t   marked obsolete on the flash at the time they _became_\n\t\t   obsolete, there was probably a reason for that. */\n\t\tspin_unlock(&c->erase_completion_lock);\n\t\t/* We didn't lock the erase_free_sem */\n\t\treturn;\n\t}\n\n\tif (jeb == c->nextblock) {\n\t\tjffs2_dbg(2, \"Not moving nextblock 0x%08x to dirty/erase_pending list\\n\",\n\t\t\t  jeb->offset);\n\t} else if (!jeb->used_size && !jeb->unchecked_size) {\n\t\tif (jeb == c->gcblock) {\n\t\t\tjffs2_dbg(1, \"gcblock at 0x%08x completely dirtied. Clearing gcblock...\\n\",\n\t\t\t\t  jeb->offset);\n\t\t\tc->gcblock = NULL;\n\t\t} else {\n\t\t\tjffs2_dbg(1, \"Eraseblock at 0x%08x completely dirtied. Removing from (dirty?) list...\\n\",\n\t\t\t\t  jeb->offset);\n\t\t\tlist_del(&jeb->list);\n\t\t}\n\t\tif (jffs2_wbuf_dirty(c)) {\n\t\t\tjffs2_dbg(1, \"...and adding to erasable_pending_wbuf_list\\n\");\n\t\t\tlist_add_tail(&jeb->list, &c->erasable_pending_wbuf_list);\n\t\t} else {\n\t\t\tif (jiffies & 127) {\n\t\t\t\t/* Most of the time, we just erase it immediately. Otherwise we\n\t\t\t\t   spend ages scanning it on mount, etc. */\n\t\t\t\tjffs2_dbg(1, \"...and adding to erase_pending_list\\n\");\n\t\t\t\tlist_add_tail(&jeb->list, &c->erase_pending_list);\n\t\t\t\tc->nr_erasing_blocks++;\n\t\t\t\tjffs2_garbage_collect_trigger(c);\n\t\t\t} else {\n\t\t\t\t/* Sometimes, however, we leave it elsewhere so it doesn't get\n\t\t\t\t   immediately reused, and we spread the load a bit. */\n\t\t\t\tjffs2_dbg(1, \"...and adding to erasable_list\\n\");\n\t\t\t\tlist_add_tail(&jeb->list, &c->erasable_list);\n\t\t\t}\n\t\t}\n\t\tjffs2_dbg(1, \"Done OK\\n\");\n\t} else if (jeb == c->gcblock) {\n\t\tjffs2_dbg(2, \"Not moving gcblock 0x%08x to dirty_list\\n\",\n\t\t\t  jeb->offset);\n\t} else if (ISDIRTY(jeb->dirty_size) && !ISDIRTY(jeb->dirty_size - addedsize)) {\n\t\tjffs2_dbg(1, \"Eraseblock at 0x%08x is freshly dirtied. Removing from clean list...\\n\",\n\t\t\t  jeb->offset);\n\t\tlist_del(&jeb->list);\n\t\tjffs2_dbg(1, \"...and adding to dirty_list\\n\");\n\t\tlist_add_tail(&jeb->list, &c->dirty_list);\n\t} else if (VERYDIRTY(c, jeb->dirty_size) &&\n\t\t   !VERYDIRTY(c, jeb->dirty_size - addedsize)) {\n\t\tjffs2_dbg(1, \"Eraseblock at 0x%08x is now very dirty. Removing from dirty list...\\n\",\n\t\t\t  jeb->offset);\n\t\tlist_del(&jeb->list);\n\t\tjffs2_dbg(1, \"...and adding to very_dirty_list\\n\");\n\t\tlist_add_tail(&jeb->list, &c->very_dirty_list);\n\t} else {\n\t\tjffs2_dbg(1, \"Eraseblock at 0x%08x not moved anywhere. (free 0x%08x, dirty 0x%08x, used 0x%08x)\\n\",\n\t\t\t  jeb->offset, jeb->free_size, jeb->dirty_size,\n\t\t\t  jeb->used_size);\n\t}\n\n\tspin_unlock(&c->erase_completion_lock);\n\n\tif (!jffs2_can_mark_obsolete(c) || jffs2_is_readonly(c) ||\n\t\t(c->flags & JFFS2_SB_FLAG_BUILDING)) {\n\t\t/* We didn't lock the erase_free_sem */\n\t\treturn;\n\t}\n\n\t/* The erase_free_sem is locked, and has been since before we marked the node obsolete\n\t   and potentially put its eraseblock onto the erase_pending_list. Thus, we know that\n\t   the block hasn't _already_ been erased, and that 'ref' itself hasn't been freed yet\n\t   by jffs2_free_jeb_node_refs() in erase.c. Which is nice. */\n\n\tjffs2_dbg(1, \"obliterating obsoleted node at 0x%08x\\n\",\n\t\t  ref_offset(ref));\n\tret = jffs2_flash_read(c, ref_offset(ref), sizeof(n), &retlen, (char *)&n);\n\tif (ret) {\n\t\tpr_warn(\"Read error reading from obsoleted node at 0x%08x: %d\\n\",\n\t\t\tref_offset(ref), ret);\n\t\tgoto out_erase_sem;\n\t}\n\tif (retlen != sizeof(n)) {\n\t\tpr_warn(\"Short read from obsoleted node at 0x%08x: %zd\\n\",\n\t\t\tref_offset(ref), retlen);\n\t\tgoto out_erase_sem;\n\t}\n\tif (PAD(je32_to_cpu(n.totlen)) != PAD(freed_len)) {\n\t\tpr_warn(\"Node totlen on flash (0x%08x) != totlen from node ref (0x%08x)\\n\",\n\t\t\tje32_to_cpu(n.totlen), freed_len);\n\t\tgoto out_erase_sem;\n\t}\n\tif (!(je16_to_cpu(n.nodetype) & JFFS2_NODE_ACCURATE)) {\n\t\tjffs2_dbg(1, \"Node at 0x%08x was already marked obsolete (nodetype 0x%04x)\\n\",\n\t\t\t  ref_offset(ref), je16_to_cpu(n.nodetype));\n\t\tgoto out_erase_sem;\n\t}\n\t/* XXX FIXME: This is ugly now */\n\tn.nodetype = cpu_to_je16(je16_to_cpu(n.nodetype) & ~JFFS2_NODE_ACCURATE);\n\tret = jffs2_flash_write(c, ref_offset(ref), sizeof(n), &retlen, (char *)&n);\n\tif (ret) {\n\t\tpr_warn(\"Write error in obliterating obsoleted node at 0x%08x: %d\\n\",\n\t\t\tref_offset(ref), ret);\n\t\tgoto out_erase_sem;\n\t}\n\tif (retlen != sizeof(n)) {\n\t\tpr_warn(\"Short write in obliterating obsoleted node at 0x%08x: %zd\\n\",\n\t\t\tref_offset(ref), retlen);\n\t\tgoto out_erase_sem;\n\t}\n\n\t/* Nodes which have been marked obsolete no longer need to be\n\t   associated with any inode. Remove them from the per-inode list.\n\n\t   Note we can't do this for NAND at the moment because we need\n\t   obsolete dirent nodes to stay on the lists, because of the\n\t   horridness in jffs2_garbage_collect_deletion_dirent(). Also\n\t   because we delete the inocache, and on NAND we need that to\n\t   stay around until all the nodes are actually erased, in order\n\t   to stop us from giving the same inode number to another newly\n\t   created inode. */\n\tif (ref->next_in_ino) {\n\t\tstruct jffs2_inode_cache *ic;\n\t\tstruct jffs2_raw_node_ref **p;\n\n\t\tspin_lock(&c->erase_completion_lock);\n\n\t\tic = jffs2_raw_ref_to_ic(ref);\n\t\tfor (p = &ic->nodes; (*p) != ref; p = &((*p)->next_in_ino))\n\t\t\t;\n\n\t\t*p = ref->next_in_ino;\n\t\tref->next_in_ino = NULL;\n\n\t\tswitch (ic->class) {\n#ifdef CONFIG_JFFS2_FS_XATTR\n\t\t\tcase RAWNODE_CLASS_XATTR_DATUM:\n\t\t\t\tjffs2_release_xattr_datum(c, (struct jffs2_xattr_datum *)ic);\n\t\t\t\tbreak;\n\t\t\tcase RAWNODE_CLASS_XATTR_REF:\n\t\t\t\tjffs2_release_xattr_ref(c, (struct jffs2_xattr_ref *)ic);\n\t\t\t\tbreak;\n#endif\n\t\t\tdefault:\n\t\t\t\tif (ic->nodes == (void *)ic && ic->pino_nlink == 0)\n\t\t\t\t\tjffs2_del_ino_cache(c, ic);\n\t\t\t\tbreak;\n\t\t}\n\t\tspin_unlock(&c->erase_completion_lock);\n\t}\n\n out_erase_sem:\n\tmutex_unlock(&c->erase_free_sem);\n}",
          "includes": [
            "include \"debug.h\"",
            "include \"nodelist.h\"\n#",
            "include <linux/sched.h> /* For cond_resched() */\n#",
            "include <linux/compiler.h>\n#",
            "include <linux/mtd/mtd.h>\n#",
            "include <linux/kernel.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"debug.h\"\ninclude \"nodelist.h\"\n#\ninclude <linux/sched.h> /* For cond_resched() */\n#\ninclude <linux/compiler.h>\n#\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/kernel.h>\n#\n\noid jffs2_mark_node_obsolete(struct jffs2_sb_info *c, struct jffs2_raw_node_ref *ref)\n{\n\tstruct jffs2_eraseblock *jeb;\n\tint blocknr;\n\tstruct jffs2_unknown_node n;\n\tint ret, addedsize;\n\tsize_t retlen;\n\tuint32_t freed_len;\n\n\tif(unlikely(!ref)) {\n\t\tpr_notice(\"EEEEEK. jffs2_mark_node_obsolete called with NULL node\\n\");\n\t\treturn;\n\t}\n\tif (ref_obsolete(ref)) {\n\t\tjffs2_dbg(1, \"%s(): called with already obsolete node at 0x%08x\\n\",\n\t\t\t  __func__, ref_offset(ref));\n\t\treturn;\n\t}\n\tblocknr = ref->flash_offset / c->sector_size;\n\tif (blocknr >= c->nr_blocks) {\n\t\tpr_notice(\"raw node at 0x%08x is off the end of device!\\n\",\n\t\t\t  ref->flash_offset);\n\t\tBUG();\n\t}\n\tjeb = &c->blocks[blocknr];\n\n\tif (jffs2_can_mark_obsolete(c) && !jffs2_is_readonly(c) &&\n\t    !(c->flags & (JFFS2_SB_FLAG_SCANNING | JFFS2_SB_FLAG_BUILDING))) {\n\t\t/* Hm. This may confuse static lock analysis. If any of the above\n\t\t   three conditions is false, we're going to return from this\n\t\t   function without actually obliterating any nodes or freeing\n\t\t   any jffs2_raw_node_refs. So we don't need to stop erases from\n\t\t   happening, or protect against people holding an obsolete\n\t\t   jffs2_raw_node_ref without the erase_completion_lock. */\n\t\tmutex_lock(&c->erase_free_sem);\n\t}\n\n\tspin_lock(&c->erase_completion_lock);\n\n\tfreed_len = ref_totlen(c, jeb, ref);\n\n\tif (ref_flags(ref) == REF_UNCHECKED) {\n\t\tD1(if (unlikely(jeb->unchecked_size < freed_len)) {\n\t\t\t\tpr_notice(\"raw unchecked node of size 0x%08x freed from erase block %d at 0x%08x, but unchecked_size was already 0x%08x\\n\",\n\t\t\t\t\t  freed_len, blocknr,\n\t\t\t\t\t  ref->flash_offset, jeb->used_size);\n\t\t\tBUG();\n\t\t})\n\t\t\tjffs2_dbg(1, \"Obsoleting previously unchecked node at 0x%08x of len %x\\n\",\n\t\t\t\t  ref_offset(ref), freed_len);\n\t\tjeb->unchecked_size -= freed_len;\n\t\tc->unchecked_size -= freed_len;\n\t} else {\n\t\tD1(if (unlikely(jeb->used_size < freed_len)) {\n\t\t\t\tpr_notice(\"raw node of size 0x%08x freed from erase block %d at 0x%08x, but used_size was already 0x%08x\\n\",\n\t\t\t\t\t  freed_len, blocknr,\n\t\t\t\t\t  ref->flash_offset, jeb->used_size);\n\t\t\tBUG();\n\t\t})\n\t\t\tjffs2_dbg(1, \"Obsoleting node at 0x%08x of len %#x: \",\n\t\t\t\t  ref_offset(ref), freed_len);\n\t\tjeb->used_size -= freed_len;\n\t\tc->used_size -= freed_len;\n\t}\n\n\t// Take care, that wasted size is taken into concern\n\tif ((jeb->dirty_size || ISDIRTY(jeb->wasted_size + freed_len)) && jeb != c->nextblock) {\n\t\tjffs2_dbg(1, \"Dirtying\\n\");\n\t\taddedsize = freed_len;\n\t\tjeb->dirty_size += freed_len;\n\t\tc->dirty_size += freed_len;\n\n\t\t/* Convert wasted space to dirty, if not a bad block */\n\t\tif (jeb->wasted_size) {\n\t\t\tif (on_list(&jeb->list, &c->bad_used_list)) {\n\t\t\t\tjffs2_dbg(1, \"Leaving block at %08x on the bad_used_list\\n\",\n\t\t\t\t\t  jeb->offset);\n\t\t\t\taddedsize = 0; /* To fool the refiling code later */\n\t\t\t} else {\n\t\t\t\tjffs2_dbg(1, \"Converting %d bytes of wasted space to dirty in block at %08x\\n\",\n\t\t\t\t\t  jeb->wasted_size, jeb->offset);\n\t\t\t\taddedsize += jeb->wasted_size;\n\t\t\t\tjeb->dirty_size += jeb->wasted_size;\n\t\t\t\tc->dirty_size += jeb->wasted_size;\n\t\t\t\tc->wasted_size -= jeb->wasted_size;\n\t\t\t\tjeb->wasted_size = 0;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tjffs2_dbg(1, \"Wasting\\n\");\n\t\taddedsize = 0;\n\t\tjeb->wasted_size += freed_len;\n\t\tc->wasted_size += freed_len;\n\t}\n\tref->flash_offset = ref_offset(ref) | REF_OBSOLETE;\n\n\tjffs2_dbg_acct_sanity_check_nolock(c, jeb);\n\tjffs2_dbg_acct_paranoia_check_nolock(c, jeb);\n\n\tif (c->flags & JFFS2_SB_FLAG_SCANNING) {\n\t\t/* Flash scanning is in progress. Don't muck about with the block\n\t\t   lists because they're not ready yet, and don't actually\n\t\t   obliterate nodes that look obsolete. If they weren't\n\t\t   marked obsolete on the flash at the time they _became_\n\t\t   obsolete, there was probably a reason for that. */\n\t\tspin_unlock(&c->erase_completion_lock);\n\t\t/* We didn't lock the erase_free_sem */\n\t\treturn;\n\t}\n\n\tif (jeb == c->nextblock) {\n\t\tjffs2_dbg(2, \"Not moving nextblock 0x%08x to dirty/erase_pending list\\n\",\n\t\t\t  jeb->offset);\n\t} else if (!jeb->used_size && !jeb->unchecked_size) {\n\t\tif (jeb == c->gcblock) {\n\t\t\tjffs2_dbg(1, \"gcblock at 0x%08x completely dirtied. Clearing gcblock...\\n\",\n\t\t\t\t  jeb->offset);\n\t\t\tc->gcblock = NULL;\n\t\t} else {\n\t\t\tjffs2_dbg(1, \"Eraseblock at 0x%08x completely dirtied. Removing from (dirty?) list...\\n\",\n\t\t\t\t  jeb->offset);\n\t\t\tlist_del(&jeb->list);\n\t\t}\n\t\tif (jffs2_wbuf_dirty(c)) {\n\t\t\tjffs2_dbg(1, \"...and adding to erasable_pending_wbuf_list\\n\");\n\t\t\tlist_add_tail(&jeb->list, &c->erasable_pending_wbuf_list);\n\t\t} else {\n\t\t\tif (jiffies & 127) {\n\t\t\t\t/* Most of the time, we just erase it immediately. Otherwise we\n\t\t\t\t   spend ages scanning it on mount, etc. */\n\t\t\t\tjffs2_dbg(1, \"...and adding to erase_pending_list\\n\");\n\t\t\t\tlist_add_tail(&jeb->list, &c->erase_pending_list);\n\t\t\t\tc->nr_erasing_blocks++;\n\t\t\t\tjffs2_garbage_collect_trigger(c);\n\t\t\t} else {\n\t\t\t\t/* Sometimes, however, we leave it elsewhere so it doesn't get\n\t\t\t\t   immediately reused, and we spread the load a bit. */\n\t\t\t\tjffs2_dbg(1, \"...and adding to erasable_list\\n\");\n\t\t\t\tlist_add_tail(&jeb->list, &c->erasable_list);\n\t\t\t}\n\t\t}\n\t\tjffs2_dbg(1, \"Done OK\\n\");\n\t} else if (jeb == c->gcblock) {\n\t\tjffs2_dbg(2, \"Not moving gcblock 0x%08x to dirty_list\\n\",\n\t\t\t  jeb->offset);\n\t} else if (ISDIRTY(jeb->dirty_size) && !ISDIRTY(jeb->dirty_size - addedsize)) {\n\t\tjffs2_dbg(1, \"Eraseblock at 0x%08x is freshly dirtied. Removing from clean list...\\n\",\n\t\t\t  jeb->offset);\n\t\tlist_del(&jeb->list);\n\t\tjffs2_dbg(1, \"...and adding to dirty_list\\n\");\n\t\tlist_add_tail(&jeb->list, &c->dirty_list);\n\t} else if (VERYDIRTY(c, jeb->dirty_size) &&\n\t\t   !VERYDIRTY(c, jeb->dirty_size - addedsize)) {\n\t\tjffs2_dbg(1, \"Eraseblock at 0x%08x is now very dirty. Removing from dirty list...\\n\",\n\t\t\t  jeb->offset);\n\t\tlist_del(&jeb->list);\n\t\tjffs2_dbg(1, \"...and adding to very_dirty_list\\n\");\n\t\tlist_add_tail(&jeb->list, &c->very_dirty_list);\n\t} else {\n\t\tjffs2_dbg(1, \"Eraseblock at 0x%08x not moved anywhere. (free 0x%08x, dirty 0x%08x, used 0x%08x)\\n\",\n\t\t\t  jeb->offset, jeb->free_size, jeb->dirty_size,\n\t\t\t  jeb->used_size);\n\t}\n\n\tspin_unlock(&c->erase_completion_lock);\n\n\tif (!jffs2_can_mark_obsolete(c) || jffs2_is_readonly(c) ||\n\t\t(c->flags & JFFS2_SB_FLAG_BUILDING)) {\n\t\t/* We didn't lock the erase_free_sem */\n\t\treturn;\n\t}\n\n\t/* The erase_free_sem is locked, and has been since before we marked the node obsolete\n\t   and potentially put its eraseblock onto the erase_pending_list. Thus, we know that\n\t   the block hasn't _already_ been erased, and that 'ref' itself hasn't been freed yet\n\t   by jffs2_free_jeb_node_refs() in erase.c. Which is nice. */\n\n\tjffs2_dbg(1, \"obliterating obsoleted node at 0x%08x\\n\",\n\t\t  ref_offset(ref));\n\tret = jffs2_flash_read(c, ref_offset(ref), sizeof(n), &retlen, (char *)&n);\n\tif (ret) {\n\t\tpr_warn(\"Read error reading from obsoleted node at 0x%08x: %d\\n\",\n\t\t\tref_offset(ref), ret);\n\t\tgoto out_erase_sem;\n\t}\n\tif (retlen != sizeof(n)) {\n\t\tpr_warn(\"Short read from obsoleted node at 0x%08x: %zd\\n\",\n\t\t\tref_offset(ref), retlen);\n\t\tgoto out_erase_sem;\n\t}\n\tif (PAD(je32_to_cpu(n.totlen)) != PAD(freed_len)) {\n\t\tpr_warn(\"Node totlen on flash (0x%08x) != totlen from node ref (0x%08x)\\n\",\n\t\t\tje32_to_cpu(n.totlen), freed_len);\n\t\tgoto out_erase_sem;\n\t}\n\tif (!(je16_to_cpu(n.nodetype) & JFFS2_NODE_ACCURATE)) {\n\t\tjffs2_dbg(1, \"Node at 0x%08x was already marked obsolete (nodetype 0x%04x)\\n\",\n\t\t\t  ref_offset(ref), je16_to_cpu(n.nodetype));\n\t\tgoto out_erase_sem;\n\t}\n\t/* XXX FIXME: This is ugly now */\n\tn.nodetype = cpu_to_je16(je16_to_cpu(n.nodetype) & ~JFFS2_NODE_ACCURATE);\n\tret = jffs2_flash_write(c, ref_offset(ref), sizeof(n), &retlen, (char *)&n);\n\tif (ret) {\n\t\tpr_warn(\"Write error in obliterating obsoleted node at 0x%08x: %d\\n\",\n\t\t\tref_offset(ref), ret);\n\t\tgoto out_erase_sem;\n\t}\n\tif (retlen != sizeof(n)) {\n\t\tpr_warn(\"Short write in obliterating obsoleted node at 0x%08x: %zd\\n\",\n\t\t\tref_offset(ref), retlen);\n\t\tgoto out_erase_sem;\n\t}\n\n\t/* Nodes which have been marked obsolete no longer need to be\n\t   associated with any inode. Remove them from the per-inode list.\n\n\t   Note we can't do this for NAND at the moment because we need\n\t   obsolete dirent nodes to stay on the lists, because of the\n\t   horridness in jffs2_garbage_collect_deletion_dirent(). Also\n\t   because we delete the inocache, and on NAND we need that to\n\t   stay around until all the nodes are actually erased, in order\n\t   to stop us from giving the same inode number to another newly\n\t   created inode. */\n\tif (ref->next_in_ino) {\n\t\tstruct jffs2_inode_cache *ic;\n\t\tstruct jffs2_raw_node_ref **p;\n\n\t\tspin_lock(&c->erase_completion_lock);\n\n\t\tic = jffs2_raw_ref_to_ic(ref);\n\t\tfor (p = &ic->nodes; (*p) != ref; p = &((*p)->next_in_ino))\n\t\t\t;\n\n\t\t*p = ref->next_in_ino;\n\t\tref->next_in_ino = NULL;\n\n\t\tswitch (ic->class) {\n#ifdef CONFIG_JFFS2_FS_XATTR\n\t\t\tcase RAWNODE_CLASS_XATTR_DATUM:\n\t\t\t\tjffs2_release_xattr_datum(c, (struct jffs2_xattr_datum *)ic);\n\t\t\t\tbreak;\n\t\t\tcase RAWNODE_CLASS_XATTR_REF:\n\t\t\t\tjffs2_release_xattr_ref(c, (struct jffs2_xattr_ref *)ic);\n\t\t\t\tbreak;\n#endif\n\t\t\tdefault:\n\t\t\t\tif (ic->nodes == (void *)ic && ic->pino_nlink == 0)\n\t\t\t\t\tjffs2_del_ino_cache(c, ic);\n\t\t\t\tbreak;\n\t\t}\n\t\tspin_unlock(&c->erase_completion_lock);\n\t}\n\n out_erase_sem:\n\tmutex_unlock(&c->erase_free_sem);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bg_readinode(",
          "args": [
            "CRC error, mark it obsolete.\\n\")"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nlikely(",
          "args": [
            "et > 0)"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FFS2_ERROR(",
          "args": [
            "check_node_data() returned error: %d.\\n\",",
            "et)"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nlikely(",
          "args": [
            "et < 0)"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "heck_node_data(",
          "args": [
            ",",
            "n)"
          ],
          "line": 163
        },
        "resolved": true,
        "details": {
          "function_name": "heck_node_data(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/readinode.c",
          "lines": "31-143",
          "snippet": "tatic int check_node_data(struct jffs2_sb_info *c, struct jffs2_tmp_dnode_info *tn)\n{\n\tstruct jffs2_raw_node_ref *ref = tn->fn->raw;\n\tint err = 0, pointed = 0;\n\tstruct jffs2_eraseblock *jeb;\n\tunsigned char *buffer;\n\tuint32_t crc, ofs, len;\n\tsize_t retlen;\n\n\tBUG_ON(tn->csize == 0);\n\n\t/* Calculate how many bytes were already checked */\n\tofs = ref_offset(ref) + sizeof(struct jffs2_raw_inode);\n\tlen = tn->csize;\n\n\tif (jffs2_is_writebuffered(c)) {\n\t\tint adj = ofs % c->wbuf_pagesize;\n\t\tif (likely(adj))\n\t\t\tadj = c->wbuf_pagesize - adj;\n\n\t\tif (adj >= tn->csize) {\n\t\t\tdbg_readinode(\"no need to check node at %#08x, data length %u, data starts at %#08x - it has already been checked.\\n\",\n\t\t\t\t      ref_offset(ref), tn->csize, ofs);\n\t\t\tgoto adj_acc;\n\t\t}\n\n\t\tofs += adj;\n\t\tlen -= adj;\n\t}\n\n\tdbg_readinode(\"check node at %#08x, data length %u, partial CRC %#08x, correct CRC %#08x, data starts at %#08x, start checking from %#08x - %u bytes.\\n\",\n\t\tref_offset(ref), tn->csize, tn->partial_crc, tn->data_crc, ofs - len, ofs, len);\n\n#ifndef __ECOS\n\t/* TODO: instead, incapsulate point() stuff to jffs2_flash_read(),\n\t * adding and jffs2_flash_read_end() interface. */\n\terr = mtd_point(c->mtd, ofs, len, &retlen, (void **)&buffer, NULL);\n\tif (!err && retlen < len) {\n\t\tJFFS2_WARNING(\"MTD point returned len too short: %zu instead of %u.\\n\", retlen, tn->csize);\n\t\tmtd_unpoint(c->mtd, ofs, retlen);\n\t} else if (err) {\n\t\tif (err != -EOPNOTSUPP)\n\t\t\tJFFS2_WARNING(\"MTD point failed: error code %d.\\n\", err);\n\t} else\n\t\tpointed = 1; /* succefully pointed to device */\n#endif\n\n\tif (!pointed) {\n\t\tbuffer = kmalloc(len, GFP_KERNEL);\n\t\tif (unlikely(!buffer))\n\t\t\treturn -ENOMEM;\n\n\t\t/* TODO: this is very frequent pattern, make it a separate\n\t\t * routine */\n\t\terr = jffs2_flash_read(c, ofs, len, &retlen, buffer);\n\t\tif (err) {\n\t\t\tJFFS2_ERROR(\"can not read %d bytes from 0x%08x, error code: %d.\\n\", len, ofs, err);\n\t\t\tgoto free_out;\n\t\t}\n\n\t\tif (retlen != len) {\n\t\t\tJFFS2_ERROR(\"short read at %#08x: %zd instead of %d.\\n\", ofs, retlen, len);\n\t\t\terr = -EIO;\n\t\t\tgoto free_out;\n\t\t}\n\t}\n\n\t/* Continue calculating CRC */\n\tcrc = crc32(tn->partial_crc, buffer, len);\n\tif(!pointed)\n\t\tkfree(buffer);\n#ifndef __ECOS\n\telse\n\t\tmtd_unpoint(c->mtd, ofs, len);\n#endif\n\n\tif (crc != tn->data_crc) {\n\t\tJFFS2_NOTICE(\"wrong data CRC in data node at 0x%08x: read %#08x, calculated %#08x.\\n\",\n\t\t\t     ref_offset(ref), tn->data_crc, crc);\n\t\treturn 1;\n\t}\n\nadj_acc:\n\tjeb = &c->blocks[ref->flash_offset / c->sector_size];\n\tlen = ref_totlen(c, jeb, ref);\n\t/* If it should be REF_NORMAL, it'll get marked as such when\n\t   we build the fragtree, shortly. No need to worry about GC\n\t   moving it while it's marked REF_PRISTINE -- GC won't happen\n\t   till we've finished checking every inode anyway. */\n\tref->flash_offset |= REF_PRISTINE;\n\t/*\n\t * Mark the node as having been checked and fix the\n\t * accounting accordingly.\n\t */\n\tspin_lock(&c->erase_completion_lock);\n\tjeb->used_size += len;\n\tjeb->unchecked_size -= len;\n\tc->used_size += len;\n\tc->unchecked_size -= len;\n\tjffs2_dbg_acct_paranoia_check_nolock(c, jeb);\n\tspin_unlock(&c->erase_completion_lock);\n\n\treturn 0;\n\nfree_out:\n\tif(!pointed)\n\t\tkfree(buffer);\n#ifndef __ECOS\n\telse\n\t\tmtd_unpoint(c->mtd, ofs, len);\n#endif\n\treturn err;\n}",
          "includes": [
            "include \"nodelist.h\"",
            "include <linux/compiler.h>\n#",
            "include <linux/mtd/mtd.h>\n#",
            "include <linux/pagemap.h>\n#",
            "include <linux/crc32.h>\n#",
            "include <linux/fs.h>\n#",
            "include <linux/slab.h>\n#",
            "include <linux/sched.h>\n#",
            "include <linux/kernel.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"nodelist.h\"\ninclude <linux/compiler.h>\n#\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/pagemap.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/fs.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/sched.h>\n#\ninclude <linux/kernel.h>\n#\n\ntatic int check_node_data(struct jffs2_sb_info *c, struct jffs2_tmp_dnode_info *tn)\n{\n\tstruct jffs2_raw_node_ref *ref = tn->fn->raw;\n\tint err = 0, pointed = 0;\n\tstruct jffs2_eraseblock *jeb;\n\tunsigned char *buffer;\n\tuint32_t crc, ofs, len;\n\tsize_t retlen;\n\n\tBUG_ON(tn->csize == 0);\n\n\t/* Calculate how many bytes were already checked */\n\tofs = ref_offset(ref) + sizeof(struct jffs2_raw_inode);\n\tlen = tn->csize;\n\n\tif (jffs2_is_writebuffered(c)) {\n\t\tint adj = ofs % c->wbuf_pagesize;\n\t\tif (likely(adj))\n\t\t\tadj = c->wbuf_pagesize - adj;\n\n\t\tif (adj >= tn->csize) {\n\t\t\tdbg_readinode(\"no need to check node at %#08x, data length %u, data starts at %#08x - it has already been checked.\\n\",\n\t\t\t\t      ref_offset(ref), tn->csize, ofs);\n\t\t\tgoto adj_acc;\n\t\t}\n\n\t\tofs += adj;\n\t\tlen -= adj;\n\t}\n\n\tdbg_readinode(\"check node at %#08x, data length %u, partial CRC %#08x, correct CRC %#08x, data starts at %#08x, start checking from %#08x - %u bytes.\\n\",\n\t\tref_offset(ref), tn->csize, tn->partial_crc, tn->data_crc, ofs - len, ofs, len);\n\n#ifndef __ECOS\n\t/* TODO: instead, incapsulate point() stuff to jffs2_flash_read(),\n\t * adding and jffs2_flash_read_end() interface. */\n\terr = mtd_point(c->mtd, ofs, len, &retlen, (void **)&buffer, NULL);\n\tif (!err && retlen < len) {\n\t\tJFFS2_WARNING(\"MTD point returned len too short: %zu instead of %u.\\n\", retlen, tn->csize);\n\t\tmtd_unpoint(c->mtd, ofs, retlen);\n\t} else if (err) {\n\t\tif (err != -EOPNOTSUPP)\n\t\t\tJFFS2_WARNING(\"MTD point failed: error code %d.\\n\", err);\n\t} else\n\t\tpointed = 1; /* succefully pointed to device */\n#endif\n\n\tif (!pointed) {\n\t\tbuffer = kmalloc(len, GFP_KERNEL);\n\t\tif (unlikely(!buffer))\n\t\t\treturn -ENOMEM;\n\n\t\t/* TODO: this is very frequent pattern, make it a separate\n\t\t * routine */\n\t\terr = jffs2_flash_read(c, ofs, len, &retlen, buffer);\n\t\tif (err) {\n\t\t\tJFFS2_ERROR(\"can not read %d bytes from 0x%08x, error code: %d.\\n\", len, ofs, err);\n\t\t\tgoto free_out;\n\t\t}\n\n\t\tif (retlen != len) {\n\t\t\tJFFS2_ERROR(\"short read at %#08x: %zd instead of %d.\\n\", ofs, retlen, len);\n\t\t\terr = -EIO;\n\t\t\tgoto free_out;\n\t\t}\n\t}\n\n\t/* Continue calculating CRC */\n\tcrc = crc32(tn->partial_crc, buffer, len);\n\tif(!pointed)\n\t\tkfree(buffer);\n#ifndef __ECOS\n\telse\n\t\tmtd_unpoint(c->mtd, ofs, len);\n#endif\n\n\tif (crc != tn->data_crc) {\n\t\tJFFS2_NOTICE(\"wrong data CRC in data node at 0x%08x: read %#08x, calculated %#08x.\\n\",\n\t\t\t     ref_offset(ref), tn->data_crc, crc);\n\t\treturn 1;\n\t}\n\nadj_acc:\n\tjeb = &c->blocks[ref->flash_offset / c->sector_size];\n\tlen = ref_totlen(c, jeb, ref);\n\t/* If it should be REF_NORMAL, it'll get marked as such when\n\t   we build the fragtree, shortly. No need to worry about GC\n\t   moving it while it's marked REF_PRISTINE -- GC won't happen\n\t   till we've finished checking every inode anyway. */\n\tref->flash_offset |= REF_PRISTINE;\n\t/*\n\t * Mark the node as having been checked and fix the\n\t * accounting accordingly.\n\t */\n\tspin_lock(&c->erase_completion_lock);\n\tjeb->used_size += len;\n\tjeb->unchecked_size -= len;\n\tc->used_size += len;\n\tc->unchecked_size -= len;\n\tjffs2_dbg_acct_paranoia_check_nolock(c, jeb);\n\tspin_unlock(&c->erase_completion_lock);\n\n\treturn 0;\n\nfree_out:\n\tif(!pointed)\n\t\tkfree(buffer);\n#ifndef __ECOS\n\telse\n\t\tmtd_unpoint(c->mtd, ofs, len);\n#endif\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bg_readinode(",
          "args": [
            "check node %#04x-%#04x, phys offs %#08x\\n\",",
            "n->fn->ofs,",
            "n->fn->ofs + tn->fn->size,",
            "ef_offset(tn->fn->raw))"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ef_offset(",
          "args": [
            "n->fn->raw)"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ef_flags(",
          "args": [
            "n->fn->raw)"
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UG_ON(",
          "args": [
            "ef_obsolete(tn->fn->raw))"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ef_obsolete(",
          "args": [
            "n->fn->raw)"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"nodelist.h\"\ninclude <linux/compiler.h>\n#\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/pagemap.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/fs.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/sched.h>\n#\ninclude <linux/kernel.h>\n#\n\ntatic int check_tn_node(struct jffs2_sb_info *c, struct jffs2_tmp_dnode_info *tn)\n{\n\tint ret;\n\n\tBUG_ON(ref_obsolete(tn->fn->raw));\n\n\t/* We only check the data CRC of unchecked nodes */\n\tif (ref_flags(tn->fn->raw) != REF_UNCHECKED)\n\t\treturn 0;\n\n\tdbg_readinode(\"check node %#04x-%#04x, phys offs %#08x\\n\",\n\t\t      tn->fn->ofs, tn->fn->ofs + tn->fn->size, ref_offset(tn->fn->raw));\n\n\tret = check_node_data(c, tn);\n\tif (unlikely(ret < 0)) {\n\t\tJFFS2_ERROR(\"check_node_data() returned error: %d.\\n\",\n\t\t\tret);\n\t} else if (unlikely(ret > 0)) {\n\t\tdbg_readinode(\"CRC error, mark it obsolete.\\n\");\n\t\tjffs2_mark_node_obsolete(c, tn->fn->raw);\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "heck_node_data(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/readinode.c",
    "lines": "31-143",
    "snippet": "tatic int check_node_data(struct jffs2_sb_info *c, struct jffs2_tmp_dnode_info *tn)\n{\n\tstruct jffs2_raw_node_ref *ref = tn->fn->raw;\n\tint err = 0, pointed = 0;\n\tstruct jffs2_eraseblock *jeb;\n\tunsigned char *buffer;\n\tuint32_t crc, ofs, len;\n\tsize_t retlen;\n\n\tBUG_ON(tn->csize == 0);\n\n\t/* Calculate how many bytes were already checked */\n\tofs = ref_offset(ref) + sizeof(struct jffs2_raw_inode);\n\tlen = tn->csize;\n\n\tif (jffs2_is_writebuffered(c)) {\n\t\tint adj = ofs % c->wbuf_pagesize;\n\t\tif (likely(adj))\n\t\t\tadj = c->wbuf_pagesize - adj;\n\n\t\tif (adj >= tn->csize) {\n\t\t\tdbg_readinode(\"no need to check node at %#08x, data length %u, data starts at %#08x - it has already been checked.\\n\",\n\t\t\t\t      ref_offset(ref), tn->csize, ofs);\n\t\t\tgoto adj_acc;\n\t\t}\n\n\t\tofs += adj;\n\t\tlen -= adj;\n\t}\n\n\tdbg_readinode(\"check node at %#08x, data length %u, partial CRC %#08x, correct CRC %#08x, data starts at %#08x, start checking from %#08x - %u bytes.\\n\",\n\t\tref_offset(ref), tn->csize, tn->partial_crc, tn->data_crc, ofs - len, ofs, len);\n\n#ifndef __ECOS\n\t/* TODO: instead, incapsulate point() stuff to jffs2_flash_read(),\n\t * adding and jffs2_flash_read_end() interface. */\n\terr = mtd_point(c->mtd, ofs, len, &retlen, (void **)&buffer, NULL);\n\tif (!err && retlen < len) {\n\t\tJFFS2_WARNING(\"MTD point returned len too short: %zu instead of %u.\\n\", retlen, tn->csize);\n\t\tmtd_unpoint(c->mtd, ofs, retlen);\n\t} else if (err) {\n\t\tif (err != -EOPNOTSUPP)\n\t\t\tJFFS2_WARNING(\"MTD point failed: error code %d.\\n\", err);\n\t} else\n\t\tpointed = 1; /* succefully pointed to device */\n#endif\n\n\tif (!pointed) {\n\t\tbuffer = kmalloc(len, GFP_KERNEL);\n\t\tif (unlikely(!buffer))\n\t\t\treturn -ENOMEM;\n\n\t\t/* TODO: this is very frequent pattern, make it a separate\n\t\t * routine */\n\t\terr = jffs2_flash_read(c, ofs, len, &retlen, buffer);\n\t\tif (err) {\n\t\t\tJFFS2_ERROR(\"can not read %d bytes from 0x%08x, error code: %d.\\n\", len, ofs, err);\n\t\t\tgoto free_out;\n\t\t}\n\n\t\tif (retlen != len) {\n\t\t\tJFFS2_ERROR(\"short read at %#08x: %zd instead of %d.\\n\", ofs, retlen, len);\n\t\t\terr = -EIO;\n\t\t\tgoto free_out;\n\t\t}\n\t}\n\n\t/* Continue calculating CRC */\n\tcrc = crc32(tn->partial_crc, buffer, len);\n\tif(!pointed)\n\t\tkfree(buffer);\n#ifndef __ECOS\n\telse\n\t\tmtd_unpoint(c->mtd, ofs, len);\n#endif\n\n\tif (crc != tn->data_crc) {\n\t\tJFFS2_NOTICE(\"wrong data CRC in data node at 0x%08x: read %#08x, calculated %#08x.\\n\",\n\t\t\t     ref_offset(ref), tn->data_crc, crc);\n\t\treturn 1;\n\t}\n\nadj_acc:\n\tjeb = &c->blocks[ref->flash_offset / c->sector_size];\n\tlen = ref_totlen(c, jeb, ref);\n\t/* If it should be REF_NORMAL, it'll get marked as such when\n\t   we build the fragtree, shortly. No need to worry about GC\n\t   moving it while it's marked REF_PRISTINE -- GC won't happen\n\t   till we've finished checking every inode anyway. */\n\tref->flash_offset |= REF_PRISTINE;\n\t/*\n\t * Mark the node as having been checked and fix the\n\t * accounting accordingly.\n\t */\n\tspin_lock(&c->erase_completion_lock);\n\tjeb->used_size += len;\n\tjeb->unchecked_size -= len;\n\tc->used_size += len;\n\tc->unchecked_size -= len;\n\tjffs2_dbg_acct_paranoia_check_nolock(c, jeb);\n\tspin_unlock(&c->erase_completion_lock);\n\n\treturn 0;\n\nfree_out:\n\tif(!pointed)\n\t\tkfree(buffer);\n#ifndef __ECOS\n\telse\n\t\tmtd_unpoint(c->mtd, ofs, len);\n#endif\n\treturn err;\n}",
    "includes": [
      "include \"nodelist.h\"",
      "include <linux/compiler.h>\n#",
      "include <linux/mtd/mtd.h>\n#",
      "include <linux/pagemap.h>\n#",
      "include <linux/crc32.h>\n#",
      "include <linux/fs.h>\n#",
      "include <linux/slab.h>\n#",
      "include <linux/sched.h>\n#",
      "include <linux/kernel.h>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free(",
          "args": [
            "uffer)"
          ],
          "line": 137
        },
        "resolved": true,
        "details": {
          "function_name": "in_free(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/scan.c",
          "lines": "51-60",
          "snippet": "tatic inline int min_free(struct jffs2_sb_info *c)\n{\n\tuint32_t min = 2 * sizeof(struct jffs2_raw_inode);\n#ifdef CONFIG_JFFS2_FS_WRITEBUFFER\n\tif (!jffs2_can_mark_obsolete(c) && min < c->wbuf_pagesize)\n\t\treturn c->wbuf_pagesize;\n#endif\n\treturn min;\n\n}",
          "includes": [
            "include \"debug.h\"",
            "include \"summary.h\"\n#",
            "include \"nodelist.h\"\n#",
            "include <linux/compiler.h>\n#",
            "include <linux/crc32.h>\n#",
            "include <linux/pagemap.h>\n#",
            "include <linux/mtd/mtd.h>\n#",
            "include <linux/slab.h>\n#",
            "include <linux/sched.h>\n#",
            "include <linux/kernel.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"debug.h\"\ninclude \"summary.h\"\n#\ninclude \"nodelist.h\"\n#\ninclude <linux/compiler.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/pagemap.h>\n#\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/sched.h>\n#\ninclude <linux/kernel.h>\n#\n\ntatic inline int min_free(struct jffs2_sb_info *c)\n{\n\tuint32_t min = 2 * sizeof(struct jffs2_raw_inode);\n#ifdef CONFIG_JFFS2_FS_WRITEBUFFER\n\tif (!jffs2_can_mark_obsolete(c) && min < c->wbuf_pagesize)\n\t\treturn c->wbuf_pagesize;\n#endif\n\treturn min;\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "pin_unlock(",
          "args": [
            "c->erase_completion_lock)"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_dbg_acct_paranoia_check_nolock(",
          "args": [
            ",",
            "eb)"
          ],
          "line": 130
        },
        "resolved": true,
        "details": {
          "function_name": "jffs2_dbg_acct_paranoia_check_nolock(s",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/debug.c",
          "lines": "309-384",
          "snippet": "id\n__jffs2_dbg_acct_paranoia_check_nolock(struct jffs2_sb_info *c,\n\t\t\t\t       struct jffs2_eraseblock *jeb)\n{\n\tuint32_t my_used_size = 0;\n\tuint32_t my_unchecked_size = 0;\n\tuint32_t my_dirty_size = 0;\n\tstruct jffs2_raw_node_ref *ref2 = jeb->first_node;\n\n\twhile (ref2) {\n\t\tuint32_t totlen = ref_totlen(c, jeb, ref2);\n\n\t\tif (ref_offset(ref2) < jeb->offset ||\n\t\t\t\tref_offset(ref2) > jeb->offset + c->sector_size) {\n\t\t\tJFFS2_ERROR(\"node_ref %#08x shouldn't be in block at %#08x.\\n\",\n\t\t\t\tref_offset(ref2), jeb->offset);\n\t\t\tgoto error;\n\n\t\t}\n\t\tif (ref_flags(ref2) == REF_UNCHECKED)\n\t\t\tmy_unchecked_size += totlen;\n\t\telse if (!ref_obsolete(ref2))\n\t\t\tmy_used_size += totlen;\n\t\telse\n\t\t\tmy_dirty_size += totlen;\n\n\t\tif ((!ref_next(ref2)) != (ref2 == jeb->last_node)) {\n\t\t\tJFFS2_ERROR(\"node_ref for node at %#08x (mem %p) has next at %#08x (mem %p), last_node is at %#08x (mem %p).\\n\",\n\t\t\t\t    ref_offset(ref2), ref2, ref_offset(ref_next(ref2)), ref_next(ref2),\n\t\t\t\t    ref_offset(jeb->last_node), jeb->last_node);\n\t\t\tgoto error;\n\t\t}\n\t\tref2 = ref_next(ref2);\n\t}\n\n\tif (my_used_size != jeb->used_size) {\n\t\tJFFS2_ERROR(\"Calculated used size %#08x != stored used size %#08x.\\n\",\n\t\t\tmy_used_size, jeb->used_size);\n\t\tgoto error;\n\t}\n\n\tif (my_unchecked_size != jeb->unchecked_size) {\n\t\tJFFS2_ERROR(\"Calculated unchecked size %#08x != stored unchecked size %#08x.\\n\",\n\t\t\tmy_unchecked_size, jeb->unchecked_size);\n\t\tgoto error;\n\t}\n\n#if 0\n\t/* This should work when we implement ref->__totlen elemination */\n\tif (my_dirty_size != jeb->dirty_size + jeb->wasted_size) {\n\t\tJFFS2_ERROR(\"Calculated dirty+wasted size %#08x != stored dirty + wasted size %#08x\\n\",\n\t\t\tmy_dirty_size, jeb->dirty_size + jeb->wasted_size);\n\t\tgoto error;\n\t}\n\n\tif (jeb->free_size == 0\n\t\t&& my_used_size + my_unchecked_size + my_dirty_size != c->sector_size) {\n\t\tJFFS2_ERROR(\"The sum of all nodes in block (%#x) != size of block (%#x)\\n\",\n\t\t\tmy_used_size + my_unchecked_size + my_dirty_size,\n\t\t\tc->sector_size);\n\t\tgoto error;\n\t}\n#endif\n\n\tif (!(c->flags & (JFFS2_SB_FLAG_BUILDING|JFFS2_SB_FLAG_SCANNING)))\n\t\t__jffs2_dbg_superblock_counts(c);\n\n\treturn;\n\nerror:\n\t__jffs2_dbg_dump_node_refs_nolock(c, jeb);\n\t__jffs2_dbg_dump_jeb_nolock(jeb);\n\t__jffs2_dbg_dump_block_lists_nolock(c);\n\tBUG();\n\n}\n#",
          "includes": [
            "nclude \"debug.h\"\n\n#",
            "nclude \"nodelist.h\"\n#i",
            "nclude <linux/slab.h>\n#i",
            "nclude <linux/mtd/mtd.h>\n#i",
            "nclude <linux/jffs2.h>\n#i",
            "nclude <linux/crc32.h>\n#i",
            "nclude <linux/pagemap.h>\n#i",
            "nclude <linux/types.h>\n#i",
            "nclude <linux/kernel.h>\n#i"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "nclude \"debug.h\"\n\n#\nnclude \"nodelist.h\"\n#i\nnclude <linux/slab.h>\n#i\nnclude <linux/mtd/mtd.h>\n#i\nnclude <linux/jffs2.h>\n#i\nnclude <linux/crc32.h>\n#i\nnclude <linux/pagemap.h>\n#i\nnclude <linux/types.h>\n#i\nnclude <linux/kernel.h>\n#i\n\nid\n__jffs2_dbg_acct_paranoia_check_nolock(struct jffs2_sb_info *c,\n\t\t\t\t       struct jffs2_eraseblock *jeb)\n{\n\tuint32_t my_used_size = 0;\n\tuint32_t my_unchecked_size = 0;\n\tuint32_t my_dirty_size = 0;\n\tstruct jffs2_raw_node_ref *ref2 = jeb->first_node;\n\n\twhile (ref2) {\n\t\tuint32_t totlen = ref_totlen(c, jeb, ref2);\n\n\t\tif (ref_offset(ref2) < jeb->offset ||\n\t\t\t\tref_offset(ref2) > jeb->offset + c->sector_size) {\n\t\t\tJFFS2_ERROR(\"node_ref %#08x shouldn't be in block at %#08x.\\n\",\n\t\t\t\tref_offset(ref2), jeb->offset);\n\t\t\tgoto error;\n\n\t\t}\n\t\tif (ref_flags(ref2) == REF_UNCHECKED)\n\t\t\tmy_unchecked_size += totlen;\n\t\telse if (!ref_obsolete(ref2))\n\t\t\tmy_used_size += totlen;\n\t\telse\n\t\t\tmy_dirty_size += totlen;\n\n\t\tif ((!ref_next(ref2)) != (ref2 == jeb->last_node)) {\n\t\t\tJFFS2_ERROR(\"node_ref for node at %#08x (mem %p) has next at %#08x (mem %p), last_node is at %#08x (mem %p).\\n\",\n\t\t\t\t    ref_offset(ref2), ref2, ref_offset(ref_next(ref2)), ref_next(ref2),\n\t\t\t\t    ref_offset(jeb->last_node), jeb->last_node);\n\t\t\tgoto error;\n\t\t}\n\t\tref2 = ref_next(ref2);\n\t}\n\n\tif (my_used_size != jeb->used_size) {\n\t\tJFFS2_ERROR(\"Calculated used size %#08x != stored used size %#08x.\\n\",\n\t\t\tmy_used_size, jeb->used_size);\n\t\tgoto error;\n\t}\n\n\tif (my_unchecked_size != jeb->unchecked_size) {\n\t\tJFFS2_ERROR(\"Calculated unchecked size %#08x != stored unchecked size %#08x.\\n\",\n\t\t\tmy_unchecked_size, jeb->unchecked_size);\n\t\tgoto error;\n\t}\n\n#if 0\n\t/* This should work when we implement ref->__totlen elemination */\n\tif (my_dirty_size != jeb->dirty_size + jeb->wasted_size) {\n\t\tJFFS2_ERROR(\"Calculated dirty+wasted size %#08x != stored dirty + wasted size %#08x\\n\",\n\t\t\tmy_dirty_size, jeb->dirty_size + jeb->wasted_size);\n\t\tgoto error;\n\t}\n\n\tif (jeb->free_size == 0\n\t\t&& my_used_size + my_unchecked_size + my_dirty_size != c->sector_size) {\n\t\tJFFS2_ERROR(\"The sum of all nodes in block (%#x) != size of block (%#x)\\n\",\n\t\t\tmy_used_size + my_unchecked_size + my_dirty_size,\n\t\t\tc->sector_size);\n\t\tgoto error;\n\t}\n#endif\n\n\tif (!(c->flags & (JFFS2_SB_FLAG_BUILDING|JFFS2_SB_FLAG_SCANNING)))\n\t\t__jffs2_dbg_superblock_counts(c);\n\n\treturn;\n\nerror:\n\t__jffs2_dbg_dump_node_refs_nolock(c, jeb);\n\t__jffs2_dbg_dump_jeb_nolock(jeb);\n\t__jffs2_dbg_dump_block_lists_nolock(c);\n\tBUG();\n\n}\n#"
        }
      },
      {
        "call_info": {
          "callee": "pin_lock(",
          "args": [
            "c->erase_completion_lock)"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ef_totlen(",
          "args": [
            ",",
            "eb,",
            "ef)"
          ],
          "line": 115
        },
        "resolved": true,
        "details": {
          "function_name": "_jffs2_ref_totlen(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/nodelist.c",
          "lines": "718-755",
          "snippet": "int32_t __jffs2_ref_totlen(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t    struct jffs2_raw_node_ref *ref)\n{\n\tuint32_t ret;\n\n\tret = __ref_totlen(c, jeb, ref);\n\n#ifdef TEST_TOTLEN\n\tif (unlikely(ret != ref->__totlen)) {\n\t\tif (!jeb)\n\t\t\tjeb = &c->blocks[ref->flash_offset / c->sector_size];\n\n\t\tpr_crit(\"Totlen for ref at %p (0x%08x-0x%08x) miscalculated as 0x%x instead of %x\\n\",\n\t\t\tref, ref_offset(ref), ref_offset(ref) + ref->__totlen,\n\t\t\tret, ref->__totlen);\n\t\tif (ref_next(ref)) {\n\t\t\tpr_crit(\"next %p (0x%08x-0x%08x)\\n\",\n\t\t\t\tref_next(ref), ref_offset(ref_next(ref)),\n\t\t\t\tref_offset(ref_next(ref)) + ref->__totlen);\n\t\t} else \n\t\t\tpr_crit(\"No next ref. jeb->last_node is %p\\n\",\n\t\t\t\tjeb->last_node);\n\n\t\tpr_crit(\"jeb->wasted_size %x, dirty_size %x, used_size %x, free_size %x\\n\",\n\t\t\tjeb->wasted_size, jeb->dirty_size, jeb->used_size,\n\t\t\tjeb->free_size);\n\n#if defined(JFFS2_DBG_DUMPS) || defined(JFFS2_DBG_PARANOIA_CHECKS)\n\t\t__jffs2_dbg_dump_node_refs_nolock(c, jeb);\n#endif\n\n\t\tWARN_ON(1);\n\n\t\tret = ref->__totlen;\n\t}\n#endif /* TEST_TOTLEN */\n\treturn ret;\n}",
          "includes": [
            "include \"nodelist.h\"",
            "include <linux/pagemap.h>\n#",
            "include <linux/crc32.h>\n#",
            "include <linux/rbtree.h>\n#",
            "include <linux/mtd/mtd.h>\n#",
            "include <linux/fs.h>\n#",
            "include <linux/sched.h>\n#",
            "include <linux/kernel.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"nodelist.h\"\ninclude <linux/pagemap.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/rbtree.h>\n#\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/fs.h>\n#\ninclude <linux/sched.h>\n#\ninclude <linux/kernel.h>\n#\n\nint32_t __jffs2_ref_totlen(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t    struct jffs2_raw_node_ref *ref)\n{\n\tuint32_t ret;\n\n\tret = __ref_totlen(c, jeb, ref);\n\n#ifdef TEST_TOTLEN\n\tif (unlikely(ret != ref->__totlen)) {\n\t\tif (!jeb)\n\t\t\tjeb = &c->blocks[ref->flash_offset / c->sector_size];\n\n\t\tpr_crit(\"Totlen for ref at %p (0x%08x-0x%08x) miscalculated as 0x%x instead of %x\\n\",\n\t\t\tref, ref_offset(ref), ref_offset(ref) + ref->__totlen,\n\t\t\tret, ref->__totlen);\n\t\tif (ref_next(ref)) {\n\t\t\tpr_crit(\"next %p (0x%08x-0x%08x)\\n\",\n\t\t\t\tref_next(ref), ref_offset(ref_next(ref)),\n\t\t\t\tref_offset(ref_next(ref)) + ref->__totlen);\n\t\t} else \n\t\t\tpr_crit(\"No next ref. jeb->last_node is %p\\n\",\n\t\t\t\tjeb->last_node);\n\n\t\tpr_crit(\"jeb->wasted_size %x, dirty_size %x, used_size %x, free_size %x\\n\",\n\t\t\tjeb->wasted_size, jeb->dirty_size, jeb->used_size,\n\t\t\tjeb->free_size);\n\n#if defined(JFFS2_DBG_DUMPS) || defined(JFFS2_DBG_PARANOIA_CHECKS)\n\t\t__jffs2_dbg_dump_node_refs_nolock(c, jeb);\n#endif\n\n\t\tWARN_ON(1);\n\n\t\tret = ref->__totlen;\n\t}\n#endif /* TEST_TOTLEN */\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "FFS2_NOTICE(",
          "args": [
            "wrong data CRC in data node at 0x%08x: read %#08x, calculated %#08x.\\n\",",
            "ef_offset(ref),",
            "n->data_crc,",
            "rc)"
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ef_offset(",
          "args": [
            "ef)"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rc32(",
          "args": [
            "n->partial_crc,",
            "uffer,",
            "en)"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FFS2_ERROR(",
          "args": [
            "short read at %#08x: %zd instead of %d.\\n\",",
            "fs,",
            "etlen,",
            "en)"
          ],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FFS2_ERROR(",
          "args": [
            "can not read %d bytes from 0x%08x, error code: %d.\\n\",",
            "en,",
            "fs,",
            "rr)"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_flash_read(",
          "args": [
            ",",
            "fs,",
            "en,",
            "retlen,",
            "uffer)"
          ],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nlikely(",
          "args": [
            "buffer)"
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc(",
          "args": [
            "en,",
            "FP_KERNEL)"
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FFS2_WARNING(",
          "args": [
            "MTD point failed: error code %d.\\n\",",
            "rr)"
          ],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "td_unpoint(",
          "args": [
            "->mtd,",
            "fs,",
            "etlen)"
          ],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FFS2_WARNING(",
          "args": [
            "MTD point returned len too short: %zu instead of %u.\\n\",",
            "etlen,",
            "n->csize)"
          ],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "td_point(",
          "args": [
            "->mtd,",
            "fs,",
            "en,",
            "retlen,",
            "void **)&buffer,",
            "ULL)"
          ],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bg_readinode(",
          "args": [
            "check node at %#08x, data length %u, partial CRC %#08x, correct CRC %#08x, data starts at %#08x, start checking from %#08x - %u bytes.\\n\",",
            "ef_offset(ref),",
            "n->csize,",
            "n->partial_crc,",
            "n->data_crc,",
            "fs - len,",
            "fs,",
            "en)"
          ],
          "line": 61
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ef_offset(",
          "args": [
            "ef)"
          ],
          "line": 62
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bg_readinode(",
          "args": [
            "no need to check node at %#08x, data length %u, data starts at %#08x - it has already been checked.\\n\",",
            "ef_offset(ref),",
            "n->csize,",
            "fs)"
          ],
          "line": 52
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ef_offset(",
          "args": [
            "ef)"
          ],
          "line": 53
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ikely(",
          "args": [
            "dj)"
          ],
          "line": 48
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_is_writebuffered(",
          "args": [
            ")"
          ],
          "line": 46
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ef_offset(",
          "args": [
            "ef)"
          ],
          "line": 43
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UG_ON(",
          "args": [
            "n->csize == 0)"
          ],
          "line": 40
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"nodelist.h\"\ninclude <linux/compiler.h>\n#\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/pagemap.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/fs.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/sched.h>\n#\ninclude <linux/kernel.h>\n#\n\ntatic int check_node_data(struct jffs2_sb_info *c, struct jffs2_tmp_dnode_info *tn)\n{\n\tstruct jffs2_raw_node_ref *ref = tn->fn->raw;\n\tint err = 0, pointed = 0;\n\tstruct jffs2_eraseblock *jeb;\n\tunsigned char *buffer;\n\tuint32_t crc, ofs, len;\n\tsize_t retlen;\n\n\tBUG_ON(tn->csize == 0);\n\n\t/* Calculate how many bytes were already checked */\n\tofs = ref_offset(ref) + sizeof(struct jffs2_raw_inode);\n\tlen = tn->csize;\n\n\tif (jffs2_is_writebuffered(c)) {\n\t\tint adj = ofs % c->wbuf_pagesize;\n\t\tif (likely(adj))\n\t\t\tadj = c->wbuf_pagesize - adj;\n\n\t\tif (adj >= tn->csize) {\n\t\t\tdbg_readinode(\"no need to check node at %#08x, data length %u, data starts at %#08x - it has already been checked.\\n\",\n\t\t\t\t      ref_offset(ref), tn->csize, ofs);\n\t\t\tgoto adj_acc;\n\t\t}\n\n\t\tofs += adj;\n\t\tlen -= adj;\n\t}\n\n\tdbg_readinode(\"check node at %#08x, data length %u, partial CRC %#08x, correct CRC %#08x, data starts at %#08x, start checking from %#08x - %u bytes.\\n\",\n\t\tref_offset(ref), tn->csize, tn->partial_crc, tn->data_crc, ofs - len, ofs, len);\n\n#ifndef __ECOS\n\t/* TODO: instead, incapsulate point() stuff to jffs2_flash_read(),\n\t * adding and jffs2_flash_read_end() interface. */\n\terr = mtd_point(c->mtd, ofs, len, &retlen, (void **)&buffer, NULL);\n\tif (!err && retlen < len) {\n\t\tJFFS2_WARNING(\"MTD point returned len too short: %zu instead of %u.\\n\", retlen, tn->csize);\n\t\tmtd_unpoint(c->mtd, ofs, retlen);\n\t} else if (err) {\n\t\tif (err != -EOPNOTSUPP)\n\t\t\tJFFS2_WARNING(\"MTD point failed: error code %d.\\n\", err);\n\t} else\n\t\tpointed = 1; /* succefully pointed to device */\n#endif\n\n\tif (!pointed) {\n\t\tbuffer = kmalloc(len, GFP_KERNEL);\n\t\tif (unlikely(!buffer))\n\t\t\treturn -ENOMEM;\n\n\t\t/* TODO: this is very frequent pattern, make it a separate\n\t\t * routine */\n\t\terr = jffs2_flash_read(c, ofs, len, &retlen, buffer);\n\t\tif (err) {\n\t\t\tJFFS2_ERROR(\"can not read %d bytes from 0x%08x, error code: %d.\\n\", len, ofs, err);\n\t\t\tgoto free_out;\n\t\t}\n\n\t\tif (retlen != len) {\n\t\t\tJFFS2_ERROR(\"short read at %#08x: %zd instead of %d.\\n\", ofs, retlen, len);\n\t\t\terr = -EIO;\n\t\t\tgoto free_out;\n\t\t}\n\t}\n\n\t/* Continue calculating CRC */\n\tcrc = crc32(tn->partial_crc, buffer, len);\n\tif(!pointed)\n\t\tkfree(buffer);\n#ifndef __ECOS\n\telse\n\t\tmtd_unpoint(c->mtd, ofs, len);\n#endif\n\n\tif (crc != tn->data_crc) {\n\t\tJFFS2_NOTICE(\"wrong data CRC in data node at 0x%08x: read %#08x, calculated %#08x.\\n\",\n\t\t\t     ref_offset(ref), tn->data_crc, crc);\n\t\treturn 1;\n\t}\n\nadj_acc:\n\tjeb = &c->blocks[ref->flash_offset / c->sector_size];\n\tlen = ref_totlen(c, jeb, ref);\n\t/* If it should be REF_NORMAL, it'll get marked as such when\n\t   we build the fragtree, shortly. No need to worry about GC\n\t   moving it while it's marked REF_PRISTINE -- GC won't happen\n\t   till we've finished checking every inode anyway. */\n\tref->flash_offset |= REF_PRISTINE;\n\t/*\n\t * Mark the node as having been checked and fix the\n\t * accounting accordingly.\n\t */\n\tspin_lock(&c->erase_completion_lock);\n\tjeb->used_size += len;\n\tjeb->unchecked_size -= len;\n\tc->used_size += len;\n\tc->unchecked_size -= len;\n\tjffs2_dbg_acct_paranoia_check_nolock(c, jeb);\n\tspin_unlock(&c->erase_completion_lock);\n\n\treturn 0;\n\nfree_out:\n\tif(!pointed)\n\t\tkfree(buffer);\n#ifndef __ECOS\n\telse\n\t\tmtd_unpoint(c->mtd, ofs, len);\n#endif\n\treturn err;\n}"
  }
]