[
  {
    "function_name": "hfsplus_rename_cat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/catalog.c",
    "lines": "413-520",
    "snippet": "int hfsplus_rename_cat(u32 cnid,\n\t\t       struct inode *src_dir, struct qstr *src_name,\n\t\t       struct inode *dst_dir, struct qstr *dst_name)\n{\n\tstruct super_block *sb = src_dir->i_sb;\n\tstruct hfs_find_data src_fd, dst_fd;\n\thfsplus_cat_entry entry;\n\tint entry_size, type;\n\tint err;\n\n\thfs_dbg(CAT_MOD, \"rename_cat: %u - %lu,%s - %lu,%s\\n\",\n\t\tcnid, src_dir->i_ino, src_name->name,\n\t\tdst_dir->i_ino, dst_name->name);\n\terr = hfs_find_init(HFSPLUS_SB(sb)->cat_tree, &src_fd);\n\tif (err)\n\t\treturn err;\n\tdst_fd = src_fd;\n\n\t/* find the old dir entry and read the data */\n\terr = hfsplus_cat_build_key(sb, src_fd.search_key,\n\t\t\tsrc_dir->i_ino, src_name);\n\tif (unlikely(err))\n\t\tgoto out;\n\n\terr = hfs_brec_find(&src_fd, hfs_find_rec_by_key);\n\tif (err)\n\t\tgoto out;\n\tif (src_fd.entrylength > sizeof(entry) || src_fd.entrylength < 0) {\n\t\terr = -EIO;\n\t\tgoto out;\n\t}\n\n\thfs_bnode_read(src_fd.bnode, &entry, src_fd.entryoffset,\n\t\t\t\tsrc_fd.entrylength);\n\ttype = be16_to_cpu(entry.type);\n\n\t/* create new dir entry with the data from the old entry */\n\terr = hfsplus_cat_build_key(sb, dst_fd.search_key,\n\t\t\tdst_dir->i_ino, dst_name);\n\tif (unlikely(err))\n\t\tgoto out;\n\n\terr = hfs_brec_find(&dst_fd, hfs_find_rec_by_key);\n\tif (err != -ENOENT) {\n\t\tif (!err)\n\t\t\terr = -EEXIST;\n\t\tgoto out;\n\t}\n\n\terr = hfs_brec_insert(&dst_fd, &entry, src_fd.entrylength);\n\tif (err)\n\t\tgoto out;\n\tdst_dir->i_size++;\n\tif (type == HFSPLUS_FOLDER)\n\t\thfsplus_subfolders_inc(dst_dir);\n\tdst_dir->i_mtime = dst_dir->i_ctime = CURRENT_TIME_SEC;\n\n\t/* finally remove the old entry */\n\terr = hfsplus_cat_build_key(sb, src_fd.search_key,\n\t\t\tsrc_dir->i_ino, src_name);\n\tif (unlikely(err))\n\t\tgoto out;\n\n\terr = hfs_brec_find(&src_fd, hfs_find_rec_by_key);\n\tif (err)\n\t\tgoto out;\n\terr = hfs_brec_remove(&src_fd);\n\tif (err)\n\t\tgoto out;\n\tsrc_dir->i_size--;\n\tif (type == HFSPLUS_FOLDER)\n\t\thfsplus_subfolders_dec(src_dir);\n\tsrc_dir->i_mtime = src_dir->i_ctime = CURRENT_TIME_SEC;\n\n\t/* remove old thread entry */\n\thfsplus_cat_build_key_with_cnid(sb, src_fd.search_key, cnid);\n\terr = hfs_brec_find(&src_fd, hfs_find_rec_by_key);\n\tif (err)\n\t\tgoto out;\n\ttype = hfs_bnode_read_u16(src_fd.bnode, src_fd.entryoffset);\n\terr = hfs_brec_remove(&src_fd);\n\tif (err)\n\t\tgoto out;\n\n\t/* create new thread entry */\n\thfsplus_cat_build_key_with_cnid(sb, dst_fd.search_key, cnid);\n\tentry_size = hfsplus_fill_cat_thread(sb, &entry, type,\n\t\tdst_dir->i_ino, dst_name);\n\tif (unlikely(entry_size < 0)) {\n\t\terr = entry_size;\n\t\tgoto out;\n\t}\n\n\terr = hfs_brec_find(&dst_fd, hfs_find_rec_by_key);\n\tif (err != -ENOENT) {\n\t\tif (!err)\n\t\t\terr = -EEXIST;\n\t\tgoto out;\n\t}\n\terr = hfs_brec_insert(&dst_fd, &entry, entry_size);\n\n\thfsplus_mark_inode_dirty(dst_dir, HFSPLUS_I_CAT_DIRTY);\n\thfsplus_mark_inode_dirty(src_dir, HFSPLUS_I_CAT_DIRTY);\nout:\n\thfs_bnode_put(dst_fd.bnode);\n\thfs_find_exit(&src_fd);\n\treturn err;\n}",
    "includes": [
      "#include \"hfsplus_raw.h\"",
      "#include \"hfsplus_fs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hfs_find_exit",
          "args": [
            "&src_fd"
          ],
          "line": 518
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_find_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/bfind.c",
          "lines": "43-51",
          "snippet": "void hfs_find_exit(struct hfs_find_data *fd)\n{\n\thfs_bnode_put(fd->bnode);\n\tkfree(fd->search_key);\n\thfs_dbg(BNODE_REFS, \"find_exit: %d (%p)\\n\",\n\t\tfd->tree->cnid, __builtin_return_address(0));\n\tmutex_unlock(&fd->tree->tree_lock);\n\tfd->tree = NULL;\n}",
          "includes": [
            "#include \"hfsplus_fs.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_fs.h\"\n#include <linux/slab.h>\n\nvoid hfs_find_exit(struct hfs_find_data *fd)\n{\n\thfs_bnode_put(fd->bnode);\n\tkfree(fd->search_key);\n\thfs_dbg(BNODE_REFS, \"find_exit: %d (%p)\\n\",\n\t\tfd->tree->cnid, __builtin_return_address(0));\n\tmutex_unlock(&fd->tree->tree_lock);\n\tfd->tree = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfs_bnode_put",
          "args": [
            "dst_fd.bnode"
          ],
          "line": 517
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_bnode_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/bnode.c",
          "lines": "628-657",
          "snippet": "void hfs_bnode_put(struct hfs_bnode *node)\n{\n\tif (node) {\n\t\tstruct hfs_btree *tree = node->tree;\n\t\tint i;\n\n\t\thfs_dbg(BNODE_REFS, \"put_node(%d:%d): %d\\n\",\n\t\t\tnode->tree->cnid, node->this,\n\t\t\tatomic_read(&node->refcnt));\n\t\tBUG_ON(!atomic_read(&node->refcnt));\n\t\tif (!atomic_dec_and_lock(&node->refcnt, &tree->hash_lock))\n\t\t\treturn;\n\t\tfor (i = 0; i < tree->pages_per_bnode; i++) {\n\t\t\tif (!node->page[i])\n\t\t\t\tcontinue;\n\t\t\tmark_page_accessed(node->page[i]);\n\t\t}\n\n\t\tif (test_bit(HFS_BNODE_DELETED, &node->flags)) {\n\t\t\thfs_bnode_unhash(node);\n\t\t\tspin_unlock(&tree->hash_lock);\n\t\t\tif (hfs_bnode_need_zeroout(tree))\n\t\t\t\thfs_bnode_clear(node, 0, tree->node_size);\n\t\t\thfs_bmap_free(node);\n\t\t\thfs_bnode_free(node);\n\t\t\treturn;\n\t\t}\n\t\tspin_unlock(&tree->hash_lock);\n\t}\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/swap.h>\n#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nvoid hfs_bnode_put(struct hfs_bnode *node)\n{\n\tif (node) {\n\t\tstruct hfs_btree *tree = node->tree;\n\t\tint i;\n\n\t\thfs_dbg(BNODE_REFS, \"put_node(%d:%d): %d\\n\",\n\t\t\tnode->tree->cnid, node->this,\n\t\t\tatomic_read(&node->refcnt));\n\t\tBUG_ON(!atomic_read(&node->refcnt));\n\t\tif (!atomic_dec_and_lock(&node->refcnt, &tree->hash_lock))\n\t\t\treturn;\n\t\tfor (i = 0; i < tree->pages_per_bnode; i++) {\n\t\t\tif (!node->page[i])\n\t\t\t\tcontinue;\n\t\t\tmark_page_accessed(node->page[i]);\n\t\t}\n\n\t\tif (test_bit(HFS_BNODE_DELETED, &node->flags)) {\n\t\t\thfs_bnode_unhash(node);\n\t\t\tspin_unlock(&tree->hash_lock);\n\t\t\tif (hfs_bnode_need_zeroout(tree))\n\t\t\t\thfs_bnode_clear(node, 0, tree->node_size);\n\t\t\thfs_bmap_free(node);\n\t\t\thfs_bnode_free(node);\n\t\t\treturn;\n\t\t}\n\t\tspin_unlock(&tree->hash_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfsplus_mark_inode_dirty",
          "args": [
            "src_dir",
            "HFSPLUS_I_CAT_DIRTY"
          ],
          "line": 515
        },
        "resolved": true,
        "details": {
          "function_name": "hfsplus_mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/hfsplus_fs.h",
          "lines": "275-280",
          "snippet": "static inline void hfsplus_mark_inode_dirty(struct inode *inode,\n\t\tunsigned int flag)\n{\n\tset_bit(flag, &HFSPLUS_I(inode)->flags);\n\tmark_inode_dirty(inode);\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mutex.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/mutex.h>\n#include <linux/fs.h>\n\nstatic inline void hfsplus_mark_inode_dirty(struct inode *inode,\n\t\tunsigned int flag)\n{\n\tset_bit(flag, &HFSPLUS_I(inode)->flags);\n\tmark_inode_dirty(inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfs_brec_insert",
          "args": [
            "&dst_fd",
            "&entry",
            "entry_size"
          ],
          "line": 512
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_brec_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/brec.c",
          "lines": "62-175",
          "snippet": "int hfs_brec_insert(struct hfs_find_data *fd, void *entry, int entry_len)\n{\n\tstruct hfs_btree *tree;\n\tstruct hfs_bnode *node, *new_node;\n\tint size, key_len, rec;\n\tint data_off, end_off;\n\tint idx_rec_off, data_rec_off, end_rec_off;\n\t__be32 cnid;\n\n\ttree = fd->tree;\n\tif (!fd->bnode) {\n\t\tif (!tree->root)\n\t\t\thfs_btree_inc_height(tree);\n\t\tfd->bnode = hfs_bnode_find(tree, tree->leaf_head);\n\t\tif (IS_ERR(fd->bnode))\n\t\t\treturn PTR_ERR(fd->bnode);\n\t\tfd->record = -1;\n\t}\n\tnew_node = NULL;\n\tkey_len = be16_to_cpu(fd->search_key->key_len) + 2;\nagain:\n\t/* new record idx and complete record size */\n\trec = fd->record + 1;\n\tsize = key_len + entry_len;\n\n\tnode = fd->bnode;\n\thfs_bnode_dump(node);\n\t/* get last offset */\n\tend_rec_off = tree->node_size - (node->num_recs + 1) * 2;\n\tend_off = hfs_bnode_read_u16(node, end_rec_off);\n\tend_rec_off -= 2;\n\thfs_dbg(BNODE_MOD, \"insert_rec: %d, %d, %d, %d\\n\",\n\t\trec, size, end_off, end_rec_off);\n\tif (size > end_rec_off - end_off) {\n\t\tif (new_node)\n\t\t\tpanic(\"not enough room!\\n\");\n\t\tnew_node = hfs_bnode_split(fd);\n\t\tif (IS_ERR(new_node))\n\t\t\treturn PTR_ERR(new_node);\n\t\tgoto again;\n\t}\n\tif (node->type == HFS_NODE_LEAF) {\n\t\ttree->leaf_count++;\n\t\tmark_inode_dirty(tree->inode);\n\t}\n\tnode->num_recs++;\n\t/* write new last offset */\n\thfs_bnode_write_u16(node,\n\t\toffsetof(struct hfs_bnode_desc, num_recs),\n\t\tnode->num_recs);\n\thfs_bnode_write_u16(node, end_rec_off, end_off + size);\n\tdata_off = end_off;\n\tdata_rec_off = end_rec_off + 2;\n\tidx_rec_off = tree->node_size - (rec + 1) * 2;\n\tif (idx_rec_off == data_rec_off)\n\t\tgoto skip;\n\t/* move all following entries */\n\tdo {\n\t\tdata_off = hfs_bnode_read_u16(node, data_rec_off + 2);\n\t\thfs_bnode_write_u16(node, data_rec_off, data_off + size);\n\t\tdata_rec_off += 2;\n\t} while (data_rec_off < idx_rec_off);\n\n\t/* move data away */\n\thfs_bnode_move(node, data_off + size, data_off,\n\t\t       end_off - data_off);\n\nskip:\n\thfs_bnode_write(node, fd->search_key, data_off, key_len);\n\thfs_bnode_write(node, entry, data_off + key_len, entry_len);\n\thfs_bnode_dump(node);\n\n\t/*\n\t * update parent key if we inserted a key\n\t * at the start of the node and it is not the new node\n\t */\n\tif (!rec && new_node != node) {\n\t\thfs_bnode_read_key(node, fd->search_key, data_off + size);\n\t\thfs_brec_update_parent(fd);\n\t}\n\n\tif (new_node) {\n\t\thfs_bnode_put(fd->bnode);\n\t\tif (!new_node->parent) {\n\t\t\thfs_btree_inc_height(tree);\n\t\t\tnew_node->parent = tree->root;\n\t\t}\n\t\tfd->bnode = hfs_bnode_find(tree, new_node->parent);\n\n\t\t/* create index data entry */\n\t\tcnid = cpu_to_be32(new_node->this);\n\t\tentry = &cnid;\n\t\tentry_len = sizeof(cnid);\n\n\t\t/* get index key */\n\t\thfs_bnode_read_key(new_node, fd->search_key, 14);\n\t\t__hfs_brec_find(fd->bnode, fd, hfs_find_rec_by_key);\n\n\t\thfs_bnode_put(new_node);\n\t\tnew_node = NULL;\n\n\t\tif ((tree->attributes & HFS_TREE_VARIDXKEYS) ||\n\t\t\t\t(tree->cnid == HFSPLUS_ATTR_CNID))\n\t\t\tkey_len = be16_to_cpu(fd->search_key->key_len) + 2;\n\t\telse {\n\t\t\tfd->search_key->key_len =\n\t\t\t\tcpu_to_be16(tree->max_key_len);\n\t\t\tkey_len = tree->max_key_len + 2;\n\t\t}\n\t\tgoto again;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hfs_bnode *hfs_bnode_split(struct hfs_find_data *fd);",
            "static int hfs_brec_update_parent(struct hfs_find_data *fd);",
            "static int hfs_btree_inc_height(struct hfs_btree *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n\nstatic struct hfs_bnode *hfs_bnode_split(struct hfs_find_data *fd);\nstatic int hfs_brec_update_parent(struct hfs_find_data *fd);\nstatic int hfs_btree_inc_height(struct hfs_btree *);\n\nint hfs_brec_insert(struct hfs_find_data *fd, void *entry, int entry_len)\n{\n\tstruct hfs_btree *tree;\n\tstruct hfs_bnode *node, *new_node;\n\tint size, key_len, rec;\n\tint data_off, end_off;\n\tint idx_rec_off, data_rec_off, end_rec_off;\n\t__be32 cnid;\n\n\ttree = fd->tree;\n\tif (!fd->bnode) {\n\t\tif (!tree->root)\n\t\t\thfs_btree_inc_height(tree);\n\t\tfd->bnode = hfs_bnode_find(tree, tree->leaf_head);\n\t\tif (IS_ERR(fd->bnode))\n\t\t\treturn PTR_ERR(fd->bnode);\n\t\tfd->record = -1;\n\t}\n\tnew_node = NULL;\n\tkey_len = be16_to_cpu(fd->search_key->key_len) + 2;\nagain:\n\t/* new record idx and complete record size */\n\trec = fd->record + 1;\n\tsize = key_len + entry_len;\n\n\tnode = fd->bnode;\n\thfs_bnode_dump(node);\n\t/* get last offset */\n\tend_rec_off = tree->node_size - (node->num_recs + 1) * 2;\n\tend_off = hfs_bnode_read_u16(node, end_rec_off);\n\tend_rec_off -= 2;\n\thfs_dbg(BNODE_MOD, \"insert_rec: %d, %d, %d, %d\\n\",\n\t\trec, size, end_off, end_rec_off);\n\tif (size > end_rec_off - end_off) {\n\t\tif (new_node)\n\t\t\tpanic(\"not enough room!\\n\");\n\t\tnew_node = hfs_bnode_split(fd);\n\t\tif (IS_ERR(new_node))\n\t\t\treturn PTR_ERR(new_node);\n\t\tgoto again;\n\t}\n\tif (node->type == HFS_NODE_LEAF) {\n\t\ttree->leaf_count++;\n\t\tmark_inode_dirty(tree->inode);\n\t}\n\tnode->num_recs++;\n\t/* write new last offset */\n\thfs_bnode_write_u16(node,\n\t\toffsetof(struct hfs_bnode_desc, num_recs),\n\t\tnode->num_recs);\n\thfs_bnode_write_u16(node, end_rec_off, end_off + size);\n\tdata_off = end_off;\n\tdata_rec_off = end_rec_off + 2;\n\tidx_rec_off = tree->node_size - (rec + 1) * 2;\n\tif (idx_rec_off == data_rec_off)\n\t\tgoto skip;\n\t/* move all following entries */\n\tdo {\n\t\tdata_off = hfs_bnode_read_u16(node, data_rec_off + 2);\n\t\thfs_bnode_write_u16(node, data_rec_off, data_off + size);\n\t\tdata_rec_off += 2;\n\t} while (data_rec_off < idx_rec_off);\n\n\t/* move data away */\n\thfs_bnode_move(node, data_off + size, data_off,\n\t\t       end_off - data_off);\n\nskip:\n\thfs_bnode_write(node, fd->search_key, data_off, key_len);\n\thfs_bnode_write(node, entry, data_off + key_len, entry_len);\n\thfs_bnode_dump(node);\n\n\t/*\n\t * update parent key if we inserted a key\n\t * at the start of the node and it is not the new node\n\t */\n\tif (!rec && new_node != node) {\n\t\thfs_bnode_read_key(node, fd->search_key, data_off + size);\n\t\thfs_brec_update_parent(fd);\n\t}\n\n\tif (new_node) {\n\t\thfs_bnode_put(fd->bnode);\n\t\tif (!new_node->parent) {\n\t\t\thfs_btree_inc_height(tree);\n\t\t\tnew_node->parent = tree->root;\n\t\t}\n\t\tfd->bnode = hfs_bnode_find(tree, new_node->parent);\n\n\t\t/* create index data entry */\n\t\tcnid = cpu_to_be32(new_node->this);\n\t\tentry = &cnid;\n\t\tentry_len = sizeof(cnid);\n\n\t\t/* get index key */\n\t\thfs_bnode_read_key(new_node, fd->search_key, 14);\n\t\t__hfs_brec_find(fd->bnode, fd, hfs_find_rec_by_key);\n\n\t\thfs_bnode_put(new_node);\n\t\tnew_node = NULL;\n\n\t\tif ((tree->attributes & HFS_TREE_VARIDXKEYS) ||\n\t\t\t\t(tree->cnid == HFSPLUS_ATTR_CNID))\n\t\t\tkey_len = be16_to_cpu(fd->search_key->key_len) + 2;\n\t\telse {\n\t\t\tfd->search_key->key_len =\n\t\t\t\tcpu_to_be16(tree->max_key_len);\n\t\t\tkey_len = tree->max_key_len + 2;\n\t\t}\n\t\tgoto again;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfs_brec_find",
          "args": [
            "&dst_fd",
            "hfs_find_rec_by_key"
          ],
          "line": 506
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_brec_find",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/bfind.c",
          "lines": "165-217",
          "snippet": "int hfs_brec_find(struct hfs_find_data *fd, search_strategy_t do_key_compare)\n{\n\tstruct hfs_btree *tree;\n\tstruct hfs_bnode *bnode;\n\tu32 nidx, parent;\n\t__be32 data;\n\tint height, res;\n\n\ttree = fd->tree;\n\tif (fd->bnode)\n\t\thfs_bnode_put(fd->bnode);\n\tfd->bnode = NULL;\n\tnidx = tree->root;\n\tif (!nidx)\n\t\treturn -ENOENT;\n\theight = tree->depth;\n\tres = 0;\n\tparent = 0;\n\tfor (;;) {\n\t\tbnode = hfs_bnode_find(tree, nidx);\n\t\tif (IS_ERR(bnode)) {\n\t\t\tres = PTR_ERR(bnode);\n\t\t\tbnode = NULL;\n\t\t\tbreak;\n\t\t}\n\t\tif (bnode->height != height)\n\t\t\tgoto invalid;\n\t\tif (bnode->type != (--height ? HFS_NODE_INDEX : HFS_NODE_LEAF))\n\t\t\tgoto invalid;\n\t\tbnode->parent = parent;\n\n\t\tres = __hfs_brec_find(bnode, fd, do_key_compare);\n\t\tif (!height)\n\t\t\tbreak;\n\t\tif (fd->record < 0)\n\t\t\tgoto release;\n\n\t\tparent = nidx;\n\t\thfs_bnode_read(bnode, &data, fd->entryoffset, 4);\n\t\tnidx = be32_to_cpu(data);\n\t\thfs_bnode_put(bnode);\n\t}\n\tfd->bnode = bnode;\n\treturn res;\n\ninvalid:\n\tpr_err(\"inconsistency in B*Tree (%d,%d,%d,%u,%u)\\n\",\n\t\theight, bnode->height, bnode->type, nidx, parent);\n\tres = -EIO;\nrelease:\n\thfs_bnode_put(bnode);\n\treturn res;\n}",
          "includes": [
            "#include \"hfsplus_fs.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_fs.h\"\n#include <linux/slab.h>\n\nint hfs_brec_find(struct hfs_find_data *fd, search_strategy_t do_key_compare)\n{\n\tstruct hfs_btree *tree;\n\tstruct hfs_bnode *bnode;\n\tu32 nidx, parent;\n\t__be32 data;\n\tint height, res;\n\n\ttree = fd->tree;\n\tif (fd->bnode)\n\t\thfs_bnode_put(fd->bnode);\n\tfd->bnode = NULL;\n\tnidx = tree->root;\n\tif (!nidx)\n\t\treturn -ENOENT;\n\theight = tree->depth;\n\tres = 0;\n\tparent = 0;\n\tfor (;;) {\n\t\tbnode = hfs_bnode_find(tree, nidx);\n\t\tif (IS_ERR(bnode)) {\n\t\t\tres = PTR_ERR(bnode);\n\t\t\tbnode = NULL;\n\t\t\tbreak;\n\t\t}\n\t\tif (bnode->height != height)\n\t\t\tgoto invalid;\n\t\tif (bnode->type != (--height ? HFS_NODE_INDEX : HFS_NODE_LEAF))\n\t\t\tgoto invalid;\n\t\tbnode->parent = parent;\n\n\t\tres = __hfs_brec_find(bnode, fd, do_key_compare);\n\t\tif (!height)\n\t\t\tbreak;\n\t\tif (fd->record < 0)\n\t\t\tgoto release;\n\n\t\tparent = nidx;\n\t\thfs_bnode_read(bnode, &data, fd->entryoffset, 4);\n\t\tnidx = be32_to_cpu(data);\n\t\thfs_bnode_put(bnode);\n\t}\n\tfd->bnode = bnode;\n\treturn res;\n\ninvalid:\n\tpr_err(\"inconsistency in B*Tree (%d,%d,%d,%u,%u)\\n\",\n\t\theight, bnode->height, bnode->type, nidx, parent);\n\tres = -EIO;\nrelease:\n\thfs_bnode_put(bnode);\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "entry_size < 0"
          ],
          "line": 501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfsplus_fill_cat_thread",
          "args": [
            "sb",
            "&entry",
            "type",
            "dst_dir->i_ino",
            "dst_name"
          ],
          "line": 499
        },
        "resolved": true,
        "details": {
          "function_name": "hfsplus_fill_cat_thread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/catalog.c",
          "lines": "175-190",
          "snippet": "static int hfsplus_fill_cat_thread(struct super_block *sb,\n\t\t\t\t   hfsplus_cat_entry *entry, int type,\n\t\t\t\t   u32 parentid, struct qstr *str)\n{\n\tint err;\n\n\tentry->type = cpu_to_be16(type);\n\tentry->thread.reserved = 0;\n\tentry->thread.parentID = cpu_to_be32(parentid);\n\terr = hfsplus_asc2uni(sb, &entry->thread.nodeName, HFSPLUS_MAX_STRLEN,\n\t\t\t\tstr->name, str->len);\n\tif (unlikely(err < 0))\n\t\treturn err;\n\n\treturn 10 + be16_to_cpu(entry->thread.nodeName.length) * 2;\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n\nstatic int hfsplus_fill_cat_thread(struct super_block *sb,\n\t\t\t\t   hfsplus_cat_entry *entry, int type,\n\t\t\t\t   u32 parentid, struct qstr *str)\n{\n\tint err;\n\n\tentry->type = cpu_to_be16(type);\n\tentry->thread.reserved = 0;\n\tentry->thread.parentID = cpu_to_be32(parentid);\n\terr = hfsplus_asc2uni(sb, &entry->thread.nodeName, HFSPLUS_MAX_STRLEN,\n\t\t\t\tstr->name, str->len);\n\tif (unlikely(err < 0))\n\t\treturn err;\n\n\treturn 10 + be16_to_cpu(entry->thread.nodeName.length) * 2;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfsplus_cat_build_key_with_cnid",
          "args": [
            "sb",
            "dst_fd.search_key",
            "cnid"
          ],
          "line": 498
        },
        "resolved": true,
        "details": {
          "function_name": "hfsplus_cat_build_key_with_cnid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/catalog.c",
          "lines": "59-65",
          "snippet": "void hfsplus_cat_build_key_with_cnid(struct super_block *sb,\n\t\t\thfsplus_btree_key *key, u32 parent)\n{\n\tkey->cat.parent = cpu_to_be32(parent);\n\tkey->cat.name.length = 0;\n\tkey->key_len = cpu_to_be16(6);\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n\nvoid hfsplus_cat_build_key_with_cnid(struct super_block *sb,\n\t\t\thfsplus_btree_key *key, u32 parent)\n{\n\tkey->cat.parent = cpu_to_be32(parent);\n\tkey->cat.name.length = 0;\n\tkey->key_len = cpu_to_be16(6);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfs_brec_remove",
          "args": [
            "&src_fd"
          ],
          "line": 493
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_brec_remove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/brec.c",
          "lines": "177-231",
          "snippet": "int hfs_brec_remove(struct hfs_find_data *fd)\n{\n\tstruct hfs_btree *tree;\n\tstruct hfs_bnode *node, *parent;\n\tint end_off, rec_off, data_off, size;\n\n\ttree = fd->tree;\n\tnode = fd->bnode;\nagain:\n\trec_off = tree->node_size - (fd->record + 2) * 2;\n\tend_off = tree->node_size - (node->num_recs + 1) * 2;\n\n\tif (node->type == HFS_NODE_LEAF) {\n\t\ttree->leaf_count--;\n\t\tmark_inode_dirty(tree->inode);\n\t}\n\thfs_bnode_dump(node);\n\thfs_dbg(BNODE_MOD, \"remove_rec: %d, %d\\n\",\n\t\tfd->record, fd->keylength + fd->entrylength);\n\tif (!--node->num_recs) {\n\t\thfs_bnode_unlink(node);\n\t\tif (!node->parent)\n\t\t\treturn 0;\n\t\tparent = hfs_bnode_find(tree, node->parent);\n\t\tif (IS_ERR(parent))\n\t\t\treturn PTR_ERR(parent);\n\t\thfs_bnode_put(node);\n\t\tnode = fd->bnode = parent;\n\n\t\t__hfs_brec_find(node, fd, hfs_find_rec_by_key);\n\t\tgoto again;\n\t}\n\thfs_bnode_write_u16(node,\n\t\toffsetof(struct hfs_bnode_desc, num_recs),\n\t\tnode->num_recs);\n\n\tif (rec_off == end_off)\n\t\tgoto skip;\n\tsize = fd->keylength + fd->entrylength;\n\n\tdo {\n\t\tdata_off = hfs_bnode_read_u16(node, rec_off);\n\t\thfs_bnode_write_u16(node, rec_off + 2, data_off - size);\n\t\trec_off -= 2;\n\t} while (rec_off >= end_off);\n\n\t/* fill hole */\n\thfs_bnode_move(node, fd->keyoffset, fd->keyoffset + size,\n\t\t       data_off - fd->keyoffset - size);\nskip:\n\thfs_bnode_dump(node);\n\tif (!fd->record)\n\t\thfs_brec_update_parent(fd);\n\treturn 0;\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hfs_bnode *hfs_bnode_split(struct hfs_find_data *fd);",
            "static int hfs_brec_update_parent(struct hfs_find_data *fd);",
            "static int hfs_btree_inc_height(struct hfs_btree *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n\nstatic struct hfs_bnode *hfs_bnode_split(struct hfs_find_data *fd);\nstatic int hfs_brec_update_parent(struct hfs_find_data *fd);\nstatic int hfs_btree_inc_height(struct hfs_btree *);\n\nint hfs_brec_remove(struct hfs_find_data *fd)\n{\n\tstruct hfs_btree *tree;\n\tstruct hfs_bnode *node, *parent;\n\tint end_off, rec_off, data_off, size;\n\n\ttree = fd->tree;\n\tnode = fd->bnode;\nagain:\n\trec_off = tree->node_size - (fd->record + 2) * 2;\n\tend_off = tree->node_size - (node->num_recs + 1) * 2;\n\n\tif (node->type == HFS_NODE_LEAF) {\n\t\ttree->leaf_count--;\n\t\tmark_inode_dirty(tree->inode);\n\t}\n\thfs_bnode_dump(node);\n\thfs_dbg(BNODE_MOD, \"remove_rec: %d, %d\\n\",\n\t\tfd->record, fd->keylength + fd->entrylength);\n\tif (!--node->num_recs) {\n\t\thfs_bnode_unlink(node);\n\t\tif (!node->parent)\n\t\t\treturn 0;\n\t\tparent = hfs_bnode_find(tree, node->parent);\n\t\tif (IS_ERR(parent))\n\t\t\treturn PTR_ERR(parent);\n\t\thfs_bnode_put(node);\n\t\tnode = fd->bnode = parent;\n\n\t\t__hfs_brec_find(node, fd, hfs_find_rec_by_key);\n\t\tgoto again;\n\t}\n\thfs_bnode_write_u16(node,\n\t\toffsetof(struct hfs_bnode_desc, num_recs),\n\t\tnode->num_recs);\n\n\tif (rec_off == end_off)\n\t\tgoto skip;\n\tsize = fd->keylength + fd->entrylength;\n\n\tdo {\n\t\tdata_off = hfs_bnode_read_u16(node, rec_off);\n\t\thfs_bnode_write_u16(node, rec_off + 2, data_off - size);\n\t\trec_off -= 2;\n\t} while (rec_off >= end_off);\n\n\t/* fill hole */\n\thfs_bnode_move(node, fd->keyoffset, fd->keyoffset + size,\n\t\t       data_off - fd->keyoffset - size);\nskip:\n\thfs_bnode_dump(node);\n\tif (!fd->record)\n\t\thfs_brec_update_parent(fd);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfs_bnode_read_u16",
          "args": [
            "src_fd.bnode",
            "src_fd.entryoffset"
          ],
          "line": 492
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_bnode_read_u16",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/bnode.c",
          "lines": "42-48",
          "snippet": "u16 hfs_bnode_read_u16(struct hfs_bnode *node, int off)\n{\n\t__be16 data;\n\t/* TODO: optimize later... */\n\thfs_bnode_read(node, &data, off, 2);\n\treturn be16_to_cpu(data);\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/swap.h>\n#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nu16 hfs_bnode_read_u16(struct hfs_bnode *node, int off)\n{\n\t__be16 data;\n\t/* TODO: optimize later... */\n\thfs_bnode_read(node, &data, off, 2);\n\treturn be16_to_cpu(data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfsplus_subfolders_dec",
          "args": [
            "src_dir"
          ],
          "line": 484
        },
        "resolved": true,
        "details": {
          "function_name": "hfsplus_subfolders_dec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/catalog.c",
          "lines": "235-250",
          "snippet": "static void hfsplus_subfolders_dec(struct inode *dir)\n{\n\tstruct hfsplus_sb_info *sbi = HFSPLUS_SB(dir->i_sb);\n\n\tif (test_bit(HFSPLUS_SB_HFSX, &sbi->flags)) {\n\t\t/*\n\t\t * Decrement subfolder count. Note, the value is only meaningful\n\t\t * for folders with HFSPLUS_HAS_FOLDER_COUNT flag set.\n\t\t *\n\t\t * Check for zero. Some subfolders may have been created\n\t\t * by an implementation ignorant of this counter.\n\t\t */\n\t\tif (HFSPLUS_I(dir)->subfolders)\n\t\t\tHFSPLUS_I(dir)->subfolders--;\n\t}\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n\nstatic void hfsplus_subfolders_dec(struct inode *dir)\n{\n\tstruct hfsplus_sb_info *sbi = HFSPLUS_SB(dir->i_sb);\n\n\tif (test_bit(HFSPLUS_SB_HFSX, &sbi->flags)) {\n\t\t/*\n\t\t * Decrement subfolder count. Note, the value is only meaningful\n\t\t * for folders with HFSPLUS_HAS_FOLDER_COUNT flag set.\n\t\t *\n\t\t * Check for zero. Some subfolders may have been created\n\t\t * by an implementation ignorant of this counter.\n\t\t */\n\t\tif (HFSPLUS_I(dir)->subfolders)\n\t\t\tHFSPLUS_I(dir)->subfolders--;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "err"
          ],
          "line": 473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfsplus_cat_build_key",
          "args": [
            "sb",
            "src_fd.search_key",
            "src_dir->i_ino",
            "src_name"
          ],
          "line": 471
        },
        "resolved": true,
        "details": {
          "function_name": "hfsplus_cat_build_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/catalog.c",
          "lines": "42-56",
          "snippet": "int hfsplus_cat_build_key(struct super_block *sb,\n\t\thfsplus_btree_key *key, u32 parent, struct qstr *str)\n{\n\tint len, err;\n\n\tkey->cat.parent = cpu_to_be32(parent);\n\terr = hfsplus_asc2uni(sb, &key->cat.name, HFSPLUS_MAX_STRLEN,\n\t\t\tstr->name, str->len);\n\tif (unlikely(err < 0))\n\t\treturn err;\n\n\tlen = be16_to_cpu(key->cat.name.length);\n\tkey->key_len = cpu_to_be16(6 + 2 * len);\n\treturn 0;\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n\nint hfsplus_cat_build_key(struct super_block *sb,\n\t\thfsplus_btree_key *key, u32 parent, struct qstr *str)\n{\n\tint len, err;\n\n\tkey->cat.parent = cpu_to_be32(parent);\n\terr = hfsplus_asc2uni(sb, &key->cat.name, HFSPLUS_MAX_STRLEN,\n\t\t\tstr->name, str->len);\n\tif (unlikely(err < 0))\n\t\treturn err;\n\n\tlen = be16_to_cpu(key->cat.name.length);\n\tkey->key_len = cpu_to_be16(6 + 2 * len);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfsplus_subfolders_inc",
          "args": [
            "dst_dir"
          ],
          "line": 467
        },
        "resolved": true,
        "details": {
          "function_name": "hfsplus_subfolders_inc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/catalog.c",
          "lines": "222-233",
          "snippet": "static void hfsplus_subfolders_inc(struct inode *dir)\n{\n\tstruct hfsplus_sb_info *sbi = HFSPLUS_SB(dir->i_sb);\n\n\tif (test_bit(HFSPLUS_SB_HFSX, &sbi->flags)) {\n\t\t/*\n\t\t * Increment subfolder count. Note, the value is only meaningful\n\t\t * for folders with HFSPLUS_HAS_FOLDER_COUNT flag set.\n\t\t */\n\t\tHFSPLUS_I(dir)->subfolders++;\n\t}\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n\nstatic void hfsplus_subfolders_inc(struct inode *dir)\n{\n\tstruct hfsplus_sb_info *sbi = HFSPLUS_SB(dir->i_sb);\n\n\tif (test_bit(HFSPLUS_SB_HFSX, &sbi->flags)) {\n\t\t/*\n\t\t * Increment subfolder count. Note, the value is only meaningful\n\t\t * for folders with HFSPLUS_HAS_FOLDER_COUNT flag set.\n\t\t */\n\t\tHFSPLUS_I(dir)->subfolders++;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "err"
          ],
          "line": 452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "entry.type"
          ],
          "line": 447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfs_bnode_read",
          "args": [
            "src_fd.bnode",
            "&entry",
            "src_fd.entryoffset",
            "src_fd.entrylength"
          ],
          "line": 445
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_bnode_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/bnode.c",
          "lines": "21-40",
          "snippet": "void hfs_bnode_read(struct hfs_bnode *node, void *buf, int off, int len)\n{\n\tstruct page **pagep;\n\tint l;\n\n\toff += node->page_offset;\n\tpagep = node->page + (off >> PAGE_CACHE_SHIFT);\n\toff &= ~PAGE_CACHE_MASK;\n\n\tl = min_t(int, len, PAGE_CACHE_SIZE - off);\n\tmemcpy(buf, kmap(*pagep) + off, l);\n\tkunmap(*pagep);\n\n\twhile ((len -= l) != 0) {\n\t\tbuf += l;\n\t\tl = min_t(int, len, PAGE_CACHE_SIZE);\n\t\tmemcpy(buf, kmap(*++pagep), l);\n\t\tkunmap(*pagep);\n\t}\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/swap.h>\n#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nvoid hfs_bnode_read(struct hfs_bnode *node, void *buf, int off, int len)\n{\n\tstruct page **pagep;\n\tint l;\n\n\toff += node->page_offset;\n\tpagep = node->page + (off >> PAGE_CACHE_SHIFT);\n\toff &= ~PAGE_CACHE_MASK;\n\n\tl = min_t(int, len, PAGE_CACHE_SIZE - off);\n\tmemcpy(buf, kmap(*pagep) + off, l);\n\tkunmap(*pagep);\n\n\twhile ((len -= l) != 0) {\n\t\tbuf += l;\n\t\tl = min_t(int, len, PAGE_CACHE_SIZE);\n\t\tmemcpy(buf, kmap(*++pagep), l);\n\t\tkunmap(*pagep);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "err"
          ],
          "line": 434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfs_find_init",
          "args": [
            "HFSPLUS_SB(sb)->cat_tree",
            "&src_fd"
          ],
          "line": 426
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_find_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/bfind.c",
          "lines": "14-41",
          "snippet": "int hfs_find_init(struct hfs_btree *tree, struct hfs_find_data *fd)\n{\n\tvoid *ptr;\n\n\tfd->tree = tree;\n\tfd->bnode = NULL;\n\tptr = kmalloc(tree->max_key_len * 2 + 4, GFP_KERNEL);\n\tif (!ptr)\n\t\treturn -ENOMEM;\n\tfd->search_key = ptr;\n\tfd->key = ptr + tree->max_key_len + 2;\n\thfs_dbg(BNODE_REFS, \"find_init: %d (%p)\\n\",\n\t\ttree->cnid, __builtin_return_address(0));\n\tswitch (tree->cnid) {\n\tcase HFSPLUS_CAT_CNID:\n\t\tmutex_lock_nested(&tree->tree_lock, CATALOG_BTREE_MUTEX);\n\t\tbreak;\n\tcase HFSPLUS_EXT_CNID:\n\t\tmutex_lock_nested(&tree->tree_lock, EXTENTS_BTREE_MUTEX);\n\t\tbreak;\n\tcase HFSPLUS_ATTR_CNID:\n\t\tmutex_lock_nested(&tree->tree_lock, ATTR_BTREE_MUTEX);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"hfsplus_fs.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_fs.h\"\n#include <linux/slab.h>\n\nint hfs_find_init(struct hfs_btree *tree, struct hfs_find_data *fd)\n{\n\tvoid *ptr;\n\n\tfd->tree = tree;\n\tfd->bnode = NULL;\n\tptr = kmalloc(tree->max_key_len * 2 + 4, GFP_KERNEL);\n\tif (!ptr)\n\t\treturn -ENOMEM;\n\tfd->search_key = ptr;\n\tfd->key = ptr + tree->max_key_len + 2;\n\thfs_dbg(BNODE_REFS, \"find_init: %d (%p)\\n\",\n\t\ttree->cnid, __builtin_return_address(0));\n\tswitch (tree->cnid) {\n\tcase HFSPLUS_CAT_CNID:\n\t\tmutex_lock_nested(&tree->tree_lock, CATALOG_BTREE_MUTEX);\n\t\tbreak;\n\tcase HFSPLUS_EXT_CNID:\n\t\tmutex_lock_nested(&tree->tree_lock, EXTENTS_BTREE_MUTEX);\n\t\tbreak;\n\tcase HFSPLUS_ATTR_CNID:\n\t\tmutex_lock_nested(&tree->tree_lock, ATTR_BTREE_MUTEX);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "HFSPLUS_SB",
          "args": [
            "sb"
          ],
          "line": 426
        },
        "resolved": true,
        "details": {
          "function_name": "HFSPLUS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/hfsplus_fs.h",
          "lines": "202-205",
          "snippet": "static inline struct hfsplus_sb_info *HFSPLUS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mutex.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/mutex.h>\n#include <linux/fs.h>\n\nstatic inline struct hfsplus_sb_info *HFSPLUS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfs_dbg",
          "args": [
            "CAT_MOD",
            "\"rename_cat: %u - %lu,%s - %lu,%s\\n\"",
            "cnid",
            "src_dir->i_ino",
            "src_name->name",
            "dst_dir->i_ino",
            "dst_name->name"
          ],
          "line": 423
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n\nint hfsplus_rename_cat(u32 cnid,\n\t\t       struct inode *src_dir, struct qstr *src_name,\n\t\t       struct inode *dst_dir, struct qstr *dst_name)\n{\n\tstruct super_block *sb = src_dir->i_sb;\n\tstruct hfs_find_data src_fd, dst_fd;\n\thfsplus_cat_entry entry;\n\tint entry_size, type;\n\tint err;\n\n\thfs_dbg(CAT_MOD, \"rename_cat: %u - %lu,%s - %lu,%s\\n\",\n\t\tcnid, src_dir->i_ino, src_name->name,\n\t\tdst_dir->i_ino, dst_name->name);\n\terr = hfs_find_init(HFSPLUS_SB(sb)->cat_tree, &src_fd);\n\tif (err)\n\t\treturn err;\n\tdst_fd = src_fd;\n\n\t/* find the old dir entry and read the data */\n\terr = hfsplus_cat_build_key(sb, src_fd.search_key,\n\t\t\tsrc_dir->i_ino, src_name);\n\tif (unlikely(err))\n\t\tgoto out;\n\n\terr = hfs_brec_find(&src_fd, hfs_find_rec_by_key);\n\tif (err)\n\t\tgoto out;\n\tif (src_fd.entrylength > sizeof(entry) || src_fd.entrylength < 0) {\n\t\terr = -EIO;\n\t\tgoto out;\n\t}\n\n\thfs_bnode_read(src_fd.bnode, &entry, src_fd.entryoffset,\n\t\t\t\tsrc_fd.entrylength);\n\ttype = be16_to_cpu(entry.type);\n\n\t/* create new dir entry with the data from the old entry */\n\terr = hfsplus_cat_build_key(sb, dst_fd.search_key,\n\t\t\tdst_dir->i_ino, dst_name);\n\tif (unlikely(err))\n\t\tgoto out;\n\n\terr = hfs_brec_find(&dst_fd, hfs_find_rec_by_key);\n\tif (err != -ENOENT) {\n\t\tif (!err)\n\t\t\terr = -EEXIST;\n\t\tgoto out;\n\t}\n\n\terr = hfs_brec_insert(&dst_fd, &entry, src_fd.entrylength);\n\tif (err)\n\t\tgoto out;\n\tdst_dir->i_size++;\n\tif (type == HFSPLUS_FOLDER)\n\t\thfsplus_subfolders_inc(dst_dir);\n\tdst_dir->i_mtime = dst_dir->i_ctime = CURRENT_TIME_SEC;\n\n\t/* finally remove the old entry */\n\terr = hfsplus_cat_build_key(sb, src_fd.search_key,\n\t\t\tsrc_dir->i_ino, src_name);\n\tif (unlikely(err))\n\t\tgoto out;\n\n\terr = hfs_brec_find(&src_fd, hfs_find_rec_by_key);\n\tif (err)\n\t\tgoto out;\n\terr = hfs_brec_remove(&src_fd);\n\tif (err)\n\t\tgoto out;\n\tsrc_dir->i_size--;\n\tif (type == HFSPLUS_FOLDER)\n\t\thfsplus_subfolders_dec(src_dir);\n\tsrc_dir->i_mtime = src_dir->i_ctime = CURRENT_TIME_SEC;\n\n\t/* remove old thread entry */\n\thfsplus_cat_build_key_with_cnid(sb, src_fd.search_key, cnid);\n\terr = hfs_brec_find(&src_fd, hfs_find_rec_by_key);\n\tif (err)\n\t\tgoto out;\n\ttype = hfs_bnode_read_u16(src_fd.bnode, src_fd.entryoffset);\n\terr = hfs_brec_remove(&src_fd);\n\tif (err)\n\t\tgoto out;\n\n\t/* create new thread entry */\n\thfsplus_cat_build_key_with_cnid(sb, dst_fd.search_key, cnid);\n\tentry_size = hfsplus_fill_cat_thread(sb, &entry, type,\n\t\tdst_dir->i_ino, dst_name);\n\tif (unlikely(entry_size < 0)) {\n\t\terr = entry_size;\n\t\tgoto out;\n\t}\n\n\terr = hfs_brec_find(&dst_fd, hfs_find_rec_by_key);\n\tif (err != -ENOENT) {\n\t\tif (!err)\n\t\t\terr = -EEXIST;\n\t\tgoto out;\n\t}\n\terr = hfs_brec_insert(&dst_fd, &entry, entry_size);\n\n\thfsplus_mark_inode_dirty(dst_dir, HFSPLUS_I_CAT_DIRTY);\n\thfsplus_mark_inode_dirty(src_dir, HFSPLUS_I_CAT_DIRTY);\nout:\n\thfs_bnode_put(dst_fd.bnode);\n\thfs_find_exit(&src_fd);\n\treturn err;\n}"
  },
  {
    "function_name": "hfsplus_delete_cat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/catalog.c",
    "lines": "321-411",
    "snippet": "int hfsplus_delete_cat(u32 cnid, struct inode *dir, struct qstr *str)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tstruct hfs_find_data fd;\n\tstruct hfsplus_fork_raw fork;\n\tstruct list_head *pos;\n\tint err, off;\n\tu16 type;\n\n\thfs_dbg(CAT_MOD, \"delete_cat: %s,%u\\n\", str ? str->name : NULL, cnid);\n\terr = hfs_find_init(HFSPLUS_SB(sb)->cat_tree, &fd);\n\tif (err)\n\t\treturn err;\n\n\tif (!str) {\n\t\tint len;\n\n\t\thfsplus_cat_build_key_with_cnid(sb, fd.search_key, cnid);\n\t\terr = hfs_brec_find(&fd, hfs_find_rec_by_key);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\toff = fd.entryoffset +\n\t\t\toffsetof(struct hfsplus_cat_thread, nodeName);\n\t\tfd.search_key->cat.parent = cpu_to_be32(dir->i_ino);\n\t\thfs_bnode_read(fd.bnode,\n\t\t\t&fd.search_key->cat.name.length, off, 2);\n\t\tlen = be16_to_cpu(fd.search_key->cat.name.length) * 2;\n\t\thfs_bnode_read(fd.bnode,\n\t\t\t&fd.search_key->cat.name.unicode,\n\t\t\toff + 2, len);\n\t\tfd.search_key->key_len = cpu_to_be16(6 + len);\n\t} else\n\t\terr = hfsplus_cat_build_key(sb, fd.search_key, dir->i_ino, str);\n\t\tif (unlikely(err))\n\t\t\tgoto out;\n\n\terr = hfs_brec_find(&fd, hfs_find_rec_by_key);\n\tif (err)\n\t\tgoto out;\n\n\ttype = hfs_bnode_read_u16(fd.bnode, fd.entryoffset);\n\tif (type == HFSPLUS_FILE) {\n#if 0\n\t\toff = fd.entryoffset + offsetof(hfsplus_cat_file, data_fork);\n\t\thfs_bnode_read(fd.bnode, &fork, off, sizeof(fork));\n\t\thfsplus_free_fork(sb, cnid, &fork, HFSPLUS_TYPE_DATA);\n#endif\n\n\t\toff = fd.entryoffset +\n\t\t\toffsetof(struct hfsplus_cat_file, rsrc_fork);\n\t\thfs_bnode_read(fd.bnode, &fork, off, sizeof(fork));\n\t\thfsplus_free_fork(sb, cnid, &fork, HFSPLUS_TYPE_RSRC);\n\t}\n\n\tlist_for_each(pos, &HFSPLUS_I(dir)->open_dir_list) {\n\t\tstruct hfsplus_readdir_data *rd =\n\t\t\tlist_entry(pos, struct hfsplus_readdir_data, list);\n\t\tif (fd.tree->keycmp(fd.search_key, (void *)&rd->key) < 0)\n\t\t\trd->file->f_pos--;\n\t}\n\n\terr = hfs_brec_remove(&fd);\n\tif (err)\n\t\tgoto out;\n\n\thfsplus_cat_build_key_with_cnid(sb, fd.search_key, cnid);\n\terr = hfs_brec_find(&fd, hfs_find_rec_by_key);\n\tif (err)\n\t\tgoto out;\n\n\terr = hfs_brec_remove(&fd);\n\tif (err)\n\t\tgoto out;\n\n\tdir->i_size--;\n\tif (type == HFSPLUS_FOLDER)\n\t\thfsplus_subfolders_dec(dir);\n\tdir->i_mtime = dir->i_ctime = CURRENT_TIME_SEC;\n\thfsplus_mark_inode_dirty(dir, HFSPLUS_I_CAT_DIRTY);\n\n\tif (type == HFSPLUS_FILE || type == HFSPLUS_FOLDER) {\n\t\tif (HFSPLUS_SB(sb)->attr_tree)\n\t\t\thfsplus_delete_all_attrs(dir, cnid);\n\t}\n\nout:\n\thfs_find_exit(&fd);\n\n\treturn err;\n}",
    "includes": [
      "#include \"hfsplus_raw.h\"",
      "#include \"hfsplus_fs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hfs_find_exit",
          "args": [
            "&fd"
          ],
          "line": 408
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_find_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/bfind.c",
          "lines": "43-51",
          "snippet": "void hfs_find_exit(struct hfs_find_data *fd)\n{\n\thfs_bnode_put(fd->bnode);\n\tkfree(fd->search_key);\n\thfs_dbg(BNODE_REFS, \"find_exit: %d (%p)\\n\",\n\t\tfd->tree->cnid, __builtin_return_address(0));\n\tmutex_unlock(&fd->tree->tree_lock);\n\tfd->tree = NULL;\n}",
          "includes": [
            "#include \"hfsplus_fs.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_fs.h\"\n#include <linux/slab.h>\n\nvoid hfs_find_exit(struct hfs_find_data *fd)\n{\n\thfs_bnode_put(fd->bnode);\n\tkfree(fd->search_key);\n\thfs_dbg(BNODE_REFS, \"find_exit: %d (%p)\\n\",\n\t\tfd->tree->cnid, __builtin_return_address(0));\n\tmutex_unlock(&fd->tree->tree_lock);\n\tfd->tree = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfsplus_delete_all_attrs",
          "args": [
            "dir",
            "cnid"
          ],
          "line": 404
        },
        "resolved": true,
        "details": {
          "function_name": "hfsplus_delete_all_attrs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/attributes.c",
          "lines": "339-371",
          "snippet": "int hfsplus_delete_all_attrs(struct inode *dir, u32 cnid)\n{\n\tint err = 0;\n\tstruct hfs_find_data fd;\n\n\thfs_dbg(ATTR_MOD, \"delete_all_attrs: %d\\n\", cnid);\n\n\tif (!HFSPLUS_SB(dir->i_sb)->attr_tree) {\n\t\tpr_err(\"attributes file doesn't exist\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\terr = hfs_find_init(HFSPLUS_SB(dir->i_sb)->attr_tree, &fd);\n\tif (err)\n\t\treturn err;\n\n\tfor (;;) {\n\t\terr = hfsplus_find_attr(dir->i_sb, cnid, NULL, &fd);\n\t\tif (err) {\n\t\t\tif (err != -ENOENT)\n\t\t\t\tpr_err(\"xattr search failed\\n\");\n\t\t\tgoto end_delete_all;\n\t\t}\n\n\t\terr = __hfsplus_delete_attr(dir, cnid, &fd);\n\t\tif (err)\n\t\t\tgoto end_delete_all;\n\t}\n\nend_delete_all:\n\thfs_find_exit(&fd);\n\treturn err;\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n\nint hfsplus_delete_all_attrs(struct inode *dir, u32 cnid)\n{\n\tint err = 0;\n\tstruct hfs_find_data fd;\n\n\thfs_dbg(ATTR_MOD, \"delete_all_attrs: %d\\n\", cnid);\n\n\tif (!HFSPLUS_SB(dir->i_sb)->attr_tree) {\n\t\tpr_err(\"attributes file doesn't exist\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\terr = hfs_find_init(HFSPLUS_SB(dir->i_sb)->attr_tree, &fd);\n\tif (err)\n\t\treturn err;\n\n\tfor (;;) {\n\t\terr = hfsplus_find_attr(dir->i_sb, cnid, NULL, &fd);\n\t\tif (err) {\n\t\t\tif (err != -ENOENT)\n\t\t\t\tpr_err(\"xattr search failed\\n\");\n\t\t\tgoto end_delete_all;\n\t\t}\n\n\t\terr = __hfsplus_delete_attr(dir, cnid, &fd);\n\t\tif (err)\n\t\t\tgoto end_delete_all;\n\t}\n\nend_delete_all:\n\thfs_find_exit(&fd);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "HFSPLUS_SB",
          "args": [
            "sb"
          ],
          "line": 403
        },
        "resolved": true,
        "details": {
          "function_name": "HFSPLUS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/hfsplus_fs.h",
          "lines": "202-205",
          "snippet": "static inline struct hfsplus_sb_info *HFSPLUS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mutex.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/mutex.h>\n#include <linux/fs.h>\n\nstatic inline struct hfsplus_sb_info *HFSPLUS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfsplus_mark_inode_dirty",
          "args": [
            "dir",
            "HFSPLUS_I_CAT_DIRTY"
          ],
          "line": 400
        },
        "resolved": true,
        "details": {
          "function_name": "hfsplus_mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/hfsplus_fs.h",
          "lines": "275-280",
          "snippet": "static inline void hfsplus_mark_inode_dirty(struct inode *inode,\n\t\tunsigned int flag)\n{\n\tset_bit(flag, &HFSPLUS_I(inode)->flags);\n\tmark_inode_dirty(inode);\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mutex.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/mutex.h>\n#include <linux/fs.h>\n\nstatic inline void hfsplus_mark_inode_dirty(struct inode *inode,\n\t\tunsigned int flag)\n{\n\tset_bit(flag, &HFSPLUS_I(inode)->flags);\n\tmark_inode_dirty(inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfsplus_subfolders_dec",
          "args": [
            "dir"
          ],
          "line": 398
        },
        "resolved": true,
        "details": {
          "function_name": "hfsplus_subfolders_dec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/catalog.c",
          "lines": "235-250",
          "snippet": "static void hfsplus_subfolders_dec(struct inode *dir)\n{\n\tstruct hfsplus_sb_info *sbi = HFSPLUS_SB(dir->i_sb);\n\n\tif (test_bit(HFSPLUS_SB_HFSX, &sbi->flags)) {\n\t\t/*\n\t\t * Decrement subfolder count. Note, the value is only meaningful\n\t\t * for folders with HFSPLUS_HAS_FOLDER_COUNT flag set.\n\t\t *\n\t\t * Check for zero. Some subfolders may have been created\n\t\t * by an implementation ignorant of this counter.\n\t\t */\n\t\tif (HFSPLUS_I(dir)->subfolders)\n\t\t\tHFSPLUS_I(dir)->subfolders--;\n\t}\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n\nstatic void hfsplus_subfolders_dec(struct inode *dir)\n{\n\tstruct hfsplus_sb_info *sbi = HFSPLUS_SB(dir->i_sb);\n\n\tif (test_bit(HFSPLUS_SB_HFSX, &sbi->flags)) {\n\t\t/*\n\t\t * Decrement subfolder count. Note, the value is only meaningful\n\t\t * for folders with HFSPLUS_HAS_FOLDER_COUNT flag set.\n\t\t *\n\t\t * Check for zero. Some subfolders may have been created\n\t\t * by an implementation ignorant of this counter.\n\t\t */\n\t\tif (HFSPLUS_I(dir)->subfolders)\n\t\t\tHFSPLUS_I(dir)->subfolders--;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfs_brec_remove",
          "args": [
            "&fd"
          ],
          "line": 392
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_brec_remove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/brec.c",
          "lines": "177-231",
          "snippet": "int hfs_brec_remove(struct hfs_find_data *fd)\n{\n\tstruct hfs_btree *tree;\n\tstruct hfs_bnode *node, *parent;\n\tint end_off, rec_off, data_off, size;\n\n\ttree = fd->tree;\n\tnode = fd->bnode;\nagain:\n\trec_off = tree->node_size - (fd->record + 2) * 2;\n\tend_off = tree->node_size - (node->num_recs + 1) * 2;\n\n\tif (node->type == HFS_NODE_LEAF) {\n\t\ttree->leaf_count--;\n\t\tmark_inode_dirty(tree->inode);\n\t}\n\thfs_bnode_dump(node);\n\thfs_dbg(BNODE_MOD, \"remove_rec: %d, %d\\n\",\n\t\tfd->record, fd->keylength + fd->entrylength);\n\tif (!--node->num_recs) {\n\t\thfs_bnode_unlink(node);\n\t\tif (!node->parent)\n\t\t\treturn 0;\n\t\tparent = hfs_bnode_find(tree, node->parent);\n\t\tif (IS_ERR(parent))\n\t\t\treturn PTR_ERR(parent);\n\t\thfs_bnode_put(node);\n\t\tnode = fd->bnode = parent;\n\n\t\t__hfs_brec_find(node, fd, hfs_find_rec_by_key);\n\t\tgoto again;\n\t}\n\thfs_bnode_write_u16(node,\n\t\toffsetof(struct hfs_bnode_desc, num_recs),\n\t\tnode->num_recs);\n\n\tif (rec_off == end_off)\n\t\tgoto skip;\n\tsize = fd->keylength + fd->entrylength;\n\n\tdo {\n\t\tdata_off = hfs_bnode_read_u16(node, rec_off);\n\t\thfs_bnode_write_u16(node, rec_off + 2, data_off - size);\n\t\trec_off -= 2;\n\t} while (rec_off >= end_off);\n\n\t/* fill hole */\n\thfs_bnode_move(node, fd->keyoffset, fd->keyoffset + size,\n\t\t       data_off - fd->keyoffset - size);\nskip:\n\thfs_bnode_dump(node);\n\tif (!fd->record)\n\t\thfs_brec_update_parent(fd);\n\treturn 0;\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hfs_bnode *hfs_bnode_split(struct hfs_find_data *fd);",
            "static int hfs_brec_update_parent(struct hfs_find_data *fd);",
            "static int hfs_btree_inc_height(struct hfs_btree *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n\nstatic struct hfs_bnode *hfs_bnode_split(struct hfs_find_data *fd);\nstatic int hfs_brec_update_parent(struct hfs_find_data *fd);\nstatic int hfs_btree_inc_height(struct hfs_btree *);\n\nint hfs_brec_remove(struct hfs_find_data *fd)\n{\n\tstruct hfs_btree *tree;\n\tstruct hfs_bnode *node, *parent;\n\tint end_off, rec_off, data_off, size;\n\n\ttree = fd->tree;\n\tnode = fd->bnode;\nagain:\n\trec_off = tree->node_size - (fd->record + 2) * 2;\n\tend_off = tree->node_size - (node->num_recs + 1) * 2;\n\n\tif (node->type == HFS_NODE_LEAF) {\n\t\ttree->leaf_count--;\n\t\tmark_inode_dirty(tree->inode);\n\t}\n\thfs_bnode_dump(node);\n\thfs_dbg(BNODE_MOD, \"remove_rec: %d, %d\\n\",\n\t\tfd->record, fd->keylength + fd->entrylength);\n\tif (!--node->num_recs) {\n\t\thfs_bnode_unlink(node);\n\t\tif (!node->parent)\n\t\t\treturn 0;\n\t\tparent = hfs_bnode_find(tree, node->parent);\n\t\tif (IS_ERR(parent))\n\t\t\treturn PTR_ERR(parent);\n\t\thfs_bnode_put(node);\n\t\tnode = fd->bnode = parent;\n\n\t\t__hfs_brec_find(node, fd, hfs_find_rec_by_key);\n\t\tgoto again;\n\t}\n\thfs_bnode_write_u16(node,\n\t\toffsetof(struct hfs_bnode_desc, num_recs),\n\t\tnode->num_recs);\n\n\tif (rec_off == end_off)\n\t\tgoto skip;\n\tsize = fd->keylength + fd->entrylength;\n\n\tdo {\n\t\tdata_off = hfs_bnode_read_u16(node, rec_off);\n\t\thfs_bnode_write_u16(node, rec_off + 2, data_off - size);\n\t\trec_off -= 2;\n\t} while (rec_off >= end_off);\n\n\t/* fill hole */\n\thfs_bnode_move(node, fd->keyoffset, fd->keyoffset + size,\n\t\t       data_off - fd->keyoffset - size);\nskip:\n\thfs_bnode_dump(node);\n\tif (!fd->record)\n\t\thfs_brec_update_parent(fd);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfs_brec_find",
          "args": [
            "&fd",
            "hfs_find_rec_by_key"
          ],
          "line": 388
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_brec_find",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/bfind.c",
          "lines": "165-217",
          "snippet": "int hfs_brec_find(struct hfs_find_data *fd, search_strategy_t do_key_compare)\n{\n\tstruct hfs_btree *tree;\n\tstruct hfs_bnode *bnode;\n\tu32 nidx, parent;\n\t__be32 data;\n\tint height, res;\n\n\ttree = fd->tree;\n\tif (fd->bnode)\n\t\thfs_bnode_put(fd->bnode);\n\tfd->bnode = NULL;\n\tnidx = tree->root;\n\tif (!nidx)\n\t\treturn -ENOENT;\n\theight = tree->depth;\n\tres = 0;\n\tparent = 0;\n\tfor (;;) {\n\t\tbnode = hfs_bnode_find(tree, nidx);\n\t\tif (IS_ERR(bnode)) {\n\t\t\tres = PTR_ERR(bnode);\n\t\t\tbnode = NULL;\n\t\t\tbreak;\n\t\t}\n\t\tif (bnode->height != height)\n\t\t\tgoto invalid;\n\t\tif (bnode->type != (--height ? HFS_NODE_INDEX : HFS_NODE_LEAF))\n\t\t\tgoto invalid;\n\t\tbnode->parent = parent;\n\n\t\tres = __hfs_brec_find(bnode, fd, do_key_compare);\n\t\tif (!height)\n\t\t\tbreak;\n\t\tif (fd->record < 0)\n\t\t\tgoto release;\n\n\t\tparent = nidx;\n\t\thfs_bnode_read(bnode, &data, fd->entryoffset, 4);\n\t\tnidx = be32_to_cpu(data);\n\t\thfs_bnode_put(bnode);\n\t}\n\tfd->bnode = bnode;\n\treturn res;\n\ninvalid:\n\tpr_err(\"inconsistency in B*Tree (%d,%d,%d,%u,%u)\\n\",\n\t\theight, bnode->height, bnode->type, nidx, parent);\n\tres = -EIO;\nrelease:\n\thfs_bnode_put(bnode);\n\treturn res;\n}",
          "includes": [
            "#include \"hfsplus_fs.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_fs.h\"\n#include <linux/slab.h>\n\nint hfs_brec_find(struct hfs_find_data *fd, search_strategy_t do_key_compare)\n{\n\tstruct hfs_btree *tree;\n\tstruct hfs_bnode *bnode;\n\tu32 nidx, parent;\n\t__be32 data;\n\tint height, res;\n\n\ttree = fd->tree;\n\tif (fd->bnode)\n\t\thfs_bnode_put(fd->bnode);\n\tfd->bnode = NULL;\n\tnidx = tree->root;\n\tif (!nidx)\n\t\treturn -ENOENT;\n\theight = tree->depth;\n\tres = 0;\n\tparent = 0;\n\tfor (;;) {\n\t\tbnode = hfs_bnode_find(tree, nidx);\n\t\tif (IS_ERR(bnode)) {\n\t\t\tres = PTR_ERR(bnode);\n\t\t\tbnode = NULL;\n\t\t\tbreak;\n\t\t}\n\t\tif (bnode->height != height)\n\t\t\tgoto invalid;\n\t\tif (bnode->type != (--height ? HFS_NODE_INDEX : HFS_NODE_LEAF))\n\t\t\tgoto invalid;\n\t\tbnode->parent = parent;\n\n\t\tres = __hfs_brec_find(bnode, fd, do_key_compare);\n\t\tif (!height)\n\t\t\tbreak;\n\t\tif (fd->record < 0)\n\t\t\tgoto release;\n\n\t\tparent = nidx;\n\t\thfs_bnode_read(bnode, &data, fd->entryoffset, 4);\n\t\tnidx = be32_to_cpu(data);\n\t\thfs_bnode_put(bnode);\n\t}\n\tfd->bnode = bnode;\n\treturn res;\n\ninvalid:\n\tpr_err(\"inconsistency in B*Tree (%d,%d,%d,%u,%u)\\n\",\n\t\theight, bnode->height, bnode->type, nidx, parent);\n\tres = -EIO;\nrelease:\n\thfs_bnode_put(bnode);\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfsplus_cat_build_key_with_cnid",
          "args": [
            "sb",
            "fd.search_key",
            "cnid"
          ],
          "line": 387
        },
        "resolved": true,
        "details": {
          "function_name": "hfsplus_cat_build_key_with_cnid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/catalog.c",
          "lines": "59-65",
          "snippet": "void hfsplus_cat_build_key_with_cnid(struct super_block *sb,\n\t\t\thfsplus_btree_key *key, u32 parent)\n{\n\tkey->cat.parent = cpu_to_be32(parent);\n\tkey->cat.name.length = 0;\n\tkey->key_len = cpu_to_be16(6);\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n\nvoid hfsplus_cat_build_key_with_cnid(struct super_block *sb,\n\t\t\thfsplus_btree_key *key, u32 parent)\n{\n\tkey->cat.parent = cpu_to_be32(parent);\n\tkey->cat.name.length = 0;\n\tkey->key_len = cpu_to_be16(6);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fd.tree->keycmp",
          "args": [
            "fd.search_key",
            "(void *)&rd->key"
          ],
          "line": 379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "pos",
            "structhfsplus_readdir_data",
            "list"
          ],
          "line": 378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each",
          "args": [
            "pos",
            "&HFSPLUS_I(dir)->open_dir_list"
          ],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HFSPLUS_I",
          "args": [
            "dir"
          ],
          "line": 376
        },
        "resolved": true,
        "details": {
          "function_name": "HFSPLUS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/hfsplus_fs.h",
          "lines": "264-267",
          "snippet": "static inline struct hfsplus_inode_info *HFSPLUS_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct hfsplus_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mutex.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/mutex.h>\n#include <linux/fs.h>\n\nstatic inline struct hfsplus_inode_info *HFSPLUS_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct hfsplus_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfsplus_free_fork",
          "args": [
            "sb",
            "cnid",
            "&fork",
            "HFSPLUS_TYPE_RSRC"
          ],
          "line": 373
        },
        "resolved": true,
        "details": {
          "function_name": "hfsplus_free_fork",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/extents.c",
          "lines": "386-426",
          "snippet": "int hfsplus_free_fork(struct super_block *sb, u32 cnid,\n\t\tstruct hfsplus_fork_raw *fork, int type)\n{\n\tstruct hfs_find_data fd;\n\thfsplus_extent_rec ext_entry;\n\tu32 total_blocks, blocks, start;\n\tint res, i;\n\n\ttotal_blocks = be32_to_cpu(fork->total_blocks);\n\tif (!total_blocks)\n\t\treturn 0;\n\n\tblocks = 0;\n\tfor (i = 0; i < 8; i++)\n\t\tblocks += be32_to_cpu(fork->extents[i].block_count);\n\n\tres = hfsplus_free_extents(sb, fork->extents, blocks, blocks);\n\tif (res)\n\t\treturn res;\n\tif (total_blocks == blocks)\n\t\treturn 0;\n\n\tres = hfs_find_init(HFSPLUS_SB(sb)->ext_tree, &fd);\n\tif (res)\n\t\treturn res;\n\tdo {\n\t\tres = __hfsplus_ext_read_extent(&fd, ext_entry, cnid,\n\t\t\t\t\t\ttotal_blocks, type);\n\t\tif (res)\n\t\t\tbreak;\n\t\tstart = be32_to_cpu(fd.key->ext.start_block);\n\t\thfsplus_free_extents(sb, ext_entry,\n\t\t\t\t     total_blocks - start,\n\t\t\t\t     total_blocks);\n\t\thfs_brec_remove(&fd);\n\t\ttotal_blocks = start;\n\t} while (total_blocks > blocks);\n\thfs_find_exit(&fd);\n\n\treturn res;\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n\nint hfsplus_free_fork(struct super_block *sb, u32 cnid,\n\t\tstruct hfsplus_fork_raw *fork, int type)\n{\n\tstruct hfs_find_data fd;\n\thfsplus_extent_rec ext_entry;\n\tu32 total_blocks, blocks, start;\n\tint res, i;\n\n\ttotal_blocks = be32_to_cpu(fork->total_blocks);\n\tif (!total_blocks)\n\t\treturn 0;\n\n\tblocks = 0;\n\tfor (i = 0; i < 8; i++)\n\t\tblocks += be32_to_cpu(fork->extents[i].block_count);\n\n\tres = hfsplus_free_extents(sb, fork->extents, blocks, blocks);\n\tif (res)\n\t\treturn res;\n\tif (total_blocks == blocks)\n\t\treturn 0;\n\n\tres = hfs_find_init(HFSPLUS_SB(sb)->ext_tree, &fd);\n\tif (res)\n\t\treturn res;\n\tdo {\n\t\tres = __hfsplus_ext_read_extent(&fd, ext_entry, cnid,\n\t\t\t\t\t\ttotal_blocks, type);\n\t\tif (res)\n\t\t\tbreak;\n\t\tstart = be32_to_cpu(fd.key->ext.start_block);\n\t\thfsplus_free_extents(sb, ext_entry,\n\t\t\t\t     total_blocks - start,\n\t\t\t\t     total_blocks);\n\t\thfs_brec_remove(&fd);\n\t\ttotal_blocks = start;\n\t} while (total_blocks > blocks);\n\thfs_find_exit(&fd);\n\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfs_bnode_read",
          "args": [
            "fd.bnode",
            "&fork",
            "off",
            "sizeof(fork)"
          ],
          "line": 372
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_bnode_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/bnode.c",
          "lines": "21-40",
          "snippet": "void hfs_bnode_read(struct hfs_bnode *node, void *buf, int off, int len)\n{\n\tstruct page **pagep;\n\tint l;\n\n\toff += node->page_offset;\n\tpagep = node->page + (off >> PAGE_CACHE_SHIFT);\n\toff &= ~PAGE_CACHE_MASK;\n\n\tl = min_t(int, len, PAGE_CACHE_SIZE - off);\n\tmemcpy(buf, kmap(*pagep) + off, l);\n\tkunmap(*pagep);\n\n\twhile ((len -= l) != 0) {\n\t\tbuf += l;\n\t\tl = min_t(int, len, PAGE_CACHE_SIZE);\n\t\tmemcpy(buf, kmap(*++pagep), l);\n\t\tkunmap(*pagep);\n\t}\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/swap.h>\n#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nvoid hfs_bnode_read(struct hfs_bnode *node, void *buf, int off, int len)\n{\n\tstruct page **pagep;\n\tint l;\n\n\toff += node->page_offset;\n\tpagep = node->page + (off >> PAGE_CACHE_SHIFT);\n\toff &= ~PAGE_CACHE_MASK;\n\n\tl = min_t(int, len, PAGE_CACHE_SIZE - off);\n\tmemcpy(buf, kmap(*pagep) + off, l);\n\tkunmap(*pagep);\n\n\twhile ((len -= l) != 0) {\n\t\tbuf += l;\n\t\tl = min_t(int, len, PAGE_CACHE_SIZE);\n\t\tmemcpy(buf, kmap(*++pagep), l);\n\t\tkunmap(*pagep);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfs_bnode_read_u16",
          "args": [
            "fd.bnode",
            "fd.entryoffset"
          ],
          "line": 362
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_bnode_read_u16",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/bnode.c",
          "lines": "42-48",
          "snippet": "u16 hfs_bnode_read_u16(struct hfs_bnode *node, int off)\n{\n\t__be16 data;\n\t/* TODO: optimize later... */\n\thfs_bnode_read(node, &data, off, 2);\n\treturn be16_to_cpu(data);\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/swap.h>\n#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nu16 hfs_bnode_read_u16(struct hfs_bnode *node, int off)\n{\n\t__be16 data;\n\t/* TODO: optimize later... */\n\thfs_bnode_read(node, &data, off, 2);\n\treturn be16_to_cpu(data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "err"
          ],
          "line": 355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfsplus_cat_build_key",
          "args": [
            "sb",
            "fd.search_key",
            "dir->i_ino",
            "str"
          ],
          "line": 354
        },
        "resolved": true,
        "details": {
          "function_name": "hfsplus_cat_build_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/catalog.c",
          "lines": "42-56",
          "snippet": "int hfsplus_cat_build_key(struct super_block *sb,\n\t\thfsplus_btree_key *key, u32 parent, struct qstr *str)\n{\n\tint len, err;\n\n\tkey->cat.parent = cpu_to_be32(parent);\n\terr = hfsplus_asc2uni(sb, &key->cat.name, HFSPLUS_MAX_STRLEN,\n\t\t\tstr->name, str->len);\n\tif (unlikely(err < 0))\n\t\treturn err;\n\n\tlen = be16_to_cpu(key->cat.name.length);\n\tkey->key_len = cpu_to_be16(6 + 2 * len);\n\treturn 0;\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n\nint hfsplus_cat_build_key(struct super_block *sb,\n\t\thfsplus_btree_key *key, u32 parent, struct qstr *str)\n{\n\tint len, err;\n\n\tkey->cat.parent = cpu_to_be32(parent);\n\terr = hfsplus_asc2uni(sb, &key->cat.name, HFSPLUS_MAX_STRLEN,\n\t\t\tstr->name, str->len);\n\tif (unlikely(err < 0))\n\t\treturn err;\n\n\tlen = be16_to_cpu(key->cat.name.length);\n\tkey->key_len = cpu_to_be16(6 + 2 * len);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "6 + len"
          ],
          "line": 352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "fd.search_key->cat.name.length"
          ],
          "line": 348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "dir->i_ino"
          ],
          "line": 345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfs_find_init",
          "args": [
            "HFSPLUS_SB(sb)->cat_tree",
            "&fd"
          ],
          "line": 331
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_find_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/bfind.c",
          "lines": "14-41",
          "snippet": "int hfs_find_init(struct hfs_btree *tree, struct hfs_find_data *fd)\n{\n\tvoid *ptr;\n\n\tfd->tree = tree;\n\tfd->bnode = NULL;\n\tptr = kmalloc(tree->max_key_len * 2 + 4, GFP_KERNEL);\n\tif (!ptr)\n\t\treturn -ENOMEM;\n\tfd->search_key = ptr;\n\tfd->key = ptr + tree->max_key_len + 2;\n\thfs_dbg(BNODE_REFS, \"find_init: %d (%p)\\n\",\n\t\ttree->cnid, __builtin_return_address(0));\n\tswitch (tree->cnid) {\n\tcase HFSPLUS_CAT_CNID:\n\t\tmutex_lock_nested(&tree->tree_lock, CATALOG_BTREE_MUTEX);\n\t\tbreak;\n\tcase HFSPLUS_EXT_CNID:\n\t\tmutex_lock_nested(&tree->tree_lock, EXTENTS_BTREE_MUTEX);\n\t\tbreak;\n\tcase HFSPLUS_ATTR_CNID:\n\t\tmutex_lock_nested(&tree->tree_lock, ATTR_BTREE_MUTEX);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"hfsplus_fs.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_fs.h\"\n#include <linux/slab.h>\n\nint hfs_find_init(struct hfs_btree *tree, struct hfs_find_data *fd)\n{\n\tvoid *ptr;\n\n\tfd->tree = tree;\n\tfd->bnode = NULL;\n\tptr = kmalloc(tree->max_key_len * 2 + 4, GFP_KERNEL);\n\tif (!ptr)\n\t\treturn -ENOMEM;\n\tfd->search_key = ptr;\n\tfd->key = ptr + tree->max_key_len + 2;\n\thfs_dbg(BNODE_REFS, \"find_init: %d (%p)\\n\",\n\t\ttree->cnid, __builtin_return_address(0));\n\tswitch (tree->cnid) {\n\tcase HFSPLUS_CAT_CNID:\n\t\tmutex_lock_nested(&tree->tree_lock, CATALOG_BTREE_MUTEX);\n\t\tbreak;\n\tcase HFSPLUS_EXT_CNID:\n\t\tmutex_lock_nested(&tree->tree_lock, EXTENTS_BTREE_MUTEX);\n\t\tbreak;\n\tcase HFSPLUS_ATTR_CNID:\n\t\tmutex_lock_nested(&tree->tree_lock, ATTR_BTREE_MUTEX);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfs_dbg",
          "args": [
            "CAT_MOD",
            "\"delete_cat: %s,%u\\n\"",
            "str ? str->name : NULL",
            "cnid"
          ],
          "line": 330
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n\nint hfsplus_delete_cat(u32 cnid, struct inode *dir, struct qstr *str)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tstruct hfs_find_data fd;\n\tstruct hfsplus_fork_raw fork;\n\tstruct list_head *pos;\n\tint err, off;\n\tu16 type;\n\n\thfs_dbg(CAT_MOD, \"delete_cat: %s,%u\\n\", str ? str->name : NULL, cnid);\n\terr = hfs_find_init(HFSPLUS_SB(sb)->cat_tree, &fd);\n\tif (err)\n\t\treturn err;\n\n\tif (!str) {\n\t\tint len;\n\n\t\thfsplus_cat_build_key_with_cnid(sb, fd.search_key, cnid);\n\t\terr = hfs_brec_find(&fd, hfs_find_rec_by_key);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\toff = fd.entryoffset +\n\t\t\toffsetof(struct hfsplus_cat_thread, nodeName);\n\t\tfd.search_key->cat.parent = cpu_to_be32(dir->i_ino);\n\t\thfs_bnode_read(fd.bnode,\n\t\t\t&fd.search_key->cat.name.length, off, 2);\n\t\tlen = be16_to_cpu(fd.search_key->cat.name.length) * 2;\n\t\thfs_bnode_read(fd.bnode,\n\t\t\t&fd.search_key->cat.name.unicode,\n\t\t\toff + 2, len);\n\t\tfd.search_key->key_len = cpu_to_be16(6 + len);\n\t} else\n\t\terr = hfsplus_cat_build_key(sb, fd.search_key, dir->i_ino, str);\n\t\tif (unlikely(err))\n\t\t\tgoto out;\n\n\terr = hfs_brec_find(&fd, hfs_find_rec_by_key);\n\tif (err)\n\t\tgoto out;\n\n\ttype = hfs_bnode_read_u16(fd.bnode, fd.entryoffset);\n\tif (type == HFSPLUS_FILE) {\n#if 0\n\t\toff = fd.entryoffset + offsetof(hfsplus_cat_file, data_fork);\n\t\thfs_bnode_read(fd.bnode, &fork, off, sizeof(fork));\n\t\thfsplus_free_fork(sb, cnid, &fork, HFSPLUS_TYPE_DATA);\n#endif\n\n\t\toff = fd.entryoffset +\n\t\t\toffsetof(struct hfsplus_cat_file, rsrc_fork);\n\t\thfs_bnode_read(fd.bnode, &fork, off, sizeof(fork));\n\t\thfsplus_free_fork(sb, cnid, &fork, HFSPLUS_TYPE_RSRC);\n\t}\n\n\tlist_for_each(pos, &HFSPLUS_I(dir)->open_dir_list) {\n\t\tstruct hfsplus_readdir_data *rd =\n\t\t\tlist_entry(pos, struct hfsplus_readdir_data, list);\n\t\tif (fd.tree->keycmp(fd.search_key, (void *)&rd->key) < 0)\n\t\t\trd->file->f_pos--;\n\t}\n\n\terr = hfs_brec_remove(&fd);\n\tif (err)\n\t\tgoto out;\n\n\thfsplus_cat_build_key_with_cnid(sb, fd.search_key, cnid);\n\terr = hfs_brec_find(&fd, hfs_find_rec_by_key);\n\tif (err)\n\t\tgoto out;\n\n\terr = hfs_brec_remove(&fd);\n\tif (err)\n\t\tgoto out;\n\n\tdir->i_size--;\n\tif (type == HFSPLUS_FOLDER)\n\t\thfsplus_subfolders_dec(dir);\n\tdir->i_mtime = dir->i_ctime = CURRENT_TIME_SEC;\n\thfsplus_mark_inode_dirty(dir, HFSPLUS_I_CAT_DIRTY);\n\n\tif (type == HFSPLUS_FILE || type == HFSPLUS_FOLDER) {\n\t\tif (HFSPLUS_SB(sb)->attr_tree)\n\t\t\thfsplus_delete_all_attrs(dir, cnid);\n\t}\n\nout:\n\thfs_find_exit(&fd);\n\n\treturn err;\n}"
  },
  {
    "function_name": "hfsplus_create_cat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/catalog.c",
    "lines": "252-319",
    "snippet": "int hfsplus_create_cat(u32 cnid, struct inode *dir,\n\t\tstruct qstr *str, struct inode *inode)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tstruct hfs_find_data fd;\n\thfsplus_cat_entry entry;\n\tint entry_size;\n\tint err;\n\n\thfs_dbg(CAT_MOD, \"create_cat: %s,%u(%d)\\n\",\n\t\tstr->name, cnid, inode->i_nlink);\n\terr = hfs_find_init(HFSPLUS_SB(sb)->cat_tree, &fd);\n\tif (err)\n\t\treturn err;\n\n\thfsplus_cat_build_key_with_cnid(sb, fd.search_key, cnid);\n\tentry_size = hfsplus_fill_cat_thread(sb, &entry,\n\t\tS_ISDIR(inode->i_mode) ?\n\t\t\tHFSPLUS_FOLDER_THREAD : HFSPLUS_FILE_THREAD,\n\t\tdir->i_ino, str);\n\tif (unlikely(entry_size < 0)) {\n\t\terr = entry_size;\n\t\tgoto err2;\n\t}\n\n\terr = hfs_brec_find(&fd, hfs_find_rec_by_key);\n\tif (err != -ENOENT) {\n\t\tif (!err)\n\t\t\terr = -EEXIST;\n\t\tgoto err2;\n\t}\n\terr = hfs_brec_insert(&fd, &entry, entry_size);\n\tif (err)\n\t\tgoto err2;\n\n\terr = hfsplus_cat_build_key(sb, fd.search_key, dir->i_ino, str);\n\tif (unlikely(err))\n\t\tgoto err1;\n\n\tentry_size = hfsplus_cat_build_record(&entry, cnid, inode);\n\terr = hfs_brec_find(&fd, hfs_find_rec_by_key);\n\tif (err != -ENOENT) {\n\t\t/* panic? */\n\t\tif (!err)\n\t\t\terr = -EEXIST;\n\t\tgoto err1;\n\t}\n\terr = hfs_brec_insert(&fd, &entry, entry_size);\n\tif (err)\n\t\tgoto err1;\n\n\tdir->i_size++;\n\tif (S_ISDIR(inode->i_mode))\n\t\thfsplus_subfolders_inc(dir);\n\tdir->i_mtime = dir->i_ctime = CURRENT_TIME_SEC;\n\thfsplus_mark_inode_dirty(dir, HFSPLUS_I_CAT_DIRTY);\n\n\thfs_find_exit(&fd);\n\treturn 0;\n\nerr1:\n\thfsplus_cat_build_key_with_cnid(sb, fd.search_key, cnid);\n\tif (!hfs_brec_find(&fd, hfs_find_rec_by_key))\n\t\thfs_brec_remove(&fd);\nerr2:\n\thfs_find_exit(&fd);\n\treturn err;\n}",
    "includes": [
      "#include \"hfsplus_raw.h\"",
      "#include \"hfsplus_fs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hfs_find_exit",
          "args": [
            "&fd"
          ],
          "line": 317
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_find_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/bfind.c",
          "lines": "43-51",
          "snippet": "void hfs_find_exit(struct hfs_find_data *fd)\n{\n\thfs_bnode_put(fd->bnode);\n\tkfree(fd->search_key);\n\thfs_dbg(BNODE_REFS, \"find_exit: %d (%p)\\n\",\n\t\tfd->tree->cnid, __builtin_return_address(0));\n\tmutex_unlock(&fd->tree->tree_lock);\n\tfd->tree = NULL;\n}",
          "includes": [
            "#include \"hfsplus_fs.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_fs.h\"\n#include <linux/slab.h>\n\nvoid hfs_find_exit(struct hfs_find_data *fd)\n{\n\thfs_bnode_put(fd->bnode);\n\tkfree(fd->search_key);\n\thfs_dbg(BNODE_REFS, \"find_exit: %d (%p)\\n\",\n\t\tfd->tree->cnid, __builtin_return_address(0));\n\tmutex_unlock(&fd->tree->tree_lock);\n\tfd->tree = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfs_brec_remove",
          "args": [
            "&fd"
          ],
          "line": 315
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_brec_remove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/brec.c",
          "lines": "177-231",
          "snippet": "int hfs_brec_remove(struct hfs_find_data *fd)\n{\n\tstruct hfs_btree *tree;\n\tstruct hfs_bnode *node, *parent;\n\tint end_off, rec_off, data_off, size;\n\n\ttree = fd->tree;\n\tnode = fd->bnode;\nagain:\n\trec_off = tree->node_size - (fd->record + 2) * 2;\n\tend_off = tree->node_size - (node->num_recs + 1) * 2;\n\n\tif (node->type == HFS_NODE_LEAF) {\n\t\ttree->leaf_count--;\n\t\tmark_inode_dirty(tree->inode);\n\t}\n\thfs_bnode_dump(node);\n\thfs_dbg(BNODE_MOD, \"remove_rec: %d, %d\\n\",\n\t\tfd->record, fd->keylength + fd->entrylength);\n\tif (!--node->num_recs) {\n\t\thfs_bnode_unlink(node);\n\t\tif (!node->parent)\n\t\t\treturn 0;\n\t\tparent = hfs_bnode_find(tree, node->parent);\n\t\tif (IS_ERR(parent))\n\t\t\treturn PTR_ERR(parent);\n\t\thfs_bnode_put(node);\n\t\tnode = fd->bnode = parent;\n\n\t\t__hfs_brec_find(node, fd, hfs_find_rec_by_key);\n\t\tgoto again;\n\t}\n\thfs_bnode_write_u16(node,\n\t\toffsetof(struct hfs_bnode_desc, num_recs),\n\t\tnode->num_recs);\n\n\tif (rec_off == end_off)\n\t\tgoto skip;\n\tsize = fd->keylength + fd->entrylength;\n\n\tdo {\n\t\tdata_off = hfs_bnode_read_u16(node, rec_off);\n\t\thfs_bnode_write_u16(node, rec_off + 2, data_off - size);\n\t\trec_off -= 2;\n\t} while (rec_off >= end_off);\n\n\t/* fill hole */\n\thfs_bnode_move(node, fd->keyoffset, fd->keyoffset + size,\n\t\t       data_off - fd->keyoffset - size);\nskip:\n\thfs_bnode_dump(node);\n\tif (!fd->record)\n\t\thfs_brec_update_parent(fd);\n\treturn 0;\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hfs_bnode *hfs_bnode_split(struct hfs_find_data *fd);",
            "static int hfs_brec_update_parent(struct hfs_find_data *fd);",
            "static int hfs_btree_inc_height(struct hfs_btree *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n\nstatic struct hfs_bnode *hfs_bnode_split(struct hfs_find_data *fd);\nstatic int hfs_brec_update_parent(struct hfs_find_data *fd);\nstatic int hfs_btree_inc_height(struct hfs_btree *);\n\nint hfs_brec_remove(struct hfs_find_data *fd)\n{\n\tstruct hfs_btree *tree;\n\tstruct hfs_bnode *node, *parent;\n\tint end_off, rec_off, data_off, size;\n\n\ttree = fd->tree;\n\tnode = fd->bnode;\nagain:\n\trec_off = tree->node_size - (fd->record + 2) * 2;\n\tend_off = tree->node_size - (node->num_recs + 1) * 2;\n\n\tif (node->type == HFS_NODE_LEAF) {\n\t\ttree->leaf_count--;\n\t\tmark_inode_dirty(tree->inode);\n\t}\n\thfs_bnode_dump(node);\n\thfs_dbg(BNODE_MOD, \"remove_rec: %d, %d\\n\",\n\t\tfd->record, fd->keylength + fd->entrylength);\n\tif (!--node->num_recs) {\n\t\thfs_bnode_unlink(node);\n\t\tif (!node->parent)\n\t\t\treturn 0;\n\t\tparent = hfs_bnode_find(tree, node->parent);\n\t\tif (IS_ERR(parent))\n\t\t\treturn PTR_ERR(parent);\n\t\thfs_bnode_put(node);\n\t\tnode = fd->bnode = parent;\n\n\t\t__hfs_brec_find(node, fd, hfs_find_rec_by_key);\n\t\tgoto again;\n\t}\n\thfs_bnode_write_u16(node,\n\t\toffsetof(struct hfs_bnode_desc, num_recs),\n\t\tnode->num_recs);\n\n\tif (rec_off == end_off)\n\t\tgoto skip;\n\tsize = fd->keylength + fd->entrylength;\n\n\tdo {\n\t\tdata_off = hfs_bnode_read_u16(node, rec_off);\n\t\thfs_bnode_write_u16(node, rec_off + 2, data_off - size);\n\t\trec_off -= 2;\n\t} while (rec_off >= end_off);\n\n\t/* fill hole */\n\thfs_bnode_move(node, fd->keyoffset, fd->keyoffset + size,\n\t\t       data_off - fd->keyoffset - size);\nskip:\n\thfs_bnode_dump(node);\n\tif (!fd->record)\n\t\thfs_brec_update_parent(fd);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfs_brec_find",
          "args": [
            "&fd",
            "hfs_find_rec_by_key"
          ],
          "line": 314
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_brec_find",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/bfind.c",
          "lines": "165-217",
          "snippet": "int hfs_brec_find(struct hfs_find_data *fd, search_strategy_t do_key_compare)\n{\n\tstruct hfs_btree *tree;\n\tstruct hfs_bnode *bnode;\n\tu32 nidx, parent;\n\t__be32 data;\n\tint height, res;\n\n\ttree = fd->tree;\n\tif (fd->bnode)\n\t\thfs_bnode_put(fd->bnode);\n\tfd->bnode = NULL;\n\tnidx = tree->root;\n\tif (!nidx)\n\t\treturn -ENOENT;\n\theight = tree->depth;\n\tres = 0;\n\tparent = 0;\n\tfor (;;) {\n\t\tbnode = hfs_bnode_find(tree, nidx);\n\t\tif (IS_ERR(bnode)) {\n\t\t\tres = PTR_ERR(bnode);\n\t\t\tbnode = NULL;\n\t\t\tbreak;\n\t\t}\n\t\tif (bnode->height != height)\n\t\t\tgoto invalid;\n\t\tif (bnode->type != (--height ? HFS_NODE_INDEX : HFS_NODE_LEAF))\n\t\t\tgoto invalid;\n\t\tbnode->parent = parent;\n\n\t\tres = __hfs_brec_find(bnode, fd, do_key_compare);\n\t\tif (!height)\n\t\t\tbreak;\n\t\tif (fd->record < 0)\n\t\t\tgoto release;\n\n\t\tparent = nidx;\n\t\thfs_bnode_read(bnode, &data, fd->entryoffset, 4);\n\t\tnidx = be32_to_cpu(data);\n\t\thfs_bnode_put(bnode);\n\t}\n\tfd->bnode = bnode;\n\treturn res;\n\ninvalid:\n\tpr_err(\"inconsistency in B*Tree (%d,%d,%d,%u,%u)\\n\",\n\t\theight, bnode->height, bnode->type, nidx, parent);\n\tres = -EIO;\nrelease:\n\thfs_bnode_put(bnode);\n\treturn res;\n}",
          "includes": [
            "#include \"hfsplus_fs.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_fs.h\"\n#include <linux/slab.h>\n\nint hfs_brec_find(struct hfs_find_data *fd, search_strategy_t do_key_compare)\n{\n\tstruct hfs_btree *tree;\n\tstruct hfs_bnode *bnode;\n\tu32 nidx, parent;\n\t__be32 data;\n\tint height, res;\n\n\ttree = fd->tree;\n\tif (fd->bnode)\n\t\thfs_bnode_put(fd->bnode);\n\tfd->bnode = NULL;\n\tnidx = tree->root;\n\tif (!nidx)\n\t\treturn -ENOENT;\n\theight = tree->depth;\n\tres = 0;\n\tparent = 0;\n\tfor (;;) {\n\t\tbnode = hfs_bnode_find(tree, nidx);\n\t\tif (IS_ERR(bnode)) {\n\t\t\tres = PTR_ERR(bnode);\n\t\t\tbnode = NULL;\n\t\t\tbreak;\n\t\t}\n\t\tif (bnode->height != height)\n\t\t\tgoto invalid;\n\t\tif (bnode->type != (--height ? HFS_NODE_INDEX : HFS_NODE_LEAF))\n\t\t\tgoto invalid;\n\t\tbnode->parent = parent;\n\n\t\tres = __hfs_brec_find(bnode, fd, do_key_compare);\n\t\tif (!height)\n\t\t\tbreak;\n\t\tif (fd->record < 0)\n\t\t\tgoto release;\n\n\t\tparent = nidx;\n\t\thfs_bnode_read(bnode, &data, fd->entryoffset, 4);\n\t\tnidx = be32_to_cpu(data);\n\t\thfs_bnode_put(bnode);\n\t}\n\tfd->bnode = bnode;\n\treturn res;\n\ninvalid:\n\tpr_err(\"inconsistency in B*Tree (%d,%d,%d,%u,%u)\\n\",\n\t\theight, bnode->height, bnode->type, nidx, parent);\n\tres = -EIO;\nrelease:\n\thfs_bnode_put(bnode);\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfsplus_cat_build_key_with_cnid",
          "args": [
            "sb",
            "fd.search_key",
            "cnid"
          ],
          "line": 313
        },
        "resolved": true,
        "details": {
          "function_name": "hfsplus_cat_build_key_with_cnid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/catalog.c",
          "lines": "59-65",
          "snippet": "void hfsplus_cat_build_key_with_cnid(struct super_block *sb,\n\t\t\thfsplus_btree_key *key, u32 parent)\n{\n\tkey->cat.parent = cpu_to_be32(parent);\n\tkey->cat.name.length = 0;\n\tkey->key_len = cpu_to_be16(6);\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n\nvoid hfsplus_cat_build_key_with_cnid(struct super_block *sb,\n\t\t\thfsplus_btree_key *key, u32 parent)\n{\n\tkey->cat.parent = cpu_to_be32(parent);\n\tkey->cat.name.length = 0;\n\tkey->key_len = cpu_to_be16(6);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfsplus_mark_inode_dirty",
          "args": [
            "dir",
            "HFSPLUS_I_CAT_DIRTY"
          ],
          "line": 307
        },
        "resolved": true,
        "details": {
          "function_name": "hfsplus_mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/hfsplus_fs.h",
          "lines": "275-280",
          "snippet": "static inline void hfsplus_mark_inode_dirty(struct inode *inode,\n\t\tunsigned int flag)\n{\n\tset_bit(flag, &HFSPLUS_I(inode)->flags);\n\tmark_inode_dirty(inode);\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mutex.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/mutex.h>\n#include <linux/fs.h>\n\nstatic inline void hfsplus_mark_inode_dirty(struct inode *inode,\n\t\tunsigned int flag)\n{\n\tset_bit(flag, &HFSPLUS_I(inode)->flags);\n\tmark_inode_dirty(inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfsplus_subfolders_inc",
          "args": [
            "dir"
          ],
          "line": 305
        },
        "resolved": true,
        "details": {
          "function_name": "hfsplus_subfolders_inc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/catalog.c",
          "lines": "222-233",
          "snippet": "static void hfsplus_subfolders_inc(struct inode *dir)\n{\n\tstruct hfsplus_sb_info *sbi = HFSPLUS_SB(dir->i_sb);\n\n\tif (test_bit(HFSPLUS_SB_HFSX, &sbi->flags)) {\n\t\t/*\n\t\t * Increment subfolder count. Note, the value is only meaningful\n\t\t * for folders with HFSPLUS_HAS_FOLDER_COUNT flag set.\n\t\t */\n\t\tHFSPLUS_I(dir)->subfolders++;\n\t}\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n\nstatic void hfsplus_subfolders_inc(struct inode *dir)\n{\n\tstruct hfsplus_sb_info *sbi = HFSPLUS_SB(dir->i_sb);\n\n\tif (test_bit(HFSPLUS_SB_HFSX, &sbi->flags)) {\n\t\t/*\n\t\t * Increment subfolder count. Note, the value is only meaningful\n\t\t * for folders with HFSPLUS_HAS_FOLDER_COUNT flag set.\n\t\t */\n\t\tHFSPLUS_I(dir)->subfolders++;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "inode->i_mode"
          ],
          "line": 304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfs_brec_insert",
          "args": [
            "&fd",
            "&entry",
            "entry_size"
          ],
          "line": 299
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_brec_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/brec.c",
          "lines": "62-175",
          "snippet": "int hfs_brec_insert(struct hfs_find_data *fd, void *entry, int entry_len)\n{\n\tstruct hfs_btree *tree;\n\tstruct hfs_bnode *node, *new_node;\n\tint size, key_len, rec;\n\tint data_off, end_off;\n\tint idx_rec_off, data_rec_off, end_rec_off;\n\t__be32 cnid;\n\n\ttree = fd->tree;\n\tif (!fd->bnode) {\n\t\tif (!tree->root)\n\t\t\thfs_btree_inc_height(tree);\n\t\tfd->bnode = hfs_bnode_find(tree, tree->leaf_head);\n\t\tif (IS_ERR(fd->bnode))\n\t\t\treturn PTR_ERR(fd->bnode);\n\t\tfd->record = -1;\n\t}\n\tnew_node = NULL;\n\tkey_len = be16_to_cpu(fd->search_key->key_len) + 2;\nagain:\n\t/* new record idx and complete record size */\n\trec = fd->record + 1;\n\tsize = key_len + entry_len;\n\n\tnode = fd->bnode;\n\thfs_bnode_dump(node);\n\t/* get last offset */\n\tend_rec_off = tree->node_size - (node->num_recs + 1) * 2;\n\tend_off = hfs_bnode_read_u16(node, end_rec_off);\n\tend_rec_off -= 2;\n\thfs_dbg(BNODE_MOD, \"insert_rec: %d, %d, %d, %d\\n\",\n\t\trec, size, end_off, end_rec_off);\n\tif (size > end_rec_off - end_off) {\n\t\tif (new_node)\n\t\t\tpanic(\"not enough room!\\n\");\n\t\tnew_node = hfs_bnode_split(fd);\n\t\tif (IS_ERR(new_node))\n\t\t\treturn PTR_ERR(new_node);\n\t\tgoto again;\n\t}\n\tif (node->type == HFS_NODE_LEAF) {\n\t\ttree->leaf_count++;\n\t\tmark_inode_dirty(tree->inode);\n\t}\n\tnode->num_recs++;\n\t/* write new last offset */\n\thfs_bnode_write_u16(node,\n\t\toffsetof(struct hfs_bnode_desc, num_recs),\n\t\tnode->num_recs);\n\thfs_bnode_write_u16(node, end_rec_off, end_off + size);\n\tdata_off = end_off;\n\tdata_rec_off = end_rec_off + 2;\n\tidx_rec_off = tree->node_size - (rec + 1) * 2;\n\tif (idx_rec_off == data_rec_off)\n\t\tgoto skip;\n\t/* move all following entries */\n\tdo {\n\t\tdata_off = hfs_bnode_read_u16(node, data_rec_off + 2);\n\t\thfs_bnode_write_u16(node, data_rec_off, data_off + size);\n\t\tdata_rec_off += 2;\n\t} while (data_rec_off < idx_rec_off);\n\n\t/* move data away */\n\thfs_bnode_move(node, data_off + size, data_off,\n\t\t       end_off - data_off);\n\nskip:\n\thfs_bnode_write(node, fd->search_key, data_off, key_len);\n\thfs_bnode_write(node, entry, data_off + key_len, entry_len);\n\thfs_bnode_dump(node);\n\n\t/*\n\t * update parent key if we inserted a key\n\t * at the start of the node and it is not the new node\n\t */\n\tif (!rec && new_node != node) {\n\t\thfs_bnode_read_key(node, fd->search_key, data_off + size);\n\t\thfs_brec_update_parent(fd);\n\t}\n\n\tif (new_node) {\n\t\thfs_bnode_put(fd->bnode);\n\t\tif (!new_node->parent) {\n\t\t\thfs_btree_inc_height(tree);\n\t\t\tnew_node->parent = tree->root;\n\t\t}\n\t\tfd->bnode = hfs_bnode_find(tree, new_node->parent);\n\n\t\t/* create index data entry */\n\t\tcnid = cpu_to_be32(new_node->this);\n\t\tentry = &cnid;\n\t\tentry_len = sizeof(cnid);\n\n\t\t/* get index key */\n\t\thfs_bnode_read_key(new_node, fd->search_key, 14);\n\t\t__hfs_brec_find(fd->bnode, fd, hfs_find_rec_by_key);\n\n\t\thfs_bnode_put(new_node);\n\t\tnew_node = NULL;\n\n\t\tif ((tree->attributes & HFS_TREE_VARIDXKEYS) ||\n\t\t\t\t(tree->cnid == HFSPLUS_ATTR_CNID))\n\t\t\tkey_len = be16_to_cpu(fd->search_key->key_len) + 2;\n\t\telse {\n\t\t\tfd->search_key->key_len =\n\t\t\t\tcpu_to_be16(tree->max_key_len);\n\t\t\tkey_len = tree->max_key_len + 2;\n\t\t}\n\t\tgoto again;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hfs_bnode *hfs_bnode_split(struct hfs_find_data *fd);",
            "static int hfs_brec_update_parent(struct hfs_find_data *fd);",
            "static int hfs_btree_inc_height(struct hfs_btree *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n\nstatic struct hfs_bnode *hfs_bnode_split(struct hfs_find_data *fd);\nstatic int hfs_brec_update_parent(struct hfs_find_data *fd);\nstatic int hfs_btree_inc_height(struct hfs_btree *);\n\nint hfs_brec_insert(struct hfs_find_data *fd, void *entry, int entry_len)\n{\n\tstruct hfs_btree *tree;\n\tstruct hfs_bnode *node, *new_node;\n\tint size, key_len, rec;\n\tint data_off, end_off;\n\tint idx_rec_off, data_rec_off, end_rec_off;\n\t__be32 cnid;\n\n\ttree = fd->tree;\n\tif (!fd->bnode) {\n\t\tif (!tree->root)\n\t\t\thfs_btree_inc_height(tree);\n\t\tfd->bnode = hfs_bnode_find(tree, tree->leaf_head);\n\t\tif (IS_ERR(fd->bnode))\n\t\t\treturn PTR_ERR(fd->bnode);\n\t\tfd->record = -1;\n\t}\n\tnew_node = NULL;\n\tkey_len = be16_to_cpu(fd->search_key->key_len) + 2;\nagain:\n\t/* new record idx and complete record size */\n\trec = fd->record + 1;\n\tsize = key_len + entry_len;\n\n\tnode = fd->bnode;\n\thfs_bnode_dump(node);\n\t/* get last offset */\n\tend_rec_off = tree->node_size - (node->num_recs + 1) * 2;\n\tend_off = hfs_bnode_read_u16(node, end_rec_off);\n\tend_rec_off -= 2;\n\thfs_dbg(BNODE_MOD, \"insert_rec: %d, %d, %d, %d\\n\",\n\t\trec, size, end_off, end_rec_off);\n\tif (size > end_rec_off - end_off) {\n\t\tif (new_node)\n\t\t\tpanic(\"not enough room!\\n\");\n\t\tnew_node = hfs_bnode_split(fd);\n\t\tif (IS_ERR(new_node))\n\t\t\treturn PTR_ERR(new_node);\n\t\tgoto again;\n\t}\n\tif (node->type == HFS_NODE_LEAF) {\n\t\ttree->leaf_count++;\n\t\tmark_inode_dirty(tree->inode);\n\t}\n\tnode->num_recs++;\n\t/* write new last offset */\n\thfs_bnode_write_u16(node,\n\t\toffsetof(struct hfs_bnode_desc, num_recs),\n\t\tnode->num_recs);\n\thfs_bnode_write_u16(node, end_rec_off, end_off + size);\n\tdata_off = end_off;\n\tdata_rec_off = end_rec_off + 2;\n\tidx_rec_off = tree->node_size - (rec + 1) * 2;\n\tif (idx_rec_off == data_rec_off)\n\t\tgoto skip;\n\t/* move all following entries */\n\tdo {\n\t\tdata_off = hfs_bnode_read_u16(node, data_rec_off + 2);\n\t\thfs_bnode_write_u16(node, data_rec_off, data_off + size);\n\t\tdata_rec_off += 2;\n\t} while (data_rec_off < idx_rec_off);\n\n\t/* move data away */\n\thfs_bnode_move(node, data_off + size, data_off,\n\t\t       end_off - data_off);\n\nskip:\n\thfs_bnode_write(node, fd->search_key, data_off, key_len);\n\thfs_bnode_write(node, entry, data_off + key_len, entry_len);\n\thfs_bnode_dump(node);\n\n\t/*\n\t * update parent key if we inserted a key\n\t * at the start of the node and it is not the new node\n\t */\n\tif (!rec && new_node != node) {\n\t\thfs_bnode_read_key(node, fd->search_key, data_off + size);\n\t\thfs_brec_update_parent(fd);\n\t}\n\n\tif (new_node) {\n\t\thfs_bnode_put(fd->bnode);\n\t\tif (!new_node->parent) {\n\t\t\thfs_btree_inc_height(tree);\n\t\t\tnew_node->parent = tree->root;\n\t\t}\n\t\tfd->bnode = hfs_bnode_find(tree, new_node->parent);\n\n\t\t/* create index data entry */\n\t\tcnid = cpu_to_be32(new_node->this);\n\t\tentry = &cnid;\n\t\tentry_len = sizeof(cnid);\n\n\t\t/* get index key */\n\t\thfs_bnode_read_key(new_node, fd->search_key, 14);\n\t\t__hfs_brec_find(fd->bnode, fd, hfs_find_rec_by_key);\n\n\t\thfs_bnode_put(new_node);\n\t\tnew_node = NULL;\n\n\t\tif ((tree->attributes & HFS_TREE_VARIDXKEYS) ||\n\t\t\t\t(tree->cnid == HFSPLUS_ATTR_CNID))\n\t\t\tkey_len = be16_to_cpu(fd->search_key->key_len) + 2;\n\t\telse {\n\t\t\tfd->search_key->key_len =\n\t\t\t\tcpu_to_be16(tree->max_key_len);\n\t\t\tkey_len = tree->max_key_len + 2;\n\t\t}\n\t\tgoto again;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfsplus_cat_build_record",
          "args": [
            "&entry",
            "cnid",
            "inode"
          ],
          "line": 291
        },
        "resolved": true,
        "details": {
          "function_name": "hfsplus_cat_build_record",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/catalog.c",
          "lines": "104-173",
          "snippet": "static int hfsplus_cat_build_record(hfsplus_cat_entry *entry,\n\t\tu32 cnid, struct inode *inode)\n{\n\tstruct hfsplus_sb_info *sbi = HFSPLUS_SB(inode->i_sb);\n\n\tif (S_ISDIR(inode->i_mode)) {\n\t\tstruct hfsplus_cat_folder *folder;\n\n\t\tfolder = &entry->folder;\n\t\tmemset(folder, 0, sizeof(*folder));\n\t\tfolder->type = cpu_to_be16(HFSPLUS_FOLDER);\n\t\tif (test_bit(HFSPLUS_SB_HFSX, &sbi->flags))\n\t\t\tfolder->flags |= cpu_to_be16(HFSPLUS_HAS_FOLDER_COUNT);\n\t\tfolder->id = cpu_to_be32(inode->i_ino);\n\t\tHFSPLUS_I(inode)->create_date =\n\t\t\tfolder->create_date =\n\t\t\tfolder->content_mod_date =\n\t\t\tfolder->attribute_mod_date =\n\t\t\tfolder->access_date = hfsp_now2mt();\n\t\thfsplus_cat_set_perms(inode, &folder->permissions);\n\t\tif (inode == sbi->hidden_dir)\n\t\t\t/* invisible and namelocked */\n\t\t\tfolder->user_info.frFlags = cpu_to_be16(0x5000);\n\t\treturn sizeof(*folder);\n\t} else {\n\t\tstruct hfsplus_cat_file *file;\n\n\t\tfile = &entry->file;\n\t\tmemset(file, 0, sizeof(*file));\n\t\tfile->type = cpu_to_be16(HFSPLUS_FILE);\n\t\tfile->flags = cpu_to_be16(HFSPLUS_FILE_THREAD_EXISTS);\n\t\tfile->id = cpu_to_be32(cnid);\n\t\tHFSPLUS_I(inode)->create_date =\n\t\t\tfile->create_date =\n\t\t\tfile->content_mod_date =\n\t\t\tfile->attribute_mod_date =\n\t\t\tfile->access_date = hfsp_now2mt();\n\t\tif (cnid == inode->i_ino) {\n\t\t\thfsplus_cat_set_perms(inode, &file->permissions);\n\t\t\tif (S_ISLNK(inode->i_mode)) {\n\t\t\t\tfile->user_info.fdType =\n\t\t\t\t\tcpu_to_be32(HFSP_SYMLINK_TYPE);\n\t\t\t\tfile->user_info.fdCreator =\n\t\t\t\t\tcpu_to_be32(HFSP_SYMLINK_CREATOR);\n\t\t\t} else {\n\t\t\t\tfile->user_info.fdType =\n\t\t\t\t\tcpu_to_be32(sbi->type);\n\t\t\t\tfile->user_info.fdCreator =\n\t\t\t\t\tcpu_to_be32(sbi->creator);\n\t\t\t}\n\t\t\tif (HFSPLUS_FLG_IMMUTABLE &\n\t\t\t\t\t(file->permissions.rootflags |\n\t\t\t\t\tfile->permissions.userflags))\n\t\t\t\tfile->flags |=\n\t\t\t\t\tcpu_to_be16(HFSPLUS_FILE_LOCKED);\n\t\t} else {\n\t\t\tfile->user_info.fdType =\n\t\t\t\tcpu_to_be32(HFSP_HARDLINK_TYPE);\n\t\t\tfile->user_info.fdCreator =\n\t\t\t\tcpu_to_be32(HFSP_HFSPLUS_CREATOR);\n\t\t\tfile->user_info.fdFlags =\n\t\t\t\tcpu_to_be16(0x100);\n\t\t\tfile->create_date =\n\t\t\t\tHFSPLUS_I(sbi->hidden_dir)->create_date;\n\t\t\tfile->permissions.dev =\n\t\t\t\tcpu_to_be32(HFSPLUS_I(inode)->linkid);\n\t\t}\n\t\treturn sizeof(*file);\n\t}\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n\nstatic int hfsplus_cat_build_record(hfsplus_cat_entry *entry,\n\t\tu32 cnid, struct inode *inode)\n{\n\tstruct hfsplus_sb_info *sbi = HFSPLUS_SB(inode->i_sb);\n\n\tif (S_ISDIR(inode->i_mode)) {\n\t\tstruct hfsplus_cat_folder *folder;\n\n\t\tfolder = &entry->folder;\n\t\tmemset(folder, 0, sizeof(*folder));\n\t\tfolder->type = cpu_to_be16(HFSPLUS_FOLDER);\n\t\tif (test_bit(HFSPLUS_SB_HFSX, &sbi->flags))\n\t\t\tfolder->flags |= cpu_to_be16(HFSPLUS_HAS_FOLDER_COUNT);\n\t\tfolder->id = cpu_to_be32(inode->i_ino);\n\t\tHFSPLUS_I(inode)->create_date =\n\t\t\tfolder->create_date =\n\t\t\tfolder->content_mod_date =\n\t\t\tfolder->attribute_mod_date =\n\t\t\tfolder->access_date = hfsp_now2mt();\n\t\thfsplus_cat_set_perms(inode, &folder->permissions);\n\t\tif (inode == sbi->hidden_dir)\n\t\t\t/* invisible and namelocked */\n\t\t\tfolder->user_info.frFlags = cpu_to_be16(0x5000);\n\t\treturn sizeof(*folder);\n\t} else {\n\t\tstruct hfsplus_cat_file *file;\n\n\t\tfile = &entry->file;\n\t\tmemset(file, 0, sizeof(*file));\n\t\tfile->type = cpu_to_be16(HFSPLUS_FILE);\n\t\tfile->flags = cpu_to_be16(HFSPLUS_FILE_THREAD_EXISTS);\n\t\tfile->id = cpu_to_be32(cnid);\n\t\tHFSPLUS_I(inode)->create_date =\n\t\t\tfile->create_date =\n\t\t\tfile->content_mod_date =\n\t\t\tfile->attribute_mod_date =\n\t\t\tfile->access_date = hfsp_now2mt();\n\t\tif (cnid == inode->i_ino) {\n\t\t\thfsplus_cat_set_perms(inode, &file->permissions);\n\t\t\tif (S_ISLNK(inode->i_mode)) {\n\t\t\t\tfile->user_info.fdType =\n\t\t\t\t\tcpu_to_be32(HFSP_SYMLINK_TYPE);\n\t\t\t\tfile->user_info.fdCreator =\n\t\t\t\t\tcpu_to_be32(HFSP_SYMLINK_CREATOR);\n\t\t\t} else {\n\t\t\t\tfile->user_info.fdType =\n\t\t\t\t\tcpu_to_be32(sbi->type);\n\t\t\t\tfile->user_info.fdCreator =\n\t\t\t\t\tcpu_to_be32(sbi->creator);\n\t\t\t}\n\t\t\tif (HFSPLUS_FLG_IMMUTABLE &\n\t\t\t\t\t(file->permissions.rootflags |\n\t\t\t\t\tfile->permissions.userflags))\n\t\t\t\tfile->flags |=\n\t\t\t\t\tcpu_to_be16(HFSPLUS_FILE_LOCKED);\n\t\t} else {\n\t\t\tfile->user_info.fdType =\n\t\t\t\tcpu_to_be32(HFSP_HARDLINK_TYPE);\n\t\t\tfile->user_info.fdCreator =\n\t\t\t\tcpu_to_be32(HFSP_HFSPLUS_CREATOR);\n\t\t\tfile->user_info.fdFlags =\n\t\t\t\tcpu_to_be16(0x100);\n\t\t\tfile->create_date =\n\t\t\t\tHFSPLUS_I(sbi->hidden_dir)->create_date;\n\t\t\tfile->permissions.dev =\n\t\t\t\tcpu_to_be32(HFSPLUS_I(inode)->linkid);\n\t\t}\n\t\treturn sizeof(*file);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "err"
          ],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfsplus_cat_build_key",
          "args": [
            "sb",
            "fd.search_key",
            "dir->i_ino",
            "str"
          ],
          "line": 287
        },
        "resolved": true,
        "details": {
          "function_name": "hfsplus_cat_build_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/catalog.c",
          "lines": "42-56",
          "snippet": "int hfsplus_cat_build_key(struct super_block *sb,\n\t\thfsplus_btree_key *key, u32 parent, struct qstr *str)\n{\n\tint len, err;\n\n\tkey->cat.parent = cpu_to_be32(parent);\n\terr = hfsplus_asc2uni(sb, &key->cat.name, HFSPLUS_MAX_STRLEN,\n\t\t\tstr->name, str->len);\n\tif (unlikely(err < 0))\n\t\treturn err;\n\n\tlen = be16_to_cpu(key->cat.name.length);\n\tkey->key_len = cpu_to_be16(6 + 2 * len);\n\treturn 0;\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n\nint hfsplus_cat_build_key(struct super_block *sb,\n\t\thfsplus_btree_key *key, u32 parent, struct qstr *str)\n{\n\tint len, err;\n\n\tkey->cat.parent = cpu_to_be32(parent);\n\terr = hfsplus_asc2uni(sb, &key->cat.name, HFSPLUS_MAX_STRLEN,\n\t\t\tstr->name, str->len);\n\tif (unlikely(err < 0))\n\t\treturn err;\n\n\tlen = be16_to_cpu(key->cat.name.length);\n\tkey->key_len = cpu_to_be16(6 + 2 * len);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "entry_size < 0"
          ],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfsplus_fill_cat_thread",
          "args": [
            "sb",
            "&entry",
            "S_ISDIR(inode->i_mode) ?\n\t\t\tHFSPLUS_FOLDER_THREAD : HFSPLUS_FILE_THREAD",
            "dir->i_ino",
            "str"
          ],
          "line": 268
        },
        "resolved": true,
        "details": {
          "function_name": "hfsplus_fill_cat_thread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/catalog.c",
          "lines": "175-190",
          "snippet": "static int hfsplus_fill_cat_thread(struct super_block *sb,\n\t\t\t\t   hfsplus_cat_entry *entry, int type,\n\t\t\t\t   u32 parentid, struct qstr *str)\n{\n\tint err;\n\n\tentry->type = cpu_to_be16(type);\n\tentry->thread.reserved = 0;\n\tentry->thread.parentID = cpu_to_be32(parentid);\n\terr = hfsplus_asc2uni(sb, &entry->thread.nodeName, HFSPLUS_MAX_STRLEN,\n\t\t\t\tstr->name, str->len);\n\tif (unlikely(err < 0))\n\t\treturn err;\n\n\treturn 10 + be16_to_cpu(entry->thread.nodeName.length) * 2;\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n\nstatic int hfsplus_fill_cat_thread(struct super_block *sb,\n\t\t\t\t   hfsplus_cat_entry *entry, int type,\n\t\t\t\t   u32 parentid, struct qstr *str)\n{\n\tint err;\n\n\tentry->type = cpu_to_be16(type);\n\tentry->thread.reserved = 0;\n\tentry->thread.parentID = cpu_to_be32(parentid);\n\terr = hfsplus_asc2uni(sb, &entry->thread.nodeName, HFSPLUS_MAX_STRLEN,\n\t\t\t\tstr->name, str->len);\n\tif (unlikely(err < 0))\n\t\treturn err;\n\n\treturn 10 + be16_to_cpu(entry->thread.nodeName.length) * 2;\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "inode->i_mode"
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfs_find_init",
          "args": [
            "HFSPLUS_SB(sb)->cat_tree",
            "&fd"
          ],
          "line": 263
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_find_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/bfind.c",
          "lines": "14-41",
          "snippet": "int hfs_find_init(struct hfs_btree *tree, struct hfs_find_data *fd)\n{\n\tvoid *ptr;\n\n\tfd->tree = tree;\n\tfd->bnode = NULL;\n\tptr = kmalloc(tree->max_key_len * 2 + 4, GFP_KERNEL);\n\tif (!ptr)\n\t\treturn -ENOMEM;\n\tfd->search_key = ptr;\n\tfd->key = ptr + tree->max_key_len + 2;\n\thfs_dbg(BNODE_REFS, \"find_init: %d (%p)\\n\",\n\t\ttree->cnid, __builtin_return_address(0));\n\tswitch (tree->cnid) {\n\tcase HFSPLUS_CAT_CNID:\n\t\tmutex_lock_nested(&tree->tree_lock, CATALOG_BTREE_MUTEX);\n\t\tbreak;\n\tcase HFSPLUS_EXT_CNID:\n\t\tmutex_lock_nested(&tree->tree_lock, EXTENTS_BTREE_MUTEX);\n\t\tbreak;\n\tcase HFSPLUS_ATTR_CNID:\n\t\tmutex_lock_nested(&tree->tree_lock, ATTR_BTREE_MUTEX);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"hfsplus_fs.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_fs.h\"\n#include <linux/slab.h>\n\nint hfs_find_init(struct hfs_btree *tree, struct hfs_find_data *fd)\n{\n\tvoid *ptr;\n\n\tfd->tree = tree;\n\tfd->bnode = NULL;\n\tptr = kmalloc(tree->max_key_len * 2 + 4, GFP_KERNEL);\n\tif (!ptr)\n\t\treturn -ENOMEM;\n\tfd->search_key = ptr;\n\tfd->key = ptr + tree->max_key_len + 2;\n\thfs_dbg(BNODE_REFS, \"find_init: %d (%p)\\n\",\n\t\ttree->cnid, __builtin_return_address(0));\n\tswitch (tree->cnid) {\n\tcase HFSPLUS_CAT_CNID:\n\t\tmutex_lock_nested(&tree->tree_lock, CATALOG_BTREE_MUTEX);\n\t\tbreak;\n\tcase HFSPLUS_EXT_CNID:\n\t\tmutex_lock_nested(&tree->tree_lock, EXTENTS_BTREE_MUTEX);\n\t\tbreak;\n\tcase HFSPLUS_ATTR_CNID:\n\t\tmutex_lock_nested(&tree->tree_lock, ATTR_BTREE_MUTEX);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "HFSPLUS_SB",
          "args": [
            "sb"
          ],
          "line": 263
        },
        "resolved": true,
        "details": {
          "function_name": "HFSPLUS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/hfsplus_fs.h",
          "lines": "202-205",
          "snippet": "static inline struct hfsplus_sb_info *HFSPLUS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mutex.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/mutex.h>\n#include <linux/fs.h>\n\nstatic inline struct hfsplus_sb_info *HFSPLUS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfs_dbg",
          "args": [
            "CAT_MOD",
            "\"create_cat: %s,%u(%d)\\n\"",
            "str->name",
            "cnid",
            "inode->i_nlink"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n\nint hfsplus_create_cat(u32 cnid, struct inode *dir,\n\t\tstruct qstr *str, struct inode *inode)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tstruct hfs_find_data fd;\n\thfsplus_cat_entry entry;\n\tint entry_size;\n\tint err;\n\n\thfs_dbg(CAT_MOD, \"create_cat: %s,%u(%d)\\n\",\n\t\tstr->name, cnid, inode->i_nlink);\n\terr = hfs_find_init(HFSPLUS_SB(sb)->cat_tree, &fd);\n\tif (err)\n\t\treturn err;\n\n\thfsplus_cat_build_key_with_cnid(sb, fd.search_key, cnid);\n\tentry_size = hfsplus_fill_cat_thread(sb, &entry,\n\t\tS_ISDIR(inode->i_mode) ?\n\t\t\tHFSPLUS_FOLDER_THREAD : HFSPLUS_FILE_THREAD,\n\t\tdir->i_ino, str);\n\tif (unlikely(entry_size < 0)) {\n\t\terr = entry_size;\n\t\tgoto err2;\n\t}\n\n\terr = hfs_brec_find(&fd, hfs_find_rec_by_key);\n\tif (err != -ENOENT) {\n\t\tif (!err)\n\t\t\terr = -EEXIST;\n\t\tgoto err2;\n\t}\n\terr = hfs_brec_insert(&fd, &entry, entry_size);\n\tif (err)\n\t\tgoto err2;\n\n\terr = hfsplus_cat_build_key(sb, fd.search_key, dir->i_ino, str);\n\tif (unlikely(err))\n\t\tgoto err1;\n\n\tentry_size = hfsplus_cat_build_record(&entry, cnid, inode);\n\terr = hfs_brec_find(&fd, hfs_find_rec_by_key);\n\tif (err != -ENOENT) {\n\t\t/* panic? */\n\t\tif (!err)\n\t\t\terr = -EEXIST;\n\t\tgoto err1;\n\t}\n\terr = hfs_brec_insert(&fd, &entry, entry_size);\n\tif (err)\n\t\tgoto err1;\n\n\tdir->i_size++;\n\tif (S_ISDIR(inode->i_mode))\n\t\thfsplus_subfolders_inc(dir);\n\tdir->i_mtime = dir->i_ctime = CURRENT_TIME_SEC;\n\thfsplus_mark_inode_dirty(dir, HFSPLUS_I_CAT_DIRTY);\n\n\thfs_find_exit(&fd);\n\treturn 0;\n\nerr1:\n\thfsplus_cat_build_key_with_cnid(sb, fd.search_key, cnid);\n\tif (!hfs_brec_find(&fd, hfs_find_rec_by_key))\n\t\thfs_brec_remove(&fd);\nerr2:\n\thfs_find_exit(&fd);\n\treturn err;\n}"
  },
  {
    "function_name": "hfsplus_subfolders_dec",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/catalog.c",
    "lines": "235-250",
    "snippet": "static void hfsplus_subfolders_dec(struct inode *dir)\n{\n\tstruct hfsplus_sb_info *sbi = HFSPLUS_SB(dir->i_sb);\n\n\tif (test_bit(HFSPLUS_SB_HFSX, &sbi->flags)) {\n\t\t/*\n\t\t * Decrement subfolder count. Note, the value is only meaningful\n\t\t * for folders with HFSPLUS_HAS_FOLDER_COUNT flag set.\n\t\t *\n\t\t * Check for zero. Some subfolders may have been created\n\t\t * by an implementation ignorant of this counter.\n\t\t */\n\t\tif (HFSPLUS_I(dir)->subfolders)\n\t\t\tHFSPLUS_I(dir)->subfolders--;\n\t}\n}",
    "includes": [
      "#include \"hfsplus_raw.h\"",
      "#include \"hfsplus_fs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "HFSPLUS_I",
          "args": [
            "dir"
          ],
          "line": 248
        },
        "resolved": true,
        "details": {
          "function_name": "HFSPLUS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/hfsplus_fs.h",
          "lines": "264-267",
          "snippet": "static inline struct hfsplus_inode_info *HFSPLUS_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct hfsplus_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mutex.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/mutex.h>\n#include <linux/fs.h>\n\nstatic inline struct hfsplus_inode_info *HFSPLUS_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct hfsplus_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "HFSPLUS_SB_HFSX",
            "&sbi->flags"
          ],
          "line": 239
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "HFSPLUS_SB",
          "args": [
            "dir->i_sb"
          ],
          "line": 237
        },
        "resolved": true,
        "details": {
          "function_name": "HFSPLUS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/hfsplus_fs.h",
          "lines": "202-205",
          "snippet": "static inline struct hfsplus_sb_info *HFSPLUS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mutex.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/mutex.h>\n#include <linux/fs.h>\n\nstatic inline struct hfsplus_sb_info *HFSPLUS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n\nstatic void hfsplus_subfolders_dec(struct inode *dir)\n{\n\tstruct hfsplus_sb_info *sbi = HFSPLUS_SB(dir->i_sb);\n\n\tif (test_bit(HFSPLUS_SB_HFSX, &sbi->flags)) {\n\t\t/*\n\t\t * Decrement subfolder count. Note, the value is only meaningful\n\t\t * for folders with HFSPLUS_HAS_FOLDER_COUNT flag set.\n\t\t *\n\t\t * Check for zero. Some subfolders may have been created\n\t\t * by an implementation ignorant of this counter.\n\t\t */\n\t\tif (HFSPLUS_I(dir)->subfolders)\n\t\t\tHFSPLUS_I(dir)->subfolders--;\n\t}\n}"
  },
  {
    "function_name": "hfsplus_subfolders_inc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/catalog.c",
    "lines": "222-233",
    "snippet": "static void hfsplus_subfolders_inc(struct inode *dir)\n{\n\tstruct hfsplus_sb_info *sbi = HFSPLUS_SB(dir->i_sb);\n\n\tif (test_bit(HFSPLUS_SB_HFSX, &sbi->flags)) {\n\t\t/*\n\t\t * Increment subfolder count. Note, the value is only meaningful\n\t\t * for folders with HFSPLUS_HAS_FOLDER_COUNT flag set.\n\t\t */\n\t\tHFSPLUS_I(dir)->subfolders++;\n\t}\n}",
    "includes": [
      "#include \"hfsplus_raw.h\"",
      "#include \"hfsplus_fs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "HFSPLUS_I",
          "args": [
            "dir"
          ],
          "line": 231
        },
        "resolved": true,
        "details": {
          "function_name": "HFSPLUS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/hfsplus_fs.h",
          "lines": "264-267",
          "snippet": "static inline struct hfsplus_inode_info *HFSPLUS_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct hfsplus_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mutex.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/mutex.h>\n#include <linux/fs.h>\n\nstatic inline struct hfsplus_inode_info *HFSPLUS_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct hfsplus_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "HFSPLUS_SB_HFSX",
            "&sbi->flags"
          ],
          "line": 226
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "HFSPLUS_SB",
          "args": [
            "dir->i_sb"
          ],
          "line": 224
        },
        "resolved": true,
        "details": {
          "function_name": "HFSPLUS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/hfsplus_fs.h",
          "lines": "202-205",
          "snippet": "static inline struct hfsplus_sb_info *HFSPLUS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mutex.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/mutex.h>\n#include <linux/fs.h>\n\nstatic inline struct hfsplus_sb_info *HFSPLUS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n\nstatic void hfsplus_subfolders_inc(struct inode *dir)\n{\n\tstruct hfsplus_sb_info *sbi = HFSPLUS_SB(dir->i_sb);\n\n\tif (test_bit(HFSPLUS_SB_HFSX, &sbi->flags)) {\n\t\t/*\n\t\t * Increment subfolder count. Note, the value is only meaningful\n\t\t * for folders with HFSPLUS_HAS_FOLDER_COUNT flag set.\n\t\t */\n\t\tHFSPLUS_I(dir)->subfolders++;\n\t}\n}"
  },
  {
    "function_name": "hfsplus_find_cat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/catalog.c",
    "lines": "193-220",
    "snippet": "int hfsplus_find_cat(struct super_block *sb, u32 cnid,\n\t\t     struct hfs_find_data *fd)\n{\n\thfsplus_cat_entry tmp;\n\tint err;\n\tu16 type;\n\n\thfsplus_cat_build_key_with_cnid(sb, fd->search_key, cnid);\n\terr = hfs_brec_read(fd, &tmp, sizeof(hfsplus_cat_entry));\n\tif (err)\n\t\treturn err;\n\n\ttype = be16_to_cpu(tmp.type);\n\tif (type != HFSPLUS_FOLDER_THREAD && type != HFSPLUS_FILE_THREAD) {\n\t\tpr_err(\"found bad thread record in catalog\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (be16_to_cpu(tmp.thread.nodeName.length) > 255) {\n\t\tpr_err(\"catalog name length corrupted\\n\");\n\t\treturn -EIO;\n\t}\n\n\thfsplus_cat_build_key_uni(fd->search_key,\n\t\tbe32_to_cpu(tmp.thread.parentID),\n\t\t&tmp.thread.nodeName);\n\treturn hfs_brec_find(fd, hfs_find_rec_by_key);\n}",
    "includes": [
      "#include \"hfsplus_raw.h\"",
      "#include \"hfsplus_fs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hfs_brec_find",
          "args": [
            "fd",
            "hfs_find_rec_by_key"
          ],
          "line": 219
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_brec_find",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/bfind.c",
          "lines": "165-217",
          "snippet": "int hfs_brec_find(struct hfs_find_data *fd, search_strategy_t do_key_compare)\n{\n\tstruct hfs_btree *tree;\n\tstruct hfs_bnode *bnode;\n\tu32 nidx, parent;\n\t__be32 data;\n\tint height, res;\n\n\ttree = fd->tree;\n\tif (fd->bnode)\n\t\thfs_bnode_put(fd->bnode);\n\tfd->bnode = NULL;\n\tnidx = tree->root;\n\tif (!nidx)\n\t\treturn -ENOENT;\n\theight = tree->depth;\n\tres = 0;\n\tparent = 0;\n\tfor (;;) {\n\t\tbnode = hfs_bnode_find(tree, nidx);\n\t\tif (IS_ERR(bnode)) {\n\t\t\tres = PTR_ERR(bnode);\n\t\t\tbnode = NULL;\n\t\t\tbreak;\n\t\t}\n\t\tif (bnode->height != height)\n\t\t\tgoto invalid;\n\t\tif (bnode->type != (--height ? HFS_NODE_INDEX : HFS_NODE_LEAF))\n\t\t\tgoto invalid;\n\t\tbnode->parent = parent;\n\n\t\tres = __hfs_brec_find(bnode, fd, do_key_compare);\n\t\tif (!height)\n\t\t\tbreak;\n\t\tif (fd->record < 0)\n\t\t\tgoto release;\n\n\t\tparent = nidx;\n\t\thfs_bnode_read(bnode, &data, fd->entryoffset, 4);\n\t\tnidx = be32_to_cpu(data);\n\t\thfs_bnode_put(bnode);\n\t}\n\tfd->bnode = bnode;\n\treturn res;\n\ninvalid:\n\tpr_err(\"inconsistency in B*Tree (%d,%d,%d,%u,%u)\\n\",\n\t\theight, bnode->height, bnode->type, nidx, parent);\n\tres = -EIO;\nrelease:\n\thfs_bnode_put(bnode);\n\treturn res;\n}",
          "includes": [
            "#include \"hfsplus_fs.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_fs.h\"\n#include <linux/slab.h>\n\nint hfs_brec_find(struct hfs_find_data *fd, search_strategy_t do_key_compare)\n{\n\tstruct hfs_btree *tree;\n\tstruct hfs_bnode *bnode;\n\tu32 nidx, parent;\n\t__be32 data;\n\tint height, res;\n\n\ttree = fd->tree;\n\tif (fd->bnode)\n\t\thfs_bnode_put(fd->bnode);\n\tfd->bnode = NULL;\n\tnidx = tree->root;\n\tif (!nidx)\n\t\treturn -ENOENT;\n\theight = tree->depth;\n\tres = 0;\n\tparent = 0;\n\tfor (;;) {\n\t\tbnode = hfs_bnode_find(tree, nidx);\n\t\tif (IS_ERR(bnode)) {\n\t\t\tres = PTR_ERR(bnode);\n\t\t\tbnode = NULL;\n\t\t\tbreak;\n\t\t}\n\t\tif (bnode->height != height)\n\t\t\tgoto invalid;\n\t\tif (bnode->type != (--height ? HFS_NODE_INDEX : HFS_NODE_LEAF))\n\t\t\tgoto invalid;\n\t\tbnode->parent = parent;\n\n\t\tres = __hfs_brec_find(bnode, fd, do_key_compare);\n\t\tif (!height)\n\t\t\tbreak;\n\t\tif (fd->record < 0)\n\t\t\tgoto release;\n\n\t\tparent = nidx;\n\t\thfs_bnode_read(bnode, &data, fd->entryoffset, 4);\n\t\tnidx = be32_to_cpu(data);\n\t\thfs_bnode_put(bnode);\n\t}\n\tfd->bnode = bnode;\n\treturn res;\n\ninvalid:\n\tpr_err(\"inconsistency in B*Tree (%d,%d,%d,%u,%u)\\n\",\n\t\theight, bnode->height, bnode->type, nidx, parent);\n\tres = -EIO;\nrelease:\n\thfs_bnode_put(bnode);\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfsplus_cat_build_key_uni",
          "args": [
            "fd->search_key",
            "be32_to_cpu(tmp.thread.parentID)",
            "&tmp.thread.nodeName"
          ],
          "line": 216
        },
        "resolved": true,
        "details": {
          "function_name": "hfsplus_cat_build_key_uni",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/catalog.c",
          "lines": "67-78",
          "snippet": "static void hfsplus_cat_build_key_uni(hfsplus_btree_key *key, u32 parent,\n\t\t\t\t      struct hfsplus_unistr *name)\n{\n\tint ustrlen;\n\n\tustrlen = be16_to_cpu(name->length);\n\tkey->cat.parent = cpu_to_be32(parent);\n\tkey->cat.name.length = cpu_to_be16(ustrlen);\n\tustrlen *= 2;\n\tmemcpy(key->cat.name.unicode, name->unicode, ustrlen);\n\tkey->key_len = cpu_to_be16(6 + ustrlen);\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n\nstatic void hfsplus_cat_build_key_uni(hfsplus_btree_key *key, u32 parent,\n\t\t\t\t      struct hfsplus_unistr *name)\n{\n\tint ustrlen;\n\n\tustrlen = be16_to_cpu(name->length);\n\tkey->cat.parent = cpu_to_be32(parent);\n\tkey->cat.name.length = cpu_to_be16(ustrlen);\n\tustrlen *= 2;\n\tmemcpy(key->cat.name.unicode, name->unicode, ustrlen);\n\tkey->key_len = cpu_to_be16(6 + ustrlen);\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "tmp.thread.parentID"
          ],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"catalog name length corrupted\\n\""
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "tmp.thread.nodeName.length"
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"found bad thread record in catalog\\n\""
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "tmp.type"
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfs_brec_read",
          "args": [
            "fd",
            "&tmp",
            "sizeof(hfsplus_cat_entry)"
          ],
          "line": 201
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_brec_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/bfind.c",
          "lines": "219-230",
          "snippet": "int hfs_brec_read(struct hfs_find_data *fd, void *rec, int rec_len)\n{\n\tint res;\n\n\tres = hfs_brec_find(fd, hfs_find_rec_by_key);\n\tif (res)\n\t\treturn res;\n\tif (fd->entrylength > rec_len)\n\t\treturn -EINVAL;\n\thfs_bnode_read(fd->bnode, rec, fd->entryoffset, fd->entrylength);\n\treturn 0;\n}",
          "includes": [
            "#include \"hfsplus_fs.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_fs.h\"\n#include <linux/slab.h>\n\nint hfs_brec_read(struct hfs_find_data *fd, void *rec, int rec_len)\n{\n\tint res;\n\n\tres = hfs_brec_find(fd, hfs_find_rec_by_key);\n\tif (res)\n\t\treturn res;\n\tif (fd->entrylength > rec_len)\n\t\treturn -EINVAL;\n\thfs_bnode_read(fd->bnode, rec, fd->entryoffset, fd->entrylength);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfsplus_cat_build_key_with_cnid",
          "args": [
            "sb",
            "fd->search_key",
            "cnid"
          ],
          "line": 200
        },
        "resolved": true,
        "details": {
          "function_name": "hfsplus_cat_build_key_with_cnid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/catalog.c",
          "lines": "59-65",
          "snippet": "void hfsplus_cat_build_key_with_cnid(struct super_block *sb,\n\t\t\thfsplus_btree_key *key, u32 parent)\n{\n\tkey->cat.parent = cpu_to_be32(parent);\n\tkey->cat.name.length = 0;\n\tkey->key_len = cpu_to_be16(6);\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n\nvoid hfsplus_cat_build_key_with_cnid(struct super_block *sb,\n\t\t\thfsplus_btree_key *key, u32 parent)\n{\n\tkey->cat.parent = cpu_to_be32(parent);\n\tkey->cat.name.length = 0;\n\tkey->key_len = cpu_to_be16(6);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n\nint hfsplus_find_cat(struct super_block *sb, u32 cnid,\n\t\t     struct hfs_find_data *fd)\n{\n\thfsplus_cat_entry tmp;\n\tint err;\n\tu16 type;\n\n\thfsplus_cat_build_key_with_cnid(sb, fd->search_key, cnid);\n\terr = hfs_brec_read(fd, &tmp, sizeof(hfsplus_cat_entry));\n\tif (err)\n\t\treturn err;\n\n\ttype = be16_to_cpu(tmp.type);\n\tif (type != HFSPLUS_FOLDER_THREAD && type != HFSPLUS_FILE_THREAD) {\n\t\tpr_err(\"found bad thread record in catalog\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (be16_to_cpu(tmp.thread.nodeName.length) > 255) {\n\t\tpr_err(\"catalog name length corrupted\\n\");\n\t\treturn -EIO;\n\t}\n\n\thfsplus_cat_build_key_uni(fd->search_key,\n\t\tbe32_to_cpu(tmp.thread.parentID),\n\t\t&tmp.thread.nodeName);\n\treturn hfs_brec_find(fd, hfs_find_rec_by_key);\n}"
  },
  {
    "function_name": "hfsplus_fill_cat_thread",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/catalog.c",
    "lines": "175-190",
    "snippet": "static int hfsplus_fill_cat_thread(struct super_block *sb,\n\t\t\t\t   hfsplus_cat_entry *entry, int type,\n\t\t\t\t   u32 parentid, struct qstr *str)\n{\n\tint err;\n\n\tentry->type = cpu_to_be16(type);\n\tentry->thread.reserved = 0;\n\tentry->thread.parentID = cpu_to_be32(parentid);\n\terr = hfsplus_asc2uni(sb, &entry->thread.nodeName, HFSPLUS_MAX_STRLEN,\n\t\t\t\tstr->name, str->len);\n\tif (unlikely(err < 0))\n\t\treturn err;\n\n\treturn 10 + be16_to_cpu(entry->thread.nodeName.length) * 2;\n}",
    "includes": [
      "#include \"hfsplus_raw.h\"",
      "#include \"hfsplus_fs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "entry->thread.nodeName.length"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "err < 0"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfsplus_asc2uni",
          "args": [
            "sb",
            "&entry->thread.nodeName",
            "HFSPLUS_MAX_STRLEN",
            "str->name",
            "str->len"
          ],
          "line": 184
        },
        "resolved": true,
        "details": {
          "function_name": "hfsplus_asc2uni",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/unicode.c",
          "lines": "298-330",
          "snippet": "int hfsplus_asc2uni(struct super_block *sb,\n\t\t    struct hfsplus_unistr *ustr, int max_unistr_len,\n\t\t    const char *astr, int len)\n{\n\tint size, dsize, decompose;\n\tu16 *dstr, outlen = 0;\n\twchar_t c;\n\n\tdecompose = !test_bit(HFSPLUS_SB_NODECOMPOSE, &HFSPLUS_SB(sb)->flags);\n\twhile (outlen < max_unistr_len && len > 0) {\n\t\tsize = asc2unichar(sb, astr, len, &c);\n\n\t\tif (decompose)\n\t\t\tdstr = decompose_unichar(c, &dsize);\n\t\telse\n\t\t\tdstr = NULL;\n\t\tif (dstr) {\n\t\t\tif (outlen + dsize > max_unistr_len)\n\t\t\t\tbreak;\n\t\t\tdo {\n\t\t\t\tustr->unicode[outlen++] = cpu_to_be16(*dstr++);\n\t\t\t} while (--dsize > 0);\n\t\t} else\n\t\t\tustr->unicode[outlen++] = cpu_to_be16(c);\n\n\t\tastr += size;\n\t\tlen -= size;\n\t}\n\tustr->length = cpu_to_be16(outlen);\n\tif (len > 0)\n\t\treturn -ENAMETOOLONG;\n\treturn 0;\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\"",
            "#include <linux/nls.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/nls.h>\n#include <linux/types.h>\n\nint hfsplus_asc2uni(struct super_block *sb,\n\t\t    struct hfsplus_unistr *ustr, int max_unistr_len,\n\t\t    const char *astr, int len)\n{\n\tint size, dsize, decompose;\n\tu16 *dstr, outlen = 0;\n\twchar_t c;\n\n\tdecompose = !test_bit(HFSPLUS_SB_NODECOMPOSE, &HFSPLUS_SB(sb)->flags);\n\twhile (outlen < max_unistr_len && len > 0) {\n\t\tsize = asc2unichar(sb, astr, len, &c);\n\n\t\tif (decompose)\n\t\t\tdstr = decompose_unichar(c, &dsize);\n\t\telse\n\t\t\tdstr = NULL;\n\t\tif (dstr) {\n\t\t\tif (outlen + dsize > max_unistr_len)\n\t\t\t\tbreak;\n\t\t\tdo {\n\t\t\t\tustr->unicode[outlen++] = cpu_to_be16(*dstr++);\n\t\t\t} while (--dsize > 0);\n\t\t} else\n\t\t\tustr->unicode[outlen++] = cpu_to_be16(c);\n\n\t\tastr += size;\n\t\tlen -= size;\n\t}\n\tustr->length = cpu_to_be16(outlen);\n\tif (len > 0)\n\t\treturn -ENAMETOOLONG;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "parentid"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "type"
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n\nstatic int hfsplus_fill_cat_thread(struct super_block *sb,\n\t\t\t\t   hfsplus_cat_entry *entry, int type,\n\t\t\t\t   u32 parentid, struct qstr *str)\n{\n\tint err;\n\n\tentry->type = cpu_to_be16(type);\n\tentry->thread.reserved = 0;\n\tentry->thread.parentID = cpu_to_be32(parentid);\n\terr = hfsplus_asc2uni(sb, &entry->thread.nodeName, HFSPLUS_MAX_STRLEN,\n\t\t\t\tstr->name, str->len);\n\tif (unlikely(err < 0))\n\t\treturn err;\n\n\treturn 10 + be16_to_cpu(entry->thread.nodeName.length) * 2;\n}"
  },
  {
    "function_name": "hfsplus_cat_build_record",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/catalog.c",
    "lines": "104-173",
    "snippet": "static int hfsplus_cat_build_record(hfsplus_cat_entry *entry,\n\t\tu32 cnid, struct inode *inode)\n{\n\tstruct hfsplus_sb_info *sbi = HFSPLUS_SB(inode->i_sb);\n\n\tif (S_ISDIR(inode->i_mode)) {\n\t\tstruct hfsplus_cat_folder *folder;\n\n\t\tfolder = &entry->folder;\n\t\tmemset(folder, 0, sizeof(*folder));\n\t\tfolder->type = cpu_to_be16(HFSPLUS_FOLDER);\n\t\tif (test_bit(HFSPLUS_SB_HFSX, &sbi->flags))\n\t\t\tfolder->flags |= cpu_to_be16(HFSPLUS_HAS_FOLDER_COUNT);\n\t\tfolder->id = cpu_to_be32(inode->i_ino);\n\t\tHFSPLUS_I(inode)->create_date =\n\t\t\tfolder->create_date =\n\t\t\tfolder->content_mod_date =\n\t\t\tfolder->attribute_mod_date =\n\t\t\tfolder->access_date = hfsp_now2mt();\n\t\thfsplus_cat_set_perms(inode, &folder->permissions);\n\t\tif (inode == sbi->hidden_dir)\n\t\t\t/* invisible and namelocked */\n\t\t\tfolder->user_info.frFlags = cpu_to_be16(0x5000);\n\t\treturn sizeof(*folder);\n\t} else {\n\t\tstruct hfsplus_cat_file *file;\n\n\t\tfile = &entry->file;\n\t\tmemset(file, 0, sizeof(*file));\n\t\tfile->type = cpu_to_be16(HFSPLUS_FILE);\n\t\tfile->flags = cpu_to_be16(HFSPLUS_FILE_THREAD_EXISTS);\n\t\tfile->id = cpu_to_be32(cnid);\n\t\tHFSPLUS_I(inode)->create_date =\n\t\t\tfile->create_date =\n\t\t\tfile->content_mod_date =\n\t\t\tfile->attribute_mod_date =\n\t\t\tfile->access_date = hfsp_now2mt();\n\t\tif (cnid == inode->i_ino) {\n\t\t\thfsplus_cat_set_perms(inode, &file->permissions);\n\t\t\tif (S_ISLNK(inode->i_mode)) {\n\t\t\t\tfile->user_info.fdType =\n\t\t\t\t\tcpu_to_be32(HFSP_SYMLINK_TYPE);\n\t\t\t\tfile->user_info.fdCreator =\n\t\t\t\t\tcpu_to_be32(HFSP_SYMLINK_CREATOR);\n\t\t\t} else {\n\t\t\t\tfile->user_info.fdType =\n\t\t\t\t\tcpu_to_be32(sbi->type);\n\t\t\t\tfile->user_info.fdCreator =\n\t\t\t\t\tcpu_to_be32(sbi->creator);\n\t\t\t}\n\t\t\tif (HFSPLUS_FLG_IMMUTABLE &\n\t\t\t\t\t(file->permissions.rootflags |\n\t\t\t\t\tfile->permissions.userflags))\n\t\t\t\tfile->flags |=\n\t\t\t\t\tcpu_to_be16(HFSPLUS_FILE_LOCKED);\n\t\t} else {\n\t\t\tfile->user_info.fdType =\n\t\t\t\tcpu_to_be32(HFSP_HARDLINK_TYPE);\n\t\t\tfile->user_info.fdCreator =\n\t\t\t\tcpu_to_be32(HFSP_HFSPLUS_CREATOR);\n\t\t\tfile->user_info.fdFlags =\n\t\t\t\tcpu_to_be16(0x100);\n\t\t\tfile->create_date =\n\t\t\t\tHFSPLUS_I(sbi->hidden_dir)->create_date;\n\t\t\tfile->permissions.dev =\n\t\t\t\tcpu_to_be32(HFSPLUS_I(inode)->linkid);\n\t\t}\n\t\treturn sizeof(*file);\n\t}\n}",
    "includes": [
      "#include \"hfsplus_raw.h\"",
      "#include \"hfsplus_fs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "HFSPLUS_I(inode)->linkid"
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HFSPLUS_I",
          "args": [
            "inode"
          ],
          "line": 169
        },
        "resolved": true,
        "details": {
          "function_name": "HFSPLUS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/hfsplus_fs.h",
          "lines": "264-267",
          "snippet": "static inline struct hfsplus_inode_info *HFSPLUS_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct hfsplus_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mutex.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/mutex.h>\n#include <linux/fs.h>\n\nstatic inline struct hfsplus_inode_info *HFSPLUS_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct hfsplus_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "0x100"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "HFSP_HFSPLUS_CREATOR"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "HFSP_HARDLINK_TYPE"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "HFSPLUS_FILE_LOCKED"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "sbi->creator"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "sbi->type"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "HFSP_SYMLINK_CREATOR"
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "HFSP_SYMLINK_TYPE"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISLNK",
          "args": [
            "inode->i_mode"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfsplus_cat_set_perms",
          "args": [
            "inode",
            "&file->permissions"
          ],
          "line": 142
        },
        "resolved": true,
        "details": {
          "function_name": "hfsplus_cat_set_perms",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/catalog.c",
          "lines": "80-102",
          "snippet": "void hfsplus_cat_set_perms(struct inode *inode, struct hfsplus_perm *perms)\n{\n\tif (inode->i_flags & S_IMMUTABLE)\n\t\tperms->rootflags |= HFSPLUS_FLG_IMMUTABLE;\n\telse\n\t\tperms->rootflags &= ~HFSPLUS_FLG_IMMUTABLE;\n\tif (inode->i_flags & S_APPEND)\n\t\tperms->rootflags |= HFSPLUS_FLG_APPEND;\n\telse\n\t\tperms->rootflags &= ~HFSPLUS_FLG_APPEND;\n\n\tperms->userflags = HFSPLUS_I(inode)->userflags;\n\tperms->mode = cpu_to_be16(inode->i_mode);\n\tperms->owner = cpu_to_be32(i_uid_read(inode));\n\tperms->group = cpu_to_be32(i_gid_read(inode));\n\n\tif (S_ISREG(inode->i_mode))\n\t\tperms->dev = cpu_to_be32(inode->i_nlink);\n\telse if (S_ISBLK(inode->i_mode) || S_ISCHR(inode->i_mode))\n\t\tperms->dev = cpu_to_be32(inode->i_rdev);\n\telse\n\t\tperms->dev = 0;\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n\nvoid hfsplus_cat_set_perms(struct inode *inode, struct hfsplus_perm *perms)\n{\n\tif (inode->i_flags & S_IMMUTABLE)\n\t\tperms->rootflags |= HFSPLUS_FLG_IMMUTABLE;\n\telse\n\t\tperms->rootflags &= ~HFSPLUS_FLG_IMMUTABLE;\n\tif (inode->i_flags & S_APPEND)\n\t\tperms->rootflags |= HFSPLUS_FLG_APPEND;\n\telse\n\t\tperms->rootflags &= ~HFSPLUS_FLG_APPEND;\n\n\tperms->userflags = HFSPLUS_I(inode)->userflags;\n\tperms->mode = cpu_to_be16(inode->i_mode);\n\tperms->owner = cpu_to_be32(i_uid_read(inode));\n\tperms->group = cpu_to_be32(i_gid_read(inode));\n\n\tif (S_ISREG(inode->i_mode))\n\t\tperms->dev = cpu_to_be32(inode->i_nlink);\n\telse if (S_ISBLK(inode->i_mode) || S_ISCHR(inode->i_mode))\n\t\tperms->dev = cpu_to_be32(inode->i_rdev);\n\telse\n\t\tperms->dev = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfsp_now2mt",
          "args": [],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "cnid"
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "HFSPLUS_FILE_THREAD_EXISTS"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "HFSPLUS_FILE"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "file",
            "0",
            "sizeof(*file)"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "0x5000"
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfsp_now2mt",
          "args": [],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "inode->i_ino"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "HFSPLUS_HAS_FOLDER_COUNT"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "HFSPLUS_SB_HFSX",
            "&sbi->flags"
          ],
          "line": 115
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "HFSPLUS_FOLDER"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "folder",
            "0",
            "sizeof(*folder)"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "inode->i_mode"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HFSPLUS_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 107
        },
        "resolved": true,
        "details": {
          "function_name": "HFSPLUS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/hfsplus_fs.h",
          "lines": "202-205",
          "snippet": "static inline struct hfsplus_sb_info *HFSPLUS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mutex.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/mutex.h>\n#include <linux/fs.h>\n\nstatic inline struct hfsplus_sb_info *HFSPLUS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n\nstatic int hfsplus_cat_build_record(hfsplus_cat_entry *entry,\n\t\tu32 cnid, struct inode *inode)\n{\n\tstruct hfsplus_sb_info *sbi = HFSPLUS_SB(inode->i_sb);\n\n\tif (S_ISDIR(inode->i_mode)) {\n\t\tstruct hfsplus_cat_folder *folder;\n\n\t\tfolder = &entry->folder;\n\t\tmemset(folder, 0, sizeof(*folder));\n\t\tfolder->type = cpu_to_be16(HFSPLUS_FOLDER);\n\t\tif (test_bit(HFSPLUS_SB_HFSX, &sbi->flags))\n\t\t\tfolder->flags |= cpu_to_be16(HFSPLUS_HAS_FOLDER_COUNT);\n\t\tfolder->id = cpu_to_be32(inode->i_ino);\n\t\tHFSPLUS_I(inode)->create_date =\n\t\t\tfolder->create_date =\n\t\t\tfolder->content_mod_date =\n\t\t\tfolder->attribute_mod_date =\n\t\t\tfolder->access_date = hfsp_now2mt();\n\t\thfsplus_cat_set_perms(inode, &folder->permissions);\n\t\tif (inode == sbi->hidden_dir)\n\t\t\t/* invisible and namelocked */\n\t\t\tfolder->user_info.frFlags = cpu_to_be16(0x5000);\n\t\treturn sizeof(*folder);\n\t} else {\n\t\tstruct hfsplus_cat_file *file;\n\n\t\tfile = &entry->file;\n\t\tmemset(file, 0, sizeof(*file));\n\t\tfile->type = cpu_to_be16(HFSPLUS_FILE);\n\t\tfile->flags = cpu_to_be16(HFSPLUS_FILE_THREAD_EXISTS);\n\t\tfile->id = cpu_to_be32(cnid);\n\t\tHFSPLUS_I(inode)->create_date =\n\t\t\tfile->create_date =\n\t\t\tfile->content_mod_date =\n\t\t\tfile->attribute_mod_date =\n\t\t\tfile->access_date = hfsp_now2mt();\n\t\tif (cnid == inode->i_ino) {\n\t\t\thfsplus_cat_set_perms(inode, &file->permissions);\n\t\t\tif (S_ISLNK(inode->i_mode)) {\n\t\t\t\tfile->user_info.fdType =\n\t\t\t\t\tcpu_to_be32(HFSP_SYMLINK_TYPE);\n\t\t\t\tfile->user_info.fdCreator =\n\t\t\t\t\tcpu_to_be32(HFSP_SYMLINK_CREATOR);\n\t\t\t} else {\n\t\t\t\tfile->user_info.fdType =\n\t\t\t\t\tcpu_to_be32(sbi->type);\n\t\t\t\tfile->user_info.fdCreator =\n\t\t\t\t\tcpu_to_be32(sbi->creator);\n\t\t\t}\n\t\t\tif (HFSPLUS_FLG_IMMUTABLE &\n\t\t\t\t\t(file->permissions.rootflags |\n\t\t\t\t\tfile->permissions.userflags))\n\t\t\t\tfile->flags |=\n\t\t\t\t\tcpu_to_be16(HFSPLUS_FILE_LOCKED);\n\t\t} else {\n\t\t\tfile->user_info.fdType =\n\t\t\t\tcpu_to_be32(HFSP_HARDLINK_TYPE);\n\t\t\tfile->user_info.fdCreator =\n\t\t\t\tcpu_to_be32(HFSP_HFSPLUS_CREATOR);\n\t\t\tfile->user_info.fdFlags =\n\t\t\t\tcpu_to_be16(0x100);\n\t\t\tfile->create_date =\n\t\t\t\tHFSPLUS_I(sbi->hidden_dir)->create_date;\n\t\t\tfile->permissions.dev =\n\t\t\t\tcpu_to_be32(HFSPLUS_I(inode)->linkid);\n\t\t}\n\t\treturn sizeof(*file);\n\t}\n}"
  },
  {
    "function_name": "hfsplus_cat_set_perms",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/catalog.c",
    "lines": "80-102",
    "snippet": "void hfsplus_cat_set_perms(struct inode *inode, struct hfsplus_perm *perms)\n{\n\tif (inode->i_flags & S_IMMUTABLE)\n\t\tperms->rootflags |= HFSPLUS_FLG_IMMUTABLE;\n\telse\n\t\tperms->rootflags &= ~HFSPLUS_FLG_IMMUTABLE;\n\tif (inode->i_flags & S_APPEND)\n\t\tperms->rootflags |= HFSPLUS_FLG_APPEND;\n\telse\n\t\tperms->rootflags &= ~HFSPLUS_FLG_APPEND;\n\n\tperms->userflags = HFSPLUS_I(inode)->userflags;\n\tperms->mode = cpu_to_be16(inode->i_mode);\n\tperms->owner = cpu_to_be32(i_uid_read(inode));\n\tperms->group = cpu_to_be32(i_gid_read(inode));\n\n\tif (S_ISREG(inode->i_mode))\n\t\tperms->dev = cpu_to_be32(inode->i_nlink);\n\telse if (S_ISBLK(inode->i_mode) || S_ISCHR(inode->i_mode))\n\t\tperms->dev = cpu_to_be32(inode->i_rdev);\n\telse\n\t\tperms->dev = 0;\n}",
    "includes": [
      "#include \"hfsplus_raw.h\"",
      "#include \"hfsplus_fs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "inode->i_rdev"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISCHR",
          "args": [
            "inode->i_mode"
          ],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISBLK",
          "args": [
            "inode->i_mode"
          ],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "inode->i_nlink"
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "inode->i_mode"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "i_gid_read(inode)"
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_gid_read",
          "args": [
            "inode"
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "i_uid_read(inode)"
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_uid_read",
          "args": [
            "inode"
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "inode->i_mode"
          ],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HFSPLUS_I",
          "args": [
            "inode"
          ],
          "line": 91
        },
        "resolved": true,
        "details": {
          "function_name": "HFSPLUS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/hfsplus_fs.h",
          "lines": "264-267",
          "snippet": "static inline struct hfsplus_inode_info *HFSPLUS_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct hfsplus_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mutex.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/mutex.h>\n#include <linux/fs.h>\n\nstatic inline struct hfsplus_inode_info *HFSPLUS_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct hfsplus_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n\nvoid hfsplus_cat_set_perms(struct inode *inode, struct hfsplus_perm *perms)\n{\n\tif (inode->i_flags & S_IMMUTABLE)\n\t\tperms->rootflags |= HFSPLUS_FLG_IMMUTABLE;\n\telse\n\t\tperms->rootflags &= ~HFSPLUS_FLG_IMMUTABLE;\n\tif (inode->i_flags & S_APPEND)\n\t\tperms->rootflags |= HFSPLUS_FLG_APPEND;\n\telse\n\t\tperms->rootflags &= ~HFSPLUS_FLG_APPEND;\n\n\tperms->userflags = HFSPLUS_I(inode)->userflags;\n\tperms->mode = cpu_to_be16(inode->i_mode);\n\tperms->owner = cpu_to_be32(i_uid_read(inode));\n\tperms->group = cpu_to_be32(i_gid_read(inode));\n\n\tif (S_ISREG(inode->i_mode))\n\t\tperms->dev = cpu_to_be32(inode->i_nlink);\n\telse if (S_ISBLK(inode->i_mode) || S_ISCHR(inode->i_mode))\n\t\tperms->dev = cpu_to_be32(inode->i_rdev);\n\telse\n\t\tperms->dev = 0;\n}"
  },
  {
    "function_name": "hfsplus_cat_build_key_uni",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/catalog.c",
    "lines": "67-78",
    "snippet": "static void hfsplus_cat_build_key_uni(hfsplus_btree_key *key, u32 parent,\n\t\t\t\t      struct hfsplus_unistr *name)\n{\n\tint ustrlen;\n\n\tustrlen = be16_to_cpu(name->length);\n\tkey->cat.parent = cpu_to_be32(parent);\n\tkey->cat.name.length = cpu_to_be16(ustrlen);\n\tustrlen *= 2;\n\tmemcpy(key->cat.name.unicode, name->unicode, ustrlen);\n\tkey->key_len = cpu_to_be16(6 + ustrlen);\n}",
    "includes": [
      "#include \"hfsplus_raw.h\"",
      "#include \"hfsplus_fs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "6 + ustrlen"
          ],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "key->cat.name.unicode",
            "name->unicode",
            "ustrlen"
          ],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "ustrlen"
          ],
          "line": 74
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "parent"
          ],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "name->length"
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n\nstatic void hfsplus_cat_build_key_uni(hfsplus_btree_key *key, u32 parent,\n\t\t\t\t      struct hfsplus_unistr *name)\n{\n\tint ustrlen;\n\n\tustrlen = be16_to_cpu(name->length);\n\tkey->cat.parent = cpu_to_be32(parent);\n\tkey->cat.name.length = cpu_to_be16(ustrlen);\n\tustrlen *= 2;\n\tmemcpy(key->cat.name.unicode, name->unicode, ustrlen);\n\tkey->key_len = cpu_to_be16(6 + ustrlen);\n}"
  },
  {
    "function_name": "hfsplus_cat_build_key_with_cnid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/catalog.c",
    "lines": "59-65",
    "snippet": "void hfsplus_cat_build_key_with_cnid(struct super_block *sb,\n\t\t\thfsplus_btree_key *key, u32 parent)\n{\n\tkey->cat.parent = cpu_to_be32(parent);\n\tkey->cat.name.length = 0;\n\tkey->key_len = cpu_to_be16(6);\n}",
    "includes": [
      "#include \"hfsplus_raw.h\"",
      "#include \"hfsplus_fs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "6"
          ],
          "line": 64
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "parent"
          ],
          "line": 62
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n\nvoid hfsplus_cat_build_key_with_cnid(struct super_block *sb,\n\t\t\thfsplus_btree_key *key, u32 parent)\n{\n\tkey->cat.parent = cpu_to_be32(parent);\n\tkey->cat.name.length = 0;\n\tkey->key_len = cpu_to_be16(6);\n}"
  },
  {
    "function_name": "hfsplus_cat_build_key",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/catalog.c",
    "lines": "42-56",
    "snippet": "int hfsplus_cat_build_key(struct super_block *sb,\n\t\thfsplus_btree_key *key, u32 parent, struct qstr *str)\n{\n\tint len, err;\n\n\tkey->cat.parent = cpu_to_be32(parent);\n\terr = hfsplus_asc2uni(sb, &key->cat.name, HFSPLUS_MAX_STRLEN,\n\t\t\tstr->name, str->len);\n\tif (unlikely(err < 0))\n\t\treturn err;\n\n\tlen = be16_to_cpu(key->cat.name.length);\n\tkey->key_len = cpu_to_be16(6 + 2 * len);\n\treturn 0;\n}",
    "includes": [
      "#include \"hfsplus_raw.h\"",
      "#include \"hfsplus_fs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "6 + 2 * len"
          ],
          "line": 54
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "key->cat.name.length"
          ],
          "line": 53
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "err < 0"
          ],
          "line": 50
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfsplus_asc2uni",
          "args": [
            "sb",
            "&key->cat.name",
            "HFSPLUS_MAX_STRLEN",
            "str->name",
            "str->len"
          ],
          "line": 48
        },
        "resolved": true,
        "details": {
          "function_name": "hfsplus_asc2uni",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/unicode.c",
          "lines": "298-330",
          "snippet": "int hfsplus_asc2uni(struct super_block *sb,\n\t\t    struct hfsplus_unistr *ustr, int max_unistr_len,\n\t\t    const char *astr, int len)\n{\n\tint size, dsize, decompose;\n\tu16 *dstr, outlen = 0;\n\twchar_t c;\n\n\tdecompose = !test_bit(HFSPLUS_SB_NODECOMPOSE, &HFSPLUS_SB(sb)->flags);\n\twhile (outlen < max_unistr_len && len > 0) {\n\t\tsize = asc2unichar(sb, astr, len, &c);\n\n\t\tif (decompose)\n\t\t\tdstr = decompose_unichar(c, &dsize);\n\t\telse\n\t\t\tdstr = NULL;\n\t\tif (dstr) {\n\t\t\tif (outlen + dsize > max_unistr_len)\n\t\t\t\tbreak;\n\t\t\tdo {\n\t\t\t\tustr->unicode[outlen++] = cpu_to_be16(*dstr++);\n\t\t\t} while (--dsize > 0);\n\t\t} else\n\t\t\tustr->unicode[outlen++] = cpu_to_be16(c);\n\n\t\tastr += size;\n\t\tlen -= size;\n\t}\n\tustr->length = cpu_to_be16(outlen);\n\tif (len > 0)\n\t\treturn -ENAMETOOLONG;\n\treturn 0;\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\"",
            "#include <linux/nls.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/nls.h>\n#include <linux/types.h>\n\nint hfsplus_asc2uni(struct super_block *sb,\n\t\t    struct hfsplus_unistr *ustr, int max_unistr_len,\n\t\t    const char *astr, int len)\n{\n\tint size, dsize, decompose;\n\tu16 *dstr, outlen = 0;\n\twchar_t c;\n\n\tdecompose = !test_bit(HFSPLUS_SB_NODECOMPOSE, &HFSPLUS_SB(sb)->flags);\n\twhile (outlen < max_unistr_len && len > 0) {\n\t\tsize = asc2unichar(sb, astr, len, &c);\n\n\t\tif (decompose)\n\t\t\tdstr = decompose_unichar(c, &dsize);\n\t\telse\n\t\t\tdstr = NULL;\n\t\tif (dstr) {\n\t\t\tif (outlen + dsize > max_unistr_len)\n\t\t\t\tbreak;\n\t\t\tdo {\n\t\t\t\tustr->unicode[outlen++] = cpu_to_be16(*dstr++);\n\t\t\t} while (--dsize > 0);\n\t\t} else\n\t\t\tustr->unicode[outlen++] = cpu_to_be16(c);\n\n\t\tastr += size;\n\t\tlen -= size;\n\t}\n\tustr->length = cpu_to_be16(outlen);\n\tif (len > 0)\n\t\treturn -ENAMETOOLONG;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "parent"
          ],
          "line": 47
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n\nint hfsplus_cat_build_key(struct super_block *sb,\n\t\thfsplus_btree_key *key, u32 parent, struct qstr *str)\n{\n\tint len, err;\n\n\tkey->cat.parent = cpu_to_be32(parent);\n\terr = hfsplus_asc2uni(sb, &key->cat.name, HFSPLUS_MAX_STRLEN,\n\t\t\tstr->name, str->len);\n\tif (unlikely(err < 0))\n\t\treturn err;\n\n\tlen = be16_to_cpu(key->cat.name.length);\n\tkey->key_len = cpu_to_be16(6 + 2 * len);\n\treturn 0;\n}"
  },
  {
    "function_name": "hfsplus_cat_bin_cmp_key",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/catalog.c",
    "lines": "28-39",
    "snippet": "int hfsplus_cat_bin_cmp_key(const hfsplus_btree_key *k1,\n\t\t\t    const hfsplus_btree_key *k2)\n{\n\t__be32 k1p, k2p;\n\n\tk1p = k1->cat.parent;\n\tk2p = k2->cat.parent;\n\tif (k1p != k2p)\n\t\treturn be32_to_cpu(k1p) < be32_to_cpu(k2p) ? -1 : 1;\n\n\treturn hfsplus_strcmp(&k1->cat.name, &k2->cat.name);\n}",
    "includes": [
      "#include \"hfsplus_raw.h\"",
      "#include \"hfsplus_fs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hfsplus_strcmp",
          "args": [
            "&k1->cat.name",
            "&k2->cat.name"
          ],
          "line": 38
        },
        "resolved": true,
        "details": {
          "function_name": "hfsplus_strcmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/unicode.c",
          "lines": "64-87",
          "snippet": "int hfsplus_strcmp(const struct hfsplus_unistr *s1,\n\t\t   const struct hfsplus_unistr *s2)\n{\n\tu16 len1, len2, c1, c2;\n\tconst hfsplus_unichr *p1, *p2;\n\tint len;\n\n\tlen1 = be16_to_cpu(s1->length);\n\tlen2 = be16_to_cpu(s2->length);\n\tp1 = s1->unicode;\n\tp2 = s2->unicode;\n\n\tfor (len = min(len1, len2); len > 0; len--) {\n\t\tc1 = be16_to_cpu(*p1);\n\t\tc2 = be16_to_cpu(*p2);\n\t\tif (c1 != c2)\n\t\t\treturn c1 < c2 ? -1 : 1;\n\t\tp1++;\n\t\tp2++;\n\t}\n\n\treturn len1 < len2 ? -1 :\n\t       len1 > len2 ? 1 : 0;\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\"",
            "#include <linux/nls.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/nls.h>\n#include <linux/types.h>\n\nint hfsplus_strcmp(const struct hfsplus_unistr *s1,\n\t\t   const struct hfsplus_unistr *s2)\n{\n\tu16 len1, len2, c1, c2;\n\tconst hfsplus_unichr *p1, *p2;\n\tint len;\n\n\tlen1 = be16_to_cpu(s1->length);\n\tlen2 = be16_to_cpu(s2->length);\n\tp1 = s1->unicode;\n\tp2 = s2->unicode;\n\n\tfor (len = min(len1, len2); len > 0; len--) {\n\t\tc1 = be16_to_cpu(*p1);\n\t\tc2 = be16_to_cpu(*p2);\n\t\tif (c1 != c2)\n\t\t\treturn c1 < c2 ? -1 : 1;\n\t\tp1++;\n\t\tp2++;\n\t}\n\n\treturn len1 < len2 ? -1 :\n\t       len1 > len2 ? 1 : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "k2p"
          ],
          "line": 36
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "k1p"
          ],
          "line": 36
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n\nint hfsplus_cat_bin_cmp_key(const hfsplus_btree_key *k1,\n\t\t\t    const hfsplus_btree_key *k2)\n{\n\t__be32 k1p, k2p;\n\n\tk1p = k1->cat.parent;\n\tk2p = k2->cat.parent;\n\tif (k1p != k2p)\n\t\treturn be32_to_cpu(k1p) < be32_to_cpu(k2p) ? -1 : 1;\n\n\treturn hfsplus_strcmp(&k1->cat.name, &k2->cat.name);\n}"
  },
  {
    "function_name": "hfsplus_cat_case_cmp_key",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/catalog.c",
    "lines": "15-26",
    "snippet": "int hfsplus_cat_case_cmp_key(const hfsplus_btree_key *k1,\n\t\t\t     const hfsplus_btree_key *k2)\n{\n\t__be32 k1p, k2p;\n\n\tk1p = k1->cat.parent;\n\tk2p = k2->cat.parent;\n\tif (k1p != k2p)\n\t\treturn be32_to_cpu(k1p) < be32_to_cpu(k2p) ? -1 : 1;\n\n\treturn hfsplus_strcasecmp(&k1->cat.name, &k2->cat.name);\n}",
    "includes": [
      "#include \"hfsplus_raw.h\"",
      "#include \"hfsplus_fs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hfsplus_strcasecmp",
          "args": [
            "&k1->cat.name",
            "&k2->cat.name"
          ],
          "line": 25
        },
        "resolved": true,
        "details": {
          "function_name": "hfsplus_strcasecmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/unicode.c",
          "lines": "31-61",
          "snippet": "int hfsplus_strcasecmp(const struct hfsplus_unistr *s1,\n\t\t       const struct hfsplus_unistr *s2)\n{\n\tu16 len1, len2, c1, c2;\n\tconst hfsplus_unichr *p1, *p2;\n\n\tlen1 = be16_to_cpu(s1->length);\n\tlen2 = be16_to_cpu(s2->length);\n\tp1 = s1->unicode;\n\tp2 = s2->unicode;\n\n\twhile (1) {\n\t\tc1 = c2 = 0;\n\n\t\twhile (len1 && !c1) {\n\t\t\tc1 = case_fold(be16_to_cpu(*p1));\n\t\t\tp1++;\n\t\t\tlen1--;\n\t\t}\n\t\twhile (len2 && !c2) {\n\t\t\tc2 = case_fold(be16_to_cpu(*p2));\n\t\t\tp2++;\n\t\t\tlen2--;\n\t\t}\n\n\t\tif (c1 != c2)\n\t\t\treturn (c1 < c2) ? -1 : 1;\n\t\tif (!c1 && !c2)\n\t\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\"",
            "#include <linux/nls.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/nls.h>\n#include <linux/types.h>\n\nint hfsplus_strcasecmp(const struct hfsplus_unistr *s1,\n\t\t       const struct hfsplus_unistr *s2)\n{\n\tu16 len1, len2, c1, c2;\n\tconst hfsplus_unichr *p1, *p2;\n\n\tlen1 = be16_to_cpu(s1->length);\n\tlen2 = be16_to_cpu(s2->length);\n\tp1 = s1->unicode;\n\tp2 = s2->unicode;\n\n\twhile (1) {\n\t\tc1 = c2 = 0;\n\n\t\twhile (len1 && !c1) {\n\t\t\tc1 = case_fold(be16_to_cpu(*p1));\n\t\t\tp1++;\n\t\t\tlen1--;\n\t\t}\n\t\twhile (len2 && !c2) {\n\t\t\tc2 = case_fold(be16_to_cpu(*p2));\n\t\t\tp2++;\n\t\t\tlen2--;\n\t\t}\n\n\t\tif (c1 != c2)\n\t\t\treturn (c1 < c2) ? -1 : 1;\n\t\tif (!c1 && !c2)\n\t\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "k2p"
          ],
          "line": 23
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "k1p"
          ],
          "line": 23
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n\nint hfsplus_cat_case_cmp_key(const hfsplus_btree_key *k1,\n\t\t\t     const hfsplus_btree_key *k2)\n{\n\t__be32 k1p, k2p;\n\n\tk1p = k1->cat.parent;\n\tk2p = k2->cat.parent;\n\tif (k1p != k2p)\n\t\treturn be32_to_cpu(k1p) < be32_to_cpu(k2p) ? -1 : 1;\n\n\treturn hfsplus_strcasecmp(&k1->cat.name, &k2->cat.name);\n}"
  }
]