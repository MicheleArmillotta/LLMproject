[
  {
    "function_name": "logfs_get_sb_bdev",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/dev_bdev.c",
    "lines": "301-321",
    "snippet": "int logfs_get_sb_bdev(struct logfs_super *p, struct file_system_type *type,\n\t\tconst char *devname)\n{\n\tstruct block_device *bdev;\n\n\tbdev = blkdev_get_by_path(devname, FMODE_READ|FMODE_WRITE|FMODE_EXCL,\n\t\t\t\t  type);\n\tif (IS_ERR(bdev))\n\t\treturn PTR_ERR(bdev);\n\n\tif (MAJOR(bdev->bd_dev) == MTD_BLOCK_MAJOR) {\n\t\tint mtdnr = MINOR(bdev->bd_dev);\n\t\tblkdev_put(bdev, FMODE_READ|FMODE_WRITE|FMODE_EXCL);\n\t\treturn logfs_get_sb_mtd(p, mtdnr);\n\t}\n\n\tp->s_bdev = bdev;\n\tp->s_mtd = NULL;\n\tp->s_devops = &bd_devops;\n\treturn 0;\n}",
    "includes": [
      "#include <linux/prefetch.h>",
      "#include <linux/gfp.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct logfs_device_ops bd_devops = {\n\t.find_first_sb\t= bdev_find_first_sb,\n\t.find_last_sb\t= bdev_find_last_sb,\n\t.write_sb\t= bdev_write_sb,\n\t.readpage\t= bdev_readpage,\n\t.writeseg\t= bdev_writeseg,\n\t.erase\t\t= bdev_erase,\n\t.can_write_buf\t= bdev_can_write_buf,\n\t.sync\t\t= bdev_sync,\n\t.put_device\t= bdev_put_device,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "logfs_get_sb_mtd",
          "args": [
            "p",
            "mtdnr"
          ],
          "line": 314
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_get_sb_mtd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/dev_mtd.c",
          "lines": "264-274",
          "snippet": "int logfs_get_sb_mtd(struct logfs_super *s, int mtdnr)\n{\n\tstruct mtd_info *mtd = get_mtd_device(NULL, mtdnr);\n\tif (IS_ERR(mtd))\n\t\treturn PTR_ERR(mtd);\n\n\ts->s_bdev = NULL;\n\ts->s_mtd = mtd;\n\ts->s_devops = &mtd_devops;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/mount.h>",
            "#include <linux/completion.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct logfs_device_ops mtd_devops = {\n\t.find_first_sb\t= logfs_mtd_find_first_sb,\n\t.find_last_sb\t= logfs_mtd_find_last_sb,\n\t.readpage\t= logfs_mtd_readpage,\n\t.writeseg\t= logfs_mtd_writeseg,\n\t.erase\t\t= logfs_mtd_erase,\n\t.can_write_buf\t= logfs_mtd_can_write_buf,\n\t.sync\t\t= logfs_mtd_sync,\n\t.put_device\t= logfs_mtd_put_device,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/mount.h>\n#include <linux/completion.h>\n#include \"logfs.h\"\n\nstatic const struct logfs_device_ops mtd_devops = {\n\t.find_first_sb\t= logfs_mtd_find_first_sb,\n\t.find_last_sb\t= logfs_mtd_find_last_sb,\n\t.readpage\t= logfs_mtd_readpage,\n\t.writeseg\t= logfs_mtd_writeseg,\n\t.erase\t\t= logfs_mtd_erase,\n\t.can_write_buf\t= logfs_mtd_can_write_buf,\n\t.sync\t\t= logfs_mtd_sync,\n\t.put_device\t= logfs_mtd_put_device,\n};\n\nint logfs_get_sb_mtd(struct logfs_super *s, int mtdnr)\n{\n\tstruct mtd_info *mtd = get_mtd_device(NULL, mtdnr);\n\tif (IS_ERR(mtd))\n\t\treturn PTR_ERR(mtd);\n\n\ts->s_bdev = NULL;\n\ts->s_mtd = mtd;\n\ts->s_devops = &mtd_devops;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "blkdev_put",
          "args": [
            "bdev",
            "FMODE_READ|FMODE_WRITE|FMODE_EXCL"
          ],
          "line": 313
        },
        "resolved": true,
        "details": {
          "function_name": "blkdev_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
          "lines": "1519-1564",
          "snippet": "void blkdev_put(struct block_device *bdev, fmode_t mode)\n{\n\tmutex_lock(&bdev->bd_mutex);\n\n\tif (mode & FMODE_EXCL) {\n\t\tbool bdev_free;\n\n\t\t/*\n\t\t * Release a claim on the device.  The holder fields\n\t\t * are protected with bdev_lock.  bd_mutex is to\n\t\t * synchronize disk_holder unlinking.\n\t\t */\n\t\tspin_lock(&bdev_lock);\n\n\t\tWARN_ON_ONCE(--bdev->bd_holders < 0);\n\t\tWARN_ON_ONCE(--bdev->bd_contains->bd_holders < 0);\n\n\t\t/* bd_contains might point to self, check in a separate step */\n\t\tif ((bdev_free = !bdev->bd_holders))\n\t\t\tbdev->bd_holder = NULL;\n\t\tif (!bdev->bd_contains->bd_holders)\n\t\t\tbdev->bd_contains->bd_holder = NULL;\n\n\t\tspin_unlock(&bdev_lock);\n\n\t\t/*\n\t\t * If this was the last claim, remove holder link and\n\t\t * unblock evpoll if it was a write holder.\n\t\t */\n\t\tif (bdev_free && bdev->bd_write_holder) {\n\t\t\tdisk_unblock_events(bdev->bd_disk);\n\t\t\tbdev->bd_write_holder = false;\n\t\t}\n\t}\n\n\t/*\n\t * Trigger event checking and tell drivers to flush MEDIA_CHANGE\n\t * event.  This is to ensure detection of media removal commanded\n\t * from userland - e.g. eject(1).\n\t */\n\tdisk_flush_events(bdev->bd_disk, DISK_EVENT_MEDIA_CHANGE);\n\n\tmutex_unlock(&bdev->bd_mutex);\n\n\t__blkdev_put(bdev, mode, 0);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static  __cacheline_aligned_in_smp DEFINE_SPINLOCK(bdev_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic  __cacheline_aligned_in_smp DEFINE_SPINLOCK(bdev_lock);\n\nvoid blkdev_put(struct block_device *bdev, fmode_t mode)\n{\n\tmutex_lock(&bdev->bd_mutex);\n\n\tif (mode & FMODE_EXCL) {\n\t\tbool bdev_free;\n\n\t\t/*\n\t\t * Release a claim on the device.  The holder fields\n\t\t * are protected with bdev_lock.  bd_mutex is to\n\t\t * synchronize disk_holder unlinking.\n\t\t */\n\t\tspin_lock(&bdev_lock);\n\n\t\tWARN_ON_ONCE(--bdev->bd_holders < 0);\n\t\tWARN_ON_ONCE(--bdev->bd_contains->bd_holders < 0);\n\n\t\t/* bd_contains might point to self, check in a separate step */\n\t\tif ((bdev_free = !bdev->bd_holders))\n\t\t\tbdev->bd_holder = NULL;\n\t\tif (!bdev->bd_contains->bd_holders)\n\t\t\tbdev->bd_contains->bd_holder = NULL;\n\n\t\tspin_unlock(&bdev_lock);\n\n\t\t/*\n\t\t * If this was the last claim, remove holder link and\n\t\t * unblock evpoll if it was a write holder.\n\t\t */\n\t\tif (bdev_free && bdev->bd_write_holder) {\n\t\t\tdisk_unblock_events(bdev->bd_disk);\n\t\t\tbdev->bd_write_holder = false;\n\t\t}\n\t}\n\n\t/*\n\t * Trigger event checking and tell drivers to flush MEDIA_CHANGE\n\t * event.  This is to ensure detection of media removal commanded\n\t * from userland - e.g. eject(1).\n\t */\n\tdisk_flush_events(bdev->bd_disk, DISK_EVENT_MEDIA_CHANGE);\n\n\tmutex_unlock(&bdev->bd_mutex);\n\n\t__blkdev_put(bdev, mode, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "MINOR",
          "args": [
            "bdev->bd_dev"
          ],
          "line": 312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAJOR",
          "args": [
            "bdev->bd_dev"
          ],
          "line": 311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "bdev"
          ],
          "line": 309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "bdev"
          ],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "blkdev_get_by_path",
          "args": [
            "devname",
            "FMODE_READ|FMODE_WRITE|FMODE_EXCL",
            "type"
          ],
          "line": 306
        },
        "resolved": true,
        "details": {
          "function_name": "blkdev_get_by_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
          "lines": "1387-1407",
          "snippet": "struct block_device *blkdev_get_by_path(const char *path, fmode_t mode,\n\t\t\t\t\tvoid *holder)\n{\n\tstruct block_device *bdev;\n\tint err;\n\n\tbdev = lookup_bdev(path);\n\tif (IS_ERR(bdev))\n\t\treturn bdev;\n\n\terr = blkdev_get(bdev, mode, holder);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\tif ((mode & FMODE_WRITE) && bdev_read_only(bdev)) {\n\t\tblkdev_put(bdev, mode);\n\t\treturn ERR_PTR(-EACCES);\n\t}\n\n\treturn bdev;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstruct block_device *blkdev_get_by_path(const char *path, fmode_t mode,\n\t\t\t\t\tvoid *holder)\n{\n\tstruct block_device *bdev;\n\tint err;\n\n\tbdev = lookup_bdev(path);\n\tif (IS_ERR(bdev))\n\t\treturn bdev;\n\n\terr = blkdev_get(bdev, mode, holder);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\tif ((mode & FMODE_WRITE) && bdev_read_only(bdev)) {\n\t\tblkdev_put(bdev, mode);\n\t\treturn ERR_PTR(-EACCES);\n\t}\n\n\treturn bdev;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/prefetch.h>\n#include <linux/gfp.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"logfs.h\"\n\nstatic const struct logfs_device_ops bd_devops = {\n\t.find_first_sb\t= bdev_find_first_sb,\n\t.find_last_sb\t= bdev_find_last_sb,\n\t.write_sb\t= bdev_write_sb,\n\t.readpage\t= bdev_readpage,\n\t.writeseg\t= bdev_writeseg,\n\t.erase\t\t= bdev_erase,\n\t.can_write_buf\t= bdev_can_write_buf,\n\t.sync\t\t= bdev_sync,\n\t.put_device\t= bdev_put_device,\n};\n\nint logfs_get_sb_bdev(struct logfs_super *p, struct file_system_type *type,\n\t\tconst char *devname)\n{\n\tstruct block_device *bdev;\n\n\tbdev = blkdev_get_by_path(devname, FMODE_READ|FMODE_WRITE|FMODE_EXCL,\n\t\t\t\t  type);\n\tif (IS_ERR(bdev))\n\t\treturn PTR_ERR(bdev);\n\n\tif (MAJOR(bdev->bd_dev) == MTD_BLOCK_MAJOR) {\n\t\tint mtdnr = MINOR(bdev->bd_dev);\n\t\tblkdev_put(bdev, FMODE_READ|FMODE_WRITE|FMODE_EXCL);\n\t\treturn logfs_get_sb_mtd(p, mtdnr);\n\t}\n\n\tp->s_bdev = bdev;\n\tp->s_mtd = NULL;\n\tp->s_devops = &bd_devops;\n\treturn 0;\n}"
  },
  {
    "function_name": "bdev_can_write_buf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/dev_bdev.c",
    "lines": "284-287",
    "snippet": "static int bdev_can_write_buf(struct super_block *sb, u64 ofs)\n{\n\treturn 0;\n}",
    "includes": [
      "#include <linux/prefetch.h>",
      "#include <linux/gfp.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/prefetch.h>\n#include <linux/gfp.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"logfs.h\"\n\nstatic int bdev_can_write_buf(struct super_block *sb, u64 ofs)\n{\n\treturn 0;\n}"
  },
  {
    "function_name": "bdev_put_device",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/dev_bdev.c",
    "lines": "279-282",
    "snippet": "static void bdev_put_device(struct logfs_super *s)\n{\n\tblkdev_put(s->s_bdev, FMODE_READ|FMODE_WRITE|FMODE_EXCL);\n}",
    "includes": [
      "#include <linux/prefetch.h>",
      "#include <linux/gfp.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "blkdev_put",
          "args": [
            "s->s_bdev",
            "FMODE_READ|FMODE_WRITE|FMODE_EXCL"
          ],
          "line": 281
        },
        "resolved": true,
        "details": {
          "function_name": "blkdev_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
          "lines": "1519-1564",
          "snippet": "void blkdev_put(struct block_device *bdev, fmode_t mode)\n{\n\tmutex_lock(&bdev->bd_mutex);\n\n\tif (mode & FMODE_EXCL) {\n\t\tbool bdev_free;\n\n\t\t/*\n\t\t * Release a claim on the device.  The holder fields\n\t\t * are protected with bdev_lock.  bd_mutex is to\n\t\t * synchronize disk_holder unlinking.\n\t\t */\n\t\tspin_lock(&bdev_lock);\n\n\t\tWARN_ON_ONCE(--bdev->bd_holders < 0);\n\t\tWARN_ON_ONCE(--bdev->bd_contains->bd_holders < 0);\n\n\t\t/* bd_contains might point to self, check in a separate step */\n\t\tif ((bdev_free = !bdev->bd_holders))\n\t\t\tbdev->bd_holder = NULL;\n\t\tif (!bdev->bd_contains->bd_holders)\n\t\t\tbdev->bd_contains->bd_holder = NULL;\n\n\t\tspin_unlock(&bdev_lock);\n\n\t\t/*\n\t\t * If this was the last claim, remove holder link and\n\t\t * unblock evpoll if it was a write holder.\n\t\t */\n\t\tif (bdev_free && bdev->bd_write_holder) {\n\t\t\tdisk_unblock_events(bdev->bd_disk);\n\t\t\tbdev->bd_write_holder = false;\n\t\t}\n\t}\n\n\t/*\n\t * Trigger event checking and tell drivers to flush MEDIA_CHANGE\n\t * event.  This is to ensure detection of media removal commanded\n\t * from userland - e.g. eject(1).\n\t */\n\tdisk_flush_events(bdev->bd_disk, DISK_EVENT_MEDIA_CHANGE);\n\n\tmutex_unlock(&bdev->bd_mutex);\n\n\t__blkdev_put(bdev, mode, 0);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static  __cacheline_aligned_in_smp DEFINE_SPINLOCK(bdev_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic  __cacheline_aligned_in_smp DEFINE_SPINLOCK(bdev_lock);\n\nvoid blkdev_put(struct block_device *bdev, fmode_t mode)\n{\n\tmutex_lock(&bdev->bd_mutex);\n\n\tif (mode & FMODE_EXCL) {\n\t\tbool bdev_free;\n\n\t\t/*\n\t\t * Release a claim on the device.  The holder fields\n\t\t * are protected with bdev_lock.  bd_mutex is to\n\t\t * synchronize disk_holder unlinking.\n\t\t */\n\t\tspin_lock(&bdev_lock);\n\n\t\tWARN_ON_ONCE(--bdev->bd_holders < 0);\n\t\tWARN_ON_ONCE(--bdev->bd_contains->bd_holders < 0);\n\n\t\t/* bd_contains might point to self, check in a separate step */\n\t\tif ((bdev_free = !bdev->bd_holders))\n\t\t\tbdev->bd_holder = NULL;\n\t\tif (!bdev->bd_contains->bd_holders)\n\t\t\tbdev->bd_contains->bd_holder = NULL;\n\n\t\tspin_unlock(&bdev_lock);\n\n\t\t/*\n\t\t * If this was the last claim, remove holder link and\n\t\t * unblock evpoll if it was a write holder.\n\t\t */\n\t\tif (bdev_free && bdev->bd_write_holder) {\n\t\t\tdisk_unblock_events(bdev->bd_disk);\n\t\t\tbdev->bd_write_holder = false;\n\t\t}\n\t}\n\n\t/*\n\t * Trigger event checking and tell drivers to flush MEDIA_CHANGE\n\t * event.  This is to ensure detection of media removal commanded\n\t * from userland - e.g. eject(1).\n\t */\n\tdisk_flush_events(bdev->bd_disk, DISK_EVENT_MEDIA_CHANGE);\n\n\tmutex_unlock(&bdev->bd_mutex);\n\n\t__blkdev_put(bdev, mode, 0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/prefetch.h>\n#include <linux/gfp.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"logfs.h\"\n\nstatic void bdev_put_device(struct logfs_super *s)\n{\n\tblkdev_put(s->s_bdev, FMODE_READ|FMODE_WRITE|FMODE_EXCL);\n}"
  },
  {
    "function_name": "bdev_write_sb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/dev_bdev.c",
    "lines": "271-277",
    "snippet": "static int bdev_write_sb(struct super_block *sb, struct page *page)\n{\n\tstruct block_device *bdev = logfs_super(sb)->s_bdev;\n\n\t/* Nothing special to do for block devices. */\n\treturn sync_request(page, bdev, WRITE);\n}",
    "includes": [
      "#include <linux/prefetch.h>",
      "#include <linux/gfp.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sync_request",
          "args": [
            "page",
            "bdev",
            "WRITE"
          ],
          "line": 276
        },
        "resolved": true,
        "details": {
          "function_name": "sync_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/dev_bdev.c",
          "lines": "17-34",
          "snippet": "static int sync_request(struct page *page, struct block_device *bdev, int rw)\n{\n\tstruct bio bio;\n\tstruct bio_vec bio_vec;\n\n\tbio_init(&bio);\n\tbio.bi_max_vecs = 1;\n\tbio.bi_io_vec = &bio_vec;\n\tbio_vec.bv_page = page;\n\tbio_vec.bv_len = PAGE_SIZE;\n\tbio_vec.bv_offset = 0;\n\tbio.bi_vcnt = 1;\n\tbio.bi_bdev = bdev;\n\tbio.bi_iter.bi_sector = page->index * (PAGE_SIZE >> 9);\n\tbio.bi_iter.bi_size = PAGE_SIZE;\n\n\treturn submit_bio_wait(rw, &bio);\n}",
          "includes": [
            "#include <linux/prefetch.h>",
            "#include <linux/gfp.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/prefetch.h>\n#include <linux/gfp.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"logfs.h\"\n\nstatic int sync_request(struct page *page, struct block_device *bdev, int rw)\n{\n\tstruct bio bio;\n\tstruct bio_vec bio_vec;\n\n\tbio_init(&bio);\n\tbio.bi_max_vecs = 1;\n\tbio.bi_io_vec = &bio_vec;\n\tbio_vec.bv_page = page;\n\tbio_vec.bv_len = PAGE_SIZE;\n\tbio_vec.bv_offset = 0;\n\tbio.bi_vcnt = 1;\n\tbio.bi_bdev = bdev;\n\tbio.bi_iter.bi_sector = page->index * (PAGE_SIZE >> 9);\n\tbio.bi_iter.bi_size = PAGE_SIZE;\n\n\treturn submit_bio_wait(rw, &bio);\n}"
        }
      },
      {
        "call_info": {
          "callee": "logfs_super",
          "args": [
            "sb"
          ],
          "line": 273
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/logfs.h",
          "lines": "628-631",
          "snippet": "static inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"logfs_abi.h\"",
            "#include <linux/mtd/mtd.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/btree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"logfs_abi.h\"\n#include <linux/mtd/mtd.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/crc32.h>\n#include <linux/btree.h>\n\nstatic inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/prefetch.h>\n#include <linux/gfp.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"logfs.h\"\n\nstatic int bdev_write_sb(struct super_block *sb, struct page *page)\n{\n\tstruct block_device *bdev = logfs_super(sb)->s_bdev;\n\n\t/* Nothing special to do for block devices. */\n\treturn sync_request(page, bdev, WRITE);\n}"
  },
  {
    "function_name": "bdev_find_last_sb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/dev_bdev.c",
    "lines": "259-269",
    "snippet": "static struct page *bdev_find_last_sb(struct super_block *sb, u64 *ofs)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct address_space *mapping = super->s_mapping_inode->i_mapping;\n\tfiller_t *filler = bdev_readpage;\n\tu64 pos = (super->s_bdev->bd_inode->i_size & ~0xfffULL) - 0x1000;\n\tpgoff_t index = pos >> PAGE_SHIFT;\n\n\t*ofs = pos;\n\treturn read_cache_page(mapping, index, filler, sb);\n}",
    "includes": [
      "#include <linux/prefetch.h>",
      "#include <linux/gfp.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "read_cache_page",
          "args": [
            "mapping",
            "index",
            "filler",
            "sb"
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logfs_super",
          "args": [
            "sb"
          ],
          "line": 261
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/logfs.h",
          "lines": "628-631",
          "snippet": "static inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"logfs_abi.h\"",
            "#include <linux/mtd/mtd.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/btree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"logfs_abi.h\"\n#include <linux/mtd/mtd.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/crc32.h>\n#include <linux/btree.h>\n\nstatic inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/prefetch.h>\n#include <linux/gfp.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"logfs.h\"\n\nstatic struct page *bdev_find_last_sb(struct super_block *sb, u64 *ofs)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct address_space *mapping = super->s_mapping_inode->i_mapping;\n\tfiller_t *filler = bdev_readpage;\n\tu64 pos = (super->s_bdev->bd_inode->i_size & ~0xfffULL) - 0x1000;\n\tpgoff_t index = pos >> PAGE_SHIFT;\n\n\t*ofs = pos;\n\treturn read_cache_page(mapping, index, filler, sb);\n}"
  },
  {
    "function_name": "bdev_find_first_sb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/dev_bdev.c",
    "lines": "249-257",
    "snippet": "static struct page *bdev_find_first_sb(struct super_block *sb, u64 *ofs)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct address_space *mapping = super->s_mapping_inode->i_mapping;\n\tfiller_t *filler = bdev_readpage;\n\n\t*ofs = 0;\n\treturn read_cache_page(mapping, 0, filler, sb);\n}",
    "includes": [
      "#include <linux/prefetch.h>",
      "#include <linux/gfp.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "read_cache_page",
          "args": [
            "mapping",
            "0",
            "filler",
            "sb"
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logfs_super",
          "args": [
            "sb"
          ],
          "line": 251
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/logfs.h",
          "lines": "628-631",
          "snippet": "static inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"logfs_abi.h\"",
            "#include <linux/mtd/mtd.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/btree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"logfs_abi.h\"\n#include <linux/mtd/mtd.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/crc32.h>\n#include <linux/btree.h>\n\nstatic inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/prefetch.h>\n#include <linux/gfp.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"logfs.h\"\n\nstatic struct page *bdev_find_first_sb(struct super_block *sb, u64 *ofs)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct address_space *mapping = super->s_mapping_inode->i_mapping;\n\tfiller_t *filler = bdev_readpage;\n\n\t*ofs = 0;\n\treturn read_cache_page(mapping, 0, filler, sb);\n}"
  },
  {
    "function_name": "bdev_sync",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/dev_bdev.c",
    "lines": "242-247",
    "snippet": "static void bdev_sync(struct super_block *sb)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\n\twait_event(wq, atomic_read(&super->s_pending_writes) == 0);\n}",
    "includes": [
      "#include <linux/prefetch.h>",
      "#include <linux/gfp.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static DECLARE_WAIT_QUEUE_HEAD(wq);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wait_event",
          "args": [
            "wq",
            "atomic_read(&super->s_pending_writes) == 0"
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&super->s_pending_writes"
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logfs_super",
          "args": [
            "sb"
          ],
          "line": 244
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/logfs.h",
          "lines": "628-631",
          "snippet": "static inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"logfs_abi.h\"",
            "#include <linux/mtd/mtd.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/btree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"logfs_abi.h\"\n#include <linux/mtd/mtd.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/crc32.h>\n#include <linux/btree.h>\n\nstatic inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/prefetch.h>\n#include <linux/gfp.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"logfs.h\"\n\nstatic DECLARE_WAIT_QUEUE_HEAD(wq);\n\nstatic void bdev_sync(struct super_block *sb)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\n\twait_event(wq, atomic_read(&super->s_pending_writes) == 0);\n}"
  },
  {
    "function_name": "bdev_erase",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/dev_bdev.c",
    "lines": "218-240",
    "snippet": "static int bdev_erase(struct super_block *sb, loff_t to, size_t len,\n\t\tint ensure_write)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\n\tBUG_ON(to & (PAGE_SIZE - 1));\n\tBUG_ON(len & (PAGE_SIZE - 1));\n\n\tif (super->s_flags & LOGFS_SB_FLAG_RO)\n\t\treturn -EROFS;\n\n\tif (ensure_write) {\n\t\t/*\n\t\t * Object store doesn't care whether erases happen or not.\n\t\t * But for the journal they are required.  Otherwise a scan\n\t\t * can find an old commit entry and assume it is the current\n\t\t * one, travelling back in time.\n\t\t */\n\t\tdo_erase(sb, to, to >> PAGE_SHIFT, len >> PAGE_SHIFT);\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/prefetch.h>",
      "#include <linux/gfp.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_erase",
          "args": [
            "sb",
            "to",
            "to >> PAGE_SHIFT",
            "len >> PAGE_SHIFT"
          ],
          "line": 236
        },
        "resolved": true,
        "details": {
          "function_name": "do_erase",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/dev_bdev.c",
          "lines": "170-216",
          "snippet": "static int do_erase(struct super_block *sb, u64 ofs, pgoff_t index,\n\t\tsize_t nr_pages)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct bio *bio;\n\tunsigned int max_pages;\n\tint i;\n\n\tmax_pages = min(nr_pages, (size_t) bio_get_nr_vecs(super->s_bdev));\n\n\tbio = bio_alloc(GFP_NOFS, max_pages);\n\tBUG_ON(!bio);\n\n\tfor (i = 0; i < nr_pages; i++) {\n\t\tif (i >= max_pages) {\n\t\t\t/* Block layer cannot split bios :( */\n\t\t\tbio->bi_vcnt = i;\n\t\t\tbio->bi_iter.bi_size = i * PAGE_SIZE;\n\t\t\tbio->bi_bdev = super->s_bdev;\n\t\t\tbio->bi_iter.bi_sector = ofs >> 9;\n\t\t\tbio->bi_private = sb;\n\t\t\tbio->bi_end_io = erase_end_io;\n\t\t\tatomic_inc(&super->s_pending_writes);\n\t\t\tsubmit_bio(WRITE, bio);\n\n\t\t\tofs += i * PAGE_SIZE;\n\t\t\tindex += i;\n\t\t\tnr_pages -= i;\n\t\t\ti = 0;\n\n\t\t\tbio = bio_alloc(GFP_NOFS, max_pages);\n\t\t\tBUG_ON(!bio);\n\t\t}\n\t\tbio->bi_io_vec[i].bv_page = super->s_erase_page;\n\t\tbio->bi_io_vec[i].bv_len = PAGE_SIZE;\n\t\tbio->bi_io_vec[i].bv_offset = 0;\n\t}\n\tbio->bi_vcnt = nr_pages;\n\tbio->bi_iter.bi_size = nr_pages * PAGE_SIZE;\n\tbio->bi_bdev = super->s_bdev;\n\tbio->bi_iter.bi_sector = ofs >> 9;\n\tbio->bi_private = sb;\n\tbio->bi_end_io = erase_end_io;\n\tatomic_inc(&super->s_pending_writes);\n\tsubmit_bio(WRITE, bio);\n\treturn 0;\n}",
          "includes": [
            "#include <linux/prefetch.h>",
            "#include <linux/gfp.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/prefetch.h>\n#include <linux/gfp.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"logfs.h\"\n\nstatic int do_erase(struct super_block *sb, u64 ofs, pgoff_t index,\n\t\tsize_t nr_pages)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct bio *bio;\n\tunsigned int max_pages;\n\tint i;\n\n\tmax_pages = min(nr_pages, (size_t) bio_get_nr_vecs(super->s_bdev));\n\n\tbio = bio_alloc(GFP_NOFS, max_pages);\n\tBUG_ON(!bio);\n\n\tfor (i = 0; i < nr_pages; i++) {\n\t\tif (i >= max_pages) {\n\t\t\t/* Block layer cannot split bios :( */\n\t\t\tbio->bi_vcnt = i;\n\t\t\tbio->bi_iter.bi_size = i * PAGE_SIZE;\n\t\t\tbio->bi_bdev = super->s_bdev;\n\t\t\tbio->bi_iter.bi_sector = ofs >> 9;\n\t\t\tbio->bi_private = sb;\n\t\t\tbio->bi_end_io = erase_end_io;\n\t\t\tatomic_inc(&super->s_pending_writes);\n\t\t\tsubmit_bio(WRITE, bio);\n\n\t\t\tofs += i * PAGE_SIZE;\n\t\t\tindex += i;\n\t\t\tnr_pages -= i;\n\t\t\ti = 0;\n\n\t\t\tbio = bio_alloc(GFP_NOFS, max_pages);\n\t\t\tBUG_ON(!bio);\n\t\t}\n\t\tbio->bi_io_vec[i].bv_page = super->s_erase_page;\n\t\tbio->bi_io_vec[i].bv_len = PAGE_SIZE;\n\t\tbio->bi_io_vec[i].bv_offset = 0;\n\t}\n\tbio->bi_vcnt = nr_pages;\n\tbio->bi_iter.bi_size = nr_pages * PAGE_SIZE;\n\tbio->bi_bdev = super->s_bdev;\n\tbio->bi_iter.bi_sector = ofs >> 9;\n\tbio->bi_private = sb;\n\tbio->bi_end_io = erase_end_io;\n\tatomic_inc(&super->s_pending_writes);\n\tsubmit_bio(WRITE, bio);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "len & (PAGE_SIZE - 1)"
          ],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "to & (PAGE_SIZE - 1)"
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logfs_super",
          "args": [
            "sb"
          ],
          "line": 221
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/logfs.h",
          "lines": "628-631",
          "snippet": "static inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"logfs_abi.h\"",
            "#include <linux/mtd/mtd.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/btree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"logfs_abi.h\"\n#include <linux/mtd/mtd.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/crc32.h>\n#include <linux/btree.h>\n\nstatic inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/prefetch.h>\n#include <linux/gfp.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"logfs.h\"\n\nstatic int bdev_erase(struct super_block *sb, loff_t to, size_t len,\n\t\tint ensure_write)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\n\tBUG_ON(to & (PAGE_SIZE - 1));\n\tBUG_ON(len & (PAGE_SIZE - 1));\n\n\tif (super->s_flags & LOGFS_SB_FLAG_RO)\n\t\treturn -EROFS;\n\n\tif (ensure_write) {\n\t\t/*\n\t\t * Object store doesn't care whether erases happen or not.\n\t\t * But for the journal they are required.  Otherwise a scan\n\t\t * can find an old commit entry and assume it is the current\n\t\t * one, travelling back in time.\n\t\t */\n\t\tdo_erase(sb, to, to >> PAGE_SHIFT, len >> PAGE_SHIFT);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "do_erase",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/dev_bdev.c",
    "lines": "170-216",
    "snippet": "static int do_erase(struct super_block *sb, u64 ofs, pgoff_t index,\n\t\tsize_t nr_pages)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct bio *bio;\n\tunsigned int max_pages;\n\tint i;\n\n\tmax_pages = min(nr_pages, (size_t) bio_get_nr_vecs(super->s_bdev));\n\n\tbio = bio_alloc(GFP_NOFS, max_pages);\n\tBUG_ON(!bio);\n\n\tfor (i = 0; i < nr_pages; i++) {\n\t\tif (i >= max_pages) {\n\t\t\t/* Block layer cannot split bios :( */\n\t\t\tbio->bi_vcnt = i;\n\t\t\tbio->bi_iter.bi_size = i * PAGE_SIZE;\n\t\t\tbio->bi_bdev = super->s_bdev;\n\t\t\tbio->bi_iter.bi_sector = ofs >> 9;\n\t\t\tbio->bi_private = sb;\n\t\t\tbio->bi_end_io = erase_end_io;\n\t\t\tatomic_inc(&super->s_pending_writes);\n\t\t\tsubmit_bio(WRITE, bio);\n\n\t\t\tofs += i * PAGE_SIZE;\n\t\t\tindex += i;\n\t\t\tnr_pages -= i;\n\t\t\ti = 0;\n\n\t\t\tbio = bio_alloc(GFP_NOFS, max_pages);\n\t\t\tBUG_ON(!bio);\n\t\t}\n\t\tbio->bi_io_vec[i].bv_page = super->s_erase_page;\n\t\tbio->bi_io_vec[i].bv_len = PAGE_SIZE;\n\t\tbio->bi_io_vec[i].bv_offset = 0;\n\t}\n\tbio->bi_vcnt = nr_pages;\n\tbio->bi_iter.bi_size = nr_pages * PAGE_SIZE;\n\tbio->bi_bdev = super->s_bdev;\n\tbio->bi_iter.bi_sector = ofs >> 9;\n\tbio->bi_private = sb;\n\tbio->bi_end_io = erase_end_io;\n\tatomic_inc(&super->s_pending_writes);\n\tsubmit_bio(WRITE, bio);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/prefetch.h>",
      "#include <linux/gfp.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "submit_bio",
          "args": [
            "WRITE",
            "bio"
          ],
          "line": 214
        },
        "resolved": true,
        "details": {
          "function_name": "bl_submit_bio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/blocklayout/blocklayout.c",
          "lines": "104-115",
          "snippet": "static struct bio *\nbl_submit_bio(int rw, struct bio *bio)\n{\n\tif (bio) {\n\t\tget_parallel(bio->bi_private);\n\t\tdprintk(\"%s submitting %s bio %u@%llu\\n\", __func__,\n\t\t\trw == READ ? \"read\" : \"write\", bio->bi_iter.bi_size,\n\t\t\t(unsigned long long)bio->bi_iter.bi_sector);\n\t\tsubmit_bio(rw, bio);\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"blocklayout.h\"",
            "#include \"../internal.h\"",
            "#include \"../nfs4session.h\"",
            "#include \"../pnfs.h\"",
            "#include <linux/pagevec.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/bio.h>\t\t/* struct bio */",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"blocklayout.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include \"../pnfs.h\"\n#include <linux/pagevec.h>\n#include <linux/prefetch.h>\n#include <linux/bio.h>\t\t/* struct bio */\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic struct bio *\nbl_submit_bio(int rw, struct bio *bio)\n{\n\tif (bio) {\n\t\tget_parallel(bio->bi_private);\n\t\tdprintk(\"%s submitting %s bio %u@%llu\\n\", __func__,\n\t\t\trw == READ ? \"read\" : \"write\", bio->bi_iter.bi_size,\n\t\t\t(unsigned long long)bio->bi_iter.bi_sector);\n\t\tsubmit_bio(rw, bio);\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&super->s_pending_writes"
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!bio"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bio_alloc",
          "args": [
            "GFP_NOFS",
            "max_pages"
          ],
          "line": 200
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_io_bio_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "2733-2746",
          "snippet": "struct bio *btrfs_io_bio_alloc(gfp_t gfp_mask, unsigned int nr_iovecs)\n{\n\tstruct btrfs_io_bio *btrfs_bio;\n\tstruct bio *bio;\n\n\tbio = bio_alloc_bioset(gfp_mask, nr_iovecs, btrfs_bioset);\n\tif (bio) {\n\t\tbtrfs_bio = btrfs_io_bio(bio);\n\t\tbtrfs_bio->csum = NULL;\n\t\tbtrfs_bio->csum_allocated = NULL;\n\t\tbtrfs_bio->end_io = NULL;\n\t}\n\treturn bio;\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct bio_set *btrfs_bioset;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic struct bio_set *btrfs_bioset;\n\nstruct bio *btrfs_io_bio_alloc(gfp_t gfp_mask, unsigned int nr_iovecs)\n{\n\tstruct btrfs_io_bio *btrfs_bio;\n\tstruct bio *bio;\n\n\tbio = bio_alloc_bioset(gfp_mask, nr_iovecs, btrfs_bioset);\n\tif (bio) {\n\t\tbtrfs_bio = btrfs_io_bio(bio);\n\t\tbtrfs_bio->csum = NULL;\n\t\tbtrfs_bio->csum_allocated = NULL;\n\t\tbtrfs_bio->end_io = NULL;\n\t}\n\treturn bio;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&super->s_pending_writes"
          ],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!bio"
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "nr_pages",
            "(size_t) bio_get_nr_vecs(super->s_bdev)"
          ],
          "line": 178
        },
        "resolved": true,
        "details": {
          "function_name": "get_dominating_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pnode.c",
          "lines": "55-66",
          "snippet": "int get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"pnode.h\"",
            "#include \"internal.h\"",
            "#include <linux/nsproxy.h>",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/mnt_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnode.h\"\n#include \"internal.h\"\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mnt_namespace.h>\n\nint get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bio_get_nr_vecs",
          "args": [
            "super->s_bdev"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logfs_super",
          "args": [
            "sb"
          ],
          "line": 173
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/logfs.h",
          "lines": "628-631",
          "snippet": "static inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"logfs_abi.h\"",
            "#include <linux/mtd/mtd.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/btree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"logfs_abi.h\"\n#include <linux/mtd/mtd.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/crc32.h>\n#include <linux/btree.h>\n\nstatic inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/prefetch.h>\n#include <linux/gfp.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"logfs.h\"\n\nstatic int do_erase(struct super_block *sb, u64 ofs, pgoff_t index,\n\t\tsize_t nr_pages)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct bio *bio;\n\tunsigned int max_pages;\n\tint i;\n\n\tmax_pages = min(nr_pages, (size_t) bio_get_nr_vecs(super->s_bdev));\n\n\tbio = bio_alloc(GFP_NOFS, max_pages);\n\tBUG_ON(!bio);\n\n\tfor (i = 0; i < nr_pages; i++) {\n\t\tif (i >= max_pages) {\n\t\t\t/* Block layer cannot split bios :( */\n\t\t\tbio->bi_vcnt = i;\n\t\t\tbio->bi_iter.bi_size = i * PAGE_SIZE;\n\t\t\tbio->bi_bdev = super->s_bdev;\n\t\t\tbio->bi_iter.bi_sector = ofs >> 9;\n\t\t\tbio->bi_private = sb;\n\t\t\tbio->bi_end_io = erase_end_io;\n\t\t\tatomic_inc(&super->s_pending_writes);\n\t\t\tsubmit_bio(WRITE, bio);\n\n\t\t\tofs += i * PAGE_SIZE;\n\t\t\tindex += i;\n\t\t\tnr_pages -= i;\n\t\t\ti = 0;\n\n\t\t\tbio = bio_alloc(GFP_NOFS, max_pages);\n\t\t\tBUG_ON(!bio);\n\t\t}\n\t\tbio->bi_io_vec[i].bv_page = super->s_erase_page;\n\t\tbio->bi_io_vec[i].bv_len = PAGE_SIZE;\n\t\tbio->bi_io_vec[i].bv_offset = 0;\n\t}\n\tbio->bi_vcnt = nr_pages;\n\tbio->bi_iter.bi_size = nr_pages * PAGE_SIZE;\n\tbio->bi_bdev = super->s_bdev;\n\tbio->bi_iter.bi_sector = ofs >> 9;\n\tbio->bi_private = sb;\n\tbio->bi_end_io = erase_end_io;\n\tatomic_inc(&super->s_pending_writes);\n\tsubmit_bio(WRITE, bio);\n\treturn 0;\n}"
  },
  {
    "function_name": "erase_end_io",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/dev_bdev.c",
    "lines": "156-168",
    "snippet": "static void erase_end_io(struct bio *bio, int err) \n{ \n\tconst int uptodate = test_bit(BIO_UPTODATE, &bio->bi_flags); \n\tstruct super_block *sb = bio->bi_private; \n\tstruct logfs_super *super = logfs_super(sb); \n\n\tBUG_ON(!uptodate); /* FIXME: Retry io or write elsewhere */ \n\tBUG_ON(err); \n\tBUG_ON(bio->bi_vcnt == 0); \n\tbio_put(bio); \n\tif (atomic_dec_and_test(&super->s_pending_writes))\n\t\twake_up(&wq); \n}",
    "includes": [
      "#include <linux/prefetch.h>",
      "#include <linux/gfp.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static DECLARE_WAIT_QUEUE_HEAD(wq);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wake_up",
          "args": [
            "&wq"
          ],
          "line": 167
        },
        "resolved": true,
        "details": {
          "function_name": "locks_wake_up_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "656-681",
          "snippet": "static void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(blocked_lock_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic DEFINE_SPINLOCK(blocked_lock_lock);\n\nstatic void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_dec_and_test",
          "args": [
            "&super->s_pending_writes"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bio_put",
          "args": [
            "bio"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "bio->bi_vcnt == 0"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "err"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!uptodate"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logfs_super",
          "args": [
            "sb"
          ],
          "line": 160
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/logfs.h",
          "lines": "628-631",
          "snippet": "static inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"logfs_abi.h\"",
            "#include <linux/mtd/mtd.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/btree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"logfs_abi.h\"\n#include <linux/mtd/mtd.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/crc32.h>\n#include <linux/btree.h>\n\nstatic inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "BIO_UPTODATE",
            "&bio->bi_flags"
          ],
          "line": 158
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/prefetch.h>\n#include <linux/gfp.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"logfs.h\"\n\nstatic DECLARE_WAIT_QUEUE_HEAD(wq);\n\nstatic void erase_end_io(struct bio *bio, int err) \n{ \n\tconst int uptodate = test_bit(BIO_UPTODATE, &bio->bi_flags); \n\tstruct super_block *sb = bio->bi_private; \n\tstruct logfs_super *super = logfs_super(sb); \n\n\tBUG_ON(!uptodate); /* FIXME: Retry io or write elsewhere */ \n\tBUG_ON(err); \n\tBUG_ON(bio->bi_vcnt == 0); \n\tbio_put(bio); \n\tif (atomic_dec_and_test(&super->s_pending_writes))\n\t\twake_up(&wq); \n}"
  },
  {
    "function_name": "bdev_writeseg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/dev_bdev.c",
    "lines": "132-153",
    "snippet": "static void bdev_writeseg(struct super_block *sb, u64 ofs, size_t len)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tint head;\n\n\tBUG_ON(super->s_flags & LOGFS_SB_FLAG_RO);\n\n\tif (len == 0) {\n\t\t/* This can happen when the object fit perfectly into a\n\t\t * segment, the segment gets written per sync and subsequently\n\t\t * closed.\n\t\t */\n\t\treturn;\n\t}\n\thead = ofs & (PAGE_SIZE - 1);\n\tif (head) {\n\t\tofs -= head;\n\t\tlen += head;\n\t}\n\tlen = PAGE_ALIGN(len);\n\t__bdev_writeseg(sb, ofs, ofs >> PAGE_SHIFT, len >> PAGE_SHIFT);\n}",
    "includes": [
      "#include <linux/prefetch.h>",
      "#include <linux/gfp.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__bdev_writeseg",
          "args": [
            "sb",
            "ofs",
            "ofs >> PAGE_SHIFT",
            "len >> PAGE_SHIFT"
          ],
          "line": 152
        },
        "resolved": true,
        "details": {
          "function_name": "__bdev_writeseg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/dev_bdev.c",
          "lines": "76-130",
          "snippet": "static int __bdev_writeseg(struct super_block *sb, u64 ofs, pgoff_t index,\n\t\tsize_t nr_pages)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct address_space *mapping = super->s_mapping_inode->i_mapping;\n\tstruct bio *bio;\n\tstruct page *page;\n\tunsigned int max_pages;\n\tint i;\n\n\tmax_pages = min(nr_pages, (size_t) bio_get_nr_vecs(super->s_bdev));\n\n\tbio = bio_alloc(GFP_NOFS, max_pages);\n\tBUG_ON(!bio);\n\n\tfor (i = 0; i < nr_pages; i++) {\n\t\tif (i >= max_pages) {\n\t\t\t/* Block layer cannot split bios :( */\n\t\t\tbio->bi_vcnt = i;\n\t\t\tbio->bi_iter.bi_size = i * PAGE_SIZE;\n\t\t\tbio->bi_bdev = super->s_bdev;\n\t\t\tbio->bi_iter.bi_sector = ofs >> 9;\n\t\t\tbio->bi_private = sb;\n\t\t\tbio->bi_end_io = writeseg_end_io;\n\t\t\tatomic_inc(&super->s_pending_writes);\n\t\t\tsubmit_bio(WRITE, bio);\n\n\t\t\tofs += i * PAGE_SIZE;\n\t\t\tindex += i;\n\t\t\tnr_pages -= i;\n\t\t\ti = 0;\n\n\t\t\tbio = bio_alloc(GFP_NOFS, max_pages);\n\t\t\tBUG_ON(!bio);\n\t\t}\n\t\tpage = find_lock_page(mapping, index + i);\n\t\tBUG_ON(!page);\n\t\tbio->bi_io_vec[i].bv_page = page;\n\t\tbio->bi_io_vec[i].bv_len = PAGE_SIZE;\n\t\tbio->bi_io_vec[i].bv_offset = 0;\n\n\t\tBUG_ON(PageWriteback(page));\n\t\tset_page_writeback(page);\n\t\tunlock_page(page);\n\t}\n\tbio->bi_vcnt = nr_pages;\n\tbio->bi_iter.bi_size = nr_pages * PAGE_SIZE;\n\tbio->bi_bdev = super->s_bdev;\n\tbio->bi_iter.bi_sector = ofs >> 9;\n\tbio->bi_private = sb;\n\tbio->bi_end_io = writeseg_end_io;\n\tatomic_inc(&super->s_pending_writes);\n\tsubmit_bio(WRITE, bio);\n\treturn 0;\n}",
          "includes": [
            "#include <linux/prefetch.h>",
            "#include <linux/gfp.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/prefetch.h>\n#include <linux/gfp.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"logfs.h\"\n\nstatic int __bdev_writeseg(struct super_block *sb, u64 ofs, pgoff_t index,\n\t\tsize_t nr_pages)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct address_space *mapping = super->s_mapping_inode->i_mapping;\n\tstruct bio *bio;\n\tstruct page *page;\n\tunsigned int max_pages;\n\tint i;\n\n\tmax_pages = min(nr_pages, (size_t) bio_get_nr_vecs(super->s_bdev));\n\n\tbio = bio_alloc(GFP_NOFS, max_pages);\n\tBUG_ON(!bio);\n\n\tfor (i = 0; i < nr_pages; i++) {\n\t\tif (i >= max_pages) {\n\t\t\t/* Block layer cannot split bios :( */\n\t\t\tbio->bi_vcnt = i;\n\t\t\tbio->bi_iter.bi_size = i * PAGE_SIZE;\n\t\t\tbio->bi_bdev = super->s_bdev;\n\t\t\tbio->bi_iter.bi_sector = ofs >> 9;\n\t\t\tbio->bi_private = sb;\n\t\t\tbio->bi_end_io = writeseg_end_io;\n\t\t\tatomic_inc(&super->s_pending_writes);\n\t\t\tsubmit_bio(WRITE, bio);\n\n\t\t\tofs += i * PAGE_SIZE;\n\t\t\tindex += i;\n\t\t\tnr_pages -= i;\n\t\t\ti = 0;\n\n\t\t\tbio = bio_alloc(GFP_NOFS, max_pages);\n\t\t\tBUG_ON(!bio);\n\t\t}\n\t\tpage = find_lock_page(mapping, index + i);\n\t\tBUG_ON(!page);\n\t\tbio->bi_io_vec[i].bv_page = page;\n\t\tbio->bi_io_vec[i].bv_len = PAGE_SIZE;\n\t\tbio->bi_io_vec[i].bv_offset = 0;\n\n\t\tBUG_ON(PageWriteback(page));\n\t\tset_page_writeback(page);\n\t\tunlock_page(page);\n\t}\n\tbio->bi_vcnt = nr_pages;\n\tbio->bi_iter.bi_size = nr_pages * PAGE_SIZE;\n\tbio->bi_bdev = super->s_bdev;\n\tbio->bi_iter.bi_sector = ofs >> 9;\n\tbio->bi_private = sb;\n\tbio->bi_end_io = writeseg_end_io;\n\tatomic_inc(&super->s_pending_writes);\n\tsubmit_bio(WRITE, bio);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PAGE_ALIGN",
          "args": [
            "len"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "super->s_flags & LOGFS_SB_FLAG_RO"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logfs_super",
          "args": [
            "sb"
          ],
          "line": 134
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/logfs.h",
          "lines": "628-631",
          "snippet": "static inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"logfs_abi.h\"",
            "#include <linux/mtd/mtd.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/btree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"logfs_abi.h\"\n#include <linux/mtd/mtd.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/crc32.h>\n#include <linux/btree.h>\n\nstatic inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/prefetch.h>\n#include <linux/gfp.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"logfs.h\"\n\nstatic void bdev_writeseg(struct super_block *sb, u64 ofs, size_t len)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tint head;\n\n\tBUG_ON(super->s_flags & LOGFS_SB_FLAG_RO);\n\n\tif (len == 0) {\n\t\t/* This can happen when the object fit perfectly into a\n\t\t * segment, the segment gets written per sync and subsequently\n\t\t * closed.\n\t\t */\n\t\treturn;\n\t}\n\thead = ofs & (PAGE_SIZE - 1);\n\tif (head) {\n\t\tofs -= head;\n\t\tlen += head;\n\t}\n\tlen = PAGE_ALIGN(len);\n\t__bdev_writeseg(sb, ofs, ofs >> PAGE_SHIFT, len >> PAGE_SHIFT);\n}"
  },
  {
    "function_name": "__bdev_writeseg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/dev_bdev.c",
    "lines": "76-130",
    "snippet": "static int __bdev_writeseg(struct super_block *sb, u64 ofs, pgoff_t index,\n\t\tsize_t nr_pages)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct address_space *mapping = super->s_mapping_inode->i_mapping;\n\tstruct bio *bio;\n\tstruct page *page;\n\tunsigned int max_pages;\n\tint i;\n\n\tmax_pages = min(nr_pages, (size_t) bio_get_nr_vecs(super->s_bdev));\n\n\tbio = bio_alloc(GFP_NOFS, max_pages);\n\tBUG_ON(!bio);\n\n\tfor (i = 0; i < nr_pages; i++) {\n\t\tif (i >= max_pages) {\n\t\t\t/* Block layer cannot split bios :( */\n\t\t\tbio->bi_vcnt = i;\n\t\t\tbio->bi_iter.bi_size = i * PAGE_SIZE;\n\t\t\tbio->bi_bdev = super->s_bdev;\n\t\t\tbio->bi_iter.bi_sector = ofs >> 9;\n\t\t\tbio->bi_private = sb;\n\t\t\tbio->bi_end_io = writeseg_end_io;\n\t\t\tatomic_inc(&super->s_pending_writes);\n\t\t\tsubmit_bio(WRITE, bio);\n\n\t\t\tofs += i * PAGE_SIZE;\n\t\t\tindex += i;\n\t\t\tnr_pages -= i;\n\t\t\ti = 0;\n\n\t\t\tbio = bio_alloc(GFP_NOFS, max_pages);\n\t\t\tBUG_ON(!bio);\n\t\t}\n\t\tpage = find_lock_page(mapping, index + i);\n\t\tBUG_ON(!page);\n\t\tbio->bi_io_vec[i].bv_page = page;\n\t\tbio->bi_io_vec[i].bv_len = PAGE_SIZE;\n\t\tbio->bi_io_vec[i].bv_offset = 0;\n\n\t\tBUG_ON(PageWriteback(page));\n\t\tset_page_writeback(page);\n\t\tunlock_page(page);\n\t}\n\tbio->bi_vcnt = nr_pages;\n\tbio->bi_iter.bi_size = nr_pages * PAGE_SIZE;\n\tbio->bi_bdev = super->s_bdev;\n\tbio->bi_iter.bi_sector = ofs >> 9;\n\tbio->bi_private = sb;\n\tbio->bi_end_io = writeseg_end_io;\n\tatomic_inc(&super->s_pending_writes);\n\tsubmit_bio(WRITE, bio);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/prefetch.h>",
      "#include <linux/gfp.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "submit_bio",
          "args": [
            "WRITE",
            "bio"
          ],
          "line": 128
        },
        "resolved": true,
        "details": {
          "function_name": "bl_submit_bio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/blocklayout/blocklayout.c",
          "lines": "104-115",
          "snippet": "static struct bio *\nbl_submit_bio(int rw, struct bio *bio)\n{\n\tif (bio) {\n\t\tget_parallel(bio->bi_private);\n\t\tdprintk(\"%s submitting %s bio %u@%llu\\n\", __func__,\n\t\t\trw == READ ? \"read\" : \"write\", bio->bi_iter.bi_size,\n\t\t\t(unsigned long long)bio->bi_iter.bi_sector);\n\t\tsubmit_bio(rw, bio);\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"blocklayout.h\"",
            "#include \"../internal.h\"",
            "#include \"../nfs4session.h\"",
            "#include \"../pnfs.h\"",
            "#include <linux/pagevec.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/bio.h>\t\t/* struct bio */",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"blocklayout.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include \"../pnfs.h\"\n#include <linux/pagevec.h>\n#include <linux/prefetch.h>\n#include <linux/bio.h>\t\t/* struct bio */\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic struct bio *\nbl_submit_bio(int rw, struct bio *bio)\n{\n\tif (bio) {\n\t\tget_parallel(bio->bi_private);\n\t\tdprintk(\"%s submitting %s bio %u@%llu\\n\", __func__,\n\t\t\trw == READ ? \"read\" : \"write\", bio->bi_iter.bi_size,\n\t\t\t(unsigned long long)bio->bi_iter.bi_sector);\n\t\tsubmit_bio(rw, bio);\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&super->s_pending_writes"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 119
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_page_writeback",
          "args": [
            "page"
          ],
          "line": 118
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_set_page_writeback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
          "lines": "265-277",
          "snippet": "static void nfs_set_page_writeback(struct page *page)\n{\n\tstruct nfs_server *nfss = NFS_SERVER(page_file_mapping(page)->host);\n\tint ret = test_set_page_writeback(page);\n\n\tWARN_ON_ONCE(ret != 0);\n\n\tif (atomic_long_inc_return(&nfss->writeback) >\n\t\t\tNFS_CONGESTION_ON_THRESH) {\n\t\tset_bdi_congested(&nfss->backing_dev_info,\n\t\t\t\t\tBLK_RW_ASYNC);\n\t}\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define NFS_CONGESTION_ON_THRESH \t(nfs_congestion_kb >> (PAGE_SHIFT-10))"
          ],
          "globals_used": [
            "static struct nfs_page *\nnfs_page_search_commits_for_head_request_locked(struct nfs_inode *nfsi,\n\t\t\t\t\t\tstruct page *page);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\n#define NFS_CONGESTION_ON_THRESH \t(nfs_congestion_kb >> (PAGE_SHIFT-10))\n\nstatic struct nfs_page *\nnfs_page_search_commits_for_head_request_locked(struct nfs_inode *nfsi,\n\t\t\t\t\t\tstruct page *page);\n\nstatic void nfs_set_page_writeback(struct page *page)\n{\n\tstruct nfs_server *nfss = NFS_SERVER(page_file_mapping(page)->host);\n\tint ret = test_set_page_writeback(page);\n\n\tWARN_ON_ONCE(ret != 0);\n\n\tif (atomic_long_inc_return(&nfss->writeback) >\n\t\t\tNFS_CONGESTION_ON_THRESH) {\n\t\tset_bdi_congested(&nfss->backing_dev_info,\n\t\t\t\t\tBLK_RW_ASYNC);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "PageWriteback(page)"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageWriteback",
          "args": [
            "page"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!page"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_lock_page",
          "args": [
            "mapping",
            "index + i"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!bio"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bio_alloc",
          "args": [
            "GFP_NOFS",
            "max_pages"
          ],
          "line": 108
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_io_bio_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "2733-2746",
          "snippet": "struct bio *btrfs_io_bio_alloc(gfp_t gfp_mask, unsigned int nr_iovecs)\n{\n\tstruct btrfs_io_bio *btrfs_bio;\n\tstruct bio *bio;\n\n\tbio = bio_alloc_bioset(gfp_mask, nr_iovecs, btrfs_bioset);\n\tif (bio) {\n\t\tbtrfs_bio = btrfs_io_bio(bio);\n\t\tbtrfs_bio->csum = NULL;\n\t\tbtrfs_bio->csum_allocated = NULL;\n\t\tbtrfs_bio->end_io = NULL;\n\t}\n\treturn bio;\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct bio_set *btrfs_bioset;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic struct bio_set *btrfs_bioset;\n\nstruct bio *btrfs_io_bio_alloc(gfp_t gfp_mask, unsigned int nr_iovecs)\n{\n\tstruct btrfs_io_bio *btrfs_bio;\n\tstruct bio *bio;\n\n\tbio = bio_alloc_bioset(gfp_mask, nr_iovecs, btrfs_bioset);\n\tif (bio) {\n\t\tbtrfs_bio = btrfs_io_bio(bio);\n\t\tbtrfs_bio->csum = NULL;\n\t\tbtrfs_bio->csum_allocated = NULL;\n\t\tbtrfs_bio->end_io = NULL;\n\t}\n\treturn bio;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&super->s_pending_writes"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!bio"
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "nr_pages",
            "(size_t) bio_get_nr_vecs(super->s_bdev)"
          ],
          "line": 86
        },
        "resolved": true,
        "details": {
          "function_name": "get_dominating_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pnode.c",
          "lines": "55-66",
          "snippet": "int get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"pnode.h\"",
            "#include \"internal.h\"",
            "#include <linux/nsproxy.h>",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/mnt_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnode.h\"\n#include \"internal.h\"\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mnt_namespace.h>\n\nint get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bio_get_nr_vecs",
          "args": [
            "super->s_bdev"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logfs_super",
          "args": [
            "sb"
          ],
          "line": 79
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/logfs.h",
          "lines": "628-631",
          "snippet": "static inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"logfs_abi.h\"",
            "#include <linux/mtd/mtd.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/btree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"logfs_abi.h\"\n#include <linux/mtd/mtd.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/crc32.h>\n#include <linux/btree.h>\n\nstatic inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/prefetch.h>\n#include <linux/gfp.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"logfs.h\"\n\nstatic int __bdev_writeseg(struct super_block *sb, u64 ofs, pgoff_t index,\n\t\tsize_t nr_pages)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct address_space *mapping = super->s_mapping_inode->i_mapping;\n\tstruct bio *bio;\n\tstruct page *page;\n\tunsigned int max_pages;\n\tint i;\n\n\tmax_pages = min(nr_pages, (size_t) bio_get_nr_vecs(super->s_bdev));\n\n\tbio = bio_alloc(GFP_NOFS, max_pages);\n\tBUG_ON(!bio);\n\n\tfor (i = 0; i < nr_pages; i++) {\n\t\tif (i >= max_pages) {\n\t\t\t/* Block layer cannot split bios :( */\n\t\t\tbio->bi_vcnt = i;\n\t\t\tbio->bi_iter.bi_size = i * PAGE_SIZE;\n\t\t\tbio->bi_bdev = super->s_bdev;\n\t\t\tbio->bi_iter.bi_sector = ofs >> 9;\n\t\t\tbio->bi_private = sb;\n\t\t\tbio->bi_end_io = writeseg_end_io;\n\t\t\tatomic_inc(&super->s_pending_writes);\n\t\t\tsubmit_bio(WRITE, bio);\n\n\t\t\tofs += i * PAGE_SIZE;\n\t\t\tindex += i;\n\t\t\tnr_pages -= i;\n\t\t\ti = 0;\n\n\t\t\tbio = bio_alloc(GFP_NOFS, max_pages);\n\t\t\tBUG_ON(!bio);\n\t\t}\n\t\tpage = find_lock_page(mapping, index + i);\n\t\tBUG_ON(!page);\n\t\tbio->bi_io_vec[i].bv_page = page;\n\t\tbio->bi_io_vec[i].bv_len = PAGE_SIZE;\n\t\tbio->bi_io_vec[i].bv_offset = 0;\n\n\t\tBUG_ON(PageWriteback(page));\n\t\tset_page_writeback(page);\n\t\tunlock_page(page);\n\t}\n\tbio->bi_vcnt = nr_pages;\n\tbio->bi_iter.bi_size = nr_pages * PAGE_SIZE;\n\tbio->bi_bdev = super->s_bdev;\n\tbio->bi_iter.bi_sector = ofs >> 9;\n\tbio->bi_private = sb;\n\tbio->bi_end_io = writeseg_end_io;\n\tatomic_inc(&super->s_pending_writes);\n\tsubmit_bio(WRITE, bio);\n\treturn 0;\n}"
  },
  {
    "function_name": "writeseg_end_io",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/dev_bdev.c",
    "lines": "56-74",
    "snippet": "static void writeseg_end_io(struct bio *bio, int err)\n{\n\tconst int uptodate = test_bit(BIO_UPTODATE, &bio->bi_flags);\n\tstruct bio_vec *bvec;\n\tint i;\n\tstruct super_block *sb = bio->bi_private;\n\tstruct logfs_super *super = logfs_super(sb);\n\n\tBUG_ON(!uptodate); /* FIXME: Retry io or write elsewhere */\n\tBUG_ON(err);\n\n\tbio_for_each_segment_all(bvec, bio, i) {\n\t\tend_page_writeback(bvec->bv_page);\n\t\tpage_cache_release(bvec->bv_page);\n\t}\n\tbio_put(bio);\n\tif (atomic_dec_and_test(&super->s_pending_writes))\n\t\twake_up(&wq);\n}",
    "includes": [
      "#include <linux/prefetch.h>",
      "#include <linux/gfp.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static DECLARE_WAIT_QUEUE_HEAD(wq);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wake_up",
          "args": [
            "&wq"
          ],
          "line": 73
        },
        "resolved": true,
        "details": {
          "function_name": "locks_wake_up_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "656-681",
          "snippet": "static void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(blocked_lock_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic DEFINE_SPINLOCK(blocked_lock_lock);\n\nstatic void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_dec_and_test",
          "args": [
            "&super->s_pending_writes"
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bio_put",
          "args": [
            "bio"
          ],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "bvec->bv_page"
          ],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "end_page_writeback",
          "args": [
            "bvec->bv_page"
          ],
          "line": 68
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_end_page_writeback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
          "lines": "279-290",
          "snippet": "static void nfs_end_page_writeback(struct nfs_page *req)\n{\n\tstruct inode *inode = page_file_mapping(req->wb_page)->host;\n\tstruct nfs_server *nfss = NFS_SERVER(inode);\n\n\tif (!nfs_page_group_sync_on_bit(req, PG_WB_END))\n\t\treturn;\n\n\tend_page_writeback(req->wb_page);\n\tif (atomic_long_dec_return(&nfss->writeback) < NFS_CONGESTION_OFF_THRESH)\n\t\tclear_bdi_congested(&nfss->backing_dev_info, BLK_RW_ASYNC);\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define NFS_CONGESTION_OFF_THRESH\t\\\n\t(NFS_CONGESTION_ON_THRESH - (NFS_CONGESTION_ON_THRESH >> 2))"
          ],
          "globals_used": [
            "static void nfs_redirty_request(struct nfs_page *req);",
            "static void nfs_clear_request_commit(struct nfs_page *req);",
            "static void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\n#define NFS_CONGESTION_OFF_THRESH\t\\\n\t(NFS_CONGESTION_ON_THRESH - (NFS_CONGESTION_ON_THRESH >> 2))\n\nstatic void nfs_redirty_request(struct nfs_page *req);\nstatic void nfs_clear_request_commit(struct nfs_page *req);\nstatic void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);\n\nstatic void nfs_end_page_writeback(struct nfs_page *req)\n{\n\tstruct inode *inode = page_file_mapping(req->wb_page)->host;\n\tstruct nfs_server *nfss = NFS_SERVER(inode);\n\n\tif (!nfs_page_group_sync_on_bit(req, PG_WB_END))\n\t\treturn;\n\n\tend_page_writeback(req->wb_page);\n\tif (atomic_long_dec_return(&nfss->writeback) < NFS_CONGESTION_OFF_THRESH)\n\t\tclear_bdi_congested(&nfss->backing_dev_info, BLK_RW_ASYNC);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bio_for_each_segment_all",
          "args": [
            "bvec",
            "bio",
            "i"
          ],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "err"
          ],
          "line": 65
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!uptodate"
          ],
          "line": 64
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logfs_super",
          "args": [
            "sb"
          ],
          "line": 62
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/logfs.h",
          "lines": "628-631",
          "snippet": "static inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"logfs_abi.h\"",
            "#include <linux/mtd/mtd.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/btree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"logfs_abi.h\"\n#include <linux/mtd/mtd.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/crc32.h>\n#include <linux/btree.h>\n\nstatic inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "BIO_UPTODATE",
            "&bio->bi_flags"
          ],
          "line": 58
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/prefetch.h>\n#include <linux/gfp.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"logfs.h\"\n\nstatic DECLARE_WAIT_QUEUE_HEAD(wq);\n\nstatic void writeseg_end_io(struct bio *bio, int err)\n{\n\tconst int uptodate = test_bit(BIO_UPTODATE, &bio->bi_flags);\n\tstruct bio_vec *bvec;\n\tint i;\n\tstruct super_block *sb = bio->bi_private;\n\tstruct logfs_super *super = logfs_super(sb);\n\n\tBUG_ON(!uptodate); /* FIXME: Retry io or write elsewhere */\n\tBUG_ON(err);\n\n\tbio_for_each_segment_all(bvec, bio, i) {\n\t\tend_page_writeback(bvec->bv_page);\n\t\tpage_cache_release(bvec->bv_page);\n\t}\n\tbio_put(bio);\n\tif (atomic_dec_and_test(&super->s_pending_writes))\n\t\twake_up(&wq);\n}"
  },
  {
    "function_name": "bdev_readpage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/dev_bdev.c",
    "lines": "36-52",
    "snippet": "static int bdev_readpage(void *_sb, struct page *page)\n{\n\tstruct super_block *sb = _sb;\n\tstruct block_device *bdev = logfs_super(sb)->s_bdev;\n\tint err;\n\n\terr = sync_request(page, bdev, READ);\n\tif (err) {\n\t\tClearPageUptodate(page);\n\t\tSetPageError(page);\n\t} else {\n\t\tSetPageUptodate(page);\n\t\tClearPageError(page);\n\t}\n\tunlock_page(page);\n\treturn err;\n}",
    "includes": [
      "#include <linux/prefetch.h>",
      "#include <linux/gfp.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 50
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ClearPageError",
          "args": [
            "page"
          ],
          "line": 48
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetPageUptodate",
          "args": [
            "page"
          ],
          "line": 47
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetPageError",
          "args": [
            "page"
          ],
          "line": 45
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ClearPageUptodate",
          "args": [
            "page"
          ],
          "line": 44
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sync_request",
          "args": [
            "page",
            "bdev",
            "READ"
          ],
          "line": 42
        },
        "resolved": true,
        "details": {
          "function_name": "sync_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/dev_bdev.c",
          "lines": "17-34",
          "snippet": "static int sync_request(struct page *page, struct block_device *bdev, int rw)\n{\n\tstruct bio bio;\n\tstruct bio_vec bio_vec;\n\n\tbio_init(&bio);\n\tbio.bi_max_vecs = 1;\n\tbio.bi_io_vec = &bio_vec;\n\tbio_vec.bv_page = page;\n\tbio_vec.bv_len = PAGE_SIZE;\n\tbio_vec.bv_offset = 0;\n\tbio.bi_vcnt = 1;\n\tbio.bi_bdev = bdev;\n\tbio.bi_iter.bi_sector = page->index * (PAGE_SIZE >> 9);\n\tbio.bi_iter.bi_size = PAGE_SIZE;\n\n\treturn submit_bio_wait(rw, &bio);\n}",
          "includes": [
            "#include <linux/prefetch.h>",
            "#include <linux/gfp.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/prefetch.h>\n#include <linux/gfp.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"logfs.h\"\n\nstatic int sync_request(struct page *page, struct block_device *bdev, int rw)\n{\n\tstruct bio bio;\n\tstruct bio_vec bio_vec;\n\n\tbio_init(&bio);\n\tbio.bi_max_vecs = 1;\n\tbio.bi_io_vec = &bio_vec;\n\tbio_vec.bv_page = page;\n\tbio_vec.bv_len = PAGE_SIZE;\n\tbio_vec.bv_offset = 0;\n\tbio.bi_vcnt = 1;\n\tbio.bi_bdev = bdev;\n\tbio.bi_iter.bi_sector = page->index * (PAGE_SIZE >> 9);\n\tbio.bi_iter.bi_size = PAGE_SIZE;\n\n\treturn submit_bio_wait(rw, &bio);\n}"
        }
      },
      {
        "call_info": {
          "callee": "logfs_super",
          "args": [
            "sb"
          ],
          "line": 39
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/logfs.h",
          "lines": "628-631",
          "snippet": "static inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"logfs_abi.h\"",
            "#include <linux/mtd/mtd.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/btree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"logfs_abi.h\"\n#include <linux/mtd/mtd.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/crc32.h>\n#include <linux/btree.h>\n\nstatic inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/prefetch.h>\n#include <linux/gfp.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"logfs.h\"\n\nstatic int bdev_readpage(void *_sb, struct page *page)\n{\n\tstruct super_block *sb = _sb;\n\tstruct block_device *bdev = logfs_super(sb)->s_bdev;\n\tint err;\n\n\terr = sync_request(page, bdev, READ);\n\tif (err) {\n\t\tClearPageUptodate(page);\n\t\tSetPageError(page);\n\t} else {\n\t\tSetPageUptodate(page);\n\t\tClearPageError(page);\n\t}\n\tunlock_page(page);\n\treturn err;\n}"
  },
  {
    "function_name": "sync_request",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/dev_bdev.c",
    "lines": "17-34",
    "snippet": "static int sync_request(struct page *page, struct block_device *bdev, int rw)\n{\n\tstruct bio bio;\n\tstruct bio_vec bio_vec;\n\n\tbio_init(&bio);\n\tbio.bi_max_vecs = 1;\n\tbio.bi_io_vec = &bio_vec;\n\tbio_vec.bv_page = page;\n\tbio_vec.bv_len = PAGE_SIZE;\n\tbio_vec.bv_offset = 0;\n\tbio.bi_vcnt = 1;\n\tbio.bi_bdev = bdev;\n\tbio.bi_iter.bi_sector = page->index * (PAGE_SIZE >> 9);\n\tbio.bi_iter.bi_size = PAGE_SIZE;\n\n\treturn submit_bio_wait(rw, &bio);\n}",
    "includes": [
      "#include <linux/prefetch.h>",
      "#include <linux/gfp.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "submit_bio_wait",
          "args": [
            "rw",
            "&bio"
          ],
          "line": 33
        },
        "resolved": true,
        "details": {
          "function_name": "btrfsic_submit_bio_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/check-integrity.c",
          "lines": "3067-3071",
          "snippet": "int btrfsic_submit_bio_wait(int rw, struct bio *bio)\n{\n\t__btrfsic_submit_bio(rw, bio);\n\treturn submit_bio_wait(rw, bio);\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"extent_io.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/genhd.h>",
            "#include <linux/mutex.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"extent_io.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n#include <linux/blkdev.h>\n#include <linux/genhd.h>\n#include <linux/mutex.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nint btrfsic_submit_bio_wait(int rw, struct bio *bio)\n{\n\t__btrfsic_submit_bio(rw, bio);\n\treturn submit_bio_wait(rw, bio);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bio_init",
          "args": [
            "&bio"
          ],
          "line": 22
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/prefetch.h>\n#include <linux/gfp.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"logfs.h\"\n\nstatic int sync_request(struct page *page, struct block_device *bdev, int rw)\n{\n\tstruct bio bio;\n\tstruct bio_vec bio_vec;\n\n\tbio_init(&bio);\n\tbio.bi_max_vecs = 1;\n\tbio.bi_io_vec = &bio_vec;\n\tbio_vec.bv_page = page;\n\tbio_vec.bv_len = PAGE_SIZE;\n\tbio_vec.bv_offset = 0;\n\tbio.bi_vcnt = 1;\n\tbio.bi_bdev = bdev;\n\tbio.bi_iter.bi_sector = page->index * (PAGE_SIZE >> 9);\n\tbio.bi_iter.bi_size = PAGE_SIZE;\n\n\treturn submit_bio_wait(rw, &bio);\n}"
  }
]