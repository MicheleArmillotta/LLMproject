[
  {
    "function_name": "recover_fsync_data",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/recovery.c",
    "lines": "495-563",
    "snippet": "int recover_fsync_data(struct f2fs_sb_info *sbi)\n{\n\tstruct curseg_info *curseg = CURSEG_I(sbi, CURSEG_WARM_NODE);\n\tstruct list_head inode_list;\n\tblock_t blkaddr;\n\tint err;\n\tbool need_writecp = false;\n\n\tfsync_entry_slab = f2fs_kmem_cache_create(\"f2fs_fsync_inode_entry\",\n\t\t\tsizeof(struct fsync_inode_entry));\n\tif (!fsync_entry_slab)\n\t\treturn -ENOMEM;\n\n\tINIT_LIST_HEAD(&inode_list);\n\n\t/* step #1: find fsynced inode numbers */\n\tset_sbi_flag(sbi, SBI_POR_DOING);\n\n\t/* prevent checkpoint */\n\tmutex_lock(&sbi->cp_mutex);\n\n\tblkaddr = NEXT_FREE_BLKADDR(sbi, curseg);\n\n\terr = find_fsync_dnodes(sbi, &inode_list);\n\tif (err)\n\t\tgoto out;\n\n\tif (list_empty(&inode_list))\n\t\tgoto out;\n\n\tneed_writecp = true;\n\n\t/* step #2: recover data */\n\terr = recover_data(sbi, &inode_list, CURSEG_WARM_NODE);\n\tif (!err)\n\t\tf2fs_bug_on(sbi, !list_empty(&inode_list));\nout:\n\tdestroy_fsync_dnodes(&inode_list);\n\tkmem_cache_destroy(fsync_entry_slab);\n\n\t/* truncate meta pages to be used by the recovery */\n\ttruncate_inode_pages_range(META_MAPPING(sbi),\n\t\t\tMAIN_BLKADDR(sbi) << PAGE_CACHE_SHIFT, -1);\n\n\tif (err) {\n\t\ttruncate_inode_pages_final(NODE_MAPPING(sbi));\n\t\ttruncate_inode_pages_final(META_MAPPING(sbi));\n\t}\n\n\tclear_sbi_flag(sbi, SBI_POR_DOING);\n\tif (err) {\n\t\tdiscard_next_dnode(sbi, blkaddr);\n\n\t\t/* Flush all the NAT/SIT pages */\n\t\twhile (get_pages(sbi, F2FS_DIRTY_META))\n\t\t\tsync_meta_pages(sbi, META, LONG_MAX);\n\t\tset_ckpt_flags(sbi->ckpt, CP_ERROR_FLAG);\n\t\tmutex_unlock(&sbi->cp_mutex);\n\t} else if (need_writecp) {\n\t\tstruct cp_control cpc = {\n\t\t\t.reason = CP_SYNC,\n\t\t};\n\t\tmutex_unlock(&sbi->cp_mutex);\n\t\twrite_checkpoint(sbi, &cpc);\n\t} else {\n\t\tmutex_unlock(&sbi->cp_mutex);\n\t}\n\treturn err;\n}",
    "includes": [
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *fsync_entry_slab;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&sbi->cp_mutex"
          ],
          "line": 560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_checkpoint",
          "args": [
            "sbi",
            "&cpc"
          ],
          "line": 558
        },
        "resolved": true,
        "details": {
          "function_name": "write_checkpoint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/checkpoint.c",
          "lines": "1046-1091",
          "snippet": "void write_checkpoint(struct f2fs_sb_info *sbi, struct cp_control *cpc)\n{\n\tstruct f2fs_checkpoint *ckpt = F2FS_CKPT(sbi);\n\tunsigned long long ckpt_ver;\n\n\ttrace_f2fs_write_checkpoint(sbi->sb, cpc->reason, \"start block_ops\");\n\n\tmutex_lock(&sbi->cp_mutex);\n\n\tif (!is_sbi_flag_set(sbi, SBI_IS_DIRTY) &&\n\t\t\tcpc->reason != CP_DISCARD && cpc->reason != CP_UMOUNT)\n\t\tgoto out;\n\tif (unlikely(f2fs_cp_error(sbi)))\n\t\tgoto out;\n\tif (f2fs_readonly(sbi->sb))\n\t\tgoto out;\n\tif (block_operations(sbi))\n\t\tgoto out;\n\n\ttrace_f2fs_write_checkpoint(sbi->sb, cpc->reason, \"finish block_ops\");\n\n\tf2fs_submit_merged_bio(sbi, DATA, WRITE);\n\tf2fs_submit_merged_bio(sbi, NODE, WRITE);\n\tf2fs_submit_merged_bio(sbi, META, WRITE);\n\n\t/*\n\t * update checkpoint pack index\n\t * Increase the version number so that\n\t * SIT entries and seg summaries are written at correct place\n\t */\n\tckpt_ver = cur_cp_version(ckpt);\n\tckpt->checkpoint_ver = cpu_to_le64(++ckpt_ver);\n\n\t/* write cached NAT/SIT entries to NAT/SIT area */\n\tflush_nat_entries(sbi);\n\tflush_sit_entries(sbi, cpc);\n\n\t/* unlock all the fs_lock[] in do_checkpoint() */\n\tdo_checkpoint(sbi, cpc);\n\n\tunblock_operations(sbi);\n\tstat_inc_cp_count(sbi->stat_info);\nout:\n\tmutex_unlock(&sbi->cp_mutex);\n\ttrace_f2fs_write_checkpoint(sbi->sb, cpc->reason, \"finish checkpoint\");\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/f2fs_fs.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n\nvoid write_checkpoint(struct f2fs_sb_info *sbi, struct cp_control *cpc)\n{\n\tstruct f2fs_checkpoint *ckpt = F2FS_CKPT(sbi);\n\tunsigned long long ckpt_ver;\n\n\ttrace_f2fs_write_checkpoint(sbi->sb, cpc->reason, \"start block_ops\");\n\n\tmutex_lock(&sbi->cp_mutex);\n\n\tif (!is_sbi_flag_set(sbi, SBI_IS_DIRTY) &&\n\t\t\tcpc->reason != CP_DISCARD && cpc->reason != CP_UMOUNT)\n\t\tgoto out;\n\tif (unlikely(f2fs_cp_error(sbi)))\n\t\tgoto out;\n\tif (f2fs_readonly(sbi->sb))\n\t\tgoto out;\n\tif (block_operations(sbi))\n\t\tgoto out;\n\n\ttrace_f2fs_write_checkpoint(sbi->sb, cpc->reason, \"finish block_ops\");\n\n\tf2fs_submit_merged_bio(sbi, DATA, WRITE);\n\tf2fs_submit_merged_bio(sbi, NODE, WRITE);\n\tf2fs_submit_merged_bio(sbi, META, WRITE);\n\n\t/*\n\t * update checkpoint pack index\n\t * Increase the version number so that\n\t * SIT entries and seg summaries are written at correct place\n\t */\n\tckpt_ver = cur_cp_version(ckpt);\n\tckpt->checkpoint_ver = cpu_to_le64(++ckpt_ver);\n\n\t/* write cached NAT/SIT entries to NAT/SIT area */\n\tflush_nat_entries(sbi);\n\tflush_sit_entries(sbi, cpc);\n\n\t/* unlock all the fs_lock[] in do_checkpoint() */\n\tdo_checkpoint(sbi, cpc);\n\n\tunblock_operations(sbi);\n\tstat_inc_cp_count(sbi->stat_info);\nout:\n\tmutex_unlock(&sbi->cp_mutex);\n\ttrace_f2fs_write_checkpoint(sbi->sb, cpc->reason, \"finish checkpoint\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&sbi->cp_mutex"
          ],
          "line": 557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&sbi->cp_mutex"
          ],
          "line": 552
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_ckpt_flags",
          "args": [
            "sbi->ckpt",
            "CP_ERROR_FLAG"
          ],
          "line": 551
        },
        "resolved": true,
        "details": {
          "function_name": "set_ckpt_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "741-746",
          "snippet": "static inline void set_ckpt_flags(struct f2fs_checkpoint *cp, unsigned int f)\n{\n\tunsigned int ckpt_flags = le32_to_cpu(cp->ckpt_flags);\n\tckpt_flags |= f;\n\tcp->ckpt_flags = cpu_to_le32(ckpt_flags);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void set_ckpt_flags(struct f2fs_checkpoint *cp, unsigned int f)\n{\n\tunsigned int ckpt_flags = le32_to_cpu(cp->ckpt_flags);\n\tckpt_flags |= f;\n\tcp->ckpt_flags = cpu_to_le32(ckpt_flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sync_meta_pages",
          "args": [
            "sbi",
            "META",
            "LONG_MAX"
          ],
          "line": 550
        },
        "resolved": true,
        "details": {
          "function_name": "sync_meta_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/checkpoint.c",
          "lines": "240-295",
          "snippet": "long sync_meta_pages(struct f2fs_sb_info *sbi, enum page_type type,\n\t\t\t\t\t\tlong nr_to_write)\n{\n\tstruct address_space *mapping = META_MAPPING(sbi);\n\tpgoff_t index = 0, end = LONG_MAX;\n\tstruct pagevec pvec;\n\tlong nwritten = 0;\n\tstruct writeback_control wbc = {\n\t\t.for_reclaim = 0,\n\t};\n\n\tpagevec_init(&pvec, 0);\n\n\twhile (index <= end) {\n\t\tint i, nr_pages;\n\t\tnr_pages = pagevec_lookup_tag(&pvec, mapping, &index,\n\t\t\t\tPAGECACHE_TAG_DIRTY,\n\t\t\t\tmin(end - index, (pgoff_t)PAGEVEC_SIZE-1) + 1);\n\t\tif (unlikely(nr_pages == 0))\n\t\t\tbreak;\n\n\t\tfor (i = 0; i < nr_pages; i++) {\n\t\t\tstruct page *page = pvec.pages[i];\n\n\t\t\tlock_page(page);\n\n\t\t\tif (unlikely(page->mapping != mapping)) {\ncontinue_unlock:\n\t\t\t\tunlock_page(page);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!PageDirty(page)) {\n\t\t\t\t/* someone wrote it for us */\n\t\t\t\tgoto continue_unlock;\n\t\t\t}\n\n\t\t\tif (!clear_page_dirty_for_io(page))\n\t\t\t\tgoto continue_unlock;\n\n\t\t\tif (f2fs_write_meta_page(page, &wbc)) {\n\t\t\t\tunlock_page(page);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tnwritten++;\n\t\t\tif (unlikely(nwritten >= nr_to_write))\n\t\t\t\tbreak;\n\t\t}\n\t\tpagevec_release(&pvec);\n\t\tcond_resched();\n\t}\n\n\tif (nwritten)\n\t\tf2fs_submit_merged_bio(sbi, type, WRITE);\n\n\treturn nwritten;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/f2fs_fs.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n\nlong sync_meta_pages(struct f2fs_sb_info *sbi, enum page_type type,\n\t\t\t\t\t\tlong nr_to_write)\n{\n\tstruct address_space *mapping = META_MAPPING(sbi);\n\tpgoff_t index = 0, end = LONG_MAX;\n\tstruct pagevec pvec;\n\tlong nwritten = 0;\n\tstruct writeback_control wbc = {\n\t\t.for_reclaim = 0,\n\t};\n\n\tpagevec_init(&pvec, 0);\n\n\twhile (index <= end) {\n\t\tint i, nr_pages;\n\t\tnr_pages = pagevec_lookup_tag(&pvec, mapping, &index,\n\t\t\t\tPAGECACHE_TAG_DIRTY,\n\t\t\t\tmin(end - index, (pgoff_t)PAGEVEC_SIZE-1) + 1);\n\t\tif (unlikely(nr_pages == 0))\n\t\t\tbreak;\n\n\t\tfor (i = 0; i < nr_pages; i++) {\n\t\t\tstruct page *page = pvec.pages[i];\n\n\t\t\tlock_page(page);\n\n\t\t\tif (unlikely(page->mapping != mapping)) {\ncontinue_unlock:\n\t\t\t\tunlock_page(page);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!PageDirty(page)) {\n\t\t\t\t/* someone wrote it for us */\n\t\t\t\tgoto continue_unlock;\n\t\t\t}\n\n\t\t\tif (!clear_page_dirty_for_io(page))\n\t\t\t\tgoto continue_unlock;\n\n\t\t\tif (f2fs_write_meta_page(page, &wbc)) {\n\t\t\t\tunlock_page(page);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tnwritten++;\n\t\t\tif (unlikely(nwritten >= nr_to_write))\n\t\t\t\tbreak;\n\t\t}\n\t\tpagevec_release(&pvec);\n\t\tcond_resched();\n\t}\n\n\tif (nwritten)\n\t\tf2fs_submit_merged_bio(sbi, type, WRITE);\n\n\treturn nwritten;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_pages",
          "args": [
            "sbi",
            "F2FS_DIRTY_META"
          ],
          "line": 549
        },
        "resolved": true,
        "details": {
          "function_name": "get_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "887-890",
          "snippet": "static inline int get_pages(struct f2fs_sb_info *sbi, int count_type)\n{\n\treturn atomic_read(&sbi->nr_pages[count_type]);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int get_pages(struct f2fs_sb_info *sbi, int count_type)\n{\n\treturn atomic_read(&sbi->nr_pages[count_type]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "discard_next_dnode",
          "args": [
            "sbi",
            "blkaddr"
          ],
          "line": 546
        },
        "resolved": true,
        "details": {
          "function_name": "discard_next_dnode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
          "lines": "466-474",
          "snippet": "void discard_next_dnode(struct f2fs_sb_info *sbi, block_t blkaddr)\n{\n\tif (f2fs_issue_discard(sbi, blkaddr, 1)) {\n\t\tstruct page *page = grab_meta_page(sbi, blkaddr);\n\t\t/* zero-filled page */\n\t\tset_page_dirty(page);\n\t\tf2fs_put_page(page, 1);\n\t}\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"node.h\"",
            "#include \"segment.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kthread.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nvoid discard_next_dnode(struct f2fs_sb_info *sbi, block_t blkaddr)\n{\n\tif (f2fs_issue_discard(sbi, blkaddr, 1)) {\n\t\tstruct page *page = grab_meta_page(sbi, blkaddr);\n\t\t/* zero-filled page */\n\t\tset_page_dirty(page);\n\t\tf2fs_put_page(page, 1);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_sbi_flag",
          "args": [
            "sbi",
            "SBI_POR_DOING"
          ],
          "line": 544
        },
        "resolved": true,
        "details": {
          "function_name": "clear_sbi_flag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "725-728",
          "snippet": "static inline void clear_sbi_flag(struct f2fs_sb_info *sbi, unsigned int type)\n{\n\tsbi->s_flag &= ~(0x01 << type);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void clear_sbi_flag(struct f2fs_sb_info *sbi, unsigned int type)\n{\n\tsbi->s_flag &= ~(0x01 << type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "truncate_inode_pages_final",
          "args": [
            "META_MAPPING(sbi)"
          ],
          "line": 541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "META_MAPPING",
          "args": [
            "sbi"
          ],
          "line": 541
        },
        "resolved": true,
        "details": {
          "function_name": "META_MAPPING",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "705-708",
          "snippet": "static inline struct address_space *META_MAPPING(struct f2fs_sb_info *sbi)\n{\n\treturn sbi->meta_inode->i_mapping;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct address_space *META_MAPPING(struct f2fs_sb_info *sbi)\n{\n\treturn sbi->meta_inode->i_mapping;\n}"
        }
      },
      {
        "call_info": {
          "callee": "truncate_inode_pages_final",
          "args": [
            "NODE_MAPPING(sbi)"
          ],
          "line": 540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NODE_MAPPING",
          "args": [
            "sbi"
          ],
          "line": 540
        },
        "resolved": true,
        "details": {
          "function_name": "NODE_MAPPING",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "710-713",
          "snippet": "static inline struct address_space *NODE_MAPPING(struct f2fs_sb_info *sbi)\n{\n\treturn sbi->node_inode->i_mapping;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct address_space *NODE_MAPPING(struct f2fs_sb_info *sbi)\n{\n\treturn sbi->node_inode->i_mapping;\n}"
        }
      },
      {
        "call_info": {
          "callee": "truncate_inode_pages_range",
          "args": [
            "META_MAPPING(sbi)",
            "MAIN_BLKADDR(sbi) << PAGE_CACHE_SHIFT",
            "-1"
          ],
          "line": 536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAIN_BLKADDR",
          "args": [
            "sbi"
          ],
          "line": 537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_destroy",
          "args": [
            "fsync_entry_slab"
          ],
          "line": 533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "destroy_fsync_dnodes",
          "args": [
            "&inode_list"
          ],
          "line": 532
        },
        "resolved": true,
        "details": {
          "function_name": "destroy_fsync_dnodes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/recovery.c",
          "lines": "239-248",
          "snippet": "static void destroy_fsync_dnodes(struct list_head *head)\n{\n\tstruct fsync_inode_entry *entry, *tmp;\n\n\tlist_for_each_entry_safe(entry, tmp, head, list) {\n\t\tiput(entry->inode);\n\t\tlist_del(&entry->list);\n\t\tkmem_cache_free(fsync_entry_slab, entry);\n\t}\n}",
          "includes": [
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *fsync_entry_slab;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic struct kmem_cache *fsync_entry_slab;\n\nstatic void destroy_fsync_dnodes(struct list_head *head)\n{\n\tstruct fsync_inode_entry *entry, *tmp;\n\n\tlist_for_each_entry_safe(entry, tmp, head, list) {\n\t\tiput(entry->inode);\n\t\tlist_del(&entry->list);\n\t\tkmem_cache_free(fsync_entry_slab, entry);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_bug_on",
          "args": [
            "sbi",
            "!list_empty(&inode_list)"
          ],
          "line": 530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&inode_list"
          ],
          "line": 530
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "recover_data",
          "args": [
            "sbi",
            "&inode_list",
            "CURSEG_WARM_NODE"
          ],
          "line": 528
        },
        "resolved": true,
        "details": {
          "function_name": "recover_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/recovery.c",
          "lines": "429-493",
          "snippet": "static int recover_data(struct f2fs_sb_info *sbi,\n\t\t\t\tstruct list_head *head, int type)\n{\n\tunsigned long long cp_ver = cur_cp_version(F2FS_CKPT(sbi));\n\tstruct curseg_info *curseg;\n\tstruct page *page = NULL;\n\tint err = 0;\n\tblock_t blkaddr;\n\n\t/* get node pages in the current segment */\n\tcurseg = CURSEG_I(sbi, type);\n\tblkaddr = NEXT_FREE_BLKADDR(sbi, curseg);\n\n\twhile (1) {\n\t\tstruct fsync_inode_entry *entry;\n\n\t\tif (blkaddr < MAIN_BLKADDR(sbi) || blkaddr >= MAX_BLKADDR(sbi))\n\t\t\tbreak;\n\n\t\tra_meta_pages_cond(sbi, blkaddr);\n\n\t\tpage = get_meta_page(sbi, blkaddr);\n\n\t\tif (cp_ver != cpver_of_node(page)) {\n\t\t\tf2fs_put_page(page, 1);\n\t\t\tbreak;\n\t\t}\n\n\t\tentry = get_fsync_inode(head, ino_of_node(page));\n\t\tif (!entry)\n\t\t\tgoto next;\n\t\t/*\n\t\t * inode(x) | CP | inode(x) | dnode(F)\n\t\t * In this case, we can lose the latest inode(x).\n\t\t * So, call recover_inode for the inode update.\n\t\t */\n\t\tif (entry->last_inode == blkaddr)\n\t\t\trecover_inode(entry->inode, page);\n\t\tif (entry->last_dentry == blkaddr) {\n\t\t\terr = recover_dentry(entry->inode, page);\n\t\t\tif (err) {\n\t\t\t\tf2fs_put_page(page, 1);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\terr = do_recover_data(sbi, entry->inode, page, blkaddr);\n\t\tif (err) {\n\t\t\tf2fs_put_page(page, 1);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (entry->blkaddr == blkaddr) {\n\t\t\tiput(entry->inode);\n\t\t\tlist_del(&entry->list);\n\t\t\tkmem_cache_free(fsync_entry_slab, entry);\n\t\t}\nnext:\n\t\t/* check next segment */\n\t\tblkaddr = next_blkaddr_of_node(page);\n\t\tf2fs_put_page(page, 1);\n\t}\n\tif (!err)\n\t\tallocate_new_segments(sbi);\n\treturn err;\n}",
          "includes": [
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *fsync_entry_slab;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic struct kmem_cache *fsync_entry_slab;\n\nstatic int recover_data(struct f2fs_sb_info *sbi,\n\t\t\t\tstruct list_head *head, int type)\n{\n\tunsigned long long cp_ver = cur_cp_version(F2FS_CKPT(sbi));\n\tstruct curseg_info *curseg;\n\tstruct page *page = NULL;\n\tint err = 0;\n\tblock_t blkaddr;\n\n\t/* get node pages in the current segment */\n\tcurseg = CURSEG_I(sbi, type);\n\tblkaddr = NEXT_FREE_BLKADDR(sbi, curseg);\n\n\twhile (1) {\n\t\tstruct fsync_inode_entry *entry;\n\n\t\tif (blkaddr < MAIN_BLKADDR(sbi) || blkaddr >= MAX_BLKADDR(sbi))\n\t\t\tbreak;\n\n\t\tra_meta_pages_cond(sbi, blkaddr);\n\n\t\tpage = get_meta_page(sbi, blkaddr);\n\n\t\tif (cp_ver != cpver_of_node(page)) {\n\t\t\tf2fs_put_page(page, 1);\n\t\t\tbreak;\n\t\t}\n\n\t\tentry = get_fsync_inode(head, ino_of_node(page));\n\t\tif (!entry)\n\t\t\tgoto next;\n\t\t/*\n\t\t * inode(x) | CP | inode(x) | dnode(F)\n\t\t * In this case, we can lose the latest inode(x).\n\t\t * So, call recover_inode for the inode update.\n\t\t */\n\t\tif (entry->last_inode == blkaddr)\n\t\t\trecover_inode(entry->inode, page);\n\t\tif (entry->last_dentry == blkaddr) {\n\t\t\terr = recover_dentry(entry->inode, page);\n\t\t\tif (err) {\n\t\t\t\tf2fs_put_page(page, 1);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\terr = do_recover_data(sbi, entry->inode, page, blkaddr);\n\t\tif (err) {\n\t\t\tf2fs_put_page(page, 1);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (entry->blkaddr == blkaddr) {\n\t\t\tiput(entry->inode);\n\t\t\tlist_del(&entry->list);\n\t\t\tkmem_cache_free(fsync_entry_slab, entry);\n\t\t}\nnext:\n\t\t/* check next segment */\n\t\tblkaddr = next_blkaddr_of_node(page);\n\t\tf2fs_put_page(page, 1);\n\t}\n\tif (!err)\n\t\tallocate_new_segments(sbi);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_fsync_dnodes",
          "args": [
            "sbi",
            "&inode_list"
          ],
          "line": 518
        },
        "resolved": true,
        "details": {
          "function_name": "find_fsync_dnodes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/recovery.c",
          "lines": "161-237",
          "snippet": "static int find_fsync_dnodes(struct f2fs_sb_info *sbi, struct list_head *head)\n{\n\tunsigned long long cp_ver = cur_cp_version(F2FS_CKPT(sbi));\n\tstruct curseg_info *curseg;\n\tstruct page *page = NULL;\n\tblock_t blkaddr;\n\tint err = 0;\n\n\t/* get node pages in the current segment */\n\tcurseg = CURSEG_I(sbi, CURSEG_WARM_NODE);\n\tblkaddr = NEXT_FREE_BLKADDR(sbi, curseg);\n\n\tra_meta_pages(sbi, blkaddr, 1, META_POR);\n\n\twhile (1) {\n\t\tstruct fsync_inode_entry *entry;\n\n\t\tif (blkaddr < MAIN_BLKADDR(sbi) || blkaddr >= MAX_BLKADDR(sbi))\n\t\t\treturn 0;\n\n\t\tpage = get_meta_page(sbi, blkaddr);\n\n\t\tif (cp_ver != cpver_of_node(page))\n\t\t\tbreak;\n\n\t\tif (!is_fsync_dnode(page))\n\t\t\tgoto next;\n\n\t\tentry = get_fsync_inode(head, ino_of_node(page));\n\t\tif (entry) {\n\t\t\tif (IS_INODE(page) && is_dent_dnode(page))\n\t\t\t\tset_inode_flag(F2FS_I(entry->inode),\n\t\t\t\t\t\t\tFI_INC_LINK);\n\t\t} else {\n\t\t\tif (IS_INODE(page) && is_dent_dnode(page)) {\n\t\t\t\terr = recover_inode_page(sbi, page);\n\t\t\t\tif (err)\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* add this fsync inode to the list */\n\t\t\tentry = kmem_cache_alloc(fsync_entry_slab, GFP_F2FS_ZERO);\n\t\t\tif (!entry) {\n\t\t\t\terr = -ENOMEM;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/*\n\t\t\t * CP | dnode(F) | inode(DF)\n\t\t\t * For this case, we should not give up now.\n\t\t\t */\n\t\t\tentry->inode = f2fs_iget(sbi->sb, ino_of_node(page));\n\t\t\tif (IS_ERR(entry->inode)) {\n\t\t\t\terr = PTR_ERR(entry->inode);\n\t\t\t\tkmem_cache_free(fsync_entry_slab, entry);\n\t\t\t\tif (err == -ENOENT)\n\t\t\t\t\tgoto next;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tlist_add_tail(&entry->list, head);\n\t\t}\n\t\tentry->blkaddr = blkaddr;\n\n\t\tif (IS_INODE(page)) {\n\t\t\tentry->last_inode = blkaddr;\n\t\t\tif (is_dent_dnode(page))\n\t\t\t\tentry->last_dentry = blkaddr;\n\t\t}\nnext:\n\t\t/* check next segment */\n\t\tblkaddr = next_blkaddr_of_node(page);\n\t\tf2fs_put_page(page, 1);\n\n\t\tra_meta_pages_cond(sbi, blkaddr);\n\t}\n\tf2fs_put_page(page, 1);\n\treturn err;\n}",
          "includes": [
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *fsync_entry_slab;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic struct kmem_cache *fsync_entry_slab;\n\nstatic int find_fsync_dnodes(struct f2fs_sb_info *sbi, struct list_head *head)\n{\n\tunsigned long long cp_ver = cur_cp_version(F2FS_CKPT(sbi));\n\tstruct curseg_info *curseg;\n\tstruct page *page = NULL;\n\tblock_t blkaddr;\n\tint err = 0;\n\n\t/* get node pages in the current segment */\n\tcurseg = CURSEG_I(sbi, CURSEG_WARM_NODE);\n\tblkaddr = NEXT_FREE_BLKADDR(sbi, curseg);\n\n\tra_meta_pages(sbi, blkaddr, 1, META_POR);\n\n\twhile (1) {\n\t\tstruct fsync_inode_entry *entry;\n\n\t\tif (blkaddr < MAIN_BLKADDR(sbi) || blkaddr >= MAX_BLKADDR(sbi))\n\t\t\treturn 0;\n\n\t\tpage = get_meta_page(sbi, blkaddr);\n\n\t\tif (cp_ver != cpver_of_node(page))\n\t\t\tbreak;\n\n\t\tif (!is_fsync_dnode(page))\n\t\t\tgoto next;\n\n\t\tentry = get_fsync_inode(head, ino_of_node(page));\n\t\tif (entry) {\n\t\t\tif (IS_INODE(page) && is_dent_dnode(page))\n\t\t\t\tset_inode_flag(F2FS_I(entry->inode),\n\t\t\t\t\t\t\tFI_INC_LINK);\n\t\t} else {\n\t\t\tif (IS_INODE(page) && is_dent_dnode(page)) {\n\t\t\t\terr = recover_inode_page(sbi, page);\n\t\t\t\tif (err)\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* add this fsync inode to the list */\n\t\t\tentry = kmem_cache_alloc(fsync_entry_slab, GFP_F2FS_ZERO);\n\t\t\tif (!entry) {\n\t\t\t\terr = -ENOMEM;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/*\n\t\t\t * CP | dnode(F) | inode(DF)\n\t\t\t * For this case, we should not give up now.\n\t\t\t */\n\t\t\tentry->inode = f2fs_iget(sbi->sb, ino_of_node(page));\n\t\t\tif (IS_ERR(entry->inode)) {\n\t\t\t\terr = PTR_ERR(entry->inode);\n\t\t\t\tkmem_cache_free(fsync_entry_slab, entry);\n\t\t\t\tif (err == -ENOENT)\n\t\t\t\t\tgoto next;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tlist_add_tail(&entry->list, head);\n\t\t}\n\t\tentry->blkaddr = blkaddr;\n\n\t\tif (IS_INODE(page)) {\n\t\t\tentry->last_inode = blkaddr;\n\t\t\tif (is_dent_dnode(page))\n\t\t\t\tentry->last_dentry = blkaddr;\n\t\t}\nnext:\n\t\t/* check next segment */\n\t\tblkaddr = next_blkaddr_of_node(page);\n\t\tf2fs_put_page(page, 1);\n\n\t\tra_meta_pages_cond(sbi, blkaddr);\n\t}\n\tf2fs_put_page(page, 1);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NEXT_FREE_BLKADDR",
          "args": [
            "sbi",
            "curseg"
          ],
          "line": 516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&sbi->cp_mutex"
          ],
          "line": 514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_sbi_flag",
          "args": [
            "sbi",
            "SBI_POR_DOING"
          ],
          "line": 511
        },
        "resolved": true,
        "details": {
          "function_name": "set_sbi_flag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "720-723",
          "snippet": "static inline void set_sbi_flag(struct f2fs_sb_info *sbi, unsigned int type)\n{\n\tsbi->s_flag |= (0x01 << type);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void set_sbi_flag(struct f2fs_sb_info *sbi, unsigned int type)\n{\n\tsbi->s_flag |= (0x01 << type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&inode_list"
          ],
          "line": 508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f2fs_kmem_cache_create",
          "args": [
            "\"f2fs_fsync_inode_entry\"",
            "sizeof(struct fsync_inode_entry)"
          ],
          "line": 503
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_kmem_cache_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1058-1062",
          "snippet": "static inline struct kmem_cache *f2fs_kmem_cache_create(const char *name,\n\t\t\t\t\tsize_t size)\n{\n\treturn kmem_cache_create(name, size, 0, SLAB_RECLAIM_ACCOUNT, NULL);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct kmem_cache *f2fs_kmem_cache_create(const char *name,\n\t\t\t\t\tsize_t size)\n{\n\treturn kmem_cache_create(name, size, 0, SLAB_RECLAIM_ACCOUNT, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "CURSEG_I",
          "args": [
            "sbi",
            "CURSEG_WARM_NODE"
          ],
          "line": 497
        },
        "resolved": true,
        "details": {
          "function_name": "CURSEG_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.h",
          "lines": "263-266",
          "snippet": "static inline struct curseg_info *CURSEG_I(struct f2fs_sb_info *sbi, int type)\n{\n\treturn (struct curseg_info *)(SM_I(sbi)->curseg_array + type);\n}",
          "includes": [
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/blkdev.h>\n\nstatic inline struct curseg_info *CURSEG_I(struct f2fs_sb_info *sbi, int type)\n{\n\treturn (struct curseg_info *)(SM_I(sbi)->curseg_array + type);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic struct kmem_cache *fsync_entry_slab;\n\nint recover_fsync_data(struct f2fs_sb_info *sbi)\n{\n\tstruct curseg_info *curseg = CURSEG_I(sbi, CURSEG_WARM_NODE);\n\tstruct list_head inode_list;\n\tblock_t blkaddr;\n\tint err;\n\tbool need_writecp = false;\n\n\tfsync_entry_slab = f2fs_kmem_cache_create(\"f2fs_fsync_inode_entry\",\n\t\t\tsizeof(struct fsync_inode_entry));\n\tif (!fsync_entry_slab)\n\t\treturn -ENOMEM;\n\n\tINIT_LIST_HEAD(&inode_list);\n\n\t/* step #1: find fsynced inode numbers */\n\tset_sbi_flag(sbi, SBI_POR_DOING);\n\n\t/* prevent checkpoint */\n\tmutex_lock(&sbi->cp_mutex);\n\n\tblkaddr = NEXT_FREE_BLKADDR(sbi, curseg);\n\n\terr = find_fsync_dnodes(sbi, &inode_list);\n\tif (err)\n\t\tgoto out;\n\n\tif (list_empty(&inode_list))\n\t\tgoto out;\n\n\tneed_writecp = true;\n\n\t/* step #2: recover data */\n\terr = recover_data(sbi, &inode_list, CURSEG_WARM_NODE);\n\tif (!err)\n\t\tf2fs_bug_on(sbi, !list_empty(&inode_list));\nout:\n\tdestroy_fsync_dnodes(&inode_list);\n\tkmem_cache_destroy(fsync_entry_slab);\n\n\t/* truncate meta pages to be used by the recovery */\n\ttruncate_inode_pages_range(META_MAPPING(sbi),\n\t\t\tMAIN_BLKADDR(sbi) << PAGE_CACHE_SHIFT, -1);\n\n\tif (err) {\n\t\ttruncate_inode_pages_final(NODE_MAPPING(sbi));\n\t\ttruncate_inode_pages_final(META_MAPPING(sbi));\n\t}\n\n\tclear_sbi_flag(sbi, SBI_POR_DOING);\n\tif (err) {\n\t\tdiscard_next_dnode(sbi, blkaddr);\n\n\t\t/* Flush all the NAT/SIT pages */\n\t\twhile (get_pages(sbi, F2FS_DIRTY_META))\n\t\t\tsync_meta_pages(sbi, META, LONG_MAX);\n\t\tset_ckpt_flags(sbi->ckpt, CP_ERROR_FLAG);\n\t\tmutex_unlock(&sbi->cp_mutex);\n\t} else if (need_writecp) {\n\t\tstruct cp_control cpc = {\n\t\t\t.reason = CP_SYNC,\n\t\t};\n\t\tmutex_unlock(&sbi->cp_mutex);\n\t\twrite_checkpoint(sbi, &cpc);\n\t} else {\n\t\tmutex_unlock(&sbi->cp_mutex);\n\t}\n\treturn err;\n}"
  },
  {
    "function_name": "recover_data",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/recovery.c",
    "lines": "429-493",
    "snippet": "static int recover_data(struct f2fs_sb_info *sbi,\n\t\t\t\tstruct list_head *head, int type)\n{\n\tunsigned long long cp_ver = cur_cp_version(F2FS_CKPT(sbi));\n\tstruct curseg_info *curseg;\n\tstruct page *page = NULL;\n\tint err = 0;\n\tblock_t blkaddr;\n\n\t/* get node pages in the current segment */\n\tcurseg = CURSEG_I(sbi, type);\n\tblkaddr = NEXT_FREE_BLKADDR(sbi, curseg);\n\n\twhile (1) {\n\t\tstruct fsync_inode_entry *entry;\n\n\t\tif (blkaddr < MAIN_BLKADDR(sbi) || blkaddr >= MAX_BLKADDR(sbi))\n\t\t\tbreak;\n\n\t\tra_meta_pages_cond(sbi, blkaddr);\n\n\t\tpage = get_meta_page(sbi, blkaddr);\n\n\t\tif (cp_ver != cpver_of_node(page)) {\n\t\t\tf2fs_put_page(page, 1);\n\t\t\tbreak;\n\t\t}\n\n\t\tentry = get_fsync_inode(head, ino_of_node(page));\n\t\tif (!entry)\n\t\t\tgoto next;\n\t\t/*\n\t\t * inode(x) | CP | inode(x) | dnode(F)\n\t\t * In this case, we can lose the latest inode(x).\n\t\t * So, call recover_inode for the inode update.\n\t\t */\n\t\tif (entry->last_inode == blkaddr)\n\t\t\trecover_inode(entry->inode, page);\n\t\tif (entry->last_dentry == blkaddr) {\n\t\t\terr = recover_dentry(entry->inode, page);\n\t\t\tif (err) {\n\t\t\t\tf2fs_put_page(page, 1);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\terr = do_recover_data(sbi, entry->inode, page, blkaddr);\n\t\tif (err) {\n\t\t\tf2fs_put_page(page, 1);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (entry->blkaddr == blkaddr) {\n\t\t\tiput(entry->inode);\n\t\t\tlist_del(&entry->list);\n\t\t\tkmem_cache_free(fsync_entry_slab, entry);\n\t\t}\nnext:\n\t\t/* check next segment */\n\t\tblkaddr = next_blkaddr_of_node(page);\n\t\tf2fs_put_page(page, 1);\n\t}\n\tif (!err)\n\t\tallocate_new_segments(sbi);\n\treturn err;\n}",
    "includes": [
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *fsync_entry_slab;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "allocate_new_segments",
          "args": [
            "sbi"
          ],
          "line": 491
        },
        "resolved": true,
        "details": {
          "function_name": "allocate_new_segments",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
          "lines": "1037-1043",
          "snippet": "void allocate_new_segments(struct f2fs_sb_info *sbi)\n{\n\tint i;\n\n\tfor (i = CURSEG_HOT_DATA; i <= CURSEG_COLD_DATA; i++)\n\t\t__allocate_new_segments(sbi, i);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"node.h\"",
            "#include \"segment.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kthread.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nvoid allocate_new_segments(struct f2fs_sb_info *sbi)\n{\n\tint i;\n\n\tfor (i = CURSEG_HOT_DATA; i <= CURSEG_COLD_DATA; i++)\n\t\t__allocate_new_segments(sbi, i);\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_put_page",
          "args": [
            "page",
            "1"
          ],
          "line": 488
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_put_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1036-1046",
          "snippet": "static inline void f2fs_put_page(struct page *page, int unlock)\n{\n\tif (!page)\n\t\treturn;\n\n\tif (unlock) {\n\t\tf2fs_bug_on(F2FS_P_SB(page), !PageLocked(page));\n\t\tunlock_page(page);\n\t}\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void f2fs_put_page(struct page *page, int unlock)\n{\n\tif (!page)\n\t\treturn;\n\n\tif (unlock) {\n\t\tf2fs_bug_on(F2FS_P_SB(page), !PageLocked(page));\n\t\tunlock_page(page);\n\t}\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "next_blkaddr_of_node",
          "args": [
            "page"
          ],
          "line": 487
        },
        "resolved": true,
        "details": {
          "function_name": "next_blkaddr_of_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.h",
          "lines": "272-276",
          "snippet": "static inline block_t next_blkaddr_of_node(struct page *node_page)\n{\n\tstruct f2fs_node *rn = F2FS_NODE(node_page);\n\treturn le32_to_cpu(rn->footer.next_blkaddr);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline block_t next_blkaddr_of_node(struct page *node_page)\n{\n\tstruct f2fs_node *rn = F2FS_NODE(node_page);\n\treturn le32_to_cpu(rn->footer.next_blkaddr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "fsync_entry_slab",
            "entry"
          ],
          "line": 483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&entry->list"
          ],
          "line": 482
        },
        "resolved": true,
        "details": {
          "function_name": "inode_sb_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "433-440",
          "snippet": "static inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\n__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "entry->inode"
          ],
          "line": 481
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_recover_data",
          "args": [
            "sbi",
            "entry->inode",
            "page",
            "blkaddr"
          ],
          "line": 474
        },
        "resolved": true,
        "details": {
          "function_name": "do_recover_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/recovery.c",
          "lines": "335-427",
          "snippet": "static int do_recover_data(struct f2fs_sb_info *sbi, struct inode *inode,\n\t\t\t\t\tstruct page *page, block_t blkaddr)\n{\n\tstruct f2fs_inode_info *fi = F2FS_I(inode);\n\tunsigned int start, end;\n\tstruct dnode_of_data dn;\n\tstruct f2fs_summary sum;\n\tstruct node_info ni;\n\tint err = 0, recovered = 0;\n\n\t/* step 1: recover xattr */\n\tif (IS_INODE(page)) {\n\t\trecover_inline_xattr(inode, page);\n\t} else if (f2fs_has_xattr_block(ofs_of_node(page))) {\n\t\t/*\n\t\t * Deprecated; xattr blocks should be found from cold log.\n\t\t * But, we should remain this for backward compatibility.\n\t\t */\n\t\trecover_xattr_data(inode, page, blkaddr);\n\t\tgoto out;\n\t}\n\n\t/* step 2: recover inline data */\n\tif (recover_inline_data(inode, page))\n\t\tgoto out;\n\n\t/* step 3: recover data indices */\n\tstart = start_bidx_of_node(ofs_of_node(page), fi);\n\tend = start + ADDRS_PER_PAGE(page, fi);\n\n\tf2fs_lock_op(sbi);\n\n\tset_new_dnode(&dn, inode, NULL, NULL, 0);\n\n\terr = get_dnode_of_data(&dn, start, ALLOC_NODE);\n\tif (err) {\n\t\tf2fs_unlock_op(sbi);\n\t\tgoto out;\n\t}\n\n\tf2fs_wait_on_page_writeback(dn.node_page, NODE);\n\n\tget_node_info(sbi, dn.nid, &ni);\n\tf2fs_bug_on(sbi, ni.ino != ino_of_node(page));\n\tf2fs_bug_on(sbi, ofs_of_node(dn.node_page) != ofs_of_node(page));\n\n\tfor (; start < end; start++) {\n\t\tblock_t src, dest;\n\n\t\tsrc = datablock_addr(dn.node_page, dn.ofs_in_node);\n\t\tdest = datablock_addr(page, dn.ofs_in_node);\n\n\t\tif (src != dest && dest != NEW_ADDR && dest != NULL_ADDR) {\n\t\t\tif (src == NULL_ADDR) {\n\t\t\t\terr = reserve_new_block(&dn);\n\t\t\t\t/* We should not get -ENOSPC */\n\t\t\t\tf2fs_bug_on(sbi, err);\n\t\t\t}\n\n\t\t\t/* Check the previous node page having this index */\n\t\t\terr = check_index_in_prev_nodes(sbi, dest, &dn);\n\t\t\tif (err)\n\t\t\t\tgoto err;\n\n\t\t\tset_summary(&sum, dn.nid, dn.ofs_in_node, ni.version);\n\n\t\t\t/* write dummy data page */\n\t\t\trecover_data_page(sbi, NULL, &sum, src, dest);\n\t\t\tdn.data_blkaddr = dest;\n\t\t\tupdate_extent_cache(&dn);\n\t\t\trecovered++;\n\t\t}\n\t\tdn.ofs_in_node++;\n\t}\n\n\t/* write node page in place */\n\tset_summary(&sum, dn.nid, 0, 0);\n\tif (IS_INODE(dn.node_page))\n\t\tsync_inode_page(&dn);\n\n\tcopy_node_footer(dn.node_page, page);\n\tfill_node_footer(dn.node_page, dn.nid, ni.ino,\n\t\t\t\t\tofs_of_node(page), false);\n\tset_page_dirty(dn.node_page);\nerr:\n\tf2fs_put_dnode(&dn);\n\tf2fs_unlock_op(sbi);\nout:\n\tf2fs_msg(sbi->sb, KERN_NOTICE,\n\t\t\"recover_data: ino = %lx, recovered = %d blocks, err = %d\",\n\t\tinode->i_ino, recovered, err);\n\treturn err;\n}",
          "includes": [
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic int do_recover_data(struct f2fs_sb_info *sbi, struct inode *inode,\n\t\t\t\t\tstruct page *page, block_t blkaddr)\n{\n\tstruct f2fs_inode_info *fi = F2FS_I(inode);\n\tunsigned int start, end;\n\tstruct dnode_of_data dn;\n\tstruct f2fs_summary sum;\n\tstruct node_info ni;\n\tint err = 0, recovered = 0;\n\n\t/* step 1: recover xattr */\n\tif (IS_INODE(page)) {\n\t\trecover_inline_xattr(inode, page);\n\t} else if (f2fs_has_xattr_block(ofs_of_node(page))) {\n\t\t/*\n\t\t * Deprecated; xattr blocks should be found from cold log.\n\t\t * But, we should remain this for backward compatibility.\n\t\t */\n\t\trecover_xattr_data(inode, page, blkaddr);\n\t\tgoto out;\n\t}\n\n\t/* step 2: recover inline data */\n\tif (recover_inline_data(inode, page))\n\t\tgoto out;\n\n\t/* step 3: recover data indices */\n\tstart = start_bidx_of_node(ofs_of_node(page), fi);\n\tend = start + ADDRS_PER_PAGE(page, fi);\n\n\tf2fs_lock_op(sbi);\n\n\tset_new_dnode(&dn, inode, NULL, NULL, 0);\n\n\terr = get_dnode_of_data(&dn, start, ALLOC_NODE);\n\tif (err) {\n\t\tf2fs_unlock_op(sbi);\n\t\tgoto out;\n\t}\n\n\tf2fs_wait_on_page_writeback(dn.node_page, NODE);\n\n\tget_node_info(sbi, dn.nid, &ni);\n\tf2fs_bug_on(sbi, ni.ino != ino_of_node(page));\n\tf2fs_bug_on(sbi, ofs_of_node(dn.node_page) != ofs_of_node(page));\n\n\tfor (; start < end; start++) {\n\t\tblock_t src, dest;\n\n\t\tsrc = datablock_addr(dn.node_page, dn.ofs_in_node);\n\t\tdest = datablock_addr(page, dn.ofs_in_node);\n\n\t\tif (src != dest && dest != NEW_ADDR && dest != NULL_ADDR) {\n\t\t\tif (src == NULL_ADDR) {\n\t\t\t\terr = reserve_new_block(&dn);\n\t\t\t\t/* We should not get -ENOSPC */\n\t\t\t\tf2fs_bug_on(sbi, err);\n\t\t\t}\n\n\t\t\t/* Check the previous node page having this index */\n\t\t\terr = check_index_in_prev_nodes(sbi, dest, &dn);\n\t\t\tif (err)\n\t\t\t\tgoto err;\n\n\t\t\tset_summary(&sum, dn.nid, dn.ofs_in_node, ni.version);\n\n\t\t\t/* write dummy data page */\n\t\t\trecover_data_page(sbi, NULL, &sum, src, dest);\n\t\t\tdn.data_blkaddr = dest;\n\t\t\tupdate_extent_cache(&dn);\n\t\t\trecovered++;\n\t\t}\n\t\tdn.ofs_in_node++;\n\t}\n\n\t/* write node page in place */\n\tset_summary(&sum, dn.nid, 0, 0);\n\tif (IS_INODE(dn.node_page))\n\t\tsync_inode_page(&dn);\n\n\tcopy_node_footer(dn.node_page, page);\n\tfill_node_footer(dn.node_page, dn.nid, ni.ino,\n\t\t\t\t\tofs_of_node(page), false);\n\tset_page_dirty(dn.node_page);\nerr:\n\tf2fs_put_dnode(&dn);\n\tf2fs_unlock_op(sbi);\nout:\n\tf2fs_msg(sbi->sb, KERN_NOTICE,\n\t\t\"recover_data: ino = %lx, recovered = %d blocks, err = %d\",\n\t\tinode->i_ino, recovered, err);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "recover_dentry",
          "args": [
            "entry->inode",
            "page"
          ],
          "line": 468
        },
        "resolved": true,
        "details": {
          "function_name": "recover_dentry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/recovery.c",
          "lines": "70-142",
          "snippet": "static int recover_dentry(struct inode *inode, struct page *ipage)\n{\n\tstruct f2fs_inode *raw_inode = F2FS_INODE(ipage);\n\tnid_t pino = le32_to_cpu(raw_inode->i_pino);\n\tstruct f2fs_dir_entry *de;\n\tstruct qstr name;\n\tstruct page *page;\n\tstruct inode *dir, *einode;\n\tint err = 0;\n\n\tdir = f2fs_iget(inode->i_sb, pino);\n\tif (IS_ERR(dir)) {\n\t\terr = PTR_ERR(dir);\n\t\tgoto out;\n\t}\n\n\tname.len = le32_to_cpu(raw_inode->i_namelen);\n\tname.name = raw_inode->i_name;\n\n\tif (unlikely(name.len > F2FS_NAME_LEN)) {\n\t\tWARN_ON(1);\n\t\terr = -ENAMETOOLONG;\n\t\tgoto out_err;\n\t}\nretry:\n\tde = f2fs_find_entry(dir, &name, &page);\n\tif (de && inode->i_ino == le32_to_cpu(de->ino)) {\n\t\tclear_inode_flag(F2FS_I(inode), FI_INC_LINK);\n\t\tgoto out_unmap_put;\n\t}\n\tif (de) {\n\t\teinode = f2fs_iget(inode->i_sb, le32_to_cpu(de->ino));\n\t\tif (IS_ERR(einode)) {\n\t\t\tWARN_ON(1);\n\t\t\terr = PTR_ERR(einode);\n\t\t\tif (err == -ENOENT)\n\t\t\t\terr = -EEXIST;\n\t\t\tgoto out_unmap_put;\n\t\t}\n\t\terr = acquire_orphan_inode(F2FS_I_SB(inode));\n\t\tif (err) {\n\t\t\tiput(einode);\n\t\t\tgoto out_unmap_put;\n\t\t}\n\t\tf2fs_delete_entry(de, page, dir, einode);\n\t\tiput(einode);\n\t\tgoto retry;\n\t}\n\terr = __f2fs_add_link(dir, &name, inode);\n\tif (err)\n\t\tgoto out_err;\n\n\tif (is_inode_flag_set(F2FS_I(dir), FI_DELAY_IPUT)) {\n\t\tiput(dir);\n\t} else {\n\t\tadd_dirty_dir_inode(dir);\n\t\tset_inode_flag(F2FS_I(dir), FI_DELAY_IPUT);\n\t}\n\n\tgoto out;\n\nout_unmap_put:\n\tf2fs_dentry_kunmap(dir, page);\n\tf2fs_put_page(page, 0);\nout_err:\n\tiput(dir);\nout:\n\tf2fs_msg(inode->i_sb, KERN_NOTICE,\n\t\t\t\"%s: ino = %x, name = %s, dir = %lx, err = %d\",\n\t\t\t__func__, ino_of_node(ipage), raw_inode->i_name,\n\t\t\tIS_ERR(dir) ? 0 : dir->i_ino, err);\n\treturn err;\n}",
          "includes": [
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic int recover_dentry(struct inode *inode, struct page *ipage)\n{\n\tstruct f2fs_inode *raw_inode = F2FS_INODE(ipage);\n\tnid_t pino = le32_to_cpu(raw_inode->i_pino);\n\tstruct f2fs_dir_entry *de;\n\tstruct qstr name;\n\tstruct page *page;\n\tstruct inode *dir, *einode;\n\tint err = 0;\n\n\tdir = f2fs_iget(inode->i_sb, pino);\n\tif (IS_ERR(dir)) {\n\t\terr = PTR_ERR(dir);\n\t\tgoto out;\n\t}\n\n\tname.len = le32_to_cpu(raw_inode->i_namelen);\n\tname.name = raw_inode->i_name;\n\n\tif (unlikely(name.len > F2FS_NAME_LEN)) {\n\t\tWARN_ON(1);\n\t\terr = -ENAMETOOLONG;\n\t\tgoto out_err;\n\t}\nretry:\n\tde = f2fs_find_entry(dir, &name, &page);\n\tif (de && inode->i_ino == le32_to_cpu(de->ino)) {\n\t\tclear_inode_flag(F2FS_I(inode), FI_INC_LINK);\n\t\tgoto out_unmap_put;\n\t}\n\tif (de) {\n\t\teinode = f2fs_iget(inode->i_sb, le32_to_cpu(de->ino));\n\t\tif (IS_ERR(einode)) {\n\t\t\tWARN_ON(1);\n\t\t\terr = PTR_ERR(einode);\n\t\t\tif (err == -ENOENT)\n\t\t\t\terr = -EEXIST;\n\t\t\tgoto out_unmap_put;\n\t\t}\n\t\terr = acquire_orphan_inode(F2FS_I_SB(inode));\n\t\tif (err) {\n\t\t\tiput(einode);\n\t\t\tgoto out_unmap_put;\n\t\t}\n\t\tf2fs_delete_entry(de, page, dir, einode);\n\t\tiput(einode);\n\t\tgoto retry;\n\t}\n\terr = __f2fs_add_link(dir, &name, inode);\n\tif (err)\n\t\tgoto out_err;\n\n\tif (is_inode_flag_set(F2FS_I(dir), FI_DELAY_IPUT)) {\n\t\tiput(dir);\n\t} else {\n\t\tadd_dirty_dir_inode(dir);\n\t\tset_inode_flag(F2FS_I(dir), FI_DELAY_IPUT);\n\t}\n\n\tgoto out;\n\nout_unmap_put:\n\tf2fs_dentry_kunmap(dir, page);\n\tf2fs_put_page(page, 0);\nout_err:\n\tiput(dir);\nout:\n\tf2fs_msg(inode->i_sb, KERN_NOTICE,\n\t\t\t\"%s: ino = %x, name = %s, dir = %lx, err = %d\",\n\t\t\t__func__, ino_of_node(ipage), raw_inode->i_name,\n\t\t\tIS_ERR(dir) ? 0 : dir->i_ino, err);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "recover_inode",
          "args": [
            "entry->inode",
            "page"
          ],
          "line": 466
        },
        "resolved": true,
        "details": {
          "function_name": "recover_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/recovery.c",
          "lines": "144-159",
          "snippet": "static void recover_inode(struct inode *inode, struct page *page)\n{\n\tstruct f2fs_inode *raw = F2FS_INODE(page);\n\n\tinode->i_mode = le16_to_cpu(raw->i_mode);\n\ti_size_write(inode, le64_to_cpu(raw->i_size));\n\tinode->i_atime.tv_sec = le64_to_cpu(raw->i_mtime);\n\tinode->i_ctime.tv_sec = le64_to_cpu(raw->i_ctime);\n\tinode->i_mtime.tv_sec = le64_to_cpu(raw->i_mtime);\n\tinode->i_atime.tv_nsec = le32_to_cpu(raw->i_mtime_nsec);\n\tinode->i_ctime.tv_nsec = le32_to_cpu(raw->i_ctime_nsec);\n\tinode->i_mtime.tv_nsec = le32_to_cpu(raw->i_mtime_nsec);\n\n\tf2fs_msg(inode->i_sb, KERN_NOTICE, \"recover_inode: ino = %x, name = %s\",\n\t\t\tino_of_node(page), F2FS_INODE(page)->i_name);\n}",
          "includes": [
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic void recover_inode(struct inode *inode, struct page *page)\n{\n\tstruct f2fs_inode *raw = F2FS_INODE(page);\n\n\tinode->i_mode = le16_to_cpu(raw->i_mode);\n\ti_size_write(inode, le64_to_cpu(raw->i_size));\n\tinode->i_atime.tv_sec = le64_to_cpu(raw->i_mtime);\n\tinode->i_ctime.tv_sec = le64_to_cpu(raw->i_ctime);\n\tinode->i_mtime.tv_sec = le64_to_cpu(raw->i_mtime);\n\tinode->i_atime.tv_nsec = le32_to_cpu(raw->i_mtime_nsec);\n\tinode->i_ctime.tv_nsec = le32_to_cpu(raw->i_ctime_nsec);\n\tinode->i_mtime.tv_nsec = le32_to_cpu(raw->i_mtime_nsec);\n\n\tf2fs_msg(inode->i_sb, KERN_NOTICE, \"recover_inode: ino = %x, name = %s\",\n\t\t\tino_of_node(page), F2FS_INODE(page)->i_name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_fsync_inode",
          "args": [
            "head",
            "ino_of_node(page)"
          ],
          "line": 457
        },
        "resolved": true,
        "details": {
          "function_name": "get_fsync_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/recovery.c",
          "lines": "58-68",
          "snippet": "static struct fsync_inode_entry *get_fsync_inode(struct list_head *head,\n\t\t\t\t\t\t\t\tnid_t ino)\n{\n\tstruct fsync_inode_entry *entry;\n\n\tlist_for_each_entry(entry, head, list)\n\t\tif (entry->inode->i_ino == ino)\n\t\t\treturn entry;\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic struct fsync_inode_entry *get_fsync_inode(struct list_head *head,\n\t\t\t\t\t\t\t\tnid_t ino)\n{\n\tstruct fsync_inode_entry *entry;\n\n\tlist_for_each_entry(entry, head, list)\n\t\tif (entry->inode->i_ino == ino)\n\t\t\treturn entry;\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ino_of_node",
          "args": [
            "page"
          ],
          "line": 457
        },
        "resolved": true,
        "details": {
          "function_name": "ino_of_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.h",
          "lines": "247-251",
          "snippet": "static inline nid_t ino_of_node(struct page *node_page)\n{\n\tstruct f2fs_node *rn = F2FS_NODE(node_page);\n\treturn le32_to_cpu(rn->footer.ino);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline nid_t ino_of_node(struct page *node_page)\n{\n\tstruct f2fs_node *rn = F2FS_NODE(node_page);\n\treturn le32_to_cpu(rn->footer.ino);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpver_of_node",
          "args": [
            "page"
          ],
          "line": 452
        },
        "resolved": true,
        "details": {
          "function_name": "cpver_of_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.h",
          "lines": "266-270",
          "snippet": "static inline unsigned long long cpver_of_node(struct page *node_page)\n{\n\tstruct f2fs_node *rn = F2FS_NODE(node_page);\n\treturn le64_to_cpu(rn->footer.cp_ver);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline unsigned long long cpver_of_node(struct page *node_page)\n{\n\tstruct f2fs_node *rn = F2FS_NODE(node_page);\n\treturn le64_to_cpu(rn->footer.cp_ver);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_meta_page",
          "args": [
            "sbi",
            "blkaddr"
          ],
          "line": 450
        },
        "resolved": true,
        "details": {
          "function_name": "get_meta_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/checkpoint.c",
          "lines": "50-78",
          "snippet": "struct page *get_meta_page(struct f2fs_sb_info *sbi, pgoff_t index)\n{\n\tstruct address_space *mapping = META_MAPPING(sbi);\n\tstruct page *page;\n\tstruct f2fs_io_info fio = {\n\t\t.type = META,\n\t\t.rw = READ_SYNC | REQ_META | REQ_PRIO,\n\t\t.blk_addr = index,\n\t};\nrepeat:\n\tpage = grab_cache_page(mapping, index);\n\tif (!page) {\n\t\tcond_resched();\n\t\tgoto repeat;\n\t}\n\tif (PageUptodate(page))\n\t\tgoto out;\n\n\tif (f2fs_submit_page_bio(sbi, page, &fio))\n\t\tgoto repeat;\n\n\tlock_page(page);\n\tif (unlikely(page->mapping != mapping)) {\n\t\tf2fs_put_page(page, 1);\n\t\tgoto repeat;\n\t}\nout:\n\treturn page;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/f2fs_fs.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n\nstruct page *get_meta_page(struct f2fs_sb_info *sbi, pgoff_t index)\n{\n\tstruct address_space *mapping = META_MAPPING(sbi);\n\tstruct page *page;\n\tstruct f2fs_io_info fio = {\n\t\t.type = META,\n\t\t.rw = READ_SYNC | REQ_META | REQ_PRIO,\n\t\t.blk_addr = index,\n\t};\nrepeat:\n\tpage = grab_cache_page(mapping, index);\n\tif (!page) {\n\t\tcond_resched();\n\t\tgoto repeat;\n\t}\n\tif (PageUptodate(page))\n\t\tgoto out;\n\n\tif (f2fs_submit_page_bio(sbi, page, &fio))\n\t\tgoto repeat;\n\n\tlock_page(page);\n\tif (unlikely(page->mapping != mapping)) {\n\t\tf2fs_put_page(page, 1);\n\t\tgoto repeat;\n\t}\nout:\n\treturn page;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ra_meta_pages_cond",
          "args": [
            "sbi",
            "blkaddr"
          ],
          "line": 448
        },
        "resolved": true,
        "details": {
          "function_name": "ra_meta_pages_cond",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/checkpoint.c",
          "lines": "172-184",
          "snippet": "void ra_meta_pages_cond(struct f2fs_sb_info *sbi, pgoff_t index)\n{\n\tstruct page *page;\n\tbool readahead = false;\n\n\tpage = find_get_page(META_MAPPING(sbi), index);\n\tif (!page || (page && !PageUptodate(page)))\n\t\treadahead = true;\n\tf2fs_put_page(page, 0);\n\n\tif (readahead)\n\t\tra_meta_pages(sbi, index, MAX_BIO_BLOCKS(sbi), META_POR);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/f2fs_fs.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n\nvoid ra_meta_pages_cond(struct f2fs_sb_info *sbi, pgoff_t index)\n{\n\tstruct page *page;\n\tbool readahead = false;\n\n\tpage = find_get_page(META_MAPPING(sbi), index);\n\tif (!page || (page && !PageUptodate(page)))\n\t\treadahead = true;\n\tf2fs_put_page(page, 0);\n\n\tif (readahead)\n\t\tra_meta_pages(sbi, index, MAX_BIO_BLOCKS(sbi), META_POR);\n}"
        }
      },
      {
        "call_info": {
          "callee": "MAX_BLKADDR",
          "args": [
            "sbi"
          ],
          "line": 445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAIN_BLKADDR",
          "args": [
            "sbi"
          ],
          "line": 445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NEXT_FREE_BLKADDR",
          "args": [
            "sbi",
            "curseg"
          ],
          "line": 440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CURSEG_I",
          "args": [
            "sbi",
            "type"
          ],
          "line": 439
        },
        "resolved": true,
        "details": {
          "function_name": "CURSEG_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.h",
          "lines": "263-266",
          "snippet": "static inline struct curseg_info *CURSEG_I(struct f2fs_sb_info *sbi, int type)\n{\n\treturn (struct curseg_info *)(SM_I(sbi)->curseg_array + type);\n}",
          "includes": [
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/blkdev.h>\n\nstatic inline struct curseg_info *CURSEG_I(struct f2fs_sb_info *sbi, int type)\n{\n\treturn (struct curseg_info *)(SM_I(sbi)->curseg_array + type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cur_cp_version",
          "args": [
            "F2FS_CKPT(sbi)"
          ],
          "line": 432
        },
        "resolved": true,
        "details": {
          "function_name": "cur_cp_version",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "730-733",
          "snippet": "static inline unsigned long long cur_cp_version(struct f2fs_checkpoint *cp)\n{\n\treturn le64_to_cpu(cp->checkpoint_ver);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline unsigned long long cur_cp_version(struct f2fs_checkpoint *cp)\n{\n\treturn le64_to_cpu(cp->checkpoint_ver);\n}"
        }
      },
      {
        "call_info": {
          "callee": "F2FS_CKPT",
          "args": [
            "sbi"
          ],
          "line": 432
        },
        "resolved": true,
        "details": {
          "function_name": "F2FS_CKPT",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "665-668",
          "snippet": "static inline struct f2fs_checkpoint *F2FS_CKPT(struct f2fs_sb_info *sbi)\n{\n\treturn (struct f2fs_checkpoint *)(sbi->ckpt);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_checkpoint *F2FS_CKPT(struct f2fs_sb_info *sbi)\n{\n\treturn (struct f2fs_checkpoint *)(sbi->ckpt);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic struct kmem_cache *fsync_entry_slab;\n\nstatic int recover_data(struct f2fs_sb_info *sbi,\n\t\t\t\tstruct list_head *head, int type)\n{\n\tunsigned long long cp_ver = cur_cp_version(F2FS_CKPT(sbi));\n\tstruct curseg_info *curseg;\n\tstruct page *page = NULL;\n\tint err = 0;\n\tblock_t blkaddr;\n\n\t/* get node pages in the current segment */\n\tcurseg = CURSEG_I(sbi, type);\n\tblkaddr = NEXT_FREE_BLKADDR(sbi, curseg);\n\n\twhile (1) {\n\t\tstruct fsync_inode_entry *entry;\n\n\t\tif (blkaddr < MAIN_BLKADDR(sbi) || blkaddr >= MAX_BLKADDR(sbi))\n\t\t\tbreak;\n\n\t\tra_meta_pages_cond(sbi, blkaddr);\n\n\t\tpage = get_meta_page(sbi, blkaddr);\n\n\t\tif (cp_ver != cpver_of_node(page)) {\n\t\t\tf2fs_put_page(page, 1);\n\t\t\tbreak;\n\t\t}\n\n\t\tentry = get_fsync_inode(head, ino_of_node(page));\n\t\tif (!entry)\n\t\t\tgoto next;\n\t\t/*\n\t\t * inode(x) | CP | inode(x) | dnode(F)\n\t\t * In this case, we can lose the latest inode(x).\n\t\t * So, call recover_inode for the inode update.\n\t\t */\n\t\tif (entry->last_inode == blkaddr)\n\t\t\trecover_inode(entry->inode, page);\n\t\tif (entry->last_dentry == blkaddr) {\n\t\t\terr = recover_dentry(entry->inode, page);\n\t\t\tif (err) {\n\t\t\t\tf2fs_put_page(page, 1);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\terr = do_recover_data(sbi, entry->inode, page, blkaddr);\n\t\tif (err) {\n\t\t\tf2fs_put_page(page, 1);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (entry->blkaddr == blkaddr) {\n\t\t\tiput(entry->inode);\n\t\t\tlist_del(&entry->list);\n\t\t\tkmem_cache_free(fsync_entry_slab, entry);\n\t\t}\nnext:\n\t\t/* check next segment */\n\t\tblkaddr = next_blkaddr_of_node(page);\n\t\tf2fs_put_page(page, 1);\n\t}\n\tif (!err)\n\t\tallocate_new_segments(sbi);\n\treturn err;\n}"
  },
  {
    "function_name": "do_recover_data",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/recovery.c",
    "lines": "335-427",
    "snippet": "static int do_recover_data(struct f2fs_sb_info *sbi, struct inode *inode,\n\t\t\t\t\tstruct page *page, block_t blkaddr)\n{\n\tstruct f2fs_inode_info *fi = F2FS_I(inode);\n\tunsigned int start, end;\n\tstruct dnode_of_data dn;\n\tstruct f2fs_summary sum;\n\tstruct node_info ni;\n\tint err = 0, recovered = 0;\n\n\t/* step 1: recover xattr */\n\tif (IS_INODE(page)) {\n\t\trecover_inline_xattr(inode, page);\n\t} else if (f2fs_has_xattr_block(ofs_of_node(page))) {\n\t\t/*\n\t\t * Deprecated; xattr blocks should be found from cold log.\n\t\t * But, we should remain this for backward compatibility.\n\t\t */\n\t\trecover_xattr_data(inode, page, blkaddr);\n\t\tgoto out;\n\t}\n\n\t/* step 2: recover inline data */\n\tif (recover_inline_data(inode, page))\n\t\tgoto out;\n\n\t/* step 3: recover data indices */\n\tstart = start_bidx_of_node(ofs_of_node(page), fi);\n\tend = start + ADDRS_PER_PAGE(page, fi);\n\n\tf2fs_lock_op(sbi);\n\n\tset_new_dnode(&dn, inode, NULL, NULL, 0);\n\n\terr = get_dnode_of_data(&dn, start, ALLOC_NODE);\n\tif (err) {\n\t\tf2fs_unlock_op(sbi);\n\t\tgoto out;\n\t}\n\n\tf2fs_wait_on_page_writeback(dn.node_page, NODE);\n\n\tget_node_info(sbi, dn.nid, &ni);\n\tf2fs_bug_on(sbi, ni.ino != ino_of_node(page));\n\tf2fs_bug_on(sbi, ofs_of_node(dn.node_page) != ofs_of_node(page));\n\n\tfor (; start < end; start++) {\n\t\tblock_t src, dest;\n\n\t\tsrc = datablock_addr(dn.node_page, dn.ofs_in_node);\n\t\tdest = datablock_addr(page, dn.ofs_in_node);\n\n\t\tif (src != dest && dest != NEW_ADDR && dest != NULL_ADDR) {\n\t\t\tif (src == NULL_ADDR) {\n\t\t\t\terr = reserve_new_block(&dn);\n\t\t\t\t/* We should not get -ENOSPC */\n\t\t\t\tf2fs_bug_on(sbi, err);\n\t\t\t}\n\n\t\t\t/* Check the previous node page having this index */\n\t\t\terr = check_index_in_prev_nodes(sbi, dest, &dn);\n\t\t\tif (err)\n\t\t\t\tgoto err;\n\n\t\t\tset_summary(&sum, dn.nid, dn.ofs_in_node, ni.version);\n\n\t\t\t/* write dummy data page */\n\t\t\trecover_data_page(sbi, NULL, &sum, src, dest);\n\t\t\tdn.data_blkaddr = dest;\n\t\t\tupdate_extent_cache(&dn);\n\t\t\trecovered++;\n\t\t}\n\t\tdn.ofs_in_node++;\n\t}\n\n\t/* write node page in place */\n\tset_summary(&sum, dn.nid, 0, 0);\n\tif (IS_INODE(dn.node_page))\n\t\tsync_inode_page(&dn);\n\n\tcopy_node_footer(dn.node_page, page);\n\tfill_node_footer(dn.node_page, dn.nid, ni.ino,\n\t\t\t\t\tofs_of_node(page), false);\n\tset_page_dirty(dn.node_page);\nerr:\n\tf2fs_put_dnode(&dn);\n\tf2fs_unlock_op(sbi);\nout:\n\tf2fs_msg(sbi->sb, KERN_NOTICE,\n\t\t\"recover_data: ino = %lx, recovered = %d blocks, err = %d\",\n\t\tinode->i_ino, recovered, err);\n\treturn err;\n}",
    "includes": [
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "f2fs_msg",
          "args": [
            "sbi->sb",
            "KERN_NOTICE",
            "\"recover_data: ino = %lx, recovered = %d blocks, err = %d\"",
            "inode->i_ino",
            "recovered",
            "err"
          ],
          "line": 423
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_msg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/super.c",
          "lines": "235-245",
          "snippet": "void f2fs_msg(struct super_block *sb, const char *level, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tprintk(\"%sF2FS-fs (%s): %pV\\n\", level, sb->s_id, &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"gc.h\"",
            "#include \"xattr.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/sysfs.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/random.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/parser.h>",
            "#include <linux/kthread.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/statfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"gc.h\"\n#include \"xattr.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/sysfs.h>\n#include <linux/f2fs_fs.h>\n#include <linux/blkdev.h>\n#include <linux/exportfs.h>\n#include <linux/random.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/parser.h>\n#include <linux/kthread.h>\n#include <linux/backing-dev.h>\n#include <linux/buffer_head.h>\n#include <linux/statfs.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nvoid f2fs_msg(struct super_block *sb, const char *level, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tprintk(\"%sF2FS-fs (%s): %pV\\n\", level, sb->s_id, &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_unlock_op",
          "args": [
            "sbi"
          ],
          "line": 421
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_unlock_op",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "760-763",
          "snippet": "static inline void f2fs_unlock_op(struct f2fs_sb_info *sbi)\n{\n\tup_read(&sbi->cp_rwsem);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void f2fs_unlock_op(struct f2fs_sb_info *sbi)\n{\n\tup_read(&sbi->cp_rwsem);\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_put_dnode",
          "args": [
            "&dn"
          ],
          "line": 420
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_put_dnode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1048-1056",
          "snippet": "static inline void f2fs_put_dnode(struct dnode_of_data *dn)\n{\n\tif (dn->node_page)\n\t\tf2fs_put_page(dn->node_page, 1);\n\tif (dn->inode_page && dn->node_page != dn->inode_page)\n\t\tf2fs_put_page(dn->inode_page, 0);\n\tdn->node_page = NULL;\n\tdn->inode_page = NULL;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void f2fs_put_dnode(struct dnode_of_data *dn)\n{\n\tif (dn->node_page)\n\t\tf2fs_put_page(dn->node_page, 1);\n\tif (dn->inode_page && dn->node_page != dn->inode_page)\n\t\tf2fs_put_page(dn->inode_page, 0);\n\tdn->node_page = NULL;\n\tdn->inode_page = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_page_dirty",
          "args": [
            "dn.node_page"
          ],
          "line": 418
        },
        "resolved": true,
        "details": {
          "function_name": "anon_set_page_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/libfs.c",
          "lines": "1040-1043",
          "snippet": "static int anon_set_page_dirty(struct page *page)\n{\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nstatic int anon_set_page_dirty(struct page *page)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fill_node_footer",
          "args": [
            "dn.node_page",
            "dn.nid",
            "ni.ino",
            "ofs_of_node(page)",
            "false"
          ],
          "line": 416
        },
        "resolved": true,
        "details": {
          "function_name": "fill_node_footer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.h",
          "lines": "212-229",
          "snippet": "static inline void fill_node_footer(struct page *page, nid_t nid,\n\t\t\t\tnid_t ino, unsigned int ofs, bool reset)\n{\n\tstruct f2fs_node *rn = F2FS_NODE(page);\n\tunsigned int old_flag = 0;\n\n\tif (reset)\n\t\tmemset(rn, 0, sizeof(*rn));\n\telse\n\t\told_flag = le32_to_cpu(rn->footer.flag);\n\n\trn->footer.nid = cpu_to_le32(nid);\n\trn->footer.ino = cpu_to_le32(ino);\n\n\t/* should remain old flag bits such as COLD_BIT_SHIFT */\n\trn->footer.flag = cpu_to_le32((ofs << OFFSET_BIT_SHIFT) |\n\t\t\t\t\t(old_flag & OFFSET_BIT_MASK));\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void fill_node_footer(struct page *page, nid_t nid,\n\t\t\t\tnid_t ino, unsigned int ofs, bool reset)\n{\n\tstruct f2fs_node *rn = F2FS_NODE(page);\n\tunsigned int old_flag = 0;\n\n\tif (reset)\n\t\tmemset(rn, 0, sizeof(*rn));\n\telse\n\t\told_flag = le32_to_cpu(rn->footer.flag);\n\n\trn->footer.nid = cpu_to_le32(nid);\n\trn->footer.ino = cpu_to_le32(ino);\n\n\t/* should remain old flag bits such as COLD_BIT_SHIFT */\n\trn->footer.flag = cpu_to_le32((ofs << OFFSET_BIT_SHIFT) |\n\t\t\t\t\t(old_flag & OFFSET_BIT_MASK));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ofs_of_node",
          "args": [
            "page"
          ],
          "line": 417
        },
        "resolved": true,
        "details": {
          "function_name": "ofs_of_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.h",
          "lines": "259-264",
          "snippet": "static inline unsigned int ofs_of_node(struct page *node_page)\n{\n\tstruct f2fs_node *rn = F2FS_NODE(node_page);\n\tunsigned flag = le32_to_cpu(rn->footer.flag);\n\treturn flag >> OFFSET_BIT_SHIFT;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline unsigned int ofs_of_node(struct page *node_page)\n{\n\tstruct f2fs_node *rn = F2FS_NODE(node_page);\n\tunsigned flag = le32_to_cpu(rn->footer.flag);\n\treturn flag >> OFFSET_BIT_SHIFT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_node_footer",
          "args": [
            "dn.node_page",
            "page"
          ],
          "line": 415
        },
        "resolved": true,
        "details": {
          "function_name": "copy_node_footer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.h",
          "lines": "231-236",
          "snippet": "static inline void copy_node_footer(struct page *dst, struct page *src)\n{\n\tstruct f2fs_node *src_rn = F2FS_NODE(src);\n\tstruct f2fs_node *dst_rn = F2FS_NODE(dst);\n\tmemcpy(&dst_rn->footer, &src_rn->footer, sizeof(struct node_footer));\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void copy_node_footer(struct page *dst, struct page *src)\n{\n\tstruct f2fs_node *src_rn = F2FS_NODE(src);\n\tstruct f2fs_node *dst_rn = F2FS_NODE(dst);\n\tmemcpy(&dst_rn->footer, &src_rn->footer, sizeof(struct node_footer));\n}"
        }
      },
      {
        "call_info": {
          "callee": "sync_inode_page",
          "args": [
            "&dn"
          ],
          "line": 413
        },
        "resolved": true,
        "details": {
          "function_name": "sync_inode_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
          "lines": "1116-1129",
          "snippet": "void sync_inode_page(struct dnode_of_data *dn)\n{\n\tif (IS_INODE(dn->node_page) || dn->inode_page == dn->node_page) {\n\t\tupdate_inode(dn->inode, dn->node_page);\n\t} else if (dn->inode_page) {\n\t\tif (!dn->inode_page_locked)\n\t\t\tlock_page(dn->inode_page);\n\t\tupdate_inode(dn->inode, dn->inode_page);\n\t\tif (!dn->inode_page_locked)\n\t\t\tunlock_page(dn->inode_page);\n\t} else {\n\t\tupdate_inode_page(dn->inode);\n\t}\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mpage.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nvoid sync_inode_page(struct dnode_of_data *dn)\n{\n\tif (IS_INODE(dn->node_page) || dn->inode_page == dn->node_page) {\n\t\tupdate_inode(dn->inode, dn->node_page);\n\t} else if (dn->inode_page) {\n\t\tif (!dn->inode_page_locked)\n\t\t\tlock_page(dn->inode_page);\n\t\tupdate_inode(dn->inode, dn->inode_page);\n\t\tif (!dn->inode_page_locked)\n\t\t\tunlock_page(dn->inode_page);\n\t} else {\n\t\tupdate_inode_page(dn->inode);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_INODE",
          "args": [
            "dn.node_page"
          ],
          "line": 412
        },
        "resolved": true,
        "details": {
          "function_name": "IS_INODE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1087-1091",
          "snippet": "static inline bool IS_INODE(struct page *page)\n{\n\tstruct f2fs_node *p = F2FS_NODE(page);\n\treturn RAW_IS_INODE(p);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline bool IS_INODE(struct page *page)\n{\n\tstruct f2fs_node *p = F2FS_NODE(page);\n\treturn RAW_IS_INODE(p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_summary",
          "args": [
            "&sum",
            "dn.nid",
            "0",
            "0"
          ],
          "line": 411
        },
        "resolved": true,
        "details": {
          "function_name": "set_summary",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.h",
          "lines": "671-677",
          "snippet": "static inline void set_summary(struct f2fs_summary *sum, nid_t nid,\n\t\t\tunsigned int ofs_in_node, unsigned char version)\n{\n\tsum->nid = cpu_to_le32(nid);\n\tsum->ofs_in_node = cpu_to_le16(ofs_in_node);\n\tsum->version = version;\n}",
          "includes": [
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/blkdev.h>\n\nstatic inline void set_summary(struct f2fs_summary *sum, nid_t nid,\n\t\t\tunsigned int ofs_in_node, unsigned char version)\n{\n\tsum->nid = cpu_to_le32(nid);\n\tsum->ofs_in_node = cpu_to_le16(ofs_in_node);\n\tsum->version = version;\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_extent_cache",
          "args": [
            "&dn"
          ],
          "line": 404
        },
        "resolved": true,
        "details": {
          "function_name": "update_extent_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/data.c",
          "lines": "294-373",
          "snippet": "void update_extent_cache(struct dnode_of_data *dn)\n{\n\tstruct f2fs_inode_info *fi = F2FS_I(dn->inode);\n\tpgoff_t fofs, start_fofs, end_fofs;\n\tblock_t start_blkaddr, end_blkaddr;\n\tint need_update = true;\n\n\tf2fs_bug_on(F2FS_I_SB(dn->inode), dn->data_blkaddr == NEW_ADDR);\n\n\t/* Update the page address in the parent node */\n\t__set_data_blkaddr(dn);\n\n\tif (is_inode_flag_set(fi, FI_NO_EXTENT))\n\t\treturn;\n\n\tfofs = start_bidx_of_node(ofs_of_node(dn->node_page), fi) +\n\t\t\t\t\t\t\tdn->ofs_in_node;\n\n\twrite_lock(&fi->ext.ext_lock);\n\n\tstart_fofs = fi->ext.fofs;\n\tend_fofs = fi->ext.fofs + fi->ext.len - 1;\n\tstart_blkaddr = fi->ext.blk_addr;\n\tend_blkaddr = fi->ext.blk_addr + fi->ext.len - 1;\n\n\t/* Drop and initialize the matched extent */\n\tif (fi->ext.len == 1 && fofs == start_fofs)\n\t\tfi->ext.len = 0;\n\n\t/* Initial extent */\n\tif (fi->ext.len == 0) {\n\t\tif (dn->data_blkaddr != NULL_ADDR) {\n\t\t\tfi->ext.fofs = fofs;\n\t\t\tfi->ext.blk_addr = dn->data_blkaddr;\n\t\t\tfi->ext.len = 1;\n\t\t}\n\t\tgoto end_update;\n\t}\n\n\t/* Front merge */\n\tif (fofs == start_fofs - 1 && dn->data_blkaddr == start_blkaddr - 1) {\n\t\tfi->ext.fofs--;\n\t\tfi->ext.blk_addr--;\n\t\tfi->ext.len++;\n\t\tgoto end_update;\n\t}\n\n\t/* Back merge */\n\tif (fofs == end_fofs + 1 && dn->data_blkaddr == end_blkaddr + 1) {\n\t\tfi->ext.len++;\n\t\tgoto end_update;\n\t}\n\n\t/* Split the existing extent */\n\tif (fi->ext.len > 1 &&\n\t\tfofs >= start_fofs && fofs <= end_fofs) {\n\t\tif ((end_fofs - fofs) < (fi->ext.len >> 1)) {\n\t\t\tfi->ext.len = fofs - start_fofs;\n\t\t} else {\n\t\t\tfi->ext.fofs = fofs + 1;\n\t\t\tfi->ext.blk_addr = start_blkaddr +\n\t\t\t\t\tfofs - start_fofs + 1;\n\t\t\tfi->ext.len -= fofs - start_fofs + 1;\n\t\t}\n\t} else {\n\t\tneed_update = false;\n\t}\n\n\t/* Finally, if the extent is very fragmented, let's drop the cache. */\n\tif (fi->ext.len < F2FS_MIN_EXTENT_LEN) {\n\t\tfi->ext.len = 0;\n\t\tset_inode_flag(fi, FI_NO_EXTENT);\n\t\tneed_update = true;\n\t}\nend_update:\n\twrite_unlock(&fi->ext.ext_lock);\n\tif (need_update)\n\t\tsync_inode_page(dn);\n\treturn;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/prefetch.h>",
            "#include <linux/bio.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/aio.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/prefetch.h>\n#include <linux/bio.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nvoid update_extent_cache(struct dnode_of_data *dn)\n{\n\tstruct f2fs_inode_info *fi = F2FS_I(dn->inode);\n\tpgoff_t fofs, start_fofs, end_fofs;\n\tblock_t start_blkaddr, end_blkaddr;\n\tint need_update = true;\n\n\tf2fs_bug_on(F2FS_I_SB(dn->inode), dn->data_blkaddr == NEW_ADDR);\n\n\t/* Update the page address in the parent node */\n\t__set_data_blkaddr(dn);\n\n\tif (is_inode_flag_set(fi, FI_NO_EXTENT))\n\t\treturn;\n\n\tfofs = start_bidx_of_node(ofs_of_node(dn->node_page), fi) +\n\t\t\t\t\t\t\tdn->ofs_in_node;\n\n\twrite_lock(&fi->ext.ext_lock);\n\n\tstart_fofs = fi->ext.fofs;\n\tend_fofs = fi->ext.fofs + fi->ext.len - 1;\n\tstart_blkaddr = fi->ext.blk_addr;\n\tend_blkaddr = fi->ext.blk_addr + fi->ext.len - 1;\n\n\t/* Drop and initialize the matched extent */\n\tif (fi->ext.len == 1 && fofs == start_fofs)\n\t\tfi->ext.len = 0;\n\n\t/* Initial extent */\n\tif (fi->ext.len == 0) {\n\t\tif (dn->data_blkaddr != NULL_ADDR) {\n\t\t\tfi->ext.fofs = fofs;\n\t\t\tfi->ext.blk_addr = dn->data_blkaddr;\n\t\t\tfi->ext.len = 1;\n\t\t}\n\t\tgoto end_update;\n\t}\n\n\t/* Front merge */\n\tif (fofs == start_fofs - 1 && dn->data_blkaddr == start_blkaddr - 1) {\n\t\tfi->ext.fofs--;\n\t\tfi->ext.blk_addr--;\n\t\tfi->ext.len++;\n\t\tgoto end_update;\n\t}\n\n\t/* Back merge */\n\tif (fofs == end_fofs + 1 && dn->data_blkaddr == end_blkaddr + 1) {\n\t\tfi->ext.len++;\n\t\tgoto end_update;\n\t}\n\n\t/* Split the existing extent */\n\tif (fi->ext.len > 1 &&\n\t\tfofs >= start_fofs && fofs <= end_fofs) {\n\t\tif ((end_fofs - fofs) < (fi->ext.len >> 1)) {\n\t\t\tfi->ext.len = fofs - start_fofs;\n\t\t} else {\n\t\t\tfi->ext.fofs = fofs + 1;\n\t\t\tfi->ext.blk_addr = start_blkaddr +\n\t\t\t\t\tfofs - start_fofs + 1;\n\t\t\tfi->ext.len -= fofs - start_fofs + 1;\n\t\t}\n\t} else {\n\t\tneed_update = false;\n\t}\n\n\t/* Finally, if the extent is very fragmented, let's drop the cache. */\n\tif (fi->ext.len < F2FS_MIN_EXTENT_LEN) {\n\t\tfi->ext.len = 0;\n\t\tset_inode_flag(fi, FI_NO_EXTENT);\n\t\tneed_update = true;\n\t}\nend_update:\n\twrite_unlock(&fi->ext.ext_lock);\n\tif (need_update)\n\t\tsync_inode_page(dn);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "recover_data_page",
          "args": [
            "sbi",
            "NULL",
            "&sum",
            "src",
            "dest"
          ],
          "line": 402
        },
        "resolved": true,
        "details": {
          "function_name": "recover_data_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
          "lines": "1254-1295",
          "snippet": "void recover_data_page(struct f2fs_sb_info *sbi,\n\t\t\tstruct page *page, struct f2fs_summary *sum,\n\t\t\tblock_t old_blkaddr, block_t new_blkaddr)\n{\n\tstruct sit_info *sit_i = SIT_I(sbi);\n\tstruct curseg_info *curseg;\n\tunsigned int segno, old_cursegno;\n\tstruct seg_entry *se;\n\tint type;\n\n\tsegno = GET_SEGNO(sbi, new_blkaddr);\n\tse = get_seg_entry(sbi, segno);\n\ttype = se->type;\n\n\tif (se->valid_blocks == 0 && !IS_CURSEG(sbi, segno)) {\n\t\tif (old_blkaddr == NULL_ADDR)\n\t\t\ttype = CURSEG_COLD_DATA;\n\t\telse\n\t\t\ttype = CURSEG_WARM_DATA;\n\t}\n\tcurseg = CURSEG_I(sbi, type);\n\n\tmutex_lock(&curseg->curseg_mutex);\n\tmutex_lock(&sit_i->sentry_lock);\n\n\told_cursegno = curseg->segno;\n\n\t/* change the current segment */\n\tif (segno != curseg->segno) {\n\t\tcurseg->next_segno = segno;\n\t\tchange_curseg(sbi, type, true);\n\t}\n\n\tcurseg->next_blkoff = GET_BLKOFF_FROM_SEG0(sbi, new_blkaddr);\n\t__add_sum_entry(sbi, type, sum);\n\n\trefresh_sit_entry(sbi, old_blkaddr, new_blkaddr);\n\tlocate_dirty_segment(sbi, old_cursegno);\n\n\tmutex_unlock(&sit_i->sentry_lock);\n\tmutex_unlock(&curseg->curseg_mutex);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"node.h\"",
            "#include \"segment.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kthread.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nvoid recover_data_page(struct f2fs_sb_info *sbi,\n\t\t\tstruct page *page, struct f2fs_summary *sum,\n\t\t\tblock_t old_blkaddr, block_t new_blkaddr)\n{\n\tstruct sit_info *sit_i = SIT_I(sbi);\n\tstruct curseg_info *curseg;\n\tunsigned int segno, old_cursegno;\n\tstruct seg_entry *se;\n\tint type;\n\n\tsegno = GET_SEGNO(sbi, new_blkaddr);\n\tse = get_seg_entry(sbi, segno);\n\ttype = se->type;\n\n\tif (se->valid_blocks == 0 && !IS_CURSEG(sbi, segno)) {\n\t\tif (old_blkaddr == NULL_ADDR)\n\t\t\ttype = CURSEG_COLD_DATA;\n\t\telse\n\t\t\ttype = CURSEG_WARM_DATA;\n\t}\n\tcurseg = CURSEG_I(sbi, type);\n\n\tmutex_lock(&curseg->curseg_mutex);\n\tmutex_lock(&sit_i->sentry_lock);\n\n\told_cursegno = curseg->segno;\n\n\t/* change the current segment */\n\tif (segno != curseg->segno) {\n\t\tcurseg->next_segno = segno;\n\t\tchange_curseg(sbi, type, true);\n\t}\n\n\tcurseg->next_blkoff = GET_BLKOFF_FROM_SEG0(sbi, new_blkaddr);\n\t__add_sum_entry(sbi, type, sum);\n\n\trefresh_sit_entry(sbi, old_blkaddr, new_blkaddr);\n\tlocate_dirty_segment(sbi, old_cursegno);\n\n\tmutex_unlock(&sit_i->sentry_lock);\n\tmutex_unlock(&curseg->curseg_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_index_in_prev_nodes",
          "args": [
            "sbi",
            "dest",
            "&dn"
          ],
          "line": 395
        },
        "resolved": true,
        "details": {
          "function_name": "check_index_in_prev_nodes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/recovery.c",
          "lines": "250-333",
          "snippet": "static int check_index_in_prev_nodes(struct f2fs_sb_info *sbi,\n\t\t\tblock_t blkaddr, struct dnode_of_data *dn)\n{\n\tstruct seg_entry *sentry;\n\tunsigned int segno = GET_SEGNO(sbi, blkaddr);\n\tunsigned short blkoff = GET_BLKOFF_FROM_SEG0(sbi, blkaddr);\n\tstruct f2fs_summary_block *sum_node;\n\tstruct f2fs_summary sum;\n\tstruct page *sum_page, *node_page;\n\tnid_t ino, nid;\n\tstruct inode *inode;\n\tunsigned int offset;\n\tblock_t bidx;\n\tint i;\n\n\tsentry = get_seg_entry(sbi, segno);\n\tif (!f2fs_test_bit(blkoff, sentry->cur_valid_map))\n\t\treturn 0;\n\n\t/* Get the previous summary */\n\tfor (i = CURSEG_WARM_DATA; i <= CURSEG_COLD_DATA; i++) {\n\t\tstruct curseg_info *curseg = CURSEG_I(sbi, i);\n\t\tif (curseg->segno == segno) {\n\t\t\tsum = curseg->sum_blk->entries[blkoff];\n\t\t\tgoto got_it;\n\t\t}\n\t}\n\n\tsum_page = get_sum_page(sbi, segno);\n\tsum_node = (struct f2fs_summary_block *)page_address(sum_page);\n\tsum = sum_node->entries[blkoff];\n\tf2fs_put_page(sum_page, 1);\ngot_it:\n\t/* Use the locked dnode page and inode */\n\tnid = le32_to_cpu(sum.nid);\n\tif (dn->inode->i_ino == nid) {\n\t\tstruct dnode_of_data tdn = *dn;\n\t\ttdn.nid = nid;\n\t\ttdn.node_page = dn->inode_page;\n\t\ttdn.ofs_in_node = le16_to_cpu(sum.ofs_in_node);\n\t\ttruncate_data_blocks_range(&tdn, 1);\n\t\treturn 0;\n\t} else if (dn->nid == nid) {\n\t\tstruct dnode_of_data tdn = *dn;\n\t\ttdn.ofs_in_node = le16_to_cpu(sum.ofs_in_node);\n\t\ttruncate_data_blocks_range(&tdn, 1);\n\t\treturn 0;\n\t}\n\n\t/* Get the node page */\n\tnode_page = get_node_page(sbi, nid);\n\tif (IS_ERR(node_page))\n\t\treturn PTR_ERR(node_page);\n\n\toffset = ofs_of_node(node_page);\n\tino = ino_of_node(node_page);\n\tf2fs_put_page(node_page, 1);\n\n\tif (ino != dn->inode->i_ino) {\n\t\t/* Deallocate previous index in the node page */\n\t\tinode = f2fs_iget(sbi->sb, ino);\n\t\tif (IS_ERR(inode))\n\t\t\treturn PTR_ERR(inode);\n\t} else {\n\t\tinode = dn->inode;\n\t}\n\n\tbidx = start_bidx_of_node(offset, F2FS_I(inode)) +\n\t\t\tle16_to_cpu(sum.ofs_in_node);\n\n\tif (ino != dn->inode->i_ino) {\n\t\ttruncate_hole(inode, bidx, bidx + 1);\n\t\tiput(inode);\n\t} else {\n\t\tstruct dnode_of_data tdn;\n\t\tset_new_dnode(&tdn, inode, dn->inode_page, NULL, 0);\n\t\tif (get_dnode_of_data(&tdn, bidx, LOOKUP_NODE))\n\t\t\treturn 0;\n\t\tif (tdn.data_blkaddr != NULL_ADDR)\n\t\t\ttruncate_data_blocks_range(&tdn, 1);\n\t\tf2fs_put_page(tdn.node_page, 1);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic int check_index_in_prev_nodes(struct f2fs_sb_info *sbi,\n\t\t\tblock_t blkaddr, struct dnode_of_data *dn)\n{\n\tstruct seg_entry *sentry;\n\tunsigned int segno = GET_SEGNO(sbi, blkaddr);\n\tunsigned short blkoff = GET_BLKOFF_FROM_SEG0(sbi, blkaddr);\n\tstruct f2fs_summary_block *sum_node;\n\tstruct f2fs_summary sum;\n\tstruct page *sum_page, *node_page;\n\tnid_t ino, nid;\n\tstruct inode *inode;\n\tunsigned int offset;\n\tblock_t bidx;\n\tint i;\n\n\tsentry = get_seg_entry(sbi, segno);\n\tif (!f2fs_test_bit(blkoff, sentry->cur_valid_map))\n\t\treturn 0;\n\n\t/* Get the previous summary */\n\tfor (i = CURSEG_WARM_DATA; i <= CURSEG_COLD_DATA; i++) {\n\t\tstruct curseg_info *curseg = CURSEG_I(sbi, i);\n\t\tif (curseg->segno == segno) {\n\t\t\tsum = curseg->sum_blk->entries[blkoff];\n\t\t\tgoto got_it;\n\t\t}\n\t}\n\n\tsum_page = get_sum_page(sbi, segno);\n\tsum_node = (struct f2fs_summary_block *)page_address(sum_page);\n\tsum = sum_node->entries[blkoff];\n\tf2fs_put_page(sum_page, 1);\ngot_it:\n\t/* Use the locked dnode page and inode */\n\tnid = le32_to_cpu(sum.nid);\n\tif (dn->inode->i_ino == nid) {\n\t\tstruct dnode_of_data tdn = *dn;\n\t\ttdn.nid = nid;\n\t\ttdn.node_page = dn->inode_page;\n\t\ttdn.ofs_in_node = le16_to_cpu(sum.ofs_in_node);\n\t\ttruncate_data_blocks_range(&tdn, 1);\n\t\treturn 0;\n\t} else if (dn->nid == nid) {\n\t\tstruct dnode_of_data tdn = *dn;\n\t\ttdn.ofs_in_node = le16_to_cpu(sum.ofs_in_node);\n\t\ttruncate_data_blocks_range(&tdn, 1);\n\t\treturn 0;\n\t}\n\n\t/* Get the node page */\n\tnode_page = get_node_page(sbi, nid);\n\tif (IS_ERR(node_page))\n\t\treturn PTR_ERR(node_page);\n\n\toffset = ofs_of_node(node_page);\n\tino = ino_of_node(node_page);\n\tf2fs_put_page(node_page, 1);\n\n\tif (ino != dn->inode->i_ino) {\n\t\t/* Deallocate previous index in the node page */\n\t\tinode = f2fs_iget(sbi->sb, ino);\n\t\tif (IS_ERR(inode))\n\t\t\treturn PTR_ERR(inode);\n\t} else {\n\t\tinode = dn->inode;\n\t}\n\n\tbidx = start_bidx_of_node(offset, F2FS_I(inode)) +\n\t\t\tle16_to_cpu(sum.ofs_in_node);\n\n\tif (ino != dn->inode->i_ino) {\n\t\ttruncate_hole(inode, bidx, bidx + 1);\n\t\tiput(inode);\n\t} else {\n\t\tstruct dnode_of_data tdn;\n\t\tset_new_dnode(&tdn, inode, dn->inode_page, NULL, 0);\n\t\tif (get_dnode_of_data(&tdn, bidx, LOOKUP_NODE))\n\t\t\treturn 0;\n\t\tif (tdn.data_blkaddr != NULL_ADDR)\n\t\t\ttruncate_data_blocks_range(&tdn, 1);\n\t\tf2fs_put_page(tdn.node_page, 1);\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_bug_on",
          "args": [
            "sbi",
            "err"
          ],
          "line": 391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reserve_new_block",
          "args": [
            "&dn"
          ],
          "line": 389
        },
        "resolved": true,
        "details": {
          "function_name": "reserve_new_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/data.c",
          "lines": "217-233",
          "snippet": "int reserve_new_block(struct dnode_of_data *dn)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(dn->inode);\n\n\tif (unlikely(is_inode_flag_set(F2FS_I(dn->inode), FI_NO_ALLOC)))\n\t\treturn -EPERM;\n\tif (unlikely(!inc_valid_block_count(sbi, dn->inode, 1)))\n\t\treturn -ENOSPC;\n\n\ttrace_f2fs_reserve_new_block(dn->inode, dn->nid, dn->ofs_in_node);\n\n\tdn->data_blkaddr = NEW_ADDR;\n\t__set_data_blkaddr(dn);\n\tmark_inode_dirty(dn->inode);\n\tsync_inode_page(dn);\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/prefetch.h>",
            "#include <linux/bio.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/aio.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/prefetch.h>\n#include <linux/bio.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nint reserve_new_block(struct dnode_of_data *dn)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(dn->inode);\n\n\tif (unlikely(is_inode_flag_set(F2FS_I(dn->inode), FI_NO_ALLOC)))\n\t\treturn -EPERM;\n\tif (unlikely(!inc_valid_block_count(sbi, dn->inode, 1)))\n\t\treturn -ENOSPC;\n\n\ttrace_f2fs_reserve_new_block(dn->inode, dn->nid, dn->ofs_in_node);\n\n\tdn->data_blkaddr = NEW_ADDR;\n\t__set_data_blkaddr(dn);\n\tmark_inode_dirty(dn->inode);\n\tsync_inode_page(dn);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "datablock_addr",
          "args": [
            "page",
            "dn.ofs_in_node"
          ],
          "line": 385
        },
        "resolved": true,
        "details": {
          "function_name": "datablock_addr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1098-1106",
          "snippet": "static inline block_t datablock_addr(struct page *node_page,\n\t\tunsigned int offset)\n{\n\tstruct f2fs_node *raw_node;\n\t__le32 *addr_array;\n\traw_node = F2FS_NODE(node_page);\n\taddr_array = blkaddr_in_node(raw_node);\n\treturn le32_to_cpu(addr_array[offset]);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline block_t datablock_addr(struct page *node_page,\n\t\tunsigned int offset)\n{\n\tstruct f2fs_node *raw_node;\n\t__le32 *addr_array;\n\traw_node = F2FS_NODE(node_page);\n\taddr_array = blkaddr_in_node(raw_node);\n\treturn le32_to_cpu(addr_array[offset]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_bug_on",
          "args": [
            "sbi",
            "ofs_of_node(dn.node_page) != ofs_of_node(page)"
          ],
          "line": 379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f2fs_bug_on",
          "args": [
            "sbi",
            "ni.ino != ino_of_node(page)"
          ],
          "line": 378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ino_of_node",
          "args": [
            "page"
          ],
          "line": 378
        },
        "resolved": true,
        "details": {
          "function_name": "ino_of_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.h",
          "lines": "247-251",
          "snippet": "static inline nid_t ino_of_node(struct page *node_page)\n{\n\tstruct f2fs_node *rn = F2FS_NODE(node_page);\n\treturn le32_to_cpu(rn->footer.ino);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline nid_t ino_of_node(struct page *node_page)\n{\n\tstruct f2fs_node *rn = F2FS_NODE(node_page);\n\treturn le32_to_cpu(rn->footer.ino);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_node_info",
          "args": [
            "sbi",
            "dn.nid",
            "&ni"
          ],
          "line": 377
        },
        "resolved": true,
        "details": {
          "function_name": "get_node_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
          "lines": "339-387",
          "snippet": "void get_node_info(struct f2fs_sb_info *sbi, nid_t nid, struct node_info *ni)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tstruct curseg_info *curseg = CURSEG_I(sbi, CURSEG_HOT_DATA);\n\tstruct f2fs_summary_block *sum = curseg->sum_blk;\n\tnid_t start_nid = START_NID(nid);\n\tstruct f2fs_nat_block *nat_blk;\n\tstruct page *page = NULL;\n\tstruct f2fs_nat_entry ne;\n\tstruct nat_entry *e;\n\tint i;\n\n\tni->nid = nid;\n\n\t/* Check nat cache */\n\tdown_read(&nm_i->nat_tree_lock);\n\te = __lookup_nat_cache(nm_i, nid);\n\tif (e) {\n\t\tni->ino = nat_get_ino(e);\n\t\tni->blk_addr = nat_get_blkaddr(e);\n\t\tni->version = nat_get_version(e);\n\t}\n\tup_read(&nm_i->nat_tree_lock);\n\tif (e)\n\t\treturn;\n\n\tmemset(&ne, 0, sizeof(struct f2fs_nat_entry));\n\n\t/* Check current segment summary */\n\tmutex_lock(&curseg->curseg_mutex);\n\ti = lookup_journal_in_cursum(sum, NAT_JOURNAL, nid, 0);\n\tif (i >= 0) {\n\t\tne = nat_in_journal(sum, i);\n\t\tnode_info_from_raw_nat(ni, &ne);\n\t}\n\tmutex_unlock(&curseg->curseg_mutex);\n\tif (i >= 0)\n\t\tgoto cache;\n\n\t/* Fill node_info from nat page */\n\tpage = get_current_nat_page(sbi, start_nid);\n\tnat_blk = (struct f2fs_nat_block *)page_address(page);\n\tne = nat_blk->entries[nid - start_nid];\n\tnode_info_from_raw_nat(ni, &ne);\n\tf2fs_put_page(page, 1);\ncache:\n\t/* cache nat entry */\n\tcache_nat_entry(NM_I(sbi), nid, &ne);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mpage.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nvoid get_node_info(struct f2fs_sb_info *sbi, nid_t nid, struct node_info *ni)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tstruct curseg_info *curseg = CURSEG_I(sbi, CURSEG_HOT_DATA);\n\tstruct f2fs_summary_block *sum = curseg->sum_blk;\n\tnid_t start_nid = START_NID(nid);\n\tstruct f2fs_nat_block *nat_blk;\n\tstruct page *page = NULL;\n\tstruct f2fs_nat_entry ne;\n\tstruct nat_entry *e;\n\tint i;\n\n\tni->nid = nid;\n\n\t/* Check nat cache */\n\tdown_read(&nm_i->nat_tree_lock);\n\te = __lookup_nat_cache(nm_i, nid);\n\tif (e) {\n\t\tni->ino = nat_get_ino(e);\n\t\tni->blk_addr = nat_get_blkaddr(e);\n\t\tni->version = nat_get_version(e);\n\t}\n\tup_read(&nm_i->nat_tree_lock);\n\tif (e)\n\t\treturn;\n\n\tmemset(&ne, 0, sizeof(struct f2fs_nat_entry));\n\n\t/* Check current segment summary */\n\tmutex_lock(&curseg->curseg_mutex);\n\ti = lookup_journal_in_cursum(sum, NAT_JOURNAL, nid, 0);\n\tif (i >= 0) {\n\t\tne = nat_in_journal(sum, i);\n\t\tnode_info_from_raw_nat(ni, &ne);\n\t}\n\tmutex_unlock(&curseg->curseg_mutex);\n\tif (i >= 0)\n\t\tgoto cache;\n\n\t/* Fill node_info from nat page */\n\tpage = get_current_nat_page(sbi, start_nid);\n\tnat_blk = (struct f2fs_nat_block *)page_address(page);\n\tne = nat_blk->entries[nid - start_nid];\n\tnode_info_from_raw_nat(ni, &ne);\n\tf2fs_put_page(page, 1);\ncache:\n\t/* cache nat entry */\n\tcache_nat_entry(NM_I(sbi), nid, &ne);\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_wait_on_page_writeback",
          "args": [
            "dn.node_page",
            "NODE"
          ],
          "line": 375
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_wait_on_page_writeback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
          "lines": "1321-1331",
          "snippet": "void f2fs_wait_on_page_writeback(struct page *page,\n\t\t\t\tenum page_type type)\n{\n\tif (PageWriteback(page)) {\n\t\tstruct f2fs_sb_info *sbi = F2FS_P_SB(page);\n\n\t\tif (is_merged_page(sbi, page, type))\n\t\t\tf2fs_submit_merged_bio(sbi, type, WRITE);\n\t\twait_on_page_writeback(page);\n\t}\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"node.h\"",
            "#include \"segment.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kthread.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nvoid f2fs_wait_on_page_writeback(struct page *page,\n\t\t\t\tenum page_type type)\n{\n\tif (PageWriteback(page)) {\n\t\tstruct f2fs_sb_info *sbi = F2FS_P_SB(page);\n\n\t\tif (is_merged_page(sbi, page, type))\n\t\t\tf2fs_submit_merged_bio(sbi, type, WRITE);\n\t\twait_on_page_writeback(page);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_dnode_of_data",
          "args": [
            "&dn",
            "start",
            "ALLOC_NODE"
          ],
          "line": 369
        },
        "resolved": true,
        "details": {
          "function_name": "get_dnode_of_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
          "lines": "473-572",
          "snippet": "int get_dnode_of_data(struct dnode_of_data *dn, pgoff_t index, int mode)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(dn->inode);\n\tstruct page *npage[4];\n\tstruct page *parent = NULL;\n\tint offset[4];\n\tunsigned int noffset[4];\n\tnid_t nids[4];\n\tint level, i;\n\tint err = 0;\n\n\tlevel = get_node_path(F2FS_I(dn->inode), index, offset, noffset);\n\n\tnids[0] = dn->inode->i_ino;\n\tnpage[0] = dn->inode_page;\n\n\tif (!npage[0]) {\n\t\tnpage[0] = get_node_page(sbi, nids[0]);\n\t\tif (IS_ERR(npage[0]))\n\t\t\treturn PTR_ERR(npage[0]);\n\t}\n\n\t/* if inline_data is set, should not report any block indices */\n\tif (f2fs_has_inline_data(dn->inode) && index) {\n\t\terr = -EINVAL;\n\t\tf2fs_put_page(npage[0], 1);\n\t\tgoto release_out;\n\t}\n\n\tparent = npage[0];\n\tif (level != 0)\n\t\tnids[1] = get_nid(parent, offset[0], true);\n\tdn->inode_page = npage[0];\n\tdn->inode_page_locked = true;\n\n\t/* get indirect or direct nodes */\n\tfor (i = 1; i <= level; i++) {\n\t\tbool done = false;\n\n\t\tif (!nids[i] && mode == ALLOC_NODE) {\n\t\t\t/* alloc new node */\n\t\t\tif (!alloc_nid(sbi, &(nids[i]))) {\n\t\t\t\terr = -ENOSPC;\n\t\t\t\tgoto release_pages;\n\t\t\t}\n\n\t\t\tdn->nid = nids[i];\n\t\t\tnpage[i] = new_node_page(dn, noffset[i], NULL);\n\t\t\tif (IS_ERR(npage[i])) {\n\t\t\t\talloc_nid_failed(sbi, nids[i]);\n\t\t\t\terr = PTR_ERR(npage[i]);\n\t\t\t\tgoto release_pages;\n\t\t\t}\n\n\t\t\tset_nid(parent, offset[i - 1], nids[i], i == 1);\n\t\t\talloc_nid_done(sbi, nids[i]);\n\t\t\tdone = true;\n\t\t} else if (mode == LOOKUP_NODE_RA && i == level && level > 1) {\n\t\t\tnpage[i] = get_node_page_ra(parent, offset[i - 1]);\n\t\t\tif (IS_ERR(npage[i])) {\n\t\t\t\terr = PTR_ERR(npage[i]);\n\t\t\t\tgoto release_pages;\n\t\t\t}\n\t\t\tdone = true;\n\t\t}\n\t\tif (i == 1) {\n\t\t\tdn->inode_page_locked = false;\n\t\t\tunlock_page(parent);\n\t\t} else {\n\t\t\tf2fs_put_page(parent, 1);\n\t\t}\n\n\t\tif (!done) {\n\t\t\tnpage[i] = get_node_page(sbi, nids[i]);\n\t\t\tif (IS_ERR(npage[i])) {\n\t\t\t\terr = PTR_ERR(npage[i]);\n\t\t\t\tf2fs_put_page(npage[0], 0);\n\t\t\t\tgoto release_out;\n\t\t\t}\n\t\t}\n\t\tif (i < level) {\n\t\t\tparent = npage[i];\n\t\t\tnids[i + 1] = get_nid(parent, offset[i], false);\n\t\t}\n\t}\n\tdn->nid = nids[level];\n\tdn->ofs_in_node = offset[level];\n\tdn->node_page = npage[level];\n\tdn->data_blkaddr = datablock_addr(dn->node_page, dn->ofs_in_node);\n\treturn 0;\n\nrelease_pages:\n\tf2fs_put_page(parent, 1);\n\tif (i > 1)\n\t\tf2fs_put_page(npage[0], 0);\nrelease_out:\n\tdn->inode_page = NULL;\n\tdn->node_page = NULL;\n\treturn err;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mpage.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nint get_dnode_of_data(struct dnode_of_data *dn, pgoff_t index, int mode)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(dn->inode);\n\tstruct page *npage[4];\n\tstruct page *parent = NULL;\n\tint offset[4];\n\tunsigned int noffset[4];\n\tnid_t nids[4];\n\tint level, i;\n\tint err = 0;\n\n\tlevel = get_node_path(F2FS_I(dn->inode), index, offset, noffset);\n\n\tnids[0] = dn->inode->i_ino;\n\tnpage[0] = dn->inode_page;\n\n\tif (!npage[0]) {\n\t\tnpage[0] = get_node_page(sbi, nids[0]);\n\t\tif (IS_ERR(npage[0]))\n\t\t\treturn PTR_ERR(npage[0]);\n\t}\n\n\t/* if inline_data is set, should not report any block indices */\n\tif (f2fs_has_inline_data(dn->inode) && index) {\n\t\terr = -EINVAL;\n\t\tf2fs_put_page(npage[0], 1);\n\t\tgoto release_out;\n\t}\n\n\tparent = npage[0];\n\tif (level != 0)\n\t\tnids[1] = get_nid(parent, offset[0], true);\n\tdn->inode_page = npage[0];\n\tdn->inode_page_locked = true;\n\n\t/* get indirect or direct nodes */\n\tfor (i = 1; i <= level; i++) {\n\t\tbool done = false;\n\n\t\tif (!nids[i] && mode == ALLOC_NODE) {\n\t\t\t/* alloc new node */\n\t\t\tif (!alloc_nid(sbi, &(nids[i]))) {\n\t\t\t\terr = -ENOSPC;\n\t\t\t\tgoto release_pages;\n\t\t\t}\n\n\t\t\tdn->nid = nids[i];\n\t\t\tnpage[i] = new_node_page(dn, noffset[i], NULL);\n\t\t\tif (IS_ERR(npage[i])) {\n\t\t\t\talloc_nid_failed(sbi, nids[i]);\n\t\t\t\terr = PTR_ERR(npage[i]);\n\t\t\t\tgoto release_pages;\n\t\t\t}\n\n\t\t\tset_nid(parent, offset[i - 1], nids[i], i == 1);\n\t\t\talloc_nid_done(sbi, nids[i]);\n\t\t\tdone = true;\n\t\t} else if (mode == LOOKUP_NODE_RA && i == level && level > 1) {\n\t\t\tnpage[i] = get_node_page_ra(parent, offset[i - 1]);\n\t\t\tif (IS_ERR(npage[i])) {\n\t\t\t\terr = PTR_ERR(npage[i]);\n\t\t\t\tgoto release_pages;\n\t\t\t}\n\t\t\tdone = true;\n\t\t}\n\t\tif (i == 1) {\n\t\t\tdn->inode_page_locked = false;\n\t\t\tunlock_page(parent);\n\t\t} else {\n\t\t\tf2fs_put_page(parent, 1);\n\t\t}\n\n\t\tif (!done) {\n\t\t\tnpage[i] = get_node_page(sbi, nids[i]);\n\t\t\tif (IS_ERR(npage[i])) {\n\t\t\t\terr = PTR_ERR(npage[i]);\n\t\t\t\tf2fs_put_page(npage[0], 0);\n\t\t\t\tgoto release_out;\n\t\t\t}\n\t\t}\n\t\tif (i < level) {\n\t\t\tparent = npage[i];\n\t\t\tnids[i + 1] = get_nid(parent, offset[i], false);\n\t\t}\n\t}\n\tdn->nid = nids[level];\n\tdn->ofs_in_node = offset[level];\n\tdn->node_page = npage[level];\n\tdn->data_blkaddr = datablock_addr(dn->node_page, dn->ofs_in_node);\n\treturn 0;\n\nrelease_pages:\n\tf2fs_put_page(parent, 1);\n\tif (i > 1)\n\t\tf2fs_put_page(npage[0], 0);\nrelease_out:\n\tdn->inode_page = NULL;\n\tdn->node_page = NULL;\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_new_dnode",
          "args": [
            "&dn",
            "inode",
            "NULL",
            "NULL",
            "0"
          ],
          "line": 367
        },
        "resolved": true,
        "details": {
          "function_name": "set_new_dnode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "381-389",
          "snippet": "static inline void set_new_dnode(struct dnode_of_data *dn, struct inode *inode,\n\t\tstruct page *ipage, struct page *npage, nid_t nid)\n{\n\tmemset(dn, 0, sizeof(*dn));\n\tdn->inode = inode;\n\tdn->inode_page = ipage;\n\tdn->node_page = npage;\n\tdn->nid = nid;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void set_new_dnode(struct dnode_of_data *dn, struct inode *inode,\n\t\tstruct page *ipage, struct page *npage, nid_t nid)\n{\n\tmemset(dn, 0, sizeof(*dn));\n\tdn->inode = inode;\n\tdn->inode_page = ipage;\n\tdn->node_page = npage;\n\tdn->nid = nid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_lock_op",
          "args": [
            "sbi"
          ],
          "line": 365
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_lock_op",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "755-758",
          "snippet": "static inline void f2fs_lock_op(struct f2fs_sb_info *sbi)\n{\n\tdown_read(&sbi->cp_rwsem);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void f2fs_lock_op(struct f2fs_sb_info *sbi)\n{\n\tdown_read(&sbi->cp_rwsem);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ADDRS_PER_PAGE",
          "args": [
            "page",
            "fi"
          ],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "start_bidx_of_node",
          "args": [
            "ofs_of_node(page)",
            "fi"
          ],
          "line": 362
        },
        "resolved": true,
        "details": {
          "function_name": "start_bidx_of_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/gc.c",
          "lines": "470-488",
          "snippet": "block_t start_bidx_of_node(unsigned int node_ofs, struct f2fs_inode_info *fi)\n{\n\tunsigned int indirect_blks = 2 * NIDS_PER_BLOCK + 4;\n\tunsigned int bidx;\n\n\tif (node_ofs == 0)\n\t\treturn 0;\n\n\tif (node_ofs <= 2) {\n\t\tbidx = node_ofs - 1;\n\t} else if (node_ofs <= indirect_blks) {\n\t\tint dec = (node_ofs - 4) / (NIDS_PER_BLOCK + 1);\n\t\tbidx = node_ofs - 2 - dec;\n\t} else {\n\t\tint dec = (node_ofs - indirect_blks - 3) / (NIDS_PER_BLOCK + 1);\n\t\tbidx = node_ofs - 5 - dec;\n\t}\n\treturn bidx * ADDRS_PER_BLOCK + ADDRS_PER_INODE(fi);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"gc.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/freezer.h>",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/init.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"gc.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/blkdev.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/f2fs_fs.h>\n#include <linux/init.h>\n#include <linux/backing-dev.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\nblock_t start_bidx_of_node(unsigned int node_ofs, struct f2fs_inode_info *fi)\n{\n\tunsigned int indirect_blks = 2 * NIDS_PER_BLOCK + 4;\n\tunsigned int bidx;\n\n\tif (node_ofs == 0)\n\t\treturn 0;\n\n\tif (node_ofs <= 2) {\n\t\tbidx = node_ofs - 1;\n\t} else if (node_ofs <= indirect_blks) {\n\t\tint dec = (node_ofs - 4) / (NIDS_PER_BLOCK + 1);\n\t\tbidx = node_ofs - 2 - dec;\n\t} else {\n\t\tint dec = (node_ofs - indirect_blks - 3) / (NIDS_PER_BLOCK + 1);\n\t\tbidx = node_ofs - 5 - dec;\n\t}\n\treturn bidx * ADDRS_PER_BLOCK + ADDRS_PER_INODE(fi);\n}"
        }
      },
      {
        "call_info": {
          "callee": "recover_inline_data",
          "args": [
            "inode",
            "page"
          ],
          "line": 358
        },
        "resolved": true,
        "details": {
          "function_name": "recover_inline_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/inline.c",
          "lines": "207-257",
          "snippet": "bool recover_inline_data(struct inode *inode, struct page *npage)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tstruct f2fs_inode *ri = NULL;\n\tvoid *src_addr, *dst_addr;\n\tstruct page *ipage;\n\n\t/*\n\t * The inline_data recovery policy is as follows.\n\t * [prev.] [next] of inline_data flag\n\t *    o       o  -> recover inline_data\n\t *    o       x  -> remove inline_data, and then recover data blocks\n\t *    x       o  -> remove inline_data, and then recover inline_data\n\t *    x       x  -> recover data blocks\n\t */\n\tif (IS_INODE(npage))\n\t\tri = F2FS_INODE(npage);\n\n\tif (f2fs_has_inline_data(inode) &&\n\t\t\tri && (ri->i_inline & F2FS_INLINE_DATA)) {\nprocess_inline:\n\t\tipage = get_node_page(sbi, inode->i_ino);\n\t\tf2fs_bug_on(sbi, IS_ERR(ipage));\n\n\t\tf2fs_wait_on_page_writeback(ipage, NODE);\n\n\t\tsrc_addr = inline_data_addr(npage);\n\t\tdst_addr = inline_data_addr(ipage);\n\t\tmemcpy(dst_addr, src_addr, MAX_INLINE_DATA);\n\n\t\tset_inode_flag(F2FS_I(inode), FI_INLINE_DATA);\n\t\tset_inode_flag(F2FS_I(inode), FI_DATA_EXIST);\n\n\t\tupdate_inode(inode, ipage);\n\t\tf2fs_put_page(ipage, 1);\n\t\treturn true;\n\t}\n\n\tif (f2fs_has_inline_data(inode)) {\n\t\tipage = get_node_page(sbi, inode->i_ino);\n\t\tf2fs_bug_on(sbi, IS_ERR(ipage));\n\t\ttruncate_inline_data(ipage);\n\t\tf2fs_clear_inline_inode(inode);\n\t\tupdate_inode(inode, ipage);\n\t\tf2fs_put_page(ipage, 1);\n\t} else if (ri && (ri->i_inline & F2FS_INLINE_DATA)) {\n\t\ttruncate_blocks(inode, 0, false);\n\t\tgoto process_inline;\n\t}\n\treturn false;\n}",
          "includes": [
            "#include \"f2fs.h\"",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"f2fs.h\"\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nbool recover_inline_data(struct inode *inode, struct page *npage)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tstruct f2fs_inode *ri = NULL;\n\tvoid *src_addr, *dst_addr;\n\tstruct page *ipage;\n\n\t/*\n\t * The inline_data recovery policy is as follows.\n\t * [prev.] [next] of inline_data flag\n\t *    o       o  -> recover inline_data\n\t *    o       x  -> remove inline_data, and then recover data blocks\n\t *    x       o  -> remove inline_data, and then recover inline_data\n\t *    x       x  -> recover data blocks\n\t */\n\tif (IS_INODE(npage))\n\t\tri = F2FS_INODE(npage);\n\n\tif (f2fs_has_inline_data(inode) &&\n\t\t\tri && (ri->i_inline & F2FS_INLINE_DATA)) {\nprocess_inline:\n\t\tipage = get_node_page(sbi, inode->i_ino);\n\t\tf2fs_bug_on(sbi, IS_ERR(ipage));\n\n\t\tf2fs_wait_on_page_writeback(ipage, NODE);\n\n\t\tsrc_addr = inline_data_addr(npage);\n\t\tdst_addr = inline_data_addr(ipage);\n\t\tmemcpy(dst_addr, src_addr, MAX_INLINE_DATA);\n\n\t\tset_inode_flag(F2FS_I(inode), FI_INLINE_DATA);\n\t\tset_inode_flag(F2FS_I(inode), FI_DATA_EXIST);\n\n\t\tupdate_inode(inode, ipage);\n\t\tf2fs_put_page(ipage, 1);\n\t\treturn true;\n\t}\n\n\tif (f2fs_has_inline_data(inode)) {\n\t\tipage = get_node_page(sbi, inode->i_ino);\n\t\tf2fs_bug_on(sbi, IS_ERR(ipage));\n\t\ttruncate_inline_data(ipage);\n\t\tf2fs_clear_inline_inode(inode);\n\t\tupdate_inode(inode, ipage);\n\t\tf2fs_put_page(ipage, 1);\n\t} else if (ri && (ri->i_inline & F2FS_INLINE_DATA)) {\n\t\ttruncate_blocks(inode, 0, false);\n\t\tgoto process_inline;\n\t}\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "recover_xattr_data",
          "args": [
            "inode",
            "page",
            "blkaddr"
          ],
          "line": 353
        },
        "resolved": true,
        "details": {
          "function_name": "recover_xattr_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
          "lines": "1651-1685",
          "snippet": "void recover_xattr_data(struct inode *inode, struct page *page, block_t blkaddr)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tnid_t prev_xnid = F2FS_I(inode)->i_xattr_nid;\n\tnid_t new_xnid = nid_of_node(page);\n\tstruct node_info ni;\n\n\t/* 1: invalidate the previous xattr nid */\n\tif (!prev_xnid)\n\t\tgoto recover_xnid;\n\n\t/* Deallocate node address */\n\tget_node_info(sbi, prev_xnid, &ni);\n\tf2fs_bug_on(sbi, ni.blk_addr == NULL_ADDR);\n\tinvalidate_blocks(sbi, ni.blk_addr);\n\tdec_valid_node_count(sbi, inode);\n\tset_node_addr(sbi, &ni, NULL_ADDR, false);\n\nrecover_xnid:\n\t/* 2: allocate new xattr nid */\n\tif (unlikely(!inc_valid_node_count(sbi, inode)))\n\t\tf2fs_bug_on(sbi, 1);\n\n\tremove_free_nid(NM_I(sbi), new_xnid);\n\tget_node_info(sbi, new_xnid, &ni);\n\tni.ino = inode->i_ino;\n\tset_node_addr(sbi, &ni, NEW_ADDR, false);\n\tF2FS_I(inode)->i_xattr_nid = new_xnid;\n\n\t/* 3: update xattr blkaddr */\n\trefresh_sit_entry(sbi, NEW_ADDR, blkaddr);\n\tset_node_addr(sbi, &ni, blkaddr, false);\n\n\tupdate_inode_page(inode);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mpage.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nvoid recover_xattr_data(struct inode *inode, struct page *page, block_t blkaddr)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tnid_t prev_xnid = F2FS_I(inode)->i_xattr_nid;\n\tnid_t new_xnid = nid_of_node(page);\n\tstruct node_info ni;\n\n\t/* 1: invalidate the previous xattr nid */\n\tif (!prev_xnid)\n\t\tgoto recover_xnid;\n\n\t/* Deallocate node address */\n\tget_node_info(sbi, prev_xnid, &ni);\n\tf2fs_bug_on(sbi, ni.blk_addr == NULL_ADDR);\n\tinvalidate_blocks(sbi, ni.blk_addr);\n\tdec_valid_node_count(sbi, inode);\n\tset_node_addr(sbi, &ni, NULL_ADDR, false);\n\nrecover_xnid:\n\t/* 2: allocate new xattr nid */\n\tif (unlikely(!inc_valid_node_count(sbi, inode)))\n\t\tf2fs_bug_on(sbi, 1);\n\n\tremove_free_nid(NM_I(sbi), new_xnid);\n\tget_node_info(sbi, new_xnid, &ni);\n\tni.ino = inode->i_ino;\n\tset_node_addr(sbi, &ni, NEW_ADDR, false);\n\tF2FS_I(inode)->i_xattr_nid = new_xnid;\n\n\t/* 3: update xattr blkaddr */\n\trefresh_sit_entry(sbi, NEW_ADDR, blkaddr);\n\tset_node_addr(sbi, &ni, blkaddr, false);\n\n\tupdate_inode_page(inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_has_xattr_block",
          "args": [
            "ofs_of_node(page)"
          ],
          "line": 348
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_has_xattr_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "822-825",
          "snippet": "static inline bool f2fs_has_xattr_block(unsigned int ofs)\n{\n\treturn ofs == XATTR_NODE_OFFSET;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define XATTR_NODE_OFFSET\t((((unsigned int)-1) << OFFSET_BIT_SHIFT) \\\n\t\t\t\t>> OFFSET_BIT_SHIFT)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\n#define XATTR_NODE_OFFSET\t((((unsigned int)-1) << OFFSET_BIT_SHIFT) \\\n\t\t\t\t>> OFFSET_BIT_SHIFT)\n\nstatic inline bool f2fs_has_xattr_block(unsigned int ofs)\n{\n\treturn ofs == XATTR_NODE_OFFSET;\n}"
        }
      },
      {
        "call_info": {
          "callee": "recover_inline_xattr",
          "args": [
            "inode",
            "page"
          ],
          "line": 347
        },
        "resolved": true,
        "details": {
          "function_name": "recover_inline_xattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
          "lines": "1624-1649",
          "snippet": "void recover_inline_xattr(struct inode *inode, struct page *page)\n{\n\tvoid *src_addr, *dst_addr;\n\tsize_t inline_size;\n\tstruct page *ipage;\n\tstruct f2fs_inode *ri;\n\n\tipage = get_node_page(F2FS_I_SB(inode), inode->i_ino);\n\tf2fs_bug_on(F2FS_I_SB(inode), IS_ERR(ipage));\n\n\tri = F2FS_INODE(page);\n\tif (!(ri->i_inline & F2FS_INLINE_XATTR)) {\n\t\tclear_inode_flag(F2FS_I(inode), FI_INLINE_XATTR);\n\t\tgoto update_inode;\n\t}\n\n\tdst_addr = inline_xattr_addr(ipage);\n\tsrc_addr = inline_xattr_addr(page);\n\tinline_size = inline_xattr_size(inode);\n\n\tf2fs_wait_on_page_writeback(ipage, NODE);\n\tmemcpy(dst_addr, src_addr, inline_size);\nupdate_inode:\n\tupdate_inode(inode, ipage);\n\tf2fs_put_page(ipage, 1);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mpage.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nvoid recover_inline_xattr(struct inode *inode, struct page *page)\n{\n\tvoid *src_addr, *dst_addr;\n\tsize_t inline_size;\n\tstruct page *ipage;\n\tstruct f2fs_inode *ri;\n\n\tipage = get_node_page(F2FS_I_SB(inode), inode->i_ino);\n\tf2fs_bug_on(F2FS_I_SB(inode), IS_ERR(ipage));\n\n\tri = F2FS_INODE(page);\n\tif (!(ri->i_inline & F2FS_INLINE_XATTR)) {\n\t\tclear_inode_flag(F2FS_I(inode), FI_INLINE_XATTR);\n\t\tgoto update_inode;\n\t}\n\n\tdst_addr = inline_xattr_addr(ipage);\n\tsrc_addr = inline_xattr_addr(page);\n\tinline_size = inline_xattr_size(inode);\n\n\tf2fs_wait_on_page_writeback(ipage, NODE);\n\tmemcpy(dst_addr, src_addr, inline_size);\nupdate_inode:\n\tupdate_inode(inode, ipage);\n\tf2fs_put_page(ipage, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "F2FS_I",
          "args": [
            "inode"
          ],
          "line": 338
        },
        "resolved": true,
        "details": {
          "function_name": "F2FS_INODE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "675-678",
          "snippet": "static inline struct f2fs_inode *F2FS_INODE(struct page *page)\n{\n\treturn &((struct f2fs_node *)page_address(page))->i;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_inode *F2FS_INODE(struct page *page)\n{\n\treturn &((struct f2fs_node *)page_address(page))->i;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic int do_recover_data(struct f2fs_sb_info *sbi, struct inode *inode,\n\t\t\t\t\tstruct page *page, block_t blkaddr)\n{\n\tstruct f2fs_inode_info *fi = F2FS_I(inode);\n\tunsigned int start, end;\n\tstruct dnode_of_data dn;\n\tstruct f2fs_summary sum;\n\tstruct node_info ni;\n\tint err = 0, recovered = 0;\n\n\t/* step 1: recover xattr */\n\tif (IS_INODE(page)) {\n\t\trecover_inline_xattr(inode, page);\n\t} else if (f2fs_has_xattr_block(ofs_of_node(page))) {\n\t\t/*\n\t\t * Deprecated; xattr blocks should be found from cold log.\n\t\t * But, we should remain this for backward compatibility.\n\t\t */\n\t\trecover_xattr_data(inode, page, blkaddr);\n\t\tgoto out;\n\t}\n\n\t/* step 2: recover inline data */\n\tif (recover_inline_data(inode, page))\n\t\tgoto out;\n\n\t/* step 3: recover data indices */\n\tstart = start_bidx_of_node(ofs_of_node(page), fi);\n\tend = start + ADDRS_PER_PAGE(page, fi);\n\n\tf2fs_lock_op(sbi);\n\n\tset_new_dnode(&dn, inode, NULL, NULL, 0);\n\n\terr = get_dnode_of_data(&dn, start, ALLOC_NODE);\n\tif (err) {\n\t\tf2fs_unlock_op(sbi);\n\t\tgoto out;\n\t}\n\n\tf2fs_wait_on_page_writeback(dn.node_page, NODE);\n\n\tget_node_info(sbi, dn.nid, &ni);\n\tf2fs_bug_on(sbi, ni.ino != ino_of_node(page));\n\tf2fs_bug_on(sbi, ofs_of_node(dn.node_page) != ofs_of_node(page));\n\n\tfor (; start < end; start++) {\n\t\tblock_t src, dest;\n\n\t\tsrc = datablock_addr(dn.node_page, dn.ofs_in_node);\n\t\tdest = datablock_addr(page, dn.ofs_in_node);\n\n\t\tif (src != dest && dest != NEW_ADDR && dest != NULL_ADDR) {\n\t\t\tif (src == NULL_ADDR) {\n\t\t\t\terr = reserve_new_block(&dn);\n\t\t\t\t/* We should not get -ENOSPC */\n\t\t\t\tf2fs_bug_on(sbi, err);\n\t\t\t}\n\n\t\t\t/* Check the previous node page having this index */\n\t\t\terr = check_index_in_prev_nodes(sbi, dest, &dn);\n\t\t\tif (err)\n\t\t\t\tgoto err;\n\n\t\t\tset_summary(&sum, dn.nid, dn.ofs_in_node, ni.version);\n\n\t\t\t/* write dummy data page */\n\t\t\trecover_data_page(sbi, NULL, &sum, src, dest);\n\t\t\tdn.data_blkaddr = dest;\n\t\t\tupdate_extent_cache(&dn);\n\t\t\trecovered++;\n\t\t}\n\t\tdn.ofs_in_node++;\n\t}\n\n\t/* write node page in place */\n\tset_summary(&sum, dn.nid, 0, 0);\n\tif (IS_INODE(dn.node_page))\n\t\tsync_inode_page(&dn);\n\n\tcopy_node_footer(dn.node_page, page);\n\tfill_node_footer(dn.node_page, dn.nid, ni.ino,\n\t\t\t\t\tofs_of_node(page), false);\n\tset_page_dirty(dn.node_page);\nerr:\n\tf2fs_put_dnode(&dn);\n\tf2fs_unlock_op(sbi);\nout:\n\tf2fs_msg(sbi->sb, KERN_NOTICE,\n\t\t\"recover_data: ino = %lx, recovered = %d blocks, err = %d\",\n\t\tinode->i_ino, recovered, err);\n\treturn err;\n}"
  },
  {
    "function_name": "check_index_in_prev_nodes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/recovery.c",
    "lines": "250-333",
    "snippet": "static int check_index_in_prev_nodes(struct f2fs_sb_info *sbi,\n\t\t\tblock_t blkaddr, struct dnode_of_data *dn)\n{\n\tstruct seg_entry *sentry;\n\tunsigned int segno = GET_SEGNO(sbi, blkaddr);\n\tunsigned short blkoff = GET_BLKOFF_FROM_SEG0(sbi, blkaddr);\n\tstruct f2fs_summary_block *sum_node;\n\tstruct f2fs_summary sum;\n\tstruct page *sum_page, *node_page;\n\tnid_t ino, nid;\n\tstruct inode *inode;\n\tunsigned int offset;\n\tblock_t bidx;\n\tint i;\n\n\tsentry = get_seg_entry(sbi, segno);\n\tif (!f2fs_test_bit(blkoff, sentry->cur_valid_map))\n\t\treturn 0;\n\n\t/* Get the previous summary */\n\tfor (i = CURSEG_WARM_DATA; i <= CURSEG_COLD_DATA; i++) {\n\t\tstruct curseg_info *curseg = CURSEG_I(sbi, i);\n\t\tif (curseg->segno == segno) {\n\t\t\tsum = curseg->sum_blk->entries[blkoff];\n\t\t\tgoto got_it;\n\t\t}\n\t}\n\n\tsum_page = get_sum_page(sbi, segno);\n\tsum_node = (struct f2fs_summary_block *)page_address(sum_page);\n\tsum = sum_node->entries[blkoff];\n\tf2fs_put_page(sum_page, 1);\ngot_it:\n\t/* Use the locked dnode page and inode */\n\tnid = le32_to_cpu(sum.nid);\n\tif (dn->inode->i_ino == nid) {\n\t\tstruct dnode_of_data tdn = *dn;\n\t\ttdn.nid = nid;\n\t\ttdn.node_page = dn->inode_page;\n\t\ttdn.ofs_in_node = le16_to_cpu(sum.ofs_in_node);\n\t\ttruncate_data_blocks_range(&tdn, 1);\n\t\treturn 0;\n\t} else if (dn->nid == nid) {\n\t\tstruct dnode_of_data tdn = *dn;\n\t\ttdn.ofs_in_node = le16_to_cpu(sum.ofs_in_node);\n\t\ttruncate_data_blocks_range(&tdn, 1);\n\t\treturn 0;\n\t}\n\n\t/* Get the node page */\n\tnode_page = get_node_page(sbi, nid);\n\tif (IS_ERR(node_page))\n\t\treturn PTR_ERR(node_page);\n\n\toffset = ofs_of_node(node_page);\n\tino = ino_of_node(node_page);\n\tf2fs_put_page(node_page, 1);\n\n\tif (ino != dn->inode->i_ino) {\n\t\t/* Deallocate previous index in the node page */\n\t\tinode = f2fs_iget(sbi->sb, ino);\n\t\tif (IS_ERR(inode))\n\t\t\treturn PTR_ERR(inode);\n\t} else {\n\t\tinode = dn->inode;\n\t}\n\n\tbidx = start_bidx_of_node(offset, F2FS_I(inode)) +\n\t\t\tle16_to_cpu(sum.ofs_in_node);\n\n\tif (ino != dn->inode->i_ino) {\n\t\ttruncate_hole(inode, bidx, bidx + 1);\n\t\tiput(inode);\n\t} else {\n\t\tstruct dnode_of_data tdn;\n\t\tset_new_dnode(&tdn, inode, dn->inode_page, NULL, 0);\n\t\tif (get_dnode_of_data(&tdn, bidx, LOOKUP_NODE))\n\t\t\treturn 0;\n\t\tif (tdn.data_blkaddr != NULL_ADDR)\n\t\t\ttruncate_data_blocks_range(&tdn, 1);\n\t\tf2fs_put_page(tdn.node_page, 1);\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "f2fs_put_page",
          "args": [
            "tdn.node_page",
            "1"
          ],
          "line": 330
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_put_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1036-1046",
          "snippet": "static inline void f2fs_put_page(struct page *page, int unlock)\n{\n\tif (!page)\n\t\treturn;\n\n\tif (unlock) {\n\t\tf2fs_bug_on(F2FS_P_SB(page), !PageLocked(page));\n\t\tunlock_page(page);\n\t}\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void f2fs_put_page(struct page *page, int unlock)\n{\n\tif (!page)\n\t\treturn;\n\n\tif (unlock) {\n\t\tf2fs_bug_on(F2FS_P_SB(page), !PageLocked(page));\n\t\tunlock_page(page);\n\t}\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "truncate_data_blocks_range",
          "args": [
            "&tdn",
            "1"
          ],
          "line": 329
        },
        "resolved": true,
        "details": {
          "function_name": "truncate_data_blocks_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/file.c",
          "lines": "420-450",
          "snippet": "int truncate_data_blocks_range(struct dnode_of_data *dn, int count)\n{\n\tint nr_free = 0, ofs = dn->ofs_in_node;\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(dn->inode);\n\tstruct f2fs_node *raw_node;\n\t__le32 *addr;\n\n\traw_node = F2FS_NODE(dn->node_page);\n\taddr = blkaddr_in_node(raw_node) + ofs;\n\n\tfor (; count > 0; count--, addr++, dn->ofs_in_node++) {\n\t\tblock_t blkaddr = le32_to_cpu(*addr);\n\t\tif (blkaddr == NULL_ADDR)\n\t\t\tcontinue;\n\n\t\tdn->data_blkaddr = NULL_ADDR;\n\t\tupdate_extent_cache(dn);\n\t\tinvalidate_blocks(sbi, blkaddr);\n\t\tnr_free++;\n\t}\n\tif (nr_free) {\n\t\tdec_valid_block_count(sbi, dn->inode, nr_free);\n\t\tset_page_dirty(dn->node_page);\n\t\tsync_inode_page(dn);\n\t}\n\tdn->ofs_in_node = ofs;\n\n\ttrace_f2fs_truncate_data_blocks_range(dn->inode, dn->nid,\n\t\t\t\t\t dn->ofs_in_node, nr_free);\n\treturn nr_free;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/pagevec.h>",
            "#include <linux/mount.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/types.h>",
            "#include <linux/falloc.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/stat.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/pagevec.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/types.h>\n#include <linux/falloc.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/stat.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nint truncate_data_blocks_range(struct dnode_of_data *dn, int count)\n{\n\tint nr_free = 0, ofs = dn->ofs_in_node;\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(dn->inode);\n\tstruct f2fs_node *raw_node;\n\t__le32 *addr;\n\n\traw_node = F2FS_NODE(dn->node_page);\n\taddr = blkaddr_in_node(raw_node) + ofs;\n\n\tfor (; count > 0; count--, addr++, dn->ofs_in_node++) {\n\t\tblock_t blkaddr = le32_to_cpu(*addr);\n\t\tif (blkaddr == NULL_ADDR)\n\t\t\tcontinue;\n\n\t\tdn->data_blkaddr = NULL_ADDR;\n\t\tupdate_extent_cache(dn);\n\t\tinvalidate_blocks(sbi, blkaddr);\n\t\tnr_free++;\n\t}\n\tif (nr_free) {\n\t\tdec_valid_block_count(sbi, dn->inode, nr_free);\n\t\tset_page_dirty(dn->node_page);\n\t\tsync_inode_page(dn);\n\t}\n\tdn->ofs_in_node = ofs;\n\n\ttrace_f2fs_truncate_data_blocks_range(dn->inode, dn->nid,\n\t\t\t\t\t dn->ofs_in_node, nr_free);\n\treturn nr_free;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_dnode_of_data",
          "args": [
            "&tdn",
            "bidx",
            "LOOKUP_NODE"
          ],
          "line": 326
        },
        "resolved": true,
        "details": {
          "function_name": "get_dnode_of_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
          "lines": "473-572",
          "snippet": "int get_dnode_of_data(struct dnode_of_data *dn, pgoff_t index, int mode)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(dn->inode);\n\tstruct page *npage[4];\n\tstruct page *parent = NULL;\n\tint offset[4];\n\tunsigned int noffset[4];\n\tnid_t nids[4];\n\tint level, i;\n\tint err = 0;\n\n\tlevel = get_node_path(F2FS_I(dn->inode), index, offset, noffset);\n\n\tnids[0] = dn->inode->i_ino;\n\tnpage[0] = dn->inode_page;\n\n\tif (!npage[0]) {\n\t\tnpage[0] = get_node_page(sbi, nids[0]);\n\t\tif (IS_ERR(npage[0]))\n\t\t\treturn PTR_ERR(npage[0]);\n\t}\n\n\t/* if inline_data is set, should not report any block indices */\n\tif (f2fs_has_inline_data(dn->inode) && index) {\n\t\terr = -EINVAL;\n\t\tf2fs_put_page(npage[0], 1);\n\t\tgoto release_out;\n\t}\n\n\tparent = npage[0];\n\tif (level != 0)\n\t\tnids[1] = get_nid(parent, offset[0], true);\n\tdn->inode_page = npage[0];\n\tdn->inode_page_locked = true;\n\n\t/* get indirect or direct nodes */\n\tfor (i = 1; i <= level; i++) {\n\t\tbool done = false;\n\n\t\tif (!nids[i] && mode == ALLOC_NODE) {\n\t\t\t/* alloc new node */\n\t\t\tif (!alloc_nid(sbi, &(nids[i]))) {\n\t\t\t\terr = -ENOSPC;\n\t\t\t\tgoto release_pages;\n\t\t\t}\n\n\t\t\tdn->nid = nids[i];\n\t\t\tnpage[i] = new_node_page(dn, noffset[i], NULL);\n\t\t\tif (IS_ERR(npage[i])) {\n\t\t\t\talloc_nid_failed(sbi, nids[i]);\n\t\t\t\terr = PTR_ERR(npage[i]);\n\t\t\t\tgoto release_pages;\n\t\t\t}\n\n\t\t\tset_nid(parent, offset[i - 1], nids[i], i == 1);\n\t\t\talloc_nid_done(sbi, nids[i]);\n\t\t\tdone = true;\n\t\t} else if (mode == LOOKUP_NODE_RA && i == level && level > 1) {\n\t\t\tnpage[i] = get_node_page_ra(parent, offset[i - 1]);\n\t\t\tif (IS_ERR(npage[i])) {\n\t\t\t\terr = PTR_ERR(npage[i]);\n\t\t\t\tgoto release_pages;\n\t\t\t}\n\t\t\tdone = true;\n\t\t}\n\t\tif (i == 1) {\n\t\t\tdn->inode_page_locked = false;\n\t\t\tunlock_page(parent);\n\t\t} else {\n\t\t\tf2fs_put_page(parent, 1);\n\t\t}\n\n\t\tif (!done) {\n\t\t\tnpage[i] = get_node_page(sbi, nids[i]);\n\t\t\tif (IS_ERR(npage[i])) {\n\t\t\t\terr = PTR_ERR(npage[i]);\n\t\t\t\tf2fs_put_page(npage[0], 0);\n\t\t\t\tgoto release_out;\n\t\t\t}\n\t\t}\n\t\tif (i < level) {\n\t\t\tparent = npage[i];\n\t\t\tnids[i + 1] = get_nid(parent, offset[i], false);\n\t\t}\n\t}\n\tdn->nid = nids[level];\n\tdn->ofs_in_node = offset[level];\n\tdn->node_page = npage[level];\n\tdn->data_blkaddr = datablock_addr(dn->node_page, dn->ofs_in_node);\n\treturn 0;\n\nrelease_pages:\n\tf2fs_put_page(parent, 1);\n\tif (i > 1)\n\t\tf2fs_put_page(npage[0], 0);\nrelease_out:\n\tdn->inode_page = NULL;\n\tdn->node_page = NULL;\n\treturn err;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mpage.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nint get_dnode_of_data(struct dnode_of_data *dn, pgoff_t index, int mode)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(dn->inode);\n\tstruct page *npage[4];\n\tstruct page *parent = NULL;\n\tint offset[4];\n\tunsigned int noffset[4];\n\tnid_t nids[4];\n\tint level, i;\n\tint err = 0;\n\n\tlevel = get_node_path(F2FS_I(dn->inode), index, offset, noffset);\n\n\tnids[0] = dn->inode->i_ino;\n\tnpage[0] = dn->inode_page;\n\n\tif (!npage[0]) {\n\t\tnpage[0] = get_node_page(sbi, nids[0]);\n\t\tif (IS_ERR(npage[0]))\n\t\t\treturn PTR_ERR(npage[0]);\n\t}\n\n\t/* if inline_data is set, should not report any block indices */\n\tif (f2fs_has_inline_data(dn->inode) && index) {\n\t\terr = -EINVAL;\n\t\tf2fs_put_page(npage[0], 1);\n\t\tgoto release_out;\n\t}\n\n\tparent = npage[0];\n\tif (level != 0)\n\t\tnids[1] = get_nid(parent, offset[0], true);\n\tdn->inode_page = npage[0];\n\tdn->inode_page_locked = true;\n\n\t/* get indirect or direct nodes */\n\tfor (i = 1; i <= level; i++) {\n\t\tbool done = false;\n\n\t\tif (!nids[i] && mode == ALLOC_NODE) {\n\t\t\t/* alloc new node */\n\t\t\tif (!alloc_nid(sbi, &(nids[i]))) {\n\t\t\t\terr = -ENOSPC;\n\t\t\t\tgoto release_pages;\n\t\t\t}\n\n\t\t\tdn->nid = nids[i];\n\t\t\tnpage[i] = new_node_page(dn, noffset[i], NULL);\n\t\t\tif (IS_ERR(npage[i])) {\n\t\t\t\talloc_nid_failed(sbi, nids[i]);\n\t\t\t\terr = PTR_ERR(npage[i]);\n\t\t\t\tgoto release_pages;\n\t\t\t}\n\n\t\t\tset_nid(parent, offset[i - 1], nids[i], i == 1);\n\t\t\talloc_nid_done(sbi, nids[i]);\n\t\t\tdone = true;\n\t\t} else if (mode == LOOKUP_NODE_RA && i == level && level > 1) {\n\t\t\tnpage[i] = get_node_page_ra(parent, offset[i - 1]);\n\t\t\tif (IS_ERR(npage[i])) {\n\t\t\t\terr = PTR_ERR(npage[i]);\n\t\t\t\tgoto release_pages;\n\t\t\t}\n\t\t\tdone = true;\n\t\t}\n\t\tif (i == 1) {\n\t\t\tdn->inode_page_locked = false;\n\t\t\tunlock_page(parent);\n\t\t} else {\n\t\t\tf2fs_put_page(parent, 1);\n\t\t}\n\n\t\tif (!done) {\n\t\t\tnpage[i] = get_node_page(sbi, nids[i]);\n\t\t\tif (IS_ERR(npage[i])) {\n\t\t\t\terr = PTR_ERR(npage[i]);\n\t\t\t\tf2fs_put_page(npage[0], 0);\n\t\t\t\tgoto release_out;\n\t\t\t}\n\t\t}\n\t\tif (i < level) {\n\t\t\tparent = npage[i];\n\t\t\tnids[i + 1] = get_nid(parent, offset[i], false);\n\t\t}\n\t}\n\tdn->nid = nids[level];\n\tdn->ofs_in_node = offset[level];\n\tdn->node_page = npage[level];\n\tdn->data_blkaddr = datablock_addr(dn->node_page, dn->ofs_in_node);\n\treturn 0;\n\nrelease_pages:\n\tf2fs_put_page(parent, 1);\n\tif (i > 1)\n\t\tf2fs_put_page(npage[0], 0);\nrelease_out:\n\tdn->inode_page = NULL;\n\tdn->node_page = NULL;\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_new_dnode",
          "args": [
            "&tdn",
            "inode",
            "dn->inode_page",
            "NULL",
            "0"
          ],
          "line": 325
        },
        "resolved": true,
        "details": {
          "function_name": "set_new_dnode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "381-389",
          "snippet": "static inline void set_new_dnode(struct dnode_of_data *dn, struct inode *inode,\n\t\tstruct page *ipage, struct page *npage, nid_t nid)\n{\n\tmemset(dn, 0, sizeof(*dn));\n\tdn->inode = inode;\n\tdn->inode_page = ipage;\n\tdn->node_page = npage;\n\tdn->nid = nid;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void set_new_dnode(struct dnode_of_data *dn, struct inode *inode,\n\t\tstruct page *ipage, struct page *npage, nid_t nid)\n{\n\tmemset(dn, 0, sizeof(*dn));\n\tdn->inode = inode;\n\tdn->inode_page = ipage;\n\tdn->node_page = npage;\n\tdn->nid = nid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "inode"
          ],
          "line": 322
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "truncate_hole",
          "args": [
            "inode",
            "bidx",
            "bidx + 1"
          ],
          "line": 321
        },
        "resolved": true,
        "details": {
          "function_name": "truncate_hole",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/file.c",
          "lines": "677-698",
          "snippet": "int truncate_hole(struct inode *inode, pgoff_t pg_start, pgoff_t pg_end)\n{\n\tpgoff_t index;\n\tint err;\n\n\tfor (index = pg_start; index < pg_end; index++) {\n\t\tstruct dnode_of_data dn;\n\n\t\tset_new_dnode(&dn, inode, NULL, NULL, 0);\n\t\terr = get_dnode_of_data(&dn, index, LOOKUP_NODE);\n\t\tif (err) {\n\t\t\tif (err == -ENOENT)\n\t\t\t\tcontinue;\n\t\t\treturn err;\n\t\t}\n\n\t\tif (dn.data_blkaddr != NULL_ADDR)\n\t\t\ttruncate_data_blocks_range(&dn, 1);\n\t\tf2fs_put_dnode(&dn);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/pagevec.h>",
            "#include <linux/mount.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/types.h>",
            "#include <linux/falloc.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/stat.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/pagevec.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/types.h>\n#include <linux/falloc.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/stat.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nint truncate_hole(struct inode *inode, pgoff_t pg_start, pgoff_t pg_end)\n{\n\tpgoff_t index;\n\tint err;\n\n\tfor (index = pg_start; index < pg_end; index++) {\n\t\tstruct dnode_of_data dn;\n\n\t\tset_new_dnode(&dn, inode, NULL, NULL, 0);\n\t\terr = get_dnode_of_data(&dn, index, LOOKUP_NODE);\n\t\tif (err) {\n\t\t\tif (err == -ENOENT)\n\t\t\t\tcontinue;\n\t\t\treturn err;\n\t\t}\n\n\t\tif (dn.data_blkaddr != NULL_ADDR)\n\t\t\ttruncate_data_blocks_range(&dn, 1);\n\t\tf2fs_put_dnode(&dn);\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "sum.ofs_in_node"
          ],
          "line": 318
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "start_bidx_of_node",
          "args": [
            "offset",
            "F2FS_I(inode)"
          ],
          "line": 317
        },
        "resolved": true,
        "details": {
          "function_name": "start_bidx_of_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/gc.c",
          "lines": "470-488",
          "snippet": "block_t start_bidx_of_node(unsigned int node_ofs, struct f2fs_inode_info *fi)\n{\n\tunsigned int indirect_blks = 2 * NIDS_PER_BLOCK + 4;\n\tunsigned int bidx;\n\n\tif (node_ofs == 0)\n\t\treturn 0;\n\n\tif (node_ofs <= 2) {\n\t\tbidx = node_ofs - 1;\n\t} else if (node_ofs <= indirect_blks) {\n\t\tint dec = (node_ofs - 4) / (NIDS_PER_BLOCK + 1);\n\t\tbidx = node_ofs - 2 - dec;\n\t} else {\n\t\tint dec = (node_ofs - indirect_blks - 3) / (NIDS_PER_BLOCK + 1);\n\t\tbidx = node_ofs - 5 - dec;\n\t}\n\treturn bidx * ADDRS_PER_BLOCK + ADDRS_PER_INODE(fi);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"gc.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/freezer.h>",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/init.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"gc.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/blkdev.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/f2fs_fs.h>\n#include <linux/init.h>\n#include <linux/backing-dev.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\nblock_t start_bidx_of_node(unsigned int node_ofs, struct f2fs_inode_info *fi)\n{\n\tunsigned int indirect_blks = 2 * NIDS_PER_BLOCK + 4;\n\tunsigned int bidx;\n\n\tif (node_ofs == 0)\n\t\treturn 0;\n\n\tif (node_ofs <= 2) {\n\t\tbidx = node_ofs - 1;\n\t} else if (node_ofs <= indirect_blks) {\n\t\tint dec = (node_ofs - 4) / (NIDS_PER_BLOCK + 1);\n\t\tbidx = node_ofs - 2 - dec;\n\t} else {\n\t\tint dec = (node_ofs - indirect_blks - 3) / (NIDS_PER_BLOCK + 1);\n\t\tbidx = node_ofs - 5 - dec;\n\t}\n\treturn bidx * ADDRS_PER_BLOCK + ADDRS_PER_INODE(fi);\n}"
        }
      },
      {
        "call_info": {
          "callee": "F2FS_I",
          "args": [
            "inode"
          ],
          "line": 317
        },
        "resolved": true,
        "details": {
          "function_name": "F2FS_INODE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "675-678",
          "snippet": "static inline struct f2fs_inode *F2FS_INODE(struct page *page)\n{\n\treturn &((struct f2fs_node *)page_address(page))->i;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_inode *F2FS_INODE(struct page *page)\n{\n\treturn &((struct f2fs_node *)page_address(page))->i;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "inode"
          ],
          "line": 312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "inode"
          ],
          "line": 311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f2fs_iget",
          "args": [
            "sbi->sb",
            "ino"
          ],
          "line": 310
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_iget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/inode.c",
          "lines": "151-206",
          "snippet": "struct inode *f2fs_iget(struct super_block *sb, unsigned long ino)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_SB(sb);\n\tstruct inode *inode;\n\tint ret = 0;\n\n\tinode = iget_locked(sb, ino);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (!(inode->i_state & I_NEW)) {\n\t\ttrace_f2fs_iget(inode);\n\t\treturn inode;\n\t}\n\tif (ino == F2FS_NODE_INO(sbi) || ino == F2FS_META_INO(sbi))\n\t\tgoto make_now;\n\n\tret = do_read_inode(inode);\n\tif (ret)\n\t\tgoto bad_inode;\nmake_now:\n\tif (ino == F2FS_NODE_INO(sbi)) {\n\t\tinode->i_mapping->a_ops = &f2fs_node_aops;\n\t\tmapping_set_gfp_mask(inode->i_mapping, GFP_F2FS_ZERO);\n\t} else if (ino == F2FS_META_INO(sbi)) {\n\t\tinode->i_mapping->a_ops = &f2fs_meta_aops;\n\t\tmapping_set_gfp_mask(inode->i_mapping, GFP_F2FS_ZERO);\n\t} else if (S_ISREG(inode->i_mode)) {\n\t\tinode->i_op = &f2fs_file_inode_operations;\n\t\tinode->i_fop = &f2fs_file_operations;\n\t\tinode->i_mapping->a_ops = &f2fs_dblock_aops;\n\t} else if (S_ISDIR(inode->i_mode)) {\n\t\tinode->i_op = &f2fs_dir_inode_operations;\n\t\tinode->i_fop = &f2fs_dir_operations;\n\t\tinode->i_mapping->a_ops = &f2fs_dblock_aops;\n\t\tmapping_set_gfp_mask(inode->i_mapping, GFP_F2FS_HIGH_ZERO);\n\t} else if (S_ISLNK(inode->i_mode)) {\n\t\tinode->i_op = &f2fs_symlink_inode_operations;\n\t\tinode->i_mapping->a_ops = &f2fs_dblock_aops;\n\t} else if (S_ISCHR(inode->i_mode) || S_ISBLK(inode->i_mode) ||\n\t\t\tS_ISFIFO(inode->i_mode) || S_ISSOCK(inode->i_mode)) {\n\t\tinode->i_op = &f2fs_special_inode_operations;\n\t\tinit_special_inode(inode, inode->i_mode, inode->i_rdev);\n\t} else {\n\t\tret = -EIO;\n\t\tgoto bad_inode;\n\t}\n\tunlock_new_inode(inode);\n\ttrace_f2fs_iget(inode);\n\treturn inode;\n\nbad_inode:\n\tiget_failed(inode);\n\ttrace_f2fs_iget_exit(inode, ret);\n\treturn ERR_PTR(ret);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/bitops.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstruct inode *f2fs_iget(struct super_block *sb, unsigned long ino)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_SB(sb);\n\tstruct inode *inode;\n\tint ret = 0;\n\n\tinode = iget_locked(sb, ino);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (!(inode->i_state & I_NEW)) {\n\t\ttrace_f2fs_iget(inode);\n\t\treturn inode;\n\t}\n\tif (ino == F2FS_NODE_INO(sbi) || ino == F2FS_META_INO(sbi))\n\t\tgoto make_now;\n\n\tret = do_read_inode(inode);\n\tif (ret)\n\t\tgoto bad_inode;\nmake_now:\n\tif (ino == F2FS_NODE_INO(sbi)) {\n\t\tinode->i_mapping->a_ops = &f2fs_node_aops;\n\t\tmapping_set_gfp_mask(inode->i_mapping, GFP_F2FS_ZERO);\n\t} else if (ino == F2FS_META_INO(sbi)) {\n\t\tinode->i_mapping->a_ops = &f2fs_meta_aops;\n\t\tmapping_set_gfp_mask(inode->i_mapping, GFP_F2FS_ZERO);\n\t} else if (S_ISREG(inode->i_mode)) {\n\t\tinode->i_op = &f2fs_file_inode_operations;\n\t\tinode->i_fop = &f2fs_file_operations;\n\t\tinode->i_mapping->a_ops = &f2fs_dblock_aops;\n\t} else if (S_ISDIR(inode->i_mode)) {\n\t\tinode->i_op = &f2fs_dir_inode_operations;\n\t\tinode->i_fop = &f2fs_dir_operations;\n\t\tinode->i_mapping->a_ops = &f2fs_dblock_aops;\n\t\tmapping_set_gfp_mask(inode->i_mapping, GFP_F2FS_HIGH_ZERO);\n\t} else if (S_ISLNK(inode->i_mode)) {\n\t\tinode->i_op = &f2fs_symlink_inode_operations;\n\t\tinode->i_mapping->a_ops = &f2fs_dblock_aops;\n\t} else if (S_ISCHR(inode->i_mode) || S_ISBLK(inode->i_mode) ||\n\t\t\tS_ISFIFO(inode->i_mode) || S_ISSOCK(inode->i_mode)) {\n\t\tinode->i_op = &f2fs_special_inode_operations;\n\t\tinit_special_inode(inode, inode->i_mode, inode->i_rdev);\n\t} else {\n\t\tret = -EIO;\n\t\tgoto bad_inode;\n\t}\n\tunlock_new_inode(inode);\n\ttrace_f2fs_iget(inode);\n\treturn inode;\n\nbad_inode:\n\tiget_failed(inode);\n\ttrace_f2fs_iget_exit(inode, ret);\n\treturn ERR_PTR(ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ino_of_node",
          "args": [
            "node_page"
          ],
          "line": 305
        },
        "resolved": true,
        "details": {
          "function_name": "ino_of_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.h",
          "lines": "247-251",
          "snippet": "static inline nid_t ino_of_node(struct page *node_page)\n{\n\tstruct f2fs_node *rn = F2FS_NODE(node_page);\n\treturn le32_to_cpu(rn->footer.ino);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline nid_t ino_of_node(struct page *node_page)\n{\n\tstruct f2fs_node *rn = F2FS_NODE(node_page);\n\treturn le32_to_cpu(rn->footer.ino);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ofs_of_node",
          "args": [
            "node_page"
          ],
          "line": 304
        },
        "resolved": true,
        "details": {
          "function_name": "ofs_of_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.h",
          "lines": "259-264",
          "snippet": "static inline unsigned int ofs_of_node(struct page *node_page)\n{\n\tstruct f2fs_node *rn = F2FS_NODE(node_page);\n\tunsigned flag = le32_to_cpu(rn->footer.flag);\n\treturn flag >> OFFSET_BIT_SHIFT;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline unsigned int ofs_of_node(struct page *node_page)\n{\n\tstruct f2fs_node *rn = F2FS_NODE(node_page);\n\tunsigned flag = le32_to_cpu(rn->footer.flag);\n\treturn flag >> OFFSET_BIT_SHIFT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "node_page"
          ],
          "line": 302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "node_page"
          ],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_node_page",
          "args": [
            "sbi",
            "nid"
          ],
          "line": 300
        },
        "resolved": true,
        "details": {
          "function_name": "get_node_page_ra",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
          "lines": "1066-1114",
          "snippet": "struct page *get_node_page_ra(struct page *parent, int start)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_P_SB(parent);\n\tstruct blk_plug plug;\n\tstruct page *page;\n\tint err, i, end;\n\tnid_t nid;\n\n\t/* First, try getting the desired direct node. */\n\tnid = get_nid(parent, start, false);\n\tif (!nid)\n\t\treturn ERR_PTR(-ENOENT);\nrepeat:\n\tpage = grab_cache_page(NODE_MAPPING(sbi), nid);\n\tif (!page)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\terr = read_node_page(page, READ_SYNC);\n\tif (err < 0)\n\t\treturn ERR_PTR(err);\n\telse if (err == LOCKED_PAGE)\n\t\tgoto page_hit;\n\n\tblk_start_plug(&plug);\n\n\t/* Then, try readahead for siblings of the desired node */\n\tend = start + MAX_RA_NODE;\n\tend = min(end, NIDS_PER_BLOCK);\n\tfor (i = start + 1; i < end; i++) {\n\t\tnid = get_nid(parent, i, false);\n\t\tif (!nid)\n\t\t\tcontinue;\n\t\tra_node_page(sbi, nid);\n\t}\n\n\tblk_finish_plug(&plug);\n\n\tlock_page(page);\n\tif (unlikely(page->mapping != NODE_MAPPING(sbi))) {\n\t\tf2fs_put_page(page, 1);\n\t\tgoto repeat;\n\t}\npage_hit:\n\tif (unlikely(!PageUptodate(page))) {\n\t\tf2fs_put_page(page, 1);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\treturn page;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mpage.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstruct page *get_node_page_ra(struct page *parent, int start)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_P_SB(parent);\n\tstruct blk_plug plug;\n\tstruct page *page;\n\tint err, i, end;\n\tnid_t nid;\n\n\t/* First, try getting the desired direct node. */\n\tnid = get_nid(parent, start, false);\n\tif (!nid)\n\t\treturn ERR_PTR(-ENOENT);\nrepeat:\n\tpage = grab_cache_page(NODE_MAPPING(sbi), nid);\n\tif (!page)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\terr = read_node_page(page, READ_SYNC);\n\tif (err < 0)\n\t\treturn ERR_PTR(err);\n\telse if (err == LOCKED_PAGE)\n\t\tgoto page_hit;\n\n\tblk_start_plug(&plug);\n\n\t/* Then, try readahead for siblings of the desired node */\n\tend = start + MAX_RA_NODE;\n\tend = min(end, NIDS_PER_BLOCK);\n\tfor (i = start + 1; i < end; i++) {\n\t\tnid = get_nid(parent, i, false);\n\t\tif (!nid)\n\t\t\tcontinue;\n\t\tra_node_page(sbi, nid);\n\t}\n\n\tblk_finish_plug(&plug);\n\n\tlock_page(page);\n\tif (unlikely(page->mapping != NODE_MAPPING(sbi))) {\n\t\tf2fs_put_page(page, 1);\n\t\tgoto repeat;\n\t}\npage_hit:\n\tif (unlikely(!PageUptodate(page))) {\n\t\tf2fs_put_page(page, 1);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\treturn page;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "sum.nid"
          ],
          "line": 284
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "sum_page"
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_sum_page",
          "args": [
            "sbi",
            "segno"
          ],
          "line": 278
        },
        "resolved": true,
        "details": {
          "function_name": "get_sum_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
          "lines": "760-763",
          "snippet": "struct page *get_sum_page(struct f2fs_sb_info *sbi, unsigned int segno)\n{\n\treturn get_meta_page(sbi, GET_SUM_BLOCK(sbi, segno));\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"node.h\"",
            "#include \"segment.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kthread.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstruct page *get_sum_page(struct f2fs_sb_info *sbi, unsigned int segno)\n{\n\treturn get_meta_page(sbi, GET_SUM_BLOCK(sbi, segno));\n}"
        }
      },
      {
        "call_info": {
          "callee": "CURSEG_I",
          "args": [
            "sbi",
            "i"
          ],
          "line": 271
        },
        "resolved": true,
        "details": {
          "function_name": "CURSEG_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.h",
          "lines": "263-266",
          "snippet": "static inline struct curseg_info *CURSEG_I(struct f2fs_sb_info *sbi, int type)\n{\n\treturn (struct curseg_info *)(SM_I(sbi)->curseg_array + type);\n}",
          "includes": [
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/blkdev.h>\n\nstatic inline struct curseg_info *CURSEG_I(struct f2fs_sb_info *sbi, int type)\n{\n\treturn (struct curseg_info *)(SM_I(sbi)->curseg_array + type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_test_bit",
          "args": [
            "blkoff",
            "sentry->cur_valid_map"
          ],
          "line": 266
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_test_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1108-1115",
          "snippet": "static inline int f2fs_test_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\treturn mask & *addr;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int f2fs_test_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\treturn mask & *addr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_seg_entry",
          "args": [
            "sbi",
            "segno"
          ],
          "line": 265
        },
        "resolved": true,
        "details": {
          "function_name": "get_seg_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.h",
          "lines": "268-273",
          "snippet": "static inline struct seg_entry *get_seg_entry(struct f2fs_sb_info *sbi,\n\t\t\t\t\t\tunsigned int segno)\n{\n\tstruct sit_info *sit_i = SIT_I(sbi);\n\treturn &sit_i->sentries[segno];\n}",
          "includes": [
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/blkdev.h>\n\nstatic inline struct seg_entry *get_seg_entry(struct f2fs_sb_info *sbi,\n\t\t\t\t\t\tunsigned int segno)\n{\n\tstruct sit_info *sit_i = SIT_I(sbi);\n\treturn &sit_i->sentries[segno];\n}"
        }
      },
      {
        "call_info": {
          "callee": "GET_BLKOFF_FROM_SEG0",
          "args": [
            "sbi",
            "blkaddr"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GET_SEGNO",
          "args": [
            "sbi",
            "blkaddr"
          ],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic int check_index_in_prev_nodes(struct f2fs_sb_info *sbi,\n\t\t\tblock_t blkaddr, struct dnode_of_data *dn)\n{\n\tstruct seg_entry *sentry;\n\tunsigned int segno = GET_SEGNO(sbi, blkaddr);\n\tunsigned short blkoff = GET_BLKOFF_FROM_SEG0(sbi, blkaddr);\n\tstruct f2fs_summary_block *sum_node;\n\tstruct f2fs_summary sum;\n\tstruct page *sum_page, *node_page;\n\tnid_t ino, nid;\n\tstruct inode *inode;\n\tunsigned int offset;\n\tblock_t bidx;\n\tint i;\n\n\tsentry = get_seg_entry(sbi, segno);\n\tif (!f2fs_test_bit(blkoff, sentry->cur_valid_map))\n\t\treturn 0;\n\n\t/* Get the previous summary */\n\tfor (i = CURSEG_WARM_DATA; i <= CURSEG_COLD_DATA; i++) {\n\t\tstruct curseg_info *curseg = CURSEG_I(sbi, i);\n\t\tif (curseg->segno == segno) {\n\t\t\tsum = curseg->sum_blk->entries[blkoff];\n\t\t\tgoto got_it;\n\t\t}\n\t}\n\n\tsum_page = get_sum_page(sbi, segno);\n\tsum_node = (struct f2fs_summary_block *)page_address(sum_page);\n\tsum = sum_node->entries[blkoff];\n\tf2fs_put_page(sum_page, 1);\ngot_it:\n\t/* Use the locked dnode page and inode */\n\tnid = le32_to_cpu(sum.nid);\n\tif (dn->inode->i_ino == nid) {\n\t\tstruct dnode_of_data tdn = *dn;\n\t\ttdn.nid = nid;\n\t\ttdn.node_page = dn->inode_page;\n\t\ttdn.ofs_in_node = le16_to_cpu(sum.ofs_in_node);\n\t\ttruncate_data_blocks_range(&tdn, 1);\n\t\treturn 0;\n\t} else if (dn->nid == nid) {\n\t\tstruct dnode_of_data tdn = *dn;\n\t\ttdn.ofs_in_node = le16_to_cpu(sum.ofs_in_node);\n\t\ttruncate_data_blocks_range(&tdn, 1);\n\t\treturn 0;\n\t}\n\n\t/* Get the node page */\n\tnode_page = get_node_page(sbi, nid);\n\tif (IS_ERR(node_page))\n\t\treturn PTR_ERR(node_page);\n\n\toffset = ofs_of_node(node_page);\n\tino = ino_of_node(node_page);\n\tf2fs_put_page(node_page, 1);\n\n\tif (ino != dn->inode->i_ino) {\n\t\t/* Deallocate previous index in the node page */\n\t\tinode = f2fs_iget(sbi->sb, ino);\n\t\tif (IS_ERR(inode))\n\t\t\treturn PTR_ERR(inode);\n\t} else {\n\t\tinode = dn->inode;\n\t}\n\n\tbidx = start_bidx_of_node(offset, F2FS_I(inode)) +\n\t\t\tle16_to_cpu(sum.ofs_in_node);\n\n\tif (ino != dn->inode->i_ino) {\n\t\ttruncate_hole(inode, bidx, bidx + 1);\n\t\tiput(inode);\n\t} else {\n\t\tstruct dnode_of_data tdn;\n\t\tset_new_dnode(&tdn, inode, dn->inode_page, NULL, 0);\n\t\tif (get_dnode_of_data(&tdn, bidx, LOOKUP_NODE))\n\t\t\treturn 0;\n\t\tif (tdn.data_blkaddr != NULL_ADDR)\n\t\t\ttruncate_data_blocks_range(&tdn, 1);\n\t\tf2fs_put_page(tdn.node_page, 1);\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "destroy_fsync_dnodes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/recovery.c",
    "lines": "239-248",
    "snippet": "static void destroy_fsync_dnodes(struct list_head *head)\n{\n\tstruct fsync_inode_entry *entry, *tmp;\n\n\tlist_for_each_entry_safe(entry, tmp, head, list) {\n\t\tiput(entry->inode);\n\t\tlist_del(&entry->list);\n\t\tkmem_cache_free(fsync_entry_slab, entry);\n\t}\n}",
    "includes": [
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *fsync_entry_slab;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "fsync_entry_slab",
            "entry"
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&entry->list"
          ],
          "line": 245
        },
        "resolved": true,
        "details": {
          "function_name": "inode_sb_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "433-440",
          "snippet": "static inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\n__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "entry->inode"
          ],
          "line": 244
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "entry",
            "tmp",
            "head",
            "list"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic struct kmem_cache *fsync_entry_slab;\n\nstatic void destroy_fsync_dnodes(struct list_head *head)\n{\n\tstruct fsync_inode_entry *entry, *tmp;\n\n\tlist_for_each_entry_safe(entry, tmp, head, list) {\n\t\tiput(entry->inode);\n\t\tlist_del(&entry->list);\n\t\tkmem_cache_free(fsync_entry_slab, entry);\n\t}\n}"
  },
  {
    "function_name": "find_fsync_dnodes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/recovery.c",
    "lines": "161-237",
    "snippet": "static int find_fsync_dnodes(struct f2fs_sb_info *sbi, struct list_head *head)\n{\n\tunsigned long long cp_ver = cur_cp_version(F2FS_CKPT(sbi));\n\tstruct curseg_info *curseg;\n\tstruct page *page = NULL;\n\tblock_t blkaddr;\n\tint err = 0;\n\n\t/* get node pages in the current segment */\n\tcurseg = CURSEG_I(sbi, CURSEG_WARM_NODE);\n\tblkaddr = NEXT_FREE_BLKADDR(sbi, curseg);\n\n\tra_meta_pages(sbi, blkaddr, 1, META_POR);\n\n\twhile (1) {\n\t\tstruct fsync_inode_entry *entry;\n\n\t\tif (blkaddr < MAIN_BLKADDR(sbi) || blkaddr >= MAX_BLKADDR(sbi))\n\t\t\treturn 0;\n\n\t\tpage = get_meta_page(sbi, blkaddr);\n\n\t\tif (cp_ver != cpver_of_node(page))\n\t\t\tbreak;\n\n\t\tif (!is_fsync_dnode(page))\n\t\t\tgoto next;\n\n\t\tentry = get_fsync_inode(head, ino_of_node(page));\n\t\tif (entry) {\n\t\t\tif (IS_INODE(page) && is_dent_dnode(page))\n\t\t\t\tset_inode_flag(F2FS_I(entry->inode),\n\t\t\t\t\t\t\tFI_INC_LINK);\n\t\t} else {\n\t\t\tif (IS_INODE(page) && is_dent_dnode(page)) {\n\t\t\t\terr = recover_inode_page(sbi, page);\n\t\t\t\tif (err)\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* add this fsync inode to the list */\n\t\t\tentry = kmem_cache_alloc(fsync_entry_slab, GFP_F2FS_ZERO);\n\t\t\tif (!entry) {\n\t\t\t\terr = -ENOMEM;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/*\n\t\t\t * CP | dnode(F) | inode(DF)\n\t\t\t * For this case, we should not give up now.\n\t\t\t */\n\t\t\tentry->inode = f2fs_iget(sbi->sb, ino_of_node(page));\n\t\t\tif (IS_ERR(entry->inode)) {\n\t\t\t\terr = PTR_ERR(entry->inode);\n\t\t\t\tkmem_cache_free(fsync_entry_slab, entry);\n\t\t\t\tif (err == -ENOENT)\n\t\t\t\t\tgoto next;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tlist_add_tail(&entry->list, head);\n\t\t}\n\t\tentry->blkaddr = blkaddr;\n\n\t\tif (IS_INODE(page)) {\n\t\t\tentry->last_inode = blkaddr;\n\t\t\tif (is_dent_dnode(page))\n\t\t\t\tentry->last_dentry = blkaddr;\n\t\t}\nnext:\n\t\t/* check next segment */\n\t\tblkaddr = next_blkaddr_of_node(page);\n\t\tf2fs_put_page(page, 1);\n\n\t\tra_meta_pages_cond(sbi, blkaddr);\n\t}\n\tf2fs_put_page(page, 1);\n\treturn err;\n}",
    "includes": [
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *fsync_entry_slab;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "f2fs_put_page",
          "args": [
            "page",
            "1"
          ],
          "line": 235
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_put_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1036-1046",
          "snippet": "static inline void f2fs_put_page(struct page *page, int unlock)\n{\n\tif (!page)\n\t\treturn;\n\n\tif (unlock) {\n\t\tf2fs_bug_on(F2FS_P_SB(page), !PageLocked(page));\n\t\tunlock_page(page);\n\t}\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void f2fs_put_page(struct page *page, int unlock)\n{\n\tif (!page)\n\t\treturn;\n\n\tif (unlock) {\n\t\tf2fs_bug_on(F2FS_P_SB(page), !PageLocked(page));\n\t\tunlock_page(page);\n\t}\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ra_meta_pages_cond",
          "args": [
            "sbi",
            "blkaddr"
          ],
          "line": 233
        },
        "resolved": true,
        "details": {
          "function_name": "ra_meta_pages_cond",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/checkpoint.c",
          "lines": "172-184",
          "snippet": "void ra_meta_pages_cond(struct f2fs_sb_info *sbi, pgoff_t index)\n{\n\tstruct page *page;\n\tbool readahead = false;\n\n\tpage = find_get_page(META_MAPPING(sbi), index);\n\tif (!page || (page && !PageUptodate(page)))\n\t\treadahead = true;\n\tf2fs_put_page(page, 0);\n\n\tif (readahead)\n\t\tra_meta_pages(sbi, index, MAX_BIO_BLOCKS(sbi), META_POR);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/f2fs_fs.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n\nvoid ra_meta_pages_cond(struct f2fs_sb_info *sbi, pgoff_t index)\n{\n\tstruct page *page;\n\tbool readahead = false;\n\n\tpage = find_get_page(META_MAPPING(sbi), index);\n\tif (!page || (page && !PageUptodate(page)))\n\t\treadahead = true;\n\tf2fs_put_page(page, 0);\n\n\tif (readahead)\n\t\tra_meta_pages(sbi, index, MAX_BIO_BLOCKS(sbi), META_POR);\n}"
        }
      },
      {
        "call_info": {
          "callee": "next_blkaddr_of_node",
          "args": [
            "page"
          ],
          "line": 230
        },
        "resolved": true,
        "details": {
          "function_name": "next_blkaddr_of_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.h",
          "lines": "272-276",
          "snippet": "static inline block_t next_blkaddr_of_node(struct page *node_page)\n{\n\tstruct f2fs_node *rn = F2FS_NODE(node_page);\n\treturn le32_to_cpu(rn->footer.next_blkaddr);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline block_t next_blkaddr_of_node(struct page *node_page)\n{\n\tstruct f2fs_node *rn = F2FS_NODE(node_page);\n\treturn le32_to_cpu(rn->footer.next_blkaddr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_dent_dnode",
          "args": [
            "page"
          ],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_INODE",
          "args": [
            "page"
          ],
          "line": 223
        },
        "resolved": true,
        "details": {
          "function_name": "IS_INODE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1087-1091",
          "snippet": "static inline bool IS_INODE(struct page *page)\n{\n\tstruct f2fs_node *p = F2FS_NODE(page);\n\treturn RAW_IS_INODE(p);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline bool IS_INODE(struct page *page)\n{\n\tstruct f2fs_node *p = F2FS_NODE(page);\n\treturn RAW_IS_INODE(p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&entry->list",
            "head"
          ],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "fsync_entry_slab",
            "entry"
          ],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "entry->inode"
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "entry->inode"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f2fs_iget",
          "args": [
            "sbi->sb",
            "ino_of_node(page)"
          ],
          "line": 211
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_iget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/inode.c",
          "lines": "151-206",
          "snippet": "struct inode *f2fs_iget(struct super_block *sb, unsigned long ino)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_SB(sb);\n\tstruct inode *inode;\n\tint ret = 0;\n\n\tinode = iget_locked(sb, ino);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (!(inode->i_state & I_NEW)) {\n\t\ttrace_f2fs_iget(inode);\n\t\treturn inode;\n\t}\n\tif (ino == F2FS_NODE_INO(sbi) || ino == F2FS_META_INO(sbi))\n\t\tgoto make_now;\n\n\tret = do_read_inode(inode);\n\tif (ret)\n\t\tgoto bad_inode;\nmake_now:\n\tif (ino == F2FS_NODE_INO(sbi)) {\n\t\tinode->i_mapping->a_ops = &f2fs_node_aops;\n\t\tmapping_set_gfp_mask(inode->i_mapping, GFP_F2FS_ZERO);\n\t} else if (ino == F2FS_META_INO(sbi)) {\n\t\tinode->i_mapping->a_ops = &f2fs_meta_aops;\n\t\tmapping_set_gfp_mask(inode->i_mapping, GFP_F2FS_ZERO);\n\t} else if (S_ISREG(inode->i_mode)) {\n\t\tinode->i_op = &f2fs_file_inode_operations;\n\t\tinode->i_fop = &f2fs_file_operations;\n\t\tinode->i_mapping->a_ops = &f2fs_dblock_aops;\n\t} else if (S_ISDIR(inode->i_mode)) {\n\t\tinode->i_op = &f2fs_dir_inode_operations;\n\t\tinode->i_fop = &f2fs_dir_operations;\n\t\tinode->i_mapping->a_ops = &f2fs_dblock_aops;\n\t\tmapping_set_gfp_mask(inode->i_mapping, GFP_F2FS_HIGH_ZERO);\n\t} else if (S_ISLNK(inode->i_mode)) {\n\t\tinode->i_op = &f2fs_symlink_inode_operations;\n\t\tinode->i_mapping->a_ops = &f2fs_dblock_aops;\n\t} else if (S_ISCHR(inode->i_mode) || S_ISBLK(inode->i_mode) ||\n\t\t\tS_ISFIFO(inode->i_mode) || S_ISSOCK(inode->i_mode)) {\n\t\tinode->i_op = &f2fs_special_inode_operations;\n\t\tinit_special_inode(inode, inode->i_mode, inode->i_rdev);\n\t} else {\n\t\tret = -EIO;\n\t\tgoto bad_inode;\n\t}\n\tunlock_new_inode(inode);\n\ttrace_f2fs_iget(inode);\n\treturn inode;\n\nbad_inode:\n\tiget_failed(inode);\n\ttrace_f2fs_iget_exit(inode, ret);\n\treturn ERR_PTR(ret);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/bitops.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstruct inode *f2fs_iget(struct super_block *sb, unsigned long ino)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_SB(sb);\n\tstruct inode *inode;\n\tint ret = 0;\n\n\tinode = iget_locked(sb, ino);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (!(inode->i_state & I_NEW)) {\n\t\ttrace_f2fs_iget(inode);\n\t\treturn inode;\n\t}\n\tif (ino == F2FS_NODE_INO(sbi) || ino == F2FS_META_INO(sbi))\n\t\tgoto make_now;\n\n\tret = do_read_inode(inode);\n\tif (ret)\n\t\tgoto bad_inode;\nmake_now:\n\tif (ino == F2FS_NODE_INO(sbi)) {\n\t\tinode->i_mapping->a_ops = &f2fs_node_aops;\n\t\tmapping_set_gfp_mask(inode->i_mapping, GFP_F2FS_ZERO);\n\t} else if (ino == F2FS_META_INO(sbi)) {\n\t\tinode->i_mapping->a_ops = &f2fs_meta_aops;\n\t\tmapping_set_gfp_mask(inode->i_mapping, GFP_F2FS_ZERO);\n\t} else if (S_ISREG(inode->i_mode)) {\n\t\tinode->i_op = &f2fs_file_inode_operations;\n\t\tinode->i_fop = &f2fs_file_operations;\n\t\tinode->i_mapping->a_ops = &f2fs_dblock_aops;\n\t} else if (S_ISDIR(inode->i_mode)) {\n\t\tinode->i_op = &f2fs_dir_inode_operations;\n\t\tinode->i_fop = &f2fs_dir_operations;\n\t\tinode->i_mapping->a_ops = &f2fs_dblock_aops;\n\t\tmapping_set_gfp_mask(inode->i_mapping, GFP_F2FS_HIGH_ZERO);\n\t} else if (S_ISLNK(inode->i_mode)) {\n\t\tinode->i_op = &f2fs_symlink_inode_operations;\n\t\tinode->i_mapping->a_ops = &f2fs_dblock_aops;\n\t} else if (S_ISCHR(inode->i_mode) || S_ISBLK(inode->i_mode) ||\n\t\t\tS_ISFIFO(inode->i_mode) || S_ISSOCK(inode->i_mode)) {\n\t\tinode->i_op = &f2fs_special_inode_operations;\n\t\tinit_special_inode(inode, inode->i_mode, inode->i_rdev);\n\t} else {\n\t\tret = -EIO;\n\t\tgoto bad_inode;\n\t}\n\tunlock_new_inode(inode);\n\ttrace_f2fs_iget(inode);\n\treturn inode;\n\nbad_inode:\n\tiget_failed(inode);\n\ttrace_f2fs_iget_exit(inode, ret);\n\treturn ERR_PTR(ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ino_of_node",
          "args": [
            "page"
          ],
          "line": 211
        },
        "resolved": true,
        "details": {
          "function_name": "ino_of_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.h",
          "lines": "247-251",
          "snippet": "static inline nid_t ino_of_node(struct page *node_page)\n{\n\tstruct f2fs_node *rn = F2FS_NODE(node_page);\n\treturn le32_to_cpu(rn->footer.ino);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline nid_t ino_of_node(struct page *node_page)\n{\n\tstruct f2fs_node *rn = F2FS_NODE(node_page);\n\treturn le32_to_cpu(rn->footer.ino);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmem_cache_alloc",
          "args": [
            "fsync_entry_slab",
            "GFP_F2FS_ZERO"
          ],
          "line": 202
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_kmem_cache_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1064-1076",
          "snippet": "static inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\nretry:\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry) {\n\t\tcond_resched();\n\t\tgoto retry;\n\t}\n\n\treturn entry;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\nretry:\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry) {\n\t\tcond_resched();\n\t\tgoto retry;\n\t}\n\n\treturn entry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "recover_inode_page",
          "args": [
            "sbi",
            "page"
          ],
          "line": 196
        },
        "resolved": true,
        "details": {
          "function_name": "recover_inode_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
          "lines": "1687-1729",
          "snippet": "int recover_inode_page(struct f2fs_sb_info *sbi, struct page *page)\n{\n\tstruct f2fs_inode *src, *dst;\n\tnid_t ino = ino_of_node(page);\n\tstruct node_info old_ni, new_ni;\n\tstruct page *ipage;\n\n\tget_node_info(sbi, ino, &old_ni);\n\n\tif (unlikely(old_ni.blk_addr != NULL_ADDR))\n\t\treturn -EINVAL;\n\n\tipage = grab_cache_page(NODE_MAPPING(sbi), ino);\n\tif (!ipage)\n\t\treturn -ENOMEM;\n\n\t/* Should not use this inode from free nid list */\n\tremove_free_nid(NM_I(sbi), ino);\n\n\tSetPageUptodate(ipage);\n\tfill_node_footer(ipage, ino, ino, 0, true);\n\n\tsrc = F2FS_INODE(page);\n\tdst = F2FS_INODE(ipage);\n\n\tmemcpy(dst, src, (unsigned long)&src->i_ext - (unsigned long)src);\n\tdst->i_size = 0;\n\tdst->i_blocks = cpu_to_le64(1);\n\tdst->i_links = cpu_to_le32(1);\n\tdst->i_xattr_nid = 0;\n\tdst->i_inline = src->i_inline & F2FS_INLINE_XATTR;\n\n\tnew_ni = old_ni;\n\tnew_ni.ino = ino;\n\n\tif (unlikely(!inc_valid_node_count(sbi, NULL)))\n\t\tWARN_ON(1);\n\tset_node_addr(sbi, &new_ni, NEW_ADDR, false);\n\tinc_valid_inode_count(sbi);\n\tset_page_dirty(ipage);\n\tf2fs_put_page(ipage, 1);\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mpage.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nint recover_inode_page(struct f2fs_sb_info *sbi, struct page *page)\n{\n\tstruct f2fs_inode *src, *dst;\n\tnid_t ino = ino_of_node(page);\n\tstruct node_info old_ni, new_ni;\n\tstruct page *ipage;\n\n\tget_node_info(sbi, ino, &old_ni);\n\n\tif (unlikely(old_ni.blk_addr != NULL_ADDR))\n\t\treturn -EINVAL;\n\n\tipage = grab_cache_page(NODE_MAPPING(sbi), ino);\n\tif (!ipage)\n\t\treturn -ENOMEM;\n\n\t/* Should not use this inode from free nid list */\n\tremove_free_nid(NM_I(sbi), ino);\n\n\tSetPageUptodate(ipage);\n\tfill_node_footer(ipage, ino, ino, 0, true);\n\n\tsrc = F2FS_INODE(page);\n\tdst = F2FS_INODE(ipage);\n\n\tmemcpy(dst, src, (unsigned long)&src->i_ext - (unsigned long)src);\n\tdst->i_size = 0;\n\tdst->i_blocks = cpu_to_le64(1);\n\tdst->i_links = cpu_to_le32(1);\n\tdst->i_xattr_nid = 0;\n\tdst->i_inline = src->i_inline & F2FS_INLINE_XATTR;\n\n\tnew_ni = old_ni;\n\tnew_ni.ino = ino;\n\n\tif (unlikely(!inc_valid_node_count(sbi, NULL)))\n\t\tWARN_ON(1);\n\tset_node_addr(sbi, &new_ni, NEW_ADDR, false);\n\tinc_valid_inode_count(sbi);\n\tset_page_dirty(ipage);\n\tf2fs_put_page(ipage, 1);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_dent_dnode",
          "args": [
            "page"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_inode_flag",
          "args": [
            "F2FS_I(entry->inode)",
            "FI_INC_LINK"
          ],
          "line": 192
        },
        "resolved": true,
        "details": {
          "function_name": "set_inode_flag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1173-1177",
          "snippet": "static inline void set_inode_flag(struct f2fs_inode_info *fi, int flag)\n{\n\tif (!test_bit(flag, &fi->flags))\n\t\tset_bit(flag, &fi->flags);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void set_inode_flag(struct f2fs_inode_info *fi, int flag)\n{\n\tif (!test_bit(flag, &fi->flags))\n\t\tset_bit(flag, &fi->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "F2FS_I",
          "args": [
            "entry->inode"
          ],
          "line": 192
        },
        "resolved": true,
        "details": {
          "function_name": "F2FS_INODE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "675-678",
          "snippet": "static inline struct f2fs_inode *F2FS_INODE(struct page *page)\n{\n\treturn &((struct f2fs_node *)page_address(page))->i;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_inode *F2FS_INODE(struct page *page)\n{\n\treturn &((struct f2fs_node *)page_address(page))->i;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_dent_dnode",
          "args": [
            "page"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_fsync_inode",
          "args": [
            "head",
            "ino_of_node(page)"
          ],
          "line": 189
        },
        "resolved": true,
        "details": {
          "function_name": "get_fsync_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/recovery.c",
          "lines": "58-68",
          "snippet": "static struct fsync_inode_entry *get_fsync_inode(struct list_head *head,\n\t\t\t\t\t\t\t\tnid_t ino)\n{\n\tstruct fsync_inode_entry *entry;\n\n\tlist_for_each_entry(entry, head, list)\n\t\tif (entry->inode->i_ino == ino)\n\t\t\treturn entry;\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic struct fsync_inode_entry *get_fsync_inode(struct list_head *head,\n\t\t\t\t\t\t\t\tnid_t ino)\n{\n\tstruct fsync_inode_entry *entry;\n\n\tlist_for_each_entry(entry, head, list)\n\t\tif (entry->inode->i_ino == ino)\n\t\t\treturn entry;\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_fsync_dnode",
          "args": [
            "page"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpver_of_node",
          "args": [
            "page"
          ],
          "line": 183
        },
        "resolved": true,
        "details": {
          "function_name": "cpver_of_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.h",
          "lines": "266-270",
          "snippet": "static inline unsigned long long cpver_of_node(struct page *node_page)\n{\n\tstruct f2fs_node *rn = F2FS_NODE(node_page);\n\treturn le64_to_cpu(rn->footer.cp_ver);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline unsigned long long cpver_of_node(struct page *node_page)\n{\n\tstruct f2fs_node *rn = F2FS_NODE(node_page);\n\treturn le64_to_cpu(rn->footer.cp_ver);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_meta_page",
          "args": [
            "sbi",
            "blkaddr"
          ],
          "line": 181
        },
        "resolved": true,
        "details": {
          "function_name": "get_meta_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/checkpoint.c",
          "lines": "50-78",
          "snippet": "struct page *get_meta_page(struct f2fs_sb_info *sbi, pgoff_t index)\n{\n\tstruct address_space *mapping = META_MAPPING(sbi);\n\tstruct page *page;\n\tstruct f2fs_io_info fio = {\n\t\t.type = META,\n\t\t.rw = READ_SYNC | REQ_META | REQ_PRIO,\n\t\t.blk_addr = index,\n\t};\nrepeat:\n\tpage = grab_cache_page(mapping, index);\n\tif (!page) {\n\t\tcond_resched();\n\t\tgoto repeat;\n\t}\n\tif (PageUptodate(page))\n\t\tgoto out;\n\n\tif (f2fs_submit_page_bio(sbi, page, &fio))\n\t\tgoto repeat;\n\n\tlock_page(page);\n\tif (unlikely(page->mapping != mapping)) {\n\t\tf2fs_put_page(page, 1);\n\t\tgoto repeat;\n\t}\nout:\n\treturn page;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/f2fs_fs.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n\nstruct page *get_meta_page(struct f2fs_sb_info *sbi, pgoff_t index)\n{\n\tstruct address_space *mapping = META_MAPPING(sbi);\n\tstruct page *page;\n\tstruct f2fs_io_info fio = {\n\t\t.type = META,\n\t\t.rw = READ_SYNC | REQ_META | REQ_PRIO,\n\t\t.blk_addr = index,\n\t};\nrepeat:\n\tpage = grab_cache_page(mapping, index);\n\tif (!page) {\n\t\tcond_resched();\n\t\tgoto repeat;\n\t}\n\tif (PageUptodate(page))\n\t\tgoto out;\n\n\tif (f2fs_submit_page_bio(sbi, page, &fio))\n\t\tgoto repeat;\n\n\tlock_page(page);\n\tif (unlikely(page->mapping != mapping)) {\n\t\tf2fs_put_page(page, 1);\n\t\tgoto repeat;\n\t}\nout:\n\treturn page;\n}"
        }
      },
      {
        "call_info": {
          "callee": "MAX_BLKADDR",
          "args": [
            "sbi"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAIN_BLKADDR",
          "args": [
            "sbi"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ra_meta_pages",
          "args": [
            "sbi",
            "blkaddr",
            "1",
            "META_POR"
          ],
          "line": 173
        },
        "resolved": true,
        "details": {
          "function_name": "ra_meta_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/checkpoint.c",
          "lines": "115-170",
          "snippet": "int ra_meta_pages(struct f2fs_sb_info *sbi, block_t start, int nrpages, int type)\n{\n\tblock_t prev_blk_addr = 0;\n\tstruct page *page;\n\tblock_t blkno = start;\n\tstruct f2fs_io_info fio = {\n\t\t.type = META,\n\t\t.rw = READ_SYNC | REQ_META | REQ_PRIO\n\t};\n\n\tfor (; nrpages-- > 0; blkno++) {\n\n\t\tif (!is_valid_blkaddr(sbi, blkno, type))\n\t\t\tgoto out;\n\n\t\tswitch (type) {\n\t\tcase META_NAT:\n\t\t\tif (unlikely(blkno >=\n\t\t\t\t\tNAT_BLOCK_OFFSET(NM_I(sbi)->max_nid)))\n\t\t\t\tblkno = 0;\n\t\t\t/* get nat block addr */\n\t\t\tfio.blk_addr = current_nat_addr(sbi,\n\t\t\t\t\tblkno * NAT_ENTRY_PER_BLOCK);\n\t\t\tbreak;\n\t\tcase META_SIT:\n\t\t\t/* get sit block addr */\n\t\t\tfio.blk_addr = current_sit_addr(sbi,\n\t\t\t\t\tblkno * SIT_ENTRY_PER_BLOCK);\n\t\t\tif (blkno != start && prev_blk_addr + 1 != fio.blk_addr)\n\t\t\t\tgoto out;\n\t\t\tprev_blk_addr = fio.blk_addr;\n\t\t\tbreak;\n\t\tcase META_SSA:\n\t\tcase META_CP:\n\t\tcase META_POR:\n\t\t\tfio.blk_addr = blkno;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tBUG();\n\t\t}\n\n\t\tpage = grab_cache_page(META_MAPPING(sbi), fio.blk_addr);\n\t\tif (!page)\n\t\t\tcontinue;\n\t\tif (PageUptodate(page)) {\n\t\t\tf2fs_put_page(page, 1);\n\t\t\tcontinue;\n\t\t}\n\n\t\tf2fs_submit_page_mbio(sbi, page, &fio);\n\t\tf2fs_put_page(page, 0);\n\t}\nout:\n\tf2fs_submit_merged_bio(sbi, META, READ);\n\treturn blkno - start;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/f2fs_fs.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n\nint ra_meta_pages(struct f2fs_sb_info *sbi, block_t start, int nrpages, int type)\n{\n\tblock_t prev_blk_addr = 0;\n\tstruct page *page;\n\tblock_t blkno = start;\n\tstruct f2fs_io_info fio = {\n\t\t.type = META,\n\t\t.rw = READ_SYNC | REQ_META | REQ_PRIO\n\t};\n\n\tfor (; nrpages-- > 0; blkno++) {\n\n\t\tif (!is_valid_blkaddr(sbi, blkno, type))\n\t\t\tgoto out;\n\n\t\tswitch (type) {\n\t\tcase META_NAT:\n\t\t\tif (unlikely(blkno >=\n\t\t\t\t\tNAT_BLOCK_OFFSET(NM_I(sbi)->max_nid)))\n\t\t\t\tblkno = 0;\n\t\t\t/* get nat block addr */\n\t\t\tfio.blk_addr = current_nat_addr(sbi,\n\t\t\t\t\tblkno * NAT_ENTRY_PER_BLOCK);\n\t\t\tbreak;\n\t\tcase META_SIT:\n\t\t\t/* get sit block addr */\n\t\t\tfio.blk_addr = current_sit_addr(sbi,\n\t\t\t\t\tblkno * SIT_ENTRY_PER_BLOCK);\n\t\t\tif (blkno != start && prev_blk_addr + 1 != fio.blk_addr)\n\t\t\t\tgoto out;\n\t\t\tprev_blk_addr = fio.blk_addr;\n\t\t\tbreak;\n\t\tcase META_SSA:\n\t\tcase META_CP:\n\t\tcase META_POR:\n\t\t\tfio.blk_addr = blkno;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tBUG();\n\t\t}\n\n\t\tpage = grab_cache_page(META_MAPPING(sbi), fio.blk_addr);\n\t\tif (!page)\n\t\t\tcontinue;\n\t\tif (PageUptodate(page)) {\n\t\t\tf2fs_put_page(page, 1);\n\t\t\tcontinue;\n\t\t}\n\n\t\tf2fs_submit_page_mbio(sbi, page, &fio);\n\t\tf2fs_put_page(page, 0);\n\t}\nout:\n\tf2fs_submit_merged_bio(sbi, META, READ);\n\treturn blkno - start;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NEXT_FREE_BLKADDR",
          "args": [
            "sbi",
            "curseg"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CURSEG_I",
          "args": [
            "sbi",
            "CURSEG_WARM_NODE"
          ],
          "line": 170
        },
        "resolved": true,
        "details": {
          "function_name": "CURSEG_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.h",
          "lines": "263-266",
          "snippet": "static inline struct curseg_info *CURSEG_I(struct f2fs_sb_info *sbi, int type)\n{\n\treturn (struct curseg_info *)(SM_I(sbi)->curseg_array + type);\n}",
          "includes": [
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/blkdev.h>\n\nstatic inline struct curseg_info *CURSEG_I(struct f2fs_sb_info *sbi, int type)\n{\n\treturn (struct curseg_info *)(SM_I(sbi)->curseg_array + type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cur_cp_version",
          "args": [
            "F2FS_CKPT(sbi)"
          ],
          "line": 163
        },
        "resolved": true,
        "details": {
          "function_name": "cur_cp_version",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "730-733",
          "snippet": "static inline unsigned long long cur_cp_version(struct f2fs_checkpoint *cp)\n{\n\treturn le64_to_cpu(cp->checkpoint_ver);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline unsigned long long cur_cp_version(struct f2fs_checkpoint *cp)\n{\n\treturn le64_to_cpu(cp->checkpoint_ver);\n}"
        }
      },
      {
        "call_info": {
          "callee": "F2FS_CKPT",
          "args": [
            "sbi"
          ],
          "line": 163
        },
        "resolved": true,
        "details": {
          "function_name": "F2FS_CKPT",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "665-668",
          "snippet": "static inline struct f2fs_checkpoint *F2FS_CKPT(struct f2fs_sb_info *sbi)\n{\n\treturn (struct f2fs_checkpoint *)(sbi->ckpt);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_checkpoint *F2FS_CKPT(struct f2fs_sb_info *sbi)\n{\n\treturn (struct f2fs_checkpoint *)(sbi->ckpt);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic struct kmem_cache *fsync_entry_slab;\n\nstatic int find_fsync_dnodes(struct f2fs_sb_info *sbi, struct list_head *head)\n{\n\tunsigned long long cp_ver = cur_cp_version(F2FS_CKPT(sbi));\n\tstruct curseg_info *curseg;\n\tstruct page *page = NULL;\n\tblock_t blkaddr;\n\tint err = 0;\n\n\t/* get node pages in the current segment */\n\tcurseg = CURSEG_I(sbi, CURSEG_WARM_NODE);\n\tblkaddr = NEXT_FREE_BLKADDR(sbi, curseg);\n\n\tra_meta_pages(sbi, blkaddr, 1, META_POR);\n\n\twhile (1) {\n\t\tstruct fsync_inode_entry *entry;\n\n\t\tif (blkaddr < MAIN_BLKADDR(sbi) || blkaddr >= MAX_BLKADDR(sbi))\n\t\t\treturn 0;\n\n\t\tpage = get_meta_page(sbi, blkaddr);\n\n\t\tif (cp_ver != cpver_of_node(page))\n\t\t\tbreak;\n\n\t\tif (!is_fsync_dnode(page))\n\t\t\tgoto next;\n\n\t\tentry = get_fsync_inode(head, ino_of_node(page));\n\t\tif (entry) {\n\t\t\tif (IS_INODE(page) && is_dent_dnode(page))\n\t\t\t\tset_inode_flag(F2FS_I(entry->inode),\n\t\t\t\t\t\t\tFI_INC_LINK);\n\t\t} else {\n\t\t\tif (IS_INODE(page) && is_dent_dnode(page)) {\n\t\t\t\terr = recover_inode_page(sbi, page);\n\t\t\t\tif (err)\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* add this fsync inode to the list */\n\t\t\tentry = kmem_cache_alloc(fsync_entry_slab, GFP_F2FS_ZERO);\n\t\t\tif (!entry) {\n\t\t\t\terr = -ENOMEM;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/*\n\t\t\t * CP | dnode(F) | inode(DF)\n\t\t\t * For this case, we should not give up now.\n\t\t\t */\n\t\t\tentry->inode = f2fs_iget(sbi->sb, ino_of_node(page));\n\t\t\tif (IS_ERR(entry->inode)) {\n\t\t\t\terr = PTR_ERR(entry->inode);\n\t\t\t\tkmem_cache_free(fsync_entry_slab, entry);\n\t\t\t\tif (err == -ENOENT)\n\t\t\t\t\tgoto next;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tlist_add_tail(&entry->list, head);\n\t\t}\n\t\tentry->blkaddr = blkaddr;\n\n\t\tif (IS_INODE(page)) {\n\t\t\tentry->last_inode = blkaddr;\n\t\t\tif (is_dent_dnode(page))\n\t\t\t\tentry->last_dentry = blkaddr;\n\t\t}\nnext:\n\t\t/* check next segment */\n\t\tblkaddr = next_blkaddr_of_node(page);\n\t\tf2fs_put_page(page, 1);\n\n\t\tra_meta_pages_cond(sbi, blkaddr);\n\t}\n\tf2fs_put_page(page, 1);\n\treturn err;\n}"
  },
  {
    "function_name": "recover_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/recovery.c",
    "lines": "144-159",
    "snippet": "static void recover_inode(struct inode *inode, struct page *page)\n{\n\tstruct f2fs_inode *raw = F2FS_INODE(page);\n\n\tinode->i_mode = le16_to_cpu(raw->i_mode);\n\ti_size_write(inode, le64_to_cpu(raw->i_size));\n\tinode->i_atime.tv_sec = le64_to_cpu(raw->i_mtime);\n\tinode->i_ctime.tv_sec = le64_to_cpu(raw->i_ctime);\n\tinode->i_mtime.tv_sec = le64_to_cpu(raw->i_mtime);\n\tinode->i_atime.tv_nsec = le32_to_cpu(raw->i_mtime_nsec);\n\tinode->i_ctime.tv_nsec = le32_to_cpu(raw->i_ctime_nsec);\n\tinode->i_mtime.tv_nsec = le32_to_cpu(raw->i_mtime_nsec);\n\n\tf2fs_msg(inode->i_sb, KERN_NOTICE, \"recover_inode: ino = %x, name = %s\",\n\t\t\tino_of_node(page), F2FS_INODE(page)->i_name);\n}",
    "includes": [
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "f2fs_msg",
          "args": [
            "inode->i_sb",
            "KERN_NOTICE",
            "\"recover_inode: ino = %x, name = %s\"",
            "ino_of_node(page)",
            "F2FS_INODE(page)->i_name"
          ],
          "line": 157
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_msg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/super.c",
          "lines": "235-245",
          "snippet": "void f2fs_msg(struct super_block *sb, const char *level, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tprintk(\"%sF2FS-fs (%s): %pV\\n\", level, sb->s_id, &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"gc.h\"",
            "#include \"xattr.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/sysfs.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/random.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/parser.h>",
            "#include <linux/kthread.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/statfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"gc.h\"\n#include \"xattr.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/sysfs.h>\n#include <linux/f2fs_fs.h>\n#include <linux/blkdev.h>\n#include <linux/exportfs.h>\n#include <linux/random.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/parser.h>\n#include <linux/kthread.h>\n#include <linux/backing-dev.h>\n#include <linux/buffer_head.h>\n#include <linux/statfs.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nvoid f2fs_msg(struct super_block *sb, const char *level, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tprintk(\"%sF2FS-fs (%s): %pV\\n\", level, sb->s_id, &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "F2FS_INODE",
          "args": [
            "page"
          ],
          "line": 158
        },
        "resolved": true,
        "details": {
          "function_name": "F2FS_INODE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "675-678",
          "snippet": "static inline struct f2fs_inode *F2FS_INODE(struct page *page)\n{\n\treturn &((struct f2fs_node *)page_address(page))->i;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_inode *F2FS_INODE(struct page *page)\n{\n\treturn &((struct f2fs_node *)page_address(page))->i;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ino_of_node",
          "args": [
            "page"
          ],
          "line": 158
        },
        "resolved": true,
        "details": {
          "function_name": "ino_of_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.h",
          "lines": "247-251",
          "snippet": "static inline nid_t ino_of_node(struct page *node_page)\n{\n\tstruct f2fs_node *rn = F2FS_NODE(node_page);\n\treturn le32_to_cpu(rn->footer.ino);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline nid_t ino_of_node(struct page *node_page)\n{\n\tstruct f2fs_node *rn = F2FS_NODE(node_page);\n\treturn le32_to_cpu(rn->footer.ino);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "raw->i_mtime_nsec"
          ],
          "line": 155
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "raw->i_mtime"
          ],
          "line": 152
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_write",
          "args": [
            "inode",
            "le64_to_cpu(raw->i_size)"
          ],
          "line": 149
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_i_size_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "233-237",
          "snippet": "static inline void btrfs_i_size_write(struct inode *inode, u64 size)\n{\n\ti_size_write(inode, size);\n\tBTRFS_I(inode)->disk_i_size = size;\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline void btrfs_i_size_write(struct inode *inode, u64 size)\n{\n\ti_size_write(inode, size);\n\tBTRFS_I(inode)->disk_i_size = size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "raw->i_mode"
          ],
          "line": 148
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic void recover_inode(struct inode *inode, struct page *page)\n{\n\tstruct f2fs_inode *raw = F2FS_INODE(page);\n\n\tinode->i_mode = le16_to_cpu(raw->i_mode);\n\ti_size_write(inode, le64_to_cpu(raw->i_size));\n\tinode->i_atime.tv_sec = le64_to_cpu(raw->i_mtime);\n\tinode->i_ctime.tv_sec = le64_to_cpu(raw->i_ctime);\n\tinode->i_mtime.tv_sec = le64_to_cpu(raw->i_mtime);\n\tinode->i_atime.tv_nsec = le32_to_cpu(raw->i_mtime_nsec);\n\tinode->i_ctime.tv_nsec = le32_to_cpu(raw->i_ctime_nsec);\n\tinode->i_mtime.tv_nsec = le32_to_cpu(raw->i_mtime_nsec);\n\n\tf2fs_msg(inode->i_sb, KERN_NOTICE, \"recover_inode: ino = %x, name = %s\",\n\t\t\tino_of_node(page), F2FS_INODE(page)->i_name);\n}"
  },
  {
    "function_name": "recover_dentry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/recovery.c",
    "lines": "70-142",
    "snippet": "static int recover_dentry(struct inode *inode, struct page *ipage)\n{\n\tstruct f2fs_inode *raw_inode = F2FS_INODE(ipage);\n\tnid_t pino = le32_to_cpu(raw_inode->i_pino);\n\tstruct f2fs_dir_entry *de;\n\tstruct qstr name;\n\tstruct page *page;\n\tstruct inode *dir, *einode;\n\tint err = 0;\n\n\tdir = f2fs_iget(inode->i_sb, pino);\n\tif (IS_ERR(dir)) {\n\t\terr = PTR_ERR(dir);\n\t\tgoto out;\n\t}\n\n\tname.len = le32_to_cpu(raw_inode->i_namelen);\n\tname.name = raw_inode->i_name;\n\n\tif (unlikely(name.len > F2FS_NAME_LEN)) {\n\t\tWARN_ON(1);\n\t\terr = -ENAMETOOLONG;\n\t\tgoto out_err;\n\t}\nretry:\n\tde = f2fs_find_entry(dir, &name, &page);\n\tif (de && inode->i_ino == le32_to_cpu(de->ino)) {\n\t\tclear_inode_flag(F2FS_I(inode), FI_INC_LINK);\n\t\tgoto out_unmap_put;\n\t}\n\tif (de) {\n\t\teinode = f2fs_iget(inode->i_sb, le32_to_cpu(de->ino));\n\t\tif (IS_ERR(einode)) {\n\t\t\tWARN_ON(1);\n\t\t\terr = PTR_ERR(einode);\n\t\t\tif (err == -ENOENT)\n\t\t\t\terr = -EEXIST;\n\t\t\tgoto out_unmap_put;\n\t\t}\n\t\terr = acquire_orphan_inode(F2FS_I_SB(inode));\n\t\tif (err) {\n\t\t\tiput(einode);\n\t\t\tgoto out_unmap_put;\n\t\t}\n\t\tf2fs_delete_entry(de, page, dir, einode);\n\t\tiput(einode);\n\t\tgoto retry;\n\t}\n\terr = __f2fs_add_link(dir, &name, inode);\n\tif (err)\n\t\tgoto out_err;\n\n\tif (is_inode_flag_set(F2FS_I(dir), FI_DELAY_IPUT)) {\n\t\tiput(dir);\n\t} else {\n\t\tadd_dirty_dir_inode(dir);\n\t\tset_inode_flag(F2FS_I(dir), FI_DELAY_IPUT);\n\t}\n\n\tgoto out;\n\nout_unmap_put:\n\tf2fs_dentry_kunmap(dir, page);\n\tf2fs_put_page(page, 0);\nout_err:\n\tiput(dir);\nout:\n\tf2fs_msg(inode->i_sb, KERN_NOTICE,\n\t\t\t\"%s: ino = %x, name = %s, dir = %lx, err = %d\",\n\t\t\t__func__, ino_of_node(ipage), raw_inode->i_name,\n\t\t\tIS_ERR(dir) ? 0 : dir->i_ino, err);\n\treturn err;\n}",
    "includes": [
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "f2fs_msg",
          "args": [
            "inode->i_sb",
            "KERN_NOTICE",
            "\"%s: ino = %x, name = %s, dir = %lx, err = %d\"",
            "__func__",
            "ino_of_node(ipage)",
            "raw_inode->i_name",
            "IS_ERR(dir) ? 0 : dir->i_ino",
            "err"
          ],
          "line": 137
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_msg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/super.c",
          "lines": "235-245",
          "snippet": "void f2fs_msg(struct super_block *sb, const char *level, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tprintk(\"%sF2FS-fs (%s): %pV\\n\", level, sb->s_id, &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"gc.h\"",
            "#include \"xattr.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/sysfs.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/random.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/parser.h>",
            "#include <linux/kthread.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/statfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"gc.h\"\n#include \"xattr.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/sysfs.h>\n#include <linux/f2fs_fs.h>\n#include <linux/blkdev.h>\n#include <linux/exportfs.h>\n#include <linux/random.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/parser.h>\n#include <linux/kthread.h>\n#include <linux/backing-dev.h>\n#include <linux/buffer_head.h>\n#include <linux/statfs.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nvoid f2fs_msg(struct super_block *sb, const char *level, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tprintk(\"%sF2FS-fs (%s): %pV\\n\", level, sb->s_id, &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "dir"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ino_of_node",
          "args": [
            "ipage"
          ],
          "line": 139
        },
        "resolved": true,
        "details": {
          "function_name": "ino_of_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.h",
          "lines": "247-251",
          "snippet": "static inline nid_t ino_of_node(struct page *node_page)\n{\n\tstruct f2fs_node *rn = F2FS_NODE(node_page);\n\treturn le32_to_cpu(rn->footer.ino);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline nid_t ino_of_node(struct page *node_page)\n{\n\tstruct f2fs_node *rn = F2FS_NODE(node_page);\n\treturn le32_to_cpu(rn->footer.ino);\n}"
        }
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "dir"
          ],
          "line": 135
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_put_page",
          "args": [
            "page",
            "0"
          ],
          "line": 133
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_put_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1036-1046",
          "snippet": "static inline void f2fs_put_page(struct page *page, int unlock)\n{\n\tif (!page)\n\t\treturn;\n\n\tif (unlock) {\n\t\tf2fs_bug_on(F2FS_P_SB(page), !PageLocked(page));\n\t\tunlock_page(page);\n\t}\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void f2fs_put_page(struct page *page, int unlock)\n{\n\tif (!page)\n\t\treturn;\n\n\tif (unlock) {\n\t\tf2fs_bug_on(F2FS_P_SB(page), !PageLocked(page));\n\t\tunlock_page(page);\n\t}\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_dentry_kunmap",
          "args": [
            "dir",
            "page"
          ],
          "line": 132
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_dentry_kunmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1299-1303",
          "snippet": "static inline void f2fs_dentry_kunmap(struct inode *dir, struct page *page)\n{\n\tif (!f2fs_has_inline_dentry(dir))\n\t\tkunmap(page);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void f2fs_dentry_kunmap(struct inode *dir, struct page *page)\n{\n\tif (!f2fs_has_inline_dentry(dir))\n\t\tkunmap(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_inode_flag",
          "args": [
            "F2FS_I(dir)",
            "FI_DELAY_IPUT"
          ],
          "line": 126
        },
        "resolved": true,
        "details": {
          "function_name": "set_inode_flag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1173-1177",
          "snippet": "static inline void set_inode_flag(struct f2fs_inode_info *fi, int flag)\n{\n\tif (!test_bit(flag, &fi->flags))\n\t\tset_bit(flag, &fi->flags);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void set_inode_flag(struct f2fs_inode_info *fi, int flag)\n{\n\tif (!test_bit(flag, &fi->flags))\n\t\tset_bit(flag, &fi->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "F2FS_I",
          "args": [
            "dir"
          ],
          "line": 126
        },
        "resolved": true,
        "details": {
          "function_name": "F2FS_INODE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "675-678",
          "snippet": "static inline struct f2fs_inode *F2FS_INODE(struct page *page)\n{\n\treturn &((struct f2fs_node *)page_address(page))->i;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_inode *F2FS_INODE(struct page *page)\n{\n\treturn &((struct f2fs_node *)page_address(page))->i;\n}"
        }
      },
      {
        "call_info": {
          "callee": "add_dirty_dir_inode",
          "args": [
            "dir"
          ],
          "line": 125
        },
        "resolved": true,
        "details": {
          "function_name": "add_dirty_dir_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/checkpoint.c",
          "lines": "723-739",
          "snippet": "void add_dirty_dir_inode(struct inode *inode)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tstruct inode_entry *new =\n\t\t\tf2fs_kmem_cache_alloc(inode_entry_slab, GFP_NOFS);\n\tint ret = 0;\n\n\tnew->inode = inode;\n\tINIT_LIST_HEAD(&new->list);\n\n\tspin_lock(&sbi->dir_inode_lock);\n\tret = __add_dirty_inode(inode, new);\n\tspin_unlock(&sbi->dir_inode_lock);\n\n\tif (ret)\n\t\tkmem_cache_free(inode_entry_slab, new);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct kmem_cache *inode_entry_slab;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/f2fs_fs.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n\nstruct kmem_cache *inode_entry_slab;\n\nvoid add_dirty_dir_inode(struct inode *inode)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tstruct inode_entry *new =\n\t\t\tf2fs_kmem_cache_alloc(inode_entry_slab, GFP_NOFS);\n\tint ret = 0;\n\n\tnew->inode = inode;\n\tINIT_LIST_HEAD(&new->list);\n\n\tspin_lock(&sbi->dir_inode_lock);\n\tret = __add_dirty_inode(inode, new);\n\tspin_unlock(&sbi->dir_inode_lock);\n\n\tif (ret)\n\t\tkmem_cache_free(inode_entry_slab, new);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_inode_flag_set",
          "args": [
            "F2FS_I(dir)",
            "FI_DELAY_IPUT"
          ],
          "line": 122
        },
        "resolved": true,
        "details": {
          "function_name": "is_inode_flag_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1179-1182",
          "snippet": "static inline int is_inode_flag_set(struct f2fs_inode_info *fi, int flag)\n{\n\treturn test_bit(flag, &fi->flags);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int is_inode_flag_set(struct f2fs_inode_info *fi, int flag)\n{\n\treturn test_bit(flag, &fi->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__f2fs_add_link",
          "args": [
            "dir",
            "&name",
            "inode"
          ],
          "line": 118
        },
        "resolved": true,
        "details": {
          "function_name": "__f2fs_add_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/dir.c",
          "lines": "481-582",
          "snippet": "int __f2fs_add_link(struct inode *dir, const struct qstr *name,\n\t\t\t\t\t\tstruct inode *inode)\n{\n\tunsigned int bit_pos;\n\tunsigned int level;\n\tunsigned int current_depth;\n\tunsigned long bidx, block;\n\tf2fs_hash_t dentry_hash;\n\tstruct f2fs_dir_entry *de;\n\tunsigned int nbucket, nblock;\n\tsize_t namelen = name->len;\n\tstruct page *dentry_page = NULL;\n\tstruct f2fs_dentry_block *dentry_blk = NULL;\n\tint slots = GET_DENTRY_SLOTS(namelen);\n\tstruct page *page;\n\tint err = 0;\n\tint i;\n\n\tif (f2fs_has_inline_dentry(dir)) {\n\t\terr = f2fs_add_inline_entry(dir, name, inode);\n\t\tif (!err || err != -EAGAIN)\n\t\t\treturn err;\n\t\telse\n\t\t\terr = 0;\n\t}\n\n\tdentry_hash = f2fs_dentry_hash(name);\n\tlevel = 0;\n\tcurrent_depth = F2FS_I(dir)->i_current_depth;\n\tif (F2FS_I(dir)->chash == dentry_hash) {\n\t\tlevel = F2FS_I(dir)->clevel;\n\t\tF2FS_I(dir)->chash = 0;\n\t}\n\nstart:\n\tif (unlikely(current_depth == MAX_DIR_HASH_DEPTH))\n\t\treturn -ENOSPC;\n\n\t/* Increase the depth, if required */\n\tif (level == current_depth)\n\t\t++current_depth;\n\n\tnbucket = dir_buckets(level, F2FS_I(dir)->i_dir_level);\n\tnblock = bucket_blocks(level);\n\n\tbidx = dir_block_index(level, F2FS_I(dir)->i_dir_level,\n\t\t\t\t(le32_to_cpu(dentry_hash) % nbucket));\n\n\tfor (block = bidx; block <= (bidx + nblock - 1); block++) {\n\t\tdentry_page = get_new_data_page(dir, NULL, block, true);\n\t\tif (IS_ERR(dentry_page))\n\t\t\treturn PTR_ERR(dentry_page);\n\n\t\tdentry_blk = kmap(dentry_page);\n\t\tbit_pos = room_for_filename(&dentry_blk->dentry_bitmap,\n\t\t\t\t\t\tslots, NR_DENTRY_IN_BLOCK);\n\t\tif (bit_pos < NR_DENTRY_IN_BLOCK)\n\t\t\tgoto add_dentry;\n\n\t\tkunmap(dentry_page);\n\t\tf2fs_put_page(dentry_page, 1);\n\t}\n\n\t/* Move to next level to find the empty slot for new dentry */\n\t++level;\n\tgoto start;\nadd_dentry:\n\tf2fs_wait_on_page_writeback(dentry_page, DATA);\n\n\tdown_write(&F2FS_I(inode)->i_sem);\n\tpage = init_inode_metadata(inode, dir, name, NULL);\n\tif (IS_ERR(page)) {\n\t\terr = PTR_ERR(page);\n\t\tgoto fail;\n\t}\n\tde = &dentry_blk->dentry[bit_pos];\n\tde->hash_code = dentry_hash;\n\tde->name_len = cpu_to_le16(namelen);\n\tmemcpy(dentry_blk->filename[bit_pos], name->name, name->len);\n\tde->ino = cpu_to_le32(inode->i_ino);\n\tset_de_type(de, inode);\n\tfor (i = 0; i < slots; i++)\n\t\ttest_and_set_bit_le(bit_pos + i, &dentry_blk->dentry_bitmap);\n\tset_page_dirty(dentry_page);\n\n\t/* we don't need to mark_inode_dirty now */\n\tF2FS_I(inode)->i_pino = dir->i_ino;\n\tupdate_inode(inode, page);\n\tf2fs_put_page(page, 1);\n\n\tupdate_parent_metadata(dir, inode, current_depth);\nfail:\n\tup_write(&F2FS_I(inode)->i_sem);\n\n\tif (is_inode_flag_set(F2FS_I(dir), FI_UPDATE_DIR)) {\n\t\tupdate_inode_page(dir);\n\t\tclear_inode_flag(F2FS_I(dir), FI_UPDATE_DIR);\n\t}\n\tkunmap(dentry_page);\n\tf2fs_put_page(dentry_page, 1);\n\treturn err;\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"acl.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nint __f2fs_add_link(struct inode *dir, const struct qstr *name,\n\t\t\t\t\t\tstruct inode *inode)\n{\n\tunsigned int bit_pos;\n\tunsigned int level;\n\tunsigned int current_depth;\n\tunsigned long bidx, block;\n\tf2fs_hash_t dentry_hash;\n\tstruct f2fs_dir_entry *de;\n\tunsigned int nbucket, nblock;\n\tsize_t namelen = name->len;\n\tstruct page *dentry_page = NULL;\n\tstruct f2fs_dentry_block *dentry_blk = NULL;\n\tint slots = GET_DENTRY_SLOTS(namelen);\n\tstruct page *page;\n\tint err = 0;\n\tint i;\n\n\tif (f2fs_has_inline_dentry(dir)) {\n\t\terr = f2fs_add_inline_entry(dir, name, inode);\n\t\tif (!err || err != -EAGAIN)\n\t\t\treturn err;\n\t\telse\n\t\t\terr = 0;\n\t}\n\n\tdentry_hash = f2fs_dentry_hash(name);\n\tlevel = 0;\n\tcurrent_depth = F2FS_I(dir)->i_current_depth;\n\tif (F2FS_I(dir)->chash == dentry_hash) {\n\t\tlevel = F2FS_I(dir)->clevel;\n\t\tF2FS_I(dir)->chash = 0;\n\t}\n\nstart:\n\tif (unlikely(current_depth == MAX_DIR_HASH_DEPTH))\n\t\treturn -ENOSPC;\n\n\t/* Increase the depth, if required */\n\tif (level == current_depth)\n\t\t++current_depth;\n\n\tnbucket = dir_buckets(level, F2FS_I(dir)->i_dir_level);\n\tnblock = bucket_blocks(level);\n\n\tbidx = dir_block_index(level, F2FS_I(dir)->i_dir_level,\n\t\t\t\t(le32_to_cpu(dentry_hash) % nbucket));\n\n\tfor (block = bidx; block <= (bidx + nblock - 1); block++) {\n\t\tdentry_page = get_new_data_page(dir, NULL, block, true);\n\t\tif (IS_ERR(dentry_page))\n\t\t\treturn PTR_ERR(dentry_page);\n\n\t\tdentry_blk = kmap(dentry_page);\n\t\tbit_pos = room_for_filename(&dentry_blk->dentry_bitmap,\n\t\t\t\t\t\tslots, NR_DENTRY_IN_BLOCK);\n\t\tif (bit_pos < NR_DENTRY_IN_BLOCK)\n\t\t\tgoto add_dentry;\n\n\t\tkunmap(dentry_page);\n\t\tf2fs_put_page(dentry_page, 1);\n\t}\n\n\t/* Move to next level to find the empty slot for new dentry */\n\t++level;\n\tgoto start;\nadd_dentry:\n\tf2fs_wait_on_page_writeback(dentry_page, DATA);\n\n\tdown_write(&F2FS_I(inode)->i_sem);\n\tpage = init_inode_metadata(inode, dir, name, NULL);\n\tif (IS_ERR(page)) {\n\t\terr = PTR_ERR(page);\n\t\tgoto fail;\n\t}\n\tde = &dentry_blk->dentry[bit_pos];\n\tde->hash_code = dentry_hash;\n\tde->name_len = cpu_to_le16(namelen);\n\tmemcpy(dentry_blk->filename[bit_pos], name->name, name->len);\n\tde->ino = cpu_to_le32(inode->i_ino);\n\tset_de_type(de, inode);\n\tfor (i = 0; i < slots; i++)\n\t\ttest_and_set_bit_le(bit_pos + i, &dentry_blk->dentry_bitmap);\n\tset_page_dirty(dentry_page);\n\n\t/* we don't need to mark_inode_dirty now */\n\tF2FS_I(inode)->i_pino = dir->i_ino;\n\tupdate_inode(inode, page);\n\tf2fs_put_page(page, 1);\n\n\tupdate_parent_metadata(dir, inode, current_depth);\nfail:\n\tup_write(&F2FS_I(inode)->i_sem);\n\n\tif (is_inode_flag_set(F2FS_I(dir), FI_UPDATE_DIR)) {\n\t\tupdate_inode_page(dir);\n\t\tclear_inode_flag(F2FS_I(dir), FI_UPDATE_DIR);\n\t}\n\tkunmap(dentry_page);\n\tf2fs_put_page(dentry_page, 1);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_delete_entry",
          "args": [
            "de",
            "page",
            "dir",
            "einode"
          ],
          "line": 114
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_delete_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/dir.c",
          "lines": "638-676",
          "snippet": "void f2fs_delete_entry(struct f2fs_dir_entry *dentry, struct page *page,\n\t\t\t\t\tstruct inode *dir, struct inode *inode)\n{\n\tstruct\tf2fs_dentry_block *dentry_blk;\n\tunsigned int bit_pos;\n\tint slots = GET_DENTRY_SLOTS(le16_to_cpu(dentry->name_len));\n\tint i;\n\n\tif (f2fs_has_inline_dentry(dir))\n\t\treturn f2fs_delete_inline_entry(dentry, page, dir, inode);\n\n\tlock_page(page);\n\tf2fs_wait_on_page_writeback(page, DATA);\n\n\tdentry_blk = page_address(page);\n\tbit_pos = dentry - dentry_blk->dentry;\n\tfor (i = 0; i < slots; i++)\n\t\tclear_bit_le(bit_pos + i, &dentry_blk->dentry_bitmap);\n\n\t/* Let's check and deallocate this dentry page */\n\tbit_pos = find_next_bit_le(&dentry_blk->dentry_bitmap,\n\t\t\tNR_DENTRY_IN_BLOCK,\n\t\t\t0);\n\tkunmap(page); /* kunmap - pair of f2fs_find_entry */\n\tset_page_dirty(page);\n\n\tdir->i_ctime = dir->i_mtime = CURRENT_TIME;\n\n\tif (inode)\n\t\tf2fs_drop_nlink(dir, inode, NULL);\n\n\tif (bit_pos == NR_DENTRY_IN_BLOCK) {\n\t\ttruncate_hole(dir, page->index, page->index + 1);\n\t\tclear_page_dirty_for_io(page);\n\t\tClearPageUptodate(page);\n\t\tinode_dec_dirty_pages(dir);\n\t}\n\tf2fs_put_page(page, 1);\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"acl.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nvoid f2fs_delete_entry(struct f2fs_dir_entry *dentry, struct page *page,\n\t\t\t\t\tstruct inode *dir, struct inode *inode)\n{\n\tstruct\tf2fs_dentry_block *dentry_blk;\n\tunsigned int bit_pos;\n\tint slots = GET_DENTRY_SLOTS(le16_to_cpu(dentry->name_len));\n\tint i;\n\n\tif (f2fs_has_inline_dentry(dir))\n\t\treturn f2fs_delete_inline_entry(dentry, page, dir, inode);\n\n\tlock_page(page);\n\tf2fs_wait_on_page_writeback(page, DATA);\n\n\tdentry_blk = page_address(page);\n\tbit_pos = dentry - dentry_blk->dentry;\n\tfor (i = 0; i < slots; i++)\n\t\tclear_bit_le(bit_pos + i, &dentry_blk->dentry_bitmap);\n\n\t/* Let's check and deallocate this dentry page */\n\tbit_pos = find_next_bit_le(&dentry_blk->dentry_bitmap,\n\t\t\tNR_DENTRY_IN_BLOCK,\n\t\t\t0);\n\tkunmap(page); /* kunmap - pair of f2fs_find_entry */\n\tset_page_dirty(page);\n\n\tdir->i_ctime = dir->i_mtime = CURRENT_TIME;\n\n\tif (inode)\n\t\tf2fs_drop_nlink(dir, inode, NULL);\n\n\tif (bit_pos == NR_DENTRY_IN_BLOCK) {\n\t\ttruncate_hole(dir, page->index, page->index + 1);\n\t\tclear_page_dirty_for_io(page);\n\t\tClearPageUptodate(page);\n\t\tinode_dec_dirty_pages(dir);\n\t}\n\tf2fs_put_page(page, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "acquire_orphan_inode",
          "args": [
            "F2FS_I_SB(inode)"
          ],
          "line": 109
        },
        "resolved": true,
        "details": {
          "function_name": "acquire_orphan_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/checkpoint.c",
          "lines": "418-431",
          "snippet": "int acquire_orphan_inode(struct f2fs_sb_info *sbi)\n{\n\tstruct inode_management *im = &sbi->im[ORPHAN_INO];\n\tint err = 0;\n\n\tspin_lock(&im->ino_lock);\n\tif (unlikely(im->ino_num >= sbi->max_orphans))\n\t\terr = -ENOSPC;\n\telse\n\t\tim->ino_num++;\n\tspin_unlock(&im->ino_lock);\n\n\treturn err;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/f2fs_fs.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n\nint acquire_orphan_inode(struct f2fs_sb_info *sbi)\n{\n\tstruct inode_management *im = &sbi->im[ORPHAN_INO];\n\tint err = 0;\n\n\tspin_lock(&im->ino_lock);\n\tif (unlikely(im->ino_num >= sbi->max_orphans))\n\t\terr = -ENOSPC;\n\telse\n\t\tim->ino_num++;\n\tspin_unlock(&im->ino_lock);\n\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "F2FS_I_SB",
          "args": [
            "inode"
          ],
          "line": 109
        },
        "resolved": true,
        "details": {
          "function_name": "F2FS_I_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "645-648",
          "snippet": "static inline struct f2fs_sb_info *F2FS_I_SB(struct inode *inode)\n{\n\treturn F2FS_SB(inode->i_sb);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_sb_info *F2FS_I_SB(struct inode *inode)\n{\n\treturn F2FS_SB(inode->i_sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "einode"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "1"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "einode"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f2fs_iget",
          "args": [
            "inode->i_sb",
            "le32_to_cpu(de->ino)"
          ],
          "line": 101
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_iget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/inode.c",
          "lines": "151-206",
          "snippet": "struct inode *f2fs_iget(struct super_block *sb, unsigned long ino)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_SB(sb);\n\tstruct inode *inode;\n\tint ret = 0;\n\n\tinode = iget_locked(sb, ino);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (!(inode->i_state & I_NEW)) {\n\t\ttrace_f2fs_iget(inode);\n\t\treturn inode;\n\t}\n\tif (ino == F2FS_NODE_INO(sbi) || ino == F2FS_META_INO(sbi))\n\t\tgoto make_now;\n\n\tret = do_read_inode(inode);\n\tif (ret)\n\t\tgoto bad_inode;\nmake_now:\n\tif (ino == F2FS_NODE_INO(sbi)) {\n\t\tinode->i_mapping->a_ops = &f2fs_node_aops;\n\t\tmapping_set_gfp_mask(inode->i_mapping, GFP_F2FS_ZERO);\n\t} else if (ino == F2FS_META_INO(sbi)) {\n\t\tinode->i_mapping->a_ops = &f2fs_meta_aops;\n\t\tmapping_set_gfp_mask(inode->i_mapping, GFP_F2FS_ZERO);\n\t} else if (S_ISREG(inode->i_mode)) {\n\t\tinode->i_op = &f2fs_file_inode_operations;\n\t\tinode->i_fop = &f2fs_file_operations;\n\t\tinode->i_mapping->a_ops = &f2fs_dblock_aops;\n\t} else if (S_ISDIR(inode->i_mode)) {\n\t\tinode->i_op = &f2fs_dir_inode_operations;\n\t\tinode->i_fop = &f2fs_dir_operations;\n\t\tinode->i_mapping->a_ops = &f2fs_dblock_aops;\n\t\tmapping_set_gfp_mask(inode->i_mapping, GFP_F2FS_HIGH_ZERO);\n\t} else if (S_ISLNK(inode->i_mode)) {\n\t\tinode->i_op = &f2fs_symlink_inode_operations;\n\t\tinode->i_mapping->a_ops = &f2fs_dblock_aops;\n\t} else if (S_ISCHR(inode->i_mode) || S_ISBLK(inode->i_mode) ||\n\t\t\tS_ISFIFO(inode->i_mode) || S_ISSOCK(inode->i_mode)) {\n\t\tinode->i_op = &f2fs_special_inode_operations;\n\t\tinit_special_inode(inode, inode->i_mode, inode->i_rdev);\n\t} else {\n\t\tret = -EIO;\n\t\tgoto bad_inode;\n\t}\n\tunlock_new_inode(inode);\n\ttrace_f2fs_iget(inode);\n\treturn inode;\n\nbad_inode:\n\tiget_failed(inode);\n\ttrace_f2fs_iget_exit(inode, ret);\n\treturn ERR_PTR(ret);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/bitops.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstruct inode *f2fs_iget(struct super_block *sb, unsigned long ino)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_SB(sb);\n\tstruct inode *inode;\n\tint ret = 0;\n\n\tinode = iget_locked(sb, ino);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (!(inode->i_state & I_NEW)) {\n\t\ttrace_f2fs_iget(inode);\n\t\treturn inode;\n\t}\n\tif (ino == F2FS_NODE_INO(sbi) || ino == F2FS_META_INO(sbi))\n\t\tgoto make_now;\n\n\tret = do_read_inode(inode);\n\tif (ret)\n\t\tgoto bad_inode;\nmake_now:\n\tif (ino == F2FS_NODE_INO(sbi)) {\n\t\tinode->i_mapping->a_ops = &f2fs_node_aops;\n\t\tmapping_set_gfp_mask(inode->i_mapping, GFP_F2FS_ZERO);\n\t} else if (ino == F2FS_META_INO(sbi)) {\n\t\tinode->i_mapping->a_ops = &f2fs_meta_aops;\n\t\tmapping_set_gfp_mask(inode->i_mapping, GFP_F2FS_ZERO);\n\t} else if (S_ISREG(inode->i_mode)) {\n\t\tinode->i_op = &f2fs_file_inode_operations;\n\t\tinode->i_fop = &f2fs_file_operations;\n\t\tinode->i_mapping->a_ops = &f2fs_dblock_aops;\n\t} else if (S_ISDIR(inode->i_mode)) {\n\t\tinode->i_op = &f2fs_dir_inode_operations;\n\t\tinode->i_fop = &f2fs_dir_operations;\n\t\tinode->i_mapping->a_ops = &f2fs_dblock_aops;\n\t\tmapping_set_gfp_mask(inode->i_mapping, GFP_F2FS_HIGH_ZERO);\n\t} else if (S_ISLNK(inode->i_mode)) {\n\t\tinode->i_op = &f2fs_symlink_inode_operations;\n\t\tinode->i_mapping->a_ops = &f2fs_dblock_aops;\n\t} else if (S_ISCHR(inode->i_mode) || S_ISBLK(inode->i_mode) ||\n\t\t\tS_ISFIFO(inode->i_mode) || S_ISSOCK(inode->i_mode)) {\n\t\tinode->i_op = &f2fs_special_inode_operations;\n\t\tinit_special_inode(inode, inode->i_mode, inode->i_rdev);\n\t} else {\n\t\tret = -EIO;\n\t\tgoto bad_inode;\n\t}\n\tunlock_new_inode(inode);\n\ttrace_f2fs_iget(inode);\n\treturn inode;\n\nbad_inode:\n\tiget_failed(inode);\n\ttrace_f2fs_iget_exit(inode, ret);\n\treturn ERR_PTR(ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "de->ino"
          ],
          "line": 101
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_inode_flag",
          "args": [
            "F2FS_I(inode)",
            "FI_INC_LINK"
          ],
          "line": 97
        },
        "resolved": true,
        "details": {
          "function_name": "clear_inode_flag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1184-1188",
          "snippet": "static inline void clear_inode_flag(struct f2fs_inode_info *fi, int flag)\n{\n\tif (test_bit(flag, &fi->flags))\n\t\tclear_bit(flag, &fi->flags);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void clear_inode_flag(struct f2fs_inode_info *fi, int flag)\n{\n\tif (test_bit(flag, &fi->flags))\n\t\tclear_bit(flag, &fi->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_find_entry",
          "args": [
            "dir",
            "&name",
            "&page"
          ],
          "line": 95
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_find_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/dir.c",
          "lines": "213-243",
          "snippet": "struct f2fs_dir_entry *f2fs_find_entry(struct inode *dir,\n\t\t\tstruct qstr *child, struct page **res_page)\n{\n\tunsigned long npages = dir_blocks(dir);\n\tstruct f2fs_dir_entry *de = NULL;\n\tf2fs_hash_t name_hash;\n\tunsigned int max_depth;\n\tunsigned int level;\n\n\tif (f2fs_has_inline_dentry(dir))\n\t\treturn find_in_inline_dir(dir, child, res_page);\n\n\tif (npages == 0)\n\t\treturn NULL;\n\n\t*res_page = NULL;\n\n\tname_hash = f2fs_dentry_hash(child);\n\tmax_depth = F2FS_I(dir)->i_current_depth;\n\n\tfor (level = 0; level < max_depth; level++) {\n\t\tde = find_in_level(dir, level, child, name_hash, res_page);\n\t\tif (de)\n\t\t\tbreak;\n\t}\n\tif (!de && F2FS_I(dir)->chash != name_hash) {\n\t\tF2FS_I(dir)->chash = name_hash;\n\t\tF2FS_I(dir)->clevel = level - 1;\n\t}\n\treturn de;\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"acl.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstruct f2fs_dir_entry *f2fs_find_entry(struct inode *dir,\n\t\t\tstruct qstr *child, struct page **res_page)\n{\n\tunsigned long npages = dir_blocks(dir);\n\tstruct f2fs_dir_entry *de = NULL;\n\tf2fs_hash_t name_hash;\n\tunsigned int max_depth;\n\tunsigned int level;\n\n\tif (f2fs_has_inline_dentry(dir))\n\t\treturn find_in_inline_dir(dir, child, res_page);\n\n\tif (npages == 0)\n\t\treturn NULL;\n\n\t*res_page = NULL;\n\n\tname_hash = f2fs_dentry_hash(child);\n\tmax_depth = F2FS_I(dir)->i_current_depth;\n\n\tfor (level = 0; level < max_depth; level++) {\n\t\tde = find_in_level(dir, level, child, name_hash, res_page);\n\t\tif (de)\n\t\t\tbreak;\n\t}\n\tif (!de && F2FS_I(dir)->chash != name_hash) {\n\t\tF2FS_I(dir)->chash = name_hash;\n\t\tF2FS_I(dir)->clevel = level - 1;\n\t}\n\treturn de;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "1"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "name.len > F2FS_NAME_LEN"
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "dir"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "dir"
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic int recover_dentry(struct inode *inode, struct page *ipage)\n{\n\tstruct f2fs_inode *raw_inode = F2FS_INODE(ipage);\n\tnid_t pino = le32_to_cpu(raw_inode->i_pino);\n\tstruct f2fs_dir_entry *de;\n\tstruct qstr name;\n\tstruct page *page;\n\tstruct inode *dir, *einode;\n\tint err = 0;\n\n\tdir = f2fs_iget(inode->i_sb, pino);\n\tif (IS_ERR(dir)) {\n\t\terr = PTR_ERR(dir);\n\t\tgoto out;\n\t}\n\n\tname.len = le32_to_cpu(raw_inode->i_namelen);\n\tname.name = raw_inode->i_name;\n\n\tif (unlikely(name.len > F2FS_NAME_LEN)) {\n\t\tWARN_ON(1);\n\t\terr = -ENAMETOOLONG;\n\t\tgoto out_err;\n\t}\nretry:\n\tde = f2fs_find_entry(dir, &name, &page);\n\tif (de && inode->i_ino == le32_to_cpu(de->ino)) {\n\t\tclear_inode_flag(F2FS_I(inode), FI_INC_LINK);\n\t\tgoto out_unmap_put;\n\t}\n\tif (de) {\n\t\teinode = f2fs_iget(inode->i_sb, le32_to_cpu(de->ino));\n\t\tif (IS_ERR(einode)) {\n\t\t\tWARN_ON(1);\n\t\t\terr = PTR_ERR(einode);\n\t\t\tif (err == -ENOENT)\n\t\t\t\terr = -EEXIST;\n\t\t\tgoto out_unmap_put;\n\t\t}\n\t\terr = acquire_orphan_inode(F2FS_I_SB(inode));\n\t\tif (err) {\n\t\t\tiput(einode);\n\t\t\tgoto out_unmap_put;\n\t\t}\n\t\tf2fs_delete_entry(de, page, dir, einode);\n\t\tiput(einode);\n\t\tgoto retry;\n\t}\n\terr = __f2fs_add_link(dir, &name, inode);\n\tif (err)\n\t\tgoto out_err;\n\n\tif (is_inode_flag_set(F2FS_I(dir), FI_DELAY_IPUT)) {\n\t\tiput(dir);\n\t} else {\n\t\tadd_dirty_dir_inode(dir);\n\t\tset_inode_flag(F2FS_I(dir), FI_DELAY_IPUT);\n\t}\n\n\tgoto out;\n\nout_unmap_put:\n\tf2fs_dentry_kunmap(dir, page);\n\tf2fs_put_page(page, 0);\nout_err:\n\tiput(dir);\nout:\n\tf2fs_msg(inode->i_sb, KERN_NOTICE,\n\t\t\t\"%s: ino = %x, name = %s, dir = %lx, err = %d\",\n\t\t\t__func__, ino_of_node(ipage), raw_inode->i_name,\n\t\t\tIS_ERR(dir) ? 0 : dir->i_ino, err);\n\treturn err;\n}"
  },
  {
    "function_name": "get_fsync_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/recovery.c",
    "lines": "58-68",
    "snippet": "static struct fsync_inode_entry *get_fsync_inode(struct list_head *head,\n\t\t\t\t\t\t\t\tnid_t ino)\n{\n\tstruct fsync_inode_entry *entry;\n\n\tlist_for_each_entry(entry, head, list)\n\t\tif (entry->inode->i_ino == ino)\n\t\t\treturn entry;\n\n\treturn NULL;\n}",
    "includes": [
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "entry",
            "head",
            "list"
          ],
          "line": 63
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic struct fsync_inode_entry *get_fsync_inode(struct list_head *head,\n\t\t\t\t\t\t\t\tnid_t ino)\n{\n\tstruct fsync_inode_entry *entry;\n\n\tlist_for_each_entry(entry, head, list)\n\t\tif (entry->inode->i_ino == ino)\n\t\t\treturn entry;\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "space_for_roll_forward",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/recovery.c",
    "lines": "50-56",
    "snippet": "bool space_for_roll_forward(struct f2fs_sb_info *sbi)\n{\n\tif (sbi->last_valid_block_count + sbi->alloc_valid_block_count\n\t\t\t> sbi->user_block_count)\n\t\treturn false;\n\treturn true;\n}",
    "includes": [
      "#include \"segment.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nbool space_for_roll_forward(struct f2fs_sb_info *sbi)\n{\n\tif (sbi->last_valid_block_count + sbi->alloc_valid_block_count\n\t\t\t> sbi->user_block_count)\n\t\treturn false;\n\treturn true;\n}"
  }
]