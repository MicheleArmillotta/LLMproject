[
  {
    "function_name": "sysv_rename",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sysv/namei.c",
    "lines": "208-274",
    "snippet": "static int sysv_rename(struct inode * old_dir, struct dentry * old_dentry,\n\t\t  struct inode * new_dir, struct dentry * new_dentry)\n{\n\tstruct inode * old_inode = old_dentry->d_inode;\n\tstruct inode * new_inode = new_dentry->d_inode;\n\tstruct page * dir_page = NULL;\n\tstruct sysv_dir_entry * dir_de = NULL;\n\tstruct page * old_page;\n\tstruct sysv_dir_entry * old_de;\n\tint err = -ENOENT;\n\n\told_de = sysv_find_entry(old_dentry, &old_page);\n\tif (!old_de)\n\t\tgoto out;\n\n\tif (S_ISDIR(old_inode->i_mode)) {\n\t\terr = -EIO;\n\t\tdir_de = sysv_dotdot(old_inode, &dir_page);\n\t\tif (!dir_de)\n\t\t\tgoto out_old;\n\t}\n\n\tif (new_inode) {\n\t\tstruct page * new_page;\n\t\tstruct sysv_dir_entry * new_de;\n\n\t\terr = -ENOTEMPTY;\n\t\tif (dir_de && !sysv_empty_dir(new_inode))\n\t\t\tgoto out_dir;\n\n\t\terr = -ENOENT;\n\t\tnew_de = sysv_find_entry(new_dentry, &new_page);\n\t\tif (!new_de)\n\t\t\tgoto out_dir;\n\t\tsysv_set_link(new_de, new_page, old_inode);\n\t\tnew_inode->i_ctime = CURRENT_TIME_SEC;\n\t\tif (dir_de)\n\t\t\tdrop_nlink(new_inode);\n\t\tinode_dec_link_count(new_inode);\n\t} else {\n\t\terr = sysv_add_link(new_dentry, old_inode);\n\t\tif (err)\n\t\t\tgoto out_dir;\n\t\tif (dir_de)\n\t\t\tinode_inc_link_count(new_dir);\n\t}\n\n\tsysv_delete_entry(old_de, old_page);\n\tmark_inode_dirty(old_inode);\n\n\tif (dir_de) {\n\t\tsysv_set_link(dir_de, dir_page, new_dir);\n\t\tinode_dec_link_count(old_dir);\n\t}\n\treturn 0;\n\nout_dir:\n\tif (dir_de) {\n\t\tkunmap(dir_page);\n\t\tpage_cache_release(dir_page);\n\t}\nout_old:\n\tkunmap(old_page);\n\tpage_cache_release(old_page);\nout:\n\treturn err;\n}",
    "includes": [
      "#include \"sysv.h\"",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "old_page"
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kunmap",
          "args": [
            "old_page"
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "dir_page"
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kunmap",
          "args": [
            "dir_page"
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode_dec_link_count",
          "args": [
            "old_dir"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sysv_set_link",
          "args": [
            "dir_de",
            "dir_page",
            "new_dir"
          ],
          "line": 259
        },
        "resolved": true,
        "details": {
          "function_name": "sysv_set_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sysv/dir.c",
          "lines": "331-347",
          "snippet": "void sysv_set_link(struct sysv_dir_entry *de, struct page *page,\n\tstruct inode *inode)\n{\n\tstruct inode *dir = page->mapping->host;\n\tloff_t pos = page_offset(page) +\n\t\t\t(char *)de-(char*)page_address(page);\n\tint err;\n\n\tlock_page(page);\n\terr = sysv_prepare_chunk(page, pos, SYSV_DIRSIZE);\n\tBUG_ON(err);\n\tde->inode = cpu_to_fs16(SYSV_SB(inode->i_sb), inode->i_ino);\n\terr = dir_commit_chunk(page, pos, SYSV_DIRSIZE);\n\tdir_put_page(page);\n\tdir->i_mtime = dir->i_ctime = CURRENT_TIME_SEC;\n\tmark_inode_dirty(dir);\n}",
          "includes": [
            "#include \"sysv.h\"",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysv.h\"\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n\nvoid sysv_set_link(struct sysv_dir_entry *de, struct page *page,\n\tstruct inode *inode)\n{\n\tstruct inode *dir = page->mapping->host;\n\tloff_t pos = page_offset(page) +\n\t\t\t(char *)de-(char*)page_address(page);\n\tint err;\n\n\tlock_page(page);\n\terr = sysv_prepare_chunk(page, pos, SYSV_DIRSIZE);\n\tBUG_ON(err);\n\tde->inode = cpu_to_fs16(SYSV_SB(inode->i_sb), inode->i_ino);\n\terr = dir_commit_chunk(page, pos, SYSV_DIRSIZE);\n\tdir_put_page(page);\n\tdir->i_mtime = dir->i_ctime = CURRENT_TIME_SEC;\n\tmark_inode_dirty(dir);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_inode_dirty",
          "args": [
            "old_inode"
          ],
          "line": 256
        },
        "resolved": true,
        "details": {
          "function_name": "block_dump___mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1134-1154",
          "snippet": "static noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sysv_delete_entry",
          "args": [
            "old_de",
            "old_page"
          ],
          "line": 255
        },
        "resolved": true,
        "details": {
          "function_name": "sysv_delete_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sysv/dir.c",
          "lines": "234-250",
          "snippet": "int sysv_delete_entry(struct sysv_dir_entry *de, struct page *page)\n{\n\tstruct inode *inode = page->mapping->host;\n\tchar *kaddr = (char*)page_address(page);\n\tloff_t pos = page_offset(page) + (char *)de - kaddr;\n\tint err;\n\n\tlock_page(page);\n\terr = sysv_prepare_chunk(page, pos, SYSV_DIRSIZE);\n\tBUG_ON(err);\n\tde->inode = 0;\n\terr = dir_commit_chunk(page, pos, SYSV_DIRSIZE);\n\tdir_put_page(page);\n\tinode->i_ctime = inode->i_mtime = CURRENT_TIME_SEC;\n\tmark_inode_dirty(inode);\n\treturn err;\n}",
          "includes": [
            "#include \"sysv.h\"",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysv.h\"\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n\nint sysv_delete_entry(struct sysv_dir_entry *de, struct page *page)\n{\n\tstruct inode *inode = page->mapping->host;\n\tchar *kaddr = (char*)page_address(page);\n\tloff_t pos = page_offset(page) + (char *)de - kaddr;\n\tint err;\n\n\tlock_page(page);\n\terr = sysv_prepare_chunk(page, pos, SYSV_DIRSIZE);\n\tBUG_ON(err);\n\tde->inode = 0;\n\terr = dir_commit_chunk(page, pos, SYSV_DIRSIZE);\n\tdir_put_page(page);\n\tinode->i_ctime = inode->i_mtime = CURRENT_TIME_SEC;\n\tmark_inode_dirty(inode);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_inc_link_count",
          "args": [
            "new_dir"
          ],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sysv_add_link",
          "args": [
            "new_dentry",
            "old_inode"
          ],
          "line": 248
        },
        "resolved": true,
        "details": {
          "function_name": "sysv_add_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sysv/dir.c",
          "lines": "177-232",
          "snippet": "int sysv_add_link(struct dentry *dentry, struct inode *inode)\n{\n\tstruct inode *dir = dentry->d_parent->d_inode;\n\tconst char * name = dentry->d_name.name;\n\tint namelen = dentry->d_name.len;\n\tstruct page *page = NULL;\n\tstruct sysv_dir_entry * de;\n\tunsigned long npages = dir_pages(dir);\n\tunsigned long n;\n\tchar *kaddr;\n\tloff_t pos;\n\tint err;\n\n\t/* We take care of directory expansion in the same loop */\n\tfor (n = 0; n <= npages; n++) {\n\t\tpage = dir_get_page(dir, n);\n\t\terr = PTR_ERR(page);\n\t\tif (IS_ERR(page))\n\t\t\tgoto out;\n\t\tkaddr = (char*)page_address(page);\n\t\tde = (struct sysv_dir_entry *)kaddr;\n\t\tkaddr += PAGE_CACHE_SIZE - SYSV_DIRSIZE;\n\t\twhile ((char *)de <= kaddr) {\n\t\t\tif (!de->inode)\n\t\t\t\tgoto got_it;\n\t\t\terr = -EEXIST;\n\t\t\tif (namecompare(namelen, SYSV_NAMELEN, name, de->name)) \n\t\t\t\tgoto out_page;\n\t\t\tde++;\n\t\t}\n\t\tdir_put_page(page);\n\t}\n\tBUG();\n\treturn -EINVAL;\n\ngot_it:\n\tpos = page_offset(page) +\n\t\t\t(char*)de - (char*)page_address(page);\n\tlock_page(page);\n\terr = sysv_prepare_chunk(page, pos, SYSV_DIRSIZE);\n\tif (err)\n\t\tgoto out_unlock;\n\tmemcpy (de->name, name, namelen);\n\tmemset (de->name + namelen, 0, SYSV_DIRSIZE - namelen - 2);\n\tde->inode = cpu_to_fs16(SYSV_SB(inode->i_sb), inode->i_ino);\n\terr = dir_commit_chunk(page, pos, SYSV_DIRSIZE);\n\tdir->i_mtime = dir->i_ctime = CURRENT_TIME_SEC;\n\tmark_inode_dirty(dir);\nout_page:\n\tdir_put_page(page);\nout:\n\treturn err;\nout_unlock:\n\tunlock_page(page);\n\tgoto out_page;\n}",
          "includes": [
            "#include \"sysv.h\"",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysv.h\"\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n\nint sysv_add_link(struct dentry *dentry, struct inode *inode)\n{\n\tstruct inode *dir = dentry->d_parent->d_inode;\n\tconst char * name = dentry->d_name.name;\n\tint namelen = dentry->d_name.len;\n\tstruct page *page = NULL;\n\tstruct sysv_dir_entry * de;\n\tunsigned long npages = dir_pages(dir);\n\tunsigned long n;\n\tchar *kaddr;\n\tloff_t pos;\n\tint err;\n\n\t/* We take care of directory expansion in the same loop */\n\tfor (n = 0; n <= npages; n++) {\n\t\tpage = dir_get_page(dir, n);\n\t\terr = PTR_ERR(page);\n\t\tif (IS_ERR(page))\n\t\t\tgoto out;\n\t\tkaddr = (char*)page_address(page);\n\t\tde = (struct sysv_dir_entry *)kaddr;\n\t\tkaddr += PAGE_CACHE_SIZE - SYSV_DIRSIZE;\n\t\twhile ((char *)de <= kaddr) {\n\t\t\tif (!de->inode)\n\t\t\t\tgoto got_it;\n\t\t\terr = -EEXIST;\n\t\t\tif (namecompare(namelen, SYSV_NAMELEN, name, de->name)) \n\t\t\t\tgoto out_page;\n\t\t\tde++;\n\t\t}\n\t\tdir_put_page(page);\n\t}\n\tBUG();\n\treturn -EINVAL;\n\ngot_it:\n\tpos = page_offset(page) +\n\t\t\t(char*)de - (char*)page_address(page);\n\tlock_page(page);\n\terr = sysv_prepare_chunk(page, pos, SYSV_DIRSIZE);\n\tif (err)\n\t\tgoto out_unlock;\n\tmemcpy (de->name, name, namelen);\n\tmemset (de->name + namelen, 0, SYSV_DIRSIZE - namelen - 2);\n\tde->inode = cpu_to_fs16(SYSV_SB(inode->i_sb), inode->i_ino);\n\terr = dir_commit_chunk(page, pos, SYSV_DIRSIZE);\n\tdir->i_mtime = dir->i_ctime = CURRENT_TIME_SEC;\n\tmark_inode_dirty(dir);\nout_page:\n\tdir_put_page(page);\nout:\n\treturn err;\nout_unlock:\n\tunlock_page(page);\n\tgoto out_page;\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_dec_link_count",
          "args": [
            "new_inode"
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "drop_nlink",
          "args": [
            "new_inode"
          ],
          "line": 245
        },
        "resolved": true,
        "details": {
          "function_name": "drop_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "271-277",
          "snippet": "void drop_nlink(struct inode *inode)\n{\n\tWARN_ON(inode->i_nlink == 0);\n\tinode->__i_nlink--;\n\tif (!inode->i_nlink)\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid drop_nlink(struct inode *inode)\n{\n\tWARN_ON(inode->i_nlink == 0);\n\tinode->__i_nlink--;\n\tif (!inode->i_nlink)\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sysv_find_entry",
          "args": [
            "new_dentry",
            "&new_page"
          ],
          "line": 239
        },
        "resolved": true,
        "details": {
          "function_name": "sysv_find_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sysv/dir.c",
          "lines": "131-175",
          "snippet": "struct sysv_dir_entry *sysv_find_entry(struct dentry *dentry, struct page **res_page)\n{\n\tconst char * name = dentry->d_name.name;\n\tint namelen = dentry->d_name.len;\n\tstruct inode * dir = dentry->d_parent->d_inode;\n\tunsigned long start, n;\n\tunsigned long npages = dir_pages(dir);\n\tstruct page *page = NULL;\n\tstruct sysv_dir_entry *de;\n\n\t*res_page = NULL;\n\n\tstart = SYSV_I(dir)->i_dir_start_lookup;\n\tif (start >= npages)\n\t\tstart = 0;\n\tn = start;\n\n\tdo {\n\t\tchar *kaddr;\n\t\tpage = dir_get_page(dir, n);\n\t\tif (!IS_ERR(page)) {\n\t\t\tkaddr = (char*)page_address(page);\n\t\t\tde = (struct sysv_dir_entry *) kaddr;\n\t\t\tkaddr += PAGE_CACHE_SIZE - SYSV_DIRSIZE;\n\t\t\tfor ( ; (char *) de <= kaddr ; de++) {\n\t\t\t\tif (!de->inode)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (namecompare(namelen, SYSV_NAMELEN,\n\t\t\t\t\t\t\tname, de->name))\n\t\t\t\t\tgoto found;\n\t\t\t}\n\t\t\tdir_put_page(page);\n\t\t}\n\n\t\tif (++n >= npages)\n\t\t\tn = 0;\n\t} while (n != start);\n\n\treturn NULL;\n\nfound:\n\tSYSV_I(dir)->i_dir_start_lookup = n;\n\t*res_page = page;\n\treturn de;\n}",
          "includes": [
            "#include \"sysv.h\"",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysv.h\"\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n\nstruct sysv_dir_entry *sysv_find_entry(struct dentry *dentry, struct page **res_page)\n{\n\tconst char * name = dentry->d_name.name;\n\tint namelen = dentry->d_name.len;\n\tstruct inode * dir = dentry->d_parent->d_inode;\n\tunsigned long start, n;\n\tunsigned long npages = dir_pages(dir);\n\tstruct page *page = NULL;\n\tstruct sysv_dir_entry *de;\n\n\t*res_page = NULL;\n\n\tstart = SYSV_I(dir)->i_dir_start_lookup;\n\tif (start >= npages)\n\t\tstart = 0;\n\tn = start;\n\n\tdo {\n\t\tchar *kaddr;\n\t\tpage = dir_get_page(dir, n);\n\t\tif (!IS_ERR(page)) {\n\t\t\tkaddr = (char*)page_address(page);\n\t\t\tde = (struct sysv_dir_entry *) kaddr;\n\t\t\tkaddr += PAGE_CACHE_SIZE - SYSV_DIRSIZE;\n\t\t\tfor ( ; (char *) de <= kaddr ; de++) {\n\t\t\t\tif (!de->inode)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (namecompare(namelen, SYSV_NAMELEN,\n\t\t\t\t\t\t\tname, de->name))\n\t\t\t\t\tgoto found;\n\t\t\t}\n\t\t\tdir_put_page(page);\n\t\t}\n\n\t\tif (++n >= npages)\n\t\t\tn = 0;\n\t} while (n != start);\n\n\treturn NULL;\n\nfound:\n\tSYSV_I(dir)->i_dir_start_lookup = n;\n\t*res_page = page;\n\treturn de;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sysv_empty_dir",
          "args": [
            "new_inode"
          ],
          "line": 235
        },
        "resolved": true,
        "details": {
          "function_name": "sysv_empty_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sysv/dir.c",
          "lines": "288-328",
          "snippet": "int sysv_empty_dir(struct inode * inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct page *page = NULL;\n\tunsigned long i, npages = dir_pages(inode);\n\n\tfor (i = 0; i < npages; i++) {\n\t\tchar *kaddr;\n\t\tstruct sysv_dir_entry * de;\n\t\tpage = dir_get_page(inode, i);\n\n\t\tif (IS_ERR(page))\n\t\t\tcontinue;\n\n\t\tkaddr = (char *)page_address(page);\n\t\tde = (struct sysv_dir_entry *)kaddr;\n\t\tkaddr += PAGE_CACHE_SIZE-SYSV_DIRSIZE;\n\n\t\tfor ( ;(char *)de <= kaddr; de++) {\n\t\t\tif (!de->inode)\n\t\t\t\tcontinue;\n\t\t\t/* check for . and .. */\n\t\t\tif (de->name[0] != '.')\n\t\t\t\tgoto not_empty;\n\t\t\tif (!de->name[1]) {\n\t\t\t\tif (de->inode == cpu_to_fs16(SYSV_SB(sb),\n\t\t\t\t\t\t\tinode->i_ino))\n\t\t\t\t\tcontinue;\n\t\t\t\tgoto not_empty;\n\t\t\t}\n\t\t\tif (de->name[1] != '.' || de->name[2])\n\t\t\t\tgoto not_empty;\n\t\t}\n\t\tdir_put_page(page);\n\t}\n\treturn 1;\n\nnot_empty:\n\tdir_put_page(page);\n\treturn 0;\n}",
          "includes": [
            "#include \"sysv.h\"",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysv.h\"\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n\nint sysv_empty_dir(struct inode * inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct page *page = NULL;\n\tunsigned long i, npages = dir_pages(inode);\n\n\tfor (i = 0; i < npages; i++) {\n\t\tchar *kaddr;\n\t\tstruct sysv_dir_entry * de;\n\t\tpage = dir_get_page(inode, i);\n\n\t\tif (IS_ERR(page))\n\t\t\tcontinue;\n\n\t\tkaddr = (char *)page_address(page);\n\t\tde = (struct sysv_dir_entry *)kaddr;\n\t\tkaddr += PAGE_CACHE_SIZE-SYSV_DIRSIZE;\n\n\t\tfor ( ;(char *)de <= kaddr; de++) {\n\t\t\tif (!de->inode)\n\t\t\t\tcontinue;\n\t\t\t/* check for . and .. */\n\t\t\tif (de->name[0] != '.')\n\t\t\t\tgoto not_empty;\n\t\t\tif (!de->name[1]) {\n\t\t\t\tif (de->inode == cpu_to_fs16(SYSV_SB(sb),\n\t\t\t\t\t\t\tinode->i_ino))\n\t\t\t\t\tcontinue;\n\t\t\t\tgoto not_empty;\n\t\t\t}\n\t\t\tif (de->name[1] != '.' || de->name[2])\n\t\t\t\tgoto not_empty;\n\t\t}\n\t\tdir_put_page(page);\n\t}\n\treturn 1;\n\nnot_empty:\n\tdir_put_page(page);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sysv_dotdot",
          "args": [
            "old_inode",
            "&dir_page"
          ],
          "line": 225
        },
        "resolved": true,
        "details": {
          "function_name": "sysv_dotdot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sysv/dir.c",
          "lines": "349-359",
          "snippet": "struct sysv_dir_entry * sysv_dotdot (struct inode *dir, struct page **p)\n{\n\tstruct page *page = dir_get_page(dir, 0);\n\tstruct sysv_dir_entry *de = NULL;\n\n\tif (!IS_ERR(page)) {\n\t\tde = (struct sysv_dir_entry*) page_address(page) + 1;\n\t\t*p = page;\n\t}\n\treturn de;\n}",
          "includes": [
            "#include \"sysv.h\"",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysv.h\"\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n\nstruct sysv_dir_entry * sysv_dotdot (struct inode *dir, struct page **p)\n{\n\tstruct page *page = dir_get_page(dir, 0);\n\tstruct sysv_dir_entry *de = NULL;\n\n\tif (!IS_ERR(page)) {\n\t\tde = (struct sysv_dir_entry*) page_address(page) + 1;\n\t\t*p = page;\n\t}\n\treturn de;\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "old_inode->i_mode"
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sysv.h\"\n#include <linux/pagemap.h>\n\nstatic int sysv_rename(struct inode * old_dir, struct dentry * old_dentry,\n\t\t  struct inode * new_dir, struct dentry * new_dentry)\n{\n\tstruct inode * old_inode = old_dentry->d_inode;\n\tstruct inode * new_inode = new_dentry->d_inode;\n\tstruct page * dir_page = NULL;\n\tstruct sysv_dir_entry * dir_de = NULL;\n\tstruct page * old_page;\n\tstruct sysv_dir_entry * old_de;\n\tint err = -ENOENT;\n\n\told_de = sysv_find_entry(old_dentry, &old_page);\n\tif (!old_de)\n\t\tgoto out;\n\n\tif (S_ISDIR(old_inode->i_mode)) {\n\t\terr = -EIO;\n\t\tdir_de = sysv_dotdot(old_inode, &dir_page);\n\t\tif (!dir_de)\n\t\t\tgoto out_old;\n\t}\n\n\tif (new_inode) {\n\t\tstruct page * new_page;\n\t\tstruct sysv_dir_entry * new_de;\n\n\t\terr = -ENOTEMPTY;\n\t\tif (dir_de && !sysv_empty_dir(new_inode))\n\t\t\tgoto out_dir;\n\n\t\terr = -ENOENT;\n\t\tnew_de = sysv_find_entry(new_dentry, &new_page);\n\t\tif (!new_de)\n\t\t\tgoto out_dir;\n\t\tsysv_set_link(new_de, new_page, old_inode);\n\t\tnew_inode->i_ctime = CURRENT_TIME_SEC;\n\t\tif (dir_de)\n\t\t\tdrop_nlink(new_inode);\n\t\tinode_dec_link_count(new_inode);\n\t} else {\n\t\terr = sysv_add_link(new_dentry, old_inode);\n\t\tif (err)\n\t\t\tgoto out_dir;\n\t\tif (dir_de)\n\t\t\tinode_inc_link_count(new_dir);\n\t}\n\n\tsysv_delete_entry(old_de, old_page);\n\tmark_inode_dirty(old_inode);\n\n\tif (dir_de) {\n\t\tsysv_set_link(dir_de, dir_page, new_dir);\n\t\tinode_dec_link_count(old_dir);\n\t}\n\treturn 0;\n\nout_dir:\n\tif (dir_de) {\n\t\tkunmap(dir_page);\n\t\tpage_cache_release(dir_page);\n\t}\nout_old:\n\tkunmap(old_page);\n\tpage_cache_release(old_page);\nout:\n\treturn err;\n}"
  },
  {
    "function_name": "sysv_rmdir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sysv/namei.c",
    "lines": "188-202",
    "snippet": "static int sysv_rmdir(struct inode * dir, struct dentry * dentry)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tint err = -ENOTEMPTY;\n\n\tif (sysv_empty_dir(inode)) {\n\t\terr = sysv_unlink(dir, dentry);\n\t\tif (!err) {\n\t\t\tinode->i_size = 0;\n\t\t\tinode_dec_link_count(inode);\n\t\t\tinode_dec_link_count(dir);\n\t\t}\n\t}\n\treturn err;\n}",
    "includes": [
      "#include \"sysv.h\"",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "inode_dec_link_count",
          "args": [
            "dir"
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode_dec_link_count",
          "args": [
            "inode"
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sysv_unlink",
          "args": [
            "dir",
            "dentry"
          ],
          "line": 194
        },
        "resolved": true,
        "details": {
          "function_name": "sysv_unlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sysv/namei.c",
          "lines": "167-186",
          "snippet": "static int sysv_unlink(struct inode * dir, struct dentry * dentry)\n{\n\tstruct inode * inode = dentry->d_inode;\n\tstruct page * page;\n\tstruct sysv_dir_entry * de;\n\tint err = -ENOENT;\n\n\tde = sysv_find_entry(dentry, &page);\n\tif (!de)\n\t\tgoto out;\n\n\terr = sysv_delete_entry (de, page);\n\tif (err)\n\t\tgoto out;\n\n\tinode->i_ctime = dir->i_ctime;\n\tinode_dec_link_count(inode);\nout:\n\treturn err;\n}",
          "includes": [
            "#include \"sysv.h\"",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysv.h\"\n#include <linux/pagemap.h>\n\nstatic int sysv_unlink(struct inode * dir, struct dentry * dentry)\n{\n\tstruct inode * inode = dentry->d_inode;\n\tstruct page * page;\n\tstruct sysv_dir_entry * de;\n\tint err = -ENOENT;\n\n\tde = sysv_find_entry(dentry, &page);\n\tif (!de)\n\t\tgoto out;\n\n\terr = sysv_delete_entry (de, page);\n\tif (err)\n\t\tgoto out;\n\n\tinode->i_ctime = dir->i_ctime;\n\tinode_dec_link_count(inode);\nout:\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sysv_empty_dir",
          "args": [
            "inode"
          ],
          "line": 193
        },
        "resolved": true,
        "details": {
          "function_name": "sysv_empty_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sysv/dir.c",
          "lines": "288-328",
          "snippet": "int sysv_empty_dir(struct inode * inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct page *page = NULL;\n\tunsigned long i, npages = dir_pages(inode);\n\n\tfor (i = 0; i < npages; i++) {\n\t\tchar *kaddr;\n\t\tstruct sysv_dir_entry * de;\n\t\tpage = dir_get_page(inode, i);\n\n\t\tif (IS_ERR(page))\n\t\t\tcontinue;\n\n\t\tkaddr = (char *)page_address(page);\n\t\tde = (struct sysv_dir_entry *)kaddr;\n\t\tkaddr += PAGE_CACHE_SIZE-SYSV_DIRSIZE;\n\n\t\tfor ( ;(char *)de <= kaddr; de++) {\n\t\t\tif (!de->inode)\n\t\t\t\tcontinue;\n\t\t\t/* check for . and .. */\n\t\t\tif (de->name[0] != '.')\n\t\t\t\tgoto not_empty;\n\t\t\tif (!de->name[1]) {\n\t\t\t\tif (de->inode == cpu_to_fs16(SYSV_SB(sb),\n\t\t\t\t\t\t\tinode->i_ino))\n\t\t\t\t\tcontinue;\n\t\t\t\tgoto not_empty;\n\t\t\t}\n\t\t\tif (de->name[1] != '.' || de->name[2])\n\t\t\t\tgoto not_empty;\n\t\t}\n\t\tdir_put_page(page);\n\t}\n\treturn 1;\n\nnot_empty:\n\tdir_put_page(page);\n\treturn 0;\n}",
          "includes": [
            "#include \"sysv.h\"",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysv.h\"\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n\nint sysv_empty_dir(struct inode * inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct page *page = NULL;\n\tunsigned long i, npages = dir_pages(inode);\n\n\tfor (i = 0; i < npages; i++) {\n\t\tchar *kaddr;\n\t\tstruct sysv_dir_entry * de;\n\t\tpage = dir_get_page(inode, i);\n\n\t\tif (IS_ERR(page))\n\t\t\tcontinue;\n\n\t\tkaddr = (char *)page_address(page);\n\t\tde = (struct sysv_dir_entry *)kaddr;\n\t\tkaddr += PAGE_CACHE_SIZE-SYSV_DIRSIZE;\n\n\t\tfor ( ;(char *)de <= kaddr; de++) {\n\t\t\tif (!de->inode)\n\t\t\t\tcontinue;\n\t\t\t/* check for . and .. */\n\t\t\tif (de->name[0] != '.')\n\t\t\t\tgoto not_empty;\n\t\t\tif (!de->name[1]) {\n\t\t\t\tif (de->inode == cpu_to_fs16(SYSV_SB(sb),\n\t\t\t\t\t\t\tinode->i_ino))\n\t\t\t\t\tcontinue;\n\t\t\t\tgoto not_empty;\n\t\t\t}\n\t\t\tif (de->name[1] != '.' || de->name[2])\n\t\t\t\tgoto not_empty;\n\t\t}\n\t\tdir_put_page(page);\n\t}\n\treturn 1;\n\nnot_empty:\n\tdir_put_page(page);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sysv.h\"\n#include <linux/pagemap.h>\n\nstatic int sysv_rmdir(struct inode * dir, struct dentry * dentry)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tint err = -ENOTEMPTY;\n\n\tif (sysv_empty_dir(inode)) {\n\t\terr = sysv_unlink(dir, dentry);\n\t\tif (!err) {\n\t\t\tinode->i_size = 0;\n\t\t\tinode_dec_link_count(inode);\n\t\t\tinode_dec_link_count(dir);\n\t\t}\n\t}\n\treturn err;\n}"
  },
  {
    "function_name": "sysv_unlink",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sysv/namei.c",
    "lines": "167-186",
    "snippet": "static int sysv_unlink(struct inode * dir, struct dentry * dentry)\n{\n\tstruct inode * inode = dentry->d_inode;\n\tstruct page * page;\n\tstruct sysv_dir_entry * de;\n\tint err = -ENOENT;\n\n\tde = sysv_find_entry(dentry, &page);\n\tif (!de)\n\t\tgoto out;\n\n\terr = sysv_delete_entry (de, page);\n\tif (err)\n\t\tgoto out;\n\n\tinode->i_ctime = dir->i_ctime;\n\tinode_dec_link_count(inode);\nout:\n\treturn err;\n}",
    "includes": [
      "#include \"sysv.h\"",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "inode_dec_link_count",
          "args": [
            "inode"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sysv_delete_entry",
          "args": [
            "de",
            "page"
          ],
          "line": 178
        },
        "resolved": true,
        "details": {
          "function_name": "sysv_delete_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sysv/dir.c",
          "lines": "234-250",
          "snippet": "int sysv_delete_entry(struct sysv_dir_entry *de, struct page *page)\n{\n\tstruct inode *inode = page->mapping->host;\n\tchar *kaddr = (char*)page_address(page);\n\tloff_t pos = page_offset(page) + (char *)de - kaddr;\n\tint err;\n\n\tlock_page(page);\n\terr = sysv_prepare_chunk(page, pos, SYSV_DIRSIZE);\n\tBUG_ON(err);\n\tde->inode = 0;\n\terr = dir_commit_chunk(page, pos, SYSV_DIRSIZE);\n\tdir_put_page(page);\n\tinode->i_ctime = inode->i_mtime = CURRENT_TIME_SEC;\n\tmark_inode_dirty(inode);\n\treturn err;\n}",
          "includes": [
            "#include \"sysv.h\"",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysv.h\"\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n\nint sysv_delete_entry(struct sysv_dir_entry *de, struct page *page)\n{\n\tstruct inode *inode = page->mapping->host;\n\tchar *kaddr = (char*)page_address(page);\n\tloff_t pos = page_offset(page) + (char *)de - kaddr;\n\tint err;\n\n\tlock_page(page);\n\terr = sysv_prepare_chunk(page, pos, SYSV_DIRSIZE);\n\tBUG_ON(err);\n\tde->inode = 0;\n\terr = dir_commit_chunk(page, pos, SYSV_DIRSIZE);\n\tdir_put_page(page);\n\tinode->i_ctime = inode->i_mtime = CURRENT_TIME_SEC;\n\tmark_inode_dirty(inode);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sysv_find_entry",
          "args": [
            "dentry",
            "&page"
          ],
          "line": 174
        },
        "resolved": true,
        "details": {
          "function_name": "sysv_find_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sysv/dir.c",
          "lines": "131-175",
          "snippet": "struct sysv_dir_entry *sysv_find_entry(struct dentry *dentry, struct page **res_page)\n{\n\tconst char * name = dentry->d_name.name;\n\tint namelen = dentry->d_name.len;\n\tstruct inode * dir = dentry->d_parent->d_inode;\n\tunsigned long start, n;\n\tunsigned long npages = dir_pages(dir);\n\tstruct page *page = NULL;\n\tstruct sysv_dir_entry *de;\n\n\t*res_page = NULL;\n\n\tstart = SYSV_I(dir)->i_dir_start_lookup;\n\tif (start >= npages)\n\t\tstart = 0;\n\tn = start;\n\n\tdo {\n\t\tchar *kaddr;\n\t\tpage = dir_get_page(dir, n);\n\t\tif (!IS_ERR(page)) {\n\t\t\tkaddr = (char*)page_address(page);\n\t\t\tde = (struct sysv_dir_entry *) kaddr;\n\t\t\tkaddr += PAGE_CACHE_SIZE - SYSV_DIRSIZE;\n\t\t\tfor ( ; (char *) de <= kaddr ; de++) {\n\t\t\t\tif (!de->inode)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (namecompare(namelen, SYSV_NAMELEN,\n\t\t\t\t\t\t\tname, de->name))\n\t\t\t\t\tgoto found;\n\t\t\t}\n\t\t\tdir_put_page(page);\n\t\t}\n\n\t\tif (++n >= npages)\n\t\t\tn = 0;\n\t} while (n != start);\n\n\treturn NULL;\n\nfound:\n\tSYSV_I(dir)->i_dir_start_lookup = n;\n\t*res_page = page;\n\treturn de;\n}",
          "includes": [
            "#include \"sysv.h\"",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysv.h\"\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n\nstruct sysv_dir_entry *sysv_find_entry(struct dentry *dentry, struct page **res_page)\n{\n\tconst char * name = dentry->d_name.name;\n\tint namelen = dentry->d_name.len;\n\tstruct inode * dir = dentry->d_parent->d_inode;\n\tunsigned long start, n;\n\tunsigned long npages = dir_pages(dir);\n\tstruct page *page = NULL;\n\tstruct sysv_dir_entry *de;\n\n\t*res_page = NULL;\n\n\tstart = SYSV_I(dir)->i_dir_start_lookup;\n\tif (start >= npages)\n\t\tstart = 0;\n\tn = start;\n\n\tdo {\n\t\tchar *kaddr;\n\t\tpage = dir_get_page(dir, n);\n\t\tif (!IS_ERR(page)) {\n\t\t\tkaddr = (char*)page_address(page);\n\t\t\tde = (struct sysv_dir_entry *) kaddr;\n\t\t\tkaddr += PAGE_CACHE_SIZE - SYSV_DIRSIZE;\n\t\t\tfor ( ; (char *) de <= kaddr ; de++) {\n\t\t\t\tif (!de->inode)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (namecompare(namelen, SYSV_NAMELEN,\n\t\t\t\t\t\t\tname, de->name))\n\t\t\t\t\tgoto found;\n\t\t\t}\n\t\t\tdir_put_page(page);\n\t\t}\n\n\t\tif (++n >= npages)\n\t\t\tn = 0;\n\t} while (n != start);\n\n\treturn NULL;\n\nfound:\n\tSYSV_I(dir)->i_dir_start_lookup = n;\n\t*res_page = page;\n\treturn de;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sysv.h\"\n#include <linux/pagemap.h>\n\nstatic int sysv_unlink(struct inode * dir, struct dentry * dentry)\n{\n\tstruct inode * inode = dentry->d_inode;\n\tstruct page * page;\n\tstruct sysv_dir_entry * de;\n\tint err = -ENOENT;\n\n\tde = sysv_find_entry(dentry, &page);\n\tif (!de)\n\t\tgoto out;\n\n\terr = sysv_delete_entry (de, page);\n\tif (err)\n\t\tgoto out;\n\n\tinode->i_ctime = dir->i_ctime;\n\tinode_dec_link_count(inode);\nout:\n\treturn err;\n}"
  },
  {
    "function_name": "sysv_mkdir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sysv/namei.c",
    "lines": "130-165",
    "snippet": "static int sysv_mkdir(struct inode * dir, struct dentry *dentry, umode_t mode)\n{\n\tstruct inode * inode;\n\tint err;\n\n\tinode_inc_link_count(dir);\n\n\tinode = sysv_new_inode(dir, S_IFDIR|mode);\n\terr = PTR_ERR(inode);\n\tif (IS_ERR(inode))\n\t\tgoto out_dir;\n\n\tsysv_set_inode(inode, 0);\n\n\tinode_inc_link_count(inode);\n\n\terr = sysv_make_empty(inode, dir);\n\tif (err)\n\t\tgoto out_fail;\n\n\terr = sysv_add_link(dentry, inode);\n\tif (err)\n\t\tgoto out_fail;\n\n        d_instantiate(dentry, inode);\nout:\n\treturn err;\n\nout_fail:\n\tinode_dec_link_count(inode);\n\tinode_dec_link_count(inode);\n\tiput(inode);\nout_dir:\n\tinode_dec_link_count(dir);\n\tgoto out;\n}",
    "includes": [
      "#include \"sysv.h\"",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "inode_dec_link_count",
          "args": [
            "dir"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "inode"
          ],
          "line": 161
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_dec_link_count",
          "args": [
            "inode"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode_dec_link_count",
          "args": [
            "inode"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_instantiate",
          "args": [
            "dentry",
            "inode"
          ],
          "line": 154
        },
        "resolved": true,
        "details": {
          "function_name": "d_instantiate_no_diralias",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1839-1854",
          "snippet": "int d_instantiate_no_diralias(struct dentry *entry, struct inode *inode)\n{\n\tBUG_ON(!hlist_unhashed(&entry->d_u.d_alias));\n\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode) && !hlist_empty(&inode->i_dentry)) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tiput(inode);\n\t\treturn -EBUSY;\n\t}\n\t__d_instantiate(entry, inode);\n\tspin_unlock(&inode->i_lock);\n\tsecurity_d_instantiate(entry, inode);\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nint d_instantiate_no_diralias(struct dentry *entry, struct inode *inode)\n{\n\tBUG_ON(!hlist_unhashed(&entry->d_u.d_alias));\n\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode) && !hlist_empty(&inode->i_dentry)) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tiput(inode);\n\t\treturn -EBUSY;\n\t}\n\t__d_instantiate(entry, inode);\n\tspin_unlock(&inode->i_lock);\n\tsecurity_d_instantiate(entry, inode);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sysv_add_link",
          "args": [
            "dentry",
            "inode"
          ],
          "line": 150
        },
        "resolved": true,
        "details": {
          "function_name": "sysv_add_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sysv/dir.c",
          "lines": "177-232",
          "snippet": "int sysv_add_link(struct dentry *dentry, struct inode *inode)\n{\n\tstruct inode *dir = dentry->d_parent->d_inode;\n\tconst char * name = dentry->d_name.name;\n\tint namelen = dentry->d_name.len;\n\tstruct page *page = NULL;\n\tstruct sysv_dir_entry * de;\n\tunsigned long npages = dir_pages(dir);\n\tunsigned long n;\n\tchar *kaddr;\n\tloff_t pos;\n\tint err;\n\n\t/* We take care of directory expansion in the same loop */\n\tfor (n = 0; n <= npages; n++) {\n\t\tpage = dir_get_page(dir, n);\n\t\terr = PTR_ERR(page);\n\t\tif (IS_ERR(page))\n\t\t\tgoto out;\n\t\tkaddr = (char*)page_address(page);\n\t\tde = (struct sysv_dir_entry *)kaddr;\n\t\tkaddr += PAGE_CACHE_SIZE - SYSV_DIRSIZE;\n\t\twhile ((char *)de <= kaddr) {\n\t\t\tif (!de->inode)\n\t\t\t\tgoto got_it;\n\t\t\terr = -EEXIST;\n\t\t\tif (namecompare(namelen, SYSV_NAMELEN, name, de->name)) \n\t\t\t\tgoto out_page;\n\t\t\tde++;\n\t\t}\n\t\tdir_put_page(page);\n\t}\n\tBUG();\n\treturn -EINVAL;\n\ngot_it:\n\tpos = page_offset(page) +\n\t\t\t(char*)de - (char*)page_address(page);\n\tlock_page(page);\n\terr = sysv_prepare_chunk(page, pos, SYSV_DIRSIZE);\n\tif (err)\n\t\tgoto out_unlock;\n\tmemcpy (de->name, name, namelen);\n\tmemset (de->name + namelen, 0, SYSV_DIRSIZE - namelen - 2);\n\tde->inode = cpu_to_fs16(SYSV_SB(inode->i_sb), inode->i_ino);\n\terr = dir_commit_chunk(page, pos, SYSV_DIRSIZE);\n\tdir->i_mtime = dir->i_ctime = CURRENT_TIME_SEC;\n\tmark_inode_dirty(dir);\nout_page:\n\tdir_put_page(page);\nout:\n\treturn err;\nout_unlock:\n\tunlock_page(page);\n\tgoto out_page;\n}",
          "includes": [
            "#include \"sysv.h\"",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysv.h\"\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n\nint sysv_add_link(struct dentry *dentry, struct inode *inode)\n{\n\tstruct inode *dir = dentry->d_parent->d_inode;\n\tconst char * name = dentry->d_name.name;\n\tint namelen = dentry->d_name.len;\n\tstruct page *page = NULL;\n\tstruct sysv_dir_entry * de;\n\tunsigned long npages = dir_pages(dir);\n\tunsigned long n;\n\tchar *kaddr;\n\tloff_t pos;\n\tint err;\n\n\t/* We take care of directory expansion in the same loop */\n\tfor (n = 0; n <= npages; n++) {\n\t\tpage = dir_get_page(dir, n);\n\t\terr = PTR_ERR(page);\n\t\tif (IS_ERR(page))\n\t\t\tgoto out;\n\t\tkaddr = (char*)page_address(page);\n\t\tde = (struct sysv_dir_entry *)kaddr;\n\t\tkaddr += PAGE_CACHE_SIZE - SYSV_DIRSIZE;\n\t\twhile ((char *)de <= kaddr) {\n\t\t\tif (!de->inode)\n\t\t\t\tgoto got_it;\n\t\t\terr = -EEXIST;\n\t\t\tif (namecompare(namelen, SYSV_NAMELEN, name, de->name)) \n\t\t\t\tgoto out_page;\n\t\t\tde++;\n\t\t}\n\t\tdir_put_page(page);\n\t}\n\tBUG();\n\treturn -EINVAL;\n\ngot_it:\n\tpos = page_offset(page) +\n\t\t\t(char*)de - (char*)page_address(page);\n\tlock_page(page);\n\terr = sysv_prepare_chunk(page, pos, SYSV_DIRSIZE);\n\tif (err)\n\t\tgoto out_unlock;\n\tmemcpy (de->name, name, namelen);\n\tmemset (de->name + namelen, 0, SYSV_DIRSIZE - namelen - 2);\n\tde->inode = cpu_to_fs16(SYSV_SB(inode->i_sb), inode->i_ino);\n\terr = dir_commit_chunk(page, pos, SYSV_DIRSIZE);\n\tdir->i_mtime = dir->i_ctime = CURRENT_TIME_SEC;\n\tmark_inode_dirty(dir);\nout_page:\n\tdir_put_page(page);\nout:\n\treturn err;\nout_unlock:\n\tunlock_page(page);\n\tgoto out_page;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sysv_make_empty",
          "args": [
            "inode",
            "dir"
          ],
          "line": 146
        },
        "resolved": true,
        "details": {
          "function_name": "sysv_make_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sysv/dir.c",
          "lines": "252-283",
          "snippet": "int sysv_make_empty(struct inode *inode, struct inode *dir)\n{\n\tstruct page *page = grab_cache_page(inode->i_mapping, 0);\n\tstruct sysv_dir_entry * de;\n\tchar *base;\n\tint err;\n\n\tif (!page)\n\t\treturn -ENOMEM;\n\terr = sysv_prepare_chunk(page, 0, 2 * SYSV_DIRSIZE);\n\tif (err) {\n\t\tunlock_page(page);\n\t\tgoto fail;\n\t}\n\tkmap(page);\n\n\tbase = (char*)page_address(page);\n\tmemset(base, 0, PAGE_CACHE_SIZE);\n\n\tde = (struct sysv_dir_entry *) base;\n\tde->inode = cpu_to_fs16(SYSV_SB(inode->i_sb), inode->i_ino);\n\tstrcpy(de->name,\".\");\n\tde++;\n\tde->inode = cpu_to_fs16(SYSV_SB(inode->i_sb), dir->i_ino);\n\tstrcpy(de->name,\"..\");\n\n\tkunmap(page);\n\terr = dir_commit_chunk(page, 0, 2 * SYSV_DIRSIZE);\nfail:\n\tpage_cache_release(page);\n\treturn err;\n}",
          "includes": [
            "#include \"sysv.h\"",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysv.h\"\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n\nint sysv_make_empty(struct inode *inode, struct inode *dir)\n{\n\tstruct page *page = grab_cache_page(inode->i_mapping, 0);\n\tstruct sysv_dir_entry * de;\n\tchar *base;\n\tint err;\n\n\tif (!page)\n\t\treturn -ENOMEM;\n\terr = sysv_prepare_chunk(page, 0, 2 * SYSV_DIRSIZE);\n\tif (err) {\n\t\tunlock_page(page);\n\t\tgoto fail;\n\t}\n\tkmap(page);\n\n\tbase = (char*)page_address(page);\n\tmemset(base, 0, PAGE_CACHE_SIZE);\n\n\tde = (struct sysv_dir_entry *) base;\n\tde->inode = cpu_to_fs16(SYSV_SB(inode->i_sb), inode->i_ino);\n\tstrcpy(de->name,\".\");\n\tde++;\n\tde->inode = cpu_to_fs16(SYSV_SB(inode->i_sb), dir->i_ino);\n\tstrcpy(de->name,\"..\");\n\n\tkunmap(page);\n\terr = dir_commit_chunk(page, 0, 2 * SYSV_DIRSIZE);\nfail:\n\tpage_cache_release(page);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_inc_link_count",
          "args": [
            "inode"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sysv_set_inode",
          "args": [
            "inode",
            "0"
          ],
          "line": 142
        },
        "resolved": true,
        "details": {
          "function_name": "sysv_set_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sysv/inode.c",
          "lines": "154-175",
          "snippet": "void sysv_set_inode(struct inode *inode, dev_t rdev)\n{\n\tif (S_ISREG(inode->i_mode)) {\n\t\tinode->i_op = &sysv_file_inode_operations;\n\t\tinode->i_fop = &sysv_file_operations;\n\t\tinode->i_mapping->a_ops = &sysv_aops;\n\t} else if (S_ISDIR(inode->i_mode)) {\n\t\tinode->i_op = &sysv_dir_inode_operations;\n\t\tinode->i_fop = &sysv_dir_operations;\n\t\tinode->i_mapping->a_ops = &sysv_aops;\n\t} else if (S_ISLNK(inode->i_mode)) {\n\t\tif (inode->i_blocks) {\n\t\t\tinode->i_op = &sysv_symlink_inode_operations;\n\t\t\tinode->i_mapping->a_ops = &sysv_aops;\n\t\t} else {\n\t\t\tinode->i_op = &sysv_fast_symlink_inode_operations;\n\t\t\tnd_terminate_link(SYSV_I(inode)->i_data, inode->i_size,\n\t\t\t\tsizeof(SYSV_I(inode)->i_data) - 1);\n\t\t}\n\t} else\n\t\tinit_special_inode(inode, inode->i_mode, rdev);\n}",
          "includes": [
            "#include \"sysv.h\"",
            "#include <asm/byteorder.h>",
            "#include <linux/namei.h>",
            "#include <linux/writeback.h>",
            "#include <linux/vfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/highuid.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct inode_operations sysv_symlink_inode_operations = {\n\t.readlink\t= generic_readlink,\n\t.follow_link\t= page_follow_link_light,\n\t.put_link\t= page_put_link,\n\t.getattr\t= sysv_getattr,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysv.h\"\n#include <asm/byteorder.h>\n#include <linux/namei.h>\n#include <linux/writeback.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/highuid.h>\n\nstatic const struct inode_operations sysv_symlink_inode_operations = {\n\t.readlink\t= generic_readlink,\n\t.follow_link\t= page_follow_link_light,\n\t.put_link\t= page_put_link,\n\t.getattr\t= sysv_getattr,\n};\n\nvoid sysv_set_inode(struct inode *inode, dev_t rdev)\n{\n\tif (S_ISREG(inode->i_mode)) {\n\t\tinode->i_op = &sysv_file_inode_operations;\n\t\tinode->i_fop = &sysv_file_operations;\n\t\tinode->i_mapping->a_ops = &sysv_aops;\n\t} else if (S_ISDIR(inode->i_mode)) {\n\t\tinode->i_op = &sysv_dir_inode_operations;\n\t\tinode->i_fop = &sysv_dir_operations;\n\t\tinode->i_mapping->a_ops = &sysv_aops;\n\t} else if (S_ISLNK(inode->i_mode)) {\n\t\tif (inode->i_blocks) {\n\t\t\tinode->i_op = &sysv_symlink_inode_operations;\n\t\t\tinode->i_mapping->a_ops = &sysv_aops;\n\t\t} else {\n\t\t\tinode->i_op = &sysv_fast_symlink_inode_operations;\n\t\t\tnd_terminate_link(SYSV_I(inode)->i_data, inode->i_size,\n\t\t\t\tsizeof(SYSV_I(inode)->i_data) - 1);\n\t\t}\n\t} else\n\t\tinit_special_inode(inode, inode->i_mode, rdev);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "inode"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "inode"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sysv_new_inode",
          "args": [
            "dir",
            "S_IFDIR|mode"
          ],
          "line": 137
        },
        "resolved": true,
        "details": {
          "function_name": "sysv_new_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sysv/ialloc.c",
          "lines": "135-179",
          "snippet": "struct inode * sysv_new_inode(const struct inode * dir, umode_t mode)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tstruct sysv_sb_info *sbi = SYSV_SB(sb);\n\tstruct inode *inode;\n\tsysv_ino_t ino;\n\tunsigned count;\n\tstruct writeback_control wbc = {\n\t\t.sync_mode = WB_SYNC_NONE\n\t};\n\n\tinode = new_inode(sb);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tmutex_lock(&sbi->s_lock);\n\tcount = fs16_to_cpu(sbi, *sbi->s_sb_fic_count);\n\tif (count == 0 || (*sv_sb_fic_inode(sb,count-1) == 0)) {\n\t\tcount = refill_free_cache(sb);\n\t\tif (count == 0) {\n\t\t\tiput(inode);\n\t\t\tmutex_unlock(&sbi->s_lock);\n\t\t\treturn ERR_PTR(-ENOSPC);\n\t\t}\n\t}\n\t/* Now count > 0. */\n\tino = *sv_sb_fic_inode(sb,--count);\n\t*sbi->s_sb_fic_count = cpu_to_fs16(sbi, count);\n\tfs16_add(sbi, sbi->s_sb_total_free_inodes, -1);\n\tdirty_sb(sb);\n\tinode_init_owner(inode, dir, mode);\n\tinode->i_ino = fs16_to_cpu(sbi, ino);\n\tinode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME_SEC;\n\tinode->i_blocks = 0;\n\tmemset(SYSV_I(inode)->i_data, 0, sizeof(SYSV_I(inode)->i_data));\n\tSYSV_I(inode)->i_dir_start_lookup = 0;\n\tinsert_inode_hash(inode);\n\tmark_inode_dirty(inode);\n\n\tsysv_write_inode(inode, &wbc);\t/* ensure inode not allocated again */\n\tmark_inode_dirty(inode);\t/* cleared by sysv_write_inode() */\n\t/* That's it. */\n\tmutex_unlock(&sbi->s_lock);\n\treturn inode;\n}",
          "includes": [
            "#include \"sysv.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/sched.h>",
            "#include <linux/stddef.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysv.h\"\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/sched.h>\n#include <linux/stddef.h>\n#include <linux/kernel.h>\n\nstruct inode * sysv_new_inode(const struct inode * dir, umode_t mode)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tstruct sysv_sb_info *sbi = SYSV_SB(sb);\n\tstruct inode *inode;\n\tsysv_ino_t ino;\n\tunsigned count;\n\tstruct writeback_control wbc = {\n\t\t.sync_mode = WB_SYNC_NONE\n\t};\n\n\tinode = new_inode(sb);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tmutex_lock(&sbi->s_lock);\n\tcount = fs16_to_cpu(sbi, *sbi->s_sb_fic_count);\n\tif (count == 0 || (*sv_sb_fic_inode(sb,count-1) == 0)) {\n\t\tcount = refill_free_cache(sb);\n\t\tif (count == 0) {\n\t\t\tiput(inode);\n\t\t\tmutex_unlock(&sbi->s_lock);\n\t\t\treturn ERR_PTR(-ENOSPC);\n\t\t}\n\t}\n\t/* Now count > 0. */\n\tino = *sv_sb_fic_inode(sb,--count);\n\t*sbi->s_sb_fic_count = cpu_to_fs16(sbi, count);\n\tfs16_add(sbi, sbi->s_sb_total_free_inodes, -1);\n\tdirty_sb(sb);\n\tinode_init_owner(inode, dir, mode);\n\tinode->i_ino = fs16_to_cpu(sbi, ino);\n\tinode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME_SEC;\n\tinode->i_blocks = 0;\n\tmemset(SYSV_I(inode)->i_data, 0, sizeof(SYSV_I(inode)->i_data));\n\tSYSV_I(inode)->i_dir_start_lookup = 0;\n\tinsert_inode_hash(inode);\n\tmark_inode_dirty(inode);\n\n\tsysv_write_inode(inode, &wbc);\t/* ensure inode not allocated again */\n\tmark_inode_dirty(inode);\t/* cleared by sysv_write_inode() */\n\t/* That's it. */\n\tmutex_unlock(&sbi->s_lock);\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_inc_link_count",
          "args": [
            "dir"
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sysv.h\"\n#include <linux/pagemap.h>\n\nstatic int sysv_mkdir(struct inode * dir, struct dentry *dentry, umode_t mode)\n{\n\tstruct inode * inode;\n\tint err;\n\n\tinode_inc_link_count(dir);\n\n\tinode = sysv_new_inode(dir, S_IFDIR|mode);\n\terr = PTR_ERR(inode);\n\tif (IS_ERR(inode))\n\t\tgoto out_dir;\n\n\tsysv_set_inode(inode, 0);\n\n\tinode_inc_link_count(inode);\n\n\terr = sysv_make_empty(inode, dir);\n\tif (err)\n\t\tgoto out_fail;\n\n\terr = sysv_add_link(dentry, inode);\n\tif (err)\n\t\tgoto out_fail;\n\n        d_instantiate(dentry, inode);\nout:\n\treturn err;\n\nout_fail:\n\tinode_dec_link_count(inode);\n\tinode_dec_link_count(inode);\n\tiput(inode);\nout_dir:\n\tinode_dec_link_count(dir);\n\tgoto out;\n}"
  },
  {
    "function_name": "sysv_link",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sysv/namei.c",
    "lines": "118-128",
    "snippet": "static int sysv_link(struct dentry * old_dentry, struct inode * dir, \n\tstruct dentry * dentry)\n{\n\tstruct inode *inode = old_dentry->d_inode;\n\n\tinode->i_ctime = CURRENT_TIME_SEC;\n\tinode_inc_link_count(inode);\n\tihold(inode);\n\n\treturn add_nondir(dentry, inode);\n}",
    "includes": [
      "#include \"sysv.h\"",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "add_nondir",
          "args": [
            "dentry",
            "inode"
          ],
          "line": 127
        },
        "resolved": true,
        "details": {
          "function_name": "add_nondir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sysv/namei.c",
          "lines": "18-28",
          "snippet": "static int add_nondir(struct dentry *dentry, struct inode *inode)\n{\n\tint err = sysv_add_link(dentry, inode);\n\tif (!err) {\n\t\td_instantiate(dentry, inode);\n\t\treturn 0;\n\t}\n\tinode_dec_link_count(inode);\n\tiput(inode);\n\treturn err;\n}",
          "includes": [
            "#include \"sysv.h\"",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysv.h\"\n#include <linux/pagemap.h>\n\nstatic int add_nondir(struct dentry *dentry, struct inode *inode)\n{\n\tint err = sysv_add_link(dentry, inode);\n\tif (!err) {\n\t\td_instantiate(dentry, inode);\n\t\treturn 0;\n\t}\n\tinode_dec_link_count(inode);\n\tiput(inode);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ihold",
          "args": [
            "inode"
          ],
          "line": 125
        },
        "resolved": true,
        "details": {
          "function_name": "ihold",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "388-391",
          "snippet": "void ihold(struct inode *inode)\n{\n\tWARN_ON(atomic_inc_return(&inode->i_count) < 2);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid ihold(struct inode *inode)\n{\n\tWARN_ON(atomic_inc_return(&inode->i_count) < 2);\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_inc_link_count",
          "args": [
            "inode"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sysv.h\"\n#include <linux/pagemap.h>\n\nstatic int sysv_link(struct dentry * old_dentry, struct inode * dir, \n\tstruct dentry * dentry)\n{\n\tstruct inode *inode = old_dentry->d_inode;\n\n\tinode->i_ctime = CURRENT_TIME_SEC;\n\tinode_inc_link_count(inode);\n\tihold(inode);\n\n\treturn add_nondir(dentry, inode);\n}"
  },
  {
    "function_name": "sysv_symlink",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sysv/namei.c",
    "lines": "87-116",
    "snippet": "static int sysv_symlink(struct inode * dir, struct dentry * dentry, \n\tconst char * symname)\n{\n\tint err = -ENAMETOOLONG;\n\tint l = strlen(symname)+1;\n\tstruct inode * inode;\n\n\tif (l > dir->i_sb->s_blocksize)\n\t\tgoto out;\n\n\tinode = sysv_new_inode(dir, S_IFLNK|0777);\n\terr = PTR_ERR(inode);\n\tif (IS_ERR(inode))\n\t\tgoto out;\n\t\n\tsysv_set_inode(inode, 0);\n\terr = page_symlink(inode, symname, l);\n\tif (err)\n\t\tgoto out_fail;\n\n\tmark_inode_dirty(inode);\n\terr = add_nondir(dentry, inode);\nout:\n\treturn err;\n\nout_fail:\n\tinode_dec_link_count(inode);\n\tiput(inode);\n\tgoto out;\n}",
    "includes": [
      "#include \"sysv.h\"",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "inode"
          ],
          "line": 114
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_dec_link_count",
          "args": [
            "inode"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add_nondir",
          "args": [
            "dentry",
            "inode"
          ],
          "line": 108
        },
        "resolved": true,
        "details": {
          "function_name": "add_nondir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sysv/namei.c",
          "lines": "18-28",
          "snippet": "static int add_nondir(struct dentry *dentry, struct inode *inode)\n{\n\tint err = sysv_add_link(dentry, inode);\n\tif (!err) {\n\t\td_instantiate(dentry, inode);\n\t\treturn 0;\n\t}\n\tinode_dec_link_count(inode);\n\tiput(inode);\n\treturn err;\n}",
          "includes": [
            "#include \"sysv.h\"",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysv.h\"\n#include <linux/pagemap.h>\n\nstatic int add_nondir(struct dentry *dentry, struct inode *inode)\n{\n\tint err = sysv_add_link(dentry, inode);\n\tif (!err) {\n\t\td_instantiate(dentry, inode);\n\t\treturn 0;\n\t}\n\tinode_dec_link_count(inode);\n\tiput(inode);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_inode_dirty",
          "args": [
            "inode"
          ],
          "line": 107
        },
        "resolved": true,
        "details": {
          "function_name": "block_dump___mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1134-1154",
          "snippet": "static noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_symlink",
          "args": [
            "inode",
            "symname",
            "l"
          ],
          "line": 103
        },
        "resolved": true,
        "details": {
          "function_name": "page_symlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "4532-4536",
          "snippet": "int page_symlink(struct inode *inode, const char *symname, int len)\n{\n\treturn __page_symlink(inode, symname, len,\n\t\t\t!(mapping_gfp_mask(inode->i_mapping) & __GFP_FS));\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nint page_symlink(struct inode *inode, const char *symname, int len)\n{\n\treturn __page_symlink(inode, symname, len,\n\t\t\t!(mapping_gfp_mask(inode->i_mapping) & __GFP_FS));\n}"
        }
      },
      {
        "call_info": {
          "callee": "sysv_set_inode",
          "args": [
            "inode",
            "0"
          ],
          "line": 102
        },
        "resolved": true,
        "details": {
          "function_name": "sysv_set_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sysv/inode.c",
          "lines": "154-175",
          "snippet": "void sysv_set_inode(struct inode *inode, dev_t rdev)\n{\n\tif (S_ISREG(inode->i_mode)) {\n\t\tinode->i_op = &sysv_file_inode_operations;\n\t\tinode->i_fop = &sysv_file_operations;\n\t\tinode->i_mapping->a_ops = &sysv_aops;\n\t} else if (S_ISDIR(inode->i_mode)) {\n\t\tinode->i_op = &sysv_dir_inode_operations;\n\t\tinode->i_fop = &sysv_dir_operations;\n\t\tinode->i_mapping->a_ops = &sysv_aops;\n\t} else if (S_ISLNK(inode->i_mode)) {\n\t\tif (inode->i_blocks) {\n\t\t\tinode->i_op = &sysv_symlink_inode_operations;\n\t\t\tinode->i_mapping->a_ops = &sysv_aops;\n\t\t} else {\n\t\t\tinode->i_op = &sysv_fast_symlink_inode_operations;\n\t\t\tnd_terminate_link(SYSV_I(inode)->i_data, inode->i_size,\n\t\t\t\tsizeof(SYSV_I(inode)->i_data) - 1);\n\t\t}\n\t} else\n\t\tinit_special_inode(inode, inode->i_mode, rdev);\n}",
          "includes": [
            "#include \"sysv.h\"",
            "#include <asm/byteorder.h>",
            "#include <linux/namei.h>",
            "#include <linux/writeback.h>",
            "#include <linux/vfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/highuid.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct inode_operations sysv_symlink_inode_operations = {\n\t.readlink\t= generic_readlink,\n\t.follow_link\t= page_follow_link_light,\n\t.put_link\t= page_put_link,\n\t.getattr\t= sysv_getattr,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysv.h\"\n#include <asm/byteorder.h>\n#include <linux/namei.h>\n#include <linux/writeback.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/highuid.h>\n\nstatic const struct inode_operations sysv_symlink_inode_operations = {\n\t.readlink\t= generic_readlink,\n\t.follow_link\t= page_follow_link_light,\n\t.put_link\t= page_put_link,\n\t.getattr\t= sysv_getattr,\n};\n\nvoid sysv_set_inode(struct inode *inode, dev_t rdev)\n{\n\tif (S_ISREG(inode->i_mode)) {\n\t\tinode->i_op = &sysv_file_inode_operations;\n\t\tinode->i_fop = &sysv_file_operations;\n\t\tinode->i_mapping->a_ops = &sysv_aops;\n\t} else if (S_ISDIR(inode->i_mode)) {\n\t\tinode->i_op = &sysv_dir_inode_operations;\n\t\tinode->i_fop = &sysv_dir_operations;\n\t\tinode->i_mapping->a_ops = &sysv_aops;\n\t} else if (S_ISLNK(inode->i_mode)) {\n\t\tif (inode->i_blocks) {\n\t\t\tinode->i_op = &sysv_symlink_inode_operations;\n\t\t\tinode->i_mapping->a_ops = &sysv_aops;\n\t\t} else {\n\t\t\tinode->i_op = &sysv_fast_symlink_inode_operations;\n\t\t\tnd_terminate_link(SYSV_I(inode)->i_data, inode->i_size,\n\t\t\t\tsizeof(SYSV_I(inode)->i_data) - 1);\n\t\t}\n\t} else\n\t\tinit_special_inode(inode, inode->i_mode, rdev);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "inode"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "inode"
          ],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sysv_new_inode",
          "args": [
            "dir",
            "S_IFLNK|0777"
          ],
          "line": 97
        },
        "resolved": true,
        "details": {
          "function_name": "sysv_new_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sysv/ialloc.c",
          "lines": "135-179",
          "snippet": "struct inode * sysv_new_inode(const struct inode * dir, umode_t mode)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tstruct sysv_sb_info *sbi = SYSV_SB(sb);\n\tstruct inode *inode;\n\tsysv_ino_t ino;\n\tunsigned count;\n\tstruct writeback_control wbc = {\n\t\t.sync_mode = WB_SYNC_NONE\n\t};\n\n\tinode = new_inode(sb);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tmutex_lock(&sbi->s_lock);\n\tcount = fs16_to_cpu(sbi, *sbi->s_sb_fic_count);\n\tif (count == 0 || (*sv_sb_fic_inode(sb,count-1) == 0)) {\n\t\tcount = refill_free_cache(sb);\n\t\tif (count == 0) {\n\t\t\tiput(inode);\n\t\t\tmutex_unlock(&sbi->s_lock);\n\t\t\treturn ERR_PTR(-ENOSPC);\n\t\t}\n\t}\n\t/* Now count > 0. */\n\tino = *sv_sb_fic_inode(sb,--count);\n\t*sbi->s_sb_fic_count = cpu_to_fs16(sbi, count);\n\tfs16_add(sbi, sbi->s_sb_total_free_inodes, -1);\n\tdirty_sb(sb);\n\tinode_init_owner(inode, dir, mode);\n\tinode->i_ino = fs16_to_cpu(sbi, ino);\n\tinode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME_SEC;\n\tinode->i_blocks = 0;\n\tmemset(SYSV_I(inode)->i_data, 0, sizeof(SYSV_I(inode)->i_data));\n\tSYSV_I(inode)->i_dir_start_lookup = 0;\n\tinsert_inode_hash(inode);\n\tmark_inode_dirty(inode);\n\n\tsysv_write_inode(inode, &wbc);\t/* ensure inode not allocated again */\n\tmark_inode_dirty(inode);\t/* cleared by sysv_write_inode() */\n\t/* That's it. */\n\tmutex_unlock(&sbi->s_lock);\n\treturn inode;\n}",
          "includes": [
            "#include \"sysv.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/sched.h>",
            "#include <linux/stddef.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysv.h\"\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/sched.h>\n#include <linux/stddef.h>\n#include <linux/kernel.h>\n\nstruct inode * sysv_new_inode(const struct inode * dir, umode_t mode)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tstruct sysv_sb_info *sbi = SYSV_SB(sb);\n\tstruct inode *inode;\n\tsysv_ino_t ino;\n\tunsigned count;\n\tstruct writeback_control wbc = {\n\t\t.sync_mode = WB_SYNC_NONE\n\t};\n\n\tinode = new_inode(sb);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tmutex_lock(&sbi->s_lock);\n\tcount = fs16_to_cpu(sbi, *sbi->s_sb_fic_count);\n\tif (count == 0 || (*sv_sb_fic_inode(sb,count-1) == 0)) {\n\t\tcount = refill_free_cache(sb);\n\t\tif (count == 0) {\n\t\t\tiput(inode);\n\t\t\tmutex_unlock(&sbi->s_lock);\n\t\t\treturn ERR_PTR(-ENOSPC);\n\t\t}\n\t}\n\t/* Now count > 0. */\n\tino = *sv_sb_fic_inode(sb,--count);\n\t*sbi->s_sb_fic_count = cpu_to_fs16(sbi, count);\n\tfs16_add(sbi, sbi->s_sb_total_free_inodes, -1);\n\tdirty_sb(sb);\n\tinode_init_owner(inode, dir, mode);\n\tinode->i_ino = fs16_to_cpu(sbi, ino);\n\tinode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME_SEC;\n\tinode->i_blocks = 0;\n\tmemset(SYSV_I(inode)->i_data, 0, sizeof(SYSV_I(inode)->i_data));\n\tSYSV_I(inode)->i_dir_start_lookup = 0;\n\tinsert_inode_hash(inode);\n\tmark_inode_dirty(inode);\n\n\tsysv_write_inode(inode, &wbc);\t/* ensure inode not allocated again */\n\tmark_inode_dirty(inode);\t/* cleared by sysv_write_inode() */\n\t/* That's it. */\n\tmutex_unlock(&sbi->s_lock);\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "symname"
          ],
          "line": 91
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sysv.h\"\n#include <linux/pagemap.h>\n\nstatic int sysv_symlink(struct inode * dir, struct dentry * dentry, \n\tconst char * symname)\n{\n\tint err = -ENAMETOOLONG;\n\tint l = strlen(symname)+1;\n\tstruct inode * inode;\n\n\tif (l > dir->i_sb->s_blocksize)\n\t\tgoto out;\n\n\tinode = sysv_new_inode(dir, S_IFLNK|0777);\n\terr = PTR_ERR(inode);\n\tif (IS_ERR(inode))\n\t\tgoto out;\n\t\n\tsysv_set_inode(inode, 0);\n\terr = page_symlink(inode, symname, l);\n\tif (err)\n\t\tgoto out_fail;\n\n\tmark_inode_dirty(inode);\n\terr = add_nondir(dentry, inode);\nout:\n\treturn err;\n\nout_fail:\n\tinode_dec_link_count(inode);\n\tiput(inode);\n\tgoto out;\n}"
  },
  {
    "function_name": "sysv_create",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sysv/namei.c",
    "lines": "82-85",
    "snippet": "static int sysv_create(struct inode * dir, struct dentry * dentry, umode_t mode, bool excl)\n{\n\treturn sysv_mknod(dir, dentry, mode, 0);\n}",
    "includes": [
      "#include \"sysv.h\"",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sysv_mknod",
          "args": [
            "dir",
            "dentry",
            "mode",
            "0"
          ],
          "line": 84
        },
        "resolved": true,
        "details": {
          "function_name": "sysv_mknod",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sysv/namei.c",
          "lines": "63-80",
          "snippet": "static int sysv_mknod(struct inode * dir, struct dentry * dentry, umode_t mode, dev_t rdev)\n{\n\tstruct inode * inode;\n\tint err;\n\n\tif (!old_valid_dev(rdev))\n\t\treturn -EINVAL;\n\n\tinode = sysv_new_inode(dir, mode);\n\terr = PTR_ERR(inode);\n\n\tif (!IS_ERR(inode)) {\n\t\tsysv_set_inode(inode, rdev);\n\t\tmark_inode_dirty(inode);\n\t\terr = add_nondir(dentry, inode);\n\t}\n\treturn err;\n}",
          "includes": [
            "#include \"sysv.h\"",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysv.h\"\n#include <linux/pagemap.h>\n\nstatic int sysv_mknod(struct inode * dir, struct dentry * dentry, umode_t mode, dev_t rdev)\n{\n\tstruct inode * inode;\n\tint err;\n\n\tif (!old_valid_dev(rdev))\n\t\treturn -EINVAL;\n\n\tinode = sysv_new_inode(dir, mode);\n\terr = PTR_ERR(inode);\n\n\tif (!IS_ERR(inode)) {\n\t\tsysv_set_inode(inode, rdev);\n\t\tmark_inode_dirty(inode);\n\t\terr = add_nondir(dentry, inode);\n\t}\n\treturn err;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sysv.h\"\n#include <linux/pagemap.h>\n\nstatic int sysv_create(struct inode * dir, struct dentry * dentry, umode_t mode, bool excl)\n{\n\treturn sysv_mknod(dir, dentry, mode, 0);\n}"
  },
  {
    "function_name": "sysv_mknod",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sysv/namei.c",
    "lines": "63-80",
    "snippet": "static int sysv_mknod(struct inode * dir, struct dentry * dentry, umode_t mode, dev_t rdev)\n{\n\tstruct inode * inode;\n\tint err;\n\n\tif (!old_valid_dev(rdev))\n\t\treturn -EINVAL;\n\n\tinode = sysv_new_inode(dir, mode);\n\terr = PTR_ERR(inode);\n\n\tif (!IS_ERR(inode)) {\n\t\tsysv_set_inode(inode, rdev);\n\t\tmark_inode_dirty(inode);\n\t\terr = add_nondir(dentry, inode);\n\t}\n\treturn err;\n}",
    "includes": [
      "#include \"sysv.h\"",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "add_nondir",
          "args": [
            "dentry",
            "inode"
          ],
          "line": 77
        },
        "resolved": true,
        "details": {
          "function_name": "add_nondir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sysv/namei.c",
          "lines": "18-28",
          "snippet": "static int add_nondir(struct dentry *dentry, struct inode *inode)\n{\n\tint err = sysv_add_link(dentry, inode);\n\tif (!err) {\n\t\td_instantiate(dentry, inode);\n\t\treturn 0;\n\t}\n\tinode_dec_link_count(inode);\n\tiput(inode);\n\treturn err;\n}",
          "includes": [
            "#include \"sysv.h\"",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysv.h\"\n#include <linux/pagemap.h>\n\nstatic int add_nondir(struct dentry *dentry, struct inode *inode)\n{\n\tint err = sysv_add_link(dentry, inode);\n\tif (!err) {\n\t\td_instantiate(dentry, inode);\n\t\treturn 0;\n\t}\n\tinode_dec_link_count(inode);\n\tiput(inode);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_inode_dirty",
          "args": [
            "inode"
          ],
          "line": 76
        },
        "resolved": true,
        "details": {
          "function_name": "block_dump___mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1134-1154",
          "snippet": "static noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sysv_set_inode",
          "args": [
            "inode",
            "rdev"
          ],
          "line": 75
        },
        "resolved": true,
        "details": {
          "function_name": "sysv_set_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sysv/inode.c",
          "lines": "154-175",
          "snippet": "void sysv_set_inode(struct inode *inode, dev_t rdev)\n{\n\tif (S_ISREG(inode->i_mode)) {\n\t\tinode->i_op = &sysv_file_inode_operations;\n\t\tinode->i_fop = &sysv_file_operations;\n\t\tinode->i_mapping->a_ops = &sysv_aops;\n\t} else if (S_ISDIR(inode->i_mode)) {\n\t\tinode->i_op = &sysv_dir_inode_operations;\n\t\tinode->i_fop = &sysv_dir_operations;\n\t\tinode->i_mapping->a_ops = &sysv_aops;\n\t} else if (S_ISLNK(inode->i_mode)) {\n\t\tif (inode->i_blocks) {\n\t\t\tinode->i_op = &sysv_symlink_inode_operations;\n\t\t\tinode->i_mapping->a_ops = &sysv_aops;\n\t\t} else {\n\t\t\tinode->i_op = &sysv_fast_symlink_inode_operations;\n\t\t\tnd_terminate_link(SYSV_I(inode)->i_data, inode->i_size,\n\t\t\t\tsizeof(SYSV_I(inode)->i_data) - 1);\n\t\t}\n\t} else\n\t\tinit_special_inode(inode, inode->i_mode, rdev);\n}",
          "includes": [
            "#include \"sysv.h\"",
            "#include <asm/byteorder.h>",
            "#include <linux/namei.h>",
            "#include <linux/writeback.h>",
            "#include <linux/vfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/highuid.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct inode_operations sysv_symlink_inode_operations = {\n\t.readlink\t= generic_readlink,\n\t.follow_link\t= page_follow_link_light,\n\t.put_link\t= page_put_link,\n\t.getattr\t= sysv_getattr,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysv.h\"\n#include <asm/byteorder.h>\n#include <linux/namei.h>\n#include <linux/writeback.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/highuid.h>\n\nstatic const struct inode_operations sysv_symlink_inode_operations = {\n\t.readlink\t= generic_readlink,\n\t.follow_link\t= page_follow_link_light,\n\t.put_link\t= page_put_link,\n\t.getattr\t= sysv_getattr,\n};\n\nvoid sysv_set_inode(struct inode *inode, dev_t rdev)\n{\n\tif (S_ISREG(inode->i_mode)) {\n\t\tinode->i_op = &sysv_file_inode_operations;\n\t\tinode->i_fop = &sysv_file_operations;\n\t\tinode->i_mapping->a_ops = &sysv_aops;\n\t} else if (S_ISDIR(inode->i_mode)) {\n\t\tinode->i_op = &sysv_dir_inode_operations;\n\t\tinode->i_fop = &sysv_dir_operations;\n\t\tinode->i_mapping->a_ops = &sysv_aops;\n\t} else if (S_ISLNK(inode->i_mode)) {\n\t\tif (inode->i_blocks) {\n\t\t\tinode->i_op = &sysv_symlink_inode_operations;\n\t\t\tinode->i_mapping->a_ops = &sysv_aops;\n\t\t} else {\n\t\t\tinode->i_op = &sysv_fast_symlink_inode_operations;\n\t\t\tnd_terminate_link(SYSV_I(inode)->i_data, inode->i_size,\n\t\t\t\tsizeof(SYSV_I(inode)->i_data) - 1);\n\t\t}\n\t} else\n\t\tinit_special_inode(inode, inode->i_mode, rdev);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "inode"
          ],
          "line": 74
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "inode"
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sysv_new_inode",
          "args": [
            "dir",
            "mode"
          ],
          "line": 71
        },
        "resolved": true,
        "details": {
          "function_name": "sysv_new_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sysv/ialloc.c",
          "lines": "135-179",
          "snippet": "struct inode * sysv_new_inode(const struct inode * dir, umode_t mode)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tstruct sysv_sb_info *sbi = SYSV_SB(sb);\n\tstruct inode *inode;\n\tsysv_ino_t ino;\n\tunsigned count;\n\tstruct writeback_control wbc = {\n\t\t.sync_mode = WB_SYNC_NONE\n\t};\n\n\tinode = new_inode(sb);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tmutex_lock(&sbi->s_lock);\n\tcount = fs16_to_cpu(sbi, *sbi->s_sb_fic_count);\n\tif (count == 0 || (*sv_sb_fic_inode(sb,count-1) == 0)) {\n\t\tcount = refill_free_cache(sb);\n\t\tif (count == 0) {\n\t\t\tiput(inode);\n\t\t\tmutex_unlock(&sbi->s_lock);\n\t\t\treturn ERR_PTR(-ENOSPC);\n\t\t}\n\t}\n\t/* Now count > 0. */\n\tino = *sv_sb_fic_inode(sb,--count);\n\t*sbi->s_sb_fic_count = cpu_to_fs16(sbi, count);\n\tfs16_add(sbi, sbi->s_sb_total_free_inodes, -1);\n\tdirty_sb(sb);\n\tinode_init_owner(inode, dir, mode);\n\tinode->i_ino = fs16_to_cpu(sbi, ino);\n\tinode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME_SEC;\n\tinode->i_blocks = 0;\n\tmemset(SYSV_I(inode)->i_data, 0, sizeof(SYSV_I(inode)->i_data));\n\tSYSV_I(inode)->i_dir_start_lookup = 0;\n\tinsert_inode_hash(inode);\n\tmark_inode_dirty(inode);\n\n\tsysv_write_inode(inode, &wbc);\t/* ensure inode not allocated again */\n\tmark_inode_dirty(inode);\t/* cleared by sysv_write_inode() */\n\t/* That's it. */\n\tmutex_unlock(&sbi->s_lock);\n\treturn inode;\n}",
          "includes": [
            "#include \"sysv.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/sched.h>",
            "#include <linux/stddef.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysv.h\"\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/sched.h>\n#include <linux/stddef.h>\n#include <linux/kernel.h>\n\nstruct inode * sysv_new_inode(const struct inode * dir, umode_t mode)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tstruct sysv_sb_info *sbi = SYSV_SB(sb);\n\tstruct inode *inode;\n\tsysv_ino_t ino;\n\tunsigned count;\n\tstruct writeback_control wbc = {\n\t\t.sync_mode = WB_SYNC_NONE\n\t};\n\n\tinode = new_inode(sb);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tmutex_lock(&sbi->s_lock);\n\tcount = fs16_to_cpu(sbi, *sbi->s_sb_fic_count);\n\tif (count == 0 || (*sv_sb_fic_inode(sb,count-1) == 0)) {\n\t\tcount = refill_free_cache(sb);\n\t\tif (count == 0) {\n\t\t\tiput(inode);\n\t\t\tmutex_unlock(&sbi->s_lock);\n\t\t\treturn ERR_PTR(-ENOSPC);\n\t\t}\n\t}\n\t/* Now count > 0. */\n\tino = *sv_sb_fic_inode(sb,--count);\n\t*sbi->s_sb_fic_count = cpu_to_fs16(sbi, count);\n\tfs16_add(sbi, sbi->s_sb_total_free_inodes, -1);\n\tdirty_sb(sb);\n\tinode_init_owner(inode, dir, mode);\n\tinode->i_ino = fs16_to_cpu(sbi, ino);\n\tinode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME_SEC;\n\tinode->i_blocks = 0;\n\tmemset(SYSV_I(inode)->i_data, 0, sizeof(SYSV_I(inode)->i_data));\n\tSYSV_I(inode)->i_dir_start_lookup = 0;\n\tinsert_inode_hash(inode);\n\tmark_inode_dirty(inode);\n\n\tsysv_write_inode(inode, &wbc);\t/* ensure inode not allocated again */\n\tmark_inode_dirty(inode);\t/* cleared by sysv_write_inode() */\n\t/* That's it. */\n\tmutex_unlock(&sbi->s_lock);\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "old_valid_dev",
          "args": [
            "rdev"
          ],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sysv.h\"\n#include <linux/pagemap.h>\n\nstatic int sysv_mknod(struct inode * dir, struct dentry * dentry, umode_t mode, dev_t rdev)\n{\n\tstruct inode * inode;\n\tint err;\n\n\tif (!old_valid_dev(rdev))\n\t\treturn -EINVAL;\n\n\tinode = sysv_new_inode(dir, mode);\n\terr = PTR_ERR(inode);\n\n\tif (!IS_ERR(inode)) {\n\t\tsysv_set_inode(inode, rdev);\n\t\tmark_inode_dirty(inode);\n\t\terr = add_nondir(dentry, inode);\n\t}\n\treturn err;\n}"
  },
  {
    "function_name": "sysv_lookup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sysv/namei.c",
    "lines": "45-61",
    "snippet": "static struct dentry *sysv_lookup(struct inode * dir, struct dentry * dentry, unsigned int flags)\n{\n\tstruct inode * inode = NULL;\n\tino_t ino;\n\n\tif (dentry->d_name.len > SYSV_NAMELEN)\n\t\treturn ERR_PTR(-ENAMETOOLONG);\n\tino = sysv_inode_by_name(dentry);\n\n\tif (ino) {\n\t\tinode = sysv_iget(dir->i_sb, ino);\n\t\tif (IS_ERR(inode))\n\t\t\treturn ERR_CAST(inode);\n\t}\n\td_add(dentry, inode);\n\treturn NULL;\n}",
    "includes": [
      "#include \"sysv.h\"",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "d_add",
          "args": [
            "dentry",
            "inode"
          ],
          "line": 59
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_fid_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/fid.c",
          "lines": "49-54",
          "snippet": "void v9fs_fid_add(struct dentry *dentry, struct p9_fid *fid)\n{\n\tspin_lock(&dentry->d_lock);\n\t__add_fid(dentry, fid);\n\tspin_unlock(&dentry->d_lock);\n}",
          "includes": [
            "#include \"fid.h\"",
            "#include \"v9fs_vfs.h\"",
            "#include \"v9fs.h\"",
            "#include <net/9p/client.h>",
            "#include <net/9p/9p.h>",
            "#include <linux/idr.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/idr.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nvoid v9fs_fid_add(struct dentry *dentry, struct p9_fid *fid)\n{\n\tspin_lock(&dentry->d_lock);\n\t__add_fid(dentry, fid);\n\tspin_unlock(&dentry->d_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_CAST",
          "args": [
            "inode"
          ],
          "line": 57
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "inode"
          ],
          "line": 56
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sysv_iget",
          "args": [
            "dir->i_sb",
            "ino"
          ],
          "line": 55
        },
        "resolved": true,
        "details": {
          "function_name": "sysv_iget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sysv/inode.c",
          "lines": "177-235",
          "snippet": "struct inode *sysv_iget(struct super_block *sb, unsigned int ino)\n{\n\tstruct sysv_sb_info * sbi = SYSV_SB(sb);\n\tstruct buffer_head * bh;\n\tstruct sysv_inode * raw_inode;\n\tstruct sysv_inode_info * si;\n\tstruct inode *inode;\n\tunsigned int block;\n\n\tif (!ino || ino > sbi->s_ninodes) {\n\t\tprintk(\"Bad inode number on dev %s: %d is out of range\\n\",\n\t\t       sb->s_id, ino);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\n\tinode = iget_locked(sb, ino);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (!(inode->i_state & I_NEW))\n\t\treturn inode;\n\n\traw_inode = sysv_raw_inode(sb, ino, &bh);\n\tif (!raw_inode) {\n\t\tprintk(\"Major problem: unable to read inode from dev %s\\n\",\n\t\t       inode->i_sb->s_id);\n\t\tgoto bad_inode;\n\t}\n\t/* SystemV FS: kludge permissions if ino==SYSV_ROOT_INO ?? */\n\tinode->i_mode = fs16_to_cpu(sbi, raw_inode->i_mode);\n\ti_uid_write(inode, (uid_t)fs16_to_cpu(sbi, raw_inode->i_uid));\n\ti_gid_write(inode, (gid_t)fs16_to_cpu(sbi, raw_inode->i_gid));\n\tset_nlink(inode, fs16_to_cpu(sbi, raw_inode->i_nlink));\n\tinode->i_size = fs32_to_cpu(sbi, raw_inode->i_size);\n\tinode->i_atime.tv_sec = fs32_to_cpu(sbi, raw_inode->i_atime);\n\tinode->i_mtime.tv_sec = fs32_to_cpu(sbi, raw_inode->i_mtime);\n\tinode->i_ctime.tv_sec = fs32_to_cpu(sbi, raw_inode->i_ctime);\n\tinode->i_ctime.tv_nsec = 0;\n\tinode->i_atime.tv_nsec = 0;\n\tinode->i_mtime.tv_nsec = 0;\n\tinode->i_blocks = 0;\n\n\tsi = SYSV_I(inode);\n\tfor (block = 0; block < 10+1+1+1; block++)\n\t\tread3byte(sbi, &raw_inode->i_data[3*block],\n\t\t\t\t(u8 *)&si->i_data[block]);\n\tbrelse(bh);\n\tsi->i_dir_start_lookup = 0;\n\tif (S_ISCHR(inode->i_mode) || S_ISBLK(inode->i_mode))\n\t\tsysv_set_inode(inode,\n\t\t\t       old_decode_dev(fs32_to_cpu(sbi, si->i_data[0])));\n\telse\n\t\tsysv_set_inode(inode, 0);\n\tunlock_new_inode(inode);\n\treturn inode;\n\nbad_inode:\n\tiget_failed(inode);\n\treturn ERR_PTR(-EIO);\n}",
          "includes": [
            "#include \"sysv.h\"",
            "#include <asm/byteorder.h>",
            "#include <linux/namei.h>",
            "#include <linux/writeback.h>",
            "#include <linux/vfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/highuid.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysv.h\"\n#include <asm/byteorder.h>\n#include <linux/namei.h>\n#include <linux/writeback.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/highuid.h>\n\nstruct inode *sysv_iget(struct super_block *sb, unsigned int ino)\n{\n\tstruct sysv_sb_info * sbi = SYSV_SB(sb);\n\tstruct buffer_head * bh;\n\tstruct sysv_inode * raw_inode;\n\tstruct sysv_inode_info * si;\n\tstruct inode *inode;\n\tunsigned int block;\n\n\tif (!ino || ino > sbi->s_ninodes) {\n\t\tprintk(\"Bad inode number on dev %s: %d is out of range\\n\",\n\t\t       sb->s_id, ino);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\n\tinode = iget_locked(sb, ino);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (!(inode->i_state & I_NEW))\n\t\treturn inode;\n\n\traw_inode = sysv_raw_inode(sb, ino, &bh);\n\tif (!raw_inode) {\n\t\tprintk(\"Major problem: unable to read inode from dev %s\\n\",\n\t\t       inode->i_sb->s_id);\n\t\tgoto bad_inode;\n\t}\n\t/* SystemV FS: kludge permissions if ino==SYSV_ROOT_INO ?? */\n\tinode->i_mode = fs16_to_cpu(sbi, raw_inode->i_mode);\n\ti_uid_write(inode, (uid_t)fs16_to_cpu(sbi, raw_inode->i_uid));\n\ti_gid_write(inode, (gid_t)fs16_to_cpu(sbi, raw_inode->i_gid));\n\tset_nlink(inode, fs16_to_cpu(sbi, raw_inode->i_nlink));\n\tinode->i_size = fs32_to_cpu(sbi, raw_inode->i_size);\n\tinode->i_atime.tv_sec = fs32_to_cpu(sbi, raw_inode->i_atime);\n\tinode->i_mtime.tv_sec = fs32_to_cpu(sbi, raw_inode->i_mtime);\n\tinode->i_ctime.tv_sec = fs32_to_cpu(sbi, raw_inode->i_ctime);\n\tinode->i_ctime.tv_nsec = 0;\n\tinode->i_atime.tv_nsec = 0;\n\tinode->i_mtime.tv_nsec = 0;\n\tinode->i_blocks = 0;\n\n\tsi = SYSV_I(inode);\n\tfor (block = 0; block < 10+1+1+1; block++)\n\t\tread3byte(sbi, &raw_inode->i_data[3*block],\n\t\t\t\t(u8 *)&si->i_data[block]);\n\tbrelse(bh);\n\tsi->i_dir_start_lookup = 0;\n\tif (S_ISCHR(inode->i_mode) || S_ISBLK(inode->i_mode))\n\t\tsysv_set_inode(inode,\n\t\t\t       old_decode_dev(fs32_to_cpu(sbi, si->i_data[0])));\n\telse\n\t\tsysv_set_inode(inode, 0);\n\tunlock_new_inode(inode);\n\treturn inode;\n\nbad_inode:\n\tiget_failed(inode);\n\treturn ERR_PTR(-EIO);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sysv_inode_by_name",
          "args": [
            "dentry"
          ],
          "line": 52
        },
        "resolved": true,
        "details": {
          "function_name": "sysv_inode_by_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sysv/dir.c",
          "lines": "361-372",
          "snippet": "ino_t sysv_inode_by_name(struct dentry *dentry)\n{\n\tstruct page *page;\n\tstruct sysv_dir_entry *de = sysv_find_entry (dentry, &page);\n\tino_t res = 0;\n\t\n\tif (de) {\n\t\tres = fs16_to_cpu(SYSV_SB(dentry->d_sb), de->inode);\n\t\tdir_put_page(page);\n\t}\n\treturn res;\n}",
          "includes": [
            "#include \"sysv.h\"",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysv.h\"\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n\nino_t sysv_inode_by_name(struct dentry *dentry)\n{\n\tstruct page *page;\n\tstruct sysv_dir_entry *de = sysv_find_entry (dentry, &page);\n\tino_t res = 0;\n\t\n\tif (de) {\n\t\tres = fs16_to_cpu(SYSV_SB(dentry->d_sb), de->inode);\n\t\tdir_put_page(page);\n\t}\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENAMETOOLONG"
          ],
          "line": 51
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sysv.h\"\n#include <linux/pagemap.h>\n\nstatic struct dentry *sysv_lookup(struct inode * dir, struct dentry * dentry, unsigned int flags)\n{\n\tstruct inode * inode = NULL;\n\tino_t ino;\n\n\tif (dentry->d_name.len > SYSV_NAMELEN)\n\t\treturn ERR_PTR(-ENAMETOOLONG);\n\tino = sysv_inode_by_name(dentry);\n\n\tif (ino) {\n\t\tinode = sysv_iget(dir->i_sb, ino);\n\t\tif (IS_ERR(inode))\n\t\t\treturn ERR_CAST(inode);\n\t}\n\td_add(dentry, inode);\n\treturn NULL;\n}"
  },
  {
    "function_name": "sysv_hash",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sysv/namei.c",
    "lines": "30-39",
    "snippet": "static int sysv_hash(const struct dentry *dentry, struct qstr *qstr)\n{\n\t/* Truncate the name in place, avoids having to define a compare\n\t   function. */\n\tif (qstr->len > SYSV_NAMELEN) {\n\t\tqstr->len = SYSV_NAMELEN;\n\t\tqstr->hash = full_name_hash(qstr->name, qstr->len);\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"sysv.h\"",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "full_name_hash",
          "args": [
            "qstr->name",
            "qstr->len"
          ],
          "line": 36
        },
        "resolved": true,
        "details": {
          "function_name": "full_name_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "1737-1743",
          "snippet": "unsigned int full_name_hash(const unsigned char *name, unsigned int len)\n{\n\tunsigned long hash = init_name_hash();\n\twhile (len--)\n\t\thash = partial_name_hash(*name++, hash);\n\treturn end_name_hash(hash);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nunsigned int full_name_hash(const unsigned char *name, unsigned int len)\n{\n\tunsigned long hash = init_name_hash();\n\twhile (len--)\n\t\thash = partial_name_hash(*name++, hash);\n\treturn end_name_hash(hash);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sysv.h\"\n#include <linux/pagemap.h>\n\nstatic int sysv_hash(const struct dentry *dentry, struct qstr *qstr)\n{\n\t/* Truncate the name in place, avoids having to define a compare\n\t   function. */\n\tif (qstr->len > SYSV_NAMELEN) {\n\t\tqstr->len = SYSV_NAMELEN;\n\t\tqstr->hash = full_name_hash(qstr->name, qstr->len);\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "add_nondir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sysv/namei.c",
    "lines": "18-28",
    "snippet": "static int add_nondir(struct dentry *dentry, struct inode *inode)\n{\n\tint err = sysv_add_link(dentry, inode);\n\tif (!err) {\n\t\td_instantiate(dentry, inode);\n\t\treturn 0;\n\t}\n\tinode_dec_link_count(inode);\n\tiput(inode);\n\treturn err;\n}",
    "includes": [
      "#include \"sysv.h\"",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "inode"
          ],
          "line": 26
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_dec_link_count",
          "args": [
            "inode"
          ],
          "line": 25
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_instantiate",
          "args": [
            "dentry",
            "inode"
          ],
          "line": 22
        },
        "resolved": true,
        "details": {
          "function_name": "d_instantiate_no_diralias",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1839-1854",
          "snippet": "int d_instantiate_no_diralias(struct dentry *entry, struct inode *inode)\n{\n\tBUG_ON(!hlist_unhashed(&entry->d_u.d_alias));\n\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode) && !hlist_empty(&inode->i_dentry)) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tiput(inode);\n\t\treturn -EBUSY;\n\t}\n\t__d_instantiate(entry, inode);\n\tspin_unlock(&inode->i_lock);\n\tsecurity_d_instantiate(entry, inode);\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nint d_instantiate_no_diralias(struct dentry *entry, struct inode *inode)\n{\n\tBUG_ON(!hlist_unhashed(&entry->d_u.d_alias));\n\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode) && !hlist_empty(&inode->i_dentry)) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tiput(inode);\n\t\treturn -EBUSY;\n\t}\n\t__d_instantiate(entry, inode);\n\tspin_unlock(&inode->i_lock);\n\tsecurity_d_instantiate(entry, inode);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sysv_add_link",
          "args": [
            "dentry",
            "inode"
          ],
          "line": 20
        },
        "resolved": true,
        "details": {
          "function_name": "sysv_add_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sysv/dir.c",
          "lines": "177-232",
          "snippet": "int sysv_add_link(struct dentry *dentry, struct inode *inode)\n{\n\tstruct inode *dir = dentry->d_parent->d_inode;\n\tconst char * name = dentry->d_name.name;\n\tint namelen = dentry->d_name.len;\n\tstruct page *page = NULL;\n\tstruct sysv_dir_entry * de;\n\tunsigned long npages = dir_pages(dir);\n\tunsigned long n;\n\tchar *kaddr;\n\tloff_t pos;\n\tint err;\n\n\t/* We take care of directory expansion in the same loop */\n\tfor (n = 0; n <= npages; n++) {\n\t\tpage = dir_get_page(dir, n);\n\t\terr = PTR_ERR(page);\n\t\tif (IS_ERR(page))\n\t\t\tgoto out;\n\t\tkaddr = (char*)page_address(page);\n\t\tde = (struct sysv_dir_entry *)kaddr;\n\t\tkaddr += PAGE_CACHE_SIZE - SYSV_DIRSIZE;\n\t\twhile ((char *)de <= kaddr) {\n\t\t\tif (!de->inode)\n\t\t\t\tgoto got_it;\n\t\t\terr = -EEXIST;\n\t\t\tif (namecompare(namelen, SYSV_NAMELEN, name, de->name)) \n\t\t\t\tgoto out_page;\n\t\t\tde++;\n\t\t}\n\t\tdir_put_page(page);\n\t}\n\tBUG();\n\treturn -EINVAL;\n\ngot_it:\n\tpos = page_offset(page) +\n\t\t\t(char*)de - (char*)page_address(page);\n\tlock_page(page);\n\terr = sysv_prepare_chunk(page, pos, SYSV_DIRSIZE);\n\tif (err)\n\t\tgoto out_unlock;\n\tmemcpy (de->name, name, namelen);\n\tmemset (de->name + namelen, 0, SYSV_DIRSIZE - namelen - 2);\n\tde->inode = cpu_to_fs16(SYSV_SB(inode->i_sb), inode->i_ino);\n\terr = dir_commit_chunk(page, pos, SYSV_DIRSIZE);\n\tdir->i_mtime = dir->i_ctime = CURRENT_TIME_SEC;\n\tmark_inode_dirty(dir);\nout_page:\n\tdir_put_page(page);\nout:\n\treturn err;\nout_unlock:\n\tunlock_page(page);\n\tgoto out_page;\n}",
          "includes": [
            "#include \"sysv.h\"",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysv.h\"\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n\nint sysv_add_link(struct dentry *dentry, struct inode *inode)\n{\n\tstruct inode *dir = dentry->d_parent->d_inode;\n\tconst char * name = dentry->d_name.name;\n\tint namelen = dentry->d_name.len;\n\tstruct page *page = NULL;\n\tstruct sysv_dir_entry * de;\n\tunsigned long npages = dir_pages(dir);\n\tunsigned long n;\n\tchar *kaddr;\n\tloff_t pos;\n\tint err;\n\n\t/* We take care of directory expansion in the same loop */\n\tfor (n = 0; n <= npages; n++) {\n\t\tpage = dir_get_page(dir, n);\n\t\terr = PTR_ERR(page);\n\t\tif (IS_ERR(page))\n\t\t\tgoto out;\n\t\tkaddr = (char*)page_address(page);\n\t\tde = (struct sysv_dir_entry *)kaddr;\n\t\tkaddr += PAGE_CACHE_SIZE - SYSV_DIRSIZE;\n\t\twhile ((char *)de <= kaddr) {\n\t\t\tif (!de->inode)\n\t\t\t\tgoto got_it;\n\t\t\terr = -EEXIST;\n\t\t\tif (namecompare(namelen, SYSV_NAMELEN, name, de->name)) \n\t\t\t\tgoto out_page;\n\t\t\tde++;\n\t\t}\n\t\tdir_put_page(page);\n\t}\n\tBUG();\n\treturn -EINVAL;\n\ngot_it:\n\tpos = page_offset(page) +\n\t\t\t(char*)de - (char*)page_address(page);\n\tlock_page(page);\n\terr = sysv_prepare_chunk(page, pos, SYSV_DIRSIZE);\n\tif (err)\n\t\tgoto out_unlock;\n\tmemcpy (de->name, name, namelen);\n\tmemset (de->name + namelen, 0, SYSV_DIRSIZE - namelen - 2);\n\tde->inode = cpu_to_fs16(SYSV_SB(inode->i_sb), inode->i_ino);\n\terr = dir_commit_chunk(page, pos, SYSV_DIRSIZE);\n\tdir->i_mtime = dir->i_ctime = CURRENT_TIME_SEC;\n\tmark_inode_dirty(dir);\nout_page:\n\tdir_put_page(page);\nout:\n\treturn err;\nout_unlock:\n\tunlock_page(page);\n\tgoto out_page;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sysv.h\"\n#include <linux/pagemap.h>\n\nstatic int add_nondir(struct dentry *dentry, struct inode *inode)\n{\n\tint err = sysv_add_link(dentry, inode);\n\tif (!err) {\n\t\td_instantiate(dentry, inode);\n\t\treturn 0;\n\t}\n\tinode_dec_link_count(inode);\n\tiput(inode);\n\treturn err;\n}"
  }
]