[
  {
    "function_name": "btrfsic_unmount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/check-integrity.c",
    "lines": "3165-3248",
    "snippet": "void btrfsic_unmount(struct btrfs_root *root,\n\t\t     struct btrfs_fs_devices *fs_devices)\n{\n\tstruct list_head *elem_all;\n\tstruct list_head *tmp_all;\n\tstruct btrfsic_state *state;\n\tstruct list_head *dev_head = &fs_devices->devices;\n\tstruct btrfs_device *device;\n\n\tif (!btrfsic_is_initialized)\n\t\treturn;\n\n\tmutex_lock(&btrfsic_mutex);\n\n\tstate = NULL;\n\tlist_for_each_entry(device, dev_head, dev_list) {\n\t\tstruct btrfsic_dev_state *ds;\n\n\t\tif (!device->bdev || !device->name)\n\t\t\tcontinue;\n\n\t\tds = btrfsic_dev_state_hashtable_lookup(\n\t\t\t\tdevice->bdev,\n\t\t\t\t&btrfsic_dev_state_hashtable);\n\t\tif (NULL != ds) {\n\t\t\tstate = ds->state;\n\t\t\tbtrfsic_dev_state_hashtable_remove(ds);\n\t\t\tbtrfsic_dev_state_free(ds);\n\t\t}\n\t}\n\n\tif (NULL == state) {\n\t\tprintk(KERN_INFO\n\t\t       \"btrfsic: error, cannot find state information\"\n\t\t       \" on umount!\\n\");\n\t\tmutex_unlock(&btrfsic_mutex);\n\t\treturn;\n\t}\n\n\t/*\n\t * Don't care about keeping the lists' state up to date,\n\t * just free all memory that was allocated dynamically.\n\t * Free the blocks and the block_links.\n\t */\n\tlist_for_each_safe(elem_all, tmp_all, &state->all_blocks_list) {\n\t\tstruct btrfsic_block *const b_all =\n\t\t    list_entry(elem_all, struct btrfsic_block,\n\t\t\t       all_blocks_node);\n\t\tstruct list_head *elem_ref_to;\n\t\tstruct list_head *tmp_ref_to;\n\n\t\tlist_for_each_safe(elem_ref_to, tmp_ref_to,\n\t\t\t\t   &b_all->ref_to_list) {\n\t\t\tstruct btrfsic_block_link *const l =\n\t\t\t    list_entry(elem_ref_to,\n\t\t\t\t       struct btrfsic_block_link,\n\t\t\t\t       node_ref_to);\n\n\t\t\tif (state->print_mask & BTRFSIC_PRINT_MASK_VERBOSE)\n\t\t\t\tbtrfsic_print_rem_link(state, l);\n\n\t\t\tl->ref_cnt--;\n\t\t\tif (0 == l->ref_cnt)\n\t\t\t\tbtrfsic_block_link_free(l);\n\t\t}\n\n\t\tif (b_all->is_iodone || b_all->never_written)\n\t\t\tbtrfsic_block_free(b_all);\n\t\telse\n\t\t\tprintk(KERN_INFO \"btrfs: attempt to free %c-block\"\n\t\t\t       \" @%llu (%s/%llu/%d) on umount which is\"\n\t\t\t       \" not yet iodone!\\n\",\n\t\t\t       btrfsic_get_block_type(state, b_all),\n\t\t\t       b_all->logical_bytenr, b_all->dev_state->name,\n\t\t\t       b_all->dev_bytenr, b_all->mirror_num);\n\t}\n\n\tmutex_unlock(&btrfsic_mutex);\n\n\tif (is_vmalloc_addr(state))\n\t\tvfree(state);\n\telse\n\t\tkfree(state);\n}",
    "includes": [
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"volumes.h\"",
      "#include \"extent_io.h\"",
      "#include \"transaction.h\"",
      "#include \"hash.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/genhd.h>",
      "#include <linux/mutex.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [
      "#define BTRFSIC_PRINT_MASK_VERBOSE\t\t\t\t0x00000040"
    ],
    "globals_used": [
      "static void btrfsic_block_link_init(struct btrfsic_block_link *n);",
      "static void btrfsic_block_link_free(struct btrfsic_block_link *n);",
      "static void btrfsic_dev_state_init(struct btrfsic_dev_state *ds);",
      "static void btrfsic_dev_state_free(struct btrfsic_dev_state *ds);",
      "static void btrfsic_block_link_hashtable_remove(struct btrfsic_block_link *l);",
      "static void btrfsic_dev_state_hashtable_remove(struct btrfsic_dev_state *ds);",
      "static int btrfsic_process_superblock(struct btrfsic_state *state,\n\t\t\t\t      struct btrfs_fs_devices *fs_devices);",
      "static int btrfsic_map_block(struct btrfsic_state *state, u64 bytenr, u32 len,\n\t\t\t     struct btrfsic_block_data_ctx *block_ctx_out,\n\t\t\t     int mirror_num);",
      "static void btrfsic_dump_database(struct btrfsic_state *state);",
      "static void btrfsic_print_add_link(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block_link *l);",
      "static void btrfsic_print_rem_link(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block_link *l);",
      "static char btrfsic_get_block_type(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block *block);",
      "static void btrfsic_dump_tree(const struct btrfsic_state *state);",
      "static struct btrfsic_dev_state *btrfsic_dev_state_lookup(\n\t\tstruct block_device *bdev);",
      "static void btrfsic_cmp_log_and_dev_bytenr(struct btrfsic_state *state,\n\t\t\t\t\t   u64 bytenr,\n\t\t\t\t\t   struct btrfsic_dev_state *dev_state,\n\t\t\t\t\t   u64 dev_bytenr);",
      "static struct mutex btrfsic_mutex;",
      "static int btrfsic_is_initialized;",
      "static struct btrfsic_dev_state_hashtable btrfsic_dev_state_hashtable;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "state"
          ],
          "line": 3247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vfree",
          "args": [
            "state"
          ],
          "line": 3245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_vmalloc_addr",
          "args": [
            "state"
          ],
          "line": 3244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&btrfsic_mutex"
          ],
          "line": 3242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_INFO \"btrfs: attempt to free %c-block\"\n\t\t\t       \" @%llu (%s/%llu/%d) on umount which is\"\n\t\t\t       \" not yet iodone!\\n\"",
            "btrfsic_get_block_type(state, b_all)",
            "b_all->logical_bytenr",
            "b_all->dev_state->name",
            "b_all->dev_bytenr",
            "b_all->mirror_num"
          ],
          "line": 3234
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/super.c",
          "lines": "186-213",
          "snippet": "void btrfs_printk(const struct btrfs_fs_info *fs_info, const char *fmt, ...)\n{\n\tstruct super_block *sb = fs_info->sb;\n\tchar lvl[4];\n\tstruct va_format vaf;\n\tva_list args;\n\tconst char *type = logtypes[4];\n\tint kern_level;\n\n\tva_start(args, fmt);\n\n\tkern_level = printk_get_level(fmt);\n\tif (kern_level) {\n\t\tsize_t size = printk_skip_level(fmt) - fmt;\n\t\tmemcpy(lvl, fmt,  size);\n\t\tlvl[size] = '\\0';\n\t\tfmt += size;\n\t\ttype = logtypes[kern_level - '0'];\n\t} else\n\t\t*lvl = '\\0';\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sBTRFS %s (device %s): %pV\\n\", lvl, type, sb->s_id, &vaf);\n\n\tva_end(args);\n}",
          "includes": [
            "#include <trace/events/btrfs.h>",
            "#include \"qgroup.h\"",
            "#include \"tests/btrfs-tests.h\"",
            "#include \"backref.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"compression.h\"",
            "#include \"export.h\"",
            "#include \"volumes.h\"",
            "#include \"xattr.h\"",
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/slab.h>",
            "#include <linux/magic.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/namei.h>",
            "#include <linux/ctype.h>",
            "#include <linux/parser.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/btrfs.h>\n#include \"qgroup.h\"\n#include \"tests/btrfs-tests.h\"\n#include \"backref.h\"\n#include \"free-space-cache.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"compression.h\"\n#include \"export.h\"\n#include \"volumes.h\"\n#include \"xattr.h\"\n#include \"props.h\"\n#include \"hash.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include \"delayed-inode.h\"\n#include <linux/btrfs.h>\n#include <linux/ratelimit.h>\n#include <linux/cleancache.h>\n#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/miscdevice.h>\n#include <linux/namei.h>\n#include <linux/ctype.h>\n#include <linux/parser.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n\nvoid btrfs_printk(const struct btrfs_fs_info *fs_info, const char *fmt, ...)\n{\n\tstruct super_block *sb = fs_info->sb;\n\tchar lvl[4];\n\tstruct va_format vaf;\n\tva_list args;\n\tconst char *type = logtypes[4];\n\tint kern_level;\n\n\tva_start(args, fmt);\n\n\tkern_level = printk_get_level(fmt);\n\tif (kern_level) {\n\t\tsize_t size = printk_skip_level(fmt) - fmt;\n\t\tmemcpy(lvl, fmt,  size);\n\t\tlvl[size] = '\\0';\n\t\tfmt += size;\n\t\ttype = logtypes[kern_level - '0'];\n\t} else\n\t\t*lvl = '\\0';\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sBTRFS %s (device %s): %pV\\n\", lvl, type, sb->s_id, &vaf);\n\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfsic_get_block_type",
          "args": [
            "state",
            "b_all"
          ],
          "line": 3237
        },
        "resolved": true,
        "details": {
          "function_name": "btrfsic_get_block_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/check-integrity.c",
          "lines": "2648-2661",
          "snippet": "static char btrfsic_get_block_type(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block *block)\n{\n\tif (block->is_superblock &&\n\t    state->latest_superblock->dev_bytenr == block->dev_bytenr &&\n\t    state->latest_superblock->dev_state->bdev == block->dev_state->bdev)\n\t\treturn 'S';\n\telse if (block->is_superblock)\n\t\treturn 's';\n\telse if (block->is_metadata)\n\t\treturn 'M';\n\telse\n\t\treturn 'D';\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"extent_io.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/genhd.h>",
            "#include <linux/mutex.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void btrfsic_dump_database(struct btrfsic_state *state);",
            "static char btrfsic_get_block_type(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block *block);",
            "static void btrfsic_dump_tree(const struct btrfsic_state *state);",
            "static struct btrfsic_dev_state *btrfsic_dev_state_lookup(\n\t\tstruct block_device *bdev);",
            "static void btrfsic_cmp_log_and_dev_bytenr(struct btrfsic_state *state,\n\t\t\t\t\t   u64 bytenr,\n\t\t\t\t\t   struct btrfsic_dev_state *dev_state,\n\t\t\t\t\t   u64 dev_bytenr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"extent_io.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n#include <linux/blkdev.h>\n#include <linux/genhd.h>\n#include <linux/mutex.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic void btrfsic_dump_database(struct btrfsic_state *state);\nstatic char btrfsic_get_block_type(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block *block);\nstatic void btrfsic_dump_tree(const struct btrfsic_state *state);\nstatic struct btrfsic_dev_state *btrfsic_dev_state_lookup(\n\t\tstruct block_device *bdev);\nstatic void btrfsic_cmp_log_and_dev_bytenr(struct btrfsic_state *state,\n\t\t\t\t\t   u64 bytenr,\n\t\t\t\t\t   struct btrfsic_dev_state *dev_state,\n\t\t\t\t\t   u64 dev_bytenr);\n\nstatic char btrfsic_get_block_type(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block *block)\n{\n\tif (block->is_superblock &&\n\t    state->latest_superblock->dev_bytenr == block->dev_bytenr &&\n\t    state->latest_superblock->dev_state->bdev == block->dev_state->bdev)\n\t\treturn 'S';\n\telse if (block->is_superblock)\n\t\treturn 's';\n\telse if (block->is_metadata)\n\t\treturn 'M';\n\telse\n\t\treturn 'D';\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfsic_block_free",
          "args": [
            "b_all"
          ],
          "line": 3232
        },
        "resolved": true,
        "details": {
          "function_name": "btrfsic_block_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/check-integrity.c",
          "lines": "436-440",
          "snippet": "static void btrfsic_block_free(struct btrfsic_block *b)\n{\n\tBUG_ON(!(NULL == b || BTRFSIC_BLOCK_MAGIC_NUMBER == b->magic_num));\n\tkfree(b);\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"extent_io.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/genhd.h>",
            "#include <linux/mutex.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define BTRFSIC_BLOCK_MAGIC_NUMBER 0x14491051"
          ],
          "globals_used": [
            "static void btrfsic_block_init(struct btrfsic_block *b);",
            "static void btrfsic_block_free(struct btrfsic_block *b);",
            "static void btrfsic_block_hashtable_remove(struct btrfsic_block *b);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"extent_io.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n#include <linux/blkdev.h>\n#include <linux/genhd.h>\n#include <linux/mutex.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\n#define BTRFSIC_BLOCK_MAGIC_NUMBER 0x14491051\n\nstatic void btrfsic_block_init(struct btrfsic_block *b);\nstatic void btrfsic_block_free(struct btrfsic_block *b);\nstatic void btrfsic_block_hashtable_remove(struct btrfsic_block *b);\n\nstatic void btrfsic_block_free(struct btrfsic_block *b)\n{\n\tBUG_ON(!(NULL == b || BTRFSIC_BLOCK_MAGIC_NUMBER == b->magic_num));\n\tkfree(b);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfsic_block_link_free",
          "args": [
            "l"
          ],
          "line": 3228
        },
        "resolved": true,
        "details": {
          "function_name": "btrfsic_block_link_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/check-integrity.c",
          "lines": "464-468",
          "snippet": "static void btrfsic_block_link_free(struct btrfsic_block_link *l)\n{\n\tBUG_ON(!(NULL == l || BTRFSIC_BLOCK_LINK_MAGIC_NUMBER == l->magic_num));\n\tkfree(l);\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"extent_io.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/genhd.h>",
            "#include <linux/mutex.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define BTRFSIC_BLOCK_LINK_MAGIC_NUMBER 0x11070807"
          ],
          "globals_used": [
            "static void btrfsic_block_link_hashtable_remove(struct btrfsic_block_link *l);",
            "static void btrfsic_print_add_link(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block_link *l);",
            "static void btrfsic_print_rem_link(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block_link *l);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"extent_io.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n#include <linux/blkdev.h>\n#include <linux/genhd.h>\n#include <linux/mutex.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\n#define BTRFSIC_BLOCK_LINK_MAGIC_NUMBER 0x11070807\n\nstatic void btrfsic_block_link_hashtable_remove(struct btrfsic_block_link *l);\nstatic void btrfsic_print_add_link(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block_link *l);\nstatic void btrfsic_print_rem_link(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block_link *l);\n\nstatic void btrfsic_block_link_free(struct btrfsic_block_link *l)\n{\n\tBUG_ON(!(NULL == l || BTRFSIC_BLOCK_LINK_MAGIC_NUMBER == l->magic_num));\n\tkfree(l);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfsic_print_rem_link",
          "args": [
            "state",
            "l"
          ],
          "line": 3224
        },
        "resolved": true,
        "details": {
          "function_name": "btrfsic_print_rem_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/check-integrity.c",
          "lines": "2631-2646",
          "snippet": "static void btrfsic_print_rem_link(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block_link *l)\n{\n\tprintk(KERN_INFO\n\t       \"Rem %u* link from %c @%llu (%s/%llu/%d)\"\n\t       \" to %c @%llu (%s/%llu/%d).\\n\",\n\t       l->ref_cnt,\n\t       btrfsic_get_block_type(state, l->block_ref_from),\n\t       l->block_ref_from->logical_bytenr,\n\t       l->block_ref_from->dev_state->name,\n\t       l->block_ref_from->dev_bytenr, l->block_ref_from->mirror_num,\n\t       btrfsic_get_block_type(state, l->block_ref_to),\n\t       l->block_ref_to->logical_bytenr,\n\t       l->block_ref_to->dev_state->name, l->block_ref_to->dev_bytenr,\n\t       l->block_ref_to->mirror_num);\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"extent_io.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/genhd.h>",
            "#include <linux/mutex.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void btrfsic_block_link_init(struct btrfsic_block_link *n);",
            "static void btrfsic_block_link_free(struct btrfsic_block_link *n);",
            "static void btrfsic_block_link_hashtable_remove(struct btrfsic_block_link *l);",
            "static int btrfsic_map_block(struct btrfsic_state *state, u64 bytenr, u32 len,\n\t\t\t     struct btrfsic_block_data_ctx *block_ctx_out,\n\t\t\t     int mirror_num);",
            "static void btrfsic_dump_database(struct btrfsic_state *state);",
            "static void btrfsic_print_add_link(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block_link *l);",
            "static void btrfsic_print_rem_link(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block_link *l);",
            "static void btrfsic_dump_tree(const struct btrfsic_state *state);",
            "static void btrfsic_cmp_log_and_dev_bytenr(struct btrfsic_state *state,\n\t\t\t\t\t   u64 bytenr,\n\t\t\t\t\t   struct btrfsic_dev_state *dev_state,\n\t\t\t\t\t   u64 dev_bytenr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"extent_io.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n#include <linux/blkdev.h>\n#include <linux/genhd.h>\n#include <linux/mutex.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic void btrfsic_block_link_init(struct btrfsic_block_link *n);\nstatic void btrfsic_block_link_free(struct btrfsic_block_link *n);\nstatic void btrfsic_block_link_hashtable_remove(struct btrfsic_block_link *l);\nstatic int btrfsic_map_block(struct btrfsic_state *state, u64 bytenr, u32 len,\n\t\t\t     struct btrfsic_block_data_ctx *block_ctx_out,\n\t\t\t     int mirror_num);\nstatic void btrfsic_dump_database(struct btrfsic_state *state);\nstatic void btrfsic_print_add_link(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block_link *l);\nstatic void btrfsic_print_rem_link(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block_link *l);\nstatic void btrfsic_dump_tree(const struct btrfsic_state *state);\nstatic void btrfsic_cmp_log_and_dev_bytenr(struct btrfsic_state *state,\n\t\t\t\t\t   u64 bytenr,\n\t\t\t\t\t   struct btrfsic_dev_state *dev_state,\n\t\t\t\t\t   u64 dev_bytenr);\n\nstatic void btrfsic_print_rem_link(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block_link *l)\n{\n\tprintk(KERN_INFO\n\t       \"Rem %u* link from %c @%llu (%s/%llu/%d)\"\n\t       \" to %c @%llu (%s/%llu/%d).\\n\",\n\t       l->ref_cnt,\n\t       btrfsic_get_block_type(state, l->block_ref_from),\n\t       l->block_ref_from->logical_bytenr,\n\t       l->block_ref_from->dev_state->name,\n\t       l->block_ref_from->dev_bytenr, l->block_ref_from->mirror_num,\n\t       btrfsic_get_block_type(state, l->block_ref_to),\n\t       l->block_ref_to->logical_bytenr,\n\t       l->block_ref_to->dev_state->name, l->block_ref_to->dev_bytenr,\n\t       l->block_ref_to->mirror_num);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "elem_ref_to",
            "structbtrfsic_block_link",
            "node_ref_to"
          ],
          "line": 3219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_safe",
          "args": [
            "elem_ref_to",
            "tmp_ref_to",
            "&b_all->ref_to_list"
          ],
          "line": 3216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "elem_all",
            "structbtrfsic_block",
            "all_blocks_node"
          ],
          "line": 3211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_safe",
          "args": [
            "elem_all",
            "tmp_all",
            "&state->all_blocks_list"
          ],
          "line": 3209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&btrfsic_mutex"
          ],
          "line": 3200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_INFO\n\t\t       \"btrfsic: error, cannot find state information\"\n\t\t       \" on umount!\\n\""
          ],
          "line": 3197
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfsic_dev_state_free",
          "args": [
            "ds"
          ],
          "line": 3192
        },
        "resolved": true,
        "details": {
          "function_name": "btrfsic_dev_state_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/check-integrity.c",
          "lines": "494-499",
          "snippet": "static void btrfsic_dev_state_free(struct btrfsic_dev_state *ds)\n{\n\tBUG_ON(!(NULL == ds ||\n\t\t BTRFSIC_DEV2STATE_MAGIC_NUMBER == ds->magic_num));\n\tkfree(ds);\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"extent_io.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/genhd.h>",
            "#include <linux/mutex.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define BTRFSIC_DEV2STATE_MAGIC_NUMBER 0x20111530"
          ],
          "globals_used": [
            "static void btrfsic_dev_state_init(struct btrfsic_dev_state *ds);",
            "static void btrfsic_dev_state_free(struct btrfsic_dev_state *ds);",
            "static void btrfsic_dev_state_hashtable_remove(struct btrfsic_dev_state *ds);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"extent_io.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n#include <linux/blkdev.h>\n#include <linux/genhd.h>\n#include <linux/mutex.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\n#define BTRFSIC_DEV2STATE_MAGIC_NUMBER 0x20111530\n\nstatic void btrfsic_dev_state_init(struct btrfsic_dev_state *ds);\nstatic void btrfsic_dev_state_free(struct btrfsic_dev_state *ds);\nstatic void btrfsic_dev_state_hashtable_remove(struct btrfsic_dev_state *ds);\n\nstatic void btrfsic_dev_state_free(struct btrfsic_dev_state *ds)\n{\n\tBUG_ON(!(NULL == ds ||\n\t\t BTRFSIC_DEV2STATE_MAGIC_NUMBER == ds->magic_num));\n\tkfree(ds);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfsic_dev_state_hashtable_remove",
          "args": [
            "ds"
          ],
          "line": 3191
        },
        "resolved": true,
        "details": {
          "function_name": "btrfsic_dev_state_hashtable_remove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/check-integrity.c",
          "lines": "630-633",
          "snippet": "static void btrfsic_dev_state_hashtable_remove(struct btrfsic_dev_state *ds)\n{\n\tlist_del(&ds->collision_resolving_node);\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"extent_io.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/genhd.h>",
            "#include <linux/mutex.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void btrfsic_dev_state_init(struct btrfsic_dev_state *ds);",
            "static void btrfsic_dev_state_free(struct btrfsic_dev_state *ds);",
            "static void btrfsic_dev_state_hashtable_remove(struct btrfsic_dev_state *ds);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"extent_io.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n#include <linux/blkdev.h>\n#include <linux/genhd.h>\n#include <linux/mutex.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic void btrfsic_dev_state_init(struct btrfsic_dev_state *ds);\nstatic void btrfsic_dev_state_free(struct btrfsic_dev_state *ds);\nstatic void btrfsic_dev_state_hashtable_remove(struct btrfsic_dev_state *ds);\n\nstatic void btrfsic_dev_state_hashtable_remove(struct btrfsic_dev_state *ds)\n{\n\tlist_del(&ds->collision_resolving_node);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfsic_dev_state_hashtable_lookup",
          "args": [
            "device->bdev",
            "&btrfsic_dev_state_hashtable"
          ],
          "line": 3186
        },
        "resolved": true,
        "details": {
          "function_name": "btrfsic_dev_state_hashtable_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/check-integrity.c",
          "lines": "635-654",
          "snippet": "static struct btrfsic_dev_state *btrfsic_dev_state_hashtable_lookup(\n\t\tstruct block_device *bdev,\n\t\tstruct btrfsic_dev_state_hashtable *h)\n{\n\tconst unsigned int hashval =\n\t    (((unsigned int)((uintptr_t)bdev)) &\n\t     (BTRFSIC_DEV2STATE_HASHTABLE_SIZE - 1));\n\tstruct list_head *elem;\n\n\tlist_for_each(elem, h->table + hashval) {\n\t\tstruct btrfsic_dev_state *const ds =\n\t\t    list_entry(elem, struct btrfsic_dev_state,\n\t\t\t       collision_resolving_node);\n\n\t\tif (ds->bdev == bdev)\n\t\t\treturn ds;\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"extent_io.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/genhd.h>",
            "#include <linux/mutex.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define BTRFSIC_DEV2STATE_HASHTABLE_SIZE 0x100"
          ],
          "globals_used": [
            "static void btrfsic_dev_state_init(struct btrfsic_dev_state *ds);",
            "static void btrfsic_dev_state_free(struct btrfsic_dev_state *ds);",
            "static void btrfsic_block_hashtable_init(struct btrfsic_block_hashtable *h);",
            "static void btrfsic_block_hashtable_add(struct btrfsic_block *b,\n\t\t\t\t\tstruct btrfsic_block_hashtable *h);",
            "static struct btrfsic_block *btrfsic_block_hashtable_lookup(\n\t\tstruct block_device *bdev,\n\t\tu64 dev_bytenr,\n\t\tstruct btrfsic_block_hashtable *h);",
            "static void btrfsic_block_link_hashtable_init(\n\t\tstruct btrfsic_block_link_hashtable *h);",
            "static void btrfsic_block_link_hashtable_add(\n\t\tstruct btrfsic_block_link *l,\n\t\tstruct btrfsic_block_link_hashtable *h);",
            "static struct btrfsic_block_link *btrfsic_block_link_hashtable_lookup(\n\t\tstruct block_device *bdev_ref_to,\n\t\tu64 dev_bytenr_ref_to,\n\t\tstruct block_device *bdev_ref_from,\n\t\tu64 dev_bytenr_ref_from,\n\t\tstruct btrfsic_block_link_hashtable *h);",
            "static void btrfsic_dev_state_hashtable_init(\n\t\tstruct btrfsic_dev_state_hashtable *h);",
            "static void btrfsic_dev_state_hashtable_add(\n\t\tstruct btrfsic_dev_state *ds,\n\t\tstruct btrfsic_dev_state_hashtable *h);",
            "static void btrfsic_dev_state_hashtable_remove(struct btrfsic_dev_state *ds);",
            "static struct btrfsic_dev_state *btrfsic_dev_state_hashtable_lookup(\n\t\tstruct block_device *bdev,\n\t\tstruct btrfsic_dev_state_hashtable *h);",
            "static struct btrfsic_dev_state *btrfsic_dev_state_lookup(\n\t\tstruct block_device *bdev);",
            "static struct btrfsic_dev_state_hashtable btrfsic_dev_state_hashtable;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"extent_io.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n#include <linux/blkdev.h>\n#include <linux/genhd.h>\n#include <linux/mutex.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\n#define BTRFSIC_DEV2STATE_HASHTABLE_SIZE 0x100\n\nstatic void btrfsic_dev_state_init(struct btrfsic_dev_state *ds);\nstatic void btrfsic_dev_state_free(struct btrfsic_dev_state *ds);\nstatic void btrfsic_block_hashtable_init(struct btrfsic_block_hashtable *h);\nstatic void btrfsic_block_hashtable_add(struct btrfsic_block *b,\n\t\t\t\t\tstruct btrfsic_block_hashtable *h);\nstatic struct btrfsic_block *btrfsic_block_hashtable_lookup(\n\t\tstruct block_device *bdev,\n\t\tu64 dev_bytenr,\n\t\tstruct btrfsic_block_hashtable *h);\nstatic void btrfsic_block_link_hashtable_init(\n\t\tstruct btrfsic_block_link_hashtable *h);\nstatic void btrfsic_block_link_hashtable_add(\n\t\tstruct btrfsic_block_link *l,\n\t\tstruct btrfsic_block_link_hashtable *h);\nstatic struct btrfsic_block_link *btrfsic_block_link_hashtable_lookup(\n\t\tstruct block_device *bdev_ref_to,\n\t\tu64 dev_bytenr_ref_to,\n\t\tstruct block_device *bdev_ref_from,\n\t\tu64 dev_bytenr_ref_from,\n\t\tstruct btrfsic_block_link_hashtable *h);\nstatic void btrfsic_dev_state_hashtable_init(\n\t\tstruct btrfsic_dev_state_hashtable *h);\nstatic void btrfsic_dev_state_hashtable_add(\n\t\tstruct btrfsic_dev_state *ds,\n\t\tstruct btrfsic_dev_state_hashtable *h);\nstatic void btrfsic_dev_state_hashtable_remove(struct btrfsic_dev_state *ds);\nstatic struct btrfsic_dev_state *btrfsic_dev_state_hashtable_lookup(\n\t\tstruct block_device *bdev,\n\t\tstruct btrfsic_dev_state_hashtable *h);\nstatic struct btrfsic_dev_state *btrfsic_dev_state_lookup(\n\t\tstruct block_device *bdev);\nstatic struct btrfsic_dev_state_hashtable btrfsic_dev_state_hashtable;\n\nstatic struct btrfsic_dev_state *btrfsic_dev_state_hashtable_lookup(\n\t\tstruct block_device *bdev,\n\t\tstruct btrfsic_dev_state_hashtable *h)\n{\n\tconst unsigned int hashval =\n\t    (((unsigned int)((uintptr_t)bdev)) &\n\t     (BTRFSIC_DEV2STATE_HASHTABLE_SIZE - 1));\n\tstruct list_head *elem;\n\n\tlist_for_each(elem, h->table + hashval) {\n\t\tstruct btrfsic_dev_state *const ds =\n\t\t    list_entry(elem, struct btrfsic_dev_state,\n\t\t\t       collision_resolving_node);\n\n\t\tif (ds->bdev == bdev)\n\t\t\treturn ds;\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "device",
            "dev_head",
            "dev_list"
          ],
          "line": 3180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&btrfsic_mutex"
          ],
          "line": 3177
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"extent_io.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n#include <linux/blkdev.h>\n#include <linux/genhd.h>\n#include <linux/mutex.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\n#define BTRFSIC_PRINT_MASK_VERBOSE\t\t\t\t0x00000040\n\nstatic void btrfsic_block_link_init(struct btrfsic_block_link *n);\nstatic void btrfsic_block_link_free(struct btrfsic_block_link *n);\nstatic void btrfsic_dev_state_init(struct btrfsic_dev_state *ds);\nstatic void btrfsic_dev_state_free(struct btrfsic_dev_state *ds);\nstatic void btrfsic_block_link_hashtable_remove(struct btrfsic_block_link *l);\nstatic void btrfsic_dev_state_hashtable_remove(struct btrfsic_dev_state *ds);\nstatic int btrfsic_process_superblock(struct btrfsic_state *state,\n\t\t\t\t      struct btrfs_fs_devices *fs_devices);\nstatic int btrfsic_map_block(struct btrfsic_state *state, u64 bytenr, u32 len,\n\t\t\t     struct btrfsic_block_data_ctx *block_ctx_out,\n\t\t\t     int mirror_num);\nstatic void btrfsic_dump_database(struct btrfsic_state *state);\nstatic void btrfsic_print_add_link(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block_link *l);\nstatic void btrfsic_print_rem_link(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block_link *l);\nstatic char btrfsic_get_block_type(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block *block);\nstatic void btrfsic_dump_tree(const struct btrfsic_state *state);\nstatic struct btrfsic_dev_state *btrfsic_dev_state_lookup(\n\t\tstruct block_device *bdev);\nstatic void btrfsic_cmp_log_and_dev_bytenr(struct btrfsic_state *state,\n\t\t\t\t\t   u64 bytenr,\n\t\t\t\t\t   struct btrfsic_dev_state *dev_state,\n\t\t\t\t\t   u64 dev_bytenr);\nstatic struct mutex btrfsic_mutex;\nstatic int btrfsic_is_initialized;\nstatic struct btrfsic_dev_state_hashtable btrfsic_dev_state_hashtable;\n\nvoid btrfsic_unmount(struct btrfs_root *root,\n\t\t     struct btrfs_fs_devices *fs_devices)\n{\n\tstruct list_head *elem_all;\n\tstruct list_head *tmp_all;\n\tstruct btrfsic_state *state;\n\tstruct list_head *dev_head = &fs_devices->devices;\n\tstruct btrfs_device *device;\n\n\tif (!btrfsic_is_initialized)\n\t\treturn;\n\n\tmutex_lock(&btrfsic_mutex);\n\n\tstate = NULL;\n\tlist_for_each_entry(device, dev_head, dev_list) {\n\t\tstruct btrfsic_dev_state *ds;\n\n\t\tif (!device->bdev || !device->name)\n\t\t\tcontinue;\n\n\t\tds = btrfsic_dev_state_hashtable_lookup(\n\t\t\t\tdevice->bdev,\n\t\t\t\t&btrfsic_dev_state_hashtable);\n\t\tif (NULL != ds) {\n\t\t\tstate = ds->state;\n\t\t\tbtrfsic_dev_state_hashtable_remove(ds);\n\t\t\tbtrfsic_dev_state_free(ds);\n\t\t}\n\t}\n\n\tif (NULL == state) {\n\t\tprintk(KERN_INFO\n\t\t       \"btrfsic: error, cannot find state information\"\n\t\t       \" on umount!\\n\");\n\t\tmutex_unlock(&btrfsic_mutex);\n\t\treturn;\n\t}\n\n\t/*\n\t * Don't care about keeping the lists' state up to date,\n\t * just free all memory that was allocated dynamically.\n\t * Free the blocks and the block_links.\n\t */\n\tlist_for_each_safe(elem_all, tmp_all, &state->all_blocks_list) {\n\t\tstruct btrfsic_block *const b_all =\n\t\t    list_entry(elem_all, struct btrfsic_block,\n\t\t\t       all_blocks_node);\n\t\tstruct list_head *elem_ref_to;\n\t\tstruct list_head *tmp_ref_to;\n\n\t\tlist_for_each_safe(elem_ref_to, tmp_ref_to,\n\t\t\t\t   &b_all->ref_to_list) {\n\t\t\tstruct btrfsic_block_link *const l =\n\t\t\t    list_entry(elem_ref_to,\n\t\t\t\t       struct btrfsic_block_link,\n\t\t\t\t       node_ref_to);\n\n\t\t\tif (state->print_mask & BTRFSIC_PRINT_MASK_VERBOSE)\n\t\t\t\tbtrfsic_print_rem_link(state, l);\n\n\t\t\tl->ref_cnt--;\n\t\t\tif (0 == l->ref_cnt)\n\t\t\t\tbtrfsic_block_link_free(l);\n\t\t}\n\n\t\tif (b_all->is_iodone || b_all->never_written)\n\t\t\tbtrfsic_block_free(b_all);\n\t\telse\n\t\t\tprintk(KERN_INFO \"btrfs: attempt to free %c-block\"\n\t\t\t       \" @%llu (%s/%llu/%d) on umount which is\"\n\t\t\t       \" not yet iodone!\\n\",\n\t\t\t       btrfsic_get_block_type(state, b_all),\n\t\t\t       b_all->logical_bytenr, b_all->dev_state->name,\n\t\t\t       b_all->dev_bytenr, b_all->mirror_num);\n\t}\n\n\tmutex_unlock(&btrfsic_mutex);\n\n\tif (is_vmalloc_addr(state))\n\t\tvfree(state);\n\telse\n\t\tkfree(state);\n}"
  },
  {
    "function_name": "btrfsic_mount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/check-integrity.c",
    "lines": "3073-3163",
    "snippet": "int btrfsic_mount(struct btrfs_root *root,\n\t\t  struct btrfs_fs_devices *fs_devices,\n\t\t  int including_extent_data, u32 print_mask)\n{\n\tint ret;\n\tstruct btrfsic_state *state;\n\tstruct list_head *dev_head = &fs_devices->devices;\n\tstruct btrfs_device *device;\n\n\tif (root->nodesize & ((u64)PAGE_CACHE_SIZE - 1)) {\n\t\tprintk(KERN_INFO\n\t\t       \"btrfsic: cannot handle nodesize %d not being a multiple of PAGE_CACHE_SIZE %ld!\\n\",\n\t\t       root->nodesize, PAGE_CACHE_SIZE);\n\t\treturn -1;\n\t}\n\tif (root->sectorsize & ((u64)PAGE_CACHE_SIZE - 1)) {\n\t\tprintk(KERN_INFO\n\t\t       \"btrfsic: cannot handle sectorsize %d not being a multiple of PAGE_CACHE_SIZE %ld!\\n\",\n\t\t       root->sectorsize, PAGE_CACHE_SIZE);\n\t\treturn -1;\n\t}\n\tstate = kzalloc(sizeof(*state), GFP_KERNEL | __GFP_NOWARN | __GFP_REPEAT);\n\tif (!state) {\n\t\tstate = vzalloc(sizeof(*state));\n\t\tif (!state) {\n\t\t\tprintk(KERN_INFO \"btrfs check-integrity: vzalloc() failed!\\n\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tif (!btrfsic_is_initialized) {\n\t\tmutex_init(&btrfsic_mutex);\n\t\tbtrfsic_dev_state_hashtable_init(&btrfsic_dev_state_hashtable);\n\t\tbtrfsic_is_initialized = 1;\n\t}\n\tmutex_lock(&btrfsic_mutex);\n\tstate->root = root;\n\tstate->print_mask = print_mask;\n\tstate->include_extent_data = including_extent_data;\n\tstate->csum_size = 0;\n\tstate->metablock_size = root->nodesize;\n\tstate->datablock_size = root->sectorsize;\n\tINIT_LIST_HEAD(&state->all_blocks_list);\n\tbtrfsic_block_hashtable_init(&state->block_hashtable);\n\tbtrfsic_block_link_hashtable_init(&state->block_link_hashtable);\n\tstate->max_superblock_generation = 0;\n\tstate->latest_superblock = NULL;\n\n\tlist_for_each_entry(device, dev_head, dev_list) {\n\t\tstruct btrfsic_dev_state *ds;\n\t\tchar *p;\n\n\t\tif (!device->bdev || !device->name)\n\t\t\tcontinue;\n\n\t\tds = btrfsic_dev_state_alloc();\n\t\tif (NULL == ds) {\n\t\t\tprintk(KERN_INFO\n\t\t\t       \"btrfs check-integrity: kmalloc() failed!\\n\");\n\t\t\tmutex_unlock(&btrfsic_mutex);\n\t\t\treturn -1;\n\t\t}\n\t\tds->bdev = device->bdev;\n\t\tds->state = state;\n\t\tbdevname(ds->bdev, ds->name);\n\t\tds->name[BDEVNAME_SIZE - 1] = '\\0';\n\t\tfor (p = ds->name; *p != '\\0'; p++);\n\t\twhile (p > ds->name && *p != '/')\n\t\t\tp--;\n\t\tif (*p == '/')\n\t\t\tp++;\n\t\tstrlcpy(ds->name, p, sizeof(ds->name));\n\t\tbtrfsic_dev_state_hashtable_add(ds,\n\t\t\t\t\t\t&btrfsic_dev_state_hashtable);\n\t}\n\n\tret = btrfsic_process_superblock(state, fs_devices);\n\tif (0 != ret) {\n\t\tmutex_unlock(&btrfsic_mutex);\n\t\tbtrfsic_unmount(root, fs_devices);\n\t\treturn ret;\n\t}\n\n\tif (state->print_mask & BTRFSIC_PRINT_MASK_INITIAL_DATABASE)\n\t\tbtrfsic_dump_database(state);\n\tif (state->print_mask & BTRFSIC_PRINT_MASK_INITIAL_TREE)\n\t\tbtrfsic_dump_tree(state);\n\n\tmutex_unlock(&btrfsic_mutex);\n\treturn 0;\n}",
    "includes": [
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"volumes.h\"",
      "#include \"extent_io.h\"",
      "#include \"transaction.h\"",
      "#include \"hash.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/genhd.h>",
      "#include <linux/mutex.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [
      "#define BTRFSIC_PRINT_MASK_INITIAL_DATABASE\t\t\t0x00000400",
      "#define BTRFSIC_PRINT_MASK_INITIAL_TREE\t\t\t\t0x00000100"
    ],
    "globals_used": [
      "static void btrfsic_block_link_init(struct btrfsic_block_link *n);",
      "static void btrfsic_block_link_free(struct btrfsic_block_link *n);",
      "static void btrfsic_dev_state_init(struct btrfsic_dev_state *ds);",
      "static struct btrfsic_dev_state *btrfsic_dev_state_alloc(void);",
      "static void btrfsic_dev_state_free(struct btrfsic_dev_state *ds);",
      "static void btrfsic_dev_state_hashtable_remove(struct btrfsic_dev_state *ds);",
      "static int btrfsic_process_superblock(struct btrfsic_state *state,\n\t\t\t\t      struct btrfs_fs_devices *fs_devices);",
      "static void btrfsic_dump_database(struct btrfsic_state *state);",
      "static void btrfsic_dump_tree(const struct btrfsic_state *state);",
      "static struct btrfsic_dev_state *btrfsic_dev_state_lookup(\n\t\tstruct block_device *bdev);",
      "static struct mutex btrfsic_mutex;",
      "static int btrfsic_is_initialized;",
      "static struct btrfsic_dev_state_hashtable btrfsic_dev_state_hashtable;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&btrfsic_mutex"
          ],
          "line": 3161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfsic_dump_tree",
          "args": [
            "state"
          ],
          "line": 3159
        },
        "resolved": true,
        "details": {
          "function_name": "btrfsic_dump_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/check-integrity.c",
          "lines": "2663-2666",
          "snippet": "static void btrfsic_dump_tree(const struct btrfsic_state *state)\n{\n\tbtrfsic_dump_tree_sub(state, state->latest_superblock, 0);\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"extent_io.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/genhd.h>",
            "#include <linux/mutex.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void btrfsic_dump_database(struct btrfsic_state *state);",
            "static void btrfsic_dump_tree(const struct btrfsic_state *state);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"extent_io.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n#include <linux/blkdev.h>\n#include <linux/genhd.h>\n#include <linux/mutex.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic void btrfsic_dump_database(struct btrfsic_state *state);\nstatic void btrfsic_dump_tree(const struct btrfsic_state *state);\n\nstatic void btrfsic_dump_tree(const struct btrfsic_state *state)\n{\n\tbtrfsic_dump_tree_sub(state, state->latest_superblock, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfsic_dump_database",
          "args": [
            "state"
          ],
          "line": 3157
        },
        "resolved": true,
        "details": {
          "function_name": "btrfsic_dump_database",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/check-integrity.c",
          "lines": "1721-1782",
          "snippet": "static void btrfsic_dump_database(struct btrfsic_state *state)\n{\n\tstruct list_head *elem_all;\n\n\tBUG_ON(NULL == state);\n\n\tprintk(KERN_INFO \"all_blocks_list:\\n\");\n\tlist_for_each(elem_all, &state->all_blocks_list) {\n\t\tconst struct btrfsic_block *const b_all =\n\t\t    list_entry(elem_all, struct btrfsic_block,\n\t\t\t       all_blocks_node);\n\t\tstruct list_head *elem_ref_to;\n\t\tstruct list_head *elem_ref_from;\n\n\t\tprintk(KERN_INFO \"%c-block @%llu (%s/%llu/%d)\\n\",\n\t\t       btrfsic_get_block_type(state, b_all),\n\t\t       b_all->logical_bytenr, b_all->dev_state->name,\n\t\t       b_all->dev_bytenr, b_all->mirror_num);\n\n\t\tlist_for_each(elem_ref_to, &b_all->ref_to_list) {\n\t\t\tconst struct btrfsic_block_link *const l =\n\t\t\t    list_entry(elem_ref_to,\n\t\t\t\t       struct btrfsic_block_link,\n\t\t\t\t       node_ref_to);\n\n\t\t\tprintk(KERN_INFO \" %c @%llu (%s/%llu/%d)\"\n\t\t\t       \" refers %u* to\"\n\t\t\t       \" %c @%llu (%s/%llu/%d)\\n\",\n\t\t\t       btrfsic_get_block_type(state, b_all),\n\t\t\t       b_all->logical_bytenr, b_all->dev_state->name,\n\t\t\t       b_all->dev_bytenr, b_all->mirror_num,\n\t\t\t       l->ref_cnt,\n\t\t\t       btrfsic_get_block_type(state, l->block_ref_to),\n\t\t\t       l->block_ref_to->logical_bytenr,\n\t\t\t       l->block_ref_to->dev_state->name,\n\t\t\t       l->block_ref_to->dev_bytenr,\n\t\t\t       l->block_ref_to->mirror_num);\n\t\t}\n\n\t\tlist_for_each(elem_ref_from, &b_all->ref_from_list) {\n\t\t\tconst struct btrfsic_block_link *const l =\n\t\t\t    list_entry(elem_ref_from,\n\t\t\t\t       struct btrfsic_block_link,\n\t\t\t\t       node_ref_from);\n\n\t\t\tprintk(KERN_INFO \" %c @%llu (%s/%llu/%d)\"\n\t\t\t       \" is ref %u* from\"\n\t\t\t       \" %c @%llu (%s/%llu/%d)\\n\",\n\t\t\t       btrfsic_get_block_type(state, b_all),\n\t\t\t       b_all->logical_bytenr, b_all->dev_state->name,\n\t\t\t       b_all->dev_bytenr, b_all->mirror_num,\n\t\t\t       l->ref_cnt,\n\t\t\t       btrfsic_get_block_type(state, l->block_ref_from),\n\t\t\t       l->block_ref_from->logical_bytenr,\n\t\t\t       l->block_ref_from->dev_state->name,\n\t\t\t       l->block_ref_from->dev_bytenr,\n\t\t\t       l->block_ref_from->mirror_num);\n\t\t}\n\n\t\tprintk(KERN_INFO \"\\n\");\n\t}\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"extent_io.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/genhd.h>",
            "#include <linux/mutex.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void btrfsic_block_link_init(struct btrfsic_block_link *n);",
            "static void btrfsic_block_link_free(struct btrfsic_block_link *n);",
            "static void btrfsic_block_link_hashtable_remove(struct btrfsic_block_link *l);",
            "static int btrfsic_map_block(struct btrfsic_state *state, u64 bytenr, u32 len,\n\t\t\t     struct btrfsic_block_data_ctx *block_ctx_out,\n\t\t\t     int mirror_num);",
            "static void btrfsic_dump_database(struct btrfsic_state *state);",
            "static void btrfsic_print_add_link(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block_link *l);",
            "static void btrfsic_print_rem_link(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block_link *l);",
            "static char btrfsic_get_block_type(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block *block);",
            "static void btrfsic_dump_tree(const struct btrfsic_state *state);",
            "static void btrfsic_cmp_log_and_dev_bytenr(struct btrfsic_state *state,\n\t\t\t\t\t   u64 bytenr,\n\t\t\t\t\t   struct btrfsic_dev_state *dev_state,\n\t\t\t\t\t   u64 dev_bytenr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"extent_io.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n#include <linux/blkdev.h>\n#include <linux/genhd.h>\n#include <linux/mutex.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic void btrfsic_block_link_init(struct btrfsic_block_link *n);\nstatic void btrfsic_block_link_free(struct btrfsic_block_link *n);\nstatic void btrfsic_block_link_hashtable_remove(struct btrfsic_block_link *l);\nstatic int btrfsic_map_block(struct btrfsic_state *state, u64 bytenr, u32 len,\n\t\t\t     struct btrfsic_block_data_ctx *block_ctx_out,\n\t\t\t     int mirror_num);\nstatic void btrfsic_dump_database(struct btrfsic_state *state);\nstatic void btrfsic_print_add_link(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block_link *l);\nstatic void btrfsic_print_rem_link(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block_link *l);\nstatic char btrfsic_get_block_type(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block *block);\nstatic void btrfsic_dump_tree(const struct btrfsic_state *state);\nstatic void btrfsic_cmp_log_and_dev_bytenr(struct btrfsic_state *state,\n\t\t\t\t\t   u64 bytenr,\n\t\t\t\t\t   struct btrfsic_dev_state *dev_state,\n\t\t\t\t\t   u64 dev_bytenr);\n\nstatic void btrfsic_dump_database(struct btrfsic_state *state)\n{\n\tstruct list_head *elem_all;\n\n\tBUG_ON(NULL == state);\n\n\tprintk(KERN_INFO \"all_blocks_list:\\n\");\n\tlist_for_each(elem_all, &state->all_blocks_list) {\n\t\tconst struct btrfsic_block *const b_all =\n\t\t    list_entry(elem_all, struct btrfsic_block,\n\t\t\t       all_blocks_node);\n\t\tstruct list_head *elem_ref_to;\n\t\tstruct list_head *elem_ref_from;\n\n\t\tprintk(KERN_INFO \"%c-block @%llu (%s/%llu/%d)\\n\",\n\t\t       btrfsic_get_block_type(state, b_all),\n\t\t       b_all->logical_bytenr, b_all->dev_state->name,\n\t\t       b_all->dev_bytenr, b_all->mirror_num);\n\n\t\tlist_for_each(elem_ref_to, &b_all->ref_to_list) {\n\t\t\tconst struct btrfsic_block_link *const l =\n\t\t\t    list_entry(elem_ref_to,\n\t\t\t\t       struct btrfsic_block_link,\n\t\t\t\t       node_ref_to);\n\n\t\t\tprintk(KERN_INFO \" %c @%llu (%s/%llu/%d)\"\n\t\t\t       \" refers %u* to\"\n\t\t\t       \" %c @%llu (%s/%llu/%d)\\n\",\n\t\t\t       btrfsic_get_block_type(state, b_all),\n\t\t\t       b_all->logical_bytenr, b_all->dev_state->name,\n\t\t\t       b_all->dev_bytenr, b_all->mirror_num,\n\t\t\t       l->ref_cnt,\n\t\t\t       btrfsic_get_block_type(state, l->block_ref_to),\n\t\t\t       l->block_ref_to->logical_bytenr,\n\t\t\t       l->block_ref_to->dev_state->name,\n\t\t\t       l->block_ref_to->dev_bytenr,\n\t\t\t       l->block_ref_to->mirror_num);\n\t\t}\n\n\t\tlist_for_each(elem_ref_from, &b_all->ref_from_list) {\n\t\t\tconst struct btrfsic_block_link *const l =\n\t\t\t    list_entry(elem_ref_from,\n\t\t\t\t       struct btrfsic_block_link,\n\t\t\t\t       node_ref_from);\n\n\t\t\tprintk(KERN_INFO \" %c @%llu (%s/%llu/%d)\"\n\t\t\t       \" is ref %u* from\"\n\t\t\t       \" %c @%llu (%s/%llu/%d)\\n\",\n\t\t\t       btrfsic_get_block_type(state, b_all),\n\t\t\t       b_all->logical_bytenr, b_all->dev_state->name,\n\t\t\t       b_all->dev_bytenr, b_all->mirror_num,\n\t\t\t       l->ref_cnt,\n\t\t\t       btrfsic_get_block_type(state, l->block_ref_from),\n\t\t\t       l->block_ref_from->logical_bytenr,\n\t\t\t       l->block_ref_from->dev_state->name,\n\t\t\t       l->block_ref_from->dev_bytenr,\n\t\t\t       l->block_ref_from->mirror_num);\n\t\t}\n\n\t\tprintk(KERN_INFO \"\\n\");\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfsic_unmount",
          "args": [
            "root",
            "fs_devices"
          ],
          "line": 3152
        },
        "resolved": true,
        "details": {
          "function_name": "btrfsic_unmount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/check-integrity.c",
          "lines": "3165-3248",
          "snippet": "void btrfsic_unmount(struct btrfs_root *root,\n\t\t     struct btrfs_fs_devices *fs_devices)\n{\n\tstruct list_head *elem_all;\n\tstruct list_head *tmp_all;\n\tstruct btrfsic_state *state;\n\tstruct list_head *dev_head = &fs_devices->devices;\n\tstruct btrfs_device *device;\n\n\tif (!btrfsic_is_initialized)\n\t\treturn;\n\n\tmutex_lock(&btrfsic_mutex);\n\n\tstate = NULL;\n\tlist_for_each_entry(device, dev_head, dev_list) {\n\t\tstruct btrfsic_dev_state *ds;\n\n\t\tif (!device->bdev || !device->name)\n\t\t\tcontinue;\n\n\t\tds = btrfsic_dev_state_hashtable_lookup(\n\t\t\t\tdevice->bdev,\n\t\t\t\t&btrfsic_dev_state_hashtable);\n\t\tif (NULL != ds) {\n\t\t\tstate = ds->state;\n\t\t\tbtrfsic_dev_state_hashtable_remove(ds);\n\t\t\tbtrfsic_dev_state_free(ds);\n\t\t}\n\t}\n\n\tif (NULL == state) {\n\t\tprintk(KERN_INFO\n\t\t       \"btrfsic: error, cannot find state information\"\n\t\t       \" on umount!\\n\");\n\t\tmutex_unlock(&btrfsic_mutex);\n\t\treturn;\n\t}\n\n\t/*\n\t * Don't care about keeping the lists' state up to date,\n\t * just free all memory that was allocated dynamically.\n\t * Free the blocks and the block_links.\n\t */\n\tlist_for_each_safe(elem_all, tmp_all, &state->all_blocks_list) {\n\t\tstruct btrfsic_block *const b_all =\n\t\t    list_entry(elem_all, struct btrfsic_block,\n\t\t\t       all_blocks_node);\n\t\tstruct list_head *elem_ref_to;\n\t\tstruct list_head *tmp_ref_to;\n\n\t\tlist_for_each_safe(elem_ref_to, tmp_ref_to,\n\t\t\t\t   &b_all->ref_to_list) {\n\t\t\tstruct btrfsic_block_link *const l =\n\t\t\t    list_entry(elem_ref_to,\n\t\t\t\t       struct btrfsic_block_link,\n\t\t\t\t       node_ref_to);\n\n\t\t\tif (state->print_mask & BTRFSIC_PRINT_MASK_VERBOSE)\n\t\t\t\tbtrfsic_print_rem_link(state, l);\n\n\t\t\tl->ref_cnt--;\n\t\t\tif (0 == l->ref_cnt)\n\t\t\t\tbtrfsic_block_link_free(l);\n\t\t}\n\n\t\tif (b_all->is_iodone || b_all->never_written)\n\t\t\tbtrfsic_block_free(b_all);\n\t\telse\n\t\t\tprintk(KERN_INFO \"btrfs: attempt to free %c-block\"\n\t\t\t       \" @%llu (%s/%llu/%d) on umount which is\"\n\t\t\t       \" not yet iodone!\\n\",\n\t\t\t       btrfsic_get_block_type(state, b_all),\n\t\t\t       b_all->logical_bytenr, b_all->dev_state->name,\n\t\t\t       b_all->dev_bytenr, b_all->mirror_num);\n\t}\n\n\tmutex_unlock(&btrfsic_mutex);\n\n\tif (is_vmalloc_addr(state))\n\t\tvfree(state);\n\telse\n\t\tkfree(state);\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"extent_io.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/genhd.h>",
            "#include <linux/mutex.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define BTRFSIC_PRINT_MASK_VERBOSE\t\t\t\t0x00000040"
          ],
          "globals_used": [
            "static void btrfsic_block_link_init(struct btrfsic_block_link *n);",
            "static void btrfsic_block_link_free(struct btrfsic_block_link *n);",
            "static void btrfsic_dev_state_init(struct btrfsic_dev_state *ds);",
            "static void btrfsic_dev_state_free(struct btrfsic_dev_state *ds);",
            "static void btrfsic_block_link_hashtable_remove(struct btrfsic_block_link *l);",
            "static void btrfsic_dev_state_hashtable_remove(struct btrfsic_dev_state *ds);",
            "static int btrfsic_process_superblock(struct btrfsic_state *state,\n\t\t\t\t      struct btrfs_fs_devices *fs_devices);",
            "static int btrfsic_map_block(struct btrfsic_state *state, u64 bytenr, u32 len,\n\t\t\t     struct btrfsic_block_data_ctx *block_ctx_out,\n\t\t\t     int mirror_num);",
            "static void btrfsic_dump_database(struct btrfsic_state *state);",
            "static void btrfsic_print_add_link(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block_link *l);",
            "static void btrfsic_print_rem_link(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block_link *l);",
            "static char btrfsic_get_block_type(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block *block);",
            "static void btrfsic_dump_tree(const struct btrfsic_state *state);",
            "static struct btrfsic_dev_state *btrfsic_dev_state_lookup(\n\t\tstruct block_device *bdev);",
            "static void btrfsic_cmp_log_and_dev_bytenr(struct btrfsic_state *state,\n\t\t\t\t\t   u64 bytenr,\n\t\t\t\t\t   struct btrfsic_dev_state *dev_state,\n\t\t\t\t\t   u64 dev_bytenr);",
            "static struct mutex btrfsic_mutex;",
            "static int btrfsic_is_initialized;",
            "static struct btrfsic_dev_state_hashtable btrfsic_dev_state_hashtable;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"extent_io.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n#include <linux/blkdev.h>\n#include <linux/genhd.h>\n#include <linux/mutex.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\n#define BTRFSIC_PRINT_MASK_VERBOSE\t\t\t\t0x00000040\n\nstatic void btrfsic_block_link_init(struct btrfsic_block_link *n);\nstatic void btrfsic_block_link_free(struct btrfsic_block_link *n);\nstatic void btrfsic_dev_state_init(struct btrfsic_dev_state *ds);\nstatic void btrfsic_dev_state_free(struct btrfsic_dev_state *ds);\nstatic void btrfsic_block_link_hashtable_remove(struct btrfsic_block_link *l);\nstatic void btrfsic_dev_state_hashtable_remove(struct btrfsic_dev_state *ds);\nstatic int btrfsic_process_superblock(struct btrfsic_state *state,\n\t\t\t\t      struct btrfs_fs_devices *fs_devices);\nstatic int btrfsic_map_block(struct btrfsic_state *state, u64 bytenr, u32 len,\n\t\t\t     struct btrfsic_block_data_ctx *block_ctx_out,\n\t\t\t     int mirror_num);\nstatic void btrfsic_dump_database(struct btrfsic_state *state);\nstatic void btrfsic_print_add_link(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block_link *l);\nstatic void btrfsic_print_rem_link(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block_link *l);\nstatic char btrfsic_get_block_type(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block *block);\nstatic void btrfsic_dump_tree(const struct btrfsic_state *state);\nstatic struct btrfsic_dev_state *btrfsic_dev_state_lookup(\n\t\tstruct block_device *bdev);\nstatic void btrfsic_cmp_log_and_dev_bytenr(struct btrfsic_state *state,\n\t\t\t\t\t   u64 bytenr,\n\t\t\t\t\t   struct btrfsic_dev_state *dev_state,\n\t\t\t\t\t   u64 dev_bytenr);\nstatic struct mutex btrfsic_mutex;\nstatic int btrfsic_is_initialized;\nstatic struct btrfsic_dev_state_hashtable btrfsic_dev_state_hashtable;\n\nvoid btrfsic_unmount(struct btrfs_root *root,\n\t\t     struct btrfs_fs_devices *fs_devices)\n{\n\tstruct list_head *elem_all;\n\tstruct list_head *tmp_all;\n\tstruct btrfsic_state *state;\n\tstruct list_head *dev_head = &fs_devices->devices;\n\tstruct btrfs_device *device;\n\n\tif (!btrfsic_is_initialized)\n\t\treturn;\n\n\tmutex_lock(&btrfsic_mutex);\n\n\tstate = NULL;\n\tlist_for_each_entry(device, dev_head, dev_list) {\n\t\tstruct btrfsic_dev_state *ds;\n\n\t\tif (!device->bdev || !device->name)\n\t\t\tcontinue;\n\n\t\tds = btrfsic_dev_state_hashtable_lookup(\n\t\t\t\tdevice->bdev,\n\t\t\t\t&btrfsic_dev_state_hashtable);\n\t\tif (NULL != ds) {\n\t\t\tstate = ds->state;\n\t\t\tbtrfsic_dev_state_hashtable_remove(ds);\n\t\t\tbtrfsic_dev_state_free(ds);\n\t\t}\n\t}\n\n\tif (NULL == state) {\n\t\tprintk(KERN_INFO\n\t\t       \"btrfsic: error, cannot find state information\"\n\t\t       \" on umount!\\n\");\n\t\tmutex_unlock(&btrfsic_mutex);\n\t\treturn;\n\t}\n\n\t/*\n\t * Don't care about keeping the lists' state up to date,\n\t * just free all memory that was allocated dynamically.\n\t * Free the blocks and the block_links.\n\t */\n\tlist_for_each_safe(elem_all, tmp_all, &state->all_blocks_list) {\n\t\tstruct btrfsic_block *const b_all =\n\t\t    list_entry(elem_all, struct btrfsic_block,\n\t\t\t       all_blocks_node);\n\t\tstruct list_head *elem_ref_to;\n\t\tstruct list_head *tmp_ref_to;\n\n\t\tlist_for_each_safe(elem_ref_to, tmp_ref_to,\n\t\t\t\t   &b_all->ref_to_list) {\n\t\t\tstruct btrfsic_block_link *const l =\n\t\t\t    list_entry(elem_ref_to,\n\t\t\t\t       struct btrfsic_block_link,\n\t\t\t\t       node_ref_to);\n\n\t\t\tif (state->print_mask & BTRFSIC_PRINT_MASK_VERBOSE)\n\t\t\t\tbtrfsic_print_rem_link(state, l);\n\n\t\t\tl->ref_cnt--;\n\t\t\tif (0 == l->ref_cnt)\n\t\t\t\tbtrfsic_block_link_free(l);\n\t\t}\n\n\t\tif (b_all->is_iodone || b_all->never_written)\n\t\t\tbtrfsic_block_free(b_all);\n\t\telse\n\t\t\tprintk(KERN_INFO \"btrfs: attempt to free %c-block\"\n\t\t\t       \" @%llu (%s/%llu/%d) on umount which is\"\n\t\t\t       \" not yet iodone!\\n\",\n\t\t\t       btrfsic_get_block_type(state, b_all),\n\t\t\t       b_all->logical_bytenr, b_all->dev_state->name,\n\t\t\t       b_all->dev_bytenr, b_all->mirror_num);\n\t}\n\n\tmutex_unlock(&btrfsic_mutex);\n\n\tif (is_vmalloc_addr(state))\n\t\tvfree(state);\n\telse\n\t\tkfree(state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&btrfsic_mutex"
          ],
          "line": 3151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfsic_process_superblock",
          "args": [
            "state",
            "fs_devices"
          ],
          "line": 3149
        },
        "resolved": true,
        "details": {
          "function_name": "btrfsic_process_superblock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/check-integrity.c",
          "lines": "656-789",
          "snippet": "static int btrfsic_process_superblock(struct btrfsic_state *state,\n\t\t\t\t      struct btrfs_fs_devices *fs_devices)\n{\n\tint ret = 0;\n\tstruct btrfs_super_block *selected_super;\n\tstruct list_head *dev_head = &fs_devices->devices;\n\tstruct btrfs_device *device;\n\tstruct btrfsic_dev_state *selected_dev_state = NULL;\n\tint pass;\n\n\tBUG_ON(NULL == state);\n\tselected_super = kzalloc(sizeof(*selected_super), GFP_NOFS);\n\tif (NULL == selected_super) {\n\t\tprintk(KERN_INFO \"btrfsic: error, kmalloc failed!\\n\");\n\t\treturn -1;\n\t}\n\n\tlist_for_each_entry(device, dev_head, dev_list) {\n\t\tint i;\n\t\tstruct btrfsic_dev_state *dev_state;\n\n\t\tif (!device->bdev || !device->name)\n\t\t\tcontinue;\n\n\t\tdev_state = btrfsic_dev_state_lookup(device->bdev);\n\t\tBUG_ON(NULL == dev_state);\n\t\tfor (i = 0; i < BTRFS_SUPER_MIRROR_MAX; i++) {\n\t\t\tret = btrfsic_process_superblock_dev_mirror(\n\t\t\t\t\tstate, dev_state, device, i,\n\t\t\t\t\t&selected_dev_state, selected_super);\n\t\t\tif (0 != ret && 0 == i) {\n\t\t\t\tkfree(selected_super);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (NULL == state->latest_superblock) {\n\t\tprintk(KERN_INFO \"btrfsic: no superblock found!\\n\");\n\t\tkfree(selected_super);\n\t\treturn -1;\n\t}\n\n\tstate->csum_size = btrfs_super_csum_size(selected_super);\n\n\tfor (pass = 0; pass < 3; pass++) {\n\t\tint num_copies;\n\t\tint mirror_num;\n\t\tu64 next_bytenr;\n\n\t\tswitch (pass) {\n\t\tcase 0:\n\t\t\tnext_bytenr = btrfs_super_root(selected_super);\n\t\t\tif (state->print_mask &\n\t\t\t    BTRFSIC_PRINT_MASK_ROOT_CHUNK_LOG_TREE_LOCATION)\n\t\t\t\tprintk(KERN_INFO \"root@%llu\\n\", next_bytenr);\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tnext_bytenr = btrfs_super_chunk_root(selected_super);\n\t\t\tif (state->print_mask &\n\t\t\t    BTRFSIC_PRINT_MASK_ROOT_CHUNK_LOG_TREE_LOCATION)\n\t\t\t\tprintk(KERN_INFO \"chunk@%llu\\n\", next_bytenr);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tnext_bytenr = btrfs_super_log_root(selected_super);\n\t\t\tif (0 == next_bytenr)\n\t\t\t\tcontinue;\n\t\t\tif (state->print_mask &\n\t\t\t    BTRFSIC_PRINT_MASK_ROOT_CHUNK_LOG_TREE_LOCATION)\n\t\t\t\tprintk(KERN_INFO \"log@%llu\\n\", next_bytenr);\n\t\t\tbreak;\n\t\t}\n\n\t\tnum_copies =\n\t\t    btrfs_num_copies(state->root->fs_info,\n\t\t\t\t     next_bytenr, state->metablock_size);\n\t\tif (state->print_mask & BTRFSIC_PRINT_MASK_NUM_COPIES)\n\t\t\tprintk(KERN_INFO \"num_copies(log_bytenr=%llu) = %d\\n\",\n\t\t\t       next_bytenr, num_copies);\n\n\t\tfor (mirror_num = 1; mirror_num <= num_copies; mirror_num++) {\n\t\t\tstruct btrfsic_block *next_block;\n\t\t\tstruct btrfsic_block_data_ctx tmp_next_block_ctx;\n\t\t\tstruct btrfsic_block_link *l;\n\n\t\t\tret = btrfsic_map_block(state, next_bytenr,\n\t\t\t\t\t\tstate->metablock_size,\n\t\t\t\t\t\t&tmp_next_block_ctx,\n\t\t\t\t\t\tmirror_num);\n\t\t\tif (ret) {\n\t\t\t\tprintk(KERN_INFO \"btrfsic:\"\n\t\t\t\t       \" btrfsic_map_block(root @%llu,\"\n\t\t\t\t       \" mirror %d) failed!\\n\",\n\t\t\t\t       next_bytenr, mirror_num);\n\t\t\t\tkfree(selected_super);\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tnext_block = btrfsic_block_hashtable_lookup(\n\t\t\t\t\ttmp_next_block_ctx.dev->bdev,\n\t\t\t\t\ttmp_next_block_ctx.dev_bytenr,\n\t\t\t\t\t&state->block_hashtable);\n\t\t\tBUG_ON(NULL == next_block);\n\n\t\t\tl = btrfsic_block_link_hashtable_lookup(\n\t\t\t\t\ttmp_next_block_ctx.dev->bdev,\n\t\t\t\t\ttmp_next_block_ctx.dev_bytenr,\n\t\t\t\t\tstate->latest_superblock->dev_state->\n\t\t\t\t\tbdev,\n\t\t\t\t\tstate->latest_superblock->dev_bytenr,\n\t\t\t\t\t&state->block_link_hashtable);\n\t\t\tBUG_ON(NULL == l);\n\n\t\t\tret = btrfsic_read_block(state, &tmp_next_block_ctx);\n\t\t\tif (ret < (int)PAGE_CACHE_SIZE) {\n\t\t\t\tprintk(KERN_INFO\n\t\t\t\t       \"btrfsic: read @logical %llu failed!\\n\",\n\t\t\t\t       tmp_next_block_ctx.start);\n\t\t\t\tbtrfsic_release_block_ctx(&tmp_next_block_ctx);\n\t\t\t\tkfree(selected_super);\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tret = btrfsic_process_metablock(state,\n\t\t\t\t\t\t\tnext_block,\n\t\t\t\t\t\t\t&tmp_next_block_ctx,\n\t\t\t\t\t\t\tBTRFS_MAX_LEVEL + 3, 1);\n\t\t\tbtrfsic_release_block_ctx(&tmp_next_block_ctx);\n\t\t}\n\t}\n\n\tkfree(selected_super);\n\treturn ret;\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"extent_io.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/genhd.h>",
            "#include <linux/mutex.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define BTRFSIC_PRINT_MASK_NUM_COPIES\t\t\t\t0x00000800",
            "#define BTRFSIC_PRINT_MASK_ROOT_CHUNK_LOG_TREE_LOCATION\t\t0x00000002"
          ],
          "globals_used": [
            "static void btrfsic_block_link_init(struct btrfsic_block_link *n);",
            "static void btrfsic_block_link_free(struct btrfsic_block_link *n);",
            "static void btrfsic_block_link_hashtable_remove(struct btrfsic_block_link *l);",
            "static int btrfsic_process_superblock(struct btrfsic_state *state,\n\t\t\t\t      struct btrfs_fs_devices *fs_devices);",
            "static int btrfsic_map_block(struct btrfsic_state *state, u64 bytenr, u32 len,\n\t\t\t     struct btrfsic_block_data_ctx *block_ctx_out,\n\t\t\t     int mirror_num);",
            "static void btrfsic_dump_database(struct btrfsic_state *state);",
            "static void btrfsic_print_add_link(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block_link *l);",
            "static void btrfsic_print_rem_link(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block_link *l);",
            "static void btrfsic_dump_tree(const struct btrfsic_state *state);",
            "static int btrfsic_process_superblock_dev_mirror(\n\t\tstruct btrfsic_state *state,\n\t\tstruct btrfsic_dev_state *dev_state,\n\t\tstruct btrfs_device *device,\n\t\tint superblock_mirror_num,\n\t\tstruct btrfsic_dev_state **selected_dev_state,\n\t\tstruct btrfs_super_block *selected_super);",
            "static struct btrfsic_dev_state *btrfsic_dev_state_lookup(\n\t\tstruct block_device *bdev);",
            "static void btrfsic_cmp_log_and_dev_bytenr(struct btrfsic_state *state,\n\t\t\t\t\t   u64 bytenr,\n\t\t\t\t\t   struct btrfsic_dev_state *dev_state,\n\t\t\t\t\t   u64 dev_bytenr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"extent_io.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n#include <linux/blkdev.h>\n#include <linux/genhd.h>\n#include <linux/mutex.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\n#define BTRFSIC_PRINT_MASK_NUM_COPIES\t\t\t\t0x00000800\n#define BTRFSIC_PRINT_MASK_ROOT_CHUNK_LOG_TREE_LOCATION\t\t0x00000002\n\nstatic void btrfsic_block_link_init(struct btrfsic_block_link *n);\nstatic void btrfsic_block_link_free(struct btrfsic_block_link *n);\nstatic void btrfsic_block_link_hashtable_remove(struct btrfsic_block_link *l);\nstatic int btrfsic_process_superblock(struct btrfsic_state *state,\n\t\t\t\t      struct btrfs_fs_devices *fs_devices);\nstatic int btrfsic_map_block(struct btrfsic_state *state, u64 bytenr, u32 len,\n\t\t\t     struct btrfsic_block_data_ctx *block_ctx_out,\n\t\t\t     int mirror_num);\nstatic void btrfsic_dump_database(struct btrfsic_state *state);\nstatic void btrfsic_print_add_link(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block_link *l);\nstatic void btrfsic_print_rem_link(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block_link *l);\nstatic void btrfsic_dump_tree(const struct btrfsic_state *state);\nstatic int btrfsic_process_superblock_dev_mirror(\n\t\tstruct btrfsic_state *state,\n\t\tstruct btrfsic_dev_state *dev_state,\n\t\tstruct btrfs_device *device,\n\t\tint superblock_mirror_num,\n\t\tstruct btrfsic_dev_state **selected_dev_state,\n\t\tstruct btrfs_super_block *selected_super);\nstatic struct btrfsic_dev_state *btrfsic_dev_state_lookup(\n\t\tstruct block_device *bdev);\nstatic void btrfsic_cmp_log_and_dev_bytenr(struct btrfsic_state *state,\n\t\t\t\t\t   u64 bytenr,\n\t\t\t\t\t   struct btrfsic_dev_state *dev_state,\n\t\t\t\t\t   u64 dev_bytenr);\n\nstatic int btrfsic_process_superblock(struct btrfsic_state *state,\n\t\t\t\t      struct btrfs_fs_devices *fs_devices)\n{\n\tint ret = 0;\n\tstruct btrfs_super_block *selected_super;\n\tstruct list_head *dev_head = &fs_devices->devices;\n\tstruct btrfs_device *device;\n\tstruct btrfsic_dev_state *selected_dev_state = NULL;\n\tint pass;\n\n\tBUG_ON(NULL == state);\n\tselected_super = kzalloc(sizeof(*selected_super), GFP_NOFS);\n\tif (NULL == selected_super) {\n\t\tprintk(KERN_INFO \"btrfsic: error, kmalloc failed!\\n\");\n\t\treturn -1;\n\t}\n\n\tlist_for_each_entry(device, dev_head, dev_list) {\n\t\tint i;\n\t\tstruct btrfsic_dev_state *dev_state;\n\n\t\tif (!device->bdev || !device->name)\n\t\t\tcontinue;\n\n\t\tdev_state = btrfsic_dev_state_lookup(device->bdev);\n\t\tBUG_ON(NULL == dev_state);\n\t\tfor (i = 0; i < BTRFS_SUPER_MIRROR_MAX; i++) {\n\t\t\tret = btrfsic_process_superblock_dev_mirror(\n\t\t\t\t\tstate, dev_state, device, i,\n\t\t\t\t\t&selected_dev_state, selected_super);\n\t\t\tif (0 != ret && 0 == i) {\n\t\t\t\tkfree(selected_super);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (NULL == state->latest_superblock) {\n\t\tprintk(KERN_INFO \"btrfsic: no superblock found!\\n\");\n\t\tkfree(selected_super);\n\t\treturn -1;\n\t}\n\n\tstate->csum_size = btrfs_super_csum_size(selected_super);\n\n\tfor (pass = 0; pass < 3; pass++) {\n\t\tint num_copies;\n\t\tint mirror_num;\n\t\tu64 next_bytenr;\n\n\t\tswitch (pass) {\n\t\tcase 0:\n\t\t\tnext_bytenr = btrfs_super_root(selected_super);\n\t\t\tif (state->print_mask &\n\t\t\t    BTRFSIC_PRINT_MASK_ROOT_CHUNK_LOG_TREE_LOCATION)\n\t\t\t\tprintk(KERN_INFO \"root@%llu\\n\", next_bytenr);\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tnext_bytenr = btrfs_super_chunk_root(selected_super);\n\t\t\tif (state->print_mask &\n\t\t\t    BTRFSIC_PRINT_MASK_ROOT_CHUNK_LOG_TREE_LOCATION)\n\t\t\t\tprintk(KERN_INFO \"chunk@%llu\\n\", next_bytenr);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tnext_bytenr = btrfs_super_log_root(selected_super);\n\t\t\tif (0 == next_bytenr)\n\t\t\t\tcontinue;\n\t\t\tif (state->print_mask &\n\t\t\t    BTRFSIC_PRINT_MASK_ROOT_CHUNK_LOG_TREE_LOCATION)\n\t\t\t\tprintk(KERN_INFO \"log@%llu\\n\", next_bytenr);\n\t\t\tbreak;\n\t\t}\n\n\t\tnum_copies =\n\t\t    btrfs_num_copies(state->root->fs_info,\n\t\t\t\t     next_bytenr, state->metablock_size);\n\t\tif (state->print_mask & BTRFSIC_PRINT_MASK_NUM_COPIES)\n\t\t\tprintk(KERN_INFO \"num_copies(log_bytenr=%llu) = %d\\n\",\n\t\t\t       next_bytenr, num_copies);\n\n\t\tfor (mirror_num = 1; mirror_num <= num_copies; mirror_num++) {\n\t\t\tstruct btrfsic_block *next_block;\n\t\t\tstruct btrfsic_block_data_ctx tmp_next_block_ctx;\n\t\t\tstruct btrfsic_block_link *l;\n\n\t\t\tret = btrfsic_map_block(state, next_bytenr,\n\t\t\t\t\t\tstate->metablock_size,\n\t\t\t\t\t\t&tmp_next_block_ctx,\n\t\t\t\t\t\tmirror_num);\n\t\t\tif (ret) {\n\t\t\t\tprintk(KERN_INFO \"btrfsic:\"\n\t\t\t\t       \" btrfsic_map_block(root @%llu,\"\n\t\t\t\t       \" mirror %d) failed!\\n\",\n\t\t\t\t       next_bytenr, mirror_num);\n\t\t\t\tkfree(selected_super);\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tnext_block = btrfsic_block_hashtable_lookup(\n\t\t\t\t\ttmp_next_block_ctx.dev->bdev,\n\t\t\t\t\ttmp_next_block_ctx.dev_bytenr,\n\t\t\t\t\t&state->block_hashtable);\n\t\t\tBUG_ON(NULL == next_block);\n\n\t\t\tl = btrfsic_block_link_hashtable_lookup(\n\t\t\t\t\ttmp_next_block_ctx.dev->bdev,\n\t\t\t\t\ttmp_next_block_ctx.dev_bytenr,\n\t\t\t\t\tstate->latest_superblock->dev_state->\n\t\t\t\t\tbdev,\n\t\t\t\t\tstate->latest_superblock->dev_bytenr,\n\t\t\t\t\t&state->block_link_hashtable);\n\t\t\tBUG_ON(NULL == l);\n\n\t\t\tret = btrfsic_read_block(state, &tmp_next_block_ctx);\n\t\t\tif (ret < (int)PAGE_CACHE_SIZE) {\n\t\t\t\tprintk(KERN_INFO\n\t\t\t\t       \"btrfsic: read @logical %llu failed!\\n\",\n\t\t\t\t       tmp_next_block_ctx.start);\n\t\t\t\tbtrfsic_release_block_ctx(&tmp_next_block_ctx);\n\t\t\t\tkfree(selected_super);\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tret = btrfsic_process_metablock(state,\n\t\t\t\t\t\t\tnext_block,\n\t\t\t\t\t\t\t&tmp_next_block_ctx,\n\t\t\t\t\t\t\tBTRFS_MAX_LEVEL + 3, 1);\n\t\t\tbtrfsic_release_block_ctx(&tmp_next_block_ctx);\n\t\t}\n\t}\n\n\tkfree(selected_super);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfsic_dev_state_hashtable_add",
          "args": [
            "ds",
            "&btrfsic_dev_state_hashtable"
          ],
          "line": 3145
        },
        "resolved": true,
        "details": {
          "function_name": "btrfsic_dev_state_hashtable_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/check-integrity.c",
          "lines": "619-628",
          "snippet": "static void btrfsic_dev_state_hashtable_add(\n\t\tstruct btrfsic_dev_state *ds,\n\t\tstruct btrfsic_dev_state_hashtable *h)\n{\n\tconst unsigned int hashval =\n\t    (((unsigned int)((uintptr_t)ds->bdev)) &\n\t     (BTRFSIC_DEV2STATE_HASHTABLE_SIZE - 1));\n\n\tlist_add(&ds->collision_resolving_node, h->table + hashval);\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"extent_io.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/genhd.h>",
            "#include <linux/mutex.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define BTRFSIC_DEV2STATE_HASHTABLE_SIZE 0x100"
          ],
          "globals_used": [
            "static void btrfsic_dev_state_init(struct btrfsic_dev_state *ds);",
            "static void btrfsic_dev_state_free(struct btrfsic_dev_state *ds);",
            "static void btrfsic_block_hashtable_init(struct btrfsic_block_hashtable *h);",
            "static void btrfsic_block_hashtable_add(struct btrfsic_block *b,\n\t\t\t\t\tstruct btrfsic_block_hashtable *h);",
            "static struct btrfsic_block *btrfsic_block_hashtable_lookup(\n\t\tstruct block_device *bdev,\n\t\tu64 dev_bytenr,\n\t\tstruct btrfsic_block_hashtable *h);",
            "static void btrfsic_block_link_hashtable_init(\n\t\tstruct btrfsic_block_link_hashtable *h);",
            "static void btrfsic_block_link_hashtable_add(\n\t\tstruct btrfsic_block_link *l,\n\t\tstruct btrfsic_block_link_hashtable *h);",
            "static struct btrfsic_block_link *btrfsic_block_link_hashtable_lookup(\n\t\tstruct block_device *bdev_ref_to,\n\t\tu64 dev_bytenr_ref_to,\n\t\tstruct block_device *bdev_ref_from,\n\t\tu64 dev_bytenr_ref_from,\n\t\tstruct btrfsic_block_link_hashtable *h);",
            "static void btrfsic_dev_state_hashtable_init(\n\t\tstruct btrfsic_dev_state_hashtable *h);",
            "static void btrfsic_dev_state_hashtable_add(\n\t\tstruct btrfsic_dev_state *ds,\n\t\tstruct btrfsic_dev_state_hashtable *h);",
            "static void btrfsic_dev_state_hashtable_remove(struct btrfsic_dev_state *ds);",
            "static struct btrfsic_dev_state *btrfsic_dev_state_hashtable_lookup(\n\t\tstruct block_device *bdev,\n\t\tstruct btrfsic_dev_state_hashtable *h);",
            "static struct btrfsic_dev_state *btrfsic_dev_state_lookup(\n\t\tstruct block_device *bdev);",
            "static struct btrfsic_dev_state_hashtable btrfsic_dev_state_hashtable;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"extent_io.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n#include <linux/blkdev.h>\n#include <linux/genhd.h>\n#include <linux/mutex.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\n#define BTRFSIC_DEV2STATE_HASHTABLE_SIZE 0x100\n\nstatic void btrfsic_dev_state_init(struct btrfsic_dev_state *ds);\nstatic void btrfsic_dev_state_free(struct btrfsic_dev_state *ds);\nstatic void btrfsic_block_hashtable_init(struct btrfsic_block_hashtable *h);\nstatic void btrfsic_block_hashtable_add(struct btrfsic_block *b,\n\t\t\t\t\tstruct btrfsic_block_hashtable *h);\nstatic struct btrfsic_block *btrfsic_block_hashtable_lookup(\n\t\tstruct block_device *bdev,\n\t\tu64 dev_bytenr,\n\t\tstruct btrfsic_block_hashtable *h);\nstatic void btrfsic_block_link_hashtable_init(\n\t\tstruct btrfsic_block_link_hashtable *h);\nstatic void btrfsic_block_link_hashtable_add(\n\t\tstruct btrfsic_block_link *l,\n\t\tstruct btrfsic_block_link_hashtable *h);\nstatic struct btrfsic_block_link *btrfsic_block_link_hashtable_lookup(\n\t\tstruct block_device *bdev_ref_to,\n\t\tu64 dev_bytenr_ref_to,\n\t\tstruct block_device *bdev_ref_from,\n\t\tu64 dev_bytenr_ref_from,\n\t\tstruct btrfsic_block_link_hashtable *h);\nstatic void btrfsic_dev_state_hashtable_init(\n\t\tstruct btrfsic_dev_state_hashtable *h);\nstatic void btrfsic_dev_state_hashtable_add(\n\t\tstruct btrfsic_dev_state *ds,\n\t\tstruct btrfsic_dev_state_hashtable *h);\nstatic void btrfsic_dev_state_hashtable_remove(struct btrfsic_dev_state *ds);\nstatic struct btrfsic_dev_state *btrfsic_dev_state_hashtable_lookup(\n\t\tstruct block_device *bdev,\n\t\tstruct btrfsic_dev_state_hashtable *h);\nstatic struct btrfsic_dev_state *btrfsic_dev_state_lookup(\n\t\tstruct block_device *bdev);\nstatic struct btrfsic_dev_state_hashtable btrfsic_dev_state_hashtable;\n\nstatic void btrfsic_dev_state_hashtable_add(\n\t\tstruct btrfsic_dev_state *ds,\n\t\tstruct btrfsic_dev_state_hashtable *h)\n{\n\tconst unsigned int hashval =\n\t    (((unsigned int)((uintptr_t)ds->bdev)) &\n\t     (BTRFSIC_DEV2STATE_HASHTABLE_SIZE - 1));\n\n\tlist_add(&ds->collision_resolving_node, h->table + hashval);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlcpy",
          "args": [
            "ds->name",
            "p",
            "sizeof(ds->name)"
          ],
          "line": 3144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bdevname",
          "args": [
            "ds->bdev",
            "ds->name"
          ],
          "line": 3137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&btrfsic_mutex"
          ],
          "line": 3132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_INFO\n\t\t\t       \"btrfs check-integrity: kmalloc() failed!\\n\""
          ],
          "line": 3130
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfsic_dev_state_alloc",
          "args": [],
          "line": 3128
        },
        "resolved": true,
        "details": {
          "function_name": "btrfsic_dev_state_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/check-integrity.c",
          "lines": "483-492",
          "snippet": "static struct btrfsic_dev_state *btrfsic_dev_state_alloc(void)\n{\n\tstruct btrfsic_dev_state *ds;\n\n\tds = kzalloc(sizeof(*ds), GFP_NOFS);\n\tif (NULL != ds)\n\t\tbtrfsic_dev_state_init(ds);\n\n\treturn ds;\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"extent_io.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/genhd.h>",
            "#include <linux/mutex.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void btrfsic_dev_state_init(struct btrfsic_dev_state *ds);",
            "static struct btrfsic_dev_state *btrfsic_dev_state_alloc(void);",
            "static void btrfsic_dev_state_free(struct btrfsic_dev_state *ds);",
            "static void btrfsic_dev_state_hashtable_remove(struct btrfsic_dev_state *ds);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"extent_io.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n#include <linux/blkdev.h>\n#include <linux/genhd.h>\n#include <linux/mutex.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic void btrfsic_dev_state_init(struct btrfsic_dev_state *ds);\nstatic struct btrfsic_dev_state *btrfsic_dev_state_alloc(void);\nstatic void btrfsic_dev_state_free(struct btrfsic_dev_state *ds);\nstatic void btrfsic_dev_state_hashtable_remove(struct btrfsic_dev_state *ds);\n\nstatic struct btrfsic_dev_state *btrfsic_dev_state_alloc(void)\n{\n\tstruct btrfsic_dev_state *ds;\n\n\tds = kzalloc(sizeof(*ds), GFP_NOFS);\n\tif (NULL != ds)\n\t\tbtrfsic_dev_state_init(ds);\n\n\treturn ds;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "device",
            "dev_head",
            "dev_list"
          ],
          "line": 3121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfsic_block_link_hashtable_init",
          "args": [
            "&state->block_link_hashtable"
          ],
          "line": 3117
        },
        "resolved": true,
        "details": {
          "function_name": "btrfsic_block_link_hashtable_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/check-integrity.c",
          "lines": "548-555",
          "snippet": "static void btrfsic_block_link_hashtable_init(\n\t\tstruct btrfsic_block_link_hashtable *h)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFSIC_BLOCK_LINK_HASHTABLE_SIZE; i++)\n\t\tINIT_LIST_HEAD(h->table + i);\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"extent_io.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/genhd.h>",
            "#include <linux/mutex.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define BTRFSIC_BLOCK_LINK_HASHTABLE_SIZE 0x10000"
          ],
          "globals_used": [
            "static void btrfsic_block_hashtable_init(struct btrfsic_block_hashtable *h);",
            "static void btrfsic_block_hashtable_add(struct btrfsic_block *b,\n\t\t\t\t\tstruct btrfsic_block_hashtable *h);",
            "static struct btrfsic_block *btrfsic_block_hashtable_lookup(\n\t\tstruct block_device *bdev,\n\t\tu64 dev_bytenr,\n\t\tstruct btrfsic_block_hashtable *h);",
            "static void btrfsic_block_link_hashtable_init(\n\t\tstruct btrfsic_block_link_hashtable *h);",
            "static void btrfsic_block_link_hashtable_add(\n\t\tstruct btrfsic_block_link *l,\n\t\tstruct btrfsic_block_link_hashtable *h);",
            "static struct btrfsic_block_link *btrfsic_block_link_hashtable_lookup(\n\t\tstruct block_device *bdev_ref_to,\n\t\tu64 dev_bytenr_ref_to,\n\t\tstruct block_device *bdev_ref_from,\n\t\tu64 dev_bytenr_ref_from,\n\t\tstruct btrfsic_block_link_hashtable *h);",
            "static void btrfsic_dev_state_hashtable_init(\n\t\tstruct btrfsic_dev_state_hashtable *h);",
            "static void btrfsic_dev_state_hashtable_add(\n\t\tstruct btrfsic_dev_state *ds,\n\t\tstruct btrfsic_dev_state_hashtable *h);",
            "static struct btrfsic_dev_state *btrfsic_dev_state_hashtable_lookup(\n\t\tstruct block_device *bdev,\n\t\tstruct btrfsic_dev_state_hashtable *h);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"extent_io.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n#include <linux/blkdev.h>\n#include <linux/genhd.h>\n#include <linux/mutex.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\n#define BTRFSIC_BLOCK_LINK_HASHTABLE_SIZE 0x10000\n\nstatic void btrfsic_block_hashtable_init(struct btrfsic_block_hashtable *h);\nstatic void btrfsic_block_hashtable_add(struct btrfsic_block *b,\n\t\t\t\t\tstruct btrfsic_block_hashtable *h);\nstatic struct btrfsic_block *btrfsic_block_hashtable_lookup(\n\t\tstruct block_device *bdev,\n\t\tu64 dev_bytenr,\n\t\tstruct btrfsic_block_hashtable *h);\nstatic void btrfsic_block_link_hashtable_init(\n\t\tstruct btrfsic_block_link_hashtable *h);\nstatic void btrfsic_block_link_hashtable_add(\n\t\tstruct btrfsic_block_link *l,\n\t\tstruct btrfsic_block_link_hashtable *h);\nstatic struct btrfsic_block_link *btrfsic_block_link_hashtable_lookup(\n\t\tstruct block_device *bdev_ref_to,\n\t\tu64 dev_bytenr_ref_to,\n\t\tstruct block_device *bdev_ref_from,\n\t\tu64 dev_bytenr_ref_from,\n\t\tstruct btrfsic_block_link_hashtable *h);\nstatic void btrfsic_dev_state_hashtable_init(\n\t\tstruct btrfsic_dev_state_hashtable *h);\nstatic void btrfsic_dev_state_hashtable_add(\n\t\tstruct btrfsic_dev_state *ds,\n\t\tstruct btrfsic_dev_state_hashtable *h);\nstatic struct btrfsic_dev_state *btrfsic_dev_state_hashtable_lookup(\n\t\tstruct block_device *bdev,\n\t\tstruct btrfsic_dev_state_hashtable *h);\n\nstatic void btrfsic_block_link_hashtable_init(\n\t\tstruct btrfsic_block_link_hashtable *h)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFSIC_BLOCK_LINK_HASHTABLE_SIZE; i++)\n\t\tINIT_LIST_HEAD(h->table + i);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfsic_block_hashtable_init",
          "args": [
            "&state->block_hashtable"
          ],
          "line": 3116
        },
        "resolved": true,
        "details": {
          "function_name": "btrfsic_block_hashtable_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/check-integrity.c",
          "lines": "501-507",
          "snippet": "static void btrfsic_block_hashtable_init(struct btrfsic_block_hashtable *h)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFSIC_BLOCK_HASHTABLE_SIZE; i++)\n\t\tINIT_LIST_HEAD(h->table + i);\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"extent_io.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/genhd.h>",
            "#include <linux/mutex.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define BTRFSIC_BLOCK_HASHTABLE_SIZE 0x10000"
          ],
          "globals_used": [
            "static void btrfsic_block_hashtable_init(struct btrfsic_block_hashtable *h);",
            "static void btrfsic_block_hashtable_add(struct btrfsic_block *b,\n\t\t\t\t\tstruct btrfsic_block_hashtable *h);",
            "static struct btrfsic_block *btrfsic_block_hashtable_lookup(\n\t\tstruct block_device *bdev,\n\t\tu64 dev_bytenr,\n\t\tstruct btrfsic_block_hashtable *h);",
            "static void btrfsic_block_link_hashtable_init(\n\t\tstruct btrfsic_block_link_hashtable *h);",
            "static void btrfsic_block_link_hashtable_add(\n\t\tstruct btrfsic_block_link *l,\n\t\tstruct btrfsic_block_link_hashtable *h);",
            "static struct btrfsic_block_link *btrfsic_block_link_hashtable_lookup(\n\t\tstruct block_device *bdev_ref_to,\n\t\tu64 dev_bytenr_ref_to,\n\t\tstruct block_device *bdev_ref_from,\n\t\tu64 dev_bytenr_ref_from,\n\t\tstruct btrfsic_block_link_hashtable *h);",
            "static void btrfsic_dev_state_hashtable_init(\n\t\tstruct btrfsic_dev_state_hashtable *h);",
            "static void btrfsic_dev_state_hashtable_add(\n\t\tstruct btrfsic_dev_state *ds,\n\t\tstruct btrfsic_dev_state_hashtable *h);",
            "static struct btrfsic_dev_state *btrfsic_dev_state_hashtable_lookup(\n\t\tstruct block_device *bdev,\n\t\tstruct btrfsic_dev_state_hashtable *h);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"extent_io.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n#include <linux/blkdev.h>\n#include <linux/genhd.h>\n#include <linux/mutex.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\n#define BTRFSIC_BLOCK_HASHTABLE_SIZE 0x10000\n\nstatic void btrfsic_block_hashtable_init(struct btrfsic_block_hashtable *h);\nstatic void btrfsic_block_hashtable_add(struct btrfsic_block *b,\n\t\t\t\t\tstruct btrfsic_block_hashtable *h);\nstatic struct btrfsic_block *btrfsic_block_hashtable_lookup(\n\t\tstruct block_device *bdev,\n\t\tu64 dev_bytenr,\n\t\tstruct btrfsic_block_hashtable *h);\nstatic void btrfsic_block_link_hashtable_init(\n\t\tstruct btrfsic_block_link_hashtable *h);\nstatic void btrfsic_block_link_hashtable_add(\n\t\tstruct btrfsic_block_link *l,\n\t\tstruct btrfsic_block_link_hashtable *h);\nstatic struct btrfsic_block_link *btrfsic_block_link_hashtable_lookup(\n\t\tstruct block_device *bdev_ref_to,\n\t\tu64 dev_bytenr_ref_to,\n\t\tstruct block_device *bdev_ref_from,\n\t\tu64 dev_bytenr_ref_from,\n\t\tstruct btrfsic_block_link_hashtable *h);\nstatic void btrfsic_dev_state_hashtable_init(\n\t\tstruct btrfsic_dev_state_hashtable *h);\nstatic void btrfsic_dev_state_hashtable_add(\n\t\tstruct btrfsic_dev_state *ds,\n\t\tstruct btrfsic_dev_state_hashtable *h);\nstatic struct btrfsic_dev_state *btrfsic_dev_state_hashtable_lookup(\n\t\tstruct block_device *bdev,\n\t\tstruct btrfsic_dev_state_hashtable *h);\n\nstatic void btrfsic_block_hashtable_init(struct btrfsic_block_hashtable *h)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFSIC_BLOCK_HASHTABLE_SIZE; i++)\n\t\tINIT_LIST_HEAD(h->table + i);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&state->all_blocks_list"
          ],
          "line": 3115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&btrfsic_mutex"
          ],
          "line": 3108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfsic_dev_state_hashtable_init",
          "args": [
            "&btrfsic_dev_state_hashtable"
          ],
          "line": 3105
        },
        "resolved": true,
        "details": {
          "function_name": "btrfsic_dev_state_hashtable_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/check-integrity.c",
          "lines": "610-617",
          "snippet": "static void btrfsic_dev_state_hashtable_init(\n\t\tstruct btrfsic_dev_state_hashtable *h)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFSIC_DEV2STATE_HASHTABLE_SIZE; i++)\n\t\tINIT_LIST_HEAD(h->table + i);\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"extent_io.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/genhd.h>",
            "#include <linux/mutex.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define BTRFSIC_DEV2STATE_HASHTABLE_SIZE 0x100"
          ],
          "globals_used": [
            "static void btrfsic_block_hashtable_init(struct btrfsic_block_hashtable *h);",
            "static void btrfsic_block_hashtable_add(struct btrfsic_block *b,\n\t\t\t\t\tstruct btrfsic_block_hashtable *h);",
            "static struct btrfsic_block *btrfsic_block_hashtable_lookup(\n\t\tstruct block_device *bdev,\n\t\tu64 dev_bytenr,\n\t\tstruct btrfsic_block_hashtable *h);",
            "static void btrfsic_block_link_hashtable_init(\n\t\tstruct btrfsic_block_link_hashtable *h);",
            "static void btrfsic_block_link_hashtable_add(\n\t\tstruct btrfsic_block_link *l,\n\t\tstruct btrfsic_block_link_hashtable *h);",
            "static struct btrfsic_block_link *btrfsic_block_link_hashtable_lookup(\n\t\tstruct block_device *bdev_ref_to,\n\t\tu64 dev_bytenr_ref_to,\n\t\tstruct block_device *bdev_ref_from,\n\t\tu64 dev_bytenr_ref_from,\n\t\tstruct btrfsic_block_link_hashtable *h);",
            "static void btrfsic_dev_state_hashtable_init(\n\t\tstruct btrfsic_dev_state_hashtable *h);",
            "static void btrfsic_dev_state_hashtable_add(\n\t\tstruct btrfsic_dev_state *ds,\n\t\tstruct btrfsic_dev_state_hashtable *h);",
            "static struct btrfsic_dev_state *btrfsic_dev_state_hashtable_lookup(\n\t\tstruct block_device *bdev,\n\t\tstruct btrfsic_dev_state_hashtable *h);",
            "static struct btrfsic_dev_state_hashtable btrfsic_dev_state_hashtable;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"extent_io.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n#include <linux/blkdev.h>\n#include <linux/genhd.h>\n#include <linux/mutex.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\n#define BTRFSIC_DEV2STATE_HASHTABLE_SIZE 0x100\n\nstatic void btrfsic_block_hashtable_init(struct btrfsic_block_hashtable *h);\nstatic void btrfsic_block_hashtable_add(struct btrfsic_block *b,\n\t\t\t\t\tstruct btrfsic_block_hashtable *h);\nstatic struct btrfsic_block *btrfsic_block_hashtable_lookup(\n\t\tstruct block_device *bdev,\n\t\tu64 dev_bytenr,\n\t\tstruct btrfsic_block_hashtable *h);\nstatic void btrfsic_block_link_hashtable_init(\n\t\tstruct btrfsic_block_link_hashtable *h);\nstatic void btrfsic_block_link_hashtable_add(\n\t\tstruct btrfsic_block_link *l,\n\t\tstruct btrfsic_block_link_hashtable *h);\nstatic struct btrfsic_block_link *btrfsic_block_link_hashtable_lookup(\n\t\tstruct block_device *bdev_ref_to,\n\t\tu64 dev_bytenr_ref_to,\n\t\tstruct block_device *bdev_ref_from,\n\t\tu64 dev_bytenr_ref_from,\n\t\tstruct btrfsic_block_link_hashtable *h);\nstatic void btrfsic_dev_state_hashtable_init(\n\t\tstruct btrfsic_dev_state_hashtable *h);\nstatic void btrfsic_dev_state_hashtable_add(\n\t\tstruct btrfsic_dev_state *ds,\n\t\tstruct btrfsic_dev_state_hashtable *h);\nstatic struct btrfsic_dev_state *btrfsic_dev_state_hashtable_lookup(\n\t\tstruct block_device *bdev,\n\t\tstruct btrfsic_dev_state_hashtable *h);\nstatic struct btrfsic_dev_state_hashtable btrfsic_dev_state_hashtable;\n\nstatic void btrfsic_dev_state_hashtable_init(\n\t\tstruct btrfsic_dev_state_hashtable *h)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFSIC_DEV2STATE_HASHTABLE_SIZE; i++)\n\t\tINIT_LIST_HEAD(h->table + i);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_init",
          "args": [
            "&btrfsic_mutex"
          ],
          "line": 3104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vzalloc",
          "args": [
            "sizeof(*state)"
          ],
          "line": 3096
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*state)",
            "GFP_KERNEL | __GFP_NOWARN | __GFP_REPEAT"
          ],
          "line": 3094
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_INFO\n\t\t       \"btrfsic: cannot handle sectorsize %d not being a multiple of PAGE_CACHE_SIZE %ld!\\n\"",
            "root->sectorsize",
            "PAGE_CACHE_SIZE"
          ],
          "line": 3089
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/super.c",
          "lines": "186-213",
          "snippet": "void btrfs_printk(const struct btrfs_fs_info *fs_info, const char *fmt, ...)\n{\n\tstruct super_block *sb = fs_info->sb;\n\tchar lvl[4];\n\tstruct va_format vaf;\n\tva_list args;\n\tconst char *type = logtypes[4];\n\tint kern_level;\n\n\tva_start(args, fmt);\n\n\tkern_level = printk_get_level(fmt);\n\tif (kern_level) {\n\t\tsize_t size = printk_skip_level(fmt) - fmt;\n\t\tmemcpy(lvl, fmt,  size);\n\t\tlvl[size] = '\\0';\n\t\tfmt += size;\n\t\ttype = logtypes[kern_level - '0'];\n\t} else\n\t\t*lvl = '\\0';\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sBTRFS %s (device %s): %pV\\n\", lvl, type, sb->s_id, &vaf);\n\n\tva_end(args);\n}",
          "includes": [
            "#include <trace/events/btrfs.h>",
            "#include \"qgroup.h\"",
            "#include \"tests/btrfs-tests.h\"",
            "#include \"backref.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"compression.h\"",
            "#include \"export.h\"",
            "#include \"volumes.h\"",
            "#include \"xattr.h\"",
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/slab.h>",
            "#include <linux/magic.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/namei.h>",
            "#include <linux/ctype.h>",
            "#include <linux/parser.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/btrfs.h>\n#include \"qgroup.h\"\n#include \"tests/btrfs-tests.h\"\n#include \"backref.h\"\n#include \"free-space-cache.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"compression.h\"\n#include \"export.h\"\n#include \"volumes.h\"\n#include \"xattr.h\"\n#include \"props.h\"\n#include \"hash.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include \"delayed-inode.h\"\n#include <linux/btrfs.h>\n#include <linux/ratelimit.h>\n#include <linux/cleancache.h>\n#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/miscdevice.h>\n#include <linux/namei.h>\n#include <linux/ctype.h>\n#include <linux/parser.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n\nvoid btrfs_printk(const struct btrfs_fs_info *fs_info, const char *fmt, ...)\n{\n\tstruct super_block *sb = fs_info->sb;\n\tchar lvl[4];\n\tstruct va_format vaf;\n\tva_list args;\n\tconst char *type = logtypes[4];\n\tint kern_level;\n\n\tva_start(args, fmt);\n\n\tkern_level = printk_get_level(fmt);\n\tif (kern_level) {\n\t\tsize_t size = printk_skip_level(fmt) - fmt;\n\t\tmemcpy(lvl, fmt,  size);\n\t\tlvl[size] = '\\0';\n\t\tfmt += size;\n\t\ttype = logtypes[kern_level - '0'];\n\t} else\n\t\t*lvl = '\\0';\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sBTRFS %s (device %s): %pV\\n\", lvl, type, sb->s_id, &vaf);\n\n\tva_end(args);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"extent_io.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n#include <linux/blkdev.h>\n#include <linux/genhd.h>\n#include <linux/mutex.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\n#define BTRFSIC_PRINT_MASK_INITIAL_DATABASE\t\t\t0x00000400\n#define BTRFSIC_PRINT_MASK_INITIAL_TREE\t\t\t\t0x00000100\n\nstatic void btrfsic_block_link_init(struct btrfsic_block_link *n);\nstatic void btrfsic_block_link_free(struct btrfsic_block_link *n);\nstatic void btrfsic_dev_state_init(struct btrfsic_dev_state *ds);\nstatic struct btrfsic_dev_state *btrfsic_dev_state_alloc(void);\nstatic void btrfsic_dev_state_free(struct btrfsic_dev_state *ds);\nstatic void btrfsic_dev_state_hashtable_remove(struct btrfsic_dev_state *ds);\nstatic int btrfsic_process_superblock(struct btrfsic_state *state,\n\t\t\t\t      struct btrfs_fs_devices *fs_devices);\nstatic void btrfsic_dump_database(struct btrfsic_state *state);\nstatic void btrfsic_dump_tree(const struct btrfsic_state *state);\nstatic struct btrfsic_dev_state *btrfsic_dev_state_lookup(\n\t\tstruct block_device *bdev);\nstatic struct mutex btrfsic_mutex;\nstatic int btrfsic_is_initialized;\nstatic struct btrfsic_dev_state_hashtable btrfsic_dev_state_hashtable;\n\nint btrfsic_mount(struct btrfs_root *root,\n\t\t  struct btrfs_fs_devices *fs_devices,\n\t\t  int including_extent_data, u32 print_mask)\n{\n\tint ret;\n\tstruct btrfsic_state *state;\n\tstruct list_head *dev_head = &fs_devices->devices;\n\tstruct btrfs_device *device;\n\n\tif (root->nodesize & ((u64)PAGE_CACHE_SIZE - 1)) {\n\t\tprintk(KERN_INFO\n\t\t       \"btrfsic: cannot handle nodesize %d not being a multiple of PAGE_CACHE_SIZE %ld!\\n\",\n\t\t       root->nodesize, PAGE_CACHE_SIZE);\n\t\treturn -1;\n\t}\n\tif (root->sectorsize & ((u64)PAGE_CACHE_SIZE - 1)) {\n\t\tprintk(KERN_INFO\n\t\t       \"btrfsic: cannot handle sectorsize %d not being a multiple of PAGE_CACHE_SIZE %ld!\\n\",\n\t\t       root->sectorsize, PAGE_CACHE_SIZE);\n\t\treturn -1;\n\t}\n\tstate = kzalloc(sizeof(*state), GFP_KERNEL | __GFP_NOWARN | __GFP_REPEAT);\n\tif (!state) {\n\t\tstate = vzalloc(sizeof(*state));\n\t\tif (!state) {\n\t\t\tprintk(KERN_INFO \"btrfs check-integrity: vzalloc() failed!\\n\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tif (!btrfsic_is_initialized) {\n\t\tmutex_init(&btrfsic_mutex);\n\t\tbtrfsic_dev_state_hashtable_init(&btrfsic_dev_state_hashtable);\n\t\tbtrfsic_is_initialized = 1;\n\t}\n\tmutex_lock(&btrfsic_mutex);\n\tstate->root = root;\n\tstate->print_mask = print_mask;\n\tstate->include_extent_data = including_extent_data;\n\tstate->csum_size = 0;\n\tstate->metablock_size = root->nodesize;\n\tstate->datablock_size = root->sectorsize;\n\tINIT_LIST_HEAD(&state->all_blocks_list);\n\tbtrfsic_block_hashtable_init(&state->block_hashtable);\n\tbtrfsic_block_link_hashtable_init(&state->block_link_hashtable);\n\tstate->max_superblock_generation = 0;\n\tstate->latest_superblock = NULL;\n\n\tlist_for_each_entry(device, dev_head, dev_list) {\n\t\tstruct btrfsic_dev_state *ds;\n\t\tchar *p;\n\n\t\tif (!device->bdev || !device->name)\n\t\t\tcontinue;\n\n\t\tds = btrfsic_dev_state_alloc();\n\t\tif (NULL == ds) {\n\t\t\tprintk(KERN_INFO\n\t\t\t       \"btrfs check-integrity: kmalloc() failed!\\n\");\n\t\t\tmutex_unlock(&btrfsic_mutex);\n\t\t\treturn -1;\n\t\t}\n\t\tds->bdev = device->bdev;\n\t\tds->state = state;\n\t\tbdevname(ds->bdev, ds->name);\n\t\tds->name[BDEVNAME_SIZE - 1] = '\\0';\n\t\tfor (p = ds->name; *p != '\\0'; p++);\n\t\twhile (p > ds->name && *p != '/')\n\t\t\tp--;\n\t\tif (*p == '/')\n\t\t\tp++;\n\t\tstrlcpy(ds->name, p, sizeof(ds->name));\n\t\tbtrfsic_dev_state_hashtable_add(ds,\n\t\t\t\t\t\t&btrfsic_dev_state_hashtable);\n\t}\n\n\tret = btrfsic_process_superblock(state, fs_devices);\n\tif (0 != ret) {\n\t\tmutex_unlock(&btrfsic_mutex);\n\t\tbtrfsic_unmount(root, fs_devices);\n\t\treturn ret;\n\t}\n\n\tif (state->print_mask & BTRFSIC_PRINT_MASK_INITIAL_DATABASE)\n\t\tbtrfsic_dump_database(state);\n\tif (state->print_mask & BTRFSIC_PRINT_MASK_INITIAL_TREE)\n\t\tbtrfsic_dump_tree(state);\n\n\tmutex_unlock(&btrfsic_mutex);\n\treturn 0;\n}"
  },
  {
    "function_name": "btrfsic_submit_bio_wait",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/check-integrity.c",
    "lines": "3067-3071",
    "snippet": "int btrfsic_submit_bio_wait(int rw, struct bio *bio)\n{\n\t__btrfsic_submit_bio(rw, bio);\n\treturn submit_bio_wait(rw, bio);\n}",
    "includes": [
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"volumes.h\"",
      "#include \"extent_io.h\"",
      "#include \"transaction.h\"",
      "#include \"hash.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/genhd.h>",
      "#include <linux/mutex.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "submit_bio_wait",
          "args": [
            "rw",
            "bio"
          ],
          "line": 3070
        },
        "resolved": true,
        "details": {
          "function_name": "btrfsic_submit_bio_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/check-integrity.c",
          "lines": "3067-3071",
          "snippet": "int btrfsic_submit_bio_wait(int rw, struct bio *bio)\n{\n\t__btrfsic_submit_bio(rw, bio);\n\treturn submit_bio_wait(rw, bio);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "__btrfsic_submit_bio",
          "args": [
            "rw",
            "bio"
          ],
          "line": 3069
        },
        "resolved": true,
        "details": {
          "function_name": "__btrfsic_submit_bio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/check-integrity.c",
          "lines": "2963-3059",
          "snippet": "static void __btrfsic_submit_bio(int rw, struct bio *bio)\n{\n\tstruct btrfsic_dev_state *dev_state;\n\n\tif (!btrfsic_is_initialized)\n\t\treturn;\n\n\tmutex_lock(&btrfsic_mutex);\n\t/* since btrfsic_submit_bio() is also called before\n\t * btrfsic_mount(), this might return NULL */\n\tdev_state = btrfsic_dev_state_lookup(bio->bi_bdev);\n\tif (NULL != dev_state &&\n\t    (rw & WRITE) && NULL != bio->bi_io_vec) {\n\t\tunsigned int i;\n\t\tu64 dev_bytenr;\n\t\tu64 cur_bytenr;\n\t\tint bio_is_patched;\n\t\tchar **mapped_datav;\n\n\t\tdev_bytenr = 512 * bio->bi_iter.bi_sector;\n\t\tbio_is_patched = 0;\n\t\tif (dev_state->state->print_mask &\n\t\t    BTRFSIC_PRINT_MASK_SUBMIT_BIO_BH)\n\t\t\tprintk(KERN_INFO\n\t\t\t       \"submit_bio(rw=0x%x, bi_vcnt=%u,\"\n\t\t\t       \" bi_sector=%llu (bytenr %llu), bi_bdev=%p)\\n\",\n\t\t\t       rw, bio->bi_vcnt,\n\t\t\t       (unsigned long long)bio->bi_iter.bi_sector,\n\t\t\t       dev_bytenr, bio->bi_bdev);\n\n\t\tmapped_datav = kmalloc(sizeof(*mapped_datav) * bio->bi_vcnt,\n\t\t\t\t       GFP_NOFS);\n\t\tif (!mapped_datav)\n\t\t\tgoto leave;\n\t\tcur_bytenr = dev_bytenr;\n\t\tfor (i = 0; i < bio->bi_vcnt; i++) {\n\t\t\tBUG_ON(bio->bi_io_vec[i].bv_len != PAGE_CACHE_SIZE);\n\t\t\tmapped_datav[i] = kmap(bio->bi_io_vec[i].bv_page);\n\t\t\tif (!mapped_datav[i]) {\n\t\t\t\twhile (i > 0) {\n\t\t\t\t\ti--;\n\t\t\t\t\tkunmap(bio->bi_io_vec[i].bv_page);\n\t\t\t\t}\n\t\t\t\tkfree(mapped_datav);\n\t\t\t\tgoto leave;\n\t\t\t}\n\t\t\tif (dev_state->state->print_mask &\n\t\t\t    BTRFSIC_PRINT_MASK_SUBMIT_BIO_BH_VERBOSE)\n\t\t\t\tprintk(KERN_INFO\n\t\t\t\t       \"#%u: bytenr=%llu, len=%u, offset=%u\\n\",\n\t\t\t\t       i, cur_bytenr, bio->bi_io_vec[i].bv_len,\n\t\t\t\t       bio->bi_io_vec[i].bv_offset);\n\t\t\tcur_bytenr += bio->bi_io_vec[i].bv_len;\n\t\t}\n\t\tbtrfsic_process_written_block(dev_state, dev_bytenr,\n\t\t\t\t\t      mapped_datav, bio->bi_vcnt,\n\t\t\t\t\t      bio, &bio_is_patched,\n\t\t\t\t\t      NULL, rw);\n\t\twhile (i > 0) {\n\t\t\ti--;\n\t\t\tkunmap(bio->bi_io_vec[i].bv_page);\n\t\t}\n\t\tkfree(mapped_datav);\n\t} else if (NULL != dev_state && (rw & REQ_FLUSH)) {\n\t\tif (dev_state->state->print_mask &\n\t\t    BTRFSIC_PRINT_MASK_SUBMIT_BIO_BH)\n\t\t\tprintk(KERN_INFO\n\t\t\t       \"submit_bio(rw=0x%x FLUSH, bdev=%p)\\n\",\n\t\t\t       rw, bio->bi_bdev);\n\t\tif (!dev_state->dummy_block_for_bio_bh_flush.is_iodone) {\n\t\t\tif ((dev_state->state->print_mask &\n\t\t\t     (BTRFSIC_PRINT_MASK_SUBMIT_BIO_BH |\n\t\t\t      BTRFSIC_PRINT_MASK_VERBOSE)))\n\t\t\t\tprintk(KERN_INFO\n\t\t\t\t       \"btrfsic_submit_bio(%s) with FLUSH\"\n\t\t\t\t       \" but dummy block already in use\"\n\t\t\t\t       \" (ignored)!\\n\",\n\t\t\t\t       dev_state->name);\n\t\t} else {\n\t\t\tstruct btrfsic_block *const block =\n\t\t\t\t&dev_state->dummy_block_for_bio_bh_flush;\n\n\t\t\tblock->is_iodone = 0;\n\t\t\tblock->never_written = 0;\n\t\t\tblock->iodone_w_error = 0;\n\t\t\tblock->flush_gen = dev_state->last_flush_gen + 1;\n\t\t\tblock->submit_bio_bh_rw = rw;\n\t\t\tblock->orig_bio_bh_private = bio->bi_private;\n\t\t\tblock->orig_bio_bh_end_io.bio = bio->bi_end_io;\n\t\t\tblock->next_in_same_bio = NULL;\n\t\t\tbio->bi_private = block;\n\t\t\tbio->bi_end_io = btrfsic_bio_end_io;\n\t\t}\n\t}\nleave:\n\tmutex_unlock(&btrfsic_mutex);\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"extent_io.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/genhd.h>",
            "#include <linux/mutex.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define BTRFSIC_PRINT_MASK_SUBMIT_BIO_BH_VERBOSE\t\t0x00002000",
            "#define BTRFSIC_PRINT_MASK_VERBOSE\t\t\t\t0x00000040",
            "#define BTRFSIC_PRINT_MASK_SUBMIT_BIO_BH\t\t\t0x00000010"
          ],
          "globals_used": [
            "static void btrfsic_block_link_init(struct btrfsic_block_link *n);",
            "static void btrfsic_block_link_free(struct btrfsic_block_link *n);",
            "static void btrfsic_read_from_block_data(\n\tstruct btrfsic_block_data_ctx *block_ctx,\n\tvoid *dst, u32 offset, size_t len);",
            "static void btrfsic_dump_database(struct btrfsic_state *state);",
            "static void btrfsic_process_written_block(struct btrfsic_dev_state *dev_state,\n\t\t\t\t\t  u64 dev_bytenr, char **mapped_datav,\n\t\t\t\t\t  unsigned int num_pages,\n\t\t\t\t\t  struct bio *bio, int *bio_is_patched,\n\t\t\t\t\t  struct buffer_head *bh,\n\t\t\t\t\t  int submit_bio_bh_rw);",
            "static char btrfsic_get_block_type(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block *block);",
            "static void btrfsic_dump_tree(const struct btrfsic_state *state);",
            "static struct btrfsic_dev_state *btrfsic_dev_state_lookup(\n\t\tstruct block_device *bdev);",
            "static void btrfsic_cmp_log_and_dev_bytenr(struct btrfsic_state *state,\n\t\t\t\t\t   u64 bytenr,\n\t\t\t\t\t   struct btrfsic_dev_state *dev_state,\n\t\t\t\t\t   u64 dev_bytenr);",
            "static struct mutex btrfsic_mutex;",
            "static int btrfsic_is_initialized;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"extent_io.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n#include <linux/blkdev.h>\n#include <linux/genhd.h>\n#include <linux/mutex.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\n#define BTRFSIC_PRINT_MASK_SUBMIT_BIO_BH_VERBOSE\t\t0x00002000\n#define BTRFSIC_PRINT_MASK_VERBOSE\t\t\t\t0x00000040\n#define BTRFSIC_PRINT_MASK_SUBMIT_BIO_BH\t\t\t0x00000010\n\nstatic void btrfsic_block_link_init(struct btrfsic_block_link *n);\nstatic void btrfsic_block_link_free(struct btrfsic_block_link *n);\nstatic void btrfsic_read_from_block_data(\n\tstruct btrfsic_block_data_ctx *block_ctx,\n\tvoid *dst, u32 offset, size_t len);\nstatic void btrfsic_dump_database(struct btrfsic_state *state);\nstatic void btrfsic_process_written_block(struct btrfsic_dev_state *dev_state,\n\t\t\t\t\t  u64 dev_bytenr, char **mapped_datav,\n\t\t\t\t\t  unsigned int num_pages,\n\t\t\t\t\t  struct bio *bio, int *bio_is_patched,\n\t\t\t\t\t  struct buffer_head *bh,\n\t\t\t\t\t  int submit_bio_bh_rw);\nstatic char btrfsic_get_block_type(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block *block);\nstatic void btrfsic_dump_tree(const struct btrfsic_state *state);\nstatic struct btrfsic_dev_state *btrfsic_dev_state_lookup(\n\t\tstruct block_device *bdev);\nstatic void btrfsic_cmp_log_and_dev_bytenr(struct btrfsic_state *state,\n\t\t\t\t\t   u64 bytenr,\n\t\t\t\t\t   struct btrfsic_dev_state *dev_state,\n\t\t\t\t\t   u64 dev_bytenr);\nstatic struct mutex btrfsic_mutex;\nstatic int btrfsic_is_initialized;\n\nstatic void __btrfsic_submit_bio(int rw, struct bio *bio)\n{\n\tstruct btrfsic_dev_state *dev_state;\n\n\tif (!btrfsic_is_initialized)\n\t\treturn;\n\n\tmutex_lock(&btrfsic_mutex);\n\t/* since btrfsic_submit_bio() is also called before\n\t * btrfsic_mount(), this might return NULL */\n\tdev_state = btrfsic_dev_state_lookup(bio->bi_bdev);\n\tif (NULL != dev_state &&\n\t    (rw & WRITE) && NULL != bio->bi_io_vec) {\n\t\tunsigned int i;\n\t\tu64 dev_bytenr;\n\t\tu64 cur_bytenr;\n\t\tint bio_is_patched;\n\t\tchar **mapped_datav;\n\n\t\tdev_bytenr = 512 * bio->bi_iter.bi_sector;\n\t\tbio_is_patched = 0;\n\t\tif (dev_state->state->print_mask &\n\t\t    BTRFSIC_PRINT_MASK_SUBMIT_BIO_BH)\n\t\t\tprintk(KERN_INFO\n\t\t\t       \"submit_bio(rw=0x%x, bi_vcnt=%u,\"\n\t\t\t       \" bi_sector=%llu (bytenr %llu), bi_bdev=%p)\\n\",\n\t\t\t       rw, bio->bi_vcnt,\n\t\t\t       (unsigned long long)bio->bi_iter.bi_sector,\n\t\t\t       dev_bytenr, bio->bi_bdev);\n\n\t\tmapped_datav = kmalloc(sizeof(*mapped_datav) * bio->bi_vcnt,\n\t\t\t\t       GFP_NOFS);\n\t\tif (!mapped_datav)\n\t\t\tgoto leave;\n\t\tcur_bytenr = dev_bytenr;\n\t\tfor (i = 0; i < bio->bi_vcnt; i++) {\n\t\t\tBUG_ON(bio->bi_io_vec[i].bv_len != PAGE_CACHE_SIZE);\n\t\t\tmapped_datav[i] = kmap(bio->bi_io_vec[i].bv_page);\n\t\t\tif (!mapped_datav[i]) {\n\t\t\t\twhile (i > 0) {\n\t\t\t\t\ti--;\n\t\t\t\t\tkunmap(bio->bi_io_vec[i].bv_page);\n\t\t\t\t}\n\t\t\t\tkfree(mapped_datav);\n\t\t\t\tgoto leave;\n\t\t\t}\n\t\t\tif (dev_state->state->print_mask &\n\t\t\t    BTRFSIC_PRINT_MASK_SUBMIT_BIO_BH_VERBOSE)\n\t\t\t\tprintk(KERN_INFO\n\t\t\t\t       \"#%u: bytenr=%llu, len=%u, offset=%u\\n\",\n\t\t\t\t       i, cur_bytenr, bio->bi_io_vec[i].bv_len,\n\t\t\t\t       bio->bi_io_vec[i].bv_offset);\n\t\t\tcur_bytenr += bio->bi_io_vec[i].bv_len;\n\t\t}\n\t\tbtrfsic_process_written_block(dev_state, dev_bytenr,\n\t\t\t\t\t      mapped_datav, bio->bi_vcnt,\n\t\t\t\t\t      bio, &bio_is_patched,\n\t\t\t\t\t      NULL, rw);\n\t\twhile (i > 0) {\n\t\t\ti--;\n\t\t\tkunmap(bio->bi_io_vec[i].bv_page);\n\t\t}\n\t\tkfree(mapped_datav);\n\t} else if (NULL != dev_state && (rw & REQ_FLUSH)) {\n\t\tif (dev_state->state->print_mask &\n\t\t    BTRFSIC_PRINT_MASK_SUBMIT_BIO_BH)\n\t\t\tprintk(KERN_INFO\n\t\t\t       \"submit_bio(rw=0x%x FLUSH, bdev=%p)\\n\",\n\t\t\t       rw, bio->bi_bdev);\n\t\tif (!dev_state->dummy_block_for_bio_bh_flush.is_iodone) {\n\t\t\tif ((dev_state->state->print_mask &\n\t\t\t     (BTRFSIC_PRINT_MASK_SUBMIT_BIO_BH |\n\t\t\t      BTRFSIC_PRINT_MASK_VERBOSE)))\n\t\t\t\tprintk(KERN_INFO\n\t\t\t\t       \"btrfsic_submit_bio(%s) with FLUSH\"\n\t\t\t\t       \" but dummy block already in use\"\n\t\t\t\t       \" (ignored)!\\n\",\n\t\t\t\t       dev_state->name);\n\t\t} else {\n\t\t\tstruct btrfsic_block *const block =\n\t\t\t\t&dev_state->dummy_block_for_bio_bh_flush;\n\n\t\t\tblock->is_iodone = 0;\n\t\t\tblock->never_written = 0;\n\t\t\tblock->iodone_w_error = 0;\n\t\t\tblock->flush_gen = dev_state->last_flush_gen + 1;\n\t\t\tblock->submit_bio_bh_rw = rw;\n\t\t\tblock->orig_bio_bh_private = bio->bi_private;\n\t\t\tblock->orig_bio_bh_end_io.bio = bio->bi_end_io;\n\t\t\tblock->next_in_same_bio = NULL;\n\t\t\tbio->bi_private = block;\n\t\t\tbio->bi_end_io = btrfsic_bio_end_io;\n\t\t}\n\t}\nleave:\n\tmutex_unlock(&btrfsic_mutex);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"extent_io.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n#include <linux/blkdev.h>\n#include <linux/genhd.h>\n#include <linux/mutex.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nint btrfsic_submit_bio_wait(int rw, struct bio *bio)\n{\n\t__btrfsic_submit_bio(rw, bio);\n\treturn submit_bio_wait(rw, bio);\n}"
  },
  {
    "function_name": "btrfsic_submit_bio",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/check-integrity.c",
    "lines": "3061-3065",
    "snippet": "void btrfsic_submit_bio(int rw, struct bio *bio)\n{\n\t__btrfsic_submit_bio(rw, bio);\n\tsubmit_bio(rw, bio);\n}",
    "includes": [
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"volumes.h\"",
      "#include \"extent_io.h\"",
      "#include \"transaction.h\"",
      "#include \"hash.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/genhd.h>",
      "#include <linux/mutex.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "submit_bio",
          "args": [
            "rw",
            "bio"
          ],
          "line": 3064
        },
        "resolved": true,
        "details": {
          "function_name": "btrfsic_submit_bio_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/check-integrity.c",
          "lines": "3067-3071",
          "snippet": "int btrfsic_submit_bio_wait(int rw, struct bio *bio)\n{\n\t__btrfsic_submit_bio(rw, bio);\n\treturn submit_bio_wait(rw, bio);\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"extent_io.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/genhd.h>",
            "#include <linux/mutex.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"extent_io.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n#include <linux/blkdev.h>\n#include <linux/genhd.h>\n#include <linux/mutex.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nint btrfsic_submit_bio_wait(int rw, struct bio *bio)\n{\n\t__btrfsic_submit_bio(rw, bio);\n\treturn submit_bio_wait(rw, bio);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__btrfsic_submit_bio",
          "args": [
            "rw",
            "bio"
          ],
          "line": 3063
        },
        "resolved": true,
        "details": {
          "function_name": "__btrfsic_submit_bio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/check-integrity.c",
          "lines": "2963-3059",
          "snippet": "static void __btrfsic_submit_bio(int rw, struct bio *bio)\n{\n\tstruct btrfsic_dev_state *dev_state;\n\n\tif (!btrfsic_is_initialized)\n\t\treturn;\n\n\tmutex_lock(&btrfsic_mutex);\n\t/* since btrfsic_submit_bio() is also called before\n\t * btrfsic_mount(), this might return NULL */\n\tdev_state = btrfsic_dev_state_lookup(bio->bi_bdev);\n\tif (NULL != dev_state &&\n\t    (rw & WRITE) && NULL != bio->bi_io_vec) {\n\t\tunsigned int i;\n\t\tu64 dev_bytenr;\n\t\tu64 cur_bytenr;\n\t\tint bio_is_patched;\n\t\tchar **mapped_datav;\n\n\t\tdev_bytenr = 512 * bio->bi_iter.bi_sector;\n\t\tbio_is_patched = 0;\n\t\tif (dev_state->state->print_mask &\n\t\t    BTRFSIC_PRINT_MASK_SUBMIT_BIO_BH)\n\t\t\tprintk(KERN_INFO\n\t\t\t       \"submit_bio(rw=0x%x, bi_vcnt=%u,\"\n\t\t\t       \" bi_sector=%llu (bytenr %llu), bi_bdev=%p)\\n\",\n\t\t\t       rw, bio->bi_vcnt,\n\t\t\t       (unsigned long long)bio->bi_iter.bi_sector,\n\t\t\t       dev_bytenr, bio->bi_bdev);\n\n\t\tmapped_datav = kmalloc(sizeof(*mapped_datav) * bio->bi_vcnt,\n\t\t\t\t       GFP_NOFS);\n\t\tif (!mapped_datav)\n\t\t\tgoto leave;\n\t\tcur_bytenr = dev_bytenr;\n\t\tfor (i = 0; i < bio->bi_vcnt; i++) {\n\t\t\tBUG_ON(bio->bi_io_vec[i].bv_len != PAGE_CACHE_SIZE);\n\t\t\tmapped_datav[i] = kmap(bio->bi_io_vec[i].bv_page);\n\t\t\tif (!mapped_datav[i]) {\n\t\t\t\twhile (i > 0) {\n\t\t\t\t\ti--;\n\t\t\t\t\tkunmap(bio->bi_io_vec[i].bv_page);\n\t\t\t\t}\n\t\t\t\tkfree(mapped_datav);\n\t\t\t\tgoto leave;\n\t\t\t}\n\t\t\tif (dev_state->state->print_mask &\n\t\t\t    BTRFSIC_PRINT_MASK_SUBMIT_BIO_BH_VERBOSE)\n\t\t\t\tprintk(KERN_INFO\n\t\t\t\t       \"#%u: bytenr=%llu, len=%u, offset=%u\\n\",\n\t\t\t\t       i, cur_bytenr, bio->bi_io_vec[i].bv_len,\n\t\t\t\t       bio->bi_io_vec[i].bv_offset);\n\t\t\tcur_bytenr += bio->bi_io_vec[i].bv_len;\n\t\t}\n\t\tbtrfsic_process_written_block(dev_state, dev_bytenr,\n\t\t\t\t\t      mapped_datav, bio->bi_vcnt,\n\t\t\t\t\t      bio, &bio_is_patched,\n\t\t\t\t\t      NULL, rw);\n\t\twhile (i > 0) {\n\t\t\ti--;\n\t\t\tkunmap(bio->bi_io_vec[i].bv_page);\n\t\t}\n\t\tkfree(mapped_datav);\n\t} else if (NULL != dev_state && (rw & REQ_FLUSH)) {\n\t\tif (dev_state->state->print_mask &\n\t\t    BTRFSIC_PRINT_MASK_SUBMIT_BIO_BH)\n\t\t\tprintk(KERN_INFO\n\t\t\t       \"submit_bio(rw=0x%x FLUSH, bdev=%p)\\n\",\n\t\t\t       rw, bio->bi_bdev);\n\t\tif (!dev_state->dummy_block_for_bio_bh_flush.is_iodone) {\n\t\t\tif ((dev_state->state->print_mask &\n\t\t\t     (BTRFSIC_PRINT_MASK_SUBMIT_BIO_BH |\n\t\t\t      BTRFSIC_PRINT_MASK_VERBOSE)))\n\t\t\t\tprintk(KERN_INFO\n\t\t\t\t       \"btrfsic_submit_bio(%s) with FLUSH\"\n\t\t\t\t       \" but dummy block already in use\"\n\t\t\t\t       \" (ignored)!\\n\",\n\t\t\t\t       dev_state->name);\n\t\t} else {\n\t\t\tstruct btrfsic_block *const block =\n\t\t\t\t&dev_state->dummy_block_for_bio_bh_flush;\n\n\t\t\tblock->is_iodone = 0;\n\t\t\tblock->never_written = 0;\n\t\t\tblock->iodone_w_error = 0;\n\t\t\tblock->flush_gen = dev_state->last_flush_gen + 1;\n\t\t\tblock->submit_bio_bh_rw = rw;\n\t\t\tblock->orig_bio_bh_private = bio->bi_private;\n\t\t\tblock->orig_bio_bh_end_io.bio = bio->bi_end_io;\n\t\t\tblock->next_in_same_bio = NULL;\n\t\t\tbio->bi_private = block;\n\t\t\tbio->bi_end_io = btrfsic_bio_end_io;\n\t\t}\n\t}\nleave:\n\tmutex_unlock(&btrfsic_mutex);\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"extent_io.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/genhd.h>",
            "#include <linux/mutex.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define BTRFSIC_PRINT_MASK_SUBMIT_BIO_BH_VERBOSE\t\t0x00002000",
            "#define BTRFSIC_PRINT_MASK_VERBOSE\t\t\t\t0x00000040",
            "#define BTRFSIC_PRINT_MASK_SUBMIT_BIO_BH\t\t\t0x00000010"
          ],
          "globals_used": [
            "static void btrfsic_block_link_init(struct btrfsic_block_link *n);",
            "static void btrfsic_block_link_free(struct btrfsic_block_link *n);",
            "static void btrfsic_read_from_block_data(\n\tstruct btrfsic_block_data_ctx *block_ctx,\n\tvoid *dst, u32 offset, size_t len);",
            "static void btrfsic_dump_database(struct btrfsic_state *state);",
            "static void btrfsic_process_written_block(struct btrfsic_dev_state *dev_state,\n\t\t\t\t\t  u64 dev_bytenr, char **mapped_datav,\n\t\t\t\t\t  unsigned int num_pages,\n\t\t\t\t\t  struct bio *bio, int *bio_is_patched,\n\t\t\t\t\t  struct buffer_head *bh,\n\t\t\t\t\t  int submit_bio_bh_rw);",
            "static char btrfsic_get_block_type(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block *block);",
            "static void btrfsic_dump_tree(const struct btrfsic_state *state);",
            "static struct btrfsic_dev_state *btrfsic_dev_state_lookup(\n\t\tstruct block_device *bdev);",
            "static void btrfsic_cmp_log_and_dev_bytenr(struct btrfsic_state *state,\n\t\t\t\t\t   u64 bytenr,\n\t\t\t\t\t   struct btrfsic_dev_state *dev_state,\n\t\t\t\t\t   u64 dev_bytenr);",
            "static struct mutex btrfsic_mutex;",
            "static int btrfsic_is_initialized;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"extent_io.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n#include <linux/blkdev.h>\n#include <linux/genhd.h>\n#include <linux/mutex.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\n#define BTRFSIC_PRINT_MASK_SUBMIT_BIO_BH_VERBOSE\t\t0x00002000\n#define BTRFSIC_PRINT_MASK_VERBOSE\t\t\t\t0x00000040\n#define BTRFSIC_PRINT_MASK_SUBMIT_BIO_BH\t\t\t0x00000010\n\nstatic void btrfsic_block_link_init(struct btrfsic_block_link *n);\nstatic void btrfsic_block_link_free(struct btrfsic_block_link *n);\nstatic void btrfsic_read_from_block_data(\n\tstruct btrfsic_block_data_ctx *block_ctx,\n\tvoid *dst, u32 offset, size_t len);\nstatic void btrfsic_dump_database(struct btrfsic_state *state);\nstatic void btrfsic_process_written_block(struct btrfsic_dev_state *dev_state,\n\t\t\t\t\t  u64 dev_bytenr, char **mapped_datav,\n\t\t\t\t\t  unsigned int num_pages,\n\t\t\t\t\t  struct bio *bio, int *bio_is_patched,\n\t\t\t\t\t  struct buffer_head *bh,\n\t\t\t\t\t  int submit_bio_bh_rw);\nstatic char btrfsic_get_block_type(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block *block);\nstatic void btrfsic_dump_tree(const struct btrfsic_state *state);\nstatic struct btrfsic_dev_state *btrfsic_dev_state_lookup(\n\t\tstruct block_device *bdev);\nstatic void btrfsic_cmp_log_and_dev_bytenr(struct btrfsic_state *state,\n\t\t\t\t\t   u64 bytenr,\n\t\t\t\t\t   struct btrfsic_dev_state *dev_state,\n\t\t\t\t\t   u64 dev_bytenr);\nstatic struct mutex btrfsic_mutex;\nstatic int btrfsic_is_initialized;\n\nstatic void __btrfsic_submit_bio(int rw, struct bio *bio)\n{\n\tstruct btrfsic_dev_state *dev_state;\n\n\tif (!btrfsic_is_initialized)\n\t\treturn;\n\n\tmutex_lock(&btrfsic_mutex);\n\t/* since btrfsic_submit_bio() is also called before\n\t * btrfsic_mount(), this might return NULL */\n\tdev_state = btrfsic_dev_state_lookup(bio->bi_bdev);\n\tif (NULL != dev_state &&\n\t    (rw & WRITE) && NULL != bio->bi_io_vec) {\n\t\tunsigned int i;\n\t\tu64 dev_bytenr;\n\t\tu64 cur_bytenr;\n\t\tint bio_is_patched;\n\t\tchar **mapped_datav;\n\n\t\tdev_bytenr = 512 * bio->bi_iter.bi_sector;\n\t\tbio_is_patched = 0;\n\t\tif (dev_state->state->print_mask &\n\t\t    BTRFSIC_PRINT_MASK_SUBMIT_BIO_BH)\n\t\t\tprintk(KERN_INFO\n\t\t\t       \"submit_bio(rw=0x%x, bi_vcnt=%u,\"\n\t\t\t       \" bi_sector=%llu (bytenr %llu), bi_bdev=%p)\\n\",\n\t\t\t       rw, bio->bi_vcnt,\n\t\t\t       (unsigned long long)bio->bi_iter.bi_sector,\n\t\t\t       dev_bytenr, bio->bi_bdev);\n\n\t\tmapped_datav = kmalloc(sizeof(*mapped_datav) * bio->bi_vcnt,\n\t\t\t\t       GFP_NOFS);\n\t\tif (!mapped_datav)\n\t\t\tgoto leave;\n\t\tcur_bytenr = dev_bytenr;\n\t\tfor (i = 0; i < bio->bi_vcnt; i++) {\n\t\t\tBUG_ON(bio->bi_io_vec[i].bv_len != PAGE_CACHE_SIZE);\n\t\t\tmapped_datav[i] = kmap(bio->bi_io_vec[i].bv_page);\n\t\t\tif (!mapped_datav[i]) {\n\t\t\t\twhile (i > 0) {\n\t\t\t\t\ti--;\n\t\t\t\t\tkunmap(bio->bi_io_vec[i].bv_page);\n\t\t\t\t}\n\t\t\t\tkfree(mapped_datav);\n\t\t\t\tgoto leave;\n\t\t\t}\n\t\t\tif (dev_state->state->print_mask &\n\t\t\t    BTRFSIC_PRINT_MASK_SUBMIT_BIO_BH_VERBOSE)\n\t\t\t\tprintk(KERN_INFO\n\t\t\t\t       \"#%u: bytenr=%llu, len=%u, offset=%u\\n\",\n\t\t\t\t       i, cur_bytenr, bio->bi_io_vec[i].bv_len,\n\t\t\t\t       bio->bi_io_vec[i].bv_offset);\n\t\t\tcur_bytenr += bio->bi_io_vec[i].bv_len;\n\t\t}\n\t\tbtrfsic_process_written_block(dev_state, dev_bytenr,\n\t\t\t\t\t      mapped_datav, bio->bi_vcnt,\n\t\t\t\t\t      bio, &bio_is_patched,\n\t\t\t\t\t      NULL, rw);\n\t\twhile (i > 0) {\n\t\t\ti--;\n\t\t\tkunmap(bio->bi_io_vec[i].bv_page);\n\t\t}\n\t\tkfree(mapped_datav);\n\t} else if (NULL != dev_state && (rw & REQ_FLUSH)) {\n\t\tif (dev_state->state->print_mask &\n\t\t    BTRFSIC_PRINT_MASK_SUBMIT_BIO_BH)\n\t\t\tprintk(KERN_INFO\n\t\t\t       \"submit_bio(rw=0x%x FLUSH, bdev=%p)\\n\",\n\t\t\t       rw, bio->bi_bdev);\n\t\tif (!dev_state->dummy_block_for_bio_bh_flush.is_iodone) {\n\t\t\tif ((dev_state->state->print_mask &\n\t\t\t     (BTRFSIC_PRINT_MASK_SUBMIT_BIO_BH |\n\t\t\t      BTRFSIC_PRINT_MASK_VERBOSE)))\n\t\t\t\tprintk(KERN_INFO\n\t\t\t\t       \"btrfsic_submit_bio(%s) with FLUSH\"\n\t\t\t\t       \" but dummy block already in use\"\n\t\t\t\t       \" (ignored)!\\n\",\n\t\t\t\t       dev_state->name);\n\t\t} else {\n\t\t\tstruct btrfsic_block *const block =\n\t\t\t\t&dev_state->dummy_block_for_bio_bh_flush;\n\n\t\t\tblock->is_iodone = 0;\n\t\t\tblock->never_written = 0;\n\t\t\tblock->iodone_w_error = 0;\n\t\t\tblock->flush_gen = dev_state->last_flush_gen + 1;\n\t\t\tblock->submit_bio_bh_rw = rw;\n\t\t\tblock->orig_bio_bh_private = bio->bi_private;\n\t\t\tblock->orig_bio_bh_end_io.bio = bio->bi_end_io;\n\t\t\tblock->next_in_same_bio = NULL;\n\t\t\tbio->bi_private = block;\n\t\t\tbio->bi_end_io = btrfsic_bio_end_io;\n\t\t}\n\t}\nleave:\n\tmutex_unlock(&btrfsic_mutex);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"extent_io.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n#include <linux/blkdev.h>\n#include <linux/genhd.h>\n#include <linux/mutex.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid btrfsic_submit_bio(int rw, struct bio *bio)\n{\n\t__btrfsic_submit_bio(rw, bio);\n\tsubmit_bio(rw, bio);\n}"
  },
  {
    "function_name": "__btrfsic_submit_bio",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/check-integrity.c",
    "lines": "2963-3059",
    "snippet": "static void __btrfsic_submit_bio(int rw, struct bio *bio)\n{\n\tstruct btrfsic_dev_state *dev_state;\n\n\tif (!btrfsic_is_initialized)\n\t\treturn;\n\n\tmutex_lock(&btrfsic_mutex);\n\t/* since btrfsic_submit_bio() is also called before\n\t * btrfsic_mount(), this might return NULL */\n\tdev_state = btrfsic_dev_state_lookup(bio->bi_bdev);\n\tif (NULL != dev_state &&\n\t    (rw & WRITE) && NULL != bio->bi_io_vec) {\n\t\tunsigned int i;\n\t\tu64 dev_bytenr;\n\t\tu64 cur_bytenr;\n\t\tint bio_is_patched;\n\t\tchar **mapped_datav;\n\n\t\tdev_bytenr = 512 * bio->bi_iter.bi_sector;\n\t\tbio_is_patched = 0;\n\t\tif (dev_state->state->print_mask &\n\t\t    BTRFSIC_PRINT_MASK_SUBMIT_BIO_BH)\n\t\t\tprintk(KERN_INFO\n\t\t\t       \"submit_bio(rw=0x%x, bi_vcnt=%u,\"\n\t\t\t       \" bi_sector=%llu (bytenr %llu), bi_bdev=%p)\\n\",\n\t\t\t       rw, bio->bi_vcnt,\n\t\t\t       (unsigned long long)bio->bi_iter.bi_sector,\n\t\t\t       dev_bytenr, bio->bi_bdev);\n\n\t\tmapped_datav = kmalloc(sizeof(*mapped_datav) * bio->bi_vcnt,\n\t\t\t\t       GFP_NOFS);\n\t\tif (!mapped_datav)\n\t\t\tgoto leave;\n\t\tcur_bytenr = dev_bytenr;\n\t\tfor (i = 0; i < bio->bi_vcnt; i++) {\n\t\t\tBUG_ON(bio->bi_io_vec[i].bv_len != PAGE_CACHE_SIZE);\n\t\t\tmapped_datav[i] = kmap(bio->bi_io_vec[i].bv_page);\n\t\t\tif (!mapped_datav[i]) {\n\t\t\t\twhile (i > 0) {\n\t\t\t\t\ti--;\n\t\t\t\t\tkunmap(bio->bi_io_vec[i].bv_page);\n\t\t\t\t}\n\t\t\t\tkfree(mapped_datav);\n\t\t\t\tgoto leave;\n\t\t\t}\n\t\t\tif (dev_state->state->print_mask &\n\t\t\t    BTRFSIC_PRINT_MASK_SUBMIT_BIO_BH_VERBOSE)\n\t\t\t\tprintk(KERN_INFO\n\t\t\t\t       \"#%u: bytenr=%llu, len=%u, offset=%u\\n\",\n\t\t\t\t       i, cur_bytenr, bio->bi_io_vec[i].bv_len,\n\t\t\t\t       bio->bi_io_vec[i].bv_offset);\n\t\t\tcur_bytenr += bio->bi_io_vec[i].bv_len;\n\t\t}\n\t\tbtrfsic_process_written_block(dev_state, dev_bytenr,\n\t\t\t\t\t      mapped_datav, bio->bi_vcnt,\n\t\t\t\t\t      bio, &bio_is_patched,\n\t\t\t\t\t      NULL, rw);\n\t\twhile (i > 0) {\n\t\t\ti--;\n\t\t\tkunmap(bio->bi_io_vec[i].bv_page);\n\t\t}\n\t\tkfree(mapped_datav);\n\t} else if (NULL != dev_state && (rw & REQ_FLUSH)) {\n\t\tif (dev_state->state->print_mask &\n\t\t    BTRFSIC_PRINT_MASK_SUBMIT_BIO_BH)\n\t\t\tprintk(KERN_INFO\n\t\t\t       \"submit_bio(rw=0x%x FLUSH, bdev=%p)\\n\",\n\t\t\t       rw, bio->bi_bdev);\n\t\tif (!dev_state->dummy_block_for_bio_bh_flush.is_iodone) {\n\t\t\tif ((dev_state->state->print_mask &\n\t\t\t     (BTRFSIC_PRINT_MASK_SUBMIT_BIO_BH |\n\t\t\t      BTRFSIC_PRINT_MASK_VERBOSE)))\n\t\t\t\tprintk(KERN_INFO\n\t\t\t\t       \"btrfsic_submit_bio(%s) with FLUSH\"\n\t\t\t\t       \" but dummy block already in use\"\n\t\t\t\t       \" (ignored)!\\n\",\n\t\t\t\t       dev_state->name);\n\t\t} else {\n\t\t\tstruct btrfsic_block *const block =\n\t\t\t\t&dev_state->dummy_block_for_bio_bh_flush;\n\n\t\t\tblock->is_iodone = 0;\n\t\t\tblock->never_written = 0;\n\t\t\tblock->iodone_w_error = 0;\n\t\t\tblock->flush_gen = dev_state->last_flush_gen + 1;\n\t\t\tblock->submit_bio_bh_rw = rw;\n\t\t\tblock->orig_bio_bh_private = bio->bi_private;\n\t\t\tblock->orig_bio_bh_end_io.bio = bio->bi_end_io;\n\t\t\tblock->next_in_same_bio = NULL;\n\t\t\tbio->bi_private = block;\n\t\t\tbio->bi_end_io = btrfsic_bio_end_io;\n\t\t}\n\t}\nleave:\n\tmutex_unlock(&btrfsic_mutex);\n}",
    "includes": [
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"volumes.h\"",
      "#include \"extent_io.h\"",
      "#include \"transaction.h\"",
      "#include \"hash.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/genhd.h>",
      "#include <linux/mutex.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [
      "#define BTRFSIC_PRINT_MASK_SUBMIT_BIO_BH_VERBOSE\t\t0x00002000",
      "#define BTRFSIC_PRINT_MASK_VERBOSE\t\t\t\t0x00000040",
      "#define BTRFSIC_PRINT_MASK_SUBMIT_BIO_BH\t\t\t0x00000010"
    ],
    "globals_used": [
      "static void btrfsic_block_link_init(struct btrfsic_block_link *n);",
      "static void btrfsic_block_link_free(struct btrfsic_block_link *n);",
      "static void btrfsic_read_from_block_data(\n\tstruct btrfsic_block_data_ctx *block_ctx,\n\tvoid *dst, u32 offset, size_t len);",
      "static void btrfsic_dump_database(struct btrfsic_state *state);",
      "static void btrfsic_process_written_block(struct btrfsic_dev_state *dev_state,\n\t\t\t\t\t  u64 dev_bytenr, char **mapped_datav,\n\t\t\t\t\t  unsigned int num_pages,\n\t\t\t\t\t  struct bio *bio, int *bio_is_patched,\n\t\t\t\t\t  struct buffer_head *bh,\n\t\t\t\t\t  int submit_bio_bh_rw);",
      "static char btrfsic_get_block_type(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block *block);",
      "static void btrfsic_dump_tree(const struct btrfsic_state *state);",
      "static struct btrfsic_dev_state *btrfsic_dev_state_lookup(\n\t\tstruct block_device *bdev);",
      "static void btrfsic_cmp_log_and_dev_bytenr(struct btrfsic_state *state,\n\t\t\t\t\t   u64 bytenr,\n\t\t\t\t\t   struct btrfsic_dev_state *dev_state,\n\t\t\t\t\t   u64 dev_bytenr);",
      "static struct mutex btrfsic_mutex;",
      "static int btrfsic_is_initialized;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&btrfsic_mutex"
          ],
          "line": 3058
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_INFO\n\t\t\t\t       \"btrfsic_submit_bio(%s) with FLUSH\"\n\t\t\t\t       \" but dummy block already in use\"\n\t\t\t\t       \" (ignored)!\\n\"",
            "dev_state->name"
          ],
          "line": 3036
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/super.c",
          "lines": "186-213",
          "snippet": "void btrfs_printk(const struct btrfs_fs_info *fs_info, const char *fmt, ...)\n{\n\tstruct super_block *sb = fs_info->sb;\n\tchar lvl[4];\n\tstruct va_format vaf;\n\tva_list args;\n\tconst char *type = logtypes[4];\n\tint kern_level;\n\n\tva_start(args, fmt);\n\n\tkern_level = printk_get_level(fmt);\n\tif (kern_level) {\n\t\tsize_t size = printk_skip_level(fmt) - fmt;\n\t\tmemcpy(lvl, fmt,  size);\n\t\tlvl[size] = '\\0';\n\t\tfmt += size;\n\t\ttype = logtypes[kern_level - '0'];\n\t} else\n\t\t*lvl = '\\0';\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sBTRFS %s (device %s): %pV\\n\", lvl, type, sb->s_id, &vaf);\n\n\tva_end(args);\n}",
          "includes": [
            "#include <trace/events/btrfs.h>",
            "#include \"qgroup.h\"",
            "#include \"tests/btrfs-tests.h\"",
            "#include \"backref.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"compression.h\"",
            "#include \"export.h\"",
            "#include \"volumes.h\"",
            "#include \"xattr.h\"",
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/slab.h>",
            "#include <linux/magic.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/namei.h>",
            "#include <linux/ctype.h>",
            "#include <linux/parser.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/btrfs.h>\n#include \"qgroup.h\"\n#include \"tests/btrfs-tests.h\"\n#include \"backref.h\"\n#include \"free-space-cache.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"compression.h\"\n#include \"export.h\"\n#include \"volumes.h\"\n#include \"xattr.h\"\n#include \"props.h\"\n#include \"hash.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include \"delayed-inode.h\"\n#include <linux/btrfs.h>\n#include <linux/ratelimit.h>\n#include <linux/cleancache.h>\n#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/miscdevice.h>\n#include <linux/namei.h>\n#include <linux/ctype.h>\n#include <linux/parser.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n\nvoid btrfs_printk(const struct btrfs_fs_info *fs_info, const char *fmt, ...)\n{\n\tstruct super_block *sb = fs_info->sb;\n\tchar lvl[4];\n\tstruct va_format vaf;\n\tva_list args;\n\tconst char *type = logtypes[4];\n\tint kern_level;\n\n\tva_start(args, fmt);\n\n\tkern_level = printk_get_level(fmt);\n\tif (kern_level) {\n\t\tsize_t size = printk_skip_level(fmt) - fmt;\n\t\tmemcpy(lvl, fmt,  size);\n\t\tlvl[size] = '\\0';\n\t\tfmt += size;\n\t\ttype = logtypes[kern_level - '0'];\n\t} else\n\t\t*lvl = '\\0';\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sBTRFS %s (device %s): %pV\\n\", lvl, type, sb->s_id, &vaf);\n\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "mapped_datav"
          ],
          "line": 3025
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kunmap",
          "args": [
            "bio->bi_io_vec[i].bv_page"
          ],
          "line": 3023
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfsic_process_written_block",
          "args": [
            "dev_state",
            "dev_bytenr",
            "mapped_datav",
            "bio->bi_vcnt",
            "bio",
            "&bio_is_patched",
            "NULL",
            "rw"
          ],
          "line": 3017
        },
        "resolved": true,
        "details": {
          "function_name": "btrfsic_process_written_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/check-integrity.c",
          "lines": "1818-2208",
          "snippet": "static void btrfsic_process_written_block(struct btrfsic_dev_state *dev_state,\n\t\t\t\t\t  u64 dev_bytenr, char **mapped_datav,\n\t\t\t\t\t  unsigned int num_pages,\n\t\t\t\t\t  struct bio *bio, int *bio_is_patched,\n\t\t\t\t\t  struct buffer_head *bh,\n\t\t\t\t\t  int submit_bio_bh_rw)\n{\n\tint is_metadata;\n\tstruct btrfsic_block *block;\n\tstruct btrfsic_block_data_ctx block_ctx;\n\tint ret;\n\tstruct btrfsic_state *state = dev_state->state;\n\tstruct block_device *bdev = dev_state->bdev;\n\tunsigned int processed_len;\n\n\tif (NULL != bio_is_patched)\n\t\t*bio_is_patched = 0;\n\nagain:\n\tif (num_pages == 0)\n\t\treturn;\n\n\tprocessed_len = 0;\n\tis_metadata = (0 == btrfsic_test_for_metadata(state, mapped_datav,\n\t\t\t\t\t\t      num_pages));\n\n\tblock = btrfsic_block_hashtable_lookup(bdev, dev_bytenr,\n\t\t\t\t\t       &state->block_hashtable);\n\tif (NULL != block) {\n\t\tu64 bytenr = 0;\n\t\tstruct list_head *elem_ref_to;\n\t\tstruct list_head *tmp_ref_to;\n\n\t\tif (block->is_superblock) {\n\t\t\tbytenr = btrfs_super_bytenr((struct btrfs_super_block *)\n\t\t\t\t\t\t    mapped_datav[0]);\n\t\t\tif (num_pages * PAGE_CACHE_SIZE <\n\t\t\t    BTRFS_SUPER_INFO_SIZE) {\n\t\t\t\tprintk(KERN_INFO\n\t\t\t\t       \"btrfsic: cannot work with too short bios!\\n\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tis_metadata = 1;\n\t\t\tBUG_ON(BTRFS_SUPER_INFO_SIZE & (PAGE_CACHE_SIZE - 1));\n\t\t\tprocessed_len = BTRFS_SUPER_INFO_SIZE;\n\t\t\tif (state->print_mask &\n\t\t\t    BTRFSIC_PRINT_MASK_TREE_BEFORE_SB_WRITE) {\n\t\t\t\tprintk(KERN_INFO\n\t\t\t\t       \"[before new superblock is written]:\\n\");\n\t\t\t\tbtrfsic_dump_tree_sub(state, block, 0);\n\t\t\t}\n\t\t}\n\t\tif (is_metadata) {\n\t\t\tif (!block->is_superblock) {\n\t\t\t\tif (num_pages * PAGE_CACHE_SIZE <\n\t\t\t\t    state->metablock_size) {\n\t\t\t\t\tprintk(KERN_INFO\n\t\t\t\t\t       \"btrfsic: cannot work with too short bios!\\n\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tprocessed_len = state->metablock_size;\n\t\t\t\tbytenr = btrfs_stack_header_bytenr(\n\t\t\t\t\t\t(struct btrfs_header *)\n\t\t\t\t\t\tmapped_datav[0]);\n\t\t\t\tbtrfsic_cmp_log_and_dev_bytenr(state, bytenr,\n\t\t\t\t\t\t\t       dev_state,\n\t\t\t\t\t\t\t       dev_bytenr);\n\t\t\t}\n\t\t\tif (state->print_mask & BTRFSIC_PRINT_MASK_VERBOSE) {\n\t\t\t\tif (block->logical_bytenr != bytenr &&\n\t\t\t\t    !(!block->is_metadata &&\n\t\t\t\t      block->logical_bytenr == 0))\n\t\t\t\t\tprintk(KERN_INFO\n\t\t\t\t\t       \"Written block @%llu (%s/%llu/%d) found in hash table, %c, bytenr mismatch (!= stored %llu).\\n\",\n\t\t\t\t\t       bytenr, dev_state->name,\n\t\t\t\t\t       dev_bytenr,\n\t\t\t\t\t       block->mirror_num,\n\t\t\t\t\t       btrfsic_get_block_type(state,\n\t\t\t\t\t\t\t\t      block),\n\t\t\t\t\t       block->logical_bytenr);\n\t\t\t\telse\n\t\t\t\t\tprintk(KERN_INFO\n\t\t\t\t\t       \"Written block @%llu (%s/%llu/%d) found in hash table, %c.\\n\",\n\t\t\t\t\t       bytenr, dev_state->name,\n\t\t\t\t\t       dev_bytenr, block->mirror_num,\n\t\t\t\t\t       btrfsic_get_block_type(state,\n\t\t\t\t\t\t\t\t      block));\n\t\t\t}\n\t\t\tblock->logical_bytenr = bytenr;\n\t\t} else {\n\t\t\tif (num_pages * PAGE_CACHE_SIZE <\n\t\t\t    state->datablock_size) {\n\t\t\t\tprintk(KERN_INFO\n\t\t\t\t       \"btrfsic: cannot work with too short bios!\\n\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tprocessed_len = state->datablock_size;\n\t\t\tbytenr = block->logical_bytenr;\n\t\t\tif (state->print_mask & BTRFSIC_PRINT_MASK_VERBOSE)\n\t\t\t\tprintk(KERN_INFO\n\t\t\t\t       \"Written block @%llu (%s/%llu/%d)\"\n\t\t\t\t       \" found in hash table, %c.\\n\",\n\t\t\t\t       bytenr, dev_state->name, dev_bytenr,\n\t\t\t\t       block->mirror_num,\n\t\t\t\t       btrfsic_get_block_type(state, block));\n\t\t}\n\n\t\tif (state->print_mask & BTRFSIC_PRINT_MASK_VERBOSE)\n\t\t\tprintk(KERN_INFO\n\t\t\t       \"ref_to_list: %cE, ref_from_list: %cE\\n\",\n\t\t\t       list_empty(&block->ref_to_list) ? ' ' : '!',\n\t\t\t       list_empty(&block->ref_from_list) ? ' ' : '!');\n\t\tif (btrfsic_is_block_ref_by_superblock(state, block, 0)) {\n\t\t\tprintk(KERN_INFO \"btrfs: attempt to overwrite %c-block\"\n\t\t\t       \" @%llu (%s/%llu/%d), old(gen=%llu,\"\n\t\t\t       \" objectid=%llu, type=%d, offset=%llu),\"\n\t\t\t       \" new(gen=%llu),\"\n\t\t\t       \" which is referenced by most recent superblock\"\n\t\t\t       \" (superblockgen=%llu)!\\n\",\n\t\t\t       btrfsic_get_block_type(state, block), bytenr,\n\t\t\t       dev_state->name, dev_bytenr, block->mirror_num,\n\t\t\t       block->generation,\n\t\t\t       btrfs_disk_key_objectid(&block->disk_key),\n\t\t\t       block->disk_key.type,\n\t\t\t       btrfs_disk_key_offset(&block->disk_key),\n\t\t\t       btrfs_stack_header_generation(\n\t\t\t\t       (struct btrfs_header *) mapped_datav[0]),\n\t\t\t       state->max_superblock_generation);\n\t\t\tbtrfsic_dump_tree(state);\n\t\t}\n\n\t\tif (!block->is_iodone && !block->never_written) {\n\t\t\tprintk(KERN_INFO \"btrfs: attempt to overwrite %c-block\"\n\t\t\t       \" @%llu (%s/%llu/%d), oldgen=%llu, newgen=%llu,\"\n\t\t\t       \" which is not yet iodone!\\n\",\n\t\t\t       btrfsic_get_block_type(state, block), bytenr,\n\t\t\t       dev_state->name, dev_bytenr, block->mirror_num,\n\t\t\t       block->generation,\n\t\t\t       btrfs_stack_header_generation(\n\t\t\t\t       (struct btrfs_header *)\n\t\t\t\t       mapped_datav[0]));\n\t\t\t/* it would not be safe to go on */\n\t\t\tbtrfsic_dump_tree(state);\n\t\t\tgoto continue_loop;\n\t\t}\n\n\t\t/*\n\t\t * Clear all references of this block. Do not free\n\t\t * the block itself even if is not referenced anymore\n\t\t * because it still carries valueable information\n\t\t * like whether it was ever written and IO completed.\n\t\t */\n\t\tlist_for_each_safe(elem_ref_to, tmp_ref_to,\n\t\t\t\t   &block->ref_to_list) {\n\t\t\tstruct btrfsic_block_link *const l =\n\t\t\t    list_entry(elem_ref_to,\n\t\t\t\t       struct btrfsic_block_link,\n\t\t\t\t       node_ref_to);\n\n\t\t\tif (state->print_mask & BTRFSIC_PRINT_MASK_VERBOSE)\n\t\t\t\tbtrfsic_print_rem_link(state, l);\n\t\t\tl->ref_cnt--;\n\t\t\tif (0 == l->ref_cnt) {\n\t\t\t\tlist_del(&l->node_ref_to);\n\t\t\t\tlist_del(&l->node_ref_from);\n\t\t\t\tbtrfsic_block_link_hashtable_remove(l);\n\t\t\t\tbtrfsic_block_link_free(l);\n\t\t\t}\n\t\t}\n\n\t\tblock_ctx.dev = dev_state;\n\t\tblock_ctx.dev_bytenr = dev_bytenr;\n\t\tblock_ctx.start = bytenr;\n\t\tblock_ctx.len = processed_len;\n\t\tblock_ctx.pagev = NULL;\n\t\tblock_ctx.mem_to_free = NULL;\n\t\tblock_ctx.datav = mapped_datav;\n\n\t\tif (is_metadata || state->include_extent_data) {\n\t\t\tblock->never_written = 0;\n\t\t\tblock->iodone_w_error = 0;\n\t\t\tif (NULL != bio) {\n\t\t\t\tblock->is_iodone = 0;\n\t\t\t\tBUG_ON(NULL == bio_is_patched);\n\t\t\t\tif (!*bio_is_patched) {\n\t\t\t\t\tblock->orig_bio_bh_private =\n\t\t\t\t\t    bio->bi_private;\n\t\t\t\t\tblock->orig_bio_bh_end_io.bio =\n\t\t\t\t\t    bio->bi_end_io;\n\t\t\t\t\tblock->next_in_same_bio = NULL;\n\t\t\t\t\tbio->bi_private = block;\n\t\t\t\t\tbio->bi_end_io = btrfsic_bio_end_io;\n\t\t\t\t\t*bio_is_patched = 1;\n\t\t\t\t} else {\n\t\t\t\t\tstruct btrfsic_block *chained_block =\n\t\t\t\t\t    (struct btrfsic_block *)\n\t\t\t\t\t    bio->bi_private;\n\n\t\t\t\t\tBUG_ON(NULL == chained_block);\n\t\t\t\t\tblock->orig_bio_bh_private =\n\t\t\t\t\t    chained_block->orig_bio_bh_private;\n\t\t\t\t\tblock->orig_bio_bh_end_io.bio =\n\t\t\t\t\t    chained_block->orig_bio_bh_end_io.\n\t\t\t\t\t    bio;\n\t\t\t\t\tblock->next_in_same_bio = chained_block;\n\t\t\t\t\tbio->bi_private = block;\n\t\t\t\t}\n\t\t\t} else if (NULL != bh) {\n\t\t\t\tblock->is_iodone = 0;\n\t\t\t\tblock->orig_bio_bh_private = bh->b_private;\n\t\t\t\tblock->orig_bio_bh_end_io.bh = bh->b_end_io;\n\t\t\t\tblock->next_in_same_bio = NULL;\n\t\t\t\tbh->b_private = block;\n\t\t\t\tbh->b_end_io = btrfsic_bh_end_io;\n\t\t\t} else {\n\t\t\t\tblock->is_iodone = 1;\n\t\t\t\tblock->orig_bio_bh_private = NULL;\n\t\t\t\tblock->orig_bio_bh_end_io.bio = NULL;\n\t\t\t\tblock->next_in_same_bio = NULL;\n\t\t\t}\n\t\t}\n\n\t\tblock->flush_gen = dev_state->last_flush_gen + 1;\n\t\tblock->submit_bio_bh_rw = submit_bio_bh_rw;\n\t\tif (is_metadata) {\n\t\t\tblock->logical_bytenr = bytenr;\n\t\t\tblock->is_metadata = 1;\n\t\t\tif (block->is_superblock) {\n\t\t\t\tBUG_ON(PAGE_CACHE_SIZE !=\n\t\t\t\t       BTRFS_SUPER_INFO_SIZE);\n\t\t\t\tret = btrfsic_process_written_superblock(\n\t\t\t\t\t\tstate,\n\t\t\t\t\t\tblock,\n\t\t\t\t\t\t(struct btrfs_super_block *)\n\t\t\t\t\t\tmapped_datav[0]);\n\t\t\t\tif (state->print_mask &\n\t\t\t\t    BTRFSIC_PRINT_MASK_TREE_AFTER_SB_WRITE) {\n\t\t\t\t\tprintk(KERN_INFO\n\t\t\t\t\t\"[after new superblock is written]:\\n\");\n\t\t\t\t\tbtrfsic_dump_tree_sub(state, block, 0);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tblock->mirror_num = 0;\t/* unknown */\n\t\t\t\tret = btrfsic_process_metablock(\n\t\t\t\t\t\tstate,\n\t\t\t\t\t\tblock,\n\t\t\t\t\t\t&block_ctx,\n\t\t\t\t\t\t0, 0);\n\t\t\t}\n\t\t\tif (ret)\n\t\t\t\tprintk(KERN_INFO\n\t\t\t\t       \"btrfsic: btrfsic_process_metablock\"\n\t\t\t\t       \"(root @%llu) failed!\\n\",\n\t\t\t\t       dev_bytenr);\n\t\t} else {\n\t\t\tblock->is_metadata = 0;\n\t\t\tblock->mirror_num = 0;\t/* unknown */\n\t\t\tblock->generation = BTRFSIC_GENERATION_UNKNOWN;\n\t\t\tif (!state->include_extent_data\n\t\t\t    && list_empty(&block->ref_from_list)) {\n\t\t\t\t/*\n\t\t\t\t * disk block is overwritten with extent\n\t\t\t\t * data (not meta data) and we are configured\n\t\t\t\t * to not include extent data: take the\n\t\t\t\t * chance and free the block's memory\n\t\t\t\t */\n\t\t\t\tbtrfsic_block_hashtable_remove(block);\n\t\t\t\tlist_del(&block->all_blocks_node);\n\t\t\t\tbtrfsic_block_free(block);\n\t\t\t}\n\t\t}\n\t\tbtrfsic_release_block_ctx(&block_ctx);\n\t} else {\n\t\t/* block has not been found in hash table */\n\t\tu64 bytenr;\n\n\t\tif (!is_metadata) {\n\t\t\tprocessed_len = state->datablock_size;\n\t\t\tif (state->print_mask & BTRFSIC_PRINT_MASK_VERBOSE)\n\t\t\t\tprintk(KERN_INFO \"Written block (%s/%llu/?)\"\n\t\t\t\t       \" !found in hash table, D.\\n\",\n\t\t\t\t       dev_state->name, dev_bytenr);\n\t\t\tif (!state->include_extent_data) {\n\t\t\t\t/* ignore that written D block */\n\t\t\t\tgoto continue_loop;\n\t\t\t}\n\n\t\t\t/* this is getting ugly for the\n\t\t\t * include_extent_data case... */\n\t\t\tbytenr = 0;\t/* unknown */\n\t\t} else {\n\t\t\tprocessed_len = state->metablock_size;\n\t\t\tbytenr = btrfs_stack_header_bytenr(\n\t\t\t\t\t(struct btrfs_header *)\n\t\t\t\t\tmapped_datav[0]);\n\t\t\tbtrfsic_cmp_log_and_dev_bytenr(state, bytenr, dev_state,\n\t\t\t\t\t\t       dev_bytenr);\n\t\t\tif (state->print_mask & BTRFSIC_PRINT_MASK_VERBOSE)\n\t\t\t\tprintk(KERN_INFO\n\t\t\t\t       \"Written block @%llu (%s/%llu/?)\"\n\t\t\t\t       \" !found in hash table, M.\\n\",\n\t\t\t\t       bytenr, dev_state->name, dev_bytenr);\n\t\t}\n\n\t\tblock_ctx.dev = dev_state;\n\t\tblock_ctx.dev_bytenr = dev_bytenr;\n\t\tblock_ctx.start = bytenr;\n\t\tblock_ctx.len = processed_len;\n\t\tblock_ctx.pagev = NULL;\n\t\tblock_ctx.mem_to_free = NULL;\n\t\tblock_ctx.datav = mapped_datav;\n\n\t\tblock = btrfsic_block_alloc();\n\t\tif (NULL == block) {\n\t\t\tprintk(KERN_INFO \"btrfsic: error, kmalloc failed!\\n\");\n\t\t\tbtrfsic_release_block_ctx(&block_ctx);\n\t\t\tgoto continue_loop;\n\t\t}\n\t\tblock->dev_state = dev_state;\n\t\tblock->dev_bytenr = dev_bytenr;\n\t\tblock->logical_bytenr = bytenr;\n\t\tblock->is_metadata = is_metadata;\n\t\tblock->never_written = 0;\n\t\tblock->iodone_w_error = 0;\n\t\tblock->mirror_num = 0;\t/* unknown */\n\t\tblock->flush_gen = dev_state->last_flush_gen + 1;\n\t\tblock->submit_bio_bh_rw = submit_bio_bh_rw;\n\t\tif (NULL != bio) {\n\t\t\tblock->is_iodone = 0;\n\t\t\tBUG_ON(NULL == bio_is_patched);\n\t\t\tif (!*bio_is_patched) {\n\t\t\t\tblock->orig_bio_bh_private = bio->bi_private;\n\t\t\t\tblock->orig_bio_bh_end_io.bio = bio->bi_end_io;\n\t\t\t\tblock->next_in_same_bio = NULL;\n\t\t\t\tbio->bi_private = block;\n\t\t\t\tbio->bi_end_io = btrfsic_bio_end_io;\n\t\t\t\t*bio_is_patched = 1;\n\t\t\t} else {\n\t\t\t\tstruct btrfsic_block *chained_block =\n\t\t\t\t    (struct btrfsic_block *)\n\t\t\t\t    bio->bi_private;\n\n\t\t\t\tBUG_ON(NULL == chained_block);\n\t\t\t\tblock->orig_bio_bh_private =\n\t\t\t\t    chained_block->orig_bio_bh_private;\n\t\t\t\tblock->orig_bio_bh_end_io.bio =\n\t\t\t\t    chained_block->orig_bio_bh_end_io.bio;\n\t\t\t\tblock->next_in_same_bio = chained_block;\n\t\t\t\tbio->bi_private = block;\n\t\t\t}\n\t\t} else if (NULL != bh) {\n\t\t\tblock->is_iodone = 0;\n\t\t\tblock->orig_bio_bh_private = bh->b_private;\n\t\t\tblock->orig_bio_bh_end_io.bh = bh->b_end_io;\n\t\t\tblock->next_in_same_bio = NULL;\n\t\t\tbh->b_private = block;\n\t\t\tbh->b_end_io = btrfsic_bh_end_io;\n\t\t} else {\n\t\t\tblock->is_iodone = 1;\n\t\t\tblock->orig_bio_bh_private = NULL;\n\t\t\tblock->orig_bio_bh_end_io.bio = NULL;\n\t\t\tblock->next_in_same_bio = NULL;\n\t\t}\n\t\tif (state->print_mask & BTRFSIC_PRINT_MASK_VERBOSE)\n\t\t\tprintk(KERN_INFO\n\t\t\t       \"New written %c-block @%llu (%s/%llu/%d)\\n\",\n\t\t\t       is_metadata ? 'M' : 'D',\n\t\t\t       block->logical_bytenr, block->dev_state->name,\n\t\t\t       block->dev_bytenr, block->mirror_num);\n\t\tlist_add(&block->all_blocks_node, &state->all_blocks_list);\n\t\tbtrfsic_block_hashtable_add(block, &state->block_hashtable);\n\n\t\tif (is_metadata) {\n\t\t\tret = btrfsic_process_metablock(state, block,\n\t\t\t\t\t\t\t&block_ctx, 0, 0);\n\t\t\tif (ret)\n\t\t\t\tprintk(KERN_INFO\n\t\t\t\t       \"btrfsic: process_metablock(root @%llu)\"\n\t\t\t\t       \" failed!\\n\",\n\t\t\t\t       dev_bytenr);\n\t\t}\n\t\tbtrfsic_release_block_ctx(&block_ctx);\n\t}\n\ncontinue_loop:\n\tBUG_ON(!processed_len);\n\tdev_bytenr += processed_len;\n\tmapped_datav += processed_len >> PAGE_CACHE_SHIFT;\n\tnum_pages -= processed_len >> PAGE_CACHE_SHIFT;\n\tgoto again;\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"extent_io.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/genhd.h>",
            "#include <linux/mutex.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define BTRFSIC_PRINT_MASK_VERBOSE\t\t\t\t0x00000040",
            "#define BTRFSIC_PRINT_MASK_TREE_BEFORE_SB_WRITE\t\t\t0x00000008",
            "#define BTRFSIC_PRINT_MASK_TREE_AFTER_SB_WRITE\t\t\t0x00000004",
            "#define BTRFSIC_GENERATION_UNKNOWN ((u64)-1)"
          ],
          "globals_used": [
            "static struct btrfsic_block *btrfsic_block_alloc(void);",
            "static void btrfsic_block_link_init(struct btrfsic_block_link *n);",
            "static void btrfsic_block_link_free(struct btrfsic_block_link *n);",
            "static void btrfsic_block_link_hashtable_remove(struct btrfsic_block_link *l);",
            "static void btrfsic_read_from_block_data(\n\tstruct btrfsic_block_data_ctx *block_ctx,\n\tvoid *dst, u32 offset, size_t len);",
            "static int btrfsic_map_block(struct btrfsic_state *state, u64 bytenr, u32 len,\n\t\t\t     struct btrfsic_block_data_ctx *block_ctx_out,\n\t\t\t     int mirror_num);",
            "static void btrfsic_release_block_ctx(struct btrfsic_block_data_ctx *block_ctx);",
            "static int btrfsic_read_block(struct btrfsic_state *state,\n\t\t\t      struct btrfsic_block_data_ctx *block_ctx);",
            "static void btrfsic_dump_database(struct btrfsic_state *state);",
            "static int btrfsic_test_for_metadata(struct btrfsic_state *state,\n\t\t\t\t     char **datav, unsigned int num_pages);",
            "static void btrfsic_process_written_block(struct btrfsic_dev_state *dev_state,\n\t\t\t\t\t  u64 dev_bytenr, char **mapped_datav,\n\t\t\t\t\t  unsigned int num_pages,\n\t\t\t\t\t  struct bio *bio, int *bio_is_patched,\n\t\t\t\t\t  struct buffer_head *bh,\n\t\t\t\t\t  int submit_bio_bh_rw);",
            "static void btrfsic_print_add_link(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block_link *l);",
            "static void btrfsic_print_rem_link(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block_link *l);",
            "static char btrfsic_get_block_type(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block *block);",
            "static void btrfsic_dump_tree(const struct btrfsic_state *state);",
            "static struct btrfsic_dev_state *btrfsic_dev_state_lookup(\n\t\tstruct block_device *bdev);",
            "static void btrfsic_cmp_log_and_dev_bytenr(struct btrfsic_state *state,\n\t\t\t\t\t   u64 bytenr,\n\t\t\t\t\t   struct btrfsic_dev_state *dev_state,\n\t\t\t\t\t   u64 dev_bytenr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"extent_io.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n#include <linux/blkdev.h>\n#include <linux/genhd.h>\n#include <linux/mutex.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\n#define BTRFSIC_PRINT_MASK_VERBOSE\t\t\t\t0x00000040\n#define BTRFSIC_PRINT_MASK_TREE_BEFORE_SB_WRITE\t\t\t0x00000008\n#define BTRFSIC_PRINT_MASK_TREE_AFTER_SB_WRITE\t\t\t0x00000004\n#define BTRFSIC_GENERATION_UNKNOWN ((u64)-1)\n\nstatic struct btrfsic_block *btrfsic_block_alloc(void);\nstatic void btrfsic_block_link_init(struct btrfsic_block_link *n);\nstatic void btrfsic_block_link_free(struct btrfsic_block_link *n);\nstatic void btrfsic_block_link_hashtable_remove(struct btrfsic_block_link *l);\nstatic void btrfsic_read_from_block_data(\n\tstruct btrfsic_block_data_ctx *block_ctx,\n\tvoid *dst, u32 offset, size_t len);\nstatic int btrfsic_map_block(struct btrfsic_state *state, u64 bytenr, u32 len,\n\t\t\t     struct btrfsic_block_data_ctx *block_ctx_out,\n\t\t\t     int mirror_num);\nstatic void btrfsic_release_block_ctx(struct btrfsic_block_data_ctx *block_ctx);\nstatic int btrfsic_read_block(struct btrfsic_state *state,\n\t\t\t      struct btrfsic_block_data_ctx *block_ctx);\nstatic void btrfsic_dump_database(struct btrfsic_state *state);\nstatic int btrfsic_test_for_metadata(struct btrfsic_state *state,\n\t\t\t\t     char **datav, unsigned int num_pages);\nstatic void btrfsic_process_written_block(struct btrfsic_dev_state *dev_state,\n\t\t\t\t\t  u64 dev_bytenr, char **mapped_datav,\n\t\t\t\t\t  unsigned int num_pages,\n\t\t\t\t\t  struct bio *bio, int *bio_is_patched,\n\t\t\t\t\t  struct buffer_head *bh,\n\t\t\t\t\t  int submit_bio_bh_rw);\nstatic void btrfsic_print_add_link(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block_link *l);\nstatic void btrfsic_print_rem_link(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block_link *l);\nstatic char btrfsic_get_block_type(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block *block);\nstatic void btrfsic_dump_tree(const struct btrfsic_state *state);\nstatic struct btrfsic_dev_state *btrfsic_dev_state_lookup(\n\t\tstruct block_device *bdev);\nstatic void btrfsic_cmp_log_and_dev_bytenr(struct btrfsic_state *state,\n\t\t\t\t\t   u64 bytenr,\n\t\t\t\t\t   struct btrfsic_dev_state *dev_state,\n\t\t\t\t\t   u64 dev_bytenr);\n\nstatic void btrfsic_process_written_block(struct btrfsic_dev_state *dev_state,\n\t\t\t\t\t  u64 dev_bytenr, char **mapped_datav,\n\t\t\t\t\t  unsigned int num_pages,\n\t\t\t\t\t  struct bio *bio, int *bio_is_patched,\n\t\t\t\t\t  struct buffer_head *bh,\n\t\t\t\t\t  int submit_bio_bh_rw)\n{\n\tint is_metadata;\n\tstruct btrfsic_block *block;\n\tstruct btrfsic_block_data_ctx block_ctx;\n\tint ret;\n\tstruct btrfsic_state *state = dev_state->state;\n\tstruct block_device *bdev = dev_state->bdev;\n\tunsigned int processed_len;\n\n\tif (NULL != bio_is_patched)\n\t\t*bio_is_patched = 0;\n\nagain:\n\tif (num_pages == 0)\n\t\treturn;\n\n\tprocessed_len = 0;\n\tis_metadata = (0 == btrfsic_test_for_metadata(state, mapped_datav,\n\t\t\t\t\t\t      num_pages));\n\n\tblock = btrfsic_block_hashtable_lookup(bdev, dev_bytenr,\n\t\t\t\t\t       &state->block_hashtable);\n\tif (NULL != block) {\n\t\tu64 bytenr = 0;\n\t\tstruct list_head *elem_ref_to;\n\t\tstruct list_head *tmp_ref_to;\n\n\t\tif (block->is_superblock) {\n\t\t\tbytenr = btrfs_super_bytenr((struct btrfs_super_block *)\n\t\t\t\t\t\t    mapped_datav[0]);\n\t\t\tif (num_pages * PAGE_CACHE_SIZE <\n\t\t\t    BTRFS_SUPER_INFO_SIZE) {\n\t\t\t\tprintk(KERN_INFO\n\t\t\t\t       \"btrfsic: cannot work with too short bios!\\n\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tis_metadata = 1;\n\t\t\tBUG_ON(BTRFS_SUPER_INFO_SIZE & (PAGE_CACHE_SIZE - 1));\n\t\t\tprocessed_len = BTRFS_SUPER_INFO_SIZE;\n\t\t\tif (state->print_mask &\n\t\t\t    BTRFSIC_PRINT_MASK_TREE_BEFORE_SB_WRITE) {\n\t\t\t\tprintk(KERN_INFO\n\t\t\t\t       \"[before new superblock is written]:\\n\");\n\t\t\t\tbtrfsic_dump_tree_sub(state, block, 0);\n\t\t\t}\n\t\t}\n\t\tif (is_metadata) {\n\t\t\tif (!block->is_superblock) {\n\t\t\t\tif (num_pages * PAGE_CACHE_SIZE <\n\t\t\t\t    state->metablock_size) {\n\t\t\t\t\tprintk(KERN_INFO\n\t\t\t\t\t       \"btrfsic: cannot work with too short bios!\\n\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tprocessed_len = state->metablock_size;\n\t\t\t\tbytenr = btrfs_stack_header_bytenr(\n\t\t\t\t\t\t(struct btrfs_header *)\n\t\t\t\t\t\tmapped_datav[0]);\n\t\t\t\tbtrfsic_cmp_log_and_dev_bytenr(state, bytenr,\n\t\t\t\t\t\t\t       dev_state,\n\t\t\t\t\t\t\t       dev_bytenr);\n\t\t\t}\n\t\t\tif (state->print_mask & BTRFSIC_PRINT_MASK_VERBOSE) {\n\t\t\t\tif (block->logical_bytenr != bytenr &&\n\t\t\t\t    !(!block->is_metadata &&\n\t\t\t\t      block->logical_bytenr == 0))\n\t\t\t\t\tprintk(KERN_INFO\n\t\t\t\t\t       \"Written block @%llu (%s/%llu/%d) found in hash table, %c, bytenr mismatch (!= stored %llu).\\n\",\n\t\t\t\t\t       bytenr, dev_state->name,\n\t\t\t\t\t       dev_bytenr,\n\t\t\t\t\t       block->mirror_num,\n\t\t\t\t\t       btrfsic_get_block_type(state,\n\t\t\t\t\t\t\t\t      block),\n\t\t\t\t\t       block->logical_bytenr);\n\t\t\t\telse\n\t\t\t\t\tprintk(KERN_INFO\n\t\t\t\t\t       \"Written block @%llu (%s/%llu/%d) found in hash table, %c.\\n\",\n\t\t\t\t\t       bytenr, dev_state->name,\n\t\t\t\t\t       dev_bytenr, block->mirror_num,\n\t\t\t\t\t       btrfsic_get_block_type(state,\n\t\t\t\t\t\t\t\t      block));\n\t\t\t}\n\t\t\tblock->logical_bytenr = bytenr;\n\t\t} else {\n\t\t\tif (num_pages * PAGE_CACHE_SIZE <\n\t\t\t    state->datablock_size) {\n\t\t\t\tprintk(KERN_INFO\n\t\t\t\t       \"btrfsic: cannot work with too short bios!\\n\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tprocessed_len = state->datablock_size;\n\t\t\tbytenr = block->logical_bytenr;\n\t\t\tif (state->print_mask & BTRFSIC_PRINT_MASK_VERBOSE)\n\t\t\t\tprintk(KERN_INFO\n\t\t\t\t       \"Written block @%llu (%s/%llu/%d)\"\n\t\t\t\t       \" found in hash table, %c.\\n\",\n\t\t\t\t       bytenr, dev_state->name, dev_bytenr,\n\t\t\t\t       block->mirror_num,\n\t\t\t\t       btrfsic_get_block_type(state, block));\n\t\t}\n\n\t\tif (state->print_mask & BTRFSIC_PRINT_MASK_VERBOSE)\n\t\t\tprintk(KERN_INFO\n\t\t\t       \"ref_to_list: %cE, ref_from_list: %cE\\n\",\n\t\t\t       list_empty(&block->ref_to_list) ? ' ' : '!',\n\t\t\t       list_empty(&block->ref_from_list) ? ' ' : '!');\n\t\tif (btrfsic_is_block_ref_by_superblock(state, block, 0)) {\n\t\t\tprintk(KERN_INFO \"btrfs: attempt to overwrite %c-block\"\n\t\t\t       \" @%llu (%s/%llu/%d), old(gen=%llu,\"\n\t\t\t       \" objectid=%llu, type=%d, offset=%llu),\"\n\t\t\t       \" new(gen=%llu),\"\n\t\t\t       \" which is referenced by most recent superblock\"\n\t\t\t       \" (superblockgen=%llu)!\\n\",\n\t\t\t       btrfsic_get_block_type(state, block), bytenr,\n\t\t\t       dev_state->name, dev_bytenr, block->mirror_num,\n\t\t\t       block->generation,\n\t\t\t       btrfs_disk_key_objectid(&block->disk_key),\n\t\t\t       block->disk_key.type,\n\t\t\t       btrfs_disk_key_offset(&block->disk_key),\n\t\t\t       btrfs_stack_header_generation(\n\t\t\t\t       (struct btrfs_header *) mapped_datav[0]),\n\t\t\t       state->max_superblock_generation);\n\t\t\tbtrfsic_dump_tree(state);\n\t\t}\n\n\t\tif (!block->is_iodone && !block->never_written) {\n\t\t\tprintk(KERN_INFO \"btrfs: attempt to overwrite %c-block\"\n\t\t\t       \" @%llu (%s/%llu/%d), oldgen=%llu, newgen=%llu,\"\n\t\t\t       \" which is not yet iodone!\\n\",\n\t\t\t       btrfsic_get_block_type(state, block), bytenr,\n\t\t\t       dev_state->name, dev_bytenr, block->mirror_num,\n\t\t\t       block->generation,\n\t\t\t       btrfs_stack_header_generation(\n\t\t\t\t       (struct btrfs_header *)\n\t\t\t\t       mapped_datav[0]));\n\t\t\t/* it would not be safe to go on */\n\t\t\tbtrfsic_dump_tree(state);\n\t\t\tgoto continue_loop;\n\t\t}\n\n\t\t/*\n\t\t * Clear all references of this block. Do not free\n\t\t * the block itself even if is not referenced anymore\n\t\t * because it still carries valueable information\n\t\t * like whether it was ever written and IO completed.\n\t\t */\n\t\tlist_for_each_safe(elem_ref_to, tmp_ref_to,\n\t\t\t\t   &block->ref_to_list) {\n\t\t\tstruct btrfsic_block_link *const l =\n\t\t\t    list_entry(elem_ref_to,\n\t\t\t\t       struct btrfsic_block_link,\n\t\t\t\t       node_ref_to);\n\n\t\t\tif (state->print_mask & BTRFSIC_PRINT_MASK_VERBOSE)\n\t\t\t\tbtrfsic_print_rem_link(state, l);\n\t\t\tl->ref_cnt--;\n\t\t\tif (0 == l->ref_cnt) {\n\t\t\t\tlist_del(&l->node_ref_to);\n\t\t\t\tlist_del(&l->node_ref_from);\n\t\t\t\tbtrfsic_block_link_hashtable_remove(l);\n\t\t\t\tbtrfsic_block_link_free(l);\n\t\t\t}\n\t\t}\n\n\t\tblock_ctx.dev = dev_state;\n\t\tblock_ctx.dev_bytenr = dev_bytenr;\n\t\tblock_ctx.start = bytenr;\n\t\tblock_ctx.len = processed_len;\n\t\tblock_ctx.pagev = NULL;\n\t\tblock_ctx.mem_to_free = NULL;\n\t\tblock_ctx.datav = mapped_datav;\n\n\t\tif (is_metadata || state->include_extent_data) {\n\t\t\tblock->never_written = 0;\n\t\t\tblock->iodone_w_error = 0;\n\t\t\tif (NULL != bio) {\n\t\t\t\tblock->is_iodone = 0;\n\t\t\t\tBUG_ON(NULL == bio_is_patched);\n\t\t\t\tif (!*bio_is_patched) {\n\t\t\t\t\tblock->orig_bio_bh_private =\n\t\t\t\t\t    bio->bi_private;\n\t\t\t\t\tblock->orig_bio_bh_end_io.bio =\n\t\t\t\t\t    bio->bi_end_io;\n\t\t\t\t\tblock->next_in_same_bio = NULL;\n\t\t\t\t\tbio->bi_private = block;\n\t\t\t\t\tbio->bi_end_io = btrfsic_bio_end_io;\n\t\t\t\t\t*bio_is_patched = 1;\n\t\t\t\t} else {\n\t\t\t\t\tstruct btrfsic_block *chained_block =\n\t\t\t\t\t    (struct btrfsic_block *)\n\t\t\t\t\t    bio->bi_private;\n\n\t\t\t\t\tBUG_ON(NULL == chained_block);\n\t\t\t\t\tblock->orig_bio_bh_private =\n\t\t\t\t\t    chained_block->orig_bio_bh_private;\n\t\t\t\t\tblock->orig_bio_bh_end_io.bio =\n\t\t\t\t\t    chained_block->orig_bio_bh_end_io.\n\t\t\t\t\t    bio;\n\t\t\t\t\tblock->next_in_same_bio = chained_block;\n\t\t\t\t\tbio->bi_private = block;\n\t\t\t\t}\n\t\t\t} else if (NULL != bh) {\n\t\t\t\tblock->is_iodone = 0;\n\t\t\t\tblock->orig_bio_bh_private = bh->b_private;\n\t\t\t\tblock->orig_bio_bh_end_io.bh = bh->b_end_io;\n\t\t\t\tblock->next_in_same_bio = NULL;\n\t\t\t\tbh->b_private = block;\n\t\t\t\tbh->b_end_io = btrfsic_bh_end_io;\n\t\t\t} else {\n\t\t\t\tblock->is_iodone = 1;\n\t\t\t\tblock->orig_bio_bh_private = NULL;\n\t\t\t\tblock->orig_bio_bh_end_io.bio = NULL;\n\t\t\t\tblock->next_in_same_bio = NULL;\n\t\t\t}\n\t\t}\n\n\t\tblock->flush_gen = dev_state->last_flush_gen + 1;\n\t\tblock->submit_bio_bh_rw = submit_bio_bh_rw;\n\t\tif (is_metadata) {\n\t\t\tblock->logical_bytenr = bytenr;\n\t\t\tblock->is_metadata = 1;\n\t\t\tif (block->is_superblock) {\n\t\t\t\tBUG_ON(PAGE_CACHE_SIZE !=\n\t\t\t\t       BTRFS_SUPER_INFO_SIZE);\n\t\t\t\tret = btrfsic_process_written_superblock(\n\t\t\t\t\t\tstate,\n\t\t\t\t\t\tblock,\n\t\t\t\t\t\t(struct btrfs_super_block *)\n\t\t\t\t\t\tmapped_datav[0]);\n\t\t\t\tif (state->print_mask &\n\t\t\t\t    BTRFSIC_PRINT_MASK_TREE_AFTER_SB_WRITE) {\n\t\t\t\t\tprintk(KERN_INFO\n\t\t\t\t\t\"[after new superblock is written]:\\n\");\n\t\t\t\t\tbtrfsic_dump_tree_sub(state, block, 0);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tblock->mirror_num = 0;\t/* unknown */\n\t\t\t\tret = btrfsic_process_metablock(\n\t\t\t\t\t\tstate,\n\t\t\t\t\t\tblock,\n\t\t\t\t\t\t&block_ctx,\n\t\t\t\t\t\t0, 0);\n\t\t\t}\n\t\t\tif (ret)\n\t\t\t\tprintk(KERN_INFO\n\t\t\t\t       \"btrfsic: btrfsic_process_metablock\"\n\t\t\t\t       \"(root @%llu) failed!\\n\",\n\t\t\t\t       dev_bytenr);\n\t\t} else {\n\t\t\tblock->is_metadata = 0;\n\t\t\tblock->mirror_num = 0;\t/* unknown */\n\t\t\tblock->generation = BTRFSIC_GENERATION_UNKNOWN;\n\t\t\tif (!state->include_extent_data\n\t\t\t    && list_empty(&block->ref_from_list)) {\n\t\t\t\t/*\n\t\t\t\t * disk block is overwritten with extent\n\t\t\t\t * data (not meta data) and we are configured\n\t\t\t\t * to not include extent data: take the\n\t\t\t\t * chance and free the block's memory\n\t\t\t\t */\n\t\t\t\tbtrfsic_block_hashtable_remove(block);\n\t\t\t\tlist_del(&block->all_blocks_node);\n\t\t\t\tbtrfsic_block_free(block);\n\t\t\t}\n\t\t}\n\t\tbtrfsic_release_block_ctx(&block_ctx);\n\t} else {\n\t\t/* block has not been found in hash table */\n\t\tu64 bytenr;\n\n\t\tif (!is_metadata) {\n\t\t\tprocessed_len = state->datablock_size;\n\t\t\tif (state->print_mask & BTRFSIC_PRINT_MASK_VERBOSE)\n\t\t\t\tprintk(KERN_INFO \"Written block (%s/%llu/?)\"\n\t\t\t\t       \" !found in hash table, D.\\n\",\n\t\t\t\t       dev_state->name, dev_bytenr);\n\t\t\tif (!state->include_extent_data) {\n\t\t\t\t/* ignore that written D block */\n\t\t\t\tgoto continue_loop;\n\t\t\t}\n\n\t\t\t/* this is getting ugly for the\n\t\t\t * include_extent_data case... */\n\t\t\tbytenr = 0;\t/* unknown */\n\t\t} else {\n\t\t\tprocessed_len = state->metablock_size;\n\t\t\tbytenr = btrfs_stack_header_bytenr(\n\t\t\t\t\t(struct btrfs_header *)\n\t\t\t\t\tmapped_datav[0]);\n\t\t\tbtrfsic_cmp_log_and_dev_bytenr(state, bytenr, dev_state,\n\t\t\t\t\t\t       dev_bytenr);\n\t\t\tif (state->print_mask & BTRFSIC_PRINT_MASK_VERBOSE)\n\t\t\t\tprintk(KERN_INFO\n\t\t\t\t       \"Written block @%llu (%s/%llu/?)\"\n\t\t\t\t       \" !found in hash table, M.\\n\",\n\t\t\t\t       bytenr, dev_state->name, dev_bytenr);\n\t\t}\n\n\t\tblock_ctx.dev = dev_state;\n\t\tblock_ctx.dev_bytenr = dev_bytenr;\n\t\tblock_ctx.start = bytenr;\n\t\tblock_ctx.len = processed_len;\n\t\tblock_ctx.pagev = NULL;\n\t\tblock_ctx.mem_to_free = NULL;\n\t\tblock_ctx.datav = mapped_datav;\n\n\t\tblock = btrfsic_block_alloc();\n\t\tif (NULL == block) {\n\t\t\tprintk(KERN_INFO \"btrfsic: error, kmalloc failed!\\n\");\n\t\t\tbtrfsic_release_block_ctx(&block_ctx);\n\t\t\tgoto continue_loop;\n\t\t}\n\t\tblock->dev_state = dev_state;\n\t\tblock->dev_bytenr = dev_bytenr;\n\t\tblock->logical_bytenr = bytenr;\n\t\tblock->is_metadata = is_metadata;\n\t\tblock->never_written = 0;\n\t\tblock->iodone_w_error = 0;\n\t\tblock->mirror_num = 0;\t/* unknown */\n\t\tblock->flush_gen = dev_state->last_flush_gen + 1;\n\t\tblock->submit_bio_bh_rw = submit_bio_bh_rw;\n\t\tif (NULL != bio) {\n\t\t\tblock->is_iodone = 0;\n\t\t\tBUG_ON(NULL == bio_is_patched);\n\t\t\tif (!*bio_is_patched) {\n\t\t\t\tblock->orig_bio_bh_private = bio->bi_private;\n\t\t\t\tblock->orig_bio_bh_end_io.bio = bio->bi_end_io;\n\t\t\t\tblock->next_in_same_bio = NULL;\n\t\t\t\tbio->bi_private = block;\n\t\t\t\tbio->bi_end_io = btrfsic_bio_end_io;\n\t\t\t\t*bio_is_patched = 1;\n\t\t\t} else {\n\t\t\t\tstruct btrfsic_block *chained_block =\n\t\t\t\t    (struct btrfsic_block *)\n\t\t\t\t    bio->bi_private;\n\n\t\t\t\tBUG_ON(NULL == chained_block);\n\t\t\t\tblock->orig_bio_bh_private =\n\t\t\t\t    chained_block->orig_bio_bh_private;\n\t\t\t\tblock->orig_bio_bh_end_io.bio =\n\t\t\t\t    chained_block->orig_bio_bh_end_io.bio;\n\t\t\t\tblock->next_in_same_bio = chained_block;\n\t\t\t\tbio->bi_private = block;\n\t\t\t}\n\t\t} else if (NULL != bh) {\n\t\t\tblock->is_iodone = 0;\n\t\t\tblock->orig_bio_bh_private = bh->b_private;\n\t\t\tblock->orig_bio_bh_end_io.bh = bh->b_end_io;\n\t\t\tblock->next_in_same_bio = NULL;\n\t\t\tbh->b_private = block;\n\t\t\tbh->b_end_io = btrfsic_bh_end_io;\n\t\t} else {\n\t\t\tblock->is_iodone = 1;\n\t\t\tblock->orig_bio_bh_private = NULL;\n\t\t\tblock->orig_bio_bh_end_io.bio = NULL;\n\t\t\tblock->next_in_same_bio = NULL;\n\t\t}\n\t\tif (state->print_mask & BTRFSIC_PRINT_MASK_VERBOSE)\n\t\t\tprintk(KERN_INFO\n\t\t\t       \"New written %c-block @%llu (%s/%llu/%d)\\n\",\n\t\t\t       is_metadata ? 'M' : 'D',\n\t\t\t       block->logical_bytenr, block->dev_state->name,\n\t\t\t       block->dev_bytenr, block->mirror_num);\n\t\tlist_add(&block->all_blocks_node, &state->all_blocks_list);\n\t\tbtrfsic_block_hashtable_add(block, &state->block_hashtable);\n\n\t\tif (is_metadata) {\n\t\t\tret = btrfsic_process_metablock(state, block,\n\t\t\t\t\t\t\t&block_ctx, 0, 0);\n\t\t\tif (ret)\n\t\t\t\tprintk(KERN_INFO\n\t\t\t\t       \"btrfsic: process_metablock(root @%llu)\"\n\t\t\t\t       \" failed!\\n\",\n\t\t\t\t       dev_bytenr);\n\t\t}\n\t\tbtrfsic_release_block_ctx(&block_ctx);\n\t}\n\ncontinue_loop:\n\tBUG_ON(!processed_len);\n\tdev_bytenr += processed_len;\n\tmapped_datav += processed_len >> PAGE_CACHE_SHIFT;\n\tnum_pages -= processed_len >> PAGE_CACHE_SHIFT;\n\tgoto again;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "mapped_datav"
          ],
          "line": 3006
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kunmap",
          "args": [
            "bio->bi_io_vec[i].bv_page"
          ],
          "line": 3004
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmap",
          "args": [
            "bio->bi_io_vec[i].bv_page"
          ],
          "line": 3000
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "bio->bi_io_vec[i].bv_len != PAGE_CACHE_SIZE"
          ],
          "line": 2999
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(*mapped_datav) * bio->bi_vcnt",
            "GFP_NOFS"
          ],
          "line": 2993
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfsic_dev_state_lookup",
          "args": [
            "bio->bi_bdev"
          ],
          "line": 2973
        },
        "resolved": true,
        "details": {
          "function_name": "btrfsic_dev_state_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/check-integrity.c",
          "lines": "2890-2898",
          "snippet": "static struct btrfsic_dev_state *btrfsic_dev_state_lookup(\n\t\tstruct block_device *bdev)\n{\n\tstruct btrfsic_dev_state *ds;\n\n\tds = btrfsic_dev_state_hashtable_lookup(bdev,\n\t\t\t\t\t\t&btrfsic_dev_state_hashtable);\n\treturn ds;\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"extent_io.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/genhd.h>",
            "#include <linux/mutex.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void btrfsic_dev_state_init(struct btrfsic_dev_state *ds);",
            "static void btrfsic_dev_state_free(struct btrfsic_dev_state *ds);",
            "static void btrfsic_dev_state_hashtable_remove(struct btrfsic_dev_state *ds);",
            "static struct btrfsic_dev_state *btrfsic_dev_state_lookup(\n\t\tstruct block_device *bdev);",
            "static struct btrfsic_dev_state_hashtable btrfsic_dev_state_hashtable;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"extent_io.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n#include <linux/blkdev.h>\n#include <linux/genhd.h>\n#include <linux/mutex.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic void btrfsic_dev_state_init(struct btrfsic_dev_state *ds);\nstatic void btrfsic_dev_state_free(struct btrfsic_dev_state *ds);\nstatic void btrfsic_dev_state_hashtable_remove(struct btrfsic_dev_state *ds);\nstatic struct btrfsic_dev_state *btrfsic_dev_state_lookup(\n\t\tstruct block_device *bdev);\nstatic struct btrfsic_dev_state_hashtable btrfsic_dev_state_hashtable;\n\nstatic struct btrfsic_dev_state *btrfsic_dev_state_lookup(\n\t\tstruct block_device *bdev)\n{\n\tstruct btrfsic_dev_state *ds;\n\n\tds = btrfsic_dev_state_hashtable_lookup(bdev,\n\t\t\t\t\t\t&btrfsic_dev_state_hashtable);\n\treturn ds;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&btrfsic_mutex"
          ],
          "line": 2970
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"extent_io.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n#include <linux/blkdev.h>\n#include <linux/genhd.h>\n#include <linux/mutex.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\n#define BTRFSIC_PRINT_MASK_SUBMIT_BIO_BH_VERBOSE\t\t0x00002000\n#define BTRFSIC_PRINT_MASK_VERBOSE\t\t\t\t0x00000040\n#define BTRFSIC_PRINT_MASK_SUBMIT_BIO_BH\t\t\t0x00000010\n\nstatic void btrfsic_block_link_init(struct btrfsic_block_link *n);\nstatic void btrfsic_block_link_free(struct btrfsic_block_link *n);\nstatic void btrfsic_read_from_block_data(\n\tstruct btrfsic_block_data_ctx *block_ctx,\n\tvoid *dst, u32 offset, size_t len);\nstatic void btrfsic_dump_database(struct btrfsic_state *state);\nstatic void btrfsic_process_written_block(struct btrfsic_dev_state *dev_state,\n\t\t\t\t\t  u64 dev_bytenr, char **mapped_datav,\n\t\t\t\t\t  unsigned int num_pages,\n\t\t\t\t\t  struct bio *bio, int *bio_is_patched,\n\t\t\t\t\t  struct buffer_head *bh,\n\t\t\t\t\t  int submit_bio_bh_rw);\nstatic char btrfsic_get_block_type(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block *block);\nstatic void btrfsic_dump_tree(const struct btrfsic_state *state);\nstatic struct btrfsic_dev_state *btrfsic_dev_state_lookup(\n\t\tstruct block_device *bdev);\nstatic void btrfsic_cmp_log_and_dev_bytenr(struct btrfsic_state *state,\n\t\t\t\t\t   u64 bytenr,\n\t\t\t\t\t   struct btrfsic_dev_state *dev_state,\n\t\t\t\t\t   u64 dev_bytenr);\nstatic struct mutex btrfsic_mutex;\nstatic int btrfsic_is_initialized;\n\nstatic void __btrfsic_submit_bio(int rw, struct bio *bio)\n{\n\tstruct btrfsic_dev_state *dev_state;\n\n\tif (!btrfsic_is_initialized)\n\t\treturn;\n\n\tmutex_lock(&btrfsic_mutex);\n\t/* since btrfsic_submit_bio() is also called before\n\t * btrfsic_mount(), this might return NULL */\n\tdev_state = btrfsic_dev_state_lookup(bio->bi_bdev);\n\tif (NULL != dev_state &&\n\t    (rw & WRITE) && NULL != bio->bi_io_vec) {\n\t\tunsigned int i;\n\t\tu64 dev_bytenr;\n\t\tu64 cur_bytenr;\n\t\tint bio_is_patched;\n\t\tchar **mapped_datav;\n\n\t\tdev_bytenr = 512 * bio->bi_iter.bi_sector;\n\t\tbio_is_patched = 0;\n\t\tif (dev_state->state->print_mask &\n\t\t    BTRFSIC_PRINT_MASK_SUBMIT_BIO_BH)\n\t\t\tprintk(KERN_INFO\n\t\t\t       \"submit_bio(rw=0x%x, bi_vcnt=%u,\"\n\t\t\t       \" bi_sector=%llu (bytenr %llu), bi_bdev=%p)\\n\",\n\t\t\t       rw, bio->bi_vcnt,\n\t\t\t       (unsigned long long)bio->bi_iter.bi_sector,\n\t\t\t       dev_bytenr, bio->bi_bdev);\n\n\t\tmapped_datav = kmalloc(sizeof(*mapped_datav) * bio->bi_vcnt,\n\t\t\t\t       GFP_NOFS);\n\t\tif (!mapped_datav)\n\t\t\tgoto leave;\n\t\tcur_bytenr = dev_bytenr;\n\t\tfor (i = 0; i < bio->bi_vcnt; i++) {\n\t\t\tBUG_ON(bio->bi_io_vec[i].bv_len != PAGE_CACHE_SIZE);\n\t\t\tmapped_datav[i] = kmap(bio->bi_io_vec[i].bv_page);\n\t\t\tif (!mapped_datav[i]) {\n\t\t\t\twhile (i > 0) {\n\t\t\t\t\ti--;\n\t\t\t\t\tkunmap(bio->bi_io_vec[i].bv_page);\n\t\t\t\t}\n\t\t\t\tkfree(mapped_datav);\n\t\t\t\tgoto leave;\n\t\t\t}\n\t\t\tif (dev_state->state->print_mask &\n\t\t\t    BTRFSIC_PRINT_MASK_SUBMIT_BIO_BH_VERBOSE)\n\t\t\t\tprintk(KERN_INFO\n\t\t\t\t       \"#%u: bytenr=%llu, len=%u, offset=%u\\n\",\n\t\t\t\t       i, cur_bytenr, bio->bi_io_vec[i].bv_len,\n\t\t\t\t       bio->bi_io_vec[i].bv_offset);\n\t\t\tcur_bytenr += bio->bi_io_vec[i].bv_len;\n\t\t}\n\t\tbtrfsic_process_written_block(dev_state, dev_bytenr,\n\t\t\t\t\t      mapped_datav, bio->bi_vcnt,\n\t\t\t\t\t      bio, &bio_is_patched,\n\t\t\t\t\t      NULL, rw);\n\t\twhile (i > 0) {\n\t\t\ti--;\n\t\t\tkunmap(bio->bi_io_vec[i].bv_page);\n\t\t}\n\t\tkfree(mapped_datav);\n\t} else if (NULL != dev_state && (rw & REQ_FLUSH)) {\n\t\tif (dev_state->state->print_mask &\n\t\t    BTRFSIC_PRINT_MASK_SUBMIT_BIO_BH)\n\t\t\tprintk(KERN_INFO\n\t\t\t       \"submit_bio(rw=0x%x FLUSH, bdev=%p)\\n\",\n\t\t\t       rw, bio->bi_bdev);\n\t\tif (!dev_state->dummy_block_for_bio_bh_flush.is_iodone) {\n\t\t\tif ((dev_state->state->print_mask &\n\t\t\t     (BTRFSIC_PRINT_MASK_SUBMIT_BIO_BH |\n\t\t\t      BTRFSIC_PRINT_MASK_VERBOSE)))\n\t\t\t\tprintk(KERN_INFO\n\t\t\t\t       \"btrfsic_submit_bio(%s) with FLUSH\"\n\t\t\t\t       \" but dummy block already in use\"\n\t\t\t\t       \" (ignored)!\\n\",\n\t\t\t\t       dev_state->name);\n\t\t} else {\n\t\t\tstruct btrfsic_block *const block =\n\t\t\t\t&dev_state->dummy_block_for_bio_bh_flush;\n\n\t\t\tblock->is_iodone = 0;\n\t\t\tblock->never_written = 0;\n\t\t\tblock->iodone_w_error = 0;\n\t\t\tblock->flush_gen = dev_state->last_flush_gen + 1;\n\t\t\tblock->submit_bio_bh_rw = rw;\n\t\t\tblock->orig_bio_bh_private = bio->bi_private;\n\t\t\tblock->orig_bio_bh_end_io.bio = bio->bi_end_io;\n\t\t\tblock->next_in_same_bio = NULL;\n\t\t\tbio->bi_private = block;\n\t\t\tbio->bi_end_io = btrfsic_bio_end_io;\n\t\t}\n\t}\nleave:\n\tmutex_unlock(&btrfsic_mutex);\n}"
  },
  {
    "function_name": "btrfsic_submit_bh",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/check-integrity.c",
    "lines": "2900-2961",
    "snippet": "int btrfsic_submit_bh(int rw, struct buffer_head *bh)\n{\n\tstruct btrfsic_dev_state *dev_state;\n\n\tif (!btrfsic_is_initialized)\n\t\treturn submit_bh(rw, bh);\n\n\tmutex_lock(&btrfsic_mutex);\n\t/* since btrfsic_submit_bh() might also be called before\n\t * btrfsic_mount(), this might return NULL */\n\tdev_state = btrfsic_dev_state_lookup(bh->b_bdev);\n\n\t/* Only called to write the superblock (incl. FLUSH/FUA) */\n\tif (NULL != dev_state &&\n\t    (rw & WRITE) && bh->b_size > 0) {\n\t\tu64 dev_bytenr;\n\n\t\tdev_bytenr = 4096 * bh->b_blocknr;\n\t\tif (dev_state->state->print_mask &\n\t\t    BTRFSIC_PRINT_MASK_SUBMIT_BIO_BH)\n\t\t\tprintk(KERN_INFO\n\t\t\t       \"submit_bh(rw=0x%x, blocknr=%llu (bytenr %llu),\"\n\t\t\t       \" size=%zu, data=%p, bdev=%p)\\n\",\n\t\t\t       rw, (unsigned long long)bh->b_blocknr,\n\t\t\t       dev_bytenr, bh->b_size, bh->b_data, bh->b_bdev);\n\t\tbtrfsic_process_written_block(dev_state, dev_bytenr,\n\t\t\t\t\t      &bh->b_data, 1, NULL,\n\t\t\t\t\t      NULL, bh, rw);\n\t} else if (NULL != dev_state && (rw & REQ_FLUSH)) {\n\t\tif (dev_state->state->print_mask &\n\t\t    BTRFSIC_PRINT_MASK_SUBMIT_BIO_BH)\n\t\t\tprintk(KERN_INFO\n\t\t\t       \"submit_bh(rw=0x%x FLUSH, bdev=%p)\\n\",\n\t\t\t       rw, bh->b_bdev);\n\t\tif (!dev_state->dummy_block_for_bio_bh_flush.is_iodone) {\n\t\t\tif ((dev_state->state->print_mask &\n\t\t\t     (BTRFSIC_PRINT_MASK_SUBMIT_BIO_BH |\n\t\t\t      BTRFSIC_PRINT_MASK_VERBOSE)))\n\t\t\t\tprintk(KERN_INFO\n\t\t\t\t       \"btrfsic_submit_bh(%s) with FLUSH\"\n\t\t\t\t       \" but dummy block already in use\"\n\t\t\t\t       \" (ignored)!\\n\",\n\t\t\t\t       dev_state->name);\n\t\t} else {\n\t\t\tstruct btrfsic_block *const block =\n\t\t\t\t&dev_state->dummy_block_for_bio_bh_flush;\n\n\t\t\tblock->is_iodone = 0;\n\t\t\tblock->never_written = 0;\n\t\t\tblock->iodone_w_error = 0;\n\t\t\tblock->flush_gen = dev_state->last_flush_gen + 1;\n\t\t\tblock->submit_bio_bh_rw = rw;\n\t\t\tblock->orig_bio_bh_private = bh->b_private;\n\t\t\tblock->orig_bio_bh_end_io.bh = bh->b_end_io;\n\t\t\tblock->next_in_same_bio = NULL;\n\t\t\tbh->b_private = block;\n\t\t\tbh->b_end_io = btrfsic_bh_end_io;\n\t\t}\n\t}\n\tmutex_unlock(&btrfsic_mutex);\n\treturn submit_bh(rw, bh);\n}",
    "includes": [
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"volumes.h\"",
      "#include \"extent_io.h\"",
      "#include \"transaction.h\"",
      "#include \"hash.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/genhd.h>",
      "#include <linux/mutex.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [
      "#define BTRFSIC_PRINT_MASK_VERBOSE\t\t\t\t0x00000040",
      "#define BTRFSIC_PRINT_MASK_SUBMIT_BIO_BH\t\t\t0x00000010"
    ],
    "globals_used": [
      "static void btrfsic_block_link_init(struct btrfsic_block_link *n);",
      "static void btrfsic_block_link_free(struct btrfsic_block_link *n);",
      "static void btrfsic_dump_database(struct btrfsic_state *state);",
      "static void btrfsic_process_written_block(struct btrfsic_dev_state *dev_state,\n\t\t\t\t\t  u64 dev_bytenr, char **mapped_datav,\n\t\t\t\t\t  unsigned int num_pages,\n\t\t\t\t\t  struct bio *bio, int *bio_is_patched,\n\t\t\t\t\t  struct buffer_head *bh,\n\t\t\t\t\t  int submit_bio_bh_rw);",
      "static char btrfsic_get_block_type(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block *block);",
      "static void btrfsic_dump_tree(const struct btrfsic_state *state);",
      "static struct btrfsic_dev_state *btrfsic_dev_state_lookup(\n\t\tstruct block_device *bdev);",
      "static void btrfsic_cmp_log_and_dev_bytenr(struct btrfsic_state *state,\n\t\t\t\t\t   u64 bytenr,\n\t\t\t\t\t   struct btrfsic_dev_state *dev_state,\n\t\t\t\t\t   u64 dev_bytenr);",
      "static struct mutex btrfsic_mutex;",
      "static int btrfsic_is_initialized;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "submit_bh",
          "args": [
            "rw",
            "bh"
          ],
          "line": 2960
        },
        "resolved": true,
        "details": {
          "function_name": "btrfsic_submit_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/check-integrity.c",
          "lines": "2900-2961",
          "snippet": "int btrfsic_submit_bh(int rw, struct buffer_head *bh)\n{\n\tstruct btrfsic_dev_state *dev_state;\n\n\tif (!btrfsic_is_initialized)\n\t\treturn submit_bh(rw, bh);\n\n\tmutex_lock(&btrfsic_mutex);\n\t/* since btrfsic_submit_bh() might also be called before\n\t * btrfsic_mount(), this might return NULL */\n\tdev_state = btrfsic_dev_state_lookup(bh->b_bdev);\n\n\t/* Only called to write the superblock (incl. FLUSH/FUA) */\n\tif (NULL != dev_state &&\n\t    (rw & WRITE) && bh->b_size > 0) {\n\t\tu64 dev_bytenr;\n\n\t\tdev_bytenr = 4096 * bh->b_blocknr;\n\t\tif (dev_state->state->print_mask &\n\t\t    BTRFSIC_PRINT_MASK_SUBMIT_BIO_BH)\n\t\t\tprintk(KERN_INFO\n\t\t\t       \"submit_bh(rw=0x%x, blocknr=%llu (bytenr %llu),\"\n\t\t\t       \" size=%zu, data=%p, bdev=%p)\\n\",\n\t\t\t       rw, (unsigned long long)bh->b_blocknr,\n\t\t\t       dev_bytenr, bh->b_size, bh->b_data, bh->b_bdev);\n\t\tbtrfsic_process_written_block(dev_state, dev_bytenr,\n\t\t\t\t\t      &bh->b_data, 1, NULL,\n\t\t\t\t\t      NULL, bh, rw);\n\t} else if (NULL != dev_state && (rw & REQ_FLUSH)) {\n\t\tif (dev_state->state->print_mask &\n\t\t    BTRFSIC_PRINT_MASK_SUBMIT_BIO_BH)\n\t\t\tprintk(KERN_INFO\n\t\t\t       \"submit_bh(rw=0x%x FLUSH, bdev=%p)\\n\",\n\t\t\t       rw, bh->b_bdev);\n\t\tif (!dev_state->dummy_block_for_bio_bh_flush.is_iodone) {\n\t\t\tif ((dev_state->state->print_mask &\n\t\t\t     (BTRFSIC_PRINT_MASK_SUBMIT_BIO_BH |\n\t\t\t      BTRFSIC_PRINT_MASK_VERBOSE)))\n\t\t\t\tprintk(KERN_INFO\n\t\t\t\t       \"btrfsic_submit_bh(%s) with FLUSH\"\n\t\t\t\t       \" but dummy block already in use\"\n\t\t\t\t       \" (ignored)!\\n\",\n\t\t\t\t       dev_state->name);\n\t\t} else {\n\t\t\tstruct btrfsic_block *const block =\n\t\t\t\t&dev_state->dummy_block_for_bio_bh_flush;\n\n\t\t\tblock->is_iodone = 0;\n\t\t\tblock->never_written = 0;\n\t\t\tblock->iodone_w_error = 0;\n\t\t\tblock->flush_gen = dev_state->last_flush_gen + 1;\n\t\t\tblock->submit_bio_bh_rw = rw;\n\t\t\tblock->orig_bio_bh_private = bh->b_private;\n\t\t\tblock->orig_bio_bh_end_io.bh = bh->b_end_io;\n\t\t\tblock->next_in_same_bio = NULL;\n\t\t\tbh->b_private = block;\n\t\t\tbh->b_end_io = btrfsic_bh_end_io;\n\t\t}\n\t}\n\tmutex_unlock(&btrfsic_mutex);\n\treturn submit_bh(rw, bh);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&btrfsic_mutex"
          ],
          "line": 2959
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_INFO\n\t\t\t\t       \"btrfsic_submit_bh(%s) with FLUSH\"\n\t\t\t\t       \" but dummy block already in use\"\n\t\t\t\t       \" (ignored)!\\n\"",
            "dev_state->name"
          ],
          "line": 2938
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/super.c",
          "lines": "186-213",
          "snippet": "void btrfs_printk(const struct btrfs_fs_info *fs_info, const char *fmt, ...)\n{\n\tstruct super_block *sb = fs_info->sb;\n\tchar lvl[4];\n\tstruct va_format vaf;\n\tva_list args;\n\tconst char *type = logtypes[4];\n\tint kern_level;\n\n\tva_start(args, fmt);\n\n\tkern_level = printk_get_level(fmt);\n\tif (kern_level) {\n\t\tsize_t size = printk_skip_level(fmt) - fmt;\n\t\tmemcpy(lvl, fmt,  size);\n\t\tlvl[size] = '\\0';\n\t\tfmt += size;\n\t\ttype = logtypes[kern_level - '0'];\n\t} else\n\t\t*lvl = '\\0';\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sBTRFS %s (device %s): %pV\\n\", lvl, type, sb->s_id, &vaf);\n\n\tva_end(args);\n}",
          "includes": [
            "#include <trace/events/btrfs.h>",
            "#include \"qgroup.h\"",
            "#include \"tests/btrfs-tests.h\"",
            "#include \"backref.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"compression.h\"",
            "#include \"export.h\"",
            "#include \"volumes.h\"",
            "#include \"xattr.h\"",
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/slab.h>",
            "#include <linux/magic.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/namei.h>",
            "#include <linux/ctype.h>",
            "#include <linux/parser.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/btrfs.h>\n#include \"qgroup.h\"\n#include \"tests/btrfs-tests.h\"\n#include \"backref.h\"\n#include \"free-space-cache.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"compression.h\"\n#include \"export.h\"\n#include \"volumes.h\"\n#include \"xattr.h\"\n#include \"props.h\"\n#include \"hash.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include \"delayed-inode.h\"\n#include <linux/btrfs.h>\n#include <linux/ratelimit.h>\n#include <linux/cleancache.h>\n#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/miscdevice.h>\n#include <linux/namei.h>\n#include <linux/ctype.h>\n#include <linux/parser.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n\nvoid btrfs_printk(const struct btrfs_fs_info *fs_info, const char *fmt, ...)\n{\n\tstruct super_block *sb = fs_info->sb;\n\tchar lvl[4];\n\tstruct va_format vaf;\n\tva_list args;\n\tconst char *type = logtypes[4];\n\tint kern_level;\n\n\tva_start(args, fmt);\n\n\tkern_level = printk_get_level(fmt);\n\tif (kern_level) {\n\t\tsize_t size = printk_skip_level(fmt) - fmt;\n\t\tmemcpy(lvl, fmt,  size);\n\t\tlvl[size] = '\\0';\n\t\tfmt += size;\n\t\ttype = logtypes[kern_level - '0'];\n\t} else\n\t\t*lvl = '\\0';\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sBTRFS %s (device %s): %pV\\n\", lvl, type, sb->s_id, &vaf);\n\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfsic_process_written_block",
          "args": [
            "dev_state",
            "dev_bytenr",
            "&bh->b_data",
            "1",
            "NULL",
            "NULL",
            "bh",
            "rw"
          ],
          "line": 2925
        },
        "resolved": true,
        "details": {
          "function_name": "btrfsic_process_written_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/check-integrity.c",
          "lines": "1818-2208",
          "snippet": "static void btrfsic_process_written_block(struct btrfsic_dev_state *dev_state,\n\t\t\t\t\t  u64 dev_bytenr, char **mapped_datav,\n\t\t\t\t\t  unsigned int num_pages,\n\t\t\t\t\t  struct bio *bio, int *bio_is_patched,\n\t\t\t\t\t  struct buffer_head *bh,\n\t\t\t\t\t  int submit_bio_bh_rw)\n{\n\tint is_metadata;\n\tstruct btrfsic_block *block;\n\tstruct btrfsic_block_data_ctx block_ctx;\n\tint ret;\n\tstruct btrfsic_state *state = dev_state->state;\n\tstruct block_device *bdev = dev_state->bdev;\n\tunsigned int processed_len;\n\n\tif (NULL != bio_is_patched)\n\t\t*bio_is_patched = 0;\n\nagain:\n\tif (num_pages == 0)\n\t\treturn;\n\n\tprocessed_len = 0;\n\tis_metadata = (0 == btrfsic_test_for_metadata(state, mapped_datav,\n\t\t\t\t\t\t      num_pages));\n\n\tblock = btrfsic_block_hashtable_lookup(bdev, dev_bytenr,\n\t\t\t\t\t       &state->block_hashtable);\n\tif (NULL != block) {\n\t\tu64 bytenr = 0;\n\t\tstruct list_head *elem_ref_to;\n\t\tstruct list_head *tmp_ref_to;\n\n\t\tif (block->is_superblock) {\n\t\t\tbytenr = btrfs_super_bytenr((struct btrfs_super_block *)\n\t\t\t\t\t\t    mapped_datav[0]);\n\t\t\tif (num_pages * PAGE_CACHE_SIZE <\n\t\t\t    BTRFS_SUPER_INFO_SIZE) {\n\t\t\t\tprintk(KERN_INFO\n\t\t\t\t       \"btrfsic: cannot work with too short bios!\\n\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tis_metadata = 1;\n\t\t\tBUG_ON(BTRFS_SUPER_INFO_SIZE & (PAGE_CACHE_SIZE - 1));\n\t\t\tprocessed_len = BTRFS_SUPER_INFO_SIZE;\n\t\t\tif (state->print_mask &\n\t\t\t    BTRFSIC_PRINT_MASK_TREE_BEFORE_SB_WRITE) {\n\t\t\t\tprintk(KERN_INFO\n\t\t\t\t       \"[before new superblock is written]:\\n\");\n\t\t\t\tbtrfsic_dump_tree_sub(state, block, 0);\n\t\t\t}\n\t\t}\n\t\tif (is_metadata) {\n\t\t\tif (!block->is_superblock) {\n\t\t\t\tif (num_pages * PAGE_CACHE_SIZE <\n\t\t\t\t    state->metablock_size) {\n\t\t\t\t\tprintk(KERN_INFO\n\t\t\t\t\t       \"btrfsic: cannot work with too short bios!\\n\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tprocessed_len = state->metablock_size;\n\t\t\t\tbytenr = btrfs_stack_header_bytenr(\n\t\t\t\t\t\t(struct btrfs_header *)\n\t\t\t\t\t\tmapped_datav[0]);\n\t\t\t\tbtrfsic_cmp_log_and_dev_bytenr(state, bytenr,\n\t\t\t\t\t\t\t       dev_state,\n\t\t\t\t\t\t\t       dev_bytenr);\n\t\t\t}\n\t\t\tif (state->print_mask & BTRFSIC_PRINT_MASK_VERBOSE) {\n\t\t\t\tif (block->logical_bytenr != bytenr &&\n\t\t\t\t    !(!block->is_metadata &&\n\t\t\t\t      block->logical_bytenr == 0))\n\t\t\t\t\tprintk(KERN_INFO\n\t\t\t\t\t       \"Written block @%llu (%s/%llu/%d) found in hash table, %c, bytenr mismatch (!= stored %llu).\\n\",\n\t\t\t\t\t       bytenr, dev_state->name,\n\t\t\t\t\t       dev_bytenr,\n\t\t\t\t\t       block->mirror_num,\n\t\t\t\t\t       btrfsic_get_block_type(state,\n\t\t\t\t\t\t\t\t      block),\n\t\t\t\t\t       block->logical_bytenr);\n\t\t\t\telse\n\t\t\t\t\tprintk(KERN_INFO\n\t\t\t\t\t       \"Written block @%llu (%s/%llu/%d) found in hash table, %c.\\n\",\n\t\t\t\t\t       bytenr, dev_state->name,\n\t\t\t\t\t       dev_bytenr, block->mirror_num,\n\t\t\t\t\t       btrfsic_get_block_type(state,\n\t\t\t\t\t\t\t\t      block));\n\t\t\t}\n\t\t\tblock->logical_bytenr = bytenr;\n\t\t} else {\n\t\t\tif (num_pages * PAGE_CACHE_SIZE <\n\t\t\t    state->datablock_size) {\n\t\t\t\tprintk(KERN_INFO\n\t\t\t\t       \"btrfsic: cannot work with too short bios!\\n\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tprocessed_len = state->datablock_size;\n\t\t\tbytenr = block->logical_bytenr;\n\t\t\tif (state->print_mask & BTRFSIC_PRINT_MASK_VERBOSE)\n\t\t\t\tprintk(KERN_INFO\n\t\t\t\t       \"Written block @%llu (%s/%llu/%d)\"\n\t\t\t\t       \" found in hash table, %c.\\n\",\n\t\t\t\t       bytenr, dev_state->name, dev_bytenr,\n\t\t\t\t       block->mirror_num,\n\t\t\t\t       btrfsic_get_block_type(state, block));\n\t\t}\n\n\t\tif (state->print_mask & BTRFSIC_PRINT_MASK_VERBOSE)\n\t\t\tprintk(KERN_INFO\n\t\t\t       \"ref_to_list: %cE, ref_from_list: %cE\\n\",\n\t\t\t       list_empty(&block->ref_to_list) ? ' ' : '!',\n\t\t\t       list_empty(&block->ref_from_list) ? ' ' : '!');\n\t\tif (btrfsic_is_block_ref_by_superblock(state, block, 0)) {\n\t\t\tprintk(KERN_INFO \"btrfs: attempt to overwrite %c-block\"\n\t\t\t       \" @%llu (%s/%llu/%d), old(gen=%llu,\"\n\t\t\t       \" objectid=%llu, type=%d, offset=%llu),\"\n\t\t\t       \" new(gen=%llu),\"\n\t\t\t       \" which is referenced by most recent superblock\"\n\t\t\t       \" (superblockgen=%llu)!\\n\",\n\t\t\t       btrfsic_get_block_type(state, block), bytenr,\n\t\t\t       dev_state->name, dev_bytenr, block->mirror_num,\n\t\t\t       block->generation,\n\t\t\t       btrfs_disk_key_objectid(&block->disk_key),\n\t\t\t       block->disk_key.type,\n\t\t\t       btrfs_disk_key_offset(&block->disk_key),\n\t\t\t       btrfs_stack_header_generation(\n\t\t\t\t       (struct btrfs_header *) mapped_datav[0]),\n\t\t\t       state->max_superblock_generation);\n\t\t\tbtrfsic_dump_tree(state);\n\t\t}\n\n\t\tif (!block->is_iodone && !block->never_written) {\n\t\t\tprintk(KERN_INFO \"btrfs: attempt to overwrite %c-block\"\n\t\t\t       \" @%llu (%s/%llu/%d), oldgen=%llu, newgen=%llu,\"\n\t\t\t       \" which is not yet iodone!\\n\",\n\t\t\t       btrfsic_get_block_type(state, block), bytenr,\n\t\t\t       dev_state->name, dev_bytenr, block->mirror_num,\n\t\t\t       block->generation,\n\t\t\t       btrfs_stack_header_generation(\n\t\t\t\t       (struct btrfs_header *)\n\t\t\t\t       mapped_datav[0]));\n\t\t\t/* it would not be safe to go on */\n\t\t\tbtrfsic_dump_tree(state);\n\t\t\tgoto continue_loop;\n\t\t}\n\n\t\t/*\n\t\t * Clear all references of this block. Do not free\n\t\t * the block itself even if is not referenced anymore\n\t\t * because it still carries valueable information\n\t\t * like whether it was ever written and IO completed.\n\t\t */\n\t\tlist_for_each_safe(elem_ref_to, tmp_ref_to,\n\t\t\t\t   &block->ref_to_list) {\n\t\t\tstruct btrfsic_block_link *const l =\n\t\t\t    list_entry(elem_ref_to,\n\t\t\t\t       struct btrfsic_block_link,\n\t\t\t\t       node_ref_to);\n\n\t\t\tif (state->print_mask & BTRFSIC_PRINT_MASK_VERBOSE)\n\t\t\t\tbtrfsic_print_rem_link(state, l);\n\t\t\tl->ref_cnt--;\n\t\t\tif (0 == l->ref_cnt) {\n\t\t\t\tlist_del(&l->node_ref_to);\n\t\t\t\tlist_del(&l->node_ref_from);\n\t\t\t\tbtrfsic_block_link_hashtable_remove(l);\n\t\t\t\tbtrfsic_block_link_free(l);\n\t\t\t}\n\t\t}\n\n\t\tblock_ctx.dev = dev_state;\n\t\tblock_ctx.dev_bytenr = dev_bytenr;\n\t\tblock_ctx.start = bytenr;\n\t\tblock_ctx.len = processed_len;\n\t\tblock_ctx.pagev = NULL;\n\t\tblock_ctx.mem_to_free = NULL;\n\t\tblock_ctx.datav = mapped_datav;\n\n\t\tif (is_metadata || state->include_extent_data) {\n\t\t\tblock->never_written = 0;\n\t\t\tblock->iodone_w_error = 0;\n\t\t\tif (NULL != bio) {\n\t\t\t\tblock->is_iodone = 0;\n\t\t\t\tBUG_ON(NULL == bio_is_patched);\n\t\t\t\tif (!*bio_is_patched) {\n\t\t\t\t\tblock->orig_bio_bh_private =\n\t\t\t\t\t    bio->bi_private;\n\t\t\t\t\tblock->orig_bio_bh_end_io.bio =\n\t\t\t\t\t    bio->bi_end_io;\n\t\t\t\t\tblock->next_in_same_bio = NULL;\n\t\t\t\t\tbio->bi_private = block;\n\t\t\t\t\tbio->bi_end_io = btrfsic_bio_end_io;\n\t\t\t\t\t*bio_is_patched = 1;\n\t\t\t\t} else {\n\t\t\t\t\tstruct btrfsic_block *chained_block =\n\t\t\t\t\t    (struct btrfsic_block *)\n\t\t\t\t\t    bio->bi_private;\n\n\t\t\t\t\tBUG_ON(NULL == chained_block);\n\t\t\t\t\tblock->orig_bio_bh_private =\n\t\t\t\t\t    chained_block->orig_bio_bh_private;\n\t\t\t\t\tblock->orig_bio_bh_end_io.bio =\n\t\t\t\t\t    chained_block->orig_bio_bh_end_io.\n\t\t\t\t\t    bio;\n\t\t\t\t\tblock->next_in_same_bio = chained_block;\n\t\t\t\t\tbio->bi_private = block;\n\t\t\t\t}\n\t\t\t} else if (NULL != bh) {\n\t\t\t\tblock->is_iodone = 0;\n\t\t\t\tblock->orig_bio_bh_private = bh->b_private;\n\t\t\t\tblock->orig_bio_bh_end_io.bh = bh->b_end_io;\n\t\t\t\tblock->next_in_same_bio = NULL;\n\t\t\t\tbh->b_private = block;\n\t\t\t\tbh->b_end_io = btrfsic_bh_end_io;\n\t\t\t} else {\n\t\t\t\tblock->is_iodone = 1;\n\t\t\t\tblock->orig_bio_bh_private = NULL;\n\t\t\t\tblock->orig_bio_bh_end_io.bio = NULL;\n\t\t\t\tblock->next_in_same_bio = NULL;\n\t\t\t}\n\t\t}\n\n\t\tblock->flush_gen = dev_state->last_flush_gen + 1;\n\t\tblock->submit_bio_bh_rw = submit_bio_bh_rw;\n\t\tif (is_metadata) {\n\t\t\tblock->logical_bytenr = bytenr;\n\t\t\tblock->is_metadata = 1;\n\t\t\tif (block->is_superblock) {\n\t\t\t\tBUG_ON(PAGE_CACHE_SIZE !=\n\t\t\t\t       BTRFS_SUPER_INFO_SIZE);\n\t\t\t\tret = btrfsic_process_written_superblock(\n\t\t\t\t\t\tstate,\n\t\t\t\t\t\tblock,\n\t\t\t\t\t\t(struct btrfs_super_block *)\n\t\t\t\t\t\tmapped_datav[0]);\n\t\t\t\tif (state->print_mask &\n\t\t\t\t    BTRFSIC_PRINT_MASK_TREE_AFTER_SB_WRITE) {\n\t\t\t\t\tprintk(KERN_INFO\n\t\t\t\t\t\"[after new superblock is written]:\\n\");\n\t\t\t\t\tbtrfsic_dump_tree_sub(state, block, 0);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tblock->mirror_num = 0;\t/* unknown */\n\t\t\t\tret = btrfsic_process_metablock(\n\t\t\t\t\t\tstate,\n\t\t\t\t\t\tblock,\n\t\t\t\t\t\t&block_ctx,\n\t\t\t\t\t\t0, 0);\n\t\t\t}\n\t\t\tif (ret)\n\t\t\t\tprintk(KERN_INFO\n\t\t\t\t       \"btrfsic: btrfsic_process_metablock\"\n\t\t\t\t       \"(root @%llu) failed!\\n\",\n\t\t\t\t       dev_bytenr);\n\t\t} else {\n\t\t\tblock->is_metadata = 0;\n\t\t\tblock->mirror_num = 0;\t/* unknown */\n\t\t\tblock->generation = BTRFSIC_GENERATION_UNKNOWN;\n\t\t\tif (!state->include_extent_data\n\t\t\t    && list_empty(&block->ref_from_list)) {\n\t\t\t\t/*\n\t\t\t\t * disk block is overwritten with extent\n\t\t\t\t * data (not meta data) and we are configured\n\t\t\t\t * to not include extent data: take the\n\t\t\t\t * chance and free the block's memory\n\t\t\t\t */\n\t\t\t\tbtrfsic_block_hashtable_remove(block);\n\t\t\t\tlist_del(&block->all_blocks_node);\n\t\t\t\tbtrfsic_block_free(block);\n\t\t\t}\n\t\t}\n\t\tbtrfsic_release_block_ctx(&block_ctx);\n\t} else {\n\t\t/* block has not been found in hash table */\n\t\tu64 bytenr;\n\n\t\tif (!is_metadata) {\n\t\t\tprocessed_len = state->datablock_size;\n\t\t\tif (state->print_mask & BTRFSIC_PRINT_MASK_VERBOSE)\n\t\t\t\tprintk(KERN_INFO \"Written block (%s/%llu/?)\"\n\t\t\t\t       \" !found in hash table, D.\\n\",\n\t\t\t\t       dev_state->name, dev_bytenr);\n\t\t\tif (!state->include_extent_data) {\n\t\t\t\t/* ignore that written D block */\n\t\t\t\tgoto continue_loop;\n\t\t\t}\n\n\t\t\t/* this is getting ugly for the\n\t\t\t * include_extent_data case... */\n\t\t\tbytenr = 0;\t/* unknown */\n\t\t} else {\n\t\t\tprocessed_len = state->metablock_size;\n\t\t\tbytenr = btrfs_stack_header_bytenr(\n\t\t\t\t\t(struct btrfs_header *)\n\t\t\t\t\tmapped_datav[0]);\n\t\t\tbtrfsic_cmp_log_and_dev_bytenr(state, bytenr, dev_state,\n\t\t\t\t\t\t       dev_bytenr);\n\t\t\tif (state->print_mask & BTRFSIC_PRINT_MASK_VERBOSE)\n\t\t\t\tprintk(KERN_INFO\n\t\t\t\t       \"Written block @%llu (%s/%llu/?)\"\n\t\t\t\t       \" !found in hash table, M.\\n\",\n\t\t\t\t       bytenr, dev_state->name, dev_bytenr);\n\t\t}\n\n\t\tblock_ctx.dev = dev_state;\n\t\tblock_ctx.dev_bytenr = dev_bytenr;\n\t\tblock_ctx.start = bytenr;\n\t\tblock_ctx.len = processed_len;\n\t\tblock_ctx.pagev = NULL;\n\t\tblock_ctx.mem_to_free = NULL;\n\t\tblock_ctx.datav = mapped_datav;\n\n\t\tblock = btrfsic_block_alloc();\n\t\tif (NULL == block) {\n\t\t\tprintk(KERN_INFO \"btrfsic: error, kmalloc failed!\\n\");\n\t\t\tbtrfsic_release_block_ctx(&block_ctx);\n\t\t\tgoto continue_loop;\n\t\t}\n\t\tblock->dev_state = dev_state;\n\t\tblock->dev_bytenr = dev_bytenr;\n\t\tblock->logical_bytenr = bytenr;\n\t\tblock->is_metadata = is_metadata;\n\t\tblock->never_written = 0;\n\t\tblock->iodone_w_error = 0;\n\t\tblock->mirror_num = 0;\t/* unknown */\n\t\tblock->flush_gen = dev_state->last_flush_gen + 1;\n\t\tblock->submit_bio_bh_rw = submit_bio_bh_rw;\n\t\tif (NULL != bio) {\n\t\t\tblock->is_iodone = 0;\n\t\t\tBUG_ON(NULL == bio_is_patched);\n\t\t\tif (!*bio_is_patched) {\n\t\t\t\tblock->orig_bio_bh_private = bio->bi_private;\n\t\t\t\tblock->orig_bio_bh_end_io.bio = bio->bi_end_io;\n\t\t\t\tblock->next_in_same_bio = NULL;\n\t\t\t\tbio->bi_private = block;\n\t\t\t\tbio->bi_end_io = btrfsic_bio_end_io;\n\t\t\t\t*bio_is_patched = 1;\n\t\t\t} else {\n\t\t\t\tstruct btrfsic_block *chained_block =\n\t\t\t\t    (struct btrfsic_block *)\n\t\t\t\t    bio->bi_private;\n\n\t\t\t\tBUG_ON(NULL == chained_block);\n\t\t\t\tblock->orig_bio_bh_private =\n\t\t\t\t    chained_block->orig_bio_bh_private;\n\t\t\t\tblock->orig_bio_bh_end_io.bio =\n\t\t\t\t    chained_block->orig_bio_bh_end_io.bio;\n\t\t\t\tblock->next_in_same_bio = chained_block;\n\t\t\t\tbio->bi_private = block;\n\t\t\t}\n\t\t} else if (NULL != bh) {\n\t\t\tblock->is_iodone = 0;\n\t\t\tblock->orig_bio_bh_private = bh->b_private;\n\t\t\tblock->orig_bio_bh_end_io.bh = bh->b_end_io;\n\t\t\tblock->next_in_same_bio = NULL;\n\t\t\tbh->b_private = block;\n\t\t\tbh->b_end_io = btrfsic_bh_end_io;\n\t\t} else {\n\t\t\tblock->is_iodone = 1;\n\t\t\tblock->orig_bio_bh_private = NULL;\n\t\t\tblock->orig_bio_bh_end_io.bio = NULL;\n\t\t\tblock->next_in_same_bio = NULL;\n\t\t}\n\t\tif (state->print_mask & BTRFSIC_PRINT_MASK_VERBOSE)\n\t\t\tprintk(KERN_INFO\n\t\t\t       \"New written %c-block @%llu (%s/%llu/%d)\\n\",\n\t\t\t       is_metadata ? 'M' : 'D',\n\t\t\t       block->logical_bytenr, block->dev_state->name,\n\t\t\t       block->dev_bytenr, block->mirror_num);\n\t\tlist_add(&block->all_blocks_node, &state->all_blocks_list);\n\t\tbtrfsic_block_hashtable_add(block, &state->block_hashtable);\n\n\t\tif (is_metadata) {\n\t\t\tret = btrfsic_process_metablock(state, block,\n\t\t\t\t\t\t\t&block_ctx, 0, 0);\n\t\t\tif (ret)\n\t\t\t\tprintk(KERN_INFO\n\t\t\t\t       \"btrfsic: process_metablock(root @%llu)\"\n\t\t\t\t       \" failed!\\n\",\n\t\t\t\t       dev_bytenr);\n\t\t}\n\t\tbtrfsic_release_block_ctx(&block_ctx);\n\t}\n\ncontinue_loop:\n\tBUG_ON(!processed_len);\n\tdev_bytenr += processed_len;\n\tmapped_datav += processed_len >> PAGE_CACHE_SHIFT;\n\tnum_pages -= processed_len >> PAGE_CACHE_SHIFT;\n\tgoto again;\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"extent_io.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/genhd.h>",
            "#include <linux/mutex.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define BTRFSIC_PRINT_MASK_VERBOSE\t\t\t\t0x00000040",
            "#define BTRFSIC_PRINT_MASK_TREE_BEFORE_SB_WRITE\t\t\t0x00000008",
            "#define BTRFSIC_PRINT_MASK_TREE_AFTER_SB_WRITE\t\t\t0x00000004",
            "#define BTRFSIC_GENERATION_UNKNOWN ((u64)-1)"
          ],
          "globals_used": [
            "static struct btrfsic_block *btrfsic_block_alloc(void);",
            "static void btrfsic_block_link_init(struct btrfsic_block_link *n);",
            "static void btrfsic_block_link_free(struct btrfsic_block_link *n);",
            "static void btrfsic_block_link_hashtable_remove(struct btrfsic_block_link *l);",
            "static void btrfsic_read_from_block_data(\n\tstruct btrfsic_block_data_ctx *block_ctx,\n\tvoid *dst, u32 offset, size_t len);",
            "static int btrfsic_map_block(struct btrfsic_state *state, u64 bytenr, u32 len,\n\t\t\t     struct btrfsic_block_data_ctx *block_ctx_out,\n\t\t\t     int mirror_num);",
            "static void btrfsic_release_block_ctx(struct btrfsic_block_data_ctx *block_ctx);",
            "static int btrfsic_read_block(struct btrfsic_state *state,\n\t\t\t      struct btrfsic_block_data_ctx *block_ctx);",
            "static void btrfsic_dump_database(struct btrfsic_state *state);",
            "static int btrfsic_test_for_metadata(struct btrfsic_state *state,\n\t\t\t\t     char **datav, unsigned int num_pages);",
            "static void btrfsic_process_written_block(struct btrfsic_dev_state *dev_state,\n\t\t\t\t\t  u64 dev_bytenr, char **mapped_datav,\n\t\t\t\t\t  unsigned int num_pages,\n\t\t\t\t\t  struct bio *bio, int *bio_is_patched,\n\t\t\t\t\t  struct buffer_head *bh,\n\t\t\t\t\t  int submit_bio_bh_rw);",
            "static void btrfsic_print_add_link(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block_link *l);",
            "static void btrfsic_print_rem_link(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block_link *l);",
            "static char btrfsic_get_block_type(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block *block);",
            "static void btrfsic_dump_tree(const struct btrfsic_state *state);",
            "static struct btrfsic_dev_state *btrfsic_dev_state_lookup(\n\t\tstruct block_device *bdev);",
            "static void btrfsic_cmp_log_and_dev_bytenr(struct btrfsic_state *state,\n\t\t\t\t\t   u64 bytenr,\n\t\t\t\t\t   struct btrfsic_dev_state *dev_state,\n\t\t\t\t\t   u64 dev_bytenr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"extent_io.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n#include <linux/blkdev.h>\n#include <linux/genhd.h>\n#include <linux/mutex.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\n#define BTRFSIC_PRINT_MASK_VERBOSE\t\t\t\t0x00000040\n#define BTRFSIC_PRINT_MASK_TREE_BEFORE_SB_WRITE\t\t\t0x00000008\n#define BTRFSIC_PRINT_MASK_TREE_AFTER_SB_WRITE\t\t\t0x00000004\n#define BTRFSIC_GENERATION_UNKNOWN ((u64)-1)\n\nstatic struct btrfsic_block *btrfsic_block_alloc(void);\nstatic void btrfsic_block_link_init(struct btrfsic_block_link *n);\nstatic void btrfsic_block_link_free(struct btrfsic_block_link *n);\nstatic void btrfsic_block_link_hashtable_remove(struct btrfsic_block_link *l);\nstatic void btrfsic_read_from_block_data(\n\tstruct btrfsic_block_data_ctx *block_ctx,\n\tvoid *dst, u32 offset, size_t len);\nstatic int btrfsic_map_block(struct btrfsic_state *state, u64 bytenr, u32 len,\n\t\t\t     struct btrfsic_block_data_ctx *block_ctx_out,\n\t\t\t     int mirror_num);\nstatic void btrfsic_release_block_ctx(struct btrfsic_block_data_ctx *block_ctx);\nstatic int btrfsic_read_block(struct btrfsic_state *state,\n\t\t\t      struct btrfsic_block_data_ctx *block_ctx);\nstatic void btrfsic_dump_database(struct btrfsic_state *state);\nstatic int btrfsic_test_for_metadata(struct btrfsic_state *state,\n\t\t\t\t     char **datav, unsigned int num_pages);\nstatic void btrfsic_process_written_block(struct btrfsic_dev_state *dev_state,\n\t\t\t\t\t  u64 dev_bytenr, char **mapped_datav,\n\t\t\t\t\t  unsigned int num_pages,\n\t\t\t\t\t  struct bio *bio, int *bio_is_patched,\n\t\t\t\t\t  struct buffer_head *bh,\n\t\t\t\t\t  int submit_bio_bh_rw);\nstatic void btrfsic_print_add_link(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block_link *l);\nstatic void btrfsic_print_rem_link(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block_link *l);\nstatic char btrfsic_get_block_type(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block *block);\nstatic void btrfsic_dump_tree(const struct btrfsic_state *state);\nstatic struct btrfsic_dev_state *btrfsic_dev_state_lookup(\n\t\tstruct block_device *bdev);\nstatic void btrfsic_cmp_log_and_dev_bytenr(struct btrfsic_state *state,\n\t\t\t\t\t   u64 bytenr,\n\t\t\t\t\t   struct btrfsic_dev_state *dev_state,\n\t\t\t\t\t   u64 dev_bytenr);\n\nstatic void btrfsic_process_written_block(struct btrfsic_dev_state *dev_state,\n\t\t\t\t\t  u64 dev_bytenr, char **mapped_datav,\n\t\t\t\t\t  unsigned int num_pages,\n\t\t\t\t\t  struct bio *bio, int *bio_is_patched,\n\t\t\t\t\t  struct buffer_head *bh,\n\t\t\t\t\t  int submit_bio_bh_rw)\n{\n\tint is_metadata;\n\tstruct btrfsic_block *block;\n\tstruct btrfsic_block_data_ctx block_ctx;\n\tint ret;\n\tstruct btrfsic_state *state = dev_state->state;\n\tstruct block_device *bdev = dev_state->bdev;\n\tunsigned int processed_len;\n\n\tif (NULL != bio_is_patched)\n\t\t*bio_is_patched = 0;\n\nagain:\n\tif (num_pages == 0)\n\t\treturn;\n\n\tprocessed_len = 0;\n\tis_metadata = (0 == btrfsic_test_for_metadata(state, mapped_datav,\n\t\t\t\t\t\t      num_pages));\n\n\tblock = btrfsic_block_hashtable_lookup(bdev, dev_bytenr,\n\t\t\t\t\t       &state->block_hashtable);\n\tif (NULL != block) {\n\t\tu64 bytenr = 0;\n\t\tstruct list_head *elem_ref_to;\n\t\tstruct list_head *tmp_ref_to;\n\n\t\tif (block->is_superblock) {\n\t\t\tbytenr = btrfs_super_bytenr((struct btrfs_super_block *)\n\t\t\t\t\t\t    mapped_datav[0]);\n\t\t\tif (num_pages * PAGE_CACHE_SIZE <\n\t\t\t    BTRFS_SUPER_INFO_SIZE) {\n\t\t\t\tprintk(KERN_INFO\n\t\t\t\t       \"btrfsic: cannot work with too short bios!\\n\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tis_metadata = 1;\n\t\t\tBUG_ON(BTRFS_SUPER_INFO_SIZE & (PAGE_CACHE_SIZE - 1));\n\t\t\tprocessed_len = BTRFS_SUPER_INFO_SIZE;\n\t\t\tif (state->print_mask &\n\t\t\t    BTRFSIC_PRINT_MASK_TREE_BEFORE_SB_WRITE) {\n\t\t\t\tprintk(KERN_INFO\n\t\t\t\t       \"[before new superblock is written]:\\n\");\n\t\t\t\tbtrfsic_dump_tree_sub(state, block, 0);\n\t\t\t}\n\t\t}\n\t\tif (is_metadata) {\n\t\t\tif (!block->is_superblock) {\n\t\t\t\tif (num_pages * PAGE_CACHE_SIZE <\n\t\t\t\t    state->metablock_size) {\n\t\t\t\t\tprintk(KERN_INFO\n\t\t\t\t\t       \"btrfsic: cannot work with too short bios!\\n\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tprocessed_len = state->metablock_size;\n\t\t\t\tbytenr = btrfs_stack_header_bytenr(\n\t\t\t\t\t\t(struct btrfs_header *)\n\t\t\t\t\t\tmapped_datav[0]);\n\t\t\t\tbtrfsic_cmp_log_and_dev_bytenr(state, bytenr,\n\t\t\t\t\t\t\t       dev_state,\n\t\t\t\t\t\t\t       dev_bytenr);\n\t\t\t}\n\t\t\tif (state->print_mask & BTRFSIC_PRINT_MASK_VERBOSE) {\n\t\t\t\tif (block->logical_bytenr != bytenr &&\n\t\t\t\t    !(!block->is_metadata &&\n\t\t\t\t      block->logical_bytenr == 0))\n\t\t\t\t\tprintk(KERN_INFO\n\t\t\t\t\t       \"Written block @%llu (%s/%llu/%d) found in hash table, %c, bytenr mismatch (!= stored %llu).\\n\",\n\t\t\t\t\t       bytenr, dev_state->name,\n\t\t\t\t\t       dev_bytenr,\n\t\t\t\t\t       block->mirror_num,\n\t\t\t\t\t       btrfsic_get_block_type(state,\n\t\t\t\t\t\t\t\t      block),\n\t\t\t\t\t       block->logical_bytenr);\n\t\t\t\telse\n\t\t\t\t\tprintk(KERN_INFO\n\t\t\t\t\t       \"Written block @%llu (%s/%llu/%d) found in hash table, %c.\\n\",\n\t\t\t\t\t       bytenr, dev_state->name,\n\t\t\t\t\t       dev_bytenr, block->mirror_num,\n\t\t\t\t\t       btrfsic_get_block_type(state,\n\t\t\t\t\t\t\t\t      block));\n\t\t\t}\n\t\t\tblock->logical_bytenr = bytenr;\n\t\t} else {\n\t\t\tif (num_pages * PAGE_CACHE_SIZE <\n\t\t\t    state->datablock_size) {\n\t\t\t\tprintk(KERN_INFO\n\t\t\t\t       \"btrfsic: cannot work with too short bios!\\n\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tprocessed_len = state->datablock_size;\n\t\t\tbytenr = block->logical_bytenr;\n\t\t\tif (state->print_mask & BTRFSIC_PRINT_MASK_VERBOSE)\n\t\t\t\tprintk(KERN_INFO\n\t\t\t\t       \"Written block @%llu (%s/%llu/%d)\"\n\t\t\t\t       \" found in hash table, %c.\\n\",\n\t\t\t\t       bytenr, dev_state->name, dev_bytenr,\n\t\t\t\t       block->mirror_num,\n\t\t\t\t       btrfsic_get_block_type(state, block));\n\t\t}\n\n\t\tif (state->print_mask & BTRFSIC_PRINT_MASK_VERBOSE)\n\t\t\tprintk(KERN_INFO\n\t\t\t       \"ref_to_list: %cE, ref_from_list: %cE\\n\",\n\t\t\t       list_empty(&block->ref_to_list) ? ' ' : '!',\n\t\t\t       list_empty(&block->ref_from_list) ? ' ' : '!');\n\t\tif (btrfsic_is_block_ref_by_superblock(state, block, 0)) {\n\t\t\tprintk(KERN_INFO \"btrfs: attempt to overwrite %c-block\"\n\t\t\t       \" @%llu (%s/%llu/%d), old(gen=%llu,\"\n\t\t\t       \" objectid=%llu, type=%d, offset=%llu),\"\n\t\t\t       \" new(gen=%llu),\"\n\t\t\t       \" which is referenced by most recent superblock\"\n\t\t\t       \" (superblockgen=%llu)!\\n\",\n\t\t\t       btrfsic_get_block_type(state, block), bytenr,\n\t\t\t       dev_state->name, dev_bytenr, block->mirror_num,\n\t\t\t       block->generation,\n\t\t\t       btrfs_disk_key_objectid(&block->disk_key),\n\t\t\t       block->disk_key.type,\n\t\t\t       btrfs_disk_key_offset(&block->disk_key),\n\t\t\t       btrfs_stack_header_generation(\n\t\t\t\t       (struct btrfs_header *) mapped_datav[0]),\n\t\t\t       state->max_superblock_generation);\n\t\t\tbtrfsic_dump_tree(state);\n\t\t}\n\n\t\tif (!block->is_iodone && !block->never_written) {\n\t\t\tprintk(KERN_INFO \"btrfs: attempt to overwrite %c-block\"\n\t\t\t       \" @%llu (%s/%llu/%d), oldgen=%llu, newgen=%llu,\"\n\t\t\t       \" which is not yet iodone!\\n\",\n\t\t\t       btrfsic_get_block_type(state, block), bytenr,\n\t\t\t       dev_state->name, dev_bytenr, block->mirror_num,\n\t\t\t       block->generation,\n\t\t\t       btrfs_stack_header_generation(\n\t\t\t\t       (struct btrfs_header *)\n\t\t\t\t       mapped_datav[0]));\n\t\t\t/* it would not be safe to go on */\n\t\t\tbtrfsic_dump_tree(state);\n\t\t\tgoto continue_loop;\n\t\t}\n\n\t\t/*\n\t\t * Clear all references of this block. Do not free\n\t\t * the block itself even if is not referenced anymore\n\t\t * because it still carries valueable information\n\t\t * like whether it was ever written and IO completed.\n\t\t */\n\t\tlist_for_each_safe(elem_ref_to, tmp_ref_to,\n\t\t\t\t   &block->ref_to_list) {\n\t\t\tstruct btrfsic_block_link *const l =\n\t\t\t    list_entry(elem_ref_to,\n\t\t\t\t       struct btrfsic_block_link,\n\t\t\t\t       node_ref_to);\n\n\t\t\tif (state->print_mask & BTRFSIC_PRINT_MASK_VERBOSE)\n\t\t\t\tbtrfsic_print_rem_link(state, l);\n\t\t\tl->ref_cnt--;\n\t\t\tif (0 == l->ref_cnt) {\n\t\t\t\tlist_del(&l->node_ref_to);\n\t\t\t\tlist_del(&l->node_ref_from);\n\t\t\t\tbtrfsic_block_link_hashtable_remove(l);\n\t\t\t\tbtrfsic_block_link_free(l);\n\t\t\t}\n\t\t}\n\n\t\tblock_ctx.dev = dev_state;\n\t\tblock_ctx.dev_bytenr = dev_bytenr;\n\t\tblock_ctx.start = bytenr;\n\t\tblock_ctx.len = processed_len;\n\t\tblock_ctx.pagev = NULL;\n\t\tblock_ctx.mem_to_free = NULL;\n\t\tblock_ctx.datav = mapped_datav;\n\n\t\tif (is_metadata || state->include_extent_data) {\n\t\t\tblock->never_written = 0;\n\t\t\tblock->iodone_w_error = 0;\n\t\t\tif (NULL != bio) {\n\t\t\t\tblock->is_iodone = 0;\n\t\t\t\tBUG_ON(NULL == bio_is_patched);\n\t\t\t\tif (!*bio_is_patched) {\n\t\t\t\t\tblock->orig_bio_bh_private =\n\t\t\t\t\t    bio->bi_private;\n\t\t\t\t\tblock->orig_bio_bh_end_io.bio =\n\t\t\t\t\t    bio->bi_end_io;\n\t\t\t\t\tblock->next_in_same_bio = NULL;\n\t\t\t\t\tbio->bi_private = block;\n\t\t\t\t\tbio->bi_end_io = btrfsic_bio_end_io;\n\t\t\t\t\t*bio_is_patched = 1;\n\t\t\t\t} else {\n\t\t\t\t\tstruct btrfsic_block *chained_block =\n\t\t\t\t\t    (struct btrfsic_block *)\n\t\t\t\t\t    bio->bi_private;\n\n\t\t\t\t\tBUG_ON(NULL == chained_block);\n\t\t\t\t\tblock->orig_bio_bh_private =\n\t\t\t\t\t    chained_block->orig_bio_bh_private;\n\t\t\t\t\tblock->orig_bio_bh_end_io.bio =\n\t\t\t\t\t    chained_block->orig_bio_bh_end_io.\n\t\t\t\t\t    bio;\n\t\t\t\t\tblock->next_in_same_bio = chained_block;\n\t\t\t\t\tbio->bi_private = block;\n\t\t\t\t}\n\t\t\t} else if (NULL != bh) {\n\t\t\t\tblock->is_iodone = 0;\n\t\t\t\tblock->orig_bio_bh_private = bh->b_private;\n\t\t\t\tblock->orig_bio_bh_end_io.bh = bh->b_end_io;\n\t\t\t\tblock->next_in_same_bio = NULL;\n\t\t\t\tbh->b_private = block;\n\t\t\t\tbh->b_end_io = btrfsic_bh_end_io;\n\t\t\t} else {\n\t\t\t\tblock->is_iodone = 1;\n\t\t\t\tblock->orig_bio_bh_private = NULL;\n\t\t\t\tblock->orig_bio_bh_end_io.bio = NULL;\n\t\t\t\tblock->next_in_same_bio = NULL;\n\t\t\t}\n\t\t}\n\n\t\tblock->flush_gen = dev_state->last_flush_gen + 1;\n\t\tblock->submit_bio_bh_rw = submit_bio_bh_rw;\n\t\tif (is_metadata) {\n\t\t\tblock->logical_bytenr = bytenr;\n\t\t\tblock->is_metadata = 1;\n\t\t\tif (block->is_superblock) {\n\t\t\t\tBUG_ON(PAGE_CACHE_SIZE !=\n\t\t\t\t       BTRFS_SUPER_INFO_SIZE);\n\t\t\t\tret = btrfsic_process_written_superblock(\n\t\t\t\t\t\tstate,\n\t\t\t\t\t\tblock,\n\t\t\t\t\t\t(struct btrfs_super_block *)\n\t\t\t\t\t\tmapped_datav[0]);\n\t\t\t\tif (state->print_mask &\n\t\t\t\t    BTRFSIC_PRINT_MASK_TREE_AFTER_SB_WRITE) {\n\t\t\t\t\tprintk(KERN_INFO\n\t\t\t\t\t\"[after new superblock is written]:\\n\");\n\t\t\t\t\tbtrfsic_dump_tree_sub(state, block, 0);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tblock->mirror_num = 0;\t/* unknown */\n\t\t\t\tret = btrfsic_process_metablock(\n\t\t\t\t\t\tstate,\n\t\t\t\t\t\tblock,\n\t\t\t\t\t\t&block_ctx,\n\t\t\t\t\t\t0, 0);\n\t\t\t}\n\t\t\tif (ret)\n\t\t\t\tprintk(KERN_INFO\n\t\t\t\t       \"btrfsic: btrfsic_process_metablock\"\n\t\t\t\t       \"(root @%llu) failed!\\n\",\n\t\t\t\t       dev_bytenr);\n\t\t} else {\n\t\t\tblock->is_metadata = 0;\n\t\t\tblock->mirror_num = 0;\t/* unknown */\n\t\t\tblock->generation = BTRFSIC_GENERATION_UNKNOWN;\n\t\t\tif (!state->include_extent_data\n\t\t\t    && list_empty(&block->ref_from_list)) {\n\t\t\t\t/*\n\t\t\t\t * disk block is overwritten with extent\n\t\t\t\t * data (not meta data) and we are configured\n\t\t\t\t * to not include extent data: take the\n\t\t\t\t * chance and free the block's memory\n\t\t\t\t */\n\t\t\t\tbtrfsic_block_hashtable_remove(block);\n\t\t\t\tlist_del(&block->all_blocks_node);\n\t\t\t\tbtrfsic_block_free(block);\n\t\t\t}\n\t\t}\n\t\tbtrfsic_release_block_ctx(&block_ctx);\n\t} else {\n\t\t/* block has not been found in hash table */\n\t\tu64 bytenr;\n\n\t\tif (!is_metadata) {\n\t\t\tprocessed_len = state->datablock_size;\n\t\t\tif (state->print_mask & BTRFSIC_PRINT_MASK_VERBOSE)\n\t\t\t\tprintk(KERN_INFO \"Written block (%s/%llu/?)\"\n\t\t\t\t       \" !found in hash table, D.\\n\",\n\t\t\t\t       dev_state->name, dev_bytenr);\n\t\t\tif (!state->include_extent_data) {\n\t\t\t\t/* ignore that written D block */\n\t\t\t\tgoto continue_loop;\n\t\t\t}\n\n\t\t\t/* this is getting ugly for the\n\t\t\t * include_extent_data case... */\n\t\t\tbytenr = 0;\t/* unknown */\n\t\t} else {\n\t\t\tprocessed_len = state->metablock_size;\n\t\t\tbytenr = btrfs_stack_header_bytenr(\n\t\t\t\t\t(struct btrfs_header *)\n\t\t\t\t\tmapped_datav[0]);\n\t\t\tbtrfsic_cmp_log_and_dev_bytenr(state, bytenr, dev_state,\n\t\t\t\t\t\t       dev_bytenr);\n\t\t\tif (state->print_mask & BTRFSIC_PRINT_MASK_VERBOSE)\n\t\t\t\tprintk(KERN_INFO\n\t\t\t\t       \"Written block @%llu (%s/%llu/?)\"\n\t\t\t\t       \" !found in hash table, M.\\n\",\n\t\t\t\t       bytenr, dev_state->name, dev_bytenr);\n\t\t}\n\n\t\tblock_ctx.dev = dev_state;\n\t\tblock_ctx.dev_bytenr = dev_bytenr;\n\t\tblock_ctx.start = bytenr;\n\t\tblock_ctx.len = processed_len;\n\t\tblock_ctx.pagev = NULL;\n\t\tblock_ctx.mem_to_free = NULL;\n\t\tblock_ctx.datav = mapped_datav;\n\n\t\tblock = btrfsic_block_alloc();\n\t\tif (NULL == block) {\n\t\t\tprintk(KERN_INFO \"btrfsic: error, kmalloc failed!\\n\");\n\t\t\tbtrfsic_release_block_ctx(&block_ctx);\n\t\t\tgoto continue_loop;\n\t\t}\n\t\tblock->dev_state = dev_state;\n\t\tblock->dev_bytenr = dev_bytenr;\n\t\tblock->logical_bytenr = bytenr;\n\t\tblock->is_metadata = is_metadata;\n\t\tblock->never_written = 0;\n\t\tblock->iodone_w_error = 0;\n\t\tblock->mirror_num = 0;\t/* unknown */\n\t\tblock->flush_gen = dev_state->last_flush_gen + 1;\n\t\tblock->submit_bio_bh_rw = submit_bio_bh_rw;\n\t\tif (NULL != bio) {\n\t\t\tblock->is_iodone = 0;\n\t\t\tBUG_ON(NULL == bio_is_patched);\n\t\t\tif (!*bio_is_patched) {\n\t\t\t\tblock->orig_bio_bh_private = bio->bi_private;\n\t\t\t\tblock->orig_bio_bh_end_io.bio = bio->bi_end_io;\n\t\t\t\tblock->next_in_same_bio = NULL;\n\t\t\t\tbio->bi_private = block;\n\t\t\t\tbio->bi_end_io = btrfsic_bio_end_io;\n\t\t\t\t*bio_is_patched = 1;\n\t\t\t} else {\n\t\t\t\tstruct btrfsic_block *chained_block =\n\t\t\t\t    (struct btrfsic_block *)\n\t\t\t\t    bio->bi_private;\n\n\t\t\t\tBUG_ON(NULL == chained_block);\n\t\t\t\tblock->orig_bio_bh_private =\n\t\t\t\t    chained_block->orig_bio_bh_private;\n\t\t\t\tblock->orig_bio_bh_end_io.bio =\n\t\t\t\t    chained_block->orig_bio_bh_end_io.bio;\n\t\t\t\tblock->next_in_same_bio = chained_block;\n\t\t\t\tbio->bi_private = block;\n\t\t\t}\n\t\t} else if (NULL != bh) {\n\t\t\tblock->is_iodone = 0;\n\t\t\tblock->orig_bio_bh_private = bh->b_private;\n\t\t\tblock->orig_bio_bh_end_io.bh = bh->b_end_io;\n\t\t\tblock->next_in_same_bio = NULL;\n\t\t\tbh->b_private = block;\n\t\t\tbh->b_end_io = btrfsic_bh_end_io;\n\t\t} else {\n\t\t\tblock->is_iodone = 1;\n\t\t\tblock->orig_bio_bh_private = NULL;\n\t\t\tblock->orig_bio_bh_end_io.bio = NULL;\n\t\t\tblock->next_in_same_bio = NULL;\n\t\t}\n\t\tif (state->print_mask & BTRFSIC_PRINT_MASK_VERBOSE)\n\t\t\tprintk(KERN_INFO\n\t\t\t       \"New written %c-block @%llu (%s/%llu/%d)\\n\",\n\t\t\t       is_metadata ? 'M' : 'D',\n\t\t\t       block->logical_bytenr, block->dev_state->name,\n\t\t\t       block->dev_bytenr, block->mirror_num);\n\t\tlist_add(&block->all_blocks_node, &state->all_blocks_list);\n\t\tbtrfsic_block_hashtable_add(block, &state->block_hashtable);\n\n\t\tif (is_metadata) {\n\t\t\tret = btrfsic_process_metablock(state, block,\n\t\t\t\t\t\t\t&block_ctx, 0, 0);\n\t\t\tif (ret)\n\t\t\t\tprintk(KERN_INFO\n\t\t\t\t       \"btrfsic: process_metablock(root @%llu)\"\n\t\t\t\t       \" failed!\\n\",\n\t\t\t\t       dev_bytenr);\n\t\t}\n\t\tbtrfsic_release_block_ctx(&block_ctx);\n\t}\n\ncontinue_loop:\n\tBUG_ON(!processed_len);\n\tdev_bytenr += processed_len;\n\tmapped_datav += processed_len >> PAGE_CACHE_SHIFT;\n\tnum_pages -= processed_len >> PAGE_CACHE_SHIFT;\n\tgoto again;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfsic_dev_state_lookup",
          "args": [
            "bh->b_bdev"
          ],
          "line": 2910
        },
        "resolved": true,
        "details": {
          "function_name": "btrfsic_dev_state_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/check-integrity.c",
          "lines": "2890-2898",
          "snippet": "static struct btrfsic_dev_state *btrfsic_dev_state_lookup(\n\t\tstruct block_device *bdev)\n{\n\tstruct btrfsic_dev_state *ds;\n\n\tds = btrfsic_dev_state_hashtable_lookup(bdev,\n\t\t\t\t\t\t&btrfsic_dev_state_hashtable);\n\treturn ds;\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"extent_io.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/genhd.h>",
            "#include <linux/mutex.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void btrfsic_dev_state_init(struct btrfsic_dev_state *ds);",
            "static void btrfsic_dev_state_free(struct btrfsic_dev_state *ds);",
            "static void btrfsic_dev_state_hashtable_remove(struct btrfsic_dev_state *ds);",
            "static struct btrfsic_dev_state *btrfsic_dev_state_lookup(\n\t\tstruct block_device *bdev);",
            "static struct btrfsic_dev_state_hashtable btrfsic_dev_state_hashtable;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"extent_io.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n#include <linux/blkdev.h>\n#include <linux/genhd.h>\n#include <linux/mutex.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic void btrfsic_dev_state_init(struct btrfsic_dev_state *ds);\nstatic void btrfsic_dev_state_free(struct btrfsic_dev_state *ds);\nstatic void btrfsic_dev_state_hashtable_remove(struct btrfsic_dev_state *ds);\nstatic struct btrfsic_dev_state *btrfsic_dev_state_lookup(\n\t\tstruct block_device *bdev);\nstatic struct btrfsic_dev_state_hashtable btrfsic_dev_state_hashtable;\n\nstatic struct btrfsic_dev_state *btrfsic_dev_state_lookup(\n\t\tstruct block_device *bdev)\n{\n\tstruct btrfsic_dev_state *ds;\n\n\tds = btrfsic_dev_state_hashtable_lookup(bdev,\n\t\t\t\t\t\t&btrfsic_dev_state_hashtable);\n\treturn ds;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&btrfsic_mutex"
          ],
          "line": 2907
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"extent_io.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n#include <linux/blkdev.h>\n#include <linux/genhd.h>\n#include <linux/mutex.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\n#define BTRFSIC_PRINT_MASK_VERBOSE\t\t\t\t0x00000040\n#define BTRFSIC_PRINT_MASK_SUBMIT_BIO_BH\t\t\t0x00000010\n\nstatic void btrfsic_block_link_init(struct btrfsic_block_link *n);\nstatic void btrfsic_block_link_free(struct btrfsic_block_link *n);\nstatic void btrfsic_dump_database(struct btrfsic_state *state);\nstatic void btrfsic_process_written_block(struct btrfsic_dev_state *dev_state,\n\t\t\t\t\t  u64 dev_bytenr, char **mapped_datav,\n\t\t\t\t\t  unsigned int num_pages,\n\t\t\t\t\t  struct bio *bio, int *bio_is_patched,\n\t\t\t\t\t  struct buffer_head *bh,\n\t\t\t\t\t  int submit_bio_bh_rw);\nstatic char btrfsic_get_block_type(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block *block);\nstatic void btrfsic_dump_tree(const struct btrfsic_state *state);\nstatic struct btrfsic_dev_state *btrfsic_dev_state_lookup(\n\t\tstruct block_device *bdev);\nstatic void btrfsic_cmp_log_and_dev_bytenr(struct btrfsic_state *state,\n\t\t\t\t\t   u64 bytenr,\n\t\t\t\t\t   struct btrfsic_dev_state *dev_state,\n\t\t\t\t\t   u64 dev_bytenr);\nstatic struct mutex btrfsic_mutex;\nstatic int btrfsic_is_initialized;\n\nint btrfsic_submit_bh(int rw, struct buffer_head *bh)\n{\n\tstruct btrfsic_dev_state *dev_state;\n\n\tif (!btrfsic_is_initialized)\n\t\treturn submit_bh(rw, bh);\n\n\tmutex_lock(&btrfsic_mutex);\n\t/* since btrfsic_submit_bh() might also be called before\n\t * btrfsic_mount(), this might return NULL */\n\tdev_state = btrfsic_dev_state_lookup(bh->b_bdev);\n\n\t/* Only called to write the superblock (incl. FLUSH/FUA) */\n\tif (NULL != dev_state &&\n\t    (rw & WRITE) && bh->b_size > 0) {\n\t\tu64 dev_bytenr;\n\n\t\tdev_bytenr = 4096 * bh->b_blocknr;\n\t\tif (dev_state->state->print_mask &\n\t\t    BTRFSIC_PRINT_MASK_SUBMIT_BIO_BH)\n\t\t\tprintk(KERN_INFO\n\t\t\t       \"submit_bh(rw=0x%x, blocknr=%llu (bytenr %llu),\"\n\t\t\t       \" size=%zu, data=%p, bdev=%p)\\n\",\n\t\t\t       rw, (unsigned long long)bh->b_blocknr,\n\t\t\t       dev_bytenr, bh->b_size, bh->b_data, bh->b_bdev);\n\t\tbtrfsic_process_written_block(dev_state, dev_bytenr,\n\t\t\t\t\t      &bh->b_data, 1, NULL,\n\t\t\t\t\t      NULL, bh, rw);\n\t} else if (NULL != dev_state && (rw & REQ_FLUSH)) {\n\t\tif (dev_state->state->print_mask &\n\t\t    BTRFSIC_PRINT_MASK_SUBMIT_BIO_BH)\n\t\t\tprintk(KERN_INFO\n\t\t\t       \"submit_bh(rw=0x%x FLUSH, bdev=%p)\\n\",\n\t\t\t       rw, bh->b_bdev);\n\t\tif (!dev_state->dummy_block_for_bio_bh_flush.is_iodone) {\n\t\t\tif ((dev_state->state->print_mask &\n\t\t\t     (BTRFSIC_PRINT_MASK_SUBMIT_BIO_BH |\n\t\t\t      BTRFSIC_PRINT_MASK_VERBOSE)))\n\t\t\t\tprintk(KERN_INFO\n\t\t\t\t       \"btrfsic_submit_bh(%s) with FLUSH\"\n\t\t\t\t       \" but dummy block already in use\"\n\t\t\t\t       \" (ignored)!\\n\",\n\t\t\t\t       dev_state->name);\n\t\t} else {\n\t\t\tstruct btrfsic_block *const block =\n\t\t\t\t&dev_state->dummy_block_for_bio_bh_flush;\n\n\t\t\tblock->is_iodone = 0;\n\t\t\tblock->never_written = 0;\n\t\t\tblock->iodone_w_error = 0;\n\t\t\tblock->flush_gen = dev_state->last_flush_gen + 1;\n\t\t\tblock->submit_bio_bh_rw = rw;\n\t\t\tblock->orig_bio_bh_private = bh->b_private;\n\t\t\tblock->orig_bio_bh_end_io.bh = bh->b_end_io;\n\t\t\tblock->next_in_same_bio = NULL;\n\t\t\tbh->b_private = block;\n\t\t\tbh->b_end_io = btrfsic_bh_end_io;\n\t\t}\n\t}\n\tmutex_unlock(&btrfsic_mutex);\n\treturn submit_bh(rw, bh);\n}"
  },
  {
    "function_name": "btrfsic_dev_state_lookup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/check-integrity.c",
    "lines": "2890-2898",
    "snippet": "static struct btrfsic_dev_state *btrfsic_dev_state_lookup(\n\t\tstruct block_device *bdev)\n{\n\tstruct btrfsic_dev_state *ds;\n\n\tds = btrfsic_dev_state_hashtable_lookup(bdev,\n\t\t\t\t\t\t&btrfsic_dev_state_hashtable);\n\treturn ds;\n}",
    "includes": [
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"volumes.h\"",
      "#include \"extent_io.h\"",
      "#include \"transaction.h\"",
      "#include \"hash.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/genhd.h>",
      "#include <linux/mutex.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void btrfsic_dev_state_init(struct btrfsic_dev_state *ds);",
      "static void btrfsic_dev_state_free(struct btrfsic_dev_state *ds);",
      "static void btrfsic_dev_state_hashtable_remove(struct btrfsic_dev_state *ds);",
      "static struct btrfsic_dev_state *btrfsic_dev_state_lookup(\n\t\tstruct block_device *bdev);",
      "static struct btrfsic_dev_state_hashtable btrfsic_dev_state_hashtable;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfsic_dev_state_hashtable_lookup",
          "args": [
            "bdev",
            "&btrfsic_dev_state_hashtable"
          ],
          "line": 2895
        },
        "resolved": true,
        "details": {
          "function_name": "btrfsic_dev_state_hashtable_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/check-integrity.c",
          "lines": "635-654",
          "snippet": "static struct btrfsic_dev_state *btrfsic_dev_state_hashtable_lookup(\n\t\tstruct block_device *bdev,\n\t\tstruct btrfsic_dev_state_hashtable *h)\n{\n\tconst unsigned int hashval =\n\t    (((unsigned int)((uintptr_t)bdev)) &\n\t     (BTRFSIC_DEV2STATE_HASHTABLE_SIZE - 1));\n\tstruct list_head *elem;\n\n\tlist_for_each(elem, h->table + hashval) {\n\t\tstruct btrfsic_dev_state *const ds =\n\t\t    list_entry(elem, struct btrfsic_dev_state,\n\t\t\t       collision_resolving_node);\n\n\t\tif (ds->bdev == bdev)\n\t\t\treturn ds;\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"extent_io.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/genhd.h>",
            "#include <linux/mutex.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define BTRFSIC_DEV2STATE_HASHTABLE_SIZE 0x100"
          ],
          "globals_used": [
            "static void btrfsic_dev_state_init(struct btrfsic_dev_state *ds);",
            "static void btrfsic_dev_state_free(struct btrfsic_dev_state *ds);",
            "static void btrfsic_block_hashtable_init(struct btrfsic_block_hashtable *h);",
            "static void btrfsic_block_hashtable_add(struct btrfsic_block *b,\n\t\t\t\t\tstruct btrfsic_block_hashtable *h);",
            "static struct btrfsic_block *btrfsic_block_hashtable_lookup(\n\t\tstruct block_device *bdev,\n\t\tu64 dev_bytenr,\n\t\tstruct btrfsic_block_hashtable *h);",
            "static void btrfsic_block_link_hashtable_init(\n\t\tstruct btrfsic_block_link_hashtable *h);",
            "static void btrfsic_block_link_hashtable_add(\n\t\tstruct btrfsic_block_link *l,\n\t\tstruct btrfsic_block_link_hashtable *h);",
            "static struct btrfsic_block_link *btrfsic_block_link_hashtable_lookup(\n\t\tstruct block_device *bdev_ref_to,\n\t\tu64 dev_bytenr_ref_to,\n\t\tstruct block_device *bdev_ref_from,\n\t\tu64 dev_bytenr_ref_from,\n\t\tstruct btrfsic_block_link_hashtable *h);",
            "static void btrfsic_dev_state_hashtable_init(\n\t\tstruct btrfsic_dev_state_hashtable *h);",
            "static void btrfsic_dev_state_hashtable_add(\n\t\tstruct btrfsic_dev_state *ds,\n\t\tstruct btrfsic_dev_state_hashtable *h);",
            "static void btrfsic_dev_state_hashtable_remove(struct btrfsic_dev_state *ds);",
            "static struct btrfsic_dev_state *btrfsic_dev_state_hashtable_lookup(\n\t\tstruct block_device *bdev,\n\t\tstruct btrfsic_dev_state_hashtable *h);",
            "static struct btrfsic_dev_state *btrfsic_dev_state_lookup(\n\t\tstruct block_device *bdev);",
            "static struct btrfsic_dev_state_hashtable btrfsic_dev_state_hashtable;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"extent_io.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n#include <linux/blkdev.h>\n#include <linux/genhd.h>\n#include <linux/mutex.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\n#define BTRFSIC_DEV2STATE_HASHTABLE_SIZE 0x100\n\nstatic void btrfsic_dev_state_init(struct btrfsic_dev_state *ds);\nstatic void btrfsic_dev_state_free(struct btrfsic_dev_state *ds);\nstatic void btrfsic_block_hashtable_init(struct btrfsic_block_hashtable *h);\nstatic void btrfsic_block_hashtable_add(struct btrfsic_block *b,\n\t\t\t\t\tstruct btrfsic_block_hashtable *h);\nstatic struct btrfsic_block *btrfsic_block_hashtable_lookup(\n\t\tstruct block_device *bdev,\n\t\tu64 dev_bytenr,\n\t\tstruct btrfsic_block_hashtable *h);\nstatic void btrfsic_block_link_hashtable_init(\n\t\tstruct btrfsic_block_link_hashtable *h);\nstatic void btrfsic_block_link_hashtable_add(\n\t\tstruct btrfsic_block_link *l,\n\t\tstruct btrfsic_block_link_hashtable *h);\nstatic struct btrfsic_block_link *btrfsic_block_link_hashtable_lookup(\n\t\tstruct block_device *bdev_ref_to,\n\t\tu64 dev_bytenr_ref_to,\n\t\tstruct block_device *bdev_ref_from,\n\t\tu64 dev_bytenr_ref_from,\n\t\tstruct btrfsic_block_link_hashtable *h);\nstatic void btrfsic_dev_state_hashtable_init(\n\t\tstruct btrfsic_dev_state_hashtable *h);\nstatic void btrfsic_dev_state_hashtable_add(\n\t\tstruct btrfsic_dev_state *ds,\n\t\tstruct btrfsic_dev_state_hashtable *h);\nstatic void btrfsic_dev_state_hashtable_remove(struct btrfsic_dev_state *ds);\nstatic struct btrfsic_dev_state *btrfsic_dev_state_hashtable_lookup(\n\t\tstruct block_device *bdev,\n\t\tstruct btrfsic_dev_state_hashtable *h);\nstatic struct btrfsic_dev_state *btrfsic_dev_state_lookup(\n\t\tstruct block_device *bdev);\nstatic struct btrfsic_dev_state_hashtable btrfsic_dev_state_hashtable;\n\nstatic struct btrfsic_dev_state *btrfsic_dev_state_hashtable_lookup(\n\t\tstruct block_device *bdev,\n\t\tstruct btrfsic_dev_state_hashtable *h)\n{\n\tconst unsigned int hashval =\n\t    (((unsigned int)((uintptr_t)bdev)) &\n\t     (BTRFSIC_DEV2STATE_HASHTABLE_SIZE - 1));\n\tstruct list_head *elem;\n\n\tlist_for_each(elem, h->table + hashval) {\n\t\tstruct btrfsic_dev_state *const ds =\n\t\t    list_entry(elem, struct btrfsic_dev_state,\n\t\t\t       collision_resolving_node);\n\n\t\tif (ds->bdev == bdev)\n\t\t\treturn ds;\n\t}\n\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"extent_io.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n#include <linux/blkdev.h>\n#include <linux/genhd.h>\n#include <linux/mutex.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic void btrfsic_dev_state_init(struct btrfsic_dev_state *ds);\nstatic void btrfsic_dev_state_free(struct btrfsic_dev_state *ds);\nstatic void btrfsic_dev_state_hashtable_remove(struct btrfsic_dev_state *ds);\nstatic struct btrfsic_dev_state *btrfsic_dev_state_lookup(\n\t\tstruct block_device *bdev);\nstatic struct btrfsic_dev_state_hashtable btrfsic_dev_state_hashtable;\n\nstatic struct btrfsic_dev_state *btrfsic_dev_state_lookup(\n\t\tstruct block_device *bdev)\n{\n\tstruct btrfsic_dev_state *ds;\n\n\tds = btrfsic_dev_state_hashtable_lookup(bdev,\n\t\t\t\t\t\t&btrfsic_dev_state_hashtable);\n\treturn ds;\n}"
  },
  {
    "function_name": "btrfsic_cmp_log_and_dev_bytenr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/check-integrity.c",
    "lines": "2836-2888",
    "snippet": "static void btrfsic_cmp_log_and_dev_bytenr(struct btrfsic_state *state,\n\t\t\t\t\t   u64 bytenr,\n\t\t\t\t\t   struct btrfsic_dev_state *dev_state,\n\t\t\t\t\t   u64 dev_bytenr)\n{\n\tint num_copies;\n\tint mirror_num;\n\tint ret;\n\tstruct btrfsic_block_data_ctx block_ctx;\n\tint match = 0;\n\n\tnum_copies = btrfs_num_copies(state->root->fs_info,\n\t\t\t\t      bytenr, state->metablock_size);\n\n\tfor (mirror_num = 1; mirror_num <= num_copies; mirror_num++) {\n\t\tret = btrfsic_map_block(state, bytenr, state->metablock_size,\n\t\t\t\t\t&block_ctx, mirror_num);\n\t\tif (ret) {\n\t\t\tprintk(KERN_INFO \"btrfsic:\"\n\t\t\t       \" btrfsic_map_block(logical @%llu,\"\n\t\t\t       \" mirror %d) failed!\\n\",\n\t\t\t       bytenr, mirror_num);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (dev_state->bdev == block_ctx.dev->bdev &&\n\t\t    dev_bytenr == block_ctx.dev_bytenr) {\n\t\t\tmatch++;\n\t\t\tbtrfsic_release_block_ctx(&block_ctx);\n\t\t\tbreak;\n\t\t}\n\t\tbtrfsic_release_block_ctx(&block_ctx);\n\t}\n\n\tif (WARN_ON(!match)) {\n\t\tprintk(KERN_INFO \"btrfs: attempt to write M-block which contains logical bytenr that doesn't map to dev+physical bytenr of submit_bio,\"\n\t\t       \" buffer->log_bytenr=%llu, submit_bio(bdev=%s,\"\n\t\t       \" phys_bytenr=%llu)!\\n\",\n\t\t       bytenr, dev_state->name, dev_bytenr);\n\t\tfor (mirror_num = 1; mirror_num <= num_copies; mirror_num++) {\n\t\t\tret = btrfsic_map_block(state, bytenr,\n\t\t\t\t\t\tstate->metablock_size,\n\t\t\t\t\t\t&block_ctx, mirror_num);\n\t\t\tif (ret)\n\t\t\t\tcontinue;\n\n\t\t\tprintk(KERN_INFO \"Read logical bytenr @%llu maps to\"\n\t\t\t       \" (%s/%llu/%d)\\n\",\n\t\t\t       bytenr, block_ctx.dev->name,\n\t\t\t       block_ctx.dev_bytenr, mirror_num);\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"volumes.h\"",
      "#include \"extent_io.h\"",
      "#include \"transaction.h\"",
      "#include \"hash.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/genhd.h>",
      "#include <linux/mutex.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void btrfsic_block_link_init(struct btrfsic_block_link *n);",
      "static void btrfsic_block_link_free(struct btrfsic_block_link *n);",
      "static int btrfsic_map_block(struct btrfsic_state *state, u64 bytenr, u32 len,\n\t\t\t     struct btrfsic_block_data_ctx *block_ctx_out,\n\t\t\t     int mirror_num);",
      "static void btrfsic_release_block_ctx(struct btrfsic_block_data_ctx *block_ctx);",
      "static int btrfsic_read_block(struct btrfsic_state *state,\n\t\t\t      struct btrfsic_block_data_ctx *block_ctx);",
      "static void btrfsic_dump_database(struct btrfsic_state *state);",
      "static char btrfsic_get_block_type(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block *block);",
      "static void btrfsic_dump_tree(const struct btrfsic_state *state);",
      "static struct btrfsic_dev_state *btrfsic_dev_state_lookup(\n\t\tstruct block_device *bdev);",
      "static void btrfsic_cmp_log_and_dev_bytenr(struct btrfsic_state *state,\n\t\t\t\t\t   u64 bytenr,\n\t\t\t\t\t   struct btrfsic_dev_state *dev_state,\n\t\t\t\t\t   u64 dev_bytenr);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_INFO \"Read logical bytenr @%llu maps to\"\n\t\t\t       \" (%s/%llu/%d)\\n\"",
            "bytenr",
            "block_ctx.dev->name",
            "block_ctx.dev_bytenr",
            "mirror_num"
          ],
          "line": 2882
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/super.c",
          "lines": "186-213",
          "snippet": "void btrfs_printk(const struct btrfs_fs_info *fs_info, const char *fmt, ...)\n{\n\tstruct super_block *sb = fs_info->sb;\n\tchar lvl[4];\n\tstruct va_format vaf;\n\tva_list args;\n\tconst char *type = logtypes[4];\n\tint kern_level;\n\n\tva_start(args, fmt);\n\n\tkern_level = printk_get_level(fmt);\n\tif (kern_level) {\n\t\tsize_t size = printk_skip_level(fmt) - fmt;\n\t\tmemcpy(lvl, fmt,  size);\n\t\tlvl[size] = '\\0';\n\t\tfmt += size;\n\t\ttype = logtypes[kern_level - '0'];\n\t} else\n\t\t*lvl = '\\0';\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sBTRFS %s (device %s): %pV\\n\", lvl, type, sb->s_id, &vaf);\n\n\tva_end(args);\n}",
          "includes": [
            "#include <trace/events/btrfs.h>",
            "#include \"qgroup.h\"",
            "#include \"tests/btrfs-tests.h\"",
            "#include \"backref.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"compression.h\"",
            "#include \"export.h\"",
            "#include \"volumes.h\"",
            "#include \"xattr.h\"",
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/slab.h>",
            "#include <linux/magic.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/namei.h>",
            "#include <linux/ctype.h>",
            "#include <linux/parser.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/btrfs.h>\n#include \"qgroup.h\"\n#include \"tests/btrfs-tests.h\"\n#include \"backref.h\"\n#include \"free-space-cache.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"compression.h\"\n#include \"export.h\"\n#include \"volumes.h\"\n#include \"xattr.h\"\n#include \"props.h\"\n#include \"hash.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include \"delayed-inode.h\"\n#include <linux/btrfs.h>\n#include <linux/ratelimit.h>\n#include <linux/cleancache.h>\n#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/miscdevice.h>\n#include <linux/namei.h>\n#include <linux/ctype.h>\n#include <linux/parser.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n\nvoid btrfs_printk(const struct btrfs_fs_info *fs_info, const char *fmt, ...)\n{\n\tstruct super_block *sb = fs_info->sb;\n\tchar lvl[4];\n\tstruct va_format vaf;\n\tva_list args;\n\tconst char *type = logtypes[4];\n\tint kern_level;\n\n\tva_start(args, fmt);\n\n\tkern_level = printk_get_level(fmt);\n\tif (kern_level) {\n\t\tsize_t size = printk_skip_level(fmt) - fmt;\n\t\tmemcpy(lvl, fmt,  size);\n\t\tlvl[size] = '\\0';\n\t\tfmt += size;\n\t\ttype = logtypes[kern_level - '0'];\n\t} else\n\t\t*lvl = '\\0';\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sBTRFS %s (device %s): %pV\\n\", lvl, type, sb->s_id, &vaf);\n\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfsic_map_block",
          "args": [
            "state",
            "bytenr",
            "state->metablock_size",
            "&block_ctx",
            "mirror_num"
          ],
          "line": 2876
        },
        "resolved": true,
        "details": {
          "function_name": "btrfsic_map_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/check-integrity.c",
          "lines": "1568-1609",
          "snippet": "static int btrfsic_map_block(struct btrfsic_state *state, u64 bytenr, u32 len,\n\t\t\t     struct btrfsic_block_data_ctx *block_ctx_out,\n\t\t\t     int mirror_num)\n{\n\tint ret;\n\tu64 length;\n\tstruct btrfs_bio *multi = NULL;\n\tstruct btrfs_device *device;\n\n\tlength = len;\n\tret = btrfs_map_block(state->root->fs_info, READ,\n\t\t\t      bytenr, &length, &multi, mirror_num);\n\n\tif (ret) {\n\t\tblock_ctx_out->start = 0;\n\t\tblock_ctx_out->dev_bytenr = 0;\n\t\tblock_ctx_out->len = 0;\n\t\tblock_ctx_out->dev = NULL;\n\t\tblock_ctx_out->datav = NULL;\n\t\tblock_ctx_out->pagev = NULL;\n\t\tblock_ctx_out->mem_to_free = NULL;\n\n\t\treturn ret;\n\t}\n\n\tdevice = multi->stripes[0].dev;\n\tblock_ctx_out->dev = btrfsic_dev_state_lookup(device->bdev);\n\tblock_ctx_out->dev_bytenr = multi->stripes[0].physical;\n\tblock_ctx_out->start = bytenr;\n\tblock_ctx_out->len = len;\n\tblock_ctx_out->datav = NULL;\n\tblock_ctx_out->pagev = NULL;\n\tblock_ctx_out->mem_to_free = NULL;\n\n\tkfree(multi);\n\tif (NULL == block_ctx_out->dev) {\n\t\tret = -ENXIO;\n\t\tprintk(KERN_INFO \"btrfsic: error, cannot lookup dev (#1)!\\n\");\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"extent_io.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/genhd.h>",
            "#include <linux/mutex.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void btrfsic_block_link_init(struct btrfsic_block_link *n);",
            "static void btrfsic_block_link_free(struct btrfsic_block_link *n);",
            "static void btrfsic_read_from_block_data(\n\tstruct btrfsic_block_data_ctx *block_ctx,\n\tvoid *dst, u32 offset, size_t len);",
            "static int btrfsic_map_block(struct btrfsic_state *state, u64 bytenr, u32 len,\n\t\t\t     struct btrfsic_block_data_ctx *block_ctx_out,\n\t\t\t     int mirror_num);",
            "static void btrfsic_dump_database(struct btrfsic_state *state);",
            "static void btrfsic_dump_tree(const struct btrfsic_state *state);",
            "static struct btrfsic_dev_state *btrfsic_dev_state_lookup(\n\t\tstruct block_device *bdev);",
            "static void btrfsic_cmp_log_and_dev_bytenr(struct btrfsic_state *state,\n\t\t\t\t\t   u64 bytenr,\n\t\t\t\t\t   struct btrfsic_dev_state *dev_state,\n\t\t\t\t\t   u64 dev_bytenr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"extent_io.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n#include <linux/blkdev.h>\n#include <linux/genhd.h>\n#include <linux/mutex.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic void btrfsic_block_link_init(struct btrfsic_block_link *n);\nstatic void btrfsic_block_link_free(struct btrfsic_block_link *n);\nstatic void btrfsic_read_from_block_data(\n\tstruct btrfsic_block_data_ctx *block_ctx,\n\tvoid *dst, u32 offset, size_t len);\nstatic int btrfsic_map_block(struct btrfsic_state *state, u64 bytenr, u32 len,\n\t\t\t     struct btrfsic_block_data_ctx *block_ctx_out,\n\t\t\t     int mirror_num);\nstatic void btrfsic_dump_database(struct btrfsic_state *state);\nstatic void btrfsic_dump_tree(const struct btrfsic_state *state);\nstatic struct btrfsic_dev_state *btrfsic_dev_state_lookup(\n\t\tstruct block_device *bdev);\nstatic void btrfsic_cmp_log_and_dev_bytenr(struct btrfsic_state *state,\n\t\t\t\t\t   u64 bytenr,\n\t\t\t\t\t   struct btrfsic_dev_state *dev_state,\n\t\t\t\t\t   u64 dev_bytenr);\n\nstatic int btrfsic_map_block(struct btrfsic_state *state, u64 bytenr, u32 len,\n\t\t\t     struct btrfsic_block_data_ctx *block_ctx_out,\n\t\t\t     int mirror_num)\n{\n\tint ret;\n\tu64 length;\n\tstruct btrfs_bio *multi = NULL;\n\tstruct btrfs_device *device;\n\n\tlength = len;\n\tret = btrfs_map_block(state->root->fs_info, READ,\n\t\t\t      bytenr, &length, &multi, mirror_num);\n\n\tif (ret) {\n\t\tblock_ctx_out->start = 0;\n\t\tblock_ctx_out->dev_bytenr = 0;\n\t\tblock_ctx_out->len = 0;\n\t\tblock_ctx_out->dev = NULL;\n\t\tblock_ctx_out->datav = NULL;\n\t\tblock_ctx_out->pagev = NULL;\n\t\tblock_ctx_out->mem_to_free = NULL;\n\n\t\treturn ret;\n\t}\n\n\tdevice = multi->stripes[0].dev;\n\tblock_ctx_out->dev = btrfsic_dev_state_lookup(device->bdev);\n\tblock_ctx_out->dev_bytenr = multi->stripes[0].physical;\n\tblock_ctx_out->start = bytenr;\n\tblock_ctx_out->len = len;\n\tblock_ctx_out->datav = NULL;\n\tblock_ctx_out->pagev = NULL;\n\tblock_ctx_out->mem_to_free = NULL;\n\n\tkfree(multi);\n\tif (NULL == block_ctx_out->dev) {\n\t\tret = -ENXIO;\n\t\tprintk(KERN_INFO \"btrfsic: error, cannot lookup dev (#1)!\\n\");\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!match"
          ],
          "line": 2870
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfsic_release_block_ctx",
          "args": [
            "&block_ctx"
          ],
          "line": 2867
        },
        "resolved": true,
        "details": {
          "function_name": "btrfsic_release_block_ctx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/check-integrity.c",
          "lines": "1611-1637",
          "snippet": "static void btrfsic_release_block_ctx(struct btrfsic_block_data_ctx *block_ctx)\n{\n\tif (block_ctx->mem_to_free) {\n\t\tunsigned int num_pages;\n\n\t\tBUG_ON(!block_ctx->datav);\n\t\tBUG_ON(!block_ctx->pagev);\n\t\tnum_pages = (block_ctx->len + (u64)PAGE_CACHE_SIZE - 1) >>\n\t\t\t    PAGE_CACHE_SHIFT;\n\t\twhile (num_pages > 0) {\n\t\t\tnum_pages--;\n\t\t\tif (block_ctx->datav[num_pages]) {\n\t\t\t\tkunmap(block_ctx->pagev[num_pages]);\n\t\t\t\tblock_ctx->datav[num_pages] = NULL;\n\t\t\t}\n\t\t\tif (block_ctx->pagev[num_pages]) {\n\t\t\t\t__free_page(block_ctx->pagev[num_pages]);\n\t\t\t\tblock_ctx->pagev[num_pages] = NULL;\n\t\t\t}\n\t\t}\n\n\t\tkfree(block_ctx->mem_to_free);\n\t\tblock_ctx->mem_to_free = NULL;\n\t\tblock_ctx->pagev = NULL;\n\t\tblock_ctx->datav = NULL;\n\t}\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"extent_io.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/genhd.h>",
            "#include <linux/mutex.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void btrfsic_read_from_block_data(\n\tstruct btrfsic_block_data_ctx *block_ctx,\n\tvoid *dst, u32 offset, size_t len);",
            "static void btrfsic_release_block_ctx(struct btrfsic_block_data_ctx *block_ctx);",
            "static int btrfsic_read_block(struct btrfsic_state *state,\n\t\t\t      struct btrfsic_block_data_ctx *block_ctx);",
            "static int btrfsic_test_for_metadata(struct btrfsic_state *state,\n\t\t\t\t     char **datav, unsigned int num_pages);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"extent_io.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n#include <linux/blkdev.h>\n#include <linux/genhd.h>\n#include <linux/mutex.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic void btrfsic_read_from_block_data(\n\tstruct btrfsic_block_data_ctx *block_ctx,\n\tvoid *dst, u32 offset, size_t len);\nstatic void btrfsic_release_block_ctx(struct btrfsic_block_data_ctx *block_ctx);\nstatic int btrfsic_read_block(struct btrfsic_state *state,\n\t\t\t      struct btrfsic_block_data_ctx *block_ctx);\nstatic int btrfsic_test_for_metadata(struct btrfsic_state *state,\n\t\t\t\t     char **datav, unsigned int num_pages);\n\nstatic void btrfsic_release_block_ctx(struct btrfsic_block_data_ctx *block_ctx)\n{\n\tif (block_ctx->mem_to_free) {\n\t\tunsigned int num_pages;\n\n\t\tBUG_ON(!block_ctx->datav);\n\t\tBUG_ON(!block_ctx->pagev);\n\t\tnum_pages = (block_ctx->len + (u64)PAGE_CACHE_SIZE - 1) >>\n\t\t\t    PAGE_CACHE_SHIFT;\n\t\twhile (num_pages > 0) {\n\t\t\tnum_pages--;\n\t\t\tif (block_ctx->datav[num_pages]) {\n\t\t\t\tkunmap(block_ctx->pagev[num_pages]);\n\t\t\t\tblock_ctx->datav[num_pages] = NULL;\n\t\t\t}\n\t\t\tif (block_ctx->pagev[num_pages]) {\n\t\t\t\t__free_page(block_ctx->pagev[num_pages]);\n\t\t\t\tblock_ctx->pagev[num_pages] = NULL;\n\t\t\t}\n\t\t}\n\n\t\tkfree(block_ctx->mem_to_free);\n\t\tblock_ctx->mem_to_free = NULL;\n\t\tblock_ctx->pagev = NULL;\n\t\tblock_ctx->datav = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_num_copies",
          "args": [
            "state->root->fs_info",
            "bytenr",
            "state->metablock_size"
          ],
          "line": 2847
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_num_copies",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
          "lines": "4740-4790",
          "snippet": "int btrfs_num_copies(struct btrfs_fs_info *fs_info, u64 logical, u64 len)\n{\n\tstruct btrfs_mapping_tree *map_tree = &fs_info->mapping_tree;\n\tstruct extent_map *em;\n\tstruct map_lookup *map;\n\tstruct extent_map_tree *em_tree = &map_tree->map_tree;\n\tint ret;\n\n\tread_lock(&em_tree->lock);\n\tem = lookup_extent_mapping(em_tree, logical, len);\n\tread_unlock(&em_tree->lock);\n\n\t/*\n\t * We could return errors for these cases, but that could get ugly and\n\t * we'd probably do the same thing which is just not do anything else\n\t * and exit, so return 1 so the callers don't try to use other copies.\n\t */\n\tif (!em) {\n\t\tbtrfs_crit(fs_info, \"No mapping for %Lu-%Lu\", logical,\n\t\t\t    logical+len);\n\t\treturn 1;\n\t}\n\n\tif (em->start > logical || em->start + em->len < logical) {\n\t\tbtrfs_crit(fs_info, \"Invalid mapping for %Lu-%Lu, got \"\n\t\t\t    \"%Lu-%Lu\", logical, logical+len, em->start,\n\t\t\t    em->start + em->len);\n\t\tfree_extent_map(em);\n\t\treturn 1;\n\t}\n\n\tmap = (struct map_lookup *)em->bdev;\n\tif (map->type & (BTRFS_BLOCK_GROUP_DUP | BTRFS_BLOCK_GROUP_RAID1))\n\t\tret = map->num_stripes;\n\telse if (map->type & BTRFS_BLOCK_GROUP_RAID10)\n\t\tret = map->sub_stripes;\n\telse if (map->type & BTRFS_BLOCK_GROUP_RAID5)\n\t\tret = 2;\n\telse if (map->type & BTRFS_BLOCK_GROUP_RAID6)\n\t\tret = 3;\n\telse\n\t\tret = 1;\n\tfree_extent_map(em);\n\n\tbtrfs_dev_replace_lock(&fs_info->dev_replace);\n\tif (btrfs_dev_replace_is_ongoing(&fs_info->dev_replace))\n\t\tret++;\n\tbtrfs_dev_replace_unlock(&fs_info->dev_replace);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\nstatic noinline struct;\n\nint btrfs_num_copies(struct btrfs_fs_info *fs_info, u64 logical, u64 len)\n{\n\tstruct btrfs_mapping_tree *map_tree = &fs_info->mapping_tree;\n\tstruct extent_map *em;\n\tstruct map_lookup *map;\n\tstruct extent_map_tree *em_tree = &map_tree->map_tree;\n\tint ret;\n\n\tread_lock(&em_tree->lock);\n\tem = lookup_extent_mapping(em_tree, logical, len);\n\tread_unlock(&em_tree->lock);\n\n\t/*\n\t * We could return errors for these cases, but that could get ugly and\n\t * we'd probably do the same thing which is just not do anything else\n\t * and exit, so return 1 so the callers don't try to use other copies.\n\t */\n\tif (!em) {\n\t\tbtrfs_crit(fs_info, \"No mapping for %Lu-%Lu\", logical,\n\t\t\t    logical+len);\n\t\treturn 1;\n\t}\n\n\tif (em->start > logical || em->start + em->len < logical) {\n\t\tbtrfs_crit(fs_info, \"Invalid mapping for %Lu-%Lu, got \"\n\t\t\t    \"%Lu-%Lu\", logical, logical+len, em->start,\n\t\t\t    em->start + em->len);\n\t\tfree_extent_map(em);\n\t\treturn 1;\n\t}\n\n\tmap = (struct map_lookup *)em->bdev;\n\tif (map->type & (BTRFS_BLOCK_GROUP_DUP | BTRFS_BLOCK_GROUP_RAID1))\n\t\tret = map->num_stripes;\n\telse if (map->type & BTRFS_BLOCK_GROUP_RAID10)\n\t\tret = map->sub_stripes;\n\telse if (map->type & BTRFS_BLOCK_GROUP_RAID5)\n\t\tret = 2;\n\telse if (map->type & BTRFS_BLOCK_GROUP_RAID6)\n\t\tret = 3;\n\telse\n\t\tret = 1;\n\tfree_extent_map(em);\n\n\tbtrfs_dev_replace_lock(&fs_info->dev_replace);\n\tif (btrfs_dev_replace_is_ongoing(&fs_info->dev_replace))\n\t\tret++;\n\tbtrfs_dev_replace_unlock(&fs_info->dev_replace);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"extent_io.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n#include <linux/blkdev.h>\n#include <linux/genhd.h>\n#include <linux/mutex.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic void btrfsic_block_link_init(struct btrfsic_block_link *n);\nstatic void btrfsic_block_link_free(struct btrfsic_block_link *n);\nstatic int btrfsic_map_block(struct btrfsic_state *state, u64 bytenr, u32 len,\n\t\t\t     struct btrfsic_block_data_ctx *block_ctx_out,\n\t\t\t     int mirror_num);\nstatic void btrfsic_release_block_ctx(struct btrfsic_block_data_ctx *block_ctx);\nstatic int btrfsic_read_block(struct btrfsic_state *state,\n\t\t\t      struct btrfsic_block_data_ctx *block_ctx);\nstatic void btrfsic_dump_database(struct btrfsic_state *state);\nstatic char btrfsic_get_block_type(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block *block);\nstatic void btrfsic_dump_tree(const struct btrfsic_state *state);\nstatic struct btrfsic_dev_state *btrfsic_dev_state_lookup(\n\t\tstruct block_device *bdev);\nstatic void btrfsic_cmp_log_and_dev_bytenr(struct btrfsic_state *state,\n\t\t\t\t\t   u64 bytenr,\n\t\t\t\t\t   struct btrfsic_dev_state *dev_state,\n\t\t\t\t\t   u64 dev_bytenr);\n\nstatic void btrfsic_cmp_log_and_dev_bytenr(struct btrfsic_state *state,\n\t\t\t\t\t   u64 bytenr,\n\t\t\t\t\t   struct btrfsic_dev_state *dev_state,\n\t\t\t\t\t   u64 dev_bytenr)\n{\n\tint num_copies;\n\tint mirror_num;\n\tint ret;\n\tstruct btrfsic_block_data_ctx block_ctx;\n\tint match = 0;\n\n\tnum_copies = btrfs_num_copies(state->root->fs_info,\n\t\t\t\t      bytenr, state->metablock_size);\n\n\tfor (mirror_num = 1; mirror_num <= num_copies; mirror_num++) {\n\t\tret = btrfsic_map_block(state, bytenr, state->metablock_size,\n\t\t\t\t\t&block_ctx, mirror_num);\n\t\tif (ret) {\n\t\t\tprintk(KERN_INFO \"btrfsic:\"\n\t\t\t       \" btrfsic_map_block(logical @%llu,\"\n\t\t\t       \" mirror %d) failed!\\n\",\n\t\t\t       bytenr, mirror_num);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (dev_state->bdev == block_ctx.dev->bdev &&\n\t\t    dev_bytenr == block_ctx.dev_bytenr) {\n\t\t\tmatch++;\n\t\t\tbtrfsic_release_block_ctx(&block_ctx);\n\t\t\tbreak;\n\t\t}\n\t\tbtrfsic_release_block_ctx(&block_ctx);\n\t}\n\n\tif (WARN_ON(!match)) {\n\t\tprintk(KERN_INFO \"btrfs: attempt to write M-block which contains logical bytenr that doesn't map to dev+physical bytenr of submit_bio,\"\n\t\t       \" buffer->log_bytenr=%llu, submit_bio(bdev=%s,\"\n\t\t       \" phys_bytenr=%llu)!\\n\",\n\t\t       bytenr, dev_state->name, dev_bytenr);\n\t\tfor (mirror_num = 1; mirror_num <= num_copies; mirror_num++) {\n\t\t\tret = btrfsic_map_block(state, bytenr,\n\t\t\t\t\t\tstate->metablock_size,\n\t\t\t\t\t\t&block_ctx, mirror_num);\n\t\t\tif (ret)\n\t\t\t\tcontinue;\n\n\t\t\tprintk(KERN_INFO \"Read logical bytenr @%llu maps to\"\n\t\t\t       \" (%s/%llu/%d)\\n\",\n\t\t\t       bytenr, block_ctx.dev->name,\n\t\t\t       block_ctx.dev_bytenr, mirror_num);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "btrfsic_block_lookup_or_add",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/check-integrity.c",
    "lines": "2780-2834",
    "snippet": "static struct btrfsic_block *btrfsic_block_lookup_or_add(\n\t\tstruct btrfsic_state *state,\n\t\tstruct btrfsic_block_data_ctx *block_ctx,\n\t\tconst char *additional_string,\n\t\tint is_metadata,\n\t\tint is_iodone,\n\t\tint never_written,\n\t\tint mirror_num,\n\t\tint *was_created)\n{\n\tstruct btrfsic_block *block;\n\n\tblock = btrfsic_block_hashtable_lookup(block_ctx->dev->bdev,\n\t\t\t\t\t       block_ctx->dev_bytenr,\n\t\t\t\t\t       &state->block_hashtable);\n\tif (NULL == block) {\n\t\tstruct btrfsic_dev_state *dev_state;\n\n\t\tblock = btrfsic_block_alloc();\n\t\tif (NULL == block) {\n\t\t\tprintk(KERN_INFO \"btrfsic: error, kmalloc failed!\\n\");\n\t\t\treturn NULL;\n\t\t}\n\t\tdev_state = btrfsic_dev_state_lookup(block_ctx->dev->bdev);\n\t\tif (NULL == dev_state) {\n\t\t\tprintk(KERN_INFO\n\t\t\t       \"btrfsic: error, lookup dev_state failed!\\n\");\n\t\t\tbtrfsic_block_free(block);\n\t\t\treturn NULL;\n\t\t}\n\t\tblock->dev_state = dev_state;\n\t\tblock->dev_bytenr = block_ctx->dev_bytenr;\n\t\tblock->logical_bytenr = block_ctx->start;\n\t\tblock->is_metadata = is_metadata;\n\t\tblock->is_iodone = is_iodone;\n\t\tblock->never_written = never_written;\n\t\tblock->mirror_num = mirror_num;\n\t\tif (state->print_mask & BTRFSIC_PRINT_MASK_VERBOSE)\n\t\t\tprintk(KERN_INFO\n\t\t\t       \"New %s%c-block @%llu (%s/%llu/%d)\\n\",\n\t\t\t       additional_string,\n\t\t\t       btrfsic_get_block_type(state, block),\n\t\t\t       block->logical_bytenr, dev_state->name,\n\t\t\t       block->dev_bytenr, mirror_num);\n\t\tlist_add(&block->all_blocks_node, &state->all_blocks_list);\n\t\tbtrfsic_block_hashtable_add(block, &state->block_hashtable);\n\t\tif (NULL != was_created)\n\t\t\t*was_created = 1;\n\t} else {\n\t\tif (NULL != was_created)\n\t\t\t*was_created = 0;\n\t}\n\n\treturn block;\n}",
    "includes": [
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"volumes.h\"",
      "#include \"extent_io.h\"",
      "#include \"transaction.h\"",
      "#include \"hash.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/genhd.h>",
      "#include <linux/mutex.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [
      "#define BTRFSIC_PRINT_MASK_VERBOSE\t\t\t\t0x00000040"
    ],
    "globals_used": [
      "static struct btrfsic_block *btrfsic_block_alloc(void);",
      "static void btrfsic_block_link_init(struct btrfsic_block_link *n);",
      "static void btrfsic_block_link_free(struct btrfsic_block_link *n);",
      "static int btrfsic_map_block(struct btrfsic_state *state, u64 bytenr, u32 len,\n\t\t\t     struct btrfsic_block_data_ctx *block_ctx_out,\n\t\t\t     int mirror_num);",
      "static void btrfsic_release_block_ctx(struct btrfsic_block_data_ctx *block_ctx);",
      "static int btrfsic_read_block(struct btrfsic_state *state,\n\t\t\t      struct btrfsic_block_data_ctx *block_ctx);",
      "static void btrfsic_dump_database(struct btrfsic_state *state);",
      "static char btrfsic_get_block_type(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block *block);",
      "static void btrfsic_dump_tree(const struct btrfsic_state *state);",
      "static struct btrfsic_block *btrfsic_block_lookup_or_add(\n\t\tstruct btrfsic_state *state,\n\t\tstruct btrfsic_block_data_ctx *block_ctx,\n\t\tconst char *additional_string,\n\t\tint is_metadata,\n\t\tint is_iodone,\n\t\tint never_written,\n\t\tint mirror_num,\n\t\tint *was_created);",
      "static struct btrfsic_dev_state *btrfsic_dev_state_lookup(\n\t\tstruct block_device *bdev);",
      "static void btrfsic_cmp_log_and_dev_bytenr(struct btrfsic_state *state,\n\t\t\t\t\t   u64 bytenr,\n\t\t\t\t\t   struct btrfsic_dev_state *dev_state,\n\t\t\t\t\t   u64 dev_bytenr);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfsic_block_hashtable_add",
          "args": [
            "block",
            "&state->block_hashtable"
          ],
          "line": 2825
        },
        "resolved": true,
        "details": {
          "function_name": "btrfsic_block_hashtable_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/check-integrity.c",
          "lines": "509-518",
          "snippet": "static void btrfsic_block_hashtable_add(struct btrfsic_block *b,\n\t\t\t\t\tstruct btrfsic_block_hashtable *h)\n{\n\tconst unsigned int hashval =\n\t    (((unsigned int)(b->dev_bytenr >> 16)) ^\n\t     ((unsigned int)((uintptr_t)b->dev_state->bdev))) &\n\t     (BTRFSIC_BLOCK_HASHTABLE_SIZE - 1);\n\n\tlist_add(&b->collision_resolving_node, h->table + hashval);\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"extent_io.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/genhd.h>",
            "#include <linux/mutex.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define BTRFSIC_BLOCK_HASHTABLE_SIZE 0x10000"
          ],
          "globals_used": [
            "static void btrfsic_block_init(struct btrfsic_block *b);",
            "static void btrfsic_block_free(struct btrfsic_block *b);",
            "static void btrfsic_block_hashtable_init(struct btrfsic_block_hashtable *h);",
            "static void btrfsic_block_hashtable_add(struct btrfsic_block *b,\n\t\t\t\t\tstruct btrfsic_block_hashtable *h);",
            "static void btrfsic_block_hashtable_remove(struct btrfsic_block *b);",
            "static struct btrfsic_block *btrfsic_block_hashtable_lookup(\n\t\tstruct block_device *bdev,\n\t\tu64 dev_bytenr,\n\t\tstruct btrfsic_block_hashtable *h);",
            "static void btrfsic_block_link_hashtable_init(\n\t\tstruct btrfsic_block_link_hashtable *h);",
            "static void btrfsic_block_link_hashtable_add(\n\t\tstruct btrfsic_block_link *l,\n\t\tstruct btrfsic_block_link_hashtable *h);",
            "static struct btrfsic_block_link *btrfsic_block_link_hashtable_lookup(\n\t\tstruct block_device *bdev_ref_to,\n\t\tu64 dev_bytenr_ref_to,\n\t\tstruct block_device *bdev_ref_from,\n\t\tu64 dev_bytenr_ref_from,\n\t\tstruct btrfsic_block_link_hashtable *h);",
            "static void btrfsic_dev_state_hashtable_init(\n\t\tstruct btrfsic_dev_state_hashtable *h);",
            "static void btrfsic_dev_state_hashtable_add(\n\t\tstruct btrfsic_dev_state *ds,\n\t\tstruct btrfsic_dev_state_hashtable *h);",
            "static struct btrfsic_dev_state *btrfsic_dev_state_hashtable_lookup(\n\t\tstruct block_device *bdev,\n\t\tstruct btrfsic_dev_state_hashtable *h);",
            "static struct btrfsic_dev_state *btrfsic_dev_state_lookup(\n\t\tstruct block_device *bdev);",
            "static void btrfsic_cmp_log_and_dev_bytenr(struct btrfsic_state *state,\n\t\t\t\t\t   u64 bytenr,\n\t\t\t\t\t   struct btrfsic_dev_state *dev_state,\n\t\t\t\t\t   u64 dev_bytenr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"extent_io.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n#include <linux/blkdev.h>\n#include <linux/genhd.h>\n#include <linux/mutex.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\n#define BTRFSIC_BLOCK_HASHTABLE_SIZE 0x10000\n\nstatic void btrfsic_block_init(struct btrfsic_block *b);\nstatic void btrfsic_block_free(struct btrfsic_block *b);\nstatic void btrfsic_block_hashtable_init(struct btrfsic_block_hashtable *h);\nstatic void btrfsic_block_hashtable_add(struct btrfsic_block *b,\n\t\t\t\t\tstruct btrfsic_block_hashtable *h);\nstatic void btrfsic_block_hashtable_remove(struct btrfsic_block *b);\nstatic struct btrfsic_block *btrfsic_block_hashtable_lookup(\n\t\tstruct block_device *bdev,\n\t\tu64 dev_bytenr,\n\t\tstruct btrfsic_block_hashtable *h);\nstatic void btrfsic_block_link_hashtable_init(\n\t\tstruct btrfsic_block_link_hashtable *h);\nstatic void btrfsic_block_link_hashtable_add(\n\t\tstruct btrfsic_block_link *l,\n\t\tstruct btrfsic_block_link_hashtable *h);\nstatic struct btrfsic_block_link *btrfsic_block_link_hashtable_lookup(\n\t\tstruct block_device *bdev_ref_to,\n\t\tu64 dev_bytenr_ref_to,\n\t\tstruct block_device *bdev_ref_from,\n\t\tu64 dev_bytenr_ref_from,\n\t\tstruct btrfsic_block_link_hashtable *h);\nstatic void btrfsic_dev_state_hashtable_init(\n\t\tstruct btrfsic_dev_state_hashtable *h);\nstatic void btrfsic_dev_state_hashtable_add(\n\t\tstruct btrfsic_dev_state *ds,\n\t\tstruct btrfsic_dev_state_hashtable *h);\nstatic struct btrfsic_dev_state *btrfsic_dev_state_hashtable_lookup(\n\t\tstruct block_device *bdev,\n\t\tstruct btrfsic_dev_state_hashtable *h);\nstatic struct btrfsic_dev_state *btrfsic_dev_state_lookup(\n\t\tstruct block_device *bdev);\nstatic void btrfsic_cmp_log_and_dev_bytenr(struct btrfsic_state *state,\n\t\t\t\t\t   u64 bytenr,\n\t\t\t\t\t   struct btrfsic_dev_state *dev_state,\n\t\t\t\t\t   u64 dev_bytenr);\n\nstatic void btrfsic_block_hashtable_add(struct btrfsic_block *b,\n\t\t\t\t\tstruct btrfsic_block_hashtable *h)\n{\n\tconst unsigned int hashval =\n\t    (((unsigned int)(b->dev_bytenr >> 16)) ^\n\t     ((unsigned int)((uintptr_t)b->dev_state->bdev))) &\n\t     (BTRFSIC_BLOCK_HASHTABLE_SIZE - 1);\n\n\tlist_add(&b->collision_resolving_node, h->table + hashval);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&block->all_blocks_node",
            "&state->all_blocks_list"
          ],
          "line": 2824
        },
        "resolved": true,
        "details": {
          "function_name": "simple_xattr_list_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "966-972",
          "snippet": "void simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_INFO\n\t\t\t       \"New %s%c-block @%llu (%s/%llu/%d)\\n\"",
            "additional_string",
            "btrfsic_get_block_type(state, block)",
            "block->logical_bytenr",
            "dev_state->name",
            "block->dev_bytenr",
            "mirror_num"
          ],
          "line": 2818
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/super.c",
          "lines": "186-213",
          "snippet": "void btrfs_printk(const struct btrfs_fs_info *fs_info, const char *fmt, ...)\n{\n\tstruct super_block *sb = fs_info->sb;\n\tchar lvl[4];\n\tstruct va_format vaf;\n\tva_list args;\n\tconst char *type = logtypes[4];\n\tint kern_level;\n\n\tva_start(args, fmt);\n\n\tkern_level = printk_get_level(fmt);\n\tif (kern_level) {\n\t\tsize_t size = printk_skip_level(fmt) - fmt;\n\t\tmemcpy(lvl, fmt,  size);\n\t\tlvl[size] = '\\0';\n\t\tfmt += size;\n\t\ttype = logtypes[kern_level - '0'];\n\t} else\n\t\t*lvl = '\\0';\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sBTRFS %s (device %s): %pV\\n\", lvl, type, sb->s_id, &vaf);\n\n\tva_end(args);\n}",
          "includes": [
            "#include <trace/events/btrfs.h>",
            "#include \"qgroup.h\"",
            "#include \"tests/btrfs-tests.h\"",
            "#include \"backref.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"compression.h\"",
            "#include \"export.h\"",
            "#include \"volumes.h\"",
            "#include \"xattr.h\"",
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/slab.h>",
            "#include <linux/magic.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/namei.h>",
            "#include <linux/ctype.h>",
            "#include <linux/parser.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/btrfs.h>\n#include \"qgroup.h\"\n#include \"tests/btrfs-tests.h\"\n#include \"backref.h\"\n#include \"free-space-cache.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"compression.h\"\n#include \"export.h\"\n#include \"volumes.h\"\n#include \"xattr.h\"\n#include \"props.h\"\n#include \"hash.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include \"delayed-inode.h\"\n#include <linux/btrfs.h>\n#include <linux/ratelimit.h>\n#include <linux/cleancache.h>\n#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/miscdevice.h>\n#include <linux/namei.h>\n#include <linux/ctype.h>\n#include <linux/parser.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n\nvoid btrfs_printk(const struct btrfs_fs_info *fs_info, const char *fmt, ...)\n{\n\tstruct super_block *sb = fs_info->sb;\n\tchar lvl[4];\n\tstruct va_format vaf;\n\tva_list args;\n\tconst char *type = logtypes[4];\n\tint kern_level;\n\n\tva_start(args, fmt);\n\n\tkern_level = printk_get_level(fmt);\n\tif (kern_level) {\n\t\tsize_t size = printk_skip_level(fmt) - fmt;\n\t\tmemcpy(lvl, fmt,  size);\n\t\tlvl[size] = '\\0';\n\t\tfmt += size;\n\t\ttype = logtypes[kern_level - '0'];\n\t} else\n\t\t*lvl = '\\0';\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sBTRFS %s (device %s): %pV\\n\", lvl, type, sb->s_id, &vaf);\n\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfsic_get_block_type",
          "args": [
            "state",
            "block"
          ],
          "line": 2821
        },
        "resolved": true,
        "details": {
          "function_name": "btrfsic_get_block_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/check-integrity.c",
          "lines": "2648-2661",
          "snippet": "static char btrfsic_get_block_type(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block *block)\n{\n\tif (block->is_superblock &&\n\t    state->latest_superblock->dev_bytenr == block->dev_bytenr &&\n\t    state->latest_superblock->dev_state->bdev == block->dev_state->bdev)\n\t\treturn 'S';\n\telse if (block->is_superblock)\n\t\treturn 's';\n\telse if (block->is_metadata)\n\t\treturn 'M';\n\telse\n\t\treturn 'D';\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"extent_io.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/genhd.h>",
            "#include <linux/mutex.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void btrfsic_dump_database(struct btrfsic_state *state);",
            "static char btrfsic_get_block_type(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block *block);",
            "static void btrfsic_dump_tree(const struct btrfsic_state *state);",
            "static struct btrfsic_dev_state *btrfsic_dev_state_lookup(\n\t\tstruct block_device *bdev);",
            "static void btrfsic_cmp_log_and_dev_bytenr(struct btrfsic_state *state,\n\t\t\t\t\t   u64 bytenr,\n\t\t\t\t\t   struct btrfsic_dev_state *dev_state,\n\t\t\t\t\t   u64 dev_bytenr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"extent_io.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n#include <linux/blkdev.h>\n#include <linux/genhd.h>\n#include <linux/mutex.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic void btrfsic_dump_database(struct btrfsic_state *state);\nstatic char btrfsic_get_block_type(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block *block);\nstatic void btrfsic_dump_tree(const struct btrfsic_state *state);\nstatic struct btrfsic_dev_state *btrfsic_dev_state_lookup(\n\t\tstruct block_device *bdev);\nstatic void btrfsic_cmp_log_and_dev_bytenr(struct btrfsic_state *state,\n\t\t\t\t\t   u64 bytenr,\n\t\t\t\t\t   struct btrfsic_dev_state *dev_state,\n\t\t\t\t\t   u64 dev_bytenr);\n\nstatic char btrfsic_get_block_type(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block *block)\n{\n\tif (block->is_superblock &&\n\t    state->latest_superblock->dev_bytenr == block->dev_bytenr &&\n\t    state->latest_superblock->dev_state->bdev == block->dev_state->bdev)\n\t\treturn 'S';\n\telse if (block->is_superblock)\n\t\treturn 's';\n\telse if (block->is_metadata)\n\t\treturn 'M';\n\telse\n\t\treturn 'D';\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfsic_block_free",
          "args": [
            "block"
          ],
          "line": 2807
        },
        "resolved": true,
        "details": {
          "function_name": "btrfsic_block_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/check-integrity.c",
          "lines": "436-440",
          "snippet": "static void btrfsic_block_free(struct btrfsic_block *b)\n{\n\tBUG_ON(!(NULL == b || BTRFSIC_BLOCK_MAGIC_NUMBER == b->magic_num));\n\tkfree(b);\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"extent_io.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/genhd.h>",
            "#include <linux/mutex.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define BTRFSIC_BLOCK_MAGIC_NUMBER 0x14491051"
          ],
          "globals_used": [
            "static void btrfsic_block_init(struct btrfsic_block *b);",
            "static void btrfsic_block_free(struct btrfsic_block *b);",
            "static void btrfsic_block_hashtable_remove(struct btrfsic_block *b);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"extent_io.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n#include <linux/blkdev.h>\n#include <linux/genhd.h>\n#include <linux/mutex.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\n#define BTRFSIC_BLOCK_MAGIC_NUMBER 0x14491051\n\nstatic void btrfsic_block_init(struct btrfsic_block *b);\nstatic void btrfsic_block_free(struct btrfsic_block *b);\nstatic void btrfsic_block_hashtable_remove(struct btrfsic_block *b);\n\nstatic void btrfsic_block_free(struct btrfsic_block *b)\n{\n\tBUG_ON(!(NULL == b || BTRFSIC_BLOCK_MAGIC_NUMBER == b->magic_num));\n\tkfree(b);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_INFO\n\t\t\t       \"btrfsic: error, lookup dev_state failed!\\n\""
          ],
          "line": 2805
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfsic_dev_state_lookup",
          "args": [
            "block_ctx->dev->bdev"
          ],
          "line": 2803
        },
        "resolved": true,
        "details": {
          "function_name": "btrfsic_dev_state_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/check-integrity.c",
          "lines": "2890-2898",
          "snippet": "static struct btrfsic_dev_state *btrfsic_dev_state_lookup(\n\t\tstruct block_device *bdev)\n{\n\tstruct btrfsic_dev_state *ds;\n\n\tds = btrfsic_dev_state_hashtable_lookup(bdev,\n\t\t\t\t\t\t&btrfsic_dev_state_hashtable);\n\treturn ds;\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"extent_io.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/genhd.h>",
            "#include <linux/mutex.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void btrfsic_dev_state_init(struct btrfsic_dev_state *ds);",
            "static void btrfsic_dev_state_free(struct btrfsic_dev_state *ds);",
            "static void btrfsic_dev_state_hashtable_remove(struct btrfsic_dev_state *ds);",
            "static struct btrfsic_dev_state *btrfsic_dev_state_lookup(\n\t\tstruct block_device *bdev);",
            "static struct btrfsic_dev_state_hashtable btrfsic_dev_state_hashtable;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"extent_io.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n#include <linux/blkdev.h>\n#include <linux/genhd.h>\n#include <linux/mutex.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic void btrfsic_dev_state_init(struct btrfsic_dev_state *ds);\nstatic void btrfsic_dev_state_free(struct btrfsic_dev_state *ds);\nstatic void btrfsic_dev_state_hashtable_remove(struct btrfsic_dev_state *ds);\nstatic struct btrfsic_dev_state *btrfsic_dev_state_lookup(\n\t\tstruct block_device *bdev);\nstatic struct btrfsic_dev_state_hashtable btrfsic_dev_state_hashtable;\n\nstatic struct btrfsic_dev_state *btrfsic_dev_state_lookup(\n\t\tstruct block_device *bdev)\n{\n\tstruct btrfsic_dev_state *ds;\n\n\tds = btrfsic_dev_state_hashtable_lookup(bdev,\n\t\t\t\t\t\t&btrfsic_dev_state_hashtable);\n\treturn ds;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfsic_block_alloc",
          "args": [],
          "line": 2798
        },
        "resolved": true,
        "details": {
          "function_name": "btrfsic_block_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/check-integrity.c",
          "lines": "425-434",
          "snippet": "static struct btrfsic_block *btrfsic_block_alloc(void)\n{\n\tstruct btrfsic_block *b;\n\n\tb = kzalloc(sizeof(*b), GFP_NOFS);\n\tif (NULL != b)\n\t\tbtrfsic_block_init(b);\n\n\treturn b;\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"extent_io.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/genhd.h>",
            "#include <linux/mutex.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void btrfsic_block_init(struct btrfsic_block *b);",
            "static struct btrfsic_block *btrfsic_block_alloc(void);",
            "static void btrfsic_block_free(struct btrfsic_block *b);",
            "static void btrfsic_block_hashtable_remove(struct btrfsic_block *b);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"extent_io.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n#include <linux/blkdev.h>\n#include <linux/genhd.h>\n#include <linux/mutex.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic void btrfsic_block_init(struct btrfsic_block *b);\nstatic struct btrfsic_block *btrfsic_block_alloc(void);\nstatic void btrfsic_block_free(struct btrfsic_block *b);\nstatic void btrfsic_block_hashtable_remove(struct btrfsic_block *b);\n\nstatic struct btrfsic_block *btrfsic_block_alloc(void)\n{\n\tstruct btrfsic_block *b;\n\n\tb = kzalloc(sizeof(*b), GFP_NOFS);\n\tif (NULL != b)\n\t\tbtrfsic_block_init(b);\n\n\treturn b;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfsic_block_hashtable_lookup",
          "args": [
            "block_ctx->dev->bdev",
            "block_ctx->dev_bytenr",
            "&state->block_hashtable"
          ],
          "line": 2792
        },
        "resolved": true,
        "details": {
          "function_name": "btrfsic_block_hashtable_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/check-integrity.c",
          "lines": "525-546",
          "snippet": "static struct btrfsic_block *btrfsic_block_hashtable_lookup(\n\t\tstruct block_device *bdev,\n\t\tu64 dev_bytenr,\n\t\tstruct btrfsic_block_hashtable *h)\n{\n\tconst unsigned int hashval =\n\t    (((unsigned int)(dev_bytenr >> 16)) ^\n\t     ((unsigned int)((uintptr_t)bdev))) &\n\t     (BTRFSIC_BLOCK_HASHTABLE_SIZE - 1);\n\tstruct list_head *elem;\n\n\tlist_for_each(elem, h->table + hashval) {\n\t\tstruct btrfsic_block *const b =\n\t\t    list_entry(elem, struct btrfsic_block,\n\t\t\t       collision_resolving_node);\n\n\t\tif (b->dev_state->bdev == bdev && b->dev_bytenr == dev_bytenr)\n\t\t\treturn b;\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"extent_io.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/genhd.h>",
            "#include <linux/mutex.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define BTRFSIC_BLOCK_HASHTABLE_SIZE 0x10000"
          ],
          "globals_used": [
            "static void btrfsic_block_init(struct btrfsic_block *b);",
            "static void btrfsic_block_free(struct btrfsic_block *b);",
            "static void btrfsic_block_hashtable_init(struct btrfsic_block_hashtable *h);",
            "static void btrfsic_block_hashtable_add(struct btrfsic_block *b,\n\t\t\t\t\tstruct btrfsic_block_hashtable *h);",
            "static void btrfsic_block_hashtable_remove(struct btrfsic_block *b);",
            "static struct btrfsic_block *btrfsic_block_hashtable_lookup(\n\t\tstruct block_device *bdev,\n\t\tu64 dev_bytenr,\n\t\tstruct btrfsic_block_hashtable *h);",
            "static void btrfsic_block_link_hashtable_init(\n\t\tstruct btrfsic_block_link_hashtable *h);",
            "static void btrfsic_block_link_hashtable_add(\n\t\tstruct btrfsic_block_link *l,\n\t\tstruct btrfsic_block_link_hashtable *h);",
            "static struct btrfsic_block_link *btrfsic_block_link_hashtable_lookup(\n\t\tstruct block_device *bdev_ref_to,\n\t\tu64 dev_bytenr_ref_to,\n\t\tstruct block_device *bdev_ref_from,\n\t\tu64 dev_bytenr_ref_from,\n\t\tstruct btrfsic_block_link_hashtable *h);",
            "static void btrfsic_dev_state_hashtable_init(\n\t\tstruct btrfsic_dev_state_hashtable *h);",
            "static void btrfsic_dev_state_hashtable_add(\n\t\tstruct btrfsic_dev_state *ds,\n\t\tstruct btrfsic_dev_state_hashtable *h);",
            "static struct btrfsic_dev_state *btrfsic_dev_state_hashtable_lookup(\n\t\tstruct block_device *bdev,\n\t\tstruct btrfsic_dev_state_hashtable *h);",
            "static struct btrfsic_dev_state *btrfsic_dev_state_lookup(\n\t\tstruct block_device *bdev);",
            "static void btrfsic_cmp_log_and_dev_bytenr(struct btrfsic_state *state,\n\t\t\t\t\t   u64 bytenr,\n\t\t\t\t\t   struct btrfsic_dev_state *dev_state,\n\t\t\t\t\t   u64 dev_bytenr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"extent_io.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n#include <linux/blkdev.h>\n#include <linux/genhd.h>\n#include <linux/mutex.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\n#define BTRFSIC_BLOCK_HASHTABLE_SIZE 0x10000\n\nstatic void btrfsic_block_init(struct btrfsic_block *b);\nstatic void btrfsic_block_free(struct btrfsic_block *b);\nstatic void btrfsic_block_hashtable_init(struct btrfsic_block_hashtable *h);\nstatic void btrfsic_block_hashtable_add(struct btrfsic_block *b,\n\t\t\t\t\tstruct btrfsic_block_hashtable *h);\nstatic void btrfsic_block_hashtable_remove(struct btrfsic_block *b);\nstatic struct btrfsic_block *btrfsic_block_hashtable_lookup(\n\t\tstruct block_device *bdev,\n\t\tu64 dev_bytenr,\n\t\tstruct btrfsic_block_hashtable *h);\nstatic void btrfsic_block_link_hashtable_init(\n\t\tstruct btrfsic_block_link_hashtable *h);\nstatic void btrfsic_block_link_hashtable_add(\n\t\tstruct btrfsic_block_link *l,\n\t\tstruct btrfsic_block_link_hashtable *h);\nstatic struct btrfsic_block_link *btrfsic_block_link_hashtable_lookup(\n\t\tstruct block_device *bdev_ref_to,\n\t\tu64 dev_bytenr_ref_to,\n\t\tstruct block_device *bdev_ref_from,\n\t\tu64 dev_bytenr_ref_from,\n\t\tstruct btrfsic_block_link_hashtable *h);\nstatic void btrfsic_dev_state_hashtable_init(\n\t\tstruct btrfsic_dev_state_hashtable *h);\nstatic void btrfsic_dev_state_hashtable_add(\n\t\tstruct btrfsic_dev_state *ds,\n\t\tstruct btrfsic_dev_state_hashtable *h);\nstatic struct btrfsic_dev_state *btrfsic_dev_state_hashtable_lookup(\n\t\tstruct block_device *bdev,\n\t\tstruct btrfsic_dev_state_hashtable *h);\nstatic struct btrfsic_dev_state *btrfsic_dev_state_lookup(\n\t\tstruct block_device *bdev);\nstatic void btrfsic_cmp_log_and_dev_bytenr(struct btrfsic_state *state,\n\t\t\t\t\t   u64 bytenr,\n\t\t\t\t\t   struct btrfsic_dev_state *dev_state,\n\t\t\t\t\t   u64 dev_bytenr);\n\nstatic struct btrfsic_block *btrfsic_block_hashtable_lookup(\n\t\tstruct block_device *bdev,\n\t\tu64 dev_bytenr,\n\t\tstruct btrfsic_block_hashtable *h)\n{\n\tconst unsigned int hashval =\n\t    (((unsigned int)(dev_bytenr >> 16)) ^\n\t     ((unsigned int)((uintptr_t)bdev))) &\n\t     (BTRFSIC_BLOCK_HASHTABLE_SIZE - 1);\n\tstruct list_head *elem;\n\n\tlist_for_each(elem, h->table + hashval) {\n\t\tstruct btrfsic_block *const b =\n\t\t    list_entry(elem, struct btrfsic_block,\n\t\t\t       collision_resolving_node);\n\n\t\tif (b->dev_state->bdev == bdev && b->dev_bytenr == dev_bytenr)\n\t\t\treturn b;\n\t}\n\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"extent_io.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n#include <linux/blkdev.h>\n#include <linux/genhd.h>\n#include <linux/mutex.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\n#define BTRFSIC_PRINT_MASK_VERBOSE\t\t\t\t0x00000040\n\nstatic struct btrfsic_block *btrfsic_block_alloc(void);\nstatic void btrfsic_block_link_init(struct btrfsic_block_link *n);\nstatic void btrfsic_block_link_free(struct btrfsic_block_link *n);\nstatic int btrfsic_map_block(struct btrfsic_state *state, u64 bytenr, u32 len,\n\t\t\t     struct btrfsic_block_data_ctx *block_ctx_out,\n\t\t\t     int mirror_num);\nstatic void btrfsic_release_block_ctx(struct btrfsic_block_data_ctx *block_ctx);\nstatic int btrfsic_read_block(struct btrfsic_state *state,\n\t\t\t      struct btrfsic_block_data_ctx *block_ctx);\nstatic void btrfsic_dump_database(struct btrfsic_state *state);\nstatic char btrfsic_get_block_type(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block *block);\nstatic void btrfsic_dump_tree(const struct btrfsic_state *state);\nstatic struct btrfsic_block *btrfsic_block_lookup_or_add(\n\t\tstruct btrfsic_state *state,\n\t\tstruct btrfsic_block_data_ctx *block_ctx,\n\t\tconst char *additional_string,\n\t\tint is_metadata,\n\t\tint is_iodone,\n\t\tint never_written,\n\t\tint mirror_num,\n\t\tint *was_created);\nstatic struct btrfsic_dev_state *btrfsic_dev_state_lookup(\n\t\tstruct block_device *bdev);\nstatic void btrfsic_cmp_log_and_dev_bytenr(struct btrfsic_state *state,\n\t\t\t\t\t   u64 bytenr,\n\t\t\t\t\t   struct btrfsic_dev_state *dev_state,\n\t\t\t\t\t   u64 dev_bytenr);\n\nstatic struct btrfsic_block *btrfsic_block_lookup_or_add(\n\t\tstruct btrfsic_state *state,\n\t\tstruct btrfsic_block_data_ctx *block_ctx,\n\t\tconst char *additional_string,\n\t\tint is_metadata,\n\t\tint is_iodone,\n\t\tint never_written,\n\t\tint mirror_num,\n\t\tint *was_created)\n{\n\tstruct btrfsic_block *block;\n\n\tblock = btrfsic_block_hashtable_lookup(block_ctx->dev->bdev,\n\t\t\t\t\t       block_ctx->dev_bytenr,\n\t\t\t\t\t       &state->block_hashtable);\n\tif (NULL == block) {\n\t\tstruct btrfsic_dev_state *dev_state;\n\n\t\tblock = btrfsic_block_alloc();\n\t\tif (NULL == block) {\n\t\t\tprintk(KERN_INFO \"btrfsic: error, kmalloc failed!\\n\");\n\t\t\treturn NULL;\n\t\t}\n\t\tdev_state = btrfsic_dev_state_lookup(block_ctx->dev->bdev);\n\t\tif (NULL == dev_state) {\n\t\t\tprintk(KERN_INFO\n\t\t\t       \"btrfsic: error, lookup dev_state failed!\\n\");\n\t\t\tbtrfsic_block_free(block);\n\t\t\treturn NULL;\n\t\t}\n\t\tblock->dev_state = dev_state;\n\t\tblock->dev_bytenr = block_ctx->dev_bytenr;\n\t\tblock->logical_bytenr = block_ctx->start;\n\t\tblock->is_metadata = is_metadata;\n\t\tblock->is_iodone = is_iodone;\n\t\tblock->never_written = never_written;\n\t\tblock->mirror_num = mirror_num;\n\t\tif (state->print_mask & BTRFSIC_PRINT_MASK_VERBOSE)\n\t\t\tprintk(KERN_INFO\n\t\t\t       \"New %s%c-block @%llu (%s/%llu/%d)\\n\",\n\t\t\t       additional_string,\n\t\t\t       btrfsic_get_block_type(state, block),\n\t\t\t       block->logical_bytenr, dev_state->name,\n\t\t\t       block->dev_bytenr, mirror_num);\n\t\tlist_add(&block->all_blocks_node, &state->all_blocks_list);\n\t\tbtrfsic_block_hashtable_add(block, &state->block_hashtable);\n\t\tif (NULL != was_created)\n\t\t\t*was_created = 1;\n\t} else {\n\t\tif (NULL != was_created)\n\t\t\t*was_created = 0;\n\t}\n\n\treturn block;\n}"
  },
  {
    "function_name": "btrfsic_block_link_lookup_or_add",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/check-integrity.c",
    "lines": "2735-2778",
    "snippet": "static struct btrfsic_block_link *btrfsic_block_link_lookup_or_add(\n\t\tstruct btrfsic_state *state,\n\t\tstruct btrfsic_block_data_ctx *next_block_ctx,\n\t\tstruct btrfsic_block *next_block,\n\t\tstruct btrfsic_block *from_block,\n\t\tu64 parent_generation)\n{\n\tstruct btrfsic_block_link *l;\n\n\tl = btrfsic_block_link_hashtable_lookup(next_block_ctx->dev->bdev,\n\t\t\t\t\t\tnext_block_ctx->dev_bytenr,\n\t\t\t\t\t\tfrom_block->dev_state->bdev,\n\t\t\t\t\t\tfrom_block->dev_bytenr,\n\t\t\t\t\t\t&state->block_link_hashtable);\n\tif (NULL == l) {\n\t\tl = btrfsic_block_link_alloc();\n\t\tif (NULL == l) {\n\t\t\tprintk(KERN_INFO\n\t\t\t       \"btrfsic: error, kmalloc\" \" failed!\\n\");\n\t\t\treturn NULL;\n\t\t}\n\n\t\tl->block_ref_to = next_block;\n\t\tl->block_ref_from = from_block;\n\t\tl->ref_cnt = 1;\n\t\tl->parent_generation = parent_generation;\n\n\t\tif (state->print_mask & BTRFSIC_PRINT_MASK_VERBOSE)\n\t\t\tbtrfsic_print_add_link(state, l);\n\n\t\tlist_add(&l->node_ref_to, &from_block->ref_to_list);\n\t\tlist_add(&l->node_ref_from, &next_block->ref_from_list);\n\n\t\tbtrfsic_block_link_hashtable_add(l,\n\t\t\t\t\t\t &state->block_link_hashtable);\n\t} else {\n\t\tl->ref_cnt++;\n\t\tl->parent_generation = parent_generation;\n\t\tif (state->print_mask & BTRFSIC_PRINT_MASK_VERBOSE)\n\t\t\tbtrfsic_print_add_link(state, l);\n\t}\n\n\treturn l;\n}",
    "includes": [
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"volumes.h\"",
      "#include \"extent_io.h\"",
      "#include \"transaction.h\"",
      "#include \"hash.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/genhd.h>",
      "#include <linux/mutex.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [
      "#define BTRFSIC_PRINT_MASK_VERBOSE\t\t\t\t0x00000040"
    ],
    "globals_used": [
      "static void btrfsic_block_link_init(struct btrfsic_block_link *n);",
      "static struct btrfsic_block_link *btrfsic_block_link_alloc(void);",
      "static void btrfsic_block_link_free(struct btrfsic_block_link *n);",
      "static void btrfsic_block_link_hashtable_remove(struct btrfsic_block_link *l);",
      "static int btrfsic_create_link_to_next_block(\n\t\tstruct btrfsic_state *state,\n\t\tstruct btrfsic_block *block,\n\t\tstruct btrfsic_block_data_ctx\n\t\t*block_ctx, u64 next_bytenr,\n\t\tint limit_nesting,\n\t\tstruct btrfsic_block_data_ctx *next_block_ctx,\n\t\tstruct btrfsic_block **next_blockp,\n\t\tint force_iodone_flag,\n\t\tint *num_copiesp, int *mirror_nump,\n\t\tstruct btrfs_disk_key *disk_key,\n\t\tu64 parent_generation);",
      "static void btrfsic_dump_database(struct btrfsic_state *state);",
      "static void btrfsic_print_add_link(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block_link *l);",
      "static void btrfsic_print_rem_link(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block_link *l);",
      "static void btrfsic_dump_tree(const struct btrfsic_state *state);",
      "static struct btrfsic_block_link *btrfsic_block_link_lookup_or_add(\n\t\tstruct btrfsic_state *state,\n\t\tstruct btrfsic_block_data_ctx *next_block_ctx,\n\t\tstruct btrfsic_block *next_block,\n\t\tstruct btrfsic_block *from_block,\n\t\tu64 parent_generation);",
      "static struct btrfsic_dev_state *btrfsic_dev_state_lookup(\n\t\tstruct block_device *bdev);",
      "static void btrfsic_cmp_log_and_dev_bytenr(struct btrfsic_state *state,\n\t\t\t\t\t   u64 bytenr,\n\t\t\t\t\t   struct btrfsic_dev_state *dev_state,\n\t\t\t\t\t   u64 dev_bytenr);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfsic_print_add_link",
          "args": [
            "state",
            "l"
          ],
          "line": 2774
        },
        "resolved": true,
        "details": {
          "function_name": "btrfsic_print_add_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/check-integrity.c",
          "lines": "2614-2629",
          "snippet": "static void btrfsic_print_add_link(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block_link *l)\n{\n\tprintk(KERN_INFO\n\t       \"Add %u* link from %c @%llu (%s/%llu/%d)\"\n\t       \" to %c @%llu (%s/%llu/%d).\\n\",\n\t       l->ref_cnt,\n\t       btrfsic_get_block_type(state, l->block_ref_from),\n\t       l->block_ref_from->logical_bytenr,\n\t       l->block_ref_from->dev_state->name,\n\t       l->block_ref_from->dev_bytenr, l->block_ref_from->mirror_num,\n\t       btrfsic_get_block_type(state, l->block_ref_to),\n\t       l->block_ref_to->logical_bytenr,\n\t       l->block_ref_to->dev_state->name, l->block_ref_to->dev_bytenr,\n\t       l->block_ref_to->mirror_num);\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"extent_io.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/genhd.h>",
            "#include <linux/mutex.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void btrfsic_block_link_init(struct btrfsic_block_link *n);",
            "static void btrfsic_block_link_free(struct btrfsic_block_link *n);",
            "static void btrfsic_block_link_hashtable_remove(struct btrfsic_block_link *l);",
            "static int btrfsic_map_block(struct btrfsic_state *state, u64 bytenr, u32 len,\n\t\t\t     struct btrfsic_block_data_ctx *block_ctx_out,\n\t\t\t     int mirror_num);",
            "static void btrfsic_dump_database(struct btrfsic_state *state);",
            "static void btrfsic_print_add_link(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block_link *l);",
            "static void btrfsic_print_rem_link(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block_link *l);",
            "static void btrfsic_dump_tree(const struct btrfsic_state *state);",
            "static void btrfsic_cmp_log_and_dev_bytenr(struct btrfsic_state *state,\n\t\t\t\t\t   u64 bytenr,\n\t\t\t\t\t   struct btrfsic_dev_state *dev_state,\n\t\t\t\t\t   u64 dev_bytenr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"extent_io.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n#include <linux/blkdev.h>\n#include <linux/genhd.h>\n#include <linux/mutex.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic void btrfsic_block_link_init(struct btrfsic_block_link *n);\nstatic void btrfsic_block_link_free(struct btrfsic_block_link *n);\nstatic void btrfsic_block_link_hashtable_remove(struct btrfsic_block_link *l);\nstatic int btrfsic_map_block(struct btrfsic_state *state, u64 bytenr, u32 len,\n\t\t\t     struct btrfsic_block_data_ctx *block_ctx_out,\n\t\t\t     int mirror_num);\nstatic void btrfsic_dump_database(struct btrfsic_state *state);\nstatic void btrfsic_print_add_link(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block_link *l);\nstatic void btrfsic_print_rem_link(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block_link *l);\nstatic void btrfsic_dump_tree(const struct btrfsic_state *state);\nstatic void btrfsic_cmp_log_and_dev_bytenr(struct btrfsic_state *state,\n\t\t\t\t\t   u64 bytenr,\n\t\t\t\t\t   struct btrfsic_dev_state *dev_state,\n\t\t\t\t\t   u64 dev_bytenr);\n\nstatic void btrfsic_print_add_link(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block_link *l)\n{\n\tprintk(KERN_INFO\n\t       \"Add %u* link from %c @%llu (%s/%llu/%d)\"\n\t       \" to %c @%llu (%s/%llu/%d).\\n\",\n\t       l->ref_cnt,\n\t       btrfsic_get_block_type(state, l->block_ref_from),\n\t       l->block_ref_from->logical_bytenr,\n\t       l->block_ref_from->dev_state->name,\n\t       l->block_ref_from->dev_bytenr, l->block_ref_from->mirror_num,\n\t       btrfsic_get_block_type(state, l->block_ref_to),\n\t       l->block_ref_to->logical_bytenr,\n\t       l->block_ref_to->dev_state->name, l->block_ref_to->dev_bytenr,\n\t       l->block_ref_to->mirror_num);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfsic_block_link_hashtable_add",
          "args": [
            "l",
            "&state->block_link_hashtable"
          ],
          "line": 2768
        },
        "resolved": true,
        "details": {
          "function_name": "btrfsic_block_link_hashtable_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/check-integrity.c",
          "lines": "557-571",
          "snippet": "static void btrfsic_block_link_hashtable_add(\n\t\tstruct btrfsic_block_link *l,\n\t\tstruct btrfsic_block_link_hashtable *h)\n{\n\tconst unsigned int hashval =\n\t    (((unsigned int)(l->block_ref_to->dev_bytenr >> 16)) ^\n\t     ((unsigned int)(l->block_ref_from->dev_bytenr >> 16)) ^\n\t     ((unsigned int)((uintptr_t)l->block_ref_to->dev_state->bdev)) ^\n\t     ((unsigned int)((uintptr_t)l->block_ref_from->dev_state->bdev)))\n\t     & (BTRFSIC_BLOCK_LINK_HASHTABLE_SIZE - 1);\n\n\tBUG_ON(NULL == l->block_ref_to);\n\tBUG_ON(NULL == l->block_ref_from);\n\tlist_add(&l->collision_resolving_node, h->table + hashval);\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"extent_io.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/genhd.h>",
            "#include <linux/mutex.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define BTRFSIC_BLOCK_LINK_HASHTABLE_SIZE 0x10000"
          ],
          "globals_used": [
            "static void btrfsic_block_hashtable_init(struct btrfsic_block_hashtable *h);",
            "static void btrfsic_block_hashtable_add(struct btrfsic_block *b,\n\t\t\t\t\tstruct btrfsic_block_hashtable *h);",
            "static struct btrfsic_block *btrfsic_block_hashtable_lookup(\n\t\tstruct block_device *bdev,\n\t\tu64 dev_bytenr,\n\t\tstruct btrfsic_block_hashtable *h);",
            "static void btrfsic_block_link_hashtable_init(\n\t\tstruct btrfsic_block_link_hashtable *h);",
            "static void btrfsic_block_link_hashtable_add(\n\t\tstruct btrfsic_block_link *l,\n\t\tstruct btrfsic_block_link_hashtable *h);",
            "static void btrfsic_block_link_hashtable_remove(struct btrfsic_block_link *l);",
            "static struct btrfsic_block_link *btrfsic_block_link_hashtable_lookup(\n\t\tstruct block_device *bdev_ref_to,\n\t\tu64 dev_bytenr_ref_to,\n\t\tstruct block_device *bdev_ref_from,\n\t\tu64 dev_bytenr_ref_from,\n\t\tstruct btrfsic_block_link_hashtable *h);",
            "static void btrfsic_dev_state_hashtable_init(\n\t\tstruct btrfsic_dev_state_hashtable *h);",
            "static void btrfsic_dev_state_hashtable_add(\n\t\tstruct btrfsic_dev_state *ds,\n\t\tstruct btrfsic_dev_state_hashtable *h);",
            "static struct btrfsic_dev_state *btrfsic_dev_state_hashtable_lookup(\n\t\tstruct block_device *bdev,\n\t\tstruct btrfsic_dev_state_hashtable *h);",
            "static void btrfsic_print_add_link(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block_link *l);",
            "static void btrfsic_print_rem_link(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block_link *l);",
            "static struct btrfsic_dev_state *btrfsic_dev_state_lookup(\n\t\tstruct block_device *bdev);",
            "static void btrfsic_cmp_log_and_dev_bytenr(struct btrfsic_state *state,\n\t\t\t\t\t   u64 bytenr,\n\t\t\t\t\t   struct btrfsic_dev_state *dev_state,\n\t\t\t\t\t   u64 dev_bytenr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"extent_io.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n#include <linux/blkdev.h>\n#include <linux/genhd.h>\n#include <linux/mutex.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\n#define BTRFSIC_BLOCK_LINK_HASHTABLE_SIZE 0x10000\n\nstatic void btrfsic_block_hashtable_init(struct btrfsic_block_hashtable *h);\nstatic void btrfsic_block_hashtable_add(struct btrfsic_block *b,\n\t\t\t\t\tstruct btrfsic_block_hashtable *h);\nstatic struct btrfsic_block *btrfsic_block_hashtable_lookup(\n\t\tstruct block_device *bdev,\n\t\tu64 dev_bytenr,\n\t\tstruct btrfsic_block_hashtable *h);\nstatic void btrfsic_block_link_hashtable_init(\n\t\tstruct btrfsic_block_link_hashtable *h);\nstatic void btrfsic_block_link_hashtable_add(\n\t\tstruct btrfsic_block_link *l,\n\t\tstruct btrfsic_block_link_hashtable *h);\nstatic void btrfsic_block_link_hashtable_remove(struct btrfsic_block_link *l);\nstatic struct btrfsic_block_link *btrfsic_block_link_hashtable_lookup(\n\t\tstruct block_device *bdev_ref_to,\n\t\tu64 dev_bytenr_ref_to,\n\t\tstruct block_device *bdev_ref_from,\n\t\tu64 dev_bytenr_ref_from,\n\t\tstruct btrfsic_block_link_hashtable *h);\nstatic void btrfsic_dev_state_hashtable_init(\n\t\tstruct btrfsic_dev_state_hashtable *h);\nstatic void btrfsic_dev_state_hashtable_add(\n\t\tstruct btrfsic_dev_state *ds,\n\t\tstruct btrfsic_dev_state_hashtable *h);\nstatic struct btrfsic_dev_state *btrfsic_dev_state_hashtable_lookup(\n\t\tstruct block_device *bdev,\n\t\tstruct btrfsic_dev_state_hashtable *h);\nstatic void btrfsic_print_add_link(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block_link *l);\nstatic void btrfsic_print_rem_link(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block_link *l);\nstatic struct btrfsic_dev_state *btrfsic_dev_state_lookup(\n\t\tstruct block_device *bdev);\nstatic void btrfsic_cmp_log_and_dev_bytenr(struct btrfsic_state *state,\n\t\t\t\t\t   u64 bytenr,\n\t\t\t\t\t   struct btrfsic_dev_state *dev_state,\n\t\t\t\t\t   u64 dev_bytenr);\n\nstatic void btrfsic_block_link_hashtable_add(\n\t\tstruct btrfsic_block_link *l,\n\t\tstruct btrfsic_block_link_hashtable *h)\n{\n\tconst unsigned int hashval =\n\t    (((unsigned int)(l->block_ref_to->dev_bytenr >> 16)) ^\n\t     ((unsigned int)(l->block_ref_from->dev_bytenr >> 16)) ^\n\t     ((unsigned int)((uintptr_t)l->block_ref_to->dev_state->bdev)) ^\n\t     ((unsigned int)((uintptr_t)l->block_ref_from->dev_state->bdev)))\n\t     & (BTRFSIC_BLOCK_LINK_HASHTABLE_SIZE - 1);\n\n\tBUG_ON(NULL == l->block_ref_to);\n\tBUG_ON(NULL == l->block_ref_from);\n\tlist_add(&l->collision_resolving_node, h->table + hashval);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&l->node_ref_from",
            "&next_block->ref_from_list"
          ],
          "line": 2766
        },
        "resolved": true,
        "details": {
          "function_name": "simple_xattr_list_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "966-972",
          "snippet": "void simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_INFO\n\t\t\t       \"btrfsic: error, kmalloc\" \" failed!\\n\""
          ],
          "line": 2752
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfsic_block_link_alloc",
          "args": [],
          "line": 2750
        },
        "resolved": true,
        "details": {
          "function_name": "btrfsic_block_link_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/check-integrity.c",
          "lines": "453-462",
          "snippet": "static struct btrfsic_block_link *btrfsic_block_link_alloc(void)\n{\n\tstruct btrfsic_block_link *l;\n\n\tl = kzalloc(sizeof(*l), GFP_NOFS);\n\tif (NULL != l)\n\t\tbtrfsic_block_link_init(l);\n\n\treturn l;\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"extent_io.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/genhd.h>",
            "#include <linux/mutex.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct btrfsic_block_link *btrfsic_block_link_alloc(void);",
            "static void btrfsic_block_link_hashtable_remove(struct btrfsic_block_link *l);",
            "static void btrfsic_print_add_link(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block_link *l);",
            "static void btrfsic_print_rem_link(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block_link *l);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"extent_io.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n#include <linux/blkdev.h>\n#include <linux/genhd.h>\n#include <linux/mutex.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct btrfsic_block_link *btrfsic_block_link_alloc(void);\nstatic void btrfsic_block_link_hashtable_remove(struct btrfsic_block_link *l);\nstatic void btrfsic_print_add_link(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block_link *l);\nstatic void btrfsic_print_rem_link(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block_link *l);\n\nstatic struct btrfsic_block_link *btrfsic_block_link_alloc(void)\n{\n\tstruct btrfsic_block_link *l;\n\n\tl = kzalloc(sizeof(*l), GFP_NOFS);\n\tif (NULL != l)\n\t\tbtrfsic_block_link_init(l);\n\n\treturn l;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfsic_block_link_hashtable_lookup",
          "args": [
            "next_block_ctx->dev->bdev",
            "next_block_ctx->dev_bytenr",
            "from_block->dev_state->bdev",
            "from_block->dev_bytenr",
            "&state->block_link_hashtable"
          ],
          "line": 2744
        },
        "resolved": true,
        "details": {
          "function_name": "btrfsic_block_link_hashtable_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/check-integrity.c",
          "lines": "578-608",
          "snippet": "static struct btrfsic_block_link *btrfsic_block_link_hashtable_lookup(\n\t\tstruct block_device *bdev_ref_to,\n\t\tu64 dev_bytenr_ref_to,\n\t\tstruct block_device *bdev_ref_from,\n\t\tu64 dev_bytenr_ref_from,\n\t\tstruct btrfsic_block_link_hashtable *h)\n{\n\tconst unsigned int hashval =\n\t    (((unsigned int)(dev_bytenr_ref_to >> 16)) ^\n\t     ((unsigned int)(dev_bytenr_ref_from >> 16)) ^\n\t     ((unsigned int)((uintptr_t)bdev_ref_to)) ^\n\t     ((unsigned int)((uintptr_t)bdev_ref_from))) &\n\t     (BTRFSIC_BLOCK_LINK_HASHTABLE_SIZE - 1);\n\tstruct list_head *elem;\n\n\tlist_for_each(elem, h->table + hashval) {\n\t\tstruct btrfsic_block_link *const l =\n\t\t    list_entry(elem, struct btrfsic_block_link,\n\t\t\t       collision_resolving_node);\n\n\t\tBUG_ON(NULL == l->block_ref_to);\n\t\tBUG_ON(NULL == l->block_ref_from);\n\t\tif (l->block_ref_to->dev_state->bdev == bdev_ref_to &&\n\t\t    l->block_ref_to->dev_bytenr == dev_bytenr_ref_to &&\n\t\t    l->block_ref_from->dev_state->bdev == bdev_ref_from &&\n\t\t    l->block_ref_from->dev_bytenr == dev_bytenr_ref_from)\n\t\t\treturn l;\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"extent_io.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/genhd.h>",
            "#include <linux/mutex.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define BTRFSIC_BLOCK_LINK_HASHTABLE_SIZE 0x10000"
          ],
          "globals_used": [
            "static void btrfsic_block_hashtable_init(struct btrfsic_block_hashtable *h);",
            "static void btrfsic_block_hashtable_add(struct btrfsic_block *b,\n\t\t\t\t\tstruct btrfsic_block_hashtable *h);",
            "static struct btrfsic_block *btrfsic_block_hashtable_lookup(\n\t\tstruct block_device *bdev,\n\t\tu64 dev_bytenr,\n\t\tstruct btrfsic_block_hashtable *h);",
            "static void btrfsic_block_link_hashtable_init(\n\t\tstruct btrfsic_block_link_hashtable *h);",
            "static void btrfsic_block_link_hashtable_add(\n\t\tstruct btrfsic_block_link *l,\n\t\tstruct btrfsic_block_link_hashtable *h);",
            "static void btrfsic_block_link_hashtable_remove(struct btrfsic_block_link *l);",
            "static struct btrfsic_block_link *btrfsic_block_link_hashtable_lookup(\n\t\tstruct block_device *bdev_ref_to,\n\t\tu64 dev_bytenr_ref_to,\n\t\tstruct block_device *bdev_ref_from,\n\t\tu64 dev_bytenr_ref_from,\n\t\tstruct btrfsic_block_link_hashtable *h);",
            "static void btrfsic_dev_state_hashtable_init(\n\t\tstruct btrfsic_dev_state_hashtable *h);",
            "static void btrfsic_dev_state_hashtable_add(\n\t\tstruct btrfsic_dev_state *ds,\n\t\tstruct btrfsic_dev_state_hashtable *h);",
            "static struct btrfsic_dev_state *btrfsic_dev_state_hashtable_lookup(\n\t\tstruct block_device *bdev,\n\t\tstruct btrfsic_dev_state_hashtable *h);",
            "static void btrfsic_print_add_link(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block_link *l);",
            "static void btrfsic_print_rem_link(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block_link *l);",
            "static struct btrfsic_dev_state *btrfsic_dev_state_lookup(\n\t\tstruct block_device *bdev);",
            "static void btrfsic_cmp_log_and_dev_bytenr(struct btrfsic_state *state,\n\t\t\t\t\t   u64 bytenr,\n\t\t\t\t\t   struct btrfsic_dev_state *dev_state,\n\t\t\t\t\t   u64 dev_bytenr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"extent_io.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n#include <linux/blkdev.h>\n#include <linux/genhd.h>\n#include <linux/mutex.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\n#define BTRFSIC_BLOCK_LINK_HASHTABLE_SIZE 0x10000\n\nstatic void btrfsic_block_hashtable_init(struct btrfsic_block_hashtable *h);\nstatic void btrfsic_block_hashtable_add(struct btrfsic_block *b,\n\t\t\t\t\tstruct btrfsic_block_hashtable *h);\nstatic struct btrfsic_block *btrfsic_block_hashtable_lookup(\n\t\tstruct block_device *bdev,\n\t\tu64 dev_bytenr,\n\t\tstruct btrfsic_block_hashtable *h);\nstatic void btrfsic_block_link_hashtable_init(\n\t\tstruct btrfsic_block_link_hashtable *h);\nstatic void btrfsic_block_link_hashtable_add(\n\t\tstruct btrfsic_block_link *l,\n\t\tstruct btrfsic_block_link_hashtable *h);\nstatic void btrfsic_block_link_hashtable_remove(struct btrfsic_block_link *l);\nstatic struct btrfsic_block_link *btrfsic_block_link_hashtable_lookup(\n\t\tstruct block_device *bdev_ref_to,\n\t\tu64 dev_bytenr_ref_to,\n\t\tstruct block_device *bdev_ref_from,\n\t\tu64 dev_bytenr_ref_from,\n\t\tstruct btrfsic_block_link_hashtable *h);\nstatic void btrfsic_dev_state_hashtable_init(\n\t\tstruct btrfsic_dev_state_hashtable *h);\nstatic void btrfsic_dev_state_hashtable_add(\n\t\tstruct btrfsic_dev_state *ds,\n\t\tstruct btrfsic_dev_state_hashtable *h);\nstatic struct btrfsic_dev_state *btrfsic_dev_state_hashtable_lookup(\n\t\tstruct block_device *bdev,\n\t\tstruct btrfsic_dev_state_hashtable *h);\nstatic void btrfsic_print_add_link(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block_link *l);\nstatic void btrfsic_print_rem_link(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block_link *l);\nstatic struct btrfsic_dev_state *btrfsic_dev_state_lookup(\n\t\tstruct block_device *bdev);\nstatic void btrfsic_cmp_log_and_dev_bytenr(struct btrfsic_state *state,\n\t\t\t\t\t   u64 bytenr,\n\t\t\t\t\t   struct btrfsic_dev_state *dev_state,\n\t\t\t\t\t   u64 dev_bytenr);\n\nstatic struct btrfsic_block_link *btrfsic_block_link_hashtable_lookup(\n\t\tstruct block_device *bdev_ref_to,\n\t\tu64 dev_bytenr_ref_to,\n\t\tstruct block_device *bdev_ref_from,\n\t\tu64 dev_bytenr_ref_from,\n\t\tstruct btrfsic_block_link_hashtable *h)\n{\n\tconst unsigned int hashval =\n\t    (((unsigned int)(dev_bytenr_ref_to >> 16)) ^\n\t     ((unsigned int)(dev_bytenr_ref_from >> 16)) ^\n\t     ((unsigned int)((uintptr_t)bdev_ref_to)) ^\n\t     ((unsigned int)((uintptr_t)bdev_ref_from))) &\n\t     (BTRFSIC_BLOCK_LINK_HASHTABLE_SIZE - 1);\n\tstruct list_head *elem;\n\n\tlist_for_each(elem, h->table + hashval) {\n\t\tstruct btrfsic_block_link *const l =\n\t\t    list_entry(elem, struct btrfsic_block_link,\n\t\t\t       collision_resolving_node);\n\n\t\tBUG_ON(NULL == l->block_ref_to);\n\t\tBUG_ON(NULL == l->block_ref_from);\n\t\tif (l->block_ref_to->dev_state->bdev == bdev_ref_to &&\n\t\t    l->block_ref_to->dev_bytenr == dev_bytenr_ref_to &&\n\t\t    l->block_ref_from->dev_state->bdev == bdev_ref_from &&\n\t\t    l->block_ref_from->dev_bytenr == dev_bytenr_ref_from)\n\t\t\treturn l;\n\t}\n\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"extent_io.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n#include <linux/blkdev.h>\n#include <linux/genhd.h>\n#include <linux/mutex.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\n#define BTRFSIC_PRINT_MASK_VERBOSE\t\t\t\t0x00000040\n\nstatic void btrfsic_block_link_init(struct btrfsic_block_link *n);\nstatic struct btrfsic_block_link *btrfsic_block_link_alloc(void);\nstatic void btrfsic_block_link_free(struct btrfsic_block_link *n);\nstatic void btrfsic_block_link_hashtable_remove(struct btrfsic_block_link *l);\nstatic int btrfsic_create_link_to_next_block(\n\t\tstruct btrfsic_state *state,\n\t\tstruct btrfsic_block *block,\n\t\tstruct btrfsic_block_data_ctx\n\t\t*block_ctx, u64 next_bytenr,\n\t\tint limit_nesting,\n\t\tstruct btrfsic_block_data_ctx *next_block_ctx,\n\t\tstruct btrfsic_block **next_blockp,\n\t\tint force_iodone_flag,\n\t\tint *num_copiesp, int *mirror_nump,\n\t\tstruct btrfs_disk_key *disk_key,\n\t\tu64 parent_generation);\nstatic void btrfsic_dump_database(struct btrfsic_state *state);\nstatic void btrfsic_print_add_link(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block_link *l);\nstatic void btrfsic_print_rem_link(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block_link *l);\nstatic void btrfsic_dump_tree(const struct btrfsic_state *state);\nstatic struct btrfsic_block_link *btrfsic_block_link_lookup_or_add(\n\t\tstruct btrfsic_state *state,\n\t\tstruct btrfsic_block_data_ctx *next_block_ctx,\n\t\tstruct btrfsic_block *next_block,\n\t\tstruct btrfsic_block *from_block,\n\t\tu64 parent_generation);\nstatic struct btrfsic_dev_state *btrfsic_dev_state_lookup(\n\t\tstruct block_device *bdev);\nstatic void btrfsic_cmp_log_and_dev_bytenr(struct btrfsic_state *state,\n\t\t\t\t\t   u64 bytenr,\n\t\t\t\t\t   struct btrfsic_dev_state *dev_state,\n\t\t\t\t\t   u64 dev_bytenr);\n\nstatic struct btrfsic_block_link *btrfsic_block_link_lookup_or_add(\n\t\tstruct btrfsic_state *state,\n\t\tstruct btrfsic_block_data_ctx *next_block_ctx,\n\t\tstruct btrfsic_block *next_block,\n\t\tstruct btrfsic_block *from_block,\n\t\tu64 parent_generation)\n{\n\tstruct btrfsic_block_link *l;\n\n\tl = btrfsic_block_link_hashtable_lookup(next_block_ctx->dev->bdev,\n\t\t\t\t\t\tnext_block_ctx->dev_bytenr,\n\t\t\t\t\t\tfrom_block->dev_state->bdev,\n\t\t\t\t\t\tfrom_block->dev_bytenr,\n\t\t\t\t\t\t&state->block_link_hashtable);\n\tif (NULL == l) {\n\t\tl = btrfsic_block_link_alloc();\n\t\tif (NULL == l) {\n\t\t\tprintk(KERN_INFO\n\t\t\t       \"btrfsic: error, kmalloc\" \" failed!\\n\");\n\t\t\treturn NULL;\n\t\t}\n\n\t\tl->block_ref_to = next_block;\n\t\tl->block_ref_from = from_block;\n\t\tl->ref_cnt = 1;\n\t\tl->parent_generation = parent_generation;\n\n\t\tif (state->print_mask & BTRFSIC_PRINT_MASK_VERBOSE)\n\t\t\tbtrfsic_print_add_link(state, l);\n\n\t\tlist_add(&l->node_ref_to, &from_block->ref_to_list);\n\t\tlist_add(&l->node_ref_from, &next_block->ref_from_list);\n\n\t\tbtrfsic_block_link_hashtable_add(l,\n\t\t\t\t\t\t &state->block_link_hashtable);\n\t} else {\n\t\tl->ref_cnt++;\n\t\tl->parent_generation = parent_generation;\n\t\tif (state->print_mask & BTRFSIC_PRINT_MASK_VERBOSE)\n\t\t\tbtrfsic_print_add_link(state, l);\n\t}\n\n\treturn l;\n}"
  },
  {
    "function_name": "btrfsic_dump_tree_sub",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/check-integrity.c",
    "lines": "2668-2733",
    "snippet": "static void btrfsic_dump_tree_sub(const struct btrfsic_state *state,\n\t\t\t\t  const struct btrfsic_block *block,\n\t\t\t\t  int indent_level)\n{\n\tstruct list_head *elem_ref_to;\n\tint indent_add;\n\tstatic char buf[80];\n\tint cursor_position;\n\n\t/*\n\t * Should better fill an on-stack buffer with a complete line and\n\t * dump it at once when it is time to print a newline character.\n\t */\n\n\t/*\n\t * This algorithm is recursive because the amount of used stack space\n\t * is very small and the max recursion depth is limited.\n\t */\n\tindent_add = sprintf(buf, \"%c-%llu(%s/%llu/%d)\",\n\t\t\t     btrfsic_get_block_type(state, block),\n\t\t\t     block->logical_bytenr, block->dev_state->name,\n\t\t\t     block->dev_bytenr, block->mirror_num);\n\tif (indent_level + indent_add > BTRFSIC_TREE_DUMP_MAX_INDENT_LEVEL) {\n\t\tprintk(\"[...]\\n\");\n\t\treturn;\n\t}\n\tprintk(buf);\n\tindent_level += indent_add;\n\tif (list_empty(&block->ref_to_list)) {\n\t\tprintk(\"\\n\");\n\t\treturn;\n\t}\n\tif (block->mirror_num > 1 &&\n\t    !(state->print_mask & BTRFSIC_PRINT_MASK_TREE_WITH_ALL_MIRRORS)) {\n\t\tprintk(\" [...]\\n\");\n\t\treturn;\n\t}\n\n\tcursor_position = indent_level;\n\tlist_for_each(elem_ref_to, &block->ref_to_list) {\n\t\tconst struct btrfsic_block_link *const l =\n\t\t    list_entry(elem_ref_to, struct btrfsic_block_link,\n\t\t\t       node_ref_to);\n\n\t\twhile (cursor_position < indent_level) {\n\t\t\tprintk(\" \");\n\t\t\tcursor_position++;\n\t\t}\n\t\tif (l->ref_cnt > 1)\n\t\t\tindent_add = sprintf(buf, \" %d*--> \", l->ref_cnt);\n\t\telse\n\t\t\tindent_add = sprintf(buf, \" --> \");\n\t\tif (indent_level + indent_add >\n\t\t    BTRFSIC_TREE_DUMP_MAX_INDENT_LEVEL) {\n\t\t\tprintk(\"[...]\\n\");\n\t\t\tcursor_position = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\tprintk(buf);\n\n\t\tbtrfsic_dump_tree_sub(state, l->block_ref_to,\n\t\t\t\t      indent_level + indent_add);\n\t\tcursor_position = 0;\n\t}\n}",
    "includes": [
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"volumes.h\"",
      "#include \"extent_io.h\"",
      "#include \"transaction.h\"",
      "#include \"hash.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/genhd.h>",
      "#include <linux/mutex.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [
      "#define BTRFSIC_PRINT_MASK_TREE_WITH_ALL_MIRRORS\t\t0x00001000",
      "#define BTRFSIC_TREE_DUMP_MAX_INDENT_LEVEL (200 - 6)\t/* in characters,\n\t\t\t\t\t\t\t * excluding \" [...]\" */"
    ],
    "globals_used": [
      "static void btrfsic_block_link_init(struct btrfsic_block_link *n);",
      "static void btrfsic_block_link_free(struct btrfsic_block_link *n);",
      "static void btrfsic_block_link_hashtable_remove(struct btrfsic_block_link *l);",
      "static int btrfsic_map_block(struct btrfsic_state *state, u64 bytenr, u32 len,\n\t\t\t     struct btrfsic_block_data_ctx *block_ctx_out,\n\t\t\t     int mirror_num);",
      "static void btrfsic_dump_database(struct btrfsic_state *state);",
      "static void btrfsic_print_add_link(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block_link *l);",
      "static void btrfsic_print_rem_link(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block_link *l);",
      "static char btrfsic_get_block_type(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block *block);",
      "static void btrfsic_dump_tree(const struct btrfsic_state *state);",
      "static void btrfsic_dump_tree_sub(const struct btrfsic_state *state,\n\t\t\t\t  const struct btrfsic_block *block,\n\t\t\t\t  int indent_level);",
      "static void btrfsic_cmp_log_and_dev_bytenr(struct btrfsic_state *state,\n\t\t\t\t\t   u64 bytenr,\n\t\t\t\t\t   struct btrfsic_dev_state *dev_state,\n\t\t\t\t\t   u64 dev_bytenr);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfsic_dump_tree_sub",
          "args": [
            "state",
            "l->block_ref_to",
            "indent_level + indent_add"
          ],
          "line": 2729
        },
        "resolved": true,
        "details": {
          "function_name": "btrfsic_dump_tree_sub",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/check-integrity.c",
          "lines": "2668-2733",
          "snippet": "static void btrfsic_dump_tree_sub(const struct btrfsic_state *state,\n\t\t\t\t  const struct btrfsic_block *block,\n\t\t\t\t  int indent_level)\n{\n\tstruct list_head *elem_ref_to;\n\tint indent_add;\n\tstatic char buf[80];\n\tint cursor_position;\n\n\t/*\n\t * Should better fill an on-stack buffer with a complete line and\n\t * dump it at once when it is time to print a newline character.\n\t */\n\n\t/*\n\t * This algorithm is recursive because the amount of used stack space\n\t * is very small and the max recursion depth is limited.\n\t */\n\tindent_add = sprintf(buf, \"%c-%llu(%s/%llu/%d)\",\n\t\t\t     btrfsic_get_block_type(state, block),\n\t\t\t     block->logical_bytenr, block->dev_state->name,\n\t\t\t     block->dev_bytenr, block->mirror_num);\n\tif (indent_level + indent_add > BTRFSIC_TREE_DUMP_MAX_INDENT_LEVEL) {\n\t\tprintk(\"[...]\\n\");\n\t\treturn;\n\t}\n\tprintk(buf);\n\tindent_level += indent_add;\n\tif (list_empty(&block->ref_to_list)) {\n\t\tprintk(\"\\n\");\n\t\treturn;\n\t}\n\tif (block->mirror_num > 1 &&\n\t    !(state->print_mask & BTRFSIC_PRINT_MASK_TREE_WITH_ALL_MIRRORS)) {\n\t\tprintk(\" [...]\\n\");\n\t\treturn;\n\t}\n\n\tcursor_position = indent_level;\n\tlist_for_each(elem_ref_to, &block->ref_to_list) {\n\t\tconst struct btrfsic_block_link *const l =\n\t\t    list_entry(elem_ref_to, struct btrfsic_block_link,\n\t\t\t       node_ref_to);\n\n\t\twhile (cursor_position < indent_level) {\n\t\t\tprintk(\" \");\n\t\t\tcursor_position++;\n\t\t}\n\t\tif (l->ref_cnt > 1)\n\t\t\tindent_add = sprintf(buf, \" %d*--> \", l->ref_cnt);\n\t\telse\n\t\t\tindent_add = sprintf(buf, \" --> \");\n\t\tif (indent_level + indent_add >\n\t\t    BTRFSIC_TREE_DUMP_MAX_INDENT_LEVEL) {\n\t\t\tprintk(\"[...]\\n\");\n\t\t\tcursor_position = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\tprintk(buf);\n\n\t\tbtrfsic_dump_tree_sub(state, l->block_ref_to,\n\t\t\t\t      indent_level + indent_add);\n\t\tcursor_position = 0;\n\t}\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "buf"
          ],
          "line": 2727
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\" --> \""
          ],
          "line": 2719
        },
        "resolved": true,
        "details": {
          "function_name": "sprintf_disk_child",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/prints.c",
          "lines": "154-158",
          "snippet": "static void sprintf_disk_child(char *buf, struct disk_child *dc)\n{\n\tsprintf(buf, \"[dc_number=%d, dc_size=%u]\", dc_block_number(dc),\n\t\tdc_size(dc));\n}",
          "includes": [
            "#include <stdarg.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdarg.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic void sprintf_disk_child(char *buf, struct disk_child *dc)\n{\n\tsprintf(buf, \"[dc_number=%d, dc_size=%u]\", dc_block_number(dc),\n\t\tdc_size(dc));\n}"
        }
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\" %d*--> \"",
            "l->ref_cnt"
          ],
          "line": 2717
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "elem_ref_to",
            "structbtrfsic_block_link",
            "node_ref_to"
          ],
          "line": 2709
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each",
          "args": [
            "elem_ref_to",
            "&block->ref_to_list"
          ],
          "line": 2707
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&block->ref_to_list"
          ],
          "line": 2696
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\"%c-%llu(%s/%llu/%d)\"",
            "btrfsic_get_block_type(state, block)",
            "block->logical_bytenr",
            "block->dev_state->name",
            "block->dev_bytenr",
            "block->mirror_num"
          ],
          "line": 2686
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfsic_get_block_type",
          "args": [
            "state",
            "block"
          ],
          "line": 2687
        },
        "resolved": true,
        "details": {
          "function_name": "btrfsic_get_block_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/check-integrity.c",
          "lines": "2648-2661",
          "snippet": "static char btrfsic_get_block_type(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block *block)\n{\n\tif (block->is_superblock &&\n\t    state->latest_superblock->dev_bytenr == block->dev_bytenr &&\n\t    state->latest_superblock->dev_state->bdev == block->dev_state->bdev)\n\t\treturn 'S';\n\telse if (block->is_superblock)\n\t\treturn 's';\n\telse if (block->is_metadata)\n\t\treturn 'M';\n\telse\n\t\treturn 'D';\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"extent_io.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/genhd.h>",
            "#include <linux/mutex.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void btrfsic_dump_database(struct btrfsic_state *state);",
            "static char btrfsic_get_block_type(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block *block);",
            "static void btrfsic_dump_tree(const struct btrfsic_state *state);",
            "static struct btrfsic_dev_state *btrfsic_dev_state_lookup(\n\t\tstruct block_device *bdev);",
            "static void btrfsic_cmp_log_and_dev_bytenr(struct btrfsic_state *state,\n\t\t\t\t\t   u64 bytenr,\n\t\t\t\t\t   struct btrfsic_dev_state *dev_state,\n\t\t\t\t\t   u64 dev_bytenr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"extent_io.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n#include <linux/blkdev.h>\n#include <linux/genhd.h>\n#include <linux/mutex.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic void btrfsic_dump_database(struct btrfsic_state *state);\nstatic char btrfsic_get_block_type(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block *block);\nstatic void btrfsic_dump_tree(const struct btrfsic_state *state);\nstatic struct btrfsic_dev_state *btrfsic_dev_state_lookup(\n\t\tstruct block_device *bdev);\nstatic void btrfsic_cmp_log_and_dev_bytenr(struct btrfsic_state *state,\n\t\t\t\t\t   u64 bytenr,\n\t\t\t\t\t   struct btrfsic_dev_state *dev_state,\n\t\t\t\t\t   u64 dev_bytenr);\n\nstatic char btrfsic_get_block_type(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block *block)\n{\n\tif (block->is_superblock &&\n\t    state->latest_superblock->dev_bytenr == block->dev_bytenr &&\n\t    state->latest_superblock->dev_state->bdev == block->dev_state->bdev)\n\t\treturn 'S';\n\telse if (block->is_superblock)\n\t\treturn 's';\n\telse if (block->is_metadata)\n\t\treturn 'M';\n\telse\n\t\treturn 'D';\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"extent_io.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n#include <linux/blkdev.h>\n#include <linux/genhd.h>\n#include <linux/mutex.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\n#define BTRFSIC_PRINT_MASK_TREE_WITH_ALL_MIRRORS\t\t0x00001000\n#define BTRFSIC_TREE_DUMP_MAX_INDENT_LEVEL (200 - 6)\t/* in characters,\n\t\t\t\t\t\t\t * excluding \" [...]\" */\n\nstatic void btrfsic_block_link_init(struct btrfsic_block_link *n);\nstatic void btrfsic_block_link_free(struct btrfsic_block_link *n);\nstatic void btrfsic_block_link_hashtable_remove(struct btrfsic_block_link *l);\nstatic int btrfsic_map_block(struct btrfsic_state *state, u64 bytenr, u32 len,\n\t\t\t     struct btrfsic_block_data_ctx *block_ctx_out,\n\t\t\t     int mirror_num);\nstatic void btrfsic_dump_database(struct btrfsic_state *state);\nstatic void btrfsic_print_add_link(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block_link *l);\nstatic void btrfsic_print_rem_link(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block_link *l);\nstatic char btrfsic_get_block_type(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block *block);\nstatic void btrfsic_dump_tree(const struct btrfsic_state *state);\nstatic void btrfsic_dump_tree_sub(const struct btrfsic_state *state,\n\t\t\t\t  const struct btrfsic_block *block,\n\t\t\t\t  int indent_level);\nstatic void btrfsic_cmp_log_and_dev_bytenr(struct btrfsic_state *state,\n\t\t\t\t\t   u64 bytenr,\n\t\t\t\t\t   struct btrfsic_dev_state *dev_state,\n\t\t\t\t\t   u64 dev_bytenr);\n\nstatic void btrfsic_dump_tree_sub(const struct btrfsic_state *state,\n\t\t\t\t  const struct btrfsic_block *block,\n\t\t\t\t  int indent_level)\n{\n\tstruct list_head *elem_ref_to;\n\tint indent_add;\n\tstatic char buf[80];\n\tint cursor_position;\n\n\t/*\n\t * Should better fill an on-stack buffer with a complete line and\n\t * dump it at once when it is time to print a newline character.\n\t */\n\n\t/*\n\t * This algorithm is recursive because the amount of used stack space\n\t * is very small and the max recursion depth is limited.\n\t */\n\tindent_add = sprintf(buf, \"%c-%llu(%s/%llu/%d)\",\n\t\t\t     btrfsic_get_block_type(state, block),\n\t\t\t     block->logical_bytenr, block->dev_state->name,\n\t\t\t     block->dev_bytenr, block->mirror_num);\n\tif (indent_level + indent_add > BTRFSIC_TREE_DUMP_MAX_INDENT_LEVEL) {\n\t\tprintk(\"[...]\\n\");\n\t\treturn;\n\t}\n\tprintk(buf);\n\tindent_level += indent_add;\n\tif (list_empty(&block->ref_to_list)) {\n\t\tprintk(\"\\n\");\n\t\treturn;\n\t}\n\tif (block->mirror_num > 1 &&\n\t    !(state->print_mask & BTRFSIC_PRINT_MASK_TREE_WITH_ALL_MIRRORS)) {\n\t\tprintk(\" [...]\\n\");\n\t\treturn;\n\t}\n\n\tcursor_position = indent_level;\n\tlist_for_each(elem_ref_to, &block->ref_to_list) {\n\t\tconst struct btrfsic_block_link *const l =\n\t\t    list_entry(elem_ref_to, struct btrfsic_block_link,\n\t\t\t       node_ref_to);\n\n\t\twhile (cursor_position < indent_level) {\n\t\t\tprintk(\" \");\n\t\t\tcursor_position++;\n\t\t}\n\t\tif (l->ref_cnt > 1)\n\t\t\tindent_add = sprintf(buf, \" %d*--> \", l->ref_cnt);\n\t\telse\n\t\t\tindent_add = sprintf(buf, \" --> \");\n\t\tif (indent_level + indent_add >\n\t\t    BTRFSIC_TREE_DUMP_MAX_INDENT_LEVEL) {\n\t\t\tprintk(\"[...]\\n\");\n\t\t\tcursor_position = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\tprintk(buf);\n\n\t\tbtrfsic_dump_tree_sub(state, l->block_ref_to,\n\t\t\t\t      indent_level + indent_add);\n\t\tcursor_position = 0;\n\t}\n}"
  },
  {
    "function_name": "btrfsic_dump_tree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/check-integrity.c",
    "lines": "2663-2666",
    "snippet": "static void btrfsic_dump_tree(const struct btrfsic_state *state)\n{\n\tbtrfsic_dump_tree_sub(state, state->latest_superblock, 0);\n}",
    "includes": [
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"volumes.h\"",
      "#include \"extent_io.h\"",
      "#include \"transaction.h\"",
      "#include \"hash.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/genhd.h>",
      "#include <linux/mutex.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void btrfsic_dump_database(struct btrfsic_state *state);",
      "static void btrfsic_dump_tree(const struct btrfsic_state *state);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfsic_dump_tree_sub",
          "args": [
            "state",
            "state->latest_superblock",
            "0"
          ],
          "line": 2665
        },
        "resolved": true,
        "details": {
          "function_name": "btrfsic_dump_tree_sub",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/check-integrity.c",
          "lines": "2668-2733",
          "snippet": "static void btrfsic_dump_tree_sub(const struct btrfsic_state *state,\n\t\t\t\t  const struct btrfsic_block *block,\n\t\t\t\t  int indent_level)\n{\n\tstruct list_head *elem_ref_to;\n\tint indent_add;\n\tstatic char buf[80];\n\tint cursor_position;\n\n\t/*\n\t * Should better fill an on-stack buffer with a complete line and\n\t * dump it at once when it is time to print a newline character.\n\t */\n\n\t/*\n\t * This algorithm is recursive because the amount of used stack space\n\t * is very small and the max recursion depth is limited.\n\t */\n\tindent_add = sprintf(buf, \"%c-%llu(%s/%llu/%d)\",\n\t\t\t     btrfsic_get_block_type(state, block),\n\t\t\t     block->logical_bytenr, block->dev_state->name,\n\t\t\t     block->dev_bytenr, block->mirror_num);\n\tif (indent_level + indent_add > BTRFSIC_TREE_DUMP_MAX_INDENT_LEVEL) {\n\t\tprintk(\"[...]\\n\");\n\t\treturn;\n\t}\n\tprintk(buf);\n\tindent_level += indent_add;\n\tif (list_empty(&block->ref_to_list)) {\n\t\tprintk(\"\\n\");\n\t\treturn;\n\t}\n\tif (block->mirror_num > 1 &&\n\t    !(state->print_mask & BTRFSIC_PRINT_MASK_TREE_WITH_ALL_MIRRORS)) {\n\t\tprintk(\" [...]\\n\");\n\t\treturn;\n\t}\n\n\tcursor_position = indent_level;\n\tlist_for_each(elem_ref_to, &block->ref_to_list) {\n\t\tconst struct btrfsic_block_link *const l =\n\t\t    list_entry(elem_ref_to, struct btrfsic_block_link,\n\t\t\t       node_ref_to);\n\n\t\twhile (cursor_position < indent_level) {\n\t\t\tprintk(\" \");\n\t\t\tcursor_position++;\n\t\t}\n\t\tif (l->ref_cnt > 1)\n\t\t\tindent_add = sprintf(buf, \" %d*--> \", l->ref_cnt);\n\t\telse\n\t\t\tindent_add = sprintf(buf, \" --> \");\n\t\tif (indent_level + indent_add >\n\t\t    BTRFSIC_TREE_DUMP_MAX_INDENT_LEVEL) {\n\t\t\tprintk(\"[...]\\n\");\n\t\t\tcursor_position = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\tprintk(buf);\n\n\t\tbtrfsic_dump_tree_sub(state, l->block_ref_to,\n\t\t\t\t      indent_level + indent_add);\n\t\tcursor_position = 0;\n\t}\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"extent_io.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/genhd.h>",
            "#include <linux/mutex.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define BTRFSIC_PRINT_MASK_TREE_WITH_ALL_MIRRORS\t\t0x00001000",
            "#define BTRFSIC_TREE_DUMP_MAX_INDENT_LEVEL (200 - 6)\t/* in characters,\n\t\t\t\t\t\t\t * excluding \" [...]\" */"
          ],
          "globals_used": [
            "static void btrfsic_block_link_init(struct btrfsic_block_link *n);",
            "static void btrfsic_block_link_free(struct btrfsic_block_link *n);",
            "static void btrfsic_block_link_hashtable_remove(struct btrfsic_block_link *l);",
            "static int btrfsic_map_block(struct btrfsic_state *state, u64 bytenr, u32 len,\n\t\t\t     struct btrfsic_block_data_ctx *block_ctx_out,\n\t\t\t     int mirror_num);",
            "static void btrfsic_dump_database(struct btrfsic_state *state);",
            "static void btrfsic_print_add_link(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block_link *l);",
            "static void btrfsic_print_rem_link(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block_link *l);",
            "static char btrfsic_get_block_type(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block *block);",
            "static void btrfsic_dump_tree(const struct btrfsic_state *state);",
            "static void btrfsic_dump_tree_sub(const struct btrfsic_state *state,\n\t\t\t\t  const struct btrfsic_block *block,\n\t\t\t\t  int indent_level);",
            "static void btrfsic_cmp_log_and_dev_bytenr(struct btrfsic_state *state,\n\t\t\t\t\t   u64 bytenr,\n\t\t\t\t\t   struct btrfsic_dev_state *dev_state,\n\t\t\t\t\t   u64 dev_bytenr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"extent_io.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n#include <linux/blkdev.h>\n#include <linux/genhd.h>\n#include <linux/mutex.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\n#define BTRFSIC_PRINT_MASK_TREE_WITH_ALL_MIRRORS\t\t0x00001000\n#define BTRFSIC_TREE_DUMP_MAX_INDENT_LEVEL (200 - 6)\t/* in characters,\n\t\t\t\t\t\t\t * excluding \" [...]\" */\n\nstatic void btrfsic_block_link_init(struct btrfsic_block_link *n);\nstatic void btrfsic_block_link_free(struct btrfsic_block_link *n);\nstatic void btrfsic_block_link_hashtable_remove(struct btrfsic_block_link *l);\nstatic int btrfsic_map_block(struct btrfsic_state *state, u64 bytenr, u32 len,\n\t\t\t     struct btrfsic_block_data_ctx *block_ctx_out,\n\t\t\t     int mirror_num);\nstatic void btrfsic_dump_database(struct btrfsic_state *state);\nstatic void btrfsic_print_add_link(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block_link *l);\nstatic void btrfsic_print_rem_link(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block_link *l);\nstatic char btrfsic_get_block_type(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block *block);\nstatic void btrfsic_dump_tree(const struct btrfsic_state *state);\nstatic void btrfsic_dump_tree_sub(const struct btrfsic_state *state,\n\t\t\t\t  const struct btrfsic_block *block,\n\t\t\t\t  int indent_level);\nstatic void btrfsic_cmp_log_and_dev_bytenr(struct btrfsic_state *state,\n\t\t\t\t\t   u64 bytenr,\n\t\t\t\t\t   struct btrfsic_dev_state *dev_state,\n\t\t\t\t\t   u64 dev_bytenr);\n\nstatic void btrfsic_dump_tree_sub(const struct btrfsic_state *state,\n\t\t\t\t  const struct btrfsic_block *block,\n\t\t\t\t  int indent_level)\n{\n\tstruct list_head *elem_ref_to;\n\tint indent_add;\n\tstatic char buf[80];\n\tint cursor_position;\n\n\t/*\n\t * Should better fill an on-stack buffer with a complete line and\n\t * dump it at once when it is time to print a newline character.\n\t */\n\n\t/*\n\t * This algorithm is recursive because the amount of used stack space\n\t * is very small and the max recursion depth is limited.\n\t */\n\tindent_add = sprintf(buf, \"%c-%llu(%s/%llu/%d)\",\n\t\t\t     btrfsic_get_block_type(state, block),\n\t\t\t     block->logical_bytenr, block->dev_state->name,\n\t\t\t     block->dev_bytenr, block->mirror_num);\n\tif (indent_level + indent_add > BTRFSIC_TREE_DUMP_MAX_INDENT_LEVEL) {\n\t\tprintk(\"[...]\\n\");\n\t\treturn;\n\t}\n\tprintk(buf);\n\tindent_level += indent_add;\n\tif (list_empty(&block->ref_to_list)) {\n\t\tprintk(\"\\n\");\n\t\treturn;\n\t}\n\tif (block->mirror_num > 1 &&\n\t    !(state->print_mask & BTRFSIC_PRINT_MASK_TREE_WITH_ALL_MIRRORS)) {\n\t\tprintk(\" [...]\\n\");\n\t\treturn;\n\t}\n\n\tcursor_position = indent_level;\n\tlist_for_each(elem_ref_to, &block->ref_to_list) {\n\t\tconst struct btrfsic_block_link *const l =\n\t\t    list_entry(elem_ref_to, struct btrfsic_block_link,\n\t\t\t       node_ref_to);\n\n\t\twhile (cursor_position < indent_level) {\n\t\t\tprintk(\" \");\n\t\t\tcursor_position++;\n\t\t}\n\t\tif (l->ref_cnt > 1)\n\t\t\tindent_add = sprintf(buf, \" %d*--> \", l->ref_cnt);\n\t\telse\n\t\t\tindent_add = sprintf(buf, \" --> \");\n\t\tif (indent_level + indent_add >\n\t\t    BTRFSIC_TREE_DUMP_MAX_INDENT_LEVEL) {\n\t\t\tprintk(\"[...]\\n\");\n\t\t\tcursor_position = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\tprintk(buf);\n\n\t\tbtrfsic_dump_tree_sub(state, l->block_ref_to,\n\t\t\t\t      indent_level + indent_add);\n\t\tcursor_position = 0;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"extent_io.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n#include <linux/blkdev.h>\n#include <linux/genhd.h>\n#include <linux/mutex.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic void btrfsic_dump_database(struct btrfsic_state *state);\nstatic void btrfsic_dump_tree(const struct btrfsic_state *state);\n\nstatic void btrfsic_dump_tree(const struct btrfsic_state *state)\n{\n\tbtrfsic_dump_tree_sub(state, state->latest_superblock, 0);\n}"
  },
  {
    "function_name": "btrfsic_get_block_type",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/check-integrity.c",
    "lines": "2648-2661",
    "snippet": "static char btrfsic_get_block_type(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block *block)\n{\n\tif (block->is_superblock &&\n\t    state->latest_superblock->dev_bytenr == block->dev_bytenr &&\n\t    state->latest_superblock->dev_state->bdev == block->dev_state->bdev)\n\t\treturn 'S';\n\telse if (block->is_superblock)\n\t\treturn 's';\n\telse if (block->is_metadata)\n\t\treturn 'M';\n\telse\n\t\treturn 'D';\n}",
    "includes": [
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"volumes.h\"",
      "#include \"extent_io.h\"",
      "#include \"transaction.h\"",
      "#include \"hash.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/genhd.h>",
      "#include <linux/mutex.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void btrfsic_dump_database(struct btrfsic_state *state);",
      "static char btrfsic_get_block_type(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block *block);",
      "static void btrfsic_dump_tree(const struct btrfsic_state *state);",
      "static struct btrfsic_dev_state *btrfsic_dev_state_lookup(\n\t\tstruct block_device *bdev);",
      "static void btrfsic_cmp_log_and_dev_bytenr(struct btrfsic_state *state,\n\t\t\t\t\t   u64 bytenr,\n\t\t\t\t\t   struct btrfsic_dev_state *dev_state,\n\t\t\t\t\t   u64 dev_bytenr);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"extent_io.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n#include <linux/blkdev.h>\n#include <linux/genhd.h>\n#include <linux/mutex.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic void btrfsic_dump_database(struct btrfsic_state *state);\nstatic char btrfsic_get_block_type(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block *block);\nstatic void btrfsic_dump_tree(const struct btrfsic_state *state);\nstatic struct btrfsic_dev_state *btrfsic_dev_state_lookup(\n\t\tstruct block_device *bdev);\nstatic void btrfsic_cmp_log_and_dev_bytenr(struct btrfsic_state *state,\n\t\t\t\t\t   u64 bytenr,\n\t\t\t\t\t   struct btrfsic_dev_state *dev_state,\n\t\t\t\t\t   u64 dev_bytenr);\n\nstatic char btrfsic_get_block_type(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block *block)\n{\n\tif (block->is_superblock &&\n\t    state->latest_superblock->dev_bytenr == block->dev_bytenr &&\n\t    state->latest_superblock->dev_state->bdev == block->dev_state->bdev)\n\t\treturn 'S';\n\telse if (block->is_superblock)\n\t\treturn 's';\n\telse if (block->is_metadata)\n\t\treturn 'M';\n\telse\n\t\treturn 'D';\n}"
  },
  {
    "function_name": "btrfsic_print_rem_link",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/check-integrity.c",
    "lines": "2631-2646",
    "snippet": "static void btrfsic_print_rem_link(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block_link *l)\n{\n\tprintk(KERN_INFO\n\t       \"Rem %u* link from %c @%llu (%s/%llu/%d)\"\n\t       \" to %c @%llu (%s/%llu/%d).\\n\",\n\t       l->ref_cnt,\n\t       btrfsic_get_block_type(state, l->block_ref_from),\n\t       l->block_ref_from->logical_bytenr,\n\t       l->block_ref_from->dev_state->name,\n\t       l->block_ref_from->dev_bytenr, l->block_ref_from->mirror_num,\n\t       btrfsic_get_block_type(state, l->block_ref_to),\n\t       l->block_ref_to->logical_bytenr,\n\t       l->block_ref_to->dev_state->name, l->block_ref_to->dev_bytenr,\n\t       l->block_ref_to->mirror_num);\n}",
    "includes": [
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"volumes.h\"",
      "#include \"extent_io.h\"",
      "#include \"transaction.h\"",
      "#include \"hash.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/genhd.h>",
      "#include <linux/mutex.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void btrfsic_block_link_init(struct btrfsic_block_link *n);",
      "static void btrfsic_block_link_free(struct btrfsic_block_link *n);",
      "static void btrfsic_block_link_hashtable_remove(struct btrfsic_block_link *l);",
      "static int btrfsic_map_block(struct btrfsic_state *state, u64 bytenr, u32 len,\n\t\t\t     struct btrfsic_block_data_ctx *block_ctx_out,\n\t\t\t     int mirror_num);",
      "static void btrfsic_dump_database(struct btrfsic_state *state);",
      "static void btrfsic_print_add_link(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block_link *l);",
      "static void btrfsic_print_rem_link(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block_link *l);",
      "static void btrfsic_dump_tree(const struct btrfsic_state *state);",
      "static void btrfsic_cmp_log_and_dev_bytenr(struct btrfsic_state *state,\n\t\t\t\t\t   u64 bytenr,\n\t\t\t\t\t   struct btrfsic_dev_state *dev_state,\n\t\t\t\t\t   u64 dev_bytenr);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_INFO\n\t       \"Rem %u* link from %c @%llu (%s/%llu/%d)\"\n\t       \" to %c @%llu (%s/%llu/%d).\\n\"",
            "l->ref_cnt",
            "btrfsic_get_block_type(state, l->block_ref_from)",
            "l->block_ref_from->logical_bytenr",
            "l->block_ref_from->dev_state->name",
            "l->block_ref_from->dev_bytenr",
            "l->block_ref_from->mirror_num",
            "btrfsic_get_block_type(state, l->block_ref_to)",
            "l->block_ref_to->logical_bytenr",
            "l->block_ref_to->dev_state->name",
            "l->block_ref_to->dev_bytenr",
            "l->block_ref_to->mirror_num"
          ],
          "line": 2634
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/super.c",
          "lines": "186-213",
          "snippet": "void btrfs_printk(const struct btrfs_fs_info *fs_info, const char *fmt, ...)\n{\n\tstruct super_block *sb = fs_info->sb;\n\tchar lvl[4];\n\tstruct va_format vaf;\n\tva_list args;\n\tconst char *type = logtypes[4];\n\tint kern_level;\n\n\tva_start(args, fmt);\n\n\tkern_level = printk_get_level(fmt);\n\tif (kern_level) {\n\t\tsize_t size = printk_skip_level(fmt) - fmt;\n\t\tmemcpy(lvl, fmt,  size);\n\t\tlvl[size] = '\\0';\n\t\tfmt += size;\n\t\ttype = logtypes[kern_level - '0'];\n\t} else\n\t\t*lvl = '\\0';\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sBTRFS %s (device %s): %pV\\n\", lvl, type, sb->s_id, &vaf);\n\n\tva_end(args);\n}",
          "includes": [
            "#include <trace/events/btrfs.h>",
            "#include \"qgroup.h\"",
            "#include \"tests/btrfs-tests.h\"",
            "#include \"backref.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"compression.h\"",
            "#include \"export.h\"",
            "#include \"volumes.h\"",
            "#include \"xattr.h\"",
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/slab.h>",
            "#include <linux/magic.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/namei.h>",
            "#include <linux/ctype.h>",
            "#include <linux/parser.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/btrfs.h>\n#include \"qgroup.h\"\n#include \"tests/btrfs-tests.h\"\n#include \"backref.h\"\n#include \"free-space-cache.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"compression.h\"\n#include \"export.h\"\n#include \"volumes.h\"\n#include \"xattr.h\"\n#include \"props.h\"\n#include \"hash.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include \"delayed-inode.h\"\n#include <linux/btrfs.h>\n#include <linux/ratelimit.h>\n#include <linux/cleancache.h>\n#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/miscdevice.h>\n#include <linux/namei.h>\n#include <linux/ctype.h>\n#include <linux/parser.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n\nvoid btrfs_printk(const struct btrfs_fs_info *fs_info, const char *fmt, ...)\n{\n\tstruct super_block *sb = fs_info->sb;\n\tchar lvl[4];\n\tstruct va_format vaf;\n\tva_list args;\n\tconst char *type = logtypes[4];\n\tint kern_level;\n\n\tva_start(args, fmt);\n\n\tkern_level = printk_get_level(fmt);\n\tif (kern_level) {\n\t\tsize_t size = printk_skip_level(fmt) - fmt;\n\t\tmemcpy(lvl, fmt,  size);\n\t\tlvl[size] = '\\0';\n\t\tfmt += size;\n\t\ttype = logtypes[kern_level - '0'];\n\t} else\n\t\t*lvl = '\\0';\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sBTRFS %s (device %s): %pV\\n\", lvl, type, sb->s_id, &vaf);\n\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfsic_get_block_type",
          "args": [
            "state",
            "l->block_ref_to"
          ],
          "line": 2642
        },
        "resolved": true,
        "details": {
          "function_name": "btrfsic_get_block_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/check-integrity.c",
          "lines": "2648-2661",
          "snippet": "static char btrfsic_get_block_type(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block *block)\n{\n\tif (block->is_superblock &&\n\t    state->latest_superblock->dev_bytenr == block->dev_bytenr &&\n\t    state->latest_superblock->dev_state->bdev == block->dev_state->bdev)\n\t\treturn 'S';\n\telse if (block->is_superblock)\n\t\treturn 's';\n\telse if (block->is_metadata)\n\t\treturn 'M';\n\telse\n\t\treturn 'D';\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"extent_io.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/genhd.h>",
            "#include <linux/mutex.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void btrfsic_dump_database(struct btrfsic_state *state);",
            "static char btrfsic_get_block_type(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block *block);",
            "static void btrfsic_dump_tree(const struct btrfsic_state *state);",
            "static struct btrfsic_dev_state *btrfsic_dev_state_lookup(\n\t\tstruct block_device *bdev);",
            "static void btrfsic_cmp_log_and_dev_bytenr(struct btrfsic_state *state,\n\t\t\t\t\t   u64 bytenr,\n\t\t\t\t\t   struct btrfsic_dev_state *dev_state,\n\t\t\t\t\t   u64 dev_bytenr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"extent_io.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n#include <linux/blkdev.h>\n#include <linux/genhd.h>\n#include <linux/mutex.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic void btrfsic_dump_database(struct btrfsic_state *state);\nstatic char btrfsic_get_block_type(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block *block);\nstatic void btrfsic_dump_tree(const struct btrfsic_state *state);\nstatic struct btrfsic_dev_state *btrfsic_dev_state_lookup(\n\t\tstruct block_device *bdev);\nstatic void btrfsic_cmp_log_and_dev_bytenr(struct btrfsic_state *state,\n\t\t\t\t\t   u64 bytenr,\n\t\t\t\t\t   struct btrfsic_dev_state *dev_state,\n\t\t\t\t\t   u64 dev_bytenr);\n\nstatic char btrfsic_get_block_type(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block *block)\n{\n\tif (block->is_superblock &&\n\t    state->latest_superblock->dev_bytenr == block->dev_bytenr &&\n\t    state->latest_superblock->dev_state->bdev == block->dev_state->bdev)\n\t\treturn 'S';\n\telse if (block->is_superblock)\n\t\treturn 's';\n\telse if (block->is_metadata)\n\t\treturn 'M';\n\telse\n\t\treturn 'D';\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"extent_io.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n#include <linux/blkdev.h>\n#include <linux/genhd.h>\n#include <linux/mutex.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic void btrfsic_block_link_init(struct btrfsic_block_link *n);\nstatic void btrfsic_block_link_free(struct btrfsic_block_link *n);\nstatic void btrfsic_block_link_hashtable_remove(struct btrfsic_block_link *l);\nstatic int btrfsic_map_block(struct btrfsic_state *state, u64 bytenr, u32 len,\n\t\t\t     struct btrfsic_block_data_ctx *block_ctx_out,\n\t\t\t     int mirror_num);\nstatic void btrfsic_dump_database(struct btrfsic_state *state);\nstatic void btrfsic_print_add_link(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block_link *l);\nstatic void btrfsic_print_rem_link(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block_link *l);\nstatic void btrfsic_dump_tree(const struct btrfsic_state *state);\nstatic void btrfsic_cmp_log_and_dev_bytenr(struct btrfsic_state *state,\n\t\t\t\t\t   u64 bytenr,\n\t\t\t\t\t   struct btrfsic_dev_state *dev_state,\n\t\t\t\t\t   u64 dev_bytenr);\n\nstatic void btrfsic_print_rem_link(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block_link *l)\n{\n\tprintk(KERN_INFO\n\t       \"Rem %u* link from %c @%llu (%s/%llu/%d)\"\n\t       \" to %c @%llu (%s/%llu/%d).\\n\",\n\t       l->ref_cnt,\n\t       btrfsic_get_block_type(state, l->block_ref_from),\n\t       l->block_ref_from->logical_bytenr,\n\t       l->block_ref_from->dev_state->name,\n\t       l->block_ref_from->dev_bytenr, l->block_ref_from->mirror_num,\n\t       btrfsic_get_block_type(state, l->block_ref_to),\n\t       l->block_ref_to->logical_bytenr,\n\t       l->block_ref_to->dev_state->name, l->block_ref_to->dev_bytenr,\n\t       l->block_ref_to->mirror_num);\n}"
  },
  {
    "function_name": "btrfsic_print_add_link",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/check-integrity.c",
    "lines": "2614-2629",
    "snippet": "static void btrfsic_print_add_link(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block_link *l)\n{\n\tprintk(KERN_INFO\n\t       \"Add %u* link from %c @%llu (%s/%llu/%d)\"\n\t       \" to %c @%llu (%s/%llu/%d).\\n\",\n\t       l->ref_cnt,\n\t       btrfsic_get_block_type(state, l->block_ref_from),\n\t       l->block_ref_from->logical_bytenr,\n\t       l->block_ref_from->dev_state->name,\n\t       l->block_ref_from->dev_bytenr, l->block_ref_from->mirror_num,\n\t       btrfsic_get_block_type(state, l->block_ref_to),\n\t       l->block_ref_to->logical_bytenr,\n\t       l->block_ref_to->dev_state->name, l->block_ref_to->dev_bytenr,\n\t       l->block_ref_to->mirror_num);\n}",
    "includes": [
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"volumes.h\"",
      "#include \"extent_io.h\"",
      "#include \"transaction.h\"",
      "#include \"hash.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/genhd.h>",
      "#include <linux/mutex.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void btrfsic_block_link_init(struct btrfsic_block_link *n);",
      "static void btrfsic_block_link_free(struct btrfsic_block_link *n);",
      "static void btrfsic_block_link_hashtable_remove(struct btrfsic_block_link *l);",
      "static int btrfsic_map_block(struct btrfsic_state *state, u64 bytenr, u32 len,\n\t\t\t     struct btrfsic_block_data_ctx *block_ctx_out,\n\t\t\t     int mirror_num);",
      "static void btrfsic_dump_database(struct btrfsic_state *state);",
      "static void btrfsic_print_add_link(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block_link *l);",
      "static void btrfsic_print_rem_link(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block_link *l);",
      "static void btrfsic_dump_tree(const struct btrfsic_state *state);",
      "static void btrfsic_cmp_log_and_dev_bytenr(struct btrfsic_state *state,\n\t\t\t\t\t   u64 bytenr,\n\t\t\t\t\t   struct btrfsic_dev_state *dev_state,\n\t\t\t\t\t   u64 dev_bytenr);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_INFO\n\t       \"Add %u* link from %c @%llu (%s/%llu/%d)\"\n\t       \" to %c @%llu (%s/%llu/%d).\\n\"",
            "l->ref_cnt",
            "btrfsic_get_block_type(state, l->block_ref_from)",
            "l->block_ref_from->logical_bytenr",
            "l->block_ref_from->dev_state->name",
            "l->block_ref_from->dev_bytenr",
            "l->block_ref_from->mirror_num",
            "btrfsic_get_block_type(state, l->block_ref_to)",
            "l->block_ref_to->logical_bytenr",
            "l->block_ref_to->dev_state->name",
            "l->block_ref_to->dev_bytenr",
            "l->block_ref_to->mirror_num"
          ],
          "line": 2617
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/super.c",
          "lines": "186-213",
          "snippet": "void btrfs_printk(const struct btrfs_fs_info *fs_info, const char *fmt, ...)\n{\n\tstruct super_block *sb = fs_info->sb;\n\tchar lvl[4];\n\tstruct va_format vaf;\n\tva_list args;\n\tconst char *type = logtypes[4];\n\tint kern_level;\n\n\tva_start(args, fmt);\n\n\tkern_level = printk_get_level(fmt);\n\tif (kern_level) {\n\t\tsize_t size = printk_skip_level(fmt) - fmt;\n\t\tmemcpy(lvl, fmt,  size);\n\t\tlvl[size] = '\\0';\n\t\tfmt += size;\n\t\ttype = logtypes[kern_level - '0'];\n\t} else\n\t\t*lvl = '\\0';\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sBTRFS %s (device %s): %pV\\n\", lvl, type, sb->s_id, &vaf);\n\n\tva_end(args);\n}",
          "includes": [
            "#include <trace/events/btrfs.h>",
            "#include \"qgroup.h\"",
            "#include \"tests/btrfs-tests.h\"",
            "#include \"backref.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"compression.h\"",
            "#include \"export.h\"",
            "#include \"volumes.h\"",
            "#include \"xattr.h\"",
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/slab.h>",
            "#include <linux/magic.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/namei.h>",
            "#include <linux/ctype.h>",
            "#include <linux/parser.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/btrfs.h>\n#include \"qgroup.h\"\n#include \"tests/btrfs-tests.h\"\n#include \"backref.h\"\n#include \"free-space-cache.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"compression.h\"\n#include \"export.h\"\n#include \"volumes.h\"\n#include \"xattr.h\"\n#include \"props.h\"\n#include \"hash.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include \"delayed-inode.h\"\n#include <linux/btrfs.h>\n#include <linux/ratelimit.h>\n#include <linux/cleancache.h>\n#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/miscdevice.h>\n#include <linux/namei.h>\n#include <linux/ctype.h>\n#include <linux/parser.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n\nvoid btrfs_printk(const struct btrfs_fs_info *fs_info, const char *fmt, ...)\n{\n\tstruct super_block *sb = fs_info->sb;\n\tchar lvl[4];\n\tstruct va_format vaf;\n\tva_list args;\n\tconst char *type = logtypes[4];\n\tint kern_level;\n\n\tva_start(args, fmt);\n\n\tkern_level = printk_get_level(fmt);\n\tif (kern_level) {\n\t\tsize_t size = printk_skip_level(fmt) - fmt;\n\t\tmemcpy(lvl, fmt,  size);\n\t\tlvl[size] = '\\0';\n\t\tfmt += size;\n\t\ttype = logtypes[kern_level - '0'];\n\t} else\n\t\t*lvl = '\\0';\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sBTRFS %s (device %s): %pV\\n\", lvl, type, sb->s_id, &vaf);\n\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfsic_get_block_type",
          "args": [
            "state",
            "l->block_ref_to"
          ],
          "line": 2625
        },
        "resolved": true,
        "details": {
          "function_name": "btrfsic_get_block_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/check-integrity.c",
          "lines": "2648-2661",
          "snippet": "static char btrfsic_get_block_type(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block *block)\n{\n\tif (block->is_superblock &&\n\t    state->latest_superblock->dev_bytenr == block->dev_bytenr &&\n\t    state->latest_superblock->dev_state->bdev == block->dev_state->bdev)\n\t\treturn 'S';\n\telse if (block->is_superblock)\n\t\treturn 's';\n\telse if (block->is_metadata)\n\t\treturn 'M';\n\telse\n\t\treturn 'D';\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"extent_io.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/genhd.h>",
            "#include <linux/mutex.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void btrfsic_dump_database(struct btrfsic_state *state);",
            "static char btrfsic_get_block_type(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block *block);",
            "static void btrfsic_dump_tree(const struct btrfsic_state *state);",
            "static struct btrfsic_dev_state *btrfsic_dev_state_lookup(\n\t\tstruct block_device *bdev);",
            "static void btrfsic_cmp_log_and_dev_bytenr(struct btrfsic_state *state,\n\t\t\t\t\t   u64 bytenr,\n\t\t\t\t\t   struct btrfsic_dev_state *dev_state,\n\t\t\t\t\t   u64 dev_bytenr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"extent_io.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n#include <linux/blkdev.h>\n#include <linux/genhd.h>\n#include <linux/mutex.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic void btrfsic_dump_database(struct btrfsic_state *state);\nstatic char btrfsic_get_block_type(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block *block);\nstatic void btrfsic_dump_tree(const struct btrfsic_state *state);\nstatic struct btrfsic_dev_state *btrfsic_dev_state_lookup(\n\t\tstruct block_device *bdev);\nstatic void btrfsic_cmp_log_and_dev_bytenr(struct btrfsic_state *state,\n\t\t\t\t\t   u64 bytenr,\n\t\t\t\t\t   struct btrfsic_dev_state *dev_state,\n\t\t\t\t\t   u64 dev_bytenr);\n\nstatic char btrfsic_get_block_type(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block *block)\n{\n\tif (block->is_superblock &&\n\t    state->latest_superblock->dev_bytenr == block->dev_bytenr &&\n\t    state->latest_superblock->dev_state->bdev == block->dev_state->bdev)\n\t\treturn 'S';\n\telse if (block->is_superblock)\n\t\treturn 's';\n\telse if (block->is_metadata)\n\t\treturn 'M';\n\telse\n\t\treturn 'D';\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"extent_io.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n#include <linux/blkdev.h>\n#include <linux/genhd.h>\n#include <linux/mutex.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic void btrfsic_block_link_init(struct btrfsic_block_link *n);\nstatic void btrfsic_block_link_free(struct btrfsic_block_link *n);\nstatic void btrfsic_block_link_hashtable_remove(struct btrfsic_block_link *l);\nstatic int btrfsic_map_block(struct btrfsic_state *state, u64 bytenr, u32 len,\n\t\t\t     struct btrfsic_block_data_ctx *block_ctx_out,\n\t\t\t     int mirror_num);\nstatic void btrfsic_dump_database(struct btrfsic_state *state);\nstatic void btrfsic_print_add_link(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block_link *l);\nstatic void btrfsic_print_rem_link(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block_link *l);\nstatic void btrfsic_dump_tree(const struct btrfsic_state *state);\nstatic void btrfsic_cmp_log_and_dev_bytenr(struct btrfsic_state *state,\n\t\t\t\t\t   u64 bytenr,\n\t\t\t\t\t   struct btrfsic_dev_state *dev_state,\n\t\t\t\t\t   u64 dev_bytenr);\n\nstatic void btrfsic_print_add_link(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block_link *l)\n{\n\tprintk(KERN_INFO\n\t       \"Add %u* link from %c @%llu (%s/%llu/%d)\"\n\t       \" to %c @%llu (%s/%llu/%d).\\n\",\n\t       l->ref_cnt,\n\t       btrfsic_get_block_type(state, l->block_ref_from),\n\t       l->block_ref_from->logical_bytenr,\n\t       l->block_ref_from->dev_state->name,\n\t       l->block_ref_from->dev_bytenr, l->block_ref_from->mirror_num,\n\t       btrfsic_get_block_type(state, l->block_ref_to),\n\t       l->block_ref_to->logical_bytenr,\n\t       l->block_ref_to->dev_state->name, l->block_ref_to->dev_bytenr,\n\t       l->block_ref_to->mirror_num);\n}"
  },
  {
    "function_name": "btrfsic_is_block_ref_by_superblock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/check-integrity.c",
    "lines": "2559-2612",
    "snippet": "static int btrfsic_is_block_ref_by_superblock(\n\t\tconst struct btrfsic_state *state,\n\t\tconst struct btrfsic_block *block,\n\t\tint recursion_level)\n{\n\tstruct list_head *elem_ref_from;\n\n\tif (recursion_level >= 3 + BTRFS_MAX_LEVEL) {\n\t\t/* refer to comment at \"abort cyclic linkage (case 1)\" */\n\t\tif (state->print_mask & BTRFSIC_PRINT_MASK_VERBOSE)\n\t\t\tprintk(KERN_INFO\n\t\t\t       \"btrfsic: abort cyclic linkage (case 2).\\n\");\n\n\t\treturn 0;\n\t}\n\n\t/*\n\t * This algorithm is recursive because the amount of used stack space\n\t * is very small and the max recursion depth is limited.\n\t */\n\tlist_for_each(elem_ref_from, &block->ref_from_list) {\n\t\tconst struct btrfsic_block_link *const l =\n\t\t    list_entry(elem_ref_from, struct btrfsic_block_link,\n\t\t\t       node_ref_from);\n\n\t\tif (state->print_mask & BTRFSIC_PRINT_MASK_VERBOSE)\n\t\t\tprintk(KERN_INFO\n\t\t\t       \"rl=%d, %c @%llu (%s/%llu/%d)\"\n\t\t\t       \" is ref %u* from %c @%llu (%s/%llu/%d)\\n\",\n\t\t\t       recursion_level,\n\t\t\t       btrfsic_get_block_type(state, block),\n\t\t\t       block->logical_bytenr, block->dev_state->name,\n\t\t\t       block->dev_bytenr, block->mirror_num,\n\t\t\t       l->ref_cnt,\n\t\t\t       btrfsic_get_block_type(state, l->block_ref_from),\n\t\t\t       l->block_ref_from->logical_bytenr,\n\t\t\t       l->block_ref_from->dev_state->name,\n\t\t\t       l->block_ref_from->dev_bytenr,\n\t\t\t       l->block_ref_from->mirror_num);\n\t\tif (l->block_ref_from->is_superblock &&\n\t\t    state->latest_superblock->dev_bytenr ==\n\t\t    l->block_ref_from->dev_bytenr &&\n\t\t    state->latest_superblock->dev_state->bdev ==\n\t\t    l->block_ref_from->dev_state->bdev)\n\t\t\treturn 1;\n\t\telse if (btrfsic_is_block_ref_by_superblock(state,\n\t\t\t\t\t\t\t    l->block_ref_from,\n\t\t\t\t\t\t\t    recursion_level +\n\t\t\t\t\t\t\t    1))\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"volumes.h\"",
      "#include \"extent_io.h\"",
      "#include \"transaction.h\"",
      "#include \"hash.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/genhd.h>",
      "#include <linux/mutex.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [
      "#define BTRFSIC_PRINT_MASK_VERBOSE\t\t\t\t0x00000040"
    ],
    "globals_used": [
      "static void btrfsic_block_link_init(struct btrfsic_block_link *n);",
      "static void btrfsic_block_link_free(struct btrfsic_block_link *n);",
      "static void btrfsic_block_link_hashtable_remove(struct btrfsic_block_link *l);",
      "static int btrfsic_map_block(struct btrfsic_state *state, u64 bytenr, u32 len,\n\t\t\t     struct btrfsic_block_data_ctx *block_ctx_out,\n\t\t\t     int mirror_num);",
      "static void btrfsic_dump_database(struct btrfsic_state *state);",
      "static int btrfsic_is_block_ref_by_superblock(const struct btrfsic_state *state,\n\t\t\t\t\t      const struct btrfsic_block *block,\n\t\t\t\t\t      int recursion_level);",
      "static int btrfsic_check_all_ref_blocks(struct btrfsic_state *state,\n\t\t\t\t\tstruct btrfsic_block *const block,\n\t\t\t\t\tint recursion_level);",
      "static void btrfsic_print_add_link(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block_link *l);",
      "static void btrfsic_print_rem_link(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block_link *l);",
      "static char btrfsic_get_block_type(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block *block);",
      "static void btrfsic_dump_tree(const struct btrfsic_state *state);",
      "static struct btrfsic_dev_state *btrfsic_dev_state_lookup(\n\t\tstruct block_device *bdev);",
      "static void btrfsic_cmp_log_and_dev_bytenr(struct btrfsic_state *state,\n\t\t\t\t\t   u64 bytenr,\n\t\t\t\t\t   struct btrfsic_dev_state *dev_state,\n\t\t\t\t\t   u64 dev_bytenr);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfsic_is_block_ref_by_superblock",
          "args": [
            "state",
            "l->block_ref_from",
            "recursion_level +\n\t\t\t\t\t\t\t    1"
          ],
          "line": 2604
        },
        "resolved": true,
        "details": {
          "function_name": "btrfsic_is_block_ref_by_superblock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/check-integrity.c",
          "lines": "2559-2612",
          "snippet": "static int btrfsic_is_block_ref_by_superblock(\n\t\tconst struct btrfsic_state *state,\n\t\tconst struct btrfsic_block *block,\n\t\tint recursion_level)\n{\n\tstruct list_head *elem_ref_from;\n\n\tif (recursion_level >= 3 + BTRFS_MAX_LEVEL) {\n\t\t/* refer to comment at \"abort cyclic linkage (case 1)\" */\n\t\tif (state->print_mask & BTRFSIC_PRINT_MASK_VERBOSE)\n\t\t\tprintk(KERN_INFO\n\t\t\t       \"btrfsic: abort cyclic linkage (case 2).\\n\");\n\n\t\treturn 0;\n\t}\n\n\t/*\n\t * This algorithm is recursive because the amount of used stack space\n\t * is very small and the max recursion depth is limited.\n\t */\n\tlist_for_each(elem_ref_from, &block->ref_from_list) {\n\t\tconst struct btrfsic_block_link *const l =\n\t\t    list_entry(elem_ref_from, struct btrfsic_block_link,\n\t\t\t       node_ref_from);\n\n\t\tif (state->print_mask & BTRFSIC_PRINT_MASK_VERBOSE)\n\t\t\tprintk(KERN_INFO\n\t\t\t       \"rl=%d, %c @%llu (%s/%llu/%d)\"\n\t\t\t       \" is ref %u* from %c @%llu (%s/%llu/%d)\\n\",\n\t\t\t       recursion_level,\n\t\t\t       btrfsic_get_block_type(state, block),\n\t\t\t       block->logical_bytenr, block->dev_state->name,\n\t\t\t       block->dev_bytenr, block->mirror_num,\n\t\t\t       l->ref_cnt,\n\t\t\t       btrfsic_get_block_type(state, l->block_ref_from),\n\t\t\t       l->block_ref_from->logical_bytenr,\n\t\t\t       l->block_ref_from->dev_state->name,\n\t\t\t       l->block_ref_from->dev_bytenr,\n\t\t\t       l->block_ref_from->mirror_num);\n\t\tif (l->block_ref_from->is_superblock &&\n\t\t    state->latest_superblock->dev_bytenr ==\n\t\t    l->block_ref_from->dev_bytenr &&\n\t\t    state->latest_superblock->dev_state->bdev ==\n\t\t    l->block_ref_from->dev_state->bdev)\n\t\t\treturn 1;\n\t\telse if (btrfsic_is_block_ref_by_superblock(state,\n\t\t\t\t\t\t\t    l->block_ref_from,\n\t\t\t\t\t\t\t    recursion_level +\n\t\t\t\t\t\t\t    1))\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_INFO\n\t\t\t       \"rl=%d, %c @%llu (%s/%llu/%d)\"\n\t\t\t       \" is ref %u* from %c @%llu (%s/%llu/%d)\\n\"",
            "recursion_level",
            "btrfsic_get_block_type(state, block)",
            "block->logical_bytenr",
            "block->dev_state->name",
            "block->dev_bytenr",
            "block->mirror_num",
            "l->ref_cnt",
            "btrfsic_get_block_type(state, l->block_ref_from)",
            "l->block_ref_from->logical_bytenr",
            "l->block_ref_from->dev_state->name",
            "l->block_ref_from->dev_bytenr",
            "l->block_ref_from->mirror_num"
          ],
          "line": 2585
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/super.c",
          "lines": "186-213",
          "snippet": "void btrfs_printk(const struct btrfs_fs_info *fs_info, const char *fmt, ...)\n{\n\tstruct super_block *sb = fs_info->sb;\n\tchar lvl[4];\n\tstruct va_format vaf;\n\tva_list args;\n\tconst char *type = logtypes[4];\n\tint kern_level;\n\n\tva_start(args, fmt);\n\n\tkern_level = printk_get_level(fmt);\n\tif (kern_level) {\n\t\tsize_t size = printk_skip_level(fmt) - fmt;\n\t\tmemcpy(lvl, fmt,  size);\n\t\tlvl[size] = '\\0';\n\t\tfmt += size;\n\t\ttype = logtypes[kern_level - '0'];\n\t} else\n\t\t*lvl = '\\0';\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sBTRFS %s (device %s): %pV\\n\", lvl, type, sb->s_id, &vaf);\n\n\tva_end(args);\n}",
          "includes": [
            "#include <trace/events/btrfs.h>",
            "#include \"qgroup.h\"",
            "#include \"tests/btrfs-tests.h\"",
            "#include \"backref.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"compression.h\"",
            "#include \"export.h\"",
            "#include \"volumes.h\"",
            "#include \"xattr.h\"",
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/slab.h>",
            "#include <linux/magic.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/namei.h>",
            "#include <linux/ctype.h>",
            "#include <linux/parser.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/btrfs.h>\n#include \"qgroup.h\"\n#include \"tests/btrfs-tests.h\"\n#include \"backref.h\"\n#include \"free-space-cache.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"compression.h\"\n#include \"export.h\"\n#include \"volumes.h\"\n#include \"xattr.h\"\n#include \"props.h\"\n#include \"hash.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include \"delayed-inode.h\"\n#include <linux/btrfs.h>\n#include <linux/ratelimit.h>\n#include <linux/cleancache.h>\n#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/miscdevice.h>\n#include <linux/namei.h>\n#include <linux/ctype.h>\n#include <linux/parser.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n\nvoid btrfs_printk(const struct btrfs_fs_info *fs_info, const char *fmt, ...)\n{\n\tstruct super_block *sb = fs_info->sb;\n\tchar lvl[4];\n\tstruct va_format vaf;\n\tva_list args;\n\tconst char *type = logtypes[4];\n\tint kern_level;\n\n\tva_start(args, fmt);\n\n\tkern_level = printk_get_level(fmt);\n\tif (kern_level) {\n\t\tsize_t size = printk_skip_level(fmt) - fmt;\n\t\tmemcpy(lvl, fmt,  size);\n\t\tlvl[size] = '\\0';\n\t\tfmt += size;\n\t\ttype = logtypes[kern_level - '0'];\n\t} else\n\t\t*lvl = '\\0';\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sBTRFS %s (device %s): %pV\\n\", lvl, type, sb->s_id, &vaf);\n\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfsic_get_block_type",
          "args": [
            "state",
            "l->block_ref_from"
          ],
          "line": 2593
        },
        "resolved": true,
        "details": {
          "function_name": "btrfsic_get_block_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/check-integrity.c",
          "lines": "2648-2661",
          "snippet": "static char btrfsic_get_block_type(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block *block)\n{\n\tif (block->is_superblock &&\n\t    state->latest_superblock->dev_bytenr == block->dev_bytenr &&\n\t    state->latest_superblock->dev_state->bdev == block->dev_state->bdev)\n\t\treturn 'S';\n\telse if (block->is_superblock)\n\t\treturn 's';\n\telse if (block->is_metadata)\n\t\treturn 'M';\n\telse\n\t\treturn 'D';\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"extent_io.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/genhd.h>",
            "#include <linux/mutex.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void btrfsic_dump_database(struct btrfsic_state *state);",
            "static char btrfsic_get_block_type(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block *block);",
            "static void btrfsic_dump_tree(const struct btrfsic_state *state);",
            "static struct btrfsic_dev_state *btrfsic_dev_state_lookup(\n\t\tstruct block_device *bdev);",
            "static void btrfsic_cmp_log_and_dev_bytenr(struct btrfsic_state *state,\n\t\t\t\t\t   u64 bytenr,\n\t\t\t\t\t   struct btrfsic_dev_state *dev_state,\n\t\t\t\t\t   u64 dev_bytenr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"extent_io.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n#include <linux/blkdev.h>\n#include <linux/genhd.h>\n#include <linux/mutex.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic void btrfsic_dump_database(struct btrfsic_state *state);\nstatic char btrfsic_get_block_type(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block *block);\nstatic void btrfsic_dump_tree(const struct btrfsic_state *state);\nstatic struct btrfsic_dev_state *btrfsic_dev_state_lookup(\n\t\tstruct block_device *bdev);\nstatic void btrfsic_cmp_log_and_dev_bytenr(struct btrfsic_state *state,\n\t\t\t\t\t   u64 bytenr,\n\t\t\t\t\t   struct btrfsic_dev_state *dev_state,\n\t\t\t\t\t   u64 dev_bytenr);\n\nstatic char btrfsic_get_block_type(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block *block)\n{\n\tif (block->is_superblock &&\n\t    state->latest_superblock->dev_bytenr == block->dev_bytenr &&\n\t    state->latest_superblock->dev_state->bdev == block->dev_state->bdev)\n\t\treturn 'S';\n\telse if (block->is_superblock)\n\t\treturn 's';\n\telse if (block->is_metadata)\n\t\treturn 'M';\n\telse\n\t\treturn 'D';\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "elem_ref_from",
            "structbtrfsic_block_link",
            "node_ref_from"
          ],
          "line": 2581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each",
          "args": [
            "elem_ref_from",
            "&block->ref_from_list"
          ],
          "line": 2579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_INFO\n\t\t\t       \"btrfsic: abort cyclic linkage (case 2).\\n\""
          ],
          "line": 2569
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"extent_io.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n#include <linux/blkdev.h>\n#include <linux/genhd.h>\n#include <linux/mutex.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\n#define BTRFSIC_PRINT_MASK_VERBOSE\t\t\t\t0x00000040\n\nstatic void btrfsic_block_link_init(struct btrfsic_block_link *n);\nstatic void btrfsic_block_link_free(struct btrfsic_block_link *n);\nstatic void btrfsic_block_link_hashtable_remove(struct btrfsic_block_link *l);\nstatic int btrfsic_map_block(struct btrfsic_state *state, u64 bytenr, u32 len,\n\t\t\t     struct btrfsic_block_data_ctx *block_ctx_out,\n\t\t\t     int mirror_num);\nstatic void btrfsic_dump_database(struct btrfsic_state *state);\nstatic int btrfsic_is_block_ref_by_superblock(const struct btrfsic_state *state,\n\t\t\t\t\t      const struct btrfsic_block *block,\n\t\t\t\t\t      int recursion_level);\nstatic int btrfsic_check_all_ref_blocks(struct btrfsic_state *state,\n\t\t\t\t\tstruct btrfsic_block *const block,\n\t\t\t\t\tint recursion_level);\nstatic void btrfsic_print_add_link(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block_link *l);\nstatic void btrfsic_print_rem_link(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block_link *l);\nstatic char btrfsic_get_block_type(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block *block);\nstatic void btrfsic_dump_tree(const struct btrfsic_state *state);\nstatic struct btrfsic_dev_state *btrfsic_dev_state_lookup(\n\t\tstruct block_device *bdev);\nstatic void btrfsic_cmp_log_and_dev_bytenr(struct btrfsic_state *state,\n\t\t\t\t\t   u64 bytenr,\n\t\t\t\t\t   struct btrfsic_dev_state *dev_state,\n\t\t\t\t\t   u64 dev_bytenr);\n\nstatic int btrfsic_is_block_ref_by_superblock(\n\t\tconst struct btrfsic_state *state,\n\t\tconst struct btrfsic_block *block,\n\t\tint recursion_level)\n{\n\tstruct list_head *elem_ref_from;\n\n\tif (recursion_level >= 3 + BTRFS_MAX_LEVEL) {\n\t\t/* refer to comment at \"abort cyclic linkage (case 1)\" */\n\t\tif (state->print_mask & BTRFSIC_PRINT_MASK_VERBOSE)\n\t\t\tprintk(KERN_INFO\n\t\t\t       \"btrfsic: abort cyclic linkage (case 2).\\n\");\n\n\t\treturn 0;\n\t}\n\n\t/*\n\t * This algorithm is recursive because the amount of used stack space\n\t * is very small and the max recursion depth is limited.\n\t */\n\tlist_for_each(elem_ref_from, &block->ref_from_list) {\n\t\tconst struct btrfsic_block_link *const l =\n\t\t    list_entry(elem_ref_from, struct btrfsic_block_link,\n\t\t\t       node_ref_from);\n\n\t\tif (state->print_mask & BTRFSIC_PRINT_MASK_VERBOSE)\n\t\t\tprintk(KERN_INFO\n\t\t\t       \"rl=%d, %c @%llu (%s/%llu/%d)\"\n\t\t\t       \" is ref %u* from %c @%llu (%s/%llu/%d)\\n\",\n\t\t\t       recursion_level,\n\t\t\t       btrfsic_get_block_type(state, block),\n\t\t\t       block->logical_bytenr, block->dev_state->name,\n\t\t\t       block->dev_bytenr, block->mirror_num,\n\t\t\t       l->ref_cnt,\n\t\t\t       btrfsic_get_block_type(state, l->block_ref_from),\n\t\t\t       l->block_ref_from->logical_bytenr,\n\t\t\t       l->block_ref_from->dev_state->name,\n\t\t\t       l->block_ref_from->dev_bytenr,\n\t\t\t       l->block_ref_from->mirror_num);\n\t\tif (l->block_ref_from->is_superblock &&\n\t\t    state->latest_superblock->dev_bytenr ==\n\t\t    l->block_ref_from->dev_bytenr &&\n\t\t    state->latest_superblock->dev_state->bdev ==\n\t\t    l->block_ref_from->dev_state->bdev)\n\t\t\treturn 1;\n\t\telse if (btrfsic_is_block_ref_by_superblock(state,\n\t\t\t\t\t\t\t    l->block_ref_from,\n\t\t\t\t\t\t\t    recursion_level +\n\t\t\t\t\t\t\t    1))\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "btrfsic_check_all_ref_blocks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/check-integrity.c",
    "lines": "2435-2557",
    "snippet": "static int btrfsic_check_all_ref_blocks(struct btrfsic_state *state,\n\t\t\t\t\tstruct btrfsic_block *const block,\n\t\t\t\t\tint recursion_level)\n{\n\tstruct list_head *elem_ref_to;\n\tint ret = 0;\n\n\tif (recursion_level >= 3 + BTRFS_MAX_LEVEL) {\n\t\t/*\n\t\t * Note that this situation can happen and does not\n\t\t * indicate an error in regular cases. It happens\n\t\t * when disk blocks are freed and later reused.\n\t\t * The check-integrity module is not aware of any\n\t\t * block free operations, it just recognizes block\n\t\t * write operations. Therefore it keeps the linkage\n\t\t * information for a block until a block is\n\t\t * rewritten. This can temporarily cause incorrect\n\t\t * and even circular linkage informations. This\n\t\t * causes no harm unless such blocks are referenced\n\t\t * by the most recent super block.\n\t\t */\n\t\tif (state->print_mask & BTRFSIC_PRINT_MASK_VERBOSE)\n\t\t\tprintk(KERN_INFO\n\t\t\t       \"btrfsic: abort cyclic linkage (case 1).\\n\");\n\n\t\treturn ret;\n\t}\n\n\t/*\n\t * This algorithm is recursive because the amount of used stack\n\t * space is very small and the max recursion depth is limited.\n\t */\n\tlist_for_each(elem_ref_to, &block->ref_to_list) {\n\t\tconst struct btrfsic_block_link *const l =\n\t\t    list_entry(elem_ref_to, struct btrfsic_block_link,\n\t\t\t       node_ref_to);\n\n\t\tif (state->print_mask & BTRFSIC_PRINT_MASK_VERBOSE)\n\t\t\tprintk(KERN_INFO\n\t\t\t       \"rl=%d, %c @%llu (%s/%llu/%d)\"\n\t\t\t       \" %u* refers to %c @%llu (%s/%llu/%d)\\n\",\n\t\t\t       recursion_level,\n\t\t\t       btrfsic_get_block_type(state, block),\n\t\t\t       block->logical_bytenr, block->dev_state->name,\n\t\t\t       block->dev_bytenr, block->mirror_num,\n\t\t\t       l->ref_cnt,\n\t\t\t       btrfsic_get_block_type(state, l->block_ref_to),\n\t\t\t       l->block_ref_to->logical_bytenr,\n\t\t\t       l->block_ref_to->dev_state->name,\n\t\t\t       l->block_ref_to->dev_bytenr,\n\t\t\t       l->block_ref_to->mirror_num);\n\t\tif (l->block_ref_to->never_written) {\n\t\t\tprintk(KERN_INFO \"btrfs: attempt to write superblock\"\n\t\t\t       \" which references block %c @%llu (%s/%llu/%d)\"\n\t\t\t       \" which is never written!\\n\",\n\t\t\t       btrfsic_get_block_type(state, l->block_ref_to),\n\t\t\t       l->block_ref_to->logical_bytenr,\n\t\t\t       l->block_ref_to->dev_state->name,\n\t\t\t       l->block_ref_to->dev_bytenr,\n\t\t\t       l->block_ref_to->mirror_num);\n\t\t\tret = -1;\n\t\t} else if (!l->block_ref_to->is_iodone) {\n\t\t\tprintk(KERN_INFO \"btrfs: attempt to write superblock\"\n\t\t\t       \" which references block %c @%llu (%s/%llu/%d)\"\n\t\t\t       \" which is not yet iodone!\\n\",\n\t\t\t       btrfsic_get_block_type(state, l->block_ref_to),\n\t\t\t       l->block_ref_to->logical_bytenr,\n\t\t\t       l->block_ref_to->dev_state->name,\n\t\t\t       l->block_ref_to->dev_bytenr,\n\t\t\t       l->block_ref_to->mirror_num);\n\t\t\tret = -1;\n\t\t} else if (l->block_ref_to->iodone_w_error) {\n\t\t\tprintk(KERN_INFO \"btrfs: attempt to write superblock\"\n\t\t\t       \" which references block %c @%llu (%s/%llu/%d)\"\n\t\t\t       \" which has write error!\\n\",\n\t\t\t       btrfsic_get_block_type(state, l->block_ref_to),\n\t\t\t       l->block_ref_to->logical_bytenr,\n\t\t\t       l->block_ref_to->dev_state->name,\n\t\t\t       l->block_ref_to->dev_bytenr,\n\t\t\t       l->block_ref_to->mirror_num);\n\t\t\tret = -1;\n\t\t} else if (l->parent_generation !=\n\t\t\t   l->block_ref_to->generation &&\n\t\t\t   BTRFSIC_GENERATION_UNKNOWN !=\n\t\t\t   l->parent_generation &&\n\t\t\t   BTRFSIC_GENERATION_UNKNOWN !=\n\t\t\t   l->block_ref_to->generation) {\n\t\t\tprintk(KERN_INFO \"btrfs: attempt to write superblock\"\n\t\t\t       \" which references block %c @%llu (%s/%llu/%d)\"\n\t\t\t       \" with generation %llu !=\"\n\t\t\t       \" parent generation %llu!\\n\",\n\t\t\t       btrfsic_get_block_type(state, l->block_ref_to),\n\t\t\t       l->block_ref_to->logical_bytenr,\n\t\t\t       l->block_ref_to->dev_state->name,\n\t\t\t       l->block_ref_to->dev_bytenr,\n\t\t\t       l->block_ref_to->mirror_num,\n\t\t\t       l->block_ref_to->generation,\n\t\t\t       l->parent_generation);\n\t\t\tret = -1;\n\t\t} else if (l->block_ref_to->flush_gen >\n\t\t\t   l->block_ref_to->dev_state->last_flush_gen) {\n\t\t\tprintk(KERN_INFO \"btrfs: attempt to write superblock\"\n\t\t\t       \" which references block %c @%llu (%s/%llu/%d)\"\n\t\t\t       \" which is not flushed out of disk's write cache\"\n\t\t\t       \" (block flush_gen=%llu,\"\n\t\t\t       \" dev->flush_gen=%llu)!\\n\",\n\t\t\t       btrfsic_get_block_type(state, l->block_ref_to),\n\t\t\t       l->block_ref_to->logical_bytenr,\n\t\t\t       l->block_ref_to->dev_state->name,\n\t\t\t       l->block_ref_to->dev_bytenr,\n\t\t\t       l->block_ref_to->mirror_num, block->flush_gen,\n\t\t\t       l->block_ref_to->dev_state->last_flush_gen);\n\t\t\tret = -1;\n\t\t} else if (-1 == btrfsic_check_all_ref_blocks(state,\n\t\t\t\t\t\t\t      l->block_ref_to,\n\t\t\t\t\t\t\t      recursion_level +\n\t\t\t\t\t\t\t      1)) {\n\t\t\tret = -1;\n\t\t}\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"volumes.h\"",
      "#include \"extent_io.h\"",
      "#include \"transaction.h\"",
      "#include \"hash.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/genhd.h>",
      "#include <linux/mutex.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [
      "#define BTRFSIC_PRINT_MASK_VERBOSE\t\t\t\t0x00000040",
      "#define BTRFSIC_GENERATION_UNKNOWN ((u64)-1)"
    ],
    "globals_used": [
      "static void btrfsic_block_link_init(struct btrfsic_block_link *n);",
      "static void btrfsic_block_link_free(struct btrfsic_block_link *n);",
      "static void btrfsic_block_link_hashtable_remove(struct btrfsic_block_link *l);",
      "static int btrfsic_create_link_to_next_block(\n\t\tstruct btrfsic_state *state,\n\t\tstruct btrfsic_block *block,\n\t\tstruct btrfsic_block_data_ctx\n\t\t*block_ctx, u64 next_bytenr,\n\t\tint limit_nesting,\n\t\tstruct btrfsic_block_data_ctx *next_block_ctx,\n\t\tstruct btrfsic_block **next_blockp,\n\t\tint force_iodone_flag,\n\t\tint *num_copiesp, int *mirror_nump,\n\t\tstruct btrfs_disk_key *disk_key,\n\t\tu64 parent_generation);",
      "static int btrfsic_map_block(struct btrfsic_state *state, u64 bytenr, u32 len,\n\t\t\t     struct btrfsic_block_data_ctx *block_ctx_out,\n\t\t\t     int mirror_num);",
      "static void btrfsic_dump_database(struct btrfsic_state *state);",
      "static int btrfsic_is_block_ref_by_superblock(const struct btrfsic_state *state,\n\t\t\t\t\t      const struct btrfsic_block *block,\n\t\t\t\t\t      int recursion_level);",
      "static int btrfsic_check_all_ref_blocks(struct btrfsic_state *state,\n\t\t\t\t\tstruct btrfsic_block *const block,\n\t\t\t\t\tint recursion_level);",
      "static void btrfsic_print_add_link(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block_link *l);",
      "static void btrfsic_print_rem_link(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block_link *l);",
      "static char btrfsic_get_block_type(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block *block);",
      "static void btrfsic_dump_tree(const struct btrfsic_state *state);",
      "static struct btrfsic_block_link *btrfsic_block_link_lookup_or_add(\n\t\tstruct btrfsic_state *state,\n\t\tstruct btrfsic_block_data_ctx *next_block_ctx,\n\t\tstruct btrfsic_block *next_block,\n\t\tstruct btrfsic_block *from_block,\n\t\tu64 parent_generation);",
      "static void btrfsic_cmp_log_and_dev_bytenr(struct btrfsic_state *state,\n\t\t\t\t\t   u64 bytenr,\n\t\t\t\t\t   struct btrfsic_dev_state *dev_state,\n\t\t\t\t\t   u64 dev_bytenr);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfsic_check_all_ref_blocks",
          "args": [
            "state",
            "l->block_ref_to",
            "recursion_level +\n\t\t\t\t\t\t\t      1"
          ],
          "line": 2548
        },
        "resolved": true,
        "details": {
          "function_name": "btrfsic_check_all_ref_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/check-integrity.c",
          "lines": "2435-2557",
          "snippet": "static int btrfsic_check_all_ref_blocks(struct btrfsic_state *state,\n\t\t\t\t\tstruct btrfsic_block *const block,\n\t\t\t\t\tint recursion_level)\n{\n\tstruct list_head *elem_ref_to;\n\tint ret = 0;\n\n\tif (recursion_level >= 3 + BTRFS_MAX_LEVEL) {\n\t\t/*\n\t\t * Note that this situation can happen and does not\n\t\t * indicate an error in regular cases. It happens\n\t\t * when disk blocks are freed and later reused.\n\t\t * The check-integrity module is not aware of any\n\t\t * block free operations, it just recognizes block\n\t\t * write operations. Therefore it keeps the linkage\n\t\t * information for a block until a block is\n\t\t * rewritten. This can temporarily cause incorrect\n\t\t * and even circular linkage informations. This\n\t\t * causes no harm unless such blocks are referenced\n\t\t * by the most recent super block.\n\t\t */\n\t\tif (state->print_mask & BTRFSIC_PRINT_MASK_VERBOSE)\n\t\t\tprintk(KERN_INFO\n\t\t\t       \"btrfsic: abort cyclic linkage (case 1).\\n\");\n\n\t\treturn ret;\n\t}\n\n\t/*\n\t * This algorithm is recursive because the amount of used stack\n\t * space is very small and the max recursion depth is limited.\n\t */\n\tlist_for_each(elem_ref_to, &block->ref_to_list) {\n\t\tconst struct btrfsic_block_link *const l =\n\t\t    list_entry(elem_ref_to, struct btrfsic_block_link,\n\t\t\t       node_ref_to);\n\n\t\tif (state->print_mask & BTRFSIC_PRINT_MASK_VERBOSE)\n\t\t\tprintk(KERN_INFO\n\t\t\t       \"rl=%d, %c @%llu (%s/%llu/%d)\"\n\t\t\t       \" %u* refers to %c @%llu (%s/%llu/%d)\\n\",\n\t\t\t       recursion_level,\n\t\t\t       btrfsic_get_block_type(state, block),\n\t\t\t       block->logical_bytenr, block->dev_state->name,\n\t\t\t       block->dev_bytenr, block->mirror_num,\n\t\t\t       l->ref_cnt,\n\t\t\t       btrfsic_get_block_type(state, l->block_ref_to),\n\t\t\t       l->block_ref_to->logical_bytenr,\n\t\t\t       l->block_ref_to->dev_state->name,\n\t\t\t       l->block_ref_to->dev_bytenr,\n\t\t\t       l->block_ref_to->mirror_num);\n\t\tif (l->block_ref_to->never_written) {\n\t\t\tprintk(KERN_INFO \"btrfs: attempt to write superblock\"\n\t\t\t       \" which references block %c @%llu (%s/%llu/%d)\"\n\t\t\t       \" which is never written!\\n\",\n\t\t\t       btrfsic_get_block_type(state, l->block_ref_to),\n\t\t\t       l->block_ref_to->logical_bytenr,\n\t\t\t       l->block_ref_to->dev_state->name,\n\t\t\t       l->block_ref_to->dev_bytenr,\n\t\t\t       l->block_ref_to->mirror_num);\n\t\t\tret = -1;\n\t\t} else if (!l->block_ref_to->is_iodone) {\n\t\t\tprintk(KERN_INFO \"btrfs: attempt to write superblock\"\n\t\t\t       \" which references block %c @%llu (%s/%llu/%d)\"\n\t\t\t       \" which is not yet iodone!\\n\",\n\t\t\t       btrfsic_get_block_type(state, l->block_ref_to),\n\t\t\t       l->block_ref_to->logical_bytenr,\n\t\t\t       l->block_ref_to->dev_state->name,\n\t\t\t       l->block_ref_to->dev_bytenr,\n\t\t\t       l->block_ref_to->mirror_num);\n\t\t\tret = -1;\n\t\t} else if (l->block_ref_to->iodone_w_error) {\n\t\t\tprintk(KERN_INFO \"btrfs: attempt to write superblock\"\n\t\t\t       \" which references block %c @%llu (%s/%llu/%d)\"\n\t\t\t       \" which has write error!\\n\",\n\t\t\t       btrfsic_get_block_type(state, l->block_ref_to),\n\t\t\t       l->block_ref_to->logical_bytenr,\n\t\t\t       l->block_ref_to->dev_state->name,\n\t\t\t       l->block_ref_to->dev_bytenr,\n\t\t\t       l->block_ref_to->mirror_num);\n\t\t\tret = -1;\n\t\t} else if (l->parent_generation !=\n\t\t\t   l->block_ref_to->generation &&\n\t\t\t   BTRFSIC_GENERATION_UNKNOWN !=\n\t\t\t   l->parent_generation &&\n\t\t\t   BTRFSIC_GENERATION_UNKNOWN !=\n\t\t\t   l->block_ref_to->generation) {\n\t\t\tprintk(KERN_INFO \"btrfs: attempt to write superblock\"\n\t\t\t       \" which references block %c @%llu (%s/%llu/%d)\"\n\t\t\t       \" with generation %llu !=\"\n\t\t\t       \" parent generation %llu!\\n\",\n\t\t\t       btrfsic_get_block_type(state, l->block_ref_to),\n\t\t\t       l->block_ref_to->logical_bytenr,\n\t\t\t       l->block_ref_to->dev_state->name,\n\t\t\t       l->block_ref_to->dev_bytenr,\n\t\t\t       l->block_ref_to->mirror_num,\n\t\t\t       l->block_ref_to->generation,\n\t\t\t       l->parent_generation);\n\t\t\tret = -1;\n\t\t} else if (l->block_ref_to->flush_gen >\n\t\t\t   l->block_ref_to->dev_state->last_flush_gen) {\n\t\t\tprintk(KERN_INFO \"btrfs: attempt to write superblock\"\n\t\t\t       \" which references block %c @%llu (%s/%llu/%d)\"\n\t\t\t       \" which is not flushed out of disk's write cache\"\n\t\t\t       \" (block flush_gen=%llu,\"\n\t\t\t       \" dev->flush_gen=%llu)!\\n\",\n\t\t\t       btrfsic_get_block_type(state, l->block_ref_to),\n\t\t\t       l->block_ref_to->logical_bytenr,\n\t\t\t       l->block_ref_to->dev_state->name,\n\t\t\t       l->block_ref_to->dev_bytenr,\n\t\t\t       l->block_ref_to->mirror_num, block->flush_gen,\n\t\t\t       l->block_ref_to->dev_state->last_flush_gen);\n\t\t\tret = -1;\n\t\t} else if (-1 == btrfsic_check_all_ref_blocks(state,\n\t\t\t\t\t\t\t      l->block_ref_to,\n\t\t\t\t\t\t\t      recursion_level +\n\t\t\t\t\t\t\t      1)) {\n\t\t\tret = -1;\n\t\t}\n\t}\n\n\treturn ret;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_INFO \"btrfs: attempt to write superblock\"\n\t\t\t       \" which references block %c @%llu (%s/%llu/%d)\"\n\t\t\t       \" which is not flushed out of disk's write cache\"\n\t\t\t       \" (block flush_gen=%llu,\"\n\t\t\t       \" dev->flush_gen=%llu)!\\n\"",
            "btrfsic_get_block_type(state, l->block_ref_to)",
            "l->block_ref_to->logical_bytenr",
            "l->block_ref_to->dev_state->name",
            "l->block_ref_to->dev_bytenr",
            "l->block_ref_to->mirror_num",
            "block->flush_gen",
            "l->block_ref_to->dev_state->last_flush_gen"
          ],
          "line": 2536
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/super.c",
          "lines": "186-213",
          "snippet": "void btrfs_printk(const struct btrfs_fs_info *fs_info, const char *fmt, ...)\n{\n\tstruct super_block *sb = fs_info->sb;\n\tchar lvl[4];\n\tstruct va_format vaf;\n\tva_list args;\n\tconst char *type = logtypes[4];\n\tint kern_level;\n\n\tva_start(args, fmt);\n\n\tkern_level = printk_get_level(fmt);\n\tif (kern_level) {\n\t\tsize_t size = printk_skip_level(fmt) - fmt;\n\t\tmemcpy(lvl, fmt,  size);\n\t\tlvl[size] = '\\0';\n\t\tfmt += size;\n\t\ttype = logtypes[kern_level - '0'];\n\t} else\n\t\t*lvl = '\\0';\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sBTRFS %s (device %s): %pV\\n\", lvl, type, sb->s_id, &vaf);\n\n\tva_end(args);\n}",
          "includes": [
            "#include <trace/events/btrfs.h>",
            "#include \"qgroup.h\"",
            "#include \"tests/btrfs-tests.h\"",
            "#include \"backref.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"compression.h\"",
            "#include \"export.h\"",
            "#include \"volumes.h\"",
            "#include \"xattr.h\"",
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/slab.h>",
            "#include <linux/magic.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/namei.h>",
            "#include <linux/ctype.h>",
            "#include <linux/parser.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/btrfs.h>\n#include \"qgroup.h\"\n#include \"tests/btrfs-tests.h\"\n#include \"backref.h\"\n#include \"free-space-cache.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"compression.h\"\n#include \"export.h\"\n#include \"volumes.h\"\n#include \"xattr.h\"\n#include \"props.h\"\n#include \"hash.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include \"delayed-inode.h\"\n#include <linux/btrfs.h>\n#include <linux/ratelimit.h>\n#include <linux/cleancache.h>\n#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/miscdevice.h>\n#include <linux/namei.h>\n#include <linux/ctype.h>\n#include <linux/parser.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n\nvoid btrfs_printk(const struct btrfs_fs_info *fs_info, const char *fmt, ...)\n{\n\tstruct super_block *sb = fs_info->sb;\n\tchar lvl[4];\n\tstruct va_format vaf;\n\tva_list args;\n\tconst char *type = logtypes[4];\n\tint kern_level;\n\n\tva_start(args, fmt);\n\n\tkern_level = printk_get_level(fmt);\n\tif (kern_level) {\n\t\tsize_t size = printk_skip_level(fmt) - fmt;\n\t\tmemcpy(lvl, fmt,  size);\n\t\tlvl[size] = '\\0';\n\t\tfmt += size;\n\t\ttype = logtypes[kern_level - '0'];\n\t} else\n\t\t*lvl = '\\0';\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sBTRFS %s (device %s): %pV\\n\", lvl, type, sb->s_id, &vaf);\n\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfsic_get_block_type",
          "args": [
            "state",
            "l->block_ref_to"
          ],
          "line": 2541
        },
        "resolved": true,
        "details": {
          "function_name": "btrfsic_get_block_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/check-integrity.c",
          "lines": "2648-2661",
          "snippet": "static char btrfsic_get_block_type(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block *block)\n{\n\tif (block->is_superblock &&\n\t    state->latest_superblock->dev_bytenr == block->dev_bytenr &&\n\t    state->latest_superblock->dev_state->bdev == block->dev_state->bdev)\n\t\treturn 'S';\n\telse if (block->is_superblock)\n\t\treturn 's';\n\telse if (block->is_metadata)\n\t\treturn 'M';\n\telse\n\t\treturn 'D';\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"extent_io.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/genhd.h>",
            "#include <linux/mutex.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void btrfsic_dump_database(struct btrfsic_state *state);",
            "static char btrfsic_get_block_type(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block *block);",
            "static void btrfsic_dump_tree(const struct btrfsic_state *state);",
            "static struct btrfsic_dev_state *btrfsic_dev_state_lookup(\n\t\tstruct block_device *bdev);",
            "static void btrfsic_cmp_log_and_dev_bytenr(struct btrfsic_state *state,\n\t\t\t\t\t   u64 bytenr,\n\t\t\t\t\t   struct btrfsic_dev_state *dev_state,\n\t\t\t\t\t   u64 dev_bytenr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"extent_io.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n#include <linux/blkdev.h>\n#include <linux/genhd.h>\n#include <linux/mutex.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic void btrfsic_dump_database(struct btrfsic_state *state);\nstatic char btrfsic_get_block_type(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block *block);\nstatic void btrfsic_dump_tree(const struct btrfsic_state *state);\nstatic struct btrfsic_dev_state *btrfsic_dev_state_lookup(\n\t\tstruct block_device *bdev);\nstatic void btrfsic_cmp_log_and_dev_bytenr(struct btrfsic_state *state,\n\t\t\t\t\t   u64 bytenr,\n\t\t\t\t\t   struct btrfsic_dev_state *dev_state,\n\t\t\t\t\t   u64 dev_bytenr);\n\nstatic char btrfsic_get_block_type(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block *block)\n{\n\tif (block->is_superblock &&\n\t    state->latest_superblock->dev_bytenr == block->dev_bytenr &&\n\t    state->latest_superblock->dev_state->bdev == block->dev_state->bdev)\n\t\treturn 'S';\n\telse if (block->is_superblock)\n\t\treturn 's';\n\telse if (block->is_metadata)\n\t\treturn 'M';\n\telse\n\t\treturn 'D';\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "elem_ref_to",
            "structbtrfsic_block_link",
            "node_ref_to"
          ],
          "line": 2469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each",
          "args": [
            "elem_ref_to",
            "&block->ref_to_list"
          ],
          "line": 2467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_INFO\n\t\t\t       \"btrfsic: abort cyclic linkage (case 1).\\n\""
          ],
          "line": 2457
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"extent_io.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n#include <linux/blkdev.h>\n#include <linux/genhd.h>\n#include <linux/mutex.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\n#define BTRFSIC_PRINT_MASK_VERBOSE\t\t\t\t0x00000040\n#define BTRFSIC_GENERATION_UNKNOWN ((u64)-1)\n\nstatic void btrfsic_block_link_init(struct btrfsic_block_link *n);\nstatic void btrfsic_block_link_free(struct btrfsic_block_link *n);\nstatic void btrfsic_block_link_hashtable_remove(struct btrfsic_block_link *l);\nstatic int btrfsic_create_link_to_next_block(\n\t\tstruct btrfsic_state *state,\n\t\tstruct btrfsic_block *block,\n\t\tstruct btrfsic_block_data_ctx\n\t\t*block_ctx, u64 next_bytenr,\n\t\tint limit_nesting,\n\t\tstruct btrfsic_block_data_ctx *next_block_ctx,\n\t\tstruct btrfsic_block **next_blockp,\n\t\tint force_iodone_flag,\n\t\tint *num_copiesp, int *mirror_nump,\n\t\tstruct btrfs_disk_key *disk_key,\n\t\tu64 parent_generation);\nstatic int btrfsic_map_block(struct btrfsic_state *state, u64 bytenr, u32 len,\n\t\t\t     struct btrfsic_block_data_ctx *block_ctx_out,\n\t\t\t     int mirror_num);\nstatic void btrfsic_dump_database(struct btrfsic_state *state);\nstatic int btrfsic_is_block_ref_by_superblock(const struct btrfsic_state *state,\n\t\t\t\t\t      const struct btrfsic_block *block,\n\t\t\t\t\t      int recursion_level);\nstatic int btrfsic_check_all_ref_blocks(struct btrfsic_state *state,\n\t\t\t\t\tstruct btrfsic_block *const block,\n\t\t\t\t\tint recursion_level);\nstatic void btrfsic_print_add_link(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block_link *l);\nstatic void btrfsic_print_rem_link(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block_link *l);\nstatic char btrfsic_get_block_type(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block *block);\nstatic void btrfsic_dump_tree(const struct btrfsic_state *state);\nstatic struct btrfsic_block_link *btrfsic_block_link_lookup_or_add(\n\t\tstruct btrfsic_state *state,\n\t\tstruct btrfsic_block_data_ctx *next_block_ctx,\n\t\tstruct btrfsic_block *next_block,\n\t\tstruct btrfsic_block *from_block,\n\t\tu64 parent_generation);\nstatic void btrfsic_cmp_log_and_dev_bytenr(struct btrfsic_state *state,\n\t\t\t\t\t   u64 bytenr,\n\t\t\t\t\t   struct btrfsic_dev_state *dev_state,\n\t\t\t\t\t   u64 dev_bytenr);\n\nstatic int btrfsic_check_all_ref_blocks(struct btrfsic_state *state,\n\t\t\t\t\tstruct btrfsic_block *const block,\n\t\t\t\t\tint recursion_level)\n{\n\tstruct list_head *elem_ref_to;\n\tint ret = 0;\n\n\tif (recursion_level >= 3 + BTRFS_MAX_LEVEL) {\n\t\t/*\n\t\t * Note that this situation can happen and does not\n\t\t * indicate an error in regular cases. It happens\n\t\t * when disk blocks are freed and later reused.\n\t\t * The check-integrity module is not aware of any\n\t\t * block free operations, it just recognizes block\n\t\t * write operations. Therefore it keeps the linkage\n\t\t * information for a block until a block is\n\t\t * rewritten. This can temporarily cause incorrect\n\t\t * and even circular linkage informations. This\n\t\t * causes no harm unless such blocks are referenced\n\t\t * by the most recent super block.\n\t\t */\n\t\tif (state->print_mask & BTRFSIC_PRINT_MASK_VERBOSE)\n\t\t\tprintk(KERN_INFO\n\t\t\t       \"btrfsic: abort cyclic linkage (case 1).\\n\");\n\n\t\treturn ret;\n\t}\n\n\t/*\n\t * This algorithm is recursive because the amount of used stack\n\t * space is very small and the max recursion depth is limited.\n\t */\n\tlist_for_each(elem_ref_to, &block->ref_to_list) {\n\t\tconst struct btrfsic_block_link *const l =\n\t\t    list_entry(elem_ref_to, struct btrfsic_block_link,\n\t\t\t       node_ref_to);\n\n\t\tif (state->print_mask & BTRFSIC_PRINT_MASK_VERBOSE)\n\t\t\tprintk(KERN_INFO\n\t\t\t       \"rl=%d, %c @%llu (%s/%llu/%d)\"\n\t\t\t       \" %u* refers to %c @%llu (%s/%llu/%d)\\n\",\n\t\t\t       recursion_level,\n\t\t\t       btrfsic_get_block_type(state, block),\n\t\t\t       block->logical_bytenr, block->dev_state->name,\n\t\t\t       block->dev_bytenr, block->mirror_num,\n\t\t\t       l->ref_cnt,\n\t\t\t       btrfsic_get_block_type(state, l->block_ref_to),\n\t\t\t       l->block_ref_to->logical_bytenr,\n\t\t\t       l->block_ref_to->dev_state->name,\n\t\t\t       l->block_ref_to->dev_bytenr,\n\t\t\t       l->block_ref_to->mirror_num);\n\t\tif (l->block_ref_to->never_written) {\n\t\t\tprintk(KERN_INFO \"btrfs: attempt to write superblock\"\n\t\t\t       \" which references block %c @%llu (%s/%llu/%d)\"\n\t\t\t       \" which is never written!\\n\",\n\t\t\t       btrfsic_get_block_type(state, l->block_ref_to),\n\t\t\t       l->block_ref_to->logical_bytenr,\n\t\t\t       l->block_ref_to->dev_state->name,\n\t\t\t       l->block_ref_to->dev_bytenr,\n\t\t\t       l->block_ref_to->mirror_num);\n\t\t\tret = -1;\n\t\t} else if (!l->block_ref_to->is_iodone) {\n\t\t\tprintk(KERN_INFO \"btrfs: attempt to write superblock\"\n\t\t\t       \" which references block %c @%llu (%s/%llu/%d)\"\n\t\t\t       \" which is not yet iodone!\\n\",\n\t\t\t       btrfsic_get_block_type(state, l->block_ref_to),\n\t\t\t       l->block_ref_to->logical_bytenr,\n\t\t\t       l->block_ref_to->dev_state->name,\n\t\t\t       l->block_ref_to->dev_bytenr,\n\t\t\t       l->block_ref_to->mirror_num);\n\t\t\tret = -1;\n\t\t} else if (l->block_ref_to->iodone_w_error) {\n\t\t\tprintk(KERN_INFO \"btrfs: attempt to write superblock\"\n\t\t\t       \" which references block %c @%llu (%s/%llu/%d)\"\n\t\t\t       \" which has write error!\\n\",\n\t\t\t       btrfsic_get_block_type(state, l->block_ref_to),\n\t\t\t       l->block_ref_to->logical_bytenr,\n\t\t\t       l->block_ref_to->dev_state->name,\n\t\t\t       l->block_ref_to->dev_bytenr,\n\t\t\t       l->block_ref_to->mirror_num);\n\t\t\tret = -1;\n\t\t} else if (l->parent_generation !=\n\t\t\t   l->block_ref_to->generation &&\n\t\t\t   BTRFSIC_GENERATION_UNKNOWN !=\n\t\t\t   l->parent_generation &&\n\t\t\t   BTRFSIC_GENERATION_UNKNOWN !=\n\t\t\t   l->block_ref_to->generation) {\n\t\t\tprintk(KERN_INFO \"btrfs: attempt to write superblock\"\n\t\t\t       \" which references block %c @%llu (%s/%llu/%d)\"\n\t\t\t       \" with generation %llu !=\"\n\t\t\t       \" parent generation %llu!\\n\",\n\t\t\t       btrfsic_get_block_type(state, l->block_ref_to),\n\t\t\t       l->block_ref_to->logical_bytenr,\n\t\t\t       l->block_ref_to->dev_state->name,\n\t\t\t       l->block_ref_to->dev_bytenr,\n\t\t\t       l->block_ref_to->mirror_num,\n\t\t\t       l->block_ref_to->generation,\n\t\t\t       l->parent_generation);\n\t\t\tret = -1;\n\t\t} else if (l->block_ref_to->flush_gen >\n\t\t\t   l->block_ref_to->dev_state->last_flush_gen) {\n\t\t\tprintk(KERN_INFO \"btrfs: attempt to write superblock\"\n\t\t\t       \" which references block %c @%llu (%s/%llu/%d)\"\n\t\t\t       \" which is not flushed out of disk's write cache\"\n\t\t\t       \" (block flush_gen=%llu,\"\n\t\t\t       \" dev->flush_gen=%llu)!\\n\",\n\t\t\t       btrfsic_get_block_type(state, l->block_ref_to),\n\t\t\t       l->block_ref_to->logical_bytenr,\n\t\t\t       l->block_ref_to->dev_state->name,\n\t\t\t       l->block_ref_to->dev_bytenr,\n\t\t\t       l->block_ref_to->mirror_num, block->flush_gen,\n\t\t\t       l->block_ref_to->dev_state->last_flush_gen);\n\t\t\tret = -1;\n\t\t} else if (-1 == btrfsic_check_all_ref_blocks(state,\n\t\t\t\t\t\t\t      l->block_ref_to,\n\t\t\t\t\t\t\t      recursion_level +\n\t\t\t\t\t\t\t      1)) {\n\t\t\tret = -1;\n\t\t}\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "btrfsic_process_written_superblock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/check-integrity.c",
    "lines": "2292-2433",
    "snippet": "static int btrfsic_process_written_superblock(\n\t\tstruct btrfsic_state *state,\n\t\tstruct btrfsic_block *const superblock,\n\t\tstruct btrfs_super_block *const super_hdr)\n{\n\tint pass;\n\n\tsuperblock->generation = btrfs_super_generation(super_hdr);\n\tif (!(superblock->generation > state->max_superblock_generation ||\n\t      0 == state->max_superblock_generation)) {\n\t\tif (state->print_mask & BTRFSIC_PRINT_MASK_SUPERBLOCK_WRITE)\n\t\t\tprintk(KERN_INFO\n\t\t\t       \"btrfsic: superblock @%llu (%s/%llu/%d)\"\n\t\t\t       \" with old gen %llu <= %llu\\n\",\n\t\t\t       superblock->logical_bytenr,\n\t\t\t       superblock->dev_state->name,\n\t\t\t       superblock->dev_bytenr, superblock->mirror_num,\n\t\t\t       btrfs_super_generation(super_hdr),\n\t\t\t       state->max_superblock_generation);\n\t} else {\n\t\tif (state->print_mask & BTRFSIC_PRINT_MASK_SUPERBLOCK_WRITE)\n\t\t\tprintk(KERN_INFO\n\t\t\t       \"btrfsic: got new superblock @%llu (%s/%llu/%d)\"\n\t\t\t       \" with new gen %llu > %llu\\n\",\n\t\t\t       superblock->logical_bytenr,\n\t\t\t       superblock->dev_state->name,\n\t\t\t       superblock->dev_bytenr, superblock->mirror_num,\n\t\t\t       btrfs_super_generation(super_hdr),\n\t\t\t       state->max_superblock_generation);\n\n\t\tstate->max_superblock_generation =\n\t\t    btrfs_super_generation(super_hdr);\n\t\tstate->latest_superblock = superblock;\n\t}\n\n\tfor (pass = 0; pass < 3; pass++) {\n\t\tint ret;\n\t\tu64 next_bytenr;\n\t\tstruct btrfsic_block *next_block;\n\t\tstruct btrfsic_block_data_ctx tmp_next_block_ctx;\n\t\tstruct btrfsic_block_link *l;\n\t\tint num_copies;\n\t\tint mirror_num;\n\t\tconst char *additional_string = NULL;\n\t\tstruct btrfs_disk_key tmp_disk_key = {0};\n\n\t\tbtrfs_set_disk_key_objectid(&tmp_disk_key,\n\t\t\t\t\t    BTRFS_ROOT_ITEM_KEY);\n\t\tbtrfs_set_disk_key_objectid(&tmp_disk_key, 0);\n\n\t\tswitch (pass) {\n\t\tcase 0:\n\t\t\tbtrfs_set_disk_key_objectid(&tmp_disk_key,\n\t\t\t\t\t\t    BTRFS_ROOT_TREE_OBJECTID);\n\t\t\tadditional_string = \"root \";\n\t\t\tnext_bytenr = btrfs_super_root(super_hdr);\n\t\t\tif (state->print_mask &\n\t\t\t    BTRFSIC_PRINT_MASK_ROOT_CHUNK_LOG_TREE_LOCATION)\n\t\t\t\tprintk(KERN_INFO \"root@%llu\\n\", next_bytenr);\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tbtrfs_set_disk_key_objectid(&tmp_disk_key,\n\t\t\t\t\t\t    BTRFS_CHUNK_TREE_OBJECTID);\n\t\t\tadditional_string = \"chunk \";\n\t\t\tnext_bytenr = btrfs_super_chunk_root(super_hdr);\n\t\t\tif (state->print_mask &\n\t\t\t    BTRFSIC_PRINT_MASK_ROOT_CHUNK_LOG_TREE_LOCATION)\n\t\t\t\tprintk(KERN_INFO \"chunk@%llu\\n\", next_bytenr);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tbtrfs_set_disk_key_objectid(&tmp_disk_key,\n\t\t\t\t\t\t    BTRFS_TREE_LOG_OBJECTID);\n\t\t\tadditional_string = \"log \";\n\t\t\tnext_bytenr = btrfs_super_log_root(super_hdr);\n\t\t\tif (0 == next_bytenr)\n\t\t\t\tcontinue;\n\t\t\tif (state->print_mask &\n\t\t\t    BTRFSIC_PRINT_MASK_ROOT_CHUNK_LOG_TREE_LOCATION)\n\t\t\t\tprintk(KERN_INFO \"log@%llu\\n\", next_bytenr);\n\t\t\tbreak;\n\t\t}\n\n\t\tnum_copies =\n\t\t    btrfs_num_copies(state->root->fs_info,\n\t\t\t\t     next_bytenr, BTRFS_SUPER_INFO_SIZE);\n\t\tif (state->print_mask & BTRFSIC_PRINT_MASK_NUM_COPIES)\n\t\t\tprintk(KERN_INFO \"num_copies(log_bytenr=%llu) = %d\\n\",\n\t\t\t       next_bytenr, num_copies);\n\t\tfor (mirror_num = 1; mirror_num <= num_copies; mirror_num++) {\n\t\t\tint was_created;\n\n\t\t\tif (state->print_mask & BTRFSIC_PRINT_MASK_VERBOSE)\n\t\t\t\tprintk(KERN_INFO\n\t\t\t\t       \"btrfsic_process_written_superblock(\"\n\t\t\t\t       \"mirror_num=%d)\\n\", mirror_num);\n\t\t\tret = btrfsic_map_block(state, next_bytenr,\n\t\t\t\t\t\tBTRFS_SUPER_INFO_SIZE,\n\t\t\t\t\t\t&tmp_next_block_ctx,\n\t\t\t\t\t\tmirror_num);\n\t\t\tif (ret) {\n\t\t\t\tprintk(KERN_INFO\n\t\t\t\t       \"btrfsic: btrfsic_map_block(@%llu,\"\n\t\t\t\t       \" mirror=%d) failed!\\n\",\n\t\t\t\t       next_bytenr, mirror_num);\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tnext_block = btrfsic_block_lookup_or_add(\n\t\t\t\t\tstate,\n\t\t\t\t\t&tmp_next_block_ctx,\n\t\t\t\t\tadditional_string,\n\t\t\t\t\t1, 0, 1,\n\t\t\t\t\tmirror_num,\n\t\t\t\t\t&was_created);\n\t\t\tif (NULL == next_block) {\n\t\t\t\tprintk(KERN_INFO\n\t\t\t\t       \"btrfsic: error, kmalloc failed!\\n\");\n\t\t\t\tbtrfsic_release_block_ctx(&tmp_next_block_ctx);\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tnext_block->disk_key = tmp_disk_key;\n\t\t\tif (was_created)\n\t\t\t\tnext_block->generation =\n\t\t\t\t    BTRFSIC_GENERATION_UNKNOWN;\n\t\t\tl = btrfsic_block_link_lookup_or_add(\n\t\t\t\t\tstate,\n\t\t\t\t\t&tmp_next_block_ctx,\n\t\t\t\t\tnext_block,\n\t\t\t\t\tsuperblock,\n\t\t\t\t\tBTRFSIC_GENERATION_UNKNOWN);\n\t\t\tbtrfsic_release_block_ctx(&tmp_next_block_ctx);\n\t\t\tif (NULL == l)\n\t\t\t\treturn -1;\n\t\t}\n\t}\n\n\tif (WARN_ON(-1 == btrfsic_check_all_ref_blocks(state, superblock, 0)))\n\t\tbtrfsic_dump_tree(state);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"volumes.h\"",
      "#include \"extent_io.h\"",
      "#include \"transaction.h\"",
      "#include \"hash.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/genhd.h>",
      "#include <linux/mutex.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [
      "#define BTRFSIC_PRINT_MASK_NUM_COPIES\t\t\t\t0x00000800",
      "#define BTRFSIC_PRINT_MASK_VERBOSE\t\t\t\t0x00000040",
      "#define BTRFSIC_PRINT_MASK_ROOT_CHUNK_LOG_TREE_LOCATION\t\t0x00000002",
      "#define BTRFSIC_PRINT_MASK_SUPERBLOCK_WRITE\t\t\t0x00000001",
      "#define BTRFSIC_GENERATION_UNKNOWN ((u64)-1)"
    ],
    "globals_used": [
      "static void btrfsic_block_link_init(struct btrfsic_block_link *n);",
      "static void btrfsic_block_link_free(struct btrfsic_block_link *n);",
      "static void btrfsic_block_link_hashtable_remove(struct btrfsic_block_link *l);",
      "static int btrfsic_map_block(struct btrfsic_state *state, u64 bytenr, u32 len,\n\t\t\t     struct btrfsic_block_data_ctx *block_ctx_out,\n\t\t\t     int mirror_num);",
      "static void btrfsic_dump_database(struct btrfsic_state *state);",
      "static int btrfsic_process_written_superblock(\n\t\tstruct btrfsic_state *state,\n\t\tstruct btrfsic_block *const block,\n\t\tstruct btrfs_super_block *const super_hdr);",
      "static void btrfsic_print_add_link(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block_link *l);",
      "static void btrfsic_print_rem_link(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block_link *l);",
      "static void btrfsic_dump_tree(const struct btrfsic_state *state);",
      "static struct btrfsic_block *btrfsic_block_lookup_or_add(\n\t\tstruct btrfsic_state *state,\n\t\tstruct btrfsic_block_data_ctx *block_ctx,\n\t\tconst char *additional_string,\n\t\tint is_metadata,\n\t\tint is_iodone,\n\t\tint never_written,\n\t\tint mirror_num,\n\t\tint *was_created);",
      "static void btrfsic_cmp_log_and_dev_bytenr(struct btrfsic_state *state,\n\t\t\t\t\t   u64 bytenr,\n\t\t\t\t\t   struct btrfsic_dev_state *dev_state,\n\t\t\t\t\t   u64 dev_bytenr);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfsic_dump_tree",
          "args": [
            "state"
          ],
          "line": 2430
        },
        "resolved": true,
        "details": {
          "function_name": "btrfsic_dump_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/check-integrity.c",
          "lines": "2663-2666",
          "snippet": "static void btrfsic_dump_tree(const struct btrfsic_state *state)\n{\n\tbtrfsic_dump_tree_sub(state, state->latest_superblock, 0);\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"extent_io.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/genhd.h>",
            "#include <linux/mutex.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void btrfsic_dump_database(struct btrfsic_state *state);",
            "static void btrfsic_dump_tree(const struct btrfsic_state *state);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"extent_io.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n#include <linux/blkdev.h>\n#include <linux/genhd.h>\n#include <linux/mutex.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic void btrfsic_dump_database(struct btrfsic_state *state);\nstatic void btrfsic_dump_tree(const struct btrfsic_state *state);\n\nstatic void btrfsic_dump_tree(const struct btrfsic_state *state)\n{\n\tbtrfsic_dump_tree_sub(state, state->latest_superblock, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "-1 == btrfsic_check_all_ref_blocks(state, superblock, 0)"
          ],
          "line": 2429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfsic_check_all_ref_blocks",
          "args": [
            "state",
            "superblock",
            "0"
          ],
          "line": 2429
        },
        "resolved": true,
        "details": {
          "function_name": "btrfsic_check_all_ref_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/check-integrity.c",
          "lines": "2435-2557",
          "snippet": "static int btrfsic_check_all_ref_blocks(struct btrfsic_state *state,\n\t\t\t\t\tstruct btrfsic_block *const block,\n\t\t\t\t\tint recursion_level)\n{\n\tstruct list_head *elem_ref_to;\n\tint ret = 0;\n\n\tif (recursion_level >= 3 + BTRFS_MAX_LEVEL) {\n\t\t/*\n\t\t * Note that this situation can happen and does not\n\t\t * indicate an error in regular cases. It happens\n\t\t * when disk blocks are freed and later reused.\n\t\t * The check-integrity module is not aware of any\n\t\t * block free operations, it just recognizes block\n\t\t * write operations. Therefore it keeps the linkage\n\t\t * information for a block until a block is\n\t\t * rewritten. This can temporarily cause incorrect\n\t\t * and even circular linkage informations. This\n\t\t * causes no harm unless such blocks are referenced\n\t\t * by the most recent super block.\n\t\t */\n\t\tif (state->print_mask & BTRFSIC_PRINT_MASK_VERBOSE)\n\t\t\tprintk(KERN_INFO\n\t\t\t       \"btrfsic: abort cyclic linkage (case 1).\\n\");\n\n\t\treturn ret;\n\t}\n\n\t/*\n\t * This algorithm is recursive because the amount of used stack\n\t * space is very small and the max recursion depth is limited.\n\t */\n\tlist_for_each(elem_ref_to, &block->ref_to_list) {\n\t\tconst struct btrfsic_block_link *const l =\n\t\t    list_entry(elem_ref_to, struct btrfsic_block_link,\n\t\t\t       node_ref_to);\n\n\t\tif (state->print_mask & BTRFSIC_PRINT_MASK_VERBOSE)\n\t\t\tprintk(KERN_INFO\n\t\t\t       \"rl=%d, %c @%llu (%s/%llu/%d)\"\n\t\t\t       \" %u* refers to %c @%llu (%s/%llu/%d)\\n\",\n\t\t\t       recursion_level,\n\t\t\t       btrfsic_get_block_type(state, block),\n\t\t\t       block->logical_bytenr, block->dev_state->name,\n\t\t\t       block->dev_bytenr, block->mirror_num,\n\t\t\t       l->ref_cnt,\n\t\t\t       btrfsic_get_block_type(state, l->block_ref_to),\n\t\t\t       l->block_ref_to->logical_bytenr,\n\t\t\t       l->block_ref_to->dev_state->name,\n\t\t\t       l->block_ref_to->dev_bytenr,\n\t\t\t       l->block_ref_to->mirror_num);\n\t\tif (l->block_ref_to->never_written) {\n\t\t\tprintk(KERN_INFO \"btrfs: attempt to write superblock\"\n\t\t\t       \" which references block %c @%llu (%s/%llu/%d)\"\n\t\t\t       \" which is never written!\\n\",\n\t\t\t       btrfsic_get_block_type(state, l->block_ref_to),\n\t\t\t       l->block_ref_to->logical_bytenr,\n\t\t\t       l->block_ref_to->dev_state->name,\n\t\t\t       l->block_ref_to->dev_bytenr,\n\t\t\t       l->block_ref_to->mirror_num);\n\t\t\tret = -1;\n\t\t} else if (!l->block_ref_to->is_iodone) {\n\t\t\tprintk(KERN_INFO \"btrfs: attempt to write superblock\"\n\t\t\t       \" which references block %c @%llu (%s/%llu/%d)\"\n\t\t\t       \" which is not yet iodone!\\n\",\n\t\t\t       btrfsic_get_block_type(state, l->block_ref_to),\n\t\t\t       l->block_ref_to->logical_bytenr,\n\t\t\t       l->block_ref_to->dev_state->name,\n\t\t\t       l->block_ref_to->dev_bytenr,\n\t\t\t       l->block_ref_to->mirror_num);\n\t\t\tret = -1;\n\t\t} else if (l->block_ref_to->iodone_w_error) {\n\t\t\tprintk(KERN_INFO \"btrfs: attempt to write superblock\"\n\t\t\t       \" which references block %c @%llu (%s/%llu/%d)\"\n\t\t\t       \" which has write error!\\n\",\n\t\t\t       btrfsic_get_block_type(state, l->block_ref_to),\n\t\t\t       l->block_ref_to->logical_bytenr,\n\t\t\t       l->block_ref_to->dev_state->name,\n\t\t\t       l->block_ref_to->dev_bytenr,\n\t\t\t       l->block_ref_to->mirror_num);\n\t\t\tret = -1;\n\t\t} else if (l->parent_generation !=\n\t\t\t   l->block_ref_to->generation &&\n\t\t\t   BTRFSIC_GENERATION_UNKNOWN !=\n\t\t\t   l->parent_generation &&\n\t\t\t   BTRFSIC_GENERATION_UNKNOWN !=\n\t\t\t   l->block_ref_to->generation) {\n\t\t\tprintk(KERN_INFO \"btrfs: attempt to write superblock\"\n\t\t\t       \" which references block %c @%llu (%s/%llu/%d)\"\n\t\t\t       \" with generation %llu !=\"\n\t\t\t       \" parent generation %llu!\\n\",\n\t\t\t       btrfsic_get_block_type(state, l->block_ref_to),\n\t\t\t       l->block_ref_to->logical_bytenr,\n\t\t\t       l->block_ref_to->dev_state->name,\n\t\t\t       l->block_ref_to->dev_bytenr,\n\t\t\t       l->block_ref_to->mirror_num,\n\t\t\t       l->block_ref_to->generation,\n\t\t\t       l->parent_generation);\n\t\t\tret = -1;\n\t\t} else if (l->block_ref_to->flush_gen >\n\t\t\t   l->block_ref_to->dev_state->last_flush_gen) {\n\t\t\tprintk(KERN_INFO \"btrfs: attempt to write superblock\"\n\t\t\t       \" which references block %c @%llu (%s/%llu/%d)\"\n\t\t\t       \" which is not flushed out of disk's write cache\"\n\t\t\t       \" (block flush_gen=%llu,\"\n\t\t\t       \" dev->flush_gen=%llu)!\\n\",\n\t\t\t       btrfsic_get_block_type(state, l->block_ref_to),\n\t\t\t       l->block_ref_to->logical_bytenr,\n\t\t\t       l->block_ref_to->dev_state->name,\n\t\t\t       l->block_ref_to->dev_bytenr,\n\t\t\t       l->block_ref_to->mirror_num, block->flush_gen,\n\t\t\t       l->block_ref_to->dev_state->last_flush_gen);\n\t\t\tret = -1;\n\t\t} else if (-1 == btrfsic_check_all_ref_blocks(state,\n\t\t\t\t\t\t\t      l->block_ref_to,\n\t\t\t\t\t\t\t      recursion_level +\n\t\t\t\t\t\t\t      1)) {\n\t\t\tret = -1;\n\t\t}\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"extent_io.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/genhd.h>",
            "#include <linux/mutex.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define BTRFSIC_PRINT_MASK_VERBOSE\t\t\t\t0x00000040",
            "#define BTRFSIC_GENERATION_UNKNOWN ((u64)-1)"
          ],
          "globals_used": [
            "static void btrfsic_block_link_init(struct btrfsic_block_link *n);",
            "static void btrfsic_block_link_free(struct btrfsic_block_link *n);",
            "static void btrfsic_block_link_hashtable_remove(struct btrfsic_block_link *l);",
            "static int btrfsic_create_link_to_next_block(\n\t\tstruct btrfsic_state *state,\n\t\tstruct btrfsic_block *block,\n\t\tstruct btrfsic_block_data_ctx\n\t\t*block_ctx, u64 next_bytenr,\n\t\tint limit_nesting,\n\t\tstruct btrfsic_block_data_ctx *next_block_ctx,\n\t\tstruct btrfsic_block **next_blockp,\n\t\tint force_iodone_flag,\n\t\tint *num_copiesp, int *mirror_nump,\n\t\tstruct btrfs_disk_key *disk_key,\n\t\tu64 parent_generation);",
            "static int btrfsic_map_block(struct btrfsic_state *state, u64 bytenr, u32 len,\n\t\t\t     struct btrfsic_block_data_ctx *block_ctx_out,\n\t\t\t     int mirror_num);",
            "static void btrfsic_dump_database(struct btrfsic_state *state);",
            "static int btrfsic_is_block_ref_by_superblock(const struct btrfsic_state *state,\n\t\t\t\t\t      const struct btrfsic_block *block,\n\t\t\t\t\t      int recursion_level);",
            "static int btrfsic_check_all_ref_blocks(struct btrfsic_state *state,\n\t\t\t\t\tstruct btrfsic_block *const block,\n\t\t\t\t\tint recursion_level);",
            "static void btrfsic_print_add_link(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block_link *l);",
            "static void btrfsic_print_rem_link(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block_link *l);",
            "static char btrfsic_get_block_type(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block *block);",
            "static void btrfsic_dump_tree(const struct btrfsic_state *state);",
            "static struct btrfsic_block_link *btrfsic_block_link_lookup_or_add(\n\t\tstruct btrfsic_state *state,\n\t\tstruct btrfsic_block_data_ctx *next_block_ctx,\n\t\tstruct btrfsic_block *next_block,\n\t\tstruct btrfsic_block *from_block,\n\t\tu64 parent_generation);",
            "static void btrfsic_cmp_log_and_dev_bytenr(struct btrfsic_state *state,\n\t\t\t\t\t   u64 bytenr,\n\t\t\t\t\t   struct btrfsic_dev_state *dev_state,\n\t\t\t\t\t   u64 dev_bytenr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"extent_io.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n#include <linux/blkdev.h>\n#include <linux/genhd.h>\n#include <linux/mutex.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\n#define BTRFSIC_PRINT_MASK_VERBOSE\t\t\t\t0x00000040\n#define BTRFSIC_GENERATION_UNKNOWN ((u64)-1)\n\nstatic void btrfsic_block_link_init(struct btrfsic_block_link *n);\nstatic void btrfsic_block_link_free(struct btrfsic_block_link *n);\nstatic void btrfsic_block_link_hashtable_remove(struct btrfsic_block_link *l);\nstatic int btrfsic_create_link_to_next_block(\n\t\tstruct btrfsic_state *state,\n\t\tstruct btrfsic_block *block,\n\t\tstruct btrfsic_block_data_ctx\n\t\t*block_ctx, u64 next_bytenr,\n\t\tint limit_nesting,\n\t\tstruct btrfsic_block_data_ctx *next_block_ctx,\n\t\tstruct btrfsic_block **next_blockp,\n\t\tint force_iodone_flag,\n\t\tint *num_copiesp, int *mirror_nump,\n\t\tstruct btrfs_disk_key *disk_key,\n\t\tu64 parent_generation);\nstatic int btrfsic_map_block(struct btrfsic_state *state, u64 bytenr, u32 len,\n\t\t\t     struct btrfsic_block_data_ctx *block_ctx_out,\n\t\t\t     int mirror_num);\nstatic void btrfsic_dump_database(struct btrfsic_state *state);\nstatic int btrfsic_is_block_ref_by_superblock(const struct btrfsic_state *state,\n\t\t\t\t\t      const struct btrfsic_block *block,\n\t\t\t\t\t      int recursion_level);\nstatic int btrfsic_check_all_ref_blocks(struct btrfsic_state *state,\n\t\t\t\t\tstruct btrfsic_block *const block,\n\t\t\t\t\tint recursion_level);\nstatic void btrfsic_print_add_link(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block_link *l);\nstatic void btrfsic_print_rem_link(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block_link *l);\nstatic char btrfsic_get_block_type(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block *block);\nstatic void btrfsic_dump_tree(const struct btrfsic_state *state);\nstatic struct btrfsic_block_link *btrfsic_block_link_lookup_or_add(\n\t\tstruct btrfsic_state *state,\n\t\tstruct btrfsic_block_data_ctx *next_block_ctx,\n\t\tstruct btrfsic_block *next_block,\n\t\tstruct btrfsic_block *from_block,\n\t\tu64 parent_generation);\nstatic void btrfsic_cmp_log_and_dev_bytenr(struct btrfsic_state *state,\n\t\t\t\t\t   u64 bytenr,\n\t\t\t\t\t   struct btrfsic_dev_state *dev_state,\n\t\t\t\t\t   u64 dev_bytenr);\n\nstatic int btrfsic_check_all_ref_blocks(struct btrfsic_state *state,\n\t\t\t\t\tstruct btrfsic_block *const block,\n\t\t\t\t\tint recursion_level)\n{\n\tstruct list_head *elem_ref_to;\n\tint ret = 0;\n\n\tif (recursion_level >= 3 + BTRFS_MAX_LEVEL) {\n\t\t/*\n\t\t * Note that this situation can happen and does not\n\t\t * indicate an error in regular cases. It happens\n\t\t * when disk blocks are freed and later reused.\n\t\t * The check-integrity module is not aware of any\n\t\t * block free operations, it just recognizes block\n\t\t * write operations. Therefore it keeps the linkage\n\t\t * information for a block until a block is\n\t\t * rewritten. This can temporarily cause incorrect\n\t\t * and even circular linkage informations. This\n\t\t * causes no harm unless such blocks are referenced\n\t\t * by the most recent super block.\n\t\t */\n\t\tif (state->print_mask & BTRFSIC_PRINT_MASK_VERBOSE)\n\t\t\tprintk(KERN_INFO\n\t\t\t       \"btrfsic: abort cyclic linkage (case 1).\\n\");\n\n\t\treturn ret;\n\t}\n\n\t/*\n\t * This algorithm is recursive because the amount of used stack\n\t * space is very small and the max recursion depth is limited.\n\t */\n\tlist_for_each(elem_ref_to, &block->ref_to_list) {\n\t\tconst struct btrfsic_block_link *const l =\n\t\t    list_entry(elem_ref_to, struct btrfsic_block_link,\n\t\t\t       node_ref_to);\n\n\t\tif (state->print_mask & BTRFSIC_PRINT_MASK_VERBOSE)\n\t\t\tprintk(KERN_INFO\n\t\t\t       \"rl=%d, %c @%llu (%s/%llu/%d)\"\n\t\t\t       \" %u* refers to %c @%llu (%s/%llu/%d)\\n\",\n\t\t\t       recursion_level,\n\t\t\t       btrfsic_get_block_type(state, block),\n\t\t\t       block->logical_bytenr, block->dev_state->name,\n\t\t\t       block->dev_bytenr, block->mirror_num,\n\t\t\t       l->ref_cnt,\n\t\t\t       btrfsic_get_block_type(state, l->block_ref_to),\n\t\t\t       l->block_ref_to->logical_bytenr,\n\t\t\t       l->block_ref_to->dev_state->name,\n\t\t\t       l->block_ref_to->dev_bytenr,\n\t\t\t       l->block_ref_to->mirror_num);\n\t\tif (l->block_ref_to->never_written) {\n\t\t\tprintk(KERN_INFO \"btrfs: attempt to write superblock\"\n\t\t\t       \" which references block %c @%llu (%s/%llu/%d)\"\n\t\t\t       \" which is never written!\\n\",\n\t\t\t       btrfsic_get_block_type(state, l->block_ref_to),\n\t\t\t       l->block_ref_to->logical_bytenr,\n\t\t\t       l->block_ref_to->dev_state->name,\n\t\t\t       l->block_ref_to->dev_bytenr,\n\t\t\t       l->block_ref_to->mirror_num);\n\t\t\tret = -1;\n\t\t} else if (!l->block_ref_to->is_iodone) {\n\t\t\tprintk(KERN_INFO \"btrfs: attempt to write superblock\"\n\t\t\t       \" which references block %c @%llu (%s/%llu/%d)\"\n\t\t\t       \" which is not yet iodone!\\n\",\n\t\t\t       btrfsic_get_block_type(state, l->block_ref_to),\n\t\t\t       l->block_ref_to->logical_bytenr,\n\t\t\t       l->block_ref_to->dev_state->name,\n\t\t\t       l->block_ref_to->dev_bytenr,\n\t\t\t       l->block_ref_to->mirror_num);\n\t\t\tret = -1;\n\t\t} else if (l->block_ref_to->iodone_w_error) {\n\t\t\tprintk(KERN_INFO \"btrfs: attempt to write superblock\"\n\t\t\t       \" which references block %c @%llu (%s/%llu/%d)\"\n\t\t\t       \" which has write error!\\n\",\n\t\t\t       btrfsic_get_block_type(state, l->block_ref_to),\n\t\t\t       l->block_ref_to->logical_bytenr,\n\t\t\t       l->block_ref_to->dev_state->name,\n\t\t\t       l->block_ref_to->dev_bytenr,\n\t\t\t       l->block_ref_to->mirror_num);\n\t\t\tret = -1;\n\t\t} else if (l->parent_generation !=\n\t\t\t   l->block_ref_to->generation &&\n\t\t\t   BTRFSIC_GENERATION_UNKNOWN !=\n\t\t\t   l->parent_generation &&\n\t\t\t   BTRFSIC_GENERATION_UNKNOWN !=\n\t\t\t   l->block_ref_to->generation) {\n\t\t\tprintk(KERN_INFO \"btrfs: attempt to write superblock\"\n\t\t\t       \" which references block %c @%llu (%s/%llu/%d)\"\n\t\t\t       \" with generation %llu !=\"\n\t\t\t       \" parent generation %llu!\\n\",\n\t\t\t       btrfsic_get_block_type(state, l->block_ref_to),\n\t\t\t       l->block_ref_to->logical_bytenr,\n\t\t\t       l->block_ref_to->dev_state->name,\n\t\t\t       l->block_ref_to->dev_bytenr,\n\t\t\t       l->block_ref_to->mirror_num,\n\t\t\t       l->block_ref_to->generation,\n\t\t\t       l->parent_generation);\n\t\t\tret = -1;\n\t\t} else if (l->block_ref_to->flush_gen >\n\t\t\t   l->block_ref_to->dev_state->last_flush_gen) {\n\t\t\tprintk(KERN_INFO \"btrfs: attempt to write superblock\"\n\t\t\t       \" which references block %c @%llu (%s/%llu/%d)\"\n\t\t\t       \" which is not flushed out of disk's write cache\"\n\t\t\t       \" (block flush_gen=%llu,\"\n\t\t\t       \" dev->flush_gen=%llu)!\\n\",\n\t\t\t       btrfsic_get_block_type(state, l->block_ref_to),\n\t\t\t       l->block_ref_to->logical_bytenr,\n\t\t\t       l->block_ref_to->dev_state->name,\n\t\t\t       l->block_ref_to->dev_bytenr,\n\t\t\t       l->block_ref_to->mirror_num, block->flush_gen,\n\t\t\t       l->block_ref_to->dev_state->last_flush_gen);\n\t\t\tret = -1;\n\t\t} else if (-1 == btrfsic_check_all_ref_blocks(state,\n\t\t\t\t\t\t\t      l->block_ref_to,\n\t\t\t\t\t\t\t      recursion_level +\n\t\t\t\t\t\t\t      1)) {\n\t\t\tret = -1;\n\t\t}\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfsic_release_block_ctx",
          "args": [
            "&tmp_next_block_ctx"
          ],
          "line": 2423
        },
        "resolved": true,
        "details": {
          "function_name": "btrfsic_release_block_ctx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/check-integrity.c",
          "lines": "1611-1637",
          "snippet": "static void btrfsic_release_block_ctx(struct btrfsic_block_data_ctx *block_ctx)\n{\n\tif (block_ctx->mem_to_free) {\n\t\tunsigned int num_pages;\n\n\t\tBUG_ON(!block_ctx->datav);\n\t\tBUG_ON(!block_ctx->pagev);\n\t\tnum_pages = (block_ctx->len + (u64)PAGE_CACHE_SIZE - 1) >>\n\t\t\t    PAGE_CACHE_SHIFT;\n\t\twhile (num_pages > 0) {\n\t\t\tnum_pages--;\n\t\t\tif (block_ctx->datav[num_pages]) {\n\t\t\t\tkunmap(block_ctx->pagev[num_pages]);\n\t\t\t\tblock_ctx->datav[num_pages] = NULL;\n\t\t\t}\n\t\t\tif (block_ctx->pagev[num_pages]) {\n\t\t\t\t__free_page(block_ctx->pagev[num_pages]);\n\t\t\t\tblock_ctx->pagev[num_pages] = NULL;\n\t\t\t}\n\t\t}\n\n\t\tkfree(block_ctx->mem_to_free);\n\t\tblock_ctx->mem_to_free = NULL;\n\t\tblock_ctx->pagev = NULL;\n\t\tblock_ctx->datav = NULL;\n\t}\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"extent_io.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/genhd.h>",
            "#include <linux/mutex.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void btrfsic_read_from_block_data(\n\tstruct btrfsic_block_data_ctx *block_ctx,\n\tvoid *dst, u32 offset, size_t len);",
            "static void btrfsic_release_block_ctx(struct btrfsic_block_data_ctx *block_ctx);",
            "static int btrfsic_read_block(struct btrfsic_state *state,\n\t\t\t      struct btrfsic_block_data_ctx *block_ctx);",
            "static int btrfsic_test_for_metadata(struct btrfsic_state *state,\n\t\t\t\t     char **datav, unsigned int num_pages);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"extent_io.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n#include <linux/blkdev.h>\n#include <linux/genhd.h>\n#include <linux/mutex.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic void btrfsic_read_from_block_data(\n\tstruct btrfsic_block_data_ctx *block_ctx,\n\tvoid *dst, u32 offset, size_t len);\nstatic void btrfsic_release_block_ctx(struct btrfsic_block_data_ctx *block_ctx);\nstatic int btrfsic_read_block(struct btrfsic_state *state,\n\t\t\t      struct btrfsic_block_data_ctx *block_ctx);\nstatic int btrfsic_test_for_metadata(struct btrfsic_state *state,\n\t\t\t\t     char **datav, unsigned int num_pages);\n\nstatic void btrfsic_release_block_ctx(struct btrfsic_block_data_ctx *block_ctx)\n{\n\tif (block_ctx->mem_to_free) {\n\t\tunsigned int num_pages;\n\n\t\tBUG_ON(!block_ctx->datav);\n\t\tBUG_ON(!block_ctx->pagev);\n\t\tnum_pages = (block_ctx->len + (u64)PAGE_CACHE_SIZE - 1) >>\n\t\t\t    PAGE_CACHE_SHIFT;\n\t\twhile (num_pages > 0) {\n\t\t\tnum_pages--;\n\t\t\tif (block_ctx->datav[num_pages]) {\n\t\t\t\tkunmap(block_ctx->pagev[num_pages]);\n\t\t\t\tblock_ctx->datav[num_pages] = NULL;\n\t\t\t}\n\t\t\tif (block_ctx->pagev[num_pages]) {\n\t\t\t\t__free_page(block_ctx->pagev[num_pages]);\n\t\t\t\tblock_ctx->pagev[num_pages] = NULL;\n\t\t\t}\n\t\t}\n\n\t\tkfree(block_ctx->mem_to_free);\n\t\tblock_ctx->mem_to_free = NULL;\n\t\tblock_ctx->pagev = NULL;\n\t\tblock_ctx->datav = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfsic_block_link_lookup_or_add",
          "args": [
            "state",
            "&tmp_next_block_ctx",
            "next_block",
            "superblock",
            "BTRFSIC_GENERATION_UNKNOWN"
          ],
          "line": 2417
        },
        "resolved": true,
        "details": {
          "function_name": "btrfsic_block_link_lookup_or_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/check-integrity.c",
          "lines": "2735-2778",
          "snippet": "static struct btrfsic_block_link *btrfsic_block_link_lookup_or_add(\n\t\tstruct btrfsic_state *state,\n\t\tstruct btrfsic_block_data_ctx *next_block_ctx,\n\t\tstruct btrfsic_block *next_block,\n\t\tstruct btrfsic_block *from_block,\n\t\tu64 parent_generation)\n{\n\tstruct btrfsic_block_link *l;\n\n\tl = btrfsic_block_link_hashtable_lookup(next_block_ctx->dev->bdev,\n\t\t\t\t\t\tnext_block_ctx->dev_bytenr,\n\t\t\t\t\t\tfrom_block->dev_state->bdev,\n\t\t\t\t\t\tfrom_block->dev_bytenr,\n\t\t\t\t\t\t&state->block_link_hashtable);\n\tif (NULL == l) {\n\t\tl = btrfsic_block_link_alloc();\n\t\tif (NULL == l) {\n\t\t\tprintk(KERN_INFO\n\t\t\t       \"btrfsic: error, kmalloc\" \" failed!\\n\");\n\t\t\treturn NULL;\n\t\t}\n\n\t\tl->block_ref_to = next_block;\n\t\tl->block_ref_from = from_block;\n\t\tl->ref_cnt = 1;\n\t\tl->parent_generation = parent_generation;\n\n\t\tif (state->print_mask & BTRFSIC_PRINT_MASK_VERBOSE)\n\t\t\tbtrfsic_print_add_link(state, l);\n\n\t\tlist_add(&l->node_ref_to, &from_block->ref_to_list);\n\t\tlist_add(&l->node_ref_from, &next_block->ref_from_list);\n\n\t\tbtrfsic_block_link_hashtable_add(l,\n\t\t\t\t\t\t &state->block_link_hashtable);\n\t} else {\n\t\tl->ref_cnt++;\n\t\tl->parent_generation = parent_generation;\n\t\tif (state->print_mask & BTRFSIC_PRINT_MASK_VERBOSE)\n\t\t\tbtrfsic_print_add_link(state, l);\n\t}\n\n\treturn l;\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"extent_io.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/genhd.h>",
            "#include <linux/mutex.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define BTRFSIC_PRINT_MASK_VERBOSE\t\t\t\t0x00000040"
          ],
          "globals_used": [
            "static void btrfsic_block_link_init(struct btrfsic_block_link *n);",
            "static struct btrfsic_block_link *btrfsic_block_link_alloc(void);",
            "static void btrfsic_block_link_free(struct btrfsic_block_link *n);",
            "static void btrfsic_block_link_hashtable_remove(struct btrfsic_block_link *l);",
            "static int btrfsic_create_link_to_next_block(\n\t\tstruct btrfsic_state *state,\n\t\tstruct btrfsic_block *block,\n\t\tstruct btrfsic_block_data_ctx\n\t\t*block_ctx, u64 next_bytenr,\n\t\tint limit_nesting,\n\t\tstruct btrfsic_block_data_ctx *next_block_ctx,\n\t\tstruct btrfsic_block **next_blockp,\n\t\tint force_iodone_flag,\n\t\tint *num_copiesp, int *mirror_nump,\n\t\tstruct btrfs_disk_key *disk_key,\n\t\tu64 parent_generation);",
            "static void btrfsic_dump_database(struct btrfsic_state *state);",
            "static void btrfsic_print_add_link(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block_link *l);",
            "static void btrfsic_print_rem_link(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block_link *l);",
            "static void btrfsic_dump_tree(const struct btrfsic_state *state);",
            "static struct btrfsic_block_link *btrfsic_block_link_lookup_or_add(\n\t\tstruct btrfsic_state *state,\n\t\tstruct btrfsic_block_data_ctx *next_block_ctx,\n\t\tstruct btrfsic_block *next_block,\n\t\tstruct btrfsic_block *from_block,\n\t\tu64 parent_generation);",
            "static struct btrfsic_dev_state *btrfsic_dev_state_lookup(\n\t\tstruct block_device *bdev);",
            "static void btrfsic_cmp_log_and_dev_bytenr(struct btrfsic_state *state,\n\t\t\t\t\t   u64 bytenr,\n\t\t\t\t\t   struct btrfsic_dev_state *dev_state,\n\t\t\t\t\t   u64 dev_bytenr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"extent_io.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n#include <linux/blkdev.h>\n#include <linux/genhd.h>\n#include <linux/mutex.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\n#define BTRFSIC_PRINT_MASK_VERBOSE\t\t\t\t0x00000040\n\nstatic void btrfsic_block_link_init(struct btrfsic_block_link *n);\nstatic struct btrfsic_block_link *btrfsic_block_link_alloc(void);\nstatic void btrfsic_block_link_free(struct btrfsic_block_link *n);\nstatic void btrfsic_block_link_hashtable_remove(struct btrfsic_block_link *l);\nstatic int btrfsic_create_link_to_next_block(\n\t\tstruct btrfsic_state *state,\n\t\tstruct btrfsic_block *block,\n\t\tstruct btrfsic_block_data_ctx\n\t\t*block_ctx, u64 next_bytenr,\n\t\tint limit_nesting,\n\t\tstruct btrfsic_block_data_ctx *next_block_ctx,\n\t\tstruct btrfsic_block **next_blockp,\n\t\tint force_iodone_flag,\n\t\tint *num_copiesp, int *mirror_nump,\n\t\tstruct btrfs_disk_key *disk_key,\n\t\tu64 parent_generation);\nstatic void btrfsic_dump_database(struct btrfsic_state *state);\nstatic void btrfsic_print_add_link(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block_link *l);\nstatic void btrfsic_print_rem_link(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block_link *l);\nstatic void btrfsic_dump_tree(const struct btrfsic_state *state);\nstatic struct btrfsic_block_link *btrfsic_block_link_lookup_or_add(\n\t\tstruct btrfsic_state *state,\n\t\tstruct btrfsic_block_data_ctx *next_block_ctx,\n\t\tstruct btrfsic_block *next_block,\n\t\tstruct btrfsic_block *from_block,\n\t\tu64 parent_generation);\nstatic struct btrfsic_dev_state *btrfsic_dev_state_lookup(\n\t\tstruct block_device *bdev);\nstatic void btrfsic_cmp_log_and_dev_bytenr(struct btrfsic_state *state,\n\t\t\t\t\t   u64 bytenr,\n\t\t\t\t\t   struct btrfsic_dev_state *dev_state,\n\t\t\t\t\t   u64 dev_bytenr);\n\nstatic struct btrfsic_block_link *btrfsic_block_link_lookup_or_add(\n\t\tstruct btrfsic_state *state,\n\t\tstruct btrfsic_block_data_ctx *next_block_ctx,\n\t\tstruct btrfsic_block *next_block,\n\t\tstruct btrfsic_block *from_block,\n\t\tu64 parent_generation)\n{\n\tstruct btrfsic_block_link *l;\n\n\tl = btrfsic_block_link_hashtable_lookup(next_block_ctx->dev->bdev,\n\t\t\t\t\t\tnext_block_ctx->dev_bytenr,\n\t\t\t\t\t\tfrom_block->dev_state->bdev,\n\t\t\t\t\t\tfrom_block->dev_bytenr,\n\t\t\t\t\t\t&state->block_link_hashtable);\n\tif (NULL == l) {\n\t\tl = btrfsic_block_link_alloc();\n\t\tif (NULL == l) {\n\t\t\tprintk(KERN_INFO\n\t\t\t       \"btrfsic: error, kmalloc\" \" failed!\\n\");\n\t\t\treturn NULL;\n\t\t}\n\n\t\tl->block_ref_to = next_block;\n\t\tl->block_ref_from = from_block;\n\t\tl->ref_cnt = 1;\n\t\tl->parent_generation = parent_generation;\n\n\t\tif (state->print_mask & BTRFSIC_PRINT_MASK_VERBOSE)\n\t\t\tbtrfsic_print_add_link(state, l);\n\n\t\tlist_add(&l->node_ref_to, &from_block->ref_to_list);\n\t\tlist_add(&l->node_ref_from, &next_block->ref_from_list);\n\n\t\tbtrfsic_block_link_hashtable_add(l,\n\t\t\t\t\t\t &state->block_link_hashtable);\n\t} else {\n\t\tl->ref_cnt++;\n\t\tl->parent_generation = parent_generation;\n\t\tif (state->print_mask & BTRFSIC_PRINT_MASK_VERBOSE)\n\t\t\tbtrfsic_print_add_link(state, l);\n\t}\n\n\treturn l;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_INFO\n\t\t\t\t       \"btrfsic: error, kmalloc failed!\\n\""
          ],
          "line": 2407
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfsic_block_lookup_or_add",
          "args": [
            "state",
            "&tmp_next_block_ctx",
            "additional_string",
            "1",
            "0",
            "1",
            "mirror_num",
            "&was_created"
          ],
          "line": 2399
        },
        "resolved": true,
        "details": {
          "function_name": "btrfsic_block_lookup_or_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/check-integrity.c",
          "lines": "2780-2834",
          "snippet": "static struct btrfsic_block *btrfsic_block_lookup_or_add(\n\t\tstruct btrfsic_state *state,\n\t\tstruct btrfsic_block_data_ctx *block_ctx,\n\t\tconst char *additional_string,\n\t\tint is_metadata,\n\t\tint is_iodone,\n\t\tint never_written,\n\t\tint mirror_num,\n\t\tint *was_created)\n{\n\tstruct btrfsic_block *block;\n\n\tblock = btrfsic_block_hashtable_lookup(block_ctx->dev->bdev,\n\t\t\t\t\t       block_ctx->dev_bytenr,\n\t\t\t\t\t       &state->block_hashtable);\n\tif (NULL == block) {\n\t\tstruct btrfsic_dev_state *dev_state;\n\n\t\tblock = btrfsic_block_alloc();\n\t\tif (NULL == block) {\n\t\t\tprintk(KERN_INFO \"btrfsic: error, kmalloc failed!\\n\");\n\t\t\treturn NULL;\n\t\t}\n\t\tdev_state = btrfsic_dev_state_lookup(block_ctx->dev->bdev);\n\t\tif (NULL == dev_state) {\n\t\t\tprintk(KERN_INFO\n\t\t\t       \"btrfsic: error, lookup dev_state failed!\\n\");\n\t\t\tbtrfsic_block_free(block);\n\t\t\treturn NULL;\n\t\t}\n\t\tblock->dev_state = dev_state;\n\t\tblock->dev_bytenr = block_ctx->dev_bytenr;\n\t\tblock->logical_bytenr = block_ctx->start;\n\t\tblock->is_metadata = is_metadata;\n\t\tblock->is_iodone = is_iodone;\n\t\tblock->never_written = never_written;\n\t\tblock->mirror_num = mirror_num;\n\t\tif (state->print_mask & BTRFSIC_PRINT_MASK_VERBOSE)\n\t\t\tprintk(KERN_INFO\n\t\t\t       \"New %s%c-block @%llu (%s/%llu/%d)\\n\",\n\t\t\t       additional_string,\n\t\t\t       btrfsic_get_block_type(state, block),\n\t\t\t       block->logical_bytenr, dev_state->name,\n\t\t\t       block->dev_bytenr, mirror_num);\n\t\tlist_add(&block->all_blocks_node, &state->all_blocks_list);\n\t\tbtrfsic_block_hashtable_add(block, &state->block_hashtable);\n\t\tif (NULL != was_created)\n\t\t\t*was_created = 1;\n\t} else {\n\t\tif (NULL != was_created)\n\t\t\t*was_created = 0;\n\t}\n\n\treturn block;\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"extent_io.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/genhd.h>",
            "#include <linux/mutex.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define BTRFSIC_PRINT_MASK_VERBOSE\t\t\t\t0x00000040"
          ],
          "globals_used": [
            "static struct btrfsic_block *btrfsic_block_alloc(void);",
            "static void btrfsic_block_link_init(struct btrfsic_block_link *n);",
            "static void btrfsic_block_link_free(struct btrfsic_block_link *n);",
            "static int btrfsic_map_block(struct btrfsic_state *state, u64 bytenr, u32 len,\n\t\t\t     struct btrfsic_block_data_ctx *block_ctx_out,\n\t\t\t     int mirror_num);",
            "static void btrfsic_release_block_ctx(struct btrfsic_block_data_ctx *block_ctx);",
            "static int btrfsic_read_block(struct btrfsic_state *state,\n\t\t\t      struct btrfsic_block_data_ctx *block_ctx);",
            "static void btrfsic_dump_database(struct btrfsic_state *state);",
            "static char btrfsic_get_block_type(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block *block);",
            "static void btrfsic_dump_tree(const struct btrfsic_state *state);",
            "static struct btrfsic_block *btrfsic_block_lookup_or_add(\n\t\tstruct btrfsic_state *state,\n\t\tstruct btrfsic_block_data_ctx *block_ctx,\n\t\tconst char *additional_string,\n\t\tint is_metadata,\n\t\tint is_iodone,\n\t\tint never_written,\n\t\tint mirror_num,\n\t\tint *was_created);",
            "static struct btrfsic_dev_state *btrfsic_dev_state_lookup(\n\t\tstruct block_device *bdev);",
            "static void btrfsic_cmp_log_and_dev_bytenr(struct btrfsic_state *state,\n\t\t\t\t\t   u64 bytenr,\n\t\t\t\t\t   struct btrfsic_dev_state *dev_state,\n\t\t\t\t\t   u64 dev_bytenr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"extent_io.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n#include <linux/blkdev.h>\n#include <linux/genhd.h>\n#include <linux/mutex.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\n#define BTRFSIC_PRINT_MASK_VERBOSE\t\t\t\t0x00000040\n\nstatic struct btrfsic_block *btrfsic_block_alloc(void);\nstatic void btrfsic_block_link_init(struct btrfsic_block_link *n);\nstatic void btrfsic_block_link_free(struct btrfsic_block_link *n);\nstatic int btrfsic_map_block(struct btrfsic_state *state, u64 bytenr, u32 len,\n\t\t\t     struct btrfsic_block_data_ctx *block_ctx_out,\n\t\t\t     int mirror_num);\nstatic void btrfsic_release_block_ctx(struct btrfsic_block_data_ctx *block_ctx);\nstatic int btrfsic_read_block(struct btrfsic_state *state,\n\t\t\t      struct btrfsic_block_data_ctx *block_ctx);\nstatic void btrfsic_dump_database(struct btrfsic_state *state);\nstatic char btrfsic_get_block_type(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block *block);\nstatic void btrfsic_dump_tree(const struct btrfsic_state *state);\nstatic struct btrfsic_block *btrfsic_block_lookup_or_add(\n\t\tstruct btrfsic_state *state,\n\t\tstruct btrfsic_block_data_ctx *block_ctx,\n\t\tconst char *additional_string,\n\t\tint is_metadata,\n\t\tint is_iodone,\n\t\tint never_written,\n\t\tint mirror_num,\n\t\tint *was_created);\nstatic struct btrfsic_dev_state *btrfsic_dev_state_lookup(\n\t\tstruct block_device *bdev);\nstatic void btrfsic_cmp_log_and_dev_bytenr(struct btrfsic_state *state,\n\t\t\t\t\t   u64 bytenr,\n\t\t\t\t\t   struct btrfsic_dev_state *dev_state,\n\t\t\t\t\t   u64 dev_bytenr);\n\nstatic struct btrfsic_block *btrfsic_block_lookup_or_add(\n\t\tstruct btrfsic_state *state,\n\t\tstruct btrfsic_block_data_ctx *block_ctx,\n\t\tconst char *additional_string,\n\t\tint is_metadata,\n\t\tint is_iodone,\n\t\tint never_written,\n\t\tint mirror_num,\n\t\tint *was_created)\n{\n\tstruct btrfsic_block *block;\n\n\tblock = btrfsic_block_hashtable_lookup(block_ctx->dev->bdev,\n\t\t\t\t\t       block_ctx->dev_bytenr,\n\t\t\t\t\t       &state->block_hashtable);\n\tif (NULL == block) {\n\t\tstruct btrfsic_dev_state *dev_state;\n\n\t\tblock = btrfsic_block_alloc();\n\t\tif (NULL == block) {\n\t\t\tprintk(KERN_INFO \"btrfsic: error, kmalloc failed!\\n\");\n\t\t\treturn NULL;\n\t\t}\n\t\tdev_state = btrfsic_dev_state_lookup(block_ctx->dev->bdev);\n\t\tif (NULL == dev_state) {\n\t\t\tprintk(KERN_INFO\n\t\t\t       \"btrfsic: error, lookup dev_state failed!\\n\");\n\t\t\tbtrfsic_block_free(block);\n\t\t\treturn NULL;\n\t\t}\n\t\tblock->dev_state = dev_state;\n\t\tblock->dev_bytenr = block_ctx->dev_bytenr;\n\t\tblock->logical_bytenr = block_ctx->start;\n\t\tblock->is_metadata = is_metadata;\n\t\tblock->is_iodone = is_iodone;\n\t\tblock->never_written = never_written;\n\t\tblock->mirror_num = mirror_num;\n\t\tif (state->print_mask & BTRFSIC_PRINT_MASK_VERBOSE)\n\t\t\tprintk(KERN_INFO\n\t\t\t       \"New %s%c-block @%llu (%s/%llu/%d)\\n\",\n\t\t\t       additional_string,\n\t\t\t       btrfsic_get_block_type(state, block),\n\t\t\t       block->logical_bytenr, dev_state->name,\n\t\t\t       block->dev_bytenr, mirror_num);\n\t\tlist_add(&block->all_blocks_node, &state->all_blocks_list);\n\t\tbtrfsic_block_hashtable_add(block, &state->block_hashtable);\n\t\tif (NULL != was_created)\n\t\t\t*was_created = 1;\n\t} else {\n\t\tif (NULL != was_created)\n\t\t\t*was_created = 0;\n\t}\n\n\treturn block;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_INFO\n\t\t\t\t       \"btrfsic: btrfsic_map_block(@%llu,\"\n\t\t\t\t       \" mirror=%d) failed!\\n\"",
            "next_bytenr",
            "mirror_num"
          ],
          "line": 2392
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/super.c",
          "lines": "186-213",
          "snippet": "void btrfs_printk(const struct btrfs_fs_info *fs_info, const char *fmt, ...)\n{\n\tstruct super_block *sb = fs_info->sb;\n\tchar lvl[4];\n\tstruct va_format vaf;\n\tva_list args;\n\tconst char *type = logtypes[4];\n\tint kern_level;\n\n\tva_start(args, fmt);\n\n\tkern_level = printk_get_level(fmt);\n\tif (kern_level) {\n\t\tsize_t size = printk_skip_level(fmt) - fmt;\n\t\tmemcpy(lvl, fmt,  size);\n\t\tlvl[size] = '\\0';\n\t\tfmt += size;\n\t\ttype = logtypes[kern_level - '0'];\n\t} else\n\t\t*lvl = '\\0';\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sBTRFS %s (device %s): %pV\\n\", lvl, type, sb->s_id, &vaf);\n\n\tva_end(args);\n}",
          "includes": [
            "#include <trace/events/btrfs.h>",
            "#include \"qgroup.h\"",
            "#include \"tests/btrfs-tests.h\"",
            "#include \"backref.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"compression.h\"",
            "#include \"export.h\"",
            "#include \"volumes.h\"",
            "#include \"xattr.h\"",
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/slab.h>",
            "#include <linux/magic.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/namei.h>",
            "#include <linux/ctype.h>",
            "#include <linux/parser.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/btrfs.h>\n#include \"qgroup.h\"\n#include \"tests/btrfs-tests.h\"\n#include \"backref.h\"\n#include \"free-space-cache.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"compression.h\"\n#include \"export.h\"\n#include \"volumes.h\"\n#include \"xattr.h\"\n#include \"props.h\"\n#include \"hash.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include \"delayed-inode.h\"\n#include <linux/btrfs.h>\n#include <linux/ratelimit.h>\n#include <linux/cleancache.h>\n#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/miscdevice.h>\n#include <linux/namei.h>\n#include <linux/ctype.h>\n#include <linux/parser.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n\nvoid btrfs_printk(const struct btrfs_fs_info *fs_info, const char *fmt, ...)\n{\n\tstruct super_block *sb = fs_info->sb;\n\tchar lvl[4];\n\tstruct va_format vaf;\n\tva_list args;\n\tconst char *type = logtypes[4];\n\tint kern_level;\n\n\tva_start(args, fmt);\n\n\tkern_level = printk_get_level(fmt);\n\tif (kern_level) {\n\t\tsize_t size = printk_skip_level(fmt) - fmt;\n\t\tmemcpy(lvl, fmt,  size);\n\t\tlvl[size] = '\\0';\n\t\tfmt += size;\n\t\ttype = logtypes[kern_level - '0'];\n\t} else\n\t\t*lvl = '\\0';\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sBTRFS %s (device %s): %pV\\n\", lvl, type, sb->s_id, &vaf);\n\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfsic_map_block",
          "args": [
            "state",
            "next_bytenr",
            "BTRFS_SUPER_INFO_SIZE",
            "&tmp_next_block_ctx",
            "mirror_num"
          ],
          "line": 2387
        },
        "resolved": true,
        "details": {
          "function_name": "btrfsic_map_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/check-integrity.c",
          "lines": "1568-1609",
          "snippet": "static int btrfsic_map_block(struct btrfsic_state *state, u64 bytenr, u32 len,\n\t\t\t     struct btrfsic_block_data_ctx *block_ctx_out,\n\t\t\t     int mirror_num)\n{\n\tint ret;\n\tu64 length;\n\tstruct btrfs_bio *multi = NULL;\n\tstruct btrfs_device *device;\n\n\tlength = len;\n\tret = btrfs_map_block(state->root->fs_info, READ,\n\t\t\t      bytenr, &length, &multi, mirror_num);\n\n\tif (ret) {\n\t\tblock_ctx_out->start = 0;\n\t\tblock_ctx_out->dev_bytenr = 0;\n\t\tblock_ctx_out->len = 0;\n\t\tblock_ctx_out->dev = NULL;\n\t\tblock_ctx_out->datav = NULL;\n\t\tblock_ctx_out->pagev = NULL;\n\t\tblock_ctx_out->mem_to_free = NULL;\n\n\t\treturn ret;\n\t}\n\n\tdevice = multi->stripes[0].dev;\n\tblock_ctx_out->dev = btrfsic_dev_state_lookup(device->bdev);\n\tblock_ctx_out->dev_bytenr = multi->stripes[0].physical;\n\tblock_ctx_out->start = bytenr;\n\tblock_ctx_out->len = len;\n\tblock_ctx_out->datav = NULL;\n\tblock_ctx_out->pagev = NULL;\n\tblock_ctx_out->mem_to_free = NULL;\n\n\tkfree(multi);\n\tif (NULL == block_ctx_out->dev) {\n\t\tret = -ENXIO;\n\t\tprintk(KERN_INFO \"btrfsic: error, cannot lookup dev (#1)!\\n\");\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"extent_io.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/genhd.h>",
            "#include <linux/mutex.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void btrfsic_block_link_init(struct btrfsic_block_link *n);",
            "static void btrfsic_block_link_free(struct btrfsic_block_link *n);",
            "static void btrfsic_read_from_block_data(\n\tstruct btrfsic_block_data_ctx *block_ctx,\n\tvoid *dst, u32 offset, size_t len);",
            "static int btrfsic_map_block(struct btrfsic_state *state, u64 bytenr, u32 len,\n\t\t\t     struct btrfsic_block_data_ctx *block_ctx_out,\n\t\t\t     int mirror_num);",
            "static void btrfsic_dump_database(struct btrfsic_state *state);",
            "static void btrfsic_dump_tree(const struct btrfsic_state *state);",
            "static struct btrfsic_dev_state *btrfsic_dev_state_lookup(\n\t\tstruct block_device *bdev);",
            "static void btrfsic_cmp_log_and_dev_bytenr(struct btrfsic_state *state,\n\t\t\t\t\t   u64 bytenr,\n\t\t\t\t\t   struct btrfsic_dev_state *dev_state,\n\t\t\t\t\t   u64 dev_bytenr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"extent_io.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n#include <linux/blkdev.h>\n#include <linux/genhd.h>\n#include <linux/mutex.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic void btrfsic_block_link_init(struct btrfsic_block_link *n);\nstatic void btrfsic_block_link_free(struct btrfsic_block_link *n);\nstatic void btrfsic_read_from_block_data(\n\tstruct btrfsic_block_data_ctx *block_ctx,\n\tvoid *dst, u32 offset, size_t len);\nstatic int btrfsic_map_block(struct btrfsic_state *state, u64 bytenr, u32 len,\n\t\t\t     struct btrfsic_block_data_ctx *block_ctx_out,\n\t\t\t     int mirror_num);\nstatic void btrfsic_dump_database(struct btrfsic_state *state);\nstatic void btrfsic_dump_tree(const struct btrfsic_state *state);\nstatic struct btrfsic_dev_state *btrfsic_dev_state_lookup(\n\t\tstruct block_device *bdev);\nstatic void btrfsic_cmp_log_and_dev_bytenr(struct btrfsic_state *state,\n\t\t\t\t\t   u64 bytenr,\n\t\t\t\t\t   struct btrfsic_dev_state *dev_state,\n\t\t\t\t\t   u64 dev_bytenr);\n\nstatic int btrfsic_map_block(struct btrfsic_state *state, u64 bytenr, u32 len,\n\t\t\t     struct btrfsic_block_data_ctx *block_ctx_out,\n\t\t\t     int mirror_num)\n{\n\tint ret;\n\tu64 length;\n\tstruct btrfs_bio *multi = NULL;\n\tstruct btrfs_device *device;\n\n\tlength = len;\n\tret = btrfs_map_block(state->root->fs_info, READ,\n\t\t\t      bytenr, &length, &multi, mirror_num);\n\n\tif (ret) {\n\t\tblock_ctx_out->start = 0;\n\t\tblock_ctx_out->dev_bytenr = 0;\n\t\tblock_ctx_out->len = 0;\n\t\tblock_ctx_out->dev = NULL;\n\t\tblock_ctx_out->datav = NULL;\n\t\tblock_ctx_out->pagev = NULL;\n\t\tblock_ctx_out->mem_to_free = NULL;\n\n\t\treturn ret;\n\t}\n\n\tdevice = multi->stripes[0].dev;\n\tblock_ctx_out->dev = btrfsic_dev_state_lookup(device->bdev);\n\tblock_ctx_out->dev_bytenr = multi->stripes[0].physical;\n\tblock_ctx_out->start = bytenr;\n\tblock_ctx_out->len = len;\n\tblock_ctx_out->datav = NULL;\n\tblock_ctx_out->pagev = NULL;\n\tblock_ctx_out->mem_to_free = NULL;\n\n\tkfree(multi);\n\tif (NULL == block_ctx_out->dev) {\n\t\tret = -ENXIO;\n\t\tprintk(KERN_INFO \"btrfsic: error, cannot lookup dev (#1)!\\n\");\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_num_copies",
          "args": [
            "state->root->fs_info",
            "next_bytenr",
            "BTRFS_SUPER_INFO_SIZE"
          ],
          "line": 2375
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_num_copies",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
          "lines": "4740-4790",
          "snippet": "int btrfs_num_copies(struct btrfs_fs_info *fs_info, u64 logical, u64 len)\n{\n\tstruct btrfs_mapping_tree *map_tree = &fs_info->mapping_tree;\n\tstruct extent_map *em;\n\tstruct map_lookup *map;\n\tstruct extent_map_tree *em_tree = &map_tree->map_tree;\n\tint ret;\n\n\tread_lock(&em_tree->lock);\n\tem = lookup_extent_mapping(em_tree, logical, len);\n\tread_unlock(&em_tree->lock);\n\n\t/*\n\t * We could return errors for these cases, but that could get ugly and\n\t * we'd probably do the same thing which is just not do anything else\n\t * and exit, so return 1 so the callers don't try to use other copies.\n\t */\n\tif (!em) {\n\t\tbtrfs_crit(fs_info, \"No mapping for %Lu-%Lu\", logical,\n\t\t\t    logical+len);\n\t\treturn 1;\n\t}\n\n\tif (em->start > logical || em->start + em->len < logical) {\n\t\tbtrfs_crit(fs_info, \"Invalid mapping for %Lu-%Lu, got \"\n\t\t\t    \"%Lu-%Lu\", logical, logical+len, em->start,\n\t\t\t    em->start + em->len);\n\t\tfree_extent_map(em);\n\t\treturn 1;\n\t}\n\n\tmap = (struct map_lookup *)em->bdev;\n\tif (map->type & (BTRFS_BLOCK_GROUP_DUP | BTRFS_BLOCK_GROUP_RAID1))\n\t\tret = map->num_stripes;\n\telse if (map->type & BTRFS_BLOCK_GROUP_RAID10)\n\t\tret = map->sub_stripes;\n\telse if (map->type & BTRFS_BLOCK_GROUP_RAID5)\n\t\tret = 2;\n\telse if (map->type & BTRFS_BLOCK_GROUP_RAID6)\n\t\tret = 3;\n\telse\n\t\tret = 1;\n\tfree_extent_map(em);\n\n\tbtrfs_dev_replace_lock(&fs_info->dev_replace);\n\tif (btrfs_dev_replace_is_ongoing(&fs_info->dev_replace))\n\t\tret++;\n\tbtrfs_dev_replace_unlock(&fs_info->dev_replace);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\nstatic noinline struct;\n\nint btrfs_num_copies(struct btrfs_fs_info *fs_info, u64 logical, u64 len)\n{\n\tstruct btrfs_mapping_tree *map_tree = &fs_info->mapping_tree;\n\tstruct extent_map *em;\n\tstruct map_lookup *map;\n\tstruct extent_map_tree *em_tree = &map_tree->map_tree;\n\tint ret;\n\n\tread_lock(&em_tree->lock);\n\tem = lookup_extent_mapping(em_tree, logical, len);\n\tread_unlock(&em_tree->lock);\n\n\t/*\n\t * We could return errors for these cases, but that could get ugly and\n\t * we'd probably do the same thing which is just not do anything else\n\t * and exit, so return 1 so the callers don't try to use other copies.\n\t */\n\tif (!em) {\n\t\tbtrfs_crit(fs_info, \"No mapping for %Lu-%Lu\", logical,\n\t\t\t    logical+len);\n\t\treturn 1;\n\t}\n\n\tif (em->start > logical || em->start + em->len < logical) {\n\t\tbtrfs_crit(fs_info, \"Invalid mapping for %Lu-%Lu, got \"\n\t\t\t    \"%Lu-%Lu\", logical, logical+len, em->start,\n\t\t\t    em->start + em->len);\n\t\tfree_extent_map(em);\n\t\treturn 1;\n\t}\n\n\tmap = (struct map_lookup *)em->bdev;\n\tif (map->type & (BTRFS_BLOCK_GROUP_DUP | BTRFS_BLOCK_GROUP_RAID1))\n\t\tret = map->num_stripes;\n\telse if (map->type & BTRFS_BLOCK_GROUP_RAID10)\n\t\tret = map->sub_stripes;\n\telse if (map->type & BTRFS_BLOCK_GROUP_RAID5)\n\t\tret = 2;\n\telse if (map->type & BTRFS_BLOCK_GROUP_RAID6)\n\t\tret = 3;\n\telse\n\t\tret = 1;\n\tfree_extent_map(em);\n\n\tbtrfs_dev_replace_lock(&fs_info->dev_replace);\n\tif (btrfs_dev_replace_is_ongoing(&fs_info->dev_replace))\n\t\tret++;\n\tbtrfs_dev_replace_unlock(&fs_info->dev_replace);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_super_log_root",
          "args": [
            "super_hdr"
          ],
          "line": 2365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_disk_key_objectid",
          "args": [
            "&tmp_disk_key",
            "BTRFS_TREE_LOG_OBJECTID"
          ],
          "line": 2362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_super_chunk_root",
          "args": [
            "super_hdr"
          ],
          "line": 2356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_disk_key_objectid",
          "args": [
            "&tmp_disk_key",
            "BTRFS_CHUNK_TREE_OBJECTID"
          ],
          "line": 2353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_super_root",
          "args": [
            "super_hdr"
          ],
          "line": 2347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_disk_key_objectid",
          "args": [
            "&tmp_disk_key",
            "BTRFS_ROOT_TREE_OBJECTID"
          ],
          "line": 2344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_disk_key_objectid",
          "args": [
            "&tmp_disk_key",
            "0"
          ],
          "line": 2340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_disk_key_objectid",
          "args": [
            "&tmp_disk_key",
            "BTRFS_ROOT_ITEM_KEY"
          ],
          "line": 2338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_super_generation",
          "args": [
            "super_hdr"
          ],
          "line": 2323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_super_generation",
          "args": [
            "super_hdr"
          ],
          "line": 2319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_super_generation",
          "args": [
            "super_hdr"
          ],
          "line": 2309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_super_generation",
          "args": [
            "super_hdr"
          ],
          "line": 2299
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"extent_io.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n#include <linux/blkdev.h>\n#include <linux/genhd.h>\n#include <linux/mutex.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\n#define BTRFSIC_PRINT_MASK_NUM_COPIES\t\t\t\t0x00000800\n#define BTRFSIC_PRINT_MASK_VERBOSE\t\t\t\t0x00000040\n#define BTRFSIC_PRINT_MASK_ROOT_CHUNK_LOG_TREE_LOCATION\t\t0x00000002\n#define BTRFSIC_PRINT_MASK_SUPERBLOCK_WRITE\t\t\t0x00000001\n#define BTRFSIC_GENERATION_UNKNOWN ((u64)-1)\n\nstatic void btrfsic_block_link_init(struct btrfsic_block_link *n);\nstatic void btrfsic_block_link_free(struct btrfsic_block_link *n);\nstatic void btrfsic_block_link_hashtable_remove(struct btrfsic_block_link *l);\nstatic int btrfsic_map_block(struct btrfsic_state *state, u64 bytenr, u32 len,\n\t\t\t     struct btrfsic_block_data_ctx *block_ctx_out,\n\t\t\t     int mirror_num);\nstatic void btrfsic_dump_database(struct btrfsic_state *state);\nstatic int btrfsic_process_written_superblock(\n\t\tstruct btrfsic_state *state,\n\t\tstruct btrfsic_block *const block,\n\t\tstruct btrfs_super_block *const super_hdr);\nstatic void btrfsic_print_add_link(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block_link *l);\nstatic void btrfsic_print_rem_link(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block_link *l);\nstatic void btrfsic_dump_tree(const struct btrfsic_state *state);\nstatic struct btrfsic_block *btrfsic_block_lookup_or_add(\n\t\tstruct btrfsic_state *state,\n\t\tstruct btrfsic_block_data_ctx *block_ctx,\n\t\tconst char *additional_string,\n\t\tint is_metadata,\n\t\tint is_iodone,\n\t\tint never_written,\n\t\tint mirror_num,\n\t\tint *was_created);\nstatic void btrfsic_cmp_log_and_dev_bytenr(struct btrfsic_state *state,\n\t\t\t\t\t   u64 bytenr,\n\t\t\t\t\t   struct btrfsic_dev_state *dev_state,\n\t\t\t\t\t   u64 dev_bytenr);\n\nstatic int btrfsic_process_written_superblock(\n\t\tstruct btrfsic_state *state,\n\t\tstruct btrfsic_block *const superblock,\n\t\tstruct btrfs_super_block *const super_hdr)\n{\n\tint pass;\n\n\tsuperblock->generation = btrfs_super_generation(super_hdr);\n\tif (!(superblock->generation > state->max_superblock_generation ||\n\t      0 == state->max_superblock_generation)) {\n\t\tif (state->print_mask & BTRFSIC_PRINT_MASK_SUPERBLOCK_WRITE)\n\t\t\tprintk(KERN_INFO\n\t\t\t       \"btrfsic: superblock @%llu (%s/%llu/%d)\"\n\t\t\t       \" with old gen %llu <= %llu\\n\",\n\t\t\t       superblock->logical_bytenr,\n\t\t\t       superblock->dev_state->name,\n\t\t\t       superblock->dev_bytenr, superblock->mirror_num,\n\t\t\t       btrfs_super_generation(super_hdr),\n\t\t\t       state->max_superblock_generation);\n\t} else {\n\t\tif (state->print_mask & BTRFSIC_PRINT_MASK_SUPERBLOCK_WRITE)\n\t\t\tprintk(KERN_INFO\n\t\t\t       \"btrfsic: got new superblock @%llu (%s/%llu/%d)\"\n\t\t\t       \" with new gen %llu > %llu\\n\",\n\t\t\t       superblock->logical_bytenr,\n\t\t\t       superblock->dev_state->name,\n\t\t\t       superblock->dev_bytenr, superblock->mirror_num,\n\t\t\t       btrfs_super_generation(super_hdr),\n\t\t\t       state->max_superblock_generation);\n\n\t\tstate->max_superblock_generation =\n\t\t    btrfs_super_generation(super_hdr);\n\t\tstate->latest_superblock = superblock;\n\t}\n\n\tfor (pass = 0; pass < 3; pass++) {\n\t\tint ret;\n\t\tu64 next_bytenr;\n\t\tstruct btrfsic_block *next_block;\n\t\tstruct btrfsic_block_data_ctx tmp_next_block_ctx;\n\t\tstruct btrfsic_block_link *l;\n\t\tint num_copies;\n\t\tint mirror_num;\n\t\tconst char *additional_string = NULL;\n\t\tstruct btrfs_disk_key tmp_disk_key = {0};\n\n\t\tbtrfs_set_disk_key_objectid(&tmp_disk_key,\n\t\t\t\t\t    BTRFS_ROOT_ITEM_KEY);\n\t\tbtrfs_set_disk_key_objectid(&tmp_disk_key, 0);\n\n\t\tswitch (pass) {\n\t\tcase 0:\n\t\t\tbtrfs_set_disk_key_objectid(&tmp_disk_key,\n\t\t\t\t\t\t    BTRFS_ROOT_TREE_OBJECTID);\n\t\t\tadditional_string = \"root \";\n\t\t\tnext_bytenr = btrfs_super_root(super_hdr);\n\t\t\tif (state->print_mask &\n\t\t\t    BTRFSIC_PRINT_MASK_ROOT_CHUNK_LOG_TREE_LOCATION)\n\t\t\t\tprintk(KERN_INFO \"root@%llu\\n\", next_bytenr);\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tbtrfs_set_disk_key_objectid(&tmp_disk_key,\n\t\t\t\t\t\t    BTRFS_CHUNK_TREE_OBJECTID);\n\t\t\tadditional_string = \"chunk \";\n\t\t\tnext_bytenr = btrfs_super_chunk_root(super_hdr);\n\t\t\tif (state->print_mask &\n\t\t\t    BTRFSIC_PRINT_MASK_ROOT_CHUNK_LOG_TREE_LOCATION)\n\t\t\t\tprintk(KERN_INFO \"chunk@%llu\\n\", next_bytenr);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tbtrfs_set_disk_key_objectid(&tmp_disk_key,\n\t\t\t\t\t\t    BTRFS_TREE_LOG_OBJECTID);\n\t\t\tadditional_string = \"log \";\n\t\t\tnext_bytenr = btrfs_super_log_root(super_hdr);\n\t\t\tif (0 == next_bytenr)\n\t\t\t\tcontinue;\n\t\t\tif (state->print_mask &\n\t\t\t    BTRFSIC_PRINT_MASK_ROOT_CHUNK_LOG_TREE_LOCATION)\n\t\t\t\tprintk(KERN_INFO \"log@%llu\\n\", next_bytenr);\n\t\t\tbreak;\n\t\t}\n\n\t\tnum_copies =\n\t\t    btrfs_num_copies(state->root->fs_info,\n\t\t\t\t     next_bytenr, BTRFS_SUPER_INFO_SIZE);\n\t\tif (state->print_mask & BTRFSIC_PRINT_MASK_NUM_COPIES)\n\t\t\tprintk(KERN_INFO \"num_copies(log_bytenr=%llu) = %d\\n\",\n\t\t\t       next_bytenr, num_copies);\n\t\tfor (mirror_num = 1; mirror_num <= num_copies; mirror_num++) {\n\t\t\tint was_created;\n\n\t\t\tif (state->print_mask & BTRFSIC_PRINT_MASK_VERBOSE)\n\t\t\t\tprintk(KERN_INFO\n\t\t\t\t       \"btrfsic_process_written_superblock(\"\n\t\t\t\t       \"mirror_num=%d)\\n\", mirror_num);\n\t\t\tret = btrfsic_map_block(state, next_bytenr,\n\t\t\t\t\t\tBTRFS_SUPER_INFO_SIZE,\n\t\t\t\t\t\t&tmp_next_block_ctx,\n\t\t\t\t\t\tmirror_num);\n\t\t\tif (ret) {\n\t\t\t\tprintk(KERN_INFO\n\t\t\t\t       \"btrfsic: btrfsic_map_block(@%llu,\"\n\t\t\t\t       \" mirror=%d) failed!\\n\",\n\t\t\t\t       next_bytenr, mirror_num);\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tnext_block = btrfsic_block_lookup_or_add(\n\t\t\t\t\tstate,\n\t\t\t\t\t&tmp_next_block_ctx,\n\t\t\t\t\tadditional_string,\n\t\t\t\t\t1, 0, 1,\n\t\t\t\t\tmirror_num,\n\t\t\t\t\t&was_created);\n\t\t\tif (NULL == next_block) {\n\t\t\t\tprintk(KERN_INFO\n\t\t\t\t       \"btrfsic: error, kmalloc failed!\\n\");\n\t\t\t\tbtrfsic_release_block_ctx(&tmp_next_block_ctx);\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tnext_block->disk_key = tmp_disk_key;\n\t\t\tif (was_created)\n\t\t\t\tnext_block->generation =\n\t\t\t\t    BTRFSIC_GENERATION_UNKNOWN;\n\t\t\tl = btrfsic_block_link_lookup_or_add(\n\t\t\t\t\tstate,\n\t\t\t\t\t&tmp_next_block_ctx,\n\t\t\t\t\tnext_block,\n\t\t\t\t\tsuperblock,\n\t\t\t\t\tBTRFSIC_GENERATION_UNKNOWN);\n\t\t\tbtrfsic_release_block_ctx(&tmp_next_block_ctx);\n\t\t\tif (NULL == l)\n\t\t\t\treturn -1;\n\t\t}\n\t}\n\n\tif (WARN_ON(-1 == btrfsic_check_all_ref_blocks(state, superblock, 0)))\n\t\tbtrfsic_dump_tree(state);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "btrfsic_bh_end_io",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/check-integrity.c",
    "lines": "2258-2290",
    "snippet": "static void btrfsic_bh_end_io(struct buffer_head *bh, int uptodate)\n{\n\tstruct btrfsic_block *block = (struct btrfsic_block *)bh->b_private;\n\tint iodone_w_error = !uptodate;\n\tstruct btrfsic_dev_state *dev_state;\n\n\tBUG_ON(NULL == block);\n\tdev_state = block->dev_state;\n\tif ((dev_state->state->print_mask & BTRFSIC_PRINT_MASK_END_IO_BIO_BH))\n\t\tprintk(KERN_INFO\n\t\t       \"bh_end_io(error=%d) for %c @%llu (%s/%llu/%d)\\n\",\n\t\t       iodone_w_error,\n\t\t       btrfsic_get_block_type(dev_state->state, block),\n\t\t       block->logical_bytenr, block->dev_state->name,\n\t\t       block->dev_bytenr, block->mirror_num);\n\n\tblock->iodone_w_error = iodone_w_error;\n\tif (block->submit_bio_bh_rw & REQ_FLUSH) {\n\t\tdev_state->last_flush_gen++;\n\t\tif ((dev_state->state->print_mask &\n\t\t     BTRFSIC_PRINT_MASK_END_IO_BIO_BH))\n\t\t\tprintk(KERN_INFO\n\t\t\t       \"bh_end_io() new %s flush_gen=%llu\\n\",\n\t\t\t       dev_state->name, dev_state->last_flush_gen);\n\t}\n\tif (block->submit_bio_bh_rw & REQ_FUA)\n\t\tblock->flush_gen = 0; /* FUA completed means block is on disk */\n\n\tbh->b_private = block->orig_bio_bh_private;\n\tbh->b_end_io = block->orig_bio_bh_end_io.bh;\n\tblock->is_iodone = 1; /* for FLUSH, this releases the block */\n\tbh->b_end_io(bh, uptodate);\n}",
    "includes": [
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"volumes.h\"",
      "#include \"extent_io.h\"",
      "#include \"transaction.h\"",
      "#include \"hash.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/genhd.h>",
      "#include <linux/mutex.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [
      "#define BTRFSIC_PRINT_MASK_END_IO_BIO_BH\t\t\t0x00000020"
    ],
    "globals_used": [
      "static void btrfsic_block_link_init(struct btrfsic_block_link *n);",
      "static void btrfsic_block_link_free(struct btrfsic_block_link *n);",
      "static int btrfsic_map_block(struct btrfsic_state *state, u64 bytenr, u32 len,\n\t\t\t     struct btrfsic_block_data_ctx *block_ctx_out,\n\t\t\t     int mirror_num);",
      "static void btrfsic_dump_database(struct btrfsic_state *state);",
      "static void btrfsic_process_written_block(struct btrfsic_dev_state *dev_state,\n\t\t\t\t\t  u64 dev_bytenr, char **mapped_datav,\n\t\t\t\t\t  unsigned int num_pages,\n\t\t\t\t\t  struct bio *bio, int *bio_is_patched,\n\t\t\t\t\t  struct buffer_head *bh,\n\t\t\t\t\t  int submit_bio_bh_rw);",
      "static void btrfsic_bh_end_io(struct buffer_head *bh, int uptodate);",
      "static char btrfsic_get_block_type(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block *block);",
      "static void btrfsic_dump_tree(const struct btrfsic_state *state);",
      "static void btrfsic_cmp_log_and_dev_bytenr(struct btrfsic_state *state,\n\t\t\t\t\t   u64 bytenr,\n\t\t\t\t\t   struct btrfsic_dev_state *dev_state,\n\t\t\t\t\t   u64 dev_bytenr);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bh->b_end_io",
          "args": [
            "bh",
            "uptodate"
          ],
          "line": 2289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_INFO\n\t\t\t       \"bh_end_io() new %s flush_gen=%llu\\n\"",
            "dev_state->name",
            "dev_state->last_flush_gen"
          ],
          "line": 2279
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/super.c",
          "lines": "186-213",
          "snippet": "void btrfs_printk(const struct btrfs_fs_info *fs_info, const char *fmt, ...)\n{\n\tstruct super_block *sb = fs_info->sb;\n\tchar lvl[4];\n\tstruct va_format vaf;\n\tva_list args;\n\tconst char *type = logtypes[4];\n\tint kern_level;\n\n\tva_start(args, fmt);\n\n\tkern_level = printk_get_level(fmt);\n\tif (kern_level) {\n\t\tsize_t size = printk_skip_level(fmt) - fmt;\n\t\tmemcpy(lvl, fmt,  size);\n\t\tlvl[size] = '\\0';\n\t\tfmt += size;\n\t\ttype = logtypes[kern_level - '0'];\n\t} else\n\t\t*lvl = '\\0';\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sBTRFS %s (device %s): %pV\\n\", lvl, type, sb->s_id, &vaf);\n\n\tva_end(args);\n}",
          "includes": [
            "#include <trace/events/btrfs.h>",
            "#include \"qgroup.h\"",
            "#include \"tests/btrfs-tests.h\"",
            "#include \"backref.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"compression.h\"",
            "#include \"export.h\"",
            "#include \"volumes.h\"",
            "#include \"xattr.h\"",
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/slab.h>",
            "#include <linux/magic.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/namei.h>",
            "#include <linux/ctype.h>",
            "#include <linux/parser.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/btrfs.h>\n#include \"qgroup.h\"\n#include \"tests/btrfs-tests.h\"\n#include \"backref.h\"\n#include \"free-space-cache.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"compression.h\"\n#include \"export.h\"\n#include \"volumes.h\"\n#include \"xattr.h\"\n#include \"props.h\"\n#include \"hash.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include \"delayed-inode.h\"\n#include <linux/btrfs.h>\n#include <linux/ratelimit.h>\n#include <linux/cleancache.h>\n#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/miscdevice.h>\n#include <linux/namei.h>\n#include <linux/ctype.h>\n#include <linux/parser.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n\nvoid btrfs_printk(const struct btrfs_fs_info *fs_info, const char *fmt, ...)\n{\n\tstruct super_block *sb = fs_info->sb;\n\tchar lvl[4];\n\tstruct va_format vaf;\n\tva_list args;\n\tconst char *type = logtypes[4];\n\tint kern_level;\n\n\tva_start(args, fmt);\n\n\tkern_level = printk_get_level(fmt);\n\tif (kern_level) {\n\t\tsize_t size = printk_skip_level(fmt) - fmt;\n\t\tmemcpy(lvl, fmt,  size);\n\t\tlvl[size] = '\\0';\n\t\tfmt += size;\n\t\ttype = logtypes[kern_level - '0'];\n\t} else\n\t\t*lvl = '\\0';\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sBTRFS %s (device %s): %pV\\n\", lvl, type, sb->s_id, &vaf);\n\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfsic_get_block_type",
          "args": [
            "dev_state->state",
            "block"
          ],
          "line": 2270
        },
        "resolved": true,
        "details": {
          "function_name": "btrfsic_get_block_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/check-integrity.c",
          "lines": "2648-2661",
          "snippet": "static char btrfsic_get_block_type(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block *block)\n{\n\tif (block->is_superblock &&\n\t    state->latest_superblock->dev_bytenr == block->dev_bytenr &&\n\t    state->latest_superblock->dev_state->bdev == block->dev_state->bdev)\n\t\treturn 'S';\n\telse if (block->is_superblock)\n\t\treturn 's';\n\telse if (block->is_metadata)\n\t\treturn 'M';\n\telse\n\t\treturn 'D';\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"extent_io.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/genhd.h>",
            "#include <linux/mutex.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void btrfsic_dump_database(struct btrfsic_state *state);",
            "static char btrfsic_get_block_type(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block *block);",
            "static void btrfsic_dump_tree(const struct btrfsic_state *state);",
            "static struct btrfsic_dev_state *btrfsic_dev_state_lookup(\n\t\tstruct block_device *bdev);",
            "static void btrfsic_cmp_log_and_dev_bytenr(struct btrfsic_state *state,\n\t\t\t\t\t   u64 bytenr,\n\t\t\t\t\t   struct btrfsic_dev_state *dev_state,\n\t\t\t\t\t   u64 dev_bytenr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"extent_io.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n#include <linux/blkdev.h>\n#include <linux/genhd.h>\n#include <linux/mutex.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic void btrfsic_dump_database(struct btrfsic_state *state);\nstatic char btrfsic_get_block_type(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block *block);\nstatic void btrfsic_dump_tree(const struct btrfsic_state *state);\nstatic struct btrfsic_dev_state *btrfsic_dev_state_lookup(\n\t\tstruct block_device *bdev);\nstatic void btrfsic_cmp_log_and_dev_bytenr(struct btrfsic_state *state,\n\t\t\t\t\t   u64 bytenr,\n\t\t\t\t\t   struct btrfsic_dev_state *dev_state,\n\t\t\t\t\t   u64 dev_bytenr);\n\nstatic char btrfsic_get_block_type(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block *block)\n{\n\tif (block->is_superblock &&\n\t    state->latest_superblock->dev_bytenr == block->dev_bytenr &&\n\t    state->latest_superblock->dev_state->bdev == block->dev_state->bdev)\n\t\treturn 'S';\n\telse if (block->is_superblock)\n\t\treturn 's';\n\telse if (block->is_metadata)\n\t\treturn 'M';\n\telse\n\t\treturn 'D';\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "NULL == block"
          ],
          "line": 2264
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"extent_io.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n#include <linux/blkdev.h>\n#include <linux/genhd.h>\n#include <linux/mutex.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\n#define BTRFSIC_PRINT_MASK_END_IO_BIO_BH\t\t\t0x00000020\n\nstatic void btrfsic_block_link_init(struct btrfsic_block_link *n);\nstatic void btrfsic_block_link_free(struct btrfsic_block_link *n);\nstatic int btrfsic_map_block(struct btrfsic_state *state, u64 bytenr, u32 len,\n\t\t\t     struct btrfsic_block_data_ctx *block_ctx_out,\n\t\t\t     int mirror_num);\nstatic void btrfsic_dump_database(struct btrfsic_state *state);\nstatic void btrfsic_process_written_block(struct btrfsic_dev_state *dev_state,\n\t\t\t\t\t  u64 dev_bytenr, char **mapped_datav,\n\t\t\t\t\t  unsigned int num_pages,\n\t\t\t\t\t  struct bio *bio, int *bio_is_patched,\n\t\t\t\t\t  struct buffer_head *bh,\n\t\t\t\t\t  int submit_bio_bh_rw);\nstatic void btrfsic_bh_end_io(struct buffer_head *bh, int uptodate);\nstatic char btrfsic_get_block_type(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block *block);\nstatic void btrfsic_dump_tree(const struct btrfsic_state *state);\nstatic void btrfsic_cmp_log_and_dev_bytenr(struct btrfsic_state *state,\n\t\t\t\t\t   u64 bytenr,\n\t\t\t\t\t   struct btrfsic_dev_state *dev_state,\n\t\t\t\t\t   u64 dev_bytenr);\n\nstatic void btrfsic_bh_end_io(struct buffer_head *bh, int uptodate)\n{\n\tstruct btrfsic_block *block = (struct btrfsic_block *)bh->b_private;\n\tint iodone_w_error = !uptodate;\n\tstruct btrfsic_dev_state *dev_state;\n\n\tBUG_ON(NULL == block);\n\tdev_state = block->dev_state;\n\tif ((dev_state->state->print_mask & BTRFSIC_PRINT_MASK_END_IO_BIO_BH))\n\t\tprintk(KERN_INFO\n\t\t       \"bh_end_io(error=%d) for %c @%llu (%s/%llu/%d)\\n\",\n\t\t       iodone_w_error,\n\t\t       btrfsic_get_block_type(dev_state->state, block),\n\t\t       block->logical_bytenr, block->dev_state->name,\n\t\t       block->dev_bytenr, block->mirror_num);\n\n\tblock->iodone_w_error = iodone_w_error;\n\tif (block->submit_bio_bh_rw & REQ_FLUSH) {\n\t\tdev_state->last_flush_gen++;\n\t\tif ((dev_state->state->print_mask &\n\t\t     BTRFSIC_PRINT_MASK_END_IO_BIO_BH))\n\t\t\tprintk(KERN_INFO\n\t\t\t       \"bh_end_io() new %s flush_gen=%llu\\n\",\n\t\t\t       dev_state->name, dev_state->last_flush_gen);\n\t}\n\tif (block->submit_bio_bh_rw & REQ_FUA)\n\t\tblock->flush_gen = 0; /* FUA completed means block is on disk */\n\n\tbh->b_private = block->orig_bio_bh_private;\n\tbh->b_end_io = block->orig_bio_bh_end_io.bh;\n\tblock->is_iodone = 1; /* for FLUSH, this releases the block */\n\tbh->b_end_io(bh, uptodate);\n}"
  },
  {
    "function_name": "btrfsic_bio_end_io",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/check-integrity.c",
    "lines": "2210-2256",
    "snippet": "static void btrfsic_bio_end_io(struct bio *bp, int bio_error_status)\n{\n\tstruct btrfsic_block *block = (struct btrfsic_block *)bp->bi_private;\n\tint iodone_w_error;\n\n\t/* mutex is not held! This is not save if IO is not yet completed\n\t * on umount */\n\tiodone_w_error = 0;\n\tif (bio_error_status)\n\t\tiodone_w_error = 1;\n\n\tBUG_ON(NULL == block);\n\tbp->bi_private = block->orig_bio_bh_private;\n\tbp->bi_end_io = block->orig_bio_bh_end_io.bio;\n\n\tdo {\n\t\tstruct btrfsic_block *next_block;\n\t\tstruct btrfsic_dev_state *const dev_state = block->dev_state;\n\n\t\tif ((dev_state->state->print_mask &\n\t\t     BTRFSIC_PRINT_MASK_END_IO_BIO_BH))\n\t\t\tprintk(KERN_INFO\n\t\t\t       \"bio_end_io(err=%d) for %c @%llu (%s/%llu/%d)\\n\",\n\t\t\t       bio_error_status,\n\t\t\t       btrfsic_get_block_type(dev_state->state, block),\n\t\t\t       block->logical_bytenr, dev_state->name,\n\t\t\t       block->dev_bytenr, block->mirror_num);\n\t\tnext_block = block->next_in_same_bio;\n\t\tblock->iodone_w_error = iodone_w_error;\n\t\tif (block->submit_bio_bh_rw & REQ_FLUSH) {\n\t\t\tdev_state->last_flush_gen++;\n\t\t\tif ((dev_state->state->print_mask &\n\t\t\t     BTRFSIC_PRINT_MASK_END_IO_BIO_BH))\n\t\t\t\tprintk(KERN_INFO\n\t\t\t\t       \"bio_end_io() new %s flush_gen=%llu\\n\",\n\t\t\t\t       dev_state->name,\n\t\t\t\t       dev_state->last_flush_gen);\n\t\t}\n\t\tif (block->submit_bio_bh_rw & REQ_FUA)\n\t\t\tblock->flush_gen = 0; /* FUA completed means block is\n\t\t\t\t\t       * on disk */\n\t\tblock->is_iodone = 1; /* for FLUSH, this releases the block */\n\t\tblock = next_block;\n\t} while (NULL != block);\n\n\tbp->bi_end_io(bp, bio_error_status);\n}",
    "includes": [
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"volumes.h\"",
      "#include \"extent_io.h\"",
      "#include \"transaction.h\"",
      "#include \"hash.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/genhd.h>",
      "#include <linux/mutex.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [
      "#define BTRFSIC_PRINT_MASK_END_IO_BIO_BH\t\t\t0x00000020"
    ],
    "globals_used": [
      "static void btrfsic_block_link_init(struct btrfsic_block_link *n);",
      "static void btrfsic_block_link_free(struct btrfsic_block_link *n);",
      "static int btrfsic_map_block(struct btrfsic_state *state, u64 bytenr, u32 len,\n\t\t\t     struct btrfsic_block_data_ctx *block_ctx_out,\n\t\t\t     int mirror_num);",
      "static void btrfsic_dump_database(struct btrfsic_state *state);",
      "static void btrfsic_process_written_block(struct btrfsic_dev_state *dev_state,\n\t\t\t\t\t  u64 dev_bytenr, char **mapped_datav,\n\t\t\t\t\t  unsigned int num_pages,\n\t\t\t\t\t  struct bio *bio, int *bio_is_patched,\n\t\t\t\t\t  struct buffer_head *bh,\n\t\t\t\t\t  int submit_bio_bh_rw);",
      "static void btrfsic_bio_end_io(struct bio *bp, int bio_error_status);",
      "static char btrfsic_get_block_type(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block *block);",
      "static void btrfsic_dump_tree(const struct btrfsic_state *state);",
      "static void btrfsic_cmp_log_and_dev_bytenr(struct btrfsic_state *state,\n\t\t\t\t\t   u64 bytenr,\n\t\t\t\t\t   struct btrfsic_dev_state *dev_state,\n\t\t\t\t\t   u64 dev_bytenr);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bp->bi_end_io",
          "args": [
            "bp",
            "bio_error_status"
          ],
          "line": 2255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_INFO\n\t\t\t\t       \"bio_end_io() new %s flush_gen=%llu\\n\"",
            "dev_state->name",
            "dev_state->last_flush_gen"
          ],
          "line": 2243
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/super.c",
          "lines": "186-213",
          "snippet": "void btrfs_printk(const struct btrfs_fs_info *fs_info, const char *fmt, ...)\n{\n\tstruct super_block *sb = fs_info->sb;\n\tchar lvl[4];\n\tstruct va_format vaf;\n\tva_list args;\n\tconst char *type = logtypes[4];\n\tint kern_level;\n\n\tva_start(args, fmt);\n\n\tkern_level = printk_get_level(fmt);\n\tif (kern_level) {\n\t\tsize_t size = printk_skip_level(fmt) - fmt;\n\t\tmemcpy(lvl, fmt,  size);\n\t\tlvl[size] = '\\0';\n\t\tfmt += size;\n\t\ttype = logtypes[kern_level - '0'];\n\t} else\n\t\t*lvl = '\\0';\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sBTRFS %s (device %s): %pV\\n\", lvl, type, sb->s_id, &vaf);\n\n\tva_end(args);\n}",
          "includes": [
            "#include <trace/events/btrfs.h>",
            "#include \"qgroup.h\"",
            "#include \"tests/btrfs-tests.h\"",
            "#include \"backref.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"compression.h\"",
            "#include \"export.h\"",
            "#include \"volumes.h\"",
            "#include \"xattr.h\"",
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/slab.h>",
            "#include <linux/magic.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/namei.h>",
            "#include <linux/ctype.h>",
            "#include <linux/parser.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/btrfs.h>\n#include \"qgroup.h\"\n#include \"tests/btrfs-tests.h\"\n#include \"backref.h\"\n#include \"free-space-cache.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"compression.h\"\n#include \"export.h\"\n#include \"volumes.h\"\n#include \"xattr.h\"\n#include \"props.h\"\n#include \"hash.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include \"delayed-inode.h\"\n#include <linux/btrfs.h>\n#include <linux/ratelimit.h>\n#include <linux/cleancache.h>\n#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/miscdevice.h>\n#include <linux/namei.h>\n#include <linux/ctype.h>\n#include <linux/parser.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n\nvoid btrfs_printk(const struct btrfs_fs_info *fs_info, const char *fmt, ...)\n{\n\tstruct super_block *sb = fs_info->sb;\n\tchar lvl[4];\n\tstruct va_format vaf;\n\tva_list args;\n\tconst char *type = logtypes[4];\n\tint kern_level;\n\n\tva_start(args, fmt);\n\n\tkern_level = printk_get_level(fmt);\n\tif (kern_level) {\n\t\tsize_t size = printk_skip_level(fmt) - fmt;\n\t\tmemcpy(lvl, fmt,  size);\n\t\tlvl[size] = '\\0';\n\t\tfmt += size;\n\t\ttype = logtypes[kern_level - '0'];\n\t} else\n\t\t*lvl = '\\0';\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sBTRFS %s (device %s): %pV\\n\", lvl, type, sb->s_id, &vaf);\n\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfsic_get_block_type",
          "args": [
            "dev_state->state",
            "block"
          ],
          "line": 2234
        },
        "resolved": true,
        "details": {
          "function_name": "btrfsic_get_block_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/check-integrity.c",
          "lines": "2648-2661",
          "snippet": "static char btrfsic_get_block_type(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block *block)\n{\n\tif (block->is_superblock &&\n\t    state->latest_superblock->dev_bytenr == block->dev_bytenr &&\n\t    state->latest_superblock->dev_state->bdev == block->dev_state->bdev)\n\t\treturn 'S';\n\telse if (block->is_superblock)\n\t\treturn 's';\n\telse if (block->is_metadata)\n\t\treturn 'M';\n\telse\n\t\treturn 'D';\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"extent_io.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/genhd.h>",
            "#include <linux/mutex.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void btrfsic_dump_database(struct btrfsic_state *state);",
            "static char btrfsic_get_block_type(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block *block);",
            "static void btrfsic_dump_tree(const struct btrfsic_state *state);",
            "static struct btrfsic_dev_state *btrfsic_dev_state_lookup(\n\t\tstruct block_device *bdev);",
            "static void btrfsic_cmp_log_and_dev_bytenr(struct btrfsic_state *state,\n\t\t\t\t\t   u64 bytenr,\n\t\t\t\t\t   struct btrfsic_dev_state *dev_state,\n\t\t\t\t\t   u64 dev_bytenr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"extent_io.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n#include <linux/blkdev.h>\n#include <linux/genhd.h>\n#include <linux/mutex.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic void btrfsic_dump_database(struct btrfsic_state *state);\nstatic char btrfsic_get_block_type(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block *block);\nstatic void btrfsic_dump_tree(const struct btrfsic_state *state);\nstatic struct btrfsic_dev_state *btrfsic_dev_state_lookup(\n\t\tstruct block_device *bdev);\nstatic void btrfsic_cmp_log_and_dev_bytenr(struct btrfsic_state *state,\n\t\t\t\t\t   u64 bytenr,\n\t\t\t\t\t   struct btrfsic_dev_state *dev_state,\n\t\t\t\t\t   u64 dev_bytenr);\n\nstatic char btrfsic_get_block_type(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block *block)\n{\n\tif (block->is_superblock &&\n\t    state->latest_superblock->dev_bytenr == block->dev_bytenr &&\n\t    state->latest_superblock->dev_state->bdev == block->dev_state->bdev)\n\t\treturn 'S';\n\telse if (block->is_superblock)\n\t\treturn 's';\n\telse if (block->is_metadata)\n\t\treturn 'M';\n\telse\n\t\treturn 'D';\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "NULL == block"
          ],
          "line": 2221
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"extent_io.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n#include <linux/blkdev.h>\n#include <linux/genhd.h>\n#include <linux/mutex.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\n#define BTRFSIC_PRINT_MASK_END_IO_BIO_BH\t\t\t0x00000020\n\nstatic void btrfsic_block_link_init(struct btrfsic_block_link *n);\nstatic void btrfsic_block_link_free(struct btrfsic_block_link *n);\nstatic int btrfsic_map_block(struct btrfsic_state *state, u64 bytenr, u32 len,\n\t\t\t     struct btrfsic_block_data_ctx *block_ctx_out,\n\t\t\t     int mirror_num);\nstatic void btrfsic_dump_database(struct btrfsic_state *state);\nstatic void btrfsic_process_written_block(struct btrfsic_dev_state *dev_state,\n\t\t\t\t\t  u64 dev_bytenr, char **mapped_datav,\n\t\t\t\t\t  unsigned int num_pages,\n\t\t\t\t\t  struct bio *bio, int *bio_is_patched,\n\t\t\t\t\t  struct buffer_head *bh,\n\t\t\t\t\t  int submit_bio_bh_rw);\nstatic void btrfsic_bio_end_io(struct bio *bp, int bio_error_status);\nstatic char btrfsic_get_block_type(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block *block);\nstatic void btrfsic_dump_tree(const struct btrfsic_state *state);\nstatic void btrfsic_cmp_log_and_dev_bytenr(struct btrfsic_state *state,\n\t\t\t\t\t   u64 bytenr,\n\t\t\t\t\t   struct btrfsic_dev_state *dev_state,\n\t\t\t\t\t   u64 dev_bytenr);\n\nstatic void btrfsic_bio_end_io(struct bio *bp, int bio_error_status)\n{\n\tstruct btrfsic_block *block = (struct btrfsic_block *)bp->bi_private;\n\tint iodone_w_error;\n\n\t/* mutex is not held! This is not save if IO is not yet completed\n\t * on umount */\n\tiodone_w_error = 0;\n\tif (bio_error_status)\n\t\tiodone_w_error = 1;\n\n\tBUG_ON(NULL == block);\n\tbp->bi_private = block->orig_bio_bh_private;\n\tbp->bi_end_io = block->orig_bio_bh_end_io.bio;\n\n\tdo {\n\t\tstruct btrfsic_block *next_block;\n\t\tstruct btrfsic_dev_state *const dev_state = block->dev_state;\n\n\t\tif ((dev_state->state->print_mask &\n\t\t     BTRFSIC_PRINT_MASK_END_IO_BIO_BH))\n\t\t\tprintk(KERN_INFO\n\t\t\t       \"bio_end_io(err=%d) for %c @%llu (%s/%llu/%d)\\n\",\n\t\t\t       bio_error_status,\n\t\t\t       btrfsic_get_block_type(dev_state->state, block),\n\t\t\t       block->logical_bytenr, dev_state->name,\n\t\t\t       block->dev_bytenr, block->mirror_num);\n\t\tnext_block = block->next_in_same_bio;\n\t\tblock->iodone_w_error = iodone_w_error;\n\t\tif (block->submit_bio_bh_rw & REQ_FLUSH) {\n\t\t\tdev_state->last_flush_gen++;\n\t\t\tif ((dev_state->state->print_mask &\n\t\t\t     BTRFSIC_PRINT_MASK_END_IO_BIO_BH))\n\t\t\t\tprintk(KERN_INFO\n\t\t\t\t       \"bio_end_io() new %s flush_gen=%llu\\n\",\n\t\t\t\t       dev_state->name,\n\t\t\t\t       dev_state->last_flush_gen);\n\t\t}\n\t\tif (block->submit_bio_bh_rw & REQ_FUA)\n\t\t\tblock->flush_gen = 0; /* FUA completed means block is\n\t\t\t\t\t       * on disk */\n\t\tblock->is_iodone = 1; /* for FLUSH, this releases the block */\n\t\tblock = next_block;\n\t} while (NULL != block);\n\n\tbp->bi_end_io(bp, bio_error_status);\n}"
  },
  {
    "function_name": "btrfsic_process_written_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/check-integrity.c",
    "lines": "1818-2208",
    "snippet": "static void btrfsic_process_written_block(struct btrfsic_dev_state *dev_state,\n\t\t\t\t\t  u64 dev_bytenr, char **mapped_datav,\n\t\t\t\t\t  unsigned int num_pages,\n\t\t\t\t\t  struct bio *bio, int *bio_is_patched,\n\t\t\t\t\t  struct buffer_head *bh,\n\t\t\t\t\t  int submit_bio_bh_rw)\n{\n\tint is_metadata;\n\tstruct btrfsic_block *block;\n\tstruct btrfsic_block_data_ctx block_ctx;\n\tint ret;\n\tstruct btrfsic_state *state = dev_state->state;\n\tstruct block_device *bdev = dev_state->bdev;\n\tunsigned int processed_len;\n\n\tif (NULL != bio_is_patched)\n\t\t*bio_is_patched = 0;\n\nagain:\n\tif (num_pages == 0)\n\t\treturn;\n\n\tprocessed_len = 0;\n\tis_metadata = (0 == btrfsic_test_for_metadata(state, mapped_datav,\n\t\t\t\t\t\t      num_pages));\n\n\tblock = btrfsic_block_hashtable_lookup(bdev, dev_bytenr,\n\t\t\t\t\t       &state->block_hashtable);\n\tif (NULL != block) {\n\t\tu64 bytenr = 0;\n\t\tstruct list_head *elem_ref_to;\n\t\tstruct list_head *tmp_ref_to;\n\n\t\tif (block->is_superblock) {\n\t\t\tbytenr = btrfs_super_bytenr((struct btrfs_super_block *)\n\t\t\t\t\t\t    mapped_datav[0]);\n\t\t\tif (num_pages * PAGE_CACHE_SIZE <\n\t\t\t    BTRFS_SUPER_INFO_SIZE) {\n\t\t\t\tprintk(KERN_INFO\n\t\t\t\t       \"btrfsic: cannot work with too short bios!\\n\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tis_metadata = 1;\n\t\t\tBUG_ON(BTRFS_SUPER_INFO_SIZE & (PAGE_CACHE_SIZE - 1));\n\t\t\tprocessed_len = BTRFS_SUPER_INFO_SIZE;\n\t\t\tif (state->print_mask &\n\t\t\t    BTRFSIC_PRINT_MASK_TREE_BEFORE_SB_WRITE) {\n\t\t\t\tprintk(KERN_INFO\n\t\t\t\t       \"[before new superblock is written]:\\n\");\n\t\t\t\tbtrfsic_dump_tree_sub(state, block, 0);\n\t\t\t}\n\t\t}\n\t\tif (is_metadata) {\n\t\t\tif (!block->is_superblock) {\n\t\t\t\tif (num_pages * PAGE_CACHE_SIZE <\n\t\t\t\t    state->metablock_size) {\n\t\t\t\t\tprintk(KERN_INFO\n\t\t\t\t\t       \"btrfsic: cannot work with too short bios!\\n\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tprocessed_len = state->metablock_size;\n\t\t\t\tbytenr = btrfs_stack_header_bytenr(\n\t\t\t\t\t\t(struct btrfs_header *)\n\t\t\t\t\t\tmapped_datav[0]);\n\t\t\t\tbtrfsic_cmp_log_and_dev_bytenr(state, bytenr,\n\t\t\t\t\t\t\t       dev_state,\n\t\t\t\t\t\t\t       dev_bytenr);\n\t\t\t}\n\t\t\tif (state->print_mask & BTRFSIC_PRINT_MASK_VERBOSE) {\n\t\t\t\tif (block->logical_bytenr != bytenr &&\n\t\t\t\t    !(!block->is_metadata &&\n\t\t\t\t      block->logical_bytenr == 0))\n\t\t\t\t\tprintk(KERN_INFO\n\t\t\t\t\t       \"Written block @%llu (%s/%llu/%d) found in hash table, %c, bytenr mismatch (!= stored %llu).\\n\",\n\t\t\t\t\t       bytenr, dev_state->name,\n\t\t\t\t\t       dev_bytenr,\n\t\t\t\t\t       block->mirror_num,\n\t\t\t\t\t       btrfsic_get_block_type(state,\n\t\t\t\t\t\t\t\t      block),\n\t\t\t\t\t       block->logical_bytenr);\n\t\t\t\telse\n\t\t\t\t\tprintk(KERN_INFO\n\t\t\t\t\t       \"Written block @%llu (%s/%llu/%d) found in hash table, %c.\\n\",\n\t\t\t\t\t       bytenr, dev_state->name,\n\t\t\t\t\t       dev_bytenr, block->mirror_num,\n\t\t\t\t\t       btrfsic_get_block_type(state,\n\t\t\t\t\t\t\t\t      block));\n\t\t\t}\n\t\t\tblock->logical_bytenr = bytenr;\n\t\t} else {\n\t\t\tif (num_pages * PAGE_CACHE_SIZE <\n\t\t\t    state->datablock_size) {\n\t\t\t\tprintk(KERN_INFO\n\t\t\t\t       \"btrfsic: cannot work with too short bios!\\n\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tprocessed_len = state->datablock_size;\n\t\t\tbytenr = block->logical_bytenr;\n\t\t\tif (state->print_mask & BTRFSIC_PRINT_MASK_VERBOSE)\n\t\t\t\tprintk(KERN_INFO\n\t\t\t\t       \"Written block @%llu (%s/%llu/%d)\"\n\t\t\t\t       \" found in hash table, %c.\\n\",\n\t\t\t\t       bytenr, dev_state->name, dev_bytenr,\n\t\t\t\t       block->mirror_num,\n\t\t\t\t       btrfsic_get_block_type(state, block));\n\t\t}\n\n\t\tif (state->print_mask & BTRFSIC_PRINT_MASK_VERBOSE)\n\t\t\tprintk(KERN_INFO\n\t\t\t       \"ref_to_list: %cE, ref_from_list: %cE\\n\",\n\t\t\t       list_empty(&block->ref_to_list) ? ' ' : '!',\n\t\t\t       list_empty(&block->ref_from_list) ? ' ' : '!');\n\t\tif (btrfsic_is_block_ref_by_superblock(state, block, 0)) {\n\t\t\tprintk(KERN_INFO \"btrfs: attempt to overwrite %c-block\"\n\t\t\t       \" @%llu (%s/%llu/%d), old(gen=%llu,\"\n\t\t\t       \" objectid=%llu, type=%d, offset=%llu),\"\n\t\t\t       \" new(gen=%llu),\"\n\t\t\t       \" which is referenced by most recent superblock\"\n\t\t\t       \" (superblockgen=%llu)!\\n\",\n\t\t\t       btrfsic_get_block_type(state, block), bytenr,\n\t\t\t       dev_state->name, dev_bytenr, block->mirror_num,\n\t\t\t       block->generation,\n\t\t\t       btrfs_disk_key_objectid(&block->disk_key),\n\t\t\t       block->disk_key.type,\n\t\t\t       btrfs_disk_key_offset(&block->disk_key),\n\t\t\t       btrfs_stack_header_generation(\n\t\t\t\t       (struct btrfs_header *) mapped_datav[0]),\n\t\t\t       state->max_superblock_generation);\n\t\t\tbtrfsic_dump_tree(state);\n\t\t}\n\n\t\tif (!block->is_iodone && !block->never_written) {\n\t\t\tprintk(KERN_INFO \"btrfs: attempt to overwrite %c-block\"\n\t\t\t       \" @%llu (%s/%llu/%d), oldgen=%llu, newgen=%llu,\"\n\t\t\t       \" which is not yet iodone!\\n\",\n\t\t\t       btrfsic_get_block_type(state, block), bytenr,\n\t\t\t       dev_state->name, dev_bytenr, block->mirror_num,\n\t\t\t       block->generation,\n\t\t\t       btrfs_stack_header_generation(\n\t\t\t\t       (struct btrfs_header *)\n\t\t\t\t       mapped_datav[0]));\n\t\t\t/* it would not be safe to go on */\n\t\t\tbtrfsic_dump_tree(state);\n\t\t\tgoto continue_loop;\n\t\t}\n\n\t\t/*\n\t\t * Clear all references of this block. Do not free\n\t\t * the block itself even if is not referenced anymore\n\t\t * because it still carries valueable information\n\t\t * like whether it was ever written and IO completed.\n\t\t */\n\t\tlist_for_each_safe(elem_ref_to, tmp_ref_to,\n\t\t\t\t   &block->ref_to_list) {\n\t\t\tstruct btrfsic_block_link *const l =\n\t\t\t    list_entry(elem_ref_to,\n\t\t\t\t       struct btrfsic_block_link,\n\t\t\t\t       node_ref_to);\n\n\t\t\tif (state->print_mask & BTRFSIC_PRINT_MASK_VERBOSE)\n\t\t\t\tbtrfsic_print_rem_link(state, l);\n\t\t\tl->ref_cnt--;\n\t\t\tif (0 == l->ref_cnt) {\n\t\t\t\tlist_del(&l->node_ref_to);\n\t\t\t\tlist_del(&l->node_ref_from);\n\t\t\t\tbtrfsic_block_link_hashtable_remove(l);\n\t\t\t\tbtrfsic_block_link_free(l);\n\t\t\t}\n\t\t}\n\n\t\tblock_ctx.dev = dev_state;\n\t\tblock_ctx.dev_bytenr = dev_bytenr;\n\t\tblock_ctx.start = bytenr;\n\t\tblock_ctx.len = processed_len;\n\t\tblock_ctx.pagev = NULL;\n\t\tblock_ctx.mem_to_free = NULL;\n\t\tblock_ctx.datav = mapped_datav;\n\n\t\tif (is_metadata || state->include_extent_data) {\n\t\t\tblock->never_written = 0;\n\t\t\tblock->iodone_w_error = 0;\n\t\t\tif (NULL != bio) {\n\t\t\t\tblock->is_iodone = 0;\n\t\t\t\tBUG_ON(NULL == bio_is_patched);\n\t\t\t\tif (!*bio_is_patched) {\n\t\t\t\t\tblock->orig_bio_bh_private =\n\t\t\t\t\t    bio->bi_private;\n\t\t\t\t\tblock->orig_bio_bh_end_io.bio =\n\t\t\t\t\t    bio->bi_end_io;\n\t\t\t\t\tblock->next_in_same_bio = NULL;\n\t\t\t\t\tbio->bi_private = block;\n\t\t\t\t\tbio->bi_end_io = btrfsic_bio_end_io;\n\t\t\t\t\t*bio_is_patched = 1;\n\t\t\t\t} else {\n\t\t\t\t\tstruct btrfsic_block *chained_block =\n\t\t\t\t\t    (struct btrfsic_block *)\n\t\t\t\t\t    bio->bi_private;\n\n\t\t\t\t\tBUG_ON(NULL == chained_block);\n\t\t\t\t\tblock->orig_bio_bh_private =\n\t\t\t\t\t    chained_block->orig_bio_bh_private;\n\t\t\t\t\tblock->orig_bio_bh_end_io.bio =\n\t\t\t\t\t    chained_block->orig_bio_bh_end_io.\n\t\t\t\t\t    bio;\n\t\t\t\t\tblock->next_in_same_bio = chained_block;\n\t\t\t\t\tbio->bi_private = block;\n\t\t\t\t}\n\t\t\t} else if (NULL != bh) {\n\t\t\t\tblock->is_iodone = 0;\n\t\t\t\tblock->orig_bio_bh_private = bh->b_private;\n\t\t\t\tblock->orig_bio_bh_end_io.bh = bh->b_end_io;\n\t\t\t\tblock->next_in_same_bio = NULL;\n\t\t\t\tbh->b_private = block;\n\t\t\t\tbh->b_end_io = btrfsic_bh_end_io;\n\t\t\t} else {\n\t\t\t\tblock->is_iodone = 1;\n\t\t\t\tblock->orig_bio_bh_private = NULL;\n\t\t\t\tblock->orig_bio_bh_end_io.bio = NULL;\n\t\t\t\tblock->next_in_same_bio = NULL;\n\t\t\t}\n\t\t}\n\n\t\tblock->flush_gen = dev_state->last_flush_gen + 1;\n\t\tblock->submit_bio_bh_rw = submit_bio_bh_rw;\n\t\tif (is_metadata) {\n\t\t\tblock->logical_bytenr = bytenr;\n\t\t\tblock->is_metadata = 1;\n\t\t\tif (block->is_superblock) {\n\t\t\t\tBUG_ON(PAGE_CACHE_SIZE !=\n\t\t\t\t       BTRFS_SUPER_INFO_SIZE);\n\t\t\t\tret = btrfsic_process_written_superblock(\n\t\t\t\t\t\tstate,\n\t\t\t\t\t\tblock,\n\t\t\t\t\t\t(struct btrfs_super_block *)\n\t\t\t\t\t\tmapped_datav[0]);\n\t\t\t\tif (state->print_mask &\n\t\t\t\t    BTRFSIC_PRINT_MASK_TREE_AFTER_SB_WRITE) {\n\t\t\t\t\tprintk(KERN_INFO\n\t\t\t\t\t\"[after new superblock is written]:\\n\");\n\t\t\t\t\tbtrfsic_dump_tree_sub(state, block, 0);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tblock->mirror_num = 0;\t/* unknown */\n\t\t\t\tret = btrfsic_process_metablock(\n\t\t\t\t\t\tstate,\n\t\t\t\t\t\tblock,\n\t\t\t\t\t\t&block_ctx,\n\t\t\t\t\t\t0, 0);\n\t\t\t}\n\t\t\tif (ret)\n\t\t\t\tprintk(KERN_INFO\n\t\t\t\t       \"btrfsic: btrfsic_process_metablock\"\n\t\t\t\t       \"(root @%llu) failed!\\n\",\n\t\t\t\t       dev_bytenr);\n\t\t} else {\n\t\t\tblock->is_metadata = 0;\n\t\t\tblock->mirror_num = 0;\t/* unknown */\n\t\t\tblock->generation = BTRFSIC_GENERATION_UNKNOWN;\n\t\t\tif (!state->include_extent_data\n\t\t\t    && list_empty(&block->ref_from_list)) {\n\t\t\t\t/*\n\t\t\t\t * disk block is overwritten with extent\n\t\t\t\t * data (not meta data) and we are configured\n\t\t\t\t * to not include extent data: take the\n\t\t\t\t * chance and free the block's memory\n\t\t\t\t */\n\t\t\t\tbtrfsic_block_hashtable_remove(block);\n\t\t\t\tlist_del(&block->all_blocks_node);\n\t\t\t\tbtrfsic_block_free(block);\n\t\t\t}\n\t\t}\n\t\tbtrfsic_release_block_ctx(&block_ctx);\n\t} else {\n\t\t/* block has not been found in hash table */\n\t\tu64 bytenr;\n\n\t\tif (!is_metadata) {\n\t\t\tprocessed_len = state->datablock_size;\n\t\t\tif (state->print_mask & BTRFSIC_PRINT_MASK_VERBOSE)\n\t\t\t\tprintk(KERN_INFO \"Written block (%s/%llu/?)\"\n\t\t\t\t       \" !found in hash table, D.\\n\",\n\t\t\t\t       dev_state->name, dev_bytenr);\n\t\t\tif (!state->include_extent_data) {\n\t\t\t\t/* ignore that written D block */\n\t\t\t\tgoto continue_loop;\n\t\t\t}\n\n\t\t\t/* this is getting ugly for the\n\t\t\t * include_extent_data case... */\n\t\t\tbytenr = 0;\t/* unknown */\n\t\t} else {\n\t\t\tprocessed_len = state->metablock_size;\n\t\t\tbytenr = btrfs_stack_header_bytenr(\n\t\t\t\t\t(struct btrfs_header *)\n\t\t\t\t\tmapped_datav[0]);\n\t\t\tbtrfsic_cmp_log_and_dev_bytenr(state, bytenr, dev_state,\n\t\t\t\t\t\t       dev_bytenr);\n\t\t\tif (state->print_mask & BTRFSIC_PRINT_MASK_VERBOSE)\n\t\t\t\tprintk(KERN_INFO\n\t\t\t\t       \"Written block @%llu (%s/%llu/?)\"\n\t\t\t\t       \" !found in hash table, M.\\n\",\n\t\t\t\t       bytenr, dev_state->name, dev_bytenr);\n\t\t}\n\n\t\tblock_ctx.dev = dev_state;\n\t\tblock_ctx.dev_bytenr = dev_bytenr;\n\t\tblock_ctx.start = bytenr;\n\t\tblock_ctx.len = processed_len;\n\t\tblock_ctx.pagev = NULL;\n\t\tblock_ctx.mem_to_free = NULL;\n\t\tblock_ctx.datav = mapped_datav;\n\n\t\tblock = btrfsic_block_alloc();\n\t\tif (NULL == block) {\n\t\t\tprintk(KERN_INFO \"btrfsic: error, kmalloc failed!\\n\");\n\t\t\tbtrfsic_release_block_ctx(&block_ctx);\n\t\t\tgoto continue_loop;\n\t\t}\n\t\tblock->dev_state = dev_state;\n\t\tblock->dev_bytenr = dev_bytenr;\n\t\tblock->logical_bytenr = bytenr;\n\t\tblock->is_metadata = is_metadata;\n\t\tblock->never_written = 0;\n\t\tblock->iodone_w_error = 0;\n\t\tblock->mirror_num = 0;\t/* unknown */\n\t\tblock->flush_gen = dev_state->last_flush_gen + 1;\n\t\tblock->submit_bio_bh_rw = submit_bio_bh_rw;\n\t\tif (NULL != bio) {\n\t\t\tblock->is_iodone = 0;\n\t\t\tBUG_ON(NULL == bio_is_patched);\n\t\t\tif (!*bio_is_patched) {\n\t\t\t\tblock->orig_bio_bh_private = bio->bi_private;\n\t\t\t\tblock->orig_bio_bh_end_io.bio = bio->bi_end_io;\n\t\t\t\tblock->next_in_same_bio = NULL;\n\t\t\t\tbio->bi_private = block;\n\t\t\t\tbio->bi_end_io = btrfsic_bio_end_io;\n\t\t\t\t*bio_is_patched = 1;\n\t\t\t} else {\n\t\t\t\tstruct btrfsic_block *chained_block =\n\t\t\t\t    (struct btrfsic_block *)\n\t\t\t\t    bio->bi_private;\n\n\t\t\t\tBUG_ON(NULL == chained_block);\n\t\t\t\tblock->orig_bio_bh_private =\n\t\t\t\t    chained_block->orig_bio_bh_private;\n\t\t\t\tblock->orig_bio_bh_end_io.bio =\n\t\t\t\t    chained_block->orig_bio_bh_end_io.bio;\n\t\t\t\tblock->next_in_same_bio = chained_block;\n\t\t\t\tbio->bi_private = block;\n\t\t\t}\n\t\t} else if (NULL != bh) {\n\t\t\tblock->is_iodone = 0;\n\t\t\tblock->orig_bio_bh_private = bh->b_private;\n\t\t\tblock->orig_bio_bh_end_io.bh = bh->b_end_io;\n\t\t\tblock->next_in_same_bio = NULL;\n\t\t\tbh->b_private = block;\n\t\t\tbh->b_end_io = btrfsic_bh_end_io;\n\t\t} else {\n\t\t\tblock->is_iodone = 1;\n\t\t\tblock->orig_bio_bh_private = NULL;\n\t\t\tblock->orig_bio_bh_end_io.bio = NULL;\n\t\t\tblock->next_in_same_bio = NULL;\n\t\t}\n\t\tif (state->print_mask & BTRFSIC_PRINT_MASK_VERBOSE)\n\t\t\tprintk(KERN_INFO\n\t\t\t       \"New written %c-block @%llu (%s/%llu/%d)\\n\",\n\t\t\t       is_metadata ? 'M' : 'D',\n\t\t\t       block->logical_bytenr, block->dev_state->name,\n\t\t\t       block->dev_bytenr, block->mirror_num);\n\t\tlist_add(&block->all_blocks_node, &state->all_blocks_list);\n\t\tbtrfsic_block_hashtable_add(block, &state->block_hashtable);\n\n\t\tif (is_metadata) {\n\t\t\tret = btrfsic_process_metablock(state, block,\n\t\t\t\t\t\t\t&block_ctx, 0, 0);\n\t\t\tif (ret)\n\t\t\t\tprintk(KERN_INFO\n\t\t\t\t       \"btrfsic: process_metablock(root @%llu)\"\n\t\t\t\t       \" failed!\\n\",\n\t\t\t\t       dev_bytenr);\n\t\t}\n\t\tbtrfsic_release_block_ctx(&block_ctx);\n\t}\n\ncontinue_loop:\n\tBUG_ON(!processed_len);\n\tdev_bytenr += processed_len;\n\tmapped_datav += processed_len >> PAGE_CACHE_SHIFT;\n\tnum_pages -= processed_len >> PAGE_CACHE_SHIFT;\n\tgoto again;\n}",
    "includes": [
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"volumes.h\"",
      "#include \"extent_io.h\"",
      "#include \"transaction.h\"",
      "#include \"hash.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/genhd.h>",
      "#include <linux/mutex.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [
      "#define BTRFSIC_PRINT_MASK_VERBOSE\t\t\t\t0x00000040",
      "#define BTRFSIC_PRINT_MASK_TREE_BEFORE_SB_WRITE\t\t\t0x00000008",
      "#define BTRFSIC_PRINT_MASK_TREE_AFTER_SB_WRITE\t\t\t0x00000004",
      "#define BTRFSIC_GENERATION_UNKNOWN ((u64)-1)"
    ],
    "globals_used": [
      "static struct btrfsic_block *btrfsic_block_alloc(void);",
      "static void btrfsic_block_link_init(struct btrfsic_block_link *n);",
      "static void btrfsic_block_link_free(struct btrfsic_block_link *n);",
      "static void btrfsic_block_link_hashtable_remove(struct btrfsic_block_link *l);",
      "static void btrfsic_read_from_block_data(\n\tstruct btrfsic_block_data_ctx *block_ctx,\n\tvoid *dst, u32 offset, size_t len);",
      "static int btrfsic_map_block(struct btrfsic_state *state, u64 bytenr, u32 len,\n\t\t\t     struct btrfsic_block_data_ctx *block_ctx_out,\n\t\t\t     int mirror_num);",
      "static void btrfsic_release_block_ctx(struct btrfsic_block_data_ctx *block_ctx);",
      "static int btrfsic_read_block(struct btrfsic_state *state,\n\t\t\t      struct btrfsic_block_data_ctx *block_ctx);",
      "static void btrfsic_dump_database(struct btrfsic_state *state);",
      "static int btrfsic_test_for_metadata(struct btrfsic_state *state,\n\t\t\t\t     char **datav, unsigned int num_pages);",
      "static void btrfsic_process_written_block(struct btrfsic_dev_state *dev_state,\n\t\t\t\t\t  u64 dev_bytenr, char **mapped_datav,\n\t\t\t\t\t  unsigned int num_pages,\n\t\t\t\t\t  struct bio *bio, int *bio_is_patched,\n\t\t\t\t\t  struct buffer_head *bh,\n\t\t\t\t\t  int submit_bio_bh_rw);",
      "static void btrfsic_print_add_link(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block_link *l);",
      "static void btrfsic_print_rem_link(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block_link *l);",
      "static char btrfsic_get_block_type(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block *block);",
      "static void btrfsic_dump_tree(const struct btrfsic_state *state);",
      "static struct btrfsic_dev_state *btrfsic_dev_state_lookup(\n\t\tstruct block_device *bdev);",
      "static void btrfsic_cmp_log_and_dev_bytenr(struct btrfsic_state *state,\n\t\t\t\t\t   u64 bytenr,\n\t\t\t\t\t   struct btrfsic_dev_state *dev_state,\n\t\t\t\t\t   u64 dev_bytenr);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!processed_len"
          ],
          "line": 2203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfsic_release_block_ctx",
          "args": [
            "&block_ctx"
          ],
          "line": 2199
        },
        "resolved": true,
        "details": {
          "function_name": "btrfsic_release_block_ctx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/check-integrity.c",
          "lines": "1611-1637",
          "snippet": "static void btrfsic_release_block_ctx(struct btrfsic_block_data_ctx *block_ctx)\n{\n\tif (block_ctx->mem_to_free) {\n\t\tunsigned int num_pages;\n\n\t\tBUG_ON(!block_ctx->datav);\n\t\tBUG_ON(!block_ctx->pagev);\n\t\tnum_pages = (block_ctx->len + (u64)PAGE_CACHE_SIZE - 1) >>\n\t\t\t    PAGE_CACHE_SHIFT;\n\t\twhile (num_pages > 0) {\n\t\t\tnum_pages--;\n\t\t\tif (block_ctx->datav[num_pages]) {\n\t\t\t\tkunmap(block_ctx->pagev[num_pages]);\n\t\t\t\tblock_ctx->datav[num_pages] = NULL;\n\t\t\t}\n\t\t\tif (block_ctx->pagev[num_pages]) {\n\t\t\t\t__free_page(block_ctx->pagev[num_pages]);\n\t\t\t\tblock_ctx->pagev[num_pages] = NULL;\n\t\t\t}\n\t\t}\n\n\t\tkfree(block_ctx->mem_to_free);\n\t\tblock_ctx->mem_to_free = NULL;\n\t\tblock_ctx->pagev = NULL;\n\t\tblock_ctx->datav = NULL;\n\t}\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"extent_io.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/genhd.h>",
            "#include <linux/mutex.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void btrfsic_read_from_block_data(\n\tstruct btrfsic_block_data_ctx *block_ctx,\n\tvoid *dst, u32 offset, size_t len);",
            "static void btrfsic_release_block_ctx(struct btrfsic_block_data_ctx *block_ctx);",
            "static int btrfsic_read_block(struct btrfsic_state *state,\n\t\t\t      struct btrfsic_block_data_ctx *block_ctx);",
            "static int btrfsic_test_for_metadata(struct btrfsic_state *state,\n\t\t\t\t     char **datav, unsigned int num_pages);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"extent_io.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n#include <linux/blkdev.h>\n#include <linux/genhd.h>\n#include <linux/mutex.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic void btrfsic_read_from_block_data(\n\tstruct btrfsic_block_data_ctx *block_ctx,\n\tvoid *dst, u32 offset, size_t len);\nstatic void btrfsic_release_block_ctx(struct btrfsic_block_data_ctx *block_ctx);\nstatic int btrfsic_read_block(struct btrfsic_state *state,\n\t\t\t      struct btrfsic_block_data_ctx *block_ctx);\nstatic int btrfsic_test_for_metadata(struct btrfsic_state *state,\n\t\t\t\t     char **datav, unsigned int num_pages);\n\nstatic void btrfsic_release_block_ctx(struct btrfsic_block_data_ctx *block_ctx)\n{\n\tif (block_ctx->mem_to_free) {\n\t\tunsigned int num_pages;\n\n\t\tBUG_ON(!block_ctx->datav);\n\t\tBUG_ON(!block_ctx->pagev);\n\t\tnum_pages = (block_ctx->len + (u64)PAGE_CACHE_SIZE - 1) >>\n\t\t\t    PAGE_CACHE_SHIFT;\n\t\twhile (num_pages > 0) {\n\t\t\tnum_pages--;\n\t\t\tif (block_ctx->datav[num_pages]) {\n\t\t\t\tkunmap(block_ctx->pagev[num_pages]);\n\t\t\t\tblock_ctx->datav[num_pages] = NULL;\n\t\t\t}\n\t\t\tif (block_ctx->pagev[num_pages]) {\n\t\t\t\t__free_page(block_ctx->pagev[num_pages]);\n\t\t\t\tblock_ctx->pagev[num_pages] = NULL;\n\t\t\t}\n\t\t}\n\n\t\tkfree(block_ctx->mem_to_free);\n\t\tblock_ctx->mem_to_free = NULL;\n\t\tblock_ctx->pagev = NULL;\n\t\tblock_ctx->datav = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_INFO\n\t\t\t\t       \"btrfsic: process_metablock(root @%llu)\"\n\t\t\t\t       \" failed!\\n\"",
            "dev_bytenr"
          ],
          "line": 2194
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/super.c",
          "lines": "186-213",
          "snippet": "void btrfs_printk(const struct btrfs_fs_info *fs_info, const char *fmt, ...)\n{\n\tstruct super_block *sb = fs_info->sb;\n\tchar lvl[4];\n\tstruct va_format vaf;\n\tva_list args;\n\tconst char *type = logtypes[4];\n\tint kern_level;\n\n\tva_start(args, fmt);\n\n\tkern_level = printk_get_level(fmt);\n\tif (kern_level) {\n\t\tsize_t size = printk_skip_level(fmt) - fmt;\n\t\tmemcpy(lvl, fmt,  size);\n\t\tlvl[size] = '\\0';\n\t\tfmt += size;\n\t\ttype = logtypes[kern_level - '0'];\n\t} else\n\t\t*lvl = '\\0';\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sBTRFS %s (device %s): %pV\\n\", lvl, type, sb->s_id, &vaf);\n\n\tva_end(args);\n}",
          "includes": [
            "#include <trace/events/btrfs.h>",
            "#include \"qgroup.h\"",
            "#include \"tests/btrfs-tests.h\"",
            "#include \"backref.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"compression.h\"",
            "#include \"export.h\"",
            "#include \"volumes.h\"",
            "#include \"xattr.h\"",
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/slab.h>",
            "#include <linux/magic.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/namei.h>",
            "#include <linux/ctype.h>",
            "#include <linux/parser.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/btrfs.h>\n#include \"qgroup.h\"\n#include \"tests/btrfs-tests.h\"\n#include \"backref.h\"\n#include \"free-space-cache.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"compression.h\"\n#include \"export.h\"\n#include \"volumes.h\"\n#include \"xattr.h\"\n#include \"props.h\"\n#include \"hash.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include \"delayed-inode.h\"\n#include <linux/btrfs.h>\n#include <linux/ratelimit.h>\n#include <linux/cleancache.h>\n#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/miscdevice.h>\n#include <linux/namei.h>\n#include <linux/ctype.h>\n#include <linux/parser.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n\nvoid btrfs_printk(const struct btrfs_fs_info *fs_info, const char *fmt, ...)\n{\n\tstruct super_block *sb = fs_info->sb;\n\tchar lvl[4];\n\tstruct va_format vaf;\n\tva_list args;\n\tconst char *type = logtypes[4];\n\tint kern_level;\n\n\tva_start(args, fmt);\n\n\tkern_level = printk_get_level(fmt);\n\tif (kern_level) {\n\t\tsize_t size = printk_skip_level(fmt) - fmt;\n\t\tmemcpy(lvl, fmt,  size);\n\t\tlvl[size] = '\\0';\n\t\tfmt += size;\n\t\ttype = logtypes[kern_level - '0'];\n\t} else\n\t\t*lvl = '\\0';\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sBTRFS %s (device %s): %pV\\n\", lvl, type, sb->s_id, &vaf);\n\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfsic_process_metablock",
          "args": [
            "state",
            "block",
            "&block_ctx",
            "0",
            "0"
          ],
          "line": 2191
        },
        "resolved": true,
        "details": {
          "function_name": "btrfsic_process_metablock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/check-integrity.c",
          "lines": "974-1234",
          "snippet": "static int btrfsic_process_metablock(\n\t\tstruct btrfsic_state *state,\n\t\tstruct btrfsic_block *const first_block,\n\t\tstruct btrfsic_block_data_ctx *const first_block_ctx,\n\t\tint first_limit_nesting, int force_iodone_flag)\n{\n\tstruct btrfsic_stack_frame initial_stack_frame = { 0 };\n\tstruct btrfsic_stack_frame *sf;\n\tstruct btrfsic_stack_frame *next_stack;\n\tstruct btrfs_header *const first_hdr =\n\t\t(struct btrfs_header *)first_block_ctx->datav[0];\n\n\tBUG_ON(!first_hdr);\n\tsf = &initial_stack_frame;\n\tsf->error = 0;\n\tsf->i = -1;\n\tsf->limit_nesting = first_limit_nesting;\n\tsf->block = first_block;\n\tsf->block_ctx = first_block_ctx;\n\tsf->next_block = NULL;\n\tsf->hdr = first_hdr;\n\tsf->prev = NULL;\n\ncontinue_with_new_stack_frame:\n\tsf->block->generation = le64_to_cpu(sf->hdr->generation);\n\tif (0 == sf->hdr->level) {\n\t\tstruct btrfs_leaf *const leafhdr =\n\t\t    (struct btrfs_leaf *)sf->hdr;\n\n\t\tif (-1 == sf->i) {\n\t\t\tsf->nr = btrfs_stack_header_nritems(&leafhdr->header);\n\n\t\t\tif (state->print_mask & BTRFSIC_PRINT_MASK_VERBOSE)\n\t\t\t\tprintk(KERN_INFO\n\t\t\t\t       \"leaf %llu items %d generation %llu\"\n\t\t\t\t       \" owner %llu\\n\",\n\t\t\t\t       sf->block_ctx->start, sf->nr,\n\t\t\t\t       btrfs_stack_header_generation(\n\t\t\t\t\t       &leafhdr->header),\n\t\t\t\t       btrfs_stack_header_owner(\n\t\t\t\t\t       &leafhdr->header));\n\t\t}\n\ncontinue_with_current_leaf_stack_frame:\n\t\tif (0 == sf->num_copies || sf->mirror_num > sf->num_copies) {\n\t\t\tsf->i++;\n\t\t\tsf->num_copies = 0;\n\t\t}\n\n\t\tif (sf->i < sf->nr) {\n\t\t\tstruct btrfs_item disk_item;\n\t\t\tu32 disk_item_offset =\n\t\t\t\t(uintptr_t)(leafhdr->items + sf->i) -\n\t\t\t\t(uintptr_t)leafhdr;\n\t\t\tstruct btrfs_disk_key *disk_key;\n\t\t\tu8 type;\n\t\t\tu32 item_offset;\n\t\t\tu32 item_size;\n\n\t\t\tif (disk_item_offset + sizeof(struct btrfs_item) >\n\t\t\t    sf->block_ctx->len) {\nleaf_item_out_of_bounce_error:\n\t\t\t\tprintk(KERN_INFO\n\t\t\t\t       \"btrfsic: leaf item out of bounce at logical %llu, dev %s\\n\",\n\t\t\t\t       sf->block_ctx->start,\n\t\t\t\t       sf->block_ctx->dev->name);\n\t\t\t\tgoto one_stack_frame_backwards;\n\t\t\t}\n\t\t\tbtrfsic_read_from_block_data(sf->block_ctx,\n\t\t\t\t\t\t     &disk_item,\n\t\t\t\t\t\t     disk_item_offset,\n\t\t\t\t\t\t     sizeof(struct btrfs_item));\n\t\t\titem_offset = btrfs_stack_item_offset(&disk_item);\n\t\t\titem_size = btrfs_stack_item_size(&disk_item);\n\t\t\tdisk_key = &disk_item.key;\n\t\t\ttype = btrfs_disk_key_type(disk_key);\n\n\t\t\tif (BTRFS_ROOT_ITEM_KEY == type) {\n\t\t\t\tstruct btrfs_root_item root_item;\n\t\t\t\tu32 root_item_offset;\n\t\t\t\tu64 next_bytenr;\n\n\t\t\t\troot_item_offset = item_offset +\n\t\t\t\t\toffsetof(struct btrfs_leaf, items);\n\t\t\t\tif (root_item_offset + item_size >\n\t\t\t\t    sf->block_ctx->len)\n\t\t\t\t\tgoto leaf_item_out_of_bounce_error;\n\t\t\t\tbtrfsic_read_from_block_data(\n\t\t\t\t\tsf->block_ctx, &root_item,\n\t\t\t\t\troot_item_offset,\n\t\t\t\t\titem_size);\n\t\t\t\tnext_bytenr = btrfs_root_bytenr(&root_item);\n\n\t\t\t\tsf->error =\n\t\t\t\t    btrfsic_create_link_to_next_block(\n\t\t\t\t\t\tstate,\n\t\t\t\t\t\tsf->block,\n\t\t\t\t\t\tsf->block_ctx,\n\t\t\t\t\t\tnext_bytenr,\n\t\t\t\t\t\tsf->limit_nesting,\n\t\t\t\t\t\t&sf->next_block_ctx,\n\t\t\t\t\t\t&sf->next_block,\n\t\t\t\t\t\tforce_iodone_flag,\n\t\t\t\t\t\t&sf->num_copies,\n\t\t\t\t\t\t&sf->mirror_num,\n\t\t\t\t\t\tdisk_key,\n\t\t\t\t\t\tbtrfs_root_generation(\n\t\t\t\t\t\t&root_item));\n\t\t\t\tif (sf->error)\n\t\t\t\t\tgoto one_stack_frame_backwards;\n\n\t\t\t\tif (NULL != sf->next_block) {\n\t\t\t\t\tstruct btrfs_header *const next_hdr =\n\t\t\t\t\t    (struct btrfs_header *)\n\t\t\t\t\t    sf->next_block_ctx.datav[0];\n\n\t\t\t\t\tnext_stack =\n\t\t\t\t\t    btrfsic_stack_frame_alloc();\n\t\t\t\t\tif (NULL == next_stack) {\n\t\t\t\t\t\tsf->error = -1;\n\t\t\t\t\t\tbtrfsic_release_block_ctx(\n\t\t\t\t\t\t\t\t&sf->\n\t\t\t\t\t\t\t\tnext_block_ctx);\n\t\t\t\t\t\tgoto one_stack_frame_backwards;\n\t\t\t\t\t}\n\n\t\t\t\t\tnext_stack->i = -1;\n\t\t\t\t\tnext_stack->block = sf->next_block;\n\t\t\t\t\tnext_stack->block_ctx =\n\t\t\t\t\t    &sf->next_block_ctx;\n\t\t\t\t\tnext_stack->next_block = NULL;\n\t\t\t\t\tnext_stack->hdr = next_hdr;\n\t\t\t\t\tnext_stack->limit_nesting =\n\t\t\t\t\t    sf->limit_nesting - 1;\n\t\t\t\t\tnext_stack->prev = sf;\n\t\t\t\t\tsf = next_stack;\n\t\t\t\t\tgoto continue_with_new_stack_frame;\n\t\t\t\t}\n\t\t\t} else if (BTRFS_EXTENT_DATA_KEY == type &&\n\t\t\t\t   state->include_extent_data) {\n\t\t\t\tsf->error = btrfsic_handle_extent_data(\n\t\t\t\t\t\tstate,\n\t\t\t\t\t\tsf->block,\n\t\t\t\t\t\tsf->block_ctx,\n\t\t\t\t\t\titem_offset,\n\t\t\t\t\t\tforce_iodone_flag);\n\t\t\t\tif (sf->error)\n\t\t\t\t\tgoto one_stack_frame_backwards;\n\t\t\t}\n\n\t\t\tgoto continue_with_current_leaf_stack_frame;\n\t\t}\n\t} else {\n\t\tstruct btrfs_node *const nodehdr = (struct btrfs_node *)sf->hdr;\n\n\t\tif (-1 == sf->i) {\n\t\t\tsf->nr = btrfs_stack_header_nritems(&nodehdr->header);\n\n\t\t\tif (state->print_mask & BTRFSIC_PRINT_MASK_VERBOSE)\n\t\t\t\tprintk(KERN_INFO \"node %llu level %d items %d\"\n\t\t\t\t       \" generation %llu owner %llu\\n\",\n\t\t\t\t       sf->block_ctx->start,\n\t\t\t\t       nodehdr->header.level, sf->nr,\n\t\t\t\t       btrfs_stack_header_generation(\n\t\t\t\t       &nodehdr->header),\n\t\t\t\t       btrfs_stack_header_owner(\n\t\t\t\t       &nodehdr->header));\n\t\t}\n\ncontinue_with_current_node_stack_frame:\n\t\tif (0 == sf->num_copies || sf->mirror_num > sf->num_copies) {\n\t\t\tsf->i++;\n\t\t\tsf->num_copies = 0;\n\t\t}\n\n\t\tif (sf->i < sf->nr) {\n\t\t\tstruct btrfs_key_ptr key_ptr;\n\t\t\tu32 key_ptr_offset;\n\t\t\tu64 next_bytenr;\n\n\t\t\tkey_ptr_offset = (uintptr_t)(nodehdr->ptrs + sf->i) -\n\t\t\t\t\t  (uintptr_t)nodehdr;\n\t\t\tif (key_ptr_offset + sizeof(struct btrfs_key_ptr) >\n\t\t\t    sf->block_ctx->len) {\n\t\t\t\tprintk(KERN_INFO\n\t\t\t\t       \"btrfsic: node item out of bounce at logical %llu, dev %s\\n\",\n\t\t\t\t       sf->block_ctx->start,\n\t\t\t\t       sf->block_ctx->dev->name);\n\t\t\t\tgoto one_stack_frame_backwards;\n\t\t\t}\n\t\t\tbtrfsic_read_from_block_data(\n\t\t\t\tsf->block_ctx, &key_ptr, key_ptr_offset,\n\t\t\t\tsizeof(struct btrfs_key_ptr));\n\t\t\tnext_bytenr = btrfs_stack_key_blockptr(&key_ptr);\n\n\t\t\tsf->error = btrfsic_create_link_to_next_block(\n\t\t\t\t\tstate,\n\t\t\t\t\tsf->block,\n\t\t\t\t\tsf->block_ctx,\n\t\t\t\t\tnext_bytenr,\n\t\t\t\t\tsf->limit_nesting,\n\t\t\t\t\t&sf->next_block_ctx,\n\t\t\t\t\t&sf->next_block,\n\t\t\t\t\tforce_iodone_flag,\n\t\t\t\t\t&sf->num_copies,\n\t\t\t\t\t&sf->mirror_num,\n\t\t\t\t\t&key_ptr.key,\n\t\t\t\t\tbtrfs_stack_key_generation(&key_ptr));\n\t\t\tif (sf->error)\n\t\t\t\tgoto one_stack_frame_backwards;\n\n\t\t\tif (NULL != sf->next_block) {\n\t\t\t\tstruct btrfs_header *const next_hdr =\n\t\t\t\t    (struct btrfs_header *)\n\t\t\t\t    sf->next_block_ctx.datav[0];\n\n\t\t\t\tnext_stack = btrfsic_stack_frame_alloc();\n\t\t\t\tif (NULL == next_stack) {\n\t\t\t\t\tsf->error = -1;\n\t\t\t\t\tgoto one_stack_frame_backwards;\n\t\t\t\t}\n\n\t\t\t\tnext_stack->i = -1;\n\t\t\t\tnext_stack->block = sf->next_block;\n\t\t\t\tnext_stack->block_ctx = &sf->next_block_ctx;\n\t\t\t\tnext_stack->next_block = NULL;\n\t\t\t\tnext_stack->hdr = next_hdr;\n\t\t\t\tnext_stack->limit_nesting =\n\t\t\t\t    sf->limit_nesting - 1;\n\t\t\t\tnext_stack->prev = sf;\n\t\t\t\tsf = next_stack;\n\t\t\t\tgoto continue_with_new_stack_frame;\n\t\t\t}\n\n\t\t\tgoto continue_with_current_node_stack_frame;\n\t\t}\n\t}\n\none_stack_frame_backwards:\n\tif (NULL != sf->prev) {\n\t\tstruct btrfsic_stack_frame *const prev = sf->prev;\n\n\t\t/* the one for the initial block is freed in the caller */\n\t\tbtrfsic_release_block_ctx(sf->block_ctx);\n\n\t\tif (sf->error) {\n\t\t\tprev->error = sf->error;\n\t\t\tbtrfsic_stack_frame_free(sf);\n\t\t\tsf = prev;\n\t\t\tgoto one_stack_frame_backwards;\n\t\t}\n\n\t\tbtrfsic_stack_frame_free(sf);\n\t\tsf = prev;\n\t\tgoto continue_with_new_stack_frame;\n\t} else {\n\t\tBUG_ON(&initial_stack_frame != sf);\n\t}\n\n\treturn sf->error;\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"extent_io.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/genhd.h>",
            "#include <linux/mutex.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define BTRFSIC_PRINT_MASK_VERBOSE\t\t\t\t0x00000040"
          ],
          "globals_used": [
            "static void btrfsic_block_link_init(struct btrfsic_block_link *n);",
            "static void btrfsic_block_link_free(struct btrfsic_block_link *n);",
            "static struct btrfsic_stack_frame *btrfsic_stack_frame_alloc(void);",
            "static void btrfsic_stack_frame_free(struct btrfsic_stack_frame *sf);",
            "static int btrfsic_process_metablock(struct btrfsic_state *state,\n\t\t\t\t     struct btrfsic_block *block,\n\t\t\t\t     struct btrfsic_block_data_ctx *block_ctx,\n\t\t\t\t     int limit_nesting, int force_iodone_flag);",
            "static void btrfsic_read_from_block_data(\n\tstruct btrfsic_block_data_ctx *block_ctx,\n\tvoid *dst, u32 offset, size_t len);",
            "static int btrfsic_handle_extent_data(struct btrfsic_state *state,\n\t\t\t\t      struct btrfsic_block *block,\n\t\t\t\t      struct btrfsic_block_data_ctx *block_ctx,\n\t\t\t\t      u32 item_offset, int force_iodone_flag);",
            "static int btrfsic_map_block(struct btrfsic_state *state, u64 bytenr, u32 len,\n\t\t\t     struct btrfsic_block_data_ctx *block_ctx_out,\n\t\t\t     int mirror_num);",
            "static void btrfsic_release_block_ctx(struct btrfsic_block_data_ctx *block_ctx);",
            "static int btrfsic_read_block(struct btrfsic_state *state,\n\t\t\t      struct btrfsic_block_data_ctx *block_ctx);",
            "static void btrfsic_dump_database(struct btrfsic_state *state);",
            "static char btrfsic_get_block_type(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block *block);",
            "static void btrfsic_dump_tree(const struct btrfsic_state *state);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"extent_io.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n#include <linux/blkdev.h>\n#include <linux/genhd.h>\n#include <linux/mutex.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\n#define BTRFSIC_PRINT_MASK_VERBOSE\t\t\t\t0x00000040\n\nstatic void btrfsic_block_link_init(struct btrfsic_block_link *n);\nstatic void btrfsic_block_link_free(struct btrfsic_block_link *n);\nstatic struct btrfsic_stack_frame *btrfsic_stack_frame_alloc(void);\nstatic void btrfsic_stack_frame_free(struct btrfsic_stack_frame *sf);\nstatic int btrfsic_process_metablock(struct btrfsic_state *state,\n\t\t\t\t     struct btrfsic_block *block,\n\t\t\t\t     struct btrfsic_block_data_ctx *block_ctx,\n\t\t\t\t     int limit_nesting, int force_iodone_flag);\nstatic void btrfsic_read_from_block_data(\n\tstruct btrfsic_block_data_ctx *block_ctx,\n\tvoid *dst, u32 offset, size_t len);\nstatic int btrfsic_handle_extent_data(struct btrfsic_state *state,\n\t\t\t\t      struct btrfsic_block *block,\n\t\t\t\t      struct btrfsic_block_data_ctx *block_ctx,\n\t\t\t\t      u32 item_offset, int force_iodone_flag);\nstatic int btrfsic_map_block(struct btrfsic_state *state, u64 bytenr, u32 len,\n\t\t\t     struct btrfsic_block_data_ctx *block_ctx_out,\n\t\t\t     int mirror_num);\nstatic void btrfsic_release_block_ctx(struct btrfsic_block_data_ctx *block_ctx);\nstatic int btrfsic_read_block(struct btrfsic_state *state,\n\t\t\t      struct btrfsic_block_data_ctx *block_ctx);\nstatic void btrfsic_dump_database(struct btrfsic_state *state);\nstatic char btrfsic_get_block_type(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block *block);\nstatic void btrfsic_dump_tree(const struct btrfsic_state *state);\n\nstatic int btrfsic_process_metablock(\n\t\tstruct btrfsic_state *state,\n\t\tstruct btrfsic_block *const first_block,\n\t\tstruct btrfsic_block_data_ctx *const first_block_ctx,\n\t\tint first_limit_nesting, int force_iodone_flag)\n{\n\tstruct btrfsic_stack_frame initial_stack_frame = { 0 };\n\tstruct btrfsic_stack_frame *sf;\n\tstruct btrfsic_stack_frame *next_stack;\n\tstruct btrfs_header *const first_hdr =\n\t\t(struct btrfs_header *)first_block_ctx->datav[0];\n\n\tBUG_ON(!first_hdr);\n\tsf = &initial_stack_frame;\n\tsf->error = 0;\n\tsf->i = -1;\n\tsf->limit_nesting = first_limit_nesting;\n\tsf->block = first_block;\n\tsf->block_ctx = first_block_ctx;\n\tsf->next_block = NULL;\n\tsf->hdr = first_hdr;\n\tsf->prev = NULL;\n\ncontinue_with_new_stack_frame:\n\tsf->block->generation = le64_to_cpu(sf->hdr->generation);\n\tif (0 == sf->hdr->level) {\n\t\tstruct btrfs_leaf *const leafhdr =\n\t\t    (struct btrfs_leaf *)sf->hdr;\n\n\t\tif (-1 == sf->i) {\n\t\t\tsf->nr = btrfs_stack_header_nritems(&leafhdr->header);\n\n\t\t\tif (state->print_mask & BTRFSIC_PRINT_MASK_VERBOSE)\n\t\t\t\tprintk(KERN_INFO\n\t\t\t\t       \"leaf %llu items %d generation %llu\"\n\t\t\t\t       \" owner %llu\\n\",\n\t\t\t\t       sf->block_ctx->start, sf->nr,\n\t\t\t\t       btrfs_stack_header_generation(\n\t\t\t\t\t       &leafhdr->header),\n\t\t\t\t       btrfs_stack_header_owner(\n\t\t\t\t\t       &leafhdr->header));\n\t\t}\n\ncontinue_with_current_leaf_stack_frame:\n\t\tif (0 == sf->num_copies || sf->mirror_num > sf->num_copies) {\n\t\t\tsf->i++;\n\t\t\tsf->num_copies = 0;\n\t\t}\n\n\t\tif (sf->i < sf->nr) {\n\t\t\tstruct btrfs_item disk_item;\n\t\t\tu32 disk_item_offset =\n\t\t\t\t(uintptr_t)(leafhdr->items + sf->i) -\n\t\t\t\t(uintptr_t)leafhdr;\n\t\t\tstruct btrfs_disk_key *disk_key;\n\t\t\tu8 type;\n\t\t\tu32 item_offset;\n\t\t\tu32 item_size;\n\n\t\t\tif (disk_item_offset + sizeof(struct btrfs_item) >\n\t\t\t    sf->block_ctx->len) {\nleaf_item_out_of_bounce_error:\n\t\t\t\tprintk(KERN_INFO\n\t\t\t\t       \"btrfsic: leaf item out of bounce at logical %llu, dev %s\\n\",\n\t\t\t\t       sf->block_ctx->start,\n\t\t\t\t       sf->block_ctx->dev->name);\n\t\t\t\tgoto one_stack_frame_backwards;\n\t\t\t}\n\t\t\tbtrfsic_read_from_block_data(sf->block_ctx,\n\t\t\t\t\t\t     &disk_item,\n\t\t\t\t\t\t     disk_item_offset,\n\t\t\t\t\t\t     sizeof(struct btrfs_item));\n\t\t\titem_offset = btrfs_stack_item_offset(&disk_item);\n\t\t\titem_size = btrfs_stack_item_size(&disk_item);\n\t\t\tdisk_key = &disk_item.key;\n\t\t\ttype = btrfs_disk_key_type(disk_key);\n\n\t\t\tif (BTRFS_ROOT_ITEM_KEY == type) {\n\t\t\t\tstruct btrfs_root_item root_item;\n\t\t\t\tu32 root_item_offset;\n\t\t\t\tu64 next_bytenr;\n\n\t\t\t\troot_item_offset = item_offset +\n\t\t\t\t\toffsetof(struct btrfs_leaf, items);\n\t\t\t\tif (root_item_offset + item_size >\n\t\t\t\t    sf->block_ctx->len)\n\t\t\t\t\tgoto leaf_item_out_of_bounce_error;\n\t\t\t\tbtrfsic_read_from_block_data(\n\t\t\t\t\tsf->block_ctx, &root_item,\n\t\t\t\t\troot_item_offset,\n\t\t\t\t\titem_size);\n\t\t\t\tnext_bytenr = btrfs_root_bytenr(&root_item);\n\n\t\t\t\tsf->error =\n\t\t\t\t    btrfsic_create_link_to_next_block(\n\t\t\t\t\t\tstate,\n\t\t\t\t\t\tsf->block,\n\t\t\t\t\t\tsf->block_ctx,\n\t\t\t\t\t\tnext_bytenr,\n\t\t\t\t\t\tsf->limit_nesting,\n\t\t\t\t\t\t&sf->next_block_ctx,\n\t\t\t\t\t\t&sf->next_block,\n\t\t\t\t\t\tforce_iodone_flag,\n\t\t\t\t\t\t&sf->num_copies,\n\t\t\t\t\t\t&sf->mirror_num,\n\t\t\t\t\t\tdisk_key,\n\t\t\t\t\t\tbtrfs_root_generation(\n\t\t\t\t\t\t&root_item));\n\t\t\t\tif (sf->error)\n\t\t\t\t\tgoto one_stack_frame_backwards;\n\n\t\t\t\tif (NULL != sf->next_block) {\n\t\t\t\t\tstruct btrfs_header *const next_hdr =\n\t\t\t\t\t    (struct btrfs_header *)\n\t\t\t\t\t    sf->next_block_ctx.datav[0];\n\n\t\t\t\t\tnext_stack =\n\t\t\t\t\t    btrfsic_stack_frame_alloc();\n\t\t\t\t\tif (NULL == next_stack) {\n\t\t\t\t\t\tsf->error = -1;\n\t\t\t\t\t\tbtrfsic_release_block_ctx(\n\t\t\t\t\t\t\t\t&sf->\n\t\t\t\t\t\t\t\tnext_block_ctx);\n\t\t\t\t\t\tgoto one_stack_frame_backwards;\n\t\t\t\t\t}\n\n\t\t\t\t\tnext_stack->i = -1;\n\t\t\t\t\tnext_stack->block = sf->next_block;\n\t\t\t\t\tnext_stack->block_ctx =\n\t\t\t\t\t    &sf->next_block_ctx;\n\t\t\t\t\tnext_stack->next_block = NULL;\n\t\t\t\t\tnext_stack->hdr = next_hdr;\n\t\t\t\t\tnext_stack->limit_nesting =\n\t\t\t\t\t    sf->limit_nesting - 1;\n\t\t\t\t\tnext_stack->prev = sf;\n\t\t\t\t\tsf = next_stack;\n\t\t\t\t\tgoto continue_with_new_stack_frame;\n\t\t\t\t}\n\t\t\t} else if (BTRFS_EXTENT_DATA_KEY == type &&\n\t\t\t\t   state->include_extent_data) {\n\t\t\t\tsf->error = btrfsic_handle_extent_data(\n\t\t\t\t\t\tstate,\n\t\t\t\t\t\tsf->block,\n\t\t\t\t\t\tsf->block_ctx,\n\t\t\t\t\t\titem_offset,\n\t\t\t\t\t\tforce_iodone_flag);\n\t\t\t\tif (sf->error)\n\t\t\t\t\tgoto one_stack_frame_backwards;\n\t\t\t}\n\n\t\t\tgoto continue_with_current_leaf_stack_frame;\n\t\t}\n\t} else {\n\t\tstruct btrfs_node *const nodehdr = (struct btrfs_node *)sf->hdr;\n\n\t\tif (-1 == sf->i) {\n\t\t\tsf->nr = btrfs_stack_header_nritems(&nodehdr->header);\n\n\t\t\tif (state->print_mask & BTRFSIC_PRINT_MASK_VERBOSE)\n\t\t\t\tprintk(KERN_INFO \"node %llu level %d items %d\"\n\t\t\t\t       \" generation %llu owner %llu\\n\",\n\t\t\t\t       sf->block_ctx->start,\n\t\t\t\t       nodehdr->header.level, sf->nr,\n\t\t\t\t       btrfs_stack_header_generation(\n\t\t\t\t       &nodehdr->header),\n\t\t\t\t       btrfs_stack_header_owner(\n\t\t\t\t       &nodehdr->header));\n\t\t}\n\ncontinue_with_current_node_stack_frame:\n\t\tif (0 == sf->num_copies || sf->mirror_num > sf->num_copies) {\n\t\t\tsf->i++;\n\t\t\tsf->num_copies = 0;\n\t\t}\n\n\t\tif (sf->i < sf->nr) {\n\t\t\tstruct btrfs_key_ptr key_ptr;\n\t\t\tu32 key_ptr_offset;\n\t\t\tu64 next_bytenr;\n\n\t\t\tkey_ptr_offset = (uintptr_t)(nodehdr->ptrs + sf->i) -\n\t\t\t\t\t  (uintptr_t)nodehdr;\n\t\t\tif (key_ptr_offset + sizeof(struct btrfs_key_ptr) >\n\t\t\t    sf->block_ctx->len) {\n\t\t\t\tprintk(KERN_INFO\n\t\t\t\t       \"btrfsic: node item out of bounce at logical %llu, dev %s\\n\",\n\t\t\t\t       sf->block_ctx->start,\n\t\t\t\t       sf->block_ctx->dev->name);\n\t\t\t\tgoto one_stack_frame_backwards;\n\t\t\t}\n\t\t\tbtrfsic_read_from_block_data(\n\t\t\t\tsf->block_ctx, &key_ptr, key_ptr_offset,\n\t\t\t\tsizeof(struct btrfs_key_ptr));\n\t\t\tnext_bytenr = btrfs_stack_key_blockptr(&key_ptr);\n\n\t\t\tsf->error = btrfsic_create_link_to_next_block(\n\t\t\t\t\tstate,\n\t\t\t\t\tsf->block,\n\t\t\t\t\tsf->block_ctx,\n\t\t\t\t\tnext_bytenr,\n\t\t\t\t\tsf->limit_nesting,\n\t\t\t\t\t&sf->next_block_ctx,\n\t\t\t\t\t&sf->next_block,\n\t\t\t\t\tforce_iodone_flag,\n\t\t\t\t\t&sf->num_copies,\n\t\t\t\t\t&sf->mirror_num,\n\t\t\t\t\t&key_ptr.key,\n\t\t\t\t\tbtrfs_stack_key_generation(&key_ptr));\n\t\t\tif (sf->error)\n\t\t\t\tgoto one_stack_frame_backwards;\n\n\t\t\tif (NULL != sf->next_block) {\n\t\t\t\tstruct btrfs_header *const next_hdr =\n\t\t\t\t    (struct btrfs_header *)\n\t\t\t\t    sf->next_block_ctx.datav[0];\n\n\t\t\t\tnext_stack = btrfsic_stack_frame_alloc();\n\t\t\t\tif (NULL == next_stack) {\n\t\t\t\t\tsf->error = -1;\n\t\t\t\t\tgoto one_stack_frame_backwards;\n\t\t\t\t}\n\n\t\t\t\tnext_stack->i = -1;\n\t\t\t\tnext_stack->block = sf->next_block;\n\t\t\t\tnext_stack->block_ctx = &sf->next_block_ctx;\n\t\t\t\tnext_stack->next_block = NULL;\n\t\t\t\tnext_stack->hdr = next_hdr;\n\t\t\t\tnext_stack->limit_nesting =\n\t\t\t\t    sf->limit_nesting - 1;\n\t\t\t\tnext_stack->prev = sf;\n\t\t\t\tsf = next_stack;\n\t\t\t\tgoto continue_with_new_stack_frame;\n\t\t\t}\n\n\t\t\tgoto continue_with_current_node_stack_frame;\n\t\t}\n\t}\n\none_stack_frame_backwards:\n\tif (NULL != sf->prev) {\n\t\tstruct btrfsic_stack_frame *const prev = sf->prev;\n\n\t\t/* the one for the initial block is freed in the caller */\n\t\tbtrfsic_release_block_ctx(sf->block_ctx);\n\n\t\tif (sf->error) {\n\t\t\tprev->error = sf->error;\n\t\t\tbtrfsic_stack_frame_free(sf);\n\t\t\tsf = prev;\n\t\t\tgoto one_stack_frame_backwards;\n\t\t}\n\n\t\tbtrfsic_stack_frame_free(sf);\n\t\tsf = prev;\n\t\tgoto continue_with_new_stack_frame;\n\t} else {\n\t\tBUG_ON(&initial_stack_frame != sf);\n\t}\n\n\treturn sf->error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfsic_block_hashtable_add",
          "args": [
            "block",
            "&state->block_hashtable"
          ],
          "line": 2188
        },
        "resolved": true,
        "details": {
          "function_name": "btrfsic_block_hashtable_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/check-integrity.c",
          "lines": "509-518",
          "snippet": "static void btrfsic_block_hashtable_add(struct btrfsic_block *b,\n\t\t\t\t\tstruct btrfsic_block_hashtable *h)\n{\n\tconst unsigned int hashval =\n\t    (((unsigned int)(b->dev_bytenr >> 16)) ^\n\t     ((unsigned int)((uintptr_t)b->dev_state->bdev))) &\n\t     (BTRFSIC_BLOCK_HASHTABLE_SIZE - 1);\n\n\tlist_add(&b->collision_resolving_node, h->table + hashval);\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"extent_io.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/genhd.h>",
            "#include <linux/mutex.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define BTRFSIC_BLOCK_HASHTABLE_SIZE 0x10000"
          ],
          "globals_used": [
            "static void btrfsic_block_init(struct btrfsic_block *b);",
            "static void btrfsic_block_free(struct btrfsic_block *b);",
            "static void btrfsic_block_hashtable_init(struct btrfsic_block_hashtable *h);",
            "static void btrfsic_block_hashtable_add(struct btrfsic_block *b,\n\t\t\t\t\tstruct btrfsic_block_hashtable *h);",
            "static void btrfsic_block_hashtable_remove(struct btrfsic_block *b);",
            "static struct btrfsic_block *btrfsic_block_hashtable_lookup(\n\t\tstruct block_device *bdev,\n\t\tu64 dev_bytenr,\n\t\tstruct btrfsic_block_hashtable *h);",
            "static void btrfsic_block_link_hashtable_init(\n\t\tstruct btrfsic_block_link_hashtable *h);",
            "static void btrfsic_block_link_hashtable_add(\n\t\tstruct btrfsic_block_link *l,\n\t\tstruct btrfsic_block_link_hashtable *h);",
            "static struct btrfsic_block_link *btrfsic_block_link_hashtable_lookup(\n\t\tstruct block_device *bdev_ref_to,\n\t\tu64 dev_bytenr_ref_to,\n\t\tstruct block_device *bdev_ref_from,\n\t\tu64 dev_bytenr_ref_from,\n\t\tstruct btrfsic_block_link_hashtable *h);",
            "static void btrfsic_dev_state_hashtable_init(\n\t\tstruct btrfsic_dev_state_hashtable *h);",
            "static void btrfsic_dev_state_hashtable_add(\n\t\tstruct btrfsic_dev_state *ds,\n\t\tstruct btrfsic_dev_state_hashtable *h);",
            "static struct btrfsic_dev_state *btrfsic_dev_state_hashtable_lookup(\n\t\tstruct block_device *bdev,\n\t\tstruct btrfsic_dev_state_hashtable *h);",
            "static struct btrfsic_dev_state *btrfsic_dev_state_lookup(\n\t\tstruct block_device *bdev);",
            "static void btrfsic_cmp_log_and_dev_bytenr(struct btrfsic_state *state,\n\t\t\t\t\t   u64 bytenr,\n\t\t\t\t\t   struct btrfsic_dev_state *dev_state,\n\t\t\t\t\t   u64 dev_bytenr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"extent_io.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n#include <linux/blkdev.h>\n#include <linux/genhd.h>\n#include <linux/mutex.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\n#define BTRFSIC_BLOCK_HASHTABLE_SIZE 0x10000\n\nstatic void btrfsic_block_init(struct btrfsic_block *b);\nstatic void btrfsic_block_free(struct btrfsic_block *b);\nstatic void btrfsic_block_hashtable_init(struct btrfsic_block_hashtable *h);\nstatic void btrfsic_block_hashtable_add(struct btrfsic_block *b,\n\t\t\t\t\tstruct btrfsic_block_hashtable *h);\nstatic void btrfsic_block_hashtable_remove(struct btrfsic_block *b);\nstatic struct btrfsic_block *btrfsic_block_hashtable_lookup(\n\t\tstruct block_device *bdev,\n\t\tu64 dev_bytenr,\n\t\tstruct btrfsic_block_hashtable *h);\nstatic void btrfsic_block_link_hashtable_init(\n\t\tstruct btrfsic_block_link_hashtable *h);\nstatic void btrfsic_block_link_hashtable_add(\n\t\tstruct btrfsic_block_link *l,\n\t\tstruct btrfsic_block_link_hashtable *h);\nstatic struct btrfsic_block_link *btrfsic_block_link_hashtable_lookup(\n\t\tstruct block_device *bdev_ref_to,\n\t\tu64 dev_bytenr_ref_to,\n\t\tstruct block_device *bdev_ref_from,\n\t\tu64 dev_bytenr_ref_from,\n\t\tstruct btrfsic_block_link_hashtable *h);\nstatic void btrfsic_dev_state_hashtable_init(\n\t\tstruct btrfsic_dev_state_hashtable *h);\nstatic void btrfsic_dev_state_hashtable_add(\n\t\tstruct btrfsic_dev_state *ds,\n\t\tstruct btrfsic_dev_state_hashtable *h);\nstatic struct btrfsic_dev_state *btrfsic_dev_state_hashtable_lookup(\n\t\tstruct block_device *bdev,\n\t\tstruct btrfsic_dev_state_hashtable *h);\nstatic struct btrfsic_dev_state *btrfsic_dev_state_lookup(\n\t\tstruct block_device *bdev);\nstatic void btrfsic_cmp_log_and_dev_bytenr(struct btrfsic_state *state,\n\t\t\t\t\t   u64 bytenr,\n\t\t\t\t\t   struct btrfsic_dev_state *dev_state,\n\t\t\t\t\t   u64 dev_bytenr);\n\nstatic void btrfsic_block_hashtable_add(struct btrfsic_block *b,\n\t\t\t\t\tstruct btrfsic_block_hashtable *h)\n{\n\tconst unsigned int hashval =\n\t    (((unsigned int)(b->dev_bytenr >> 16)) ^\n\t     ((unsigned int)((uintptr_t)b->dev_state->bdev))) &\n\t     (BTRFSIC_BLOCK_HASHTABLE_SIZE - 1);\n\n\tlist_add(&b->collision_resolving_node, h->table + hashval);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&block->all_blocks_node",
            "&state->all_blocks_list"
          ],
          "line": 2187
        },
        "resolved": true,
        "details": {
          "function_name": "simple_xattr_list_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "966-972",
          "snippet": "void simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "NULL == chained_block"
          ],
          "line": 2160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "NULL == bio_is_patched"
          ],
          "line": 2147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_INFO \"btrfsic: error, kmalloc failed!\\n\""
          ],
          "line": 2132
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfsic_block_alloc",
          "args": [],
          "line": 2130
        },
        "resolved": true,
        "details": {
          "function_name": "btrfsic_block_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/check-integrity.c",
          "lines": "425-434",
          "snippet": "static struct btrfsic_block *btrfsic_block_alloc(void)\n{\n\tstruct btrfsic_block *b;\n\n\tb = kzalloc(sizeof(*b), GFP_NOFS);\n\tif (NULL != b)\n\t\tbtrfsic_block_init(b);\n\n\treturn b;\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"extent_io.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/genhd.h>",
            "#include <linux/mutex.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void btrfsic_block_init(struct btrfsic_block *b);",
            "static struct btrfsic_block *btrfsic_block_alloc(void);",
            "static void btrfsic_block_free(struct btrfsic_block *b);",
            "static void btrfsic_block_hashtable_remove(struct btrfsic_block *b);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"extent_io.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n#include <linux/blkdev.h>\n#include <linux/genhd.h>\n#include <linux/mutex.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic void btrfsic_block_init(struct btrfsic_block *b);\nstatic struct btrfsic_block *btrfsic_block_alloc(void);\nstatic void btrfsic_block_free(struct btrfsic_block *b);\nstatic void btrfsic_block_hashtable_remove(struct btrfsic_block *b);\n\nstatic struct btrfsic_block *btrfsic_block_alloc(void)\n{\n\tstruct btrfsic_block *b;\n\n\tb = kzalloc(sizeof(*b), GFP_NOFS);\n\tif (NULL != b)\n\t\tbtrfsic_block_init(b);\n\n\treturn b;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfsic_cmp_log_and_dev_bytenr",
          "args": [
            "state",
            "bytenr",
            "dev_state",
            "dev_bytenr"
          ],
          "line": 2113
        },
        "resolved": true,
        "details": {
          "function_name": "btrfsic_cmp_log_and_dev_bytenr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/check-integrity.c",
          "lines": "2836-2888",
          "snippet": "static void btrfsic_cmp_log_and_dev_bytenr(struct btrfsic_state *state,\n\t\t\t\t\t   u64 bytenr,\n\t\t\t\t\t   struct btrfsic_dev_state *dev_state,\n\t\t\t\t\t   u64 dev_bytenr)\n{\n\tint num_copies;\n\tint mirror_num;\n\tint ret;\n\tstruct btrfsic_block_data_ctx block_ctx;\n\tint match = 0;\n\n\tnum_copies = btrfs_num_copies(state->root->fs_info,\n\t\t\t\t      bytenr, state->metablock_size);\n\n\tfor (mirror_num = 1; mirror_num <= num_copies; mirror_num++) {\n\t\tret = btrfsic_map_block(state, bytenr, state->metablock_size,\n\t\t\t\t\t&block_ctx, mirror_num);\n\t\tif (ret) {\n\t\t\tprintk(KERN_INFO \"btrfsic:\"\n\t\t\t       \" btrfsic_map_block(logical @%llu,\"\n\t\t\t       \" mirror %d) failed!\\n\",\n\t\t\t       bytenr, mirror_num);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (dev_state->bdev == block_ctx.dev->bdev &&\n\t\t    dev_bytenr == block_ctx.dev_bytenr) {\n\t\t\tmatch++;\n\t\t\tbtrfsic_release_block_ctx(&block_ctx);\n\t\t\tbreak;\n\t\t}\n\t\tbtrfsic_release_block_ctx(&block_ctx);\n\t}\n\n\tif (WARN_ON(!match)) {\n\t\tprintk(KERN_INFO \"btrfs: attempt to write M-block which contains logical bytenr that doesn't map to dev+physical bytenr of submit_bio,\"\n\t\t       \" buffer->log_bytenr=%llu, submit_bio(bdev=%s,\"\n\t\t       \" phys_bytenr=%llu)!\\n\",\n\t\t       bytenr, dev_state->name, dev_bytenr);\n\t\tfor (mirror_num = 1; mirror_num <= num_copies; mirror_num++) {\n\t\t\tret = btrfsic_map_block(state, bytenr,\n\t\t\t\t\t\tstate->metablock_size,\n\t\t\t\t\t\t&block_ctx, mirror_num);\n\t\t\tif (ret)\n\t\t\t\tcontinue;\n\n\t\t\tprintk(KERN_INFO \"Read logical bytenr @%llu maps to\"\n\t\t\t       \" (%s/%llu/%d)\\n\",\n\t\t\t       bytenr, block_ctx.dev->name,\n\t\t\t       block_ctx.dev_bytenr, mirror_num);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"extent_io.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/genhd.h>",
            "#include <linux/mutex.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void btrfsic_block_link_init(struct btrfsic_block_link *n);",
            "static void btrfsic_block_link_free(struct btrfsic_block_link *n);",
            "static int btrfsic_map_block(struct btrfsic_state *state, u64 bytenr, u32 len,\n\t\t\t     struct btrfsic_block_data_ctx *block_ctx_out,\n\t\t\t     int mirror_num);",
            "static void btrfsic_release_block_ctx(struct btrfsic_block_data_ctx *block_ctx);",
            "static int btrfsic_read_block(struct btrfsic_state *state,\n\t\t\t      struct btrfsic_block_data_ctx *block_ctx);",
            "static void btrfsic_dump_database(struct btrfsic_state *state);",
            "static char btrfsic_get_block_type(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block *block);",
            "static void btrfsic_dump_tree(const struct btrfsic_state *state);",
            "static struct btrfsic_dev_state *btrfsic_dev_state_lookup(\n\t\tstruct block_device *bdev);",
            "static void btrfsic_cmp_log_and_dev_bytenr(struct btrfsic_state *state,\n\t\t\t\t\t   u64 bytenr,\n\t\t\t\t\t   struct btrfsic_dev_state *dev_state,\n\t\t\t\t\t   u64 dev_bytenr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"extent_io.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n#include <linux/blkdev.h>\n#include <linux/genhd.h>\n#include <linux/mutex.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic void btrfsic_block_link_init(struct btrfsic_block_link *n);\nstatic void btrfsic_block_link_free(struct btrfsic_block_link *n);\nstatic int btrfsic_map_block(struct btrfsic_state *state, u64 bytenr, u32 len,\n\t\t\t     struct btrfsic_block_data_ctx *block_ctx_out,\n\t\t\t     int mirror_num);\nstatic void btrfsic_release_block_ctx(struct btrfsic_block_data_ctx *block_ctx);\nstatic int btrfsic_read_block(struct btrfsic_state *state,\n\t\t\t      struct btrfsic_block_data_ctx *block_ctx);\nstatic void btrfsic_dump_database(struct btrfsic_state *state);\nstatic char btrfsic_get_block_type(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block *block);\nstatic void btrfsic_dump_tree(const struct btrfsic_state *state);\nstatic struct btrfsic_dev_state *btrfsic_dev_state_lookup(\n\t\tstruct block_device *bdev);\nstatic void btrfsic_cmp_log_and_dev_bytenr(struct btrfsic_state *state,\n\t\t\t\t\t   u64 bytenr,\n\t\t\t\t\t   struct btrfsic_dev_state *dev_state,\n\t\t\t\t\t   u64 dev_bytenr);\n\nstatic void btrfsic_cmp_log_and_dev_bytenr(struct btrfsic_state *state,\n\t\t\t\t\t   u64 bytenr,\n\t\t\t\t\t   struct btrfsic_dev_state *dev_state,\n\t\t\t\t\t   u64 dev_bytenr)\n{\n\tint num_copies;\n\tint mirror_num;\n\tint ret;\n\tstruct btrfsic_block_data_ctx block_ctx;\n\tint match = 0;\n\n\tnum_copies = btrfs_num_copies(state->root->fs_info,\n\t\t\t\t      bytenr, state->metablock_size);\n\n\tfor (mirror_num = 1; mirror_num <= num_copies; mirror_num++) {\n\t\tret = btrfsic_map_block(state, bytenr, state->metablock_size,\n\t\t\t\t\t&block_ctx, mirror_num);\n\t\tif (ret) {\n\t\t\tprintk(KERN_INFO \"btrfsic:\"\n\t\t\t       \" btrfsic_map_block(logical @%llu,\"\n\t\t\t       \" mirror %d) failed!\\n\",\n\t\t\t       bytenr, mirror_num);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (dev_state->bdev == block_ctx.dev->bdev &&\n\t\t    dev_bytenr == block_ctx.dev_bytenr) {\n\t\t\tmatch++;\n\t\t\tbtrfsic_release_block_ctx(&block_ctx);\n\t\t\tbreak;\n\t\t}\n\t\tbtrfsic_release_block_ctx(&block_ctx);\n\t}\n\n\tif (WARN_ON(!match)) {\n\t\tprintk(KERN_INFO \"btrfs: attempt to write M-block which contains logical bytenr that doesn't map to dev+physical bytenr of submit_bio,\"\n\t\t       \" buffer->log_bytenr=%llu, submit_bio(bdev=%s,\"\n\t\t       \" phys_bytenr=%llu)!\\n\",\n\t\t       bytenr, dev_state->name, dev_bytenr);\n\t\tfor (mirror_num = 1; mirror_num <= num_copies; mirror_num++) {\n\t\t\tret = btrfsic_map_block(state, bytenr,\n\t\t\t\t\t\tstate->metablock_size,\n\t\t\t\t\t\t&block_ctx, mirror_num);\n\t\t\tif (ret)\n\t\t\t\tcontinue;\n\n\t\t\tprintk(KERN_INFO \"Read logical bytenr @%llu maps to\"\n\t\t\t       \" (%s/%llu/%d)\\n\",\n\t\t\t       bytenr, block_ctx.dev->name,\n\t\t\t       block_ctx.dev_bytenr, mirror_num);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_stack_header_bytenr",
          "args": [
            "(struct btrfs_header *)\n\t\t\t\t\tmapped_datav[0]"
          ],
          "line": 2110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfsic_block_free",
          "args": [
            "block"
          ],
          "line": 2086
        },
        "resolved": true,
        "details": {
          "function_name": "btrfsic_block_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/check-integrity.c",
          "lines": "436-440",
          "snippet": "static void btrfsic_block_free(struct btrfsic_block *b)\n{\n\tBUG_ON(!(NULL == b || BTRFSIC_BLOCK_MAGIC_NUMBER == b->magic_num));\n\tkfree(b);\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"extent_io.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/genhd.h>",
            "#include <linux/mutex.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define BTRFSIC_BLOCK_MAGIC_NUMBER 0x14491051"
          ],
          "globals_used": [
            "static void btrfsic_block_init(struct btrfsic_block *b);",
            "static void btrfsic_block_free(struct btrfsic_block *b);",
            "static void btrfsic_block_hashtable_remove(struct btrfsic_block *b);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"extent_io.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n#include <linux/blkdev.h>\n#include <linux/genhd.h>\n#include <linux/mutex.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\n#define BTRFSIC_BLOCK_MAGIC_NUMBER 0x14491051\n\nstatic void btrfsic_block_init(struct btrfsic_block *b);\nstatic void btrfsic_block_free(struct btrfsic_block *b);\nstatic void btrfsic_block_hashtable_remove(struct btrfsic_block *b);\n\nstatic void btrfsic_block_free(struct btrfsic_block *b)\n{\n\tBUG_ON(!(NULL == b || BTRFSIC_BLOCK_MAGIC_NUMBER == b->magic_num));\n\tkfree(b);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&block->all_blocks_node"
          ],
          "line": 2085
        },
        "resolved": true,
        "details": {
          "function_name": "inode_sb_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "433-440",
          "snippet": "static inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\n__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfsic_block_hashtable_remove",
          "args": [
            "block"
          ],
          "line": 2084
        },
        "resolved": true,
        "details": {
          "function_name": "btrfsic_block_hashtable_remove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/check-integrity.c",
          "lines": "520-523",
          "snippet": "static void btrfsic_block_hashtable_remove(struct btrfsic_block *b)\n{\n\tlist_del(&b->collision_resolving_node);\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"extent_io.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/genhd.h>",
            "#include <linux/mutex.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void btrfsic_block_init(struct btrfsic_block *b);",
            "static void btrfsic_block_free(struct btrfsic_block *b);",
            "static void btrfsic_block_hashtable_remove(struct btrfsic_block *b);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"extent_io.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n#include <linux/blkdev.h>\n#include <linux/genhd.h>\n#include <linux/mutex.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic void btrfsic_block_init(struct btrfsic_block *b);\nstatic void btrfsic_block_free(struct btrfsic_block *b);\nstatic void btrfsic_block_hashtable_remove(struct btrfsic_block *b);\n\nstatic void btrfsic_block_hashtable_remove(struct btrfsic_block *b)\n{\n\tlist_del(&b->collision_resolving_node);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&block->ref_from_list"
          ],
          "line": 2077
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfsic_dump_tree_sub",
          "args": [
            "state",
            "block",
            "0"
          ],
          "line": 2057
        },
        "resolved": true,
        "details": {
          "function_name": "btrfsic_dump_tree_sub",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/check-integrity.c",
          "lines": "2668-2733",
          "snippet": "static void btrfsic_dump_tree_sub(const struct btrfsic_state *state,\n\t\t\t\t  const struct btrfsic_block *block,\n\t\t\t\t  int indent_level)\n{\n\tstruct list_head *elem_ref_to;\n\tint indent_add;\n\tstatic char buf[80];\n\tint cursor_position;\n\n\t/*\n\t * Should better fill an on-stack buffer with a complete line and\n\t * dump it at once when it is time to print a newline character.\n\t */\n\n\t/*\n\t * This algorithm is recursive because the amount of used stack space\n\t * is very small and the max recursion depth is limited.\n\t */\n\tindent_add = sprintf(buf, \"%c-%llu(%s/%llu/%d)\",\n\t\t\t     btrfsic_get_block_type(state, block),\n\t\t\t     block->logical_bytenr, block->dev_state->name,\n\t\t\t     block->dev_bytenr, block->mirror_num);\n\tif (indent_level + indent_add > BTRFSIC_TREE_DUMP_MAX_INDENT_LEVEL) {\n\t\tprintk(\"[...]\\n\");\n\t\treturn;\n\t}\n\tprintk(buf);\n\tindent_level += indent_add;\n\tif (list_empty(&block->ref_to_list)) {\n\t\tprintk(\"\\n\");\n\t\treturn;\n\t}\n\tif (block->mirror_num > 1 &&\n\t    !(state->print_mask & BTRFSIC_PRINT_MASK_TREE_WITH_ALL_MIRRORS)) {\n\t\tprintk(\" [...]\\n\");\n\t\treturn;\n\t}\n\n\tcursor_position = indent_level;\n\tlist_for_each(elem_ref_to, &block->ref_to_list) {\n\t\tconst struct btrfsic_block_link *const l =\n\t\t    list_entry(elem_ref_to, struct btrfsic_block_link,\n\t\t\t       node_ref_to);\n\n\t\twhile (cursor_position < indent_level) {\n\t\t\tprintk(\" \");\n\t\t\tcursor_position++;\n\t\t}\n\t\tif (l->ref_cnt > 1)\n\t\t\tindent_add = sprintf(buf, \" %d*--> \", l->ref_cnt);\n\t\telse\n\t\t\tindent_add = sprintf(buf, \" --> \");\n\t\tif (indent_level + indent_add >\n\t\t    BTRFSIC_TREE_DUMP_MAX_INDENT_LEVEL) {\n\t\t\tprintk(\"[...]\\n\");\n\t\t\tcursor_position = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\tprintk(buf);\n\n\t\tbtrfsic_dump_tree_sub(state, l->block_ref_to,\n\t\t\t\t      indent_level + indent_add);\n\t\tcursor_position = 0;\n\t}\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"extent_io.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/genhd.h>",
            "#include <linux/mutex.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define BTRFSIC_PRINT_MASK_TREE_WITH_ALL_MIRRORS\t\t0x00001000",
            "#define BTRFSIC_TREE_DUMP_MAX_INDENT_LEVEL (200 - 6)\t/* in characters,\n\t\t\t\t\t\t\t * excluding \" [...]\" */"
          ],
          "globals_used": [
            "static void btrfsic_block_link_init(struct btrfsic_block_link *n);",
            "static void btrfsic_block_link_free(struct btrfsic_block_link *n);",
            "static void btrfsic_block_link_hashtable_remove(struct btrfsic_block_link *l);",
            "static int btrfsic_map_block(struct btrfsic_state *state, u64 bytenr, u32 len,\n\t\t\t     struct btrfsic_block_data_ctx *block_ctx_out,\n\t\t\t     int mirror_num);",
            "static void btrfsic_dump_database(struct btrfsic_state *state);",
            "static void btrfsic_print_add_link(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block_link *l);",
            "static void btrfsic_print_rem_link(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block_link *l);",
            "static char btrfsic_get_block_type(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block *block);",
            "static void btrfsic_dump_tree(const struct btrfsic_state *state);",
            "static void btrfsic_dump_tree_sub(const struct btrfsic_state *state,\n\t\t\t\t  const struct btrfsic_block *block,\n\t\t\t\t  int indent_level);",
            "static void btrfsic_cmp_log_and_dev_bytenr(struct btrfsic_state *state,\n\t\t\t\t\t   u64 bytenr,\n\t\t\t\t\t   struct btrfsic_dev_state *dev_state,\n\t\t\t\t\t   u64 dev_bytenr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"extent_io.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n#include <linux/blkdev.h>\n#include <linux/genhd.h>\n#include <linux/mutex.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\n#define BTRFSIC_PRINT_MASK_TREE_WITH_ALL_MIRRORS\t\t0x00001000\n#define BTRFSIC_TREE_DUMP_MAX_INDENT_LEVEL (200 - 6)\t/* in characters,\n\t\t\t\t\t\t\t * excluding \" [...]\" */\n\nstatic void btrfsic_block_link_init(struct btrfsic_block_link *n);\nstatic void btrfsic_block_link_free(struct btrfsic_block_link *n);\nstatic void btrfsic_block_link_hashtable_remove(struct btrfsic_block_link *l);\nstatic int btrfsic_map_block(struct btrfsic_state *state, u64 bytenr, u32 len,\n\t\t\t     struct btrfsic_block_data_ctx *block_ctx_out,\n\t\t\t     int mirror_num);\nstatic void btrfsic_dump_database(struct btrfsic_state *state);\nstatic void btrfsic_print_add_link(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block_link *l);\nstatic void btrfsic_print_rem_link(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block_link *l);\nstatic char btrfsic_get_block_type(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block *block);\nstatic void btrfsic_dump_tree(const struct btrfsic_state *state);\nstatic void btrfsic_dump_tree_sub(const struct btrfsic_state *state,\n\t\t\t\t  const struct btrfsic_block *block,\n\t\t\t\t  int indent_level);\nstatic void btrfsic_cmp_log_and_dev_bytenr(struct btrfsic_state *state,\n\t\t\t\t\t   u64 bytenr,\n\t\t\t\t\t   struct btrfsic_dev_state *dev_state,\n\t\t\t\t\t   u64 dev_bytenr);\n\nstatic void btrfsic_dump_tree_sub(const struct btrfsic_state *state,\n\t\t\t\t  const struct btrfsic_block *block,\n\t\t\t\t  int indent_level)\n{\n\tstruct list_head *elem_ref_to;\n\tint indent_add;\n\tstatic char buf[80];\n\tint cursor_position;\n\n\t/*\n\t * Should better fill an on-stack buffer with a complete line and\n\t * dump it at once when it is time to print a newline character.\n\t */\n\n\t/*\n\t * This algorithm is recursive because the amount of used stack space\n\t * is very small and the max recursion depth is limited.\n\t */\n\tindent_add = sprintf(buf, \"%c-%llu(%s/%llu/%d)\",\n\t\t\t     btrfsic_get_block_type(state, block),\n\t\t\t     block->logical_bytenr, block->dev_state->name,\n\t\t\t     block->dev_bytenr, block->mirror_num);\n\tif (indent_level + indent_add > BTRFSIC_TREE_DUMP_MAX_INDENT_LEVEL) {\n\t\tprintk(\"[...]\\n\");\n\t\treturn;\n\t}\n\tprintk(buf);\n\tindent_level += indent_add;\n\tif (list_empty(&block->ref_to_list)) {\n\t\tprintk(\"\\n\");\n\t\treturn;\n\t}\n\tif (block->mirror_num > 1 &&\n\t    !(state->print_mask & BTRFSIC_PRINT_MASK_TREE_WITH_ALL_MIRRORS)) {\n\t\tprintk(\" [...]\\n\");\n\t\treturn;\n\t}\n\n\tcursor_position = indent_level;\n\tlist_for_each(elem_ref_to, &block->ref_to_list) {\n\t\tconst struct btrfsic_block_link *const l =\n\t\t    list_entry(elem_ref_to, struct btrfsic_block_link,\n\t\t\t       node_ref_to);\n\n\t\twhile (cursor_position < indent_level) {\n\t\t\tprintk(\" \");\n\t\t\tcursor_position++;\n\t\t}\n\t\tif (l->ref_cnt > 1)\n\t\t\tindent_add = sprintf(buf, \" %d*--> \", l->ref_cnt);\n\t\telse\n\t\t\tindent_add = sprintf(buf, \" --> \");\n\t\tif (indent_level + indent_add >\n\t\t    BTRFSIC_TREE_DUMP_MAX_INDENT_LEVEL) {\n\t\t\tprintk(\"[...]\\n\");\n\t\t\tcursor_position = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\tprintk(buf);\n\n\t\tbtrfsic_dump_tree_sub(state, l->block_ref_to,\n\t\t\t\t      indent_level + indent_add);\n\t\tcursor_position = 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfsic_process_written_superblock",
          "args": [
            "state",
            "block",
            "(struct btrfs_super_block *)\n\t\t\t\t\t\tmapped_datav[0]"
          ],
          "line": 2048
        },
        "resolved": true,
        "details": {
          "function_name": "btrfsic_process_written_superblock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/check-integrity.c",
          "lines": "2292-2433",
          "snippet": "static int btrfsic_process_written_superblock(\n\t\tstruct btrfsic_state *state,\n\t\tstruct btrfsic_block *const superblock,\n\t\tstruct btrfs_super_block *const super_hdr)\n{\n\tint pass;\n\n\tsuperblock->generation = btrfs_super_generation(super_hdr);\n\tif (!(superblock->generation > state->max_superblock_generation ||\n\t      0 == state->max_superblock_generation)) {\n\t\tif (state->print_mask & BTRFSIC_PRINT_MASK_SUPERBLOCK_WRITE)\n\t\t\tprintk(KERN_INFO\n\t\t\t       \"btrfsic: superblock @%llu (%s/%llu/%d)\"\n\t\t\t       \" with old gen %llu <= %llu\\n\",\n\t\t\t       superblock->logical_bytenr,\n\t\t\t       superblock->dev_state->name,\n\t\t\t       superblock->dev_bytenr, superblock->mirror_num,\n\t\t\t       btrfs_super_generation(super_hdr),\n\t\t\t       state->max_superblock_generation);\n\t} else {\n\t\tif (state->print_mask & BTRFSIC_PRINT_MASK_SUPERBLOCK_WRITE)\n\t\t\tprintk(KERN_INFO\n\t\t\t       \"btrfsic: got new superblock @%llu (%s/%llu/%d)\"\n\t\t\t       \" with new gen %llu > %llu\\n\",\n\t\t\t       superblock->logical_bytenr,\n\t\t\t       superblock->dev_state->name,\n\t\t\t       superblock->dev_bytenr, superblock->mirror_num,\n\t\t\t       btrfs_super_generation(super_hdr),\n\t\t\t       state->max_superblock_generation);\n\n\t\tstate->max_superblock_generation =\n\t\t    btrfs_super_generation(super_hdr);\n\t\tstate->latest_superblock = superblock;\n\t}\n\n\tfor (pass = 0; pass < 3; pass++) {\n\t\tint ret;\n\t\tu64 next_bytenr;\n\t\tstruct btrfsic_block *next_block;\n\t\tstruct btrfsic_block_data_ctx tmp_next_block_ctx;\n\t\tstruct btrfsic_block_link *l;\n\t\tint num_copies;\n\t\tint mirror_num;\n\t\tconst char *additional_string = NULL;\n\t\tstruct btrfs_disk_key tmp_disk_key = {0};\n\n\t\tbtrfs_set_disk_key_objectid(&tmp_disk_key,\n\t\t\t\t\t    BTRFS_ROOT_ITEM_KEY);\n\t\tbtrfs_set_disk_key_objectid(&tmp_disk_key, 0);\n\n\t\tswitch (pass) {\n\t\tcase 0:\n\t\t\tbtrfs_set_disk_key_objectid(&tmp_disk_key,\n\t\t\t\t\t\t    BTRFS_ROOT_TREE_OBJECTID);\n\t\t\tadditional_string = \"root \";\n\t\t\tnext_bytenr = btrfs_super_root(super_hdr);\n\t\t\tif (state->print_mask &\n\t\t\t    BTRFSIC_PRINT_MASK_ROOT_CHUNK_LOG_TREE_LOCATION)\n\t\t\t\tprintk(KERN_INFO \"root@%llu\\n\", next_bytenr);\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tbtrfs_set_disk_key_objectid(&tmp_disk_key,\n\t\t\t\t\t\t    BTRFS_CHUNK_TREE_OBJECTID);\n\t\t\tadditional_string = \"chunk \";\n\t\t\tnext_bytenr = btrfs_super_chunk_root(super_hdr);\n\t\t\tif (state->print_mask &\n\t\t\t    BTRFSIC_PRINT_MASK_ROOT_CHUNK_LOG_TREE_LOCATION)\n\t\t\t\tprintk(KERN_INFO \"chunk@%llu\\n\", next_bytenr);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tbtrfs_set_disk_key_objectid(&tmp_disk_key,\n\t\t\t\t\t\t    BTRFS_TREE_LOG_OBJECTID);\n\t\t\tadditional_string = \"log \";\n\t\t\tnext_bytenr = btrfs_super_log_root(super_hdr);\n\t\t\tif (0 == next_bytenr)\n\t\t\t\tcontinue;\n\t\t\tif (state->print_mask &\n\t\t\t    BTRFSIC_PRINT_MASK_ROOT_CHUNK_LOG_TREE_LOCATION)\n\t\t\t\tprintk(KERN_INFO \"log@%llu\\n\", next_bytenr);\n\t\t\tbreak;\n\t\t}\n\n\t\tnum_copies =\n\t\t    btrfs_num_copies(state->root->fs_info,\n\t\t\t\t     next_bytenr, BTRFS_SUPER_INFO_SIZE);\n\t\tif (state->print_mask & BTRFSIC_PRINT_MASK_NUM_COPIES)\n\t\t\tprintk(KERN_INFO \"num_copies(log_bytenr=%llu) = %d\\n\",\n\t\t\t       next_bytenr, num_copies);\n\t\tfor (mirror_num = 1; mirror_num <= num_copies; mirror_num++) {\n\t\t\tint was_created;\n\n\t\t\tif (state->print_mask & BTRFSIC_PRINT_MASK_VERBOSE)\n\t\t\t\tprintk(KERN_INFO\n\t\t\t\t       \"btrfsic_process_written_superblock(\"\n\t\t\t\t       \"mirror_num=%d)\\n\", mirror_num);\n\t\t\tret = btrfsic_map_block(state, next_bytenr,\n\t\t\t\t\t\tBTRFS_SUPER_INFO_SIZE,\n\t\t\t\t\t\t&tmp_next_block_ctx,\n\t\t\t\t\t\tmirror_num);\n\t\t\tif (ret) {\n\t\t\t\tprintk(KERN_INFO\n\t\t\t\t       \"btrfsic: btrfsic_map_block(@%llu,\"\n\t\t\t\t       \" mirror=%d) failed!\\n\",\n\t\t\t\t       next_bytenr, mirror_num);\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tnext_block = btrfsic_block_lookup_or_add(\n\t\t\t\t\tstate,\n\t\t\t\t\t&tmp_next_block_ctx,\n\t\t\t\t\tadditional_string,\n\t\t\t\t\t1, 0, 1,\n\t\t\t\t\tmirror_num,\n\t\t\t\t\t&was_created);\n\t\t\tif (NULL == next_block) {\n\t\t\t\tprintk(KERN_INFO\n\t\t\t\t       \"btrfsic: error, kmalloc failed!\\n\");\n\t\t\t\tbtrfsic_release_block_ctx(&tmp_next_block_ctx);\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tnext_block->disk_key = tmp_disk_key;\n\t\t\tif (was_created)\n\t\t\t\tnext_block->generation =\n\t\t\t\t    BTRFSIC_GENERATION_UNKNOWN;\n\t\t\tl = btrfsic_block_link_lookup_or_add(\n\t\t\t\t\tstate,\n\t\t\t\t\t&tmp_next_block_ctx,\n\t\t\t\t\tnext_block,\n\t\t\t\t\tsuperblock,\n\t\t\t\t\tBTRFSIC_GENERATION_UNKNOWN);\n\t\t\tbtrfsic_release_block_ctx(&tmp_next_block_ctx);\n\t\t\tif (NULL == l)\n\t\t\t\treturn -1;\n\t\t}\n\t}\n\n\tif (WARN_ON(-1 == btrfsic_check_all_ref_blocks(state, superblock, 0)))\n\t\tbtrfsic_dump_tree(state);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"extent_io.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/genhd.h>",
            "#include <linux/mutex.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define BTRFSIC_PRINT_MASK_NUM_COPIES\t\t\t\t0x00000800",
            "#define BTRFSIC_PRINT_MASK_VERBOSE\t\t\t\t0x00000040",
            "#define BTRFSIC_PRINT_MASK_ROOT_CHUNK_LOG_TREE_LOCATION\t\t0x00000002",
            "#define BTRFSIC_PRINT_MASK_SUPERBLOCK_WRITE\t\t\t0x00000001",
            "#define BTRFSIC_GENERATION_UNKNOWN ((u64)-1)"
          ],
          "globals_used": [
            "static void btrfsic_block_link_init(struct btrfsic_block_link *n);",
            "static void btrfsic_block_link_free(struct btrfsic_block_link *n);",
            "static void btrfsic_block_link_hashtable_remove(struct btrfsic_block_link *l);",
            "static int btrfsic_map_block(struct btrfsic_state *state, u64 bytenr, u32 len,\n\t\t\t     struct btrfsic_block_data_ctx *block_ctx_out,\n\t\t\t     int mirror_num);",
            "static void btrfsic_dump_database(struct btrfsic_state *state);",
            "static int btrfsic_process_written_superblock(\n\t\tstruct btrfsic_state *state,\n\t\tstruct btrfsic_block *const block,\n\t\tstruct btrfs_super_block *const super_hdr);",
            "static void btrfsic_print_add_link(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block_link *l);",
            "static void btrfsic_print_rem_link(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block_link *l);",
            "static void btrfsic_dump_tree(const struct btrfsic_state *state);",
            "static struct btrfsic_block *btrfsic_block_lookup_or_add(\n\t\tstruct btrfsic_state *state,\n\t\tstruct btrfsic_block_data_ctx *block_ctx,\n\t\tconst char *additional_string,\n\t\tint is_metadata,\n\t\tint is_iodone,\n\t\tint never_written,\n\t\tint mirror_num,\n\t\tint *was_created);",
            "static void btrfsic_cmp_log_and_dev_bytenr(struct btrfsic_state *state,\n\t\t\t\t\t   u64 bytenr,\n\t\t\t\t\t   struct btrfsic_dev_state *dev_state,\n\t\t\t\t\t   u64 dev_bytenr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"extent_io.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n#include <linux/blkdev.h>\n#include <linux/genhd.h>\n#include <linux/mutex.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\n#define BTRFSIC_PRINT_MASK_NUM_COPIES\t\t\t\t0x00000800\n#define BTRFSIC_PRINT_MASK_VERBOSE\t\t\t\t0x00000040\n#define BTRFSIC_PRINT_MASK_ROOT_CHUNK_LOG_TREE_LOCATION\t\t0x00000002\n#define BTRFSIC_PRINT_MASK_SUPERBLOCK_WRITE\t\t\t0x00000001\n#define BTRFSIC_GENERATION_UNKNOWN ((u64)-1)\n\nstatic void btrfsic_block_link_init(struct btrfsic_block_link *n);\nstatic void btrfsic_block_link_free(struct btrfsic_block_link *n);\nstatic void btrfsic_block_link_hashtable_remove(struct btrfsic_block_link *l);\nstatic int btrfsic_map_block(struct btrfsic_state *state, u64 bytenr, u32 len,\n\t\t\t     struct btrfsic_block_data_ctx *block_ctx_out,\n\t\t\t     int mirror_num);\nstatic void btrfsic_dump_database(struct btrfsic_state *state);\nstatic int btrfsic_process_written_superblock(\n\t\tstruct btrfsic_state *state,\n\t\tstruct btrfsic_block *const block,\n\t\tstruct btrfs_super_block *const super_hdr);\nstatic void btrfsic_print_add_link(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block_link *l);\nstatic void btrfsic_print_rem_link(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block_link *l);\nstatic void btrfsic_dump_tree(const struct btrfsic_state *state);\nstatic struct btrfsic_block *btrfsic_block_lookup_or_add(\n\t\tstruct btrfsic_state *state,\n\t\tstruct btrfsic_block_data_ctx *block_ctx,\n\t\tconst char *additional_string,\n\t\tint is_metadata,\n\t\tint is_iodone,\n\t\tint never_written,\n\t\tint mirror_num,\n\t\tint *was_created);\nstatic void btrfsic_cmp_log_and_dev_bytenr(struct btrfsic_state *state,\n\t\t\t\t\t   u64 bytenr,\n\t\t\t\t\t   struct btrfsic_dev_state *dev_state,\n\t\t\t\t\t   u64 dev_bytenr);\n\nstatic int btrfsic_process_written_superblock(\n\t\tstruct btrfsic_state *state,\n\t\tstruct btrfsic_block *const superblock,\n\t\tstruct btrfs_super_block *const super_hdr)\n{\n\tint pass;\n\n\tsuperblock->generation = btrfs_super_generation(super_hdr);\n\tif (!(superblock->generation > state->max_superblock_generation ||\n\t      0 == state->max_superblock_generation)) {\n\t\tif (state->print_mask & BTRFSIC_PRINT_MASK_SUPERBLOCK_WRITE)\n\t\t\tprintk(KERN_INFO\n\t\t\t       \"btrfsic: superblock @%llu (%s/%llu/%d)\"\n\t\t\t       \" with old gen %llu <= %llu\\n\",\n\t\t\t       superblock->logical_bytenr,\n\t\t\t       superblock->dev_state->name,\n\t\t\t       superblock->dev_bytenr, superblock->mirror_num,\n\t\t\t       btrfs_super_generation(super_hdr),\n\t\t\t       state->max_superblock_generation);\n\t} else {\n\t\tif (state->print_mask & BTRFSIC_PRINT_MASK_SUPERBLOCK_WRITE)\n\t\t\tprintk(KERN_INFO\n\t\t\t       \"btrfsic: got new superblock @%llu (%s/%llu/%d)\"\n\t\t\t       \" with new gen %llu > %llu\\n\",\n\t\t\t       superblock->logical_bytenr,\n\t\t\t       superblock->dev_state->name,\n\t\t\t       superblock->dev_bytenr, superblock->mirror_num,\n\t\t\t       btrfs_super_generation(super_hdr),\n\t\t\t       state->max_superblock_generation);\n\n\t\tstate->max_superblock_generation =\n\t\t    btrfs_super_generation(super_hdr);\n\t\tstate->latest_superblock = superblock;\n\t}\n\n\tfor (pass = 0; pass < 3; pass++) {\n\t\tint ret;\n\t\tu64 next_bytenr;\n\t\tstruct btrfsic_block *next_block;\n\t\tstruct btrfsic_block_data_ctx tmp_next_block_ctx;\n\t\tstruct btrfsic_block_link *l;\n\t\tint num_copies;\n\t\tint mirror_num;\n\t\tconst char *additional_string = NULL;\n\t\tstruct btrfs_disk_key tmp_disk_key = {0};\n\n\t\tbtrfs_set_disk_key_objectid(&tmp_disk_key,\n\t\t\t\t\t    BTRFS_ROOT_ITEM_KEY);\n\t\tbtrfs_set_disk_key_objectid(&tmp_disk_key, 0);\n\n\t\tswitch (pass) {\n\t\tcase 0:\n\t\t\tbtrfs_set_disk_key_objectid(&tmp_disk_key,\n\t\t\t\t\t\t    BTRFS_ROOT_TREE_OBJECTID);\n\t\t\tadditional_string = \"root \";\n\t\t\tnext_bytenr = btrfs_super_root(super_hdr);\n\t\t\tif (state->print_mask &\n\t\t\t    BTRFSIC_PRINT_MASK_ROOT_CHUNK_LOG_TREE_LOCATION)\n\t\t\t\tprintk(KERN_INFO \"root@%llu\\n\", next_bytenr);\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tbtrfs_set_disk_key_objectid(&tmp_disk_key,\n\t\t\t\t\t\t    BTRFS_CHUNK_TREE_OBJECTID);\n\t\t\tadditional_string = \"chunk \";\n\t\t\tnext_bytenr = btrfs_super_chunk_root(super_hdr);\n\t\t\tif (state->print_mask &\n\t\t\t    BTRFSIC_PRINT_MASK_ROOT_CHUNK_LOG_TREE_LOCATION)\n\t\t\t\tprintk(KERN_INFO \"chunk@%llu\\n\", next_bytenr);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tbtrfs_set_disk_key_objectid(&tmp_disk_key,\n\t\t\t\t\t\t    BTRFS_TREE_LOG_OBJECTID);\n\t\t\tadditional_string = \"log \";\n\t\t\tnext_bytenr = btrfs_super_log_root(super_hdr);\n\t\t\tif (0 == next_bytenr)\n\t\t\t\tcontinue;\n\t\t\tif (state->print_mask &\n\t\t\t    BTRFSIC_PRINT_MASK_ROOT_CHUNK_LOG_TREE_LOCATION)\n\t\t\t\tprintk(KERN_INFO \"log@%llu\\n\", next_bytenr);\n\t\t\tbreak;\n\t\t}\n\n\t\tnum_copies =\n\t\t    btrfs_num_copies(state->root->fs_info,\n\t\t\t\t     next_bytenr, BTRFS_SUPER_INFO_SIZE);\n\t\tif (state->print_mask & BTRFSIC_PRINT_MASK_NUM_COPIES)\n\t\t\tprintk(KERN_INFO \"num_copies(log_bytenr=%llu) = %d\\n\",\n\t\t\t       next_bytenr, num_copies);\n\t\tfor (mirror_num = 1; mirror_num <= num_copies; mirror_num++) {\n\t\t\tint was_created;\n\n\t\t\tif (state->print_mask & BTRFSIC_PRINT_MASK_VERBOSE)\n\t\t\t\tprintk(KERN_INFO\n\t\t\t\t       \"btrfsic_process_written_superblock(\"\n\t\t\t\t       \"mirror_num=%d)\\n\", mirror_num);\n\t\t\tret = btrfsic_map_block(state, next_bytenr,\n\t\t\t\t\t\tBTRFS_SUPER_INFO_SIZE,\n\t\t\t\t\t\t&tmp_next_block_ctx,\n\t\t\t\t\t\tmirror_num);\n\t\t\tif (ret) {\n\t\t\t\tprintk(KERN_INFO\n\t\t\t\t       \"btrfsic: btrfsic_map_block(@%llu,\"\n\t\t\t\t       \" mirror=%d) failed!\\n\",\n\t\t\t\t       next_bytenr, mirror_num);\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tnext_block = btrfsic_block_lookup_or_add(\n\t\t\t\t\tstate,\n\t\t\t\t\t&tmp_next_block_ctx,\n\t\t\t\t\tadditional_string,\n\t\t\t\t\t1, 0, 1,\n\t\t\t\t\tmirror_num,\n\t\t\t\t\t&was_created);\n\t\t\tif (NULL == next_block) {\n\t\t\t\tprintk(KERN_INFO\n\t\t\t\t       \"btrfsic: error, kmalloc failed!\\n\");\n\t\t\t\tbtrfsic_release_block_ctx(&tmp_next_block_ctx);\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tnext_block->disk_key = tmp_disk_key;\n\t\t\tif (was_created)\n\t\t\t\tnext_block->generation =\n\t\t\t\t    BTRFSIC_GENERATION_UNKNOWN;\n\t\t\tl = btrfsic_block_link_lookup_or_add(\n\t\t\t\t\tstate,\n\t\t\t\t\t&tmp_next_block_ctx,\n\t\t\t\t\tnext_block,\n\t\t\t\t\tsuperblock,\n\t\t\t\t\tBTRFSIC_GENERATION_UNKNOWN);\n\t\t\tbtrfsic_release_block_ctx(&tmp_next_block_ctx);\n\t\t\tif (NULL == l)\n\t\t\t\treturn -1;\n\t\t}\n\t}\n\n\tif (WARN_ON(-1 == btrfsic_check_all_ref_blocks(state, superblock, 0)))\n\t\tbtrfsic_dump_tree(state);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "PAGE_CACHE_SIZE !=\n\t\t\t\t       BTRFS_SUPER_INFO_SIZE"
          ],
          "line": 2046
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "NULL == chained_block"
          ],
          "line": 2016
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "NULL == bio_is_patched"
          ],
          "line": 2001
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfsic_block_link_free",
          "args": [
            "l"
          ],
          "line": 1984
        },
        "resolved": true,
        "details": {
          "function_name": "btrfsic_block_link_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/check-integrity.c",
          "lines": "464-468",
          "snippet": "static void btrfsic_block_link_free(struct btrfsic_block_link *l)\n{\n\tBUG_ON(!(NULL == l || BTRFSIC_BLOCK_LINK_MAGIC_NUMBER == l->magic_num));\n\tkfree(l);\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"extent_io.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/genhd.h>",
            "#include <linux/mutex.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define BTRFSIC_BLOCK_LINK_MAGIC_NUMBER 0x11070807"
          ],
          "globals_used": [
            "static void btrfsic_block_link_hashtable_remove(struct btrfsic_block_link *l);",
            "static void btrfsic_print_add_link(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block_link *l);",
            "static void btrfsic_print_rem_link(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block_link *l);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"extent_io.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n#include <linux/blkdev.h>\n#include <linux/genhd.h>\n#include <linux/mutex.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\n#define BTRFSIC_BLOCK_LINK_MAGIC_NUMBER 0x11070807\n\nstatic void btrfsic_block_link_hashtable_remove(struct btrfsic_block_link *l);\nstatic void btrfsic_print_add_link(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block_link *l);\nstatic void btrfsic_print_rem_link(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block_link *l);\n\nstatic void btrfsic_block_link_free(struct btrfsic_block_link *l)\n{\n\tBUG_ON(!(NULL == l || BTRFSIC_BLOCK_LINK_MAGIC_NUMBER == l->magic_num));\n\tkfree(l);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfsic_block_link_hashtable_remove",
          "args": [
            "l"
          ],
          "line": 1983
        },
        "resolved": true,
        "details": {
          "function_name": "btrfsic_block_link_hashtable_remove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/check-integrity.c",
          "lines": "573-576",
          "snippet": "static void btrfsic_block_link_hashtable_remove(struct btrfsic_block_link *l)\n{\n\tlist_del(&l->collision_resolving_node);\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"extent_io.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/genhd.h>",
            "#include <linux/mutex.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void btrfsic_block_link_hashtable_remove(struct btrfsic_block_link *l);",
            "static void btrfsic_print_add_link(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block_link *l);",
            "static void btrfsic_print_rem_link(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block_link *l);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"extent_io.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n#include <linux/blkdev.h>\n#include <linux/genhd.h>\n#include <linux/mutex.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic void btrfsic_block_link_hashtable_remove(struct btrfsic_block_link *l);\nstatic void btrfsic_print_add_link(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block_link *l);\nstatic void btrfsic_print_rem_link(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block_link *l);\n\nstatic void btrfsic_block_link_hashtable_remove(struct btrfsic_block_link *l)\n{\n\tlist_del(&l->collision_resolving_node);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfsic_print_rem_link",
          "args": [
            "state",
            "l"
          ],
          "line": 1978
        },
        "resolved": true,
        "details": {
          "function_name": "btrfsic_print_rem_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/check-integrity.c",
          "lines": "2631-2646",
          "snippet": "static void btrfsic_print_rem_link(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block_link *l)\n{\n\tprintk(KERN_INFO\n\t       \"Rem %u* link from %c @%llu (%s/%llu/%d)\"\n\t       \" to %c @%llu (%s/%llu/%d).\\n\",\n\t       l->ref_cnt,\n\t       btrfsic_get_block_type(state, l->block_ref_from),\n\t       l->block_ref_from->logical_bytenr,\n\t       l->block_ref_from->dev_state->name,\n\t       l->block_ref_from->dev_bytenr, l->block_ref_from->mirror_num,\n\t       btrfsic_get_block_type(state, l->block_ref_to),\n\t       l->block_ref_to->logical_bytenr,\n\t       l->block_ref_to->dev_state->name, l->block_ref_to->dev_bytenr,\n\t       l->block_ref_to->mirror_num);\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"extent_io.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/genhd.h>",
            "#include <linux/mutex.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void btrfsic_block_link_init(struct btrfsic_block_link *n);",
            "static void btrfsic_block_link_free(struct btrfsic_block_link *n);",
            "static void btrfsic_block_link_hashtable_remove(struct btrfsic_block_link *l);",
            "static int btrfsic_map_block(struct btrfsic_state *state, u64 bytenr, u32 len,\n\t\t\t     struct btrfsic_block_data_ctx *block_ctx_out,\n\t\t\t     int mirror_num);",
            "static void btrfsic_dump_database(struct btrfsic_state *state);",
            "static void btrfsic_print_add_link(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block_link *l);",
            "static void btrfsic_print_rem_link(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block_link *l);",
            "static void btrfsic_dump_tree(const struct btrfsic_state *state);",
            "static void btrfsic_cmp_log_and_dev_bytenr(struct btrfsic_state *state,\n\t\t\t\t\t   u64 bytenr,\n\t\t\t\t\t   struct btrfsic_dev_state *dev_state,\n\t\t\t\t\t   u64 dev_bytenr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"extent_io.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n#include <linux/blkdev.h>\n#include <linux/genhd.h>\n#include <linux/mutex.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic void btrfsic_block_link_init(struct btrfsic_block_link *n);\nstatic void btrfsic_block_link_free(struct btrfsic_block_link *n);\nstatic void btrfsic_block_link_hashtable_remove(struct btrfsic_block_link *l);\nstatic int btrfsic_map_block(struct btrfsic_state *state, u64 bytenr, u32 len,\n\t\t\t     struct btrfsic_block_data_ctx *block_ctx_out,\n\t\t\t     int mirror_num);\nstatic void btrfsic_dump_database(struct btrfsic_state *state);\nstatic void btrfsic_print_add_link(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block_link *l);\nstatic void btrfsic_print_rem_link(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block_link *l);\nstatic void btrfsic_dump_tree(const struct btrfsic_state *state);\nstatic void btrfsic_cmp_log_and_dev_bytenr(struct btrfsic_state *state,\n\t\t\t\t\t   u64 bytenr,\n\t\t\t\t\t   struct btrfsic_dev_state *dev_state,\n\t\t\t\t\t   u64 dev_bytenr);\n\nstatic void btrfsic_print_rem_link(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block_link *l)\n{\n\tprintk(KERN_INFO\n\t       \"Rem %u* link from %c @%llu (%s/%llu/%d)\"\n\t       \" to %c @%llu (%s/%llu/%d).\\n\",\n\t       l->ref_cnt,\n\t       btrfsic_get_block_type(state, l->block_ref_from),\n\t       l->block_ref_from->logical_bytenr,\n\t       l->block_ref_from->dev_state->name,\n\t       l->block_ref_from->dev_bytenr, l->block_ref_from->mirror_num,\n\t       btrfsic_get_block_type(state, l->block_ref_to),\n\t       l->block_ref_to->logical_bytenr,\n\t       l->block_ref_to->dev_state->name, l->block_ref_to->dev_bytenr,\n\t       l->block_ref_to->mirror_num);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "elem_ref_to",
            "structbtrfsic_block_link",
            "node_ref_to"
          ],
          "line": 1973
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_safe",
          "args": [
            "elem_ref_to",
            "tmp_ref_to",
            "&block->ref_to_list"
          ],
          "line": 1970
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfsic_dump_tree",
          "args": [
            "state"
          ],
          "line": 1960
        },
        "resolved": true,
        "details": {
          "function_name": "btrfsic_dump_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/check-integrity.c",
          "lines": "2663-2666",
          "snippet": "static void btrfsic_dump_tree(const struct btrfsic_state *state)\n{\n\tbtrfsic_dump_tree_sub(state, state->latest_superblock, 0);\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"extent_io.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/genhd.h>",
            "#include <linux/mutex.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void btrfsic_dump_database(struct btrfsic_state *state);",
            "static void btrfsic_dump_tree(const struct btrfsic_state *state);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"extent_io.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n#include <linux/blkdev.h>\n#include <linux/genhd.h>\n#include <linux/mutex.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic void btrfsic_dump_database(struct btrfsic_state *state);\nstatic void btrfsic_dump_tree(const struct btrfsic_state *state);\n\nstatic void btrfsic_dump_tree(const struct btrfsic_state *state)\n{\n\tbtrfsic_dump_tree_sub(state, state->latest_superblock, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_stack_header_generation",
          "args": [
            "(struct btrfs_header *)\n\t\t\t\t       mapped_datav[0]"
          ],
          "line": 1956
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfsic_get_block_type",
          "args": [
            "state",
            "block"
          ],
          "line": 1953
        },
        "resolved": true,
        "details": {
          "function_name": "btrfsic_get_block_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/check-integrity.c",
          "lines": "2648-2661",
          "snippet": "static char btrfsic_get_block_type(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block *block)\n{\n\tif (block->is_superblock &&\n\t    state->latest_superblock->dev_bytenr == block->dev_bytenr &&\n\t    state->latest_superblock->dev_state->bdev == block->dev_state->bdev)\n\t\treturn 'S';\n\telse if (block->is_superblock)\n\t\treturn 's';\n\telse if (block->is_metadata)\n\t\treturn 'M';\n\telse\n\t\treturn 'D';\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"extent_io.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/genhd.h>",
            "#include <linux/mutex.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void btrfsic_dump_database(struct btrfsic_state *state);",
            "static char btrfsic_get_block_type(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block *block);",
            "static void btrfsic_dump_tree(const struct btrfsic_state *state);",
            "static struct btrfsic_dev_state *btrfsic_dev_state_lookup(\n\t\tstruct block_device *bdev);",
            "static void btrfsic_cmp_log_and_dev_bytenr(struct btrfsic_state *state,\n\t\t\t\t\t   u64 bytenr,\n\t\t\t\t\t   struct btrfsic_dev_state *dev_state,\n\t\t\t\t\t   u64 dev_bytenr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"extent_io.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n#include <linux/blkdev.h>\n#include <linux/genhd.h>\n#include <linux/mutex.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic void btrfsic_dump_database(struct btrfsic_state *state);\nstatic char btrfsic_get_block_type(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block *block);\nstatic void btrfsic_dump_tree(const struct btrfsic_state *state);\nstatic struct btrfsic_dev_state *btrfsic_dev_state_lookup(\n\t\tstruct block_device *bdev);\nstatic void btrfsic_cmp_log_and_dev_bytenr(struct btrfsic_state *state,\n\t\t\t\t\t   u64 bytenr,\n\t\t\t\t\t   struct btrfsic_dev_state *dev_state,\n\t\t\t\t\t   u64 dev_bytenr);\n\nstatic char btrfsic_get_block_type(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block *block)\n{\n\tif (block->is_superblock &&\n\t    state->latest_superblock->dev_bytenr == block->dev_bytenr &&\n\t    state->latest_superblock->dev_state->bdev == block->dev_state->bdev)\n\t\treturn 'S';\n\telse if (block->is_superblock)\n\t\treturn 's';\n\telse if (block->is_metadata)\n\t\treturn 'M';\n\telse\n\t\treturn 'D';\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_stack_header_generation",
          "args": [
            "(struct btrfs_header *) mapped_datav[0]"
          ],
          "line": 1943
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_disk_key_offset",
          "args": [
            "&block->disk_key"
          ],
          "line": 1942
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_disk_key_objectid",
          "args": [
            "&block->disk_key"
          ],
          "line": 1940
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfsic_is_block_ref_by_superblock",
          "args": [
            "state",
            "block",
            "0"
          ],
          "line": 1930
        },
        "resolved": true,
        "details": {
          "function_name": "btrfsic_is_block_ref_by_superblock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/check-integrity.c",
          "lines": "2559-2612",
          "snippet": "static int btrfsic_is_block_ref_by_superblock(\n\t\tconst struct btrfsic_state *state,\n\t\tconst struct btrfsic_block *block,\n\t\tint recursion_level)\n{\n\tstruct list_head *elem_ref_from;\n\n\tif (recursion_level >= 3 + BTRFS_MAX_LEVEL) {\n\t\t/* refer to comment at \"abort cyclic linkage (case 1)\" */\n\t\tif (state->print_mask & BTRFSIC_PRINT_MASK_VERBOSE)\n\t\t\tprintk(KERN_INFO\n\t\t\t       \"btrfsic: abort cyclic linkage (case 2).\\n\");\n\n\t\treturn 0;\n\t}\n\n\t/*\n\t * This algorithm is recursive because the amount of used stack space\n\t * is very small and the max recursion depth is limited.\n\t */\n\tlist_for_each(elem_ref_from, &block->ref_from_list) {\n\t\tconst struct btrfsic_block_link *const l =\n\t\t    list_entry(elem_ref_from, struct btrfsic_block_link,\n\t\t\t       node_ref_from);\n\n\t\tif (state->print_mask & BTRFSIC_PRINT_MASK_VERBOSE)\n\t\t\tprintk(KERN_INFO\n\t\t\t       \"rl=%d, %c @%llu (%s/%llu/%d)\"\n\t\t\t       \" is ref %u* from %c @%llu (%s/%llu/%d)\\n\",\n\t\t\t       recursion_level,\n\t\t\t       btrfsic_get_block_type(state, block),\n\t\t\t       block->logical_bytenr, block->dev_state->name,\n\t\t\t       block->dev_bytenr, block->mirror_num,\n\t\t\t       l->ref_cnt,\n\t\t\t       btrfsic_get_block_type(state, l->block_ref_from),\n\t\t\t       l->block_ref_from->logical_bytenr,\n\t\t\t       l->block_ref_from->dev_state->name,\n\t\t\t       l->block_ref_from->dev_bytenr,\n\t\t\t       l->block_ref_from->mirror_num);\n\t\tif (l->block_ref_from->is_superblock &&\n\t\t    state->latest_superblock->dev_bytenr ==\n\t\t    l->block_ref_from->dev_bytenr &&\n\t\t    state->latest_superblock->dev_state->bdev ==\n\t\t    l->block_ref_from->dev_state->bdev)\n\t\t\treturn 1;\n\t\telse if (btrfsic_is_block_ref_by_superblock(state,\n\t\t\t\t\t\t\t    l->block_ref_from,\n\t\t\t\t\t\t\t    recursion_level +\n\t\t\t\t\t\t\t    1))\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"extent_io.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/genhd.h>",
            "#include <linux/mutex.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define BTRFSIC_PRINT_MASK_VERBOSE\t\t\t\t0x00000040"
          ],
          "globals_used": [
            "static void btrfsic_block_link_init(struct btrfsic_block_link *n);",
            "static void btrfsic_block_link_free(struct btrfsic_block_link *n);",
            "static void btrfsic_block_link_hashtable_remove(struct btrfsic_block_link *l);",
            "static int btrfsic_map_block(struct btrfsic_state *state, u64 bytenr, u32 len,\n\t\t\t     struct btrfsic_block_data_ctx *block_ctx_out,\n\t\t\t     int mirror_num);",
            "static void btrfsic_dump_database(struct btrfsic_state *state);",
            "static int btrfsic_is_block_ref_by_superblock(const struct btrfsic_state *state,\n\t\t\t\t\t      const struct btrfsic_block *block,\n\t\t\t\t\t      int recursion_level);",
            "static int btrfsic_check_all_ref_blocks(struct btrfsic_state *state,\n\t\t\t\t\tstruct btrfsic_block *const block,\n\t\t\t\t\tint recursion_level);",
            "static void btrfsic_print_add_link(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block_link *l);",
            "static void btrfsic_print_rem_link(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block_link *l);",
            "static char btrfsic_get_block_type(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block *block);",
            "static void btrfsic_dump_tree(const struct btrfsic_state *state);",
            "static struct btrfsic_dev_state *btrfsic_dev_state_lookup(\n\t\tstruct block_device *bdev);",
            "static void btrfsic_cmp_log_and_dev_bytenr(struct btrfsic_state *state,\n\t\t\t\t\t   u64 bytenr,\n\t\t\t\t\t   struct btrfsic_dev_state *dev_state,\n\t\t\t\t\t   u64 dev_bytenr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"extent_io.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n#include <linux/blkdev.h>\n#include <linux/genhd.h>\n#include <linux/mutex.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\n#define BTRFSIC_PRINT_MASK_VERBOSE\t\t\t\t0x00000040\n\nstatic void btrfsic_block_link_init(struct btrfsic_block_link *n);\nstatic void btrfsic_block_link_free(struct btrfsic_block_link *n);\nstatic void btrfsic_block_link_hashtable_remove(struct btrfsic_block_link *l);\nstatic int btrfsic_map_block(struct btrfsic_state *state, u64 bytenr, u32 len,\n\t\t\t     struct btrfsic_block_data_ctx *block_ctx_out,\n\t\t\t     int mirror_num);\nstatic void btrfsic_dump_database(struct btrfsic_state *state);\nstatic int btrfsic_is_block_ref_by_superblock(const struct btrfsic_state *state,\n\t\t\t\t\t      const struct btrfsic_block *block,\n\t\t\t\t\t      int recursion_level);\nstatic int btrfsic_check_all_ref_blocks(struct btrfsic_state *state,\n\t\t\t\t\tstruct btrfsic_block *const block,\n\t\t\t\t\tint recursion_level);\nstatic void btrfsic_print_add_link(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block_link *l);\nstatic void btrfsic_print_rem_link(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block_link *l);\nstatic char btrfsic_get_block_type(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block *block);\nstatic void btrfsic_dump_tree(const struct btrfsic_state *state);\nstatic struct btrfsic_dev_state *btrfsic_dev_state_lookup(\n\t\tstruct block_device *bdev);\nstatic void btrfsic_cmp_log_and_dev_bytenr(struct btrfsic_state *state,\n\t\t\t\t\t   u64 bytenr,\n\t\t\t\t\t   struct btrfsic_dev_state *dev_state,\n\t\t\t\t\t   u64 dev_bytenr);\n\nstatic int btrfsic_is_block_ref_by_superblock(\n\t\tconst struct btrfsic_state *state,\n\t\tconst struct btrfsic_block *block,\n\t\tint recursion_level)\n{\n\tstruct list_head *elem_ref_from;\n\n\tif (recursion_level >= 3 + BTRFS_MAX_LEVEL) {\n\t\t/* refer to comment at \"abort cyclic linkage (case 1)\" */\n\t\tif (state->print_mask & BTRFSIC_PRINT_MASK_VERBOSE)\n\t\t\tprintk(KERN_INFO\n\t\t\t       \"btrfsic: abort cyclic linkage (case 2).\\n\");\n\n\t\treturn 0;\n\t}\n\n\t/*\n\t * This algorithm is recursive because the amount of used stack space\n\t * is very small and the max recursion depth is limited.\n\t */\n\tlist_for_each(elem_ref_from, &block->ref_from_list) {\n\t\tconst struct btrfsic_block_link *const l =\n\t\t    list_entry(elem_ref_from, struct btrfsic_block_link,\n\t\t\t       node_ref_from);\n\n\t\tif (state->print_mask & BTRFSIC_PRINT_MASK_VERBOSE)\n\t\t\tprintk(KERN_INFO\n\t\t\t       \"rl=%d, %c @%llu (%s/%llu/%d)\"\n\t\t\t       \" is ref %u* from %c @%llu (%s/%llu/%d)\\n\",\n\t\t\t       recursion_level,\n\t\t\t       btrfsic_get_block_type(state, block),\n\t\t\t       block->logical_bytenr, block->dev_state->name,\n\t\t\t       block->dev_bytenr, block->mirror_num,\n\t\t\t       l->ref_cnt,\n\t\t\t       btrfsic_get_block_type(state, l->block_ref_from),\n\t\t\t       l->block_ref_from->logical_bytenr,\n\t\t\t       l->block_ref_from->dev_state->name,\n\t\t\t       l->block_ref_from->dev_bytenr,\n\t\t\t       l->block_ref_from->mirror_num);\n\t\tif (l->block_ref_from->is_superblock &&\n\t\t    state->latest_superblock->dev_bytenr ==\n\t\t    l->block_ref_from->dev_bytenr &&\n\t\t    state->latest_superblock->dev_state->bdev ==\n\t\t    l->block_ref_from->dev_state->bdev)\n\t\t\treturn 1;\n\t\telse if (btrfsic_is_block_ref_by_superblock(state,\n\t\t\t\t\t\t\t    l->block_ref_from,\n\t\t\t\t\t\t\t    recursion_level +\n\t\t\t\t\t\t\t    1))\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_stack_header_bytenr",
          "args": [
            "(struct btrfs_header *)\n\t\t\t\t\t\tmapped_datav[0]"
          ],
          "line": 1879
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "BTRFS_SUPER_INFO_SIZE & (PAGE_CACHE_SIZE - 1)"
          ],
          "line": 1861
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_super_bytenr",
          "args": [
            "(struct btrfs_super_block *)\n\t\t\t\t\t\t    mapped_datav[0]"
          ],
          "line": 1852
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfsic_block_hashtable_lookup",
          "args": [
            "bdev",
            "dev_bytenr",
            "&state->block_hashtable"
          ],
          "line": 1844
        },
        "resolved": true,
        "details": {
          "function_name": "btrfsic_block_hashtable_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/check-integrity.c",
          "lines": "525-546",
          "snippet": "static struct btrfsic_block *btrfsic_block_hashtable_lookup(\n\t\tstruct block_device *bdev,\n\t\tu64 dev_bytenr,\n\t\tstruct btrfsic_block_hashtable *h)\n{\n\tconst unsigned int hashval =\n\t    (((unsigned int)(dev_bytenr >> 16)) ^\n\t     ((unsigned int)((uintptr_t)bdev))) &\n\t     (BTRFSIC_BLOCK_HASHTABLE_SIZE - 1);\n\tstruct list_head *elem;\n\n\tlist_for_each(elem, h->table + hashval) {\n\t\tstruct btrfsic_block *const b =\n\t\t    list_entry(elem, struct btrfsic_block,\n\t\t\t       collision_resolving_node);\n\n\t\tif (b->dev_state->bdev == bdev && b->dev_bytenr == dev_bytenr)\n\t\t\treturn b;\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"extent_io.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/genhd.h>",
            "#include <linux/mutex.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define BTRFSIC_BLOCK_HASHTABLE_SIZE 0x10000"
          ],
          "globals_used": [
            "static void btrfsic_block_init(struct btrfsic_block *b);",
            "static void btrfsic_block_free(struct btrfsic_block *b);",
            "static void btrfsic_block_hashtable_init(struct btrfsic_block_hashtable *h);",
            "static void btrfsic_block_hashtable_add(struct btrfsic_block *b,\n\t\t\t\t\tstruct btrfsic_block_hashtable *h);",
            "static void btrfsic_block_hashtable_remove(struct btrfsic_block *b);",
            "static struct btrfsic_block *btrfsic_block_hashtable_lookup(\n\t\tstruct block_device *bdev,\n\t\tu64 dev_bytenr,\n\t\tstruct btrfsic_block_hashtable *h);",
            "static void btrfsic_block_link_hashtable_init(\n\t\tstruct btrfsic_block_link_hashtable *h);",
            "static void btrfsic_block_link_hashtable_add(\n\t\tstruct btrfsic_block_link *l,\n\t\tstruct btrfsic_block_link_hashtable *h);",
            "static struct btrfsic_block_link *btrfsic_block_link_hashtable_lookup(\n\t\tstruct block_device *bdev_ref_to,\n\t\tu64 dev_bytenr_ref_to,\n\t\tstruct block_device *bdev_ref_from,\n\t\tu64 dev_bytenr_ref_from,\n\t\tstruct btrfsic_block_link_hashtable *h);",
            "static void btrfsic_dev_state_hashtable_init(\n\t\tstruct btrfsic_dev_state_hashtable *h);",
            "static void btrfsic_dev_state_hashtable_add(\n\t\tstruct btrfsic_dev_state *ds,\n\t\tstruct btrfsic_dev_state_hashtable *h);",
            "static struct btrfsic_dev_state *btrfsic_dev_state_hashtable_lookup(\n\t\tstruct block_device *bdev,\n\t\tstruct btrfsic_dev_state_hashtable *h);",
            "static struct btrfsic_dev_state *btrfsic_dev_state_lookup(\n\t\tstruct block_device *bdev);",
            "static void btrfsic_cmp_log_and_dev_bytenr(struct btrfsic_state *state,\n\t\t\t\t\t   u64 bytenr,\n\t\t\t\t\t   struct btrfsic_dev_state *dev_state,\n\t\t\t\t\t   u64 dev_bytenr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"extent_io.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n#include <linux/blkdev.h>\n#include <linux/genhd.h>\n#include <linux/mutex.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\n#define BTRFSIC_BLOCK_HASHTABLE_SIZE 0x10000\n\nstatic void btrfsic_block_init(struct btrfsic_block *b);\nstatic void btrfsic_block_free(struct btrfsic_block *b);\nstatic void btrfsic_block_hashtable_init(struct btrfsic_block_hashtable *h);\nstatic void btrfsic_block_hashtable_add(struct btrfsic_block *b,\n\t\t\t\t\tstruct btrfsic_block_hashtable *h);\nstatic void btrfsic_block_hashtable_remove(struct btrfsic_block *b);\nstatic struct btrfsic_block *btrfsic_block_hashtable_lookup(\n\t\tstruct block_device *bdev,\n\t\tu64 dev_bytenr,\n\t\tstruct btrfsic_block_hashtable *h);\nstatic void btrfsic_block_link_hashtable_init(\n\t\tstruct btrfsic_block_link_hashtable *h);\nstatic void btrfsic_block_link_hashtable_add(\n\t\tstruct btrfsic_block_link *l,\n\t\tstruct btrfsic_block_link_hashtable *h);\nstatic struct btrfsic_block_link *btrfsic_block_link_hashtable_lookup(\n\t\tstruct block_device *bdev_ref_to,\n\t\tu64 dev_bytenr_ref_to,\n\t\tstruct block_device *bdev_ref_from,\n\t\tu64 dev_bytenr_ref_from,\n\t\tstruct btrfsic_block_link_hashtable *h);\nstatic void btrfsic_dev_state_hashtable_init(\n\t\tstruct btrfsic_dev_state_hashtable *h);\nstatic void btrfsic_dev_state_hashtable_add(\n\t\tstruct btrfsic_dev_state *ds,\n\t\tstruct btrfsic_dev_state_hashtable *h);\nstatic struct btrfsic_dev_state *btrfsic_dev_state_hashtable_lookup(\n\t\tstruct block_device *bdev,\n\t\tstruct btrfsic_dev_state_hashtable *h);\nstatic struct btrfsic_dev_state *btrfsic_dev_state_lookup(\n\t\tstruct block_device *bdev);\nstatic void btrfsic_cmp_log_and_dev_bytenr(struct btrfsic_state *state,\n\t\t\t\t\t   u64 bytenr,\n\t\t\t\t\t   struct btrfsic_dev_state *dev_state,\n\t\t\t\t\t   u64 dev_bytenr);\n\nstatic struct btrfsic_block *btrfsic_block_hashtable_lookup(\n\t\tstruct block_device *bdev,\n\t\tu64 dev_bytenr,\n\t\tstruct btrfsic_block_hashtable *h)\n{\n\tconst unsigned int hashval =\n\t    (((unsigned int)(dev_bytenr >> 16)) ^\n\t     ((unsigned int)((uintptr_t)bdev))) &\n\t     (BTRFSIC_BLOCK_HASHTABLE_SIZE - 1);\n\tstruct list_head *elem;\n\n\tlist_for_each(elem, h->table + hashval) {\n\t\tstruct btrfsic_block *const b =\n\t\t    list_entry(elem, struct btrfsic_block,\n\t\t\t       collision_resolving_node);\n\n\t\tif (b->dev_state->bdev == bdev && b->dev_bytenr == dev_bytenr)\n\t\t\treturn b;\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfsic_test_for_metadata",
          "args": [
            "state",
            "mapped_datav",
            "num_pages"
          ],
          "line": 1841
        },
        "resolved": true,
        "details": {
          "function_name": "btrfsic_test_for_metadata",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/check-integrity.c",
          "lines": "1788-1816",
          "snippet": "static int btrfsic_test_for_metadata(struct btrfsic_state *state,\n\t\t\t\t     char **datav, unsigned int num_pages)\n{\n\tstruct btrfs_header *h;\n\tu8 csum[BTRFS_CSUM_SIZE];\n\tu32 crc = ~(u32)0;\n\tunsigned int i;\n\n\tif (num_pages * PAGE_CACHE_SIZE < state->metablock_size)\n\t\treturn 1; /* not metadata */\n\tnum_pages = state->metablock_size >> PAGE_CACHE_SHIFT;\n\th = (struct btrfs_header *)datav[0];\n\n\tif (memcmp(h->fsid, state->root->fs_info->fsid, BTRFS_UUID_SIZE))\n\t\treturn 1;\n\n\tfor (i = 0; i < num_pages; i++) {\n\t\tu8 *data = i ? datav[i] : (datav[i] + BTRFS_CSUM_SIZE);\n\t\tsize_t sublen = i ? PAGE_CACHE_SIZE :\n\t\t\t\t    (PAGE_CACHE_SIZE - BTRFS_CSUM_SIZE);\n\n\t\tcrc = btrfs_crc32c(crc, data, sublen);\n\t}\n\tbtrfs_csum_final(crc, csum);\n\tif (memcmp(csum, h->csum, state->csum_size))\n\t\treturn 1;\n\n\treturn 0; /* is metadata */\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"extent_io.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/genhd.h>",
            "#include <linux/mutex.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void btrfsic_block_hashtable_init(struct btrfsic_block_hashtable *h);",
            "static void btrfsic_block_hashtable_add(struct btrfsic_block *b,\n\t\t\t\t\tstruct btrfsic_block_hashtable *h);",
            "static struct btrfsic_block *btrfsic_block_hashtable_lookup(\n\t\tstruct block_device *bdev,\n\t\tu64 dev_bytenr,\n\t\tstruct btrfsic_block_hashtable *h);",
            "static void btrfsic_block_link_hashtable_init(\n\t\tstruct btrfsic_block_link_hashtable *h);",
            "static void btrfsic_block_link_hashtable_add(\n\t\tstruct btrfsic_block_link *l,\n\t\tstruct btrfsic_block_link_hashtable *h);",
            "static struct btrfsic_block_link *btrfsic_block_link_hashtable_lookup(\n\t\tstruct block_device *bdev_ref_to,\n\t\tu64 dev_bytenr_ref_to,\n\t\tstruct block_device *bdev_ref_from,\n\t\tu64 dev_bytenr_ref_from,\n\t\tstruct btrfsic_block_link_hashtable *h);",
            "static void btrfsic_dev_state_hashtable_init(\n\t\tstruct btrfsic_dev_state_hashtable *h);",
            "static void btrfsic_dev_state_hashtable_add(\n\t\tstruct btrfsic_dev_state *ds,\n\t\tstruct btrfsic_dev_state_hashtable *h);",
            "static struct btrfsic_dev_state *btrfsic_dev_state_hashtable_lookup(\n\t\tstruct block_device *bdev,\n\t\tstruct btrfsic_dev_state_hashtable *h);",
            "static void btrfsic_dump_database(struct btrfsic_state *state);",
            "static int btrfsic_test_for_metadata(struct btrfsic_state *state,\n\t\t\t\t     char **datav, unsigned int num_pages);",
            "static void btrfsic_dump_tree(const struct btrfsic_state *state);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"extent_io.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n#include <linux/blkdev.h>\n#include <linux/genhd.h>\n#include <linux/mutex.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic void btrfsic_block_hashtable_init(struct btrfsic_block_hashtable *h);\nstatic void btrfsic_block_hashtable_add(struct btrfsic_block *b,\n\t\t\t\t\tstruct btrfsic_block_hashtable *h);\nstatic struct btrfsic_block *btrfsic_block_hashtable_lookup(\n\t\tstruct block_device *bdev,\n\t\tu64 dev_bytenr,\n\t\tstruct btrfsic_block_hashtable *h);\nstatic void btrfsic_block_link_hashtable_init(\n\t\tstruct btrfsic_block_link_hashtable *h);\nstatic void btrfsic_block_link_hashtable_add(\n\t\tstruct btrfsic_block_link *l,\n\t\tstruct btrfsic_block_link_hashtable *h);\nstatic struct btrfsic_block_link *btrfsic_block_link_hashtable_lookup(\n\t\tstruct block_device *bdev_ref_to,\n\t\tu64 dev_bytenr_ref_to,\n\t\tstruct block_device *bdev_ref_from,\n\t\tu64 dev_bytenr_ref_from,\n\t\tstruct btrfsic_block_link_hashtable *h);\nstatic void btrfsic_dev_state_hashtable_init(\n\t\tstruct btrfsic_dev_state_hashtable *h);\nstatic void btrfsic_dev_state_hashtable_add(\n\t\tstruct btrfsic_dev_state *ds,\n\t\tstruct btrfsic_dev_state_hashtable *h);\nstatic struct btrfsic_dev_state *btrfsic_dev_state_hashtable_lookup(\n\t\tstruct block_device *bdev,\n\t\tstruct btrfsic_dev_state_hashtable *h);\nstatic void btrfsic_dump_database(struct btrfsic_state *state);\nstatic int btrfsic_test_for_metadata(struct btrfsic_state *state,\n\t\t\t\t     char **datav, unsigned int num_pages);\nstatic void btrfsic_dump_tree(const struct btrfsic_state *state);\n\nstatic int btrfsic_test_for_metadata(struct btrfsic_state *state,\n\t\t\t\t     char **datav, unsigned int num_pages)\n{\n\tstruct btrfs_header *h;\n\tu8 csum[BTRFS_CSUM_SIZE];\n\tu32 crc = ~(u32)0;\n\tunsigned int i;\n\n\tif (num_pages * PAGE_CACHE_SIZE < state->metablock_size)\n\t\treturn 1; /* not metadata */\n\tnum_pages = state->metablock_size >> PAGE_CACHE_SHIFT;\n\th = (struct btrfs_header *)datav[0];\n\n\tif (memcmp(h->fsid, state->root->fs_info->fsid, BTRFS_UUID_SIZE))\n\t\treturn 1;\n\n\tfor (i = 0; i < num_pages; i++) {\n\t\tu8 *data = i ? datav[i] : (datav[i] + BTRFS_CSUM_SIZE);\n\t\tsize_t sublen = i ? PAGE_CACHE_SIZE :\n\t\t\t\t    (PAGE_CACHE_SIZE - BTRFS_CSUM_SIZE);\n\n\t\tcrc = btrfs_crc32c(crc, data, sublen);\n\t}\n\tbtrfs_csum_final(crc, csum);\n\tif (memcmp(csum, h->csum, state->csum_size))\n\t\treturn 1;\n\n\treturn 0; /* is metadata */\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"extent_io.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n#include <linux/blkdev.h>\n#include <linux/genhd.h>\n#include <linux/mutex.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\n#define BTRFSIC_PRINT_MASK_VERBOSE\t\t\t\t0x00000040\n#define BTRFSIC_PRINT_MASK_TREE_BEFORE_SB_WRITE\t\t\t0x00000008\n#define BTRFSIC_PRINT_MASK_TREE_AFTER_SB_WRITE\t\t\t0x00000004\n#define BTRFSIC_GENERATION_UNKNOWN ((u64)-1)\n\nstatic struct btrfsic_block *btrfsic_block_alloc(void);\nstatic void btrfsic_block_link_init(struct btrfsic_block_link *n);\nstatic void btrfsic_block_link_free(struct btrfsic_block_link *n);\nstatic void btrfsic_block_link_hashtable_remove(struct btrfsic_block_link *l);\nstatic void btrfsic_read_from_block_data(\n\tstruct btrfsic_block_data_ctx *block_ctx,\n\tvoid *dst, u32 offset, size_t len);\nstatic int btrfsic_map_block(struct btrfsic_state *state, u64 bytenr, u32 len,\n\t\t\t     struct btrfsic_block_data_ctx *block_ctx_out,\n\t\t\t     int mirror_num);\nstatic void btrfsic_release_block_ctx(struct btrfsic_block_data_ctx *block_ctx);\nstatic int btrfsic_read_block(struct btrfsic_state *state,\n\t\t\t      struct btrfsic_block_data_ctx *block_ctx);\nstatic void btrfsic_dump_database(struct btrfsic_state *state);\nstatic int btrfsic_test_for_metadata(struct btrfsic_state *state,\n\t\t\t\t     char **datav, unsigned int num_pages);\nstatic void btrfsic_process_written_block(struct btrfsic_dev_state *dev_state,\n\t\t\t\t\t  u64 dev_bytenr, char **mapped_datav,\n\t\t\t\t\t  unsigned int num_pages,\n\t\t\t\t\t  struct bio *bio, int *bio_is_patched,\n\t\t\t\t\t  struct buffer_head *bh,\n\t\t\t\t\t  int submit_bio_bh_rw);\nstatic void btrfsic_print_add_link(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block_link *l);\nstatic void btrfsic_print_rem_link(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block_link *l);\nstatic char btrfsic_get_block_type(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block *block);\nstatic void btrfsic_dump_tree(const struct btrfsic_state *state);\nstatic struct btrfsic_dev_state *btrfsic_dev_state_lookup(\n\t\tstruct block_device *bdev);\nstatic void btrfsic_cmp_log_and_dev_bytenr(struct btrfsic_state *state,\n\t\t\t\t\t   u64 bytenr,\n\t\t\t\t\t   struct btrfsic_dev_state *dev_state,\n\t\t\t\t\t   u64 dev_bytenr);\n\nstatic void btrfsic_process_written_block(struct btrfsic_dev_state *dev_state,\n\t\t\t\t\t  u64 dev_bytenr, char **mapped_datav,\n\t\t\t\t\t  unsigned int num_pages,\n\t\t\t\t\t  struct bio *bio, int *bio_is_patched,\n\t\t\t\t\t  struct buffer_head *bh,\n\t\t\t\t\t  int submit_bio_bh_rw)\n{\n\tint is_metadata;\n\tstruct btrfsic_block *block;\n\tstruct btrfsic_block_data_ctx block_ctx;\n\tint ret;\n\tstruct btrfsic_state *state = dev_state->state;\n\tstruct block_device *bdev = dev_state->bdev;\n\tunsigned int processed_len;\n\n\tif (NULL != bio_is_patched)\n\t\t*bio_is_patched = 0;\n\nagain:\n\tif (num_pages == 0)\n\t\treturn;\n\n\tprocessed_len = 0;\n\tis_metadata = (0 == btrfsic_test_for_metadata(state, mapped_datav,\n\t\t\t\t\t\t      num_pages));\n\n\tblock = btrfsic_block_hashtable_lookup(bdev, dev_bytenr,\n\t\t\t\t\t       &state->block_hashtable);\n\tif (NULL != block) {\n\t\tu64 bytenr = 0;\n\t\tstruct list_head *elem_ref_to;\n\t\tstruct list_head *tmp_ref_to;\n\n\t\tif (block->is_superblock) {\n\t\t\tbytenr = btrfs_super_bytenr((struct btrfs_super_block *)\n\t\t\t\t\t\t    mapped_datav[0]);\n\t\t\tif (num_pages * PAGE_CACHE_SIZE <\n\t\t\t    BTRFS_SUPER_INFO_SIZE) {\n\t\t\t\tprintk(KERN_INFO\n\t\t\t\t       \"btrfsic: cannot work with too short bios!\\n\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tis_metadata = 1;\n\t\t\tBUG_ON(BTRFS_SUPER_INFO_SIZE & (PAGE_CACHE_SIZE - 1));\n\t\t\tprocessed_len = BTRFS_SUPER_INFO_SIZE;\n\t\t\tif (state->print_mask &\n\t\t\t    BTRFSIC_PRINT_MASK_TREE_BEFORE_SB_WRITE) {\n\t\t\t\tprintk(KERN_INFO\n\t\t\t\t       \"[before new superblock is written]:\\n\");\n\t\t\t\tbtrfsic_dump_tree_sub(state, block, 0);\n\t\t\t}\n\t\t}\n\t\tif (is_metadata) {\n\t\t\tif (!block->is_superblock) {\n\t\t\t\tif (num_pages * PAGE_CACHE_SIZE <\n\t\t\t\t    state->metablock_size) {\n\t\t\t\t\tprintk(KERN_INFO\n\t\t\t\t\t       \"btrfsic: cannot work with too short bios!\\n\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tprocessed_len = state->metablock_size;\n\t\t\t\tbytenr = btrfs_stack_header_bytenr(\n\t\t\t\t\t\t(struct btrfs_header *)\n\t\t\t\t\t\tmapped_datav[0]);\n\t\t\t\tbtrfsic_cmp_log_and_dev_bytenr(state, bytenr,\n\t\t\t\t\t\t\t       dev_state,\n\t\t\t\t\t\t\t       dev_bytenr);\n\t\t\t}\n\t\t\tif (state->print_mask & BTRFSIC_PRINT_MASK_VERBOSE) {\n\t\t\t\tif (block->logical_bytenr != bytenr &&\n\t\t\t\t    !(!block->is_metadata &&\n\t\t\t\t      block->logical_bytenr == 0))\n\t\t\t\t\tprintk(KERN_INFO\n\t\t\t\t\t       \"Written block @%llu (%s/%llu/%d) found in hash table, %c, bytenr mismatch (!= stored %llu).\\n\",\n\t\t\t\t\t       bytenr, dev_state->name,\n\t\t\t\t\t       dev_bytenr,\n\t\t\t\t\t       block->mirror_num,\n\t\t\t\t\t       btrfsic_get_block_type(state,\n\t\t\t\t\t\t\t\t      block),\n\t\t\t\t\t       block->logical_bytenr);\n\t\t\t\telse\n\t\t\t\t\tprintk(KERN_INFO\n\t\t\t\t\t       \"Written block @%llu (%s/%llu/%d) found in hash table, %c.\\n\",\n\t\t\t\t\t       bytenr, dev_state->name,\n\t\t\t\t\t       dev_bytenr, block->mirror_num,\n\t\t\t\t\t       btrfsic_get_block_type(state,\n\t\t\t\t\t\t\t\t      block));\n\t\t\t}\n\t\t\tblock->logical_bytenr = bytenr;\n\t\t} else {\n\t\t\tif (num_pages * PAGE_CACHE_SIZE <\n\t\t\t    state->datablock_size) {\n\t\t\t\tprintk(KERN_INFO\n\t\t\t\t       \"btrfsic: cannot work with too short bios!\\n\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tprocessed_len = state->datablock_size;\n\t\t\tbytenr = block->logical_bytenr;\n\t\t\tif (state->print_mask & BTRFSIC_PRINT_MASK_VERBOSE)\n\t\t\t\tprintk(KERN_INFO\n\t\t\t\t       \"Written block @%llu (%s/%llu/%d)\"\n\t\t\t\t       \" found in hash table, %c.\\n\",\n\t\t\t\t       bytenr, dev_state->name, dev_bytenr,\n\t\t\t\t       block->mirror_num,\n\t\t\t\t       btrfsic_get_block_type(state, block));\n\t\t}\n\n\t\tif (state->print_mask & BTRFSIC_PRINT_MASK_VERBOSE)\n\t\t\tprintk(KERN_INFO\n\t\t\t       \"ref_to_list: %cE, ref_from_list: %cE\\n\",\n\t\t\t       list_empty(&block->ref_to_list) ? ' ' : '!',\n\t\t\t       list_empty(&block->ref_from_list) ? ' ' : '!');\n\t\tif (btrfsic_is_block_ref_by_superblock(state, block, 0)) {\n\t\t\tprintk(KERN_INFO \"btrfs: attempt to overwrite %c-block\"\n\t\t\t       \" @%llu (%s/%llu/%d), old(gen=%llu,\"\n\t\t\t       \" objectid=%llu, type=%d, offset=%llu),\"\n\t\t\t       \" new(gen=%llu),\"\n\t\t\t       \" which is referenced by most recent superblock\"\n\t\t\t       \" (superblockgen=%llu)!\\n\",\n\t\t\t       btrfsic_get_block_type(state, block), bytenr,\n\t\t\t       dev_state->name, dev_bytenr, block->mirror_num,\n\t\t\t       block->generation,\n\t\t\t       btrfs_disk_key_objectid(&block->disk_key),\n\t\t\t       block->disk_key.type,\n\t\t\t       btrfs_disk_key_offset(&block->disk_key),\n\t\t\t       btrfs_stack_header_generation(\n\t\t\t\t       (struct btrfs_header *) mapped_datav[0]),\n\t\t\t       state->max_superblock_generation);\n\t\t\tbtrfsic_dump_tree(state);\n\t\t}\n\n\t\tif (!block->is_iodone && !block->never_written) {\n\t\t\tprintk(KERN_INFO \"btrfs: attempt to overwrite %c-block\"\n\t\t\t       \" @%llu (%s/%llu/%d), oldgen=%llu, newgen=%llu,\"\n\t\t\t       \" which is not yet iodone!\\n\",\n\t\t\t       btrfsic_get_block_type(state, block), bytenr,\n\t\t\t       dev_state->name, dev_bytenr, block->mirror_num,\n\t\t\t       block->generation,\n\t\t\t       btrfs_stack_header_generation(\n\t\t\t\t       (struct btrfs_header *)\n\t\t\t\t       mapped_datav[0]));\n\t\t\t/* it would not be safe to go on */\n\t\t\tbtrfsic_dump_tree(state);\n\t\t\tgoto continue_loop;\n\t\t}\n\n\t\t/*\n\t\t * Clear all references of this block. Do not free\n\t\t * the block itself even if is not referenced anymore\n\t\t * because it still carries valueable information\n\t\t * like whether it was ever written and IO completed.\n\t\t */\n\t\tlist_for_each_safe(elem_ref_to, tmp_ref_to,\n\t\t\t\t   &block->ref_to_list) {\n\t\t\tstruct btrfsic_block_link *const l =\n\t\t\t    list_entry(elem_ref_to,\n\t\t\t\t       struct btrfsic_block_link,\n\t\t\t\t       node_ref_to);\n\n\t\t\tif (state->print_mask & BTRFSIC_PRINT_MASK_VERBOSE)\n\t\t\t\tbtrfsic_print_rem_link(state, l);\n\t\t\tl->ref_cnt--;\n\t\t\tif (0 == l->ref_cnt) {\n\t\t\t\tlist_del(&l->node_ref_to);\n\t\t\t\tlist_del(&l->node_ref_from);\n\t\t\t\tbtrfsic_block_link_hashtable_remove(l);\n\t\t\t\tbtrfsic_block_link_free(l);\n\t\t\t}\n\t\t}\n\n\t\tblock_ctx.dev = dev_state;\n\t\tblock_ctx.dev_bytenr = dev_bytenr;\n\t\tblock_ctx.start = bytenr;\n\t\tblock_ctx.len = processed_len;\n\t\tblock_ctx.pagev = NULL;\n\t\tblock_ctx.mem_to_free = NULL;\n\t\tblock_ctx.datav = mapped_datav;\n\n\t\tif (is_metadata || state->include_extent_data) {\n\t\t\tblock->never_written = 0;\n\t\t\tblock->iodone_w_error = 0;\n\t\t\tif (NULL != bio) {\n\t\t\t\tblock->is_iodone = 0;\n\t\t\t\tBUG_ON(NULL == bio_is_patched);\n\t\t\t\tif (!*bio_is_patched) {\n\t\t\t\t\tblock->orig_bio_bh_private =\n\t\t\t\t\t    bio->bi_private;\n\t\t\t\t\tblock->orig_bio_bh_end_io.bio =\n\t\t\t\t\t    bio->bi_end_io;\n\t\t\t\t\tblock->next_in_same_bio = NULL;\n\t\t\t\t\tbio->bi_private = block;\n\t\t\t\t\tbio->bi_end_io = btrfsic_bio_end_io;\n\t\t\t\t\t*bio_is_patched = 1;\n\t\t\t\t} else {\n\t\t\t\t\tstruct btrfsic_block *chained_block =\n\t\t\t\t\t    (struct btrfsic_block *)\n\t\t\t\t\t    bio->bi_private;\n\n\t\t\t\t\tBUG_ON(NULL == chained_block);\n\t\t\t\t\tblock->orig_bio_bh_private =\n\t\t\t\t\t    chained_block->orig_bio_bh_private;\n\t\t\t\t\tblock->orig_bio_bh_end_io.bio =\n\t\t\t\t\t    chained_block->orig_bio_bh_end_io.\n\t\t\t\t\t    bio;\n\t\t\t\t\tblock->next_in_same_bio = chained_block;\n\t\t\t\t\tbio->bi_private = block;\n\t\t\t\t}\n\t\t\t} else if (NULL != bh) {\n\t\t\t\tblock->is_iodone = 0;\n\t\t\t\tblock->orig_bio_bh_private = bh->b_private;\n\t\t\t\tblock->orig_bio_bh_end_io.bh = bh->b_end_io;\n\t\t\t\tblock->next_in_same_bio = NULL;\n\t\t\t\tbh->b_private = block;\n\t\t\t\tbh->b_end_io = btrfsic_bh_end_io;\n\t\t\t} else {\n\t\t\t\tblock->is_iodone = 1;\n\t\t\t\tblock->orig_bio_bh_private = NULL;\n\t\t\t\tblock->orig_bio_bh_end_io.bio = NULL;\n\t\t\t\tblock->next_in_same_bio = NULL;\n\t\t\t}\n\t\t}\n\n\t\tblock->flush_gen = dev_state->last_flush_gen + 1;\n\t\tblock->submit_bio_bh_rw = submit_bio_bh_rw;\n\t\tif (is_metadata) {\n\t\t\tblock->logical_bytenr = bytenr;\n\t\t\tblock->is_metadata = 1;\n\t\t\tif (block->is_superblock) {\n\t\t\t\tBUG_ON(PAGE_CACHE_SIZE !=\n\t\t\t\t       BTRFS_SUPER_INFO_SIZE);\n\t\t\t\tret = btrfsic_process_written_superblock(\n\t\t\t\t\t\tstate,\n\t\t\t\t\t\tblock,\n\t\t\t\t\t\t(struct btrfs_super_block *)\n\t\t\t\t\t\tmapped_datav[0]);\n\t\t\t\tif (state->print_mask &\n\t\t\t\t    BTRFSIC_PRINT_MASK_TREE_AFTER_SB_WRITE) {\n\t\t\t\t\tprintk(KERN_INFO\n\t\t\t\t\t\"[after new superblock is written]:\\n\");\n\t\t\t\t\tbtrfsic_dump_tree_sub(state, block, 0);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tblock->mirror_num = 0;\t/* unknown */\n\t\t\t\tret = btrfsic_process_metablock(\n\t\t\t\t\t\tstate,\n\t\t\t\t\t\tblock,\n\t\t\t\t\t\t&block_ctx,\n\t\t\t\t\t\t0, 0);\n\t\t\t}\n\t\t\tif (ret)\n\t\t\t\tprintk(KERN_INFO\n\t\t\t\t       \"btrfsic: btrfsic_process_metablock\"\n\t\t\t\t       \"(root @%llu) failed!\\n\",\n\t\t\t\t       dev_bytenr);\n\t\t} else {\n\t\t\tblock->is_metadata = 0;\n\t\t\tblock->mirror_num = 0;\t/* unknown */\n\t\t\tblock->generation = BTRFSIC_GENERATION_UNKNOWN;\n\t\t\tif (!state->include_extent_data\n\t\t\t    && list_empty(&block->ref_from_list)) {\n\t\t\t\t/*\n\t\t\t\t * disk block is overwritten with extent\n\t\t\t\t * data (not meta data) and we are configured\n\t\t\t\t * to not include extent data: take the\n\t\t\t\t * chance and free the block's memory\n\t\t\t\t */\n\t\t\t\tbtrfsic_block_hashtable_remove(block);\n\t\t\t\tlist_del(&block->all_blocks_node);\n\t\t\t\tbtrfsic_block_free(block);\n\t\t\t}\n\t\t}\n\t\tbtrfsic_release_block_ctx(&block_ctx);\n\t} else {\n\t\t/* block has not been found in hash table */\n\t\tu64 bytenr;\n\n\t\tif (!is_metadata) {\n\t\t\tprocessed_len = state->datablock_size;\n\t\t\tif (state->print_mask & BTRFSIC_PRINT_MASK_VERBOSE)\n\t\t\t\tprintk(KERN_INFO \"Written block (%s/%llu/?)\"\n\t\t\t\t       \" !found in hash table, D.\\n\",\n\t\t\t\t       dev_state->name, dev_bytenr);\n\t\t\tif (!state->include_extent_data) {\n\t\t\t\t/* ignore that written D block */\n\t\t\t\tgoto continue_loop;\n\t\t\t}\n\n\t\t\t/* this is getting ugly for the\n\t\t\t * include_extent_data case... */\n\t\t\tbytenr = 0;\t/* unknown */\n\t\t} else {\n\t\t\tprocessed_len = state->metablock_size;\n\t\t\tbytenr = btrfs_stack_header_bytenr(\n\t\t\t\t\t(struct btrfs_header *)\n\t\t\t\t\tmapped_datav[0]);\n\t\t\tbtrfsic_cmp_log_and_dev_bytenr(state, bytenr, dev_state,\n\t\t\t\t\t\t       dev_bytenr);\n\t\t\tif (state->print_mask & BTRFSIC_PRINT_MASK_VERBOSE)\n\t\t\t\tprintk(KERN_INFO\n\t\t\t\t       \"Written block @%llu (%s/%llu/?)\"\n\t\t\t\t       \" !found in hash table, M.\\n\",\n\t\t\t\t       bytenr, dev_state->name, dev_bytenr);\n\t\t}\n\n\t\tblock_ctx.dev = dev_state;\n\t\tblock_ctx.dev_bytenr = dev_bytenr;\n\t\tblock_ctx.start = bytenr;\n\t\tblock_ctx.len = processed_len;\n\t\tblock_ctx.pagev = NULL;\n\t\tblock_ctx.mem_to_free = NULL;\n\t\tblock_ctx.datav = mapped_datav;\n\n\t\tblock = btrfsic_block_alloc();\n\t\tif (NULL == block) {\n\t\t\tprintk(KERN_INFO \"btrfsic: error, kmalloc failed!\\n\");\n\t\t\tbtrfsic_release_block_ctx(&block_ctx);\n\t\t\tgoto continue_loop;\n\t\t}\n\t\tblock->dev_state = dev_state;\n\t\tblock->dev_bytenr = dev_bytenr;\n\t\tblock->logical_bytenr = bytenr;\n\t\tblock->is_metadata = is_metadata;\n\t\tblock->never_written = 0;\n\t\tblock->iodone_w_error = 0;\n\t\tblock->mirror_num = 0;\t/* unknown */\n\t\tblock->flush_gen = dev_state->last_flush_gen + 1;\n\t\tblock->submit_bio_bh_rw = submit_bio_bh_rw;\n\t\tif (NULL != bio) {\n\t\t\tblock->is_iodone = 0;\n\t\t\tBUG_ON(NULL == bio_is_patched);\n\t\t\tif (!*bio_is_patched) {\n\t\t\t\tblock->orig_bio_bh_private = bio->bi_private;\n\t\t\t\tblock->orig_bio_bh_end_io.bio = bio->bi_end_io;\n\t\t\t\tblock->next_in_same_bio = NULL;\n\t\t\t\tbio->bi_private = block;\n\t\t\t\tbio->bi_end_io = btrfsic_bio_end_io;\n\t\t\t\t*bio_is_patched = 1;\n\t\t\t} else {\n\t\t\t\tstruct btrfsic_block *chained_block =\n\t\t\t\t    (struct btrfsic_block *)\n\t\t\t\t    bio->bi_private;\n\n\t\t\t\tBUG_ON(NULL == chained_block);\n\t\t\t\tblock->orig_bio_bh_private =\n\t\t\t\t    chained_block->orig_bio_bh_private;\n\t\t\t\tblock->orig_bio_bh_end_io.bio =\n\t\t\t\t    chained_block->orig_bio_bh_end_io.bio;\n\t\t\t\tblock->next_in_same_bio = chained_block;\n\t\t\t\tbio->bi_private = block;\n\t\t\t}\n\t\t} else if (NULL != bh) {\n\t\t\tblock->is_iodone = 0;\n\t\t\tblock->orig_bio_bh_private = bh->b_private;\n\t\t\tblock->orig_bio_bh_end_io.bh = bh->b_end_io;\n\t\t\tblock->next_in_same_bio = NULL;\n\t\t\tbh->b_private = block;\n\t\t\tbh->b_end_io = btrfsic_bh_end_io;\n\t\t} else {\n\t\t\tblock->is_iodone = 1;\n\t\t\tblock->orig_bio_bh_private = NULL;\n\t\t\tblock->orig_bio_bh_end_io.bio = NULL;\n\t\t\tblock->next_in_same_bio = NULL;\n\t\t}\n\t\tif (state->print_mask & BTRFSIC_PRINT_MASK_VERBOSE)\n\t\t\tprintk(KERN_INFO\n\t\t\t       \"New written %c-block @%llu (%s/%llu/%d)\\n\",\n\t\t\t       is_metadata ? 'M' : 'D',\n\t\t\t       block->logical_bytenr, block->dev_state->name,\n\t\t\t       block->dev_bytenr, block->mirror_num);\n\t\tlist_add(&block->all_blocks_node, &state->all_blocks_list);\n\t\tbtrfsic_block_hashtable_add(block, &state->block_hashtable);\n\n\t\tif (is_metadata) {\n\t\t\tret = btrfsic_process_metablock(state, block,\n\t\t\t\t\t\t\t&block_ctx, 0, 0);\n\t\t\tif (ret)\n\t\t\t\tprintk(KERN_INFO\n\t\t\t\t       \"btrfsic: process_metablock(root @%llu)\"\n\t\t\t\t       \" failed!\\n\",\n\t\t\t\t       dev_bytenr);\n\t\t}\n\t\tbtrfsic_release_block_ctx(&block_ctx);\n\t}\n\ncontinue_loop:\n\tBUG_ON(!processed_len);\n\tdev_bytenr += processed_len;\n\tmapped_datav += processed_len >> PAGE_CACHE_SHIFT;\n\tnum_pages -= processed_len >> PAGE_CACHE_SHIFT;\n\tgoto again;\n}"
  },
  {
    "function_name": "btrfsic_test_for_metadata",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/check-integrity.c",
    "lines": "1788-1816",
    "snippet": "static int btrfsic_test_for_metadata(struct btrfsic_state *state,\n\t\t\t\t     char **datav, unsigned int num_pages)\n{\n\tstruct btrfs_header *h;\n\tu8 csum[BTRFS_CSUM_SIZE];\n\tu32 crc = ~(u32)0;\n\tunsigned int i;\n\n\tif (num_pages * PAGE_CACHE_SIZE < state->metablock_size)\n\t\treturn 1; /* not metadata */\n\tnum_pages = state->metablock_size >> PAGE_CACHE_SHIFT;\n\th = (struct btrfs_header *)datav[0];\n\n\tif (memcmp(h->fsid, state->root->fs_info->fsid, BTRFS_UUID_SIZE))\n\t\treturn 1;\n\n\tfor (i = 0; i < num_pages; i++) {\n\t\tu8 *data = i ? datav[i] : (datav[i] + BTRFS_CSUM_SIZE);\n\t\tsize_t sublen = i ? PAGE_CACHE_SIZE :\n\t\t\t\t    (PAGE_CACHE_SIZE - BTRFS_CSUM_SIZE);\n\n\t\tcrc = btrfs_crc32c(crc, data, sublen);\n\t}\n\tbtrfs_csum_final(crc, csum);\n\tif (memcmp(csum, h->csum, state->csum_size))\n\t\treturn 1;\n\n\treturn 0; /* is metadata */\n}",
    "includes": [
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"volumes.h\"",
      "#include \"extent_io.h\"",
      "#include \"transaction.h\"",
      "#include \"hash.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/genhd.h>",
      "#include <linux/mutex.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void btrfsic_block_hashtable_init(struct btrfsic_block_hashtable *h);",
      "static void btrfsic_block_hashtable_add(struct btrfsic_block *b,\n\t\t\t\t\tstruct btrfsic_block_hashtable *h);",
      "static struct btrfsic_block *btrfsic_block_hashtable_lookup(\n\t\tstruct block_device *bdev,\n\t\tu64 dev_bytenr,\n\t\tstruct btrfsic_block_hashtable *h);",
      "static void btrfsic_block_link_hashtable_init(\n\t\tstruct btrfsic_block_link_hashtable *h);",
      "static void btrfsic_block_link_hashtable_add(\n\t\tstruct btrfsic_block_link *l,\n\t\tstruct btrfsic_block_link_hashtable *h);",
      "static struct btrfsic_block_link *btrfsic_block_link_hashtable_lookup(\n\t\tstruct block_device *bdev_ref_to,\n\t\tu64 dev_bytenr_ref_to,\n\t\tstruct block_device *bdev_ref_from,\n\t\tu64 dev_bytenr_ref_from,\n\t\tstruct btrfsic_block_link_hashtable *h);",
      "static void btrfsic_dev_state_hashtable_init(\n\t\tstruct btrfsic_dev_state_hashtable *h);",
      "static void btrfsic_dev_state_hashtable_add(\n\t\tstruct btrfsic_dev_state *ds,\n\t\tstruct btrfsic_dev_state_hashtable *h);",
      "static struct btrfsic_dev_state *btrfsic_dev_state_hashtable_lookup(\n\t\tstruct block_device *bdev,\n\t\tstruct btrfsic_dev_state_hashtable *h);",
      "static void btrfsic_dump_database(struct btrfsic_state *state);",
      "static int btrfsic_test_for_metadata(struct btrfsic_state *state,\n\t\t\t\t     char **datav, unsigned int num_pages);",
      "static void btrfsic_dump_tree(const struct btrfsic_state *state);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "csum",
            "h->csum",
            "state->csum_size"
          ],
          "line": 1812
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_csum_final",
          "args": [
            "crc",
            "csum"
          ],
          "line": 1811
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_csum_final",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "268-271",
          "snippet": "void btrfs_csum_final(u32 crc, char *result)\n{\n\tput_unaligned_le32(~crc, result);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nvoid btrfs_csum_final(u32 crc, char *result)\n{\n\tput_unaligned_le32(~crc, result);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_crc32c",
          "args": [
            "crc",
            "data",
            "sublen"
          ],
          "line": 1809
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_crc32c",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/hash.c",
          "lines": "32-46",
          "snippet": "u32 btrfs_crc32c(u32 crc, const void *address, unsigned int length)\n{\n\tSHASH_DESC_ON_STACK(shash, tfm);\n\tu32 *ctx = (u32 *)shash_desc_ctx(shash);\n\tint err;\n\n\tshash->tfm = tfm;\n\tshash->flags = 0;\n\t*ctx = crc;\n\n\terr = crypto_shash_update(shash, address, length);\n\tBUG_ON(err);\n\n\treturn *ctx;\n}",
          "includes": [
            "#include \"hash.h\"",
            "#include <linux/err.h>",
            "#include <crypto/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct crypto_shash *tfm;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hash.h\"\n#include <linux/err.h>\n#include <crypto/hash.h>\n\nstatic struct crypto_shash *tfm;\n\nu32 btrfs_crc32c(u32 crc, const void *address, unsigned int length)\n{\n\tSHASH_DESC_ON_STACK(shash, tfm);\n\tu32 *ctx = (u32 *)shash_desc_ctx(shash);\n\tint err;\n\n\tshash->tfm = tfm;\n\tshash->flags = 0;\n\t*ctx = crc;\n\n\terr = crypto_shash_update(shash, address, length);\n\tBUG_ON(err);\n\n\treturn *ctx;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "h->fsid",
            "state->root->fs_info->fsid",
            "BTRFS_UUID_SIZE"
          ],
          "line": 1801
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"extent_io.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n#include <linux/blkdev.h>\n#include <linux/genhd.h>\n#include <linux/mutex.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic void btrfsic_block_hashtable_init(struct btrfsic_block_hashtable *h);\nstatic void btrfsic_block_hashtable_add(struct btrfsic_block *b,\n\t\t\t\t\tstruct btrfsic_block_hashtable *h);\nstatic struct btrfsic_block *btrfsic_block_hashtable_lookup(\n\t\tstruct block_device *bdev,\n\t\tu64 dev_bytenr,\n\t\tstruct btrfsic_block_hashtable *h);\nstatic void btrfsic_block_link_hashtable_init(\n\t\tstruct btrfsic_block_link_hashtable *h);\nstatic void btrfsic_block_link_hashtable_add(\n\t\tstruct btrfsic_block_link *l,\n\t\tstruct btrfsic_block_link_hashtable *h);\nstatic struct btrfsic_block_link *btrfsic_block_link_hashtable_lookup(\n\t\tstruct block_device *bdev_ref_to,\n\t\tu64 dev_bytenr_ref_to,\n\t\tstruct block_device *bdev_ref_from,\n\t\tu64 dev_bytenr_ref_from,\n\t\tstruct btrfsic_block_link_hashtable *h);\nstatic void btrfsic_dev_state_hashtable_init(\n\t\tstruct btrfsic_dev_state_hashtable *h);\nstatic void btrfsic_dev_state_hashtable_add(\n\t\tstruct btrfsic_dev_state *ds,\n\t\tstruct btrfsic_dev_state_hashtable *h);\nstatic struct btrfsic_dev_state *btrfsic_dev_state_hashtable_lookup(\n\t\tstruct block_device *bdev,\n\t\tstruct btrfsic_dev_state_hashtable *h);\nstatic void btrfsic_dump_database(struct btrfsic_state *state);\nstatic int btrfsic_test_for_metadata(struct btrfsic_state *state,\n\t\t\t\t     char **datav, unsigned int num_pages);\nstatic void btrfsic_dump_tree(const struct btrfsic_state *state);\n\nstatic int btrfsic_test_for_metadata(struct btrfsic_state *state,\n\t\t\t\t     char **datav, unsigned int num_pages)\n{\n\tstruct btrfs_header *h;\n\tu8 csum[BTRFS_CSUM_SIZE];\n\tu32 crc = ~(u32)0;\n\tunsigned int i;\n\n\tif (num_pages * PAGE_CACHE_SIZE < state->metablock_size)\n\t\treturn 1; /* not metadata */\n\tnum_pages = state->metablock_size >> PAGE_CACHE_SHIFT;\n\th = (struct btrfs_header *)datav[0];\n\n\tif (memcmp(h->fsid, state->root->fs_info->fsid, BTRFS_UUID_SIZE))\n\t\treturn 1;\n\n\tfor (i = 0; i < num_pages; i++) {\n\t\tu8 *data = i ? datav[i] : (datav[i] + BTRFS_CSUM_SIZE);\n\t\tsize_t sublen = i ? PAGE_CACHE_SIZE :\n\t\t\t\t    (PAGE_CACHE_SIZE - BTRFS_CSUM_SIZE);\n\n\t\tcrc = btrfs_crc32c(crc, data, sublen);\n\t}\n\tbtrfs_csum_final(crc, csum);\n\tif (memcmp(csum, h->csum, state->csum_size))\n\t\treturn 1;\n\n\treturn 0; /* is metadata */\n}"
  },
  {
    "function_name": "btrfsic_dump_database",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/check-integrity.c",
    "lines": "1721-1782",
    "snippet": "static void btrfsic_dump_database(struct btrfsic_state *state)\n{\n\tstruct list_head *elem_all;\n\n\tBUG_ON(NULL == state);\n\n\tprintk(KERN_INFO \"all_blocks_list:\\n\");\n\tlist_for_each(elem_all, &state->all_blocks_list) {\n\t\tconst struct btrfsic_block *const b_all =\n\t\t    list_entry(elem_all, struct btrfsic_block,\n\t\t\t       all_blocks_node);\n\t\tstruct list_head *elem_ref_to;\n\t\tstruct list_head *elem_ref_from;\n\n\t\tprintk(KERN_INFO \"%c-block @%llu (%s/%llu/%d)\\n\",\n\t\t       btrfsic_get_block_type(state, b_all),\n\t\t       b_all->logical_bytenr, b_all->dev_state->name,\n\t\t       b_all->dev_bytenr, b_all->mirror_num);\n\n\t\tlist_for_each(elem_ref_to, &b_all->ref_to_list) {\n\t\t\tconst struct btrfsic_block_link *const l =\n\t\t\t    list_entry(elem_ref_to,\n\t\t\t\t       struct btrfsic_block_link,\n\t\t\t\t       node_ref_to);\n\n\t\t\tprintk(KERN_INFO \" %c @%llu (%s/%llu/%d)\"\n\t\t\t       \" refers %u* to\"\n\t\t\t       \" %c @%llu (%s/%llu/%d)\\n\",\n\t\t\t       btrfsic_get_block_type(state, b_all),\n\t\t\t       b_all->logical_bytenr, b_all->dev_state->name,\n\t\t\t       b_all->dev_bytenr, b_all->mirror_num,\n\t\t\t       l->ref_cnt,\n\t\t\t       btrfsic_get_block_type(state, l->block_ref_to),\n\t\t\t       l->block_ref_to->logical_bytenr,\n\t\t\t       l->block_ref_to->dev_state->name,\n\t\t\t       l->block_ref_to->dev_bytenr,\n\t\t\t       l->block_ref_to->mirror_num);\n\t\t}\n\n\t\tlist_for_each(elem_ref_from, &b_all->ref_from_list) {\n\t\t\tconst struct btrfsic_block_link *const l =\n\t\t\t    list_entry(elem_ref_from,\n\t\t\t\t       struct btrfsic_block_link,\n\t\t\t\t       node_ref_from);\n\n\t\t\tprintk(KERN_INFO \" %c @%llu (%s/%llu/%d)\"\n\t\t\t       \" is ref %u* from\"\n\t\t\t       \" %c @%llu (%s/%llu/%d)\\n\",\n\t\t\t       btrfsic_get_block_type(state, b_all),\n\t\t\t       b_all->logical_bytenr, b_all->dev_state->name,\n\t\t\t       b_all->dev_bytenr, b_all->mirror_num,\n\t\t\t       l->ref_cnt,\n\t\t\t       btrfsic_get_block_type(state, l->block_ref_from),\n\t\t\t       l->block_ref_from->logical_bytenr,\n\t\t\t       l->block_ref_from->dev_state->name,\n\t\t\t       l->block_ref_from->dev_bytenr,\n\t\t\t       l->block_ref_from->mirror_num);\n\t\t}\n\n\t\tprintk(KERN_INFO \"\\n\");\n\t}\n}",
    "includes": [
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"volumes.h\"",
      "#include \"extent_io.h\"",
      "#include \"transaction.h\"",
      "#include \"hash.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/genhd.h>",
      "#include <linux/mutex.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void btrfsic_block_link_init(struct btrfsic_block_link *n);",
      "static void btrfsic_block_link_free(struct btrfsic_block_link *n);",
      "static void btrfsic_block_link_hashtable_remove(struct btrfsic_block_link *l);",
      "static int btrfsic_map_block(struct btrfsic_state *state, u64 bytenr, u32 len,\n\t\t\t     struct btrfsic_block_data_ctx *block_ctx_out,\n\t\t\t     int mirror_num);",
      "static void btrfsic_dump_database(struct btrfsic_state *state);",
      "static void btrfsic_print_add_link(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block_link *l);",
      "static void btrfsic_print_rem_link(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block_link *l);",
      "static char btrfsic_get_block_type(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block *block);",
      "static void btrfsic_dump_tree(const struct btrfsic_state *state);",
      "static void btrfsic_cmp_log_and_dev_bytenr(struct btrfsic_state *state,\n\t\t\t\t\t   u64 bytenr,\n\t\t\t\t\t   struct btrfsic_dev_state *dev_state,\n\t\t\t\t\t   u64 dev_bytenr);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_INFO \"\\n\""
          ],
          "line": 1780
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_INFO \" %c @%llu (%s/%llu/%d)\"\n\t\t\t       \" is ref %u* from\"\n\t\t\t       \" %c @%llu (%s/%llu/%d)\\n\"",
            "btrfsic_get_block_type(state, b_all)",
            "b_all->logical_bytenr",
            "b_all->dev_state->name",
            "b_all->dev_bytenr",
            "b_all->mirror_num",
            "l->ref_cnt",
            "btrfsic_get_block_type(state, l->block_ref_from)",
            "l->block_ref_from->logical_bytenr",
            "l->block_ref_from->dev_state->name",
            "l->block_ref_from->dev_bytenr",
            "l->block_ref_from->mirror_num"
          ],
          "line": 1766
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/super.c",
          "lines": "186-213",
          "snippet": "void btrfs_printk(const struct btrfs_fs_info *fs_info, const char *fmt, ...)\n{\n\tstruct super_block *sb = fs_info->sb;\n\tchar lvl[4];\n\tstruct va_format vaf;\n\tva_list args;\n\tconst char *type = logtypes[4];\n\tint kern_level;\n\n\tva_start(args, fmt);\n\n\tkern_level = printk_get_level(fmt);\n\tif (kern_level) {\n\t\tsize_t size = printk_skip_level(fmt) - fmt;\n\t\tmemcpy(lvl, fmt,  size);\n\t\tlvl[size] = '\\0';\n\t\tfmt += size;\n\t\ttype = logtypes[kern_level - '0'];\n\t} else\n\t\t*lvl = '\\0';\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sBTRFS %s (device %s): %pV\\n\", lvl, type, sb->s_id, &vaf);\n\n\tva_end(args);\n}",
          "includes": [
            "#include <trace/events/btrfs.h>",
            "#include \"qgroup.h\"",
            "#include \"tests/btrfs-tests.h\"",
            "#include \"backref.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"compression.h\"",
            "#include \"export.h\"",
            "#include \"volumes.h\"",
            "#include \"xattr.h\"",
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/slab.h>",
            "#include <linux/magic.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/namei.h>",
            "#include <linux/ctype.h>",
            "#include <linux/parser.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/btrfs.h>\n#include \"qgroup.h\"\n#include \"tests/btrfs-tests.h\"\n#include \"backref.h\"\n#include \"free-space-cache.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"compression.h\"\n#include \"export.h\"\n#include \"volumes.h\"\n#include \"xattr.h\"\n#include \"props.h\"\n#include \"hash.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include \"delayed-inode.h\"\n#include <linux/btrfs.h>\n#include <linux/ratelimit.h>\n#include <linux/cleancache.h>\n#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/miscdevice.h>\n#include <linux/namei.h>\n#include <linux/ctype.h>\n#include <linux/parser.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n\nvoid btrfs_printk(const struct btrfs_fs_info *fs_info, const char *fmt, ...)\n{\n\tstruct super_block *sb = fs_info->sb;\n\tchar lvl[4];\n\tstruct va_format vaf;\n\tva_list args;\n\tconst char *type = logtypes[4];\n\tint kern_level;\n\n\tva_start(args, fmt);\n\n\tkern_level = printk_get_level(fmt);\n\tif (kern_level) {\n\t\tsize_t size = printk_skip_level(fmt) - fmt;\n\t\tmemcpy(lvl, fmt,  size);\n\t\tlvl[size] = '\\0';\n\t\tfmt += size;\n\t\ttype = logtypes[kern_level - '0'];\n\t} else\n\t\t*lvl = '\\0';\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sBTRFS %s (device %s): %pV\\n\", lvl, type, sb->s_id, &vaf);\n\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfsic_get_block_type",
          "args": [
            "state",
            "l->block_ref_from"
          ],
          "line": 1773
        },
        "resolved": true,
        "details": {
          "function_name": "btrfsic_get_block_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/check-integrity.c",
          "lines": "2648-2661",
          "snippet": "static char btrfsic_get_block_type(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block *block)\n{\n\tif (block->is_superblock &&\n\t    state->latest_superblock->dev_bytenr == block->dev_bytenr &&\n\t    state->latest_superblock->dev_state->bdev == block->dev_state->bdev)\n\t\treturn 'S';\n\telse if (block->is_superblock)\n\t\treturn 's';\n\telse if (block->is_metadata)\n\t\treturn 'M';\n\telse\n\t\treturn 'D';\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"extent_io.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/genhd.h>",
            "#include <linux/mutex.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void btrfsic_dump_database(struct btrfsic_state *state);",
            "static char btrfsic_get_block_type(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block *block);",
            "static void btrfsic_dump_tree(const struct btrfsic_state *state);",
            "static struct btrfsic_dev_state *btrfsic_dev_state_lookup(\n\t\tstruct block_device *bdev);",
            "static void btrfsic_cmp_log_and_dev_bytenr(struct btrfsic_state *state,\n\t\t\t\t\t   u64 bytenr,\n\t\t\t\t\t   struct btrfsic_dev_state *dev_state,\n\t\t\t\t\t   u64 dev_bytenr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"extent_io.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n#include <linux/blkdev.h>\n#include <linux/genhd.h>\n#include <linux/mutex.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic void btrfsic_dump_database(struct btrfsic_state *state);\nstatic char btrfsic_get_block_type(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block *block);\nstatic void btrfsic_dump_tree(const struct btrfsic_state *state);\nstatic struct btrfsic_dev_state *btrfsic_dev_state_lookup(\n\t\tstruct block_device *bdev);\nstatic void btrfsic_cmp_log_and_dev_bytenr(struct btrfsic_state *state,\n\t\t\t\t\t   u64 bytenr,\n\t\t\t\t\t   struct btrfsic_dev_state *dev_state,\n\t\t\t\t\t   u64 dev_bytenr);\n\nstatic char btrfsic_get_block_type(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block *block)\n{\n\tif (block->is_superblock &&\n\t    state->latest_superblock->dev_bytenr == block->dev_bytenr &&\n\t    state->latest_superblock->dev_state->bdev == block->dev_state->bdev)\n\t\treturn 'S';\n\telse if (block->is_superblock)\n\t\treturn 's';\n\telse if (block->is_metadata)\n\t\treturn 'M';\n\telse\n\t\treturn 'D';\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "elem_ref_from",
            "structbtrfsic_block_link",
            "node_ref_from"
          ],
          "line": 1762
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each",
          "args": [
            "elem_ref_from",
            "&b_all->ref_from_list"
          ],
          "line": 1760
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "elem_ref_to",
            "structbtrfsic_block_link",
            "node_ref_to"
          ],
          "line": 1742
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each",
          "args": [
            "elem_ref_to",
            "&b_all->ref_to_list"
          ],
          "line": 1740
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "elem_all",
            "structbtrfsic_block",
            "all_blocks_node"
          ],
          "line": 1730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each",
          "args": [
            "elem_all",
            "&state->all_blocks_list"
          ],
          "line": 1728
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "NULL == state"
          ],
          "line": 1725
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"extent_io.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n#include <linux/blkdev.h>\n#include <linux/genhd.h>\n#include <linux/mutex.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic void btrfsic_block_link_init(struct btrfsic_block_link *n);\nstatic void btrfsic_block_link_free(struct btrfsic_block_link *n);\nstatic void btrfsic_block_link_hashtable_remove(struct btrfsic_block_link *l);\nstatic int btrfsic_map_block(struct btrfsic_state *state, u64 bytenr, u32 len,\n\t\t\t     struct btrfsic_block_data_ctx *block_ctx_out,\n\t\t\t     int mirror_num);\nstatic void btrfsic_dump_database(struct btrfsic_state *state);\nstatic void btrfsic_print_add_link(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block_link *l);\nstatic void btrfsic_print_rem_link(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block_link *l);\nstatic char btrfsic_get_block_type(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block *block);\nstatic void btrfsic_dump_tree(const struct btrfsic_state *state);\nstatic void btrfsic_cmp_log_and_dev_bytenr(struct btrfsic_state *state,\n\t\t\t\t\t   u64 bytenr,\n\t\t\t\t\t   struct btrfsic_dev_state *dev_state,\n\t\t\t\t\t   u64 dev_bytenr);\n\nstatic void btrfsic_dump_database(struct btrfsic_state *state)\n{\n\tstruct list_head *elem_all;\n\n\tBUG_ON(NULL == state);\n\n\tprintk(KERN_INFO \"all_blocks_list:\\n\");\n\tlist_for_each(elem_all, &state->all_blocks_list) {\n\t\tconst struct btrfsic_block *const b_all =\n\t\t    list_entry(elem_all, struct btrfsic_block,\n\t\t\t       all_blocks_node);\n\t\tstruct list_head *elem_ref_to;\n\t\tstruct list_head *elem_ref_from;\n\n\t\tprintk(KERN_INFO \"%c-block @%llu (%s/%llu/%d)\\n\",\n\t\t       btrfsic_get_block_type(state, b_all),\n\t\t       b_all->logical_bytenr, b_all->dev_state->name,\n\t\t       b_all->dev_bytenr, b_all->mirror_num);\n\n\t\tlist_for_each(elem_ref_to, &b_all->ref_to_list) {\n\t\t\tconst struct btrfsic_block_link *const l =\n\t\t\t    list_entry(elem_ref_to,\n\t\t\t\t       struct btrfsic_block_link,\n\t\t\t\t       node_ref_to);\n\n\t\t\tprintk(KERN_INFO \" %c @%llu (%s/%llu/%d)\"\n\t\t\t       \" refers %u* to\"\n\t\t\t       \" %c @%llu (%s/%llu/%d)\\n\",\n\t\t\t       btrfsic_get_block_type(state, b_all),\n\t\t\t       b_all->logical_bytenr, b_all->dev_state->name,\n\t\t\t       b_all->dev_bytenr, b_all->mirror_num,\n\t\t\t       l->ref_cnt,\n\t\t\t       btrfsic_get_block_type(state, l->block_ref_to),\n\t\t\t       l->block_ref_to->logical_bytenr,\n\t\t\t       l->block_ref_to->dev_state->name,\n\t\t\t       l->block_ref_to->dev_bytenr,\n\t\t\t       l->block_ref_to->mirror_num);\n\t\t}\n\n\t\tlist_for_each(elem_ref_from, &b_all->ref_from_list) {\n\t\t\tconst struct btrfsic_block_link *const l =\n\t\t\t    list_entry(elem_ref_from,\n\t\t\t\t       struct btrfsic_block_link,\n\t\t\t\t       node_ref_from);\n\n\t\t\tprintk(KERN_INFO \" %c @%llu (%s/%llu/%d)\"\n\t\t\t       \" is ref %u* from\"\n\t\t\t       \" %c @%llu (%s/%llu/%d)\\n\",\n\t\t\t       btrfsic_get_block_type(state, b_all),\n\t\t\t       b_all->logical_bytenr, b_all->dev_state->name,\n\t\t\t       b_all->dev_bytenr, b_all->mirror_num,\n\t\t\t       l->ref_cnt,\n\t\t\t       btrfsic_get_block_type(state, l->block_ref_from),\n\t\t\t       l->block_ref_from->logical_bytenr,\n\t\t\t       l->block_ref_from->dev_state->name,\n\t\t\t       l->block_ref_from->dev_bytenr,\n\t\t\t       l->block_ref_from->mirror_num);\n\t\t}\n\n\t\tprintk(KERN_INFO \"\\n\");\n\t}\n}"
  },
  {
    "function_name": "btrfsic_read_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/check-integrity.c",
    "lines": "1639-1719",
    "snippet": "static int btrfsic_read_block(struct btrfsic_state *state,\n\t\t\t      struct btrfsic_block_data_ctx *block_ctx)\n{\n\tunsigned int num_pages;\n\tunsigned int i;\n\tu64 dev_bytenr;\n\tint ret;\n\n\tBUG_ON(block_ctx->datav);\n\tBUG_ON(block_ctx->pagev);\n\tBUG_ON(block_ctx->mem_to_free);\n\tif (block_ctx->dev_bytenr & ((u64)PAGE_CACHE_SIZE - 1)) {\n\t\tprintk(KERN_INFO\n\t\t       \"btrfsic: read_block() with unaligned bytenr %llu\\n\",\n\t\t       block_ctx->dev_bytenr);\n\t\treturn -1;\n\t}\n\n\tnum_pages = (block_ctx->len + (u64)PAGE_CACHE_SIZE - 1) >>\n\t\t    PAGE_CACHE_SHIFT;\n\tblock_ctx->mem_to_free = kzalloc((sizeof(*block_ctx->datav) +\n\t\t\t\t\t  sizeof(*block_ctx->pagev)) *\n\t\t\t\t\t num_pages, GFP_NOFS);\n\tif (!block_ctx->mem_to_free)\n\t\treturn -1;\n\tblock_ctx->datav = block_ctx->mem_to_free;\n\tblock_ctx->pagev = (struct page **)(block_ctx->datav + num_pages);\n\tfor (i = 0; i < num_pages; i++) {\n\t\tblock_ctx->pagev[i] = alloc_page(GFP_NOFS);\n\t\tif (!block_ctx->pagev[i])\n\t\t\treturn -1;\n\t}\n\n\tdev_bytenr = block_ctx->dev_bytenr;\n\tfor (i = 0; i < num_pages;) {\n\t\tstruct bio *bio;\n\t\tunsigned int j;\n\n\t\tbio = btrfs_io_bio_alloc(GFP_NOFS, num_pages - i);\n\t\tif (!bio) {\n\t\t\tprintk(KERN_INFO\n\t\t\t       \"btrfsic: bio_alloc() for %u pages failed!\\n\",\n\t\t\t       num_pages - i);\n\t\t\treturn -1;\n\t\t}\n\t\tbio->bi_bdev = block_ctx->dev->bdev;\n\t\tbio->bi_iter.bi_sector = dev_bytenr >> 9;\n\n\t\tfor (j = i; j < num_pages; j++) {\n\t\t\tret = bio_add_page(bio, block_ctx->pagev[j],\n\t\t\t\t\t   PAGE_CACHE_SIZE, 0);\n\t\t\tif (PAGE_CACHE_SIZE != ret)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (j == i) {\n\t\t\tprintk(KERN_INFO\n\t\t\t       \"btrfsic: error, failed to add a single page!\\n\");\n\t\t\treturn -1;\n\t\t}\n\t\tif (submit_bio_wait(READ, bio)) {\n\t\t\tprintk(KERN_INFO\n\t\t\t       \"btrfsic: read error at logical %llu dev %s!\\n\",\n\t\t\t       block_ctx->start, block_ctx->dev->name);\n\t\t\tbio_put(bio);\n\t\t\treturn -1;\n\t\t}\n\t\tbio_put(bio);\n\t\tdev_bytenr += (j - i) * PAGE_CACHE_SIZE;\n\t\ti = j;\n\t}\n\tfor (i = 0; i < num_pages; i++) {\n\t\tblock_ctx->datav[i] = kmap(block_ctx->pagev[i]);\n\t\tif (!block_ctx->datav[i]) {\n\t\t\tprintk(KERN_INFO \"btrfsic: kmap() failed (dev %s)!\\n\",\n\t\t\t       block_ctx->dev->name);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn block_ctx->len;\n}",
    "includes": [
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"volumes.h\"",
      "#include \"extent_io.h\"",
      "#include \"transaction.h\"",
      "#include \"hash.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/genhd.h>",
      "#include <linux/mutex.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void btrfsic_block_link_init(struct btrfsic_block_link *n);",
      "static void btrfsic_block_link_free(struct btrfsic_block_link *n);",
      "static void btrfsic_read_from_block_data(\n\tstruct btrfsic_block_data_ctx *block_ctx,\n\tvoid *dst, u32 offset, size_t len);",
      "static void btrfsic_release_block_ctx(struct btrfsic_block_data_ctx *block_ctx);",
      "static int btrfsic_read_block(struct btrfsic_state *state,\n\t\t\t      struct btrfsic_block_data_ctx *block_ctx);",
      "static void btrfsic_dump_database(struct btrfsic_state *state);",
      "static int btrfsic_test_for_metadata(struct btrfsic_state *state,\n\t\t\t\t     char **datav, unsigned int num_pages);",
      "static void btrfsic_dump_tree(const struct btrfsic_state *state);",
      "static struct btrfsic_dev_state *btrfsic_dev_state_lookup(\n\t\tstruct block_device *bdev);",
      "static void btrfsic_cmp_log_and_dev_bytenr(struct btrfsic_state *state,\n\t\t\t\t\t   u64 bytenr,\n\t\t\t\t\t   struct btrfsic_dev_state *dev_state,\n\t\t\t\t\t   u64 dev_bytenr);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_INFO \"btrfsic: kmap() failed (dev %s)!\\n\"",
            "block_ctx->dev->name"
          ],
          "line": 1712
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/super.c",
          "lines": "186-213",
          "snippet": "void btrfs_printk(const struct btrfs_fs_info *fs_info, const char *fmt, ...)\n{\n\tstruct super_block *sb = fs_info->sb;\n\tchar lvl[4];\n\tstruct va_format vaf;\n\tva_list args;\n\tconst char *type = logtypes[4];\n\tint kern_level;\n\n\tva_start(args, fmt);\n\n\tkern_level = printk_get_level(fmt);\n\tif (kern_level) {\n\t\tsize_t size = printk_skip_level(fmt) - fmt;\n\t\tmemcpy(lvl, fmt,  size);\n\t\tlvl[size] = '\\0';\n\t\tfmt += size;\n\t\ttype = logtypes[kern_level - '0'];\n\t} else\n\t\t*lvl = '\\0';\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sBTRFS %s (device %s): %pV\\n\", lvl, type, sb->s_id, &vaf);\n\n\tva_end(args);\n}",
          "includes": [
            "#include <trace/events/btrfs.h>",
            "#include \"qgroup.h\"",
            "#include \"tests/btrfs-tests.h\"",
            "#include \"backref.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"compression.h\"",
            "#include \"export.h\"",
            "#include \"volumes.h\"",
            "#include \"xattr.h\"",
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/slab.h>",
            "#include <linux/magic.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/namei.h>",
            "#include <linux/ctype.h>",
            "#include <linux/parser.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/btrfs.h>\n#include \"qgroup.h\"\n#include \"tests/btrfs-tests.h\"\n#include \"backref.h\"\n#include \"free-space-cache.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"compression.h\"\n#include \"export.h\"\n#include \"volumes.h\"\n#include \"xattr.h\"\n#include \"props.h\"\n#include \"hash.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include \"delayed-inode.h\"\n#include <linux/btrfs.h>\n#include <linux/ratelimit.h>\n#include <linux/cleancache.h>\n#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/miscdevice.h>\n#include <linux/namei.h>\n#include <linux/ctype.h>\n#include <linux/parser.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n\nvoid btrfs_printk(const struct btrfs_fs_info *fs_info, const char *fmt, ...)\n{\n\tstruct super_block *sb = fs_info->sb;\n\tchar lvl[4];\n\tstruct va_format vaf;\n\tva_list args;\n\tconst char *type = logtypes[4];\n\tint kern_level;\n\n\tva_start(args, fmt);\n\n\tkern_level = printk_get_level(fmt);\n\tif (kern_level) {\n\t\tsize_t size = printk_skip_level(fmt) - fmt;\n\t\tmemcpy(lvl, fmt,  size);\n\t\tlvl[size] = '\\0';\n\t\tfmt += size;\n\t\ttype = logtypes[kern_level - '0'];\n\t} else\n\t\t*lvl = '\\0';\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sBTRFS %s (device %s): %pV\\n\", lvl, type, sb->s_id, &vaf);\n\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmap",
          "args": [
            "block_ctx->pagev[i]"
          ],
          "line": 1710
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bio_put",
          "args": [
            "bio"
          ],
          "line": 1705
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bio_put",
          "args": [
            "bio"
          ],
          "line": 1702
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "submit_bio_wait",
          "args": [
            "READ",
            "bio"
          ],
          "line": 1698
        },
        "resolved": true,
        "details": {
          "function_name": "btrfsic_submit_bio_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/check-integrity.c",
          "lines": "3067-3071",
          "snippet": "int btrfsic_submit_bio_wait(int rw, struct bio *bio)\n{\n\t__btrfsic_submit_bio(rw, bio);\n\treturn submit_bio_wait(rw, bio);\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"extent_io.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/genhd.h>",
            "#include <linux/mutex.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"extent_io.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n#include <linux/blkdev.h>\n#include <linux/genhd.h>\n#include <linux/mutex.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nint btrfsic_submit_bio_wait(int rw, struct bio *bio)\n{\n\t__btrfsic_submit_bio(rw, bio);\n\treturn submit_bio_wait(rw, bio);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_INFO\n\t\t\t       \"btrfsic: error, failed to add a single page!\\n\""
          ],
          "line": 1694
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bio_add_page",
          "args": [
            "bio",
            "block_ctx->pagev[j]",
            "PAGE_CACHE_SIZE",
            "0"
          ],
          "line": 1688
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_io_bio_alloc",
          "args": [
            "GFP_NOFS",
            "num_pages - i"
          ],
          "line": 1677
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_io_bio_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "2733-2746",
          "snippet": "struct bio *btrfs_io_bio_alloc(gfp_t gfp_mask, unsigned int nr_iovecs)\n{\n\tstruct btrfs_io_bio *btrfs_bio;\n\tstruct bio *bio;\n\n\tbio = bio_alloc_bioset(gfp_mask, nr_iovecs, btrfs_bioset);\n\tif (bio) {\n\t\tbtrfs_bio = btrfs_io_bio(bio);\n\t\tbtrfs_bio->csum = NULL;\n\t\tbtrfs_bio->csum_allocated = NULL;\n\t\tbtrfs_bio->end_io = NULL;\n\t}\n\treturn bio;\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct bio_set *btrfs_bioset;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic struct bio_set *btrfs_bioset;\n\nstruct bio *btrfs_io_bio_alloc(gfp_t gfp_mask, unsigned int nr_iovecs)\n{\n\tstruct btrfs_io_bio *btrfs_bio;\n\tstruct bio *bio;\n\n\tbio = bio_alloc_bioset(gfp_mask, nr_iovecs, btrfs_bioset);\n\tif (bio) {\n\t\tbtrfs_bio = btrfs_io_bio(bio);\n\t\tbtrfs_bio->csum = NULL;\n\t\tbtrfs_bio->csum_allocated = NULL;\n\t\tbtrfs_bio->end_io = NULL;\n\t}\n\treturn bio;\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_page",
          "args": [
            "GFP_NOFS"
          ],
          "line": 1667
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_alloc_pagevec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
          "lines": "86-105",
          "snippet": "static void **dlm_alloc_pagevec(int pages)\n{\n\tvoid **vec = kmalloc(pages * sizeof(void *), GFP_KERNEL);\n\tint i;\n\n\tif (!vec)\n\t\treturn NULL;\n\n\tfor (i = 0; i < pages; i++)\n\t\tif (!(vec[i] = (void *)__get_free_page(GFP_KERNEL)))\n\t\t\tgoto out_free;\n\n\tmlog(0, \"Allocated DLM hash pagevec; %d pages (%lu expected), %lu buckets per page\\n\",\n\t     pages, (unsigned long)DLM_HASH_PAGES,\n\t     (unsigned long)DLM_BUCKETS_PER_PAGE);\n\treturn vec;\nout_free:\n\tdlm_free_pagevec(vec, i);\n\treturn NULL;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/debugfs.h>",
            "#include <linux/err.h>",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic void **dlm_alloc_pagevec(int pages)\n{\n\tvoid **vec = kmalloc(pages * sizeof(void *), GFP_KERNEL);\n\tint i;\n\n\tif (!vec)\n\t\treturn NULL;\n\n\tfor (i = 0; i < pages; i++)\n\t\tif (!(vec[i] = (void *)__get_free_page(GFP_KERNEL)))\n\t\t\tgoto out_free;\n\n\tmlog(0, \"Allocated DLM hash pagevec; %d pages (%lu expected), %lu buckets per page\\n\",\n\t     pages, (unsigned long)DLM_HASH_PAGES,\n\t     (unsigned long)DLM_BUCKETS_PER_PAGE);\n\treturn vec;\nout_free:\n\tdlm_free_pagevec(vec, i);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "(sizeof(*block_ctx->datav) +\n\t\t\t\t\t  sizeof(*block_ctx->pagev)) *\n\t\t\t\t\t num_pages",
            "GFP_NOFS"
          ],
          "line": 1659
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "block_ctx->mem_to_free"
          ],
          "line": 1649
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "block_ctx->pagev"
          ],
          "line": 1648
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "block_ctx->datav"
          ],
          "line": 1647
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"extent_io.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n#include <linux/blkdev.h>\n#include <linux/genhd.h>\n#include <linux/mutex.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic void btrfsic_block_link_init(struct btrfsic_block_link *n);\nstatic void btrfsic_block_link_free(struct btrfsic_block_link *n);\nstatic void btrfsic_read_from_block_data(\n\tstruct btrfsic_block_data_ctx *block_ctx,\n\tvoid *dst, u32 offset, size_t len);\nstatic void btrfsic_release_block_ctx(struct btrfsic_block_data_ctx *block_ctx);\nstatic int btrfsic_read_block(struct btrfsic_state *state,\n\t\t\t      struct btrfsic_block_data_ctx *block_ctx);\nstatic void btrfsic_dump_database(struct btrfsic_state *state);\nstatic int btrfsic_test_for_metadata(struct btrfsic_state *state,\n\t\t\t\t     char **datav, unsigned int num_pages);\nstatic void btrfsic_dump_tree(const struct btrfsic_state *state);\nstatic struct btrfsic_dev_state *btrfsic_dev_state_lookup(\n\t\tstruct block_device *bdev);\nstatic void btrfsic_cmp_log_and_dev_bytenr(struct btrfsic_state *state,\n\t\t\t\t\t   u64 bytenr,\n\t\t\t\t\t   struct btrfsic_dev_state *dev_state,\n\t\t\t\t\t   u64 dev_bytenr);\n\nstatic int btrfsic_read_block(struct btrfsic_state *state,\n\t\t\t      struct btrfsic_block_data_ctx *block_ctx)\n{\n\tunsigned int num_pages;\n\tunsigned int i;\n\tu64 dev_bytenr;\n\tint ret;\n\n\tBUG_ON(block_ctx->datav);\n\tBUG_ON(block_ctx->pagev);\n\tBUG_ON(block_ctx->mem_to_free);\n\tif (block_ctx->dev_bytenr & ((u64)PAGE_CACHE_SIZE - 1)) {\n\t\tprintk(KERN_INFO\n\t\t       \"btrfsic: read_block() with unaligned bytenr %llu\\n\",\n\t\t       block_ctx->dev_bytenr);\n\t\treturn -1;\n\t}\n\n\tnum_pages = (block_ctx->len + (u64)PAGE_CACHE_SIZE - 1) >>\n\t\t    PAGE_CACHE_SHIFT;\n\tblock_ctx->mem_to_free = kzalloc((sizeof(*block_ctx->datav) +\n\t\t\t\t\t  sizeof(*block_ctx->pagev)) *\n\t\t\t\t\t num_pages, GFP_NOFS);\n\tif (!block_ctx->mem_to_free)\n\t\treturn -1;\n\tblock_ctx->datav = block_ctx->mem_to_free;\n\tblock_ctx->pagev = (struct page **)(block_ctx->datav + num_pages);\n\tfor (i = 0; i < num_pages; i++) {\n\t\tblock_ctx->pagev[i] = alloc_page(GFP_NOFS);\n\t\tif (!block_ctx->pagev[i])\n\t\t\treturn -1;\n\t}\n\n\tdev_bytenr = block_ctx->dev_bytenr;\n\tfor (i = 0; i < num_pages;) {\n\t\tstruct bio *bio;\n\t\tunsigned int j;\n\n\t\tbio = btrfs_io_bio_alloc(GFP_NOFS, num_pages - i);\n\t\tif (!bio) {\n\t\t\tprintk(KERN_INFO\n\t\t\t       \"btrfsic: bio_alloc() for %u pages failed!\\n\",\n\t\t\t       num_pages - i);\n\t\t\treturn -1;\n\t\t}\n\t\tbio->bi_bdev = block_ctx->dev->bdev;\n\t\tbio->bi_iter.bi_sector = dev_bytenr >> 9;\n\n\t\tfor (j = i; j < num_pages; j++) {\n\t\t\tret = bio_add_page(bio, block_ctx->pagev[j],\n\t\t\t\t\t   PAGE_CACHE_SIZE, 0);\n\t\t\tif (PAGE_CACHE_SIZE != ret)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (j == i) {\n\t\t\tprintk(KERN_INFO\n\t\t\t       \"btrfsic: error, failed to add a single page!\\n\");\n\t\t\treturn -1;\n\t\t}\n\t\tif (submit_bio_wait(READ, bio)) {\n\t\t\tprintk(KERN_INFO\n\t\t\t       \"btrfsic: read error at logical %llu dev %s!\\n\",\n\t\t\t       block_ctx->start, block_ctx->dev->name);\n\t\t\tbio_put(bio);\n\t\t\treturn -1;\n\t\t}\n\t\tbio_put(bio);\n\t\tdev_bytenr += (j - i) * PAGE_CACHE_SIZE;\n\t\ti = j;\n\t}\n\tfor (i = 0; i < num_pages; i++) {\n\t\tblock_ctx->datav[i] = kmap(block_ctx->pagev[i]);\n\t\tif (!block_ctx->datav[i]) {\n\t\t\tprintk(KERN_INFO \"btrfsic: kmap() failed (dev %s)!\\n\",\n\t\t\t       block_ctx->dev->name);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn block_ctx->len;\n}"
  },
  {
    "function_name": "btrfsic_release_block_ctx",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/check-integrity.c",
    "lines": "1611-1637",
    "snippet": "static void btrfsic_release_block_ctx(struct btrfsic_block_data_ctx *block_ctx)\n{\n\tif (block_ctx->mem_to_free) {\n\t\tunsigned int num_pages;\n\n\t\tBUG_ON(!block_ctx->datav);\n\t\tBUG_ON(!block_ctx->pagev);\n\t\tnum_pages = (block_ctx->len + (u64)PAGE_CACHE_SIZE - 1) >>\n\t\t\t    PAGE_CACHE_SHIFT;\n\t\twhile (num_pages > 0) {\n\t\t\tnum_pages--;\n\t\t\tif (block_ctx->datav[num_pages]) {\n\t\t\t\tkunmap(block_ctx->pagev[num_pages]);\n\t\t\t\tblock_ctx->datav[num_pages] = NULL;\n\t\t\t}\n\t\t\tif (block_ctx->pagev[num_pages]) {\n\t\t\t\t__free_page(block_ctx->pagev[num_pages]);\n\t\t\t\tblock_ctx->pagev[num_pages] = NULL;\n\t\t\t}\n\t\t}\n\n\t\tkfree(block_ctx->mem_to_free);\n\t\tblock_ctx->mem_to_free = NULL;\n\t\tblock_ctx->pagev = NULL;\n\t\tblock_ctx->datav = NULL;\n\t}\n}",
    "includes": [
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"volumes.h\"",
      "#include \"extent_io.h\"",
      "#include \"transaction.h\"",
      "#include \"hash.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/genhd.h>",
      "#include <linux/mutex.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void btrfsic_read_from_block_data(\n\tstruct btrfsic_block_data_ctx *block_ctx,\n\tvoid *dst, u32 offset, size_t len);",
      "static void btrfsic_release_block_ctx(struct btrfsic_block_data_ctx *block_ctx);",
      "static int btrfsic_read_block(struct btrfsic_state *state,\n\t\t\t      struct btrfsic_block_data_ctx *block_ctx);",
      "static int btrfsic_test_for_metadata(struct btrfsic_state *state,\n\t\t\t\t     char **datav, unsigned int num_pages);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "block_ctx->mem_to_free"
          ],
          "line": 1632
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__free_page",
          "args": [
            "block_ctx->pagev[num_pages]"
          ],
          "line": 1627
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kunmap",
          "args": [
            "block_ctx->pagev[num_pages]"
          ],
          "line": 1623
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!block_ctx->pagev"
          ],
          "line": 1617
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!block_ctx->datav"
          ],
          "line": 1616
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"extent_io.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n#include <linux/blkdev.h>\n#include <linux/genhd.h>\n#include <linux/mutex.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic void btrfsic_read_from_block_data(\n\tstruct btrfsic_block_data_ctx *block_ctx,\n\tvoid *dst, u32 offset, size_t len);\nstatic void btrfsic_release_block_ctx(struct btrfsic_block_data_ctx *block_ctx);\nstatic int btrfsic_read_block(struct btrfsic_state *state,\n\t\t\t      struct btrfsic_block_data_ctx *block_ctx);\nstatic int btrfsic_test_for_metadata(struct btrfsic_state *state,\n\t\t\t\t     char **datav, unsigned int num_pages);\n\nstatic void btrfsic_release_block_ctx(struct btrfsic_block_data_ctx *block_ctx)\n{\n\tif (block_ctx->mem_to_free) {\n\t\tunsigned int num_pages;\n\n\t\tBUG_ON(!block_ctx->datav);\n\t\tBUG_ON(!block_ctx->pagev);\n\t\tnum_pages = (block_ctx->len + (u64)PAGE_CACHE_SIZE - 1) >>\n\t\t\t    PAGE_CACHE_SHIFT;\n\t\twhile (num_pages > 0) {\n\t\t\tnum_pages--;\n\t\t\tif (block_ctx->datav[num_pages]) {\n\t\t\t\tkunmap(block_ctx->pagev[num_pages]);\n\t\t\t\tblock_ctx->datav[num_pages] = NULL;\n\t\t\t}\n\t\t\tif (block_ctx->pagev[num_pages]) {\n\t\t\t\t__free_page(block_ctx->pagev[num_pages]);\n\t\t\t\tblock_ctx->pagev[num_pages] = NULL;\n\t\t\t}\n\t\t}\n\n\t\tkfree(block_ctx->mem_to_free);\n\t\tblock_ctx->mem_to_free = NULL;\n\t\tblock_ctx->pagev = NULL;\n\t\tblock_ctx->datav = NULL;\n\t}\n}"
  },
  {
    "function_name": "btrfsic_map_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/check-integrity.c",
    "lines": "1568-1609",
    "snippet": "static int btrfsic_map_block(struct btrfsic_state *state, u64 bytenr, u32 len,\n\t\t\t     struct btrfsic_block_data_ctx *block_ctx_out,\n\t\t\t     int mirror_num)\n{\n\tint ret;\n\tu64 length;\n\tstruct btrfs_bio *multi = NULL;\n\tstruct btrfs_device *device;\n\n\tlength = len;\n\tret = btrfs_map_block(state->root->fs_info, READ,\n\t\t\t      bytenr, &length, &multi, mirror_num);\n\n\tif (ret) {\n\t\tblock_ctx_out->start = 0;\n\t\tblock_ctx_out->dev_bytenr = 0;\n\t\tblock_ctx_out->len = 0;\n\t\tblock_ctx_out->dev = NULL;\n\t\tblock_ctx_out->datav = NULL;\n\t\tblock_ctx_out->pagev = NULL;\n\t\tblock_ctx_out->mem_to_free = NULL;\n\n\t\treturn ret;\n\t}\n\n\tdevice = multi->stripes[0].dev;\n\tblock_ctx_out->dev = btrfsic_dev_state_lookup(device->bdev);\n\tblock_ctx_out->dev_bytenr = multi->stripes[0].physical;\n\tblock_ctx_out->start = bytenr;\n\tblock_ctx_out->len = len;\n\tblock_ctx_out->datav = NULL;\n\tblock_ctx_out->pagev = NULL;\n\tblock_ctx_out->mem_to_free = NULL;\n\n\tkfree(multi);\n\tif (NULL == block_ctx_out->dev) {\n\t\tret = -ENXIO;\n\t\tprintk(KERN_INFO \"btrfsic: error, cannot lookup dev (#1)!\\n\");\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"volumes.h\"",
      "#include \"extent_io.h\"",
      "#include \"transaction.h\"",
      "#include \"hash.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/genhd.h>",
      "#include <linux/mutex.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void btrfsic_block_link_init(struct btrfsic_block_link *n);",
      "static void btrfsic_block_link_free(struct btrfsic_block_link *n);",
      "static void btrfsic_read_from_block_data(\n\tstruct btrfsic_block_data_ctx *block_ctx,\n\tvoid *dst, u32 offset, size_t len);",
      "static int btrfsic_map_block(struct btrfsic_state *state, u64 bytenr, u32 len,\n\t\t\t     struct btrfsic_block_data_ctx *block_ctx_out,\n\t\t\t     int mirror_num);",
      "static void btrfsic_dump_database(struct btrfsic_state *state);",
      "static void btrfsic_dump_tree(const struct btrfsic_state *state);",
      "static struct btrfsic_dev_state *btrfsic_dev_state_lookup(\n\t\tstruct block_device *bdev);",
      "static void btrfsic_cmp_log_and_dev_bytenr(struct btrfsic_state *state,\n\t\t\t\t\t   u64 bytenr,\n\t\t\t\t\t   struct btrfsic_dev_state *dev_state,\n\t\t\t\t\t   u64 dev_bytenr);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_INFO \"btrfsic: error, cannot lookup dev (#1)!\\n\""
          ],
          "line": 1605
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "multi"
          ],
          "line": 1602
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfsic_dev_state_lookup",
          "args": [
            "device->bdev"
          ],
          "line": 1594
        },
        "resolved": true,
        "details": {
          "function_name": "btrfsic_dev_state_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/check-integrity.c",
          "lines": "2890-2898",
          "snippet": "static struct btrfsic_dev_state *btrfsic_dev_state_lookup(\n\t\tstruct block_device *bdev)\n{\n\tstruct btrfsic_dev_state *ds;\n\n\tds = btrfsic_dev_state_hashtable_lookup(bdev,\n\t\t\t\t\t\t&btrfsic_dev_state_hashtable);\n\treturn ds;\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"extent_io.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/genhd.h>",
            "#include <linux/mutex.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void btrfsic_dev_state_init(struct btrfsic_dev_state *ds);",
            "static void btrfsic_dev_state_free(struct btrfsic_dev_state *ds);",
            "static void btrfsic_dev_state_hashtable_remove(struct btrfsic_dev_state *ds);",
            "static struct btrfsic_dev_state *btrfsic_dev_state_lookup(\n\t\tstruct block_device *bdev);",
            "static struct btrfsic_dev_state_hashtable btrfsic_dev_state_hashtable;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"extent_io.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n#include <linux/blkdev.h>\n#include <linux/genhd.h>\n#include <linux/mutex.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic void btrfsic_dev_state_init(struct btrfsic_dev_state *ds);\nstatic void btrfsic_dev_state_free(struct btrfsic_dev_state *ds);\nstatic void btrfsic_dev_state_hashtable_remove(struct btrfsic_dev_state *ds);\nstatic struct btrfsic_dev_state *btrfsic_dev_state_lookup(\n\t\tstruct block_device *bdev);\nstatic struct btrfsic_dev_state_hashtable btrfsic_dev_state_hashtable;\n\nstatic struct btrfsic_dev_state *btrfsic_dev_state_lookup(\n\t\tstruct block_device *bdev)\n{\n\tstruct btrfsic_dev_state *ds;\n\n\tds = btrfsic_dev_state_hashtable_lookup(bdev,\n\t\t\t\t\t\t&btrfsic_dev_state_hashtable);\n\treturn ds;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_map_block",
          "args": [
            "state->root->fs_info",
            "READ",
            "bytenr",
            "&length",
            "&multi",
            "mirror_num"
          ],
          "line": 1578
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_map_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
          "lines": "5484-5490",
          "snippet": "int btrfs_map_block(struct btrfs_fs_info *fs_info, int rw,\n\t\t      u64 logical, u64 *length,\n\t\t      struct btrfs_bio **bbio_ret, int mirror_num)\n{\n\treturn __btrfs_map_block(fs_info, rw, logical, length, bbio_ret,\n\t\t\t\t mirror_num, 0);\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\nstatic noinline struct;\n\nint btrfs_map_block(struct btrfs_fs_info *fs_info, int rw,\n\t\t      u64 logical, u64 *length,\n\t\t      struct btrfs_bio **bbio_ret, int mirror_num)\n{\n\treturn __btrfs_map_block(fs_info, rw, logical, length, bbio_ret,\n\t\t\t\t mirror_num, 0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"extent_io.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n#include <linux/blkdev.h>\n#include <linux/genhd.h>\n#include <linux/mutex.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic void btrfsic_block_link_init(struct btrfsic_block_link *n);\nstatic void btrfsic_block_link_free(struct btrfsic_block_link *n);\nstatic void btrfsic_read_from_block_data(\n\tstruct btrfsic_block_data_ctx *block_ctx,\n\tvoid *dst, u32 offset, size_t len);\nstatic int btrfsic_map_block(struct btrfsic_state *state, u64 bytenr, u32 len,\n\t\t\t     struct btrfsic_block_data_ctx *block_ctx_out,\n\t\t\t     int mirror_num);\nstatic void btrfsic_dump_database(struct btrfsic_state *state);\nstatic void btrfsic_dump_tree(const struct btrfsic_state *state);\nstatic struct btrfsic_dev_state *btrfsic_dev_state_lookup(\n\t\tstruct block_device *bdev);\nstatic void btrfsic_cmp_log_and_dev_bytenr(struct btrfsic_state *state,\n\t\t\t\t\t   u64 bytenr,\n\t\t\t\t\t   struct btrfsic_dev_state *dev_state,\n\t\t\t\t\t   u64 dev_bytenr);\n\nstatic int btrfsic_map_block(struct btrfsic_state *state, u64 bytenr, u32 len,\n\t\t\t     struct btrfsic_block_data_ctx *block_ctx_out,\n\t\t\t     int mirror_num)\n{\n\tint ret;\n\tu64 length;\n\tstruct btrfs_bio *multi = NULL;\n\tstruct btrfs_device *device;\n\n\tlength = len;\n\tret = btrfs_map_block(state->root->fs_info, READ,\n\t\t\t      bytenr, &length, &multi, mirror_num);\n\n\tif (ret) {\n\t\tblock_ctx_out->start = 0;\n\t\tblock_ctx_out->dev_bytenr = 0;\n\t\tblock_ctx_out->len = 0;\n\t\tblock_ctx_out->dev = NULL;\n\t\tblock_ctx_out->datav = NULL;\n\t\tblock_ctx_out->pagev = NULL;\n\t\tblock_ctx_out->mem_to_free = NULL;\n\n\t\treturn ret;\n\t}\n\n\tdevice = multi->stripes[0].dev;\n\tblock_ctx_out->dev = btrfsic_dev_state_lookup(device->bdev);\n\tblock_ctx_out->dev_bytenr = multi->stripes[0].physical;\n\tblock_ctx_out->start = bytenr;\n\tblock_ctx_out->len = len;\n\tblock_ctx_out->datav = NULL;\n\tblock_ctx_out->pagev = NULL;\n\tblock_ctx_out->mem_to_free = NULL;\n\n\tkfree(multi);\n\tif (NULL == block_ctx_out->dev) {\n\t\tret = -ENXIO;\n\t\tprintk(KERN_INFO \"btrfsic: error, cannot lookup dev (#1)!\\n\");\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "btrfsic_handle_extent_data",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/check-integrity.c",
    "lines": "1411-1566",
    "snippet": "static int btrfsic_handle_extent_data(\n\t\tstruct btrfsic_state *state,\n\t\tstruct btrfsic_block *block,\n\t\tstruct btrfsic_block_data_ctx *block_ctx,\n\t\tu32 item_offset, int force_iodone_flag)\n{\n\tint ret;\n\tstruct btrfs_file_extent_item file_extent_item;\n\tu64 file_extent_item_offset;\n\tu64 next_bytenr;\n\tu64 num_bytes;\n\tu64 generation;\n\tstruct btrfsic_block_link *l;\n\n\tfile_extent_item_offset = offsetof(struct btrfs_leaf, items) +\n\t\t\t\t  item_offset;\n\tif (file_extent_item_offset +\n\t    offsetof(struct btrfs_file_extent_item, disk_num_bytes) >\n\t    block_ctx->len) {\n\t\tprintk(KERN_INFO\n\t\t       \"btrfsic: file item out of bounce at logical %llu, dev %s\\n\",\n\t\t       block_ctx->start, block_ctx->dev->name);\n\t\treturn -1;\n\t}\n\n\tbtrfsic_read_from_block_data(block_ctx, &file_extent_item,\n\t\tfile_extent_item_offset,\n\t\toffsetof(struct btrfs_file_extent_item, disk_num_bytes));\n\tif (BTRFS_FILE_EXTENT_REG != file_extent_item.type ||\n\t    btrfs_stack_file_extent_disk_bytenr(&file_extent_item) == 0) {\n\t\tif (state->print_mask & BTRFSIC_PRINT_MASK_VERY_VERBOSE)\n\t\t\tprintk(KERN_INFO \"extent_data: type %u, disk_bytenr = %llu\\n\",\n\t\t\t       file_extent_item.type,\n\t\t\t       btrfs_stack_file_extent_disk_bytenr(\n\t\t\t       &file_extent_item));\n\t\treturn 0;\n\t}\n\n\tif (file_extent_item_offset + sizeof(struct btrfs_file_extent_item) >\n\t    block_ctx->len) {\n\t\tprintk(KERN_INFO\n\t\t       \"btrfsic: file item out of bounce at logical %llu, dev %s\\n\",\n\t\t       block_ctx->start, block_ctx->dev->name);\n\t\treturn -1;\n\t}\n\tbtrfsic_read_from_block_data(block_ctx, &file_extent_item,\n\t\t\t\t     file_extent_item_offset,\n\t\t\t\t     sizeof(struct btrfs_file_extent_item));\n\tnext_bytenr = btrfs_stack_file_extent_disk_bytenr(&file_extent_item);\n\tif (btrfs_stack_file_extent_compression(&file_extent_item) ==\n\t    BTRFS_COMPRESS_NONE) {\n\t\tnext_bytenr += btrfs_stack_file_extent_offset(&file_extent_item);\n\t\tnum_bytes = btrfs_stack_file_extent_num_bytes(&file_extent_item);\n\t} else {\n\t\tnum_bytes = btrfs_stack_file_extent_disk_num_bytes(&file_extent_item);\n\t}\n\tgeneration = btrfs_stack_file_extent_generation(&file_extent_item);\n\n\tif (state->print_mask & BTRFSIC_PRINT_MASK_VERY_VERBOSE)\n\t\tprintk(KERN_INFO \"extent_data: type %u, disk_bytenr = %llu,\"\n\t\t       \" offset = %llu, num_bytes = %llu\\n\",\n\t\t       file_extent_item.type,\n\t\t       btrfs_stack_file_extent_disk_bytenr(&file_extent_item),\n\t\t       btrfs_stack_file_extent_offset(&file_extent_item),\n\t\t       num_bytes);\n\twhile (num_bytes > 0) {\n\t\tu32 chunk_len;\n\t\tint num_copies;\n\t\tint mirror_num;\n\n\t\tif (num_bytes > state->datablock_size)\n\t\t\tchunk_len = state->datablock_size;\n\t\telse\n\t\t\tchunk_len = num_bytes;\n\n\t\tnum_copies =\n\t\t    btrfs_num_copies(state->root->fs_info,\n\t\t\t\t     next_bytenr, state->datablock_size);\n\t\tif (state->print_mask & BTRFSIC_PRINT_MASK_NUM_COPIES)\n\t\t\tprintk(KERN_INFO \"num_copies(log_bytenr=%llu) = %d\\n\",\n\t\t\t       next_bytenr, num_copies);\n\t\tfor (mirror_num = 1; mirror_num <= num_copies; mirror_num++) {\n\t\t\tstruct btrfsic_block_data_ctx next_block_ctx;\n\t\t\tstruct btrfsic_block *next_block;\n\t\t\tint block_was_created;\n\n\t\t\tif (state->print_mask & BTRFSIC_PRINT_MASK_VERBOSE)\n\t\t\t\tprintk(KERN_INFO \"btrfsic_handle_extent_data(\"\n\t\t\t\t       \"mirror_num=%d)\\n\", mirror_num);\n\t\t\tif (state->print_mask & BTRFSIC_PRINT_MASK_VERY_VERBOSE)\n\t\t\t\tprintk(KERN_INFO\n\t\t\t\t       \"\\tdisk_bytenr = %llu, num_bytes %u\\n\",\n\t\t\t\t       next_bytenr, chunk_len);\n\t\t\tret = btrfsic_map_block(state, next_bytenr,\n\t\t\t\t\t\tchunk_len, &next_block_ctx,\n\t\t\t\t\t\tmirror_num);\n\t\t\tif (ret) {\n\t\t\t\tprintk(KERN_INFO\n\t\t\t\t       \"btrfsic: btrfsic_map_block(@%llu,\"\n\t\t\t\t       \" mirror=%d) failed!\\n\",\n\t\t\t\t       next_bytenr, mirror_num);\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tnext_block = btrfsic_block_lookup_or_add(\n\t\t\t\t\tstate,\n\t\t\t\t\t&next_block_ctx,\n\t\t\t\t\t\"referenced \",\n\t\t\t\t\t0,\n\t\t\t\t\tforce_iodone_flag,\n\t\t\t\t\t!force_iodone_flag,\n\t\t\t\t\tmirror_num,\n\t\t\t\t\t&block_was_created);\n\t\t\tif (NULL == next_block) {\n\t\t\t\tprintk(KERN_INFO\n\t\t\t\t       \"btrfsic: error, kmalloc failed!\\n\");\n\t\t\t\tbtrfsic_release_block_ctx(&next_block_ctx);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif (!block_was_created) {\n\t\t\t\tif ((state->print_mask &\n\t\t\t\t     BTRFSIC_PRINT_MASK_VERBOSE) &&\n\t\t\t\t    next_block->logical_bytenr != next_bytenr &&\n\t\t\t\t    !(!next_block->is_metadata &&\n\t\t\t\t      0 == next_block->logical_bytenr)) {\n\t\t\t\t\tprintk(KERN_INFO\n\t\t\t\t\t       \"Referenced block\"\n\t\t\t\t\t       \" @%llu (%s/%llu/%d)\"\n\t\t\t\t\t       \" found in hash table, D,\"\n\t\t\t\t\t       \" bytenr mismatch\"\n\t\t\t\t\t       \" (!= stored %llu).\\n\",\n\t\t\t\t\t       next_bytenr,\n\t\t\t\t\t       next_block_ctx.dev->name,\n\t\t\t\t\t       next_block_ctx.dev_bytenr,\n\t\t\t\t\t       mirror_num,\n\t\t\t\t\t       next_block->logical_bytenr);\n\t\t\t\t}\n\t\t\t\tnext_block->logical_bytenr = next_bytenr;\n\t\t\t\tnext_block->mirror_num = mirror_num;\n\t\t\t}\n\n\t\t\tl = btrfsic_block_link_lookup_or_add(state,\n\t\t\t\t\t\t\t     &next_block_ctx,\n\t\t\t\t\t\t\t     next_block, block,\n\t\t\t\t\t\t\t     generation);\n\t\t\tbtrfsic_release_block_ctx(&next_block_ctx);\n\t\t\tif (NULL == l)\n\t\t\t\treturn -1;\n\t\t}\n\n\t\tnext_bytenr += chunk_len;\n\t\tnum_bytes -= chunk_len;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"volumes.h\"",
      "#include \"extent_io.h\"",
      "#include \"transaction.h\"",
      "#include \"hash.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/genhd.h>",
      "#include <linux/mutex.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [
      "#define BTRFSIC_PRINT_MASK_NUM_COPIES\t\t\t\t0x00000800",
      "#define BTRFSIC_PRINT_MASK_VERY_VERBOSE\t\t\t\t0x00000080",
      "#define BTRFSIC_PRINT_MASK_VERBOSE\t\t\t\t0x00000040"
    ],
    "globals_used": [
      "static void btrfsic_block_link_init(struct btrfsic_block_link *n);",
      "static void btrfsic_block_link_free(struct btrfsic_block_link *n);",
      "static void btrfsic_block_link_hashtable_remove(struct btrfsic_block_link *l);",
      "static int btrfsic_process_metablock(struct btrfsic_state *state,\n\t\t\t\t     struct btrfsic_block *block,\n\t\t\t\t     struct btrfsic_block_data_ctx *block_ctx,\n\t\t\t\t     int limit_nesting, int force_iodone_flag);",
      "static void btrfsic_read_from_block_data(\n\tstruct btrfsic_block_data_ctx *block_ctx,\n\tvoid *dst, u32 offset, size_t len);",
      "static int btrfsic_handle_extent_data(struct btrfsic_state *state,\n\t\t\t\t      struct btrfsic_block *block,\n\t\t\t\t      struct btrfsic_block_data_ctx *block_ctx,\n\t\t\t\t      u32 item_offset, int force_iodone_flag);",
      "static int btrfsic_map_block(struct btrfsic_state *state, u64 bytenr, u32 len,\n\t\t\t     struct btrfsic_block_data_ctx *block_ctx_out,\n\t\t\t     int mirror_num);",
      "static void btrfsic_release_block_ctx(struct btrfsic_block_data_ctx *block_ctx);",
      "static int btrfsic_read_block(struct btrfsic_state *state,\n\t\t\t      struct btrfsic_block_data_ctx *block_ctx);",
      "static void btrfsic_dump_database(struct btrfsic_state *state);",
      "static void btrfsic_print_add_link(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block_link *l);",
      "static void btrfsic_print_rem_link(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block_link *l);",
      "static char btrfsic_get_block_type(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block *block);",
      "static void btrfsic_dump_tree(const struct btrfsic_state *state);",
      "static void btrfsic_cmp_log_and_dev_bytenr(struct btrfsic_state *state,\n\t\t\t\t\t   u64 bytenr,\n\t\t\t\t\t   struct btrfsic_dev_state *dev_state,\n\t\t\t\t\t   u64 dev_bytenr);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfsic_release_block_ctx",
          "args": [
            "&next_block_ctx"
          ],
          "line": 1556
        },
        "resolved": true,
        "details": {
          "function_name": "btrfsic_release_block_ctx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/check-integrity.c",
          "lines": "1611-1637",
          "snippet": "static void btrfsic_release_block_ctx(struct btrfsic_block_data_ctx *block_ctx)\n{\n\tif (block_ctx->mem_to_free) {\n\t\tunsigned int num_pages;\n\n\t\tBUG_ON(!block_ctx->datav);\n\t\tBUG_ON(!block_ctx->pagev);\n\t\tnum_pages = (block_ctx->len + (u64)PAGE_CACHE_SIZE - 1) >>\n\t\t\t    PAGE_CACHE_SHIFT;\n\t\twhile (num_pages > 0) {\n\t\t\tnum_pages--;\n\t\t\tif (block_ctx->datav[num_pages]) {\n\t\t\t\tkunmap(block_ctx->pagev[num_pages]);\n\t\t\t\tblock_ctx->datav[num_pages] = NULL;\n\t\t\t}\n\t\t\tif (block_ctx->pagev[num_pages]) {\n\t\t\t\t__free_page(block_ctx->pagev[num_pages]);\n\t\t\t\tblock_ctx->pagev[num_pages] = NULL;\n\t\t\t}\n\t\t}\n\n\t\tkfree(block_ctx->mem_to_free);\n\t\tblock_ctx->mem_to_free = NULL;\n\t\tblock_ctx->pagev = NULL;\n\t\tblock_ctx->datav = NULL;\n\t}\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"extent_io.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/genhd.h>",
            "#include <linux/mutex.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void btrfsic_read_from_block_data(\n\tstruct btrfsic_block_data_ctx *block_ctx,\n\tvoid *dst, u32 offset, size_t len);",
            "static void btrfsic_release_block_ctx(struct btrfsic_block_data_ctx *block_ctx);",
            "static int btrfsic_read_block(struct btrfsic_state *state,\n\t\t\t      struct btrfsic_block_data_ctx *block_ctx);",
            "static int btrfsic_test_for_metadata(struct btrfsic_state *state,\n\t\t\t\t     char **datav, unsigned int num_pages);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"extent_io.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n#include <linux/blkdev.h>\n#include <linux/genhd.h>\n#include <linux/mutex.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic void btrfsic_read_from_block_data(\n\tstruct btrfsic_block_data_ctx *block_ctx,\n\tvoid *dst, u32 offset, size_t len);\nstatic void btrfsic_release_block_ctx(struct btrfsic_block_data_ctx *block_ctx);\nstatic int btrfsic_read_block(struct btrfsic_state *state,\n\t\t\t      struct btrfsic_block_data_ctx *block_ctx);\nstatic int btrfsic_test_for_metadata(struct btrfsic_state *state,\n\t\t\t\t     char **datav, unsigned int num_pages);\n\nstatic void btrfsic_release_block_ctx(struct btrfsic_block_data_ctx *block_ctx)\n{\n\tif (block_ctx->mem_to_free) {\n\t\tunsigned int num_pages;\n\n\t\tBUG_ON(!block_ctx->datav);\n\t\tBUG_ON(!block_ctx->pagev);\n\t\tnum_pages = (block_ctx->len + (u64)PAGE_CACHE_SIZE - 1) >>\n\t\t\t    PAGE_CACHE_SHIFT;\n\t\twhile (num_pages > 0) {\n\t\t\tnum_pages--;\n\t\t\tif (block_ctx->datav[num_pages]) {\n\t\t\t\tkunmap(block_ctx->pagev[num_pages]);\n\t\t\t\tblock_ctx->datav[num_pages] = NULL;\n\t\t\t}\n\t\t\tif (block_ctx->pagev[num_pages]) {\n\t\t\t\t__free_page(block_ctx->pagev[num_pages]);\n\t\t\t\tblock_ctx->pagev[num_pages] = NULL;\n\t\t\t}\n\t\t}\n\n\t\tkfree(block_ctx->mem_to_free);\n\t\tblock_ctx->mem_to_free = NULL;\n\t\tblock_ctx->pagev = NULL;\n\t\tblock_ctx->datav = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfsic_block_link_lookup_or_add",
          "args": [
            "state",
            "&next_block_ctx",
            "next_block",
            "block",
            "generation"
          ],
          "line": 1552
        },
        "resolved": true,
        "details": {
          "function_name": "btrfsic_block_link_lookup_or_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/check-integrity.c",
          "lines": "2735-2778",
          "snippet": "static struct btrfsic_block_link *btrfsic_block_link_lookup_or_add(\n\t\tstruct btrfsic_state *state,\n\t\tstruct btrfsic_block_data_ctx *next_block_ctx,\n\t\tstruct btrfsic_block *next_block,\n\t\tstruct btrfsic_block *from_block,\n\t\tu64 parent_generation)\n{\n\tstruct btrfsic_block_link *l;\n\n\tl = btrfsic_block_link_hashtable_lookup(next_block_ctx->dev->bdev,\n\t\t\t\t\t\tnext_block_ctx->dev_bytenr,\n\t\t\t\t\t\tfrom_block->dev_state->bdev,\n\t\t\t\t\t\tfrom_block->dev_bytenr,\n\t\t\t\t\t\t&state->block_link_hashtable);\n\tif (NULL == l) {\n\t\tl = btrfsic_block_link_alloc();\n\t\tif (NULL == l) {\n\t\t\tprintk(KERN_INFO\n\t\t\t       \"btrfsic: error, kmalloc\" \" failed!\\n\");\n\t\t\treturn NULL;\n\t\t}\n\n\t\tl->block_ref_to = next_block;\n\t\tl->block_ref_from = from_block;\n\t\tl->ref_cnt = 1;\n\t\tl->parent_generation = parent_generation;\n\n\t\tif (state->print_mask & BTRFSIC_PRINT_MASK_VERBOSE)\n\t\t\tbtrfsic_print_add_link(state, l);\n\n\t\tlist_add(&l->node_ref_to, &from_block->ref_to_list);\n\t\tlist_add(&l->node_ref_from, &next_block->ref_from_list);\n\n\t\tbtrfsic_block_link_hashtable_add(l,\n\t\t\t\t\t\t &state->block_link_hashtable);\n\t} else {\n\t\tl->ref_cnt++;\n\t\tl->parent_generation = parent_generation;\n\t\tif (state->print_mask & BTRFSIC_PRINT_MASK_VERBOSE)\n\t\t\tbtrfsic_print_add_link(state, l);\n\t}\n\n\treturn l;\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"extent_io.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/genhd.h>",
            "#include <linux/mutex.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define BTRFSIC_PRINT_MASK_VERBOSE\t\t\t\t0x00000040"
          ],
          "globals_used": [
            "static void btrfsic_block_link_init(struct btrfsic_block_link *n);",
            "static struct btrfsic_block_link *btrfsic_block_link_alloc(void);",
            "static void btrfsic_block_link_free(struct btrfsic_block_link *n);",
            "static void btrfsic_block_link_hashtable_remove(struct btrfsic_block_link *l);",
            "static int btrfsic_create_link_to_next_block(\n\t\tstruct btrfsic_state *state,\n\t\tstruct btrfsic_block *block,\n\t\tstruct btrfsic_block_data_ctx\n\t\t*block_ctx, u64 next_bytenr,\n\t\tint limit_nesting,\n\t\tstruct btrfsic_block_data_ctx *next_block_ctx,\n\t\tstruct btrfsic_block **next_blockp,\n\t\tint force_iodone_flag,\n\t\tint *num_copiesp, int *mirror_nump,\n\t\tstruct btrfs_disk_key *disk_key,\n\t\tu64 parent_generation);",
            "static void btrfsic_dump_database(struct btrfsic_state *state);",
            "static void btrfsic_print_add_link(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block_link *l);",
            "static void btrfsic_print_rem_link(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block_link *l);",
            "static void btrfsic_dump_tree(const struct btrfsic_state *state);",
            "static struct btrfsic_block_link *btrfsic_block_link_lookup_or_add(\n\t\tstruct btrfsic_state *state,\n\t\tstruct btrfsic_block_data_ctx *next_block_ctx,\n\t\tstruct btrfsic_block *next_block,\n\t\tstruct btrfsic_block *from_block,\n\t\tu64 parent_generation);",
            "static struct btrfsic_dev_state *btrfsic_dev_state_lookup(\n\t\tstruct block_device *bdev);",
            "static void btrfsic_cmp_log_and_dev_bytenr(struct btrfsic_state *state,\n\t\t\t\t\t   u64 bytenr,\n\t\t\t\t\t   struct btrfsic_dev_state *dev_state,\n\t\t\t\t\t   u64 dev_bytenr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"extent_io.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n#include <linux/blkdev.h>\n#include <linux/genhd.h>\n#include <linux/mutex.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\n#define BTRFSIC_PRINT_MASK_VERBOSE\t\t\t\t0x00000040\n\nstatic void btrfsic_block_link_init(struct btrfsic_block_link *n);\nstatic struct btrfsic_block_link *btrfsic_block_link_alloc(void);\nstatic void btrfsic_block_link_free(struct btrfsic_block_link *n);\nstatic void btrfsic_block_link_hashtable_remove(struct btrfsic_block_link *l);\nstatic int btrfsic_create_link_to_next_block(\n\t\tstruct btrfsic_state *state,\n\t\tstruct btrfsic_block *block,\n\t\tstruct btrfsic_block_data_ctx\n\t\t*block_ctx, u64 next_bytenr,\n\t\tint limit_nesting,\n\t\tstruct btrfsic_block_data_ctx *next_block_ctx,\n\t\tstruct btrfsic_block **next_blockp,\n\t\tint force_iodone_flag,\n\t\tint *num_copiesp, int *mirror_nump,\n\t\tstruct btrfs_disk_key *disk_key,\n\t\tu64 parent_generation);\nstatic void btrfsic_dump_database(struct btrfsic_state *state);\nstatic void btrfsic_print_add_link(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block_link *l);\nstatic void btrfsic_print_rem_link(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block_link *l);\nstatic void btrfsic_dump_tree(const struct btrfsic_state *state);\nstatic struct btrfsic_block_link *btrfsic_block_link_lookup_or_add(\n\t\tstruct btrfsic_state *state,\n\t\tstruct btrfsic_block_data_ctx *next_block_ctx,\n\t\tstruct btrfsic_block *next_block,\n\t\tstruct btrfsic_block *from_block,\n\t\tu64 parent_generation);\nstatic struct btrfsic_dev_state *btrfsic_dev_state_lookup(\n\t\tstruct block_device *bdev);\nstatic void btrfsic_cmp_log_and_dev_bytenr(struct btrfsic_state *state,\n\t\t\t\t\t   u64 bytenr,\n\t\t\t\t\t   struct btrfsic_dev_state *dev_state,\n\t\t\t\t\t   u64 dev_bytenr);\n\nstatic struct btrfsic_block_link *btrfsic_block_link_lookup_or_add(\n\t\tstruct btrfsic_state *state,\n\t\tstruct btrfsic_block_data_ctx *next_block_ctx,\n\t\tstruct btrfsic_block *next_block,\n\t\tstruct btrfsic_block *from_block,\n\t\tu64 parent_generation)\n{\n\tstruct btrfsic_block_link *l;\n\n\tl = btrfsic_block_link_hashtable_lookup(next_block_ctx->dev->bdev,\n\t\t\t\t\t\tnext_block_ctx->dev_bytenr,\n\t\t\t\t\t\tfrom_block->dev_state->bdev,\n\t\t\t\t\t\tfrom_block->dev_bytenr,\n\t\t\t\t\t\t&state->block_link_hashtable);\n\tif (NULL == l) {\n\t\tl = btrfsic_block_link_alloc();\n\t\tif (NULL == l) {\n\t\t\tprintk(KERN_INFO\n\t\t\t       \"btrfsic: error, kmalloc\" \" failed!\\n\");\n\t\t\treturn NULL;\n\t\t}\n\n\t\tl->block_ref_to = next_block;\n\t\tl->block_ref_from = from_block;\n\t\tl->ref_cnt = 1;\n\t\tl->parent_generation = parent_generation;\n\n\t\tif (state->print_mask & BTRFSIC_PRINT_MASK_VERBOSE)\n\t\t\tbtrfsic_print_add_link(state, l);\n\n\t\tlist_add(&l->node_ref_to, &from_block->ref_to_list);\n\t\tlist_add(&l->node_ref_from, &next_block->ref_from_list);\n\n\t\tbtrfsic_block_link_hashtable_add(l,\n\t\t\t\t\t\t &state->block_link_hashtable);\n\t} else {\n\t\tl->ref_cnt++;\n\t\tl->parent_generation = parent_generation;\n\t\tif (state->print_mask & BTRFSIC_PRINT_MASK_VERBOSE)\n\t\t\tbtrfsic_print_add_link(state, l);\n\t}\n\n\treturn l;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_INFO\n\t\t\t\t\t       \"Referenced block\"\n\t\t\t\t\t       \" @%llu (%s/%llu/%d)\"\n\t\t\t\t\t       \" found in hash table, D,\"\n\t\t\t\t\t       \" bytenr mismatch\"\n\t\t\t\t\t       \" (!= stored %llu).\\n\"",
            "next_bytenr",
            "next_block_ctx.dev->name",
            "next_block_ctx.dev_bytenr",
            "mirror_num",
            "next_block->logical_bytenr"
          ],
          "line": 1536
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/super.c",
          "lines": "186-213",
          "snippet": "void btrfs_printk(const struct btrfs_fs_info *fs_info, const char *fmt, ...)\n{\n\tstruct super_block *sb = fs_info->sb;\n\tchar lvl[4];\n\tstruct va_format vaf;\n\tva_list args;\n\tconst char *type = logtypes[4];\n\tint kern_level;\n\n\tva_start(args, fmt);\n\n\tkern_level = printk_get_level(fmt);\n\tif (kern_level) {\n\t\tsize_t size = printk_skip_level(fmt) - fmt;\n\t\tmemcpy(lvl, fmt,  size);\n\t\tlvl[size] = '\\0';\n\t\tfmt += size;\n\t\ttype = logtypes[kern_level - '0'];\n\t} else\n\t\t*lvl = '\\0';\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sBTRFS %s (device %s): %pV\\n\", lvl, type, sb->s_id, &vaf);\n\n\tva_end(args);\n}",
          "includes": [
            "#include <trace/events/btrfs.h>",
            "#include \"qgroup.h\"",
            "#include \"tests/btrfs-tests.h\"",
            "#include \"backref.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"compression.h\"",
            "#include \"export.h\"",
            "#include \"volumes.h\"",
            "#include \"xattr.h\"",
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/slab.h>",
            "#include <linux/magic.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/namei.h>",
            "#include <linux/ctype.h>",
            "#include <linux/parser.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/btrfs.h>\n#include \"qgroup.h\"\n#include \"tests/btrfs-tests.h\"\n#include \"backref.h\"\n#include \"free-space-cache.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"compression.h\"\n#include \"export.h\"\n#include \"volumes.h\"\n#include \"xattr.h\"\n#include \"props.h\"\n#include \"hash.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include \"delayed-inode.h\"\n#include <linux/btrfs.h>\n#include <linux/ratelimit.h>\n#include <linux/cleancache.h>\n#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/miscdevice.h>\n#include <linux/namei.h>\n#include <linux/ctype.h>\n#include <linux/parser.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n\nvoid btrfs_printk(const struct btrfs_fs_info *fs_info, const char *fmt, ...)\n{\n\tstruct super_block *sb = fs_info->sb;\n\tchar lvl[4];\n\tstruct va_format vaf;\n\tva_list args;\n\tconst char *type = logtypes[4];\n\tint kern_level;\n\n\tva_start(args, fmt);\n\n\tkern_level = printk_get_level(fmt);\n\tif (kern_level) {\n\t\tsize_t size = printk_skip_level(fmt) - fmt;\n\t\tmemcpy(lvl, fmt,  size);\n\t\tlvl[size] = '\\0';\n\t\tfmt += size;\n\t\ttype = logtypes[kern_level - '0'];\n\t} else\n\t\t*lvl = '\\0';\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sBTRFS %s (device %s): %pV\\n\", lvl, type, sb->s_id, &vaf);\n\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_INFO\n\t\t\t\t       \"btrfsic: error, kmalloc failed!\\n\""
          ],
          "line": 1525
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfsic_block_lookup_or_add",
          "args": [
            "state",
            "&next_block_ctx",
            "\"referenced \"",
            "0",
            "force_iodone_flag",
            "!force_iodone_flag",
            "mirror_num",
            "&block_was_created"
          ],
          "line": 1515
        },
        "resolved": true,
        "details": {
          "function_name": "btrfsic_block_lookup_or_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/check-integrity.c",
          "lines": "2780-2834",
          "snippet": "static struct btrfsic_block *btrfsic_block_lookup_or_add(\n\t\tstruct btrfsic_state *state,\n\t\tstruct btrfsic_block_data_ctx *block_ctx,\n\t\tconst char *additional_string,\n\t\tint is_metadata,\n\t\tint is_iodone,\n\t\tint never_written,\n\t\tint mirror_num,\n\t\tint *was_created)\n{\n\tstruct btrfsic_block *block;\n\n\tblock = btrfsic_block_hashtable_lookup(block_ctx->dev->bdev,\n\t\t\t\t\t       block_ctx->dev_bytenr,\n\t\t\t\t\t       &state->block_hashtable);\n\tif (NULL == block) {\n\t\tstruct btrfsic_dev_state *dev_state;\n\n\t\tblock = btrfsic_block_alloc();\n\t\tif (NULL == block) {\n\t\t\tprintk(KERN_INFO \"btrfsic: error, kmalloc failed!\\n\");\n\t\t\treturn NULL;\n\t\t}\n\t\tdev_state = btrfsic_dev_state_lookup(block_ctx->dev->bdev);\n\t\tif (NULL == dev_state) {\n\t\t\tprintk(KERN_INFO\n\t\t\t       \"btrfsic: error, lookup dev_state failed!\\n\");\n\t\t\tbtrfsic_block_free(block);\n\t\t\treturn NULL;\n\t\t}\n\t\tblock->dev_state = dev_state;\n\t\tblock->dev_bytenr = block_ctx->dev_bytenr;\n\t\tblock->logical_bytenr = block_ctx->start;\n\t\tblock->is_metadata = is_metadata;\n\t\tblock->is_iodone = is_iodone;\n\t\tblock->never_written = never_written;\n\t\tblock->mirror_num = mirror_num;\n\t\tif (state->print_mask & BTRFSIC_PRINT_MASK_VERBOSE)\n\t\t\tprintk(KERN_INFO\n\t\t\t       \"New %s%c-block @%llu (%s/%llu/%d)\\n\",\n\t\t\t       additional_string,\n\t\t\t       btrfsic_get_block_type(state, block),\n\t\t\t       block->logical_bytenr, dev_state->name,\n\t\t\t       block->dev_bytenr, mirror_num);\n\t\tlist_add(&block->all_blocks_node, &state->all_blocks_list);\n\t\tbtrfsic_block_hashtable_add(block, &state->block_hashtable);\n\t\tif (NULL != was_created)\n\t\t\t*was_created = 1;\n\t} else {\n\t\tif (NULL != was_created)\n\t\t\t*was_created = 0;\n\t}\n\n\treturn block;\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"extent_io.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/genhd.h>",
            "#include <linux/mutex.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define BTRFSIC_PRINT_MASK_VERBOSE\t\t\t\t0x00000040"
          ],
          "globals_used": [
            "static struct btrfsic_block *btrfsic_block_alloc(void);",
            "static void btrfsic_block_link_init(struct btrfsic_block_link *n);",
            "static void btrfsic_block_link_free(struct btrfsic_block_link *n);",
            "static int btrfsic_map_block(struct btrfsic_state *state, u64 bytenr, u32 len,\n\t\t\t     struct btrfsic_block_data_ctx *block_ctx_out,\n\t\t\t     int mirror_num);",
            "static void btrfsic_release_block_ctx(struct btrfsic_block_data_ctx *block_ctx);",
            "static int btrfsic_read_block(struct btrfsic_state *state,\n\t\t\t      struct btrfsic_block_data_ctx *block_ctx);",
            "static void btrfsic_dump_database(struct btrfsic_state *state);",
            "static char btrfsic_get_block_type(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block *block);",
            "static void btrfsic_dump_tree(const struct btrfsic_state *state);",
            "static struct btrfsic_block *btrfsic_block_lookup_or_add(\n\t\tstruct btrfsic_state *state,\n\t\tstruct btrfsic_block_data_ctx *block_ctx,\n\t\tconst char *additional_string,\n\t\tint is_metadata,\n\t\tint is_iodone,\n\t\tint never_written,\n\t\tint mirror_num,\n\t\tint *was_created);",
            "static struct btrfsic_dev_state *btrfsic_dev_state_lookup(\n\t\tstruct block_device *bdev);",
            "static void btrfsic_cmp_log_and_dev_bytenr(struct btrfsic_state *state,\n\t\t\t\t\t   u64 bytenr,\n\t\t\t\t\t   struct btrfsic_dev_state *dev_state,\n\t\t\t\t\t   u64 dev_bytenr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"extent_io.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n#include <linux/blkdev.h>\n#include <linux/genhd.h>\n#include <linux/mutex.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\n#define BTRFSIC_PRINT_MASK_VERBOSE\t\t\t\t0x00000040\n\nstatic struct btrfsic_block *btrfsic_block_alloc(void);\nstatic void btrfsic_block_link_init(struct btrfsic_block_link *n);\nstatic void btrfsic_block_link_free(struct btrfsic_block_link *n);\nstatic int btrfsic_map_block(struct btrfsic_state *state, u64 bytenr, u32 len,\n\t\t\t     struct btrfsic_block_data_ctx *block_ctx_out,\n\t\t\t     int mirror_num);\nstatic void btrfsic_release_block_ctx(struct btrfsic_block_data_ctx *block_ctx);\nstatic int btrfsic_read_block(struct btrfsic_state *state,\n\t\t\t      struct btrfsic_block_data_ctx *block_ctx);\nstatic void btrfsic_dump_database(struct btrfsic_state *state);\nstatic char btrfsic_get_block_type(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block *block);\nstatic void btrfsic_dump_tree(const struct btrfsic_state *state);\nstatic struct btrfsic_block *btrfsic_block_lookup_or_add(\n\t\tstruct btrfsic_state *state,\n\t\tstruct btrfsic_block_data_ctx *block_ctx,\n\t\tconst char *additional_string,\n\t\tint is_metadata,\n\t\tint is_iodone,\n\t\tint never_written,\n\t\tint mirror_num,\n\t\tint *was_created);\nstatic struct btrfsic_dev_state *btrfsic_dev_state_lookup(\n\t\tstruct block_device *bdev);\nstatic void btrfsic_cmp_log_and_dev_bytenr(struct btrfsic_state *state,\n\t\t\t\t\t   u64 bytenr,\n\t\t\t\t\t   struct btrfsic_dev_state *dev_state,\n\t\t\t\t\t   u64 dev_bytenr);\n\nstatic struct btrfsic_block *btrfsic_block_lookup_or_add(\n\t\tstruct btrfsic_state *state,\n\t\tstruct btrfsic_block_data_ctx *block_ctx,\n\t\tconst char *additional_string,\n\t\tint is_metadata,\n\t\tint is_iodone,\n\t\tint never_written,\n\t\tint mirror_num,\n\t\tint *was_created)\n{\n\tstruct btrfsic_block *block;\n\n\tblock = btrfsic_block_hashtable_lookup(block_ctx->dev->bdev,\n\t\t\t\t\t       block_ctx->dev_bytenr,\n\t\t\t\t\t       &state->block_hashtable);\n\tif (NULL == block) {\n\t\tstruct btrfsic_dev_state *dev_state;\n\n\t\tblock = btrfsic_block_alloc();\n\t\tif (NULL == block) {\n\t\t\tprintk(KERN_INFO \"btrfsic: error, kmalloc failed!\\n\");\n\t\t\treturn NULL;\n\t\t}\n\t\tdev_state = btrfsic_dev_state_lookup(block_ctx->dev->bdev);\n\t\tif (NULL == dev_state) {\n\t\t\tprintk(KERN_INFO\n\t\t\t       \"btrfsic: error, lookup dev_state failed!\\n\");\n\t\t\tbtrfsic_block_free(block);\n\t\t\treturn NULL;\n\t\t}\n\t\tblock->dev_state = dev_state;\n\t\tblock->dev_bytenr = block_ctx->dev_bytenr;\n\t\tblock->logical_bytenr = block_ctx->start;\n\t\tblock->is_metadata = is_metadata;\n\t\tblock->is_iodone = is_iodone;\n\t\tblock->never_written = never_written;\n\t\tblock->mirror_num = mirror_num;\n\t\tif (state->print_mask & BTRFSIC_PRINT_MASK_VERBOSE)\n\t\t\tprintk(KERN_INFO\n\t\t\t       \"New %s%c-block @%llu (%s/%llu/%d)\\n\",\n\t\t\t       additional_string,\n\t\t\t       btrfsic_get_block_type(state, block),\n\t\t\t       block->logical_bytenr, dev_state->name,\n\t\t\t       block->dev_bytenr, mirror_num);\n\t\tlist_add(&block->all_blocks_node, &state->all_blocks_list);\n\t\tbtrfsic_block_hashtable_add(block, &state->block_hashtable);\n\t\tif (NULL != was_created)\n\t\t\t*was_created = 1;\n\t} else {\n\t\tif (NULL != was_created)\n\t\t\t*was_created = 0;\n\t}\n\n\treturn block;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfsic_map_block",
          "args": [
            "state",
            "next_bytenr",
            "chunk_len",
            "&next_block_ctx",
            "mirror_num"
          ],
          "line": 1504
        },
        "resolved": true,
        "details": {
          "function_name": "btrfsic_map_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/check-integrity.c",
          "lines": "1568-1609",
          "snippet": "static int btrfsic_map_block(struct btrfsic_state *state, u64 bytenr, u32 len,\n\t\t\t     struct btrfsic_block_data_ctx *block_ctx_out,\n\t\t\t     int mirror_num)\n{\n\tint ret;\n\tu64 length;\n\tstruct btrfs_bio *multi = NULL;\n\tstruct btrfs_device *device;\n\n\tlength = len;\n\tret = btrfs_map_block(state->root->fs_info, READ,\n\t\t\t      bytenr, &length, &multi, mirror_num);\n\n\tif (ret) {\n\t\tblock_ctx_out->start = 0;\n\t\tblock_ctx_out->dev_bytenr = 0;\n\t\tblock_ctx_out->len = 0;\n\t\tblock_ctx_out->dev = NULL;\n\t\tblock_ctx_out->datav = NULL;\n\t\tblock_ctx_out->pagev = NULL;\n\t\tblock_ctx_out->mem_to_free = NULL;\n\n\t\treturn ret;\n\t}\n\n\tdevice = multi->stripes[0].dev;\n\tblock_ctx_out->dev = btrfsic_dev_state_lookup(device->bdev);\n\tblock_ctx_out->dev_bytenr = multi->stripes[0].physical;\n\tblock_ctx_out->start = bytenr;\n\tblock_ctx_out->len = len;\n\tblock_ctx_out->datav = NULL;\n\tblock_ctx_out->pagev = NULL;\n\tblock_ctx_out->mem_to_free = NULL;\n\n\tkfree(multi);\n\tif (NULL == block_ctx_out->dev) {\n\t\tret = -ENXIO;\n\t\tprintk(KERN_INFO \"btrfsic: error, cannot lookup dev (#1)!\\n\");\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"extent_io.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/genhd.h>",
            "#include <linux/mutex.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void btrfsic_block_link_init(struct btrfsic_block_link *n);",
            "static void btrfsic_block_link_free(struct btrfsic_block_link *n);",
            "static void btrfsic_read_from_block_data(\n\tstruct btrfsic_block_data_ctx *block_ctx,\n\tvoid *dst, u32 offset, size_t len);",
            "static int btrfsic_map_block(struct btrfsic_state *state, u64 bytenr, u32 len,\n\t\t\t     struct btrfsic_block_data_ctx *block_ctx_out,\n\t\t\t     int mirror_num);",
            "static void btrfsic_dump_database(struct btrfsic_state *state);",
            "static void btrfsic_dump_tree(const struct btrfsic_state *state);",
            "static struct btrfsic_dev_state *btrfsic_dev_state_lookup(\n\t\tstruct block_device *bdev);",
            "static void btrfsic_cmp_log_and_dev_bytenr(struct btrfsic_state *state,\n\t\t\t\t\t   u64 bytenr,\n\t\t\t\t\t   struct btrfsic_dev_state *dev_state,\n\t\t\t\t\t   u64 dev_bytenr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"extent_io.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n#include <linux/blkdev.h>\n#include <linux/genhd.h>\n#include <linux/mutex.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic void btrfsic_block_link_init(struct btrfsic_block_link *n);\nstatic void btrfsic_block_link_free(struct btrfsic_block_link *n);\nstatic void btrfsic_read_from_block_data(\n\tstruct btrfsic_block_data_ctx *block_ctx,\n\tvoid *dst, u32 offset, size_t len);\nstatic int btrfsic_map_block(struct btrfsic_state *state, u64 bytenr, u32 len,\n\t\t\t     struct btrfsic_block_data_ctx *block_ctx_out,\n\t\t\t     int mirror_num);\nstatic void btrfsic_dump_database(struct btrfsic_state *state);\nstatic void btrfsic_dump_tree(const struct btrfsic_state *state);\nstatic struct btrfsic_dev_state *btrfsic_dev_state_lookup(\n\t\tstruct block_device *bdev);\nstatic void btrfsic_cmp_log_and_dev_bytenr(struct btrfsic_state *state,\n\t\t\t\t\t   u64 bytenr,\n\t\t\t\t\t   struct btrfsic_dev_state *dev_state,\n\t\t\t\t\t   u64 dev_bytenr);\n\nstatic int btrfsic_map_block(struct btrfsic_state *state, u64 bytenr, u32 len,\n\t\t\t     struct btrfsic_block_data_ctx *block_ctx_out,\n\t\t\t     int mirror_num)\n{\n\tint ret;\n\tu64 length;\n\tstruct btrfs_bio *multi = NULL;\n\tstruct btrfs_device *device;\n\n\tlength = len;\n\tret = btrfs_map_block(state->root->fs_info, READ,\n\t\t\t      bytenr, &length, &multi, mirror_num);\n\n\tif (ret) {\n\t\tblock_ctx_out->start = 0;\n\t\tblock_ctx_out->dev_bytenr = 0;\n\t\tblock_ctx_out->len = 0;\n\t\tblock_ctx_out->dev = NULL;\n\t\tblock_ctx_out->datav = NULL;\n\t\tblock_ctx_out->pagev = NULL;\n\t\tblock_ctx_out->mem_to_free = NULL;\n\n\t\treturn ret;\n\t}\n\n\tdevice = multi->stripes[0].dev;\n\tblock_ctx_out->dev = btrfsic_dev_state_lookup(device->bdev);\n\tblock_ctx_out->dev_bytenr = multi->stripes[0].physical;\n\tblock_ctx_out->start = bytenr;\n\tblock_ctx_out->len = len;\n\tblock_ctx_out->datav = NULL;\n\tblock_ctx_out->pagev = NULL;\n\tblock_ctx_out->mem_to_free = NULL;\n\n\tkfree(multi);\n\tif (NULL == block_ctx_out->dev) {\n\t\tret = -ENXIO;\n\t\tprintk(KERN_INFO \"btrfsic: error, cannot lookup dev (#1)!\\n\");\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_num_copies",
          "args": [
            "state->root->fs_info",
            "next_bytenr",
            "state->datablock_size"
          ],
          "line": 1487
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_num_copies",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
          "lines": "4740-4790",
          "snippet": "int btrfs_num_copies(struct btrfs_fs_info *fs_info, u64 logical, u64 len)\n{\n\tstruct btrfs_mapping_tree *map_tree = &fs_info->mapping_tree;\n\tstruct extent_map *em;\n\tstruct map_lookup *map;\n\tstruct extent_map_tree *em_tree = &map_tree->map_tree;\n\tint ret;\n\n\tread_lock(&em_tree->lock);\n\tem = lookup_extent_mapping(em_tree, logical, len);\n\tread_unlock(&em_tree->lock);\n\n\t/*\n\t * We could return errors for these cases, but that could get ugly and\n\t * we'd probably do the same thing which is just not do anything else\n\t * and exit, so return 1 so the callers don't try to use other copies.\n\t */\n\tif (!em) {\n\t\tbtrfs_crit(fs_info, \"No mapping for %Lu-%Lu\", logical,\n\t\t\t    logical+len);\n\t\treturn 1;\n\t}\n\n\tif (em->start > logical || em->start + em->len < logical) {\n\t\tbtrfs_crit(fs_info, \"Invalid mapping for %Lu-%Lu, got \"\n\t\t\t    \"%Lu-%Lu\", logical, logical+len, em->start,\n\t\t\t    em->start + em->len);\n\t\tfree_extent_map(em);\n\t\treturn 1;\n\t}\n\n\tmap = (struct map_lookup *)em->bdev;\n\tif (map->type & (BTRFS_BLOCK_GROUP_DUP | BTRFS_BLOCK_GROUP_RAID1))\n\t\tret = map->num_stripes;\n\telse if (map->type & BTRFS_BLOCK_GROUP_RAID10)\n\t\tret = map->sub_stripes;\n\telse if (map->type & BTRFS_BLOCK_GROUP_RAID5)\n\t\tret = 2;\n\telse if (map->type & BTRFS_BLOCK_GROUP_RAID6)\n\t\tret = 3;\n\telse\n\t\tret = 1;\n\tfree_extent_map(em);\n\n\tbtrfs_dev_replace_lock(&fs_info->dev_replace);\n\tif (btrfs_dev_replace_is_ongoing(&fs_info->dev_replace))\n\t\tret++;\n\tbtrfs_dev_replace_unlock(&fs_info->dev_replace);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\nstatic noinline struct;\n\nint btrfs_num_copies(struct btrfs_fs_info *fs_info, u64 logical, u64 len)\n{\n\tstruct btrfs_mapping_tree *map_tree = &fs_info->mapping_tree;\n\tstruct extent_map *em;\n\tstruct map_lookup *map;\n\tstruct extent_map_tree *em_tree = &map_tree->map_tree;\n\tint ret;\n\n\tread_lock(&em_tree->lock);\n\tem = lookup_extent_mapping(em_tree, logical, len);\n\tread_unlock(&em_tree->lock);\n\n\t/*\n\t * We could return errors for these cases, but that could get ugly and\n\t * we'd probably do the same thing which is just not do anything else\n\t * and exit, so return 1 so the callers don't try to use other copies.\n\t */\n\tif (!em) {\n\t\tbtrfs_crit(fs_info, \"No mapping for %Lu-%Lu\", logical,\n\t\t\t    logical+len);\n\t\treturn 1;\n\t}\n\n\tif (em->start > logical || em->start + em->len < logical) {\n\t\tbtrfs_crit(fs_info, \"Invalid mapping for %Lu-%Lu, got \"\n\t\t\t    \"%Lu-%Lu\", logical, logical+len, em->start,\n\t\t\t    em->start + em->len);\n\t\tfree_extent_map(em);\n\t\treturn 1;\n\t}\n\n\tmap = (struct map_lookup *)em->bdev;\n\tif (map->type & (BTRFS_BLOCK_GROUP_DUP | BTRFS_BLOCK_GROUP_RAID1))\n\t\tret = map->num_stripes;\n\telse if (map->type & BTRFS_BLOCK_GROUP_RAID10)\n\t\tret = map->sub_stripes;\n\telse if (map->type & BTRFS_BLOCK_GROUP_RAID5)\n\t\tret = 2;\n\telse if (map->type & BTRFS_BLOCK_GROUP_RAID6)\n\t\tret = 3;\n\telse\n\t\tret = 1;\n\tfree_extent_map(em);\n\n\tbtrfs_dev_replace_lock(&fs_info->dev_replace);\n\tif (btrfs_dev_replace_is_ongoing(&fs_info->dev_replace))\n\t\tret++;\n\tbtrfs_dev_replace_unlock(&fs_info->dev_replace);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_stack_file_extent_offset",
          "args": [
            "&file_extent_item"
          ],
          "line": 1474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_stack_file_extent_disk_bytenr",
          "args": [
            "&file_extent_item"
          ],
          "line": 1473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_stack_file_extent_generation",
          "args": [
            "&file_extent_item"
          ],
          "line": 1467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_stack_file_extent_disk_num_bytes",
          "args": [
            "&file_extent_item"
          ],
          "line": 1465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_stack_file_extent_num_bytes",
          "args": [
            "&file_extent_item"
          ],
          "line": 1463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_stack_file_extent_offset",
          "args": [
            "&file_extent_item"
          ],
          "line": 1462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_stack_file_extent_compression",
          "args": [
            "&file_extent_item"
          ],
          "line": 1460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_stack_file_extent_disk_bytenr",
          "args": [
            "&file_extent_item"
          ],
          "line": 1459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfsic_read_from_block_data",
          "args": [
            "block_ctx",
            "&file_extent_item",
            "file_extent_item_offset",
            "sizeof(struct btrfs_file_extent_item)"
          ],
          "line": 1456
        },
        "resolved": true,
        "details": {
          "function_name": "btrfsic_read_from_block_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/check-integrity.c",
          "lines": "1236-1261",
          "snippet": "static void btrfsic_read_from_block_data(\n\tstruct btrfsic_block_data_ctx *block_ctx,\n\tvoid *dstv, u32 offset, size_t len)\n{\n\tsize_t cur;\n\tsize_t offset_in_page;\n\tchar *kaddr;\n\tchar *dst = (char *)dstv;\n\tsize_t start_offset = block_ctx->start & ((u64)PAGE_CACHE_SIZE - 1);\n\tunsigned long i = (start_offset + offset) >> PAGE_CACHE_SHIFT;\n\n\tWARN_ON(offset + len > block_ctx->len);\n\toffset_in_page = (start_offset + offset) & (PAGE_CACHE_SIZE - 1);\n\n\twhile (len > 0) {\n\t\tcur = min(len, ((size_t)PAGE_CACHE_SIZE - offset_in_page));\n\t\tBUG_ON(i >= DIV_ROUND_UP(block_ctx->len, PAGE_CACHE_SIZE));\n\t\tkaddr = block_ctx->datav[i];\n\t\tmemcpy(dst, kaddr + offset_in_page, cur);\n\n\t\tdst += cur;\n\t\tlen -= cur;\n\t\toffset_in_page = 0;\n\t\ti++;\n\t}\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"extent_io.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/genhd.h>",
            "#include <linux/mutex.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void btrfsic_read_from_block_data(\n\tstruct btrfsic_block_data_ctx *block_ctx,\n\tvoid *dst, u32 offset, size_t len);",
            "static void btrfsic_release_block_ctx(struct btrfsic_block_data_ctx *block_ctx);",
            "static int btrfsic_read_block(struct btrfsic_state *state,\n\t\t\t      struct btrfsic_block_data_ctx *block_ctx);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"extent_io.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n#include <linux/blkdev.h>\n#include <linux/genhd.h>\n#include <linux/mutex.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic void btrfsic_read_from_block_data(\n\tstruct btrfsic_block_data_ctx *block_ctx,\n\tvoid *dst, u32 offset, size_t len);\nstatic void btrfsic_release_block_ctx(struct btrfsic_block_data_ctx *block_ctx);\nstatic int btrfsic_read_block(struct btrfsic_state *state,\n\t\t\t      struct btrfsic_block_data_ctx *block_ctx);\n\nstatic void btrfsic_read_from_block_data(\n\tstruct btrfsic_block_data_ctx *block_ctx,\n\tvoid *dstv, u32 offset, size_t len)\n{\n\tsize_t cur;\n\tsize_t offset_in_page;\n\tchar *kaddr;\n\tchar *dst = (char *)dstv;\n\tsize_t start_offset = block_ctx->start & ((u64)PAGE_CACHE_SIZE - 1);\n\tunsigned long i = (start_offset + offset) >> PAGE_CACHE_SHIFT;\n\n\tWARN_ON(offset + len > block_ctx->len);\n\toffset_in_page = (start_offset + offset) & (PAGE_CACHE_SIZE - 1);\n\n\twhile (len > 0) {\n\t\tcur = min(len, ((size_t)PAGE_CACHE_SIZE - offset_in_page));\n\t\tBUG_ON(i >= DIV_ROUND_UP(block_ctx->len, PAGE_CACHE_SIZE));\n\t\tkaddr = block_ctx->datav[i];\n\t\tmemcpy(dst, kaddr + offset_in_page, cur);\n\n\t\tdst += cur;\n\t\tlen -= cur;\n\t\toffset_in_page = 0;\n\t\ti++;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_stack_file_extent_disk_bytenr",
          "args": [
            "&file_extent_item"
          ],
          "line": 1444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_stack_file_extent_disk_bytenr",
          "args": [
            "&file_extent_item"
          ],
          "line": 1440
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"extent_io.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n#include <linux/blkdev.h>\n#include <linux/genhd.h>\n#include <linux/mutex.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\n#define BTRFSIC_PRINT_MASK_NUM_COPIES\t\t\t\t0x00000800\n#define BTRFSIC_PRINT_MASK_VERY_VERBOSE\t\t\t\t0x00000080\n#define BTRFSIC_PRINT_MASK_VERBOSE\t\t\t\t0x00000040\n\nstatic void btrfsic_block_link_init(struct btrfsic_block_link *n);\nstatic void btrfsic_block_link_free(struct btrfsic_block_link *n);\nstatic void btrfsic_block_link_hashtable_remove(struct btrfsic_block_link *l);\nstatic int btrfsic_process_metablock(struct btrfsic_state *state,\n\t\t\t\t     struct btrfsic_block *block,\n\t\t\t\t     struct btrfsic_block_data_ctx *block_ctx,\n\t\t\t\t     int limit_nesting, int force_iodone_flag);\nstatic void btrfsic_read_from_block_data(\n\tstruct btrfsic_block_data_ctx *block_ctx,\n\tvoid *dst, u32 offset, size_t len);\nstatic int btrfsic_handle_extent_data(struct btrfsic_state *state,\n\t\t\t\t      struct btrfsic_block *block,\n\t\t\t\t      struct btrfsic_block_data_ctx *block_ctx,\n\t\t\t\t      u32 item_offset, int force_iodone_flag);\nstatic int btrfsic_map_block(struct btrfsic_state *state, u64 bytenr, u32 len,\n\t\t\t     struct btrfsic_block_data_ctx *block_ctx_out,\n\t\t\t     int mirror_num);\nstatic void btrfsic_release_block_ctx(struct btrfsic_block_data_ctx *block_ctx);\nstatic int btrfsic_read_block(struct btrfsic_state *state,\n\t\t\t      struct btrfsic_block_data_ctx *block_ctx);\nstatic void btrfsic_dump_database(struct btrfsic_state *state);\nstatic void btrfsic_print_add_link(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block_link *l);\nstatic void btrfsic_print_rem_link(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block_link *l);\nstatic char btrfsic_get_block_type(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block *block);\nstatic void btrfsic_dump_tree(const struct btrfsic_state *state);\nstatic void btrfsic_cmp_log_and_dev_bytenr(struct btrfsic_state *state,\n\t\t\t\t\t   u64 bytenr,\n\t\t\t\t\t   struct btrfsic_dev_state *dev_state,\n\t\t\t\t\t   u64 dev_bytenr);\n\nstatic int btrfsic_handle_extent_data(\n\t\tstruct btrfsic_state *state,\n\t\tstruct btrfsic_block *block,\n\t\tstruct btrfsic_block_data_ctx *block_ctx,\n\t\tu32 item_offset, int force_iodone_flag)\n{\n\tint ret;\n\tstruct btrfs_file_extent_item file_extent_item;\n\tu64 file_extent_item_offset;\n\tu64 next_bytenr;\n\tu64 num_bytes;\n\tu64 generation;\n\tstruct btrfsic_block_link *l;\n\n\tfile_extent_item_offset = offsetof(struct btrfs_leaf, items) +\n\t\t\t\t  item_offset;\n\tif (file_extent_item_offset +\n\t    offsetof(struct btrfs_file_extent_item, disk_num_bytes) >\n\t    block_ctx->len) {\n\t\tprintk(KERN_INFO\n\t\t       \"btrfsic: file item out of bounce at logical %llu, dev %s\\n\",\n\t\t       block_ctx->start, block_ctx->dev->name);\n\t\treturn -1;\n\t}\n\n\tbtrfsic_read_from_block_data(block_ctx, &file_extent_item,\n\t\tfile_extent_item_offset,\n\t\toffsetof(struct btrfs_file_extent_item, disk_num_bytes));\n\tif (BTRFS_FILE_EXTENT_REG != file_extent_item.type ||\n\t    btrfs_stack_file_extent_disk_bytenr(&file_extent_item) == 0) {\n\t\tif (state->print_mask & BTRFSIC_PRINT_MASK_VERY_VERBOSE)\n\t\t\tprintk(KERN_INFO \"extent_data: type %u, disk_bytenr = %llu\\n\",\n\t\t\t       file_extent_item.type,\n\t\t\t       btrfs_stack_file_extent_disk_bytenr(\n\t\t\t       &file_extent_item));\n\t\treturn 0;\n\t}\n\n\tif (file_extent_item_offset + sizeof(struct btrfs_file_extent_item) >\n\t    block_ctx->len) {\n\t\tprintk(KERN_INFO\n\t\t       \"btrfsic: file item out of bounce at logical %llu, dev %s\\n\",\n\t\t       block_ctx->start, block_ctx->dev->name);\n\t\treturn -1;\n\t}\n\tbtrfsic_read_from_block_data(block_ctx, &file_extent_item,\n\t\t\t\t     file_extent_item_offset,\n\t\t\t\t     sizeof(struct btrfs_file_extent_item));\n\tnext_bytenr = btrfs_stack_file_extent_disk_bytenr(&file_extent_item);\n\tif (btrfs_stack_file_extent_compression(&file_extent_item) ==\n\t    BTRFS_COMPRESS_NONE) {\n\t\tnext_bytenr += btrfs_stack_file_extent_offset(&file_extent_item);\n\t\tnum_bytes = btrfs_stack_file_extent_num_bytes(&file_extent_item);\n\t} else {\n\t\tnum_bytes = btrfs_stack_file_extent_disk_num_bytes(&file_extent_item);\n\t}\n\tgeneration = btrfs_stack_file_extent_generation(&file_extent_item);\n\n\tif (state->print_mask & BTRFSIC_PRINT_MASK_VERY_VERBOSE)\n\t\tprintk(KERN_INFO \"extent_data: type %u, disk_bytenr = %llu,\"\n\t\t       \" offset = %llu, num_bytes = %llu\\n\",\n\t\t       file_extent_item.type,\n\t\t       btrfs_stack_file_extent_disk_bytenr(&file_extent_item),\n\t\t       btrfs_stack_file_extent_offset(&file_extent_item),\n\t\t       num_bytes);\n\twhile (num_bytes > 0) {\n\t\tu32 chunk_len;\n\t\tint num_copies;\n\t\tint mirror_num;\n\n\t\tif (num_bytes > state->datablock_size)\n\t\t\tchunk_len = state->datablock_size;\n\t\telse\n\t\t\tchunk_len = num_bytes;\n\n\t\tnum_copies =\n\t\t    btrfs_num_copies(state->root->fs_info,\n\t\t\t\t     next_bytenr, state->datablock_size);\n\t\tif (state->print_mask & BTRFSIC_PRINT_MASK_NUM_COPIES)\n\t\t\tprintk(KERN_INFO \"num_copies(log_bytenr=%llu) = %d\\n\",\n\t\t\t       next_bytenr, num_copies);\n\t\tfor (mirror_num = 1; mirror_num <= num_copies; mirror_num++) {\n\t\t\tstruct btrfsic_block_data_ctx next_block_ctx;\n\t\t\tstruct btrfsic_block *next_block;\n\t\t\tint block_was_created;\n\n\t\t\tif (state->print_mask & BTRFSIC_PRINT_MASK_VERBOSE)\n\t\t\t\tprintk(KERN_INFO \"btrfsic_handle_extent_data(\"\n\t\t\t\t       \"mirror_num=%d)\\n\", mirror_num);\n\t\t\tif (state->print_mask & BTRFSIC_PRINT_MASK_VERY_VERBOSE)\n\t\t\t\tprintk(KERN_INFO\n\t\t\t\t       \"\\tdisk_bytenr = %llu, num_bytes %u\\n\",\n\t\t\t\t       next_bytenr, chunk_len);\n\t\t\tret = btrfsic_map_block(state, next_bytenr,\n\t\t\t\t\t\tchunk_len, &next_block_ctx,\n\t\t\t\t\t\tmirror_num);\n\t\t\tif (ret) {\n\t\t\t\tprintk(KERN_INFO\n\t\t\t\t       \"btrfsic: btrfsic_map_block(@%llu,\"\n\t\t\t\t       \" mirror=%d) failed!\\n\",\n\t\t\t\t       next_bytenr, mirror_num);\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tnext_block = btrfsic_block_lookup_or_add(\n\t\t\t\t\tstate,\n\t\t\t\t\t&next_block_ctx,\n\t\t\t\t\t\"referenced \",\n\t\t\t\t\t0,\n\t\t\t\t\tforce_iodone_flag,\n\t\t\t\t\t!force_iodone_flag,\n\t\t\t\t\tmirror_num,\n\t\t\t\t\t&block_was_created);\n\t\t\tif (NULL == next_block) {\n\t\t\t\tprintk(KERN_INFO\n\t\t\t\t       \"btrfsic: error, kmalloc failed!\\n\");\n\t\t\t\tbtrfsic_release_block_ctx(&next_block_ctx);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif (!block_was_created) {\n\t\t\t\tif ((state->print_mask &\n\t\t\t\t     BTRFSIC_PRINT_MASK_VERBOSE) &&\n\t\t\t\t    next_block->logical_bytenr != next_bytenr &&\n\t\t\t\t    !(!next_block->is_metadata &&\n\t\t\t\t      0 == next_block->logical_bytenr)) {\n\t\t\t\t\tprintk(KERN_INFO\n\t\t\t\t\t       \"Referenced block\"\n\t\t\t\t\t       \" @%llu (%s/%llu/%d)\"\n\t\t\t\t\t       \" found in hash table, D,\"\n\t\t\t\t\t       \" bytenr mismatch\"\n\t\t\t\t\t       \" (!= stored %llu).\\n\",\n\t\t\t\t\t       next_bytenr,\n\t\t\t\t\t       next_block_ctx.dev->name,\n\t\t\t\t\t       next_block_ctx.dev_bytenr,\n\t\t\t\t\t       mirror_num,\n\t\t\t\t\t       next_block->logical_bytenr);\n\t\t\t\t}\n\t\t\t\tnext_block->logical_bytenr = next_bytenr;\n\t\t\t\tnext_block->mirror_num = mirror_num;\n\t\t\t}\n\n\t\t\tl = btrfsic_block_link_lookup_or_add(state,\n\t\t\t\t\t\t\t     &next_block_ctx,\n\t\t\t\t\t\t\t     next_block, block,\n\t\t\t\t\t\t\t     generation);\n\t\t\tbtrfsic_release_block_ctx(&next_block_ctx);\n\t\t\tif (NULL == l)\n\t\t\t\treturn -1;\n\t\t}\n\n\t\tnext_bytenr += chunk_len;\n\t\tnum_bytes -= chunk_len;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "btrfsic_create_link_to_next_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/check-integrity.c",
    "lines": "1263-1409",
    "snippet": "static int btrfsic_create_link_to_next_block(\n\t\tstruct btrfsic_state *state,\n\t\tstruct btrfsic_block *block,\n\t\tstruct btrfsic_block_data_ctx *block_ctx,\n\t\tu64 next_bytenr,\n\t\tint limit_nesting,\n\t\tstruct btrfsic_block_data_ctx *next_block_ctx,\n\t\tstruct btrfsic_block **next_blockp,\n\t\tint force_iodone_flag,\n\t\tint *num_copiesp, int *mirror_nump,\n\t\tstruct btrfs_disk_key *disk_key,\n\t\tu64 parent_generation)\n{\n\tstruct btrfsic_block *next_block = NULL;\n\tint ret;\n\tstruct btrfsic_block_link *l;\n\tint did_alloc_block_link;\n\tint block_was_created;\n\n\t*next_blockp = NULL;\n\tif (0 == *num_copiesp) {\n\t\t*num_copiesp =\n\t\t    btrfs_num_copies(state->root->fs_info,\n\t\t\t\t     next_bytenr, state->metablock_size);\n\t\tif (state->print_mask & BTRFSIC_PRINT_MASK_NUM_COPIES)\n\t\t\tprintk(KERN_INFO \"num_copies(log_bytenr=%llu) = %d\\n\",\n\t\t\t       next_bytenr, *num_copiesp);\n\t\t*mirror_nump = 1;\n\t}\n\n\tif (*mirror_nump > *num_copiesp)\n\t\treturn 0;\n\n\tif (state->print_mask & BTRFSIC_PRINT_MASK_VERBOSE)\n\t\tprintk(KERN_INFO\n\t\t       \"btrfsic_create_link_to_next_block(mirror_num=%d)\\n\",\n\t\t       *mirror_nump);\n\tret = btrfsic_map_block(state, next_bytenr,\n\t\t\t\tstate->metablock_size,\n\t\t\t\tnext_block_ctx, *mirror_nump);\n\tif (ret) {\n\t\tprintk(KERN_INFO\n\t\t       \"btrfsic: btrfsic_map_block(@%llu, mirror=%d) failed!\\n\",\n\t\t       next_bytenr, *mirror_nump);\n\t\tbtrfsic_release_block_ctx(next_block_ctx);\n\t\t*next_blockp = NULL;\n\t\treturn -1;\n\t}\n\n\tnext_block = btrfsic_block_lookup_or_add(state,\n\t\t\t\t\t\t next_block_ctx, \"referenced \",\n\t\t\t\t\t\t 1, force_iodone_flag,\n\t\t\t\t\t\t !force_iodone_flag,\n\t\t\t\t\t\t *mirror_nump,\n\t\t\t\t\t\t &block_was_created);\n\tif (NULL == next_block) {\n\t\tbtrfsic_release_block_ctx(next_block_ctx);\n\t\t*next_blockp = NULL;\n\t\treturn -1;\n\t}\n\tif (block_was_created) {\n\t\tl = NULL;\n\t\tnext_block->generation = BTRFSIC_GENERATION_UNKNOWN;\n\t} else {\n\t\tif (state->print_mask & BTRFSIC_PRINT_MASK_VERBOSE) {\n\t\t\tif (next_block->logical_bytenr != next_bytenr &&\n\t\t\t    !(!next_block->is_metadata &&\n\t\t\t      0 == next_block->logical_bytenr))\n\t\t\t\tprintk(KERN_INFO\n\t\t\t\t       \"Referenced block @%llu (%s/%llu/%d) found in hash table, %c, bytenr mismatch (!= stored %llu).\\n\",\n\t\t\t\t       next_bytenr, next_block_ctx->dev->name,\n\t\t\t\t       next_block_ctx->dev_bytenr, *mirror_nump,\n\t\t\t\t       btrfsic_get_block_type(state,\n\t\t\t\t\t\t\t      next_block),\n\t\t\t\t       next_block->logical_bytenr);\n\t\t\telse\n\t\t\t\tprintk(KERN_INFO\n\t\t\t\t       \"Referenced block @%llu (%s/%llu/%d) found in hash table, %c.\\n\",\n\t\t\t\t       next_bytenr, next_block_ctx->dev->name,\n\t\t\t\t       next_block_ctx->dev_bytenr, *mirror_nump,\n\t\t\t\t       btrfsic_get_block_type(state,\n\t\t\t\t\t\t\t      next_block));\n\t\t}\n\t\tnext_block->logical_bytenr = next_bytenr;\n\n\t\tnext_block->mirror_num = *mirror_nump;\n\t\tl = btrfsic_block_link_hashtable_lookup(\n\t\t\t\tnext_block_ctx->dev->bdev,\n\t\t\t\tnext_block_ctx->dev_bytenr,\n\t\t\t\tblock_ctx->dev->bdev,\n\t\t\t\tblock_ctx->dev_bytenr,\n\t\t\t\t&state->block_link_hashtable);\n\t}\n\n\tnext_block->disk_key = *disk_key;\n\tif (NULL == l) {\n\t\tl = btrfsic_block_link_alloc();\n\t\tif (NULL == l) {\n\t\t\tprintk(KERN_INFO \"btrfsic: error, kmalloc failed!\\n\");\n\t\t\tbtrfsic_release_block_ctx(next_block_ctx);\n\t\t\t*next_blockp = NULL;\n\t\t\treturn -1;\n\t\t}\n\n\t\tdid_alloc_block_link = 1;\n\t\tl->block_ref_to = next_block;\n\t\tl->block_ref_from = block;\n\t\tl->ref_cnt = 1;\n\t\tl->parent_generation = parent_generation;\n\n\t\tif (state->print_mask & BTRFSIC_PRINT_MASK_VERBOSE)\n\t\t\tbtrfsic_print_add_link(state, l);\n\n\t\tlist_add(&l->node_ref_to, &block->ref_to_list);\n\t\tlist_add(&l->node_ref_from, &next_block->ref_from_list);\n\n\t\tbtrfsic_block_link_hashtable_add(l,\n\t\t\t\t\t\t &state->block_link_hashtable);\n\t} else {\n\t\tdid_alloc_block_link = 0;\n\t\tif (0 == limit_nesting) {\n\t\t\tl->ref_cnt++;\n\t\t\tl->parent_generation = parent_generation;\n\t\t\tif (state->print_mask & BTRFSIC_PRINT_MASK_VERBOSE)\n\t\t\t\tbtrfsic_print_add_link(state, l);\n\t\t}\n\t}\n\n\tif (limit_nesting > 0 && did_alloc_block_link) {\n\t\tret = btrfsic_read_block(state, next_block_ctx);\n\t\tif (ret < (int)next_block_ctx->len) {\n\t\t\tprintk(KERN_INFO\n\t\t\t       \"btrfsic: read block @logical %llu failed!\\n\",\n\t\t\t       next_bytenr);\n\t\t\tbtrfsic_release_block_ctx(next_block_ctx);\n\t\t\t*next_blockp = NULL;\n\t\t\treturn -1;\n\t\t}\n\n\t\t*next_blockp = next_block;\n\t} else {\n\t\t*next_blockp = NULL;\n\t}\n\t(*mirror_nump)++;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"volumes.h\"",
      "#include \"extent_io.h\"",
      "#include \"transaction.h\"",
      "#include \"hash.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/genhd.h>",
      "#include <linux/mutex.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [
      "#define BTRFSIC_PRINT_MASK_NUM_COPIES\t\t\t\t0x00000800",
      "#define BTRFSIC_PRINT_MASK_VERBOSE\t\t\t\t0x00000040",
      "#define BTRFSIC_GENERATION_UNKNOWN ((u64)-1)"
    ],
    "globals_used": [
      "static void btrfsic_block_link_init(struct btrfsic_block_link *n);",
      "static struct btrfsic_block_link *btrfsic_block_link_alloc(void);",
      "static void btrfsic_block_link_free(struct btrfsic_block_link *n);",
      "static void btrfsic_block_link_hashtable_remove(struct btrfsic_block_link *l);",
      "static int btrfsic_process_metablock(struct btrfsic_state *state,\n\t\t\t\t     struct btrfsic_block *block,\n\t\t\t\t     struct btrfsic_block_data_ctx *block_ctx,\n\t\t\t\t     int limit_nesting, int force_iodone_flag);",
      "static void btrfsic_read_from_block_data(\n\tstruct btrfsic_block_data_ctx *block_ctx,\n\tvoid *dst, u32 offset, size_t len);",
      "static int btrfsic_create_link_to_next_block(\n\t\tstruct btrfsic_state *state,\n\t\tstruct btrfsic_block *block,\n\t\tstruct btrfsic_block_data_ctx\n\t\t*block_ctx, u64 next_bytenr,\n\t\tint limit_nesting,\n\t\tstruct btrfsic_block_data_ctx *next_block_ctx,\n\t\tstruct btrfsic_block **next_blockp,\n\t\tint force_iodone_flag,\n\t\tint *num_copiesp, int *mirror_nump,\n\t\tstruct btrfs_disk_key *disk_key,\n\t\tu64 parent_generation);",
      "static int btrfsic_handle_extent_data(struct btrfsic_state *state,\n\t\t\t\t      struct btrfsic_block *block,\n\t\t\t\t      struct btrfsic_block_data_ctx *block_ctx,\n\t\t\t\t      u32 item_offset, int force_iodone_flag);",
      "static int btrfsic_map_block(struct btrfsic_state *state, u64 bytenr, u32 len,\n\t\t\t     struct btrfsic_block_data_ctx *block_ctx_out,\n\t\t\t     int mirror_num);",
      "static void btrfsic_release_block_ctx(struct btrfsic_block_data_ctx *block_ctx);",
      "static int btrfsic_read_block(struct btrfsic_state *state,\n\t\t\t      struct btrfsic_block_data_ctx *block_ctx);",
      "static void btrfsic_dump_database(struct btrfsic_state *state);",
      "static void btrfsic_print_add_link(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block_link *l);",
      "static void btrfsic_print_rem_link(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block_link *l);",
      "static char btrfsic_get_block_type(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block *block);",
      "static void btrfsic_dump_tree(const struct btrfsic_state *state);",
      "static struct btrfsic_block_link *btrfsic_block_link_lookup_or_add(\n\t\tstruct btrfsic_state *state,\n\t\tstruct btrfsic_block_data_ctx *next_block_ctx,\n\t\tstruct btrfsic_block *next_block,\n\t\tstruct btrfsic_block *from_block,\n\t\tu64 parent_generation);",
      "static struct btrfsic_dev_state *btrfsic_dev_state_lookup(\n\t\tstruct block_device *bdev);",
      "static void btrfsic_cmp_log_and_dev_bytenr(struct btrfsic_state *state,\n\t\t\t\t\t   u64 bytenr,\n\t\t\t\t\t   struct btrfsic_dev_state *dev_state,\n\t\t\t\t\t   u64 dev_bytenr);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfsic_release_block_ctx",
          "args": [
            "next_block_ctx"
          ],
          "line": 1397
        },
        "resolved": true,
        "details": {
          "function_name": "btrfsic_release_block_ctx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/check-integrity.c",
          "lines": "1611-1637",
          "snippet": "static void btrfsic_release_block_ctx(struct btrfsic_block_data_ctx *block_ctx)\n{\n\tif (block_ctx->mem_to_free) {\n\t\tunsigned int num_pages;\n\n\t\tBUG_ON(!block_ctx->datav);\n\t\tBUG_ON(!block_ctx->pagev);\n\t\tnum_pages = (block_ctx->len + (u64)PAGE_CACHE_SIZE - 1) >>\n\t\t\t    PAGE_CACHE_SHIFT;\n\t\twhile (num_pages > 0) {\n\t\t\tnum_pages--;\n\t\t\tif (block_ctx->datav[num_pages]) {\n\t\t\t\tkunmap(block_ctx->pagev[num_pages]);\n\t\t\t\tblock_ctx->datav[num_pages] = NULL;\n\t\t\t}\n\t\t\tif (block_ctx->pagev[num_pages]) {\n\t\t\t\t__free_page(block_ctx->pagev[num_pages]);\n\t\t\t\tblock_ctx->pagev[num_pages] = NULL;\n\t\t\t}\n\t\t}\n\n\t\tkfree(block_ctx->mem_to_free);\n\t\tblock_ctx->mem_to_free = NULL;\n\t\tblock_ctx->pagev = NULL;\n\t\tblock_ctx->datav = NULL;\n\t}\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"extent_io.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/genhd.h>",
            "#include <linux/mutex.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void btrfsic_read_from_block_data(\n\tstruct btrfsic_block_data_ctx *block_ctx,\n\tvoid *dst, u32 offset, size_t len);",
            "static void btrfsic_release_block_ctx(struct btrfsic_block_data_ctx *block_ctx);",
            "static int btrfsic_read_block(struct btrfsic_state *state,\n\t\t\t      struct btrfsic_block_data_ctx *block_ctx);",
            "static int btrfsic_test_for_metadata(struct btrfsic_state *state,\n\t\t\t\t     char **datav, unsigned int num_pages);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"extent_io.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n#include <linux/blkdev.h>\n#include <linux/genhd.h>\n#include <linux/mutex.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic void btrfsic_read_from_block_data(\n\tstruct btrfsic_block_data_ctx *block_ctx,\n\tvoid *dst, u32 offset, size_t len);\nstatic void btrfsic_release_block_ctx(struct btrfsic_block_data_ctx *block_ctx);\nstatic int btrfsic_read_block(struct btrfsic_state *state,\n\t\t\t      struct btrfsic_block_data_ctx *block_ctx);\nstatic int btrfsic_test_for_metadata(struct btrfsic_state *state,\n\t\t\t\t     char **datav, unsigned int num_pages);\n\nstatic void btrfsic_release_block_ctx(struct btrfsic_block_data_ctx *block_ctx)\n{\n\tif (block_ctx->mem_to_free) {\n\t\tunsigned int num_pages;\n\n\t\tBUG_ON(!block_ctx->datav);\n\t\tBUG_ON(!block_ctx->pagev);\n\t\tnum_pages = (block_ctx->len + (u64)PAGE_CACHE_SIZE - 1) >>\n\t\t\t    PAGE_CACHE_SHIFT;\n\t\twhile (num_pages > 0) {\n\t\t\tnum_pages--;\n\t\t\tif (block_ctx->datav[num_pages]) {\n\t\t\t\tkunmap(block_ctx->pagev[num_pages]);\n\t\t\t\tblock_ctx->datav[num_pages] = NULL;\n\t\t\t}\n\t\t\tif (block_ctx->pagev[num_pages]) {\n\t\t\t\t__free_page(block_ctx->pagev[num_pages]);\n\t\t\t\tblock_ctx->pagev[num_pages] = NULL;\n\t\t\t}\n\t\t}\n\n\t\tkfree(block_ctx->mem_to_free);\n\t\tblock_ctx->mem_to_free = NULL;\n\t\tblock_ctx->pagev = NULL;\n\t\tblock_ctx->datav = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_INFO\n\t\t\t       \"btrfsic: read block @logical %llu failed!\\n\"",
            "next_bytenr"
          ],
          "line": 1394
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/super.c",
          "lines": "186-213",
          "snippet": "void btrfs_printk(const struct btrfs_fs_info *fs_info, const char *fmt, ...)\n{\n\tstruct super_block *sb = fs_info->sb;\n\tchar lvl[4];\n\tstruct va_format vaf;\n\tva_list args;\n\tconst char *type = logtypes[4];\n\tint kern_level;\n\n\tva_start(args, fmt);\n\n\tkern_level = printk_get_level(fmt);\n\tif (kern_level) {\n\t\tsize_t size = printk_skip_level(fmt) - fmt;\n\t\tmemcpy(lvl, fmt,  size);\n\t\tlvl[size] = '\\0';\n\t\tfmt += size;\n\t\ttype = logtypes[kern_level - '0'];\n\t} else\n\t\t*lvl = '\\0';\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sBTRFS %s (device %s): %pV\\n\", lvl, type, sb->s_id, &vaf);\n\n\tva_end(args);\n}",
          "includes": [
            "#include <trace/events/btrfs.h>",
            "#include \"qgroup.h\"",
            "#include \"tests/btrfs-tests.h\"",
            "#include \"backref.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"compression.h\"",
            "#include \"export.h\"",
            "#include \"volumes.h\"",
            "#include \"xattr.h\"",
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/slab.h>",
            "#include <linux/magic.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/namei.h>",
            "#include <linux/ctype.h>",
            "#include <linux/parser.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/btrfs.h>\n#include \"qgroup.h\"\n#include \"tests/btrfs-tests.h\"\n#include \"backref.h\"\n#include \"free-space-cache.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"compression.h\"\n#include \"export.h\"\n#include \"volumes.h\"\n#include \"xattr.h\"\n#include \"props.h\"\n#include \"hash.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include \"delayed-inode.h\"\n#include <linux/btrfs.h>\n#include <linux/ratelimit.h>\n#include <linux/cleancache.h>\n#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/miscdevice.h>\n#include <linux/namei.h>\n#include <linux/ctype.h>\n#include <linux/parser.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n\nvoid btrfs_printk(const struct btrfs_fs_info *fs_info, const char *fmt, ...)\n{\n\tstruct super_block *sb = fs_info->sb;\n\tchar lvl[4];\n\tstruct va_format vaf;\n\tva_list args;\n\tconst char *type = logtypes[4];\n\tint kern_level;\n\n\tva_start(args, fmt);\n\n\tkern_level = printk_get_level(fmt);\n\tif (kern_level) {\n\t\tsize_t size = printk_skip_level(fmt) - fmt;\n\t\tmemcpy(lvl, fmt,  size);\n\t\tlvl[size] = '\\0';\n\t\tfmt += size;\n\t\ttype = logtypes[kern_level - '0'];\n\t} else\n\t\t*lvl = '\\0';\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sBTRFS %s (device %s): %pV\\n\", lvl, type, sb->s_id, &vaf);\n\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfsic_read_block",
          "args": [
            "state",
            "next_block_ctx"
          ],
          "line": 1392
        },
        "resolved": true,
        "details": {
          "function_name": "btrfsic_read_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/check-integrity.c",
          "lines": "1639-1719",
          "snippet": "static int btrfsic_read_block(struct btrfsic_state *state,\n\t\t\t      struct btrfsic_block_data_ctx *block_ctx)\n{\n\tunsigned int num_pages;\n\tunsigned int i;\n\tu64 dev_bytenr;\n\tint ret;\n\n\tBUG_ON(block_ctx->datav);\n\tBUG_ON(block_ctx->pagev);\n\tBUG_ON(block_ctx->mem_to_free);\n\tif (block_ctx->dev_bytenr & ((u64)PAGE_CACHE_SIZE - 1)) {\n\t\tprintk(KERN_INFO\n\t\t       \"btrfsic: read_block() with unaligned bytenr %llu\\n\",\n\t\t       block_ctx->dev_bytenr);\n\t\treturn -1;\n\t}\n\n\tnum_pages = (block_ctx->len + (u64)PAGE_CACHE_SIZE - 1) >>\n\t\t    PAGE_CACHE_SHIFT;\n\tblock_ctx->mem_to_free = kzalloc((sizeof(*block_ctx->datav) +\n\t\t\t\t\t  sizeof(*block_ctx->pagev)) *\n\t\t\t\t\t num_pages, GFP_NOFS);\n\tif (!block_ctx->mem_to_free)\n\t\treturn -1;\n\tblock_ctx->datav = block_ctx->mem_to_free;\n\tblock_ctx->pagev = (struct page **)(block_ctx->datav + num_pages);\n\tfor (i = 0; i < num_pages; i++) {\n\t\tblock_ctx->pagev[i] = alloc_page(GFP_NOFS);\n\t\tif (!block_ctx->pagev[i])\n\t\t\treturn -1;\n\t}\n\n\tdev_bytenr = block_ctx->dev_bytenr;\n\tfor (i = 0; i < num_pages;) {\n\t\tstruct bio *bio;\n\t\tunsigned int j;\n\n\t\tbio = btrfs_io_bio_alloc(GFP_NOFS, num_pages - i);\n\t\tif (!bio) {\n\t\t\tprintk(KERN_INFO\n\t\t\t       \"btrfsic: bio_alloc() for %u pages failed!\\n\",\n\t\t\t       num_pages - i);\n\t\t\treturn -1;\n\t\t}\n\t\tbio->bi_bdev = block_ctx->dev->bdev;\n\t\tbio->bi_iter.bi_sector = dev_bytenr >> 9;\n\n\t\tfor (j = i; j < num_pages; j++) {\n\t\t\tret = bio_add_page(bio, block_ctx->pagev[j],\n\t\t\t\t\t   PAGE_CACHE_SIZE, 0);\n\t\t\tif (PAGE_CACHE_SIZE != ret)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (j == i) {\n\t\t\tprintk(KERN_INFO\n\t\t\t       \"btrfsic: error, failed to add a single page!\\n\");\n\t\t\treturn -1;\n\t\t}\n\t\tif (submit_bio_wait(READ, bio)) {\n\t\t\tprintk(KERN_INFO\n\t\t\t       \"btrfsic: read error at logical %llu dev %s!\\n\",\n\t\t\t       block_ctx->start, block_ctx->dev->name);\n\t\t\tbio_put(bio);\n\t\t\treturn -1;\n\t\t}\n\t\tbio_put(bio);\n\t\tdev_bytenr += (j - i) * PAGE_CACHE_SIZE;\n\t\ti = j;\n\t}\n\tfor (i = 0; i < num_pages; i++) {\n\t\tblock_ctx->datav[i] = kmap(block_ctx->pagev[i]);\n\t\tif (!block_ctx->datav[i]) {\n\t\t\tprintk(KERN_INFO \"btrfsic: kmap() failed (dev %s)!\\n\",\n\t\t\t       block_ctx->dev->name);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn block_ctx->len;\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"extent_io.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/genhd.h>",
            "#include <linux/mutex.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void btrfsic_block_link_init(struct btrfsic_block_link *n);",
            "static void btrfsic_block_link_free(struct btrfsic_block_link *n);",
            "static void btrfsic_read_from_block_data(\n\tstruct btrfsic_block_data_ctx *block_ctx,\n\tvoid *dst, u32 offset, size_t len);",
            "static void btrfsic_release_block_ctx(struct btrfsic_block_data_ctx *block_ctx);",
            "static int btrfsic_read_block(struct btrfsic_state *state,\n\t\t\t      struct btrfsic_block_data_ctx *block_ctx);",
            "static void btrfsic_dump_database(struct btrfsic_state *state);",
            "static int btrfsic_test_for_metadata(struct btrfsic_state *state,\n\t\t\t\t     char **datav, unsigned int num_pages);",
            "static void btrfsic_dump_tree(const struct btrfsic_state *state);",
            "static struct btrfsic_dev_state *btrfsic_dev_state_lookup(\n\t\tstruct block_device *bdev);",
            "static void btrfsic_cmp_log_and_dev_bytenr(struct btrfsic_state *state,\n\t\t\t\t\t   u64 bytenr,\n\t\t\t\t\t   struct btrfsic_dev_state *dev_state,\n\t\t\t\t\t   u64 dev_bytenr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"extent_io.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n#include <linux/blkdev.h>\n#include <linux/genhd.h>\n#include <linux/mutex.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic void btrfsic_block_link_init(struct btrfsic_block_link *n);\nstatic void btrfsic_block_link_free(struct btrfsic_block_link *n);\nstatic void btrfsic_read_from_block_data(\n\tstruct btrfsic_block_data_ctx *block_ctx,\n\tvoid *dst, u32 offset, size_t len);\nstatic void btrfsic_release_block_ctx(struct btrfsic_block_data_ctx *block_ctx);\nstatic int btrfsic_read_block(struct btrfsic_state *state,\n\t\t\t      struct btrfsic_block_data_ctx *block_ctx);\nstatic void btrfsic_dump_database(struct btrfsic_state *state);\nstatic int btrfsic_test_for_metadata(struct btrfsic_state *state,\n\t\t\t\t     char **datav, unsigned int num_pages);\nstatic void btrfsic_dump_tree(const struct btrfsic_state *state);\nstatic struct btrfsic_dev_state *btrfsic_dev_state_lookup(\n\t\tstruct block_device *bdev);\nstatic void btrfsic_cmp_log_and_dev_bytenr(struct btrfsic_state *state,\n\t\t\t\t\t   u64 bytenr,\n\t\t\t\t\t   struct btrfsic_dev_state *dev_state,\n\t\t\t\t\t   u64 dev_bytenr);\n\nstatic int btrfsic_read_block(struct btrfsic_state *state,\n\t\t\t      struct btrfsic_block_data_ctx *block_ctx)\n{\n\tunsigned int num_pages;\n\tunsigned int i;\n\tu64 dev_bytenr;\n\tint ret;\n\n\tBUG_ON(block_ctx->datav);\n\tBUG_ON(block_ctx->pagev);\n\tBUG_ON(block_ctx->mem_to_free);\n\tif (block_ctx->dev_bytenr & ((u64)PAGE_CACHE_SIZE - 1)) {\n\t\tprintk(KERN_INFO\n\t\t       \"btrfsic: read_block() with unaligned bytenr %llu\\n\",\n\t\t       block_ctx->dev_bytenr);\n\t\treturn -1;\n\t}\n\n\tnum_pages = (block_ctx->len + (u64)PAGE_CACHE_SIZE - 1) >>\n\t\t    PAGE_CACHE_SHIFT;\n\tblock_ctx->mem_to_free = kzalloc((sizeof(*block_ctx->datav) +\n\t\t\t\t\t  sizeof(*block_ctx->pagev)) *\n\t\t\t\t\t num_pages, GFP_NOFS);\n\tif (!block_ctx->mem_to_free)\n\t\treturn -1;\n\tblock_ctx->datav = block_ctx->mem_to_free;\n\tblock_ctx->pagev = (struct page **)(block_ctx->datav + num_pages);\n\tfor (i = 0; i < num_pages; i++) {\n\t\tblock_ctx->pagev[i] = alloc_page(GFP_NOFS);\n\t\tif (!block_ctx->pagev[i])\n\t\t\treturn -1;\n\t}\n\n\tdev_bytenr = block_ctx->dev_bytenr;\n\tfor (i = 0; i < num_pages;) {\n\t\tstruct bio *bio;\n\t\tunsigned int j;\n\n\t\tbio = btrfs_io_bio_alloc(GFP_NOFS, num_pages - i);\n\t\tif (!bio) {\n\t\t\tprintk(KERN_INFO\n\t\t\t       \"btrfsic: bio_alloc() for %u pages failed!\\n\",\n\t\t\t       num_pages - i);\n\t\t\treturn -1;\n\t\t}\n\t\tbio->bi_bdev = block_ctx->dev->bdev;\n\t\tbio->bi_iter.bi_sector = dev_bytenr >> 9;\n\n\t\tfor (j = i; j < num_pages; j++) {\n\t\t\tret = bio_add_page(bio, block_ctx->pagev[j],\n\t\t\t\t\t   PAGE_CACHE_SIZE, 0);\n\t\t\tif (PAGE_CACHE_SIZE != ret)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (j == i) {\n\t\t\tprintk(KERN_INFO\n\t\t\t       \"btrfsic: error, failed to add a single page!\\n\");\n\t\t\treturn -1;\n\t\t}\n\t\tif (submit_bio_wait(READ, bio)) {\n\t\t\tprintk(KERN_INFO\n\t\t\t       \"btrfsic: read error at logical %llu dev %s!\\n\",\n\t\t\t       block_ctx->start, block_ctx->dev->name);\n\t\t\tbio_put(bio);\n\t\t\treturn -1;\n\t\t}\n\t\tbio_put(bio);\n\t\tdev_bytenr += (j - i) * PAGE_CACHE_SIZE;\n\t\ti = j;\n\t}\n\tfor (i = 0; i < num_pages; i++) {\n\t\tblock_ctx->datav[i] = kmap(block_ctx->pagev[i]);\n\t\tif (!block_ctx->datav[i]) {\n\t\t\tprintk(KERN_INFO \"btrfsic: kmap() failed (dev %s)!\\n\",\n\t\t\t       block_ctx->dev->name);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn block_ctx->len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfsic_print_add_link",
          "args": [
            "state",
            "l"
          ],
          "line": 1387
        },
        "resolved": true,
        "details": {
          "function_name": "btrfsic_print_add_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/check-integrity.c",
          "lines": "2614-2629",
          "snippet": "static void btrfsic_print_add_link(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block_link *l)\n{\n\tprintk(KERN_INFO\n\t       \"Add %u* link from %c @%llu (%s/%llu/%d)\"\n\t       \" to %c @%llu (%s/%llu/%d).\\n\",\n\t       l->ref_cnt,\n\t       btrfsic_get_block_type(state, l->block_ref_from),\n\t       l->block_ref_from->logical_bytenr,\n\t       l->block_ref_from->dev_state->name,\n\t       l->block_ref_from->dev_bytenr, l->block_ref_from->mirror_num,\n\t       btrfsic_get_block_type(state, l->block_ref_to),\n\t       l->block_ref_to->logical_bytenr,\n\t       l->block_ref_to->dev_state->name, l->block_ref_to->dev_bytenr,\n\t       l->block_ref_to->mirror_num);\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"extent_io.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/genhd.h>",
            "#include <linux/mutex.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void btrfsic_block_link_init(struct btrfsic_block_link *n);",
            "static void btrfsic_block_link_free(struct btrfsic_block_link *n);",
            "static void btrfsic_block_link_hashtable_remove(struct btrfsic_block_link *l);",
            "static int btrfsic_map_block(struct btrfsic_state *state, u64 bytenr, u32 len,\n\t\t\t     struct btrfsic_block_data_ctx *block_ctx_out,\n\t\t\t     int mirror_num);",
            "static void btrfsic_dump_database(struct btrfsic_state *state);",
            "static void btrfsic_print_add_link(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block_link *l);",
            "static void btrfsic_print_rem_link(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block_link *l);",
            "static void btrfsic_dump_tree(const struct btrfsic_state *state);",
            "static void btrfsic_cmp_log_and_dev_bytenr(struct btrfsic_state *state,\n\t\t\t\t\t   u64 bytenr,\n\t\t\t\t\t   struct btrfsic_dev_state *dev_state,\n\t\t\t\t\t   u64 dev_bytenr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"extent_io.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n#include <linux/blkdev.h>\n#include <linux/genhd.h>\n#include <linux/mutex.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic void btrfsic_block_link_init(struct btrfsic_block_link *n);\nstatic void btrfsic_block_link_free(struct btrfsic_block_link *n);\nstatic void btrfsic_block_link_hashtable_remove(struct btrfsic_block_link *l);\nstatic int btrfsic_map_block(struct btrfsic_state *state, u64 bytenr, u32 len,\n\t\t\t     struct btrfsic_block_data_ctx *block_ctx_out,\n\t\t\t     int mirror_num);\nstatic void btrfsic_dump_database(struct btrfsic_state *state);\nstatic void btrfsic_print_add_link(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block_link *l);\nstatic void btrfsic_print_rem_link(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block_link *l);\nstatic void btrfsic_dump_tree(const struct btrfsic_state *state);\nstatic void btrfsic_cmp_log_and_dev_bytenr(struct btrfsic_state *state,\n\t\t\t\t\t   u64 bytenr,\n\t\t\t\t\t   struct btrfsic_dev_state *dev_state,\n\t\t\t\t\t   u64 dev_bytenr);\n\nstatic void btrfsic_print_add_link(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block_link *l)\n{\n\tprintk(KERN_INFO\n\t       \"Add %u* link from %c @%llu (%s/%llu/%d)\"\n\t       \" to %c @%llu (%s/%llu/%d).\\n\",\n\t       l->ref_cnt,\n\t       btrfsic_get_block_type(state, l->block_ref_from),\n\t       l->block_ref_from->logical_bytenr,\n\t       l->block_ref_from->dev_state->name,\n\t       l->block_ref_from->dev_bytenr, l->block_ref_from->mirror_num,\n\t       btrfsic_get_block_type(state, l->block_ref_to),\n\t       l->block_ref_to->logical_bytenr,\n\t       l->block_ref_to->dev_state->name, l->block_ref_to->dev_bytenr,\n\t       l->block_ref_to->mirror_num);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfsic_block_link_hashtable_add",
          "args": [
            "l",
            "&state->block_link_hashtable"
          ],
          "line": 1379
        },
        "resolved": true,
        "details": {
          "function_name": "btrfsic_block_link_hashtable_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/check-integrity.c",
          "lines": "557-571",
          "snippet": "static void btrfsic_block_link_hashtable_add(\n\t\tstruct btrfsic_block_link *l,\n\t\tstruct btrfsic_block_link_hashtable *h)\n{\n\tconst unsigned int hashval =\n\t    (((unsigned int)(l->block_ref_to->dev_bytenr >> 16)) ^\n\t     ((unsigned int)(l->block_ref_from->dev_bytenr >> 16)) ^\n\t     ((unsigned int)((uintptr_t)l->block_ref_to->dev_state->bdev)) ^\n\t     ((unsigned int)((uintptr_t)l->block_ref_from->dev_state->bdev)))\n\t     & (BTRFSIC_BLOCK_LINK_HASHTABLE_SIZE - 1);\n\n\tBUG_ON(NULL == l->block_ref_to);\n\tBUG_ON(NULL == l->block_ref_from);\n\tlist_add(&l->collision_resolving_node, h->table + hashval);\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"extent_io.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/genhd.h>",
            "#include <linux/mutex.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define BTRFSIC_BLOCK_LINK_HASHTABLE_SIZE 0x10000"
          ],
          "globals_used": [
            "static void btrfsic_block_hashtable_init(struct btrfsic_block_hashtable *h);",
            "static void btrfsic_block_hashtable_add(struct btrfsic_block *b,\n\t\t\t\t\tstruct btrfsic_block_hashtable *h);",
            "static struct btrfsic_block *btrfsic_block_hashtable_lookup(\n\t\tstruct block_device *bdev,\n\t\tu64 dev_bytenr,\n\t\tstruct btrfsic_block_hashtable *h);",
            "static void btrfsic_block_link_hashtable_init(\n\t\tstruct btrfsic_block_link_hashtable *h);",
            "static void btrfsic_block_link_hashtable_add(\n\t\tstruct btrfsic_block_link *l,\n\t\tstruct btrfsic_block_link_hashtable *h);",
            "static void btrfsic_block_link_hashtable_remove(struct btrfsic_block_link *l);",
            "static struct btrfsic_block_link *btrfsic_block_link_hashtable_lookup(\n\t\tstruct block_device *bdev_ref_to,\n\t\tu64 dev_bytenr_ref_to,\n\t\tstruct block_device *bdev_ref_from,\n\t\tu64 dev_bytenr_ref_from,\n\t\tstruct btrfsic_block_link_hashtable *h);",
            "static void btrfsic_dev_state_hashtable_init(\n\t\tstruct btrfsic_dev_state_hashtable *h);",
            "static void btrfsic_dev_state_hashtable_add(\n\t\tstruct btrfsic_dev_state *ds,\n\t\tstruct btrfsic_dev_state_hashtable *h);",
            "static struct btrfsic_dev_state *btrfsic_dev_state_hashtable_lookup(\n\t\tstruct block_device *bdev,\n\t\tstruct btrfsic_dev_state_hashtable *h);",
            "static void btrfsic_print_add_link(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block_link *l);",
            "static void btrfsic_print_rem_link(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block_link *l);",
            "static struct btrfsic_dev_state *btrfsic_dev_state_lookup(\n\t\tstruct block_device *bdev);",
            "static void btrfsic_cmp_log_and_dev_bytenr(struct btrfsic_state *state,\n\t\t\t\t\t   u64 bytenr,\n\t\t\t\t\t   struct btrfsic_dev_state *dev_state,\n\t\t\t\t\t   u64 dev_bytenr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"extent_io.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n#include <linux/blkdev.h>\n#include <linux/genhd.h>\n#include <linux/mutex.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\n#define BTRFSIC_BLOCK_LINK_HASHTABLE_SIZE 0x10000\n\nstatic void btrfsic_block_hashtable_init(struct btrfsic_block_hashtable *h);\nstatic void btrfsic_block_hashtable_add(struct btrfsic_block *b,\n\t\t\t\t\tstruct btrfsic_block_hashtable *h);\nstatic struct btrfsic_block *btrfsic_block_hashtable_lookup(\n\t\tstruct block_device *bdev,\n\t\tu64 dev_bytenr,\n\t\tstruct btrfsic_block_hashtable *h);\nstatic void btrfsic_block_link_hashtable_init(\n\t\tstruct btrfsic_block_link_hashtable *h);\nstatic void btrfsic_block_link_hashtable_add(\n\t\tstruct btrfsic_block_link *l,\n\t\tstruct btrfsic_block_link_hashtable *h);\nstatic void btrfsic_block_link_hashtable_remove(struct btrfsic_block_link *l);\nstatic struct btrfsic_block_link *btrfsic_block_link_hashtable_lookup(\n\t\tstruct block_device *bdev_ref_to,\n\t\tu64 dev_bytenr_ref_to,\n\t\tstruct block_device *bdev_ref_from,\n\t\tu64 dev_bytenr_ref_from,\n\t\tstruct btrfsic_block_link_hashtable *h);\nstatic void btrfsic_dev_state_hashtable_init(\n\t\tstruct btrfsic_dev_state_hashtable *h);\nstatic void btrfsic_dev_state_hashtable_add(\n\t\tstruct btrfsic_dev_state *ds,\n\t\tstruct btrfsic_dev_state_hashtable *h);\nstatic struct btrfsic_dev_state *btrfsic_dev_state_hashtable_lookup(\n\t\tstruct block_device *bdev,\n\t\tstruct btrfsic_dev_state_hashtable *h);\nstatic void btrfsic_print_add_link(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block_link *l);\nstatic void btrfsic_print_rem_link(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block_link *l);\nstatic struct btrfsic_dev_state *btrfsic_dev_state_lookup(\n\t\tstruct block_device *bdev);\nstatic void btrfsic_cmp_log_and_dev_bytenr(struct btrfsic_state *state,\n\t\t\t\t\t   u64 bytenr,\n\t\t\t\t\t   struct btrfsic_dev_state *dev_state,\n\t\t\t\t\t   u64 dev_bytenr);\n\nstatic void btrfsic_block_link_hashtable_add(\n\t\tstruct btrfsic_block_link *l,\n\t\tstruct btrfsic_block_link_hashtable *h)\n{\n\tconst unsigned int hashval =\n\t    (((unsigned int)(l->block_ref_to->dev_bytenr >> 16)) ^\n\t     ((unsigned int)(l->block_ref_from->dev_bytenr >> 16)) ^\n\t     ((unsigned int)((uintptr_t)l->block_ref_to->dev_state->bdev)) ^\n\t     ((unsigned int)((uintptr_t)l->block_ref_from->dev_state->bdev)))\n\t     & (BTRFSIC_BLOCK_LINK_HASHTABLE_SIZE - 1);\n\n\tBUG_ON(NULL == l->block_ref_to);\n\tBUG_ON(NULL == l->block_ref_from);\n\tlist_add(&l->collision_resolving_node, h->table + hashval);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&l->node_ref_from",
            "&next_block->ref_from_list"
          ],
          "line": 1377
        },
        "resolved": true,
        "details": {
          "function_name": "simple_xattr_list_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "966-972",
          "snippet": "void simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_INFO \"btrfsic: error, kmalloc failed!\\n\""
          ],
          "line": 1361
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfsic_block_link_alloc",
          "args": [],
          "line": 1359
        },
        "resolved": true,
        "details": {
          "function_name": "btrfsic_block_link_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/check-integrity.c",
          "lines": "453-462",
          "snippet": "static struct btrfsic_block_link *btrfsic_block_link_alloc(void)\n{\n\tstruct btrfsic_block_link *l;\n\n\tl = kzalloc(sizeof(*l), GFP_NOFS);\n\tif (NULL != l)\n\t\tbtrfsic_block_link_init(l);\n\n\treturn l;\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"extent_io.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/genhd.h>",
            "#include <linux/mutex.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct btrfsic_block_link *btrfsic_block_link_alloc(void);",
            "static void btrfsic_block_link_hashtable_remove(struct btrfsic_block_link *l);",
            "static void btrfsic_print_add_link(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block_link *l);",
            "static void btrfsic_print_rem_link(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block_link *l);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"extent_io.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n#include <linux/blkdev.h>\n#include <linux/genhd.h>\n#include <linux/mutex.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct btrfsic_block_link *btrfsic_block_link_alloc(void);\nstatic void btrfsic_block_link_hashtable_remove(struct btrfsic_block_link *l);\nstatic void btrfsic_print_add_link(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block_link *l);\nstatic void btrfsic_print_rem_link(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block_link *l);\n\nstatic struct btrfsic_block_link *btrfsic_block_link_alloc(void)\n{\n\tstruct btrfsic_block_link *l;\n\n\tl = kzalloc(sizeof(*l), GFP_NOFS);\n\tif (NULL != l)\n\t\tbtrfsic_block_link_init(l);\n\n\treturn l;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfsic_block_link_hashtable_lookup",
          "args": [
            "next_block_ctx->dev->bdev",
            "next_block_ctx->dev_bytenr",
            "block_ctx->dev->bdev",
            "block_ctx->dev_bytenr",
            "&state->block_link_hashtable"
          ],
          "line": 1349
        },
        "resolved": true,
        "details": {
          "function_name": "btrfsic_block_link_hashtable_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/check-integrity.c",
          "lines": "578-608",
          "snippet": "static struct btrfsic_block_link *btrfsic_block_link_hashtable_lookup(\n\t\tstruct block_device *bdev_ref_to,\n\t\tu64 dev_bytenr_ref_to,\n\t\tstruct block_device *bdev_ref_from,\n\t\tu64 dev_bytenr_ref_from,\n\t\tstruct btrfsic_block_link_hashtable *h)\n{\n\tconst unsigned int hashval =\n\t    (((unsigned int)(dev_bytenr_ref_to >> 16)) ^\n\t     ((unsigned int)(dev_bytenr_ref_from >> 16)) ^\n\t     ((unsigned int)((uintptr_t)bdev_ref_to)) ^\n\t     ((unsigned int)((uintptr_t)bdev_ref_from))) &\n\t     (BTRFSIC_BLOCK_LINK_HASHTABLE_SIZE - 1);\n\tstruct list_head *elem;\n\n\tlist_for_each(elem, h->table + hashval) {\n\t\tstruct btrfsic_block_link *const l =\n\t\t    list_entry(elem, struct btrfsic_block_link,\n\t\t\t       collision_resolving_node);\n\n\t\tBUG_ON(NULL == l->block_ref_to);\n\t\tBUG_ON(NULL == l->block_ref_from);\n\t\tif (l->block_ref_to->dev_state->bdev == bdev_ref_to &&\n\t\t    l->block_ref_to->dev_bytenr == dev_bytenr_ref_to &&\n\t\t    l->block_ref_from->dev_state->bdev == bdev_ref_from &&\n\t\t    l->block_ref_from->dev_bytenr == dev_bytenr_ref_from)\n\t\t\treturn l;\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"extent_io.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/genhd.h>",
            "#include <linux/mutex.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define BTRFSIC_BLOCK_LINK_HASHTABLE_SIZE 0x10000"
          ],
          "globals_used": [
            "static void btrfsic_block_hashtable_init(struct btrfsic_block_hashtable *h);",
            "static void btrfsic_block_hashtable_add(struct btrfsic_block *b,\n\t\t\t\t\tstruct btrfsic_block_hashtable *h);",
            "static struct btrfsic_block *btrfsic_block_hashtable_lookup(\n\t\tstruct block_device *bdev,\n\t\tu64 dev_bytenr,\n\t\tstruct btrfsic_block_hashtable *h);",
            "static void btrfsic_block_link_hashtable_init(\n\t\tstruct btrfsic_block_link_hashtable *h);",
            "static void btrfsic_block_link_hashtable_add(\n\t\tstruct btrfsic_block_link *l,\n\t\tstruct btrfsic_block_link_hashtable *h);",
            "static void btrfsic_block_link_hashtable_remove(struct btrfsic_block_link *l);",
            "static struct btrfsic_block_link *btrfsic_block_link_hashtable_lookup(\n\t\tstruct block_device *bdev_ref_to,\n\t\tu64 dev_bytenr_ref_to,\n\t\tstruct block_device *bdev_ref_from,\n\t\tu64 dev_bytenr_ref_from,\n\t\tstruct btrfsic_block_link_hashtable *h);",
            "static void btrfsic_dev_state_hashtable_init(\n\t\tstruct btrfsic_dev_state_hashtable *h);",
            "static void btrfsic_dev_state_hashtable_add(\n\t\tstruct btrfsic_dev_state *ds,\n\t\tstruct btrfsic_dev_state_hashtable *h);",
            "static struct btrfsic_dev_state *btrfsic_dev_state_hashtable_lookup(\n\t\tstruct block_device *bdev,\n\t\tstruct btrfsic_dev_state_hashtable *h);",
            "static void btrfsic_print_add_link(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block_link *l);",
            "static void btrfsic_print_rem_link(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block_link *l);",
            "static struct btrfsic_dev_state *btrfsic_dev_state_lookup(\n\t\tstruct block_device *bdev);",
            "static void btrfsic_cmp_log_and_dev_bytenr(struct btrfsic_state *state,\n\t\t\t\t\t   u64 bytenr,\n\t\t\t\t\t   struct btrfsic_dev_state *dev_state,\n\t\t\t\t\t   u64 dev_bytenr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"extent_io.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n#include <linux/blkdev.h>\n#include <linux/genhd.h>\n#include <linux/mutex.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\n#define BTRFSIC_BLOCK_LINK_HASHTABLE_SIZE 0x10000\n\nstatic void btrfsic_block_hashtable_init(struct btrfsic_block_hashtable *h);\nstatic void btrfsic_block_hashtable_add(struct btrfsic_block *b,\n\t\t\t\t\tstruct btrfsic_block_hashtable *h);\nstatic struct btrfsic_block *btrfsic_block_hashtable_lookup(\n\t\tstruct block_device *bdev,\n\t\tu64 dev_bytenr,\n\t\tstruct btrfsic_block_hashtable *h);\nstatic void btrfsic_block_link_hashtable_init(\n\t\tstruct btrfsic_block_link_hashtable *h);\nstatic void btrfsic_block_link_hashtable_add(\n\t\tstruct btrfsic_block_link *l,\n\t\tstruct btrfsic_block_link_hashtable *h);\nstatic void btrfsic_block_link_hashtable_remove(struct btrfsic_block_link *l);\nstatic struct btrfsic_block_link *btrfsic_block_link_hashtable_lookup(\n\t\tstruct block_device *bdev_ref_to,\n\t\tu64 dev_bytenr_ref_to,\n\t\tstruct block_device *bdev_ref_from,\n\t\tu64 dev_bytenr_ref_from,\n\t\tstruct btrfsic_block_link_hashtable *h);\nstatic void btrfsic_dev_state_hashtable_init(\n\t\tstruct btrfsic_dev_state_hashtable *h);\nstatic void btrfsic_dev_state_hashtable_add(\n\t\tstruct btrfsic_dev_state *ds,\n\t\tstruct btrfsic_dev_state_hashtable *h);\nstatic struct btrfsic_dev_state *btrfsic_dev_state_hashtable_lookup(\n\t\tstruct block_device *bdev,\n\t\tstruct btrfsic_dev_state_hashtable *h);\nstatic void btrfsic_print_add_link(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block_link *l);\nstatic void btrfsic_print_rem_link(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block_link *l);\nstatic struct btrfsic_dev_state *btrfsic_dev_state_lookup(\n\t\tstruct block_device *bdev);\nstatic void btrfsic_cmp_log_and_dev_bytenr(struct btrfsic_state *state,\n\t\t\t\t\t   u64 bytenr,\n\t\t\t\t\t   struct btrfsic_dev_state *dev_state,\n\t\t\t\t\t   u64 dev_bytenr);\n\nstatic struct btrfsic_block_link *btrfsic_block_link_hashtable_lookup(\n\t\tstruct block_device *bdev_ref_to,\n\t\tu64 dev_bytenr_ref_to,\n\t\tstruct block_device *bdev_ref_from,\n\t\tu64 dev_bytenr_ref_from,\n\t\tstruct btrfsic_block_link_hashtable *h)\n{\n\tconst unsigned int hashval =\n\t    (((unsigned int)(dev_bytenr_ref_to >> 16)) ^\n\t     ((unsigned int)(dev_bytenr_ref_from >> 16)) ^\n\t     ((unsigned int)((uintptr_t)bdev_ref_to)) ^\n\t     ((unsigned int)((uintptr_t)bdev_ref_from))) &\n\t     (BTRFSIC_BLOCK_LINK_HASHTABLE_SIZE - 1);\n\tstruct list_head *elem;\n\n\tlist_for_each(elem, h->table + hashval) {\n\t\tstruct btrfsic_block_link *const l =\n\t\t    list_entry(elem, struct btrfsic_block_link,\n\t\t\t       collision_resolving_node);\n\n\t\tBUG_ON(NULL == l->block_ref_to);\n\t\tBUG_ON(NULL == l->block_ref_from);\n\t\tif (l->block_ref_to->dev_state->bdev == bdev_ref_to &&\n\t\t    l->block_ref_to->dev_bytenr == dev_bytenr_ref_to &&\n\t\t    l->block_ref_from->dev_state->bdev == bdev_ref_from &&\n\t\t    l->block_ref_from->dev_bytenr == dev_bytenr_ref_from)\n\t\t\treturn l;\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfsic_get_block_type",
          "args": [
            "state",
            "next_block"
          ],
          "line": 1343
        },
        "resolved": true,
        "details": {
          "function_name": "btrfsic_get_block_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/check-integrity.c",
          "lines": "2648-2661",
          "snippet": "static char btrfsic_get_block_type(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block *block)\n{\n\tif (block->is_superblock &&\n\t    state->latest_superblock->dev_bytenr == block->dev_bytenr &&\n\t    state->latest_superblock->dev_state->bdev == block->dev_state->bdev)\n\t\treturn 'S';\n\telse if (block->is_superblock)\n\t\treturn 's';\n\telse if (block->is_metadata)\n\t\treturn 'M';\n\telse\n\t\treturn 'D';\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"extent_io.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/genhd.h>",
            "#include <linux/mutex.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void btrfsic_dump_database(struct btrfsic_state *state);",
            "static char btrfsic_get_block_type(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block *block);",
            "static void btrfsic_dump_tree(const struct btrfsic_state *state);",
            "static struct btrfsic_dev_state *btrfsic_dev_state_lookup(\n\t\tstruct block_device *bdev);",
            "static void btrfsic_cmp_log_and_dev_bytenr(struct btrfsic_state *state,\n\t\t\t\t\t   u64 bytenr,\n\t\t\t\t\t   struct btrfsic_dev_state *dev_state,\n\t\t\t\t\t   u64 dev_bytenr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"extent_io.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n#include <linux/blkdev.h>\n#include <linux/genhd.h>\n#include <linux/mutex.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic void btrfsic_dump_database(struct btrfsic_state *state);\nstatic char btrfsic_get_block_type(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block *block);\nstatic void btrfsic_dump_tree(const struct btrfsic_state *state);\nstatic struct btrfsic_dev_state *btrfsic_dev_state_lookup(\n\t\tstruct block_device *bdev);\nstatic void btrfsic_cmp_log_and_dev_bytenr(struct btrfsic_state *state,\n\t\t\t\t\t   u64 bytenr,\n\t\t\t\t\t   struct btrfsic_dev_state *dev_state,\n\t\t\t\t\t   u64 dev_bytenr);\n\nstatic char btrfsic_get_block_type(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block *block)\n{\n\tif (block->is_superblock &&\n\t    state->latest_superblock->dev_bytenr == block->dev_bytenr &&\n\t    state->latest_superblock->dev_state->bdev == block->dev_state->bdev)\n\t\treturn 'S';\n\telse if (block->is_superblock)\n\t\treturn 's';\n\telse if (block->is_metadata)\n\t\treturn 'M';\n\telse\n\t\treturn 'D';\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfsic_block_lookup_or_add",
          "args": [
            "state",
            "next_block_ctx",
            "\"referenced \"",
            "1",
            "force_iodone_flag",
            "!force_iodone_flag",
            "*mirror_nump",
            "&block_was_created"
          ],
          "line": 1312
        },
        "resolved": true,
        "details": {
          "function_name": "btrfsic_block_lookup_or_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/check-integrity.c",
          "lines": "2780-2834",
          "snippet": "static struct btrfsic_block *btrfsic_block_lookup_or_add(\n\t\tstruct btrfsic_state *state,\n\t\tstruct btrfsic_block_data_ctx *block_ctx,\n\t\tconst char *additional_string,\n\t\tint is_metadata,\n\t\tint is_iodone,\n\t\tint never_written,\n\t\tint mirror_num,\n\t\tint *was_created)\n{\n\tstruct btrfsic_block *block;\n\n\tblock = btrfsic_block_hashtable_lookup(block_ctx->dev->bdev,\n\t\t\t\t\t       block_ctx->dev_bytenr,\n\t\t\t\t\t       &state->block_hashtable);\n\tif (NULL == block) {\n\t\tstruct btrfsic_dev_state *dev_state;\n\n\t\tblock = btrfsic_block_alloc();\n\t\tif (NULL == block) {\n\t\t\tprintk(KERN_INFO \"btrfsic: error, kmalloc failed!\\n\");\n\t\t\treturn NULL;\n\t\t}\n\t\tdev_state = btrfsic_dev_state_lookup(block_ctx->dev->bdev);\n\t\tif (NULL == dev_state) {\n\t\t\tprintk(KERN_INFO\n\t\t\t       \"btrfsic: error, lookup dev_state failed!\\n\");\n\t\t\tbtrfsic_block_free(block);\n\t\t\treturn NULL;\n\t\t}\n\t\tblock->dev_state = dev_state;\n\t\tblock->dev_bytenr = block_ctx->dev_bytenr;\n\t\tblock->logical_bytenr = block_ctx->start;\n\t\tblock->is_metadata = is_metadata;\n\t\tblock->is_iodone = is_iodone;\n\t\tblock->never_written = never_written;\n\t\tblock->mirror_num = mirror_num;\n\t\tif (state->print_mask & BTRFSIC_PRINT_MASK_VERBOSE)\n\t\t\tprintk(KERN_INFO\n\t\t\t       \"New %s%c-block @%llu (%s/%llu/%d)\\n\",\n\t\t\t       additional_string,\n\t\t\t       btrfsic_get_block_type(state, block),\n\t\t\t       block->logical_bytenr, dev_state->name,\n\t\t\t       block->dev_bytenr, mirror_num);\n\t\tlist_add(&block->all_blocks_node, &state->all_blocks_list);\n\t\tbtrfsic_block_hashtable_add(block, &state->block_hashtable);\n\t\tif (NULL != was_created)\n\t\t\t*was_created = 1;\n\t} else {\n\t\tif (NULL != was_created)\n\t\t\t*was_created = 0;\n\t}\n\n\treturn block;\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"extent_io.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/genhd.h>",
            "#include <linux/mutex.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define BTRFSIC_PRINT_MASK_VERBOSE\t\t\t\t0x00000040"
          ],
          "globals_used": [
            "static struct btrfsic_block *btrfsic_block_alloc(void);",
            "static void btrfsic_block_link_init(struct btrfsic_block_link *n);",
            "static void btrfsic_block_link_free(struct btrfsic_block_link *n);",
            "static int btrfsic_map_block(struct btrfsic_state *state, u64 bytenr, u32 len,\n\t\t\t     struct btrfsic_block_data_ctx *block_ctx_out,\n\t\t\t     int mirror_num);",
            "static void btrfsic_release_block_ctx(struct btrfsic_block_data_ctx *block_ctx);",
            "static int btrfsic_read_block(struct btrfsic_state *state,\n\t\t\t      struct btrfsic_block_data_ctx *block_ctx);",
            "static void btrfsic_dump_database(struct btrfsic_state *state);",
            "static char btrfsic_get_block_type(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block *block);",
            "static void btrfsic_dump_tree(const struct btrfsic_state *state);",
            "static struct btrfsic_block *btrfsic_block_lookup_or_add(\n\t\tstruct btrfsic_state *state,\n\t\tstruct btrfsic_block_data_ctx *block_ctx,\n\t\tconst char *additional_string,\n\t\tint is_metadata,\n\t\tint is_iodone,\n\t\tint never_written,\n\t\tint mirror_num,\n\t\tint *was_created);",
            "static struct btrfsic_dev_state *btrfsic_dev_state_lookup(\n\t\tstruct block_device *bdev);",
            "static void btrfsic_cmp_log_and_dev_bytenr(struct btrfsic_state *state,\n\t\t\t\t\t   u64 bytenr,\n\t\t\t\t\t   struct btrfsic_dev_state *dev_state,\n\t\t\t\t\t   u64 dev_bytenr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"extent_io.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n#include <linux/blkdev.h>\n#include <linux/genhd.h>\n#include <linux/mutex.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\n#define BTRFSIC_PRINT_MASK_VERBOSE\t\t\t\t0x00000040\n\nstatic struct btrfsic_block *btrfsic_block_alloc(void);\nstatic void btrfsic_block_link_init(struct btrfsic_block_link *n);\nstatic void btrfsic_block_link_free(struct btrfsic_block_link *n);\nstatic int btrfsic_map_block(struct btrfsic_state *state, u64 bytenr, u32 len,\n\t\t\t     struct btrfsic_block_data_ctx *block_ctx_out,\n\t\t\t     int mirror_num);\nstatic void btrfsic_release_block_ctx(struct btrfsic_block_data_ctx *block_ctx);\nstatic int btrfsic_read_block(struct btrfsic_state *state,\n\t\t\t      struct btrfsic_block_data_ctx *block_ctx);\nstatic void btrfsic_dump_database(struct btrfsic_state *state);\nstatic char btrfsic_get_block_type(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block *block);\nstatic void btrfsic_dump_tree(const struct btrfsic_state *state);\nstatic struct btrfsic_block *btrfsic_block_lookup_or_add(\n\t\tstruct btrfsic_state *state,\n\t\tstruct btrfsic_block_data_ctx *block_ctx,\n\t\tconst char *additional_string,\n\t\tint is_metadata,\n\t\tint is_iodone,\n\t\tint never_written,\n\t\tint mirror_num,\n\t\tint *was_created);\nstatic struct btrfsic_dev_state *btrfsic_dev_state_lookup(\n\t\tstruct block_device *bdev);\nstatic void btrfsic_cmp_log_and_dev_bytenr(struct btrfsic_state *state,\n\t\t\t\t\t   u64 bytenr,\n\t\t\t\t\t   struct btrfsic_dev_state *dev_state,\n\t\t\t\t\t   u64 dev_bytenr);\n\nstatic struct btrfsic_block *btrfsic_block_lookup_or_add(\n\t\tstruct btrfsic_state *state,\n\t\tstruct btrfsic_block_data_ctx *block_ctx,\n\t\tconst char *additional_string,\n\t\tint is_metadata,\n\t\tint is_iodone,\n\t\tint never_written,\n\t\tint mirror_num,\n\t\tint *was_created)\n{\n\tstruct btrfsic_block *block;\n\n\tblock = btrfsic_block_hashtable_lookup(block_ctx->dev->bdev,\n\t\t\t\t\t       block_ctx->dev_bytenr,\n\t\t\t\t\t       &state->block_hashtable);\n\tif (NULL == block) {\n\t\tstruct btrfsic_dev_state *dev_state;\n\n\t\tblock = btrfsic_block_alloc();\n\t\tif (NULL == block) {\n\t\t\tprintk(KERN_INFO \"btrfsic: error, kmalloc failed!\\n\");\n\t\t\treturn NULL;\n\t\t}\n\t\tdev_state = btrfsic_dev_state_lookup(block_ctx->dev->bdev);\n\t\tif (NULL == dev_state) {\n\t\t\tprintk(KERN_INFO\n\t\t\t       \"btrfsic: error, lookup dev_state failed!\\n\");\n\t\t\tbtrfsic_block_free(block);\n\t\t\treturn NULL;\n\t\t}\n\t\tblock->dev_state = dev_state;\n\t\tblock->dev_bytenr = block_ctx->dev_bytenr;\n\t\tblock->logical_bytenr = block_ctx->start;\n\t\tblock->is_metadata = is_metadata;\n\t\tblock->is_iodone = is_iodone;\n\t\tblock->never_written = never_written;\n\t\tblock->mirror_num = mirror_num;\n\t\tif (state->print_mask & BTRFSIC_PRINT_MASK_VERBOSE)\n\t\t\tprintk(KERN_INFO\n\t\t\t       \"New %s%c-block @%llu (%s/%llu/%d)\\n\",\n\t\t\t       additional_string,\n\t\t\t       btrfsic_get_block_type(state, block),\n\t\t\t       block->logical_bytenr, dev_state->name,\n\t\t\t       block->dev_bytenr, mirror_num);\n\t\tlist_add(&block->all_blocks_node, &state->all_blocks_list);\n\t\tbtrfsic_block_hashtable_add(block, &state->block_hashtable);\n\t\tif (NULL != was_created)\n\t\t\t*was_created = 1;\n\t} else {\n\t\tif (NULL != was_created)\n\t\t\t*was_created = 0;\n\t}\n\n\treturn block;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfsic_map_block",
          "args": [
            "state",
            "next_bytenr",
            "state->metablock_size",
            "next_block_ctx",
            "*mirror_nump"
          ],
          "line": 1300
        },
        "resolved": true,
        "details": {
          "function_name": "btrfsic_map_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/check-integrity.c",
          "lines": "1568-1609",
          "snippet": "static int btrfsic_map_block(struct btrfsic_state *state, u64 bytenr, u32 len,\n\t\t\t     struct btrfsic_block_data_ctx *block_ctx_out,\n\t\t\t     int mirror_num)\n{\n\tint ret;\n\tu64 length;\n\tstruct btrfs_bio *multi = NULL;\n\tstruct btrfs_device *device;\n\n\tlength = len;\n\tret = btrfs_map_block(state->root->fs_info, READ,\n\t\t\t      bytenr, &length, &multi, mirror_num);\n\n\tif (ret) {\n\t\tblock_ctx_out->start = 0;\n\t\tblock_ctx_out->dev_bytenr = 0;\n\t\tblock_ctx_out->len = 0;\n\t\tblock_ctx_out->dev = NULL;\n\t\tblock_ctx_out->datav = NULL;\n\t\tblock_ctx_out->pagev = NULL;\n\t\tblock_ctx_out->mem_to_free = NULL;\n\n\t\treturn ret;\n\t}\n\n\tdevice = multi->stripes[0].dev;\n\tblock_ctx_out->dev = btrfsic_dev_state_lookup(device->bdev);\n\tblock_ctx_out->dev_bytenr = multi->stripes[0].physical;\n\tblock_ctx_out->start = bytenr;\n\tblock_ctx_out->len = len;\n\tblock_ctx_out->datav = NULL;\n\tblock_ctx_out->pagev = NULL;\n\tblock_ctx_out->mem_to_free = NULL;\n\n\tkfree(multi);\n\tif (NULL == block_ctx_out->dev) {\n\t\tret = -ENXIO;\n\t\tprintk(KERN_INFO \"btrfsic: error, cannot lookup dev (#1)!\\n\");\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"extent_io.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/genhd.h>",
            "#include <linux/mutex.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void btrfsic_block_link_init(struct btrfsic_block_link *n);",
            "static void btrfsic_block_link_free(struct btrfsic_block_link *n);",
            "static void btrfsic_read_from_block_data(\n\tstruct btrfsic_block_data_ctx *block_ctx,\n\tvoid *dst, u32 offset, size_t len);",
            "static int btrfsic_map_block(struct btrfsic_state *state, u64 bytenr, u32 len,\n\t\t\t     struct btrfsic_block_data_ctx *block_ctx_out,\n\t\t\t     int mirror_num);",
            "static void btrfsic_dump_database(struct btrfsic_state *state);",
            "static void btrfsic_dump_tree(const struct btrfsic_state *state);",
            "static struct btrfsic_dev_state *btrfsic_dev_state_lookup(\n\t\tstruct block_device *bdev);",
            "static void btrfsic_cmp_log_and_dev_bytenr(struct btrfsic_state *state,\n\t\t\t\t\t   u64 bytenr,\n\t\t\t\t\t   struct btrfsic_dev_state *dev_state,\n\t\t\t\t\t   u64 dev_bytenr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"extent_io.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n#include <linux/blkdev.h>\n#include <linux/genhd.h>\n#include <linux/mutex.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic void btrfsic_block_link_init(struct btrfsic_block_link *n);\nstatic void btrfsic_block_link_free(struct btrfsic_block_link *n);\nstatic void btrfsic_read_from_block_data(\n\tstruct btrfsic_block_data_ctx *block_ctx,\n\tvoid *dst, u32 offset, size_t len);\nstatic int btrfsic_map_block(struct btrfsic_state *state, u64 bytenr, u32 len,\n\t\t\t     struct btrfsic_block_data_ctx *block_ctx_out,\n\t\t\t     int mirror_num);\nstatic void btrfsic_dump_database(struct btrfsic_state *state);\nstatic void btrfsic_dump_tree(const struct btrfsic_state *state);\nstatic struct btrfsic_dev_state *btrfsic_dev_state_lookup(\n\t\tstruct block_device *bdev);\nstatic void btrfsic_cmp_log_and_dev_bytenr(struct btrfsic_state *state,\n\t\t\t\t\t   u64 bytenr,\n\t\t\t\t\t   struct btrfsic_dev_state *dev_state,\n\t\t\t\t\t   u64 dev_bytenr);\n\nstatic int btrfsic_map_block(struct btrfsic_state *state, u64 bytenr, u32 len,\n\t\t\t     struct btrfsic_block_data_ctx *block_ctx_out,\n\t\t\t     int mirror_num)\n{\n\tint ret;\n\tu64 length;\n\tstruct btrfs_bio *multi = NULL;\n\tstruct btrfs_device *device;\n\n\tlength = len;\n\tret = btrfs_map_block(state->root->fs_info, READ,\n\t\t\t      bytenr, &length, &multi, mirror_num);\n\n\tif (ret) {\n\t\tblock_ctx_out->start = 0;\n\t\tblock_ctx_out->dev_bytenr = 0;\n\t\tblock_ctx_out->len = 0;\n\t\tblock_ctx_out->dev = NULL;\n\t\tblock_ctx_out->datav = NULL;\n\t\tblock_ctx_out->pagev = NULL;\n\t\tblock_ctx_out->mem_to_free = NULL;\n\n\t\treturn ret;\n\t}\n\n\tdevice = multi->stripes[0].dev;\n\tblock_ctx_out->dev = btrfsic_dev_state_lookup(device->bdev);\n\tblock_ctx_out->dev_bytenr = multi->stripes[0].physical;\n\tblock_ctx_out->start = bytenr;\n\tblock_ctx_out->len = len;\n\tblock_ctx_out->datav = NULL;\n\tblock_ctx_out->pagev = NULL;\n\tblock_ctx_out->mem_to_free = NULL;\n\n\tkfree(multi);\n\tif (NULL == block_ctx_out->dev) {\n\t\tret = -ENXIO;\n\t\tprintk(KERN_INFO \"btrfsic: error, cannot lookup dev (#1)!\\n\");\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_num_copies",
          "args": [
            "state->root->fs_info",
            "next_bytenr",
            "state->metablock_size"
          ],
          "line": 1285
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_num_copies",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
          "lines": "4740-4790",
          "snippet": "int btrfs_num_copies(struct btrfs_fs_info *fs_info, u64 logical, u64 len)\n{\n\tstruct btrfs_mapping_tree *map_tree = &fs_info->mapping_tree;\n\tstruct extent_map *em;\n\tstruct map_lookup *map;\n\tstruct extent_map_tree *em_tree = &map_tree->map_tree;\n\tint ret;\n\n\tread_lock(&em_tree->lock);\n\tem = lookup_extent_mapping(em_tree, logical, len);\n\tread_unlock(&em_tree->lock);\n\n\t/*\n\t * We could return errors for these cases, but that could get ugly and\n\t * we'd probably do the same thing which is just not do anything else\n\t * and exit, so return 1 so the callers don't try to use other copies.\n\t */\n\tif (!em) {\n\t\tbtrfs_crit(fs_info, \"No mapping for %Lu-%Lu\", logical,\n\t\t\t    logical+len);\n\t\treturn 1;\n\t}\n\n\tif (em->start > logical || em->start + em->len < logical) {\n\t\tbtrfs_crit(fs_info, \"Invalid mapping for %Lu-%Lu, got \"\n\t\t\t    \"%Lu-%Lu\", logical, logical+len, em->start,\n\t\t\t    em->start + em->len);\n\t\tfree_extent_map(em);\n\t\treturn 1;\n\t}\n\n\tmap = (struct map_lookup *)em->bdev;\n\tif (map->type & (BTRFS_BLOCK_GROUP_DUP | BTRFS_BLOCK_GROUP_RAID1))\n\t\tret = map->num_stripes;\n\telse if (map->type & BTRFS_BLOCK_GROUP_RAID10)\n\t\tret = map->sub_stripes;\n\telse if (map->type & BTRFS_BLOCK_GROUP_RAID5)\n\t\tret = 2;\n\telse if (map->type & BTRFS_BLOCK_GROUP_RAID6)\n\t\tret = 3;\n\telse\n\t\tret = 1;\n\tfree_extent_map(em);\n\n\tbtrfs_dev_replace_lock(&fs_info->dev_replace);\n\tif (btrfs_dev_replace_is_ongoing(&fs_info->dev_replace))\n\t\tret++;\n\tbtrfs_dev_replace_unlock(&fs_info->dev_replace);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\nstatic noinline struct;\n\nint btrfs_num_copies(struct btrfs_fs_info *fs_info, u64 logical, u64 len)\n{\n\tstruct btrfs_mapping_tree *map_tree = &fs_info->mapping_tree;\n\tstruct extent_map *em;\n\tstruct map_lookup *map;\n\tstruct extent_map_tree *em_tree = &map_tree->map_tree;\n\tint ret;\n\n\tread_lock(&em_tree->lock);\n\tem = lookup_extent_mapping(em_tree, logical, len);\n\tread_unlock(&em_tree->lock);\n\n\t/*\n\t * We could return errors for these cases, but that could get ugly and\n\t * we'd probably do the same thing which is just not do anything else\n\t * and exit, so return 1 so the callers don't try to use other copies.\n\t */\n\tif (!em) {\n\t\tbtrfs_crit(fs_info, \"No mapping for %Lu-%Lu\", logical,\n\t\t\t    logical+len);\n\t\treturn 1;\n\t}\n\n\tif (em->start > logical || em->start + em->len < logical) {\n\t\tbtrfs_crit(fs_info, \"Invalid mapping for %Lu-%Lu, got \"\n\t\t\t    \"%Lu-%Lu\", logical, logical+len, em->start,\n\t\t\t    em->start + em->len);\n\t\tfree_extent_map(em);\n\t\treturn 1;\n\t}\n\n\tmap = (struct map_lookup *)em->bdev;\n\tif (map->type & (BTRFS_BLOCK_GROUP_DUP | BTRFS_BLOCK_GROUP_RAID1))\n\t\tret = map->num_stripes;\n\telse if (map->type & BTRFS_BLOCK_GROUP_RAID10)\n\t\tret = map->sub_stripes;\n\telse if (map->type & BTRFS_BLOCK_GROUP_RAID5)\n\t\tret = 2;\n\telse if (map->type & BTRFS_BLOCK_GROUP_RAID6)\n\t\tret = 3;\n\telse\n\t\tret = 1;\n\tfree_extent_map(em);\n\n\tbtrfs_dev_replace_lock(&fs_info->dev_replace);\n\tif (btrfs_dev_replace_is_ongoing(&fs_info->dev_replace))\n\t\tret++;\n\tbtrfs_dev_replace_unlock(&fs_info->dev_replace);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"extent_io.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n#include <linux/blkdev.h>\n#include <linux/genhd.h>\n#include <linux/mutex.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\n#define BTRFSIC_PRINT_MASK_NUM_COPIES\t\t\t\t0x00000800\n#define BTRFSIC_PRINT_MASK_VERBOSE\t\t\t\t0x00000040\n#define BTRFSIC_GENERATION_UNKNOWN ((u64)-1)\n\nstatic void btrfsic_block_link_init(struct btrfsic_block_link *n);\nstatic struct btrfsic_block_link *btrfsic_block_link_alloc(void);\nstatic void btrfsic_block_link_free(struct btrfsic_block_link *n);\nstatic void btrfsic_block_link_hashtable_remove(struct btrfsic_block_link *l);\nstatic int btrfsic_process_metablock(struct btrfsic_state *state,\n\t\t\t\t     struct btrfsic_block *block,\n\t\t\t\t     struct btrfsic_block_data_ctx *block_ctx,\n\t\t\t\t     int limit_nesting, int force_iodone_flag);\nstatic void btrfsic_read_from_block_data(\n\tstruct btrfsic_block_data_ctx *block_ctx,\n\tvoid *dst, u32 offset, size_t len);\nstatic int btrfsic_create_link_to_next_block(\n\t\tstruct btrfsic_state *state,\n\t\tstruct btrfsic_block *block,\n\t\tstruct btrfsic_block_data_ctx\n\t\t*block_ctx, u64 next_bytenr,\n\t\tint limit_nesting,\n\t\tstruct btrfsic_block_data_ctx *next_block_ctx,\n\t\tstruct btrfsic_block **next_blockp,\n\t\tint force_iodone_flag,\n\t\tint *num_copiesp, int *mirror_nump,\n\t\tstruct btrfs_disk_key *disk_key,\n\t\tu64 parent_generation);\nstatic int btrfsic_handle_extent_data(struct btrfsic_state *state,\n\t\t\t\t      struct btrfsic_block *block,\n\t\t\t\t      struct btrfsic_block_data_ctx *block_ctx,\n\t\t\t\t      u32 item_offset, int force_iodone_flag);\nstatic int btrfsic_map_block(struct btrfsic_state *state, u64 bytenr, u32 len,\n\t\t\t     struct btrfsic_block_data_ctx *block_ctx_out,\n\t\t\t     int mirror_num);\nstatic void btrfsic_release_block_ctx(struct btrfsic_block_data_ctx *block_ctx);\nstatic int btrfsic_read_block(struct btrfsic_state *state,\n\t\t\t      struct btrfsic_block_data_ctx *block_ctx);\nstatic void btrfsic_dump_database(struct btrfsic_state *state);\nstatic void btrfsic_print_add_link(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block_link *l);\nstatic void btrfsic_print_rem_link(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block_link *l);\nstatic char btrfsic_get_block_type(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block *block);\nstatic void btrfsic_dump_tree(const struct btrfsic_state *state);\nstatic struct btrfsic_block_link *btrfsic_block_link_lookup_or_add(\n\t\tstruct btrfsic_state *state,\n\t\tstruct btrfsic_block_data_ctx *next_block_ctx,\n\t\tstruct btrfsic_block *next_block,\n\t\tstruct btrfsic_block *from_block,\n\t\tu64 parent_generation);\nstatic struct btrfsic_dev_state *btrfsic_dev_state_lookup(\n\t\tstruct block_device *bdev);\nstatic void btrfsic_cmp_log_and_dev_bytenr(struct btrfsic_state *state,\n\t\t\t\t\t   u64 bytenr,\n\t\t\t\t\t   struct btrfsic_dev_state *dev_state,\n\t\t\t\t\t   u64 dev_bytenr);\n\nstatic int btrfsic_create_link_to_next_block(\n\t\tstruct btrfsic_state *state,\n\t\tstruct btrfsic_block *block,\n\t\tstruct btrfsic_block_data_ctx *block_ctx,\n\t\tu64 next_bytenr,\n\t\tint limit_nesting,\n\t\tstruct btrfsic_block_data_ctx *next_block_ctx,\n\t\tstruct btrfsic_block **next_blockp,\n\t\tint force_iodone_flag,\n\t\tint *num_copiesp, int *mirror_nump,\n\t\tstruct btrfs_disk_key *disk_key,\n\t\tu64 parent_generation)\n{\n\tstruct btrfsic_block *next_block = NULL;\n\tint ret;\n\tstruct btrfsic_block_link *l;\n\tint did_alloc_block_link;\n\tint block_was_created;\n\n\t*next_blockp = NULL;\n\tif (0 == *num_copiesp) {\n\t\t*num_copiesp =\n\t\t    btrfs_num_copies(state->root->fs_info,\n\t\t\t\t     next_bytenr, state->metablock_size);\n\t\tif (state->print_mask & BTRFSIC_PRINT_MASK_NUM_COPIES)\n\t\t\tprintk(KERN_INFO \"num_copies(log_bytenr=%llu) = %d\\n\",\n\t\t\t       next_bytenr, *num_copiesp);\n\t\t*mirror_nump = 1;\n\t}\n\n\tif (*mirror_nump > *num_copiesp)\n\t\treturn 0;\n\n\tif (state->print_mask & BTRFSIC_PRINT_MASK_VERBOSE)\n\t\tprintk(KERN_INFO\n\t\t       \"btrfsic_create_link_to_next_block(mirror_num=%d)\\n\",\n\t\t       *mirror_nump);\n\tret = btrfsic_map_block(state, next_bytenr,\n\t\t\t\tstate->metablock_size,\n\t\t\t\tnext_block_ctx, *mirror_nump);\n\tif (ret) {\n\t\tprintk(KERN_INFO\n\t\t       \"btrfsic: btrfsic_map_block(@%llu, mirror=%d) failed!\\n\",\n\t\t       next_bytenr, *mirror_nump);\n\t\tbtrfsic_release_block_ctx(next_block_ctx);\n\t\t*next_blockp = NULL;\n\t\treturn -1;\n\t}\n\n\tnext_block = btrfsic_block_lookup_or_add(state,\n\t\t\t\t\t\t next_block_ctx, \"referenced \",\n\t\t\t\t\t\t 1, force_iodone_flag,\n\t\t\t\t\t\t !force_iodone_flag,\n\t\t\t\t\t\t *mirror_nump,\n\t\t\t\t\t\t &block_was_created);\n\tif (NULL == next_block) {\n\t\tbtrfsic_release_block_ctx(next_block_ctx);\n\t\t*next_blockp = NULL;\n\t\treturn -1;\n\t}\n\tif (block_was_created) {\n\t\tl = NULL;\n\t\tnext_block->generation = BTRFSIC_GENERATION_UNKNOWN;\n\t} else {\n\t\tif (state->print_mask & BTRFSIC_PRINT_MASK_VERBOSE) {\n\t\t\tif (next_block->logical_bytenr != next_bytenr &&\n\t\t\t    !(!next_block->is_metadata &&\n\t\t\t      0 == next_block->logical_bytenr))\n\t\t\t\tprintk(KERN_INFO\n\t\t\t\t       \"Referenced block @%llu (%s/%llu/%d) found in hash table, %c, bytenr mismatch (!= stored %llu).\\n\",\n\t\t\t\t       next_bytenr, next_block_ctx->dev->name,\n\t\t\t\t       next_block_ctx->dev_bytenr, *mirror_nump,\n\t\t\t\t       btrfsic_get_block_type(state,\n\t\t\t\t\t\t\t      next_block),\n\t\t\t\t       next_block->logical_bytenr);\n\t\t\telse\n\t\t\t\tprintk(KERN_INFO\n\t\t\t\t       \"Referenced block @%llu (%s/%llu/%d) found in hash table, %c.\\n\",\n\t\t\t\t       next_bytenr, next_block_ctx->dev->name,\n\t\t\t\t       next_block_ctx->dev_bytenr, *mirror_nump,\n\t\t\t\t       btrfsic_get_block_type(state,\n\t\t\t\t\t\t\t      next_block));\n\t\t}\n\t\tnext_block->logical_bytenr = next_bytenr;\n\n\t\tnext_block->mirror_num = *mirror_nump;\n\t\tl = btrfsic_block_link_hashtable_lookup(\n\t\t\t\tnext_block_ctx->dev->bdev,\n\t\t\t\tnext_block_ctx->dev_bytenr,\n\t\t\t\tblock_ctx->dev->bdev,\n\t\t\t\tblock_ctx->dev_bytenr,\n\t\t\t\t&state->block_link_hashtable);\n\t}\n\n\tnext_block->disk_key = *disk_key;\n\tif (NULL == l) {\n\t\tl = btrfsic_block_link_alloc();\n\t\tif (NULL == l) {\n\t\t\tprintk(KERN_INFO \"btrfsic: error, kmalloc failed!\\n\");\n\t\t\tbtrfsic_release_block_ctx(next_block_ctx);\n\t\t\t*next_blockp = NULL;\n\t\t\treturn -1;\n\t\t}\n\n\t\tdid_alloc_block_link = 1;\n\t\tl->block_ref_to = next_block;\n\t\tl->block_ref_from = block;\n\t\tl->ref_cnt = 1;\n\t\tl->parent_generation = parent_generation;\n\n\t\tif (state->print_mask & BTRFSIC_PRINT_MASK_VERBOSE)\n\t\t\tbtrfsic_print_add_link(state, l);\n\n\t\tlist_add(&l->node_ref_to, &block->ref_to_list);\n\t\tlist_add(&l->node_ref_from, &next_block->ref_from_list);\n\n\t\tbtrfsic_block_link_hashtable_add(l,\n\t\t\t\t\t\t &state->block_link_hashtable);\n\t} else {\n\t\tdid_alloc_block_link = 0;\n\t\tif (0 == limit_nesting) {\n\t\t\tl->ref_cnt++;\n\t\t\tl->parent_generation = parent_generation;\n\t\t\tif (state->print_mask & BTRFSIC_PRINT_MASK_VERBOSE)\n\t\t\t\tbtrfsic_print_add_link(state, l);\n\t\t}\n\t}\n\n\tif (limit_nesting > 0 && did_alloc_block_link) {\n\t\tret = btrfsic_read_block(state, next_block_ctx);\n\t\tif (ret < (int)next_block_ctx->len) {\n\t\t\tprintk(KERN_INFO\n\t\t\t       \"btrfsic: read block @logical %llu failed!\\n\",\n\t\t\t       next_bytenr);\n\t\t\tbtrfsic_release_block_ctx(next_block_ctx);\n\t\t\t*next_blockp = NULL;\n\t\t\treturn -1;\n\t\t}\n\n\t\t*next_blockp = next_block;\n\t} else {\n\t\t*next_blockp = NULL;\n\t}\n\t(*mirror_nump)++;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "btrfsic_read_from_block_data",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/check-integrity.c",
    "lines": "1236-1261",
    "snippet": "static void btrfsic_read_from_block_data(\n\tstruct btrfsic_block_data_ctx *block_ctx,\n\tvoid *dstv, u32 offset, size_t len)\n{\n\tsize_t cur;\n\tsize_t offset_in_page;\n\tchar *kaddr;\n\tchar *dst = (char *)dstv;\n\tsize_t start_offset = block_ctx->start & ((u64)PAGE_CACHE_SIZE - 1);\n\tunsigned long i = (start_offset + offset) >> PAGE_CACHE_SHIFT;\n\n\tWARN_ON(offset + len > block_ctx->len);\n\toffset_in_page = (start_offset + offset) & (PAGE_CACHE_SIZE - 1);\n\n\twhile (len > 0) {\n\t\tcur = min(len, ((size_t)PAGE_CACHE_SIZE - offset_in_page));\n\t\tBUG_ON(i >= DIV_ROUND_UP(block_ctx->len, PAGE_CACHE_SIZE));\n\t\tkaddr = block_ctx->datav[i];\n\t\tmemcpy(dst, kaddr + offset_in_page, cur);\n\n\t\tdst += cur;\n\t\tlen -= cur;\n\t\toffset_in_page = 0;\n\t\ti++;\n\t}\n}",
    "includes": [
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"volumes.h\"",
      "#include \"extent_io.h\"",
      "#include \"transaction.h\"",
      "#include \"hash.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/genhd.h>",
      "#include <linux/mutex.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void btrfsic_read_from_block_data(\n\tstruct btrfsic_block_data_ctx *block_ctx,\n\tvoid *dst, u32 offset, size_t len);",
      "static void btrfsic_release_block_ctx(struct btrfsic_block_data_ctx *block_ctx);",
      "static int btrfsic_read_block(struct btrfsic_state *state,\n\t\t\t      struct btrfsic_block_data_ctx *block_ctx);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "dst",
            "kaddr + offset_in_page",
            "cur"
          ],
          "line": 1254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "i >= DIV_ROUND_UP(block_ctx->len, PAGE_CACHE_SIZE)"
          ],
          "line": 1252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DIV_ROUND_UP",
          "args": [
            "block_ctx->len",
            "PAGE_CACHE_SIZE"
          ],
          "line": 1252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "len",
            "((size_t)PAGE_CACHE_SIZE - offset_in_page)"
          ],
          "line": 1251
        },
        "resolved": true,
        "details": {
          "function_name": "get_dominating_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pnode.c",
          "lines": "55-66",
          "snippet": "int get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"pnode.h\"",
            "#include \"internal.h\"",
            "#include <linux/nsproxy.h>",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/mnt_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnode.h\"\n#include \"internal.h\"\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mnt_namespace.h>\n\nint get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "offset + len > block_ctx->len"
          ],
          "line": 1247
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"extent_io.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n#include <linux/blkdev.h>\n#include <linux/genhd.h>\n#include <linux/mutex.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic void btrfsic_read_from_block_data(\n\tstruct btrfsic_block_data_ctx *block_ctx,\n\tvoid *dst, u32 offset, size_t len);\nstatic void btrfsic_release_block_ctx(struct btrfsic_block_data_ctx *block_ctx);\nstatic int btrfsic_read_block(struct btrfsic_state *state,\n\t\t\t      struct btrfsic_block_data_ctx *block_ctx);\n\nstatic void btrfsic_read_from_block_data(\n\tstruct btrfsic_block_data_ctx *block_ctx,\n\tvoid *dstv, u32 offset, size_t len)\n{\n\tsize_t cur;\n\tsize_t offset_in_page;\n\tchar *kaddr;\n\tchar *dst = (char *)dstv;\n\tsize_t start_offset = block_ctx->start & ((u64)PAGE_CACHE_SIZE - 1);\n\tunsigned long i = (start_offset + offset) >> PAGE_CACHE_SHIFT;\n\n\tWARN_ON(offset + len > block_ctx->len);\n\toffset_in_page = (start_offset + offset) & (PAGE_CACHE_SIZE - 1);\n\n\twhile (len > 0) {\n\t\tcur = min(len, ((size_t)PAGE_CACHE_SIZE - offset_in_page));\n\t\tBUG_ON(i >= DIV_ROUND_UP(block_ctx->len, PAGE_CACHE_SIZE));\n\t\tkaddr = block_ctx->datav[i];\n\t\tmemcpy(dst, kaddr + offset_in_page, cur);\n\n\t\tdst += cur;\n\t\tlen -= cur;\n\t\toffset_in_page = 0;\n\t\ti++;\n\t}\n}"
  },
  {
    "function_name": "btrfsic_process_metablock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/check-integrity.c",
    "lines": "974-1234",
    "snippet": "static int btrfsic_process_metablock(\n\t\tstruct btrfsic_state *state,\n\t\tstruct btrfsic_block *const first_block,\n\t\tstruct btrfsic_block_data_ctx *const first_block_ctx,\n\t\tint first_limit_nesting, int force_iodone_flag)\n{\n\tstruct btrfsic_stack_frame initial_stack_frame = { 0 };\n\tstruct btrfsic_stack_frame *sf;\n\tstruct btrfsic_stack_frame *next_stack;\n\tstruct btrfs_header *const first_hdr =\n\t\t(struct btrfs_header *)first_block_ctx->datav[0];\n\n\tBUG_ON(!first_hdr);\n\tsf = &initial_stack_frame;\n\tsf->error = 0;\n\tsf->i = -1;\n\tsf->limit_nesting = first_limit_nesting;\n\tsf->block = first_block;\n\tsf->block_ctx = first_block_ctx;\n\tsf->next_block = NULL;\n\tsf->hdr = first_hdr;\n\tsf->prev = NULL;\n\ncontinue_with_new_stack_frame:\n\tsf->block->generation = le64_to_cpu(sf->hdr->generation);\n\tif (0 == sf->hdr->level) {\n\t\tstruct btrfs_leaf *const leafhdr =\n\t\t    (struct btrfs_leaf *)sf->hdr;\n\n\t\tif (-1 == sf->i) {\n\t\t\tsf->nr = btrfs_stack_header_nritems(&leafhdr->header);\n\n\t\t\tif (state->print_mask & BTRFSIC_PRINT_MASK_VERBOSE)\n\t\t\t\tprintk(KERN_INFO\n\t\t\t\t       \"leaf %llu items %d generation %llu\"\n\t\t\t\t       \" owner %llu\\n\",\n\t\t\t\t       sf->block_ctx->start, sf->nr,\n\t\t\t\t       btrfs_stack_header_generation(\n\t\t\t\t\t       &leafhdr->header),\n\t\t\t\t       btrfs_stack_header_owner(\n\t\t\t\t\t       &leafhdr->header));\n\t\t}\n\ncontinue_with_current_leaf_stack_frame:\n\t\tif (0 == sf->num_copies || sf->mirror_num > sf->num_copies) {\n\t\t\tsf->i++;\n\t\t\tsf->num_copies = 0;\n\t\t}\n\n\t\tif (sf->i < sf->nr) {\n\t\t\tstruct btrfs_item disk_item;\n\t\t\tu32 disk_item_offset =\n\t\t\t\t(uintptr_t)(leafhdr->items + sf->i) -\n\t\t\t\t(uintptr_t)leafhdr;\n\t\t\tstruct btrfs_disk_key *disk_key;\n\t\t\tu8 type;\n\t\t\tu32 item_offset;\n\t\t\tu32 item_size;\n\n\t\t\tif (disk_item_offset + sizeof(struct btrfs_item) >\n\t\t\t    sf->block_ctx->len) {\nleaf_item_out_of_bounce_error:\n\t\t\t\tprintk(KERN_INFO\n\t\t\t\t       \"btrfsic: leaf item out of bounce at logical %llu, dev %s\\n\",\n\t\t\t\t       sf->block_ctx->start,\n\t\t\t\t       sf->block_ctx->dev->name);\n\t\t\t\tgoto one_stack_frame_backwards;\n\t\t\t}\n\t\t\tbtrfsic_read_from_block_data(sf->block_ctx,\n\t\t\t\t\t\t     &disk_item,\n\t\t\t\t\t\t     disk_item_offset,\n\t\t\t\t\t\t     sizeof(struct btrfs_item));\n\t\t\titem_offset = btrfs_stack_item_offset(&disk_item);\n\t\t\titem_size = btrfs_stack_item_size(&disk_item);\n\t\t\tdisk_key = &disk_item.key;\n\t\t\ttype = btrfs_disk_key_type(disk_key);\n\n\t\t\tif (BTRFS_ROOT_ITEM_KEY == type) {\n\t\t\t\tstruct btrfs_root_item root_item;\n\t\t\t\tu32 root_item_offset;\n\t\t\t\tu64 next_bytenr;\n\n\t\t\t\troot_item_offset = item_offset +\n\t\t\t\t\toffsetof(struct btrfs_leaf, items);\n\t\t\t\tif (root_item_offset + item_size >\n\t\t\t\t    sf->block_ctx->len)\n\t\t\t\t\tgoto leaf_item_out_of_bounce_error;\n\t\t\t\tbtrfsic_read_from_block_data(\n\t\t\t\t\tsf->block_ctx, &root_item,\n\t\t\t\t\troot_item_offset,\n\t\t\t\t\titem_size);\n\t\t\t\tnext_bytenr = btrfs_root_bytenr(&root_item);\n\n\t\t\t\tsf->error =\n\t\t\t\t    btrfsic_create_link_to_next_block(\n\t\t\t\t\t\tstate,\n\t\t\t\t\t\tsf->block,\n\t\t\t\t\t\tsf->block_ctx,\n\t\t\t\t\t\tnext_bytenr,\n\t\t\t\t\t\tsf->limit_nesting,\n\t\t\t\t\t\t&sf->next_block_ctx,\n\t\t\t\t\t\t&sf->next_block,\n\t\t\t\t\t\tforce_iodone_flag,\n\t\t\t\t\t\t&sf->num_copies,\n\t\t\t\t\t\t&sf->mirror_num,\n\t\t\t\t\t\tdisk_key,\n\t\t\t\t\t\tbtrfs_root_generation(\n\t\t\t\t\t\t&root_item));\n\t\t\t\tif (sf->error)\n\t\t\t\t\tgoto one_stack_frame_backwards;\n\n\t\t\t\tif (NULL != sf->next_block) {\n\t\t\t\t\tstruct btrfs_header *const next_hdr =\n\t\t\t\t\t    (struct btrfs_header *)\n\t\t\t\t\t    sf->next_block_ctx.datav[0];\n\n\t\t\t\t\tnext_stack =\n\t\t\t\t\t    btrfsic_stack_frame_alloc();\n\t\t\t\t\tif (NULL == next_stack) {\n\t\t\t\t\t\tsf->error = -1;\n\t\t\t\t\t\tbtrfsic_release_block_ctx(\n\t\t\t\t\t\t\t\t&sf->\n\t\t\t\t\t\t\t\tnext_block_ctx);\n\t\t\t\t\t\tgoto one_stack_frame_backwards;\n\t\t\t\t\t}\n\n\t\t\t\t\tnext_stack->i = -1;\n\t\t\t\t\tnext_stack->block = sf->next_block;\n\t\t\t\t\tnext_stack->block_ctx =\n\t\t\t\t\t    &sf->next_block_ctx;\n\t\t\t\t\tnext_stack->next_block = NULL;\n\t\t\t\t\tnext_stack->hdr = next_hdr;\n\t\t\t\t\tnext_stack->limit_nesting =\n\t\t\t\t\t    sf->limit_nesting - 1;\n\t\t\t\t\tnext_stack->prev = sf;\n\t\t\t\t\tsf = next_stack;\n\t\t\t\t\tgoto continue_with_new_stack_frame;\n\t\t\t\t}\n\t\t\t} else if (BTRFS_EXTENT_DATA_KEY == type &&\n\t\t\t\t   state->include_extent_data) {\n\t\t\t\tsf->error = btrfsic_handle_extent_data(\n\t\t\t\t\t\tstate,\n\t\t\t\t\t\tsf->block,\n\t\t\t\t\t\tsf->block_ctx,\n\t\t\t\t\t\titem_offset,\n\t\t\t\t\t\tforce_iodone_flag);\n\t\t\t\tif (sf->error)\n\t\t\t\t\tgoto one_stack_frame_backwards;\n\t\t\t}\n\n\t\t\tgoto continue_with_current_leaf_stack_frame;\n\t\t}\n\t} else {\n\t\tstruct btrfs_node *const nodehdr = (struct btrfs_node *)sf->hdr;\n\n\t\tif (-1 == sf->i) {\n\t\t\tsf->nr = btrfs_stack_header_nritems(&nodehdr->header);\n\n\t\t\tif (state->print_mask & BTRFSIC_PRINT_MASK_VERBOSE)\n\t\t\t\tprintk(KERN_INFO \"node %llu level %d items %d\"\n\t\t\t\t       \" generation %llu owner %llu\\n\",\n\t\t\t\t       sf->block_ctx->start,\n\t\t\t\t       nodehdr->header.level, sf->nr,\n\t\t\t\t       btrfs_stack_header_generation(\n\t\t\t\t       &nodehdr->header),\n\t\t\t\t       btrfs_stack_header_owner(\n\t\t\t\t       &nodehdr->header));\n\t\t}\n\ncontinue_with_current_node_stack_frame:\n\t\tif (0 == sf->num_copies || sf->mirror_num > sf->num_copies) {\n\t\t\tsf->i++;\n\t\t\tsf->num_copies = 0;\n\t\t}\n\n\t\tif (sf->i < sf->nr) {\n\t\t\tstruct btrfs_key_ptr key_ptr;\n\t\t\tu32 key_ptr_offset;\n\t\t\tu64 next_bytenr;\n\n\t\t\tkey_ptr_offset = (uintptr_t)(nodehdr->ptrs + sf->i) -\n\t\t\t\t\t  (uintptr_t)nodehdr;\n\t\t\tif (key_ptr_offset + sizeof(struct btrfs_key_ptr) >\n\t\t\t    sf->block_ctx->len) {\n\t\t\t\tprintk(KERN_INFO\n\t\t\t\t       \"btrfsic: node item out of bounce at logical %llu, dev %s\\n\",\n\t\t\t\t       sf->block_ctx->start,\n\t\t\t\t       sf->block_ctx->dev->name);\n\t\t\t\tgoto one_stack_frame_backwards;\n\t\t\t}\n\t\t\tbtrfsic_read_from_block_data(\n\t\t\t\tsf->block_ctx, &key_ptr, key_ptr_offset,\n\t\t\t\tsizeof(struct btrfs_key_ptr));\n\t\t\tnext_bytenr = btrfs_stack_key_blockptr(&key_ptr);\n\n\t\t\tsf->error = btrfsic_create_link_to_next_block(\n\t\t\t\t\tstate,\n\t\t\t\t\tsf->block,\n\t\t\t\t\tsf->block_ctx,\n\t\t\t\t\tnext_bytenr,\n\t\t\t\t\tsf->limit_nesting,\n\t\t\t\t\t&sf->next_block_ctx,\n\t\t\t\t\t&sf->next_block,\n\t\t\t\t\tforce_iodone_flag,\n\t\t\t\t\t&sf->num_copies,\n\t\t\t\t\t&sf->mirror_num,\n\t\t\t\t\t&key_ptr.key,\n\t\t\t\t\tbtrfs_stack_key_generation(&key_ptr));\n\t\t\tif (sf->error)\n\t\t\t\tgoto one_stack_frame_backwards;\n\n\t\t\tif (NULL != sf->next_block) {\n\t\t\t\tstruct btrfs_header *const next_hdr =\n\t\t\t\t    (struct btrfs_header *)\n\t\t\t\t    sf->next_block_ctx.datav[0];\n\n\t\t\t\tnext_stack = btrfsic_stack_frame_alloc();\n\t\t\t\tif (NULL == next_stack) {\n\t\t\t\t\tsf->error = -1;\n\t\t\t\t\tgoto one_stack_frame_backwards;\n\t\t\t\t}\n\n\t\t\t\tnext_stack->i = -1;\n\t\t\t\tnext_stack->block = sf->next_block;\n\t\t\t\tnext_stack->block_ctx = &sf->next_block_ctx;\n\t\t\t\tnext_stack->next_block = NULL;\n\t\t\t\tnext_stack->hdr = next_hdr;\n\t\t\t\tnext_stack->limit_nesting =\n\t\t\t\t    sf->limit_nesting - 1;\n\t\t\t\tnext_stack->prev = sf;\n\t\t\t\tsf = next_stack;\n\t\t\t\tgoto continue_with_new_stack_frame;\n\t\t\t}\n\n\t\t\tgoto continue_with_current_node_stack_frame;\n\t\t}\n\t}\n\none_stack_frame_backwards:\n\tif (NULL != sf->prev) {\n\t\tstruct btrfsic_stack_frame *const prev = sf->prev;\n\n\t\t/* the one for the initial block is freed in the caller */\n\t\tbtrfsic_release_block_ctx(sf->block_ctx);\n\n\t\tif (sf->error) {\n\t\t\tprev->error = sf->error;\n\t\t\tbtrfsic_stack_frame_free(sf);\n\t\t\tsf = prev;\n\t\t\tgoto one_stack_frame_backwards;\n\t\t}\n\n\t\tbtrfsic_stack_frame_free(sf);\n\t\tsf = prev;\n\t\tgoto continue_with_new_stack_frame;\n\t} else {\n\t\tBUG_ON(&initial_stack_frame != sf);\n\t}\n\n\treturn sf->error;\n}",
    "includes": [
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"volumes.h\"",
      "#include \"extent_io.h\"",
      "#include \"transaction.h\"",
      "#include \"hash.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/genhd.h>",
      "#include <linux/mutex.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [
      "#define BTRFSIC_PRINT_MASK_VERBOSE\t\t\t\t0x00000040"
    ],
    "globals_used": [
      "static void btrfsic_block_link_init(struct btrfsic_block_link *n);",
      "static void btrfsic_block_link_free(struct btrfsic_block_link *n);",
      "static struct btrfsic_stack_frame *btrfsic_stack_frame_alloc(void);",
      "static void btrfsic_stack_frame_free(struct btrfsic_stack_frame *sf);",
      "static int btrfsic_process_metablock(struct btrfsic_state *state,\n\t\t\t\t     struct btrfsic_block *block,\n\t\t\t\t     struct btrfsic_block_data_ctx *block_ctx,\n\t\t\t\t     int limit_nesting, int force_iodone_flag);",
      "static void btrfsic_read_from_block_data(\n\tstruct btrfsic_block_data_ctx *block_ctx,\n\tvoid *dst, u32 offset, size_t len);",
      "static int btrfsic_handle_extent_data(struct btrfsic_state *state,\n\t\t\t\t      struct btrfsic_block *block,\n\t\t\t\t      struct btrfsic_block_data_ctx *block_ctx,\n\t\t\t\t      u32 item_offset, int force_iodone_flag);",
      "static int btrfsic_map_block(struct btrfsic_state *state, u64 bytenr, u32 len,\n\t\t\t     struct btrfsic_block_data_ctx *block_ctx_out,\n\t\t\t     int mirror_num);",
      "static void btrfsic_release_block_ctx(struct btrfsic_block_data_ctx *block_ctx);",
      "static int btrfsic_read_block(struct btrfsic_state *state,\n\t\t\t      struct btrfsic_block_data_ctx *block_ctx);",
      "static void btrfsic_dump_database(struct btrfsic_state *state);",
      "static char btrfsic_get_block_type(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block *block);",
      "static void btrfsic_dump_tree(const struct btrfsic_state *state);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "&initial_stack_frame != sf"
          ],
          "line": 1230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfsic_stack_frame_free",
          "args": [
            "sf"
          ],
          "line": 1226
        },
        "resolved": true,
        "details": {
          "function_name": "btrfsic_stack_frame_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/check-integrity.c",
          "lines": "967-972",
          "snippet": "static void btrfsic_stack_frame_free(struct btrfsic_stack_frame *sf)\n{\n\tBUG_ON(!(NULL == sf ||\n\t\t BTRFSIC_BLOCK_STACK_FRAME_MAGIC_NUMBER == sf->magic));\n\tkfree(sf);\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"extent_io.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/genhd.h>",
            "#include <linux/mutex.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define BTRFSIC_BLOCK_STACK_FRAME_MAGIC_NUMBER 20111300"
          ],
          "globals_used": [
            "static void btrfsic_stack_frame_free(struct btrfsic_stack_frame *sf);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"extent_io.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n#include <linux/blkdev.h>\n#include <linux/genhd.h>\n#include <linux/mutex.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\n#define BTRFSIC_BLOCK_STACK_FRAME_MAGIC_NUMBER 20111300\n\nstatic void btrfsic_stack_frame_free(struct btrfsic_stack_frame *sf);\n\nstatic void btrfsic_stack_frame_free(struct btrfsic_stack_frame *sf)\n{\n\tBUG_ON(!(NULL == sf ||\n\t\t BTRFSIC_BLOCK_STACK_FRAME_MAGIC_NUMBER == sf->magic));\n\tkfree(sf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfsic_release_block_ctx",
          "args": [
            "sf->block_ctx"
          ],
          "line": 1217
        },
        "resolved": true,
        "details": {
          "function_name": "btrfsic_release_block_ctx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/check-integrity.c",
          "lines": "1611-1637",
          "snippet": "static void btrfsic_release_block_ctx(struct btrfsic_block_data_ctx *block_ctx)\n{\n\tif (block_ctx->mem_to_free) {\n\t\tunsigned int num_pages;\n\n\t\tBUG_ON(!block_ctx->datav);\n\t\tBUG_ON(!block_ctx->pagev);\n\t\tnum_pages = (block_ctx->len + (u64)PAGE_CACHE_SIZE - 1) >>\n\t\t\t    PAGE_CACHE_SHIFT;\n\t\twhile (num_pages > 0) {\n\t\t\tnum_pages--;\n\t\t\tif (block_ctx->datav[num_pages]) {\n\t\t\t\tkunmap(block_ctx->pagev[num_pages]);\n\t\t\t\tblock_ctx->datav[num_pages] = NULL;\n\t\t\t}\n\t\t\tif (block_ctx->pagev[num_pages]) {\n\t\t\t\t__free_page(block_ctx->pagev[num_pages]);\n\t\t\t\tblock_ctx->pagev[num_pages] = NULL;\n\t\t\t}\n\t\t}\n\n\t\tkfree(block_ctx->mem_to_free);\n\t\tblock_ctx->mem_to_free = NULL;\n\t\tblock_ctx->pagev = NULL;\n\t\tblock_ctx->datav = NULL;\n\t}\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"extent_io.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/genhd.h>",
            "#include <linux/mutex.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void btrfsic_read_from_block_data(\n\tstruct btrfsic_block_data_ctx *block_ctx,\n\tvoid *dst, u32 offset, size_t len);",
            "static void btrfsic_release_block_ctx(struct btrfsic_block_data_ctx *block_ctx);",
            "static int btrfsic_read_block(struct btrfsic_state *state,\n\t\t\t      struct btrfsic_block_data_ctx *block_ctx);",
            "static int btrfsic_test_for_metadata(struct btrfsic_state *state,\n\t\t\t\t     char **datav, unsigned int num_pages);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"extent_io.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n#include <linux/blkdev.h>\n#include <linux/genhd.h>\n#include <linux/mutex.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic void btrfsic_read_from_block_data(\n\tstruct btrfsic_block_data_ctx *block_ctx,\n\tvoid *dst, u32 offset, size_t len);\nstatic void btrfsic_release_block_ctx(struct btrfsic_block_data_ctx *block_ctx);\nstatic int btrfsic_read_block(struct btrfsic_state *state,\n\t\t\t      struct btrfsic_block_data_ctx *block_ctx);\nstatic int btrfsic_test_for_metadata(struct btrfsic_state *state,\n\t\t\t\t     char **datav, unsigned int num_pages);\n\nstatic void btrfsic_release_block_ctx(struct btrfsic_block_data_ctx *block_ctx)\n{\n\tif (block_ctx->mem_to_free) {\n\t\tunsigned int num_pages;\n\n\t\tBUG_ON(!block_ctx->datav);\n\t\tBUG_ON(!block_ctx->pagev);\n\t\tnum_pages = (block_ctx->len + (u64)PAGE_CACHE_SIZE - 1) >>\n\t\t\t    PAGE_CACHE_SHIFT;\n\t\twhile (num_pages > 0) {\n\t\t\tnum_pages--;\n\t\t\tif (block_ctx->datav[num_pages]) {\n\t\t\t\tkunmap(block_ctx->pagev[num_pages]);\n\t\t\t\tblock_ctx->datav[num_pages] = NULL;\n\t\t\t}\n\t\t\tif (block_ctx->pagev[num_pages]) {\n\t\t\t\t__free_page(block_ctx->pagev[num_pages]);\n\t\t\t\tblock_ctx->pagev[num_pages] = NULL;\n\t\t\t}\n\t\t}\n\n\t\tkfree(block_ctx->mem_to_free);\n\t\tblock_ctx->mem_to_free = NULL;\n\t\tblock_ctx->pagev = NULL;\n\t\tblock_ctx->datav = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfsic_stack_frame_alloc",
          "args": [],
          "line": 1190
        },
        "resolved": true,
        "details": {
          "function_name": "btrfsic_stack_frame_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/check-integrity.c",
          "lines": "955-965",
          "snippet": "static struct btrfsic_stack_frame *btrfsic_stack_frame_alloc(void)\n{\n\tstruct btrfsic_stack_frame *sf;\n\n\tsf = kzalloc(sizeof(*sf), GFP_NOFS);\n\tif (NULL == sf)\n\t\tprintk(KERN_INFO \"btrfsic: alloc memory failed!\\n\");\n\telse\n\t\tsf->magic = BTRFSIC_BLOCK_STACK_FRAME_MAGIC_NUMBER;\n\treturn sf;\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"extent_io.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/genhd.h>",
            "#include <linux/mutex.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define BTRFSIC_BLOCK_STACK_FRAME_MAGIC_NUMBER 20111300"
          ],
          "globals_used": [
            "static void btrfsic_block_link_init(struct btrfsic_block_link *n);",
            "static void btrfsic_block_link_free(struct btrfsic_block_link *n);",
            "static struct btrfsic_stack_frame *btrfsic_stack_frame_alloc(void);",
            "static void btrfsic_stack_frame_free(struct btrfsic_stack_frame *sf);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"extent_io.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n#include <linux/blkdev.h>\n#include <linux/genhd.h>\n#include <linux/mutex.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\n#define BTRFSIC_BLOCK_STACK_FRAME_MAGIC_NUMBER 20111300\n\nstatic void btrfsic_block_link_init(struct btrfsic_block_link *n);\nstatic void btrfsic_block_link_free(struct btrfsic_block_link *n);\nstatic struct btrfsic_stack_frame *btrfsic_stack_frame_alloc(void);\nstatic void btrfsic_stack_frame_free(struct btrfsic_stack_frame *sf);\n\nstatic struct btrfsic_stack_frame *btrfsic_stack_frame_alloc(void)\n{\n\tstruct btrfsic_stack_frame *sf;\n\n\tsf = kzalloc(sizeof(*sf), GFP_NOFS);\n\tif (NULL == sf)\n\t\tprintk(KERN_INFO \"btrfsic: alloc memory failed!\\n\");\n\telse\n\t\tsf->magic = BTRFSIC_BLOCK_STACK_FRAME_MAGIC_NUMBER;\n\treturn sf;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfsic_create_link_to_next_block",
          "args": [
            "state",
            "sf->block",
            "sf->block_ctx",
            "next_bytenr",
            "sf->limit_nesting",
            "&sf->next_block_ctx",
            "&sf->next_block",
            "force_iodone_flag",
            "&sf->num_copies",
            "&sf->mirror_num",
            "&key_ptr.key",
            "btrfs_stack_key_generation(&key_ptr)"
          ],
          "line": 1169
        },
        "resolved": true,
        "details": {
          "function_name": "btrfsic_create_link_to_next_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/check-integrity.c",
          "lines": "1263-1409",
          "snippet": "static int btrfsic_create_link_to_next_block(\n\t\tstruct btrfsic_state *state,\n\t\tstruct btrfsic_block *block,\n\t\tstruct btrfsic_block_data_ctx *block_ctx,\n\t\tu64 next_bytenr,\n\t\tint limit_nesting,\n\t\tstruct btrfsic_block_data_ctx *next_block_ctx,\n\t\tstruct btrfsic_block **next_blockp,\n\t\tint force_iodone_flag,\n\t\tint *num_copiesp, int *mirror_nump,\n\t\tstruct btrfs_disk_key *disk_key,\n\t\tu64 parent_generation)\n{\n\tstruct btrfsic_block *next_block = NULL;\n\tint ret;\n\tstruct btrfsic_block_link *l;\n\tint did_alloc_block_link;\n\tint block_was_created;\n\n\t*next_blockp = NULL;\n\tif (0 == *num_copiesp) {\n\t\t*num_copiesp =\n\t\t    btrfs_num_copies(state->root->fs_info,\n\t\t\t\t     next_bytenr, state->metablock_size);\n\t\tif (state->print_mask & BTRFSIC_PRINT_MASK_NUM_COPIES)\n\t\t\tprintk(KERN_INFO \"num_copies(log_bytenr=%llu) = %d\\n\",\n\t\t\t       next_bytenr, *num_copiesp);\n\t\t*mirror_nump = 1;\n\t}\n\n\tif (*mirror_nump > *num_copiesp)\n\t\treturn 0;\n\n\tif (state->print_mask & BTRFSIC_PRINT_MASK_VERBOSE)\n\t\tprintk(KERN_INFO\n\t\t       \"btrfsic_create_link_to_next_block(mirror_num=%d)\\n\",\n\t\t       *mirror_nump);\n\tret = btrfsic_map_block(state, next_bytenr,\n\t\t\t\tstate->metablock_size,\n\t\t\t\tnext_block_ctx, *mirror_nump);\n\tif (ret) {\n\t\tprintk(KERN_INFO\n\t\t       \"btrfsic: btrfsic_map_block(@%llu, mirror=%d) failed!\\n\",\n\t\t       next_bytenr, *mirror_nump);\n\t\tbtrfsic_release_block_ctx(next_block_ctx);\n\t\t*next_blockp = NULL;\n\t\treturn -1;\n\t}\n\n\tnext_block = btrfsic_block_lookup_or_add(state,\n\t\t\t\t\t\t next_block_ctx, \"referenced \",\n\t\t\t\t\t\t 1, force_iodone_flag,\n\t\t\t\t\t\t !force_iodone_flag,\n\t\t\t\t\t\t *mirror_nump,\n\t\t\t\t\t\t &block_was_created);\n\tif (NULL == next_block) {\n\t\tbtrfsic_release_block_ctx(next_block_ctx);\n\t\t*next_blockp = NULL;\n\t\treturn -1;\n\t}\n\tif (block_was_created) {\n\t\tl = NULL;\n\t\tnext_block->generation = BTRFSIC_GENERATION_UNKNOWN;\n\t} else {\n\t\tif (state->print_mask & BTRFSIC_PRINT_MASK_VERBOSE) {\n\t\t\tif (next_block->logical_bytenr != next_bytenr &&\n\t\t\t    !(!next_block->is_metadata &&\n\t\t\t      0 == next_block->logical_bytenr))\n\t\t\t\tprintk(KERN_INFO\n\t\t\t\t       \"Referenced block @%llu (%s/%llu/%d) found in hash table, %c, bytenr mismatch (!= stored %llu).\\n\",\n\t\t\t\t       next_bytenr, next_block_ctx->dev->name,\n\t\t\t\t       next_block_ctx->dev_bytenr, *mirror_nump,\n\t\t\t\t       btrfsic_get_block_type(state,\n\t\t\t\t\t\t\t      next_block),\n\t\t\t\t       next_block->logical_bytenr);\n\t\t\telse\n\t\t\t\tprintk(KERN_INFO\n\t\t\t\t       \"Referenced block @%llu (%s/%llu/%d) found in hash table, %c.\\n\",\n\t\t\t\t       next_bytenr, next_block_ctx->dev->name,\n\t\t\t\t       next_block_ctx->dev_bytenr, *mirror_nump,\n\t\t\t\t       btrfsic_get_block_type(state,\n\t\t\t\t\t\t\t      next_block));\n\t\t}\n\t\tnext_block->logical_bytenr = next_bytenr;\n\n\t\tnext_block->mirror_num = *mirror_nump;\n\t\tl = btrfsic_block_link_hashtable_lookup(\n\t\t\t\tnext_block_ctx->dev->bdev,\n\t\t\t\tnext_block_ctx->dev_bytenr,\n\t\t\t\tblock_ctx->dev->bdev,\n\t\t\t\tblock_ctx->dev_bytenr,\n\t\t\t\t&state->block_link_hashtable);\n\t}\n\n\tnext_block->disk_key = *disk_key;\n\tif (NULL == l) {\n\t\tl = btrfsic_block_link_alloc();\n\t\tif (NULL == l) {\n\t\t\tprintk(KERN_INFO \"btrfsic: error, kmalloc failed!\\n\");\n\t\t\tbtrfsic_release_block_ctx(next_block_ctx);\n\t\t\t*next_blockp = NULL;\n\t\t\treturn -1;\n\t\t}\n\n\t\tdid_alloc_block_link = 1;\n\t\tl->block_ref_to = next_block;\n\t\tl->block_ref_from = block;\n\t\tl->ref_cnt = 1;\n\t\tl->parent_generation = parent_generation;\n\n\t\tif (state->print_mask & BTRFSIC_PRINT_MASK_VERBOSE)\n\t\t\tbtrfsic_print_add_link(state, l);\n\n\t\tlist_add(&l->node_ref_to, &block->ref_to_list);\n\t\tlist_add(&l->node_ref_from, &next_block->ref_from_list);\n\n\t\tbtrfsic_block_link_hashtable_add(l,\n\t\t\t\t\t\t &state->block_link_hashtable);\n\t} else {\n\t\tdid_alloc_block_link = 0;\n\t\tif (0 == limit_nesting) {\n\t\t\tl->ref_cnt++;\n\t\t\tl->parent_generation = parent_generation;\n\t\t\tif (state->print_mask & BTRFSIC_PRINT_MASK_VERBOSE)\n\t\t\t\tbtrfsic_print_add_link(state, l);\n\t\t}\n\t}\n\n\tif (limit_nesting > 0 && did_alloc_block_link) {\n\t\tret = btrfsic_read_block(state, next_block_ctx);\n\t\tif (ret < (int)next_block_ctx->len) {\n\t\t\tprintk(KERN_INFO\n\t\t\t       \"btrfsic: read block @logical %llu failed!\\n\",\n\t\t\t       next_bytenr);\n\t\t\tbtrfsic_release_block_ctx(next_block_ctx);\n\t\t\t*next_blockp = NULL;\n\t\t\treturn -1;\n\t\t}\n\n\t\t*next_blockp = next_block;\n\t} else {\n\t\t*next_blockp = NULL;\n\t}\n\t(*mirror_nump)++;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"extent_io.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/genhd.h>",
            "#include <linux/mutex.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define BTRFSIC_PRINT_MASK_NUM_COPIES\t\t\t\t0x00000800",
            "#define BTRFSIC_PRINT_MASK_VERBOSE\t\t\t\t0x00000040",
            "#define BTRFSIC_GENERATION_UNKNOWN ((u64)-1)"
          ],
          "globals_used": [
            "static void btrfsic_block_link_init(struct btrfsic_block_link *n);",
            "static struct btrfsic_block_link *btrfsic_block_link_alloc(void);",
            "static void btrfsic_block_link_free(struct btrfsic_block_link *n);",
            "static void btrfsic_block_link_hashtable_remove(struct btrfsic_block_link *l);",
            "static int btrfsic_process_metablock(struct btrfsic_state *state,\n\t\t\t\t     struct btrfsic_block *block,\n\t\t\t\t     struct btrfsic_block_data_ctx *block_ctx,\n\t\t\t\t     int limit_nesting, int force_iodone_flag);",
            "static void btrfsic_read_from_block_data(\n\tstruct btrfsic_block_data_ctx *block_ctx,\n\tvoid *dst, u32 offset, size_t len);",
            "static int btrfsic_create_link_to_next_block(\n\t\tstruct btrfsic_state *state,\n\t\tstruct btrfsic_block *block,\n\t\tstruct btrfsic_block_data_ctx\n\t\t*block_ctx, u64 next_bytenr,\n\t\tint limit_nesting,\n\t\tstruct btrfsic_block_data_ctx *next_block_ctx,\n\t\tstruct btrfsic_block **next_blockp,\n\t\tint force_iodone_flag,\n\t\tint *num_copiesp, int *mirror_nump,\n\t\tstruct btrfs_disk_key *disk_key,\n\t\tu64 parent_generation);",
            "static int btrfsic_handle_extent_data(struct btrfsic_state *state,\n\t\t\t\t      struct btrfsic_block *block,\n\t\t\t\t      struct btrfsic_block_data_ctx *block_ctx,\n\t\t\t\t      u32 item_offset, int force_iodone_flag);",
            "static int btrfsic_map_block(struct btrfsic_state *state, u64 bytenr, u32 len,\n\t\t\t     struct btrfsic_block_data_ctx *block_ctx_out,\n\t\t\t     int mirror_num);",
            "static void btrfsic_release_block_ctx(struct btrfsic_block_data_ctx *block_ctx);",
            "static int btrfsic_read_block(struct btrfsic_state *state,\n\t\t\t      struct btrfsic_block_data_ctx *block_ctx);",
            "static void btrfsic_dump_database(struct btrfsic_state *state);",
            "static void btrfsic_print_add_link(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block_link *l);",
            "static void btrfsic_print_rem_link(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block_link *l);",
            "static char btrfsic_get_block_type(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block *block);",
            "static void btrfsic_dump_tree(const struct btrfsic_state *state);",
            "static struct btrfsic_block_link *btrfsic_block_link_lookup_or_add(\n\t\tstruct btrfsic_state *state,\n\t\tstruct btrfsic_block_data_ctx *next_block_ctx,\n\t\tstruct btrfsic_block *next_block,\n\t\tstruct btrfsic_block *from_block,\n\t\tu64 parent_generation);",
            "static struct btrfsic_dev_state *btrfsic_dev_state_lookup(\n\t\tstruct block_device *bdev);",
            "static void btrfsic_cmp_log_and_dev_bytenr(struct btrfsic_state *state,\n\t\t\t\t\t   u64 bytenr,\n\t\t\t\t\t   struct btrfsic_dev_state *dev_state,\n\t\t\t\t\t   u64 dev_bytenr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"extent_io.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n#include <linux/blkdev.h>\n#include <linux/genhd.h>\n#include <linux/mutex.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\n#define BTRFSIC_PRINT_MASK_NUM_COPIES\t\t\t\t0x00000800\n#define BTRFSIC_PRINT_MASK_VERBOSE\t\t\t\t0x00000040\n#define BTRFSIC_GENERATION_UNKNOWN ((u64)-1)\n\nstatic void btrfsic_block_link_init(struct btrfsic_block_link *n);\nstatic struct btrfsic_block_link *btrfsic_block_link_alloc(void);\nstatic void btrfsic_block_link_free(struct btrfsic_block_link *n);\nstatic void btrfsic_block_link_hashtable_remove(struct btrfsic_block_link *l);\nstatic int btrfsic_process_metablock(struct btrfsic_state *state,\n\t\t\t\t     struct btrfsic_block *block,\n\t\t\t\t     struct btrfsic_block_data_ctx *block_ctx,\n\t\t\t\t     int limit_nesting, int force_iodone_flag);\nstatic void btrfsic_read_from_block_data(\n\tstruct btrfsic_block_data_ctx *block_ctx,\n\tvoid *dst, u32 offset, size_t len);\nstatic int btrfsic_create_link_to_next_block(\n\t\tstruct btrfsic_state *state,\n\t\tstruct btrfsic_block *block,\n\t\tstruct btrfsic_block_data_ctx\n\t\t*block_ctx, u64 next_bytenr,\n\t\tint limit_nesting,\n\t\tstruct btrfsic_block_data_ctx *next_block_ctx,\n\t\tstruct btrfsic_block **next_blockp,\n\t\tint force_iodone_flag,\n\t\tint *num_copiesp, int *mirror_nump,\n\t\tstruct btrfs_disk_key *disk_key,\n\t\tu64 parent_generation);\nstatic int btrfsic_handle_extent_data(struct btrfsic_state *state,\n\t\t\t\t      struct btrfsic_block *block,\n\t\t\t\t      struct btrfsic_block_data_ctx *block_ctx,\n\t\t\t\t      u32 item_offset, int force_iodone_flag);\nstatic int btrfsic_map_block(struct btrfsic_state *state, u64 bytenr, u32 len,\n\t\t\t     struct btrfsic_block_data_ctx *block_ctx_out,\n\t\t\t     int mirror_num);\nstatic void btrfsic_release_block_ctx(struct btrfsic_block_data_ctx *block_ctx);\nstatic int btrfsic_read_block(struct btrfsic_state *state,\n\t\t\t      struct btrfsic_block_data_ctx *block_ctx);\nstatic void btrfsic_dump_database(struct btrfsic_state *state);\nstatic void btrfsic_print_add_link(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block_link *l);\nstatic void btrfsic_print_rem_link(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block_link *l);\nstatic char btrfsic_get_block_type(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block *block);\nstatic void btrfsic_dump_tree(const struct btrfsic_state *state);\nstatic struct btrfsic_block_link *btrfsic_block_link_lookup_or_add(\n\t\tstruct btrfsic_state *state,\n\t\tstruct btrfsic_block_data_ctx *next_block_ctx,\n\t\tstruct btrfsic_block *next_block,\n\t\tstruct btrfsic_block *from_block,\n\t\tu64 parent_generation);\nstatic struct btrfsic_dev_state *btrfsic_dev_state_lookup(\n\t\tstruct block_device *bdev);\nstatic void btrfsic_cmp_log_and_dev_bytenr(struct btrfsic_state *state,\n\t\t\t\t\t   u64 bytenr,\n\t\t\t\t\t   struct btrfsic_dev_state *dev_state,\n\t\t\t\t\t   u64 dev_bytenr);\n\nstatic int btrfsic_create_link_to_next_block(\n\t\tstruct btrfsic_state *state,\n\t\tstruct btrfsic_block *block,\n\t\tstruct btrfsic_block_data_ctx *block_ctx,\n\t\tu64 next_bytenr,\n\t\tint limit_nesting,\n\t\tstruct btrfsic_block_data_ctx *next_block_ctx,\n\t\tstruct btrfsic_block **next_blockp,\n\t\tint force_iodone_flag,\n\t\tint *num_copiesp, int *mirror_nump,\n\t\tstruct btrfs_disk_key *disk_key,\n\t\tu64 parent_generation)\n{\n\tstruct btrfsic_block *next_block = NULL;\n\tint ret;\n\tstruct btrfsic_block_link *l;\n\tint did_alloc_block_link;\n\tint block_was_created;\n\n\t*next_blockp = NULL;\n\tif (0 == *num_copiesp) {\n\t\t*num_copiesp =\n\t\t    btrfs_num_copies(state->root->fs_info,\n\t\t\t\t     next_bytenr, state->metablock_size);\n\t\tif (state->print_mask & BTRFSIC_PRINT_MASK_NUM_COPIES)\n\t\t\tprintk(KERN_INFO \"num_copies(log_bytenr=%llu) = %d\\n\",\n\t\t\t       next_bytenr, *num_copiesp);\n\t\t*mirror_nump = 1;\n\t}\n\n\tif (*mirror_nump > *num_copiesp)\n\t\treturn 0;\n\n\tif (state->print_mask & BTRFSIC_PRINT_MASK_VERBOSE)\n\t\tprintk(KERN_INFO\n\t\t       \"btrfsic_create_link_to_next_block(mirror_num=%d)\\n\",\n\t\t       *mirror_nump);\n\tret = btrfsic_map_block(state, next_bytenr,\n\t\t\t\tstate->metablock_size,\n\t\t\t\tnext_block_ctx, *mirror_nump);\n\tif (ret) {\n\t\tprintk(KERN_INFO\n\t\t       \"btrfsic: btrfsic_map_block(@%llu, mirror=%d) failed!\\n\",\n\t\t       next_bytenr, *mirror_nump);\n\t\tbtrfsic_release_block_ctx(next_block_ctx);\n\t\t*next_blockp = NULL;\n\t\treturn -1;\n\t}\n\n\tnext_block = btrfsic_block_lookup_or_add(state,\n\t\t\t\t\t\t next_block_ctx, \"referenced \",\n\t\t\t\t\t\t 1, force_iodone_flag,\n\t\t\t\t\t\t !force_iodone_flag,\n\t\t\t\t\t\t *mirror_nump,\n\t\t\t\t\t\t &block_was_created);\n\tif (NULL == next_block) {\n\t\tbtrfsic_release_block_ctx(next_block_ctx);\n\t\t*next_blockp = NULL;\n\t\treturn -1;\n\t}\n\tif (block_was_created) {\n\t\tl = NULL;\n\t\tnext_block->generation = BTRFSIC_GENERATION_UNKNOWN;\n\t} else {\n\t\tif (state->print_mask & BTRFSIC_PRINT_MASK_VERBOSE) {\n\t\t\tif (next_block->logical_bytenr != next_bytenr &&\n\t\t\t    !(!next_block->is_metadata &&\n\t\t\t      0 == next_block->logical_bytenr))\n\t\t\t\tprintk(KERN_INFO\n\t\t\t\t       \"Referenced block @%llu (%s/%llu/%d) found in hash table, %c, bytenr mismatch (!= stored %llu).\\n\",\n\t\t\t\t       next_bytenr, next_block_ctx->dev->name,\n\t\t\t\t       next_block_ctx->dev_bytenr, *mirror_nump,\n\t\t\t\t       btrfsic_get_block_type(state,\n\t\t\t\t\t\t\t      next_block),\n\t\t\t\t       next_block->logical_bytenr);\n\t\t\telse\n\t\t\t\tprintk(KERN_INFO\n\t\t\t\t       \"Referenced block @%llu (%s/%llu/%d) found in hash table, %c.\\n\",\n\t\t\t\t       next_bytenr, next_block_ctx->dev->name,\n\t\t\t\t       next_block_ctx->dev_bytenr, *mirror_nump,\n\t\t\t\t       btrfsic_get_block_type(state,\n\t\t\t\t\t\t\t      next_block));\n\t\t}\n\t\tnext_block->logical_bytenr = next_bytenr;\n\n\t\tnext_block->mirror_num = *mirror_nump;\n\t\tl = btrfsic_block_link_hashtable_lookup(\n\t\t\t\tnext_block_ctx->dev->bdev,\n\t\t\t\tnext_block_ctx->dev_bytenr,\n\t\t\t\tblock_ctx->dev->bdev,\n\t\t\t\tblock_ctx->dev_bytenr,\n\t\t\t\t&state->block_link_hashtable);\n\t}\n\n\tnext_block->disk_key = *disk_key;\n\tif (NULL == l) {\n\t\tl = btrfsic_block_link_alloc();\n\t\tif (NULL == l) {\n\t\t\tprintk(KERN_INFO \"btrfsic: error, kmalloc failed!\\n\");\n\t\t\tbtrfsic_release_block_ctx(next_block_ctx);\n\t\t\t*next_blockp = NULL;\n\t\t\treturn -1;\n\t\t}\n\n\t\tdid_alloc_block_link = 1;\n\t\tl->block_ref_to = next_block;\n\t\tl->block_ref_from = block;\n\t\tl->ref_cnt = 1;\n\t\tl->parent_generation = parent_generation;\n\n\t\tif (state->print_mask & BTRFSIC_PRINT_MASK_VERBOSE)\n\t\t\tbtrfsic_print_add_link(state, l);\n\n\t\tlist_add(&l->node_ref_to, &block->ref_to_list);\n\t\tlist_add(&l->node_ref_from, &next_block->ref_from_list);\n\n\t\tbtrfsic_block_link_hashtable_add(l,\n\t\t\t\t\t\t &state->block_link_hashtable);\n\t} else {\n\t\tdid_alloc_block_link = 0;\n\t\tif (0 == limit_nesting) {\n\t\t\tl->ref_cnt++;\n\t\t\tl->parent_generation = parent_generation;\n\t\t\tif (state->print_mask & BTRFSIC_PRINT_MASK_VERBOSE)\n\t\t\t\tbtrfsic_print_add_link(state, l);\n\t\t}\n\t}\n\n\tif (limit_nesting > 0 && did_alloc_block_link) {\n\t\tret = btrfsic_read_block(state, next_block_ctx);\n\t\tif (ret < (int)next_block_ctx->len) {\n\t\t\tprintk(KERN_INFO\n\t\t\t       \"btrfsic: read block @logical %llu failed!\\n\",\n\t\t\t       next_bytenr);\n\t\t\tbtrfsic_release_block_ctx(next_block_ctx);\n\t\t\t*next_blockp = NULL;\n\t\t\treturn -1;\n\t\t}\n\n\t\t*next_blockp = next_block;\n\t} else {\n\t\t*next_blockp = NULL;\n\t}\n\t(*mirror_nump)++;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_stack_key_generation",
          "args": [
            "&key_ptr"
          ],
          "line": 1181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_stack_key_blockptr",
          "args": [
            "&key_ptr"
          ],
          "line": 1167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfsic_read_from_block_data",
          "args": [
            "sf->block_ctx",
            "&key_ptr",
            "key_ptr_offset",
            "sizeof(struct btrfs_key_ptr)"
          ],
          "line": 1164
        },
        "resolved": true,
        "details": {
          "function_name": "btrfsic_read_from_block_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/check-integrity.c",
          "lines": "1236-1261",
          "snippet": "static void btrfsic_read_from_block_data(\n\tstruct btrfsic_block_data_ctx *block_ctx,\n\tvoid *dstv, u32 offset, size_t len)\n{\n\tsize_t cur;\n\tsize_t offset_in_page;\n\tchar *kaddr;\n\tchar *dst = (char *)dstv;\n\tsize_t start_offset = block_ctx->start & ((u64)PAGE_CACHE_SIZE - 1);\n\tunsigned long i = (start_offset + offset) >> PAGE_CACHE_SHIFT;\n\n\tWARN_ON(offset + len > block_ctx->len);\n\toffset_in_page = (start_offset + offset) & (PAGE_CACHE_SIZE - 1);\n\n\twhile (len > 0) {\n\t\tcur = min(len, ((size_t)PAGE_CACHE_SIZE - offset_in_page));\n\t\tBUG_ON(i >= DIV_ROUND_UP(block_ctx->len, PAGE_CACHE_SIZE));\n\t\tkaddr = block_ctx->datav[i];\n\t\tmemcpy(dst, kaddr + offset_in_page, cur);\n\n\t\tdst += cur;\n\t\tlen -= cur;\n\t\toffset_in_page = 0;\n\t\ti++;\n\t}\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"extent_io.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/genhd.h>",
            "#include <linux/mutex.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void btrfsic_read_from_block_data(\n\tstruct btrfsic_block_data_ctx *block_ctx,\n\tvoid *dst, u32 offset, size_t len);",
            "static void btrfsic_release_block_ctx(struct btrfsic_block_data_ctx *block_ctx);",
            "static int btrfsic_read_block(struct btrfsic_state *state,\n\t\t\t      struct btrfsic_block_data_ctx *block_ctx);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"extent_io.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n#include <linux/blkdev.h>\n#include <linux/genhd.h>\n#include <linux/mutex.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic void btrfsic_read_from_block_data(\n\tstruct btrfsic_block_data_ctx *block_ctx,\n\tvoid *dst, u32 offset, size_t len);\nstatic void btrfsic_release_block_ctx(struct btrfsic_block_data_ctx *block_ctx);\nstatic int btrfsic_read_block(struct btrfsic_state *state,\n\t\t\t      struct btrfsic_block_data_ctx *block_ctx);\n\nstatic void btrfsic_read_from_block_data(\n\tstruct btrfsic_block_data_ctx *block_ctx,\n\tvoid *dstv, u32 offset, size_t len)\n{\n\tsize_t cur;\n\tsize_t offset_in_page;\n\tchar *kaddr;\n\tchar *dst = (char *)dstv;\n\tsize_t start_offset = block_ctx->start & ((u64)PAGE_CACHE_SIZE - 1);\n\tunsigned long i = (start_offset + offset) >> PAGE_CACHE_SHIFT;\n\n\tWARN_ON(offset + len > block_ctx->len);\n\toffset_in_page = (start_offset + offset) & (PAGE_CACHE_SIZE - 1);\n\n\twhile (len > 0) {\n\t\tcur = min(len, ((size_t)PAGE_CACHE_SIZE - offset_in_page));\n\t\tBUG_ON(i >= DIV_ROUND_UP(block_ctx->len, PAGE_CACHE_SIZE));\n\t\tkaddr = block_ctx->datav[i];\n\t\tmemcpy(dst, kaddr + offset_in_page, cur);\n\n\t\tdst += cur;\n\t\tlen -= cur;\n\t\toffset_in_page = 0;\n\t\ti++;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_INFO\n\t\t\t\t       \"btrfsic: node item out of bounce at logical %llu, dev %s\\n\"",
            "sf->block_ctx->start",
            "sf->block_ctx->dev->name"
          ],
          "line": 1158
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/super.c",
          "lines": "186-213",
          "snippet": "void btrfs_printk(const struct btrfs_fs_info *fs_info, const char *fmt, ...)\n{\n\tstruct super_block *sb = fs_info->sb;\n\tchar lvl[4];\n\tstruct va_format vaf;\n\tva_list args;\n\tconst char *type = logtypes[4];\n\tint kern_level;\n\n\tva_start(args, fmt);\n\n\tkern_level = printk_get_level(fmt);\n\tif (kern_level) {\n\t\tsize_t size = printk_skip_level(fmt) - fmt;\n\t\tmemcpy(lvl, fmt,  size);\n\t\tlvl[size] = '\\0';\n\t\tfmt += size;\n\t\ttype = logtypes[kern_level - '0'];\n\t} else\n\t\t*lvl = '\\0';\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sBTRFS %s (device %s): %pV\\n\", lvl, type, sb->s_id, &vaf);\n\n\tva_end(args);\n}",
          "includes": [
            "#include <trace/events/btrfs.h>",
            "#include \"qgroup.h\"",
            "#include \"tests/btrfs-tests.h\"",
            "#include \"backref.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"compression.h\"",
            "#include \"export.h\"",
            "#include \"volumes.h\"",
            "#include \"xattr.h\"",
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/slab.h>",
            "#include <linux/magic.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/namei.h>",
            "#include <linux/ctype.h>",
            "#include <linux/parser.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/btrfs.h>\n#include \"qgroup.h\"\n#include \"tests/btrfs-tests.h\"\n#include \"backref.h\"\n#include \"free-space-cache.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"compression.h\"\n#include \"export.h\"\n#include \"volumes.h\"\n#include \"xattr.h\"\n#include \"props.h\"\n#include \"hash.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include \"delayed-inode.h\"\n#include <linux/btrfs.h>\n#include <linux/ratelimit.h>\n#include <linux/cleancache.h>\n#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/miscdevice.h>\n#include <linux/namei.h>\n#include <linux/ctype.h>\n#include <linux/parser.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n\nvoid btrfs_printk(const struct btrfs_fs_info *fs_info, const char *fmt, ...)\n{\n\tstruct super_block *sb = fs_info->sb;\n\tchar lvl[4];\n\tstruct va_format vaf;\n\tva_list args;\n\tconst char *type = logtypes[4];\n\tint kern_level;\n\n\tva_start(args, fmt);\n\n\tkern_level = printk_get_level(fmt);\n\tif (kern_level) {\n\t\tsize_t size = printk_skip_level(fmt) - fmt;\n\t\tmemcpy(lvl, fmt,  size);\n\t\tlvl[size] = '\\0';\n\t\tfmt += size;\n\t\ttype = logtypes[kern_level - '0'];\n\t} else\n\t\t*lvl = '\\0';\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sBTRFS %s (device %s): %pV\\n\", lvl, type, sb->s_id, &vaf);\n\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_stack_header_owner",
          "args": [
            "&nodehdr->header"
          ],
          "line": 1139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_stack_header_generation",
          "args": [
            "&nodehdr->header"
          ],
          "line": 1137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_stack_header_nritems",
          "args": [
            "&nodehdr->header"
          ],
          "line": 1130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfsic_handle_extent_data",
          "args": [
            "state",
            "sf->block",
            "sf->block_ctx",
            "item_offset",
            "force_iodone_flag"
          ],
          "line": 1114
        },
        "resolved": true,
        "details": {
          "function_name": "btrfsic_handle_extent_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/check-integrity.c",
          "lines": "1411-1566",
          "snippet": "static int btrfsic_handle_extent_data(\n\t\tstruct btrfsic_state *state,\n\t\tstruct btrfsic_block *block,\n\t\tstruct btrfsic_block_data_ctx *block_ctx,\n\t\tu32 item_offset, int force_iodone_flag)\n{\n\tint ret;\n\tstruct btrfs_file_extent_item file_extent_item;\n\tu64 file_extent_item_offset;\n\tu64 next_bytenr;\n\tu64 num_bytes;\n\tu64 generation;\n\tstruct btrfsic_block_link *l;\n\n\tfile_extent_item_offset = offsetof(struct btrfs_leaf, items) +\n\t\t\t\t  item_offset;\n\tif (file_extent_item_offset +\n\t    offsetof(struct btrfs_file_extent_item, disk_num_bytes) >\n\t    block_ctx->len) {\n\t\tprintk(KERN_INFO\n\t\t       \"btrfsic: file item out of bounce at logical %llu, dev %s\\n\",\n\t\t       block_ctx->start, block_ctx->dev->name);\n\t\treturn -1;\n\t}\n\n\tbtrfsic_read_from_block_data(block_ctx, &file_extent_item,\n\t\tfile_extent_item_offset,\n\t\toffsetof(struct btrfs_file_extent_item, disk_num_bytes));\n\tif (BTRFS_FILE_EXTENT_REG != file_extent_item.type ||\n\t    btrfs_stack_file_extent_disk_bytenr(&file_extent_item) == 0) {\n\t\tif (state->print_mask & BTRFSIC_PRINT_MASK_VERY_VERBOSE)\n\t\t\tprintk(KERN_INFO \"extent_data: type %u, disk_bytenr = %llu\\n\",\n\t\t\t       file_extent_item.type,\n\t\t\t       btrfs_stack_file_extent_disk_bytenr(\n\t\t\t       &file_extent_item));\n\t\treturn 0;\n\t}\n\n\tif (file_extent_item_offset + sizeof(struct btrfs_file_extent_item) >\n\t    block_ctx->len) {\n\t\tprintk(KERN_INFO\n\t\t       \"btrfsic: file item out of bounce at logical %llu, dev %s\\n\",\n\t\t       block_ctx->start, block_ctx->dev->name);\n\t\treturn -1;\n\t}\n\tbtrfsic_read_from_block_data(block_ctx, &file_extent_item,\n\t\t\t\t     file_extent_item_offset,\n\t\t\t\t     sizeof(struct btrfs_file_extent_item));\n\tnext_bytenr = btrfs_stack_file_extent_disk_bytenr(&file_extent_item);\n\tif (btrfs_stack_file_extent_compression(&file_extent_item) ==\n\t    BTRFS_COMPRESS_NONE) {\n\t\tnext_bytenr += btrfs_stack_file_extent_offset(&file_extent_item);\n\t\tnum_bytes = btrfs_stack_file_extent_num_bytes(&file_extent_item);\n\t} else {\n\t\tnum_bytes = btrfs_stack_file_extent_disk_num_bytes(&file_extent_item);\n\t}\n\tgeneration = btrfs_stack_file_extent_generation(&file_extent_item);\n\n\tif (state->print_mask & BTRFSIC_PRINT_MASK_VERY_VERBOSE)\n\t\tprintk(KERN_INFO \"extent_data: type %u, disk_bytenr = %llu,\"\n\t\t       \" offset = %llu, num_bytes = %llu\\n\",\n\t\t       file_extent_item.type,\n\t\t       btrfs_stack_file_extent_disk_bytenr(&file_extent_item),\n\t\t       btrfs_stack_file_extent_offset(&file_extent_item),\n\t\t       num_bytes);\n\twhile (num_bytes > 0) {\n\t\tu32 chunk_len;\n\t\tint num_copies;\n\t\tint mirror_num;\n\n\t\tif (num_bytes > state->datablock_size)\n\t\t\tchunk_len = state->datablock_size;\n\t\telse\n\t\t\tchunk_len = num_bytes;\n\n\t\tnum_copies =\n\t\t    btrfs_num_copies(state->root->fs_info,\n\t\t\t\t     next_bytenr, state->datablock_size);\n\t\tif (state->print_mask & BTRFSIC_PRINT_MASK_NUM_COPIES)\n\t\t\tprintk(KERN_INFO \"num_copies(log_bytenr=%llu) = %d\\n\",\n\t\t\t       next_bytenr, num_copies);\n\t\tfor (mirror_num = 1; mirror_num <= num_copies; mirror_num++) {\n\t\t\tstruct btrfsic_block_data_ctx next_block_ctx;\n\t\t\tstruct btrfsic_block *next_block;\n\t\t\tint block_was_created;\n\n\t\t\tif (state->print_mask & BTRFSIC_PRINT_MASK_VERBOSE)\n\t\t\t\tprintk(KERN_INFO \"btrfsic_handle_extent_data(\"\n\t\t\t\t       \"mirror_num=%d)\\n\", mirror_num);\n\t\t\tif (state->print_mask & BTRFSIC_PRINT_MASK_VERY_VERBOSE)\n\t\t\t\tprintk(KERN_INFO\n\t\t\t\t       \"\\tdisk_bytenr = %llu, num_bytes %u\\n\",\n\t\t\t\t       next_bytenr, chunk_len);\n\t\t\tret = btrfsic_map_block(state, next_bytenr,\n\t\t\t\t\t\tchunk_len, &next_block_ctx,\n\t\t\t\t\t\tmirror_num);\n\t\t\tif (ret) {\n\t\t\t\tprintk(KERN_INFO\n\t\t\t\t       \"btrfsic: btrfsic_map_block(@%llu,\"\n\t\t\t\t       \" mirror=%d) failed!\\n\",\n\t\t\t\t       next_bytenr, mirror_num);\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tnext_block = btrfsic_block_lookup_or_add(\n\t\t\t\t\tstate,\n\t\t\t\t\t&next_block_ctx,\n\t\t\t\t\t\"referenced \",\n\t\t\t\t\t0,\n\t\t\t\t\tforce_iodone_flag,\n\t\t\t\t\t!force_iodone_flag,\n\t\t\t\t\tmirror_num,\n\t\t\t\t\t&block_was_created);\n\t\t\tif (NULL == next_block) {\n\t\t\t\tprintk(KERN_INFO\n\t\t\t\t       \"btrfsic: error, kmalloc failed!\\n\");\n\t\t\t\tbtrfsic_release_block_ctx(&next_block_ctx);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif (!block_was_created) {\n\t\t\t\tif ((state->print_mask &\n\t\t\t\t     BTRFSIC_PRINT_MASK_VERBOSE) &&\n\t\t\t\t    next_block->logical_bytenr != next_bytenr &&\n\t\t\t\t    !(!next_block->is_metadata &&\n\t\t\t\t      0 == next_block->logical_bytenr)) {\n\t\t\t\t\tprintk(KERN_INFO\n\t\t\t\t\t       \"Referenced block\"\n\t\t\t\t\t       \" @%llu (%s/%llu/%d)\"\n\t\t\t\t\t       \" found in hash table, D,\"\n\t\t\t\t\t       \" bytenr mismatch\"\n\t\t\t\t\t       \" (!= stored %llu).\\n\",\n\t\t\t\t\t       next_bytenr,\n\t\t\t\t\t       next_block_ctx.dev->name,\n\t\t\t\t\t       next_block_ctx.dev_bytenr,\n\t\t\t\t\t       mirror_num,\n\t\t\t\t\t       next_block->logical_bytenr);\n\t\t\t\t}\n\t\t\t\tnext_block->logical_bytenr = next_bytenr;\n\t\t\t\tnext_block->mirror_num = mirror_num;\n\t\t\t}\n\n\t\t\tl = btrfsic_block_link_lookup_or_add(state,\n\t\t\t\t\t\t\t     &next_block_ctx,\n\t\t\t\t\t\t\t     next_block, block,\n\t\t\t\t\t\t\t     generation);\n\t\t\tbtrfsic_release_block_ctx(&next_block_ctx);\n\t\t\tif (NULL == l)\n\t\t\t\treturn -1;\n\t\t}\n\n\t\tnext_bytenr += chunk_len;\n\t\tnum_bytes -= chunk_len;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"extent_io.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/genhd.h>",
            "#include <linux/mutex.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define BTRFSIC_PRINT_MASK_NUM_COPIES\t\t\t\t0x00000800",
            "#define BTRFSIC_PRINT_MASK_VERY_VERBOSE\t\t\t\t0x00000080",
            "#define BTRFSIC_PRINT_MASK_VERBOSE\t\t\t\t0x00000040"
          ],
          "globals_used": [
            "static void btrfsic_block_link_init(struct btrfsic_block_link *n);",
            "static void btrfsic_block_link_free(struct btrfsic_block_link *n);",
            "static void btrfsic_block_link_hashtable_remove(struct btrfsic_block_link *l);",
            "static int btrfsic_process_metablock(struct btrfsic_state *state,\n\t\t\t\t     struct btrfsic_block *block,\n\t\t\t\t     struct btrfsic_block_data_ctx *block_ctx,\n\t\t\t\t     int limit_nesting, int force_iodone_flag);",
            "static void btrfsic_read_from_block_data(\n\tstruct btrfsic_block_data_ctx *block_ctx,\n\tvoid *dst, u32 offset, size_t len);",
            "static int btrfsic_handle_extent_data(struct btrfsic_state *state,\n\t\t\t\t      struct btrfsic_block *block,\n\t\t\t\t      struct btrfsic_block_data_ctx *block_ctx,\n\t\t\t\t      u32 item_offset, int force_iodone_flag);",
            "static int btrfsic_map_block(struct btrfsic_state *state, u64 bytenr, u32 len,\n\t\t\t     struct btrfsic_block_data_ctx *block_ctx_out,\n\t\t\t     int mirror_num);",
            "static void btrfsic_release_block_ctx(struct btrfsic_block_data_ctx *block_ctx);",
            "static int btrfsic_read_block(struct btrfsic_state *state,\n\t\t\t      struct btrfsic_block_data_ctx *block_ctx);",
            "static void btrfsic_dump_database(struct btrfsic_state *state);",
            "static void btrfsic_print_add_link(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block_link *l);",
            "static void btrfsic_print_rem_link(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block_link *l);",
            "static char btrfsic_get_block_type(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block *block);",
            "static void btrfsic_dump_tree(const struct btrfsic_state *state);",
            "static void btrfsic_cmp_log_and_dev_bytenr(struct btrfsic_state *state,\n\t\t\t\t\t   u64 bytenr,\n\t\t\t\t\t   struct btrfsic_dev_state *dev_state,\n\t\t\t\t\t   u64 dev_bytenr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"extent_io.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n#include <linux/blkdev.h>\n#include <linux/genhd.h>\n#include <linux/mutex.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\n#define BTRFSIC_PRINT_MASK_NUM_COPIES\t\t\t\t0x00000800\n#define BTRFSIC_PRINT_MASK_VERY_VERBOSE\t\t\t\t0x00000080\n#define BTRFSIC_PRINT_MASK_VERBOSE\t\t\t\t0x00000040\n\nstatic void btrfsic_block_link_init(struct btrfsic_block_link *n);\nstatic void btrfsic_block_link_free(struct btrfsic_block_link *n);\nstatic void btrfsic_block_link_hashtable_remove(struct btrfsic_block_link *l);\nstatic int btrfsic_process_metablock(struct btrfsic_state *state,\n\t\t\t\t     struct btrfsic_block *block,\n\t\t\t\t     struct btrfsic_block_data_ctx *block_ctx,\n\t\t\t\t     int limit_nesting, int force_iodone_flag);\nstatic void btrfsic_read_from_block_data(\n\tstruct btrfsic_block_data_ctx *block_ctx,\n\tvoid *dst, u32 offset, size_t len);\nstatic int btrfsic_handle_extent_data(struct btrfsic_state *state,\n\t\t\t\t      struct btrfsic_block *block,\n\t\t\t\t      struct btrfsic_block_data_ctx *block_ctx,\n\t\t\t\t      u32 item_offset, int force_iodone_flag);\nstatic int btrfsic_map_block(struct btrfsic_state *state, u64 bytenr, u32 len,\n\t\t\t     struct btrfsic_block_data_ctx *block_ctx_out,\n\t\t\t     int mirror_num);\nstatic void btrfsic_release_block_ctx(struct btrfsic_block_data_ctx *block_ctx);\nstatic int btrfsic_read_block(struct btrfsic_state *state,\n\t\t\t      struct btrfsic_block_data_ctx *block_ctx);\nstatic void btrfsic_dump_database(struct btrfsic_state *state);\nstatic void btrfsic_print_add_link(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block_link *l);\nstatic void btrfsic_print_rem_link(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block_link *l);\nstatic char btrfsic_get_block_type(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block *block);\nstatic void btrfsic_dump_tree(const struct btrfsic_state *state);\nstatic void btrfsic_cmp_log_and_dev_bytenr(struct btrfsic_state *state,\n\t\t\t\t\t   u64 bytenr,\n\t\t\t\t\t   struct btrfsic_dev_state *dev_state,\n\t\t\t\t\t   u64 dev_bytenr);\n\nstatic int btrfsic_handle_extent_data(\n\t\tstruct btrfsic_state *state,\n\t\tstruct btrfsic_block *block,\n\t\tstruct btrfsic_block_data_ctx *block_ctx,\n\t\tu32 item_offset, int force_iodone_flag)\n{\n\tint ret;\n\tstruct btrfs_file_extent_item file_extent_item;\n\tu64 file_extent_item_offset;\n\tu64 next_bytenr;\n\tu64 num_bytes;\n\tu64 generation;\n\tstruct btrfsic_block_link *l;\n\n\tfile_extent_item_offset = offsetof(struct btrfs_leaf, items) +\n\t\t\t\t  item_offset;\n\tif (file_extent_item_offset +\n\t    offsetof(struct btrfs_file_extent_item, disk_num_bytes) >\n\t    block_ctx->len) {\n\t\tprintk(KERN_INFO\n\t\t       \"btrfsic: file item out of bounce at logical %llu, dev %s\\n\",\n\t\t       block_ctx->start, block_ctx->dev->name);\n\t\treturn -1;\n\t}\n\n\tbtrfsic_read_from_block_data(block_ctx, &file_extent_item,\n\t\tfile_extent_item_offset,\n\t\toffsetof(struct btrfs_file_extent_item, disk_num_bytes));\n\tif (BTRFS_FILE_EXTENT_REG != file_extent_item.type ||\n\t    btrfs_stack_file_extent_disk_bytenr(&file_extent_item) == 0) {\n\t\tif (state->print_mask & BTRFSIC_PRINT_MASK_VERY_VERBOSE)\n\t\t\tprintk(KERN_INFO \"extent_data: type %u, disk_bytenr = %llu\\n\",\n\t\t\t       file_extent_item.type,\n\t\t\t       btrfs_stack_file_extent_disk_bytenr(\n\t\t\t       &file_extent_item));\n\t\treturn 0;\n\t}\n\n\tif (file_extent_item_offset + sizeof(struct btrfs_file_extent_item) >\n\t    block_ctx->len) {\n\t\tprintk(KERN_INFO\n\t\t       \"btrfsic: file item out of bounce at logical %llu, dev %s\\n\",\n\t\t       block_ctx->start, block_ctx->dev->name);\n\t\treturn -1;\n\t}\n\tbtrfsic_read_from_block_data(block_ctx, &file_extent_item,\n\t\t\t\t     file_extent_item_offset,\n\t\t\t\t     sizeof(struct btrfs_file_extent_item));\n\tnext_bytenr = btrfs_stack_file_extent_disk_bytenr(&file_extent_item);\n\tif (btrfs_stack_file_extent_compression(&file_extent_item) ==\n\t    BTRFS_COMPRESS_NONE) {\n\t\tnext_bytenr += btrfs_stack_file_extent_offset(&file_extent_item);\n\t\tnum_bytes = btrfs_stack_file_extent_num_bytes(&file_extent_item);\n\t} else {\n\t\tnum_bytes = btrfs_stack_file_extent_disk_num_bytes(&file_extent_item);\n\t}\n\tgeneration = btrfs_stack_file_extent_generation(&file_extent_item);\n\n\tif (state->print_mask & BTRFSIC_PRINT_MASK_VERY_VERBOSE)\n\t\tprintk(KERN_INFO \"extent_data: type %u, disk_bytenr = %llu,\"\n\t\t       \" offset = %llu, num_bytes = %llu\\n\",\n\t\t       file_extent_item.type,\n\t\t       btrfs_stack_file_extent_disk_bytenr(&file_extent_item),\n\t\t       btrfs_stack_file_extent_offset(&file_extent_item),\n\t\t       num_bytes);\n\twhile (num_bytes > 0) {\n\t\tu32 chunk_len;\n\t\tint num_copies;\n\t\tint mirror_num;\n\n\t\tif (num_bytes > state->datablock_size)\n\t\t\tchunk_len = state->datablock_size;\n\t\telse\n\t\t\tchunk_len = num_bytes;\n\n\t\tnum_copies =\n\t\t    btrfs_num_copies(state->root->fs_info,\n\t\t\t\t     next_bytenr, state->datablock_size);\n\t\tif (state->print_mask & BTRFSIC_PRINT_MASK_NUM_COPIES)\n\t\t\tprintk(KERN_INFO \"num_copies(log_bytenr=%llu) = %d\\n\",\n\t\t\t       next_bytenr, num_copies);\n\t\tfor (mirror_num = 1; mirror_num <= num_copies; mirror_num++) {\n\t\t\tstruct btrfsic_block_data_ctx next_block_ctx;\n\t\t\tstruct btrfsic_block *next_block;\n\t\t\tint block_was_created;\n\n\t\t\tif (state->print_mask & BTRFSIC_PRINT_MASK_VERBOSE)\n\t\t\t\tprintk(KERN_INFO \"btrfsic_handle_extent_data(\"\n\t\t\t\t       \"mirror_num=%d)\\n\", mirror_num);\n\t\t\tif (state->print_mask & BTRFSIC_PRINT_MASK_VERY_VERBOSE)\n\t\t\t\tprintk(KERN_INFO\n\t\t\t\t       \"\\tdisk_bytenr = %llu, num_bytes %u\\n\",\n\t\t\t\t       next_bytenr, chunk_len);\n\t\t\tret = btrfsic_map_block(state, next_bytenr,\n\t\t\t\t\t\tchunk_len, &next_block_ctx,\n\t\t\t\t\t\tmirror_num);\n\t\t\tif (ret) {\n\t\t\t\tprintk(KERN_INFO\n\t\t\t\t       \"btrfsic: btrfsic_map_block(@%llu,\"\n\t\t\t\t       \" mirror=%d) failed!\\n\",\n\t\t\t\t       next_bytenr, mirror_num);\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tnext_block = btrfsic_block_lookup_or_add(\n\t\t\t\t\tstate,\n\t\t\t\t\t&next_block_ctx,\n\t\t\t\t\t\"referenced \",\n\t\t\t\t\t0,\n\t\t\t\t\tforce_iodone_flag,\n\t\t\t\t\t!force_iodone_flag,\n\t\t\t\t\tmirror_num,\n\t\t\t\t\t&block_was_created);\n\t\t\tif (NULL == next_block) {\n\t\t\t\tprintk(KERN_INFO\n\t\t\t\t       \"btrfsic: error, kmalloc failed!\\n\");\n\t\t\t\tbtrfsic_release_block_ctx(&next_block_ctx);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif (!block_was_created) {\n\t\t\t\tif ((state->print_mask &\n\t\t\t\t     BTRFSIC_PRINT_MASK_VERBOSE) &&\n\t\t\t\t    next_block->logical_bytenr != next_bytenr &&\n\t\t\t\t    !(!next_block->is_metadata &&\n\t\t\t\t      0 == next_block->logical_bytenr)) {\n\t\t\t\t\tprintk(KERN_INFO\n\t\t\t\t\t       \"Referenced block\"\n\t\t\t\t\t       \" @%llu (%s/%llu/%d)\"\n\t\t\t\t\t       \" found in hash table, D,\"\n\t\t\t\t\t       \" bytenr mismatch\"\n\t\t\t\t\t       \" (!= stored %llu).\\n\",\n\t\t\t\t\t       next_bytenr,\n\t\t\t\t\t       next_block_ctx.dev->name,\n\t\t\t\t\t       next_block_ctx.dev_bytenr,\n\t\t\t\t\t       mirror_num,\n\t\t\t\t\t       next_block->logical_bytenr);\n\t\t\t\t}\n\t\t\t\tnext_block->logical_bytenr = next_bytenr;\n\t\t\t\tnext_block->mirror_num = mirror_num;\n\t\t\t}\n\n\t\t\tl = btrfsic_block_link_lookup_or_add(state,\n\t\t\t\t\t\t\t     &next_block_ctx,\n\t\t\t\t\t\t\t     next_block, block,\n\t\t\t\t\t\t\t     generation);\n\t\t\tbtrfsic_release_block_ctx(&next_block_ctx);\n\t\t\tif (NULL == l)\n\t\t\t\treturn -1;\n\t\t}\n\n\t\tnext_bytenr += chunk_len;\n\t\tnum_bytes -= chunk_len;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_root_generation",
          "args": [
            "&root_item"
          ],
          "line": 1080
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_root_bytenr",
          "args": [
            "&root_item"
          ],
          "line": 1065
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_disk_key_type",
          "args": [
            "disk_key"
          ],
          "line": 1049
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_stack_item_size",
          "args": [
            "&disk_item"
          ],
          "line": 1047
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_stack_item_offset",
          "args": [
            "&disk_item"
          ],
          "line": 1046
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_stack_header_owner",
          "args": [
            "&leafhdr->header"
          ],
          "line": 1013
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_stack_header_generation",
          "args": [
            "&leafhdr->header"
          ],
          "line": 1011
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_stack_header_nritems",
          "args": [
            "&leafhdr->header"
          ],
          "line": 1004
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "sf->hdr->generation"
          ],
          "line": 998
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!first_hdr"
          ],
          "line": 986
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"extent_io.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n#include <linux/blkdev.h>\n#include <linux/genhd.h>\n#include <linux/mutex.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\n#define BTRFSIC_PRINT_MASK_VERBOSE\t\t\t\t0x00000040\n\nstatic void btrfsic_block_link_init(struct btrfsic_block_link *n);\nstatic void btrfsic_block_link_free(struct btrfsic_block_link *n);\nstatic struct btrfsic_stack_frame *btrfsic_stack_frame_alloc(void);\nstatic void btrfsic_stack_frame_free(struct btrfsic_stack_frame *sf);\nstatic int btrfsic_process_metablock(struct btrfsic_state *state,\n\t\t\t\t     struct btrfsic_block *block,\n\t\t\t\t     struct btrfsic_block_data_ctx *block_ctx,\n\t\t\t\t     int limit_nesting, int force_iodone_flag);\nstatic void btrfsic_read_from_block_data(\n\tstruct btrfsic_block_data_ctx *block_ctx,\n\tvoid *dst, u32 offset, size_t len);\nstatic int btrfsic_handle_extent_data(struct btrfsic_state *state,\n\t\t\t\t      struct btrfsic_block *block,\n\t\t\t\t      struct btrfsic_block_data_ctx *block_ctx,\n\t\t\t\t      u32 item_offset, int force_iodone_flag);\nstatic int btrfsic_map_block(struct btrfsic_state *state, u64 bytenr, u32 len,\n\t\t\t     struct btrfsic_block_data_ctx *block_ctx_out,\n\t\t\t     int mirror_num);\nstatic void btrfsic_release_block_ctx(struct btrfsic_block_data_ctx *block_ctx);\nstatic int btrfsic_read_block(struct btrfsic_state *state,\n\t\t\t      struct btrfsic_block_data_ctx *block_ctx);\nstatic void btrfsic_dump_database(struct btrfsic_state *state);\nstatic char btrfsic_get_block_type(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block *block);\nstatic void btrfsic_dump_tree(const struct btrfsic_state *state);\n\nstatic int btrfsic_process_metablock(\n\t\tstruct btrfsic_state *state,\n\t\tstruct btrfsic_block *const first_block,\n\t\tstruct btrfsic_block_data_ctx *const first_block_ctx,\n\t\tint first_limit_nesting, int force_iodone_flag)\n{\n\tstruct btrfsic_stack_frame initial_stack_frame = { 0 };\n\tstruct btrfsic_stack_frame *sf;\n\tstruct btrfsic_stack_frame *next_stack;\n\tstruct btrfs_header *const first_hdr =\n\t\t(struct btrfs_header *)first_block_ctx->datav[0];\n\n\tBUG_ON(!first_hdr);\n\tsf = &initial_stack_frame;\n\tsf->error = 0;\n\tsf->i = -1;\n\tsf->limit_nesting = first_limit_nesting;\n\tsf->block = first_block;\n\tsf->block_ctx = first_block_ctx;\n\tsf->next_block = NULL;\n\tsf->hdr = first_hdr;\n\tsf->prev = NULL;\n\ncontinue_with_new_stack_frame:\n\tsf->block->generation = le64_to_cpu(sf->hdr->generation);\n\tif (0 == sf->hdr->level) {\n\t\tstruct btrfs_leaf *const leafhdr =\n\t\t    (struct btrfs_leaf *)sf->hdr;\n\n\t\tif (-1 == sf->i) {\n\t\t\tsf->nr = btrfs_stack_header_nritems(&leafhdr->header);\n\n\t\t\tif (state->print_mask & BTRFSIC_PRINT_MASK_VERBOSE)\n\t\t\t\tprintk(KERN_INFO\n\t\t\t\t       \"leaf %llu items %d generation %llu\"\n\t\t\t\t       \" owner %llu\\n\",\n\t\t\t\t       sf->block_ctx->start, sf->nr,\n\t\t\t\t       btrfs_stack_header_generation(\n\t\t\t\t\t       &leafhdr->header),\n\t\t\t\t       btrfs_stack_header_owner(\n\t\t\t\t\t       &leafhdr->header));\n\t\t}\n\ncontinue_with_current_leaf_stack_frame:\n\t\tif (0 == sf->num_copies || sf->mirror_num > sf->num_copies) {\n\t\t\tsf->i++;\n\t\t\tsf->num_copies = 0;\n\t\t}\n\n\t\tif (sf->i < sf->nr) {\n\t\t\tstruct btrfs_item disk_item;\n\t\t\tu32 disk_item_offset =\n\t\t\t\t(uintptr_t)(leafhdr->items + sf->i) -\n\t\t\t\t(uintptr_t)leafhdr;\n\t\t\tstruct btrfs_disk_key *disk_key;\n\t\t\tu8 type;\n\t\t\tu32 item_offset;\n\t\t\tu32 item_size;\n\n\t\t\tif (disk_item_offset + sizeof(struct btrfs_item) >\n\t\t\t    sf->block_ctx->len) {\nleaf_item_out_of_bounce_error:\n\t\t\t\tprintk(KERN_INFO\n\t\t\t\t       \"btrfsic: leaf item out of bounce at logical %llu, dev %s\\n\",\n\t\t\t\t       sf->block_ctx->start,\n\t\t\t\t       sf->block_ctx->dev->name);\n\t\t\t\tgoto one_stack_frame_backwards;\n\t\t\t}\n\t\t\tbtrfsic_read_from_block_data(sf->block_ctx,\n\t\t\t\t\t\t     &disk_item,\n\t\t\t\t\t\t     disk_item_offset,\n\t\t\t\t\t\t     sizeof(struct btrfs_item));\n\t\t\titem_offset = btrfs_stack_item_offset(&disk_item);\n\t\t\titem_size = btrfs_stack_item_size(&disk_item);\n\t\t\tdisk_key = &disk_item.key;\n\t\t\ttype = btrfs_disk_key_type(disk_key);\n\n\t\t\tif (BTRFS_ROOT_ITEM_KEY == type) {\n\t\t\t\tstruct btrfs_root_item root_item;\n\t\t\t\tu32 root_item_offset;\n\t\t\t\tu64 next_bytenr;\n\n\t\t\t\troot_item_offset = item_offset +\n\t\t\t\t\toffsetof(struct btrfs_leaf, items);\n\t\t\t\tif (root_item_offset + item_size >\n\t\t\t\t    sf->block_ctx->len)\n\t\t\t\t\tgoto leaf_item_out_of_bounce_error;\n\t\t\t\tbtrfsic_read_from_block_data(\n\t\t\t\t\tsf->block_ctx, &root_item,\n\t\t\t\t\troot_item_offset,\n\t\t\t\t\titem_size);\n\t\t\t\tnext_bytenr = btrfs_root_bytenr(&root_item);\n\n\t\t\t\tsf->error =\n\t\t\t\t    btrfsic_create_link_to_next_block(\n\t\t\t\t\t\tstate,\n\t\t\t\t\t\tsf->block,\n\t\t\t\t\t\tsf->block_ctx,\n\t\t\t\t\t\tnext_bytenr,\n\t\t\t\t\t\tsf->limit_nesting,\n\t\t\t\t\t\t&sf->next_block_ctx,\n\t\t\t\t\t\t&sf->next_block,\n\t\t\t\t\t\tforce_iodone_flag,\n\t\t\t\t\t\t&sf->num_copies,\n\t\t\t\t\t\t&sf->mirror_num,\n\t\t\t\t\t\tdisk_key,\n\t\t\t\t\t\tbtrfs_root_generation(\n\t\t\t\t\t\t&root_item));\n\t\t\t\tif (sf->error)\n\t\t\t\t\tgoto one_stack_frame_backwards;\n\n\t\t\t\tif (NULL != sf->next_block) {\n\t\t\t\t\tstruct btrfs_header *const next_hdr =\n\t\t\t\t\t    (struct btrfs_header *)\n\t\t\t\t\t    sf->next_block_ctx.datav[0];\n\n\t\t\t\t\tnext_stack =\n\t\t\t\t\t    btrfsic_stack_frame_alloc();\n\t\t\t\t\tif (NULL == next_stack) {\n\t\t\t\t\t\tsf->error = -1;\n\t\t\t\t\t\tbtrfsic_release_block_ctx(\n\t\t\t\t\t\t\t\t&sf->\n\t\t\t\t\t\t\t\tnext_block_ctx);\n\t\t\t\t\t\tgoto one_stack_frame_backwards;\n\t\t\t\t\t}\n\n\t\t\t\t\tnext_stack->i = -1;\n\t\t\t\t\tnext_stack->block = sf->next_block;\n\t\t\t\t\tnext_stack->block_ctx =\n\t\t\t\t\t    &sf->next_block_ctx;\n\t\t\t\t\tnext_stack->next_block = NULL;\n\t\t\t\t\tnext_stack->hdr = next_hdr;\n\t\t\t\t\tnext_stack->limit_nesting =\n\t\t\t\t\t    sf->limit_nesting - 1;\n\t\t\t\t\tnext_stack->prev = sf;\n\t\t\t\t\tsf = next_stack;\n\t\t\t\t\tgoto continue_with_new_stack_frame;\n\t\t\t\t}\n\t\t\t} else if (BTRFS_EXTENT_DATA_KEY == type &&\n\t\t\t\t   state->include_extent_data) {\n\t\t\t\tsf->error = btrfsic_handle_extent_data(\n\t\t\t\t\t\tstate,\n\t\t\t\t\t\tsf->block,\n\t\t\t\t\t\tsf->block_ctx,\n\t\t\t\t\t\titem_offset,\n\t\t\t\t\t\tforce_iodone_flag);\n\t\t\t\tif (sf->error)\n\t\t\t\t\tgoto one_stack_frame_backwards;\n\t\t\t}\n\n\t\t\tgoto continue_with_current_leaf_stack_frame;\n\t\t}\n\t} else {\n\t\tstruct btrfs_node *const nodehdr = (struct btrfs_node *)sf->hdr;\n\n\t\tif (-1 == sf->i) {\n\t\t\tsf->nr = btrfs_stack_header_nritems(&nodehdr->header);\n\n\t\t\tif (state->print_mask & BTRFSIC_PRINT_MASK_VERBOSE)\n\t\t\t\tprintk(KERN_INFO \"node %llu level %d items %d\"\n\t\t\t\t       \" generation %llu owner %llu\\n\",\n\t\t\t\t       sf->block_ctx->start,\n\t\t\t\t       nodehdr->header.level, sf->nr,\n\t\t\t\t       btrfs_stack_header_generation(\n\t\t\t\t       &nodehdr->header),\n\t\t\t\t       btrfs_stack_header_owner(\n\t\t\t\t       &nodehdr->header));\n\t\t}\n\ncontinue_with_current_node_stack_frame:\n\t\tif (0 == sf->num_copies || sf->mirror_num > sf->num_copies) {\n\t\t\tsf->i++;\n\t\t\tsf->num_copies = 0;\n\t\t}\n\n\t\tif (sf->i < sf->nr) {\n\t\t\tstruct btrfs_key_ptr key_ptr;\n\t\t\tu32 key_ptr_offset;\n\t\t\tu64 next_bytenr;\n\n\t\t\tkey_ptr_offset = (uintptr_t)(nodehdr->ptrs + sf->i) -\n\t\t\t\t\t  (uintptr_t)nodehdr;\n\t\t\tif (key_ptr_offset + sizeof(struct btrfs_key_ptr) >\n\t\t\t    sf->block_ctx->len) {\n\t\t\t\tprintk(KERN_INFO\n\t\t\t\t       \"btrfsic: node item out of bounce at logical %llu, dev %s\\n\",\n\t\t\t\t       sf->block_ctx->start,\n\t\t\t\t       sf->block_ctx->dev->name);\n\t\t\t\tgoto one_stack_frame_backwards;\n\t\t\t}\n\t\t\tbtrfsic_read_from_block_data(\n\t\t\t\tsf->block_ctx, &key_ptr, key_ptr_offset,\n\t\t\t\tsizeof(struct btrfs_key_ptr));\n\t\t\tnext_bytenr = btrfs_stack_key_blockptr(&key_ptr);\n\n\t\t\tsf->error = btrfsic_create_link_to_next_block(\n\t\t\t\t\tstate,\n\t\t\t\t\tsf->block,\n\t\t\t\t\tsf->block_ctx,\n\t\t\t\t\tnext_bytenr,\n\t\t\t\t\tsf->limit_nesting,\n\t\t\t\t\t&sf->next_block_ctx,\n\t\t\t\t\t&sf->next_block,\n\t\t\t\t\tforce_iodone_flag,\n\t\t\t\t\t&sf->num_copies,\n\t\t\t\t\t&sf->mirror_num,\n\t\t\t\t\t&key_ptr.key,\n\t\t\t\t\tbtrfs_stack_key_generation(&key_ptr));\n\t\t\tif (sf->error)\n\t\t\t\tgoto one_stack_frame_backwards;\n\n\t\t\tif (NULL != sf->next_block) {\n\t\t\t\tstruct btrfs_header *const next_hdr =\n\t\t\t\t    (struct btrfs_header *)\n\t\t\t\t    sf->next_block_ctx.datav[0];\n\n\t\t\t\tnext_stack = btrfsic_stack_frame_alloc();\n\t\t\t\tif (NULL == next_stack) {\n\t\t\t\t\tsf->error = -1;\n\t\t\t\t\tgoto one_stack_frame_backwards;\n\t\t\t\t}\n\n\t\t\t\tnext_stack->i = -1;\n\t\t\t\tnext_stack->block = sf->next_block;\n\t\t\t\tnext_stack->block_ctx = &sf->next_block_ctx;\n\t\t\t\tnext_stack->next_block = NULL;\n\t\t\t\tnext_stack->hdr = next_hdr;\n\t\t\t\tnext_stack->limit_nesting =\n\t\t\t\t    sf->limit_nesting - 1;\n\t\t\t\tnext_stack->prev = sf;\n\t\t\t\tsf = next_stack;\n\t\t\t\tgoto continue_with_new_stack_frame;\n\t\t\t}\n\n\t\t\tgoto continue_with_current_node_stack_frame;\n\t\t}\n\t}\n\none_stack_frame_backwards:\n\tif (NULL != sf->prev) {\n\t\tstruct btrfsic_stack_frame *const prev = sf->prev;\n\n\t\t/* the one for the initial block is freed in the caller */\n\t\tbtrfsic_release_block_ctx(sf->block_ctx);\n\n\t\tif (sf->error) {\n\t\t\tprev->error = sf->error;\n\t\t\tbtrfsic_stack_frame_free(sf);\n\t\t\tsf = prev;\n\t\t\tgoto one_stack_frame_backwards;\n\t\t}\n\n\t\tbtrfsic_stack_frame_free(sf);\n\t\tsf = prev;\n\t\tgoto continue_with_new_stack_frame;\n\t} else {\n\t\tBUG_ON(&initial_stack_frame != sf);\n\t}\n\n\treturn sf->error;\n}"
  },
  {
    "function_name": "btrfsic_stack_frame_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/check-integrity.c",
    "lines": "967-972",
    "snippet": "static void btrfsic_stack_frame_free(struct btrfsic_stack_frame *sf)\n{\n\tBUG_ON(!(NULL == sf ||\n\t\t BTRFSIC_BLOCK_STACK_FRAME_MAGIC_NUMBER == sf->magic));\n\tkfree(sf);\n}",
    "includes": [
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"volumes.h\"",
      "#include \"extent_io.h\"",
      "#include \"transaction.h\"",
      "#include \"hash.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/genhd.h>",
      "#include <linux/mutex.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [
      "#define BTRFSIC_BLOCK_STACK_FRAME_MAGIC_NUMBER 20111300"
    ],
    "globals_used": [
      "static void btrfsic_stack_frame_free(struct btrfsic_stack_frame *sf);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "sf"
          ],
          "line": 971
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!(NULL == sf ||\n\t\t BTRFSIC_BLOCK_STACK_FRAME_MAGIC_NUMBER == sf->magic)"
          ],
          "line": 969
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"extent_io.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n#include <linux/blkdev.h>\n#include <linux/genhd.h>\n#include <linux/mutex.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\n#define BTRFSIC_BLOCK_STACK_FRAME_MAGIC_NUMBER 20111300\n\nstatic void btrfsic_stack_frame_free(struct btrfsic_stack_frame *sf);\n\nstatic void btrfsic_stack_frame_free(struct btrfsic_stack_frame *sf)\n{\n\tBUG_ON(!(NULL == sf ||\n\t\t BTRFSIC_BLOCK_STACK_FRAME_MAGIC_NUMBER == sf->magic));\n\tkfree(sf);\n}"
  },
  {
    "function_name": "btrfsic_stack_frame_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/check-integrity.c",
    "lines": "955-965",
    "snippet": "static struct btrfsic_stack_frame *btrfsic_stack_frame_alloc(void)\n{\n\tstruct btrfsic_stack_frame *sf;\n\n\tsf = kzalloc(sizeof(*sf), GFP_NOFS);\n\tif (NULL == sf)\n\t\tprintk(KERN_INFO \"btrfsic: alloc memory failed!\\n\");\n\telse\n\t\tsf->magic = BTRFSIC_BLOCK_STACK_FRAME_MAGIC_NUMBER;\n\treturn sf;\n}",
    "includes": [
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"volumes.h\"",
      "#include \"extent_io.h\"",
      "#include \"transaction.h\"",
      "#include \"hash.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/genhd.h>",
      "#include <linux/mutex.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [
      "#define BTRFSIC_BLOCK_STACK_FRAME_MAGIC_NUMBER 20111300"
    ],
    "globals_used": [
      "static void btrfsic_block_link_init(struct btrfsic_block_link *n);",
      "static void btrfsic_block_link_free(struct btrfsic_block_link *n);",
      "static struct btrfsic_stack_frame *btrfsic_stack_frame_alloc(void);",
      "static void btrfsic_stack_frame_free(struct btrfsic_stack_frame *sf);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_INFO \"btrfsic: alloc memory failed!\\n\""
          ],
          "line": 961
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*sf)",
            "GFP_NOFS"
          ],
          "line": 959
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"extent_io.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n#include <linux/blkdev.h>\n#include <linux/genhd.h>\n#include <linux/mutex.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\n#define BTRFSIC_BLOCK_STACK_FRAME_MAGIC_NUMBER 20111300\n\nstatic void btrfsic_block_link_init(struct btrfsic_block_link *n);\nstatic void btrfsic_block_link_free(struct btrfsic_block_link *n);\nstatic struct btrfsic_stack_frame *btrfsic_stack_frame_alloc(void);\nstatic void btrfsic_stack_frame_free(struct btrfsic_stack_frame *sf);\n\nstatic struct btrfsic_stack_frame *btrfsic_stack_frame_alloc(void)\n{\n\tstruct btrfsic_stack_frame *sf;\n\n\tsf = kzalloc(sizeof(*sf), GFP_NOFS);\n\tif (NULL == sf)\n\t\tprintk(KERN_INFO \"btrfsic: alloc memory failed!\\n\");\n\telse\n\t\tsf->magic = BTRFSIC_BLOCK_STACK_FRAME_MAGIC_NUMBER;\n\treturn sf;\n}"
  },
  {
    "function_name": "btrfsic_process_superblock_dev_mirror",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/check-integrity.c",
    "lines": "791-953",
    "snippet": "static int btrfsic_process_superblock_dev_mirror(\n\t\tstruct btrfsic_state *state,\n\t\tstruct btrfsic_dev_state *dev_state,\n\t\tstruct btrfs_device *device,\n\t\tint superblock_mirror_num,\n\t\tstruct btrfsic_dev_state **selected_dev_state,\n\t\tstruct btrfs_super_block *selected_super)\n{\n\tstruct btrfs_super_block *super_tmp;\n\tu64 dev_bytenr;\n\tstruct buffer_head *bh;\n\tstruct btrfsic_block *superblock_tmp;\n\tint pass;\n\tstruct block_device *const superblock_bdev = device->bdev;\n\n\t/* super block bytenr is always the unmapped device bytenr */\n\tdev_bytenr = btrfs_sb_offset(superblock_mirror_num);\n\tif (dev_bytenr + BTRFS_SUPER_INFO_SIZE > device->commit_total_bytes)\n\t\treturn -1;\n\tbh = __bread(superblock_bdev, dev_bytenr / 4096,\n\t\t     BTRFS_SUPER_INFO_SIZE);\n\tif (NULL == bh)\n\t\treturn -1;\n\tsuper_tmp = (struct btrfs_super_block *)\n\t    (bh->b_data + (dev_bytenr & 4095));\n\n\tif (btrfs_super_bytenr(super_tmp) != dev_bytenr ||\n\t    btrfs_super_magic(super_tmp) != BTRFS_MAGIC ||\n\t    memcmp(device->uuid, super_tmp->dev_item.uuid, BTRFS_UUID_SIZE) ||\n\t    btrfs_super_nodesize(super_tmp) != state->metablock_size ||\n\t    btrfs_super_sectorsize(super_tmp) != state->datablock_size) {\n\t\tbrelse(bh);\n\t\treturn 0;\n\t}\n\n\tsuperblock_tmp =\n\t    btrfsic_block_hashtable_lookup(superblock_bdev,\n\t\t\t\t\t   dev_bytenr,\n\t\t\t\t\t   &state->block_hashtable);\n\tif (NULL == superblock_tmp) {\n\t\tsuperblock_tmp = btrfsic_block_alloc();\n\t\tif (NULL == superblock_tmp) {\n\t\t\tprintk(KERN_INFO \"btrfsic: error, kmalloc failed!\\n\");\n\t\t\tbrelse(bh);\n\t\t\treturn -1;\n\t\t}\n\t\t/* for superblock, only the dev_bytenr makes sense */\n\t\tsuperblock_tmp->dev_bytenr = dev_bytenr;\n\t\tsuperblock_tmp->dev_state = dev_state;\n\t\tsuperblock_tmp->logical_bytenr = dev_bytenr;\n\t\tsuperblock_tmp->generation = btrfs_super_generation(super_tmp);\n\t\tsuperblock_tmp->is_metadata = 1;\n\t\tsuperblock_tmp->is_superblock = 1;\n\t\tsuperblock_tmp->is_iodone = 1;\n\t\tsuperblock_tmp->never_written = 0;\n\t\tsuperblock_tmp->mirror_num = 1 + superblock_mirror_num;\n\t\tif (state->print_mask & BTRFSIC_PRINT_MASK_SUPERBLOCK_WRITE)\n\t\t\tprintk_in_rcu(KERN_INFO \"New initial S-block (bdev %p, %s)\"\n\t\t\t\t     \" @%llu (%s/%llu/%d)\\n\",\n\t\t\t\t     superblock_bdev,\n\t\t\t\t     rcu_str_deref(device->name), dev_bytenr,\n\t\t\t\t     dev_state->name, dev_bytenr,\n\t\t\t\t     superblock_mirror_num);\n\t\tlist_add(&superblock_tmp->all_blocks_node,\n\t\t\t &state->all_blocks_list);\n\t\tbtrfsic_block_hashtable_add(superblock_tmp,\n\t\t\t\t\t    &state->block_hashtable);\n\t}\n\n\t/* select the one with the highest generation field */\n\tif (btrfs_super_generation(super_tmp) >\n\t    state->max_superblock_generation ||\n\t    0 == state->max_superblock_generation) {\n\t\tmemcpy(selected_super, super_tmp, sizeof(*selected_super));\n\t\t*selected_dev_state = dev_state;\n\t\tstate->max_superblock_generation =\n\t\t    btrfs_super_generation(super_tmp);\n\t\tstate->latest_superblock = superblock_tmp;\n\t}\n\n\tfor (pass = 0; pass < 3; pass++) {\n\t\tu64 next_bytenr;\n\t\tint num_copies;\n\t\tint mirror_num;\n\t\tconst char *additional_string = NULL;\n\t\tstruct btrfs_disk_key tmp_disk_key;\n\n\t\ttmp_disk_key.type = BTRFS_ROOT_ITEM_KEY;\n\t\ttmp_disk_key.offset = 0;\n\t\tswitch (pass) {\n\t\tcase 0:\n\t\t\tbtrfs_set_disk_key_objectid(&tmp_disk_key,\n\t\t\t\t\t\t    BTRFS_ROOT_TREE_OBJECTID);\n\t\t\tadditional_string = \"initial root \";\n\t\t\tnext_bytenr = btrfs_super_root(super_tmp);\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tbtrfs_set_disk_key_objectid(&tmp_disk_key,\n\t\t\t\t\t\t    BTRFS_CHUNK_TREE_OBJECTID);\n\t\t\tadditional_string = \"initial chunk \";\n\t\t\tnext_bytenr = btrfs_super_chunk_root(super_tmp);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tbtrfs_set_disk_key_objectid(&tmp_disk_key,\n\t\t\t\t\t\t    BTRFS_TREE_LOG_OBJECTID);\n\t\t\tadditional_string = \"initial log \";\n\t\t\tnext_bytenr = btrfs_super_log_root(super_tmp);\n\t\t\tif (0 == next_bytenr)\n\t\t\t\tcontinue;\n\t\t\tbreak;\n\t\t}\n\n\t\tnum_copies =\n\t\t    btrfs_num_copies(state->root->fs_info,\n\t\t\t\t     next_bytenr, state->metablock_size);\n\t\tif (state->print_mask & BTRFSIC_PRINT_MASK_NUM_COPIES)\n\t\t\tprintk(KERN_INFO \"num_copies(log_bytenr=%llu) = %d\\n\",\n\t\t\t       next_bytenr, num_copies);\n\t\tfor (mirror_num = 1; mirror_num <= num_copies; mirror_num++) {\n\t\t\tstruct btrfsic_block *next_block;\n\t\t\tstruct btrfsic_block_data_ctx tmp_next_block_ctx;\n\t\t\tstruct btrfsic_block_link *l;\n\n\t\t\tif (btrfsic_map_block(state, next_bytenr,\n\t\t\t\t\t      state->metablock_size,\n\t\t\t\t\t      &tmp_next_block_ctx,\n\t\t\t\t\t      mirror_num)) {\n\t\t\t\tprintk(KERN_INFO \"btrfsic: btrfsic_map_block(\"\n\t\t\t\t       \"bytenr @%llu, mirror %d) failed!\\n\",\n\t\t\t\t       next_bytenr, mirror_num);\n\t\t\t\tbrelse(bh);\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tnext_block = btrfsic_block_lookup_or_add(\n\t\t\t\t\tstate, &tmp_next_block_ctx,\n\t\t\t\t\tadditional_string, 1, 1, 0,\n\t\t\t\t\tmirror_num, NULL);\n\t\t\tif (NULL == next_block) {\n\t\t\t\tbtrfsic_release_block_ctx(&tmp_next_block_ctx);\n\t\t\t\tbrelse(bh);\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tnext_block->disk_key = tmp_disk_key;\n\t\t\tnext_block->generation = BTRFSIC_GENERATION_UNKNOWN;\n\t\t\tl = btrfsic_block_link_lookup_or_add(\n\t\t\t\t\tstate, &tmp_next_block_ctx,\n\t\t\t\t\tnext_block, superblock_tmp,\n\t\t\t\t\tBTRFSIC_GENERATION_UNKNOWN);\n\t\t\tbtrfsic_release_block_ctx(&tmp_next_block_ctx);\n\t\t\tif (NULL == l) {\n\t\t\t\tbrelse(bh);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\tif (state->print_mask & BTRFSIC_PRINT_MASK_INITIAL_ALL_TREES)\n\t\tbtrfsic_dump_tree_sub(state, superblock_tmp, 0);\n\n\tbrelse(bh);\n\treturn 0;\n}",
    "includes": [
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"volumes.h\"",
      "#include \"extent_io.h\"",
      "#include \"transaction.h\"",
      "#include \"hash.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/genhd.h>",
      "#include <linux/mutex.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [
      "#define BTRFSIC_PRINT_MASK_NUM_COPIES\t\t\t\t0x00000800",
      "#define BTRFSIC_PRINT_MASK_INITIAL_ALL_TREES\t\t\t0x00000200",
      "#define BTRFSIC_PRINT_MASK_SUPERBLOCK_WRITE\t\t\t0x00000001",
      "#define BTRFSIC_GENERATION_UNKNOWN ((u64)-1)"
    ],
    "globals_used": [
      "static struct btrfsic_block *btrfsic_block_alloc(void);",
      "static void btrfsic_block_link_init(struct btrfsic_block_link *n);",
      "static void btrfsic_block_link_free(struct btrfsic_block_link *n);",
      "static void btrfsic_block_link_hashtable_remove(struct btrfsic_block_link *l);",
      "static int btrfsic_map_block(struct btrfsic_state *state, u64 bytenr, u32 len,\n\t\t\t     struct btrfsic_block_data_ctx *block_ctx_out,\n\t\t\t     int mirror_num);",
      "static void btrfsic_dump_database(struct btrfsic_state *state);",
      "static void btrfsic_print_add_link(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block_link *l);",
      "static void btrfsic_print_rem_link(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block_link *l);",
      "static char btrfsic_get_block_type(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block *block);",
      "static void btrfsic_dump_tree(const struct btrfsic_state *state);",
      "static int btrfsic_process_superblock_dev_mirror(\n\t\tstruct btrfsic_state *state,\n\t\tstruct btrfsic_dev_state *dev_state,\n\t\tstruct btrfs_device *device,\n\t\tint superblock_mirror_num,\n\t\tstruct btrfsic_dev_state **selected_dev_state,\n\t\tstruct btrfs_super_block *selected_super);",
      "static struct btrfsic_dev_state *btrfsic_dev_state_lookup(\n\t\tstruct block_device *bdev);",
      "static void btrfsic_cmp_log_and_dev_bytenr(struct btrfsic_state *state,\n\t\t\t\t\t   u64 bytenr,\n\t\t\t\t\t   struct btrfsic_dev_state *dev_state,\n\t\t\t\t\t   u64 dev_bytenr);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 951
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfsic_dump_tree_sub",
          "args": [
            "state",
            "superblock_tmp",
            "0"
          ],
          "line": 949
        },
        "resolved": true,
        "details": {
          "function_name": "btrfsic_dump_tree_sub",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/check-integrity.c",
          "lines": "2668-2733",
          "snippet": "static void btrfsic_dump_tree_sub(const struct btrfsic_state *state,\n\t\t\t\t  const struct btrfsic_block *block,\n\t\t\t\t  int indent_level)\n{\n\tstruct list_head *elem_ref_to;\n\tint indent_add;\n\tstatic char buf[80];\n\tint cursor_position;\n\n\t/*\n\t * Should better fill an on-stack buffer with a complete line and\n\t * dump it at once when it is time to print a newline character.\n\t */\n\n\t/*\n\t * This algorithm is recursive because the amount of used stack space\n\t * is very small and the max recursion depth is limited.\n\t */\n\tindent_add = sprintf(buf, \"%c-%llu(%s/%llu/%d)\",\n\t\t\t     btrfsic_get_block_type(state, block),\n\t\t\t     block->logical_bytenr, block->dev_state->name,\n\t\t\t     block->dev_bytenr, block->mirror_num);\n\tif (indent_level + indent_add > BTRFSIC_TREE_DUMP_MAX_INDENT_LEVEL) {\n\t\tprintk(\"[...]\\n\");\n\t\treturn;\n\t}\n\tprintk(buf);\n\tindent_level += indent_add;\n\tif (list_empty(&block->ref_to_list)) {\n\t\tprintk(\"\\n\");\n\t\treturn;\n\t}\n\tif (block->mirror_num > 1 &&\n\t    !(state->print_mask & BTRFSIC_PRINT_MASK_TREE_WITH_ALL_MIRRORS)) {\n\t\tprintk(\" [...]\\n\");\n\t\treturn;\n\t}\n\n\tcursor_position = indent_level;\n\tlist_for_each(elem_ref_to, &block->ref_to_list) {\n\t\tconst struct btrfsic_block_link *const l =\n\t\t    list_entry(elem_ref_to, struct btrfsic_block_link,\n\t\t\t       node_ref_to);\n\n\t\twhile (cursor_position < indent_level) {\n\t\t\tprintk(\" \");\n\t\t\tcursor_position++;\n\t\t}\n\t\tif (l->ref_cnt > 1)\n\t\t\tindent_add = sprintf(buf, \" %d*--> \", l->ref_cnt);\n\t\telse\n\t\t\tindent_add = sprintf(buf, \" --> \");\n\t\tif (indent_level + indent_add >\n\t\t    BTRFSIC_TREE_DUMP_MAX_INDENT_LEVEL) {\n\t\t\tprintk(\"[...]\\n\");\n\t\t\tcursor_position = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\tprintk(buf);\n\n\t\tbtrfsic_dump_tree_sub(state, l->block_ref_to,\n\t\t\t\t      indent_level + indent_add);\n\t\tcursor_position = 0;\n\t}\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"extent_io.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/genhd.h>",
            "#include <linux/mutex.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define BTRFSIC_PRINT_MASK_TREE_WITH_ALL_MIRRORS\t\t0x00001000",
            "#define BTRFSIC_TREE_DUMP_MAX_INDENT_LEVEL (200 - 6)\t/* in characters,\n\t\t\t\t\t\t\t * excluding \" [...]\" */"
          ],
          "globals_used": [
            "static void btrfsic_block_link_init(struct btrfsic_block_link *n);",
            "static void btrfsic_block_link_free(struct btrfsic_block_link *n);",
            "static void btrfsic_block_link_hashtable_remove(struct btrfsic_block_link *l);",
            "static int btrfsic_map_block(struct btrfsic_state *state, u64 bytenr, u32 len,\n\t\t\t     struct btrfsic_block_data_ctx *block_ctx_out,\n\t\t\t     int mirror_num);",
            "static void btrfsic_dump_database(struct btrfsic_state *state);",
            "static void btrfsic_print_add_link(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block_link *l);",
            "static void btrfsic_print_rem_link(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block_link *l);",
            "static char btrfsic_get_block_type(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block *block);",
            "static void btrfsic_dump_tree(const struct btrfsic_state *state);",
            "static void btrfsic_dump_tree_sub(const struct btrfsic_state *state,\n\t\t\t\t  const struct btrfsic_block *block,\n\t\t\t\t  int indent_level);",
            "static void btrfsic_cmp_log_and_dev_bytenr(struct btrfsic_state *state,\n\t\t\t\t\t   u64 bytenr,\n\t\t\t\t\t   struct btrfsic_dev_state *dev_state,\n\t\t\t\t\t   u64 dev_bytenr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"extent_io.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n#include <linux/blkdev.h>\n#include <linux/genhd.h>\n#include <linux/mutex.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\n#define BTRFSIC_PRINT_MASK_TREE_WITH_ALL_MIRRORS\t\t0x00001000\n#define BTRFSIC_TREE_DUMP_MAX_INDENT_LEVEL (200 - 6)\t/* in characters,\n\t\t\t\t\t\t\t * excluding \" [...]\" */\n\nstatic void btrfsic_block_link_init(struct btrfsic_block_link *n);\nstatic void btrfsic_block_link_free(struct btrfsic_block_link *n);\nstatic void btrfsic_block_link_hashtable_remove(struct btrfsic_block_link *l);\nstatic int btrfsic_map_block(struct btrfsic_state *state, u64 bytenr, u32 len,\n\t\t\t     struct btrfsic_block_data_ctx *block_ctx_out,\n\t\t\t     int mirror_num);\nstatic void btrfsic_dump_database(struct btrfsic_state *state);\nstatic void btrfsic_print_add_link(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block_link *l);\nstatic void btrfsic_print_rem_link(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block_link *l);\nstatic char btrfsic_get_block_type(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block *block);\nstatic void btrfsic_dump_tree(const struct btrfsic_state *state);\nstatic void btrfsic_dump_tree_sub(const struct btrfsic_state *state,\n\t\t\t\t  const struct btrfsic_block *block,\n\t\t\t\t  int indent_level);\nstatic void btrfsic_cmp_log_and_dev_bytenr(struct btrfsic_state *state,\n\t\t\t\t\t   u64 bytenr,\n\t\t\t\t\t   struct btrfsic_dev_state *dev_state,\n\t\t\t\t\t   u64 dev_bytenr);\n\nstatic void btrfsic_dump_tree_sub(const struct btrfsic_state *state,\n\t\t\t\t  const struct btrfsic_block *block,\n\t\t\t\t  int indent_level)\n{\n\tstruct list_head *elem_ref_to;\n\tint indent_add;\n\tstatic char buf[80];\n\tint cursor_position;\n\n\t/*\n\t * Should better fill an on-stack buffer with a complete line and\n\t * dump it at once when it is time to print a newline character.\n\t */\n\n\t/*\n\t * This algorithm is recursive because the amount of used stack space\n\t * is very small and the max recursion depth is limited.\n\t */\n\tindent_add = sprintf(buf, \"%c-%llu(%s/%llu/%d)\",\n\t\t\t     btrfsic_get_block_type(state, block),\n\t\t\t     block->logical_bytenr, block->dev_state->name,\n\t\t\t     block->dev_bytenr, block->mirror_num);\n\tif (indent_level + indent_add > BTRFSIC_TREE_DUMP_MAX_INDENT_LEVEL) {\n\t\tprintk(\"[...]\\n\");\n\t\treturn;\n\t}\n\tprintk(buf);\n\tindent_level += indent_add;\n\tif (list_empty(&block->ref_to_list)) {\n\t\tprintk(\"\\n\");\n\t\treturn;\n\t}\n\tif (block->mirror_num > 1 &&\n\t    !(state->print_mask & BTRFSIC_PRINT_MASK_TREE_WITH_ALL_MIRRORS)) {\n\t\tprintk(\" [...]\\n\");\n\t\treturn;\n\t}\n\n\tcursor_position = indent_level;\n\tlist_for_each(elem_ref_to, &block->ref_to_list) {\n\t\tconst struct btrfsic_block_link *const l =\n\t\t    list_entry(elem_ref_to, struct btrfsic_block_link,\n\t\t\t       node_ref_to);\n\n\t\twhile (cursor_position < indent_level) {\n\t\t\tprintk(\" \");\n\t\t\tcursor_position++;\n\t\t}\n\t\tif (l->ref_cnt > 1)\n\t\t\tindent_add = sprintf(buf, \" %d*--> \", l->ref_cnt);\n\t\telse\n\t\t\tindent_add = sprintf(buf, \" --> \");\n\t\tif (indent_level + indent_add >\n\t\t    BTRFSIC_TREE_DUMP_MAX_INDENT_LEVEL) {\n\t\t\tprintk(\"[...]\\n\");\n\t\t\tcursor_position = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\tprintk(buf);\n\n\t\tbtrfsic_dump_tree_sub(state, l->block_ref_to,\n\t\t\t\t      indent_level + indent_add);\n\t\tcursor_position = 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfsic_release_block_ctx",
          "args": [
            "&tmp_next_block_ctx"
          ],
          "line": 941
        },
        "resolved": true,
        "details": {
          "function_name": "btrfsic_release_block_ctx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/check-integrity.c",
          "lines": "1611-1637",
          "snippet": "static void btrfsic_release_block_ctx(struct btrfsic_block_data_ctx *block_ctx)\n{\n\tif (block_ctx->mem_to_free) {\n\t\tunsigned int num_pages;\n\n\t\tBUG_ON(!block_ctx->datav);\n\t\tBUG_ON(!block_ctx->pagev);\n\t\tnum_pages = (block_ctx->len + (u64)PAGE_CACHE_SIZE - 1) >>\n\t\t\t    PAGE_CACHE_SHIFT;\n\t\twhile (num_pages > 0) {\n\t\t\tnum_pages--;\n\t\t\tif (block_ctx->datav[num_pages]) {\n\t\t\t\tkunmap(block_ctx->pagev[num_pages]);\n\t\t\t\tblock_ctx->datav[num_pages] = NULL;\n\t\t\t}\n\t\t\tif (block_ctx->pagev[num_pages]) {\n\t\t\t\t__free_page(block_ctx->pagev[num_pages]);\n\t\t\t\tblock_ctx->pagev[num_pages] = NULL;\n\t\t\t}\n\t\t}\n\n\t\tkfree(block_ctx->mem_to_free);\n\t\tblock_ctx->mem_to_free = NULL;\n\t\tblock_ctx->pagev = NULL;\n\t\tblock_ctx->datav = NULL;\n\t}\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"extent_io.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/genhd.h>",
            "#include <linux/mutex.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void btrfsic_read_from_block_data(\n\tstruct btrfsic_block_data_ctx *block_ctx,\n\tvoid *dst, u32 offset, size_t len);",
            "static void btrfsic_release_block_ctx(struct btrfsic_block_data_ctx *block_ctx);",
            "static int btrfsic_read_block(struct btrfsic_state *state,\n\t\t\t      struct btrfsic_block_data_ctx *block_ctx);",
            "static int btrfsic_test_for_metadata(struct btrfsic_state *state,\n\t\t\t\t     char **datav, unsigned int num_pages);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"extent_io.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n#include <linux/blkdev.h>\n#include <linux/genhd.h>\n#include <linux/mutex.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic void btrfsic_read_from_block_data(\n\tstruct btrfsic_block_data_ctx *block_ctx,\n\tvoid *dst, u32 offset, size_t len);\nstatic void btrfsic_release_block_ctx(struct btrfsic_block_data_ctx *block_ctx);\nstatic int btrfsic_read_block(struct btrfsic_state *state,\n\t\t\t      struct btrfsic_block_data_ctx *block_ctx);\nstatic int btrfsic_test_for_metadata(struct btrfsic_state *state,\n\t\t\t\t     char **datav, unsigned int num_pages);\n\nstatic void btrfsic_release_block_ctx(struct btrfsic_block_data_ctx *block_ctx)\n{\n\tif (block_ctx->mem_to_free) {\n\t\tunsigned int num_pages;\n\n\t\tBUG_ON(!block_ctx->datav);\n\t\tBUG_ON(!block_ctx->pagev);\n\t\tnum_pages = (block_ctx->len + (u64)PAGE_CACHE_SIZE - 1) >>\n\t\t\t    PAGE_CACHE_SHIFT;\n\t\twhile (num_pages > 0) {\n\t\t\tnum_pages--;\n\t\t\tif (block_ctx->datav[num_pages]) {\n\t\t\t\tkunmap(block_ctx->pagev[num_pages]);\n\t\t\t\tblock_ctx->datav[num_pages] = NULL;\n\t\t\t}\n\t\t\tif (block_ctx->pagev[num_pages]) {\n\t\t\t\t__free_page(block_ctx->pagev[num_pages]);\n\t\t\t\tblock_ctx->pagev[num_pages] = NULL;\n\t\t\t}\n\t\t}\n\n\t\tkfree(block_ctx->mem_to_free);\n\t\tblock_ctx->mem_to_free = NULL;\n\t\tblock_ctx->pagev = NULL;\n\t\tblock_ctx->datav = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfsic_block_link_lookup_or_add",
          "args": [
            "state",
            "&tmp_next_block_ctx",
            "next_block",
            "superblock_tmp",
            "BTRFSIC_GENERATION_UNKNOWN"
          ],
          "line": 937
        },
        "resolved": true,
        "details": {
          "function_name": "btrfsic_block_link_lookup_or_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/check-integrity.c",
          "lines": "2735-2778",
          "snippet": "static struct btrfsic_block_link *btrfsic_block_link_lookup_or_add(\n\t\tstruct btrfsic_state *state,\n\t\tstruct btrfsic_block_data_ctx *next_block_ctx,\n\t\tstruct btrfsic_block *next_block,\n\t\tstruct btrfsic_block *from_block,\n\t\tu64 parent_generation)\n{\n\tstruct btrfsic_block_link *l;\n\n\tl = btrfsic_block_link_hashtable_lookup(next_block_ctx->dev->bdev,\n\t\t\t\t\t\tnext_block_ctx->dev_bytenr,\n\t\t\t\t\t\tfrom_block->dev_state->bdev,\n\t\t\t\t\t\tfrom_block->dev_bytenr,\n\t\t\t\t\t\t&state->block_link_hashtable);\n\tif (NULL == l) {\n\t\tl = btrfsic_block_link_alloc();\n\t\tif (NULL == l) {\n\t\t\tprintk(KERN_INFO\n\t\t\t       \"btrfsic: error, kmalloc\" \" failed!\\n\");\n\t\t\treturn NULL;\n\t\t}\n\n\t\tl->block_ref_to = next_block;\n\t\tl->block_ref_from = from_block;\n\t\tl->ref_cnt = 1;\n\t\tl->parent_generation = parent_generation;\n\n\t\tif (state->print_mask & BTRFSIC_PRINT_MASK_VERBOSE)\n\t\t\tbtrfsic_print_add_link(state, l);\n\n\t\tlist_add(&l->node_ref_to, &from_block->ref_to_list);\n\t\tlist_add(&l->node_ref_from, &next_block->ref_from_list);\n\n\t\tbtrfsic_block_link_hashtable_add(l,\n\t\t\t\t\t\t &state->block_link_hashtable);\n\t} else {\n\t\tl->ref_cnt++;\n\t\tl->parent_generation = parent_generation;\n\t\tif (state->print_mask & BTRFSIC_PRINT_MASK_VERBOSE)\n\t\t\tbtrfsic_print_add_link(state, l);\n\t}\n\n\treturn l;\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"extent_io.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/genhd.h>",
            "#include <linux/mutex.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define BTRFSIC_PRINT_MASK_VERBOSE\t\t\t\t0x00000040"
          ],
          "globals_used": [
            "static void btrfsic_block_link_init(struct btrfsic_block_link *n);",
            "static struct btrfsic_block_link *btrfsic_block_link_alloc(void);",
            "static void btrfsic_block_link_free(struct btrfsic_block_link *n);",
            "static void btrfsic_block_link_hashtable_remove(struct btrfsic_block_link *l);",
            "static int btrfsic_create_link_to_next_block(\n\t\tstruct btrfsic_state *state,\n\t\tstruct btrfsic_block *block,\n\t\tstruct btrfsic_block_data_ctx\n\t\t*block_ctx, u64 next_bytenr,\n\t\tint limit_nesting,\n\t\tstruct btrfsic_block_data_ctx *next_block_ctx,\n\t\tstruct btrfsic_block **next_blockp,\n\t\tint force_iodone_flag,\n\t\tint *num_copiesp, int *mirror_nump,\n\t\tstruct btrfs_disk_key *disk_key,\n\t\tu64 parent_generation);",
            "static void btrfsic_dump_database(struct btrfsic_state *state);",
            "static void btrfsic_print_add_link(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block_link *l);",
            "static void btrfsic_print_rem_link(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block_link *l);",
            "static void btrfsic_dump_tree(const struct btrfsic_state *state);",
            "static struct btrfsic_block_link *btrfsic_block_link_lookup_or_add(\n\t\tstruct btrfsic_state *state,\n\t\tstruct btrfsic_block_data_ctx *next_block_ctx,\n\t\tstruct btrfsic_block *next_block,\n\t\tstruct btrfsic_block *from_block,\n\t\tu64 parent_generation);",
            "static struct btrfsic_dev_state *btrfsic_dev_state_lookup(\n\t\tstruct block_device *bdev);",
            "static void btrfsic_cmp_log_and_dev_bytenr(struct btrfsic_state *state,\n\t\t\t\t\t   u64 bytenr,\n\t\t\t\t\t   struct btrfsic_dev_state *dev_state,\n\t\t\t\t\t   u64 dev_bytenr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"extent_io.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n#include <linux/blkdev.h>\n#include <linux/genhd.h>\n#include <linux/mutex.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\n#define BTRFSIC_PRINT_MASK_VERBOSE\t\t\t\t0x00000040\n\nstatic void btrfsic_block_link_init(struct btrfsic_block_link *n);\nstatic struct btrfsic_block_link *btrfsic_block_link_alloc(void);\nstatic void btrfsic_block_link_free(struct btrfsic_block_link *n);\nstatic void btrfsic_block_link_hashtable_remove(struct btrfsic_block_link *l);\nstatic int btrfsic_create_link_to_next_block(\n\t\tstruct btrfsic_state *state,\n\t\tstruct btrfsic_block *block,\n\t\tstruct btrfsic_block_data_ctx\n\t\t*block_ctx, u64 next_bytenr,\n\t\tint limit_nesting,\n\t\tstruct btrfsic_block_data_ctx *next_block_ctx,\n\t\tstruct btrfsic_block **next_blockp,\n\t\tint force_iodone_flag,\n\t\tint *num_copiesp, int *mirror_nump,\n\t\tstruct btrfs_disk_key *disk_key,\n\t\tu64 parent_generation);\nstatic void btrfsic_dump_database(struct btrfsic_state *state);\nstatic void btrfsic_print_add_link(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block_link *l);\nstatic void btrfsic_print_rem_link(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block_link *l);\nstatic void btrfsic_dump_tree(const struct btrfsic_state *state);\nstatic struct btrfsic_block_link *btrfsic_block_link_lookup_or_add(\n\t\tstruct btrfsic_state *state,\n\t\tstruct btrfsic_block_data_ctx *next_block_ctx,\n\t\tstruct btrfsic_block *next_block,\n\t\tstruct btrfsic_block *from_block,\n\t\tu64 parent_generation);\nstatic struct btrfsic_dev_state *btrfsic_dev_state_lookup(\n\t\tstruct block_device *bdev);\nstatic void btrfsic_cmp_log_and_dev_bytenr(struct btrfsic_state *state,\n\t\t\t\t\t   u64 bytenr,\n\t\t\t\t\t   struct btrfsic_dev_state *dev_state,\n\t\t\t\t\t   u64 dev_bytenr);\n\nstatic struct btrfsic_block_link *btrfsic_block_link_lookup_or_add(\n\t\tstruct btrfsic_state *state,\n\t\tstruct btrfsic_block_data_ctx *next_block_ctx,\n\t\tstruct btrfsic_block *next_block,\n\t\tstruct btrfsic_block *from_block,\n\t\tu64 parent_generation)\n{\n\tstruct btrfsic_block_link *l;\n\n\tl = btrfsic_block_link_hashtable_lookup(next_block_ctx->dev->bdev,\n\t\t\t\t\t\tnext_block_ctx->dev_bytenr,\n\t\t\t\t\t\tfrom_block->dev_state->bdev,\n\t\t\t\t\t\tfrom_block->dev_bytenr,\n\t\t\t\t\t\t&state->block_link_hashtable);\n\tif (NULL == l) {\n\t\tl = btrfsic_block_link_alloc();\n\t\tif (NULL == l) {\n\t\t\tprintk(KERN_INFO\n\t\t\t       \"btrfsic: error, kmalloc\" \" failed!\\n\");\n\t\t\treturn NULL;\n\t\t}\n\n\t\tl->block_ref_to = next_block;\n\t\tl->block_ref_from = from_block;\n\t\tl->ref_cnt = 1;\n\t\tl->parent_generation = parent_generation;\n\n\t\tif (state->print_mask & BTRFSIC_PRINT_MASK_VERBOSE)\n\t\t\tbtrfsic_print_add_link(state, l);\n\n\t\tlist_add(&l->node_ref_to, &from_block->ref_to_list);\n\t\tlist_add(&l->node_ref_from, &next_block->ref_from_list);\n\n\t\tbtrfsic_block_link_hashtable_add(l,\n\t\t\t\t\t\t &state->block_link_hashtable);\n\t} else {\n\t\tl->ref_cnt++;\n\t\tl->parent_generation = parent_generation;\n\t\tif (state->print_mask & BTRFSIC_PRINT_MASK_VERBOSE)\n\t\t\tbtrfsic_print_add_link(state, l);\n\t}\n\n\treturn l;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfsic_block_lookup_or_add",
          "args": [
            "state",
            "&tmp_next_block_ctx",
            "additional_string",
            "1",
            "1",
            "0",
            "mirror_num",
            "NULL"
          ],
          "line": 925
        },
        "resolved": true,
        "details": {
          "function_name": "btrfsic_block_lookup_or_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/check-integrity.c",
          "lines": "2780-2834",
          "snippet": "static struct btrfsic_block *btrfsic_block_lookup_or_add(\n\t\tstruct btrfsic_state *state,\n\t\tstruct btrfsic_block_data_ctx *block_ctx,\n\t\tconst char *additional_string,\n\t\tint is_metadata,\n\t\tint is_iodone,\n\t\tint never_written,\n\t\tint mirror_num,\n\t\tint *was_created)\n{\n\tstruct btrfsic_block *block;\n\n\tblock = btrfsic_block_hashtable_lookup(block_ctx->dev->bdev,\n\t\t\t\t\t       block_ctx->dev_bytenr,\n\t\t\t\t\t       &state->block_hashtable);\n\tif (NULL == block) {\n\t\tstruct btrfsic_dev_state *dev_state;\n\n\t\tblock = btrfsic_block_alloc();\n\t\tif (NULL == block) {\n\t\t\tprintk(KERN_INFO \"btrfsic: error, kmalloc failed!\\n\");\n\t\t\treturn NULL;\n\t\t}\n\t\tdev_state = btrfsic_dev_state_lookup(block_ctx->dev->bdev);\n\t\tif (NULL == dev_state) {\n\t\t\tprintk(KERN_INFO\n\t\t\t       \"btrfsic: error, lookup dev_state failed!\\n\");\n\t\t\tbtrfsic_block_free(block);\n\t\t\treturn NULL;\n\t\t}\n\t\tblock->dev_state = dev_state;\n\t\tblock->dev_bytenr = block_ctx->dev_bytenr;\n\t\tblock->logical_bytenr = block_ctx->start;\n\t\tblock->is_metadata = is_metadata;\n\t\tblock->is_iodone = is_iodone;\n\t\tblock->never_written = never_written;\n\t\tblock->mirror_num = mirror_num;\n\t\tif (state->print_mask & BTRFSIC_PRINT_MASK_VERBOSE)\n\t\t\tprintk(KERN_INFO\n\t\t\t       \"New %s%c-block @%llu (%s/%llu/%d)\\n\",\n\t\t\t       additional_string,\n\t\t\t       btrfsic_get_block_type(state, block),\n\t\t\t       block->logical_bytenr, dev_state->name,\n\t\t\t       block->dev_bytenr, mirror_num);\n\t\tlist_add(&block->all_blocks_node, &state->all_blocks_list);\n\t\tbtrfsic_block_hashtable_add(block, &state->block_hashtable);\n\t\tif (NULL != was_created)\n\t\t\t*was_created = 1;\n\t} else {\n\t\tif (NULL != was_created)\n\t\t\t*was_created = 0;\n\t}\n\n\treturn block;\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"extent_io.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/genhd.h>",
            "#include <linux/mutex.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define BTRFSIC_PRINT_MASK_VERBOSE\t\t\t\t0x00000040"
          ],
          "globals_used": [
            "static struct btrfsic_block *btrfsic_block_alloc(void);",
            "static void btrfsic_block_link_init(struct btrfsic_block_link *n);",
            "static void btrfsic_block_link_free(struct btrfsic_block_link *n);",
            "static int btrfsic_map_block(struct btrfsic_state *state, u64 bytenr, u32 len,\n\t\t\t     struct btrfsic_block_data_ctx *block_ctx_out,\n\t\t\t     int mirror_num);",
            "static void btrfsic_release_block_ctx(struct btrfsic_block_data_ctx *block_ctx);",
            "static int btrfsic_read_block(struct btrfsic_state *state,\n\t\t\t      struct btrfsic_block_data_ctx *block_ctx);",
            "static void btrfsic_dump_database(struct btrfsic_state *state);",
            "static char btrfsic_get_block_type(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block *block);",
            "static void btrfsic_dump_tree(const struct btrfsic_state *state);",
            "static struct btrfsic_block *btrfsic_block_lookup_or_add(\n\t\tstruct btrfsic_state *state,\n\t\tstruct btrfsic_block_data_ctx *block_ctx,\n\t\tconst char *additional_string,\n\t\tint is_metadata,\n\t\tint is_iodone,\n\t\tint never_written,\n\t\tint mirror_num,\n\t\tint *was_created);",
            "static struct btrfsic_dev_state *btrfsic_dev_state_lookup(\n\t\tstruct block_device *bdev);",
            "static void btrfsic_cmp_log_and_dev_bytenr(struct btrfsic_state *state,\n\t\t\t\t\t   u64 bytenr,\n\t\t\t\t\t   struct btrfsic_dev_state *dev_state,\n\t\t\t\t\t   u64 dev_bytenr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"extent_io.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n#include <linux/blkdev.h>\n#include <linux/genhd.h>\n#include <linux/mutex.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\n#define BTRFSIC_PRINT_MASK_VERBOSE\t\t\t\t0x00000040\n\nstatic struct btrfsic_block *btrfsic_block_alloc(void);\nstatic void btrfsic_block_link_init(struct btrfsic_block_link *n);\nstatic void btrfsic_block_link_free(struct btrfsic_block_link *n);\nstatic int btrfsic_map_block(struct btrfsic_state *state, u64 bytenr, u32 len,\n\t\t\t     struct btrfsic_block_data_ctx *block_ctx_out,\n\t\t\t     int mirror_num);\nstatic void btrfsic_release_block_ctx(struct btrfsic_block_data_ctx *block_ctx);\nstatic int btrfsic_read_block(struct btrfsic_state *state,\n\t\t\t      struct btrfsic_block_data_ctx *block_ctx);\nstatic void btrfsic_dump_database(struct btrfsic_state *state);\nstatic char btrfsic_get_block_type(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block *block);\nstatic void btrfsic_dump_tree(const struct btrfsic_state *state);\nstatic struct btrfsic_block *btrfsic_block_lookup_or_add(\n\t\tstruct btrfsic_state *state,\n\t\tstruct btrfsic_block_data_ctx *block_ctx,\n\t\tconst char *additional_string,\n\t\tint is_metadata,\n\t\tint is_iodone,\n\t\tint never_written,\n\t\tint mirror_num,\n\t\tint *was_created);\nstatic struct btrfsic_dev_state *btrfsic_dev_state_lookup(\n\t\tstruct block_device *bdev);\nstatic void btrfsic_cmp_log_and_dev_bytenr(struct btrfsic_state *state,\n\t\t\t\t\t   u64 bytenr,\n\t\t\t\t\t   struct btrfsic_dev_state *dev_state,\n\t\t\t\t\t   u64 dev_bytenr);\n\nstatic struct btrfsic_block *btrfsic_block_lookup_or_add(\n\t\tstruct btrfsic_state *state,\n\t\tstruct btrfsic_block_data_ctx *block_ctx,\n\t\tconst char *additional_string,\n\t\tint is_metadata,\n\t\tint is_iodone,\n\t\tint never_written,\n\t\tint mirror_num,\n\t\tint *was_created)\n{\n\tstruct btrfsic_block *block;\n\n\tblock = btrfsic_block_hashtable_lookup(block_ctx->dev->bdev,\n\t\t\t\t\t       block_ctx->dev_bytenr,\n\t\t\t\t\t       &state->block_hashtable);\n\tif (NULL == block) {\n\t\tstruct btrfsic_dev_state *dev_state;\n\n\t\tblock = btrfsic_block_alloc();\n\t\tif (NULL == block) {\n\t\t\tprintk(KERN_INFO \"btrfsic: error, kmalloc failed!\\n\");\n\t\t\treturn NULL;\n\t\t}\n\t\tdev_state = btrfsic_dev_state_lookup(block_ctx->dev->bdev);\n\t\tif (NULL == dev_state) {\n\t\t\tprintk(KERN_INFO\n\t\t\t       \"btrfsic: error, lookup dev_state failed!\\n\");\n\t\t\tbtrfsic_block_free(block);\n\t\t\treturn NULL;\n\t\t}\n\t\tblock->dev_state = dev_state;\n\t\tblock->dev_bytenr = block_ctx->dev_bytenr;\n\t\tblock->logical_bytenr = block_ctx->start;\n\t\tblock->is_metadata = is_metadata;\n\t\tblock->is_iodone = is_iodone;\n\t\tblock->never_written = never_written;\n\t\tblock->mirror_num = mirror_num;\n\t\tif (state->print_mask & BTRFSIC_PRINT_MASK_VERBOSE)\n\t\t\tprintk(KERN_INFO\n\t\t\t       \"New %s%c-block @%llu (%s/%llu/%d)\\n\",\n\t\t\t       additional_string,\n\t\t\t       btrfsic_get_block_type(state, block),\n\t\t\t       block->logical_bytenr, dev_state->name,\n\t\t\t       block->dev_bytenr, mirror_num);\n\t\tlist_add(&block->all_blocks_node, &state->all_blocks_list);\n\t\tbtrfsic_block_hashtable_add(block, &state->block_hashtable);\n\t\tif (NULL != was_created)\n\t\t\t*was_created = 1;\n\t} else {\n\t\tif (NULL != was_created)\n\t\t\t*was_created = 0;\n\t}\n\n\treturn block;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_INFO \"btrfsic: btrfsic_map_block(\"\n\t\t\t\t       \"bytenr @%llu, mirror %d) failed!\\n\"",
            "next_bytenr",
            "mirror_num"
          ],
          "line": 918
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/super.c",
          "lines": "186-213",
          "snippet": "void btrfs_printk(const struct btrfs_fs_info *fs_info, const char *fmt, ...)\n{\n\tstruct super_block *sb = fs_info->sb;\n\tchar lvl[4];\n\tstruct va_format vaf;\n\tva_list args;\n\tconst char *type = logtypes[4];\n\tint kern_level;\n\n\tva_start(args, fmt);\n\n\tkern_level = printk_get_level(fmt);\n\tif (kern_level) {\n\t\tsize_t size = printk_skip_level(fmt) - fmt;\n\t\tmemcpy(lvl, fmt,  size);\n\t\tlvl[size] = '\\0';\n\t\tfmt += size;\n\t\ttype = logtypes[kern_level - '0'];\n\t} else\n\t\t*lvl = '\\0';\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sBTRFS %s (device %s): %pV\\n\", lvl, type, sb->s_id, &vaf);\n\n\tva_end(args);\n}",
          "includes": [
            "#include <trace/events/btrfs.h>",
            "#include \"qgroup.h\"",
            "#include \"tests/btrfs-tests.h\"",
            "#include \"backref.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"compression.h\"",
            "#include \"export.h\"",
            "#include \"volumes.h\"",
            "#include \"xattr.h\"",
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/slab.h>",
            "#include <linux/magic.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/namei.h>",
            "#include <linux/ctype.h>",
            "#include <linux/parser.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/btrfs.h>\n#include \"qgroup.h\"\n#include \"tests/btrfs-tests.h\"\n#include \"backref.h\"\n#include \"free-space-cache.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"compression.h\"\n#include \"export.h\"\n#include \"volumes.h\"\n#include \"xattr.h\"\n#include \"props.h\"\n#include \"hash.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include \"delayed-inode.h\"\n#include <linux/btrfs.h>\n#include <linux/ratelimit.h>\n#include <linux/cleancache.h>\n#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/miscdevice.h>\n#include <linux/namei.h>\n#include <linux/ctype.h>\n#include <linux/parser.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n\nvoid btrfs_printk(const struct btrfs_fs_info *fs_info, const char *fmt, ...)\n{\n\tstruct super_block *sb = fs_info->sb;\n\tchar lvl[4];\n\tstruct va_format vaf;\n\tva_list args;\n\tconst char *type = logtypes[4];\n\tint kern_level;\n\n\tva_start(args, fmt);\n\n\tkern_level = printk_get_level(fmt);\n\tif (kern_level) {\n\t\tsize_t size = printk_skip_level(fmt) - fmt;\n\t\tmemcpy(lvl, fmt,  size);\n\t\tlvl[size] = '\\0';\n\t\tfmt += size;\n\t\ttype = logtypes[kern_level - '0'];\n\t} else\n\t\t*lvl = '\\0';\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sBTRFS %s (device %s): %pV\\n\", lvl, type, sb->s_id, &vaf);\n\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfsic_map_block",
          "args": [
            "state",
            "next_bytenr",
            "state->metablock_size",
            "&tmp_next_block_ctx",
            "mirror_num"
          ],
          "line": 914
        },
        "resolved": true,
        "details": {
          "function_name": "btrfsic_map_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/check-integrity.c",
          "lines": "1568-1609",
          "snippet": "static int btrfsic_map_block(struct btrfsic_state *state, u64 bytenr, u32 len,\n\t\t\t     struct btrfsic_block_data_ctx *block_ctx_out,\n\t\t\t     int mirror_num)\n{\n\tint ret;\n\tu64 length;\n\tstruct btrfs_bio *multi = NULL;\n\tstruct btrfs_device *device;\n\n\tlength = len;\n\tret = btrfs_map_block(state->root->fs_info, READ,\n\t\t\t      bytenr, &length, &multi, mirror_num);\n\n\tif (ret) {\n\t\tblock_ctx_out->start = 0;\n\t\tblock_ctx_out->dev_bytenr = 0;\n\t\tblock_ctx_out->len = 0;\n\t\tblock_ctx_out->dev = NULL;\n\t\tblock_ctx_out->datav = NULL;\n\t\tblock_ctx_out->pagev = NULL;\n\t\tblock_ctx_out->mem_to_free = NULL;\n\n\t\treturn ret;\n\t}\n\n\tdevice = multi->stripes[0].dev;\n\tblock_ctx_out->dev = btrfsic_dev_state_lookup(device->bdev);\n\tblock_ctx_out->dev_bytenr = multi->stripes[0].physical;\n\tblock_ctx_out->start = bytenr;\n\tblock_ctx_out->len = len;\n\tblock_ctx_out->datav = NULL;\n\tblock_ctx_out->pagev = NULL;\n\tblock_ctx_out->mem_to_free = NULL;\n\n\tkfree(multi);\n\tif (NULL == block_ctx_out->dev) {\n\t\tret = -ENXIO;\n\t\tprintk(KERN_INFO \"btrfsic: error, cannot lookup dev (#1)!\\n\");\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"extent_io.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/genhd.h>",
            "#include <linux/mutex.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void btrfsic_block_link_init(struct btrfsic_block_link *n);",
            "static void btrfsic_block_link_free(struct btrfsic_block_link *n);",
            "static void btrfsic_read_from_block_data(\n\tstruct btrfsic_block_data_ctx *block_ctx,\n\tvoid *dst, u32 offset, size_t len);",
            "static int btrfsic_map_block(struct btrfsic_state *state, u64 bytenr, u32 len,\n\t\t\t     struct btrfsic_block_data_ctx *block_ctx_out,\n\t\t\t     int mirror_num);",
            "static void btrfsic_dump_database(struct btrfsic_state *state);",
            "static void btrfsic_dump_tree(const struct btrfsic_state *state);",
            "static struct btrfsic_dev_state *btrfsic_dev_state_lookup(\n\t\tstruct block_device *bdev);",
            "static void btrfsic_cmp_log_and_dev_bytenr(struct btrfsic_state *state,\n\t\t\t\t\t   u64 bytenr,\n\t\t\t\t\t   struct btrfsic_dev_state *dev_state,\n\t\t\t\t\t   u64 dev_bytenr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"extent_io.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n#include <linux/blkdev.h>\n#include <linux/genhd.h>\n#include <linux/mutex.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic void btrfsic_block_link_init(struct btrfsic_block_link *n);\nstatic void btrfsic_block_link_free(struct btrfsic_block_link *n);\nstatic void btrfsic_read_from_block_data(\n\tstruct btrfsic_block_data_ctx *block_ctx,\n\tvoid *dst, u32 offset, size_t len);\nstatic int btrfsic_map_block(struct btrfsic_state *state, u64 bytenr, u32 len,\n\t\t\t     struct btrfsic_block_data_ctx *block_ctx_out,\n\t\t\t     int mirror_num);\nstatic void btrfsic_dump_database(struct btrfsic_state *state);\nstatic void btrfsic_dump_tree(const struct btrfsic_state *state);\nstatic struct btrfsic_dev_state *btrfsic_dev_state_lookup(\n\t\tstruct block_device *bdev);\nstatic void btrfsic_cmp_log_and_dev_bytenr(struct btrfsic_state *state,\n\t\t\t\t\t   u64 bytenr,\n\t\t\t\t\t   struct btrfsic_dev_state *dev_state,\n\t\t\t\t\t   u64 dev_bytenr);\n\nstatic int btrfsic_map_block(struct btrfsic_state *state, u64 bytenr, u32 len,\n\t\t\t     struct btrfsic_block_data_ctx *block_ctx_out,\n\t\t\t     int mirror_num)\n{\n\tint ret;\n\tu64 length;\n\tstruct btrfs_bio *multi = NULL;\n\tstruct btrfs_device *device;\n\n\tlength = len;\n\tret = btrfs_map_block(state->root->fs_info, READ,\n\t\t\t      bytenr, &length, &multi, mirror_num);\n\n\tif (ret) {\n\t\tblock_ctx_out->start = 0;\n\t\tblock_ctx_out->dev_bytenr = 0;\n\t\tblock_ctx_out->len = 0;\n\t\tblock_ctx_out->dev = NULL;\n\t\tblock_ctx_out->datav = NULL;\n\t\tblock_ctx_out->pagev = NULL;\n\t\tblock_ctx_out->mem_to_free = NULL;\n\n\t\treturn ret;\n\t}\n\n\tdevice = multi->stripes[0].dev;\n\tblock_ctx_out->dev = btrfsic_dev_state_lookup(device->bdev);\n\tblock_ctx_out->dev_bytenr = multi->stripes[0].physical;\n\tblock_ctx_out->start = bytenr;\n\tblock_ctx_out->len = len;\n\tblock_ctx_out->datav = NULL;\n\tblock_ctx_out->pagev = NULL;\n\tblock_ctx_out->mem_to_free = NULL;\n\n\tkfree(multi);\n\tif (NULL == block_ctx_out->dev) {\n\t\tret = -ENXIO;\n\t\tprintk(KERN_INFO \"btrfsic: error, cannot lookup dev (#1)!\\n\");\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_num_copies",
          "args": [
            "state->root->fs_info",
            "next_bytenr",
            "state->metablock_size"
          ],
          "line": 904
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_num_copies",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
          "lines": "4740-4790",
          "snippet": "int btrfs_num_copies(struct btrfs_fs_info *fs_info, u64 logical, u64 len)\n{\n\tstruct btrfs_mapping_tree *map_tree = &fs_info->mapping_tree;\n\tstruct extent_map *em;\n\tstruct map_lookup *map;\n\tstruct extent_map_tree *em_tree = &map_tree->map_tree;\n\tint ret;\n\n\tread_lock(&em_tree->lock);\n\tem = lookup_extent_mapping(em_tree, logical, len);\n\tread_unlock(&em_tree->lock);\n\n\t/*\n\t * We could return errors for these cases, but that could get ugly and\n\t * we'd probably do the same thing which is just not do anything else\n\t * and exit, so return 1 so the callers don't try to use other copies.\n\t */\n\tif (!em) {\n\t\tbtrfs_crit(fs_info, \"No mapping for %Lu-%Lu\", logical,\n\t\t\t    logical+len);\n\t\treturn 1;\n\t}\n\n\tif (em->start > logical || em->start + em->len < logical) {\n\t\tbtrfs_crit(fs_info, \"Invalid mapping for %Lu-%Lu, got \"\n\t\t\t    \"%Lu-%Lu\", logical, logical+len, em->start,\n\t\t\t    em->start + em->len);\n\t\tfree_extent_map(em);\n\t\treturn 1;\n\t}\n\n\tmap = (struct map_lookup *)em->bdev;\n\tif (map->type & (BTRFS_BLOCK_GROUP_DUP | BTRFS_BLOCK_GROUP_RAID1))\n\t\tret = map->num_stripes;\n\telse if (map->type & BTRFS_BLOCK_GROUP_RAID10)\n\t\tret = map->sub_stripes;\n\telse if (map->type & BTRFS_BLOCK_GROUP_RAID5)\n\t\tret = 2;\n\telse if (map->type & BTRFS_BLOCK_GROUP_RAID6)\n\t\tret = 3;\n\telse\n\t\tret = 1;\n\tfree_extent_map(em);\n\n\tbtrfs_dev_replace_lock(&fs_info->dev_replace);\n\tif (btrfs_dev_replace_is_ongoing(&fs_info->dev_replace))\n\t\tret++;\n\tbtrfs_dev_replace_unlock(&fs_info->dev_replace);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\nstatic noinline struct;\n\nint btrfs_num_copies(struct btrfs_fs_info *fs_info, u64 logical, u64 len)\n{\n\tstruct btrfs_mapping_tree *map_tree = &fs_info->mapping_tree;\n\tstruct extent_map *em;\n\tstruct map_lookup *map;\n\tstruct extent_map_tree *em_tree = &map_tree->map_tree;\n\tint ret;\n\n\tread_lock(&em_tree->lock);\n\tem = lookup_extent_mapping(em_tree, logical, len);\n\tread_unlock(&em_tree->lock);\n\n\t/*\n\t * We could return errors for these cases, but that could get ugly and\n\t * we'd probably do the same thing which is just not do anything else\n\t * and exit, so return 1 so the callers don't try to use other copies.\n\t */\n\tif (!em) {\n\t\tbtrfs_crit(fs_info, \"No mapping for %Lu-%Lu\", logical,\n\t\t\t    logical+len);\n\t\treturn 1;\n\t}\n\n\tif (em->start > logical || em->start + em->len < logical) {\n\t\tbtrfs_crit(fs_info, \"Invalid mapping for %Lu-%Lu, got \"\n\t\t\t    \"%Lu-%Lu\", logical, logical+len, em->start,\n\t\t\t    em->start + em->len);\n\t\tfree_extent_map(em);\n\t\treturn 1;\n\t}\n\n\tmap = (struct map_lookup *)em->bdev;\n\tif (map->type & (BTRFS_BLOCK_GROUP_DUP | BTRFS_BLOCK_GROUP_RAID1))\n\t\tret = map->num_stripes;\n\telse if (map->type & BTRFS_BLOCK_GROUP_RAID10)\n\t\tret = map->sub_stripes;\n\telse if (map->type & BTRFS_BLOCK_GROUP_RAID5)\n\t\tret = 2;\n\telse if (map->type & BTRFS_BLOCK_GROUP_RAID6)\n\t\tret = 3;\n\telse\n\t\tret = 1;\n\tfree_extent_map(em);\n\n\tbtrfs_dev_replace_lock(&fs_info->dev_replace);\n\tif (btrfs_dev_replace_is_ongoing(&fs_info->dev_replace))\n\t\tret++;\n\tbtrfs_dev_replace_unlock(&fs_info->dev_replace);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_super_log_root",
          "args": [
            "super_tmp"
          ],
          "line": 897
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_disk_key_objectid",
          "args": [
            "&tmp_disk_key",
            "BTRFS_TREE_LOG_OBJECTID"
          ],
          "line": 894
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_super_chunk_root",
          "args": [
            "super_tmp"
          ],
          "line": 891
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_disk_key_objectid",
          "args": [
            "&tmp_disk_key",
            "BTRFS_CHUNK_TREE_OBJECTID"
          ],
          "line": 888
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_super_root",
          "args": [
            "super_tmp"
          ],
          "line": 885
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_disk_key_objectid",
          "args": [
            "&tmp_disk_key",
            "BTRFS_ROOT_TREE_OBJECTID"
          ],
          "line": 882
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_super_generation",
          "args": [
            "super_tmp"
          ],
          "line": 867
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "selected_super",
            "super_tmp",
            "sizeof(*selected_super)"
          ],
          "line": 864
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_super_generation",
          "args": [
            "super_tmp"
          ],
          "line": 861
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfsic_block_hashtable_add",
          "args": [
            "superblock_tmp",
            "&state->block_hashtable"
          ],
          "line": 856
        },
        "resolved": true,
        "details": {
          "function_name": "btrfsic_block_hashtable_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/check-integrity.c",
          "lines": "509-518",
          "snippet": "static void btrfsic_block_hashtable_add(struct btrfsic_block *b,\n\t\t\t\t\tstruct btrfsic_block_hashtable *h)\n{\n\tconst unsigned int hashval =\n\t    (((unsigned int)(b->dev_bytenr >> 16)) ^\n\t     ((unsigned int)((uintptr_t)b->dev_state->bdev))) &\n\t     (BTRFSIC_BLOCK_HASHTABLE_SIZE - 1);\n\n\tlist_add(&b->collision_resolving_node, h->table + hashval);\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"extent_io.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/genhd.h>",
            "#include <linux/mutex.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define BTRFSIC_BLOCK_HASHTABLE_SIZE 0x10000"
          ],
          "globals_used": [
            "static void btrfsic_block_init(struct btrfsic_block *b);",
            "static void btrfsic_block_free(struct btrfsic_block *b);",
            "static void btrfsic_block_hashtable_init(struct btrfsic_block_hashtable *h);",
            "static void btrfsic_block_hashtable_add(struct btrfsic_block *b,\n\t\t\t\t\tstruct btrfsic_block_hashtable *h);",
            "static void btrfsic_block_hashtable_remove(struct btrfsic_block *b);",
            "static struct btrfsic_block *btrfsic_block_hashtable_lookup(\n\t\tstruct block_device *bdev,\n\t\tu64 dev_bytenr,\n\t\tstruct btrfsic_block_hashtable *h);",
            "static void btrfsic_block_link_hashtable_init(\n\t\tstruct btrfsic_block_link_hashtable *h);",
            "static void btrfsic_block_link_hashtable_add(\n\t\tstruct btrfsic_block_link *l,\n\t\tstruct btrfsic_block_link_hashtable *h);",
            "static struct btrfsic_block_link *btrfsic_block_link_hashtable_lookup(\n\t\tstruct block_device *bdev_ref_to,\n\t\tu64 dev_bytenr_ref_to,\n\t\tstruct block_device *bdev_ref_from,\n\t\tu64 dev_bytenr_ref_from,\n\t\tstruct btrfsic_block_link_hashtable *h);",
            "static void btrfsic_dev_state_hashtable_init(\n\t\tstruct btrfsic_dev_state_hashtable *h);",
            "static void btrfsic_dev_state_hashtable_add(\n\t\tstruct btrfsic_dev_state *ds,\n\t\tstruct btrfsic_dev_state_hashtable *h);",
            "static struct btrfsic_dev_state *btrfsic_dev_state_hashtable_lookup(\n\t\tstruct block_device *bdev,\n\t\tstruct btrfsic_dev_state_hashtable *h);",
            "static struct btrfsic_dev_state *btrfsic_dev_state_lookup(\n\t\tstruct block_device *bdev);",
            "static void btrfsic_cmp_log_and_dev_bytenr(struct btrfsic_state *state,\n\t\t\t\t\t   u64 bytenr,\n\t\t\t\t\t   struct btrfsic_dev_state *dev_state,\n\t\t\t\t\t   u64 dev_bytenr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"extent_io.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n#include <linux/blkdev.h>\n#include <linux/genhd.h>\n#include <linux/mutex.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\n#define BTRFSIC_BLOCK_HASHTABLE_SIZE 0x10000\n\nstatic void btrfsic_block_init(struct btrfsic_block *b);\nstatic void btrfsic_block_free(struct btrfsic_block *b);\nstatic void btrfsic_block_hashtable_init(struct btrfsic_block_hashtable *h);\nstatic void btrfsic_block_hashtable_add(struct btrfsic_block *b,\n\t\t\t\t\tstruct btrfsic_block_hashtable *h);\nstatic void btrfsic_block_hashtable_remove(struct btrfsic_block *b);\nstatic struct btrfsic_block *btrfsic_block_hashtable_lookup(\n\t\tstruct block_device *bdev,\n\t\tu64 dev_bytenr,\n\t\tstruct btrfsic_block_hashtable *h);\nstatic void btrfsic_block_link_hashtable_init(\n\t\tstruct btrfsic_block_link_hashtable *h);\nstatic void btrfsic_block_link_hashtable_add(\n\t\tstruct btrfsic_block_link *l,\n\t\tstruct btrfsic_block_link_hashtable *h);\nstatic struct btrfsic_block_link *btrfsic_block_link_hashtable_lookup(\n\t\tstruct block_device *bdev_ref_to,\n\t\tu64 dev_bytenr_ref_to,\n\t\tstruct block_device *bdev_ref_from,\n\t\tu64 dev_bytenr_ref_from,\n\t\tstruct btrfsic_block_link_hashtable *h);\nstatic void btrfsic_dev_state_hashtable_init(\n\t\tstruct btrfsic_dev_state_hashtable *h);\nstatic void btrfsic_dev_state_hashtable_add(\n\t\tstruct btrfsic_dev_state *ds,\n\t\tstruct btrfsic_dev_state_hashtable *h);\nstatic struct btrfsic_dev_state *btrfsic_dev_state_hashtable_lookup(\n\t\tstruct block_device *bdev,\n\t\tstruct btrfsic_dev_state_hashtable *h);\nstatic struct btrfsic_dev_state *btrfsic_dev_state_lookup(\n\t\tstruct block_device *bdev);\nstatic void btrfsic_cmp_log_and_dev_bytenr(struct btrfsic_state *state,\n\t\t\t\t\t   u64 bytenr,\n\t\t\t\t\t   struct btrfsic_dev_state *dev_state,\n\t\t\t\t\t   u64 dev_bytenr);\n\nstatic void btrfsic_block_hashtable_add(struct btrfsic_block *b,\n\t\t\t\t\tstruct btrfsic_block_hashtable *h)\n{\n\tconst unsigned int hashval =\n\t    (((unsigned int)(b->dev_bytenr >> 16)) ^\n\t     ((unsigned int)((uintptr_t)b->dev_state->bdev))) &\n\t     (BTRFSIC_BLOCK_HASHTABLE_SIZE - 1);\n\n\tlist_add(&b->collision_resolving_node, h->table + hashval);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&superblock_tmp->all_blocks_node",
            "&state->all_blocks_list"
          ],
          "line": 854
        },
        "resolved": true,
        "details": {
          "function_name": "simple_xattr_list_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "966-972",
          "snippet": "void simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk_in_rcu",
          "args": [
            "KERN_INFO \"New initial S-block (bdev %p, %s)\"\n\t\t\t\t     \" @%llu (%s/%llu/%d)\\n\"",
            "superblock_bdev",
            "rcu_str_deref(device->name)",
            "dev_bytenr",
            "dev_state->name",
            "dev_bytenr",
            "superblock_mirror_num"
          ],
          "line": 848
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_str_deref",
          "args": [
            "device->name"
          ],
          "line": 851
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_super_generation",
          "args": [
            "super_tmp"
          ],
          "line": 841
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_INFO \"btrfsic: error, kmalloc failed!\\n\""
          ],
          "line": 833
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfsic_block_alloc",
          "args": [],
          "line": 831
        },
        "resolved": true,
        "details": {
          "function_name": "btrfsic_block_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/check-integrity.c",
          "lines": "425-434",
          "snippet": "static struct btrfsic_block *btrfsic_block_alloc(void)\n{\n\tstruct btrfsic_block *b;\n\n\tb = kzalloc(sizeof(*b), GFP_NOFS);\n\tif (NULL != b)\n\t\tbtrfsic_block_init(b);\n\n\treturn b;\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"extent_io.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/genhd.h>",
            "#include <linux/mutex.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void btrfsic_block_init(struct btrfsic_block *b);",
            "static struct btrfsic_block *btrfsic_block_alloc(void);",
            "static void btrfsic_block_free(struct btrfsic_block *b);",
            "static void btrfsic_block_hashtable_remove(struct btrfsic_block *b);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"extent_io.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n#include <linux/blkdev.h>\n#include <linux/genhd.h>\n#include <linux/mutex.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic void btrfsic_block_init(struct btrfsic_block *b);\nstatic struct btrfsic_block *btrfsic_block_alloc(void);\nstatic void btrfsic_block_free(struct btrfsic_block *b);\nstatic void btrfsic_block_hashtable_remove(struct btrfsic_block *b);\n\nstatic struct btrfsic_block *btrfsic_block_alloc(void)\n{\n\tstruct btrfsic_block *b;\n\n\tb = kzalloc(sizeof(*b), GFP_NOFS);\n\tif (NULL != b)\n\t\tbtrfsic_block_init(b);\n\n\treturn b;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfsic_block_hashtable_lookup",
          "args": [
            "superblock_bdev",
            "dev_bytenr",
            "&state->block_hashtable"
          ],
          "line": 827
        },
        "resolved": true,
        "details": {
          "function_name": "btrfsic_block_hashtable_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/check-integrity.c",
          "lines": "525-546",
          "snippet": "static struct btrfsic_block *btrfsic_block_hashtable_lookup(\n\t\tstruct block_device *bdev,\n\t\tu64 dev_bytenr,\n\t\tstruct btrfsic_block_hashtable *h)\n{\n\tconst unsigned int hashval =\n\t    (((unsigned int)(dev_bytenr >> 16)) ^\n\t     ((unsigned int)((uintptr_t)bdev))) &\n\t     (BTRFSIC_BLOCK_HASHTABLE_SIZE - 1);\n\tstruct list_head *elem;\n\n\tlist_for_each(elem, h->table + hashval) {\n\t\tstruct btrfsic_block *const b =\n\t\t    list_entry(elem, struct btrfsic_block,\n\t\t\t       collision_resolving_node);\n\n\t\tif (b->dev_state->bdev == bdev && b->dev_bytenr == dev_bytenr)\n\t\t\treturn b;\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"extent_io.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/genhd.h>",
            "#include <linux/mutex.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define BTRFSIC_BLOCK_HASHTABLE_SIZE 0x10000"
          ],
          "globals_used": [
            "static void btrfsic_block_init(struct btrfsic_block *b);",
            "static void btrfsic_block_free(struct btrfsic_block *b);",
            "static void btrfsic_block_hashtable_init(struct btrfsic_block_hashtable *h);",
            "static void btrfsic_block_hashtable_add(struct btrfsic_block *b,\n\t\t\t\t\tstruct btrfsic_block_hashtable *h);",
            "static void btrfsic_block_hashtable_remove(struct btrfsic_block *b);",
            "static struct btrfsic_block *btrfsic_block_hashtable_lookup(\n\t\tstruct block_device *bdev,\n\t\tu64 dev_bytenr,\n\t\tstruct btrfsic_block_hashtable *h);",
            "static void btrfsic_block_link_hashtable_init(\n\t\tstruct btrfsic_block_link_hashtable *h);",
            "static void btrfsic_block_link_hashtable_add(\n\t\tstruct btrfsic_block_link *l,\n\t\tstruct btrfsic_block_link_hashtable *h);",
            "static struct btrfsic_block_link *btrfsic_block_link_hashtable_lookup(\n\t\tstruct block_device *bdev_ref_to,\n\t\tu64 dev_bytenr_ref_to,\n\t\tstruct block_device *bdev_ref_from,\n\t\tu64 dev_bytenr_ref_from,\n\t\tstruct btrfsic_block_link_hashtable *h);",
            "static void btrfsic_dev_state_hashtable_init(\n\t\tstruct btrfsic_dev_state_hashtable *h);",
            "static void btrfsic_dev_state_hashtable_add(\n\t\tstruct btrfsic_dev_state *ds,\n\t\tstruct btrfsic_dev_state_hashtable *h);",
            "static struct btrfsic_dev_state *btrfsic_dev_state_hashtable_lookup(\n\t\tstruct block_device *bdev,\n\t\tstruct btrfsic_dev_state_hashtable *h);",
            "static struct btrfsic_dev_state *btrfsic_dev_state_lookup(\n\t\tstruct block_device *bdev);",
            "static void btrfsic_cmp_log_and_dev_bytenr(struct btrfsic_state *state,\n\t\t\t\t\t   u64 bytenr,\n\t\t\t\t\t   struct btrfsic_dev_state *dev_state,\n\t\t\t\t\t   u64 dev_bytenr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"extent_io.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n#include <linux/blkdev.h>\n#include <linux/genhd.h>\n#include <linux/mutex.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\n#define BTRFSIC_BLOCK_HASHTABLE_SIZE 0x10000\n\nstatic void btrfsic_block_init(struct btrfsic_block *b);\nstatic void btrfsic_block_free(struct btrfsic_block *b);\nstatic void btrfsic_block_hashtable_init(struct btrfsic_block_hashtable *h);\nstatic void btrfsic_block_hashtable_add(struct btrfsic_block *b,\n\t\t\t\t\tstruct btrfsic_block_hashtable *h);\nstatic void btrfsic_block_hashtable_remove(struct btrfsic_block *b);\nstatic struct btrfsic_block *btrfsic_block_hashtable_lookup(\n\t\tstruct block_device *bdev,\n\t\tu64 dev_bytenr,\n\t\tstruct btrfsic_block_hashtable *h);\nstatic void btrfsic_block_link_hashtable_init(\n\t\tstruct btrfsic_block_link_hashtable *h);\nstatic void btrfsic_block_link_hashtable_add(\n\t\tstruct btrfsic_block_link *l,\n\t\tstruct btrfsic_block_link_hashtable *h);\nstatic struct btrfsic_block_link *btrfsic_block_link_hashtable_lookup(\n\t\tstruct block_device *bdev_ref_to,\n\t\tu64 dev_bytenr_ref_to,\n\t\tstruct block_device *bdev_ref_from,\n\t\tu64 dev_bytenr_ref_from,\n\t\tstruct btrfsic_block_link_hashtable *h);\nstatic void btrfsic_dev_state_hashtable_init(\n\t\tstruct btrfsic_dev_state_hashtable *h);\nstatic void btrfsic_dev_state_hashtable_add(\n\t\tstruct btrfsic_dev_state *ds,\n\t\tstruct btrfsic_dev_state_hashtable *h);\nstatic struct btrfsic_dev_state *btrfsic_dev_state_hashtable_lookup(\n\t\tstruct block_device *bdev,\n\t\tstruct btrfsic_dev_state_hashtable *h);\nstatic struct btrfsic_dev_state *btrfsic_dev_state_lookup(\n\t\tstruct block_device *bdev);\nstatic void btrfsic_cmp_log_and_dev_bytenr(struct btrfsic_state *state,\n\t\t\t\t\t   u64 bytenr,\n\t\t\t\t\t   struct btrfsic_dev_state *dev_state,\n\t\t\t\t\t   u64 dev_bytenr);\n\nstatic struct btrfsic_block *btrfsic_block_hashtable_lookup(\n\t\tstruct block_device *bdev,\n\t\tu64 dev_bytenr,\n\t\tstruct btrfsic_block_hashtable *h)\n{\n\tconst unsigned int hashval =\n\t    (((unsigned int)(dev_bytenr >> 16)) ^\n\t     ((unsigned int)((uintptr_t)bdev))) &\n\t     (BTRFSIC_BLOCK_HASHTABLE_SIZE - 1);\n\tstruct list_head *elem;\n\n\tlist_for_each(elem, h->table + hashval) {\n\t\tstruct btrfsic_block *const b =\n\t\t    list_entry(elem, struct btrfsic_block,\n\t\t\t       collision_resolving_node);\n\n\t\tif (b->dev_state->bdev == bdev && b->dev_bytenr == dev_bytenr)\n\t\t\treturn b;\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_super_sectorsize",
          "args": [
            "super_tmp"
          ],
          "line": 821
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_super_nodesize",
          "args": [
            "super_tmp"
          ],
          "line": 820
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "device->uuid",
            "super_tmp->dev_item.uuid",
            "BTRFS_UUID_SIZE"
          ],
          "line": 819
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_super_magic",
          "args": [
            "super_tmp"
          ],
          "line": 818
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_super_bytenr",
          "args": [
            "super_tmp"
          ],
          "line": 817
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__bread",
          "args": [
            "superblock_bdev",
            "dev_bytenr / 4096",
            "BTRFS_SUPER_INFO_SIZE"
          ],
          "line": 810
        },
        "resolved": true,
        "details": {
          "function_name": "__breadahead",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1381-1388",
          "snippet": "void __breadahead(struct block_device *bdev, sector_t block, unsigned size)\n{\n\tstruct buffer_head *bh = __getblk(bdev, block, size);\n\tif (likely(bh)) {\n\t\tll_rw_block(READA, 1, &bh);\n\t\tbrelse(bh);\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __breadahead(struct block_device *bdev, sector_t block, unsigned size)\n{\n\tstruct buffer_head *bh = __getblk(bdev, block, size);\n\tif (likely(bh)) {\n\t\tll_rw_block(READA, 1, &bh);\n\t\tbrelse(bh);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_sb_offset",
          "args": [
            "superblock_mirror_num"
          ],
          "line": 807
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_sb_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.h",
          "lines": "36-42",
          "snippet": "static inline u64 btrfs_sb_offset(int mirror)\n{\n\tu64 start = 16 * 1024;\n\tif (mirror)\n\t\treturn start << (BTRFS_SUPER_MIRROR_SHIFT * mirror);\n\treturn BTRFS_SUPER_INFO_OFFSET;\n}",
          "includes": [],
          "macros_used": [
            "#define BTRFS_SUPER_MIRROR_SHIFT 12",
            "#define BTRFS_SUPER_INFO_OFFSET (64 * 1024)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define BTRFS_SUPER_MIRROR_SHIFT 12\n#define BTRFS_SUPER_INFO_OFFSET (64 * 1024)\n\nstatic inline u64 btrfs_sb_offset(int mirror)\n{\n\tu64 start = 16 * 1024;\n\tif (mirror)\n\t\treturn start << (BTRFS_SUPER_MIRROR_SHIFT * mirror);\n\treturn BTRFS_SUPER_INFO_OFFSET;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"extent_io.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n#include <linux/blkdev.h>\n#include <linux/genhd.h>\n#include <linux/mutex.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\n#define BTRFSIC_PRINT_MASK_NUM_COPIES\t\t\t\t0x00000800\n#define BTRFSIC_PRINT_MASK_INITIAL_ALL_TREES\t\t\t0x00000200\n#define BTRFSIC_PRINT_MASK_SUPERBLOCK_WRITE\t\t\t0x00000001\n#define BTRFSIC_GENERATION_UNKNOWN ((u64)-1)\n\nstatic struct btrfsic_block *btrfsic_block_alloc(void);\nstatic void btrfsic_block_link_init(struct btrfsic_block_link *n);\nstatic void btrfsic_block_link_free(struct btrfsic_block_link *n);\nstatic void btrfsic_block_link_hashtable_remove(struct btrfsic_block_link *l);\nstatic int btrfsic_map_block(struct btrfsic_state *state, u64 bytenr, u32 len,\n\t\t\t     struct btrfsic_block_data_ctx *block_ctx_out,\n\t\t\t     int mirror_num);\nstatic void btrfsic_dump_database(struct btrfsic_state *state);\nstatic void btrfsic_print_add_link(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block_link *l);\nstatic void btrfsic_print_rem_link(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block_link *l);\nstatic char btrfsic_get_block_type(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block *block);\nstatic void btrfsic_dump_tree(const struct btrfsic_state *state);\nstatic int btrfsic_process_superblock_dev_mirror(\n\t\tstruct btrfsic_state *state,\n\t\tstruct btrfsic_dev_state *dev_state,\n\t\tstruct btrfs_device *device,\n\t\tint superblock_mirror_num,\n\t\tstruct btrfsic_dev_state **selected_dev_state,\n\t\tstruct btrfs_super_block *selected_super);\nstatic struct btrfsic_dev_state *btrfsic_dev_state_lookup(\n\t\tstruct block_device *bdev);\nstatic void btrfsic_cmp_log_and_dev_bytenr(struct btrfsic_state *state,\n\t\t\t\t\t   u64 bytenr,\n\t\t\t\t\t   struct btrfsic_dev_state *dev_state,\n\t\t\t\t\t   u64 dev_bytenr);\n\nstatic int btrfsic_process_superblock_dev_mirror(\n\t\tstruct btrfsic_state *state,\n\t\tstruct btrfsic_dev_state *dev_state,\n\t\tstruct btrfs_device *device,\n\t\tint superblock_mirror_num,\n\t\tstruct btrfsic_dev_state **selected_dev_state,\n\t\tstruct btrfs_super_block *selected_super)\n{\n\tstruct btrfs_super_block *super_tmp;\n\tu64 dev_bytenr;\n\tstruct buffer_head *bh;\n\tstruct btrfsic_block *superblock_tmp;\n\tint pass;\n\tstruct block_device *const superblock_bdev = device->bdev;\n\n\t/* super block bytenr is always the unmapped device bytenr */\n\tdev_bytenr = btrfs_sb_offset(superblock_mirror_num);\n\tif (dev_bytenr + BTRFS_SUPER_INFO_SIZE > device->commit_total_bytes)\n\t\treturn -1;\n\tbh = __bread(superblock_bdev, dev_bytenr / 4096,\n\t\t     BTRFS_SUPER_INFO_SIZE);\n\tif (NULL == bh)\n\t\treturn -1;\n\tsuper_tmp = (struct btrfs_super_block *)\n\t    (bh->b_data + (dev_bytenr & 4095));\n\n\tif (btrfs_super_bytenr(super_tmp) != dev_bytenr ||\n\t    btrfs_super_magic(super_tmp) != BTRFS_MAGIC ||\n\t    memcmp(device->uuid, super_tmp->dev_item.uuid, BTRFS_UUID_SIZE) ||\n\t    btrfs_super_nodesize(super_tmp) != state->metablock_size ||\n\t    btrfs_super_sectorsize(super_tmp) != state->datablock_size) {\n\t\tbrelse(bh);\n\t\treturn 0;\n\t}\n\n\tsuperblock_tmp =\n\t    btrfsic_block_hashtable_lookup(superblock_bdev,\n\t\t\t\t\t   dev_bytenr,\n\t\t\t\t\t   &state->block_hashtable);\n\tif (NULL == superblock_tmp) {\n\t\tsuperblock_tmp = btrfsic_block_alloc();\n\t\tif (NULL == superblock_tmp) {\n\t\t\tprintk(KERN_INFO \"btrfsic: error, kmalloc failed!\\n\");\n\t\t\tbrelse(bh);\n\t\t\treturn -1;\n\t\t}\n\t\t/* for superblock, only the dev_bytenr makes sense */\n\t\tsuperblock_tmp->dev_bytenr = dev_bytenr;\n\t\tsuperblock_tmp->dev_state = dev_state;\n\t\tsuperblock_tmp->logical_bytenr = dev_bytenr;\n\t\tsuperblock_tmp->generation = btrfs_super_generation(super_tmp);\n\t\tsuperblock_tmp->is_metadata = 1;\n\t\tsuperblock_tmp->is_superblock = 1;\n\t\tsuperblock_tmp->is_iodone = 1;\n\t\tsuperblock_tmp->never_written = 0;\n\t\tsuperblock_tmp->mirror_num = 1 + superblock_mirror_num;\n\t\tif (state->print_mask & BTRFSIC_PRINT_MASK_SUPERBLOCK_WRITE)\n\t\t\tprintk_in_rcu(KERN_INFO \"New initial S-block (bdev %p, %s)\"\n\t\t\t\t     \" @%llu (%s/%llu/%d)\\n\",\n\t\t\t\t     superblock_bdev,\n\t\t\t\t     rcu_str_deref(device->name), dev_bytenr,\n\t\t\t\t     dev_state->name, dev_bytenr,\n\t\t\t\t     superblock_mirror_num);\n\t\tlist_add(&superblock_tmp->all_blocks_node,\n\t\t\t &state->all_blocks_list);\n\t\tbtrfsic_block_hashtable_add(superblock_tmp,\n\t\t\t\t\t    &state->block_hashtable);\n\t}\n\n\t/* select the one with the highest generation field */\n\tif (btrfs_super_generation(super_tmp) >\n\t    state->max_superblock_generation ||\n\t    0 == state->max_superblock_generation) {\n\t\tmemcpy(selected_super, super_tmp, sizeof(*selected_super));\n\t\t*selected_dev_state = dev_state;\n\t\tstate->max_superblock_generation =\n\t\t    btrfs_super_generation(super_tmp);\n\t\tstate->latest_superblock = superblock_tmp;\n\t}\n\n\tfor (pass = 0; pass < 3; pass++) {\n\t\tu64 next_bytenr;\n\t\tint num_copies;\n\t\tint mirror_num;\n\t\tconst char *additional_string = NULL;\n\t\tstruct btrfs_disk_key tmp_disk_key;\n\n\t\ttmp_disk_key.type = BTRFS_ROOT_ITEM_KEY;\n\t\ttmp_disk_key.offset = 0;\n\t\tswitch (pass) {\n\t\tcase 0:\n\t\t\tbtrfs_set_disk_key_objectid(&tmp_disk_key,\n\t\t\t\t\t\t    BTRFS_ROOT_TREE_OBJECTID);\n\t\t\tadditional_string = \"initial root \";\n\t\t\tnext_bytenr = btrfs_super_root(super_tmp);\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tbtrfs_set_disk_key_objectid(&tmp_disk_key,\n\t\t\t\t\t\t    BTRFS_CHUNK_TREE_OBJECTID);\n\t\t\tadditional_string = \"initial chunk \";\n\t\t\tnext_bytenr = btrfs_super_chunk_root(super_tmp);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tbtrfs_set_disk_key_objectid(&tmp_disk_key,\n\t\t\t\t\t\t    BTRFS_TREE_LOG_OBJECTID);\n\t\t\tadditional_string = \"initial log \";\n\t\t\tnext_bytenr = btrfs_super_log_root(super_tmp);\n\t\t\tif (0 == next_bytenr)\n\t\t\t\tcontinue;\n\t\t\tbreak;\n\t\t}\n\n\t\tnum_copies =\n\t\t    btrfs_num_copies(state->root->fs_info,\n\t\t\t\t     next_bytenr, state->metablock_size);\n\t\tif (state->print_mask & BTRFSIC_PRINT_MASK_NUM_COPIES)\n\t\t\tprintk(KERN_INFO \"num_copies(log_bytenr=%llu) = %d\\n\",\n\t\t\t       next_bytenr, num_copies);\n\t\tfor (mirror_num = 1; mirror_num <= num_copies; mirror_num++) {\n\t\t\tstruct btrfsic_block *next_block;\n\t\t\tstruct btrfsic_block_data_ctx tmp_next_block_ctx;\n\t\t\tstruct btrfsic_block_link *l;\n\n\t\t\tif (btrfsic_map_block(state, next_bytenr,\n\t\t\t\t\t      state->metablock_size,\n\t\t\t\t\t      &tmp_next_block_ctx,\n\t\t\t\t\t      mirror_num)) {\n\t\t\t\tprintk(KERN_INFO \"btrfsic: btrfsic_map_block(\"\n\t\t\t\t       \"bytenr @%llu, mirror %d) failed!\\n\",\n\t\t\t\t       next_bytenr, mirror_num);\n\t\t\t\tbrelse(bh);\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tnext_block = btrfsic_block_lookup_or_add(\n\t\t\t\t\tstate, &tmp_next_block_ctx,\n\t\t\t\t\tadditional_string, 1, 1, 0,\n\t\t\t\t\tmirror_num, NULL);\n\t\t\tif (NULL == next_block) {\n\t\t\t\tbtrfsic_release_block_ctx(&tmp_next_block_ctx);\n\t\t\t\tbrelse(bh);\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tnext_block->disk_key = tmp_disk_key;\n\t\t\tnext_block->generation = BTRFSIC_GENERATION_UNKNOWN;\n\t\t\tl = btrfsic_block_link_lookup_or_add(\n\t\t\t\t\tstate, &tmp_next_block_ctx,\n\t\t\t\t\tnext_block, superblock_tmp,\n\t\t\t\t\tBTRFSIC_GENERATION_UNKNOWN);\n\t\t\tbtrfsic_release_block_ctx(&tmp_next_block_ctx);\n\t\t\tif (NULL == l) {\n\t\t\t\tbrelse(bh);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\tif (state->print_mask & BTRFSIC_PRINT_MASK_INITIAL_ALL_TREES)\n\t\tbtrfsic_dump_tree_sub(state, superblock_tmp, 0);\n\n\tbrelse(bh);\n\treturn 0;\n}"
  },
  {
    "function_name": "btrfsic_process_superblock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/check-integrity.c",
    "lines": "656-789",
    "snippet": "static int btrfsic_process_superblock(struct btrfsic_state *state,\n\t\t\t\t      struct btrfs_fs_devices *fs_devices)\n{\n\tint ret = 0;\n\tstruct btrfs_super_block *selected_super;\n\tstruct list_head *dev_head = &fs_devices->devices;\n\tstruct btrfs_device *device;\n\tstruct btrfsic_dev_state *selected_dev_state = NULL;\n\tint pass;\n\n\tBUG_ON(NULL == state);\n\tselected_super = kzalloc(sizeof(*selected_super), GFP_NOFS);\n\tif (NULL == selected_super) {\n\t\tprintk(KERN_INFO \"btrfsic: error, kmalloc failed!\\n\");\n\t\treturn -1;\n\t}\n\n\tlist_for_each_entry(device, dev_head, dev_list) {\n\t\tint i;\n\t\tstruct btrfsic_dev_state *dev_state;\n\n\t\tif (!device->bdev || !device->name)\n\t\t\tcontinue;\n\n\t\tdev_state = btrfsic_dev_state_lookup(device->bdev);\n\t\tBUG_ON(NULL == dev_state);\n\t\tfor (i = 0; i < BTRFS_SUPER_MIRROR_MAX; i++) {\n\t\t\tret = btrfsic_process_superblock_dev_mirror(\n\t\t\t\t\tstate, dev_state, device, i,\n\t\t\t\t\t&selected_dev_state, selected_super);\n\t\t\tif (0 != ret && 0 == i) {\n\t\t\t\tkfree(selected_super);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (NULL == state->latest_superblock) {\n\t\tprintk(KERN_INFO \"btrfsic: no superblock found!\\n\");\n\t\tkfree(selected_super);\n\t\treturn -1;\n\t}\n\n\tstate->csum_size = btrfs_super_csum_size(selected_super);\n\n\tfor (pass = 0; pass < 3; pass++) {\n\t\tint num_copies;\n\t\tint mirror_num;\n\t\tu64 next_bytenr;\n\n\t\tswitch (pass) {\n\t\tcase 0:\n\t\t\tnext_bytenr = btrfs_super_root(selected_super);\n\t\t\tif (state->print_mask &\n\t\t\t    BTRFSIC_PRINT_MASK_ROOT_CHUNK_LOG_TREE_LOCATION)\n\t\t\t\tprintk(KERN_INFO \"root@%llu\\n\", next_bytenr);\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tnext_bytenr = btrfs_super_chunk_root(selected_super);\n\t\t\tif (state->print_mask &\n\t\t\t    BTRFSIC_PRINT_MASK_ROOT_CHUNK_LOG_TREE_LOCATION)\n\t\t\t\tprintk(KERN_INFO \"chunk@%llu\\n\", next_bytenr);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tnext_bytenr = btrfs_super_log_root(selected_super);\n\t\t\tif (0 == next_bytenr)\n\t\t\t\tcontinue;\n\t\t\tif (state->print_mask &\n\t\t\t    BTRFSIC_PRINT_MASK_ROOT_CHUNK_LOG_TREE_LOCATION)\n\t\t\t\tprintk(KERN_INFO \"log@%llu\\n\", next_bytenr);\n\t\t\tbreak;\n\t\t}\n\n\t\tnum_copies =\n\t\t    btrfs_num_copies(state->root->fs_info,\n\t\t\t\t     next_bytenr, state->metablock_size);\n\t\tif (state->print_mask & BTRFSIC_PRINT_MASK_NUM_COPIES)\n\t\t\tprintk(KERN_INFO \"num_copies(log_bytenr=%llu) = %d\\n\",\n\t\t\t       next_bytenr, num_copies);\n\n\t\tfor (mirror_num = 1; mirror_num <= num_copies; mirror_num++) {\n\t\t\tstruct btrfsic_block *next_block;\n\t\t\tstruct btrfsic_block_data_ctx tmp_next_block_ctx;\n\t\t\tstruct btrfsic_block_link *l;\n\n\t\t\tret = btrfsic_map_block(state, next_bytenr,\n\t\t\t\t\t\tstate->metablock_size,\n\t\t\t\t\t\t&tmp_next_block_ctx,\n\t\t\t\t\t\tmirror_num);\n\t\t\tif (ret) {\n\t\t\t\tprintk(KERN_INFO \"btrfsic:\"\n\t\t\t\t       \" btrfsic_map_block(root @%llu,\"\n\t\t\t\t       \" mirror %d) failed!\\n\",\n\t\t\t\t       next_bytenr, mirror_num);\n\t\t\t\tkfree(selected_super);\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tnext_block = btrfsic_block_hashtable_lookup(\n\t\t\t\t\ttmp_next_block_ctx.dev->bdev,\n\t\t\t\t\ttmp_next_block_ctx.dev_bytenr,\n\t\t\t\t\t&state->block_hashtable);\n\t\t\tBUG_ON(NULL == next_block);\n\n\t\t\tl = btrfsic_block_link_hashtable_lookup(\n\t\t\t\t\ttmp_next_block_ctx.dev->bdev,\n\t\t\t\t\ttmp_next_block_ctx.dev_bytenr,\n\t\t\t\t\tstate->latest_superblock->dev_state->\n\t\t\t\t\tbdev,\n\t\t\t\t\tstate->latest_superblock->dev_bytenr,\n\t\t\t\t\t&state->block_link_hashtable);\n\t\t\tBUG_ON(NULL == l);\n\n\t\t\tret = btrfsic_read_block(state, &tmp_next_block_ctx);\n\t\t\tif (ret < (int)PAGE_CACHE_SIZE) {\n\t\t\t\tprintk(KERN_INFO\n\t\t\t\t       \"btrfsic: read @logical %llu failed!\\n\",\n\t\t\t\t       tmp_next_block_ctx.start);\n\t\t\t\tbtrfsic_release_block_ctx(&tmp_next_block_ctx);\n\t\t\t\tkfree(selected_super);\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tret = btrfsic_process_metablock(state,\n\t\t\t\t\t\t\tnext_block,\n\t\t\t\t\t\t\t&tmp_next_block_ctx,\n\t\t\t\t\t\t\tBTRFS_MAX_LEVEL + 3, 1);\n\t\t\tbtrfsic_release_block_ctx(&tmp_next_block_ctx);\n\t\t}\n\t}\n\n\tkfree(selected_super);\n\treturn ret;\n}",
    "includes": [
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"volumes.h\"",
      "#include \"extent_io.h\"",
      "#include \"transaction.h\"",
      "#include \"hash.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/genhd.h>",
      "#include <linux/mutex.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [
      "#define BTRFSIC_PRINT_MASK_NUM_COPIES\t\t\t\t0x00000800",
      "#define BTRFSIC_PRINT_MASK_ROOT_CHUNK_LOG_TREE_LOCATION\t\t0x00000002"
    ],
    "globals_used": [
      "static void btrfsic_block_link_init(struct btrfsic_block_link *n);",
      "static void btrfsic_block_link_free(struct btrfsic_block_link *n);",
      "static void btrfsic_block_link_hashtable_remove(struct btrfsic_block_link *l);",
      "static int btrfsic_process_superblock(struct btrfsic_state *state,\n\t\t\t\t      struct btrfs_fs_devices *fs_devices);",
      "static int btrfsic_map_block(struct btrfsic_state *state, u64 bytenr, u32 len,\n\t\t\t     struct btrfsic_block_data_ctx *block_ctx_out,\n\t\t\t     int mirror_num);",
      "static void btrfsic_dump_database(struct btrfsic_state *state);",
      "static void btrfsic_print_add_link(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block_link *l);",
      "static void btrfsic_print_rem_link(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block_link *l);",
      "static void btrfsic_dump_tree(const struct btrfsic_state *state);",
      "static int btrfsic_process_superblock_dev_mirror(\n\t\tstruct btrfsic_state *state,\n\t\tstruct btrfsic_dev_state *dev_state,\n\t\tstruct btrfs_device *device,\n\t\tint superblock_mirror_num,\n\t\tstruct btrfsic_dev_state **selected_dev_state,\n\t\tstruct btrfs_super_block *selected_super);",
      "static struct btrfsic_dev_state *btrfsic_dev_state_lookup(\n\t\tstruct block_device *bdev);",
      "static void btrfsic_cmp_log_and_dev_bytenr(struct btrfsic_state *state,\n\t\t\t\t\t   u64 bytenr,\n\t\t\t\t\t   struct btrfsic_dev_state *dev_state,\n\t\t\t\t\t   u64 dev_bytenr);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "selected_super"
          ],
          "line": 787
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfsic_release_block_ctx",
          "args": [
            "&tmp_next_block_ctx"
          ],
          "line": 783
        },
        "resolved": true,
        "details": {
          "function_name": "btrfsic_release_block_ctx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/check-integrity.c",
          "lines": "1611-1637",
          "snippet": "static void btrfsic_release_block_ctx(struct btrfsic_block_data_ctx *block_ctx)\n{\n\tif (block_ctx->mem_to_free) {\n\t\tunsigned int num_pages;\n\n\t\tBUG_ON(!block_ctx->datav);\n\t\tBUG_ON(!block_ctx->pagev);\n\t\tnum_pages = (block_ctx->len + (u64)PAGE_CACHE_SIZE - 1) >>\n\t\t\t    PAGE_CACHE_SHIFT;\n\t\twhile (num_pages > 0) {\n\t\t\tnum_pages--;\n\t\t\tif (block_ctx->datav[num_pages]) {\n\t\t\t\tkunmap(block_ctx->pagev[num_pages]);\n\t\t\t\tblock_ctx->datav[num_pages] = NULL;\n\t\t\t}\n\t\t\tif (block_ctx->pagev[num_pages]) {\n\t\t\t\t__free_page(block_ctx->pagev[num_pages]);\n\t\t\t\tblock_ctx->pagev[num_pages] = NULL;\n\t\t\t}\n\t\t}\n\n\t\tkfree(block_ctx->mem_to_free);\n\t\tblock_ctx->mem_to_free = NULL;\n\t\tblock_ctx->pagev = NULL;\n\t\tblock_ctx->datav = NULL;\n\t}\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"extent_io.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/genhd.h>",
            "#include <linux/mutex.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void btrfsic_read_from_block_data(\n\tstruct btrfsic_block_data_ctx *block_ctx,\n\tvoid *dst, u32 offset, size_t len);",
            "static void btrfsic_release_block_ctx(struct btrfsic_block_data_ctx *block_ctx);",
            "static int btrfsic_read_block(struct btrfsic_state *state,\n\t\t\t      struct btrfsic_block_data_ctx *block_ctx);",
            "static int btrfsic_test_for_metadata(struct btrfsic_state *state,\n\t\t\t\t     char **datav, unsigned int num_pages);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"extent_io.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n#include <linux/blkdev.h>\n#include <linux/genhd.h>\n#include <linux/mutex.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic void btrfsic_read_from_block_data(\n\tstruct btrfsic_block_data_ctx *block_ctx,\n\tvoid *dst, u32 offset, size_t len);\nstatic void btrfsic_release_block_ctx(struct btrfsic_block_data_ctx *block_ctx);\nstatic int btrfsic_read_block(struct btrfsic_state *state,\n\t\t\t      struct btrfsic_block_data_ctx *block_ctx);\nstatic int btrfsic_test_for_metadata(struct btrfsic_state *state,\n\t\t\t\t     char **datav, unsigned int num_pages);\n\nstatic void btrfsic_release_block_ctx(struct btrfsic_block_data_ctx *block_ctx)\n{\n\tif (block_ctx->mem_to_free) {\n\t\tunsigned int num_pages;\n\n\t\tBUG_ON(!block_ctx->datav);\n\t\tBUG_ON(!block_ctx->pagev);\n\t\tnum_pages = (block_ctx->len + (u64)PAGE_CACHE_SIZE - 1) >>\n\t\t\t    PAGE_CACHE_SHIFT;\n\t\twhile (num_pages > 0) {\n\t\t\tnum_pages--;\n\t\t\tif (block_ctx->datav[num_pages]) {\n\t\t\t\tkunmap(block_ctx->pagev[num_pages]);\n\t\t\t\tblock_ctx->datav[num_pages] = NULL;\n\t\t\t}\n\t\t\tif (block_ctx->pagev[num_pages]) {\n\t\t\t\t__free_page(block_ctx->pagev[num_pages]);\n\t\t\t\tblock_ctx->pagev[num_pages] = NULL;\n\t\t\t}\n\t\t}\n\n\t\tkfree(block_ctx->mem_to_free);\n\t\tblock_ctx->mem_to_free = NULL;\n\t\tblock_ctx->pagev = NULL;\n\t\tblock_ctx->datav = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfsic_process_metablock",
          "args": [
            "state",
            "next_block",
            "&tmp_next_block_ctx",
            "BTRFS_MAX_LEVEL + 3",
            "1"
          ],
          "line": 779
        },
        "resolved": true,
        "details": {
          "function_name": "btrfsic_process_metablock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/check-integrity.c",
          "lines": "974-1234",
          "snippet": "static int btrfsic_process_metablock(\n\t\tstruct btrfsic_state *state,\n\t\tstruct btrfsic_block *const first_block,\n\t\tstruct btrfsic_block_data_ctx *const first_block_ctx,\n\t\tint first_limit_nesting, int force_iodone_flag)\n{\n\tstruct btrfsic_stack_frame initial_stack_frame = { 0 };\n\tstruct btrfsic_stack_frame *sf;\n\tstruct btrfsic_stack_frame *next_stack;\n\tstruct btrfs_header *const first_hdr =\n\t\t(struct btrfs_header *)first_block_ctx->datav[0];\n\n\tBUG_ON(!first_hdr);\n\tsf = &initial_stack_frame;\n\tsf->error = 0;\n\tsf->i = -1;\n\tsf->limit_nesting = first_limit_nesting;\n\tsf->block = first_block;\n\tsf->block_ctx = first_block_ctx;\n\tsf->next_block = NULL;\n\tsf->hdr = first_hdr;\n\tsf->prev = NULL;\n\ncontinue_with_new_stack_frame:\n\tsf->block->generation = le64_to_cpu(sf->hdr->generation);\n\tif (0 == sf->hdr->level) {\n\t\tstruct btrfs_leaf *const leafhdr =\n\t\t    (struct btrfs_leaf *)sf->hdr;\n\n\t\tif (-1 == sf->i) {\n\t\t\tsf->nr = btrfs_stack_header_nritems(&leafhdr->header);\n\n\t\t\tif (state->print_mask & BTRFSIC_PRINT_MASK_VERBOSE)\n\t\t\t\tprintk(KERN_INFO\n\t\t\t\t       \"leaf %llu items %d generation %llu\"\n\t\t\t\t       \" owner %llu\\n\",\n\t\t\t\t       sf->block_ctx->start, sf->nr,\n\t\t\t\t       btrfs_stack_header_generation(\n\t\t\t\t\t       &leafhdr->header),\n\t\t\t\t       btrfs_stack_header_owner(\n\t\t\t\t\t       &leafhdr->header));\n\t\t}\n\ncontinue_with_current_leaf_stack_frame:\n\t\tif (0 == sf->num_copies || sf->mirror_num > sf->num_copies) {\n\t\t\tsf->i++;\n\t\t\tsf->num_copies = 0;\n\t\t}\n\n\t\tif (sf->i < sf->nr) {\n\t\t\tstruct btrfs_item disk_item;\n\t\t\tu32 disk_item_offset =\n\t\t\t\t(uintptr_t)(leafhdr->items + sf->i) -\n\t\t\t\t(uintptr_t)leafhdr;\n\t\t\tstruct btrfs_disk_key *disk_key;\n\t\t\tu8 type;\n\t\t\tu32 item_offset;\n\t\t\tu32 item_size;\n\n\t\t\tif (disk_item_offset + sizeof(struct btrfs_item) >\n\t\t\t    sf->block_ctx->len) {\nleaf_item_out_of_bounce_error:\n\t\t\t\tprintk(KERN_INFO\n\t\t\t\t       \"btrfsic: leaf item out of bounce at logical %llu, dev %s\\n\",\n\t\t\t\t       sf->block_ctx->start,\n\t\t\t\t       sf->block_ctx->dev->name);\n\t\t\t\tgoto one_stack_frame_backwards;\n\t\t\t}\n\t\t\tbtrfsic_read_from_block_data(sf->block_ctx,\n\t\t\t\t\t\t     &disk_item,\n\t\t\t\t\t\t     disk_item_offset,\n\t\t\t\t\t\t     sizeof(struct btrfs_item));\n\t\t\titem_offset = btrfs_stack_item_offset(&disk_item);\n\t\t\titem_size = btrfs_stack_item_size(&disk_item);\n\t\t\tdisk_key = &disk_item.key;\n\t\t\ttype = btrfs_disk_key_type(disk_key);\n\n\t\t\tif (BTRFS_ROOT_ITEM_KEY == type) {\n\t\t\t\tstruct btrfs_root_item root_item;\n\t\t\t\tu32 root_item_offset;\n\t\t\t\tu64 next_bytenr;\n\n\t\t\t\troot_item_offset = item_offset +\n\t\t\t\t\toffsetof(struct btrfs_leaf, items);\n\t\t\t\tif (root_item_offset + item_size >\n\t\t\t\t    sf->block_ctx->len)\n\t\t\t\t\tgoto leaf_item_out_of_bounce_error;\n\t\t\t\tbtrfsic_read_from_block_data(\n\t\t\t\t\tsf->block_ctx, &root_item,\n\t\t\t\t\troot_item_offset,\n\t\t\t\t\titem_size);\n\t\t\t\tnext_bytenr = btrfs_root_bytenr(&root_item);\n\n\t\t\t\tsf->error =\n\t\t\t\t    btrfsic_create_link_to_next_block(\n\t\t\t\t\t\tstate,\n\t\t\t\t\t\tsf->block,\n\t\t\t\t\t\tsf->block_ctx,\n\t\t\t\t\t\tnext_bytenr,\n\t\t\t\t\t\tsf->limit_nesting,\n\t\t\t\t\t\t&sf->next_block_ctx,\n\t\t\t\t\t\t&sf->next_block,\n\t\t\t\t\t\tforce_iodone_flag,\n\t\t\t\t\t\t&sf->num_copies,\n\t\t\t\t\t\t&sf->mirror_num,\n\t\t\t\t\t\tdisk_key,\n\t\t\t\t\t\tbtrfs_root_generation(\n\t\t\t\t\t\t&root_item));\n\t\t\t\tif (sf->error)\n\t\t\t\t\tgoto one_stack_frame_backwards;\n\n\t\t\t\tif (NULL != sf->next_block) {\n\t\t\t\t\tstruct btrfs_header *const next_hdr =\n\t\t\t\t\t    (struct btrfs_header *)\n\t\t\t\t\t    sf->next_block_ctx.datav[0];\n\n\t\t\t\t\tnext_stack =\n\t\t\t\t\t    btrfsic_stack_frame_alloc();\n\t\t\t\t\tif (NULL == next_stack) {\n\t\t\t\t\t\tsf->error = -1;\n\t\t\t\t\t\tbtrfsic_release_block_ctx(\n\t\t\t\t\t\t\t\t&sf->\n\t\t\t\t\t\t\t\tnext_block_ctx);\n\t\t\t\t\t\tgoto one_stack_frame_backwards;\n\t\t\t\t\t}\n\n\t\t\t\t\tnext_stack->i = -1;\n\t\t\t\t\tnext_stack->block = sf->next_block;\n\t\t\t\t\tnext_stack->block_ctx =\n\t\t\t\t\t    &sf->next_block_ctx;\n\t\t\t\t\tnext_stack->next_block = NULL;\n\t\t\t\t\tnext_stack->hdr = next_hdr;\n\t\t\t\t\tnext_stack->limit_nesting =\n\t\t\t\t\t    sf->limit_nesting - 1;\n\t\t\t\t\tnext_stack->prev = sf;\n\t\t\t\t\tsf = next_stack;\n\t\t\t\t\tgoto continue_with_new_stack_frame;\n\t\t\t\t}\n\t\t\t} else if (BTRFS_EXTENT_DATA_KEY == type &&\n\t\t\t\t   state->include_extent_data) {\n\t\t\t\tsf->error = btrfsic_handle_extent_data(\n\t\t\t\t\t\tstate,\n\t\t\t\t\t\tsf->block,\n\t\t\t\t\t\tsf->block_ctx,\n\t\t\t\t\t\titem_offset,\n\t\t\t\t\t\tforce_iodone_flag);\n\t\t\t\tif (sf->error)\n\t\t\t\t\tgoto one_stack_frame_backwards;\n\t\t\t}\n\n\t\t\tgoto continue_with_current_leaf_stack_frame;\n\t\t}\n\t} else {\n\t\tstruct btrfs_node *const nodehdr = (struct btrfs_node *)sf->hdr;\n\n\t\tif (-1 == sf->i) {\n\t\t\tsf->nr = btrfs_stack_header_nritems(&nodehdr->header);\n\n\t\t\tif (state->print_mask & BTRFSIC_PRINT_MASK_VERBOSE)\n\t\t\t\tprintk(KERN_INFO \"node %llu level %d items %d\"\n\t\t\t\t       \" generation %llu owner %llu\\n\",\n\t\t\t\t       sf->block_ctx->start,\n\t\t\t\t       nodehdr->header.level, sf->nr,\n\t\t\t\t       btrfs_stack_header_generation(\n\t\t\t\t       &nodehdr->header),\n\t\t\t\t       btrfs_stack_header_owner(\n\t\t\t\t       &nodehdr->header));\n\t\t}\n\ncontinue_with_current_node_stack_frame:\n\t\tif (0 == sf->num_copies || sf->mirror_num > sf->num_copies) {\n\t\t\tsf->i++;\n\t\t\tsf->num_copies = 0;\n\t\t}\n\n\t\tif (sf->i < sf->nr) {\n\t\t\tstruct btrfs_key_ptr key_ptr;\n\t\t\tu32 key_ptr_offset;\n\t\t\tu64 next_bytenr;\n\n\t\t\tkey_ptr_offset = (uintptr_t)(nodehdr->ptrs + sf->i) -\n\t\t\t\t\t  (uintptr_t)nodehdr;\n\t\t\tif (key_ptr_offset + sizeof(struct btrfs_key_ptr) >\n\t\t\t    sf->block_ctx->len) {\n\t\t\t\tprintk(KERN_INFO\n\t\t\t\t       \"btrfsic: node item out of bounce at logical %llu, dev %s\\n\",\n\t\t\t\t       sf->block_ctx->start,\n\t\t\t\t       sf->block_ctx->dev->name);\n\t\t\t\tgoto one_stack_frame_backwards;\n\t\t\t}\n\t\t\tbtrfsic_read_from_block_data(\n\t\t\t\tsf->block_ctx, &key_ptr, key_ptr_offset,\n\t\t\t\tsizeof(struct btrfs_key_ptr));\n\t\t\tnext_bytenr = btrfs_stack_key_blockptr(&key_ptr);\n\n\t\t\tsf->error = btrfsic_create_link_to_next_block(\n\t\t\t\t\tstate,\n\t\t\t\t\tsf->block,\n\t\t\t\t\tsf->block_ctx,\n\t\t\t\t\tnext_bytenr,\n\t\t\t\t\tsf->limit_nesting,\n\t\t\t\t\t&sf->next_block_ctx,\n\t\t\t\t\t&sf->next_block,\n\t\t\t\t\tforce_iodone_flag,\n\t\t\t\t\t&sf->num_copies,\n\t\t\t\t\t&sf->mirror_num,\n\t\t\t\t\t&key_ptr.key,\n\t\t\t\t\tbtrfs_stack_key_generation(&key_ptr));\n\t\t\tif (sf->error)\n\t\t\t\tgoto one_stack_frame_backwards;\n\n\t\t\tif (NULL != sf->next_block) {\n\t\t\t\tstruct btrfs_header *const next_hdr =\n\t\t\t\t    (struct btrfs_header *)\n\t\t\t\t    sf->next_block_ctx.datav[0];\n\n\t\t\t\tnext_stack = btrfsic_stack_frame_alloc();\n\t\t\t\tif (NULL == next_stack) {\n\t\t\t\t\tsf->error = -1;\n\t\t\t\t\tgoto one_stack_frame_backwards;\n\t\t\t\t}\n\n\t\t\t\tnext_stack->i = -1;\n\t\t\t\tnext_stack->block = sf->next_block;\n\t\t\t\tnext_stack->block_ctx = &sf->next_block_ctx;\n\t\t\t\tnext_stack->next_block = NULL;\n\t\t\t\tnext_stack->hdr = next_hdr;\n\t\t\t\tnext_stack->limit_nesting =\n\t\t\t\t    sf->limit_nesting - 1;\n\t\t\t\tnext_stack->prev = sf;\n\t\t\t\tsf = next_stack;\n\t\t\t\tgoto continue_with_new_stack_frame;\n\t\t\t}\n\n\t\t\tgoto continue_with_current_node_stack_frame;\n\t\t}\n\t}\n\none_stack_frame_backwards:\n\tif (NULL != sf->prev) {\n\t\tstruct btrfsic_stack_frame *const prev = sf->prev;\n\n\t\t/* the one for the initial block is freed in the caller */\n\t\tbtrfsic_release_block_ctx(sf->block_ctx);\n\n\t\tif (sf->error) {\n\t\t\tprev->error = sf->error;\n\t\t\tbtrfsic_stack_frame_free(sf);\n\t\t\tsf = prev;\n\t\t\tgoto one_stack_frame_backwards;\n\t\t}\n\n\t\tbtrfsic_stack_frame_free(sf);\n\t\tsf = prev;\n\t\tgoto continue_with_new_stack_frame;\n\t} else {\n\t\tBUG_ON(&initial_stack_frame != sf);\n\t}\n\n\treturn sf->error;\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"extent_io.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/genhd.h>",
            "#include <linux/mutex.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define BTRFSIC_PRINT_MASK_VERBOSE\t\t\t\t0x00000040"
          ],
          "globals_used": [
            "static void btrfsic_block_link_init(struct btrfsic_block_link *n);",
            "static void btrfsic_block_link_free(struct btrfsic_block_link *n);",
            "static struct btrfsic_stack_frame *btrfsic_stack_frame_alloc(void);",
            "static void btrfsic_stack_frame_free(struct btrfsic_stack_frame *sf);",
            "static int btrfsic_process_metablock(struct btrfsic_state *state,\n\t\t\t\t     struct btrfsic_block *block,\n\t\t\t\t     struct btrfsic_block_data_ctx *block_ctx,\n\t\t\t\t     int limit_nesting, int force_iodone_flag);",
            "static void btrfsic_read_from_block_data(\n\tstruct btrfsic_block_data_ctx *block_ctx,\n\tvoid *dst, u32 offset, size_t len);",
            "static int btrfsic_handle_extent_data(struct btrfsic_state *state,\n\t\t\t\t      struct btrfsic_block *block,\n\t\t\t\t      struct btrfsic_block_data_ctx *block_ctx,\n\t\t\t\t      u32 item_offset, int force_iodone_flag);",
            "static int btrfsic_map_block(struct btrfsic_state *state, u64 bytenr, u32 len,\n\t\t\t     struct btrfsic_block_data_ctx *block_ctx_out,\n\t\t\t     int mirror_num);",
            "static void btrfsic_release_block_ctx(struct btrfsic_block_data_ctx *block_ctx);",
            "static int btrfsic_read_block(struct btrfsic_state *state,\n\t\t\t      struct btrfsic_block_data_ctx *block_ctx);",
            "static void btrfsic_dump_database(struct btrfsic_state *state);",
            "static char btrfsic_get_block_type(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block *block);",
            "static void btrfsic_dump_tree(const struct btrfsic_state *state);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"extent_io.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n#include <linux/blkdev.h>\n#include <linux/genhd.h>\n#include <linux/mutex.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\n#define BTRFSIC_PRINT_MASK_VERBOSE\t\t\t\t0x00000040\n\nstatic void btrfsic_block_link_init(struct btrfsic_block_link *n);\nstatic void btrfsic_block_link_free(struct btrfsic_block_link *n);\nstatic struct btrfsic_stack_frame *btrfsic_stack_frame_alloc(void);\nstatic void btrfsic_stack_frame_free(struct btrfsic_stack_frame *sf);\nstatic int btrfsic_process_metablock(struct btrfsic_state *state,\n\t\t\t\t     struct btrfsic_block *block,\n\t\t\t\t     struct btrfsic_block_data_ctx *block_ctx,\n\t\t\t\t     int limit_nesting, int force_iodone_flag);\nstatic void btrfsic_read_from_block_data(\n\tstruct btrfsic_block_data_ctx *block_ctx,\n\tvoid *dst, u32 offset, size_t len);\nstatic int btrfsic_handle_extent_data(struct btrfsic_state *state,\n\t\t\t\t      struct btrfsic_block *block,\n\t\t\t\t      struct btrfsic_block_data_ctx *block_ctx,\n\t\t\t\t      u32 item_offset, int force_iodone_flag);\nstatic int btrfsic_map_block(struct btrfsic_state *state, u64 bytenr, u32 len,\n\t\t\t     struct btrfsic_block_data_ctx *block_ctx_out,\n\t\t\t     int mirror_num);\nstatic void btrfsic_release_block_ctx(struct btrfsic_block_data_ctx *block_ctx);\nstatic int btrfsic_read_block(struct btrfsic_state *state,\n\t\t\t      struct btrfsic_block_data_ctx *block_ctx);\nstatic void btrfsic_dump_database(struct btrfsic_state *state);\nstatic char btrfsic_get_block_type(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block *block);\nstatic void btrfsic_dump_tree(const struct btrfsic_state *state);\n\nstatic int btrfsic_process_metablock(\n\t\tstruct btrfsic_state *state,\n\t\tstruct btrfsic_block *const first_block,\n\t\tstruct btrfsic_block_data_ctx *const first_block_ctx,\n\t\tint first_limit_nesting, int force_iodone_flag)\n{\n\tstruct btrfsic_stack_frame initial_stack_frame = { 0 };\n\tstruct btrfsic_stack_frame *sf;\n\tstruct btrfsic_stack_frame *next_stack;\n\tstruct btrfs_header *const first_hdr =\n\t\t(struct btrfs_header *)first_block_ctx->datav[0];\n\n\tBUG_ON(!first_hdr);\n\tsf = &initial_stack_frame;\n\tsf->error = 0;\n\tsf->i = -1;\n\tsf->limit_nesting = first_limit_nesting;\n\tsf->block = first_block;\n\tsf->block_ctx = first_block_ctx;\n\tsf->next_block = NULL;\n\tsf->hdr = first_hdr;\n\tsf->prev = NULL;\n\ncontinue_with_new_stack_frame:\n\tsf->block->generation = le64_to_cpu(sf->hdr->generation);\n\tif (0 == sf->hdr->level) {\n\t\tstruct btrfs_leaf *const leafhdr =\n\t\t    (struct btrfs_leaf *)sf->hdr;\n\n\t\tif (-1 == sf->i) {\n\t\t\tsf->nr = btrfs_stack_header_nritems(&leafhdr->header);\n\n\t\t\tif (state->print_mask & BTRFSIC_PRINT_MASK_VERBOSE)\n\t\t\t\tprintk(KERN_INFO\n\t\t\t\t       \"leaf %llu items %d generation %llu\"\n\t\t\t\t       \" owner %llu\\n\",\n\t\t\t\t       sf->block_ctx->start, sf->nr,\n\t\t\t\t       btrfs_stack_header_generation(\n\t\t\t\t\t       &leafhdr->header),\n\t\t\t\t       btrfs_stack_header_owner(\n\t\t\t\t\t       &leafhdr->header));\n\t\t}\n\ncontinue_with_current_leaf_stack_frame:\n\t\tif (0 == sf->num_copies || sf->mirror_num > sf->num_copies) {\n\t\t\tsf->i++;\n\t\t\tsf->num_copies = 0;\n\t\t}\n\n\t\tif (sf->i < sf->nr) {\n\t\t\tstruct btrfs_item disk_item;\n\t\t\tu32 disk_item_offset =\n\t\t\t\t(uintptr_t)(leafhdr->items + sf->i) -\n\t\t\t\t(uintptr_t)leafhdr;\n\t\t\tstruct btrfs_disk_key *disk_key;\n\t\t\tu8 type;\n\t\t\tu32 item_offset;\n\t\t\tu32 item_size;\n\n\t\t\tif (disk_item_offset + sizeof(struct btrfs_item) >\n\t\t\t    sf->block_ctx->len) {\nleaf_item_out_of_bounce_error:\n\t\t\t\tprintk(KERN_INFO\n\t\t\t\t       \"btrfsic: leaf item out of bounce at logical %llu, dev %s\\n\",\n\t\t\t\t       sf->block_ctx->start,\n\t\t\t\t       sf->block_ctx->dev->name);\n\t\t\t\tgoto one_stack_frame_backwards;\n\t\t\t}\n\t\t\tbtrfsic_read_from_block_data(sf->block_ctx,\n\t\t\t\t\t\t     &disk_item,\n\t\t\t\t\t\t     disk_item_offset,\n\t\t\t\t\t\t     sizeof(struct btrfs_item));\n\t\t\titem_offset = btrfs_stack_item_offset(&disk_item);\n\t\t\titem_size = btrfs_stack_item_size(&disk_item);\n\t\t\tdisk_key = &disk_item.key;\n\t\t\ttype = btrfs_disk_key_type(disk_key);\n\n\t\t\tif (BTRFS_ROOT_ITEM_KEY == type) {\n\t\t\t\tstruct btrfs_root_item root_item;\n\t\t\t\tu32 root_item_offset;\n\t\t\t\tu64 next_bytenr;\n\n\t\t\t\troot_item_offset = item_offset +\n\t\t\t\t\toffsetof(struct btrfs_leaf, items);\n\t\t\t\tif (root_item_offset + item_size >\n\t\t\t\t    sf->block_ctx->len)\n\t\t\t\t\tgoto leaf_item_out_of_bounce_error;\n\t\t\t\tbtrfsic_read_from_block_data(\n\t\t\t\t\tsf->block_ctx, &root_item,\n\t\t\t\t\troot_item_offset,\n\t\t\t\t\titem_size);\n\t\t\t\tnext_bytenr = btrfs_root_bytenr(&root_item);\n\n\t\t\t\tsf->error =\n\t\t\t\t    btrfsic_create_link_to_next_block(\n\t\t\t\t\t\tstate,\n\t\t\t\t\t\tsf->block,\n\t\t\t\t\t\tsf->block_ctx,\n\t\t\t\t\t\tnext_bytenr,\n\t\t\t\t\t\tsf->limit_nesting,\n\t\t\t\t\t\t&sf->next_block_ctx,\n\t\t\t\t\t\t&sf->next_block,\n\t\t\t\t\t\tforce_iodone_flag,\n\t\t\t\t\t\t&sf->num_copies,\n\t\t\t\t\t\t&sf->mirror_num,\n\t\t\t\t\t\tdisk_key,\n\t\t\t\t\t\tbtrfs_root_generation(\n\t\t\t\t\t\t&root_item));\n\t\t\t\tif (sf->error)\n\t\t\t\t\tgoto one_stack_frame_backwards;\n\n\t\t\t\tif (NULL != sf->next_block) {\n\t\t\t\t\tstruct btrfs_header *const next_hdr =\n\t\t\t\t\t    (struct btrfs_header *)\n\t\t\t\t\t    sf->next_block_ctx.datav[0];\n\n\t\t\t\t\tnext_stack =\n\t\t\t\t\t    btrfsic_stack_frame_alloc();\n\t\t\t\t\tif (NULL == next_stack) {\n\t\t\t\t\t\tsf->error = -1;\n\t\t\t\t\t\tbtrfsic_release_block_ctx(\n\t\t\t\t\t\t\t\t&sf->\n\t\t\t\t\t\t\t\tnext_block_ctx);\n\t\t\t\t\t\tgoto one_stack_frame_backwards;\n\t\t\t\t\t}\n\n\t\t\t\t\tnext_stack->i = -1;\n\t\t\t\t\tnext_stack->block = sf->next_block;\n\t\t\t\t\tnext_stack->block_ctx =\n\t\t\t\t\t    &sf->next_block_ctx;\n\t\t\t\t\tnext_stack->next_block = NULL;\n\t\t\t\t\tnext_stack->hdr = next_hdr;\n\t\t\t\t\tnext_stack->limit_nesting =\n\t\t\t\t\t    sf->limit_nesting - 1;\n\t\t\t\t\tnext_stack->prev = sf;\n\t\t\t\t\tsf = next_stack;\n\t\t\t\t\tgoto continue_with_new_stack_frame;\n\t\t\t\t}\n\t\t\t} else if (BTRFS_EXTENT_DATA_KEY == type &&\n\t\t\t\t   state->include_extent_data) {\n\t\t\t\tsf->error = btrfsic_handle_extent_data(\n\t\t\t\t\t\tstate,\n\t\t\t\t\t\tsf->block,\n\t\t\t\t\t\tsf->block_ctx,\n\t\t\t\t\t\titem_offset,\n\t\t\t\t\t\tforce_iodone_flag);\n\t\t\t\tif (sf->error)\n\t\t\t\t\tgoto one_stack_frame_backwards;\n\t\t\t}\n\n\t\t\tgoto continue_with_current_leaf_stack_frame;\n\t\t}\n\t} else {\n\t\tstruct btrfs_node *const nodehdr = (struct btrfs_node *)sf->hdr;\n\n\t\tif (-1 == sf->i) {\n\t\t\tsf->nr = btrfs_stack_header_nritems(&nodehdr->header);\n\n\t\t\tif (state->print_mask & BTRFSIC_PRINT_MASK_VERBOSE)\n\t\t\t\tprintk(KERN_INFO \"node %llu level %d items %d\"\n\t\t\t\t       \" generation %llu owner %llu\\n\",\n\t\t\t\t       sf->block_ctx->start,\n\t\t\t\t       nodehdr->header.level, sf->nr,\n\t\t\t\t       btrfs_stack_header_generation(\n\t\t\t\t       &nodehdr->header),\n\t\t\t\t       btrfs_stack_header_owner(\n\t\t\t\t       &nodehdr->header));\n\t\t}\n\ncontinue_with_current_node_stack_frame:\n\t\tif (0 == sf->num_copies || sf->mirror_num > sf->num_copies) {\n\t\t\tsf->i++;\n\t\t\tsf->num_copies = 0;\n\t\t}\n\n\t\tif (sf->i < sf->nr) {\n\t\t\tstruct btrfs_key_ptr key_ptr;\n\t\t\tu32 key_ptr_offset;\n\t\t\tu64 next_bytenr;\n\n\t\t\tkey_ptr_offset = (uintptr_t)(nodehdr->ptrs + sf->i) -\n\t\t\t\t\t  (uintptr_t)nodehdr;\n\t\t\tif (key_ptr_offset + sizeof(struct btrfs_key_ptr) >\n\t\t\t    sf->block_ctx->len) {\n\t\t\t\tprintk(KERN_INFO\n\t\t\t\t       \"btrfsic: node item out of bounce at logical %llu, dev %s\\n\",\n\t\t\t\t       sf->block_ctx->start,\n\t\t\t\t       sf->block_ctx->dev->name);\n\t\t\t\tgoto one_stack_frame_backwards;\n\t\t\t}\n\t\t\tbtrfsic_read_from_block_data(\n\t\t\t\tsf->block_ctx, &key_ptr, key_ptr_offset,\n\t\t\t\tsizeof(struct btrfs_key_ptr));\n\t\t\tnext_bytenr = btrfs_stack_key_blockptr(&key_ptr);\n\n\t\t\tsf->error = btrfsic_create_link_to_next_block(\n\t\t\t\t\tstate,\n\t\t\t\t\tsf->block,\n\t\t\t\t\tsf->block_ctx,\n\t\t\t\t\tnext_bytenr,\n\t\t\t\t\tsf->limit_nesting,\n\t\t\t\t\t&sf->next_block_ctx,\n\t\t\t\t\t&sf->next_block,\n\t\t\t\t\tforce_iodone_flag,\n\t\t\t\t\t&sf->num_copies,\n\t\t\t\t\t&sf->mirror_num,\n\t\t\t\t\t&key_ptr.key,\n\t\t\t\t\tbtrfs_stack_key_generation(&key_ptr));\n\t\t\tif (sf->error)\n\t\t\t\tgoto one_stack_frame_backwards;\n\n\t\t\tif (NULL != sf->next_block) {\n\t\t\t\tstruct btrfs_header *const next_hdr =\n\t\t\t\t    (struct btrfs_header *)\n\t\t\t\t    sf->next_block_ctx.datav[0];\n\n\t\t\t\tnext_stack = btrfsic_stack_frame_alloc();\n\t\t\t\tif (NULL == next_stack) {\n\t\t\t\t\tsf->error = -1;\n\t\t\t\t\tgoto one_stack_frame_backwards;\n\t\t\t\t}\n\n\t\t\t\tnext_stack->i = -1;\n\t\t\t\tnext_stack->block = sf->next_block;\n\t\t\t\tnext_stack->block_ctx = &sf->next_block_ctx;\n\t\t\t\tnext_stack->next_block = NULL;\n\t\t\t\tnext_stack->hdr = next_hdr;\n\t\t\t\tnext_stack->limit_nesting =\n\t\t\t\t    sf->limit_nesting - 1;\n\t\t\t\tnext_stack->prev = sf;\n\t\t\t\tsf = next_stack;\n\t\t\t\tgoto continue_with_new_stack_frame;\n\t\t\t}\n\n\t\t\tgoto continue_with_current_node_stack_frame;\n\t\t}\n\t}\n\none_stack_frame_backwards:\n\tif (NULL != sf->prev) {\n\t\tstruct btrfsic_stack_frame *const prev = sf->prev;\n\n\t\t/* the one for the initial block is freed in the caller */\n\t\tbtrfsic_release_block_ctx(sf->block_ctx);\n\n\t\tif (sf->error) {\n\t\t\tprev->error = sf->error;\n\t\t\tbtrfsic_stack_frame_free(sf);\n\t\t\tsf = prev;\n\t\t\tgoto one_stack_frame_backwards;\n\t\t}\n\n\t\tbtrfsic_stack_frame_free(sf);\n\t\tsf = prev;\n\t\tgoto continue_with_new_stack_frame;\n\t} else {\n\t\tBUG_ON(&initial_stack_frame != sf);\n\t}\n\n\treturn sf->error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "selected_super"
          ],
          "line": 775
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_INFO\n\t\t\t\t       \"btrfsic: read @logical %llu failed!\\n\"",
            "tmp_next_block_ctx.start"
          ],
          "line": 771
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/super.c",
          "lines": "186-213",
          "snippet": "void btrfs_printk(const struct btrfs_fs_info *fs_info, const char *fmt, ...)\n{\n\tstruct super_block *sb = fs_info->sb;\n\tchar lvl[4];\n\tstruct va_format vaf;\n\tva_list args;\n\tconst char *type = logtypes[4];\n\tint kern_level;\n\n\tva_start(args, fmt);\n\n\tkern_level = printk_get_level(fmt);\n\tif (kern_level) {\n\t\tsize_t size = printk_skip_level(fmt) - fmt;\n\t\tmemcpy(lvl, fmt,  size);\n\t\tlvl[size] = '\\0';\n\t\tfmt += size;\n\t\ttype = logtypes[kern_level - '0'];\n\t} else\n\t\t*lvl = '\\0';\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sBTRFS %s (device %s): %pV\\n\", lvl, type, sb->s_id, &vaf);\n\n\tva_end(args);\n}",
          "includes": [
            "#include <trace/events/btrfs.h>",
            "#include \"qgroup.h\"",
            "#include \"tests/btrfs-tests.h\"",
            "#include \"backref.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"compression.h\"",
            "#include \"export.h\"",
            "#include \"volumes.h\"",
            "#include \"xattr.h\"",
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/slab.h>",
            "#include <linux/magic.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/namei.h>",
            "#include <linux/ctype.h>",
            "#include <linux/parser.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/btrfs.h>\n#include \"qgroup.h\"\n#include \"tests/btrfs-tests.h\"\n#include \"backref.h\"\n#include \"free-space-cache.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"compression.h\"\n#include \"export.h\"\n#include \"volumes.h\"\n#include \"xattr.h\"\n#include \"props.h\"\n#include \"hash.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include \"delayed-inode.h\"\n#include <linux/btrfs.h>\n#include <linux/ratelimit.h>\n#include <linux/cleancache.h>\n#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/miscdevice.h>\n#include <linux/namei.h>\n#include <linux/ctype.h>\n#include <linux/parser.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n\nvoid btrfs_printk(const struct btrfs_fs_info *fs_info, const char *fmt, ...)\n{\n\tstruct super_block *sb = fs_info->sb;\n\tchar lvl[4];\n\tstruct va_format vaf;\n\tva_list args;\n\tconst char *type = logtypes[4];\n\tint kern_level;\n\n\tva_start(args, fmt);\n\n\tkern_level = printk_get_level(fmt);\n\tif (kern_level) {\n\t\tsize_t size = printk_skip_level(fmt) - fmt;\n\t\tmemcpy(lvl, fmt,  size);\n\t\tlvl[size] = '\\0';\n\t\tfmt += size;\n\t\ttype = logtypes[kern_level - '0'];\n\t} else\n\t\t*lvl = '\\0';\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sBTRFS %s (device %s): %pV\\n\", lvl, type, sb->s_id, &vaf);\n\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfsic_read_block",
          "args": [
            "state",
            "&tmp_next_block_ctx"
          ],
          "line": 769
        },
        "resolved": true,
        "details": {
          "function_name": "btrfsic_read_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/check-integrity.c",
          "lines": "1639-1719",
          "snippet": "static int btrfsic_read_block(struct btrfsic_state *state,\n\t\t\t      struct btrfsic_block_data_ctx *block_ctx)\n{\n\tunsigned int num_pages;\n\tunsigned int i;\n\tu64 dev_bytenr;\n\tint ret;\n\n\tBUG_ON(block_ctx->datav);\n\tBUG_ON(block_ctx->pagev);\n\tBUG_ON(block_ctx->mem_to_free);\n\tif (block_ctx->dev_bytenr & ((u64)PAGE_CACHE_SIZE - 1)) {\n\t\tprintk(KERN_INFO\n\t\t       \"btrfsic: read_block() with unaligned bytenr %llu\\n\",\n\t\t       block_ctx->dev_bytenr);\n\t\treturn -1;\n\t}\n\n\tnum_pages = (block_ctx->len + (u64)PAGE_CACHE_SIZE - 1) >>\n\t\t    PAGE_CACHE_SHIFT;\n\tblock_ctx->mem_to_free = kzalloc((sizeof(*block_ctx->datav) +\n\t\t\t\t\t  sizeof(*block_ctx->pagev)) *\n\t\t\t\t\t num_pages, GFP_NOFS);\n\tif (!block_ctx->mem_to_free)\n\t\treturn -1;\n\tblock_ctx->datav = block_ctx->mem_to_free;\n\tblock_ctx->pagev = (struct page **)(block_ctx->datav + num_pages);\n\tfor (i = 0; i < num_pages; i++) {\n\t\tblock_ctx->pagev[i] = alloc_page(GFP_NOFS);\n\t\tif (!block_ctx->pagev[i])\n\t\t\treturn -1;\n\t}\n\n\tdev_bytenr = block_ctx->dev_bytenr;\n\tfor (i = 0; i < num_pages;) {\n\t\tstruct bio *bio;\n\t\tunsigned int j;\n\n\t\tbio = btrfs_io_bio_alloc(GFP_NOFS, num_pages - i);\n\t\tif (!bio) {\n\t\t\tprintk(KERN_INFO\n\t\t\t       \"btrfsic: bio_alloc() for %u pages failed!\\n\",\n\t\t\t       num_pages - i);\n\t\t\treturn -1;\n\t\t}\n\t\tbio->bi_bdev = block_ctx->dev->bdev;\n\t\tbio->bi_iter.bi_sector = dev_bytenr >> 9;\n\n\t\tfor (j = i; j < num_pages; j++) {\n\t\t\tret = bio_add_page(bio, block_ctx->pagev[j],\n\t\t\t\t\t   PAGE_CACHE_SIZE, 0);\n\t\t\tif (PAGE_CACHE_SIZE != ret)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (j == i) {\n\t\t\tprintk(KERN_INFO\n\t\t\t       \"btrfsic: error, failed to add a single page!\\n\");\n\t\t\treturn -1;\n\t\t}\n\t\tif (submit_bio_wait(READ, bio)) {\n\t\t\tprintk(KERN_INFO\n\t\t\t       \"btrfsic: read error at logical %llu dev %s!\\n\",\n\t\t\t       block_ctx->start, block_ctx->dev->name);\n\t\t\tbio_put(bio);\n\t\t\treturn -1;\n\t\t}\n\t\tbio_put(bio);\n\t\tdev_bytenr += (j - i) * PAGE_CACHE_SIZE;\n\t\ti = j;\n\t}\n\tfor (i = 0; i < num_pages; i++) {\n\t\tblock_ctx->datav[i] = kmap(block_ctx->pagev[i]);\n\t\tif (!block_ctx->datav[i]) {\n\t\t\tprintk(KERN_INFO \"btrfsic: kmap() failed (dev %s)!\\n\",\n\t\t\t       block_ctx->dev->name);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn block_ctx->len;\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"extent_io.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/genhd.h>",
            "#include <linux/mutex.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void btrfsic_block_link_init(struct btrfsic_block_link *n);",
            "static void btrfsic_block_link_free(struct btrfsic_block_link *n);",
            "static void btrfsic_read_from_block_data(\n\tstruct btrfsic_block_data_ctx *block_ctx,\n\tvoid *dst, u32 offset, size_t len);",
            "static void btrfsic_release_block_ctx(struct btrfsic_block_data_ctx *block_ctx);",
            "static int btrfsic_read_block(struct btrfsic_state *state,\n\t\t\t      struct btrfsic_block_data_ctx *block_ctx);",
            "static void btrfsic_dump_database(struct btrfsic_state *state);",
            "static int btrfsic_test_for_metadata(struct btrfsic_state *state,\n\t\t\t\t     char **datav, unsigned int num_pages);",
            "static void btrfsic_dump_tree(const struct btrfsic_state *state);",
            "static struct btrfsic_dev_state *btrfsic_dev_state_lookup(\n\t\tstruct block_device *bdev);",
            "static void btrfsic_cmp_log_and_dev_bytenr(struct btrfsic_state *state,\n\t\t\t\t\t   u64 bytenr,\n\t\t\t\t\t   struct btrfsic_dev_state *dev_state,\n\t\t\t\t\t   u64 dev_bytenr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"extent_io.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n#include <linux/blkdev.h>\n#include <linux/genhd.h>\n#include <linux/mutex.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic void btrfsic_block_link_init(struct btrfsic_block_link *n);\nstatic void btrfsic_block_link_free(struct btrfsic_block_link *n);\nstatic void btrfsic_read_from_block_data(\n\tstruct btrfsic_block_data_ctx *block_ctx,\n\tvoid *dst, u32 offset, size_t len);\nstatic void btrfsic_release_block_ctx(struct btrfsic_block_data_ctx *block_ctx);\nstatic int btrfsic_read_block(struct btrfsic_state *state,\n\t\t\t      struct btrfsic_block_data_ctx *block_ctx);\nstatic void btrfsic_dump_database(struct btrfsic_state *state);\nstatic int btrfsic_test_for_metadata(struct btrfsic_state *state,\n\t\t\t\t     char **datav, unsigned int num_pages);\nstatic void btrfsic_dump_tree(const struct btrfsic_state *state);\nstatic struct btrfsic_dev_state *btrfsic_dev_state_lookup(\n\t\tstruct block_device *bdev);\nstatic void btrfsic_cmp_log_and_dev_bytenr(struct btrfsic_state *state,\n\t\t\t\t\t   u64 bytenr,\n\t\t\t\t\t   struct btrfsic_dev_state *dev_state,\n\t\t\t\t\t   u64 dev_bytenr);\n\nstatic int btrfsic_read_block(struct btrfsic_state *state,\n\t\t\t      struct btrfsic_block_data_ctx *block_ctx)\n{\n\tunsigned int num_pages;\n\tunsigned int i;\n\tu64 dev_bytenr;\n\tint ret;\n\n\tBUG_ON(block_ctx->datav);\n\tBUG_ON(block_ctx->pagev);\n\tBUG_ON(block_ctx->mem_to_free);\n\tif (block_ctx->dev_bytenr & ((u64)PAGE_CACHE_SIZE - 1)) {\n\t\tprintk(KERN_INFO\n\t\t       \"btrfsic: read_block() with unaligned bytenr %llu\\n\",\n\t\t       block_ctx->dev_bytenr);\n\t\treturn -1;\n\t}\n\n\tnum_pages = (block_ctx->len + (u64)PAGE_CACHE_SIZE - 1) >>\n\t\t    PAGE_CACHE_SHIFT;\n\tblock_ctx->mem_to_free = kzalloc((sizeof(*block_ctx->datav) +\n\t\t\t\t\t  sizeof(*block_ctx->pagev)) *\n\t\t\t\t\t num_pages, GFP_NOFS);\n\tif (!block_ctx->mem_to_free)\n\t\treturn -1;\n\tblock_ctx->datav = block_ctx->mem_to_free;\n\tblock_ctx->pagev = (struct page **)(block_ctx->datav + num_pages);\n\tfor (i = 0; i < num_pages; i++) {\n\t\tblock_ctx->pagev[i] = alloc_page(GFP_NOFS);\n\t\tif (!block_ctx->pagev[i])\n\t\t\treturn -1;\n\t}\n\n\tdev_bytenr = block_ctx->dev_bytenr;\n\tfor (i = 0; i < num_pages;) {\n\t\tstruct bio *bio;\n\t\tunsigned int j;\n\n\t\tbio = btrfs_io_bio_alloc(GFP_NOFS, num_pages - i);\n\t\tif (!bio) {\n\t\t\tprintk(KERN_INFO\n\t\t\t       \"btrfsic: bio_alloc() for %u pages failed!\\n\",\n\t\t\t       num_pages - i);\n\t\t\treturn -1;\n\t\t}\n\t\tbio->bi_bdev = block_ctx->dev->bdev;\n\t\tbio->bi_iter.bi_sector = dev_bytenr >> 9;\n\n\t\tfor (j = i; j < num_pages; j++) {\n\t\t\tret = bio_add_page(bio, block_ctx->pagev[j],\n\t\t\t\t\t   PAGE_CACHE_SIZE, 0);\n\t\t\tif (PAGE_CACHE_SIZE != ret)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (j == i) {\n\t\t\tprintk(KERN_INFO\n\t\t\t       \"btrfsic: error, failed to add a single page!\\n\");\n\t\t\treturn -1;\n\t\t}\n\t\tif (submit_bio_wait(READ, bio)) {\n\t\t\tprintk(KERN_INFO\n\t\t\t       \"btrfsic: read error at logical %llu dev %s!\\n\",\n\t\t\t       block_ctx->start, block_ctx->dev->name);\n\t\t\tbio_put(bio);\n\t\t\treturn -1;\n\t\t}\n\t\tbio_put(bio);\n\t\tdev_bytenr += (j - i) * PAGE_CACHE_SIZE;\n\t\ti = j;\n\t}\n\tfor (i = 0; i < num_pages; i++) {\n\t\tblock_ctx->datav[i] = kmap(block_ctx->pagev[i]);\n\t\tif (!block_ctx->datav[i]) {\n\t\t\tprintk(KERN_INFO \"btrfsic: kmap() failed (dev %s)!\\n\",\n\t\t\t       block_ctx->dev->name);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn block_ctx->len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "NULL == l"
          ],
          "line": 767
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfsic_block_link_hashtable_lookup",
          "args": [
            "tmp_next_block_ctx.dev->bdev",
            "tmp_next_block_ctx.dev_bytenr",
            "state->latest_superblock->dev_state->\n\t\t\t\t\tbdev",
            "state->latest_superblock->dev_bytenr",
            "&state->block_link_hashtable"
          ],
          "line": 760
        },
        "resolved": true,
        "details": {
          "function_name": "btrfsic_block_link_hashtable_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/check-integrity.c",
          "lines": "578-608",
          "snippet": "static struct btrfsic_block_link *btrfsic_block_link_hashtable_lookup(\n\t\tstruct block_device *bdev_ref_to,\n\t\tu64 dev_bytenr_ref_to,\n\t\tstruct block_device *bdev_ref_from,\n\t\tu64 dev_bytenr_ref_from,\n\t\tstruct btrfsic_block_link_hashtable *h)\n{\n\tconst unsigned int hashval =\n\t    (((unsigned int)(dev_bytenr_ref_to >> 16)) ^\n\t     ((unsigned int)(dev_bytenr_ref_from >> 16)) ^\n\t     ((unsigned int)((uintptr_t)bdev_ref_to)) ^\n\t     ((unsigned int)((uintptr_t)bdev_ref_from))) &\n\t     (BTRFSIC_BLOCK_LINK_HASHTABLE_SIZE - 1);\n\tstruct list_head *elem;\n\n\tlist_for_each(elem, h->table + hashval) {\n\t\tstruct btrfsic_block_link *const l =\n\t\t    list_entry(elem, struct btrfsic_block_link,\n\t\t\t       collision_resolving_node);\n\n\t\tBUG_ON(NULL == l->block_ref_to);\n\t\tBUG_ON(NULL == l->block_ref_from);\n\t\tif (l->block_ref_to->dev_state->bdev == bdev_ref_to &&\n\t\t    l->block_ref_to->dev_bytenr == dev_bytenr_ref_to &&\n\t\t    l->block_ref_from->dev_state->bdev == bdev_ref_from &&\n\t\t    l->block_ref_from->dev_bytenr == dev_bytenr_ref_from)\n\t\t\treturn l;\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"extent_io.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/genhd.h>",
            "#include <linux/mutex.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define BTRFSIC_BLOCK_LINK_HASHTABLE_SIZE 0x10000"
          ],
          "globals_used": [
            "static void btrfsic_block_hashtable_init(struct btrfsic_block_hashtable *h);",
            "static void btrfsic_block_hashtable_add(struct btrfsic_block *b,\n\t\t\t\t\tstruct btrfsic_block_hashtable *h);",
            "static struct btrfsic_block *btrfsic_block_hashtable_lookup(\n\t\tstruct block_device *bdev,\n\t\tu64 dev_bytenr,\n\t\tstruct btrfsic_block_hashtable *h);",
            "static void btrfsic_block_link_hashtable_init(\n\t\tstruct btrfsic_block_link_hashtable *h);",
            "static void btrfsic_block_link_hashtable_add(\n\t\tstruct btrfsic_block_link *l,\n\t\tstruct btrfsic_block_link_hashtable *h);",
            "static void btrfsic_block_link_hashtable_remove(struct btrfsic_block_link *l);",
            "static struct btrfsic_block_link *btrfsic_block_link_hashtable_lookup(\n\t\tstruct block_device *bdev_ref_to,\n\t\tu64 dev_bytenr_ref_to,\n\t\tstruct block_device *bdev_ref_from,\n\t\tu64 dev_bytenr_ref_from,\n\t\tstruct btrfsic_block_link_hashtable *h);",
            "static void btrfsic_dev_state_hashtable_init(\n\t\tstruct btrfsic_dev_state_hashtable *h);",
            "static void btrfsic_dev_state_hashtable_add(\n\t\tstruct btrfsic_dev_state *ds,\n\t\tstruct btrfsic_dev_state_hashtable *h);",
            "static struct btrfsic_dev_state *btrfsic_dev_state_hashtable_lookup(\n\t\tstruct block_device *bdev,\n\t\tstruct btrfsic_dev_state_hashtable *h);",
            "static void btrfsic_print_add_link(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block_link *l);",
            "static void btrfsic_print_rem_link(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block_link *l);",
            "static struct btrfsic_dev_state *btrfsic_dev_state_lookup(\n\t\tstruct block_device *bdev);",
            "static void btrfsic_cmp_log_and_dev_bytenr(struct btrfsic_state *state,\n\t\t\t\t\t   u64 bytenr,\n\t\t\t\t\t   struct btrfsic_dev_state *dev_state,\n\t\t\t\t\t   u64 dev_bytenr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"extent_io.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n#include <linux/blkdev.h>\n#include <linux/genhd.h>\n#include <linux/mutex.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\n#define BTRFSIC_BLOCK_LINK_HASHTABLE_SIZE 0x10000\n\nstatic void btrfsic_block_hashtable_init(struct btrfsic_block_hashtable *h);\nstatic void btrfsic_block_hashtable_add(struct btrfsic_block *b,\n\t\t\t\t\tstruct btrfsic_block_hashtable *h);\nstatic struct btrfsic_block *btrfsic_block_hashtable_lookup(\n\t\tstruct block_device *bdev,\n\t\tu64 dev_bytenr,\n\t\tstruct btrfsic_block_hashtable *h);\nstatic void btrfsic_block_link_hashtable_init(\n\t\tstruct btrfsic_block_link_hashtable *h);\nstatic void btrfsic_block_link_hashtable_add(\n\t\tstruct btrfsic_block_link *l,\n\t\tstruct btrfsic_block_link_hashtable *h);\nstatic void btrfsic_block_link_hashtable_remove(struct btrfsic_block_link *l);\nstatic struct btrfsic_block_link *btrfsic_block_link_hashtable_lookup(\n\t\tstruct block_device *bdev_ref_to,\n\t\tu64 dev_bytenr_ref_to,\n\t\tstruct block_device *bdev_ref_from,\n\t\tu64 dev_bytenr_ref_from,\n\t\tstruct btrfsic_block_link_hashtable *h);\nstatic void btrfsic_dev_state_hashtable_init(\n\t\tstruct btrfsic_dev_state_hashtable *h);\nstatic void btrfsic_dev_state_hashtable_add(\n\t\tstruct btrfsic_dev_state *ds,\n\t\tstruct btrfsic_dev_state_hashtable *h);\nstatic struct btrfsic_dev_state *btrfsic_dev_state_hashtable_lookup(\n\t\tstruct block_device *bdev,\n\t\tstruct btrfsic_dev_state_hashtable *h);\nstatic void btrfsic_print_add_link(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block_link *l);\nstatic void btrfsic_print_rem_link(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block_link *l);\nstatic struct btrfsic_dev_state *btrfsic_dev_state_lookup(\n\t\tstruct block_device *bdev);\nstatic void btrfsic_cmp_log_and_dev_bytenr(struct btrfsic_state *state,\n\t\t\t\t\t   u64 bytenr,\n\t\t\t\t\t   struct btrfsic_dev_state *dev_state,\n\t\t\t\t\t   u64 dev_bytenr);\n\nstatic struct btrfsic_block_link *btrfsic_block_link_hashtable_lookup(\n\t\tstruct block_device *bdev_ref_to,\n\t\tu64 dev_bytenr_ref_to,\n\t\tstruct block_device *bdev_ref_from,\n\t\tu64 dev_bytenr_ref_from,\n\t\tstruct btrfsic_block_link_hashtable *h)\n{\n\tconst unsigned int hashval =\n\t    (((unsigned int)(dev_bytenr_ref_to >> 16)) ^\n\t     ((unsigned int)(dev_bytenr_ref_from >> 16)) ^\n\t     ((unsigned int)((uintptr_t)bdev_ref_to)) ^\n\t     ((unsigned int)((uintptr_t)bdev_ref_from))) &\n\t     (BTRFSIC_BLOCK_LINK_HASHTABLE_SIZE - 1);\n\tstruct list_head *elem;\n\n\tlist_for_each(elem, h->table + hashval) {\n\t\tstruct btrfsic_block_link *const l =\n\t\t    list_entry(elem, struct btrfsic_block_link,\n\t\t\t       collision_resolving_node);\n\n\t\tBUG_ON(NULL == l->block_ref_to);\n\t\tBUG_ON(NULL == l->block_ref_from);\n\t\tif (l->block_ref_to->dev_state->bdev == bdev_ref_to &&\n\t\t    l->block_ref_to->dev_bytenr == dev_bytenr_ref_to &&\n\t\t    l->block_ref_from->dev_state->bdev == bdev_ref_from &&\n\t\t    l->block_ref_from->dev_bytenr == dev_bytenr_ref_from)\n\t\t\treturn l;\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "NULL == next_block"
          ],
          "line": 758
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfsic_block_hashtable_lookup",
          "args": [
            "tmp_next_block_ctx.dev->bdev",
            "tmp_next_block_ctx.dev_bytenr",
            "&state->block_hashtable"
          ],
          "line": 754
        },
        "resolved": true,
        "details": {
          "function_name": "btrfsic_block_hashtable_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/check-integrity.c",
          "lines": "525-546",
          "snippet": "static struct btrfsic_block *btrfsic_block_hashtable_lookup(\n\t\tstruct block_device *bdev,\n\t\tu64 dev_bytenr,\n\t\tstruct btrfsic_block_hashtable *h)\n{\n\tconst unsigned int hashval =\n\t    (((unsigned int)(dev_bytenr >> 16)) ^\n\t     ((unsigned int)((uintptr_t)bdev))) &\n\t     (BTRFSIC_BLOCK_HASHTABLE_SIZE - 1);\n\tstruct list_head *elem;\n\n\tlist_for_each(elem, h->table + hashval) {\n\t\tstruct btrfsic_block *const b =\n\t\t    list_entry(elem, struct btrfsic_block,\n\t\t\t       collision_resolving_node);\n\n\t\tif (b->dev_state->bdev == bdev && b->dev_bytenr == dev_bytenr)\n\t\t\treturn b;\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"extent_io.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/genhd.h>",
            "#include <linux/mutex.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define BTRFSIC_BLOCK_HASHTABLE_SIZE 0x10000"
          ],
          "globals_used": [
            "static void btrfsic_block_init(struct btrfsic_block *b);",
            "static void btrfsic_block_free(struct btrfsic_block *b);",
            "static void btrfsic_block_hashtable_init(struct btrfsic_block_hashtable *h);",
            "static void btrfsic_block_hashtable_add(struct btrfsic_block *b,\n\t\t\t\t\tstruct btrfsic_block_hashtable *h);",
            "static void btrfsic_block_hashtable_remove(struct btrfsic_block *b);",
            "static struct btrfsic_block *btrfsic_block_hashtable_lookup(\n\t\tstruct block_device *bdev,\n\t\tu64 dev_bytenr,\n\t\tstruct btrfsic_block_hashtable *h);",
            "static void btrfsic_block_link_hashtable_init(\n\t\tstruct btrfsic_block_link_hashtable *h);",
            "static void btrfsic_block_link_hashtable_add(\n\t\tstruct btrfsic_block_link *l,\n\t\tstruct btrfsic_block_link_hashtable *h);",
            "static struct btrfsic_block_link *btrfsic_block_link_hashtable_lookup(\n\t\tstruct block_device *bdev_ref_to,\n\t\tu64 dev_bytenr_ref_to,\n\t\tstruct block_device *bdev_ref_from,\n\t\tu64 dev_bytenr_ref_from,\n\t\tstruct btrfsic_block_link_hashtable *h);",
            "static void btrfsic_dev_state_hashtable_init(\n\t\tstruct btrfsic_dev_state_hashtable *h);",
            "static void btrfsic_dev_state_hashtable_add(\n\t\tstruct btrfsic_dev_state *ds,\n\t\tstruct btrfsic_dev_state_hashtable *h);",
            "static struct btrfsic_dev_state *btrfsic_dev_state_hashtable_lookup(\n\t\tstruct block_device *bdev,\n\t\tstruct btrfsic_dev_state_hashtable *h);",
            "static struct btrfsic_dev_state *btrfsic_dev_state_lookup(\n\t\tstruct block_device *bdev);",
            "static void btrfsic_cmp_log_and_dev_bytenr(struct btrfsic_state *state,\n\t\t\t\t\t   u64 bytenr,\n\t\t\t\t\t   struct btrfsic_dev_state *dev_state,\n\t\t\t\t\t   u64 dev_bytenr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"extent_io.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n#include <linux/blkdev.h>\n#include <linux/genhd.h>\n#include <linux/mutex.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\n#define BTRFSIC_BLOCK_HASHTABLE_SIZE 0x10000\n\nstatic void btrfsic_block_init(struct btrfsic_block *b);\nstatic void btrfsic_block_free(struct btrfsic_block *b);\nstatic void btrfsic_block_hashtable_init(struct btrfsic_block_hashtable *h);\nstatic void btrfsic_block_hashtable_add(struct btrfsic_block *b,\n\t\t\t\t\tstruct btrfsic_block_hashtable *h);\nstatic void btrfsic_block_hashtable_remove(struct btrfsic_block *b);\nstatic struct btrfsic_block *btrfsic_block_hashtable_lookup(\n\t\tstruct block_device *bdev,\n\t\tu64 dev_bytenr,\n\t\tstruct btrfsic_block_hashtable *h);\nstatic void btrfsic_block_link_hashtable_init(\n\t\tstruct btrfsic_block_link_hashtable *h);\nstatic void btrfsic_block_link_hashtable_add(\n\t\tstruct btrfsic_block_link *l,\n\t\tstruct btrfsic_block_link_hashtable *h);\nstatic struct btrfsic_block_link *btrfsic_block_link_hashtable_lookup(\n\t\tstruct block_device *bdev_ref_to,\n\t\tu64 dev_bytenr_ref_to,\n\t\tstruct block_device *bdev_ref_from,\n\t\tu64 dev_bytenr_ref_from,\n\t\tstruct btrfsic_block_link_hashtable *h);\nstatic void btrfsic_dev_state_hashtable_init(\n\t\tstruct btrfsic_dev_state_hashtable *h);\nstatic void btrfsic_dev_state_hashtable_add(\n\t\tstruct btrfsic_dev_state *ds,\n\t\tstruct btrfsic_dev_state_hashtable *h);\nstatic struct btrfsic_dev_state *btrfsic_dev_state_hashtable_lookup(\n\t\tstruct block_device *bdev,\n\t\tstruct btrfsic_dev_state_hashtable *h);\nstatic struct btrfsic_dev_state *btrfsic_dev_state_lookup(\n\t\tstruct block_device *bdev);\nstatic void btrfsic_cmp_log_and_dev_bytenr(struct btrfsic_state *state,\n\t\t\t\t\t   u64 bytenr,\n\t\t\t\t\t   struct btrfsic_dev_state *dev_state,\n\t\t\t\t\t   u64 dev_bytenr);\n\nstatic struct btrfsic_block *btrfsic_block_hashtable_lookup(\n\t\tstruct block_device *bdev,\n\t\tu64 dev_bytenr,\n\t\tstruct btrfsic_block_hashtable *h)\n{\n\tconst unsigned int hashval =\n\t    (((unsigned int)(dev_bytenr >> 16)) ^\n\t     ((unsigned int)((uintptr_t)bdev))) &\n\t     (BTRFSIC_BLOCK_HASHTABLE_SIZE - 1);\n\tstruct list_head *elem;\n\n\tlist_for_each(elem, h->table + hashval) {\n\t\tstruct btrfsic_block *const b =\n\t\t    list_entry(elem, struct btrfsic_block,\n\t\t\t       collision_resolving_node);\n\n\t\tif (b->dev_state->bdev == bdev && b->dev_bytenr == dev_bytenr)\n\t\t\treturn b;\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "selected_super"
          ],
          "line": 750
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfsic_map_block",
          "args": [
            "state",
            "next_bytenr",
            "state->metablock_size",
            "&tmp_next_block_ctx",
            "mirror_num"
          ],
          "line": 741
        },
        "resolved": true,
        "details": {
          "function_name": "btrfsic_map_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/check-integrity.c",
          "lines": "1568-1609",
          "snippet": "static int btrfsic_map_block(struct btrfsic_state *state, u64 bytenr, u32 len,\n\t\t\t     struct btrfsic_block_data_ctx *block_ctx_out,\n\t\t\t     int mirror_num)\n{\n\tint ret;\n\tu64 length;\n\tstruct btrfs_bio *multi = NULL;\n\tstruct btrfs_device *device;\n\n\tlength = len;\n\tret = btrfs_map_block(state->root->fs_info, READ,\n\t\t\t      bytenr, &length, &multi, mirror_num);\n\n\tif (ret) {\n\t\tblock_ctx_out->start = 0;\n\t\tblock_ctx_out->dev_bytenr = 0;\n\t\tblock_ctx_out->len = 0;\n\t\tblock_ctx_out->dev = NULL;\n\t\tblock_ctx_out->datav = NULL;\n\t\tblock_ctx_out->pagev = NULL;\n\t\tblock_ctx_out->mem_to_free = NULL;\n\n\t\treturn ret;\n\t}\n\n\tdevice = multi->stripes[0].dev;\n\tblock_ctx_out->dev = btrfsic_dev_state_lookup(device->bdev);\n\tblock_ctx_out->dev_bytenr = multi->stripes[0].physical;\n\tblock_ctx_out->start = bytenr;\n\tblock_ctx_out->len = len;\n\tblock_ctx_out->datav = NULL;\n\tblock_ctx_out->pagev = NULL;\n\tblock_ctx_out->mem_to_free = NULL;\n\n\tkfree(multi);\n\tif (NULL == block_ctx_out->dev) {\n\t\tret = -ENXIO;\n\t\tprintk(KERN_INFO \"btrfsic: error, cannot lookup dev (#1)!\\n\");\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"extent_io.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/genhd.h>",
            "#include <linux/mutex.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void btrfsic_block_link_init(struct btrfsic_block_link *n);",
            "static void btrfsic_block_link_free(struct btrfsic_block_link *n);",
            "static void btrfsic_read_from_block_data(\n\tstruct btrfsic_block_data_ctx *block_ctx,\n\tvoid *dst, u32 offset, size_t len);",
            "static int btrfsic_map_block(struct btrfsic_state *state, u64 bytenr, u32 len,\n\t\t\t     struct btrfsic_block_data_ctx *block_ctx_out,\n\t\t\t     int mirror_num);",
            "static void btrfsic_dump_database(struct btrfsic_state *state);",
            "static void btrfsic_dump_tree(const struct btrfsic_state *state);",
            "static struct btrfsic_dev_state *btrfsic_dev_state_lookup(\n\t\tstruct block_device *bdev);",
            "static void btrfsic_cmp_log_and_dev_bytenr(struct btrfsic_state *state,\n\t\t\t\t\t   u64 bytenr,\n\t\t\t\t\t   struct btrfsic_dev_state *dev_state,\n\t\t\t\t\t   u64 dev_bytenr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"extent_io.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n#include <linux/blkdev.h>\n#include <linux/genhd.h>\n#include <linux/mutex.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic void btrfsic_block_link_init(struct btrfsic_block_link *n);\nstatic void btrfsic_block_link_free(struct btrfsic_block_link *n);\nstatic void btrfsic_read_from_block_data(\n\tstruct btrfsic_block_data_ctx *block_ctx,\n\tvoid *dst, u32 offset, size_t len);\nstatic int btrfsic_map_block(struct btrfsic_state *state, u64 bytenr, u32 len,\n\t\t\t     struct btrfsic_block_data_ctx *block_ctx_out,\n\t\t\t     int mirror_num);\nstatic void btrfsic_dump_database(struct btrfsic_state *state);\nstatic void btrfsic_dump_tree(const struct btrfsic_state *state);\nstatic struct btrfsic_dev_state *btrfsic_dev_state_lookup(\n\t\tstruct block_device *bdev);\nstatic void btrfsic_cmp_log_and_dev_bytenr(struct btrfsic_state *state,\n\t\t\t\t\t   u64 bytenr,\n\t\t\t\t\t   struct btrfsic_dev_state *dev_state,\n\t\t\t\t\t   u64 dev_bytenr);\n\nstatic int btrfsic_map_block(struct btrfsic_state *state, u64 bytenr, u32 len,\n\t\t\t     struct btrfsic_block_data_ctx *block_ctx_out,\n\t\t\t     int mirror_num)\n{\n\tint ret;\n\tu64 length;\n\tstruct btrfs_bio *multi = NULL;\n\tstruct btrfs_device *device;\n\n\tlength = len;\n\tret = btrfs_map_block(state->root->fs_info, READ,\n\t\t\t      bytenr, &length, &multi, mirror_num);\n\n\tif (ret) {\n\t\tblock_ctx_out->start = 0;\n\t\tblock_ctx_out->dev_bytenr = 0;\n\t\tblock_ctx_out->len = 0;\n\t\tblock_ctx_out->dev = NULL;\n\t\tblock_ctx_out->datav = NULL;\n\t\tblock_ctx_out->pagev = NULL;\n\t\tblock_ctx_out->mem_to_free = NULL;\n\n\t\treturn ret;\n\t}\n\n\tdevice = multi->stripes[0].dev;\n\tblock_ctx_out->dev = btrfsic_dev_state_lookup(device->bdev);\n\tblock_ctx_out->dev_bytenr = multi->stripes[0].physical;\n\tblock_ctx_out->start = bytenr;\n\tblock_ctx_out->len = len;\n\tblock_ctx_out->datav = NULL;\n\tblock_ctx_out->pagev = NULL;\n\tblock_ctx_out->mem_to_free = NULL;\n\n\tkfree(multi);\n\tif (NULL == block_ctx_out->dev) {\n\t\tret = -ENXIO;\n\t\tprintk(KERN_INFO \"btrfsic: error, cannot lookup dev (#1)!\\n\");\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_num_copies",
          "args": [
            "state->root->fs_info",
            "next_bytenr",
            "state->metablock_size"
          ],
          "line": 730
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_num_copies",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
          "lines": "4740-4790",
          "snippet": "int btrfs_num_copies(struct btrfs_fs_info *fs_info, u64 logical, u64 len)\n{\n\tstruct btrfs_mapping_tree *map_tree = &fs_info->mapping_tree;\n\tstruct extent_map *em;\n\tstruct map_lookup *map;\n\tstruct extent_map_tree *em_tree = &map_tree->map_tree;\n\tint ret;\n\n\tread_lock(&em_tree->lock);\n\tem = lookup_extent_mapping(em_tree, logical, len);\n\tread_unlock(&em_tree->lock);\n\n\t/*\n\t * We could return errors for these cases, but that could get ugly and\n\t * we'd probably do the same thing which is just not do anything else\n\t * and exit, so return 1 so the callers don't try to use other copies.\n\t */\n\tif (!em) {\n\t\tbtrfs_crit(fs_info, \"No mapping for %Lu-%Lu\", logical,\n\t\t\t    logical+len);\n\t\treturn 1;\n\t}\n\n\tif (em->start > logical || em->start + em->len < logical) {\n\t\tbtrfs_crit(fs_info, \"Invalid mapping for %Lu-%Lu, got \"\n\t\t\t    \"%Lu-%Lu\", logical, logical+len, em->start,\n\t\t\t    em->start + em->len);\n\t\tfree_extent_map(em);\n\t\treturn 1;\n\t}\n\n\tmap = (struct map_lookup *)em->bdev;\n\tif (map->type & (BTRFS_BLOCK_GROUP_DUP | BTRFS_BLOCK_GROUP_RAID1))\n\t\tret = map->num_stripes;\n\telse if (map->type & BTRFS_BLOCK_GROUP_RAID10)\n\t\tret = map->sub_stripes;\n\telse if (map->type & BTRFS_BLOCK_GROUP_RAID5)\n\t\tret = 2;\n\telse if (map->type & BTRFS_BLOCK_GROUP_RAID6)\n\t\tret = 3;\n\telse\n\t\tret = 1;\n\tfree_extent_map(em);\n\n\tbtrfs_dev_replace_lock(&fs_info->dev_replace);\n\tif (btrfs_dev_replace_is_ongoing(&fs_info->dev_replace))\n\t\tret++;\n\tbtrfs_dev_replace_unlock(&fs_info->dev_replace);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\nstatic noinline struct;\n\nint btrfs_num_copies(struct btrfs_fs_info *fs_info, u64 logical, u64 len)\n{\n\tstruct btrfs_mapping_tree *map_tree = &fs_info->mapping_tree;\n\tstruct extent_map *em;\n\tstruct map_lookup *map;\n\tstruct extent_map_tree *em_tree = &map_tree->map_tree;\n\tint ret;\n\n\tread_lock(&em_tree->lock);\n\tem = lookup_extent_mapping(em_tree, logical, len);\n\tread_unlock(&em_tree->lock);\n\n\t/*\n\t * We could return errors for these cases, but that could get ugly and\n\t * we'd probably do the same thing which is just not do anything else\n\t * and exit, so return 1 so the callers don't try to use other copies.\n\t */\n\tif (!em) {\n\t\tbtrfs_crit(fs_info, \"No mapping for %Lu-%Lu\", logical,\n\t\t\t    logical+len);\n\t\treturn 1;\n\t}\n\n\tif (em->start > logical || em->start + em->len < logical) {\n\t\tbtrfs_crit(fs_info, \"Invalid mapping for %Lu-%Lu, got \"\n\t\t\t    \"%Lu-%Lu\", logical, logical+len, em->start,\n\t\t\t    em->start + em->len);\n\t\tfree_extent_map(em);\n\t\treturn 1;\n\t}\n\n\tmap = (struct map_lookup *)em->bdev;\n\tif (map->type & (BTRFS_BLOCK_GROUP_DUP | BTRFS_BLOCK_GROUP_RAID1))\n\t\tret = map->num_stripes;\n\telse if (map->type & BTRFS_BLOCK_GROUP_RAID10)\n\t\tret = map->sub_stripes;\n\telse if (map->type & BTRFS_BLOCK_GROUP_RAID5)\n\t\tret = 2;\n\telse if (map->type & BTRFS_BLOCK_GROUP_RAID6)\n\t\tret = 3;\n\telse\n\t\tret = 1;\n\tfree_extent_map(em);\n\n\tbtrfs_dev_replace_lock(&fs_info->dev_replace);\n\tif (btrfs_dev_replace_is_ongoing(&fs_info->dev_replace))\n\t\tret++;\n\tbtrfs_dev_replace_unlock(&fs_info->dev_replace);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_super_log_root",
          "args": [
            "selected_super"
          ],
          "line": 720
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_super_chunk_root",
          "args": [
            "selected_super"
          ],
          "line": 714
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_super_root",
          "args": [
            "selected_super"
          ],
          "line": 708
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_super_csum_size",
          "args": [
            "selected_super"
          ],
          "line": 699
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_super_csum_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "3066-3073",
          "snippet": "static inline int btrfs_super_csum_size(struct btrfs_super_block *s)\n{\n\tu16 t = btrfs_super_csum_type(s);\n\t/*\n\t * csum type is validated at mount time\n\t */\n\treturn btrfs_csum_sizes[t];\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline int btrfs_super_csum_size(struct btrfs_super_block *s)\n{\n\tu16 t = btrfs_super_csum_type(s);\n\t/*\n\t * csum type is validated at mount time\n\t */\n\treturn btrfs_csum_sizes[t];\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "selected_super"
          ],
          "line": 695
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_INFO \"btrfsic: no superblock found!\\n\""
          ],
          "line": 694
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "selected_super"
          ],
          "line": 687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfsic_process_superblock_dev_mirror",
          "args": [
            "state",
            "dev_state",
            "device",
            "i",
            "&selected_dev_state",
            "selected_super"
          ],
          "line": 683
        },
        "resolved": true,
        "details": {
          "function_name": "btrfsic_process_superblock_dev_mirror",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/check-integrity.c",
          "lines": "791-953",
          "snippet": "static int btrfsic_process_superblock_dev_mirror(\n\t\tstruct btrfsic_state *state,\n\t\tstruct btrfsic_dev_state *dev_state,\n\t\tstruct btrfs_device *device,\n\t\tint superblock_mirror_num,\n\t\tstruct btrfsic_dev_state **selected_dev_state,\n\t\tstruct btrfs_super_block *selected_super)\n{\n\tstruct btrfs_super_block *super_tmp;\n\tu64 dev_bytenr;\n\tstruct buffer_head *bh;\n\tstruct btrfsic_block *superblock_tmp;\n\tint pass;\n\tstruct block_device *const superblock_bdev = device->bdev;\n\n\t/* super block bytenr is always the unmapped device bytenr */\n\tdev_bytenr = btrfs_sb_offset(superblock_mirror_num);\n\tif (dev_bytenr + BTRFS_SUPER_INFO_SIZE > device->commit_total_bytes)\n\t\treturn -1;\n\tbh = __bread(superblock_bdev, dev_bytenr / 4096,\n\t\t     BTRFS_SUPER_INFO_SIZE);\n\tif (NULL == bh)\n\t\treturn -1;\n\tsuper_tmp = (struct btrfs_super_block *)\n\t    (bh->b_data + (dev_bytenr & 4095));\n\n\tif (btrfs_super_bytenr(super_tmp) != dev_bytenr ||\n\t    btrfs_super_magic(super_tmp) != BTRFS_MAGIC ||\n\t    memcmp(device->uuid, super_tmp->dev_item.uuid, BTRFS_UUID_SIZE) ||\n\t    btrfs_super_nodesize(super_tmp) != state->metablock_size ||\n\t    btrfs_super_sectorsize(super_tmp) != state->datablock_size) {\n\t\tbrelse(bh);\n\t\treturn 0;\n\t}\n\n\tsuperblock_tmp =\n\t    btrfsic_block_hashtable_lookup(superblock_bdev,\n\t\t\t\t\t   dev_bytenr,\n\t\t\t\t\t   &state->block_hashtable);\n\tif (NULL == superblock_tmp) {\n\t\tsuperblock_tmp = btrfsic_block_alloc();\n\t\tif (NULL == superblock_tmp) {\n\t\t\tprintk(KERN_INFO \"btrfsic: error, kmalloc failed!\\n\");\n\t\t\tbrelse(bh);\n\t\t\treturn -1;\n\t\t}\n\t\t/* for superblock, only the dev_bytenr makes sense */\n\t\tsuperblock_tmp->dev_bytenr = dev_bytenr;\n\t\tsuperblock_tmp->dev_state = dev_state;\n\t\tsuperblock_tmp->logical_bytenr = dev_bytenr;\n\t\tsuperblock_tmp->generation = btrfs_super_generation(super_tmp);\n\t\tsuperblock_tmp->is_metadata = 1;\n\t\tsuperblock_tmp->is_superblock = 1;\n\t\tsuperblock_tmp->is_iodone = 1;\n\t\tsuperblock_tmp->never_written = 0;\n\t\tsuperblock_tmp->mirror_num = 1 + superblock_mirror_num;\n\t\tif (state->print_mask & BTRFSIC_PRINT_MASK_SUPERBLOCK_WRITE)\n\t\t\tprintk_in_rcu(KERN_INFO \"New initial S-block (bdev %p, %s)\"\n\t\t\t\t     \" @%llu (%s/%llu/%d)\\n\",\n\t\t\t\t     superblock_bdev,\n\t\t\t\t     rcu_str_deref(device->name), dev_bytenr,\n\t\t\t\t     dev_state->name, dev_bytenr,\n\t\t\t\t     superblock_mirror_num);\n\t\tlist_add(&superblock_tmp->all_blocks_node,\n\t\t\t &state->all_blocks_list);\n\t\tbtrfsic_block_hashtable_add(superblock_tmp,\n\t\t\t\t\t    &state->block_hashtable);\n\t}\n\n\t/* select the one with the highest generation field */\n\tif (btrfs_super_generation(super_tmp) >\n\t    state->max_superblock_generation ||\n\t    0 == state->max_superblock_generation) {\n\t\tmemcpy(selected_super, super_tmp, sizeof(*selected_super));\n\t\t*selected_dev_state = dev_state;\n\t\tstate->max_superblock_generation =\n\t\t    btrfs_super_generation(super_tmp);\n\t\tstate->latest_superblock = superblock_tmp;\n\t}\n\n\tfor (pass = 0; pass < 3; pass++) {\n\t\tu64 next_bytenr;\n\t\tint num_copies;\n\t\tint mirror_num;\n\t\tconst char *additional_string = NULL;\n\t\tstruct btrfs_disk_key tmp_disk_key;\n\n\t\ttmp_disk_key.type = BTRFS_ROOT_ITEM_KEY;\n\t\ttmp_disk_key.offset = 0;\n\t\tswitch (pass) {\n\t\tcase 0:\n\t\t\tbtrfs_set_disk_key_objectid(&tmp_disk_key,\n\t\t\t\t\t\t    BTRFS_ROOT_TREE_OBJECTID);\n\t\t\tadditional_string = \"initial root \";\n\t\t\tnext_bytenr = btrfs_super_root(super_tmp);\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tbtrfs_set_disk_key_objectid(&tmp_disk_key,\n\t\t\t\t\t\t    BTRFS_CHUNK_TREE_OBJECTID);\n\t\t\tadditional_string = \"initial chunk \";\n\t\t\tnext_bytenr = btrfs_super_chunk_root(super_tmp);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tbtrfs_set_disk_key_objectid(&tmp_disk_key,\n\t\t\t\t\t\t    BTRFS_TREE_LOG_OBJECTID);\n\t\t\tadditional_string = \"initial log \";\n\t\t\tnext_bytenr = btrfs_super_log_root(super_tmp);\n\t\t\tif (0 == next_bytenr)\n\t\t\t\tcontinue;\n\t\t\tbreak;\n\t\t}\n\n\t\tnum_copies =\n\t\t    btrfs_num_copies(state->root->fs_info,\n\t\t\t\t     next_bytenr, state->metablock_size);\n\t\tif (state->print_mask & BTRFSIC_PRINT_MASK_NUM_COPIES)\n\t\t\tprintk(KERN_INFO \"num_copies(log_bytenr=%llu) = %d\\n\",\n\t\t\t       next_bytenr, num_copies);\n\t\tfor (mirror_num = 1; mirror_num <= num_copies; mirror_num++) {\n\t\t\tstruct btrfsic_block *next_block;\n\t\t\tstruct btrfsic_block_data_ctx tmp_next_block_ctx;\n\t\t\tstruct btrfsic_block_link *l;\n\n\t\t\tif (btrfsic_map_block(state, next_bytenr,\n\t\t\t\t\t      state->metablock_size,\n\t\t\t\t\t      &tmp_next_block_ctx,\n\t\t\t\t\t      mirror_num)) {\n\t\t\t\tprintk(KERN_INFO \"btrfsic: btrfsic_map_block(\"\n\t\t\t\t       \"bytenr @%llu, mirror %d) failed!\\n\",\n\t\t\t\t       next_bytenr, mirror_num);\n\t\t\t\tbrelse(bh);\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tnext_block = btrfsic_block_lookup_or_add(\n\t\t\t\t\tstate, &tmp_next_block_ctx,\n\t\t\t\t\tadditional_string, 1, 1, 0,\n\t\t\t\t\tmirror_num, NULL);\n\t\t\tif (NULL == next_block) {\n\t\t\t\tbtrfsic_release_block_ctx(&tmp_next_block_ctx);\n\t\t\t\tbrelse(bh);\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tnext_block->disk_key = tmp_disk_key;\n\t\t\tnext_block->generation = BTRFSIC_GENERATION_UNKNOWN;\n\t\t\tl = btrfsic_block_link_lookup_or_add(\n\t\t\t\t\tstate, &tmp_next_block_ctx,\n\t\t\t\t\tnext_block, superblock_tmp,\n\t\t\t\t\tBTRFSIC_GENERATION_UNKNOWN);\n\t\t\tbtrfsic_release_block_ctx(&tmp_next_block_ctx);\n\t\t\tif (NULL == l) {\n\t\t\t\tbrelse(bh);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\tif (state->print_mask & BTRFSIC_PRINT_MASK_INITIAL_ALL_TREES)\n\t\tbtrfsic_dump_tree_sub(state, superblock_tmp, 0);\n\n\tbrelse(bh);\n\treturn 0;\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"extent_io.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/genhd.h>",
            "#include <linux/mutex.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define BTRFSIC_PRINT_MASK_NUM_COPIES\t\t\t\t0x00000800",
            "#define BTRFSIC_PRINT_MASK_INITIAL_ALL_TREES\t\t\t0x00000200",
            "#define BTRFSIC_PRINT_MASK_SUPERBLOCK_WRITE\t\t\t0x00000001",
            "#define BTRFSIC_GENERATION_UNKNOWN ((u64)-1)"
          ],
          "globals_used": [
            "static struct btrfsic_block *btrfsic_block_alloc(void);",
            "static void btrfsic_block_link_init(struct btrfsic_block_link *n);",
            "static void btrfsic_block_link_free(struct btrfsic_block_link *n);",
            "static void btrfsic_block_link_hashtable_remove(struct btrfsic_block_link *l);",
            "static int btrfsic_map_block(struct btrfsic_state *state, u64 bytenr, u32 len,\n\t\t\t     struct btrfsic_block_data_ctx *block_ctx_out,\n\t\t\t     int mirror_num);",
            "static void btrfsic_dump_database(struct btrfsic_state *state);",
            "static void btrfsic_print_add_link(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block_link *l);",
            "static void btrfsic_print_rem_link(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block_link *l);",
            "static char btrfsic_get_block_type(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block *block);",
            "static void btrfsic_dump_tree(const struct btrfsic_state *state);",
            "static int btrfsic_process_superblock_dev_mirror(\n\t\tstruct btrfsic_state *state,\n\t\tstruct btrfsic_dev_state *dev_state,\n\t\tstruct btrfs_device *device,\n\t\tint superblock_mirror_num,\n\t\tstruct btrfsic_dev_state **selected_dev_state,\n\t\tstruct btrfs_super_block *selected_super);",
            "static struct btrfsic_dev_state *btrfsic_dev_state_lookup(\n\t\tstruct block_device *bdev);",
            "static void btrfsic_cmp_log_and_dev_bytenr(struct btrfsic_state *state,\n\t\t\t\t\t   u64 bytenr,\n\t\t\t\t\t   struct btrfsic_dev_state *dev_state,\n\t\t\t\t\t   u64 dev_bytenr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"extent_io.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n#include <linux/blkdev.h>\n#include <linux/genhd.h>\n#include <linux/mutex.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\n#define BTRFSIC_PRINT_MASK_NUM_COPIES\t\t\t\t0x00000800\n#define BTRFSIC_PRINT_MASK_INITIAL_ALL_TREES\t\t\t0x00000200\n#define BTRFSIC_PRINT_MASK_SUPERBLOCK_WRITE\t\t\t0x00000001\n#define BTRFSIC_GENERATION_UNKNOWN ((u64)-1)\n\nstatic struct btrfsic_block *btrfsic_block_alloc(void);\nstatic void btrfsic_block_link_init(struct btrfsic_block_link *n);\nstatic void btrfsic_block_link_free(struct btrfsic_block_link *n);\nstatic void btrfsic_block_link_hashtable_remove(struct btrfsic_block_link *l);\nstatic int btrfsic_map_block(struct btrfsic_state *state, u64 bytenr, u32 len,\n\t\t\t     struct btrfsic_block_data_ctx *block_ctx_out,\n\t\t\t     int mirror_num);\nstatic void btrfsic_dump_database(struct btrfsic_state *state);\nstatic void btrfsic_print_add_link(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block_link *l);\nstatic void btrfsic_print_rem_link(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block_link *l);\nstatic char btrfsic_get_block_type(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block *block);\nstatic void btrfsic_dump_tree(const struct btrfsic_state *state);\nstatic int btrfsic_process_superblock_dev_mirror(\n\t\tstruct btrfsic_state *state,\n\t\tstruct btrfsic_dev_state *dev_state,\n\t\tstruct btrfs_device *device,\n\t\tint superblock_mirror_num,\n\t\tstruct btrfsic_dev_state **selected_dev_state,\n\t\tstruct btrfs_super_block *selected_super);\nstatic struct btrfsic_dev_state *btrfsic_dev_state_lookup(\n\t\tstruct block_device *bdev);\nstatic void btrfsic_cmp_log_and_dev_bytenr(struct btrfsic_state *state,\n\t\t\t\t\t   u64 bytenr,\n\t\t\t\t\t   struct btrfsic_dev_state *dev_state,\n\t\t\t\t\t   u64 dev_bytenr);\n\nstatic int btrfsic_process_superblock_dev_mirror(\n\t\tstruct btrfsic_state *state,\n\t\tstruct btrfsic_dev_state *dev_state,\n\t\tstruct btrfs_device *device,\n\t\tint superblock_mirror_num,\n\t\tstruct btrfsic_dev_state **selected_dev_state,\n\t\tstruct btrfs_super_block *selected_super)\n{\n\tstruct btrfs_super_block *super_tmp;\n\tu64 dev_bytenr;\n\tstruct buffer_head *bh;\n\tstruct btrfsic_block *superblock_tmp;\n\tint pass;\n\tstruct block_device *const superblock_bdev = device->bdev;\n\n\t/* super block bytenr is always the unmapped device bytenr */\n\tdev_bytenr = btrfs_sb_offset(superblock_mirror_num);\n\tif (dev_bytenr + BTRFS_SUPER_INFO_SIZE > device->commit_total_bytes)\n\t\treturn -1;\n\tbh = __bread(superblock_bdev, dev_bytenr / 4096,\n\t\t     BTRFS_SUPER_INFO_SIZE);\n\tif (NULL == bh)\n\t\treturn -1;\n\tsuper_tmp = (struct btrfs_super_block *)\n\t    (bh->b_data + (dev_bytenr & 4095));\n\n\tif (btrfs_super_bytenr(super_tmp) != dev_bytenr ||\n\t    btrfs_super_magic(super_tmp) != BTRFS_MAGIC ||\n\t    memcmp(device->uuid, super_tmp->dev_item.uuid, BTRFS_UUID_SIZE) ||\n\t    btrfs_super_nodesize(super_tmp) != state->metablock_size ||\n\t    btrfs_super_sectorsize(super_tmp) != state->datablock_size) {\n\t\tbrelse(bh);\n\t\treturn 0;\n\t}\n\n\tsuperblock_tmp =\n\t    btrfsic_block_hashtable_lookup(superblock_bdev,\n\t\t\t\t\t   dev_bytenr,\n\t\t\t\t\t   &state->block_hashtable);\n\tif (NULL == superblock_tmp) {\n\t\tsuperblock_tmp = btrfsic_block_alloc();\n\t\tif (NULL == superblock_tmp) {\n\t\t\tprintk(KERN_INFO \"btrfsic: error, kmalloc failed!\\n\");\n\t\t\tbrelse(bh);\n\t\t\treturn -1;\n\t\t}\n\t\t/* for superblock, only the dev_bytenr makes sense */\n\t\tsuperblock_tmp->dev_bytenr = dev_bytenr;\n\t\tsuperblock_tmp->dev_state = dev_state;\n\t\tsuperblock_tmp->logical_bytenr = dev_bytenr;\n\t\tsuperblock_tmp->generation = btrfs_super_generation(super_tmp);\n\t\tsuperblock_tmp->is_metadata = 1;\n\t\tsuperblock_tmp->is_superblock = 1;\n\t\tsuperblock_tmp->is_iodone = 1;\n\t\tsuperblock_tmp->never_written = 0;\n\t\tsuperblock_tmp->mirror_num = 1 + superblock_mirror_num;\n\t\tif (state->print_mask & BTRFSIC_PRINT_MASK_SUPERBLOCK_WRITE)\n\t\t\tprintk_in_rcu(KERN_INFO \"New initial S-block (bdev %p, %s)\"\n\t\t\t\t     \" @%llu (%s/%llu/%d)\\n\",\n\t\t\t\t     superblock_bdev,\n\t\t\t\t     rcu_str_deref(device->name), dev_bytenr,\n\t\t\t\t     dev_state->name, dev_bytenr,\n\t\t\t\t     superblock_mirror_num);\n\t\tlist_add(&superblock_tmp->all_blocks_node,\n\t\t\t &state->all_blocks_list);\n\t\tbtrfsic_block_hashtable_add(superblock_tmp,\n\t\t\t\t\t    &state->block_hashtable);\n\t}\n\n\t/* select the one with the highest generation field */\n\tif (btrfs_super_generation(super_tmp) >\n\t    state->max_superblock_generation ||\n\t    0 == state->max_superblock_generation) {\n\t\tmemcpy(selected_super, super_tmp, sizeof(*selected_super));\n\t\t*selected_dev_state = dev_state;\n\t\tstate->max_superblock_generation =\n\t\t    btrfs_super_generation(super_tmp);\n\t\tstate->latest_superblock = superblock_tmp;\n\t}\n\n\tfor (pass = 0; pass < 3; pass++) {\n\t\tu64 next_bytenr;\n\t\tint num_copies;\n\t\tint mirror_num;\n\t\tconst char *additional_string = NULL;\n\t\tstruct btrfs_disk_key tmp_disk_key;\n\n\t\ttmp_disk_key.type = BTRFS_ROOT_ITEM_KEY;\n\t\ttmp_disk_key.offset = 0;\n\t\tswitch (pass) {\n\t\tcase 0:\n\t\t\tbtrfs_set_disk_key_objectid(&tmp_disk_key,\n\t\t\t\t\t\t    BTRFS_ROOT_TREE_OBJECTID);\n\t\t\tadditional_string = \"initial root \";\n\t\t\tnext_bytenr = btrfs_super_root(super_tmp);\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tbtrfs_set_disk_key_objectid(&tmp_disk_key,\n\t\t\t\t\t\t    BTRFS_CHUNK_TREE_OBJECTID);\n\t\t\tadditional_string = \"initial chunk \";\n\t\t\tnext_bytenr = btrfs_super_chunk_root(super_tmp);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tbtrfs_set_disk_key_objectid(&tmp_disk_key,\n\t\t\t\t\t\t    BTRFS_TREE_LOG_OBJECTID);\n\t\t\tadditional_string = \"initial log \";\n\t\t\tnext_bytenr = btrfs_super_log_root(super_tmp);\n\t\t\tif (0 == next_bytenr)\n\t\t\t\tcontinue;\n\t\t\tbreak;\n\t\t}\n\n\t\tnum_copies =\n\t\t    btrfs_num_copies(state->root->fs_info,\n\t\t\t\t     next_bytenr, state->metablock_size);\n\t\tif (state->print_mask & BTRFSIC_PRINT_MASK_NUM_COPIES)\n\t\t\tprintk(KERN_INFO \"num_copies(log_bytenr=%llu) = %d\\n\",\n\t\t\t       next_bytenr, num_copies);\n\t\tfor (mirror_num = 1; mirror_num <= num_copies; mirror_num++) {\n\t\t\tstruct btrfsic_block *next_block;\n\t\t\tstruct btrfsic_block_data_ctx tmp_next_block_ctx;\n\t\t\tstruct btrfsic_block_link *l;\n\n\t\t\tif (btrfsic_map_block(state, next_bytenr,\n\t\t\t\t\t      state->metablock_size,\n\t\t\t\t\t      &tmp_next_block_ctx,\n\t\t\t\t\t      mirror_num)) {\n\t\t\t\tprintk(KERN_INFO \"btrfsic: btrfsic_map_block(\"\n\t\t\t\t       \"bytenr @%llu, mirror %d) failed!\\n\",\n\t\t\t\t       next_bytenr, mirror_num);\n\t\t\t\tbrelse(bh);\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tnext_block = btrfsic_block_lookup_or_add(\n\t\t\t\t\tstate, &tmp_next_block_ctx,\n\t\t\t\t\tadditional_string, 1, 1, 0,\n\t\t\t\t\tmirror_num, NULL);\n\t\t\tif (NULL == next_block) {\n\t\t\t\tbtrfsic_release_block_ctx(&tmp_next_block_ctx);\n\t\t\t\tbrelse(bh);\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tnext_block->disk_key = tmp_disk_key;\n\t\t\tnext_block->generation = BTRFSIC_GENERATION_UNKNOWN;\n\t\t\tl = btrfsic_block_link_lookup_or_add(\n\t\t\t\t\tstate, &tmp_next_block_ctx,\n\t\t\t\t\tnext_block, superblock_tmp,\n\t\t\t\t\tBTRFSIC_GENERATION_UNKNOWN);\n\t\t\tbtrfsic_release_block_ctx(&tmp_next_block_ctx);\n\t\t\tif (NULL == l) {\n\t\t\t\tbrelse(bh);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\tif (state->print_mask & BTRFSIC_PRINT_MASK_INITIAL_ALL_TREES)\n\t\tbtrfsic_dump_tree_sub(state, superblock_tmp, 0);\n\n\tbrelse(bh);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "NULL == dev_state"
          ],
          "line": 681
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfsic_dev_state_lookup",
          "args": [
            "device->bdev"
          ],
          "line": 680
        },
        "resolved": true,
        "details": {
          "function_name": "btrfsic_dev_state_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/check-integrity.c",
          "lines": "2890-2898",
          "snippet": "static struct btrfsic_dev_state *btrfsic_dev_state_lookup(\n\t\tstruct block_device *bdev)\n{\n\tstruct btrfsic_dev_state *ds;\n\n\tds = btrfsic_dev_state_hashtable_lookup(bdev,\n\t\t\t\t\t\t&btrfsic_dev_state_hashtable);\n\treturn ds;\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"extent_io.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/genhd.h>",
            "#include <linux/mutex.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void btrfsic_dev_state_init(struct btrfsic_dev_state *ds);",
            "static void btrfsic_dev_state_free(struct btrfsic_dev_state *ds);",
            "static void btrfsic_dev_state_hashtable_remove(struct btrfsic_dev_state *ds);",
            "static struct btrfsic_dev_state *btrfsic_dev_state_lookup(\n\t\tstruct block_device *bdev);",
            "static struct btrfsic_dev_state_hashtable btrfsic_dev_state_hashtable;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"extent_io.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n#include <linux/blkdev.h>\n#include <linux/genhd.h>\n#include <linux/mutex.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic void btrfsic_dev_state_init(struct btrfsic_dev_state *ds);\nstatic void btrfsic_dev_state_free(struct btrfsic_dev_state *ds);\nstatic void btrfsic_dev_state_hashtable_remove(struct btrfsic_dev_state *ds);\nstatic struct btrfsic_dev_state *btrfsic_dev_state_lookup(\n\t\tstruct block_device *bdev);\nstatic struct btrfsic_dev_state_hashtable btrfsic_dev_state_hashtable;\n\nstatic struct btrfsic_dev_state *btrfsic_dev_state_lookup(\n\t\tstruct block_device *bdev)\n{\n\tstruct btrfsic_dev_state *ds;\n\n\tds = btrfsic_dev_state_hashtable_lookup(bdev,\n\t\t\t\t\t\t&btrfsic_dev_state_hashtable);\n\treturn ds;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "device",
            "dev_head",
            "dev_list"
          ],
          "line": 673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*selected_super)",
            "GFP_NOFS"
          ],
          "line": 667
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "NULL == state"
          ],
          "line": 666
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"extent_io.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n#include <linux/blkdev.h>\n#include <linux/genhd.h>\n#include <linux/mutex.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\n#define BTRFSIC_PRINT_MASK_NUM_COPIES\t\t\t\t0x00000800\n#define BTRFSIC_PRINT_MASK_ROOT_CHUNK_LOG_TREE_LOCATION\t\t0x00000002\n\nstatic void btrfsic_block_link_init(struct btrfsic_block_link *n);\nstatic void btrfsic_block_link_free(struct btrfsic_block_link *n);\nstatic void btrfsic_block_link_hashtable_remove(struct btrfsic_block_link *l);\nstatic int btrfsic_process_superblock(struct btrfsic_state *state,\n\t\t\t\t      struct btrfs_fs_devices *fs_devices);\nstatic int btrfsic_map_block(struct btrfsic_state *state, u64 bytenr, u32 len,\n\t\t\t     struct btrfsic_block_data_ctx *block_ctx_out,\n\t\t\t     int mirror_num);\nstatic void btrfsic_dump_database(struct btrfsic_state *state);\nstatic void btrfsic_print_add_link(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block_link *l);\nstatic void btrfsic_print_rem_link(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block_link *l);\nstatic void btrfsic_dump_tree(const struct btrfsic_state *state);\nstatic int btrfsic_process_superblock_dev_mirror(\n\t\tstruct btrfsic_state *state,\n\t\tstruct btrfsic_dev_state *dev_state,\n\t\tstruct btrfs_device *device,\n\t\tint superblock_mirror_num,\n\t\tstruct btrfsic_dev_state **selected_dev_state,\n\t\tstruct btrfs_super_block *selected_super);\nstatic struct btrfsic_dev_state *btrfsic_dev_state_lookup(\n\t\tstruct block_device *bdev);\nstatic void btrfsic_cmp_log_and_dev_bytenr(struct btrfsic_state *state,\n\t\t\t\t\t   u64 bytenr,\n\t\t\t\t\t   struct btrfsic_dev_state *dev_state,\n\t\t\t\t\t   u64 dev_bytenr);\n\nstatic int btrfsic_process_superblock(struct btrfsic_state *state,\n\t\t\t\t      struct btrfs_fs_devices *fs_devices)\n{\n\tint ret = 0;\n\tstruct btrfs_super_block *selected_super;\n\tstruct list_head *dev_head = &fs_devices->devices;\n\tstruct btrfs_device *device;\n\tstruct btrfsic_dev_state *selected_dev_state = NULL;\n\tint pass;\n\n\tBUG_ON(NULL == state);\n\tselected_super = kzalloc(sizeof(*selected_super), GFP_NOFS);\n\tif (NULL == selected_super) {\n\t\tprintk(KERN_INFO \"btrfsic: error, kmalloc failed!\\n\");\n\t\treturn -1;\n\t}\n\n\tlist_for_each_entry(device, dev_head, dev_list) {\n\t\tint i;\n\t\tstruct btrfsic_dev_state *dev_state;\n\n\t\tif (!device->bdev || !device->name)\n\t\t\tcontinue;\n\n\t\tdev_state = btrfsic_dev_state_lookup(device->bdev);\n\t\tBUG_ON(NULL == dev_state);\n\t\tfor (i = 0; i < BTRFS_SUPER_MIRROR_MAX; i++) {\n\t\t\tret = btrfsic_process_superblock_dev_mirror(\n\t\t\t\t\tstate, dev_state, device, i,\n\t\t\t\t\t&selected_dev_state, selected_super);\n\t\t\tif (0 != ret && 0 == i) {\n\t\t\t\tkfree(selected_super);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (NULL == state->latest_superblock) {\n\t\tprintk(KERN_INFO \"btrfsic: no superblock found!\\n\");\n\t\tkfree(selected_super);\n\t\treturn -1;\n\t}\n\n\tstate->csum_size = btrfs_super_csum_size(selected_super);\n\n\tfor (pass = 0; pass < 3; pass++) {\n\t\tint num_copies;\n\t\tint mirror_num;\n\t\tu64 next_bytenr;\n\n\t\tswitch (pass) {\n\t\tcase 0:\n\t\t\tnext_bytenr = btrfs_super_root(selected_super);\n\t\t\tif (state->print_mask &\n\t\t\t    BTRFSIC_PRINT_MASK_ROOT_CHUNK_LOG_TREE_LOCATION)\n\t\t\t\tprintk(KERN_INFO \"root@%llu\\n\", next_bytenr);\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tnext_bytenr = btrfs_super_chunk_root(selected_super);\n\t\t\tif (state->print_mask &\n\t\t\t    BTRFSIC_PRINT_MASK_ROOT_CHUNK_LOG_TREE_LOCATION)\n\t\t\t\tprintk(KERN_INFO \"chunk@%llu\\n\", next_bytenr);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tnext_bytenr = btrfs_super_log_root(selected_super);\n\t\t\tif (0 == next_bytenr)\n\t\t\t\tcontinue;\n\t\t\tif (state->print_mask &\n\t\t\t    BTRFSIC_PRINT_MASK_ROOT_CHUNK_LOG_TREE_LOCATION)\n\t\t\t\tprintk(KERN_INFO \"log@%llu\\n\", next_bytenr);\n\t\t\tbreak;\n\t\t}\n\n\t\tnum_copies =\n\t\t    btrfs_num_copies(state->root->fs_info,\n\t\t\t\t     next_bytenr, state->metablock_size);\n\t\tif (state->print_mask & BTRFSIC_PRINT_MASK_NUM_COPIES)\n\t\t\tprintk(KERN_INFO \"num_copies(log_bytenr=%llu) = %d\\n\",\n\t\t\t       next_bytenr, num_copies);\n\n\t\tfor (mirror_num = 1; mirror_num <= num_copies; mirror_num++) {\n\t\t\tstruct btrfsic_block *next_block;\n\t\t\tstruct btrfsic_block_data_ctx tmp_next_block_ctx;\n\t\t\tstruct btrfsic_block_link *l;\n\n\t\t\tret = btrfsic_map_block(state, next_bytenr,\n\t\t\t\t\t\tstate->metablock_size,\n\t\t\t\t\t\t&tmp_next_block_ctx,\n\t\t\t\t\t\tmirror_num);\n\t\t\tif (ret) {\n\t\t\t\tprintk(KERN_INFO \"btrfsic:\"\n\t\t\t\t       \" btrfsic_map_block(root @%llu,\"\n\t\t\t\t       \" mirror %d) failed!\\n\",\n\t\t\t\t       next_bytenr, mirror_num);\n\t\t\t\tkfree(selected_super);\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tnext_block = btrfsic_block_hashtable_lookup(\n\t\t\t\t\ttmp_next_block_ctx.dev->bdev,\n\t\t\t\t\ttmp_next_block_ctx.dev_bytenr,\n\t\t\t\t\t&state->block_hashtable);\n\t\t\tBUG_ON(NULL == next_block);\n\n\t\t\tl = btrfsic_block_link_hashtable_lookup(\n\t\t\t\t\ttmp_next_block_ctx.dev->bdev,\n\t\t\t\t\ttmp_next_block_ctx.dev_bytenr,\n\t\t\t\t\tstate->latest_superblock->dev_state->\n\t\t\t\t\tbdev,\n\t\t\t\t\tstate->latest_superblock->dev_bytenr,\n\t\t\t\t\t&state->block_link_hashtable);\n\t\t\tBUG_ON(NULL == l);\n\n\t\t\tret = btrfsic_read_block(state, &tmp_next_block_ctx);\n\t\t\tif (ret < (int)PAGE_CACHE_SIZE) {\n\t\t\t\tprintk(KERN_INFO\n\t\t\t\t       \"btrfsic: read @logical %llu failed!\\n\",\n\t\t\t\t       tmp_next_block_ctx.start);\n\t\t\t\tbtrfsic_release_block_ctx(&tmp_next_block_ctx);\n\t\t\t\tkfree(selected_super);\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tret = btrfsic_process_metablock(state,\n\t\t\t\t\t\t\tnext_block,\n\t\t\t\t\t\t\t&tmp_next_block_ctx,\n\t\t\t\t\t\t\tBTRFS_MAX_LEVEL + 3, 1);\n\t\t\tbtrfsic_release_block_ctx(&tmp_next_block_ctx);\n\t\t}\n\t}\n\n\tkfree(selected_super);\n\treturn ret;\n}"
  },
  {
    "function_name": "btrfsic_dev_state_hashtable_lookup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/check-integrity.c",
    "lines": "635-654",
    "snippet": "static struct btrfsic_dev_state *btrfsic_dev_state_hashtable_lookup(\n\t\tstruct block_device *bdev,\n\t\tstruct btrfsic_dev_state_hashtable *h)\n{\n\tconst unsigned int hashval =\n\t    (((unsigned int)((uintptr_t)bdev)) &\n\t     (BTRFSIC_DEV2STATE_HASHTABLE_SIZE - 1));\n\tstruct list_head *elem;\n\n\tlist_for_each(elem, h->table + hashval) {\n\t\tstruct btrfsic_dev_state *const ds =\n\t\t    list_entry(elem, struct btrfsic_dev_state,\n\t\t\t       collision_resolving_node);\n\n\t\tif (ds->bdev == bdev)\n\t\t\treturn ds;\n\t}\n\n\treturn NULL;\n}",
    "includes": [
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"volumes.h\"",
      "#include \"extent_io.h\"",
      "#include \"transaction.h\"",
      "#include \"hash.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/genhd.h>",
      "#include <linux/mutex.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [
      "#define BTRFSIC_DEV2STATE_HASHTABLE_SIZE 0x100"
    ],
    "globals_used": [
      "static void btrfsic_dev_state_init(struct btrfsic_dev_state *ds);",
      "static void btrfsic_dev_state_free(struct btrfsic_dev_state *ds);",
      "static void btrfsic_block_hashtable_init(struct btrfsic_block_hashtable *h);",
      "static void btrfsic_block_hashtable_add(struct btrfsic_block *b,\n\t\t\t\t\tstruct btrfsic_block_hashtable *h);",
      "static struct btrfsic_block *btrfsic_block_hashtable_lookup(\n\t\tstruct block_device *bdev,\n\t\tu64 dev_bytenr,\n\t\tstruct btrfsic_block_hashtable *h);",
      "static void btrfsic_block_link_hashtable_init(\n\t\tstruct btrfsic_block_link_hashtable *h);",
      "static void btrfsic_block_link_hashtable_add(\n\t\tstruct btrfsic_block_link *l,\n\t\tstruct btrfsic_block_link_hashtable *h);",
      "static struct btrfsic_block_link *btrfsic_block_link_hashtable_lookup(\n\t\tstruct block_device *bdev_ref_to,\n\t\tu64 dev_bytenr_ref_to,\n\t\tstruct block_device *bdev_ref_from,\n\t\tu64 dev_bytenr_ref_from,\n\t\tstruct btrfsic_block_link_hashtable *h);",
      "static void btrfsic_dev_state_hashtable_init(\n\t\tstruct btrfsic_dev_state_hashtable *h);",
      "static void btrfsic_dev_state_hashtable_add(\n\t\tstruct btrfsic_dev_state *ds,\n\t\tstruct btrfsic_dev_state_hashtable *h);",
      "static void btrfsic_dev_state_hashtable_remove(struct btrfsic_dev_state *ds);",
      "static struct btrfsic_dev_state *btrfsic_dev_state_hashtable_lookup(\n\t\tstruct block_device *bdev,\n\t\tstruct btrfsic_dev_state_hashtable *h);",
      "static struct btrfsic_dev_state *btrfsic_dev_state_lookup(\n\t\tstruct block_device *bdev);",
      "static struct btrfsic_dev_state_hashtable btrfsic_dev_state_hashtable;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "elem",
            "structbtrfsic_dev_state",
            "collision_resolving_node"
          ],
          "line": 646
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each",
          "args": [
            "elem",
            "h->table + hashval"
          ],
          "line": 644
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"extent_io.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n#include <linux/blkdev.h>\n#include <linux/genhd.h>\n#include <linux/mutex.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\n#define BTRFSIC_DEV2STATE_HASHTABLE_SIZE 0x100\n\nstatic void btrfsic_dev_state_init(struct btrfsic_dev_state *ds);\nstatic void btrfsic_dev_state_free(struct btrfsic_dev_state *ds);\nstatic void btrfsic_block_hashtable_init(struct btrfsic_block_hashtable *h);\nstatic void btrfsic_block_hashtable_add(struct btrfsic_block *b,\n\t\t\t\t\tstruct btrfsic_block_hashtable *h);\nstatic struct btrfsic_block *btrfsic_block_hashtable_lookup(\n\t\tstruct block_device *bdev,\n\t\tu64 dev_bytenr,\n\t\tstruct btrfsic_block_hashtable *h);\nstatic void btrfsic_block_link_hashtable_init(\n\t\tstruct btrfsic_block_link_hashtable *h);\nstatic void btrfsic_block_link_hashtable_add(\n\t\tstruct btrfsic_block_link *l,\n\t\tstruct btrfsic_block_link_hashtable *h);\nstatic struct btrfsic_block_link *btrfsic_block_link_hashtable_lookup(\n\t\tstruct block_device *bdev_ref_to,\n\t\tu64 dev_bytenr_ref_to,\n\t\tstruct block_device *bdev_ref_from,\n\t\tu64 dev_bytenr_ref_from,\n\t\tstruct btrfsic_block_link_hashtable *h);\nstatic void btrfsic_dev_state_hashtable_init(\n\t\tstruct btrfsic_dev_state_hashtable *h);\nstatic void btrfsic_dev_state_hashtable_add(\n\t\tstruct btrfsic_dev_state *ds,\n\t\tstruct btrfsic_dev_state_hashtable *h);\nstatic void btrfsic_dev_state_hashtable_remove(struct btrfsic_dev_state *ds);\nstatic struct btrfsic_dev_state *btrfsic_dev_state_hashtable_lookup(\n\t\tstruct block_device *bdev,\n\t\tstruct btrfsic_dev_state_hashtable *h);\nstatic struct btrfsic_dev_state *btrfsic_dev_state_lookup(\n\t\tstruct block_device *bdev);\nstatic struct btrfsic_dev_state_hashtable btrfsic_dev_state_hashtable;\n\nstatic struct btrfsic_dev_state *btrfsic_dev_state_hashtable_lookup(\n\t\tstruct block_device *bdev,\n\t\tstruct btrfsic_dev_state_hashtable *h)\n{\n\tconst unsigned int hashval =\n\t    (((unsigned int)((uintptr_t)bdev)) &\n\t     (BTRFSIC_DEV2STATE_HASHTABLE_SIZE - 1));\n\tstruct list_head *elem;\n\n\tlist_for_each(elem, h->table + hashval) {\n\t\tstruct btrfsic_dev_state *const ds =\n\t\t    list_entry(elem, struct btrfsic_dev_state,\n\t\t\t       collision_resolving_node);\n\n\t\tif (ds->bdev == bdev)\n\t\t\treturn ds;\n\t}\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "btrfsic_dev_state_hashtable_remove",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/check-integrity.c",
    "lines": "630-633",
    "snippet": "static void btrfsic_dev_state_hashtable_remove(struct btrfsic_dev_state *ds)\n{\n\tlist_del(&ds->collision_resolving_node);\n}",
    "includes": [
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"volumes.h\"",
      "#include \"extent_io.h\"",
      "#include \"transaction.h\"",
      "#include \"hash.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/genhd.h>",
      "#include <linux/mutex.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void btrfsic_dev_state_init(struct btrfsic_dev_state *ds);",
      "static void btrfsic_dev_state_free(struct btrfsic_dev_state *ds);",
      "static void btrfsic_dev_state_hashtable_remove(struct btrfsic_dev_state *ds);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&ds->collision_resolving_node"
          ],
          "line": 632
        },
        "resolved": true,
        "details": {
          "function_name": "inode_sb_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "433-440",
          "snippet": "static inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\n__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"extent_io.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n#include <linux/blkdev.h>\n#include <linux/genhd.h>\n#include <linux/mutex.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic void btrfsic_dev_state_init(struct btrfsic_dev_state *ds);\nstatic void btrfsic_dev_state_free(struct btrfsic_dev_state *ds);\nstatic void btrfsic_dev_state_hashtable_remove(struct btrfsic_dev_state *ds);\n\nstatic void btrfsic_dev_state_hashtable_remove(struct btrfsic_dev_state *ds)\n{\n\tlist_del(&ds->collision_resolving_node);\n}"
  },
  {
    "function_name": "btrfsic_dev_state_hashtable_add",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/check-integrity.c",
    "lines": "619-628",
    "snippet": "static void btrfsic_dev_state_hashtable_add(\n\t\tstruct btrfsic_dev_state *ds,\n\t\tstruct btrfsic_dev_state_hashtable *h)\n{\n\tconst unsigned int hashval =\n\t    (((unsigned int)((uintptr_t)ds->bdev)) &\n\t     (BTRFSIC_DEV2STATE_HASHTABLE_SIZE - 1));\n\n\tlist_add(&ds->collision_resolving_node, h->table + hashval);\n}",
    "includes": [
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"volumes.h\"",
      "#include \"extent_io.h\"",
      "#include \"transaction.h\"",
      "#include \"hash.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/genhd.h>",
      "#include <linux/mutex.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [
      "#define BTRFSIC_DEV2STATE_HASHTABLE_SIZE 0x100"
    ],
    "globals_used": [
      "static void btrfsic_dev_state_init(struct btrfsic_dev_state *ds);",
      "static void btrfsic_dev_state_free(struct btrfsic_dev_state *ds);",
      "static void btrfsic_block_hashtable_init(struct btrfsic_block_hashtable *h);",
      "static void btrfsic_block_hashtable_add(struct btrfsic_block *b,\n\t\t\t\t\tstruct btrfsic_block_hashtable *h);",
      "static struct btrfsic_block *btrfsic_block_hashtable_lookup(\n\t\tstruct block_device *bdev,\n\t\tu64 dev_bytenr,\n\t\tstruct btrfsic_block_hashtable *h);",
      "static void btrfsic_block_link_hashtable_init(\n\t\tstruct btrfsic_block_link_hashtable *h);",
      "static void btrfsic_block_link_hashtable_add(\n\t\tstruct btrfsic_block_link *l,\n\t\tstruct btrfsic_block_link_hashtable *h);",
      "static struct btrfsic_block_link *btrfsic_block_link_hashtable_lookup(\n\t\tstruct block_device *bdev_ref_to,\n\t\tu64 dev_bytenr_ref_to,\n\t\tstruct block_device *bdev_ref_from,\n\t\tu64 dev_bytenr_ref_from,\n\t\tstruct btrfsic_block_link_hashtable *h);",
      "static void btrfsic_dev_state_hashtable_init(\n\t\tstruct btrfsic_dev_state_hashtable *h);",
      "static void btrfsic_dev_state_hashtable_add(\n\t\tstruct btrfsic_dev_state *ds,\n\t\tstruct btrfsic_dev_state_hashtable *h);",
      "static void btrfsic_dev_state_hashtable_remove(struct btrfsic_dev_state *ds);",
      "static struct btrfsic_dev_state *btrfsic_dev_state_hashtable_lookup(\n\t\tstruct block_device *bdev,\n\t\tstruct btrfsic_dev_state_hashtable *h);",
      "static struct btrfsic_dev_state *btrfsic_dev_state_lookup(\n\t\tstruct block_device *bdev);",
      "static struct btrfsic_dev_state_hashtable btrfsic_dev_state_hashtable;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&ds->collision_resolving_node",
            "h->table + hashval"
          ],
          "line": 627
        },
        "resolved": true,
        "details": {
          "function_name": "simple_xattr_list_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "966-972",
          "snippet": "void simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"extent_io.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n#include <linux/blkdev.h>\n#include <linux/genhd.h>\n#include <linux/mutex.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\n#define BTRFSIC_DEV2STATE_HASHTABLE_SIZE 0x100\n\nstatic void btrfsic_dev_state_init(struct btrfsic_dev_state *ds);\nstatic void btrfsic_dev_state_free(struct btrfsic_dev_state *ds);\nstatic void btrfsic_block_hashtable_init(struct btrfsic_block_hashtable *h);\nstatic void btrfsic_block_hashtable_add(struct btrfsic_block *b,\n\t\t\t\t\tstruct btrfsic_block_hashtable *h);\nstatic struct btrfsic_block *btrfsic_block_hashtable_lookup(\n\t\tstruct block_device *bdev,\n\t\tu64 dev_bytenr,\n\t\tstruct btrfsic_block_hashtable *h);\nstatic void btrfsic_block_link_hashtable_init(\n\t\tstruct btrfsic_block_link_hashtable *h);\nstatic void btrfsic_block_link_hashtable_add(\n\t\tstruct btrfsic_block_link *l,\n\t\tstruct btrfsic_block_link_hashtable *h);\nstatic struct btrfsic_block_link *btrfsic_block_link_hashtable_lookup(\n\t\tstruct block_device *bdev_ref_to,\n\t\tu64 dev_bytenr_ref_to,\n\t\tstruct block_device *bdev_ref_from,\n\t\tu64 dev_bytenr_ref_from,\n\t\tstruct btrfsic_block_link_hashtable *h);\nstatic void btrfsic_dev_state_hashtable_init(\n\t\tstruct btrfsic_dev_state_hashtable *h);\nstatic void btrfsic_dev_state_hashtable_add(\n\t\tstruct btrfsic_dev_state *ds,\n\t\tstruct btrfsic_dev_state_hashtable *h);\nstatic void btrfsic_dev_state_hashtable_remove(struct btrfsic_dev_state *ds);\nstatic struct btrfsic_dev_state *btrfsic_dev_state_hashtable_lookup(\n\t\tstruct block_device *bdev,\n\t\tstruct btrfsic_dev_state_hashtable *h);\nstatic struct btrfsic_dev_state *btrfsic_dev_state_lookup(\n\t\tstruct block_device *bdev);\nstatic struct btrfsic_dev_state_hashtable btrfsic_dev_state_hashtable;\n\nstatic void btrfsic_dev_state_hashtable_add(\n\t\tstruct btrfsic_dev_state *ds,\n\t\tstruct btrfsic_dev_state_hashtable *h)\n{\n\tconst unsigned int hashval =\n\t    (((unsigned int)((uintptr_t)ds->bdev)) &\n\t     (BTRFSIC_DEV2STATE_HASHTABLE_SIZE - 1));\n\n\tlist_add(&ds->collision_resolving_node, h->table + hashval);\n}"
  },
  {
    "function_name": "btrfsic_dev_state_hashtable_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/check-integrity.c",
    "lines": "610-617",
    "snippet": "static void btrfsic_dev_state_hashtable_init(\n\t\tstruct btrfsic_dev_state_hashtable *h)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFSIC_DEV2STATE_HASHTABLE_SIZE; i++)\n\t\tINIT_LIST_HEAD(h->table + i);\n}",
    "includes": [
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"volumes.h\"",
      "#include \"extent_io.h\"",
      "#include \"transaction.h\"",
      "#include \"hash.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/genhd.h>",
      "#include <linux/mutex.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [
      "#define BTRFSIC_DEV2STATE_HASHTABLE_SIZE 0x100"
    ],
    "globals_used": [
      "static void btrfsic_block_hashtable_init(struct btrfsic_block_hashtable *h);",
      "static void btrfsic_block_hashtable_add(struct btrfsic_block *b,\n\t\t\t\t\tstruct btrfsic_block_hashtable *h);",
      "static struct btrfsic_block *btrfsic_block_hashtable_lookup(\n\t\tstruct block_device *bdev,\n\t\tu64 dev_bytenr,\n\t\tstruct btrfsic_block_hashtable *h);",
      "static void btrfsic_block_link_hashtable_init(\n\t\tstruct btrfsic_block_link_hashtable *h);",
      "static void btrfsic_block_link_hashtable_add(\n\t\tstruct btrfsic_block_link *l,\n\t\tstruct btrfsic_block_link_hashtable *h);",
      "static struct btrfsic_block_link *btrfsic_block_link_hashtable_lookup(\n\t\tstruct block_device *bdev_ref_to,\n\t\tu64 dev_bytenr_ref_to,\n\t\tstruct block_device *bdev_ref_from,\n\t\tu64 dev_bytenr_ref_from,\n\t\tstruct btrfsic_block_link_hashtable *h);",
      "static void btrfsic_dev_state_hashtable_init(\n\t\tstruct btrfsic_dev_state_hashtable *h);",
      "static void btrfsic_dev_state_hashtable_add(\n\t\tstruct btrfsic_dev_state *ds,\n\t\tstruct btrfsic_dev_state_hashtable *h);",
      "static struct btrfsic_dev_state *btrfsic_dev_state_hashtable_lookup(\n\t\tstruct block_device *bdev,\n\t\tstruct btrfsic_dev_state_hashtable *h);",
      "static struct btrfsic_dev_state_hashtable btrfsic_dev_state_hashtable;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "h->table + i"
          ],
          "line": 616
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"extent_io.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n#include <linux/blkdev.h>\n#include <linux/genhd.h>\n#include <linux/mutex.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\n#define BTRFSIC_DEV2STATE_HASHTABLE_SIZE 0x100\n\nstatic void btrfsic_block_hashtable_init(struct btrfsic_block_hashtable *h);\nstatic void btrfsic_block_hashtable_add(struct btrfsic_block *b,\n\t\t\t\t\tstruct btrfsic_block_hashtable *h);\nstatic struct btrfsic_block *btrfsic_block_hashtable_lookup(\n\t\tstruct block_device *bdev,\n\t\tu64 dev_bytenr,\n\t\tstruct btrfsic_block_hashtable *h);\nstatic void btrfsic_block_link_hashtable_init(\n\t\tstruct btrfsic_block_link_hashtable *h);\nstatic void btrfsic_block_link_hashtable_add(\n\t\tstruct btrfsic_block_link *l,\n\t\tstruct btrfsic_block_link_hashtable *h);\nstatic struct btrfsic_block_link *btrfsic_block_link_hashtable_lookup(\n\t\tstruct block_device *bdev_ref_to,\n\t\tu64 dev_bytenr_ref_to,\n\t\tstruct block_device *bdev_ref_from,\n\t\tu64 dev_bytenr_ref_from,\n\t\tstruct btrfsic_block_link_hashtable *h);\nstatic void btrfsic_dev_state_hashtable_init(\n\t\tstruct btrfsic_dev_state_hashtable *h);\nstatic void btrfsic_dev_state_hashtable_add(\n\t\tstruct btrfsic_dev_state *ds,\n\t\tstruct btrfsic_dev_state_hashtable *h);\nstatic struct btrfsic_dev_state *btrfsic_dev_state_hashtable_lookup(\n\t\tstruct block_device *bdev,\n\t\tstruct btrfsic_dev_state_hashtable *h);\nstatic struct btrfsic_dev_state_hashtable btrfsic_dev_state_hashtable;\n\nstatic void btrfsic_dev_state_hashtable_init(\n\t\tstruct btrfsic_dev_state_hashtable *h)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFSIC_DEV2STATE_HASHTABLE_SIZE; i++)\n\t\tINIT_LIST_HEAD(h->table + i);\n}"
  },
  {
    "function_name": "btrfsic_block_link_hashtable_lookup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/check-integrity.c",
    "lines": "578-608",
    "snippet": "static struct btrfsic_block_link *btrfsic_block_link_hashtable_lookup(\n\t\tstruct block_device *bdev_ref_to,\n\t\tu64 dev_bytenr_ref_to,\n\t\tstruct block_device *bdev_ref_from,\n\t\tu64 dev_bytenr_ref_from,\n\t\tstruct btrfsic_block_link_hashtable *h)\n{\n\tconst unsigned int hashval =\n\t    (((unsigned int)(dev_bytenr_ref_to >> 16)) ^\n\t     ((unsigned int)(dev_bytenr_ref_from >> 16)) ^\n\t     ((unsigned int)((uintptr_t)bdev_ref_to)) ^\n\t     ((unsigned int)((uintptr_t)bdev_ref_from))) &\n\t     (BTRFSIC_BLOCK_LINK_HASHTABLE_SIZE - 1);\n\tstruct list_head *elem;\n\n\tlist_for_each(elem, h->table + hashval) {\n\t\tstruct btrfsic_block_link *const l =\n\t\t    list_entry(elem, struct btrfsic_block_link,\n\t\t\t       collision_resolving_node);\n\n\t\tBUG_ON(NULL == l->block_ref_to);\n\t\tBUG_ON(NULL == l->block_ref_from);\n\t\tif (l->block_ref_to->dev_state->bdev == bdev_ref_to &&\n\t\t    l->block_ref_to->dev_bytenr == dev_bytenr_ref_to &&\n\t\t    l->block_ref_from->dev_state->bdev == bdev_ref_from &&\n\t\t    l->block_ref_from->dev_bytenr == dev_bytenr_ref_from)\n\t\t\treturn l;\n\t}\n\n\treturn NULL;\n}",
    "includes": [
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"volumes.h\"",
      "#include \"extent_io.h\"",
      "#include \"transaction.h\"",
      "#include \"hash.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/genhd.h>",
      "#include <linux/mutex.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [
      "#define BTRFSIC_BLOCK_LINK_HASHTABLE_SIZE 0x10000"
    ],
    "globals_used": [
      "static void btrfsic_block_hashtable_init(struct btrfsic_block_hashtable *h);",
      "static void btrfsic_block_hashtable_add(struct btrfsic_block *b,\n\t\t\t\t\tstruct btrfsic_block_hashtable *h);",
      "static struct btrfsic_block *btrfsic_block_hashtable_lookup(\n\t\tstruct block_device *bdev,\n\t\tu64 dev_bytenr,\n\t\tstruct btrfsic_block_hashtable *h);",
      "static void btrfsic_block_link_hashtable_init(\n\t\tstruct btrfsic_block_link_hashtable *h);",
      "static void btrfsic_block_link_hashtable_add(\n\t\tstruct btrfsic_block_link *l,\n\t\tstruct btrfsic_block_link_hashtable *h);",
      "static void btrfsic_block_link_hashtable_remove(struct btrfsic_block_link *l);",
      "static struct btrfsic_block_link *btrfsic_block_link_hashtable_lookup(\n\t\tstruct block_device *bdev_ref_to,\n\t\tu64 dev_bytenr_ref_to,\n\t\tstruct block_device *bdev_ref_from,\n\t\tu64 dev_bytenr_ref_from,\n\t\tstruct btrfsic_block_link_hashtable *h);",
      "static void btrfsic_dev_state_hashtable_init(\n\t\tstruct btrfsic_dev_state_hashtable *h);",
      "static void btrfsic_dev_state_hashtable_add(\n\t\tstruct btrfsic_dev_state *ds,\n\t\tstruct btrfsic_dev_state_hashtable *h);",
      "static struct btrfsic_dev_state *btrfsic_dev_state_hashtable_lookup(\n\t\tstruct block_device *bdev,\n\t\tstruct btrfsic_dev_state_hashtable *h);",
      "static void btrfsic_print_add_link(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block_link *l);",
      "static void btrfsic_print_rem_link(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block_link *l);",
      "static struct btrfsic_dev_state *btrfsic_dev_state_lookup(\n\t\tstruct block_device *bdev);",
      "static void btrfsic_cmp_log_and_dev_bytenr(struct btrfsic_state *state,\n\t\t\t\t\t   u64 bytenr,\n\t\t\t\t\t   struct btrfsic_dev_state *dev_state,\n\t\t\t\t\t   u64 dev_bytenr);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "NULL == l->block_ref_from"
          ],
          "line": 599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "NULL == l->block_ref_to"
          ],
          "line": 598
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "elem",
            "structbtrfsic_block_link",
            "collision_resolving_node"
          ],
          "line": 595
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each",
          "args": [
            "elem",
            "h->table + hashval"
          ],
          "line": 593
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"extent_io.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n#include <linux/blkdev.h>\n#include <linux/genhd.h>\n#include <linux/mutex.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\n#define BTRFSIC_BLOCK_LINK_HASHTABLE_SIZE 0x10000\n\nstatic void btrfsic_block_hashtable_init(struct btrfsic_block_hashtable *h);\nstatic void btrfsic_block_hashtable_add(struct btrfsic_block *b,\n\t\t\t\t\tstruct btrfsic_block_hashtable *h);\nstatic struct btrfsic_block *btrfsic_block_hashtable_lookup(\n\t\tstruct block_device *bdev,\n\t\tu64 dev_bytenr,\n\t\tstruct btrfsic_block_hashtable *h);\nstatic void btrfsic_block_link_hashtable_init(\n\t\tstruct btrfsic_block_link_hashtable *h);\nstatic void btrfsic_block_link_hashtable_add(\n\t\tstruct btrfsic_block_link *l,\n\t\tstruct btrfsic_block_link_hashtable *h);\nstatic void btrfsic_block_link_hashtable_remove(struct btrfsic_block_link *l);\nstatic struct btrfsic_block_link *btrfsic_block_link_hashtable_lookup(\n\t\tstruct block_device *bdev_ref_to,\n\t\tu64 dev_bytenr_ref_to,\n\t\tstruct block_device *bdev_ref_from,\n\t\tu64 dev_bytenr_ref_from,\n\t\tstruct btrfsic_block_link_hashtable *h);\nstatic void btrfsic_dev_state_hashtable_init(\n\t\tstruct btrfsic_dev_state_hashtable *h);\nstatic void btrfsic_dev_state_hashtable_add(\n\t\tstruct btrfsic_dev_state *ds,\n\t\tstruct btrfsic_dev_state_hashtable *h);\nstatic struct btrfsic_dev_state *btrfsic_dev_state_hashtable_lookup(\n\t\tstruct block_device *bdev,\n\t\tstruct btrfsic_dev_state_hashtable *h);\nstatic void btrfsic_print_add_link(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block_link *l);\nstatic void btrfsic_print_rem_link(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block_link *l);\nstatic struct btrfsic_dev_state *btrfsic_dev_state_lookup(\n\t\tstruct block_device *bdev);\nstatic void btrfsic_cmp_log_and_dev_bytenr(struct btrfsic_state *state,\n\t\t\t\t\t   u64 bytenr,\n\t\t\t\t\t   struct btrfsic_dev_state *dev_state,\n\t\t\t\t\t   u64 dev_bytenr);\n\nstatic struct btrfsic_block_link *btrfsic_block_link_hashtable_lookup(\n\t\tstruct block_device *bdev_ref_to,\n\t\tu64 dev_bytenr_ref_to,\n\t\tstruct block_device *bdev_ref_from,\n\t\tu64 dev_bytenr_ref_from,\n\t\tstruct btrfsic_block_link_hashtable *h)\n{\n\tconst unsigned int hashval =\n\t    (((unsigned int)(dev_bytenr_ref_to >> 16)) ^\n\t     ((unsigned int)(dev_bytenr_ref_from >> 16)) ^\n\t     ((unsigned int)((uintptr_t)bdev_ref_to)) ^\n\t     ((unsigned int)((uintptr_t)bdev_ref_from))) &\n\t     (BTRFSIC_BLOCK_LINK_HASHTABLE_SIZE - 1);\n\tstruct list_head *elem;\n\n\tlist_for_each(elem, h->table + hashval) {\n\t\tstruct btrfsic_block_link *const l =\n\t\t    list_entry(elem, struct btrfsic_block_link,\n\t\t\t       collision_resolving_node);\n\n\t\tBUG_ON(NULL == l->block_ref_to);\n\t\tBUG_ON(NULL == l->block_ref_from);\n\t\tif (l->block_ref_to->dev_state->bdev == bdev_ref_to &&\n\t\t    l->block_ref_to->dev_bytenr == dev_bytenr_ref_to &&\n\t\t    l->block_ref_from->dev_state->bdev == bdev_ref_from &&\n\t\t    l->block_ref_from->dev_bytenr == dev_bytenr_ref_from)\n\t\t\treturn l;\n\t}\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "btrfsic_block_link_hashtable_remove",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/check-integrity.c",
    "lines": "573-576",
    "snippet": "static void btrfsic_block_link_hashtable_remove(struct btrfsic_block_link *l)\n{\n\tlist_del(&l->collision_resolving_node);\n}",
    "includes": [
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"volumes.h\"",
      "#include \"extent_io.h\"",
      "#include \"transaction.h\"",
      "#include \"hash.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/genhd.h>",
      "#include <linux/mutex.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void btrfsic_block_link_hashtable_remove(struct btrfsic_block_link *l);",
      "static void btrfsic_print_add_link(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block_link *l);",
      "static void btrfsic_print_rem_link(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block_link *l);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&l->collision_resolving_node"
          ],
          "line": 575
        },
        "resolved": true,
        "details": {
          "function_name": "inode_sb_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "433-440",
          "snippet": "static inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\n__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"extent_io.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n#include <linux/blkdev.h>\n#include <linux/genhd.h>\n#include <linux/mutex.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic void btrfsic_block_link_hashtable_remove(struct btrfsic_block_link *l);\nstatic void btrfsic_print_add_link(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block_link *l);\nstatic void btrfsic_print_rem_link(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block_link *l);\n\nstatic void btrfsic_block_link_hashtable_remove(struct btrfsic_block_link *l)\n{\n\tlist_del(&l->collision_resolving_node);\n}"
  },
  {
    "function_name": "btrfsic_block_link_hashtable_add",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/check-integrity.c",
    "lines": "557-571",
    "snippet": "static void btrfsic_block_link_hashtable_add(\n\t\tstruct btrfsic_block_link *l,\n\t\tstruct btrfsic_block_link_hashtable *h)\n{\n\tconst unsigned int hashval =\n\t    (((unsigned int)(l->block_ref_to->dev_bytenr >> 16)) ^\n\t     ((unsigned int)(l->block_ref_from->dev_bytenr >> 16)) ^\n\t     ((unsigned int)((uintptr_t)l->block_ref_to->dev_state->bdev)) ^\n\t     ((unsigned int)((uintptr_t)l->block_ref_from->dev_state->bdev)))\n\t     & (BTRFSIC_BLOCK_LINK_HASHTABLE_SIZE - 1);\n\n\tBUG_ON(NULL == l->block_ref_to);\n\tBUG_ON(NULL == l->block_ref_from);\n\tlist_add(&l->collision_resolving_node, h->table + hashval);\n}",
    "includes": [
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"volumes.h\"",
      "#include \"extent_io.h\"",
      "#include \"transaction.h\"",
      "#include \"hash.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/genhd.h>",
      "#include <linux/mutex.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [
      "#define BTRFSIC_BLOCK_LINK_HASHTABLE_SIZE 0x10000"
    ],
    "globals_used": [
      "static void btrfsic_block_hashtable_init(struct btrfsic_block_hashtable *h);",
      "static void btrfsic_block_hashtable_add(struct btrfsic_block *b,\n\t\t\t\t\tstruct btrfsic_block_hashtable *h);",
      "static struct btrfsic_block *btrfsic_block_hashtable_lookup(\n\t\tstruct block_device *bdev,\n\t\tu64 dev_bytenr,\n\t\tstruct btrfsic_block_hashtable *h);",
      "static void btrfsic_block_link_hashtable_init(\n\t\tstruct btrfsic_block_link_hashtable *h);",
      "static void btrfsic_block_link_hashtable_add(\n\t\tstruct btrfsic_block_link *l,\n\t\tstruct btrfsic_block_link_hashtable *h);",
      "static void btrfsic_block_link_hashtable_remove(struct btrfsic_block_link *l);",
      "static struct btrfsic_block_link *btrfsic_block_link_hashtable_lookup(\n\t\tstruct block_device *bdev_ref_to,\n\t\tu64 dev_bytenr_ref_to,\n\t\tstruct block_device *bdev_ref_from,\n\t\tu64 dev_bytenr_ref_from,\n\t\tstruct btrfsic_block_link_hashtable *h);",
      "static void btrfsic_dev_state_hashtable_init(\n\t\tstruct btrfsic_dev_state_hashtable *h);",
      "static void btrfsic_dev_state_hashtable_add(\n\t\tstruct btrfsic_dev_state *ds,\n\t\tstruct btrfsic_dev_state_hashtable *h);",
      "static struct btrfsic_dev_state *btrfsic_dev_state_hashtable_lookup(\n\t\tstruct block_device *bdev,\n\t\tstruct btrfsic_dev_state_hashtable *h);",
      "static void btrfsic_print_add_link(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block_link *l);",
      "static void btrfsic_print_rem_link(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block_link *l);",
      "static struct btrfsic_dev_state *btrfsic_dev_state_lookup(\n\t\tstruct block_device *bdev);",
      "static void btrfsic_cmp_log_and_dev_bytenr(struct btrfsic_state *state,\n\t\t\t\t\t   u64 bytenr,\n\t\t\t\t\t   struct btrfsic_dev_state *dev_state,\n\t\t\t\t\t   u64 dev_bytenr);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&l->collision_resolving_node",
            "h->table + hashval"
          ],
          "line": 570
        },
        "resolved": true,
        "details": {
          "function_name": "simple_xattr_list_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "966-972",
          "snippet": "void simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "NULL == l->block_ref_from"
          ],
          "line": 569
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "NULL == l->block_ref_to"
          ],
          "line": 568
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"extent_io.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n#include <linux/blkdev.h>\n#include <linux/genhd.h>\n#include <linux/mutex.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\n#define BTRFSIC_BLOCK_LINK_HASHTABLE_SIZE 0x10000\n\nstatic void btrfsic_block_hashtable_init(struct btrfsic_block_hashtable *h);\nstatic void btrfsic_block_hashtable_add(struct btrfsic_block *b,\n\t\t\t\t\tstruct btrfsic_block_hashtable *h);\nstatic struct btrfsic_block *btrfsic_block_hashtable_lookup(\n\t\tstruct block_device *bdev,\n\t\tu64 dev_bytenr,\n\t\tstruct btrfsic_block_hashtable *h);\nstatic void btrfsic_block_link_hashtable_init(\n\t\tstruct btrfsic_block_link_hashtable *h);\nstatic void btrfsic_block_link_hashtable_add(\n\t\tstruct btrfsic_block_link *l,\n\t\tstruct btrfsic_block_link_hashtable *h);\nstatic void btrfsic_block_link_hashtable_remove(struct btrfsic_block_link *l);\nstatic struct btrfsic_block_link *btrfsic_block_link_hashtable_lookup(\n\t\tstruct block_device *bdev_ref_to,\n\t\tu64 dev_bytenr_ref_to,\n\t\tstruct block_device *bdev_ref_from,\n\t\tu64 dev_bytenr_ref_from,\n\t\tstruct btrfsic_block_link_hashtable *h);\nstatic void btrfsic_dev_state_hashtable_init(\n\t\tstruct btrfsic_dev_state_hashtable *h);\nstatic void btrfsic_dev_state_hashtable_add(\n\t\tstruct btrfsic_dev_state *ds,\n\t\tstruct btrfsic_dev_state_hashtable *h);\nstatic struct btrfsic_dev_state *btrfsic_dev_state_hashtable_lookup(\n\t\tstruct block_device *bdev,\n\t\tstruct btrfsic_dev_state_hashtable *h);\nstatic void btrfsic_print_add_link(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block_link *l);\nstatic void btrfsic_print_rem_link(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block_link *l);\nstatic struct btrfsic_dev_state *btrfsic_dev_state_lookup(\n\t\tstruct block_device *bdev);\nstatic void btrfsic_cmp_log_and_dev_bytenr(struct btrfsic_state *state,\n\t\t\t\t\t   u64 bytenr,\n\t\t\t\t\t   struct btrfsic_dev_state *dev_state,\n\t\t\t\t\t   u64 dev_bytenr);\n\nstatic void btrfsic_block_link_hashtable_add(\n\t\tstruct btrfsic_block_link *l,\n\t\tstruct btrfsic_block_link_hashtable *h)\n{\n\tconst unsigned int hashval =\n\t    (((unsigned int)(l->block_ref_to->dev_bytenr >> 16)) ^\n\t     ((unsigned int)(l->block_ref_from->dev_bytenr >> 16)) ^\n\t     ((unsigned int)((uintptr_t)l->block_ref_to->dev_state->bdev)) ^\n\t     ((unsigned int)((uintptr_t)l->block_ref_from->dev_state->bdev)))\n\t     & (BTRFSIC_BLOCK_LINK_HASHTABLE_SIZE - 1);\n\n\tBUG_ON(NULL == l->block_ref_to);\n\tBUG_ON(NULL == l->block_ref_from);\n\tlist_add(&l->collision_resolving_node, h->table + hashval);\n}"
  },
  {
    "function_name": "btrfsic_block_link_hashtable_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/check-integrity.c",
    "lines": "548-555",
    "snippet": "static void btrfsic_block_link_hashtable_init(\n\t\tstruct btrfsic_block_link_hashtable *h)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFSIC_BLOCK_LINK_HASHTABLE_SIZE; i++)\n\t\tINIT_LIST_HEAD(h->table + i);\n}",
    "includes": [
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"volumes.h\"",
      "#include \"extent_io.h\"",
      "#include \"transaction.h\"",
      "#include \"hash.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/genhd.h>",
      "#include <linux/mutex.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [
      "#define BTRFSIC_BLOCK_LINK_HASHTABLE_SIZE 0x10000"
    ],
    "globals_used": [
      "static void btrfsic_block_hashtable_init(struct btrfsic_block_hashtable *h);",
      "static void btrfsic_block_hashtable_add(struct btrfsic_block *b,\n\t\t\t\t\tstruct btrfsic_block_hashtable *h);",
      "static struct btrfsic_block *btrfsic_block_hashtable_lookup(\n\t\tstruct block_device *bdev,\n\t\tu64 dev_bytenr,\n\t\tstruct btrfsic_block_hashtable *h);",
      "static void btrfsic_block_link_hashtable_init(\n\t\tstruct btrfsic_block_link_hashtable *h);",
      "static void btrfsic_block_link_hashtable_add(\n\t\tstruct btrfsic_block_link *l,\n\t\tstruct btrfsic_block_link_hashtable *h);",
      "static struct btrfsic_block_link *btrfsic_block_link_hashtable_lookup(\n\t\tstruct block_device *bdev_ref_to,\n\t\tu64 dev_bytenr_ref_to,\n\t\tstruct block_device *bdev_ref_from,\n\t\tu64 dev_bytenr_ref_from,\n\t\tstruct btrfsic_block_link_hashtable *h);",
      "static void btrfsic_dev_state_hashtable_init(\n\t\tstruct btrfsic_dev_state_hashtable *h);",
      "static void btrfsic_dev_state_hashtable_add(\n\t\tstruct btrfsic_dev_state *ds,\n\t\tstruct btrfsic_dev_state_hashtable *h);",
      "static struct btrfsic_dev_state *btrfsic_dev_state_hashtable_lookup(\n\t\tstruct block_device *bdev,\n\t\tstruct btrfsic_dev_state_hashtable *h);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "h->table + i"
          ],
          "line": 554
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"extent_io.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n#include <linux/blkdev.h>\n#include <linux/genhd.h>\n#include <linux/mutex.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\n#define BTRFSIC_BLOCK_LINK_HASHTABLE_SIZE 0x10000\n\nstatic void btrfsic_block_hashtable_init(struct btrfsic_block_hashtable *h);\nstatic void btrfsic_block_hashtable_add(struct btrfsic_block *b,\n\t\t\t\t\tstruct btrfsic_block_hashtable *h);\nstatic struct btrfsic_block *btrfsic_block_hashtable_lookup(\n\t\tstruct block_device *bdev,\n\t\tu64 dev_bytenr,\n\t\tstruct btrfsic_block_hashtable *h);\nstatic void btrfsic_block_link_hashtable_init(\n\t\tstruct btrfsic_block_link_hashtable *h);\nstatic void btrfsic_block_link_hashtable_add(\n\t\tstruct btrfsic_block_link *l,\n\t\tstruct btrfsic_block_link_hashtable *h);\nstatic struct btrfsic_block_link *btrfsic_block_link_hashtable_lookup(\n\t\tstruct block_device *bdev_ref_to,\n\t\tu64 dev_bytenr_ref_to,\n\t\tstruct block_device *bdev_ref_from,\n\t\tu64 dev_bytenr_ref_from,\n\t\tstruct btrfsic_block_link_hashtable *h);\nstatic void btrfsic_dev_state_hashtable_init(\n\t\tstruct btrfsic_dev_state_hashtable *h);\nstatic void btrfsic_dev_state_hashtable_add(\n\t\tstruct btrfsic_dev_state *ds,\n\t\tstruct btrfsic_dev_state_hashtable *h);\nstatic struct btrfsic_dev_state *btrfsic_dev_state_hashtable_lookup(\n\t\tstruct block_device *bdev,\n\t\tstruct btrfsic_dev_state_hashtable *h);\n\nstatic void btrfsic_block_link_hashtable_init(\n\t\tstruct btrfsic_block_link_hashtable *h)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFSIC_BLOCK_LINK_HASHTABLE_SIZE; i++)\n\t\tINIT_LIST_HEAD(h->table + i);\n}"
  },
  {
    "function_name": "btrfsic_block_hashtable_lookup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/check-integrity.c",
    "lines": "525-546",
    "snippet": "static struct btrfsic_block *btrfsic_block_hashtable_lookup(\n\t\tstruct block_device *bdev,\n\t\tu64 dev_bytenr,\n\t\tstruct btrfsic_block_hashtable *h)\n{\n\tconst unsigned int hashval =\n\t    (((unsigned int)(dev_bytenr >> 16)) ^\n\t     ((unsigned int)((uintptr_t)bdev))) &\n\t     (BTRFSIC_BLOCK_HASHTABLE_SIZE - 1);\n\tstruct list_head *elem;\n\n\tlist_for_each(elem, h->table + hashval) {\n\t\tstruct btrfsic_block *const b =\n\t\t    list_entry(elem, struct btrfsic_block,\n\t\t\t       collision_resolving_node);\n\n\t\tif (b->dev_state->bdev == bdev && b->dev_bytenr == dev_bytenr)\n\t\t\treturn b;\n\t}\n\n\treturn NULL;\n}",
    "includes": [
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"volumes.h\"",
      "#include \"extent_io.h\"",
      "#include \"transaction.h\"",
      "#include \"hash.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/genhd.h>",
      "#include <linux/mutex.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [
      "#define BTRFSIC_BLOCK_HASHTABLE_SIZE 0x10000"
    ],
    "globals_used": [
      "static void btrfsic_block_init(struct btrfsic_block *b);",
      "static void btrfsic_block_free(struct btrfsic_block *b);",
      "static void btrfsic_block_hashtable_init(struct btrfsic_block_hashtable *h);",
      "static void btrfsic_block_hashtable_add(struct btrfsic_block *b,\n\t\t\t\t\tstruct btrfsic_block_hashtable *h);",
      "static void btrfsic_block_hashtable_remove(struct btrfsic_block *b);",
      "static struct btrfsic_block *btrfsic_block_hashtable_lookup(\n\t\tstruct block_device *bdev,\n\t\tu64 dev_bytenr,\n\t\tstruct btrfsic_block_hashtable *h);",
      "static void btrfsic_block_link_hashtable_init(\n\t\tstruct btrfsic_block_link_hashtable *h);",
      "static void btrfsic_block_link_hashtable_add(\n\t\tstruct btrfsic_block_link *l,\n\t\tstruct btrfsic_block_link_hashtable *h);",
      "static struct btrfsic_block_link *btrfsic_block_link_hashtable_lookup(\n\t\tstruct block_device *bdev_ref_to,\n\t\tu64 dev_bytenr_ref_to,\n\t\tstruct block_device *bdev_ref_from,\n\t\tu64 dev_bytenr_ref_from,\n\t\tstruct btrfsic_block_link_hashtable *h);",
      "static void btrfsic_dev_state_hashtable_init(\n\t\tstruct btrfsic_dev_state_hashtable *h);",
      "static void btrfsic_dev_state_hashtable_add(\n\t\tstruct btrfsic_dev_state *ds,\n\t\tstruct btrfsic_dev_state_hashtable *h);",
      "static struct btrfsic_dev_state *btrfsic_dev_state_hashtable_lookup(\n\t\tstruct block_device *bdev,\n\t\tstruct btrfsic_dev_state_hashtable *h);",
      "static struct btrfsic_dev_state *btrfsic_dev_state_lookup(\n\t\tstruct block_device *bdev);",
      "static void btrfsic_cmp_log_and_dev_bytenr(struct btrfsic_state *state,\n\t\t\t\t\t   u64 bytenr,\n\t\t\t\t\t   struct btrfsic_dev_state *dev_state,\n\t\t\t\t\t   u64 dev_bytenr);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "elem",
            "structbtrfsic_block",
            "collision_resolving_node"
          ],
          "line": 538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each",
          "args": [
            "elem",
            "h->table + hashval"
          ],
          "line": 536
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"extent_io.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n#include <linux/blkdev.h>\n#include <linux/genhd.h>\n#include <linux/mutex.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\n#define BTRFSIC_BLOCK_HASHTABLE_SIZE 0x10000\n\nstatic void btrfsic_block_init(struct btrfsic_block *b);\nstatic void btrfsic_block_free(struct btrfsic_block *b);\nstatic void btrfsic_block_hashtable_init(struct btrfsic_block_hashtable *h);\nstatic void btrfsic_block_hashtable_add(struct btrfsic_block *b,\n\t\t\t\t\tstruct btrfsic_block_hashtable *h);\nstatic void btrfsic_block_hashtable_remove(struct btrfsic_block *b);\nstatic struct btrfsic_block *btrfsic_block_hashtable_lookup(\n\t\tstruct block_device *bdev,\n\t\tu64 dev_bytenr,\n\t\tstruct btrfsic_block_hashtable *h);\nstatic void btrfsic_block_link_hashtable_init(\n\t\tstruct btrfsic_block_link_hashtable *h);\nstatic void btrfsic_block_link_hashtable_add(\n\t\tstruct btrfsic_block_link *l,\n\t\tstruct btrfsic_block_link_hashtable *h);\nstatic struct btrfsic_block_link *btrfsic_block_link_hashtable_lookup(\n\t\tstruct block_device *bdev_ref_to,\n\t\tu64 dev_bytenr_ref_to,\n\t\tstruct block_device *bdev_ref_from,\n\t\tu64 dev_bytenr_ref_from,\n\t\tstruct btrfsic_block_link_hashtable *h);\nstatic void btrfsic_dev_state_hashtable_init(\n\t\tstruct btrfsic_dev_state_hashtable *h);\nstatic void btrfsic_dev_state_hashtable_add(\n\t\tstruct btrfsic_dev_state *ds,\n\t\tstruct btrfsic_dev_state_hashtable *h);\nstatic struct btrfsic_dev_state *btrfsic_dev_state_hashtable_lookup(\n\t\tstruct block_device *bdev,\n\t\tstruct btrfsic_dev_state_hashtable *h);\nstatic struct btrfsic_dev_state *btrfsic_dev_state_lookup(\n\t\tstruct block_device *bdev);\nstatic void btrfsic_cmp_log_and_dev_bytenr(struct btrfsic_state *state,\n\t\t\t\t\t   u64 bytenr,\n\t\t\t\t\t   struct btrfsic_dev_state *dev_state,\n\t\t\t\t\t   u64 dev_bytenr);\n\nstatic struct btrfsic_block *btrfsic_block_hashtable_lookup(\n\t\tstruct block_device *bdev,\n\t\tu64 dev_bytenr,\n\t\tstruct btrfsic_block_hashtable *h)\n{\n\tconst unsigned int hashval =\n\t    (((unsigned int)(dev_bytenr >> 16)) ^\n\t     ((unsigned int)((uintptr_t)bdev))) &\n\t     (BTRFSIC_BLOCK_HASHTABLE_SIZE - 1);\n\tstruct list_head *elem;\n\n\tlist_for_each(elem, h->table + hashval) {\n\t\tstruct btrfsic_block *const b =\n\t\t    list_entry(elem, struct btrfsic_block,\n\t\t\t       collision_resolving_node);\n\n\t\tif (b->dev_state->bdev == bdev && b->dev_bytenr == dev_bytenr)\n\t\t\treturn b;\n\t}\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "btrfsic_block_hashtable_remove",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/check-integrity.c",
    "lines": "520-523",
    "snippet": "static void btrfsic_block_hashtable_remove(struct btrfsic_block *b)\n{\n\tlist_del(&b->collision_resolving_node);\n}",
    "includes": [
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"volumes.h\"",
      "#include \"extent_io.h\"",
      "#include \"transaction.h\"",
      "#include \"hash.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/genhd.h>",
      "#include <linux/mutex.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void btrfsic_block_init(struct btrfsic_block *b);",
      "static void btrfsic_block_free(struct btrfsic_block *b);",
      "static void btrfsic_block_hashtable_remove(struct btrfsic_block *b);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&b->collision_resolving_node"
          ],
          "line": 522
        },
        "resolved": true,
        "details": {
          "function_name": "inode_sb_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "433-440",
          "snippet": "static inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\n__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"extent_io.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n#include <linux/blkdev.h>\n#include <linux/genhd.h>\n#include <linux/mutex.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic void btrfsic_block_init(struct btrfsic_block *b);\nstatic void btrfsic_block_free(struct btrfsic_block *b);\nstatic void btrfsic_block_hashtable_remove(struct btrfsic_block *b);\n\nstatic void btrfsic_block_hashtable_remove(struct btrfsic_block *b)\n{\n\tlist_del(&b->collision_resolving_node);\n}"
  },
  {
    "function_name": "btrfsic_block_hashtable_add",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/check-integrity.c",
    "lines": "509-518",
    "snippet": "static void btrfsic_block_hashtable_add(struct btrfsic_block *b,\n\t\t\t\t\tstruct btrfsic_block_hashtable *h)\n{\n\tconst unsigned int hashval =\n\t    (((unsigned int)(b->dev_bytenr >> 16)) ^\n\t     ((unsigned int)((uintptr_t)b->dev_state->bdev))) &\n\t     (BTRFSIC_BLOCK_HASHTABLE_SIZE - 1);\n\n\tlist_add(&b->collision_resolving_node, h->table + hashval);\n}",
    "includes": [
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"volumes.h\"",
      "#include \"extent_io.h\"",
      "#include \"transaction.h\"",
      "#include \"hash.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/genhd.h>",
      "#include <linux/mutex.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [
      "#define BTRFSIC_BLOCK_HASHTABLE_SIZE 0x10000"
    ],
    "globals_used": [
      "static void btrfsic_block_init(struct btrfsic_block *b);",
      "static void btrfsic_block_free(struct btrfsic_block *b);",
      "static void btrfsic_block_hashtable_init(struct btrfsic_block_hashtable *h);",
      "static void btrfsic_block_hashtable_add(struct btrfsic_block *b,\n\t\t\t\t\tstruct btrfsic_block_hashtable *h);",
      "static void btrfsic_block_hashtable_remove(struct btrfsic_block *b);",
      "static struct btrfsic_block *btrfsic_block_hashtable_lookup(\n\t\tstruct block_device *bdev,\n\t\tu64 dev_bytenr,\n\t\tstruct btrfsic_block_hashtable *h);",
      "static void btrfsic_block_link_hashtable_init(\n\t\tstruct btrfsic_block_link_hashtable *h);",
      "static void btrfsic_block_link_hashtable_add(\n\t\tstruct btrfsic_block_link *l,\n\t\tstruct btrfsic_block_link_hashtable *h);",
      "static struct btrfsic_block_link *btrfsic_block_link_hashtable_lookup(\n\t\tstruct block_device *bdev_ref_to,\n\t\tu64 dev_bytenr_ref_to,\n\t\tstruct block_device *bdev_ref_from,\n\t\tu64 dev_bytenr_ref_from,\n\t\tstruct btrfsic_block_link_hashtable *h);",
      "static void btrfsic_dev_state_hashtable_init(\n\t\tstruct btrfsic_dev_state_hashtable *h);",
      "static void btrfsic_dev_state_hashtable_add(\n\t\tstruct btrfsic_dev_state *ds,\n\t\tstruct btrfsic_dev_state_hashtable *h);",
      "static struct btrfsic_dev_state *btrfsic_dev_state_hashtable_lookup(\n\t\tstruct block_device *bdev,\n\t\tstruct btrfsic_dev_state_hashtable *h);",
      "static struct btrfsic_dev_state *btrfsic_dev_state_lookup(\n\t\tstruct block_device *bdev);",
      "static void btrfsic_cmp_log_and_dev_bytenr(struct btrfsic_state *state,\n\t\t\t\t\t   u64 bytenr,\n\t\t\t\t\t   struct btrfsic_dev_state *dev_state,\n\t\t\t\t\t   u64 dev_bytenr);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&b->collision_resolving_node",
            "h->table + hashval"
          ],
          "line": 517
        },
        "resolved": true,
        "details": {
          "function_name": "simple_xattr_list_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "966-972",
          "snippet": "void simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"extent_io.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n#include <linux/blkdev.h>\n#include <linux/genhd.h>\n#include <linux/mutex.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\n#define BTRFSIC_BLOCK_HASHTABLE_SIZE 0x10000\n\nstatic void btrfsic_block_init(struct btrfsic_block *b);\nstatic void btrfsic_block_free(struct btrfsic_block *b);\nstatic void btrfsic_block_hashtable_init(struct btrfsic_block_hashtable *h);\nstatic void btrfsic_block_hashtable_add(struct btrfsic_block *b,\n\t\t\t\t\tstruct btrfsic_block_hashtable *h);\nstatic void btrfsic_block_hashtable_remove(struct btrfsic_block *b);\nstatic struct btrfsic_block *btrfsic_block_hashtable_lookup(\n\t\tstruct block_device *bdev,\n\t\tu64 dev_bytenr,\n\t\tstruct btrfsic_block_hashtable *h);\nstatic void btrfsic_block_link_hashtable_init(\n\t\tstruct btrfsic_block_link_hashtable *h);\nstatic void btrfsic_block_link_hashtable_add(\n\t\tstruct btrfsic_block_link *l,\n\t\tstruct btrfsic_block_link_hashtable *h);\nstatic struct btrfsic_block_link *btrfsic_block_link_hashtable_lookup(\n\t\tstruct block_device *bdev_ref_to,\n\t\tu64 dev_bytenr_ref_to,\n\t\tstruct block_device *bdev_ref_from,\n\t\tu64 dev_bytenr_ref_from,\n\t\tstruct btrfsic_block_link_hashtable *h);\nstatic void btrfsic_dev_state_hashtable_init(\n\t\tstruct btrfsic_dev_state_hashtable *h);\nstatic void btrfsic_dev_state_hashtable_add(\n\t\tstruct btrfsic_dev_state *ds,\n\t\tstruct btrfsic_dev_state_hashtable *h);\nstatic struct btrfsic_dev_state *btrfsic_dev_state_hashtable_lookup(\n\t\tstruct block_device *bdev,\n\t\tstruct btrfsic_dev_state_hashtable *h);\nstatic struct btrfsic_dev_state *btrfsic_dev_state_lookup(\n\t\tstruct block_device *bdev);\nstatic void btrfsic_cmp_log_and_dev_bytenr(struct btrfsic_state *state,\n\t\t\t\t\t   u64 bytenr,\n\t\t\t\t\t   struct btrfsic_dev_state *dev_state,\n\t\t\t\t\t   u64 dev_bytenr);\n\nstatic void btrfsic_block_hashtable_add(struct btrfsic_block *b,\n\t\t\t\t\tstruct btrfsic_block_hashtable *h)\n{\n\tconst unsigned int hashval =\n\t    (((unsigned int)(b->dev_bytenr >> 16)) ^\n\t     ((unsigned int)((uintptr_t)b->dev_state->bdev))) &\n\t     (BTRFSIC_BLOCK_HASHTABLE_SIZE - 1);\n\n\tlist_add(&b->collision_resolving_node, h->table + hashval);\n}"
  },
  {
    "function_name": "btrfsic_block_hashtable_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/check-integrity.c",
    "lines": "501-507",
    "snippet": "static void btrfsic_block_hashtable_init(struct btrfsic_block_hashtable *h)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFSIC_BLOCK_HASHTABLE_SIZE; i++)\n\t\tINIT_LIST_HEAD(h->table + i);\n}",
    "includes": [
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"volumes.h\"",
      "#include \"extent_io.h\"",
      "#include \"transaction.h\"",
      "#include \"hash.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/genhd.h>",
      "#include <linux/mutex.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [
      "#define BTRFSIC_BLOCK_HASHTABLE_SIZE 0x10000"
    ],
    "globals_used": [
      "static void btrfsic_block_hashtable_init(struct btrfsic_block_hashtable *h);",
      "static void btrfsic_block_hashtable_add(struct btrfsic_block *b,\n\t\t\t\t\tstruct btrfsic_block_hashtable *h);",
      "static struct btrfsic_block *btrfsic_block_hashtable_lookup(\n\t\tstruct block_device *bdev,\n\t\tu64 dev_bytenr,\n\t\tstruct btrfsic_block_hashtable *h);",
      "static void btrfsic_block_link_hashtable_init(\n\t\tstruct btrfsic_block_link_hashtable *h);",
      "static void btrfsic_block_link_hashtable_add(\n\t\tstruct btrfsic_block_link *l,\n\t\tstruct btrfsic_block_link_hashtable *h);",
      "static struct btrfsic_block_link *btrfsic_block_link_hashtable_lookup(\n\t\tstruct block_device *bdev_ref_to,\n\t\tu64 dev_bytenr_ref_to,\n\t\tstruct block_device *bdev_ref_from,\n\t\tu64 dev_bytenr_ref_from,\n\t\tstruct btrfsic_block_link_hashtable *h);",
      "static void btrfsic_dev_state_hashtable_init(\n\t\tstruct btrfsic_dev_state_hashtable *h);",
      "static void btrfsic_dev_state_hashtable_add(\n\t\tstruct btrfsic_dev_state *ds,\n\t\tstruct btrfsic_dev_state_hashtable *h);",
      "static struct btrfsic_dev_state *btrfsic_dev_state_hashtable_lookup(\n\t\tstruct block_device *bdev,\n\t\tstruct btrfsic_dev_state_hashtable *h);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "h->table + i"
          ],
          "line": 506
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"extent_io.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n#include <linux/blkdev.h>\n#include <linux/genhd.h>\n#include <linux/mutex.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\n#define BTRFSIC_BLOCK_HASHTABLE_SIZE 0x10000\n\nstatic void btrfsic_block_hashtable_init(struct btrfsic_block_hashtable *h);\nstatic void btrfsic_block_hashtable_add(struct btrfsic_block *b,\n\t\t\t\t\tstruct btrfsic_block_hashtable *h);\nstatic struct btrfsic_block *btrfsic_block_hashtable_lookup(\n\t\tstruct block_device *bdev,\n\t\tu64 dev_bytenr,\n\t\tstruct btrfsic_block_hashtable *h);\nstatic void btrfsic_block_link_hashtable_init(\n\t\tstruct btrfsic_block_link_hashtable *h);\nstatic void btrfsic_block_link_hashtable_add(\n\t\tstruct btrfsic_block_link *l,\n\t\tstruct btrfsic_block_link_hashtable *h);\nstatic struct btrfsic_block_link *btrfsic_block_link_hashtable_lookup(\n\t\tstruct block_device *bdev_ref_to,\n\t\tu64 dev_bytenr_ref_to,\n\t\tstruct block_device *bdev_ref_from,\n\t\tu64 dev_bytenr_ref_from,\n\t\tstruct btrfsic_block_link_hashtable *h);\nstatic void btrfsic_dev_state_hashtable_init(\n\t\tstruct btrfsic_dev_state_hashtable *h);\nstatic void btrfsic_dev_state_hashtable_add(\n\t\tstruct btrfsic_dev_state *ds,\n\t\tstruct btrfsic_dev_state_hashtable *h);\nstatic struct btrfsic_dev_state *btrfsic_dev_state_hashtable_lookup(\n\t\tstruct block_device *bdev,\n\t\tstruct btrfsic_dev_state_hashtable *h);\n\nstatic void btrfsic_block_hashtable_init(struct btrfsic_block_hashtable *h)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFSIC_BLOCK_HASHTABLE_SIZE; i++)\n\t\tINIT_LIST_HEAD(h->table + i);\n}"
  },
  {
    "function_name": "btrfsic_dev_state_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/check-integrity.c",
    "lines": "494-499",
    "snippet": "static void btrfsic_dev_state_free(struct btrfsic_dev_state *ds)\n{\n\tBUG_ON(!(NULL == ds ||\n\t\t BTRFSIC_DEV2STATE_MAGIC_NUMBER == ds->magic_num));\n\tkfree(ds);\n}",
    "includes": [
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"volumes.h\"",
      "#include \"extent_io.h\"",
      "#include \"transaction.h\"",
      "#include \"hash.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/genhd.h>",
      "#include <linux/mutex.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [
      "#define BTRFSIC_DEV2STATE_MAGIC_NUMBER 0x20111530"
    ],
    "globals_used": [
      "static void btrfsic_dev_state_init(struct btrfsic_dev_state *ds);",
      "static void btrfsic_dev_state_free(struct btrfsic_dev_state *ds);",
      "static void btrfsic_dev_state_hashtable_remove(struct btrfsic_dev_state *ds);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ds"
          ],
          "line": 498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!(NULL == ds ||\n\t\t BTRFSIC_DEV2STATE_MAGIC_NUMBER == ds->magic_num)"
          ],
          "line": 496
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"extent_io.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n#include <linux/blkdev.h>\n#include <linux/genhd.h>\n#include <linux/mutex.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\n#define BTRFSIC_DEV2STATE_MAGIC_NUMBER 0x20111530\n\nstatic void btrfsic_dev_state_init(struct btrfsic_dev_state *ds);\nstatic void btrfsic_dev_state_free(struct btrfsic_dev_state *ds);\nstatic void btrfsic_dev_state_hashtable_remove(struct btrfsic_dev_state *ds);\n\nstatic void btrfsic_dev_state_free(struct btrfsic_dev_state *ds)\n{\n\tBUG_ON(!(NULL == ds ||\n\t\t BTRFSIC_DEV2STATE_MAGIC_NUMBER == ds->magic_num));\n\tkfree(ds);\n}"
  },
  {
    "function_name": "btrfsic_dev_state_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/check-integrity.c",
    "lines": "483-492",
    "snippet": "static struct btrfsic_dev_state *btrfsic_dev_state_alloc(void)\n{\n\tstruct btrfsic_dev_state *ds;\n\n\tds = kzalloc(sizeof(*ds), GFP_NOFS);\n\tif (NULL != ds)\n\t\tbtrfsic_dev_state_init(ds);\n\n\treturn ds;\n}",
    "includes": [
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"volumes.h\"",
      "#include \"extent_io.h\"",
      "#include \"transaction.h\"",
      "#include \"hash.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/genhd.h>",
      "#include <linux/mutex.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void btrfsic_dev_state_init(struct btrfsic_dev_state *ds);",
      "static struct btrfsic_dev_state *btrfsic_dev_state_alloc(void);",
      "static void btrfsic_dev_state_free(struct btrfsic_dev_state *ds);",
      "static void btrfsic_dev_state_hashtable_remove(struct btrfsic_dev_state *ds);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfsic_dev_state_init",
          "args": [
            "ds"
          ],
          "line": 489
        },
        "resolved": true,
        "details": {
          "function_name": "btrfsic_dev_state_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/check-integrity.c",
          "lines": "470-481",
          "snippet": "static void btrfsic_dev_state_init(struct btrfsic_dev_state *ds)\n{\n\tds->magic_num = BTRFSIC_DEV2STATE_MAGIC_NUMBER;\n\tds->bdev = NULL;\n\tds->state = NULL;\n\tds->name[0] = '\\0';\n\tINIT_LIST_HEAD(&ds->collision_resolving_node);\n\tds->last_flush_gen = 0;\n\tbtrfsic_block_init(&ds->dummy_block_for_bio_bh_flush);\n\tds->dummy_block_for_bio_bh_flush.is_iodone = 1;\n\tds->dummy_block_for_bio_bh_flush.dev_state = ds;\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"extent_io.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/genhd.h>",
            "#include <linux/mutex.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define BTRFSIC_DEV2STATE_MAGIC_NUMBER 0x20111530"
          ],
          "globals_used": [
            "static void btrfsic_dev_state_init(struct btrfsic_dev_state *ds);",
            "static void btrfsic_dev_state_free(struct btrfsic_dev_state *ds);",
            "static void btrfsic_dev_state_hashtable_remove(struct btrfsic_dev_state *ds);",
            "static void btrfsic_dump_database(struct btrfsic_state *state);",
            "static void btrfsic_dump_tree(const struct btrfsic_state *state);",
            "static struct btrfsic_dev_state *btrfsic_dev_state_lookup(\n\t\tstruct block_device *bdev);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"extent_io.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n#include <linux/blkdev.h>\n#include <linux/genhd.h>\n#include <linux/mutex.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\n#define BTRFSIC_DEV2STATE_MAGIC_NUMBER 0x20111530\n\nstatic void btrfsic_dev_state_init(struct btrfsic_dev_state *ds);\nstatic void btrfsic_dev_state_free(struct btrfsic_dev_state *ds);\nstatic void btrfsic_dev_state_hashtable_remove(struct btrfsic_dev_state *ds);\nstatic void btrfsic_dump_database(struct btrfsic_state *state);\nstatic void btrfsic_dump_tree(const struct btrfsic_state *state);\nstatic struct btrfsic_dev_state *btrfsic_dev_state_lookup(\n\t\tstruct block_device *bdev);\n\nstatic void btrfsic_dev_state_init(struct btrfsic_dev_state *ds)\n{\n\tds->magic_num = BTRFSIC_DEV2STATE_MAGIC_NUMBER;\n\tds->bdev = NULL;\n\tds->state = NULL;\n\tds->name[0] = '\\0';\n\tINIT_LIST_HEAD(&ds->collision_resolving_node);\n\tds->last_flush_gen = 0;\n\tbtrfsic_block_init(&ds->dummy_block_for_bio_bh_flush);\n\tds->dummy_block_for_bio_bh_flush.is_iodone = 1;\n\tds->dummy_block_for_bio_bh_flush.dev_state = ds;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*ds)",
            "GFP_NOFS"
          ],
          "line": 487
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"extent_io.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n#include <linux/blkdev.h>\n#include <linux/genhd.h>\n#include <linux/mutex.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic void btrfsic_dev_state_init(struct btrfsic_dev_state *ds);\nstatic struct btrfsic_dev_state *btrfsic_dev_state_alloc(void);\nstatic void btrfsic_dev_state_free(struct btrfsic_dev_state *ds);\nstatic void btrfsic_dev_state_hashtable_remove(struct btrfsic_dev_state *ds);\n\nstatic struct btrfsic_dev_state *btrfsic_dev_state_alloc(void)\n{\n\tstruct btrfsic_dev_state *ds;\n\n\tds = kzalloc(sizeof(*ds), GFP_NOFS);\n\tif (NULL != ds)\n\t\tbtrfsic_dev_state_init(ds);\n\n\treturn ds;\n}"
  },
  {
    "function_name": "btrfsic_dev_state_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/check-integrity.c",
    "lines": "470-481",
    "snippet": "static void btrfsic_dev_state_init(struct btrfsic_dev_state *ds)\n{\n\tds->magic_num = BTRFSIC_DEV2STATE_MAGIC_NUMBER;\n\tds->bdev = NULL;\n\tds->state = NULL;\n\tds->name[0] = '\\0';\n\tINIT_LIST_HEAD(&ds->collision_resolving_node);\n\tds->last_flush_gen = 0;\n\tbtrfsic_block_init(&ds->dummy_block_for_bio_bh_flush);\n\tds->dummy_block_for_bio_bh_flush.is_iodone = 1;\n\tds->dummy_block_for_bio_bh_flush.dev_state = ds;\n}",
    "includes": [
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"volumes.h\"",
      "#include \"extent_io.h\"",
      "#include \"transaction.h\"",
      "#include \"hash.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/genhd.h>",
      "#include <linux/mutex.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [
      "#define BTRFSIC_DEV2STATE_MAGIC_NUMBER 0x20111530"
    ],
    "globals_used": [
      "static void btrfsic_dev_state_init(struct btrfsic_dev_state *ds);",
      "static void btrfsic_dev_state_free(struct btrfsic_dev_state *ds);",
      "static void btrfsic_dev_state_hashtable_remove(struct btrfsic_dev_state *ds);",
      "static void btrfsic_dump_database(struct btrfsic_state *state);",
      "static void btrfsic_dump_tree(const struct btrfsic_state *state);",
      "static struct btrfsic_dev_state *btrfsic_dev_state_lookup(\n\t\tstruct block_device *bdev);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfsic_block_init",
          "args": [
            "&ds->dummy_block_for_bio_bh_flush"
          ],
          "line": 478
        },
        "resolved": true,
        "details": {
          "function_name": "btrfsic_block_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/check-integrity.c",
          "lines": "398-423",
          "snippet": "static void btrfsic_block_init(struct btrfsic_block *b)\n{\n\tb->magic_num = BTRFSIC_BLOCK_MAGIC_NUMBER;\n\tb->dev_state = NULL;\n\tb->dev_bytenr = 0;\n\tb->logical_bytenr = 0;\n\tb->generation = BTRFSIC_GENERATION_UNKNOWN;\n\tb->disk_key.objectid = 0;\n\tb->disk_key.type = 0;\n\tb->disk_key.offset = 0;\n\tb->is_metadata = 0;\n\tb->is_superblock = 0;\n\tb->is_iodone = 0;\n\tb->iodone_w_error = 0;\n\tb->never_written = 0;\n\tb->mirror_num = 0;\n\tb->next_in_same_bio = NULL;\n\tb->orig_bio_bh_private = NULL;\n\tb->orig_bio_bh_end_io.bio = NULL;\n\tINIT_LIST_HEAD(&b->collision_resolving_node);\n\tINIT_LIST_HEAD(&b->all_blocks_node);\n\tINIT_LIST_HEAD(&b->ref_to_list);\n\tINIT_LIST_HEAD(&b->ref_from_list);\n\tb->submit_bio_bh_rw = 0;\n\tb->flush_gen = 0;\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"extent_io.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/genhd.h>",
            "#include <linux/mutex.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define BTRFSIC_GENERATION_UNKNOWN ((u64)-1)",
            "#define BTRFSIC_BLOCK_MAGIC_NUMBER 0x14491051"
          ],
          "globals_used": [
            "static void btrfsic_block_init(struct btrfsic_block *b);",
            "static void btrfsic_block_free(struct btrfsic_block *b);",
            "static void btrfsic_block_hashtable_remove(struct btrfsic_block *b);",
            "static int btrfsic_map_block(struct btrfsic_state *state, u64 bytenr, u32 len,\n\t\t\t     struct btrfsic_block_data_ctx *block_ctx_out,\n\t\t\t     int mirror_num);",
            "static void btrfsic_process_written_block(struct btrfsic_dev_state *dev_state,\n\t\t\t\t\t  u64 dev_bytenr, char **mapped_datav,\n\t\t\t\t\t  unsigned int num_pages,\n\t\t\t\t\t  struct bio *bio, int *bio_is_patched,\n\t\t\t\t\t  struct buffer_head *bh,\n\t\t\t\t\t  int submit_bio_bh_rw);",
            "static void btrfsic_cmp_log_and_dev_bytenr(struct btrfsic_state *state,\n\t\t\t\t\t   u64 bytenr,\n\t\t\t\t\t   struct btrfsic_dev_state *dev_state,\n\t\t\t\t\t   u64 dev_bytenr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"extent_io.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n#include <linux/blkdev.h>\n#include <linux/genhd.h>\n#include <linux/mutex.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\n#define BTRFSIC_GENERATION_UNKNOWN ((u64)-1)\n#define BTRFSIC_BLOCK_MAGIC_NUMBER 0x14491051\n\nstatic void btrfsic_block_init(struct btrfsic_block *b);\nstatic void btrfsic_block_free(struct btrfsic_block *b);\nstatic void btrfsic_block_hashtable_remove(struct btrfsic_block *b);\nstatic int btrfsic_map_block(struct btrfsic_state *state, u64 bytenr, u32 len,\n\t\t\t     struct btrfsic_block_data_ctx *block_ctx_out,\n\t\t\t     int mirror_num);\nstatic void btrfsic_process_written_block(struct btrfsic_dev_state *dev_state,\n\t\t\t\t\t  u64 dev_bytenr, char **mapped_datav,\n\t\t\t\t\t  unsigned int num_pages,\n\t\t\t\t\t  struct bio *bio, int *bio_is_patched,\n\t\t\t\t\t  struct buffer_head *bh,\n\t\t\t\t\t  int submit_bio_bh_rw);\nstatic void btrfsic_cmp_log_and_dev_bytenr(struct btrfsic_state *state,\n\t\t\t\t\t   u64 bytenr,\n\t\t\t\t\t   struct btrfsic_dev_state *dev_state,\n\t\t\t\t\t   u64 dev_bytenr);\n\nstatic void btrfsic_block_init(struct btrfsic_block *b)\n{\n\tb->magic_num = BTRFSIC_BLOCK_MAGIC_NUMBER;\n\tb->dev_state = NULL;\n\tb->dev_bytenr = 0;\n\tb->logical_bytenr = 0;\n\tb->generation = BTRFSIC_GENERATION_UNKNOWN;\n\tb->disk_key.objectid = 0;\n\tb->disk_key.type = 0;\n\tb->disk_key.offset = 0;\n\tb->is_metadata = 0;\n\tb->is_superblock = 0;\n\tb->is_iodone = 0;\n\tb->iodone_w_error = 0;\n\tb->never_written = 0;\n\tb->mirror_num = 0;\n\tb->next_in_same_bio = NULL;\n\tb->orig_bio_bh_private = NULL;\n\tb->orig_bio_bh_end_io.bio = NULL;\n\tINIT_LIST_HEAD(&b->collision_resolving_node);\n\tINIT_LIST_HEAD(&b->all_blocks_node);\n\tINIT_LIST_HEAD(&b->ref_to_list);\n\tINIT_LIST_HEAD(&b->ref_from_list);\n\tb->submit_bio_bh_rw = 0;\n\tb->flush_gen = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&ds->collision_resolving_node"
          ],
          "line": 476
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"extent_io.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n#include <linux/blkdev.h>\n#include <linux/genhd.h>\n#include <linux/mutex.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\n#define BTRFSIC_DEV2STATE_MAGIC_NUMBER 0x20111530\n\nstatic void btrfsic_dev_state_init(struct btrfsic_dev_state *ds);\nstatic void btrfsic_dev_state_free(struct btrfsic_dev_state *ds);\nstatic void btrfsic_dev_state_hashtable_remove(struct btrfsic_dev_state *ds);\nstatic void btrfsic_dump_database(struct btrfsic_state *state);\nstatic void btrfsic_dump_tree(const struct btrfsic_state *state);\nstatic struct btrfsic_dev_state *btrfsic_dev_state_lookup(\n\t\tstruct block_device *bdev);\n\nstatic void btrfsic_dev_state_init(struct btrfsic_dev_state *ds)\n{\n\tds->magic_num = BTRFSIC_DEV2STATE_MAGIC_NUMBER;\n\tds->bdev = NULL;\n\tds->state = NULL;\n\tds->name[0] = '\\0';\n\tINIT_LIST_HEAD(&ds->collision_resolving_node);\n\tds->last_flush_gen = 0;\n\tbtrfsic_block_init(&ds->dummy_block_for_bio_bh_flush);\n\tds->dummy_block_for_bio_bh_flush.is_iodone = 1;\n\tds->dummy_block_for_bio_bh_flush.dev_state = ds;\n}"
  },
  {
    "function_name": "btrfsic_block_link_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/check-integrity.c",
    "lines": "464-468",
    "snippet": "static void btrfsic_block_link_free(struct btrfsic_block_link *l)\n{\n\tBUG_ON(!(NULL == l || BTRFSIC_BLOCK_LINK_MAGIC_NUMBER == l->magic_num));\n\tkfree(l);\n}",
    "includes": [
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"volumes.h\"",
      "#include \"extent_io.h\"",
      "#include \"transaction.h\"",
      "#include \"hash.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/genhd.h>",
      "#include <linux/mutex.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [
      "#define BTRFSIC_BLOCK_LINK_MAGIC_NUMBER 0x11070807"
    ],
    "globals_used": [
      "static void btrfsic_block_link_hashtable_remove(struct btrfsic_block_link *l);",
      "static void btrfsic_print_add_link(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block_link *l);",
      "static void btrfsic_print_rem_link(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block_link *l);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "l"
          ],
          "line": 467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!(NULL == l || BTRFSIC_BLOCK_LINK_MAGIC_NUMBER == l->magic_num)"
          ],
          "line": 466
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"extent_io.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n#include <linux/blkdev.h>\n#include <linux/genhd.h>\n#include <linux/mutex.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\n#define BTRFSIC_BLOCK_LINK_MAGIC_NUMBER 0x11070807\n\nstatic void btrfsic_block_link_hashtable_remove(struct btrfsic_block_link *l);\nstatic void btrfsic_print_add_link(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block_link *l);\nstatic void btrfsic_print_rem_link(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block_link *l);\n\nstatic void btrfsic_block_link_free(struct btrfsic_block_link *l)\n{\n\tBUG_ON(!(NULL == l || BTRFSIC_BLOCK_LINK_MAGIC_NUMBER == l->magic_num));\n\tkfree(l);\n}"
  },
  {
    "function_name": "btrfsic_block_link_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/check-integrity.c",
    "lines": "453-462",
    "snippet": "static struct btrfsic_block_link *btrfsic_block_link_alloc(void)\n{\n\tstruct btrfsic_block_link *l;\n\n\tl = kzalloc(sizeof(*l), GFP_NOFS);\n\tif (NULL != l)\n\t\tbtrfsic_block_link_init(l);\n\n\treturn l;\n}",
    "includes": [
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"volumes.h\"",
      "#include \"extent_io.h\"",
      "#include \"transaction.h\"",
      "#include \"hash.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/genhd.h>",
      "#include <linux/mutex.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct btrfsic_block_link *btrfsic_block_link_alloc(void);",
      "static void btrfsic_block_link_hashtable_remove(struct btrfsic_block_link *l);",
      "static void btrfsic_print_add_link(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block_link *l);",
      "static void btrfsic_print_rem_link(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block_link *l);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfsic_block_link_init",
          "args": [
            "l"
          ],
          "line": 459
        },
        "resolved": true,
        "details": {
          "function_name": "btrfsic_block_link_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/check-integrity.c",
          "lines": "442-451",
          "snippet": "static void btrfsic_block_link_init(struct btrfsic_block_link *l)\n{\n\tl->magic_num = BTRFSIC_BLOCK_LINK_MAGIC_NUMBER;\n\tl->ref_cnt = 1;\n\tINIT_LIST_HEAD(&l->node_ref_to);\n\tINIT_LIST_HEAD(&l->node_ref_from);\n\tINIT_LIST_HEAD(&l->collision_resolving_node);\n\tl->block_ref_to = NULL;\n\tl->block_ref_from = NULL;\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"extent_io.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/genhd.h>",
            "#include <linux/mutex.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define BTRFSIC_BLOCK_LINK_MAGIC_NUMBER 0x11070807"
          ],
          "globals_used": [
            "static void btrfsic_block_link_hashtable_remove(struct btrfsic_block_link *l);",
            "static void btrfsic_print_add_link(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block_link *l);",
            "static void btrfsic_print_rem_link(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block_link *l);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"extent_io.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n#include <linux/blkdev.h>\n#include <linux/genhd.h>\n#include <linux/mutex.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\n#define BTRFSIC_BLOCK_LINK_MAGIC_NUMBER 0x11070807\n\nstatic void btrfsic_block_link_hashtable_remove(struct btrfsic_block_link *l);\nstatic void btrfsic_print_add_link(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block_link *l);\nstatic void btrfsic_print_rem_link(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block_link *l);\n\nstatic void btrfsic_block_link_init(struct btrfsic_block_link *l)\n{\n\tl->magic_num = BTRFSIC_BLOCK_LINK_MAGIC_NUMBER;\n\tl->ref_cnt = 1;\n\tINIT_LIST_HEAD(&l->node_ref_to);\n\tINIT_LIST_HEAD(&l->node_ref_from);\n\tINIT_LIST_HEAD(&l->collision_resolving_node);\n\tl->block_ref_to = NULL;\n\tl->block_ref_from = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*l)",
            "GFP_NOFS"
          ],
          "line": 457
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"extent_io.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n#include <linux/blkdev.h>\n#include <linux/genhd.h>\n#include <linux/mutex.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct btrfsic_block_link *btrfsic_block_link_alloc(void);\nstatic void btrfsic_block_link_hashtable_remove(struct btrfsic_block_link *l);\nstatic void btrfsic_print_add_link(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block_link *l);\nstatic void btrfsic_print_rem_link(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block_link *l);\n\nstatic struct btrfsic_block_link *btrfsic_block_link_alloc(void)\n{\n\tstruct btrfsic_block_link *l;\n\n\tl = kzalloc(sizeof(*l), GFP_NOFS);\n\tif (NULL != l)\n\t\tbtrfsic_block_link_init(l);\n\n\treturn l;\n}"
  },
  {
    "function_name": "btrfsic_block_link_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/check-integrity.c",
    "lines": "442-451",
    "snippet": "static void btrfsic_block_link_init(struct btrfsic_block_link *l)\n{\n\tl->magic_num = BTRFSIC_BLOCK_LINK_MAGIC_NUMBER;\n\tl->ref_cnt = 1;\n\tINIT_LIST_HEAD(&l->node_ref_to);\n\tINIT_LIST_HEAD(&l->node_ref_from);\n\tINIT_LIST_HEAD(&l->collision_resolving_node);\n\tl->block_ref_to = NULL;\n\tl->block_ref_from = NULL;\n}",
    "includes": [
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"volumes.h\"",
      "#include \"extent_io.h\"",
      "#include \"transaction.h\"",
      "#include \"hash.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/genhd.h>",
      "#include <linux/mutex.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [
      "#define BTRFSIC_BLOCK_LINK_MAGIC_NUMBER 0x11070807"
    ],
    "globals_used": [
      "static void btrfsic_block_link_hashtable_remove(struct btrfsic_block_link *l);",
      "static void btrfsic_print_add_link(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block_link *l);",
      "static void btrfsic_print_rem_link(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block_link *l);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&l->collision_resolving_node"
          ],
          "line": 448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&l->node_ref_from"
          ],
          "line": 447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&l->node_ref_to"
          ],
          "line": 446
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"extent_io.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n#include <linux/blkdev.h>\n#include <linux/genhd.h>\n#include <linux/mutex.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\n#define BTRFSIC_BLOCK_LINK_MAGIC_NUMBER 0x11070807\n\nstatic void btrfsic_block_link_hashtable_remove(struct btrfsic_block_link *l);\nstatic void btrfsic_print_add_link(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block_link *l);\nstatic void btrfsic_print_rem_link(const struct btrfsic_state *state,\n\t\t\t\t   const struct btrfsic_block_link *l);\n\nstatic void btrfsic_block_link_init(struct btrfsic_block_link *l)\n{\n\tl->magic_num = BTRFSIC_BLOCK_LINK_MAGIC_NUMBER;\n\tl->ref_cnt = 1;\n\tINIT_LIST_HEAD(&l->node_ref_to);\n\tINIT_LIST_HEAD(&l->node_ref_from);\n\tINIT_LIST_HEAD(&l->collision_resolving_node);\n\tl->block_ref_to = NULL;\n\tl->block_ref_from = NULL;\n}"
  },
  {
    "function_name": "btrfsic_block_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/check-integrity.c",
    "lines": "436-440",
    "snippet": "static void btrfsic_block_free(struct btrfsic_block *b)\n{\n\tBUG_ON(!(NULL == b || BTRFSIC_BLOCK_MAGIC_NUMBER == b->magic_num));\n\tkfree(b);\n}",
    "includes": [
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"volumes.h\"",
      "#include \"extent_io.h\"",
      "#include \"transaction.h\"",
      "#include \"hash.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/genhd.h>",
      "#include <linux/mutex.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [
      "#define BTRFSIC_BLOCK_MAGIC_NUMBER 0x14491051"
    ],
    "globals_used": [
      "static void btrfsic_block_init(struct btrfsic_block *b);",
      "static void btrfsic_block_free(struct btrfsic_block *b);",
      "static void btrfsic_block_hashtable_remove(struct btrfsic_block *b);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "b"
          ],
          "line": 439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!(NULL == b || BTRFSIC_BLOCK_MAGIC_NUMBER == b->magic_num)"
          ],
          "line": 438
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"extent_io.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n#include <linux/blkdev.h>\n#include <linux/genhd.h>\n#include <linux/mutex.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\n#define BTRFSIC_BLOCK_MAGIC_NUMBER 0x14491051\n\nstatic void btrfsic_block_init(struct btrfsic_block *b);\nstatic void btrfsic_block_free(struct btrfsic_block *b);\nstatic void btrfsic_block_hashtable_remove(struct btrfsic_block *b);\n\nstatic void btrfsic_block_free(struct btrfsic_block *b)\n{\n\tBUG_ON(!(NULL == b || BTRFSIC_BLOCK_MAGIC_NUMBER == b->magic_num));\n\tkfree(b);\n}"
  },
  {
    "function_name": "btrfsic_block_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/check-integrity.c",
    "lines": "425-434",
    "snippet": "static struct btrfsic_block *btrfsic_block_alloc(void)\n{\n\tstruct btrfsic_block *b;\n\n\tb = kzalloc(sizeof(*b), GFP_NOFS);\n\tif (NULL != b)\n\t\tbtrfsic_block_init(b);\n\n\treturn b;\n}",
    "includes": [
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"volumes.h\"",
      "#include \"extent_io.h\"",
      "#include \"transaction.h\"",
      "#include \"hash.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/genhd.h>",
      "#include <linux/mutex.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void btrfsic_block_init(struct btrfsic_block *b);",
      "static struct btrfsic_block *btrfsic_block_alloc(void);",
      "static void btrfsic_block_free(struct btrfsic_block *b);",
      "static void btrfsic_block_hashtable_remove(struct btrfsic_block *b);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfsic_block_init",
          "args": [
            "b"
          ],
          "line": 431
        },
        "resolved": true,
        "details": {
          "function_name": "btrfsic_block_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/check-integrity.c",
          "lines": "398-423",
          "snippet": "static void btrfsic_block_init(struct btrfsic_block *b)\n{\n\tb->magic_num = BTRFSIC_BLOCK_MAGIC_NUMBER;\n\tb->dev_state = NULL;\n\tb->dev_bytenr = 0;\n\tb->logical_bytenr = 0;\n\tb->generation = BTRFSIC_GENERATION_UNKNOWN;\n\tb->disk_key.objectid = 0;\n\tb->disk_key.type = 0;\n\tb->disk_key.offset = 0;\n\tb->is_metadata = 0;\n\tb->is_superblock = 0;\n\tb->is_iodone = 0;\n\tb->iodone_w_error = 0;\n\tb->never_written = 0;\n\tb->mirror_num = 0;\n\tb->next_in_same_bio = NULL;\n\tb->orig_bio_bh_private = NULL;\n\tb->orig_bio_bh_end_io.bio = NULL;\n\tINIT_LIST_HEAD(&b->collision_resolving_node);\n\tINIT_LIST_HEAD(&b->all_blocks_node);\n\tINIT_LIST_HEAD(&b->ref_to_list);\n\tINIT_LIST_HEAD(&b->ref_from_list);\n\tb->submit_bio_bh_rw = 0;\n\tb->flush_gen = 0;\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"extent_io.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/genhd.h>",
            "#include <linux/mutex.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define BTRFSIC_GENERATION_UNKNOWN ((u64)-1)",
            "#define BTRFSIC_BLOCK_MAGIC_NUMBER 0x14491051"
          ],
          "globals_used": [
            "static void btrfsic_block_init(struct btrfsic_block *b);",
            "static void btrfsic_block_free(struct btrfsic_block *b);",
            "static void btrfsic_block_hashtable_remove(struct btrfsic_block *b);",
            "static int btrfsic_map_block(struct btrfsic_state *state, u64 bytenr, u32 len,\n\t\t\t     struct btrfsic_block_data_ctx *block_ctx_out,\n\t\t\t     int mirror_num);",
            "static void btrfsic_process_written_block(struct btrfsic_dev_state *dev_state,\n\t\t\t\t\t  u64 dev_bytenr, char **mapped_datav,\n\t\t\t\t\t  unsigned int num_pages,\n\t\t\t\t\t  struct bio *bio, int *bio_is_patched,\n\t\t\t\t\t  struct buffer_head *bh,\n\t\t\t\t\t  int submit_bio_bh_rw);",
            "static void btrfsic_cmp_log_and_dev_bytenr(struct btrfsic_state *state,\n\t\t\t\t\t   u64 bytenr,\n\t\t\t\t\t   struct btrfsic_dev_state *dev_state,\n\t\t\t\t\t   u64 dev_bytenr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"extent_io.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n#include <linux/blkdev.h>\n#include <linux/genhd.h>\n#include <linux/mutex.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\n#define BTRFSIC_GENERATION_UNKNOWN ((u64)-1)\n#define BTRFSIC_BLOCK_MAGIC_NUMBER 0x14491051\n\nstatic void btrfsic_block_init(struct btrfsic_block *b);\nstatic void btrfsic_block_free(struct btrfsic_block *b);\nstatic void btrfsic_block_hashtable_remove(struct btrfsic_block *b);\nstatic int btrfsic_map_block(struct btrfsic_state *state, u64 bytenr, u32 len,\n\t\t\t     struct btrfsic_block_data_ctx *block_ctx_out,\n\t\t\t     int mirror_num);\nstatic void btrfsic_process_written_block(struct btrfsic_dev_state *dev_state,\n\t\t\t\t\t  u64 dev_bytenr, char **mapped_datav,\n\t\t\t\t\t  unsigned int num_pages,\n\t\t\t\t\t  struct bio *bio, int *bio_is_patched,\n\t\t\t\t\t  struct buffer_head *bh,\n\t\t\t\t\t  int submit_bio_bh_rw);\nstatic void btrfsic_cmp_log_and_dev_bytenr(struct btrfsic_state *state,\n\t\t\t\t\t   u64 bytenr,\n\t\t\t\t\t   struct btrfsic_dev_state *dev_state,\n\t\t\t\t\t   u64 dev_bytenr);\n\nstatic void btrfsic_block_init(struct btrfsic_block *b)\n{\n\tb->magic_num = BTRFSIC_BLOCK_MAGIC_NUMBER;\n\tb->dev_state = NULL;\n\tb->dev_bytenr = 0;\n\tb->logical_bytenr = 0;\n\tb->generation = BTRFSIC_GENERATION_UNKNOWN;\n\tb->disk_key.objectid = 0;\n\tb->disk_key.type = 0;\n\tb->disk_key.offset = 0;\n\tb->is_metadata = 0;\n\tb->is_superblock = 0;\n\tb->is_iodone = 0;\n\tb->iodone_w_error = 0;\n\tb->never_written = 0;\n\tb->mirror_num = 0;\n\tb->next_in_same_bio = NULL;\n\tb->orig_bio_bh_private = NULL;\n\tb->orig_bio_bh_end_io.bio = NULL;\n\tINIT_LIST_HEAD(&b->collision_resolving_node);\n\tINIT_LIST_HEAD(&b->all_blocks_node);\n\tINIT_LIST_HEAD(&b->ref_to_list);\n\tINIT_LIST_HEAD(&b->ref_from_list);\n\tb->submit_bio_bh_rw = 0;\n\tb->flush_gen = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*b)",
            "GFP_NOFS"
          ],
          "line": 429
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"extent_io.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n#include <linux/blkdev.h>\n#include <linux/genhd.h>\n#include <linux/mutex.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic void btrfsic_block_init(struct btrfsic_block *b);\nstatic struct btrfsic_block *btrfsic_block_alloc(void);\nstatic void btrfsic_block_free(struct btrfsic_block *b);\nstatic void btrfsic_block_hashtable_remove(struct btrfsic_block *b);\n\nstatic struct btrfsic_block *btrfsic_block_alloc(void)\n{\n\tstruct btrfsic_block *b;\n\n\tb = kzalloc(sizeof(*b), GFP_NOFS);\n\tif (NULL != b)\n\t\tbtrfsic_block_init(b);\n\n\treturn b;\n}"
  },
  {
    "function_name": "btrfsic_block_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/check-integrity.c",
    "lines": "398-423",
    "snippet": "static void btrfsic_block_init(struct btrfsic_block *b)\n{\n\tb->magic_num = BTRFSIC_BLOCK_MAGIC_NUMBER;\n\tb->dev_state = NULL;\n\tb->dev_bytenr = 0;\n\tb->logical_bytenr = 0;\n\tb->generation = BTRFSIC_GENERATION_UNKNOWN;\n\tb->disk_key.objectid = 0;\n\tb->disk_key.type = 0;\n\tb->disk_key.offset = 0;\n\tb->is_metadata = 0;\n\tb->is_superblock = 0;\n\tb->is_iodone = 0;\n\tb->iodone_w_error = 0;\n\tb->never_written = 0;\n\tb->mirror_num = 0;\n\tb->next_in_same_bio = NULL;\n\tb->orig_bio_bh_private = NULL;\n\tb->orig_bio_bh_end_io.bio = NULL;\n\tINIT_LIST_HEAD(&b->collision_resolving_node);\n\tINIT_LIST_HEAD(&b->all_blocks_node);\n\tINIT_LIST_HEAD(&b->ref_to_list);\n\tINIT_LIST_HEAD(&b->ref_from_list);\n\tb->submit_bio_bh_rw = 0;\n\tb->flush_gen = 0;\n}",
    "includes": [
      "#include \"rcu-string.h\"",
      "#include \"check-integrity.h\"",
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"volumes.h\"",
      "#include \"extent_io.h\"",
      "#include \"transaction.h\"",
      "#include \"hash.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/genhd.h>",
      "#include <linux/mutex.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [
      "#define BTRFSIC_GENERATION_UNKNOWN ((u64)-1)",
      "#define BTRFSIC_BLOCK_MAGIC_NUMBER 0x14491051"
    ],
    "globals_used": [
      "static void btrfsic_block_init(struct btrfsic_block *b);",
      "static void btrfsic_block_free(struct btrfsic_block *b);",
      "static void btrfsic_block_hashtable_remove(struct btrfsic_block *b);",
      "static int btrfsic_map_block(struct btrfsic_state *state, u64 bytenr, u32 len,\n\t\t\t     struct btrfsic_block_data_ctx *block_ctx_out,\n\t\t\t     int mirror_num);",
      "static void btrfsic_process_written_block(struct btrfsic_dev_state *dev_state,\n\t\t\t\t\t  u64 dev_bytenr, char **mapped_datav,\n\t\t\t\t\t  unsigned int num_pages,\n\t\t\t\t\t  struct bio *bio, int *bio_is_patched,\n\t\t\t\t\t  struct buffer_head *bh,\n\t\t\t\t\t  int submit_bio_bh_rw);",
      "static void btrfsic_cmp_log_and_dev_bytenr(struct btrfsic_state *state,\n\t\t\t\t\t   u64 bytenr,\n\t\t\t\t\t   struct btrfsic_dev_state *dev_state,\n\t\t\t\t\t   u64 dev_bytenr);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&b->ref_from_list"
          ],
          "line": 420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&b->ref_to_list"
          ],
          "line": 419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&b->all_blocks_node"
          ],
          "line": 418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&b->collision_resolving_node"
          ],
          "line": 417
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"extent_io.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n#include <linux/blkdev.h>\n#include <linux/genhd.h>\n#include <linux/mutex.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\n#define BTRFSIC_GENERATION_UNKNOWN ((u64)-1)\n#define BTRFSIC_BLOCK_MAGIC_NUMBER 0x14491051\n\nstatic void btrfsic_block_init(struct btrfsic_block *b);\nstatic void btrfsic_block_free(struct btrfsic_block *b);\nstatic void btrfsic_block_hashtable_remove(struct btrfsic_block *b);\nstatic int btrfsic_map_block(struct btrfsic_state *state, u64 bytenr, u32 len,\n\t\t\t     struct btrfsic_block_data_ctx *block_ctx_out,\n\t\t\t     int mirror_num);\nstatic void btrfsic_process_written_block(struct btrfsic_dev_state *dev_state,\n\t\t\t\t\t  u64 dev_bytenr, char **mapped_datav,\n\t\t\t\t\t  unsigned int num_pages,\n\t\t\t\t\t  struct bio *bio, int *bio_is_patched,\n\t\t\t\t\t  struct buffer_head *bh,\n\t\t\t\t\t  int submit_bio_bh_rw);\nstatic void btrfsic_cmp_log_and_dev_bytenr(struct btrfsic_state *state,\n\t\t\t\t\t   u64 bytenr,\n\t\t\t\t\t   struct btrfsic_dev_state *dev_state,\n\t\t\t\t\t   u64 dev_bytenr);\n\nstatic void btrfsic_block_init(struct btrfsic_block *b)\n{\n\tb->magic_num = BTRFSIC_BLOCK_MAGIC_NUMBER;\n\tb->dev_state = NULL;\n\tb->dev_bytenr = 0;\n\tb->logical_bytenr = 0;\n\tb->generation = BTRFSIC_GENERATION_UNKNOWN;\n\tb->disk_key.objectid = 0;\n\tb->disk_key.type = 0;\n\tb->disk_key.offset = 0;\n\tb->is_metadata = 0;\n\tb->is_superblock = 0;\n\tb->is_iodone = 0;\n\tb->iodone_w_error = 0;\n\tb->never_written = 0;\n\tb->mirror_num = 0;\n\tb->next_in_same_bio = NULL;\n\tb->orig_bio_bh_private = NULL;\n\tb->orig_bio_bh_end_io.bio = NULL;\n\tINIT_LIST_HEAD(&b->collision_resolving_node);\n\tINIT_LIST_HEAD(&b->all_blocks_node);\n\tINIT_LIST_HEAD(&b->ref_to_list);\n\tINIT_LIST_HEAD(&b->ref_from_list);\n\tb->submit_bio_bh_rw = 0;\n\tb->flush_gen = 0;\n}"
  }
]