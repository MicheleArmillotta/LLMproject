[
  {
    "function_name": "nfs4blocklayout_exit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/blocklayout/blocklayout.c",
    "lines": "915-922",
    "snippet": "static void __exit nfs4blocklayout_exit(void)\n{\n\tdprintk(\"%s: NFSv4 Block Layout Driver Unregistering...\\n\",\n\t       __func__);\n\n\tbl_cleanup_pipefs();\n\tpnfs_unregister_layoutdriver(&blocklayout_type);\n}",
    "includes": [
      "#include \"blocklayout.h\"",
      "#include \"../internal.h\"",
      "#include \"../nfs4session.h\"",
      "#include \"../pnfs.h\"",
      "#include <linux/pagevec.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/bio.h>\t\t/* struct bio */",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct pnfs_layoutdriver_type blocklayout_type = {\n\t.id\t\t\t\t= LAYOUT_BLOCK_VOLUME,\n\t.name\t\t\t\t= \"LAYOUT_BLOCK_VOLUME\",\n\t.owner\t\t\t\t= THIS_MODULE,\n\t.flags\t\t\t\t= PNFS_LAYOUTRET_ON_SETATTR |\n\t\t\t\t\t  PNFS_READ_WHOLE_PAGE,\n\t.read_pagelist\t\t\t= bl_read_pagelist,\n\t.write_pagelist\t\t\t= bl_write_pagelist,\n\t.alloc_layout_hdr\t\t= bl_alloc_layout_hdr,\n\t.free_layout_hdr\t\t= bl_free_layout_hdr,\n\t.alloc_lseg\t\t\t= bl_alloc_lseg,\n\t.free_lseg\t\t\t= bl_free_lseg,\n\t.return_range\t\t\t= bl_return_range,\n\t.prepare_layoutcommit\t\t= bl_prepare_layoutcommit,\n\t.cleanup_layoutcommit\t\t= bl_cleanup_layoutcommit,\n\t.set_layoutdriver\t\t= bl_set_layoutdriver,\n\t.alloc_deviceid_node\t\t= bl_alloc_deviceid_node,\n\t.free_deviceid_node\t\t= bl_free_deviceid_node,\n\t.pg_read_ops\t\t\t= &bl_pg_read_ops,\n\t.pg_write_ops\t\t\t= &bl_pg_write_ops,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pnfs_unregister_layoutdriver",
          "args": [
            "&blocklayout_type"
          ],
          "line": 921
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_unregister_layoutdriver",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
          "lines": "184-191",
          "snippet": "void\npnfs_unregister_layoutdriver(struct pnfs_layoutdriver_type *ld_type)\n{\n\tdprintk(\"%s Deregistering id:%u\\n\", __func__, ld_type->id);\n\tspin_lock(&pnfs_spinlock);\n\tlist_del(&ld_type->pnfs_tblid);\n\tspin_unlock(&pnfs_spinlock);\n}",
          "includes": [
            "#include \"delegation.h\"",
            "#include \"nfs4trace.h\"",
            "#include \"iostat.h\"",
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(pnfs_spinlock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic DEFINE_SPINLOCK(pnfs_spinlock);\n\nvoid\npnfs_unregister_layoutdriver(struct pnfs_layoutdriver_type *ld_type)\n{\n\tdprintk(\"%s Deregistering id:%u\\n\", __func__, ld_type->id);\n\tspin_lock(&pnfs_spinlock);\n\tlist_del(&ld_type->pnfs_tblid);\n\tspin_unlock(&pnfs_spinlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bl_cleanup_pipefs",
          "args": [],
          "line": 920
        },
        "resolved": true,
        "details": {
          "function_name": "bl_cleanup_pipefs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/blocklayout/rpc_pipefs.c",
          "lines": "284-288",
          "snippet": "void __exit bl_cleanup_pipefs(void)\n{\n\trpc_pipefs_notifier_unregister(&nfs4blocklayout_block);\n\tunregister_pernet_subsys(&nfs4blocklayout_net_ops);\n}",
          "includes": [
            "#include \"blocklayout.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/genhd.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct notifier_block nfs4blocklayout_block = {\n\t.notifier_call = rpc_pipefs_event,\n};",
            "static struct pernet_operations nfs4blocklayout_net_ops = {\n\t.init = nfs4blocklayout_net_init,\n\t.exit = nfs4blocklayout_net_exit,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"blocklayout.h\"\n#include <linux/blkdev.h>\n#include <linux/genhd.h>\n#include <linux/module.h>\n\nstatic struct notifier_block nfs4blocklayout_block = {\n\t.notifier_call = rpc_pipefs_event,\n};\nstatic struct pernet_operations nfs4blocklayout_net_ops = {\n\t.init = nfs4blocklayout_net_init,\n\t.exit = nfs4blocklayout_net_exit,\n};\n\nvoid __exit bl_cleanup_pipefs(void)\n{\n\trpc_pipefs_notifier_unregister(&nfs4blocklayout_block);\n\tunregister_pernet_subsys(&nfs4blocklayout_net_ops);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s: NFSv4 Block Layout Driver Unregistering...\\n\"",
            "__func__"
          ],
          "line": 917
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"blocklayout.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include \"../pnfs.h\"\n#include <linux/pagevec.h>\n#include <linux/prefetch.h>\n#include <linux/bio.h>\t\t/* struct bio */\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic struct pnfs_layoutdriver_type blocklayout_type = {\n\t.id\t\t\t\t= LAYOUT_BLOCK_VOLUME,\n\t.name\t\t\t\t= \"LAYOUT_BLOCK_VOLUME\",\n\t.owner\t\t\t\t= THIS_MODULE,\n\t.flags\t\t\t\t= PNFS_LAYOUTRET_ON_SETATTR |\n\t\t\t\t\t  PNFS_READ_WHOLE_PAGE,\n\t.read_pagelist\t\t\t= bl_read_pagelist,\n\t.write_pagelist\t\t\t= bl_write_pagelist,\n\t.alloc_layout_hdr\t\t= bl_alloc_layout_hdr,\n\t.free_layout_hdr\t\t= bl_free_layout_hdr,\n\t.alloc_lseg\t\t\t= bl_alloc_lseg,\n\t.free_lseg\t\t\t= bl_free_lseg,\n\t.return_range\t\t\t= bl_return_range,\n\t.prepare_layoutcommit\t\t= bl_prepare_layoutcommit,\n\t.cleanup_layoutcommit\t\t= bl_cleanup_layoutcommit,\n\t.set_layoutdriver\t\t= bl_set_layoutdriver,\n\t.alloc_deviceid_node\t\t= bl_alloc_deviceid_node,\n\t.free_deviceid_node\t\t= bl_free_deviceid_node,\n\t.pg_read_ops\t\t\t= &bl_pg_read_ops,\n\t.pg_write_ops\t\t\t= &bl_pg_write_ops,\n};\n\nstatic void __exit nfs4blocklayout_exit(void)\n{\n\tdprintk(\"%s: NFSv4 Block Layout Driver Unregistering...\\n\",\n\t       __func__);\n\n\tbl_cleanup_pipefs();\n\tpnfs_unregister_layoutdriver(&blocklayout_type);\n}"
  },
  {
    "function_name": "nfs4blocklayout_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/blocklayout/blocklayout.c",
    "lines": "895-913",
    "snippet": "static int __init nfs4blocklayout_init(void)\n{\n\tint ret;\n\n\tdprintk(\"%s: NFSv4 Block Layout Driver Registering...\\n\", __func__);\n\n\tret = pnfs_register_layoutdriver(&blocklayout_type);\n\tif (ret)\n\t\tgoto out;\n\tret = bl_init_pipefs();\n\tif (ret)\n\t\tgoto out_unregister;\n\treturn 0;\n\nout_unregister:\n\tpnfs_unregister_layoutdriver(&blocklayout_type);\nout:\n\treturn ret;\n}",
    "includes": [
      "#include \"blocklayout.h\"",
      "#include \"../internal.h\"",
      "#include \"../nfs4session.h\"",
      "#include \"../pnfs.h\"",
      "#include <linux/pagevec.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/bio.h>\t\t/* struct bio */",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct pnfs_layoutdriver_type blocklayout_type = {\n\t.id\t\t\t\t= LAYOUT_BLOCK_VOLUME,\n\t.name\t\t\t\t= \"LAYOUT_BLOCK_VOLUME\",\n\t.owner\t\t\t\t= THIS_MODULE,\n\t.flags\t\t\t\t= PNFS_LAYOUTRET_ON_SETATTR |\n\t\t\t\t\t  PNFS_READ_WHOLE_PAGE,\n\t.read_pagelist\t\t\t= bl_read_pagelist,\n\t.write_pagelist\t\t\t= bl_write_pagelist,\n\t.alloc_layout_hdr\t\t= bl_alloc_layout_hdr,\n\t.free_layout_hdr\t\t= bl_free_layout_hdr,\n\t.alloc_lseg\t\t\t= bl_alloc_lseg,\n\t.free_lseg\t\t\t= bl_free_lseg,\n\t.return_range\t\t\t= bl_return_range,\n\t.prepare_layoutcommit\t\t= bl_prepare_layoutcommit,\n\t.cleanup_layoutcommit\t\t= bl_cleanup_layoutcommit,\n\t.set_layoutdriver\t\t= bl_set_layoutdriver,\n\t.alloc_deviceid_node\t\t= bl_alloc_deviceid_node,\n\t.free_deviceid_node\t\t= bl_free_deviceid_node,\n\t.pg_read_ops\t\t\t= &bl_pg_read_ops,\n\t.pg_write_ops\t\t\t= &bl_pg_write_ops,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pnfs_unregister_layoutdriver",
          "args": [
            "&blocklayout_type"
          ],
          "line": 910
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_unregister_layoutdriver",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
          "lines": "184-191",
          "snippet": "void\npnfs_unregister_layoutdriver(struct pnfs_layoutdriver_type *ld_type)\n{\n\tdprintk(\"%s Deregistering id:%u\\n\", __func__, ld_type->id);\n\tspin_lock(&pnfs_spinlock);\n\tlist_del(&ld_type->pnfs_tblid);\n\tspin_unlock(&pnfs_spinlock);\n}",
          "includes": [
            "#include \"delegation.h\"",
            "#include \"nfs4trace.h\"",
            "#include \"iostat.h\"",
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(pnfs_spinlock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic DEFINE_SPINLOCK(pnfs_spinlock);\n\nvoid\npnfs_unregister_layoutdriver(struct pnfs_layoutdriver_type *ld_type)\n{\n\tdprintk(\"%s Deregistering id:%u\\n\", __func__, ld_type->id);\n\tspin_lock(&pnfs_spinlock);\n\tlist_del(&ld_type->pnfs_tblid);\n\tspin_unlock(&pnfs_spinlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bl_init_pipefs",
          "args": [],
          "line": 904
        },
        "resolved": true,
        "details": {
          "function_name": "bl_init_pipefs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/blocklayout/rpc_pipefs.c",
          "lines": "266-282",
          "snippet": "int __init bl_init_pipefs(void)\n{\n\tint ret;\n\n\tret = rpc_pipefs_notifier_register(&nfs4blocklayout_block);\n\tif (ret)\n\t\tgoto out;\n\tret = register_pernet_subsys(&nfs4blocklayout_net_ops);\n\tif (ret)\n\t\tgoto out_unregister_notifier;\n\treturn 0;\n\nout_unregister_notifier:\n\trpc_pipefs_notifier_unregister(&nfs4blocklayout_block);\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"blocklayout.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/genhd.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct notifier_block nfs4blocklayout_block = {\n\t.notifier_call = rpc_pipefs_event,\n};",
            "static struct pernet_operations nfs4blocklayout_net_ops = {\n\t.init = nfs4blocklayout_net_init,\n\t.exit = nfs4blocklayout_net_exit,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"blocklayout.h\"\n#include <linux/blkdev.h>\n#include <linux/genhd.h>\n#include <linux/module.h>\n\nstatic struct notifier_block nfs4blocklayout_block = {\n\t.notifier_call = rpc_pipefs_event,\n};\nstatic struct pernet_operations nfs4blocklayout_net_ops = {\n\t.init = nfs4blocklayout_net_init,\n\t.exit = nfs4blocklayout_net_exit,\n};\n\nint __init bl_init_pipefs(void)\n{\n\tint ret;\n\n\tret = rpc_pipefs_notifier_register(&nfs4blocklayout_block);\n\tif (ret)\n\t\tgoto out;\n\tret = register_pernet_subsys(&nfs4blocklayout_net_ops);\n\tif (ret)\n\t\tgoto out_unregister_notifier;\n\treturn 0;\n\nout_unregister_notifier:\n\trpc_pipefs_notifier_unregister(&nfs4blocklayout_block);\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pnfs_register_layoutdriver",
          "args": [
            "&blocklayout_type"
          ],
          "line": 901
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_register_layoutdriver",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
          "lines": "151-181",
          "snippet": "int\npnfs_register_layoutdriver(struct pnfs_layoutdriver_type *ld_type)\n{\n\tint status = -EINVAL;\n\tstruct pnfs_layoutdriver_type *tmp;\n\n\tif (ld_type->id == 0) {\n\t\tprintk(KERN_ERR \"NFS: %s id 0 is reserved\\n\", __func__);\n\t\treturn status;\n\t}\n\tif (!ld_type->alloc_lseg || !ld_type->free_lseg) {\n\t\tprintk(KERN_ERR \"NFS: %s Layout driver must provide \"\n\t\t       \"alloc_lseg and free_lseg.\\n\", __func__);\n\t\treturn status;\n\t}\n\n\tspin_lock(&pnfs_spinlock);\n\ttmp = find_pnfs_driver_locked(ld_type->id);\n\tif (!tmp) {\n\t\tlist_add(&ld_type->pnfs_tblid, &pnfs_modules_tbl);\n\t\tstatus = 0;\n\t\tdprintk(\"%s Registering id:%u name:%s\\n\", __func__, ld_type->id,\n\t\t\tld_type->name);\n\t} else {\n\t\tprintk(KERN_ERR \"NFS: %s Module with id %d already loaded!\\n\",\n\t\t\t__func__, ld_type->id);\n\t}\n\tspin_unlock(&pnfs_spinlock);\n\n\treturn status;\n}",
          "includes": [
            "#include \"delegation.h\"",
            "#include \"nfs4trace.h\"",
            "#include \"iostat.h\"",
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(pnfs_spinlock);",
            "static LIST_HEAD(pnfs_modules_tbl);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic DEFINE_SPINLOCK(pnfs_spinlock);\nstatic LIST_HEAD(pnfs_modules_tbl);\n\nint\npnfs_register_layoutdriver(struct pnfs_layoutdriver_type *ld_type)\n{\n\tint status = -EINVAL;\n\tstruct pnfs_layoutdriver_type *tmp;\n\n\tif (ld_type->id == 0) {\n\t\tprintk(KERN_ERR \"NFS: %s id 0 is reserved\\n\", __func__);\n\t\treturn status;\n\t}\n\tif (!ld_type->alloc_lseg || !ld_type->free_lseg) {\n\t\tprintk(KERN_ERR \"NFS: %s Layout driver must provide \"\n\t\t       \"alloc_lseg and free_lseg.\\n\", __func__);\n\t\treturn status;\n\t}\n\n\tspin_lock(&pnfs_spinlock);\n\ttmp = find_pnfs_driver_locked(ld_type->id);\n\tif (!tmp) {\n\t\tlist_add(&ld_type->pnfs_tblid, &pnfs_modules_tbl);\n\t\tstatus = 0;\n\t\tdprintk(\"%s Registering id:%u name:%s\\n\", __func__, ld_type->id,\n\t\t\tld_type->name);\n\t} else {\n\t\tprintk(KERN_ERR \"NFS: %s Module with id %d already loaded!\\n\",\n\t\t\t__func__, ld_type->id);\n\t}\n\tspin_unlock(&pnfs_spinlock);\n\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s: NFSv4 Block Layout Driver Registering...\\n\"",
            "__func__"
          ],
          "line": 899
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"blocklayout.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include \"../pnfs.h\"\n#include <linux/pagevec.h>\n#include <linux/prefetch.h>\n#include <linux/bio.h>\t\t/* struct bio */\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic struct pnfs_layoutdriver_type blocklayout_type = {\n\t.id\t\t\t\t= LAYOUT_BLOCK_VOLUME,\n\t.name\t\t\t\t= \"LAYOUT_BLOCK_VOLUME\",\n\t.owner\t\t\t\t= THIS_MODULE,\n\t.flags\t\t\t\t= PNFS_LAYOUTRET_ON_SETATTR |\n\t\t\t\t\t  PNFS_READ_WHOLE_PAGE,\n\t.read_pagelist\t\t\t= bl_read_pagelist,\n\t.write_pagelist\t\t\t= bl_write_pagelist,\n\t.alloc_layout_hdr\t\t= bl_alloc_layout_hdr,\n\t.free_layout_hdr\t\t= bl_free_layout_hdr,\n\t.alloc_lseg\t\t\t= bl_alloc_lseg,\n\t.free_lseg\t\t\t= bl_free_lseg,\n\t.return_range\t\t\t= bl_return_range,\n\t.prepare_layoutcommit\t\t= bl_prepare_layoutcommit,\n\t.cleanup_layoutcommit\t\t= bl_cleanup_layoutcommit,\n\t.set_layoutdriver\t\t= bl_set_layoutdriver,\n\t.alloc_deviceid_node\t\t= bl_alloc_deviceid_node,\n\t.free_deviceid_node\t\t= bl_free_deviceid_node,\n\t.pg_read_ops\t\t\t= &bl_pg_read_ops,\n\t.pg_write_ops\t\t\t= &bl_pg_write_ops,\n};\n\nstatic int __init nfs4blocklayout_init(void)\n{\n\tint ret;\n\n\tdprintk(\"%s: NFSv4 Block Layout Driver Registering...\\n\", __func__);\n\n\tret = pnfs_register_layoutdriver(&blocklayout_type);\n\tif (ret)\n\t\tgoto out;\n\tret = bl_init_pipefs();\n\tif (ret)\n\t\tgoto out_unregister;\n\treturn 0;\n\nout_unregister:\n\tpnfs_unregister_layoutdriver(&blocklayout_type);\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "bl_pg_test_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/blocklayout/blocklayout.c",
    "lines": "850-857",
    "snippet": "static size_t\nbl_pg_test_write(struct nfs_pageio_descriptor *pgio, struct nfs_page *prev,\n\t\t struct nfs_page *req)\n{\n\tif (!is_aligned_req(pgio, req, PAGE_SIZE))\n\t\treturn 0;\n\treturn pnfs_generic_pg_test(pgio, prev, req);\n}",
    "includes": [
      "#include \"blocklayout.h\"",
      "#include \"../internal.h\"",
      "#include \"../nfs4session.h\"",
      "#include \"../pnfs.h\"",
      "#include <linux/pagevec.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/bio.h>\t\t/* struct bio */",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pnfs_generic_pg_test",
          "args": [
            "pgio",
            "prev",
            "req"
          ],
          "line": 856
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_generic_pg_test",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
          "lines": "1766-1811",
          "snippet": "size_t\npnfs_generic_pg_test(struct nfs_pageio_descriptor *pgio,\n\t\t     struct nfs_page *prev, struct nfs_page *req)\n{\n\tunsigned int size;\n\tu64 seg_end, req_start, seg_left;\n\n\tsize = nfs_generic_pg_test(pgio, prev, req);\n\tif (!size)\n\t\treturn 0;\n\n\t/*\n\t * 'size' contains the number of bytes left in the current page (up\n\t * to the original size asked for in @req->wb_bytes).\n\t *\n\t * Calculate how many bytes are left in the layout segment\n\t * and if there are less bytes than 'size', return that instead.\n\t *\n\t * Please also note that 'end_offset' is actually the offset of the\n\t * first byte that lies outside the pnfs_layout_range. FIXME?\n\t *\n\t */\n\tif (pgio->pg_lseg) {\n\t\tseg_end = end_offset(pgio->pg_lseg->pls_range.offset,\n\t\t\t\t     pgio->pg_lseg->pls_range.length);\n\t\treq_start = req_offset(req);\n\t\tWARN_ON_ONCE(req_start >= seg_end);\n\t\t/* start of request is past the last byte of this segment */\n\t\tif (req_start >= seg_end) {\n\t\t\t/* reference the new lseg */\n\t\t\tif (pgio->pg_ops->pg_cleanup)\n\t\t\t\tpgio->pg_ops->pg_cleanup(pgio);\n\t\t\tif (pgio->pg_ops->pg_init)\n\t\t\t\tpgio->pg_ops->pg_init(pgio, req);\n\t\t\treturn 0;\n\t\t}\n\n\t\t/* adjust 'size' iff there are fewer bytes left in the\n\t\t * segment than what nfs_generic_pg_test returned */\n\t\tseg_left = seg_end - req_start;\n\t\tif (seg_left < size)\n\t\t\tsize = (unsigned int)seg_left;\n\t}\n\n\treturn size;\n}",
          "includes": [
            "#include \"delegation.h\"",
            "#include \"nfs4trace.h\"",
            "#include \"iostat.h\"",
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nsize_t\npnfs_generic_pg_test(struct nfs_pageio_descriptor *pgio,\n\t\t     struct nfs_page *prev, struct nfs_page *req)\n{\n\tunsigned int size;\n\tu64 seg_end, req_start, seg_left;\n\n\tsize = nfs_generic_pg_test(pgio, prev, req);\n\tif (!size)\n\t\treturn 0;\n\n\t/*\n\t * 'size' contains the number of bytes left in the current page (up\n\t * to the original size asked for in @req->wb_bytes).\n\t *\n\t * Calculate how many bytes are left in the layout segment\n\t * and if there are less bytes than 'size', return that instead.\n\t *\n\t * Please also note that 'end_offset' is actually the offset of the\n\t * first byte that lies outside the pnfs_layout_range. FIXME?\n\t *\n\t */\n\tif (pgio->pg_lseg) {\n\t\tseg_end = end_offset(pgio->pg_lseg->pls_range.offset,\n\t\t\t\t     pgio->pg_lseg->pls_range.length);\n\t\treq_start = req_offset(req);\n\t\tWARN_ON_ONCE(req_start >= seg_end);\n\t\t/* start of request is past the last byte of this segment */\n\t\tif (req_start >= seg_end) {\n\t\t\t/* reference the new lseg */\n\t\t\tif (pgio->pg_ops->pg_cleanup)\n\t\t\t\tpgio->pg_ops->pg_cleanup(pgio);\n\t\t\tif (pgio->pg_ops->pg_init)\n\t\t\t\tpgio->pg_ops->pg_init(pgio, req);\n\t\t\treturn 0;\n\t\t}\n\n\t\t/* adjust 'size' iff there are fewer bytes left in the\n\t\t * segment than what nfs_generic_pg_test returned */\n\t\tseg_left = seg_end - req_start;\n\t\tif (seg_left < size)\n\t\t\tsize = (unsigned int)seg_left;\n\t}\n\n\treturn size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_aligned_req",
          "args": [
            "pgio",
            "req",
            "PAGE_SIZE"
          ],
          "line": 854
        },
        "resolved": true,
        "details": {
          "function_name": "is_aligned_req",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/blocklayout/blocklayout.c",
          "lines": "749-778",
          "snippet": "static bool\nis_aligned_req(struct nfs_pageio_descriptor *pgio,\n\t\tstruct nfs_page *req, unsigned int alignment)\n{\n\t/*\n\t * Always accept buffered writes, higher layers take care of the\n\t * right alignment.\n\t */\n\tif (pgio->pg_dreq == NULL)\n\t\treturn true;\n\n\tif (!IS_ALIGNED(req->wb_offset, alignment))\n\t\treturn false;\n\n\tif (IS_ALIGNED(req->wb_bytes, alignment))\n\t\treturn true;\n\n\tif (req_offset(req) + req->wb_bytes == i_size_read(pgio->pg_inode)) {\n\t\t/*\n\t\t * If the write goes up to the inode size, just write\n\t\t * the full page.  Data past the inode size is\n\t\t * guaranteed to be zeroed by the higher level client\n\t\t * code, and this behaviour is mandated by RFC 5663\n\t\t * section 2.3.2.\n\t\t */\n\t\treturn true;\n\t}\n\n\treturn false;\n}",
          "includes": [
            "#include \"blocklayout.h\"",
            "#include \"../internal.h\"",
            "#include \"../nfs4session.h\"",
            "#include \"../pnfs.h\"",
            "#include <linux/pagevec.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/bio.h>\t\t/* struct bio */",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"blocklayout.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include \"../pnfs.h\"\n#include <linux/pagevec.h>\n#include <linux/prefetch.h>\n#include <linux/bio.h>\t\t/* struct bio */\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic bool\nis_aligned_req(struct nfs_pageio_descriptor *pgio,\n\t\tstruct nfs_page *req, unsigned int alignment)\n{\n\t/*\n\t * Always accept buffered writes, higher layers take care of the\n\t * right alignment.\n\t */\n\tif (pgio->pg_dreq == NULL)\n\t\treturn true;\n\n\tif (!IS_ALIGNED(req->wb_offset, alignment))\n\t\treturn false;\n\n\tif (IS_ALIGNED(req->wb_bytes, alignment))\n\t\treturn true;\n\n\tif (req_offset(req) + req->wb_bytes == i_size_read(pgio->pg_inode)) {\n\t\t/*\n\t\t * If the write goes up to the inode size, just write\n\t\t * the full page.  Data past the inode size is\n\t\t * guaranteed to be zeroed by the higher level client\n\t\t * code, and this behaviour is mandated by RFC 5663\n\t\t * section 2.3.2.\n\t\t */\n\t\treturn true;\n\t}\n\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"blocklayout.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include \"../pnfs.h\"\n#include <linux/pagevec.h>\n#include <linux/prefetch.h>\n#include <linux/bio.h>\t\t/* struct bio */\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic size_t\nbl_pg_test_write(struct nfs_pageio_descriptor *pgio, struct nfs_page *prev,\n\t\t struct nfs_page *req)\n{\n\tif (!is_aligned_req(pgio, req, PAGE_SIZE))\n\t\treturn 0;\n\treturn pnfs_generic_pg_test(pgio, prev, req);\n}"
  },
  {
    "function_name": "bl_pg_init_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/blocklayout/blocklayout.c",
    "lines": "827-844",
    "snippet": "static void\nbl_pg_init_write(struct nfs_pageio_descriptor *pgio, struct nfs_page *req)\n{\n\tu64 wb_size;\n\n\tif (!is_aligned_req(pgio, req, PAGE_SIZE)) {\n\t\tnfs_pageio_reset_write_mds(pgio);\n\t\treturn;\n\t}\n\n\tif (pgio->pg_dreq == NULL)\n\t\twb_size = pnfs_num_cont_bytes(pgio->pg_inode,\n\t\t\t\t\t      req->wb_index);\n\telse\n\t\twb_size = nfs_dreq_bytes_left(pgio->pg_dreq);\n\n\tpnfs_generic_pg_init_write(pgio, req, wb_size);\n}",
    "includes": [
      "#include \"blocklayout.h\"",
      "#include \"../internal.h\"",
      "#include \"../nfs4session.h\"",
      "#include \"../pnfs.h\"",
      "#include <linux/pagevec.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/bio.h>\t\t/* struct bio */",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pnfs_generic_pg_init_write",
          "args": [
            "pgio",
            "req",
            "wb_size"
          ],
          "line": 843
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_generic_pg_init_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
          "lines": "1735-1749",
          "snippet": "void\npnfs_generic_pg_init_write(struct nfs_pageio_descriptor *pgio,\n\t\t\t   struct nfs_page *req, u64 wb_size)\n{\n\tif (pgio->pg_lseg == NULL)\n\t\tpgio->pg_lseg = pnfs_update_layout(pgio->pg_inode,\n\t\t\t\t\t\t   req->wb_context,\n\t\t\t\t\t\t   req_offset(req),\n\t\t\t\t\t\t   wb_size,\n\t\t\t\t\t\t   IOMODE_RW,\n\t\t\t\t\t\t   GFP_NOFS);\n\t/* If no lseg, fall back to write through mds */\n\tif (pgio->pg_lseg == NULL)\n\t\tnfs_pageio_reset_write_mds(pgio);\n}",
          "includes": [
            "#include \"delegation.h\"",
            "#include \"nfs4trace.h\"",
            "#include \"iostat.h\"",
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nvoid\npnfs_generic_pg_init_write(struct nfs_pageio_descriptor *pgio,\n\t\t\t   struct nfs_page *req, u64 wb_size)\n{\n\tif (pgio->pg_lseg == NULL)\n\t\tpgio->pg_lseg = pnfs_update_layout(pgio->pg_inode,\n\t\t\t\t\t\t   req->wb_context,\n\t\t\t\t\t\t   req_offset(req),\n\t\t\t\t\t\t   wb_size,\n\t\t\t\t\t\t   IOMODE_RW,\n\t\t\t\t\t\t   GFP_NOFS);\n\t/* If no lseg, fall back to write through mds */\n\tif (pgio->pg_lseg == NULL)\n\t\tnfs_pageio_reset_write_mds(pgio);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_dreq_bytes_left",
          "args": [
            "pgio->pg_dreq"
          ],
          "line": 841
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_dreq_bytes_left",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/direct.c",
          "lines": "342-345",
          "snippet": "ssize_t nfs_dreq_bytes_left(struct nfs_direct_req *dreq)\n{\n\treturn dreq->bytes_left;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include <linux/atomic.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/slab.h>",
            "#include <linux/kref.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include <linux/atomic.h>\n#include <asm/uaccess.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n#include <linux/module.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/slab.h>\n#include <linux/kref.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nssize_t nfs_dreq_bytes_left(struct nfs_direct_req *dreq)\n{\n\treturn dreq->bytes_left;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pnfs_num_cont_bytes",
          "args": [
            "pgio->pg_inode",
            "req->wb_index"
          ],
          "line": 838
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_num_cont_bytes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/blocklayout/blocklayout.c",
          "lines": "808-825",
          "snippet": "static u64 pnfs_num_cont_bytes(struct inode *inode, pgoff_t idx)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tpgoff_t end;\n\n\t/* Optimize common case that writes from 0 to end of file */\n\tend = DIV_ROUND_UP(i_size_read(inode), PAGE_CACHE_SIZE);\n\tif (end != inode->i_mapping->nrpages) {\n\t\trcu_read_lock();\n\t\tend = page_cache_next_hole(mapping, idx + 1, ULONG_MAX);\n\t\trcu_read_unlock();\n\t}\n\n\tif (!end)\n\t\treturn i_size_read(inode) - (idx << PAGE_CACHE_SHIFT);\n\telse\n\t\treturn (end - idx) << PAGE_CACHE_SHIFT;\n}",
          "includes": [
            "#include \"blocklayout.h\"",
            "#include \"../internal.h\"",
            "#include \"../nfs4session.h\"",
            "#include \"../pnfs.h\"",
            "#include <linux/pagevec.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/bio.h>\t\t/* struct bio */",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"blocklayout.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include \"../pnfs.h\"\n#include <linux/pagevec.h>\n#include <linux/prefetch.h>\n#include <linux/bio.h>\t\t/* struct bio */\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic u64 pnfs_num_cont_bytes(struct inode *inode, pgoff_t idx)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tpgoff_t end;\n\n\t/* Optimize common case that writes from 0 to end of file */\n\tend = DIV_ROUND_UP(i_size_read(inode), PAGE_CACHE_SIZE);\n\tif (end != inode->i_mapping->nrpages) {\n\t\trcu_read_lock();\n\t\tend = page_cache_next_hole(mapping, idx + 1, ULONG_MAX);\n\t\trcu_read_unlock();\n\t}\n\n\tif (!end)\n\t\treturn i_size_read(inode) - (idx << PAGE_CACHE_SHIFT);\n\telse\n\t\treturn (end - idx) << PAGE_CACHE_SHIFT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_pageio_reset_write_mds",
          "args": [
            "pgio"
          ],
          "line": 833
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_pageio_reset_write_mds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
          "lines": "1329-1339",
          "snippet": "void nfs_pageio_reset_write_mds(struct nfs_pageio_descriptor *pgio)\n{\n\tstruct nfs_pgio_mirror *mirror;\n\n\tpgio->pg_ops = &nfs_pgio_rw_ops;\n\n\tnfs_pageio_stop_mirroring(pgio);\n\n\tmirror = &pgio->pg_mirrors[0];\n\tmirror->pg_bsize = NFS_SERVER(pgio->pg_inode)->wsize;\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nvoid nfs_pageio_reset_write_mds(struct nfs_pageio_descriptor *pgio)\n{\n\tstruct nfs_pgio_mirror *mirror;\n\n\tpgio->pg_ops = &nfs_pgio_rw_ops;\n\n\tnfs_pageio_stop_mirroring(pgio);\n\n\tmirror = &pgio->pg_mirrors[0];\n\tmirror->pg_bsize = NFS_SERVER(pgio->pg_inode)->wsize;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_aligned_req",
          "args": [
            "pgio",
            "req",
            "PAGE_SIZE"
          ],
          "line": 832
        },
        "resolved": true,
        "details": {
          "function_name": "is_aligned_req",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/blocklayout/blocklayout.c",
          "lines": "749-778",
          "snippet": "static bool\nis_aligned_req(struct nfs_pageio_descriptor *pgio,\n\t\tstruct nfs_page *req, unsigned int alignment)\n{\n\t/*\n\t * Always accept buffered writes, higher layers take care of the\n\t * right alignment.\n\t */\n\tif (pgio->pg_dreq == NULL)\n\t\treturn true;\n\n\tif (!IS_ALIGNED(req->wb_offset, alignment))\n\t\treturn false;\n\n\tif (IS_ALIGNED(req->wb_bytes, alignment))\n\t\treturn true;\n\n\tif (req_offset(req) + req->wb_bytes == i_size_read(pgio->pg_inode)) {\n\t\t/*\n\t\t * If the write goes up to the inode size, just write\n\t\t * the full page.  Data past the inode size is\n\t\t * guaranteed to be zeroed by the higher level client\n\t\t * code, and this behaviour is mandated by RFC 5663\n\t\t * section 2.3.2.\n\t\t */\n\t\treturn true;\n\t}\n\n\treturn false;\n}",
          "includes": [
            "#include \"blocklayout.h\"",
            "#include \"../internal.h\"",
            "#include \"../nfs4session.h\"",
            "#include \"../pnfs.h\"",
            "#include <linux/pagevec.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/bio.h>\t\t/* struct bio */",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"blocklayout.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include \"../pnfs.h\"\n#include <linux/pagevec.h>\n#include <linux/prefetch.h>\n#include <linux/bio.h>\t\t/* struct bio */\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic bool\nis_aligned_req(struct nfs_pageio_descriptor *pgio,\n\t\tstruct nfs_page *req, unsigned int alignment)\n{\n\t/*\n\t * Always accept buffered writes, higher layers take care of the\n\t * right alignment.\n\t */\n\tif (pgio->pg_dreq == NULL)\n\t\treturn true;\n\n\tif (!IS_ALIGNED(req->wb_offset, alignment))\n\t\treturn false;\n\n\tif (IS_ALIGNED(req->wb_bytes, alignment))\n\t\treturn true;\n\n\tif (req_offset(req) + req->wb_bytes == i_size_read(pgio->pg_inode)) {\n\t\t/*\n\t\t * If the write goes up to the inode size, just write\n\t\t * the full page.  Data past the inode size is\n\t\t * guaranteed to be zeroed by the higher level client\n\t\t * code, and this behaviour is mandated by RFC 5663\n\t\t * section 2.3.2.\n\t\t */\n\t\treturn true;\n\t}\n\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"blocklayout.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include \"../pnfs.h\"\n#include <linux/pagevec.h>\n#include <linux/prefetch.h>\n#include <linux/bio.h>\t\t/* struct bio */\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic void\nbl_pg_init_write(struct nfs_pageio_descriptor *pgio, struct nfs_page *req)\n{\n\tu64 wb_size;\n\n\tif (!is_aligned_req(pgio, req, PAGE_SIZE)) {\n\t\tnfs_pageio_reset_write_mds(pgio);\n\t\treturn;\n\t}\n\n\tif (pgio->pg_dreq == NULL)\n\t\twb_size = pnfs_num_cont_bytes(pgio->pg_inode,\n\t\t\t\t\t      req->wb_index);\n\telse\n\t\twb_size = nfs_dreq_bytes_left(pgio->pg_dreq);\n\n\tpnfs_generic_pg_init_write(pgio, req, wb_size);\n}"
  },
  {
    "function_name": "pnfs_num_cont_bytes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/blocklayout/blocklayout.c",
    "lines": "808-825",
    "snippet": "static u64 pnfs_num_cont_bytes(struct inode *inode, pgoff_t idx)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tpgoff_t end;\n\n\t/* Optimize common case that writes from 0 to end of file */\n\tend = DIV_ROUND_UP(i_size_read(inode), PAGE_CACHE_SIZE);\n\tif (end != inode->i_mapping->nrpages) {\n\t\trcu_read_lock();\n\t\tend = page_cache_next_hole(mapping, idx + 1, ULONG_MAX);\n\t\trcu_read_unlock();\n\t}\n\n\tif (!end)\n\t\treturn i_size_read(inode) - (idx << PAGE_CACHE_SHIFT);\n\telse\n\t\treturn (end - idx) << PAGE_CACHE_SHIFT;\n}",
    "includes": [
      "#include \"blocklayout.h\"",
      "#include \"../internal.h\"",
      "#include \"../nfs4session.h\"",
      "#include \"../pnfs.h\"",
      "#include <linux/pagevec.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/bio.h>\t\t/* struct bio */",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 822
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 818
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_cache_next_hole",
          "args": [
            "mapping",
            "idx + 1",
            "ULONG_MAX"
          ],
          "line": 817
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 816
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DIV_ROUND_UP",
          "args": [
            "i_size_read(inode)",
            "PAGE_CACHE_SIZE"
          ],
          "line": 814
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 814
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"blocklayout.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include \"../pnfs.h\"\n#include <linux/pagevec.h>\n#include <linux/prefetch.h>\n#include <linux/bio.h>\t\t/* struct bio */\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic u64 pnfs_num_cont_bytes(struct inode *inode, pgoff_t idx)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tpgoff_t end;\n\n\t/* Optimize common case that writes from 0 to end of file */\n\tend = DIV_ROUND_UP(i_size_read(inode), PAGE_CACHE_SIZE);\n\tif (end != inode->i_mapping->nrpages) {\n\t\trcu_read_lock();\n\t\tend = page_cache_next_hole(mapping, idx + 1, ULONG_MAX);\n\t\trcu_read_unlock();\n\t}\n\n\tif (!end)\n\t\treturn i_size_read(inode) - (idx << PAGE_CACHE_SHIFT);\n\telse\n\t\treturn (end - idx) << PAGE_CACHE_SHIFT;\n}"
  },
  {
    "function_name": "bl_pg_test_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/blocklayout/blocklayout.c",
    "lines": "795-802",
    "snippet": "static size_t\nbl_pg_test_read(struct nfs_pageio_descriptor *pgio, struct nfs_page *prev,\n\t\tstruct nfs_page *req)\n{\n\tif (!is_aligned_req(pgio, req, SECTOR_SIZE))\n\t\treturn 0;\n\treturn pnfs_generic_pg_test(pgio, prev, req);\n}",
    "includes": [
      "#include \"blocklayout.h\"",
      "#include \"../internal.h\"",
      "#include \"../nfs4session.h\"",
      "#include \"../pnfs.h\"",
      "#include <linux/pagevec.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/bio.h>\t\t/* struct bio */",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pnfs_generic_pg_test",
          "args": [
            "pgio",
            "prev",
            "req"
          ],
          "line": 801
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_generic_pg_test",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
          "lines": "1766-1811",
          "snippet": "size_t\npnfs_generic_pg_test(struct nfs_pageio_descriptor *pgio,\n\t\t     struct nfs_page *prev, struct nfs_page *req)\n{\n\tunsigned int size;\n\tu64 seg_end, req_start, seg_left;\n\n\tsize = nfs_generic_pg_test(pgio, prev, req);\n\tif (!size)\n\t\treturn 0;\n\n\t/*\n\t * 'size' contains the number of bytes left in the current page (up\n\t * to the original size asked for in @req->wb_bytes).\n\t *\n\t * Calculate how many bytes are left in the layout segment\n\t * and if there are less bytes than 'size', return that instead.\n\t *\n\t * Please also note that 'end_offset' is actually the offset of the\n\t * first byte that lies outside the pnfs_layout_range. FIXME?\n\t *\n\t */\n\tif (pgio->pg_lseg) {\n\t\tseg_end = end_offset(pgio->pg_lseg->pls_range.offset,\n\t\t\t\t     pgio->pg_lseg->pls_range.length);\n\t\treq_start = req_offset(req);\n\t\tWARN_ON_ONCE(req_start >= seg_end);\n\t\t/* start of request is past the last byte of this segment */\n\t\tif (req_start >= seg_end) {\n\t\t\t/* reference the new lseg */\n\t\t\tif (pgio->pg_ops->pg_cleanup)\n\t\t\t\tpgio->pg_ops->pg_cleanup(pgio);\n\t\t\tif (pgio->pg_ops->pg_init)\n\t\t\t\tpgio->pg_ops->pg_init(pgio, req);\n\t\t\treturn 0;\n\t\t}\n\n\t\t/* adjust 'size' iff there are fewer bytes left in the\n\t\t * segment than what nfs_generic_pg_test returned */\n\t\tseg_left = seg_end - req_start;\n\t\tif (seg_left < size)\n\t\t\tsize = (unsigned int)seg_left;\n\t}\n\n\treturn size;\n}",
          "includes": [
            "#include \"delegation.h\"",
            "#include \"nfs4trace.h\"",
            "#include \"iostat.h\"",
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nsize_t\npnfs_generic_pg_test(struct nfs_pageio_descriptor *pgio,\n\t\t     struct nfs_page *prev, struct nfs_page *req)\n{\n\tunsigned int size;\n\tu64 seg_end, req_start, seg_left;\n\n\tsize = nfs_generic_pg_test(pgio, prev, req);\n\tif (!size)\n\t\treturn 0;\n\n\t/*\n\t * 'size' contains the number of bytes left in the current page (up\n\t * to the original size asked for in @req->wb_bytes).\n\t *\n\t * Calculate how many bytes are left in the layout segment\n\t * and if there are less bytes than 'size', return that instead.\n\t *\n\t * Please also note that 'end_offset' is actually the offset of the\n\t * first byte that lies outside the pnfs_layout_range. FIXME?\n\t *\n\t */\n\tif (pgio->pg_lseg) {\n\t\tseg_end = end_offset(pgio->pg_lseg->pls_range.offset,\n\t\t\t\t     pgio->pg_lseg->pls_range.length);\n\t\treq_start = req_offset(req);\n\t\tWARN_ON_ONCE(req_start >= seg_end);\n\t\t/* start of request is past the last byte of this segment */\n\t\tif (req_start >= seg_end) {\n\t\t\t/* reference the new lseg */\n\t\t\tif (pgio->pg_ops->pg_cleanup)\n\t\t\t\tpgio->pg_ops->pg_cleanup(pgio);\n\t\t\tif (pgio->pg_ops->pg_init)\n\t\t\t\tpgio->pg_ops->pg_init(pgio, req);\n\t\t\treturn 0;\n\t\t}\n\n\t\t/* adjust 'size' iff there are fewer bytes left in the\n\t\t * segment than what nfs_generic_pg_test returned */\n\t\tseg_left = seg_end - req_start;\n\t\tif (seg_left < size)\n\t\t\tsize = (unsigned int)seg_left;\n\t}\n\n\treturn size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_aligned_req",
          "args": [
            "pgio",
            "req",
            "SECTOR_SIZE"
          ],
          "line": 799
        },
        "resolved": true,
        "details": {
          "function_name": "is_aligned_req",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/blocklayout/blocklayout.c",
          "lines": "749-778",
          "snippet": "static bool\nis_aligned_req(struct nfs_pageio_descriptor *pgio,\n\t\tstruct nfs_page *req, unsigned int alignment)\n{\n\t/*\n\t * Always accept buffered writes, higher layers take care of the\n\t * right alignment.\n\t */\n\tif (pgio->pg_dreq == NULL)\n\t\treturn true;\n\n\tif (!IS_ALIGNED(req->wb_offset, alignment))\n\t\treturn false;\n\n\tif (IS_ALIGNED(req->wb_bytes, alignment))\n\t\treturn true;\n\n\tif (req_offset(req) + req->wb_bytes == i_size_read(pgio->pg_inode)) {\n\t\t/*\n\t\t * If the write goes up to the inode size, just write\n\t\t * the full page.  Data past the inode size is\n\t\t * guaranteed to be zeroed by the higher level client\n\t\t * code, and this behaviour is mandated by RFC 5663\n\t\t * section 2.3.2.\n\t\t */\n\t\treturn true;\n\t}\n\n\treturn false;\n}",
          "includes": [
            "#include \"blocklayout.h\"",
            "#include \"../internal.h\"",
            "#include \"../nfs4session.h\"",
            "#include \"../pnfs.h\"",
            "#include <linux/pagevec.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/bio.h>\t\t/* struct bio */",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"blocklayout.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include \"../pnfs.h\"\n#include <linux/pagevec.h>\n#include <linux/prefetch.h>\n#include <linux/bio.h>\t\t/* struct bio */\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic bool\nis_aligned_req(struct nfs_pageio_descriptor *pgio,\n\t\tstruct nfs_page *req, unsigned int alignment)\n{\n\t/*\n\t * Always accept buffered writes, higher layers take care of the\n\t * right alignment.\n\t */\n\tif (pgio->pg_dreq == NULL)\n\t\treturn true;\n\n\tif (!IS_ALIGNED(req->wb_offset, alignment))\n\t\treturn false;\n\n\tif (IS_ALIGNED(req->wb_bytes, alignment))\n\t\treturn true;\n\n\tif (req_offset(req) + req->wb_bytes == i_size_read(pgio->pg_inode)) {\n\t\t/*\n\t\t * If the write goes up to the inode size, just write\n\t\t * the full page.  Data past the inode size is\n\t\t * guaranteed to be zeroed by the higher level client\n\t\t * code, and this behaviour is mandated by RFC 5663\n\t\t * section 2.3.2.\n\t\t */\n\t\treturn true;\n\t}\n\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"blocklayout.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include \"../pnfs.h\"\n#include <linux/pagevec.h>\n#include <linux/prefetch.h>\n#include <linux/bio.h>\t\t/* struct bio */\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic size_t\nbl_pg_test_read(struct nfs_pageio_descriptor *pgio, struct nfs_page *prev,\n\t\tstruct nfs_page *req)\n{\n\tif (!is_aligned_req(pgio, req, SECTOR_SIZE))\n\t\treturn 0;\n\treturn pnfs_generic_pg_test(pgio, prev, req);\n}"
  },
  {
    "function_name": "bl_pg_init_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/blocklayout/blocklayout.c",
    "lines": "780-789",
    "snippet": "static void\nbl_pg_init_read(struct nfs_pageio_descriptor *pgio, struct nfs_page *req)\n{\n\tif (!is_aligned_req(pgio, req, SECTOR_SIZE)) {\n\t\tnfs_pageio_reset_read_mds(pgio);\n\t\treturn;\n\t}\n\n\tpnfs_generic_pg_init_read(pgio, req);\n}",
    "includes": [
      "#include \"blocklayout.h\"",
      "#include \"../internal.h\"",
      "#include \"../nfs4session.h\"",
      "#include \"../pnfs.h\"",
      "#include <linux/pagevec.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/bio.h>\t\t/* struct bio */",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pnfs_generic_pg_init_read",
          "args": [
            "pgio",
            "req"
          ],
          "line": 788
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_generic_pg_init_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
          "lines": "1710-1732",
          "snippet": "void\npnfs_generic_pg_init_read(struct nfs_pageio_descriptor *pgio, struct nfs_page *req)\n{\n\tu64 rd_size = req->wb_bytes;\n\n\tif (pgio->pg_lseg == NULL) {\n\t\tif (pgio->pg_dreq == NULL)\n\t\t\trd_size = i_size_read(pgio->pg_inode) - req_offset(req);\n\t\telse\n\t\t\trd_size = nfs_dreq_bytes_left(pgio->pg_dreq);\n\n\t\tpgio->pg_lseg = pnfs_update_layout(pgio->pg_inode,\n\t\t\t\t\t\t   req->wb_context,\n\t\t\t\t\t\t   req_offset(req),\n\t\t\t\t\t\t   rd_size,\n\t\t\t\t\t\t   IOMODE_READ,\n\t\t\t\t\t\t   GFP_KERNEL);\n\t}\n\t/* If no lseg, fall back to read through mds */\n\tif (pgio->pg_lseg == NULL)\n\t\tnfs_pageio_reset_read_mds(pgio);\n\n}",
          "includes": [
            "#include \"delegation.h\"",
            "#include \"nfs4trace.h\"",
            "#include \"iostat.h\"",
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nvoid\npnfs_generic_pg_init_read(struct nfs_pageio_descriptor *pgio, struct nfs_page *req)\n{\n\tu64 rd_size = req->wb_bytes;\n\n\tif (pgio->pg_lseg == NULL) {\n\t\tif (pgio->pg_dreq == NULL)\n\t\t\trd_size = i_size_read(pgio->pg_inode) - req_offset(req);\n\t\telse\n\t\t\trd_size = nfs_dreq_bytes_left(pgio->pg_dreq);\n\n\t\tpgio->pg_lseg = pnfs_update_layout(pgio->pg_inode,\n\t\t\t\t\t\t   req->wb_context,\n\t\t\t\t\t\t   req_offset(req),\n\t\t\t\t\t\t   rd_size,\n\t\t\t\t\t\t   IOMODE_READ,\n\t\t\t\t\t\t   GFP_KERNEL);\n\t}\n\t/* If no lseg, fall back to read through mds */\n\tif (pgio->pg_lseg == NULL)\n\t\tnfs_pageio_reset_read_mds(pgio);\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_pageio_reset_read_mds",
          "args": [
            "pgio"
          ],
          "line": 784
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_pageio_reset_read_mds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/read.c",
          "lines": "71-82",
          "snippet": "void nfs_pageio_reset_read_mds(struct nfs_pageio_descriptor *pgio)\n{\n\tstruct nfs_pgio_mirror *mirror;\n\n\tpgio->pg_ops = &nfs_pgio_rw_ops;\n\n\t/* read path should never have more than one mirror */\n\tWARN_ON_ONCE(pgio->pg_mirror_count != 1);\n\n\tmirror = &pgio->pg_mirrors[0];\n\tmirror->pg_bsize = NFS_SERVER(pgio->pg_inode)->rsize;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"nfs4_fs.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n\nvoid nfs_pageio_reset_read_mds(struct nfs_pageio_descriptor *pgio)\n{\n\tstruct nfs_pgio_mirror *mirror;\n\n\tpgio->pg_ops = &nfs_pgio_rw_ops;\n\n\t/* read path should never have more than one mirror */\n\tWARN_ON_ONCE(pgio->pg_mirror_count != 1);\n\n\tmirror = &pgio->pg_mirrors[0];\n\tmirror->pg_bsize = NFS_SERVER(pgio->pg_inode)->rsize;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_aligned_req",
          "args": [
            "pgio",
            "req",
            "SECTOR_SIZE"
          ],
          "line": 783
        },
        "resolved": true,
        "details": {
          "function_name": "is_aligned_req",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/blocklayout/blocklayout.c",
          "lines": "749-778",
          "snippet": "static bool\nis_aligned_req(struct nfs_pageio_descriptor *pgio,\n\t\tstruct nfs_page *req, unsigned int alignment)\n{\n\t/*\n\t * Always accept buffered writes, higher layers take care of the\n\t * right alignment.\n\t */\n\tif (pgio->pg_dreq == NULL)\n\t\treturn true;\n\n\tif (!IS_ALIGNED(req->wb_offset, alignment))\n\t\treturn false;\n\n\tif (IS_ALIGNED(req->wb_bytes, alignment))\n\t\treturn true;\n\n\tif (req_offset(req) + req->wb_bytes == i_size_read(pgio->pg_inode)) {\n\t\t/*\n\t\t * If the write goes up to the inode size, just write\n\t\t * the full page.  Data past the inode size is\n\t\t * guaranteed to be zeroed by the higher level client\n\t\t * code, and this behaviour is mandated by RFC 5663\n\t\t * section 2.3.2.\n\t\t */\n\t\treturn true;\n\t}\n\n\treturn false;\n}",
          "includes": [
            "#include \"blocklayout.h\"",
            "#include \"../internal.h\"",
            "#include \"../nfs4session.h\"",
            "#include \"../pnfs.h\"",
            "#include <linux/pagevec.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/bio.h>\t\t/* struct bio */",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"blocklayout.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include \"../pnfs.h\"\n#include <linux/pagevec.h>\n#include <linux/prefetch.h>\n#include <linux/bio.h>\t\t/* struct bio */\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic bool\nis_aligned_req(struct nfs_pageio_descriptor *pgio,\n\t\tstruct nfs_page *req, unsigned int alignment)\n{\n\t/*\n\t * Always accept buffered writes, higher layers take care of the\n\t * right alignment.\n\t */\n\tif (pgio->pg_dreq == NULL)\n\t\treturn true;\n\n\tif (!IS_ALIGNED(req->wb_offset, alignment))\n\t\treturn false;\n\n\tif (IS_ALIGNED(req->wb_bytes, alignment))\n\t\treturn true;\n\n\tif (req_offset(req) + req->wb_bytes == i_size_read(pgio->pg_inode)) {\n\t\t/*\n\t\t * If the write goes up to the inode size, just write\n\t\t * the full page.  Data past the inode size is\n\t\t * guaranteed to be zeroed by the higher level client\n\t\t * code, and this behaviour is mandated by RFC 5663\n\t\t * section 2.3.2.\n\t\t */\n\t\treturn true;\n\t}\n\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"blocklayout.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include \"../pnfs.h\"\n#include <linux/pagevec.h>\n#include <linux/prefetch.h>\n#include <linux/bio.h>\t\t/* struct bio */\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic void\nbl_pg_init_read(struct nfs_pageio_descriptor *pgio, struct nfs_page *req)\n{\n\tif (!is_aligned_req(pgio, req, SECTOR_SIZE)) {\n\t\tnfs_pageio_reset_read_mds(pgio);\n\t\treturn;\n\t}\n\n\tpnfs_generic_pg_init_read(pgio, req);\n}"
  },
  {
    "function_name": "is_aligned_req",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/blocklayout/blocklayout.c",
    "lines": "749-778",
    "snippet": "static bool\nis_aligned_req(struct nfs_pageio_descriptor *pgio,\n\t\tstruct nfs_page *req, unsigned int alignment)\n{\n\t/*\n\t * Always accept buffered writes, higher layers take care of the\n\t * right alignment.\n\t */\n\tif (pgio->pg_dreq == NULL)\n\t\treturn true;\n\n\tif (!IS_ALIGNED(req->wb_offset, alignment))\n\t\treturn false;\n\n\tif (IS_ALIGNED(req->wb_bytes, alignment))\n\t\treturn true;\n\n\tif (req_offset(req) + req->wb_bytes == i_size_read(pgio->pg_inode)) {\n\t\t/*\n\t\t * If the write goes up to the inode size, just write\n\t\t * the full page.  Data past the inode size is\n\t\t * guaranteed to be zeroed by the higher level client\n\t\t * code, and this behaviour is mandated by RFC 5663\n\t\t * section 2.3.2.\n\t\t */\n\t\treturn true;\n\t}\n\n\treturn false;\n}",
    "includes": [
      "#include \"blocklayout.h\"",
      "#include \"../internal.h\"",
      "#include \"../nfs4session.h\"",
      "#include \"../pnfs.h\"",
      "#include <linux/pagevec.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/bio.h>\t\t/* struct bio */",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "pgio->pg_inode"
          ],
          "line": 766
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "req_offset",
          "args": [
            "req"
          ],
          "line": 766
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ALIGNED",
          "args": [
            "req->wb_bytes",
            "alignment"
          ],
          "line": 763
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ALIGNED",
          "args": [
            "req->wb_offset",
            "alignment"
          ],
          "line": 760
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"blocklayout.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include \"../pnfs.h\"\n#include <linux/pagevec.h>\n#include <linux/prefetch.h>\n#include <linux/bio.h>\t\t/* struct bio */\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic bool\nis_aligned_req(struct nfs_pageio_descriptor *pgio,\n\t\tstruct nfs_page *req, unsigned int alignment)\n{\n\t/*\n\t * Always accept buffered writes, higher layers take care of the\n\t * right alignment.\n\t */\n\tif (pgio->pg_dreq == NULL)\n\t\treturn true;\n\n\tif (!IS_ALIGNED(req->wb_offset, alignment))\n\t\treturn false;\n\n\tif (IS_ALIGNED(req->wb_bytes, alignment))\n\t\treturn true;\n\n\tif (req_offset(req) + req->wb_bytes == i_size_read(pgio->pg_inode)) {\n\t\t/*\n\t\t * If the write goes up to the inode size, just write\n\t\t * the full page.  Data past the inode size is\n\t\t * guaranteed to be zeroed by the higher level client\n\t\t * code, and this behaviour is mandated by RFC 5663\n\t\t * section 2.3.2.\n\t\t */\n\t\treturn true;\n\t}\n\n\treturn false;\n}"
  },
  {
    "function_name": "bl_set_layoutdriver",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/blocklayout/blocklayout.c",
    "lines": "731-747",
    "snippet": "static int\nbl_set_layoutdriver(struct nfs_server *server, const struct nfs_fh *fh)\n{\n\tdprintk(\"%s enter\\n\", __func__);\n\n\tif (server->pnfs_blksize == 0) {\n\t\tdprintk(\"%s Server did not return blksize\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\tif (server->pnfs_blksize > PAGE_SIZE) {\n\t\tprintk(KERN_ERR \"%s: pNFS blksize %d not supported.\\n\",\n\t\t\t__func__, server->pnfs_blksize);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"blocklayout.h\"",
      "#include \"../internal.h\"",
      "#include \"../nfs4session.h\"",
      "#include \"../pnfs.h\"",
      "#include <linux/pagevec.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/bio.h>\t\t/* struct bio */",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"%s: pNFS blksize %d not supported.\\n\"",
            "__func__",
            "server->pnfs_blksize"
          ],
          "line": 741
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s Server did not return blksize\\n\"",
            "__func__"
          ],
          "line": 737
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s enter\\n\"",
            "__func__"
          ],
          "line": 734
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"blocklayout.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include \"../pnfs.h\"\n#include <linux/pagevec.h>\n#include <linux/prefetch.h>\n#include <linux/bio.h>\t\t/* struct bio */\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic int\nbl_set_layoutdriver(struct nfs_server *server, const struct nfs_fh *fh)\n{\n\tdprintk(\"%s enter\\n\", __func__);\n\n\tif (server->pnfs_blksize == 0) {\n\t\tdprintk(\"%s Server did not return blksize\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\tif (server->pnfs_blksize > PAGE_SIZE) {\n\t\tprintk(KERN_ERR \"%s: pNFS blksize %d not supported.\\n\",\n\t\t\t__func__, server->pnfs_blksize);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "bl_cleanup_layoutcommit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/blocklayout/blocklayout.c",
    "lines": "725-729",
    "snippet": "static void\nbl_cleanup_layoutcommit(struct nfs4_layoutcommit_data *lcdata)\n{\n\text_tree_mark_committed(&lcdata->args, lcdata->res.status);\n}",
    "includes": [
      "#include \"blocklayout.h\"",
      "#include \"../internal.h\"",
      "#include \"../nfs4session.h\"",
      "#include \"../pnfs.h\"",
      "#include <linux/pagevec.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/bio.h>\t\t/* struct bio */",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext_tree_mark_committed",
          "args": [
            "&lcdata->args",
            "lcdata->res.status"
          ],
          "line": 728
        },
        "resolved": true,
        "details": {
          "function_name": "ext_tree_mark_committed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/blocklayout/extent_tree.c",
          "lines": "569-602",
          "snippet": "void\next_tree_mark_committed(struct nfs4_layoutcommit_args *arg, int status)\n{\n\tstruct pnfs_block_layout *bl = BLK_LO2EXT(NFS_I(arg->inode)->layout);\n\tstruct rb_root *root = &bl->bl_ext_rw;\n\tstruct pnfs_block_extent *be;\n\n\tdprintk(\"%s status %d\\n\", __func__, status);\n\n\text_tree_free_commitdata(arg, arg->layoutupdate_len);\n\n\tspin_lock(&bl->bl_ext_lock);\n\tfor (be = ext_tree_first(root); be; be = ext_tree_next(be)) {\n\t\tif (be->be_state != PNFS_BLOCK_INVALID_DATA ||\n\t\t    be->be_tag != EXTENT_COMMITTING)\n\t\t\tcontinue;\n\n\t\tif (status) {\n\t\t\t/*\n\t\t\t * Mark as written and try again.\n\t\t\t *\n\t\t\t * XXX: some real error handling here wouldn't hurt..\n\t\t\t */\n\t\t\tbe->be_tag = EXTENT_WRITTEN;\n\t\t} else {\n\t\t\tbe->be_state = PNFS_BLOCK_READWRITE_DATA;\n\t\t\tbe->be_tag = 0;\n\t\t}\n\n\t\tbe = ext_try_to_merge_left(root, be);\n\t\tbe = ext_try_to_merge_right(root, be);\n\t}\n\tspin_unlock(&bl->bl_ext_lock);\n}",
          "includes": [
            "#include \"blocklayout.h\"",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"blocklayout.h\"\n#include <linux/vmalloc.h>\n\nvoid\next_tree_mark_committed(struct nfs4_layoutcommit_args *arg, int status)\n{\n\tstruct pnfs_block_layout *bl = BLK_LO2EXT(NFS_I(arg->inode)->layout);\n\tstruct rb_root *root = &bl->bl_ext_rw;\n\tstruct pnfs_block_extent *be;\n\n\tdprintk(\"%s status %d\\n\", __func__, status);\n\n\text_tree_free_commitdata(arg, arg->layoutupdate_len);\n\n\tspin_lock(&bl->bl_ext_lock);\n\tfor (be = ext_tree_first(root); be; be = ext_tree_next(be)) {\n\t\tif (be->be_state != PNFS_BLOCK_INVALID_DATA ||\n\t\t    be->be_tag != EXTENT_COMMITTING)\n\t\t\tcontinue;\n\n\t\tif (status) {\n\t\t\t/*\n\t\t\t * Mark as written and try again.\n\t\t\t *\n\t\t\t * XXX: some real error handling here wouldn't hurt..\n\t\t\t */\n\t\t\tbe->be_tag = EXTENT_WRITTEN;\n\t\t} else {\n\t\t\tbe->be_state = PNFS_BLOCK_READWRITE_DATA;\n\t\t\tbe->be_tag = 0;\n\t\t}\n\n\t\tbe = ext_try_to_merge_left(root, be);\n\t\tbe = ext_try_to_merge_right(root, be);\n\t}\n\tspin_unlock(&bl->bl_ext_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"blocklayout.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include \"../pnfs.h\"\n#include <linux/pagevec.h>\n#include <linux/prefetch.h>\n#include <linux/bio.h>\t\t/* struct bio */\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic void\nbl_cleanup_layoutcommit(struct nfs4_layoutcommit_data *lcdata)\n{\n\text_tree_mark_committed(&lcdata->args, lcdata->res.status);\n}"
  },
  {
    "function_name": "bl_prepare_layoutcommit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/blocklayout/blocklayout.c",
    "lines": "719-723",
    "snippet": "static int\nbl_prepare_layoutcommit(struct nfs4_layoutcommit_args *arg)\n{\n\treturn ext_tree_prepare_commit(arg);\n}",
    "includes": [
      "#include \"blocklayout.h\"",
      "#include \"../internal.h\"",
      "#include \"../nfs4session.h\"",
      "#include \"../pnfs.h\"",
      "#include <linux/pagevec.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/bio.h>\t\t/* struct bio */",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext_tree_prepare_commit",
          "args": [
            "arg"
          ],
          "line": 722
        },
        "resolved": true,
        "details": {
          "function_name": "ext_tree_prepare_commit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/blocklayout/extent_tree.c",
          "lines": "512-567",
          "snippet": "int\next_tree_prepare_commit(struct nfs4_layoutcommit_args *arg)\n{\n\tstruct pnfs_block_layout *bl = BLK_LO2EXT(NFS_I(arg->inode)->layout);\n\tsize_t count = 0, buffer_size = PAGE_SIZE;\n\t__be32 *start_p;\n\tint ret;\n\n\tdprintk(\"%s enter\\n\", __func__);\n\n\targ->layoutupdate_page = alloc_page(GFP_NOFS);\n\tif (!arg->layoutupdate_page)\n\t\treturn -ENOMEM;\n\tstart_p = page_address(arg->layoutupdate_page);\n\targ->layoutupdate_pages = &arg->layoutupdate_page;\n\nretry:\n\tret = ext_tree_encode_commit(bl, start_p + 1, buffer_size, &count);\n\tif (unlikely(ret)) {\n\t\text_tree_free_commitdata(arg, buffer_size);\n\n\t\tbuffer_size = sizeof(__be32) + BL_EXTENT_SIZE * count;\n\t\tcount = 0;\n\n\t\targ->layoutupdate_pages =\n\t\t\tkcalloc(DIV_ROUND_UP(buffer_size, PAGE_SIZE),\n\t\t\t\tsizeof(struct page *), GFP_NOFS);\n\t\tif (!arg->layoutupdate_pages)\n\t\t\treturn -ENOMEM;\n\n\t\tstart_p = __vmalloc(buffer_size, GFP_NOFS, PAGE_KERNEL);\n\t\tif (!start_p) {\n\t\t\tkfree(arg->layoutupdate_pages);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tgoto retry;\n\t}\n\n\t*start_p = cpu_to_be32(count);\n\targ->layoutupdate_len = sizeof(__be32) + BL_EXTENT_SIZE * count;\n\n\tif (unlikely(arg->layoutupdate_pages != &arg->layoutupdate_page)) {\n\t\t__be32 *p = start_p;\n\t\tint i = 0;\n\n\t\tfor (p = start_p;\n\t\t     p < start_p + arg->layoutupdate_len;\n\t\t     p += PAGE_SIZE) {\n\t\t\targ->layoutupdate_pages[i++] = vmalloc_to_page(p);\n\t\t}\n\t}\n\n\tdprintk(\"%s found %zu ranges\\n\", __func__, count);\n\treturn 0;\n}",
          "includes": [
            "#include \"blocklayout.h\"",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"blocklayout.h\"\n#include <linux/vmalloc.h>\n\nint\next_tree_prepare_commit(struct nfs4_layoutcommit_args *arg)\n{\n\tstruct pnfs_block_layout *bl = BLK_LO2EXT(NFS_I(arg->inode)->layout);\n\tsize_t count = 0, buffer_size = PAGE_SIZE;\n\t__be32 *start_p;\n\tint ret;\n\n\tdprintk(\"%s enter\\n\", __func__);\n\n\targ->layoutupdate_page = alloc_page(GFP_NOFS);\n\tif (!arg->layoutupdate_page)\n\t\treturn -ENOMEM;\n\tstart_p = page_address(arg->layoutupdate_page);\n\targ->layoutupdate_pages = &arg->layoutupdate_page;\n\nretry:\n\tret = ext_tree_encode_commit(bl, start_p + 1, buffer_size, &count);\n\tif (unlikely(ret)) {\n\t\text_tree_free_commitdata(arg, buffer_size);\n\n\t\tbuffer_size = sizeof(__be32) + BL_EXTENT_SIZE * count;\n\t\tcount = 0;\n\n\t\targ->layoutupdate_pages =\n\t\t\tkcalloc(DIV_ROUND_UP(buffer_size, PAGE_SIZE),\n\t\t\t\tsizeof(struct page *), GFP_NOFS);\n\t\tif (!arg->layoutupdate_pages)\n\t\t\treturn -ENOMEM;\n\n\t\tstart_p = __vmalloc(buffer_size, GFP_NOFS, PAGE_KERNEL);\n\t\tif (!start_p) {\n\t\t\tkfree(arg->layoutupdate_pages);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tgoto retry;\n\t}\n\n\t*start_p = cpu_to_be32(count);\n\targ->layoutupdate_len = sizeof(__be32) + BL_EXTENT_SIZE * count;\n\n\tif (unlikely(arg->layoutupdate_pages != &arg->layoutupdate_page)) {\n\t\t__be32 *p = start_p;\n\t\tint i = 0;\n\n\t\tfor (p = start_p;\n\t\t     p < start_p + arg->layoutupdate_len;\n\t\t     p += PAGE_SIZE) {\n\t\t\targ->layoutupdate_pages[i++] = vmalloc_to_page(p);\n\t\t}\n\t}\n\n\tdprintk(\"%s found %zu ranges\\n\", __func__, count);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"blocklayout.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include \"../pnfs.h\"\n#include <linux/pagevec.h>\n#include <linux/prefetch.h>\n#include <linux/bio.h>\t\t/* struct bio */\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic int\nbl_prepare_layoutcommit(struct nfs4_layoutcommit_args *arg)\n{\n\treturn ext_tree_prepare_commit(arg);\n}"
  },
  {
    "function_name": "bl_return_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/blocklayout/blocklayout.c",
    "lines": "691-717",
    "snippet": "static void\nbl_return_range(struct pnfs_layout_hdr *lo,\n\t\tstruct pnfs_layout_range *range)\n{\n\tstruct pnfs_block_layout *bl = BLK_LO2EXT(lo);\n\tsector_t offset = range->offset >> SECTOR_SHIFT, end;\n\n\tif (range->offset % 8) {\n\t\tdprintk(\"%s: offset %lld not block size aligned\\n\",\n\t\t\t__func__, range->offset);\n\t\treturn;\n\t}\n\n\tif (range->length != NFS4_MAX_UINT64) {\n\t\tif (range->length % 8) {\n\t\t\tdprintk(\"%s: length %lld not block size aligned\\n\",\n\t\t\t\t__func__, range->length);\n\t\t\treturn;\n\t\t}\n\n\t\tend = offset + (range->length >> SECTOR_SHIFT);\n\t} else {\n\t\tend = round_down(NFS4_MAX_UINT64, PAGE_SIZE);\n\t}\n\n\text_tree_remove(bl, range->iomode & IOMODE_RW, offset, end);\n}",
    "includes": [
      "#include \"blocklayout.h\"",
      "#include \"../internal.h\"",
      "#include \"../nfs4session.h\"",
      "#include \"../pnfs.h\"",
      "#include <linux/pagevec.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/bio.h>\t\t/* struct bio */",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext_tree_remove",
          "args": [
            "bl",
            "range->iomode & IOMODE_RW",
            "offset",
            "end"
          ],
          "line": 716
        },
        "resolved": true,
        "details": {
          "function_name": "ext_tree_remove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/blocklayout/extent_tree.c",
          "lines": "349-364",
          "snippet": "int ext_tree_remove(struct pnfs_block_layout *bl, bool rw,\n\t\tsector_t start, sector_t end)\n{\n\tint err, err2;\n\n\tspin_lock(&bl->bl_ext_lock);\n\terr = __ext_tree_remove(&bl->bl_ext_ro, start, end);\n\tif (rw) {\n\t\terr2 = __ext_tree_remove(&bl->bl_ext_rw, start, end);\n\t\tif (!err)\n\t\t\terr = err2;\n\t}\n\tspin_unlock(&bl->bl_ext_lock);\n\n\treturn err;\n}",
          "includes": [
            "#include \"blocklayout.h\"",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"blocklayout.h\"\n#include <linux/vmalloc.h>\n\nint ext_tree_remove(struct pnfs_block_layout *bl, bool rw,\n\t\tsector_t start, sector_t end)\n{\n\tint err, err2;\n\n\tspin_lock(&bl->bl_ext_lock);\n\terr = __ext_tree_remove(&bl->bl_ext_ro, start, end);\n\tif (rw) {\n\t\terr2 = __ext_tree_remove(&bl->bl_ext_rw, start, end);\n\t\tif (!err)\n\t\t\terr = err2;\n\t}\n\tspin_unlock(&bl->bl_ext_lock);\n\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "round_down",
          "args": [
            "NFS4_MAX_UINT64",
            "PAGE_SIZE"
          ],
          "line": 713
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s: length %lld not block size aligned\\n\"",
            "__func__",
            "range->length"
          ],
          "line": 706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s: offset %lld not block size aligned\\n\"",
            "__func__",
            "range->offset"
          ],
          "line": 699
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BLK_LO2EXT",
          "args": [
            "lo"
          ],
          "line": 695
        },
        "resolved": true,
        "details": {
          "function_name": "BLK_LO2EXT",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/blocklayout/blocklayout.h",
          "lines": "153-157",
          "snippet": "static inline struct pnfs_block_layout *\nBLK_LO2EXT(struct pnfs_layout_hdr *lo)\n{\n\treturn container_of(lo, struct pnfs_block_layout, bl_layout);\n}",
          "includes": [
            "#include \"../netns.h\"",
            "#include \"../pnfs.h\"",
            "#include \"../nfs4_fs.h\"",
            "#include <linux/sunrpc/rpc_pipe_fs.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/device-mapper.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../netns.h\"\n#include \"../pnfs.h\"\n#include \"../nfs4_fs.h\"\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <linux/nfs_fs.h>\n#include <linux/device-mapper.h>\n\nstatic inline struct pnfs_block_layout *\nBLK_LO2EXT(struct pnfs_layout_hdr *lo)\n{\n\treturn container_of(lo, struct pnfs_block_layout, bl_layout);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"blocklayout.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include \"../pnfs.h\"\n#include <linux/pagevec.h>\n#include <linux/prefetch.h>\n#include <linux/bio.h>\t\t/* struct bio */\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic void\nbl_return_range(struct pnfs_layout_hdr *lo,\n\t\tstruct pnfs_layout_range *range)\n{\n\tstruct pnfs_block_layout *bl = BLK_LO2EXT(lo);\n\tsector_t offset = range->offset >> SECTOR_SHIFT, end;\n\n\tif (range->offset % 8) {\n\t\tdprintk(\"%s: offset %lld not block size aligned\\n\",\n\t\t\t__func__, range->offset);\n\t\treturn;\n\t}\n\n\tif (range->length != NFS4_MAX_UINT64) {\n\t\tif (range->length % 8) {\n\t\t\tdprintk(\"%s: length %lld not block size aligned\\n\",\n\t\t\t\t__func__, range->length);\n\t\t\treturn;\n\t\t}\n\n\t\tend = offset + (range->length >> SECTOR_SHIFT);\n\t} else {\n\t\tend = round_down(NFS4_MAX_UINT64, PAGE_SIZE);\n\t}\n\n\text_tree_remove(bl, range->iomode & IOMODE_RW, offset, end);\n}"
  },
  {
    "function_name": "bl_alloc_lseg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/blocklayout/blocklayout.c",
    "lines": "599-689",
    "snippet": "static struct pnfs_layout_segment *\nbl_alloc_lseg(struct pnfs_layout_hdr *lo, struct nfs4_layoutget_res *lgr,\n\t\tgfp_t gfp_mask)\n{\n\tstruct layout_verification lv = {\n\t\t.mode = lgr->range.iomode,\n\t\t.start = lgr->range.offset >> SECTOR_SHIFT,\n\t\t.inval = lgr->range.offset >> SECTOR_SHIFT,\n\t\t.cowread = lgr->range.offset >> SECTOR_SHIFT,\n\t};\n\tstruct pnfs_block_layout *bl = BLK_LO2EXT(lo);\n\tstruct pnfs_layout_segment *lseg;\n\tstruct xdr_buf buf;\n\tstruct xdr_stream xdr;\n\tstruct page *scratch;\n\tint status, i;\n\tuint32_t count;\n\t__be32 *p;\n\tLIST_HEAD(extents);\n\n\tdprintk(\"---> %s\\n\", __func__);\n\n\tlseg = kzalloc(sizeof(*lseg), gfp_mask);\n\tif (!lseg)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tstatus = -ENOMEM;\n\tscratch = alloc_page(gfp_mask);\n\tif (!scratch)\n\t\tgoto out;\n\n\txdr_init_decode_pages(&xdr, &buf,\n\t\t\tlgr->layoutp->pages, lgr->layoutp->len);\n\txdr_set_scratch_buffer(&xdr, page_address(scratch), PAGE_SIZE);\n\n\tstatus = -EIO;\n\tp = xdr_inline_decode(&xdr, 4);\n\tif (unlikely(!p))\n\t\tgoto out_free_scratch;\n\n\tcount = be32_to_cpup(p++);\n\tdprintk(\"%s: number of extents %d\\n\", __func__, count);\n\n\t/*\n\t * Decode individual extents, putting them in temporary staging area\n\t * until whole layout is decoded to make error recovery easier.\n\t */\n\tfor (i = 0; i < count; i++) {\n\t\tstatus = bl_alloc_extent(&xdr, lo, &lv, &extents, gfp_mask);\n\t\tif (status)\n\t\t\tgoto process_extents;\n\t}\n\n\tif (lgr->range.offset + lgr->range.length !=\n\t\t\tlv.start << SECTOR_SHIFT) {\n\t\tdprintk(\"%s Final length mismatch\\n\", __func__);\n\t\tstatus = -EIO;\n\t\tgoto process_extents;\n\t}\n\n\tif (lv.start < lv.cowread) {\n\t\tdprintk(\"%s Final uncovered COW extent\\n\", __func__);\n\t\tstatus = -EIO;\n\t}\n\nprocess_extents:\n\twhile (!list_empty(&extents)) {\n\t\tstruct pnfs_block_extent *be =\n\t\t\tlist_first_entry(&extents, struct pnfs_block_extent,\n\t\t\t\t\t be_list);\n\t\tlist_del(&be->be_list);\n\n\t\tif (!status)\n\t\t\tstatus = ext_tree_insert(bl, be);\n\n\t\tif (status) {\n\t\t\tnfs4_put_deviceid_node(be->be_device);\n\t\t\tkfree(be);\n\t\t}\n\t}\n\nout_free_scratch:\n\t__free_page(scratch);\nout:\n\tdprintk(\"%s returns %d\\n\", __func__, status);\n\tif (status) {\n\t\tkfree(lseg);\n\t\treturn ERR_PTR(status);\n\t}\n\treturn lseg;\n}",
    "includes": [
      "#include \"blocklayout.h\"",
      "#include \"../internal.h\"",
      "#include \"../nfs4session.h\"",
      "#include \"../pnfs.h\"",
      "#include <linux/pagevec.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/bio.h>\t\t/* struct bio */",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "status"
          ],
          "line": 686
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "lseg"
          ],
          "line": 685
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s returns %d\\n\"",
            "__func__",
            "status"
          ],
          "line": 683
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__free_page",
          "args": [
            "scratch"
          ],
          "line": 681
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "be"
          ],
          "line": 676
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs4_put_deviceid_node",
          "args": [
            "be->be_device"
          ],
          "line": 675
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_put_deviceid_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs_dev.c",
          "lines": "271-278",
          "snippet": "bool\nnfs4_put_deviceid_node(struct nfs4_deviceid_node *d)\n{\n\tif (!atomic_dec_and_test(&d->ref))\n\t\treturn false;\n\td->ld->free_deviceid_node(d);\n\treturn true;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include \"nfs4session.h\"",
            "#include <linux/nfs_fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"internal.h\"\n#include \"nfs4session.h\"\n#include <linux/nfs_fs.h>\n#include <linux/export.h>\n\nbool\nnfs4_put_deviceid_node(struct nfs4_deviceid_node *d)\n{\n\tif (!atomic_dec_and_test(&d->ref))\n\t\treturn false;\n\td->ld->free_deviceid_node(d);\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext_tree_insert",
          "args": [
            "bl",
            "be"
          ],
          "line": 672
        },
        "resolved": true,
        "details": {
          "function_name": "ext_tree_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/blocklayout/extent_tree.c",
          "lines": "243-308",
          "snippet": "int\next_tree_insert(struct pnfs_block_layout *bl, struct pnfs_block_extent *new)\n{\n\tstruct pnfs_block_extent *be;\n\tstruct rb_root *root;\n\tint err = 0;\n\n\tswitch (new->be_state) {\n\tcase PNFS_BLOCK_READWRITE_DATA:\n\tcase PNFS_BLOCK_INVALID_DATA:\n\t\troot = &bl->bl_ext_rw;\n\t\tbreak;\n\tcase PNFS_BLOCK_READ_DATA:\n\tcase PNFS_BLOCK_NONE_DATA:\n\t\troot = &bl->bl_ext_ro;\n\t\tbreak;\n\tdefault:\n\t\tdprintk(\"invalid extent type\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tspin_lock(&bl->bl_ext_lock);\nretry:\n\tbe = __ext_tree_search(root, new->be_f_offset);\n\tif (!be || be->be_f_offset >= ext_f_end(new)) {\n\t\t__ext_tree_insert(root, new, true);\n\t} else if (new->be_f_offset >= be->be_f_offset) {\n\t\tif (ext_f_end(new) <= ext_f_end(be)) {\n\t\t\tnfs4_put_deviceid_node(new->be_device);\n\t\t\tkfree(new);\n\t\t} else {\n\t\t\tsector_t new_len = ext_f_end(new) - ext_f_end(be);\n\t\t\tsector_t diff = new->be_length - new_len;\n\n\t\t\tnew->be_f_offset += diff;\n\t\t\tnew->be_v_offset += diff;\n\t\t\tnew->be_length = new_len;\n\t\t\tgoto retry;\n\t\t}\n\t} else if (ext_f_end(new) <= ext_f_end(be)) {\n\t\tnew->be_length = be->be_f_offset - new->be_f_offset;\n\t\t__ext_tree_insert(root, new, true);\n\t} else {\n\t\tstruct pnfs_block_extent *split;\n\t\tsector_t new_len = ext_f_end(new) - ext_f_end(be);\n\t\tsector_t diff = new->be_length - new_len;\n\n\t\tsplit = kmemdup(new, sizeof(*new), GFP_ATOMIC);\n\t\tif (!split) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tsplit->be_length = be->be_f_offset - split->be_f_offset;\n\t\tsplit->be_device = nfs4_get_deviceid(new->be_device);\n\t\t__ext_tree_insert(root, split, true);\n\n\t\tnew->be_f_offset += diff;\n\t\tnew->be_v_offset += diff;\n\t\tnew->be_length = new_len;\n\t\tgoto retry;\n\t}\nout:\n\tspin_unlock(&bl->bl_ext_lock);\n\treturn err;\n}",
          "includes": [
            "#include \"blocklayout.h\"",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"blocklayout.h\"\n#include <linux/vmalloc.h>\n\nint\next_tree_insert(struct pnfs_block_layout *bl, struct pnfs_block_extent *new)\n{\n\tstruct pnfs_block_extent *be;\n\tstruct rb_root *root;\n\tint err = 0;\n\n\tswitch (new->be_state) {\n\tcase PNFS_BLOCK_READWRITE_DATA:\n\tcase PNFS_BLOCK_INVALID_DATA:\n\t\troot = &bl->bl_ext_rw;\n\t\tbreak;\n\tcase PNFS_BLOCK_READ_DATA:\n\tcase PNFS_BLOCK_NONE_DATA:\n\t\troot = &bl->bl_ext_ro;\n\t\tbreak;\n\tdefault:\n\t\tdprintk(\"invalid extent type\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tspin_lock(&bl->bl_ext_lock);\nretry:\n\tbe = __ext_tree_search(root, new->be_f_offset);\n\tif (!be || be->be_f_offset >= ext_f_end(new)) {\n\t\t__ext_tree_insert(root, new, true);\n\t} else if (new->be_f_offset >= be->be_f_offset) {\n\t\tif (ext_f_end(new) <= ext_f_end(be)) {\n\t\t\tnfs4_put_deviceid_node(new->be_device);\n\t\t\tkfree(new);\n\t\t} else {\n\t\t\tsector_t new_len = ext_f_end(new) - ext_f_end(be);\n\t\t\tsector_t diff = new->be_length - new_len;\n\n\t\t\tnew->be_f_offset += diff;\n\t\t\tnew->be_v_offset += diff;\n\t\t\tnew->be_length = new_len;\n\t\t\tgoto retry;\n\t\t}\n\t} else if (ext_f_end(new) <= ext_f_end(be)) {\n\t\tnew->be_length = be->be_f_offset - new->be_f_offset;\n\t\t__ext_tree_insert(root, new, true);\n\t} else {\n\t\tstruct pnfs_block_extent *split;\n\t\tsector_t new_len = ext_f_end(new) - ext_f_end(be);\n\t\tsector_t diff = new->be_length - new_len;\n\n\t\tsplit = kmemdup(new, sizeof(*new), GFP_ATOMIC);\n\t\tif (!split) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tsplit->be_length = be->be_f_offset - split->be_f_offset;\n\t\tsplit->be_device = nfs4_get_deviceid(new->be_device);\n\t\t__ext_tree_insert(root, split, true);\n\n\t\tnew->be_f_offset += diff;\n\t\tnew->be_v_offset += diff;\n\t\tnew->be_length = new_len;\n\t\tgoto retry;\n\t}\nout:\n\tspin_unlock(&bl->bl_ext_lock);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&be->be_list"
          ],
          "line": 669
        },
        "resolved": true,
        "details": {
          "function_name": "inode_sb_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "433-440",
          "snippet": "static inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\n__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_first_entry",
          "args": [
            "&extents",
            "structpnfs_block_extent",
            "be_list"
          ],
          "line": 667
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&extents"
          ],
          "line": 665
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s Final uncovered COW extent\\n\"",
            "__func__"
          ],
          "line": 660
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s Final length mismatch\\n\"",
            "__func__"
          ],
          "line": 654
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bl_alloc_extent",
          "args": [
            "&xdr",
            "lo",
            "&lv",
            "&extents",
            "gfp_mask"
          ],
          "line": 647
        },
        "resolved": true,
        "details": {
          "function_name": "bl_alloc_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/blocklayout/blocklayout.c",
          "lines": "544-597",
          "snippet": "static int\nbl_alloc_extent(struct xdr_stream *xdr, struct pnfs_layout_hdr *lo,\n\t\tstruct layout_verification *lv, struct list_head *extents,\n\t\tgfp_t gfp_mask)\n{\n\tstruct pnfs_block_extent *be;\n\tstruct nfs4_deviceid id;\n\tint error;\n\t__be32 *p;\n\n\tp = xdr_inline_decode(xdr, 28 + NFS4_DEVICEID4_SIZE);\n\tif (!p)\n\t\treturn -EIO;\n\n\tbe = kzalloc(sizeof(*be), GFP_NOFS);\n\tif (!be)\n\t\treturn -ENOMEM;\n\n\tmemcpy(&id, p, NFS4_DEVICEID4_SIZE);\n\tp += XDR_QUADLEN(NFS4_DEVICEID4_SIZE);\n\n\terror = -EIO;\n\tbe->be_device = nfs4_find_get_deviceid(NFS_SERVER(lo->plh_inode), &id,\n\t\t\t\t\t\tlo->plh_lc_cred, gfp_mask);\n\tif (!be->be_device)\n\t\tgoto out_free_be;\n\n\t/*\n\t * The next three values are read in as bytes, but stored in the\n\t * extent structure in 512-byte granularity.\n\t */\n\tif (decode_sector_number(&p, &be->be_f_offset) < 0)\n\t\tgoto out_put_deviceid;\n\tif (decode_sector_number(&p, &be->be_length) < 0)\n\t\tgoto out_put_deviceid;\n\tif (decode_sector_number(&p, &be->be_v_offset) < 0)\n\t\tgoto out_put_deviceid;\n\tbe->be_state = be32_to_cpup(p++);\n\n\terror = verify_extent(be, lv);\n\tif (error) {\n\t\tdprintk(\"%s: extent verification failed\\n\", __func__);\n\t\tgoto out_put_deviceid;\n\t}\n\n\tlist_add_tail(&be->be_list, extents);\n\treturn 0;\n\nout_put_deviceid:\n\tnfs4_put_deviceid_node(be->be_device);\nout_free_be:\n\tkfree(be);\n\treturn error;\n}",
          "includes": [
            "#include \"blocklayout.h\"",
            "#include \"../internal.h\"",
            "#include \"../nfs4session.h\"",
            "#include \"../pnfs.h\"",
            "#include <linux/pagevec.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/bio.h>\t\t/* struct bio */",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"blocklayout.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include \"../pnfs.h\"\n#include <linux/pagevec.h>\n#include <linux/prefetch.h>\n#include <linux/bio.h>\t\t/* struct bio */\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic int\nbl_alloc_extent(struct xdr_stream *xdr, struct pnfs_layout_hdr *lo,\n\t\tstruct layout_verification *lv, struct list_head *extents,\n\t\tgfp_t gfp_mask)\n{\n\tstruct pnfs_block_extent *be;\n\tstruct nfs4_deviceid id;\n\tint error;\n\t__be32 *p;\n\n\tp = xdr_inline_decode(xdr, 28 + NFS4_DEVICEID4_SIZE);\n\tif (!p)\n\t\treturn -EIO;\n\n\tbe = kzalloc(sizeof(*be), GFP_NOFS);\n\tif (!be)\n\t\treturn -ENOMEM;\n\n\tmemcpy(&id, p, NFS4_DEVICEID4_SIZE);\n\tp += XDR_QUADLEN(NFS4_DEVICEID4_SIZE);\n\n\terror = -EIO;\n\tbe->be_device = nfs4_find_get_deviceid(NFS_SERVER(lo->plh_inode), &id,\n\t\t\t\t\t\tlo->plh_lc_cred, gfp_mask);\n\tif (!be->be_device)\n\t\tgoto out_free_be;\n\n\t/*\n\t * The next three values are read in as bytes, but stored in the\n\t * extent structure in 512-byte granularity.\n\t */\n\tif (decode_sector_number(&p, &be->be_f_offset) < 0)\n\t\tgoto out_put_deviceid;\n\tif (decode_sector_number(&p, &be->be_length) < 0)\n\t\tgoto out_put_deviceid;\n\tif (decode_sector_number(&p, &be->be_v_offset) < 0)\n\t\tgoto out_put_deviceid;\n\tbe->be_state = be32_to_cpup(p++);\n\n\terror = verify_extent(be, lv);\n\tif (error) {\n\t\tdprintk(\"%s: extent verification failed\\n\", __func__);\n\t\tgoto out_put_deviceid;\n\t}\n\n\tlist_add_tail(&be->be_list, extents);\n\treturn 0;\n\nout_put_deviceid:\n\tnfs4_put_deviceid_node(be->be_device);\nout_free_be:\n\tkfree(be);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s: number of extents %d\\n\"",
            "__func__",
            "count"
          ],
          "line": 640
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!p"
          ],
          "line": 636
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_inline_decode",
          "args": [
            "&xdr",
            "4"
          ],
          "line": 635
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_set_scratch_buffer",
          "args": [
            "&xdr",
            "page_address(scratch)",
            "PAGE_SIZE"
          ],
          "line": 632
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "scratch"
          ],
          "line": 632
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_init_decode_pages",
          "args": [
            "&xdr",
            "&buf",
            "lgr->layoutp->pages",
            "lgr->layoutp->len"
          ],
          "line": 630
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_page",
          "args": [
            "gfp_mask"
          ],
          "line": 626
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_alloc_pagevec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
          "lines": "86-105",
          "snippet": "static void **dlm_alloc_pagevec(int pages)\n{\n\tvoid **vec = kmalloc(pages * sizeof(void *), GFP_KERNEL);\n\tint i;\n\n\tif (!vec)\n\t\treturn NULL;\n\n\tfor (i = 0; i < pages; i++)\n\t\tif (!(vec[i] = (void *)__get_free_page(GFP_KERNEL)))\n\t\t\tgoto out_free;\n\n\tmlog(0, \"Allocated DLM hash pagevec; %d pages (%lu expected), %lu buckets per page\\n\",\n\t     pages, (unsigned long)DLM_HASH_PAGES,\n\t     (unsigned long)DLM_BUCKETS_PER_PAGE);\n\treturn vec;\nout_free:\n\tdlm_free_pagevec(vec, i);\n\treturn NULL;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/debugfs.h>",
            "#include <linux/err.h>",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic void **dlm_alloc_pagevec(int pages)\n{\n\tvoid **vec = kmalloc(pages * sizeof(void *), GFP_KERNEL);\n\tint i;\n\n\tif (!vec)\n\t\treturn NULL;\n\n\tfor (i = 0; i < pages; i++)\n\t\tif (!(vec[i] = (void *)__get_free_page(GFP_KERNEL)))\n\t\t\tgoto out_free;\n\n\tmlog(0, \"Allocated DLM hash pagevec; %d pages (%lu expected), %lu buckets per page\\n\",\n\t     pages, (unsigned long)DLM_HASH_PAGES,\n\t     (unsigned long)DLM_BUCKETS_PER_PAGE);\n\treturn vec;\nout_free:\n\tdlm_free_pagevec(vec, i);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 623
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*lseg)",
            "gfp_mask"
          ],
          "line": 621
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"---> %s\\n\"",
            "__func__"
          ],
          "line": 619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_HEAD",
          "args": [
            "extents"
          ],
          "line": 617
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BLK_LO2EXT",
          "args": [
            "lo"
          ],
          "line": 609
        },
        "resolved": true,
        "details": {
          "function_name": "BLK_LO2EXT",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/blocklayout/blocklayout.h",
          "lines": "153-157",
          "snippet": "static inline struct pnfs_block_layout *\nBLK_LO2EXT(struct pnfs_layout_hdr *lo)\n{\n\treturn container_of(lo, struct pnfs_block_layout, bl_layout);\n}",
          "includes": [
            "#include \"../netns.h\"",
            "#include \"../pnfs.h\"",
            "#include \"../nfs4_fs.h\"",
            "#include <linux/sunrpc/rpc_pipe_fs.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/device-mapper.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../netns.h\"\n#include \"../pnfs.h\"\n#include \"../nfs4_fs.h\"\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <linux/nfs_fs.h>\n#include <linux/device-mapper.h>\n\nstatic inline struct pnfs_block_layout *\nBLK_LO2EXT(struct pnfs_layout_hdr *lo)\n{\n\treturn container_of(lo, struct pnfs_block_layout, bl_layout);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"blocklayout.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include \"../pnfs.h\"\n#include <linux/pagevec.h>\n#include <linux/prefetch.h>\n#include <linux/bio.h>\t\t/* struct bio */\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic struct pnfs_layout_segment *\nbl_alloc_lseg(struct pnfs_layout_hdr *lo, struct nfs4_layoutget_res *lgr,\n\t\tgfp_t gfp_mask)\n{\n\tstruct layout_verification lv = {\n\t\t.mode = lgr->range.iomode,\n\t\t.start = lgr->range.offset >> SECTOR_SHIFT,\n\t\t.inval = lgr->range.offset >> SECTOR_SHIFT,\n\t\t.cowread = lgr->range.offset >> SECTOR_SHIFT,\n\t};\n\tstruct pnfs_block_layout *bl = BLK_LO2EXT(lo);\n\tstruct pnfs_layout_segment *lseg;\n\tstruct xdr_buf buf;\n\tstruct xdr_stream xdr;\n\tstruct page *scratch;\n\tint status, i;\n\tuint32_t count;\n\t__be32 *p;\n\tLIST_HEAD(extents);\n\n\tdprintk(\"---> %s\\n\", __func__);\n\n\tlseg = kzalloc(sizeof(*lseg), gfp_mask);\n\tif (!lseg)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tstatus = -ENOMEM;\n\tscratch = alloc_page(gfp_mask);\n\tif (!scratch)\n\t\tgoto out;\n\n\txdr_init_decode_pages(&xdr, &buf,\n\t\t\tlgr->layoutp->pages, lgr->layoutp->len);\n\txdr_set_scratch_buffer(&xdr, page_address(scratch), PAGE_SIZE);\n\n\tstatus = -EIO;\n\tp = xdr_inline_decode(&xdr, 4);\n\tif (unlikely(!p))\n\t\tgoto out_free_scratch;\n\n\tcount = be32_to_cpup(p++);\n\tdprintk(\"%s: number of extents %d\\n\", __func__, count);\n\n\t/*\n\t * Decode individual extents, putting them in temporary staging area\n\t * until whole layout is decoded to make error recovery easier.\n\t */\n\tfor (i = 0; i < count; i++) {\n\t\tstatus = bl_alloc_extent(&xdr, lo, &lv, &extents, gfp_mask);\n\t\tif (status)\n\t\t\tgoto process_extents;\n\t}\n\n\tif (lgr->range.offset + lgr->range.length !=\n\t\t\tlv.start << SECTOR_SHIFT) {\n\t\tdprintk(\"%s Final length mismatch\\n\", __func__);\n\t\tstatus = -EIO;\n\t\tgoto process_extents;\n\t}\n\n\tif (lv.start < lv.cowread) {\n\t\tdprintk(\"%s Final uncovered COW extent\\n\", __func__);\n\t\tstatus = -EIO;\n\t}\n\nprocess_extents:\n\twhile (!list_empty(&extents)) {\n\t\tstruct pnfs_block_extent *be =\n\t\t\tlist_first_entry(&extents, struct pnfs_block_extent,\n\t\t\t\t\t be_list);\n\t\tlist_del(&be->be_list);\n\n\t\tif (!status)\n\t\t\tstatus = ext_tree_insert(bl, be);\n\n\t\tif (status) {\n\t\t\tnfs4_put_deviceid_node(be->be_device);\n\t\t\tkfree(be);\n\t\t}\n\t}\n\nout_free_scratch:\n\t__free_page(scratch);\nout:\n\tdprintk(\"%s returns %d\\n\", __func__, status);\n\tif (status) {\n\t\tkfree(lseg);\n\t\treturn ERR_PTR(status);\n\t}\n\treturn lseg;\n}"
  },
  {
    "function_name": "bl_alloc_extent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/blocklayout/blocklayout.c",
    "lines": "544-597",
    "snippet": "static int\nbl_alloc_extent(struct xdr_stream *xdr, struct pnfs_layout_hdr *lo,\n\t\tstruct layout_verification *lv, struct list_head *extents,\n\t\tgfp_t gfp_mask)\n{\n\tstruct pnfs_block_extent *be;\n\tstruct nfs4_deviceid id;\n\tint error;\n\t__be32 *p;\n\n\tp = xdr_inline_decode(xdr, 28 + NFS4_DEVICEID4_SIZE);\n\tif (!p)\n\t\treturn -EIO;\n\n\tbe = kzalloc(sizeof(*be), GFP_NOFS);\n\tif (!be)\n\t\treturn -ENOMEM;\n\n\tmemcpy(&id, p, NFS4_DEVICEID4_SIZE);\n\tp += XDR_QUADLEN(NFS4_DEVICEID4_SIZE);\n\n\terror = -EIO;\n\tbe->be_device = nfs4_find_get_deviceid(NFS_SERVER(lo->plh_inode), &id,\n\t\t\t\t\t\tlo->plh_lc_cred, gfp_mask);\n\tif (!be->be_device)\n\t\tgoto out_free_be;\n\n\t/*\n\t * The next three values are read in as bytes, but stored in the\n\t * extent structure in 512-byte granularity.\n\t */\n\tif (decode_sector_number(&p, &be->be_f_offset) < 0)\n\t\tgoto out_put_deviceid;\n\tif (decode_sector_number(&p, &be->be_length) < 0)\n\t\tgoto out_put_deviceid;\n\tif (decode_sector_number(&p, &be->be_v_offset) < 0)\n\t\tgoto out_put_deviceid;\n\tbe->be_state = be32_to_cpup(p++);\n\n\terror = verify_extent(be, lv);\n\tif (error) {\n\t\tdprintk(\"%s: extent verification failed\\n\", __func__);\n\t\tgoto out_put_deviceid;\n\t}\n\n\tlist_add_tail(&be->be_list, extents);\n\treturn 0;\n\nout_put_deviceid:\n\tnfs4_put_deviceid_node(be->be_device);\nout_free_be:\n\tkfree(be);\n\treturn error;\n}",
    "includes": [
      "#include \"blocklayout.h\"",
      "#include \"../internal.h\"",
      "#include \"../nfs4session.h\"",
      "#include \"../pnfs.h\"",
      "#include <linux/pagevec.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/bio.h>\t\t/* struct bio */",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "be"
          ],
          "line": 595
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs4_put_deviceid_node",
          "args": [
            "be->be_device"
          ],
          "line": 593
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_put_deviceid_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs_dev.c",
          "lines": "271-278",
          "snippet": "bool\nnfs4_put_deviceid_node(struct nfs4_deviceid_node *d)\n{\n\tif (!atomic_dec_and_test(&d->ref))\n\t\treturn false;\n\td->ld->free_deviceid_node(d);\n\treturn true;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include \"nfs4session.h\"",
            "#include <linux/nfs_fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"internal.h\"\n#include \"nfs4session.h\"\n#include <linux/nfs_fs.h>\n#include <linux/export.h>\n\nbool\nnfs4_put_deviceid_node(struct nfs4_deviceid_node *d)\n{\n\tif (!atomic_dec_and_test(&d->ref))\n\t\treturn false;\n\td->ld->free_deviceid_node(d);\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&be->be_list",
            "extents"
          ],
          "line": 589
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s: extent verification failed\\n\"",
            "__func__"
          ],
          "line": 585
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "verify_extent",
          "args": [
            "be",
            "lv"
          ],
          "line": 583
        },
        "resolved": true,
        "details": {
          "function_name": "verify_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/blocklayout/blocklayout.c",
          "lines": "488-529",
          "snippet": "static int verify_extent(struct pnfs_block_extent *be,\n\t\t\t struct layout_verification *lv)\n{\n\tif (lv->mode == IOMODE_READ) {\n\t\tif (be->be_state == PNFS_BLOCK_READWRITE_DATA ||\n\t\t    be->be_state == PNFS_BLOCK_INVALID_DATA)\n\t\t\treturn -EIO;\n\t\tif (be->be_f_offset != lv->start)\n\t\t\treturn -EIO;\n\t\tlv->start += be->be_length;\n\t\treturn 0;\n\t}\n\t/* lv->mode == IOMODE_RW */\n\tif (be->be_state == PNFS_BLOCK_READWRITE_DATA) {\n\t\tif (be->be_f_offset != lv->start)\n\t\t\treturn -EIO;\n\t\tif (lv->cowread > lv->start)\n\t\t\treturn -EIO;\n\t\tlv->start += be->be_length;\n\t\tlv->inval = lv->start;\n\t\treturn 0;\n\t} else if (be->be_state == PNFS_BLOCK_INVALID_DATA) {\n\t\tif (be->be_f_offset != lv->start)\n\t\t\treturn -EIO;\n\t\tlv->start += be->be_length;\n\t\treturn 0;\n\t} else if (be->be_state == PNFS_BLOCK_READ_DATA) {\n\t\tif (be->be_f_offset > lv->start)\n\t\t\treturn -EIO;\n\t\tif (be->be_f_offset < lv->inval)\n\t\t\treturn -EIO;\n\t\tif (be->be_f_offset < lv->cowread)\n\t\t\treturn -EIO;\n\t\t/* It looks like you might want to min this with lv->start,\n\t\t * but you really don't.\n\t\t */\n\t\tlv->inval = lv->inval + be->be_length;\n\t\tlv->cowread = be->be_f_offset + be->be_length;\n\t\treturn 0;\n\t} else\n\t\treturn -EIO;\n}",
          "includes": [
            "#include \"blocklayout.h\"",
            "#include \"../internal.h\"",
            "#include \"../nfs4session.h\"",
            "#include \"../pnfs.h\"",
            "#include <linux/pagevec.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/bio.h>\t\t/* struct bio */",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"blocklayout.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include \"../pnfs.h\"\n#include <linux/pagevec.h>\n#include <linux/prefetch.h>\n#include <linux/bio.h>\t\t/* struct bio */\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic int verify_extent(struct pnfs_block_extent *be,\n\t\t\t struct layout_verification *lv)\n{\n\tif (lv->mode == IOMODE_READ) {\n\t\tif (be->be_state == PNFS_BLOCK_READWRITE_DATA ||\n\t\t    be->be_state == PNFS_BLOCK_INVALID_DATA)\n\t\t\treturn -EIO;\n\t\tif (be->be_f_offset != lv->start)\n\t\t\treturn -EIO;\n\t\tlv->start += be->be_length;\n\t\treturn 0;\n\t}\n\t/* lv->mode == IOMODE_RW */\n\tif (be->be_state == PNFS_BLOCK_READWRITE_DATA) {\n\t\tif (be->be_f_offset != lv->start)\n\t\t\treturn -EIO;\n\t\tif (lv->cowread > lv->start)\n\t\t\treturn -EIO;\n\t\tlv->start += be->be_length;\n\t\tlv->inval = lv->start;\n\t\treturn 0;\n\t} else if (be->be_state == PNFS_BLOCK_INVALID_DATA) {\n\t\tif (be->be_f_offset != lv->start)\n\t\t\treturn -EIO;\n\t\tlv->start += be->be_length;\n\t\treturn 0;\n\t} else if (be->be_state == PNFS_BLOCK_READ_DATA) {\n\t\tif (be->be_f_offset > lv->start)\n\t\t\treturn -EIO;\n\t\tif (be->be_f_offset < lv->inval)\n\t\t\treturn -EIO;\n\t\tif (be->be_f_offset < lv->cowread)\n\t\t\treturn -EIO;\n\t\t/* It looks like you might want to min this with lv->start,\n\t\t * but you really don't.\n\t\t */\n\t\tlv->inval = lv->inval + be->be_length;\n\t\tlv->cowread = be->be_f_offset + be->be_length;\n\t\treturn 0;\n\t} else\n\t\treturn -EIO;\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "decode_sector_number",
          "args": [
            "&p",
            "&be->be_v_offset"
          ],
          "line": 579
        },
        "resolved": true,
        "details": {
          "function_name": "decode_sector_number",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/blocklayout/blocklayout.c",
          "lines": "531-542",
          "snippet": "static int decode_sector_number(__be32 **rp, sector_t *sp)\n{\n\tuint64_t s;\n\n\t*rp = xdr_decode_hyper(*rp, &s);\n\tif (s & 0x1ff) {\n\t\tprintk(KERN_WARNING \"NFS: %s: sector not aligned\\n\", __func__);\n\t\treturn -1;\n\t}\n\t*sp = s >> SECTOR_SHIFT;\n\treturn 0;\n}",
          "includes": [
            "#include \"blocklayout.h\"",
            "#include \"../internal.h\"",
            "#include \"../nfs4session.h\"",
            "#include \"../pnfs.h\"",
            "#include <linux/pagevec.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/bio.h>\t\t/* struct bio */",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"blocklayout.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include \"../pnfs.h\"\n#include <linux/pagevec.h>\n#include <linux/prefetch.h>\n#include <linux/bio.h>\t\t/* struct bio */\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic int decode_sector_number(__be32 **rp, sector_t *sp)\n{\n\tuint64_t s;\n\n\t*rp = xdr_decode_hyper(*rp, &s);\n\tif (s & 0x1ff) {\n\t\tprintk(KERN_WARNING \"NFS: %s: sector not aligned\\n\", __func__);\n\t\treturn -1;\n\t}\n\t*sp = s >> SECTOR_SHIFT;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_find_get_deviceid",
          "args": [
            "NFS_SERVER(lo->plh_inode)",
            "&id",
            "lo->plh_lc_cred",
            "gfp_mask"
          ],
          "line": 566
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_find_get_deviceid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs_dev.c",
          "lines": "184-212",
          "snippet": "struct nfs4_deviceid_node *\nnfs4_find_get_deviceid(struct nfs_server *server,\n\t\tconst struct nfs4_deviceid *id, struct rpc_cred *cred,\n\t\tgfp_t gfp_mask)\n{\n\tlong hash = nfs4_deviceid_hash(id);\n\tstruct nfs4_deviceid_node *d, *new;\n\n\td = __nfs4_find_get_deviceid(server, id, hash);\n\tif (d)\n\t\treturn d;\n\n\tnew = nfs4_get_device_info(server, id, cred, gfp_mask);\n\tif (!new)\n\t\treturn new;\n\n\tspin_lock(&nfs4_deviceid_lock);\n\td = __nfs4_find_get_deviceid(server, id, hash);\n\tif (d) {\n\t\tspin_unlock(&nfs4_deviceid_lock);\n\t\tserver->pnfs_curr_ld->free_deviceid_node(new);\n\t\treturn d;\n\t}\n\thlist_add_head_rcu(&new->node, &nfs4_deviceid_cache[hash]);\n\tatomic_inc(&new->ref);\n\tspin_unlock(&nfs4_deviceid_lock);\n\n\treturn new;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include \"nfs4session.h\"",
            "#include <linux/nfs_fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_head nfs4_deviceid_cache[NFS4_DEVICE_ID_HASH_SIZE];",
            "static DEFINE_SPINLOCK(nfs4_deviceid_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"internal.h\"\n#include \"nfs4session.h\"\n#include <linux/nfs_fs.h>\n#include <linux/export.h>\n\nstatic struct hlist_head nfs4_deviceid_cache[NFS4_DEVICE_ID_HASH_SIZE];\nstatic DEFINE_SPINLOCK(nfs4_deviceid_lock);\n\nstruct nfs4_deviceid_node *\nnfs4_find_get_deviceid(struct nfs_server *server,\n\t\tconst struct nfs4_deviceid *id, struct rpc_cred *cred,\n\t\tgfp_t gfp_mask)\n{\n\tlong hash = nfs4_deviceid_hash(id);\n\tstruct nfs4_deviceid_node *d, *new;\n\n\td = __nfs4_find_get_deviceid(server, id, hash);\n\tif (d)\n\t\treturn d;\n\n\tnew = nfs4_get_device_info(server, id, cred, gfp_mask);\n\tif (!new)\n\t\treturn new;\n\n\tspin_lock(&nfs4_deviceid_lock);\n\td = __nfs4_find_get_deviceid(server, id, hash);\n\tif (d) {\n\t\tspin_unlock(&nfs4_deviceid_lock);\n\t\tserver->pnfs_curr_ld->free_deviceid_node(new);\n\t\treturn d;\n\t}\n\thlist_add_head_rcu(&new->node, &nfs4_deviceid_cache[hash]);\n\tatomic_inc(&new->ref);\n\tspin_unlock(&nfs4_deviceid_lock);\n\n\treturn new;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NFS_SERVER",
          "args": [
            "lo->plh_inode"
          ],
          "line": 566
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XDR_QUADLEN",
          "args": [
            "NFS4_DEVICEID4_SIZE"
          ],
          "line": 563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&id",
            "p",
            "NFS4_DEVICEID4_SIZE"
          ],
          "line": 562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*be)",
            "GFP_NOFS"
          ],
          "line": 558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_inline_decode",
          "args": [
            "xdr",
            "28 + NFS4_DEVICEID4_SIZE"
          ],
          "line": 554
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"blocklayout.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include \"../pnfs.h\"\n#include <linux/pagevec.h>\n#include <linux/prefetch.h>\n#include <linux/bio.h>\t\t/* struct bio */\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic int\nbl_alloc_extent(struct xdr_stream *xdr, struct pnfs_layout_hdr *lo,\n\t\tstruct layout_verification *lv, struct list_head *extents,\n\t\tgfp_t gfp_mask)\n{\n\tstruct pnfs_block_extent *be;\n\tstruct nfs4_deviceid id;\n\tint error;\n\t__be32 *p;\n\n\tp = xdr_inline_decode(xdr, 28 + NFS4_DEVICEID4_SIZE);\n\tif (!p)\n\t\treturn -EIO;\n\n\tbe = kzalloc(sizeof(*be), GFP_NOFS);\n\tif (!be)\n\t\treturn -ENOMEM;\n\n\tmemcpy(&id, p, NFS4_DEVICEID4_SIZE);\n\tp += XDR_QUADLEN(NFS4_DEVICEID4_SIZE);\n\n\terror = -EIO;\n\tbe->be_device = nfs4_find_get_deviceid(NFS_SERVER(lo->plh_inode), &id,\n\t\t\t\t\t\tlo->plh_lc_cred, gfp_mask);\n\tif (!be->be_device)\n\t\tgoto out_free_be;\n\n\t/*\n\t * The next three values are read in as bytes, but stored in the\n\t * extent structure in 512-byte granularity.\n\t */\n\tif (decode_sector_number(&p, &be->be_f_offset) < 0)\n\t\tgoto out_put_deviceid;\n\tif (decode_sector_number(&p, &be->be_length) < 0)\n\t\tgoto out_put_deviceid;\n\tif (decode_sector_number(&p, &be->be_v_offset) < 0)\n\t\tgoto out_put_deviceid;\n\tbe->be_state = be32_to_cpup(p++);\n\n\terror = verify_extent(be, lv);\n\tif (error) {\n\t\tdprintk(\"%s: extent verification failed\\n\", __func__);\n\t\tgoto out_put_deviceid;\n\t}\n\n\tlist_add_tail(&be->be_list, extents);\n\treturn 0;\n\nout_put_deviceid:\n\tnfs4_put_deviceid_node(be->be_device);\nout_free_be:\n\tkfree(be);\n\treturn error;\n}"
  },
  {
    "function_name": "decode_sector_number",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/blocklayout/blocklayout.c",
    "lines": "531-542",
    "snippet": "static int decode_sector_number(__be32 **rp, sector_t *sp)\n{\n\tuint64_t s;\n\n\t*rp = xdr_decode_hyper(*rp, &s);\n\tif (s & 0x1ff) {\n\t\tprintk(KERN_WARNING \"NFS: %s: sector not aligned\\n\", __func__);\n\t\treturn -1;\n\t}\n\t*sp = s >> SECTOR_SHIFT;\n\treturn 0;\n}",
    "includes": [
      "#include \"blocklayout.h\"",
      "#include \"../internal.h\"",
      "#include \"../nfs4session.h\"",
      "#include \"../pnfs.h\"",
      "#include <linux/pagevec.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/bio.h>\t\t/* struct bio */",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_WARNING \"NFS: %s: sector not aligned\\n\"",
            "__func__"
          ],
          "line": 537
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xdr_decode_hyper",
          "args": [
            "*rp",
            "&s"
          ],
          "line": 535
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"blocklayout.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include \"../pnfs.h\"\n#include <linux/pagevec.h>\n#include <linux/prefetch.h>\n#include <linux/bio.h>\t\t/* struct bio */\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic int decode_sector_number(__be32 **rp, sector_t *sp)\n{\n\tuint64_t s;\n\n\t*rp = xdr_decode_hyper(*rp, &s);\n\tif (s & 0x1ff) {\n\t\tprintk(KERN_WARNING \"NFS: %s: sector not aligned\\n\", __func__);\n\t\treturn -1;\n\t}\n\t*sp = s >> SECTOR_SHIFT;\n\treturn 0;\n}"
  },
  {
    "function_name": "verify_extent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/blocklayout/blocklayout.c",
    "lines": "488-529",
    "snippet": "static int verify_extent(struct pnfs_block_extent *be,\n\t\t\t struct layout_verification *lv)\n{\n\tif (lv->mode == IOMODE_READ) {\n\t\tif (be->be_state == PNFS_BLOCK_READWRITE_DATA ||\n\t\t    be->be_state == PNFS_BLOCK_INVALID_DATA)\n\t\t\treturn -EIO;\n\t\tif (be->be_f_offset != lv->start)\n\t\t\treturn -EIO;\n\t\tlv->start += be->be_length;\n\t\treturn 0;\n\t}\n\t/* lv->mode == IOMODE_RW */\n\tif (be->be_state == PNFS_BLOCK_READWRITE_DATA) {\n\t\tif (be->be_f_offset != lv->start)\n\t\t\treturn -EIO;\n\t\tif (lv->cowread > lv->start)\n\t\t\treturn -EIO;\n\t\tlv->start += be->be_length;\n\t\tlv->inval = lv->start;\n\t\treturn 0;\n\t} else if (be->be_state == PNFS_BLOCK_INVALID_DATA) {\n\t\tif (be->be_f_offset != lv->start)\n\t\t\treturn -EIO;\n\t\tlv->start += be->be_length;\n\t\treturn 0;\n\t} else if (be->be_state == PNFS_BLOCK_READ_DATA) {\n\t\tif (be->be_f_offset > lv->start)\n\t\t\treturn -EIO;\n\t\tif (be->be_f_offset < lv->inval)\n\t\t\treturn -EIO;\n\t\tif (be->be_f_offset < lv->cowread)\n\t\t\treturn -EIO;\n\t\t/* It looks like you might want to min this with lv->start,\n\t\t * but you really don't.\n\t\t */\n\t\tlv->inval = lv->inval + be->be_length;\n\t\tlv->cowread = be->be_f_offset + be->be_length;\n\t\treturn 0;\n\t} else\n\t\treturn -EIO;\n}",
    "includes": [
      "#include \"blocklayout.h\"",
      "#include \"../internal.h\"",
      "#include \"../nfs4session.h\"",
      "#include \"../pnfs.h\"",
      "#include <linux/pagevec.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/bio.h>\t\t/* struct bio */",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"blocklayout.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include \"../pnfs.h\"\n#include <linux/pagevec.h>\n#include <linux/prefetch.h>\n#include <linux/bio.h>\t\t/* struct bio */\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic int verify_extent(struct pnfs_block_extent *be,\n\t\t\t struct layout_verification *lv)\n{\n\tif (lv->mode == IOMODE_READ) {\n\t\tif (be->be_state == PNFS_BLOCK_READWRITE_DATA ||\n\t\t    be->be_state == PNFS_BLOCK_INVALID_DATA)\n\t\t\treturn -EIO;\n\t\tif (be->be_f_offset != lv->start)\n\t\t\treturn -EIO;\n\t\tlv->start += be->be_length;\n\t\treturn 0;\n\t}\n\t/* lv->mode == IOMODE_RW */\n\tif (be->be_state == PNFS_BLOCK_READWRITE_DATA) {\n\t\tif (be->be_f_offset != lv->start)\n\t\t\treturn -EIO;\n\t\tif (lv->cowread > lv->start)\n\t\t\treturn -EIO;\n\t\tlv->start += be->be_length;\n\t\tlv->inval = lv->start;\n\t\treturn 0;\n\t} else if (be->be_state == PNFS_BLOCK_INVALID_DATA) {\n\t\tif (be->be_f_offset != lv->start)\n\t\t\treturn -EIO;\n\t\tlv->start += be->be_length;\n\t\treturn 0;\n\t} else if (be->be_state == PNFS_BLOCK_READ_DATA) {\n\t\tif (be->be_f_offset > lv->start)\n\t\t\treturn -EIO;\n\t\tif (be->be_f_offset < lv->inval)\n\t\t\treturn -EIO;\n\t\tif (be->be_f_offset < lv->cowread)\n\t\t\treturn -EIO;\n\t\t/* It looks like you might want to min this with lv->start,\n\t\t * but you really don't.\n\t\t */\n\t\tlv->inval = lv->inval + be->be_length;\n\t\tlv->cowread = be->be_f_offset + be->be_length;\n\t\treturn 0;\n\t} else\n\t\treturn -EIO;\n}"
  },
  {
    "function_name": "bl_free_lseg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/blocklayout/blocklayout.c",
    "lines": "471-475",
    "snippet": "static void bl_free_lseg(struct pnfs_layout_segment *lseg)\n{\n\tdprintk(\"%s enter\\n\", __func__);\n\tkfree(lseg);\n}",
    "includes": [
      "#include \"blocklayout.h\"",
      "#include \"../internal.h\"",
      "#include \"../nfs4session.h\"",
      "#include \"../pnfs.h\"",
      "#include <linux/pagevec.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/bio.h>\t\t/* struct bio */",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "lseg"
          ],
          "line": 474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s enter\\n\"",
            "__func__"
          ],
          "line": 473
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"blocklayout.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include \"../pnfs.h\"\n#include <linux/pagevec.h>\n#include <linux/prefetch.h>\n#include <linux/bio.h>\t\t/* struct bio */\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic void bl_free_lseg(struct pnfs_layout_segment *lseg)\n{\n\tdprintk(\"%s enter\\n\", __func__);\n\tkfree(lseg);\n}"
  },
  {
    "function_name": "bl_alloc_layout_hdr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/blocklayout/blocklayout.c",
    "lines": "454-469",
    "snippet": "static struct pnfs_layout_hdr *bl_alloc_layout_hdr(struct inode *inode,\n\t\t\t\t\t\t   gfp_t gfp_flags)\n{\n\tstruct pnfs_block_layout *bl;\n\n\tdprintk(\"%s enter\\n\", __func__);\n\tbl = kzalloc(sizeof(*bl), gfp_flags);\n\tif (!bl)\n\t\treturn NULL;\n\n\tbl->bl_ext_rw = RB_ROOT;\n\tbl->bl_ext_ro = RB_ROOT;\n\tspin_lock_init(&bl->bl_ext_lock);\n\n\treturn &bl->bl_layout;\n}",
    "includes": [
      "#include \"blocklayout.h\"",
      "#include \"../internal.h\"",
      "#include \"../nfs4session.h\"",
      "#include \"../pnfs.h\"",
      "#include <linux/pagevec.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/bio.h>\t\t/* struct bio */",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&bl->bl_ext_lock"
          ],
          "line": 466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*bl)",
            "gfp_flags"
          ],
          "line": 460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s enter\\n\"",
            "__func__"
          ],
          "line": 459
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"blocklayout.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include \"../pnfs.h\"\n#include <linux/pagevec.h>\n#include <linux/prefetch.h>\n#include <linux/bio.h>\t\t/* struct bio */\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic struct pnfs_layout_hdr *bl_alloc_layout_hdr(struct inode *inode,\n\t\t\t\t\t\t   gfp_t gfp_flags)\n{\n\tstruct pnfs_block_layout *bl;\n\n\tdprintk(\"%s enter\\n\", __func__);\n\tbl = kzalloc(sizeof(*bl), gfp_flags);\n\tif (!bl)\n\t\treturn NULL;\n\n\tbl->bl_ext_rw = RB_ROOT;\n\tbl->bl_ext_ro = RB_ROOT;\n\tspin_lock_init(&bl->bl_ext_lock);\n\n\treturn &bl->bl_layout;\n}"
  },
  {
    "function_name": "bl_free_layout_hdr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/blocklayout/blocklayout.c",
    "lines": "441-452",
    "snippet": "static void bl_free_layout_hdr(struct pnfs_layout_hdr *lo)\n{\n\tstruct pnfs_block_layout *bl = BLK_LO2EXT(lo);\n\tint err;\n\n\tdprintk(\"%s enter\\n\", __func__);\n\n\terr = ext_tree_remove(bl, true, 0, LLONG_MAX);\n\tWARN_ON(err);\n\n\tkfree(bl);\n}",
    "includes": [
      "#include \"blocklayout.h\"",
      "#include \"../internal.h\"",
      "#include \"../nfs4session.h\"",
      "#include \"../pnfs.h\"",
      "#include <linux/pagevec.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/bio.h>\t\t/* struct bio */",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "bl"
          ],
          "line": 451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "err"
          ],
          "line": 449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext_tree_remove",
          "args": [
            "bl",
            "true",
            "0",
            "LLONG_MAX"
          ],
          "line": 448
        },
        "resolved": true,
        "details": {
          "function_name": "ext_tree_remove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/blocklayout/extent_tree.c",
          "lines": "349-364",
          "snippet": "int ext_tree_remove(struct pnfs_block_layout *bl, bool rw,\n\t\tsector_t start, sector_t end)\n{\n\tint err, err2;\n\n\tspin_lock(&bl->bl_ext_lock);\n\terr = __ext_tree_remove(&bl->bl_ext_ro, start, end);\n\tif (rw) {\n\t\terr2 = __ext_tree_remove(&bl->bl_ext_rw, start, end);\n\t\tif (!err)\n\t\t\terr = err2;\n\t}\n\tspin_unlock(&bl->bl_ext_lock);\n\n\treturn err;\n}",
          "includes": [
            "#include \"blocklayout.h\"",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"blocklayout.h\"\n#include <linux/vmalloc.h>\n\nint ext_tree_remove(struct pnfs_block_layout *bl, bool rw,\n\t\tsector_t start, sector_t end)\n{\n\tint err, err2;\n\n\tspin_lock(&bl->bl_ext_lock);\n\terr = __ext_tree_remove(&bl->bl_ext_ro, start, end);\n\tif (rw) {\n\t\terr2 = __ext_tree_remove(&bl->bl_ext_rw, start, end);\n\t\tif (!err)\n\t\t\terr = err2;\n\t}\n\tspin_unlock(&bl->bl_ext_lock);\n\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s enter\\n\"",
            "__func__"
          ],
          "line": 446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BLK_LO2EXT",
          "args": [
            "lo"
          ],
          "line": 443
        },
        "resolved": true,
        "details": {
          "function_name": "BLK_LO2EXT",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/blocklayout/blocklayout.h",
          "lines": "153-157",
          "snippet": "static inline struct pnfs_block_layout *\nBLK_LO2EXT(struct pnfs_layout_hdr *lo)\n{\n\treturn container_of(lo, struct pnfs_block_layout, bl_layout);\n}",
          "includes": [
            "#include \"../netns.h\"",
            "#include \"../pnfs.h\"",
            "#include \"../nfs4_fs.h\"",
            "#include <linux/sunrpc/rpc_pipe_fs.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/device-mapper.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../netns.h\"\n#include \"../pnfs.h\"\n#include \"../nfs4_fs.h\"\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <linux/nfs_fs.h>\n#include <linux/device-mapper.h>\n\nstatic inline struct pnfs_block_layout *\nBLK_LO2EXT(struct pnfs_layout_hdr *lo)\n{\n\treturn container_of(lo, struct pnfs_block_layout, bl_layout);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"blocklayout.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include \"../pnfs.h\"\n#include <linux/pagevec.h>\n#include <linux/prefetch.h>\n#include <linux/bio.h>\t\t/* struct bio */\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic void bl_free_layout_hdr(struct pnfs_layout_hdr *lo)\n{\n\tstruct pnfs_block_layout *bl = BLK_LO2EXT(lo);\n\tint err;\n\n\tdprintk(\"%s enter\\n\", __func__);\n\n\terr = ext_tree_remove(bl, true, 0, LLONG_MAX);\n\tWARN_ON(err);\n\n\tkfree(bl);\n}"
  },
  {
    "function_name": "bl_write_pagelist",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/blocklayout/blocklayout.c",
    "lines": "369-439",
    "snippet": "static enum pnfs_try_status\nbl_write_pagelist(struct nfs_pgio_header *header, int sync)\n{\n\tstruct pnfs_block_layout *bl = BLK_LSEG2EXT(header->lseg);\n\tstruct pnfs_block_dev_map map = { .start = NFS4_MAX_UINT64 };\n\tstruct bio *bio = NULL;\n\tstruct pnfs_block_extent be;\n\tsector_t isect, extent_length = 0;\n\tstruct parallel_io *par = NULL;\n\tloff_t offset = header->args.offset;\n\tsize_t count = header->args.count;\n\tstruct page **pages = header->args.pages;\n\tint pg_index = header->args.pgbase >> PAGE_CACHE_SHIFT;\n\tunsigned int pg_len;\n\tstruct blk_plug plug;\n\tint i;\n\n\tdprintk(\"%s enter, %Zu@%lld\\n\", __func__, count, offset);\n\n\t/* At this point, header->page_aray is a (sequential) list of nfs_pages.\n\t * We want to write each, and if there is an error set pnfs_error\n\t * to have it redone using nfs.\n\t */\n\tpar = alloc_parallel(header);\n\tif (!par)\n\t\treturn PNFS_NOT_ATTEMPTED;\n\tpar->pnfs_callback = bl_end_par_io_write;\n\n\tblk_start_plug(&plug);\n\n\t/* we always write out the whole page */\n\toffset = offset & (loff_t)PAGE_CACHE_MASK;\n\tisect = offset >> SECTOR_SHIFT;\n\n\tfor (i = pg_index; i < header->page_array.npages; i++) {\n\t\tif (extent_length <= 0) {\n\t\t\t/* We've used up the previous extent */\n\t\t\tbio = bl_submit_bio(WRITE, bio);\n\t\t\t/* Get the next one */\n\t\t\tif (!ext_tree_lookup(bl, isect, &be, true)) {\n\t\t\t\theader->pnfs_error = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\textent_length = be.be_length - (isect - be.be_f_offset);\n\t\t}\n\n\t\tpg_len = PAGE_CACHE_SIZE;\n\t\tbio = do_add_page_to_bio(bio, header->page_array.npages - i,\n\t\t\t\t\t WRITE, isect, pages[i], &map, &be,\n\t\t\t\t\t bl_end_io_write, par,\n\t\t\t\t\t 0, &pg_len);\n\t\tif (IS_ERR(bio)) {\n\t\t\theader->pnfs_error = PTR_ERR(bio);\n\t\t\tbio = NULL;\n\t\t\tgoto out;\n\t\t}\n\n\t\toffset += pg_len;\n\t\tcount -= pg_len;\n\t\tisect += (pg_len >> SECTOR_SHIFT);\n\t\textent_length -= (pg_len >> SECTOR_SHIFT);\n\t}\n\n\theader->res.count = header->args.count;\nout:\n\tbl_submit_bio(WRITE, bio);\n\tblk_finish_plug(&plug);\n\tput_parallel(par);\n\treturn PNFS_ATTEMPTED;\n}",
    "includes": [
      "#include \"blocklayout.h\"",
      "#include \"../internal.h\"",
      "#include \"../nfs4session.h\"",
      "#include \"../pnfs.h\"",
      "#include <linux/pagevec.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/bio.h>\t\t/* struct bio */",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_parallel",
          "args": [
            "par"
          ],
          "line": 437
        },
        "resolved": true,
        "details": {
          "function_name": "put_parallel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/blocklayout/blocklayout.c",
          "lines": "99-102",
          "snippet": "static inline void put_parallel(struct parallel_io *p)\n{\n\tkref_put(&p->refcnt, destroy_parallel);\n}",
          "includes": [
            "#include \"blocklayout.h\"",
            "#include \"../internal.h\"",
            "#include \"../nfs4session.h\"",
            "#include \"../pnfs.h\"",
            "#include <linux/pagevec.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/bio.h>\t\t/* struct bio */",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"blocklayout.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include \"../pnfs.h\"\n#include <linux/pagevec.h>\n#include <linux/prefetch.h>\n#include <linux/bio.h>\t\t/* struct bio */\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic inline void put_parallel(struct parallel_io *p)\n{\n\tkref_put(&p->refcnt, destroy_parallel);\n}"
        }
      },
      {
        "call_info": {
          "callee": "blk_finish_plug",
          "args": [
            "&plug"
          ],
          "line": 436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bl_submit_bio",
          "args": [
            "WRITE",
            "bio"
          ],
          "line": 435
        },
        "resolved": true,
        "details": {
          "function_name": "bl_submit_bio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/blocklayout/blocklayout.c",
          "lines": "104-115",
          "snippet": "static struct bio *\nbl_submit_bio(int rw, struct bio *bio)\n{\n\tif (bio) {\n\t\tget_parallel(bio->bi_private);\n\t\tdprintk(\"%s submitting %s bio %u@%llu\\n\", __func__,\n\t\t\trw == READ ? \"read\" : \"write\", bio->bi_iter.bi_size,\n\t\t\t(unsigned long long)bio->bi_iter.bi_sector);\n\t\tsubmit_bio(rw, bio);\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"blocklayout.h\"",
            "#include \"../internal.h\"",
            "#include \"../nfs4session.h\"",
            "#include \"../pnfs.h\"",
            "#include <linux/pagevec.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/bio.h>\t\t/* struct bio */",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"blocklayout.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include \"../pnfs.h\"\n#include <linux/pagevec.h>\n#include <linux/prefetch.h>\n#include <linux/bio.h>\t\t/* struct bio */\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic struct bio *\nbl_submit_bio(int rw, struct bio *bio)\n{\n\tif (bio) {\n\t\tget_parallel(bio->bi_private);\n\t\tdprintk(\"%s submitting %s bio %u@%llu\\n\", __func__,\n\t\t\trw == READ ? \"read\" : \"write\", bio->bi_iter.bi_size,\n\t\t\t(unsigned long long)bio->bi_iter.bi_sector);\n\t\tsubmit_bio(rw, bio);\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "bio"
          ],
          "line": 422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "bio"
          ],
          "line": 421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_add_page_to_bio",
          "args": [
            "bio",
            "header->page_array.npages - i",
            "WRITE",
            "isect",
            "pages[i]",
            "&map",
            "&be",
            "bl_end_io_write",
            "par",
            "0",
            "&pg_len"
          ],
          "line": 417
        },
        "resolved": true,
        "details": {
          "function_name": "do_add_page_to_bio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/blocklayout/blocklayout.c",
          "lines": "139-184",
          "snippet": "static struct bio *\ndo_add_page_to_bio(struct bio *bio, int npg, int rw, sector_t isect,\n\t\tstruct page *page, struct pnfs_block_dev_map *map,\n\t\tstruct pnfs_block_extent *be,\n\t\tvoid (*end_io)(struct bio *, int err),\n\t\tstruct parallel_io *par, unsigned int offset, int *len)\n{\n\tstruct pnfs_block_dev *dev =\n\t\tcontainer_of(be->be_device, struct pnfs_block_dev, node);\n\tu64 disk_addr, end;\n\n\tdprintk(\"%s: npg %d rw %d isect %llu offset %u len %d\\n\", __func__,\n\t\tnpg, rw, (unsigned long long)isect, offset, *len);\n\n\t/* translate to device offset */\n\tisect += be->be_v_offset;\n\tisect -= be->be_f_offset;\n\n\t/* translate to physical disk offset */\n\tdisk_addr = (u64)isect << SECTOR_SHIFT;\n\tif (disk_addr < map->start || disk_addr >= map->start + map->len) {\n\t\tif (!dev->map(dev, disk_addr, map))\n\t\t\treturn ERR_PTR(-EIO);\n\t\tbio = bl_submit_bio(rw, bio);\n\t}\n\tdisk_addr += map->disk_offset;\n\tdisk_addr -= map->start;\n\n\t/* limit length to what the device mapping allows */\n\tend = disk_addr + *len;\n\tif (end >= map->start + map->len)\n\t\t*len = map->start + map->len - disk_addr;\n\nretry:\n\tif (!bio) {\n\t\tbio = bl_alloc_init_bio(npg, map->bdev,\n\t\t\t\tdisk_addr >> SECTOR_SHIFT, end_io, par);\n\t\tif (!bio)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\tif (bio_add_page(bio, page, *len, offset) < *len) {\n\t\tbio = bl_submit_bio(rw, bio);\n\t\tgoto retry;\n\t}\n\treturn bio;\n}",
          "includes": [
            "#include \"blocklayout.h\"",
            "#include \"../internal.h\"",
            "#include \"../nfs4session.h\"",
            "#include \"../pnfs.h\"",
            "#include <linux/pagevec.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/bio.h>\t\t/* struct bio */",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"blocklayout.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include \"../pnfs.h\"\n#include <linux/pagevec.h>\n#include <linux/prefetch.h>\n#include <linux/bio.h>\t\t/* struct bio */\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic struct bio *\ndo_add_page_to_bio(struct bio *bio, int npg, int rw, sector_t isect,\n\t\tstruct page *page, struct pnfs_block_dev_map *map,\n\t\tstruct pnfs_block_extent *be,\n\t\tvoid (*end_io)(struct bio *, int err),\n\t\tstruct parallel_io *par, unsigned int offset, int *len)\n{\n\tstruct pnfs_block_dev *dev =\n\t\tcontainer_of(be->be_device, struct pnfs_block_dev, node);\n\tu64 disk_addr, end;\n\n\tdprintk(\"%s: npg %d rw %d isect %llu offset %u len %d\\n\", __func__,\n\t\tnpg, rw, (unsigned long long)isect, offset, *len);\n\n\t/* translate to device offset */\n\tisect += be->be_v_offset;\n\tisect -= be->be_f_offset;\n\n\t/* translate to physical disk offset */\n\tdisk_addr = (u64)isect << SECTOR_SHIFT;\n\tif (disk_addr < map->start || disk_addr >= map->start + map->len) {\n\t\tif (!dev->map(dev, disk_addr, map))\n\t\t\treturn ERR_PTR(-EIO);\n\t\tbio = bl_submit_bio(rw, bio);\n\t}\n\tdisk_addr += map->disk_offset;\n\tdisk_addr -= map->start;\n\n\t/* limit length to what the device mapping allows */\n\tend = disk_addr + *len;\n\tif (end >= map->start + map->len)\n\t\t*len = map->start + map->len - disk_addr;\n\nretry:\n\tif (!bio) {\n\t\tbio = bl_alloc_init_bio(npg, map->bdev,\n\t\t\t\tdisk_addr >> SECTOR_SHIFT, end_io, par);\n\t\tif (!bio)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\tif (bio_add_page(bio, page, *len, offset) < *len) {\n\t\tbio = bl_submit_bio(rw, bio);\n\t\tgoto retry;\n\t}\n\treturn bio;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext_tree_lookup",
          "args": [
            "bl",
            "isect",
            "&be",
            "true"
          ],
          "line": 408
        },
        "resolved": true,
        "details": {
          "function_name": "ext_tree_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/blocklayout/extent_tree.c",
          "lines": "333-347",
          "snippet": "bool\next_tree_lookup(struct pnfs_block_layout *bl, sector_t isect,\n\t    struct pnfs_block_extent *ret, bool rw)\n{\n\tbool found = false;\n\n\tspin_lock(&bl->bl_ext_lock);\n\tif (!rw)\n\t\tfound = __ext_tree_lookup(&bl->bl_ext_ro, isect, ret);\n\tif (!found)\n\t\tfound = __ext_tree_lookup(&bl->bl_ext_rw, isect, ret);\n\tspin_unlock(&bl->bl_ext_lock);\n\n\treturn found;\n}",
          "includes": [
            "#include \"blocklayout.h\"",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"blocklayout.h\"\n#include <linux/vmalloc.h>\n\nbool\next_tree_lookup(struct pnfs_block_layout *bl, sector_t isect,\n\t    struct pnfs_block_extent *ret, bool rw)\n{\n\tbool found = false;\n\n\tspin_lock(&bl->bl_ext_lock);\n\tif (!rw)\n\t\tfound = __ext_tree_lookup(&bl->bl_ext_ro, isect, ret);\n\tif (!found)\n\t\tfound = __ext_tree_lookup(&bl->bl_ext_rw, isect, ret);\n\tspin_unlock(&bl->bl_ext_lock);\n\n\treturn found;\n}"
        }
      },
      {
        "call_info": {
          "callee": "blk_start_plug",
          "args": [
            "&plug"
          ],
          "line": 397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_parallel",
          "args": [
            "header"
          ],
          "line": 392
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_parallel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/blocklayout/blocklayout.c",
          "lines": "73-83",
          "snippet": "static inline struct parallel_io *alloc_parallel(void *data)\n{\n\tstruct parallel_io *rv;\n\n\trv  = kmalloc(sizeof(*rv), GFP_NOFS);\n\tif (rv) {\n\t\trv->data = data;\n\t\tkref_init(&rv->refcnt);\n\t}\n\treturn rv;\n}",
          "includes": [
            "#include \"blocklayout.h\"",
            "#include \"../internal.h\"",
            "#include \"../nfs4session.h\"",
            "#include \"../pnfs.h\"",
            "#include <linux/pagevec.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/bio.h>\t\t/* struct bio */",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"blocklayout.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include \"../pnfs.h\"\n#include <linux/pagevec.h>\n#include <linux/prefetch.h>\n#include <linux/bio.h>\t\t/* struct bio */\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic inline struct parallel_io *alloc_parallel(void *data)\n{\n\tstruct parallel_io *rv;\n\n\trv  = kmalloc(sizeof(*rv), GFP_NOFS);\n\tif (rv) {\n\t\trv->data = data;\n\t\tkref_init(&rv->refcnt);\n\t}\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s enter, %Zu@%lld\\n\"",
            "__func__",
            "count",
            "offset"
          ],
          "line": 386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BLK_LSEG2EXT",
          "args": [
            "header->lseg"
          ],
          "line": 372
        },
        "resolved": true,
        "details": {
          "function_name": "BLK_LSEG2EXT",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/blocklayout/blocklayout.h",
          "lines": "159-163",
          "snippet": "static inline struct pnfs_block_layout *\nBLK_LSEG2EXT(struct pnfs_layout_segment *lseg)\n{\n\treturn BLK_LO2EXT(lseg->pls_layout);\n}",
          "includes": [
            "#include \"../netns.h\"",
            "#include \"../pnfs.h\"",
            "#include \"../nfs4_fs.h\"",
            "#include <linux/sunrpc/rpc_pipe_fs.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/device-mapper.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../netns.h\"\n#include \"../pnfs.h\"\n#include \"../nfs4_fs.h\"\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <linux/nfs_fs.h>\n#include <linux/device-mapper.h>\n\nstatic inline struct pnfs_block_layout *\nBLK_LSEG2EXT(struct pnfs_layout_segment *lseg)\n{\n\treturn BLK_LO2EXT(lseg->pls_layout);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"blocklayout.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include \"../pnfs.h\"\n#include <linux/pagevec.h>\n#include <linux/prefetch.h>\n#include <linux/bio.h>\t\t/* struct bio */\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic enum pnfs_try_status\nbl_write_pagelist(struct nfs_pgio_header *header, int sync)\n{\n\tstruct pnfs_block_layout *bl = BLK_LSEG2EXT(header->lseg);\n\tstruct pnfs_block_dev_map map = { .start = NFS4_MAX_UINT64 };\n\tstruct bio *bio = NULL;\n\tstruct pnfs_block_extent be;\n\tsector_t isect, extent_length = 0;\n\tstruct parallel_io *par = NULL;\n\tloff_t offset = header->args.offset;\n\tsize_t count = header->args.count;\n\tstruct page **pages = header->args.pages;\n\tint pg_index = header->args.pgbase >> PAGE_CACHE_SHIFT;\n\tunsigned int pg_len;\n\tstruct blk_plug plug;\n\tint i;\n\n\tdprintk(\"%s enter, %Zu@%lld\\n\", __func__, count, offset);\n\n\t/* At this point, header->page_aray is a (sequential) list of nfs_pages.\n\t * We want to write each, and if there is an error set pnfs_error\n\t * to have it redone using nfs.\n\t */\n\tpar = alloc_parallel(header);\n\tif (!par)\n\t\treturn PNFS_NOT_ATTEMPTED;\n\tpar->pnfs_callback = bl_end_par_io_write;\n\n\tblk_start_plug(&plug);\n\n\t/* we always write out the whole page */\n\toffset = offset & (loff_t)PAGE_CACHE_MASK;\n\tisect = offset >> SECTOR_SHIFT;\n\n\tfor (i = pg_index; i < header->page_array.npages; i++) {\n\t\tif (extent_length <= 0) {\n\t\t\t/* We've used up the previous extent */\n\t\t\tbio = bl_submit_bio(WRITE, bio);\n\t\t\t/* Get the next one */\n\t\t\tif (!ext_tree_lookup(bl, isect, &be, true)) {\n\t\t\t\theader->pnfs_error = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\textent_length = be.be_length - (isect - be.be_f_offset);\n\t\t}\n\n\t\tpg_len = PAGE_CACHE_SIZE;\n\t\tbio = do_add_page_to_bio(bio, header->page_array.npages - i,\n\t\t\t\t\t WRITE, isect, pages[i], &map, &be,\n\t\t\t\t\t bl_end_io_write, par,\n\t\t\t\t\t 0, &pg_len);\n\t\tif (IS_ERR(bio)) {\n\t\t\theader->pnfs_error = PTR_ERR(bio);\n\t\t\tbio = NULL;\n\t\t\tgoto out;\n\t\t}\n\n\t\toffset += pg_len;\n\t\tcount -= pg_len;\n\t\tisect += (pg_len >> SECTOR_SHIFT);\n\t\textent_length -= (pg_len >> SECTOR_SHIFT);\n\t}\n\n\theader->res.count = header->args.count;\nout:\n\tbl_submit_bio(WRITE, bio);\n\tblk_finish_plug(&plug);\n\tput_parallel(par);\n\treturn PNFS_ATTEMPTED;\n}"
  },
  {
    "function_name": "bl_end_par_io_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/blocklayout/blocklayout.c",
    "lines": "359-367",
    "snippet": "static void bl_end_par_io_write(void *data)\n{\n\tstruct nfs_pgio_header *hdr = data;\n\n\thdr->task.tk_status = hdr->pnfs_error;\n\thdr->verf.committed = NFS_FILE_SYNC;\n\tINIT_WORK(&hdr->task.u.tk_work, bl_write_cleanup);\n\tschedule_work(&hdr->task.u.tk_work);\n}",
    "includes": [
      "#include \"blocklayout.h\"",
      "#include \"../internal.h\"",
      "#include \"../nfs4session.h\"",
      "#include \"../pnfs.h\"",
      "#include <linux/pagevec.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/bio.h>\t\t/* struct bio */",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "schedule_work",
          "args": [
            "&hdr->task.u.tk_work"
          ],
          "line": 366
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_direct_write_schedule_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/direct.c",
          "lines": "755-771",
          "snippet": "static void nfs_direct_write_schedule_work(struct work_struct *work)\n{\n\tstruct nfs_direct_req *dreq = container_of(work, struct nfs_direct_req, work);\n\tint flags = dreq->flags;\n\n\tdreq->flags = 0;\n\tswitch (flags) {\n\t\tcase NFS_ODIRECT_DO_COMMIT:\n\t\t\tnfs_direct_commit_schedule(dreq);\n\t\t\tbreak;\n\t\tcase NFS_ODIRECT_RESCHED_WRITES:\n\t\t\tnfs_direct_write_reschedule(dreq);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tnfs_direct_complete(dreq, true);\n\t}\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include <linux/atomic.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/slab.h>",
            "#include <linux/kref.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [
            "#define NFS_ODIRECT_RESCHED_WRITES\t(2)\t/* write verification failed */",
            "#define NFS_ODIRECT_DO_COMMIT\t\t(1)\t/* an unstable reply was received */"
          ],
          "globals_used": [
            "static void nfs_direct_write_schedule_work(struct work_struct *work);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include <linux/atomic.h>\n#include <asm/uaccess.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n#include <linux/module.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/slab.h>\n#include <linux/kref.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\n#define NFS_ODIRECT_RESCHED_WRITES\t(2)\t/* write verification failed */\n#define NFS_ODIRECT_DO_COMMIT\t\t(1)\t/* an unstable reply was received */\n\nstatic void nfs_direct_write_schedule_work(struct work_struct *work);\n\nstatic void nfs_direct_write_schedule_work(struct work_struct *work)\n{\n\tstruct nfs_direct_req *dreq = container_of(work, struct nfs_direct_req, work);\n\tint flags = dreq->flags;\n\n\tdreq->flags = 0;\n\tswitch (flags) {\n\t\tcase NFS_ODIRECT_DO_COMMIT:\n\t\t\tnfs_direct_commit_schedule(dreq);\n\t\t\tbreak;\n\t\tcase NFS_ODIRECT_RESCHED_WRITES:\n\t\t\tnfs_direct_write_reschedule(dreq);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tnfs_direct_complete(dreq, true);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_WORK",
          "args": [
            "&hdr->task.u.tk_work",
            "bl_write_cleanup"
          ],
          "line": 365
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"blocklayout.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include \"../pnfs.h\"\n#include <linux/pagevec.h>\n#include <linux/prefetch.h>\n#include <linux/bio.h>\t\t/* struct bio */\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic void bl_end_par_io_write(void *data)\n{\n\tstruct nfs_pgio_header *hdr = data;\n\n\thdr->task.tk_status = hdr->pnfs_error;\n\thdr->verf.committed = NFS_FILE_SYNC;\n\tINIT_WORK(&hdr->task.u.tk_work, bl_write_cleanup);\n\tschedule_work(&hdr->task.u.tk_work);\n}"
  },
  {
    "function_name": "bl_write_cleanup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/blocklayout/blocklayout.c",
    "lines": "337-356",
    "snippet": "static void bl_write_cleanup(struct work_struct *work)\n{\n\tstruct rpc_task *task = container_of(work, struct rpc_task, u.tk_work);\n\tstruct nfs_pgio_header *hdr =\n\t\t\tcontainer_of(task, struct nfs_pgio_header, task);\n\n\tdprintk(\"%s enter\\n\", __func__);\n\n\tif (likely(!hdr->pnfs_error)) {\n\t\tstruct pnfs_block_layout *bl = BLK_LSEG2EXT(hdr->lseg);\n\t\tu64 start = hdr->args.offset & (loff_t)PAGE_CACHE_MASK;\n\t\tu64 end = (hdr->args.offset + hdr->args.count +\n\t\t\tPAGE_CACHE_SIZE - 1) & (loff_t)PAGE_CACHE_MASK;\n\n\t\text_tree_mark_written(bl, start >> SECTOR_SHIFT,\n\t\t\t\t\t(end - start) >> SECTOR_SHIFT);\n\t}\n\n\tpnfs_ld_write_done(hdr);\n}",
    "includes": [
      "#include \"blocklayout.h\"",
      "#include \"../internal.h\"",
      "#include \"../nfs4session.h\"",
      "#include \"../pnfs.h\"",
      "#include <linux/pagevec.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/bio.h>\t\t/* struct bio */",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pnfs_ld_write_done",
          "args": [
            "hdr"
          ],
          "line": 355
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_ld_write_done",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
          "lines": "1840-1849",
          "snippet": "void pnfs_ld_write_done(struct nfs_pgio_header *hdr)\n{\n\ttrace_nfs4_pnfs_write(hdr, hdr->pnfs_error);\n\tif (!hdr->pnfs_error) {\n\t\tpnfs_set_layoutcommit(hdr);\n\t\thdr->mds_ops->rpc_call_done(&hdr->task, hdr);\n\t} else\n\t\tpnfs_ld_handle_write_error(hdr);\n\thdr->mds_ops->rpc_release(hdr);\n}",
          "includes": [
            "#include \"delegation.h\"",
            "#include \"nfs4trace.h\"",
            "#include \"iostat.h\"",
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nvoid pnfs_ld_write_done(struct nfs_pgio_header *hdr)\n{\n\ttrace_nfs4_pnfs_write(hdr, hdr->pnfs_error);\n\tif (!hdr->pnfs_error) {\n\t\tpnfs_set_layoutcommit(hdr);\n\t\thdr->mds_ops->rpc_call_done(&hdr->task, hdr);\n\t} else\n\t\tpnfs_ld_handle_write_error(hdr);\n\thdr->mds_ops->rpc_release(hdr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext_tree_mark_written",
          "args": [
            "bl",
            "start >> SECTOR_SHIFT",
            "(end - start) >> SECTOR_SHIFT"
          ],
          "line": 351
        },
        "resolved": true,
        "details": {
          "function_name": "ext_tree_mark_written",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/blocklayout/extent_tree.c",
          "lines": "391-463",
          "snippet": "int\next_tree_mark_written(struct pnfs_block_layout *bl, sector_t start,\n\t\tsector_t len)\n{\n\tstruct rb_root *root = &bl->bl_ext_rw;\n\tsector_t end = start + len;\n\tstruct pnfs_block_extent *be;\n\tint err = 0;\n\n\tspin_lock(&bl->bl_ext_lock);\n\t/*\n\t * First remove all COW extents or holes from written to range.\n\t */\n\terr = __ext_tree_remove(&bl->bl_ext_ro, start, end);\n\tif (err)\n\t\tgoto out;\n\n\t/*\n\t * Then mark all invalid extents in the range as written to.\n\t */\n\tfor (be = __ext_tree_search(root, start); be; be = ext_tree_next(be)) {\n\t\tif (be->be_f_offset >= end)\n\t\t\tbreak;\n\n\t\tif (be->be_state != PNFS_BLOCK_INVALID_DATA || be->be_tag)\n\t\t\tcontinue;\n\n\t\tif (be->be_f_offset < start) {\n\t\t\tstruct pnfs_block_extent *left = ext_tree_prev(be);\n\n\t\t\tif (left && ext_can_merge(left, be)) {\n\t\t\t\tsector_t diff = start - be->be_f_offset;\n\n\t\t\t\tleft->be_length += diff;\n\n\t\t\t\tbe->be_f_offset += diff;\n\t\t\t\tbe->be_v_offset += diff;\n\t\t\t\tbe->be_length -= diff;\n\t\t\t} else {\n\t\t\t\terr = ext_tree_split(root, be, start);\n\t\t\t\tif (err)\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\tif (ext_f_end(be) > end) {\n\t\t\tstruct pnfs_block_extent *right = ext_tree_next(be);\n\n\t\t\tif (right && ext_can_merge(be, right)) {\n\t\t\t\tsector_t diff = end - be->be_f_offset;\n\n\t\t\t\tbe->be_length -= diff;\n\n\t\t\t\tright->be_f_offset -= diff;\n\t\t\t\tright->be_v_offset -= diff;\n\t\t\t\tright->be_length += diff;\n\t\t\t} else {\n\t\t\t\terr = ext_tree_split(root, be, end);\n\t\t\t\tif (err)\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\tif (be->be_f_offset >= start && ext_f_end(be) <= end) {\n\t\t\tbe->be_tag = EXTENT_WRITTEN;\n\t\t\tbe = ext_try_to_merge_left(root, be);\n\t\t\tbe = ext_try_to_merge_right(root, be);\n\t\t}\n\t}\nout:\n\tspin_unlock(&bl->bl_ext_lock);\n\treturn err;\n}",
          "includes": [
            "#include \"blocklayout.h\"",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"blocklayout.h\"\n#include <linux/vmalloc.h>\n\nint\next_tree_mark_written(struct pnfs_block_layout *bl, sector_t start,\n\t\tsector_t len)\n{\n\tstruct rb_root *root = &bl->bl_ext_rw;\n\tsector_t end = start + len;\n\tstruct pnfs_block_extent *be;\n\tint err = 0;\n\n\tspin_lock(&bl->bl_ext_lock);\n\t/*\n\t * First remove all COW extents or holes from written to range.\n\t */\n\terr = __ext_tree_remove(&bl->bl_ext_ro, start, end);\n\tif (err)\n\t\tgoto out;\n\n\t/*\n\t * Then mark all invalid extents in the range as written to.\n\t */\n\tfor (be = __ext_tree_search(root, start); be; be = ext_tree_next(be)) {\n\t\tif (be->be_f_offset >= end)\n\t\t\tbreak;\n\n\t\tif (be->be_state != PNFS_BLOCK_INVALID_DATA || be->be_tag)\n\t\t\tcontinue;\n\n\t\tif (be->be_f_offset < start) {\n\t\t\tstruct pnfs_block_extent *left = ext_tree_prev(be);\n\n\t\t\tif (left && ext_can_merge(left, be)) {\n\t\t\t\tsector_t diff = start - be->be_f_offset;\n\n\t\t\t\tleft->be_length += diff;\n\n\t\t\t\tbe->be_f_offset += diff;\n\t\t\t\tbe->be_v_offset += diff;\n\t\t\t\tbe->be_length -= diff;\n\t\t\t} else {\n\t\t\t\terr = ext_tree_split(root, be, start);\n\t\t\t\tif (err)\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\tif (ext_f_end(be) > end) {\n\t\t\tstruct pnfs_block_extent *right = ext_tree_next(be);\n\n\t\t\tif (right && ext_can_merge(be, right)) {\n\t\t\t\tsector_t diff = end - be->be_f_offset;\n\n\t\t\t\tbe->be_length -= diff;\n\n\t\t\t\tright->be_f_offset -= diff;\n\t\t\t\tright->be_v_offset -= diff;\n\t\t\t\tright->be_length += diff;\n\t\t\t} else {\n\t\t\t\terr = ext_tree_split(root, be, end);\n\t\t\t\tif (err)\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\tif (be->be_f_offset >= start && ext_f_end(be) <= end) {\n\t\t\tbe->be_tag = EXTENT_WRITTEN;\n\t\t\tbe = ext_try_to_merge_left(root, be);\n\t\t\tbe = ext_try_to_merge_right(root, be);\n\t\t}\n\t}\nout:\n\tspin_unlock(&bl->bl_ext_lock);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BLK_LSEG2EXT",
          "args": [
            "hdr->lseg"
          ],
          "line": 346
        },
        "resolved": true,
        "details": {
          "function_name": "BLK_LSEG2EXT",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/blocklayout/blocklayout.h",
          "lines": "159-163",
          "snippet": "static inline struct pnfs_block_layout *\nBLK_LSEG2EXT(struct pnfs_layout_segment *lseg)\n{\n\treturn BLK_LO2EXT(lseg->pls_layout);\n}",
          "includes": [
            "#include \"../netns.h\"",
            "#include \"../pnfs.h\"",
            "#include \"../nfs4_fs.h\"",
            "#include <linux/sunrpc/rpc_pipe_fs.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/device-mapper.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../netns.h\"\n#include \"../pnfs.h\"\n#include \"../nfs4_fs.h\"\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <linux/nfs_fs.h>\n#include <linux/device-mapper.h>\n\nstatic inline struct pnfs_block_layout *\nBLK_LSEG2EXT(struct pnfs_layout_segment *lseg)\n{\n\treturn BLK_LO2EXT(lseg->pls_layout);\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "!hdr->pnfs_error"
          ],
          "line": 345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s enter\\n\"",
            "__func__"
          ],
          "line": 343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "task",
            "structnfs_pgio_header",
            "task"
          ],
          "line": 341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "work",
            "structrpc_task",
            "u.tk_work"
          ],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"blocklayout.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include \"../pnfs.h\"\n#include <linux/pagevec.h>\n#include <linux/prefetch.h>\n#include <linux/bio.h>\t\t/* struct bio */\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic void bl_write_cleanup(struct work_struct *work)\n{\n\tstruct rpc_task *task = container_of(work, struct rpc_task, u.tk_work);\n\tstruct nfs_pgio_header *hdr =\n\t\t\tcontainer_of(task, struct nfs_pgio_header, task);\n\n\tdprintk(\"%s enter\\n\", __func__);\n\n\tif (likely(!hdr->pnfs_error)) {\n\t\tstruct pnfs_block_layout *bl = BLK_LSEG2EXT(hdr->lseg);\n\t\tu64 start = hdr->args.offset & (loff_t)PAGE_CACHE_MASK;\n\t\tu64 end = (hdr->args.offset + hdr->args.count +\n\t\t\tPAGE_CACHE_SIZE - 1) & (loff_t)PAGE_CACHE_MASK;\n\n\t\text_tree_mark_written(bl, start >> SECTOR_SHIFT,\n\t\t\t\t\t(end - start) >> SECTOR_SHIFT);\n\t}\n\n\tpnfs_ld_write_done(hdr);\n}"
  },
  {
    "function_name": "bl_end_io_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/blocklayout/blocklayout.c",
    "lines": "319-332",
    "snippet": "static void bl_end_io_write(struct bio *bio, int err)\n{\n\tstruct parallel_io *par = bio->bi_private;\n\tconst int uptodate = test_bit(BIO_UPTODATE, &bio->bi_flags);\n\tstruct nfs_pgio_header *header = par->data;\n\n\tif (!uptodate) {\n\t\tif (!header->pnfs_error)\n\t\t\theader->pnfs_error = -EIO;\n\t\tpnfs_set_lo_fail(header->lseg);\n\t}\n\tbio_put(bio);\n\tput_parallel(par);\n}",
    "includes": [
      "#include \"blocklayout.h\"",
      "#include \"../internal.h\"",
      "#include \"../nfs4session.h\"",
      "#include \"../pnfs.h\"",
      "#include <linux/pagevec.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/bio.h>\t\t/* struct bio */",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_parallel",
          "args": [
            "par"
          ],
          "line": 331
        },
        "resolved": true,
        "details": {
          "function_name": "put_parallel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/blocklayout/blocklayout.c",
          "lines": "99-102",
          "snippet": "static inline void put_parallel(struct parallel_io *p)\n{\n\tkref_put(&p->refcnt, destroy_parallel);\n}",
          "includes": [
            "#include \"blocklayout.h\"",
            "#include \"../internal.h\"",
            "#include \"../nfs4session.h\"",
            "#include \"../pnfs.h\"",
            "#include <linux/pagevec.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/bio.h>\t\t/* struct bio */",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"blocklayout.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include \"../pnfs.h\"\n#include <linux/pagevec.h>\n#include <linux/prefetch.h>\n#include <linux/bio.h>\t\t/* struct bio */\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic inline void put_parallel(struct parallel_io *p)\n{\n\tkref_put(&p->refcnt, destroy_parallel);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bio_put",
          "args": [
            "bio"
          ],
          "line": 330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pnfs_set_lo_fail",
          "args": [
            "header->lseg"
          ],
          "line": 328
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_set_lo_fail",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
          "lines": "2095-2098",
          "snippet": "void pnfs_set_lo_fail(struct pnfs_layout_segment *lseg)\n{\n\tpnfs_layout_io_set_failed(lseg->pls_layout, lseg->pls_range.iomode);\n}",
          "includes": [
            "#include \"delegation.h\"",
            "#include \"nfs4trace.h\"",
            "#include \"iostat.h\"",
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nvoid pnfs_set_lo_fail(struct pnfs_layout_segment *lseg)\n{\n\tpnfs_layout_io_set_failed(lseg->pls_layout, lseg->pls_range.iomode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "BIO_UPTODATE",
            "&bio->bi_flags"
          ],
          "line": 322
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"blocklayout.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include \"../pnfs.h\"\n#include <linux/pagevec.h>\n#include <linux/prefetch.h>\n#include <linux/bio.h>\t\t/* struct bio */\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic void bl_end_io_write(struct bio *bio, int err)\n{\n\tstruct parallel_io *par = bio->bi_private;\n\tconst int uptodate = test_bit(BIO_UPTODATE, &bio->bi_flags);\n\tstruct nfs_pgio_header *header = par->data;\n\n\tif (!uptodate) {\n\t\tif (!header->pnfs_error)\n\t\t\theader->pnfs_error = -EIO;\n\t\tpnfs_set_lo_fail(header->lseg);\n\t}\n\tbio_put(bio);\n\tput_parallel(par);\n}"
  },
  {
    "function_name": "bl_read_pagelist",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/blocklayout/blocklayout.c",
    "lines": "222-317",
    "snippet": "static enum pnfs_try_status\nbl_read_pagelist(struct nfs_pgio_header *header)\n{\n\tstruct pnfs_block_layout *bl = BLK_LSEG2EXT(header->lseg);\n\tstruct pnfs_block_dev_map map = { .start = NFS4_MAX_UINT64 };\n\tstruct bio *bio = NULL;\n\tstruct pnfs_block_extent be;\n\tsector_t isect, extent_length = 0;\n\tstruct parallel_io *par;\n\tloff_t f_offset = header->args.offset;\n\tsize_t bytes_left = header->args.count;\n\tunsigned int pg_offset, pg_len;\n\tstruct page **pages = header->args.pages;\n\tint pg_index = header->args.pgbase >> PAGE_CACHE_SHIFT;\n\tconst bool is_dio = (header->dreq != NULL);\n\tstruct blk_plug plug;\n\tint i;\n\n\tdprintk(\"%s enter nr_pages %u offset %lld count %u\\n\", __func__,\n\t\theader->page_array.npages, f_offset,\n\t\t(unsigned int)header->args.count);\n\n\tpar = alloc_parallel(header);\n\tif (!par)\n\t\treturn PNFS_NOT_ATTEMPTED;\n\tpar->pnfs_callback = bl_end_par_io_read;\n\n\tblk_start_plug(&plug);\n\n\tisect = (sector_t) (f_offset >> SECTOR_SHIFT);\n\t/* Code assumes extents are page-aligned */\n\tfor (i = pg_index; i < header->page_array.npages; i++) {\n\t\tif (extent_length <= 0) {\n\t\t\t/* We've used up the previous extent */\n\t\t\tbio = bl_submit_bio(READ, bio);\n\n\t\t\t/* Get the next one */\n\t\t\tif (!ext_tree_lookup(bl, isect, &be, false)) {\n\t\t\t\theader->pnfs_error = -EIO;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\textent_length = be.be_length - (isect - be.be_f_offset);\n\t\t}\n\n\t\tpg_offset = f_offset & ~PAGE_CACHE_MASK;\n\t\tif (is_dio) {\n\t\t\tif (pg_offset + bytes_left > PAGE_CACHE_SIZE)\n\t\t\t\tpg_len = PAGE_CACHE_SIZE - pg_offset;\n\t\t\telse\n\t\t\t\tpg_len = bytes_left;\n\t\t} else {\n\t\t\tBUG_ON(pg_offset != 0);\n\t\t\tpg_len = PAGE_CACHE_SIZE;\n\t\t}\n\n\t\tisect += (pg_offset >> SECTOR_SHIFT);\n\t\textent_length -= (pg_offset >> SECTOR_SHIFT);\n\n\t\tif (is_hole(&be)) {\n\t\t\tbio = bl_submit_bio(READ, bio);\n\t\t\t/* Fill hole w/ zeroes w/o accessing device */\n\t\t\tdprintk(\"%s Zeroing page for hole\\n\", __func__);\n\t\t\tzero_user_segment(pages[i], pg_offset, pg_len);\n\n\t\t\t/* invalidate map */\n\t\t\tmap.start = NFS4_MAX_UINT64;\n\t\t} else {\n\t\t\tbio = do_add_page_to_bio(bio,\n\t\t\t\t\t\t header->page_array.npages - i,\n\t\t\t\t\t\t READ,\n\t\t\t\t\t\t isect, pages[i], &map, &be,\n\t\t\t\t\t\t bl_end_io_read, par,\n\t\t\t\t\t\t pg_offset, &pg_len);\n\t\t\tif (IS_ERR(bio)) {\n\t\t\t\theader->pnfs_error = PTR_ERR(bio);\n\t\t\t\tbio = NULL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\tisect += (pg_len >> SECTOR_SHIFT);\n\t\textent_length -= (pg_len >> SECTOR_SHIFT);\n\t\tf_offset += pg_len;\n\t\tbytes_left -= pg_len;\n\t}\n\tif ((isect << SECTOR_SHIFT) >= header->inode->i_size) {\n\t\theader->res.eof = 1;\n\t\theader->res.count = header->inode->i_size - header->args.offset;\n\t} else {\n\t\theader->res.count = (isect << SECTOR_SHIFT) - header->args.offset;\n\t}\nout:\n\tbl_submit_bio(READ, bio);\n\tblk_finish_plug(&plug);\n\tput_parallel(par);\n\treturn PNFS_ATTEMPTED;\n}",
    "includes": [
      "#include \"blocklayout.h\"",
      "#include \"../internal.h\"",
      "#include \"../nfs4session.h\"",
      "#include \"../pnfs.h\"",
      "#include <linux/pagevec.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/bio.h>\t\t/* struct bio */",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_parallel",
          "args": [
            "par"
          ],
          "line": 315
        },
        "resolved": true,
        "details": {
          "function_name": "put_parallel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/blocklayout/blocklayout.c",
          "lines": "99-102",
          "snippet": "static inline void put_parallel(struct parallel_io *p)\n{\n\tkref_put(&p->refcnt, destroy_parallel);\n}",
          "includes": [
            "#include \"blocklayout.h\"",
            "#include \"../internal.h\"",
            "#include \"../nfs4session.h\"",
            "#include \"../pnfs.h\"",
            "#include <linux/pagevec.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/bio.h>\t\t/* struct bio */",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"blocklayout.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include \"../pnfs.h\"\n#include <linux/pagevec.h>\n#include <linux/prefetch.h>\n#include <linux/bio.h>\t\t/* struct bio */\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic inline void put_parallel(struct parallel_io *p)\n{\n\tkref_put(&p->refcnt, destroy_parallel);\n}"
        }
      },
      {
        "call_info": {
          "callee": "blk_finish_plug",
          "args": [
            "&plug"
          ],
          "line": 314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bl_submit_bio",
          "args": [
            "READ",
            "bio"
          ],
          "line": 313
        },
        "resolved": true,
        "details": {
          "function_name": "bl_submit_bio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/blocklayout/blocklayout.c",
          "lines": "104-115",
          "snippet": "static struct bio *\nbl_submit_bio(int rw, struct bio *bio)\n{\n\tif (bio) {\n\t\tget_parallel(bio->bi_private);\n\t\tdprintk(\"%s submitting %s bio %u@%llu\\n\", __func__,\n\t\t\trw == READ ? \"read\" : \"write\", bio->bi_iter.bi_size,\n\t\t\t(unsigned long long)bio->bi_iter.bi_sector);\n\t\tsubmit_bio(rw, bio);\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"blocklayout.h\"",
            "#include \"../internal.h\"",
            "#include \"../nfs4session.h\"",
            "#include \"../pnfs.h\"",
            "#include <linux/pagevec.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/bio.h>\t\t/* struct bio */",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"blocklayout.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include \"../pnfs.h\"\n#include <linux/pagevec.h>\n#include <linux/prefetch.h>\n#include <linux/bio.h>\t\t/* struct bio */\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic struct bio *\nbl_submit_bio(int rw, struct bio *bio)\n{\n\tif (bio) {\n\t\tget_parallel(bio->bi_private);\n\t\tdprintk(\"%s submitting %s bio %u@%llu\\n\", __func__,\n\t\t\trw == READ ? \"read\" : \"write\", bio->bi_iter.bi_size,\n\t\t\t(unsigned long long)bio->bi_iter.bi_sector);\n\t\tsubmit_bio(rw, bio);\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "bio"
          ],
          "line": 296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "bio"
          ],
          "line": 295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_add_page_to_bio",
          "args": [
            "bio",
            "header->page_array.npages - i",
            "READ",
            "isect",
            "pages[i]",
            "&map",
            "&be",
            "bl_end_io_read",
            "par",
            "pg_offset",
            "&pg_len"
          ],
          "line": 289
        },
        "resolved": true,
        "details": {
          "function_name": "do_add_page_to_bio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/blocklayout/blocklayout.c",
          "lines": "139-184",
          "snippet": "static struct bio *\ndo_add_page_to_bio(struct bio *bio, int npg, int rw, sector_t isect,\n\t\tstruct page *page, struct pnfs_block_dev_map *map,\n\t\tstruct pnfs_block_extent *be,\n\t\tvoid (*end_io)(struct bio *, int err),\n\t\tstruct parallel_io *par, unsigned int offset, int *len)\n{\n\tstruct pnfs_block_dev *dev =\n\t\tcontainer_of(be->be_device, struct pnfs_block_dev, node);\n\tu64 disk_addr, end;\n\n\tdprintk(\"%s: npg %d rw %d isect %llu offset %u len %d\\n\", __func__,\n\t\tnpg, rw, (unsigned long long)isect, offset, *len);\n\n\t/* translate to device offset */\n\tisect += be->be_v_offset;\n\tisect -= be->be_f_offset;\n\n\t/* translate to physical disk offset */\n\tdisk_addr = (u64)isect << SECTOR_SHIFT;\n\tif (disk_addr < map->start || disk_addr >= map->start + map->len) {\n\t\tif (!dev->map(dev, disk_addr, map))\n\t\t\treturn ERR_PTR(-EIO);\n\t\tbio = bl_submit_bio(rw, bio);\n\t}\n\tdisk_addr += map->disk_offset;\n\tdisk_addr -= map->start;\n\n\t/* limit length to what the device mapping allows */\n\tend = disk_addr + *len;\n\tif (end >= map->start + map->len)\n\t\t*len = map->start + map->len - disk_addr;\n\nretry:\n\tif (!bio) {\n\t\tbio = bl_alloc_init_bio(npg, map->bdev,\n\t\t\t\tdisk_addr >> SECTOR_SHIFT, end_io, par);\n\t\tif (!bio)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\tif (bio_add_page(bio, page, *len, offset) < *len) {\n\t\tbio = bl_submit_bio(rw, bio);\n\t\tgoto retry;\n\t}\n\treturn bio;\n}",
          "includes": [
            "#include \"blocklayout.h\"",
            "#include \"../internal.h\"",
            "#include \"../nfs4session.h\"",
            "#include \"../pnfs.h\"",
            "#include <linux/pagevec.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/bio.h>\t\t/* struct bio */",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"blocklayout.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include \"../pnfs.h\"\n#include <linux/pagevec.h>\n#include <linux/prefetch.h>\n#include <linux/bio.h>\t\t/* struct bio */\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic struct bio *\ndo_add_page_to_bio(struct bio *bio, int npg, int rw, sector_t isect,\n\t\tstruct page *page, struct pnfs_block_dev_map *map,\n\t\tstruct pnfs_block_extent *be,\n\t\tvoid (*end_io)(struct bio *, int err),\n\t\tstruct parallel_io *par, unsigned int offset, int *len)\n{\n\tstruct pnfs_block_dev *dev =\n\t\tcontainer_of(be->be_device, struct pnfs_block_dev, node);\n\tu64 disk_addr, end;\n\n\tdprintk(\"%s: npg %d rw %d isect %llu offset %u len %d\\n\", __func__,\n\t\tnpg, rw, (unsigned long long)isect, offset, *len);\n\n\t/* translate to device offset */\n\tisect += be->be_v_offset;\n\tisect -= be->be_f_offset;\n\n\t/* translate to physical disk offset */\n\tdisk_addr = (u64)isect << SECTOR_SHIFT;\n\tif (disk_addr < map->start || disk_addr >= map->start + map->len) {\n\t\tif (!dev->map(dev, disk_addr, map))\n\t\t\treturn ERR_PTR(-EIO);\n\t\tbio = bl_submit_bio(rw, bio);\n\t}\n\tdisk_addr += map->disk_offset;\n\tdisk_addr -= map->start;\n\n\t/* limit length to what the device mapping allows */\n\tend = disk_addr + *len;\n\tif (end >= map->start + map->len)\n\t\t*len = map->start + map->len - disk_addr;\n\nretry:\n\tif (!bio) {\n\t\tbio = bl_alloc_init_bio(npg, map->bdev,\n\t\t\t\tdisk_addr >> SECTOR_SHIFT, end_io, par);\n\t\tif (!bio)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\tif (bio_add_page(bio, page, *len, offset) < *len) {\n\t\tbio = bl_submit_bio(rw, bio);\n\t\tgoto retry;\n\t}\n\treturn bio;\n}"
        }
      },
      {
        "call_info": {
          "callee": "zero_user_segment",
          "args": [
            "pages[i]",
            "pg_offset",
            "pg_len"
          ],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s Zeroing page for hole\\n\"",
            "__func__"
          ],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_hole",
          "args": [
            "&be"
          ],
          "line": 280
        },
        "resolved": true,
        "details": {
          "function_name": "is_hole",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/blocklayout/blocklayout.c",
          "lines": "52-62",
          "snippet": "static bool is_hole(struct pnfs_block_extent *be)\n{\n\tswitch (be->be_state) {\n\tcase PNFS_BLOCK_NONE_DATA:\n\t\treturn true;\n\tcase PNFS_BLOCK_INVALID_DATA:\n\t\treturn be->be_tag ? false : true;\n\tdefault:\n\t\treturn false;\n\t}\n}",
          "includes": [
            "#include \"blocklayout.h\"",
            "#include \"../internal.h\"",
            "#include \"../nfs4session.h\"",
            "#include \"../pnfs.h\"",
            "#include <linux/pagevec.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/bio.h>\t\t/* struct bio */",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"blocklayout.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include \"../pnfs.h\"\n#include <linux/pagevec.h>\n#include <linux/prefetch.h>\n#include <linux/bio.h>\t\t/* struct bio */\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic bool is_hole(struct pnfs_block_extent *be)\n{\n\tswitch (be->be_state) {\n\tcase PNFS_BLOCK_NONE_DATA:\n\t\treturn true;\n\tcase PNFS_BLOCK_INVALID_DATA:\n\t\treturn be->be_tag ? false : true;\n\tdefault:\n\t\treturn false;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "pg_offset != 0"
          ],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext_tree_lookup",
          "args": [
            "bl",
            "isect",
            "&be",
            "false"
          ],
          "line": 259
        },
        "resolved": true,
        "details": {
          "function_name": "ext_tree_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/blocklayout/extent_tree.c",
          "lines": "333-347",
          "snippet": "bool\next_tree_lookup(struct pnfs_block_layout *bl, sector_t isect,\n\t    struct pnfs_block_extent *ret, bool rw)\n{\n\tbool found = false;\n\n\tspin_lock(&bl->bl_ext_lock);\n\tif (!rw)\n\t\tfound = __ext_tree_lookup(&bl->bl_ext_ro, isect, ret);\n\tif (!found)\n\t\tfound = __ext_tree_lookup(&bl->bl_ext_rw, isect, ret);\n\tspin_unlock(&bl->bl_ext_lock);\n\n\treturn found;\n}",
          "includes": [
            "#include \"blocklayout.h\"",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"blocklayout.h\"\n#include <linux/vmalloc.h>\n\nbool\next_tree_lookup(struct pnfs_block_layout *bl, sector_t isect,\n\t    struct pnfs_block_extent *ret, bool rw)\n{\n\tbool found = false;\n\n\tspin_lock(&bl->bl_ext_lock);\n\tif (!rw)\n\t\tfound = __ext_tree_lookup(&bl->bl_ext_ro, isect, ret);\n\tif (!found)\n\t\tfound = __ext_tree_lookup(&bl->bl_ext_rw, isect, ret);\n\tspin_unlock(&bl->bl_ext_lock);\n\n\treturn found;\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "f_offset >> SECTOR_SHIFT"
          ],
          "line": 251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "blk_start_plug",
          "args": [
            "&plug"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_parallel",
          "args": [
            "header"
          ],
          "line": 244
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_parallel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/blocklayout/blocklayout.c",
          "lines": "73-83",
          "snippet": "static inline struct parallel_io *alloc_parallel(void *data)\n{\n\tstruct parallel_io *rv;\n\n\trv  = kmalloc(sizeof(*rv), GFP_NOFS);\n\tif (rv) {\n\t\trv->data = data;\n\t\tkref_init(&rv->refcnt);\n\t}\n\treturn rv;\n}",
          "includes": [
            "#include \"blocklayout.h\"",
            "#include \"../internal.h\"",
            "#include \"../nfs4session.h\"",
            "#include \"../pnfs.h\"",
            "#include <linux/pagevec.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/bio.h>\t\t/* struct bio */",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"blocklayout.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include \"../pnfs.h\"\n#include <linux/pagevec.h>\n#include <linux/prefetch.h>\n#include <linux/bio.h>\t\t/* struct bio */\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic inline struct parallel_io *alloc_parallel(void *data)\n{\n\tstruct parallel_io *rv;\n\n\trv  = kmalloc(sizeof(*rv), GFP_NOFS);\n\tif (rv) {\n\t\trv->data = data;\n\t\tkref_init(&rv->refcnt);\n\t}\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s enter nr_pages %u offset %lld count %u\\n\"",
            "__func__",
            "header->page_array.npages",
            "f_offset",
            "(unsigned int)header->args.count"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BLK_LSEG2EXT",
          "args": [
            "header->lseg"
          ],
          "line": 225
        },
        "resolved": true,
        "details": {
          "function_name": "BLK_LSEG2EXT",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/blocklayout/blocklayout.h",
          "lines": "159-163",
          "snippet": "static inline struct pnfs_block_layout *\nBLK_LSEG2EXT(struct pnfs_layout_segment *lseg)\n{\n\treturn BLK_LO2EXT(lseg->pls_layout);\n}",
          "includes": [
            "#include \"../netns.h\"",
            "#include \"../pnfs.h\"",
            "#include \"../nfs4_fs.h\"",
            "#include <linux/sunrpc/rpc_pipe_fs.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/device-mapper.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../netns.h\"\n#include \"../pnfs.h\"\n#include \"../nfs4_fs.h\"\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <linux/nfs_fs.h>\n#include <linux/device-mapper.h>\n\nstatic inline struct pnfs_block_layout *\nBLK_LSEG2EXT(struct pnfs_layout_segment *lseg)\n{\n\treturn BLK_LO2EXT(lseg->pls_layout);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"blocklayout.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include \"../pnfs.h\"\n#include <linux/pagevec.h>\n#include <linux/prefetch.h>\n#include <linux/bio.h>\t\t/* struct bio */\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic enum pnfs_try_status\nbl_read_pagelist(struct nfs_pgio_header *header)\n{\n\tstruct pnfs_block_layout *bl = BLK_LSEG2EXT(header->lseg);\n\tstruct pnfs_block_dev_map map = { .start = NFS4_MAX_UINT64 };\n\tstruct bio *bio = NULL;\n\tstruct pnfs_block_extent be;\n\tsector_t isect, extent_length = 0;\n\tstruct parallel_io *par;\n\tloff_t f_offset = header->args.offset;\n\tsize_t bytes_left = header->args.count;\n\tunsigned int pg_offset, pg_len;\n\tstruct page **pages = header->args.pages;\n\tint pg_index = header->args.pgbase >> PAGE_CACHE_SHIFT;\n\tconst bool is_dio = (header->dreq != NULL);\n\tstruct blk_plug plug;\n\tint i;\n\n\tdprintk(\"%s enter nr_pages %u offset %lld count %u\\n\", __func__,\n\t\theader->page_array.npages, f_offset,\n\t\t(unsigned int)header->args.count);\n\n\tpar = alloc_parallel(header);\n\tif (!par)\n\t\treturn PNFS_NOT_ATTEMPTED;\n\tpar->pnfs_callback = bl_end_par_io_read;\n\n\tblk_start_plug(&plug);\n\n\tisect = (sector_t) (f_offset >> SECTOR_SHIFT);\n\t/* Code assumes extents are page-aligned */\n\tfor (i = pg_index; i < header->page_array.npages; i++) {\n\t\tif (extent_length <= 0) {\n\t\t\t/* We've used up the previous extent */\n\t\t\tbio = bl_submit_bio(READ, bio);\n\n\t\t\t/* Get the next one */\n\t\t\tif (!ext_tree_lookup(bl, isect, &be, false)) {\n\t\t\t\theader->pnfs_error = -EIO;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\textent_length = be.be_length - (isect - be.be_f_offset);\n\t\t}\n\n\t\tpg_offset = f_offset & ~PAGE_CACHE_MASK;\n\t\tif (is_dio) {\n\t\t\tif (pg_offset + bytes_left > PAGE_CACHE_SIZE)\n\t\t\t\tpg_len = PAGE_CACHE_SIZE - pg_offset;\n\t\t\telse\n\t\t\t\tpg_len = bytes_left;\n\t\t} else {\n\t\t\tBUG_ON(pg_offset != 0);\n\t\t\tpg_len = PAGE_CACHE_SIZE;\n\t\t}\n\n\t\tisect += (pg_offset >> SECTOR_SHIFT);\n\t\textent_length -= (pg_offset >> SECTOR_SHIFT);\n\n\t\tif (is_hole(&be)) {\n\t\t\tbio = bl_submit_bio(READ, bio);\n\t\t\t/* Fill hole w/ zeroes w/o accessing device */\n\t\t\tdprintk(\"%s Zeroing page for hole\\n\", __func__);\n\t\t\tzero_user_segment(pages[i], pg_offset, pg_len);\n\n\t\t\t/* invalidate map */\n\t\t\tmap.start = NFS4_MAX_UINT64;\n\t\t} else {\n\t\t\tbio = do_add_page_to_bio(bio,\n\t\t\t\t\t\t header->page_array.npages - i,\n\t\t\t\t\t\t READ,\n\t\t\t\t\t\t isect, pages[i], &map, &be,\n\t\t\t\t\t\t bl_end_io_read, par,\n\t\t\t\t\t\t pg_offset, &pg_len);\n\t\t\tif (IS_ERR(bio)) {\n\t\t\t\theader->pnfs_error = PTR_ERR(bio);\n\t\t\t\tbio = NULL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\tisect += (pg_len >> SECTOR_SHIFT);\n\t\textent_length -= (pg_len >> SECTOR_SHIFT);\n\t\tf_offset += pg_len;\n\t\tbytes_left -= pg_len;\n\t}\n\tif ((isect << SECTOR_SHIFT) >= header->inode->i_size) {\n\t\theader->res.eof = 1;\n\t\theader->res.count = header->inode->i_size - header->args.offset;\n\t} else {\n\t\theader->res.count = (isect << SECTOR_SHIFT) - header->args.offset;\n\t}\nout:\n\tbl_submit_bio(READ, bio);\n\tblk_finish_plug(&plug);\n\tput_parallel(par);\n\treturn PNFS_ATTEMPTED;\n}"
  },
  {
    "function_name": "bl_end_par_io_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/blocklayout/blocklayout.c",
    "lines": "212-220",
    "snippet": "static void\nbl_end_par_io_read(void *data)\n{\n\tstruct nfs_pgio_header *hdr = data;\n\n\thdr->task.tk_status = hdr->pnfs_error;\n\tINIT_WORK(&hdr->task.u.tk_work, bl_read_cleanup);\n\tschedule_work(&hdr->task.u.tk_work);\n}",
    "includes": [
      "#include \"blocklayout.h\"",
      "#include \"../internal.h\"",
      "#include \"../nfs4session.h\"",
      "#include \"../pnfs.h\"",
      "#include <linux/pagevec.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/bio.h>\t\t/* struct bio */",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "schedule_work",
          "args": [
            "&hdr->task.u.tk_work"
          ],
          "line": 219
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_direct_write_schedule_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/direct.c",
          "lines": "755-771",
          "snippet": "static void nfs_direct_write_schedule_work(struct work_struct *work)\n{\n\tstruct nfs_direct_req *dreq = container_of(work, struct nfs_direct_req, work);\n\tint flags = dreq->flags;\n\n\tdreq->flags = 0;\n\tswitch (flags) {\n\t\tcase NFS_ODIRECT_DO_COMMIT:\n\t\t\tnfs_direct_commit_schedule(dreq);\n\t\t\tbreak;\n\t\tcase NFS_ODIRECT_RESCHED_WRITES:\n\t\t\tnfs_direct_write_reschedule(dreq);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tnfs_direct_complete(dreq, true);\n\t}\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include <linux/atomic.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/slab.h>",
            "#include <linux/kref.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [
            "#define NFS_ODIRECT_RESCHED_WRITES\t(2)\t/* write verification failed */",
            "#define NFS_ODIRECT_DO_COMMIT\t\t(1)\t/* an unstable reply was received */"
          ],
          "globals_used": [
            "static void nfs_direct_write_schedule_work(struct work_struct *work);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include <linux/atomic.h>\n#include <asm/uaccess.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n#include <linux/module.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/slab.h>\n#include <linux/kref.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\n#define NFS_ODIRECT_RESCHED_WRITES\t(2)\t/* write verification failed */\n#define NFS_ODIRECT_DO_COMMIT\t\t(1)\t/* an unstable reply was received */\n\nstatic void nfs_direct_write_schedule_work(struct work_struct *work);\n\nstatic void nfs_direct_write_schedule_work(struct work_struct *work)\n{\n\tstruct nfs_direct_req *dreq = container_of(work, struct nfs_direct_req, work);\n\tint flags = dreq->flags;\n\n\tdreq->flags = 0;\n\tswitch (flags) {\n\t\tcase NFS_ODIRECT_DO_COMMIT:\n\t\t\tnfs_direct_commit_schedule(dreq);\n\t\t\tbreak;\n\t\tcase NFS_ODIRECT_RESCHED_WRITES:\n\t\t\tnfs_direct_write_reschedule(dreq);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tnfs_direct_complete(dreq, true);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_WORK",
          "args": [
            "&hdr->task.u.tk_work",
            "bl_read_cleanup"
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"blocklayout.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include \"../pnfs.h\"\n#include <linux/pagevec.h>\n#include <linux/prefetch.h>\n#include <linux/bio.h>\t\t/* struct bio */\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic void\nbl_end_par_io_read(void *data)\n{\n\tstruct nfs_pgio_header *hdr = data;\n\n\thdr->task.tk_status = hdr->pnfs_error;\n\tINIT_WORK(&hdr->task.u.tk_work, bl_read_cleanup);\n\tschedule_work(&hdr->task.u.tk_work);\n}"
  },
  {
    "function_name": "bl_read_cleanup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/blocklayout/blocklayout.c",
    "lines": "202-210",
    "snippet": "static void bl_read_cleanup(struct work_struct *work)\n{\n\tstruct rpc_task *task;\n\tstruct nfs_pgio_header *hdr;\n\tdprintk(\"%s enter\\n\", __func__);\n\ttask = container_of(work, struct rpc_task, u.tk_work);\n\thdr = container_of(task, struct nfs_pgio_header, task);\n\tpnfs_ld_read_done(hdr);\n}",
    "includes": [
      "#include \"blocklayout.h\"",
      "#include \"../internal.h\"",
      "#include \"../nfs4session.h\"",
      "#include \"../pnfs.h\"",
      "#include <linux/pagevec.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/bio.h>\t\t/* struct bio */",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pnfs_ld_read_done",
          "args": [
            "hdr"
          ],
          "line": 209
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_ld_read_done",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
          "lines": "1955-1964",
          "snippet": "void pnfs_ld_read_done(struct nfs_pgio_header *hdr)\n{\n\ttrace_nfs4_pnfs_read(hdr, hdr->pnfs_error);\n\tif (likely(!hdr->pnfs_error)) {\n\t\t__nfs4_read_done_cb(hdr);\n\t\thdr->mds_ops->rpc_call_done(&hdr->task, hdr);\n\t} else\n\t\tpnfs_ld_handle_read_error(hdr);\n\thdr->mds_ops->rpc_release(hdr);\n}",
          "includes": [
            "#include \"delegation.h\"",
            "#include \"nfs4trace.h\"",
            "#include \"iostat.h\"",
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nvoid pnfs_ld_read_done(struct nfs_pgio_header *hdr)\n{\n\ttrace_nfs4_pnfs_read(hdr, hdr->pnfs_error);\n\tif (likely(!hdr->pnfs_error)) {\n\t\t__nfs4_read_done_cb(hdr);\n\t\thdr->mds_ops->rpc_call_done(&hdr->task, hdr);\n\t} else\n\t\tpnfs_ld_handle_read_error(hdr);\n\thdr->mds_ops->rpc_release(hdr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "task",
            "structnfs_pgio_header",
            "task"
          ],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "work",
            "structrpc_task",
            "u.tk_work"
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s enter\\n\"",
            "__func__"
          ],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"blocklayout.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include \"../pnfs.h\"\n#include <linux/pagevec.h>\n#include <linux/prefetch.h>\n#include <linux/bio.h>\t\t/* struct bio */\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic void bl_read_cleanup(struct work_struct *work)\n{\n\tstruct rpc_task *task;\n\tstruct nfs_pgio_header *hdr;\n\tdprintk(\"%s enter\\n\", __func__);\n\ttask = container_of(work, struct rpc_task, u.tk_work);\n\thdr = container_of(task, struct nfs_pgio_header, task);\n\tpnfs_ld_read_done(hdr);\n}"
  },
  {
    "function_name": "bl_end_io_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/blocklayout/blocklayout.c",
    "lines": "186-200",
    "snippet": "static void bl_end_io_read(struct bio *bio, int err)\n{\n\tstruct parallel_io *par = bio->bi_private;\n\n\tif (err) {\n\t\tstruct nfs_pgio_header *header = par->data;\n\n\t\tif (!header->pnfs_error)\n\t\t\theader->pnfs_error = -EIO;\n\t\tpnfs_set_lo_fail(header->lseg);\n\t}\n\n\tbio_put(bio);\n\tput_parallel(par);\n}",
    "includes": [
      "#include \"blocklayout.h\"",
      "#include \"../internal.h\"",
      "#include \"../nfs4session.h\"",
      "#include \"../pnfs.h\"",
      "#include <linux/pagevec.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/bio.h>\t\t/* struct bio */",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_parallel",
          "args": [
            "par"
          ],
          "line": 199
        },
        "resolved": true,
        "details": {
          "function_name": "put_parallel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/blocklayout/blocklayout.c",
          "lines": "99-102",
          "snippet": "static inline void put_parallel(struct parallel_io *p)\n{\n\tkref_put(&p->refcnt, destroy_parallel);\n}",
          "includes": [
            "#include \"blocklayout.h\"",
            "#include \"../internal.h\"",
            "#include \"../nfs4session.h\"",
            "#include \"../pnfs.h\"",
            "#include <linux/pagevec.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/bio.h>\t\t/* struct bio */",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"blocklayout.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include \"../pnfs.h\"\n#include <linux/pagevec.h>\n#include <linux/prefetch.h>\n#include <linux/bio.h>\t\t/* struct bio */\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic inline void put_parallel(struct parallel_io *p)\n{\n\tkref_put(&p->refcnt, destroy_parallel);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bio_put",
          "args": [
            "bio"
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pnfs_set_lo_fail",
          "args": [
            "header->lseg"
          ],
          "line": 195
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_set_lo_fail",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
          "lines": "2095-2098",
          "snippet": "void pnfs_set_lo_fail(struct pnfs_layout_segment *lseg)\n{\n\tpnfs_layout_io_set_failed(lseg->pls_layout, lseg->pls_range.iomode);\n}",
          "includes": [
            "#include \"delegation.h\"",
            "#include \"nfs4trace.h\"",
            "#include \"iostat.h\"",
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nvoid pnfs_set_lo_fail(struct pnfs_layout_segment *lseg)\n{\n\tpnfs_layout_io_set_failed(lseg->pls_layout, lseg->pls_range.iomode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"blocklayout.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include \"../pnfs.h\"\n#include <linux/pagevec.h>\n#include <linux/prefetch.h>\n#include <linux/bio.h>\t\t/* struct bio */\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic void bl_end_io_read(struct bio *bio, int err)\n{\n\tstruct parallel_io *par = bio->bi_private;\n\n\tif (err) {\n\t\tstruct nfs_pgio_header *header = par->data;\n\n\t\tif (!header->pnfs_error)\n\t\t\theader->pnfs_error = -EIO;\n\t\tpnfs_set_lo_fail(header->lseg);\n\t}\n\n\tbio_put(bio);\n\tput_parallel(par);\n}"
  },
  {
    "function_name": "do_add_page_to_bio",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/blocklayout/blocklayout.c",
    "lines": "139-184",
    "snippet": "static struct bio *\ndo_add_page_to_bio(struct bio *bio, int npg, int rw, sector_t isect,\n\t\tstruct page *page, struct pnfs_block_dev_map *map,\n\t\tstruct pnfs_block_extent *be,\n\t\tvoid (*end_io)(struct bio *, int err),\n\t\tstruct parallel_io *par, unsigned int offset, int *len)\n{\n\tstruct pnfs_block_dev *dev =\n\t\tcontainer_of(be->be_device, struct pnfs_block_dev, node);\n\tu64 disk_addr, end;\n\n\tdprintk(\"%s: npg %d rw %d isect %llu offset %u len %d\\n\", __func__,\n\t\tnpg, rw, (unsigned long long)isect, offset, *len);\n\n\t/* translate to device offset */\n\tisect += be->be_v_offset;\n\tisect -= be->be_f_offset;\n\n\t/* translate to physical disk offset */\n\tdisk_addr = (u64)isect << SECTOR_SHIFT;\n\tif (disk_addr < map->start || disk_addr >= map->start + map->len) {\n\t\tif (!dev->map(dev, disk_addr, map))\n\t\t\treturn ERR_PTR(-EIO);\n\t\tbio = bl_submit_bio(rw, bio);\n\t}\n\tdisk_addr += map->disk_offset;\n\tdisk_addr -= map->start;\n\n\t/* limit length to what the device mapping allows */\n\tend = disk_addr + *len;\n\tif (end >= map->start + map->len)\n\t\t*len = map->start + map->len - disk_addr;\n\nretry:\n\tif (!bio) {\n\t\tbio = bl_alloc_init_bio(npg, map->bdev,\n\t\t\t\tdisk_addr >> SECTOR_SHIFT, end_io, par);\n\t\tif (!bio)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\tif (bio_add_page(bio, page, *len, offset) < *len) {\n\t\tbio = bl_submit_bio(rw, bio);\n\t\tgoto retry;\n\t}\n\treturn bio;\n}",
    "includes": [
      "#include \"blocklayout.h\"",
      "#include \"../internal.h\"",
      "#include \"../nfs4session.h\"",
      "#include \"../pnfs.h\"",
      "#include <linux/pagevec.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/bio.h>\t\t/* struct bio */",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bl_submit_bio",
          "args": [
            "rw",
            "bio"
          ],
          "line": 180
        },
        "resolved": true,
        "details": {
          "function_name": "bl_submit_bio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/blocklayout/blocklayout.c",
          "lines": "104-115",
          "snippet": "static struct bio *\nbl_submit_bio(int rw, struct bio *bio)\n{\n\tif (bio) {\n\t\tget_parallel(bio->bi_private);\n\t\tdprintk(\"%s submitting %s bio %u@%llu\\n\", __func__,\n\t\t\trw == READ ? \"read\" : \"write\", bio->bi_iter.bi_size,\n\t\t\t(unsigned long long)bio->bi_iter.bi_sector);\n\t\tsubmit_bio(rw, bio);\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"blocklayout.h\"",
            "#include \"../internal.h\"",
            "#include \"../nfs4session.h\"",
            "#include \"../pnfs.h\"",
            "#include <linux/pagevec.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/bio.h>\t\t/* struct bio */",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"blocklayout.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include \"../pnfs.h\"\n#include <linux/pagevec.h>\n#include <linux/prefetch.h>\n#include <linux/bio.h>\t\t/* struct bio */\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic struct bio *\nbl_submit_bio(int rw, struct bio *bio)\n{\n\tif (bio) {\n\t\tget_parallel(bio->bi_private);\n\t\tdprintk(\"%s submitting %s bio %u@%llu\\n\", __func__,\n\t\t\trw == READ ? \"read\" : \"write\", bio->bi_iter.bi_size,\n\t\t\t(unsigned long long)bio->bi_iter.bi_sector);\n\t\tsubmit_bio(rw, bio);\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bio_add_page",
          "args": [
            "bio",
            "page",
            "*len",
            "offset"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bl_alloc_init_bio",
          "args": [
            "npg",
            "map->bdev",
            "disk_addr >> SECTOR_SHIFT",
            "end_io",
            "par"
          ],
          "line": 174
        },
        "resolved": true,
        "details": {
          "function_name": "bl_alloc_init_bio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/blocklayout/blocklayout.c",
          "lines": "117-137",
          "snippet": "static struct bio *\nbl_alloc_init_bio(int npg, struct block_device *bdev, sector_t disk_sector,\n\t\tvoid (*end_io)(struct bio *, int err), struct parallel_io *par)\n{\n\tstruct bio *bio;\n\n\tnpg = min(npg, BIO_MAX_PAGES);\n\tbio = bio_alloc(GFP_NOIO, npg);\n\tif (!bio && (current->flags & PF_MEMALLOC)) {\n\t\twhile (!bio && (npg /= 2))\n\t\t\tbio = bio_alloc(GFP_NOIO, npg);\n\t}\n\n\tif (bio) {\n\t\tbio->bi_iter.bi_sector = disk_sector;\n\t\tbio->bi_bdev = bdev;\n\t\tbio->bi_end_io = end_io;\n\t\tbio->bi_private = par;\n\t}\n\treturn bio;\n}",
          "includes": [
            "#include \"blocklayout.h\"",
            "#include \"../internal.h\"",
            "#include \"../nfs4session.h\"",
            "#include \"../pnfs.h\"",
            "#include <linux/pagevec.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/bio.h>\t\t/* struct bio */",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"blocklayout.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include \"../pnfs.h\"\n#include <linux/pagevec.h>\n#include <linux/prefetch.h>\n#include <linux/bio.h>\t\t/* struct bio */\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic struct bio *\nbl_alloc_init_bio(int npg, struct block_device *bdev, sector_t disk_sector,\n\t\tvoid (*end_io)(struct bio *, int err), struct parallel_io *par)\n{\n\tstruct bio *bio;\n\n\tnpg = min(npg, BIO_MAX_PAGES);\n\tbio = bio_alloc(GFP_NOIO, npg);\n\tif (!bio && (current->flags & PF_MEMALLOC)) {\n\t\twhile (!bio && (npg /= 2))\n\t\t\tbio = bio_alloc(GFP_NOIO, npg);\n\t}\n\n\tif (bio) {\n\t\tbio->bi_iter.bi_sector = disk_sector;\n\t\tbio->bi_bdev = bdev;\n\t\tbio->bi_end_io = end_io;\n\t\tbio->bi_private = par;\n\t}\n\treturn bio;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EIO"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dev->map",
          "args": [
            "dev",
            "disk_addr",
            "map"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s: npg %d rw %d isect %llu offset %u len %d\\n\"",
            "__func__",
            "npg",
            "rw",
            "(unsigned long long)isect",
            "offset",
            "*len"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "be->be_device",
            "structpnfs_block_dev",
            "node"
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"blocklayout.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include \"../pnfs.h\"\n#include <linux/pagevec.h>\n#include <linux/prefetch.h>\n#include <linux/bio.h>\t\t/* struct bio */\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic struct bio *\ndo_add_page_to_bio(struct bio *bio, int npg, int rw, sector_t isect,\n\t\tstruct page *page, struct pnfs_block_dev_map *map,\n\t\tstruct pnfs_block_extent *be,\n\t\tvoid (*end_io)(struct bio *, int err),\n\t\tstruct parallel_io *par, unsigned int offset, int *len)\n{\n\tstruct pnfs_block_dev *dev =\n\t\tcontainer_of(be->be_device, struct pnfs_block_dev, node);\n\tu64 disk_addr, end;\n\n\tdprintk(\"%s: npg %d rw %d isect %llu offset %u len %d\\n\", __func__,\n\t\tnpg, rw, (unsigned long long)isect, offset, *len);\n\n\t/* translate to device offset */\n\tisect += be->be_v_offset;\n\tisect -= be->be_f_offset;\n\n\t/* translate to physical disk offset */\n\tdisk_addr = (u64)isect << SECTOR_SHIFT;\n\tif (disk_addr < map->start || disk_addr >= map->start + map->len) {\n\t\tif (!dev->map(dev, disk_addr, map))\n\t\t\treturn ERR_PTR(-EIO);\n\t\tbio = bl_submit_bio(rw, bio);\n\t}\n\tdisk_addr += map->disk_offset;\n\tdisk_addr -= map->start;\n\n\t/* limit length to what the device mapping allows */\n\tend = disk_addr + *len;\n\tif (end >= map->start + map->len)\n\t\t*len = map->start + map->len - disk_addr;\n\nretry:\n\tif (!bio) {\n\t\tbio = bl_alloc_init_bio(npg, map->bdev,\n\t\t\t\tdisk_addr >> SECTOR_SHIFT, end_io, par);\n\t\tif (!bio)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\tif (bio_add_page(bio, page, *len, offset) < *len) {\n\t\tbio = bl_submit_bio(rw, bio);\n\t\tgoto retry;\n\t}\n\treturn bio;\n}"
  },
  {
    "function_name": "bl_alloc_init_bio",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/blocklayout/blocklayout.c",
    "lines": "117-137",
    "snippet": "static struct bio *\nbl_alloc_init_bio(int npg, struct block_device *bdev, sector_t disk_sector,\n\t\tvoid (*end_io)(struct bio *, int err), struct parallel_io *par)\n{\n\tstruct bio *bio;\n\n\tnpg = min(npg, BIO_MAX_PAGES);\n\tbio = bio_alloc(GFP_NOIO, npg);\n\tif (!bio && (current->flags & PF_MEMALLOC)) {\n\t\twhile (!bio && (npg /= 2))\n\t\t\tbio = bio_alloc(GFP_NOIO, npg);\n\t}\n\n\tif (bio) {\n\t\tbio->bi_iter.bi_sector = disk_sector;\n\t\tbio->bi_bdev = bdev;\n\t\tbio->bi_end_io = end_io;\n\t\tbio->bi_private = par;\n\t}\n\treturn bio;\n}",
    "includes": [
      "#include \"blocklayout.h\"",
      "#include \"../internal.h\"",
      "#include \"../nfs4session.h\"",
      "#include \"../pnfs.h\"",
      "#include <linux/pagevec.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/bio.h>\t\t/* struct bio */",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bio_alloc",
          "args": [
            "GFP_NOIO",
            "npg"
          ],
          "line": 127
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_io_bio_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "2733-2746",
          "snippet": "struct bio *btrfs_io_bio_alloc(gfp_t gfp_mask, unsigned int nr_iovecs)\n{\n\tstruct btrfs_io_bio *btrfs_bio;\n\tstruct bio *bio;\n\n\tbio = bio_alloc_bioset(gfp_mask, nr_iovecs, btrfs_bioset);\n\tif (bio) {\n\t\tbtrfs_bio = btrfs_io_bio(bio);\n\t\tbtrfs_bio->csum = NULL;\n\t\tbtrfs_bio->csum_allocated = NULL;\n\t\tbtrfs_bio->end_io = NULL;\n\t}\n\treturn bio;\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct bio_set *btrfs_bioset;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic struct bio_set *btrfs_bioset;\n\nstruct bio *btrfs_io_bio_alloc(gfp_t gfp_mask, unsigned int nr_iovecs)\n{\n\tstruct btrfs_io_bio *btrfs_bio;\n\tstruct bio *bio;\n\n\tbio = bio_alloc_bioset(gfp_mask, nr_iovecs, btrfs_bioset);\n\tif (bio) {\n\t\tbtrfs_bio = btrfs_io_bio(bio);\n\t\tbtrfs_bio->csum = NULL;\n\t\tbtrfs_bio->csum_allocated = NULL;\n\t\tbtrfs_bio->end_io = NULL;\n\t}\n\treturn bio;\n}"
        }
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "npg",
            "BIO_MAX_PAGES"
          ],
          "line": 123
        },
        "resolved": true,
        "details": {
          "function_name": "get_dominating_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pnode.c",
          "lines": "55-66",
          "snippet": "int get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"pnode.h\"",
            "#include \"internal.h\"",
            "#include <linux/nsproxy.h>",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/mnt_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnode.h\"\n#include \"internal.h\"\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mnt_namespace.h>\n\nint get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"blocklayout.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include \"../pnfs.h\"\n#include <linux/pagevec.h>\n#include <linux/prefetch.h>\n#include <linux/bio.h>\t\t/* struct bio */\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic struct bio *\nbl_alloc_init_bio(int npg, struct block_device *bdev, sector_t disk_sector,\n\t\tvoid (*end_io)(struct bio *, int err), struct parallel_io *par)\n{\n\tstruct bio *bio;\n\n\tnpg = min(npg, BIO_MAX_PAGES);\n\tbio = bio_alloc(GFP_NOIO, npg);\n\tif (!bio && (current->flags & PF_MEMALLOC)) {\n\t\twhile (!bio && (npg /= 2))\n\t\t\tbio = bio_alloc(GFP_NOIO, npg);\n\t}\n\n\tif (bio) {\n\t\tbio->bi_iter.bi_sector = disk_sector;\n\t\tbio->bi_bdev = bdev;\n\t\tbio->bi_end_io = end_io;\n\t\tbio->bi_private = par;\n\t}\n\treturn bio;\n}"
  },
  {
    "function_name": "bl_submit_bio",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/blocklayout/blocklayout.c",
    "lines": "104-115",
    "snippet": "static struct bio *\nbl_submit_bio(int rw, struct bio *bio)\n{\n\tif (bio) {\n\t\tget_parallel(bio->bi_private);\n\t\tdprintk(\"%s submitting %s bio %u@%llu\\n\", __func__,\n\t\t\trw == READ ? \"read\" : \"write\", bio->bi_iter.bi_size,\n\t\t\t(unsigned long long)bio->bi_iter.bi_sector);\n\t\tsubmit_bio(rw, bio);\n\t}\n\treturn NULL;\n}",
    "includes": [
      "#include \"blocklayout.h\"",
      "#include \"../internal.h\"",
      "#include \"../nfs4session.h\"",
      "#include \"../pnfs.h\"",
      "#include <linux/pagevec.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/bio.h>\t\t/* struct bio */",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "submit_bio",
          "args": [
            "rw",
            "bio"
          ],
          "line": 112
        },
        "resolved": true,
        "details": {
          "function_name": "bl_submit_bio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/blocklayout/blocklayout.c",
          "lines": "104-115",
          "snippet": "static struct bio *\nbl_submit_bio(int rw, struct bio *bio)\n{\n\tif (bio) {\n\t\tget_parallel(bio->bi_private);\n\t\tdprintk(\"%s submitting %s bio %u@%llu\\n\", __func__,\n\t\t\trw == READ ? \"read\" : \"write\", bio->bi_iter.bi_size,\n\t\t\t(unsigned long long)bio->bi_iter.bi_sector);\n\t\tsubmit_bio(rw, bio);\n\t}\n\treturn NULL;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s submitting %s bio %u@%llu\\n\"",
            "__func__",
            "rw == READ ? \"read\" : \"write\"",
            "bio->bi_iter.bi_size",
            "(unsigned long long)bio->bi_iter.bi_sector"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_parallel",
          "args": [
            "bio->bi_private"
          ],
          "line": 108
        },
        "resolved": true,
        "details": {
          "function_name": "get_parallel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/blocklayout/blocklayout.c",
          "lines": "85-88",
          "snippet": "static inline void get_parallel(struct parallel_io *p)\n{\n\tkref_get(&p->refcnt);\n}",
          "includes": [
            "#include \"blocklayout.h\"",
            "#include \"../internal.h\"",
            "#include \"../nfs4session.h\"",
            "#include \"../pnfs.h\"",
            "#include <linux/pagevec.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/bio.h>\t\t/* struct bio */",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"blocklayout.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include \"../pnfs.h\"\n#include <linux/pagevec.h>\n#include <linux/prefetch.h>\n#include <linux/bio.h>\t\t/* struct bio */\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic inline void get_parallel(struct parallel_io *p)\n{\n\tkref_get(&p->refcnt);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"blocklayout.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include \"../pnfs.h\"\n#include <linux/pagevec.h>\n#include <linux/prefetch.h>\n#include <linux/bio.h>\t\t/* struct bio */\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic struct bio *\nbl_submit_bio(int rw, struct bio *bio)\n{\n\tif (bio) {\n\t\tget_parallel(bio->bi_private);\n\t\tdprintk(\"%s submitting %s bio %u@%llu\\n\", __func__,\n\t\t\trw == READ ? \"read\" : \"write\", bio->bi_iter.bi_size,\n\t\t\t(unsigned long long)bio->bi_iter.bi_sector);\n\t\tsubmit_bio(rw, bio);\n\t}\n\treturn NULL;\n}"
  },
  {
    "function_name": "put_parallel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/blocklayout/blocklayout.c",
    "lines": "99-102",
    "snippet": "static inline void put_parallel(struct parallel_io *p)\n{\n\tkref_put(&p->refcnt, destroy_parallel);\n}",
    "includes": [
      "#include \"blocklayout.h\"",
      "#include \"../internal.h\"",
      "#include \"../nfs4session.h\"",
      "#include \"../pnfs.h\"",
      "#include <linux/pagevec.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/bio.h>\t\t/* struct bio */",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kref_put",
          "args": [
            "&p->refcnt",
            "destroy_parallel"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"blocklayout.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include \"../pnfs.h\"\n#include <linux/pagevec.h>\n#include <linux/prefetch.h>\n#include <linux/bio.h>\t\t/* struct bio */\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic inline void put_parallel(struct parallel_io *p)\n{\n\tkref_put(&p->refcnt, destroy_parallel);\n}"
  },
  {
    "function_name": "destroy_parallel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/blocklayout/blocklayout.c",
    "lines": "90-97",
    "snippet": "static void destroy_parallel(struct kref *kref)\n{\n\tstruct parallel_io *p = container_of(kref, struct parallel_io, refcnt);\n\n\tdprintk(\"%s enter\\n\", __func__);\n\tp->pnfs_callback(p->data);\n\tkfree(p);\n}",
    "includes": [
      "#include \"blocklayout.h\"",
      "#include \"../internal.h\"",
      "#include \"../nfs4session.h\"",
      "#include \"../pnfs.h\"",
      "#include <linux/pagevec.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/bio.h>\t\t/* struct bio */",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "p"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p->pnfs_callback",
          "args": [
            "p->data"
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s enter\\n\"",
            "__func__"
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "kref",
            "structparallel_io",
            "refcnt"
          ],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"blocklayout.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include \"../pnfs.h\"\n#include <linux/pagevec.h>\n#include <linux/prefetch.h>\n#include <linux/bio.h>\t\t/* struct bio */\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic void destroy_parallel(struct kref *kref)\n{\n\tstruct parallel_io *p = container_of(kref, struct parallel_io, refcnt);\n\n\tdprintk(\"%s enter\\n\", __func__);\n\tp->pnfs_callback(p->data);\n\tkfree(p);\n}"
  },
  {
    "function_name": "get_parallel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/blocklayout/blocklayout.c",
    "lines": "85-88",
    "snippet": "static inline void get_parallel(struct parallel_io *p)\n{\n\tkref_get(&p->refcnt);\n}",
    "includes": [
      "#include \"blocklayout.h\"",
      "#include \"../internal.h\"",
      "#include \"../nfs4session.h\"",
      "#include \"../pnfs.h\"",
      "#include <linux/pagevec.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/bio.h>\t\t/* struct bio */",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kref_get",
          "args": [
            "&p->refcnt"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"blocklayout.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include \"../pnfs.h\"\n#include <linux/pagevec.h>\n#include <linux/prefetch.h>\n#include <linux/bio.h>\t\t/* struct bio */\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic inline void get_parallel(struct parallel_io *p)\n{\n\tkref_get(&p->refcnt);\n}"
  },
  {
    "function_name": "alloc_parallel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/blocklayout/blocklayout.c",
    "lines": "73-83",
    "snippet": "static inline struct parallel_io *alloc_parallel(void *data)\n{\n\tstruct parallel_io *rv;\n\n\trv  = kmalloc(sizeof(*rv), GFP_NOFS);\n\tif (rv) {\n\t\trv->data = data;\n\t\tkref_init(&rv->refcnt);\n\t}\n\treturn rv;\n}",
    "includes": [
      "#include \"blocklayout.h\"",
      "#include \"../internal.h\"",
      "#include \"../nfs4session.h\"",
      "#include \"../pnfs.h\"",
      "#include <linux/pagevec.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/bio.h>\t\t/* struct bio */",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kref_init",
          "args": [
            "&rv->refcnt"
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(*rv)",
            "GFP_NOFS"
          ],
          "line": 77
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"blocklayout.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include \"../pnfs.h\"\n#include <linux/pagevec.h>\n#include <linux/prefetch.h>\n#include <linux/bio.h>\t\t/* struct bio */\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic inline struct parallel_io *alloc_parallel(void *data)\n{\n\tstruct parallel_io *rv;\n\n\trv  = kmalloc(sizeof(*rv), GFP_NOFS);\n\tif (rv) {\n\t\trv->data = data;\n\t\tkref_init(&rv->refcnt);\n\t}\n\treturn rv;\n}"
  },
  {
    "function_name": "is_hole",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/blocklayout/blocklayout.c",
    "lines": "52-62",
    "snippet": "static bool is_hole(struct pnfs_block_extent *be)\n{\n\tswitch (be->be_state) {\n\tcase PNFS_BLOCK_NONE_DATA:\n\t\treturn true;\n\tcase PNFS_BLOCK_INVALID_DATA:\n\t\treturn be->be_tag ? false : true;\n\tdefault:\n\t\treturn false;\n\t}\n}",
    "includes": [
      "#include \"blocklayout.h\"",
      "#include \"../internal.h\"",
      "#include \"../nfs4session.h\"",
      "#include \"../pnfs.h\"",
      "#include <linux/pagevec.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/bio.h>\t\t/* struct bio */",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"blocklayout.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include \"../pnfs.h\"\n#include <linux/pagevec.h>\n#include <linux/prefetch.h>\n#include <linux/bio.h>\t\t/* struct bio */\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic bool is_hole(struct pnfs_block_extent *be)\n{\n\tswitch (be->be_state) {\n\tcase PNFS_BLOCK_NONE_DATA:\n\t\treturn true;\n\tcase PNFS_BLOCK_INVALID_DATA:\n\t\treturn be->be_tag ? false : true;\n\tdefault:\n\t\treturn false;\n\t}\n}"
  }
]