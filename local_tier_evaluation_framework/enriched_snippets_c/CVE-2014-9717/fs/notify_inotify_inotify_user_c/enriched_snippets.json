[
  {
    "function_name": "inotify_user_setup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/inotify/inotify_user.c",
    "lines": "784-814",
    "snippet": "static int __init inotify_user_setup(void)\n{\n\tBUILD_BUG_ON(IN_ACCESS != FS_ACCESS);\n\tBUILD_BUG_ON(IN_MODIFY != FS_MODIFY);\n\tBUILD_BUG_ON(IN_ATTRIB != FS_ATTRIB);\n\tBUILD_BUG_ON(IN_CLOSE_WRITE != FS_CLOSE_WRITE);\n\tBUILD_BUG_ON(IN_CLOSE_NOWRITE != FS_CLOSE_NOWRITE);\n\tBUILD_BUG_ON(IN_OPEN != FS_OPEN);\n\tBUILD_BUG_ON(IN_MOVED_FROM != FS_MOVED_FROM);\n\tBUILD_BUG_ON(IN_MOVED_TO != FS_MOVED_TO);\n\tBUILD_BUG_ON(IN_CREATE != FS_CREATE);\n\tBUILD_BUG_ON(IN_DELETE != FS_DELETE);\n\tBUILD_BUG_ON(IN_DELETE_SELF != FS_DELETE_SELF);\n\tBUILD_BUG_ON(IN_MOVE_SELF != FS_MOVE_SELF);\n\tBUILD_BUG_ON(IN_UNMOUNT != FS_UNMOUNT);\n\tBUILD_BUG_ON(IN_Q_OVERFLOW != FS_Q_OVERFLOW);\n\tBUILD_BUG_ON(IN_IGNORED != FS_IN_IGNORED);\n\tBUILD_BUG_ON(IN_EXCL_UNLINK != FS_EXCL_UNLINK);\n\tBUILD_BUG_ON(IN_ISDIR != FS_ISDIR);\n\tBUILD_BUG_ON(IN_ONESHOT != FS_IN_ONESHOT);\n\n\tBUG_ON(hweight32(ALL_INOTIFY_BITS) != 21);\n\n\tinotify_inode_mark_cachep = KMEM_CACHE(inotify_inode_mark, SLAB_PANIC);\n\n\tinotify_max_queued_events = 16384;\n\tinotify_max_user_instances = 128;\n\tinotify_max_user_watches = 8192;\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/sysctl.h>",
      "#include <asm/ioctls.h>",
      "#include \"../fdinfo.h\"",
      "#include \"inotify.h\"",
      "#include <linux/wait.h>",
      "#include <linux/poll.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/types.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h> /* struct kmem_cache */",
      "#include <linux/sched.h> /* struct user */",
      "#include <linux/namei.h> /* LOOKUP_FOLLOW */",
      "#include <linux/kernel.h> /* roundup() */",
      "#include <linux/inotify.h>",
      "#include <linux/init.h> /* module_init */",
      "#include <linux/idr.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/fs.h> /* struct inode */",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int inotify_max_user_instances",
      "static int inotify_max_queued_events",
      "static int inotify_max_user_watches",
      "static struct kmem_cache *inotify_inode_mark_cachep"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "KMEM_CACHE",
          "args": [
            "inotify_inode_mark",
            "SLAB_PANIC"
          ],
          "line": 807
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "hweight32(ALL_INOTIFY_BITS) != 21"
          ],
          "line": 805
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hweight32",
          "args": [
            "ALL_INOTIFY_BITS"
          ],
          "line": 805
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "IN_ONESHOT != FS_IN_ONESHOT"
          ],
          "line": 803
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "IN_ISDIR != FS_ISDIR"
          ],
          "line": 802
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "IN_EXCL_UNLINK != FS_EXCL_UNLINK"
          ],
          "line": 801
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "IN_IGNORED != FS_IN_IGNORED"
          ],
          "line": 800
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "IN_Q_OVERFLOW != FS_Q_OVERFLOW"
          ],
          "line": 799
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "IN_UNMOUNT != FS_UNMOUNT"
          ],
          "line": 798
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "IN_MOVE_SELF != FS_MOVE_SELF"
          ],
          "line": 797
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "IN_DELETE_SELF != FS_DELETE_SELF"
          ],
          "line": 796
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "IN_DELETE != FS_DELETE"
          ],
          "line": 795
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "IN_CREATE != FS_CREATE"
          ],
          "line": 794
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "IN_MOVED_TO != FS_MOVED_TO"
          ],
          "line": 793
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "IN_MOVED_FROM != FS_MOVED_FROM"
          ],
          "line": 792
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "IN_OPEN != FS_OPEN"
          ],
          "line": 791
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "IN_CLOSE_NOWRITE != FS_CLOSE_NOWRITE"
          ],
          "line": 790
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "IN_CLOSE_WRITE != FS_CLOSE_WRITE"
          ],
          "line": 789
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "IN_ATTRIB != FS_ATTRIB"
          ],
          "line": 788
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "IN_MODIFY != FS_MODIFY"
          ],
          "line": 787
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "IN_ACCESS != FS_ACCESS"
          ],
          "line": 786
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sysctl.h>\n#include <asm/ioctls.h>\n#include \"../fdinfo.h\"\n#include \"inotify.h\"\n#include <linux/wait.h>\n#include <linux/poll.h>\n#include <linux/uaccess.h>\n#include <linux/anon_inodes.h>\n#include <linux/types.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h> /* struct kmem_cache */\n#include <linux/sched.h> /* struct user */\n#include <linux/namei.h> /* LOOKUP_FOLLOW */\n#include <linux/kernel.h> /* roundup() */\n#include <linux/inotify.h>\n#include <linux/init.h> /* module_init */\n#include <linux/idr.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/fs.h> /* struct inode */\n#include <linux/file.h>\n\nstatic int inotify_max_user_instances;\nstatic int inotify_max_queued_events;\nstatic int inotify_max_user_watches;\nstatic struct kmem_cache *inotify_inode_mark_cachep;\n\nstatic int __init inotify_user_setup(void)\n{\n\tBUILD_BUG_ON(IN_ACCESS != FS_ACCESS);\n\tBUILD_BUG_ON(IN_MODIFY != FS_MODIFY);\n\tBUILD_BUG_ON(IN_ATTRIB != FS_ATTRIB);\n\tBUILD_BUG_ON(IN_CLOSE_WRITE != FS_CLOSE_WRITE);\n\tBUILD_BUG_ON(IN_CLOSE_NOWRITE != FS_CLOSE_NOWRITE);\n\tBUILD_BUG_ON(IN_OPEN != FS_OPEN);\n\tBUILD_BUG_ON(IN_MOVED_FROM != FS_MOVED_FROM);\n\tBUILD_BUG_ON(IN_MOVED_TO != FS_MOVED_TO);\n\tBUILD_BUG_ON(IN_CREATE != FS_CREATE);\n\tBUILD_BUG_ON(IN_DELETE != FS_DELETE);\n\tBUILD_BUG_ON(IN_DELETE_SELF != FS_DELETE_SELF);\n\tBUILD_BUG_ON(IN_MOVE_SELF != FS_MOVE_SELF);\n\tBUILD_BUG_ON(IN_UNMOUNT != FS_UNMOUNT);\n\tBUILD_BUG_ON(IN_Q_OVERFLOW != FS_Q_OVERFLOW);\n\tBUILD_BUG_ON(IN_IGNORED != FS_IN_IGNORED);\n\tBUILD_BUG_ON(IN_EXCL_UNLINK != FS_EXCL_UNLINK);\n\tBUILD_BUG_ON(IN_ISDIR != FS_ISDIR);\n\tBUILD_BUG_ON(IN_ONESHOT != FS_IN_ONESHOT);\n\n\tBUG_ON(hweight32(ALL_INOTIFY_BITS) != 21);\n\n\tinotify_inode_mark_cachep = KMEM_CACHE(inotify_inode_mark, SLAB_PANIC);\n\n\tinotify_max_queued_events = 16384;\n\tinotify_max_user_instances = 128;\n\tinotify_max_user_watches = 8192;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "inotify_new_group",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/inotify/inotify_user.c",
    "lines": "632-665",
    "snippet": "static struct fsnotify_group *inotify_new_group(unsigned int max_events)\n{\n\tstruct fsnotify_group *group;\n\tstruct inotify_event_info *oevent;\n\n\tgroup = fsnotify_alloc_group(&inotify_fsnotify_ops);\n\tif (IS_ERR(group))\n\t\treturn group;\n\n\toevent = kmalloc(sizeof(struct inotify_event_info), GFP_KERNEL);\n\tif (unlikely(!oevent)) {\n\t\tfsnotify_destroy_group(group);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\tgroup->overflow_event = &oevent->fse;\n\tfsnotify_init_event(group->overflow_event, NULL, FS_Q_OVERFLOW);\n\toevent->wd = -1;\n\toevent->sync_cookie = 0;\n\toevent->name_len = 0;\n\n\tgroup->max_events = max_events;\n\n\tspin_lock_init(&group->inotify_data.idr_lock);\n\tidr_init(&group->inotify_data.idr);\n\tgroup->inotify_data.user = get_current_user();\n\n\tif (atomic_inc_return(&group->inotify_data.user->inotify_devs) >\n\t    inotify_max_user_instances) {\n\t\tfsnotify_destroy_group(group);\n\t\treturn ERR_PTR(-EMFILE);\n\t}\n\n\treturn group;\n}",
    "includes": [
      "#include <linux/sysctl.h>",
      "#include <asm/ioctls.h>",
      "#include \"../fdinfo.h\"",
      "#include \"inotify.h\"",
      "#include <linux/wait.h>",
      "#include <linux/poll.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/types.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h> /* struct kmem_cache */",
      "#include <linux/sched.h> /* struct user */",
      "#include <linux/namei.h> /* LOOKUP_FOLLOW */",
      "#include <linux/kernel.h> /* roundup() */",
      "#include <linux/inotify.h>",
      "#include <linux/init.h> /* module_init */",
      "#include <linux/idr.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/fs.h> /* struct inode */",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int inotify_max_user_instances"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EMFILE"
          ],
          "line": 661
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fsnotify_destroy_group",
          "args": [
            "group"
          ],
          "line": 660
        },
        "resolved": true,
        "details": {
          "function_name": "fsnotify_destroy_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/group.c",
          "lines": "48-66",
          "snippet": "void fsnotify_destroy_group(struct fsnotify_group *group)\n{\n\t/* clear all inode marks for this group */\n\tfsnotify_clear_marks_by_group(group);\n\n\tsynchronize_srcu(&fsnotify_mark_srcu);\n\n\t/* clear the notification queue of all events */\n\tfsnotify_flush_notify(group);\n\n\t/*\n\t * Destroy overflow event (we cannot use fsnotify_destroy_event() as\n\t * that deliberately ignores overflow events.\n\t */\n\tif (group->overflow_event)\n\t\tgroup->ops->free_event(group->overflow_event);\n\n\tfsnotify_put_group(group);\n}",
          "includes": [
            "#include <linux/atomic.h>",
            "#include \"fsnotify.h\"",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/wait.h>",
            "#include <linux/rculist.h>",
            "#include <linux/srcu.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/atomic.h>\n#include \"fsnotify.h\"\n#include <linux/fsnotify_backend.h>\n#include <linux/wait.h>\n#include <linux/rculist.h>\n#include <linux/srcu.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/list.h>\n\nvoid fsnotify_destroy_group(struct fsnotify_group *group)\n{\n\t/* clear all inode marks for this group */\n\tfsnotify_clear_marks_by_group(group);\n\n\tsynchronize_srcu(&fsnotify_mark_srcu);\n\n\t/* clear the notification queue of all events */\n\tfsnotify_flush_notify(group);\n\n\t/*\n\t * Destroy overflow event (we cannot use fsnotify_destroy_event() as\n\t * that deliberately ignores overflow events.\n\t */\n\tif (group->overflow_event)\n\t\tgroup->ops->free_event(group->overflow_event);\n\n\tfsnotify_put_group(group);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_inc_return",
          "args": [
            "&group->inotify_data.user->inotify_devs"
          ],
          "line": 658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_current_user",
          "args": [],
          "line": 656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "idr_init",
          "args": [
            "&group->inotify_data.idr"
          ],
          "line": 655
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&group->inotify_data.idr_lock"
          ],
          "line": 654
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fsnotify_init_event",
          "args": [
            "group->overflow_event",
            "NULL",
            "FS_Q_OVERFLOW"
          ],
          "line": 647
        },
        "resolved": true,
        "details": {
          "function_name": "fsnotify_init_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/notification.c",
          "lines": "207-213",
          "snippet": "void fsnotify_init_event(struct fsnotify_event *event, struct inode *inode,\n\t\t\t u32 mask)\n{\n\tINIT_LIST_HEAD(&event->list);\n\tevent->inode = inode;\n\tevent->mask = mask;\n}",
          "includes": [
            "#include \"fsnotify.h\"",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/atomic.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/path.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mount.h>",
            "#include <linux/module.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fsnotify.h\"\n#include <linux/fsnotify_backend.h>\n#include <linux/atomic.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/path.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n\nvoid fsnotify_init_event(struct fsnotify_event *event, struct inode *inode,\n\t\t\t u32 mask)\n{\n\tINIT_LIST_HEAD(&event->list);\n\tevent->inode = inode;\n\tevent->mask = mask;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 644
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!oevent"
          ],
          "line": 642
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(struct inotify_event_info)",
            "GFP_KERNEL"
          ],
          "line": 641
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "group"
          ],
          "line": 638
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fsnotify_alloc_group",
          "args": [
            "&inotify_fsnotify_ops"
          ],
          "line": 637
        },
        "resolved": true,
        "details": {
          "function_name": "fsnotify_alloc_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/group.c",
          "lines": "88-111",
          "snippet": "struct fsnotify_group *fsnotify_alloc_group(const struct fsnotify_ops *ops)\n{\n\tstruct fsnotify_group *group;\n\n\tgroup = kzalloc(sizeof(struct fsnotify_group), GFP_KERNEL);\n\tif (!group)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\t/* set to 0 when there a no external references to this group */\n\tatomic_set(&group->refcnt, 1);\n\tatomic_set(&group->num_marks, 0);\n\n\tmutex_init(&group->notification_mutex);\n\tINIT_LIST_HEAD(&group->notification_list);\n\tinit_waitqueue_head(&group->notification_waitq);\n\tgroup->max_events = UINT_MAX;\n\n\tmutex_init(&group->mark_mutex);\n\tINIT_LIST_HEAD(&group->marks_list);\n\n\tgroup->ops = ops;\n\n\treturn group;\n}",
          "includes": [
            "#include <linux/atomic.h>",
            "#include \"fsnotify.h\"",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/wait.h>",
            "#include <linux/rculist.h>",
            "#include <linux/srcu.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/atomic.h>\n#include \"fsnotify.h\"\n#include <linux/fsnotify_backend.h>\n#include <linux/wait.h>\n#include <linux/rculist.h>\n#include <linux/srcu.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/list.h>\n\nstruct fsnotify_group *fsnotify_alloc_group(const struct fsnotify_ops *ops)\n{\n\tstruct fsnotify_group *group;\n\n\tgroup = kzalloc(sizeof(struct fsnotify_group), GFP_KERNEL);\n\tif (!group)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\t/* set to 0 when there a no external references to this group */\n\tatomic_set(&group->refcnt, 1);\n\tatomic_set(&group->num_marks, 0);\n\n\tmutex_init(&group->notification_mutex);\n\tINIT_LIST_HEAD(&group->notification_list);\n\tinit_waitqueue_head(&group->notification_waitq);\n\tgroup->max_events = UINT_MAX;\n\n\tmutex_init(&group->mark_mutex);\n\tINIT_LIST_HEAD(&group->marks_list);\n\n\tgroup->ops = ops;\n\n\treturn group;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/sysctl.h>\n#include <asm/ioctls.h>\n#include \"../fdinfo.h\"\n#include \"inotify.h\"\n#include <linux/wait.h>\n#include <linux/poll.h>\n#include <linux/uaccess.h>\n#include <linux/anon_inodes.h>\n#include <linux/types.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h> /* struct kmem_cache */\n#include <linux/sched.h> /* struct user */\n#include <linux/namei.h> /* LOOKUP_FOLLOW */\n#include <linux/kernel.h> /* roundup() */\n#include <linux/inotify.h>\n#include <linux/init.h> /* module_init */\n#include <linux/idr.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/fs.h> /* struct inode */\n#include <linux/file.h>\n\nstatic int inotify_max_user_instances;\n\nstatic struct fsnotify_group *inotify_new_group(unsigned int max_events)\n{\n\tstruct fsnotify_group *group;\n\tstruct inotify_event_info *oevent;\n\n\tgroup = fsnotify_alloc_group(&inotify_fsnotify_ops);\n\tif (IS_ERR(group))\n\t\treturn group;\n\n\toevent = kmalloc(sizeof(struct inotify_event_info), GFP_KERNEL);\n\tif (unlikely(!oevent)) {\n\t\tfsnotify_destroy_group(group);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\tgroup->overflow_event = &oevent->fse;\n\tfsnotify_init_event(group->overflow_event, NULL, FS_Q_OVERFLOW);\n\toevent->wd = -1;\n\toevent->sync_cookie = 0;\n\toevent->name_len = 0;\n\n\tgroup->max_events = max_events;\n\n\tspin_lock_init(&group->inotify_data.idr_lock);\n\tidr_init(&group->inotify_data.idr);\n\tgroup->inotify_data.user = get_current_user();\n\n\tif (atomic_inc_return(&group->inotify_data.user->inotify_devs) >\n\t    inotify_max_user_instances) {\n\t\tfsnotify_destroy_group(group);\n\t\treturn ERR_PTR(-EMFILE);\n\t}\n\n\treturn group;\n}"
  },
  {
    "function_name": "inotify_update_watch",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/inotify/inotify_user.c",
    "lines": "617-630",
    "snippet": "static int inotify_update_watch(struct fsnotify_group *group, struct inode *inode, u32 arg)\n{\n\tint ret = 0;\n\n\tmutex_lock(&group->mark_mutex);\n\t/* try to update and existing watch with the new arg */\n\tret = inotify_update_existing_watch(group, inode, arg);\n\t/* no mark present, try to add a new one */\n\tif (ret == -ENOENT)\n\t\tret = inotify_new_watch(group, inode, arg);\n\tmutex_unlock(&group->mark_mutex);\n\n\treturn ret;\n}",
    "includes": [
      "#include <linux/sysctl.h>",
      "#include <asm/ioctls.h>",
      "#include \"../fdinfo.h\"",
      "#include \"inotify.h\"",
      "#include <linux/wait.h>",
      "#include <linux/poll.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/types.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h> /* struct kmem_cache */",
      "#include <linux/sched.h> /* struct user */",
      "#include <linux/namei.h> /* LOOKUP_FOLLOW */",
      "#include <linux/kernel.h> /* roundup() */",
      "#include <linux/inotify.h>",
      "#include <linux/init.h> /* module_init */",
      "#include <linux/idr.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/fs.h> /* struct inode */",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&group->mark_mutex"
          ],
          "line": 627
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inotify_new_watch",
          "args": [
            "group",
            "inode",
            "arg"
          ],
          "line": 626
        },
        "resolved": true,
        "details": {
          "function_name": "inotify_new_watch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/inotify/inotify_user.c",
          "lines": "567-615",
          "snippet": "static int inotify_new_watch(struct fsnotify_group *group,\n\t\t\t     struct inode *inode,\n\t\t\t     u32 arg)\n{\n\tstruct inotify_inode_mark *tmp_i_mark;\n\t__u32 mask;\n\tint ret;\n\tstruct idr *idr = &group->inotify_data.idr;\n\tspinlock_t *idr_lock = &group->inotify_data.idr_lock;\n\n\tmask = inotify_arg_to_mask(arg);\n\n\ttmp_i_mark = kmem_cache_alloc(inotify_inode_mark_cachep, GFP_KERNEL);\n\tif (unlikely(!tmp_i_mark))\n\t\treturn -ENOMEM;\n\n\tfsnotify_init_mark(&tmp_i_mark->fsn_mark, inotify_free_mark);\n\ttmp_i_mark->fsn_mark.mask = mask;\n\ttmp_i_mark->wd = -1;\n\n\tret = -ENOSPC;\n\tif (atomic_read(&group->inotify_data.user->inotify_watches) >= inotify_max_user_watches)\n\t\tgoto out_err;\n\n\tret = inotify_add_to_idr(idr, idr_lock, tmp_i_mark);\n\tif (ret)\n\t\tgoto out_err;\n\n\t/* we are on the idr, now get on the inode */\n\tret = fsnotify_add_mark_locked(&tmp_i_mark->fsn_mark, group, inode,\n\t\t\t\t       NULL, 0);\n\tif (ret) {\n\t\t/* we failed to get on the inode, get off the idr */\n\t\tinotify_remove_from_idr(group, tmp_i_mark);\n\t\tgoto out_err;\n\t}\n\n\t/* increment the number of watches the user has */\n\tatomic_inc(&group->inotify_data.user->inotify_watches);\n\n\t/* return the watch descriptor for this new mark */\n\tret = tmp_i_mark->wd;\n\nout_err:\n\t/* match the ref from fsnotify_init_mark() */\n\tfsnotify_put_mark(&tmp_i_mark->fsn_mark);\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/sysctl.h>",
            "#include <asm/ioctls.h>",
            "#include \"../fdinfo.h\"",
            "#include \"inotify.h\"",
            "#include <linux/wait.h>",
            "#include <linux/poll.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/types.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h> /* struct kmem_cache */",
            "#include <linux/sched.h> /* struct user */",
            "#include <linux/namei.h> /* LOOKUP_FOLLOW */",
            "#include <linux/kernel.h> /* roundup() */",
            "#include <linux/inotify.h>",
            "#include <linux/init.h> /* module_init */",
            "#include <linux/idr.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/fs.h> /* struct inode */",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int inotify_max_user_watches",
            "static struct kmem_cache *inotify_inode_mark_cachep"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sysctl.h>\n#include <asm/ioctls.h>\n#include \"../fdinfo.h\"\n#include \"inotify.h\"\n#include <linux/wait.h>\n#include <linux/poll.h>\n#include <linux/uaccess.h>\n#include <linux/anon_inodes.h>\n#include <linux/types.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h> /* struct kmem_cache */\n#include <linux/sched.h> /* struct user */\n#include <linux/namei.h> /* LOOKUP_FOLLOW */\n#include <linux/kernel.h> /* roundup() */\n#include <linux/inotify.h>\n#include <linux/init.h> /* module_init */\n#include <linux/idr.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/fs.h> /* struct inode */\n#include <linux/file.h>\n\nstatic int inotify_max_user_watches;\nstatic struct kmem_cache *inotify_inode_mark_cachep;\n\nstatic int inotify_new_watch(struct fsnotify_group *group,\n\t\t\t     struct inode *inode,\n\t\t\t     u32 arg)\n{\n\tstruct inotify_inode_mark *tmp_i_mark;\n\t__u32 mask;\n\tint ret;\n\tstruct idr *idr = &group->inotify_data.idr;\n\tspinlock_t *idr_lock = &group->inotify_data.idr_lock;\n\n\tmask = inotify_arg_to_mask(arg);\n\n\ttmp_i_mark = kmem_cache_alloc(inotify_inode_mark_cachep, GFP_KERNEL);\n\tif (unlikely(!tmp_i_mark))\n\t\treturn -ENOMEM;\n\n\tfsnotify_init_mark(&tmp_i_mark->fsn_mark, inotify_free_mark);\n\ttmp_i_mark->fsn_mark.mask = mask;\n\ttmp_i_mark->wd = -1;\n\n\tret = -ENOSPC;\n\tif (atomic_read(&group->inotify_data.user->inotify_watches) >= inotify_max_user_watches)\n\t\tgoto out_err;\n\n\tret = inotify_add_to_idr(idr, idr_lock, tmp_i_mark);\n\tif (ret)\n\t\tgoto out_err;\n\n\t/* we are on the idr, now get on the inode */\n\tret = fsnotify_add_mark_locked(&tmp_i_mark->fsn_mark, group, inode,\n\t\t\t\t       NULL, 0);\n\tif (ret) {\n\t\t/* we failed to get on the inode, get off the idr */\n\t\tinotify_remove_from_idr(group, tmp_i_mark);\n\t\tgoto out_err;\n\t}\n\n\t/* increment the number of watches the user has */\n\tatomic_inc(&group->inotify_data.user->inotify_watches);\n\n\t/* return the watch descriptor for this new mark */\n\tret = tmp_i_mark->wd;\n\nout_err:\n\t/* match the ref from fsnotify_init_mark() */\n\tfsnotify_put_mark(&tmp_i_mark->fsn_mark);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "inotify_update_existing_watch",
          "args": [
            "group",
            "inode",
            "arg"
          ],
          "line": 623
        },
        "resolved": true,
        "details": {
          "function_name": "inotify_update_existing_watch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/inotify/inotify_user.c",
          "lines": "516-565",
          "snippet": "static int inotify_update_existing_watch(struct fsnotify_group *group,\n\t\t\t\t\t struct inode *inode,\n\t\t\t\t\t u32 arg)\n{\n\tstruct fsnotify_mark *fsn_mark;\n\tstruct inotify_inode_mark *i_mark;\n\t__u32 old_mask, new_mask;\n\t__u32 mask;\n\tint add = (arg & IN_MASK_ADD);\n\tint ret;\n\n\tmask = inotify_arg_to_mask(arg);\n\n\tfsn_mark = fsnotify_find_inode_mark(group, inode);\n\tif (!fsn_mark)\n\t\treturn -ENOENT;\n\n\ti_mark = container_of(fsn_mark, struct inotify_inode_mark, fsn_mark);\n\n\tspin_lock(&fsn_mark->lock);\n\n\told_mask = fsn_mark->mask;\n\tif (add)\n\t\tfsnotify_set_mark_mask_locked(fsn_mark, (fsn_mark->mask | mask));\n\telse\n\t\tfsnotify_set_mark_mask_locked(fsn_mark, mask);\n\tnew_mask = fsn_mark->mask;\n\n\tspin_unlock(&fsn_mark->lock);\n\n\tif (old_mask != new_mask) {\n\t\t/* more bits in old than in new? */\n\t\tint dropped = (old_mask & ~new_mask);\n\t\t/* more bits in this fsn_mark than the inode's mask? */\n\t\tint do_inode = (new_mask & ~inode->i_fsnotify_mask);\n\n\t\t/* update the inode with this new fsn_mark */\n\t\tif (dropped || do_inode)\n\t\t\tfsnotify_recalc_inode_mask(inode);\n\n\t}\n\n\t/* return the wd */\n\tret = i_mark->wd;\n\n\t/* match the get from fsnotify_find_mark() */\n\tfsnotify_put_mark(fsn_mark);\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/sysctl.h>",
            "#include <asm/ioctls.h>",
            "#include \"../fdinfo.h\"",
            "#include \"inotify.h\"",
            "#include <linux/wait.h>",
            "#include <linux/poll.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/types.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h> /* struct kmem_cache */",
            "#include <linux/sched.h> /* struct user */",
            "#include <linux/namei.h> /* LOOKUP_FOLLOW */",
            "#include <linux/kernel.h> /* roundup() */",
            "#include <linux/inotify.h>",
            "#include <linux/init.h> /* module_init */",
            "#include <linux/idr.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/fs.h> /* struct inode */",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sysctl.h>\n#include <asm/ioctls.h>\n#include \"../fdinfo.h\"\n#include \"inotify.h\"\n#include <linux/wait.h>\n#include <linux/poll.h>\n#include <linux/uaccess.h>\n#include <linux/anon_inodes.h>\n#include <linux/types.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h> /* struct kmem_cache */\n#include <linux/sched.h> /* struct user */\n#include <linux/namei.h> /* LOOKUP_FOLLOW */\n#include <linux/kernel.h> /* roundup() */\n#include <linux/inotify.h>\n#include <linux/init.h> /* module_init */\n#include <linux/idr.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/fs.h> /* struct inode */\n#include <linux/file.h>\n\nstatic int inotify_update_existing_watch(struct fsnotify_group *group,\n\t\t\t\t\t struct inode *inode,\n\t\t\t\t\t u32 arg)\n{\n\tstruct fsnotify_mark *fsn_mark;\n\tstruct inotify_inode_mark *i_mark;\n\t__u32 old_mask, new_mask;\n\t__u32 mask;\n\tint add = (arg & IN_MASK_ADD);\n\tint ret;\n\n\tmask = inotify_arg_to_mask(arg);\n\n\tfsn_mark = fsnotify_find_inode_mark(group, inode);\n\tif (!fsn_mark)\n\t\treturn -ENOENT;\n\n\ti_mark = container_of(fsn_mark, struct inotify_inode_mark, fsn_mark);\n\n\tspin_lock(&fsn_mark->lock);\n\n\told_mask = fsn_mark->mask;\n\tif (add)\n\t\tfsnotify_set_mark_mask_locked(fsn_mark, (fsn_mark->mask | mask));\n\telse\n\t\tfsnotify_set_mark_mask_locked(fsn_mark, mask);\n\tnew_mask = fsn_mark->mask;\n\n\tspin_unlock(&fsn_mark->lock);\n\n\tif (old_mask != new_mask) {\n\t\t/* more bits in old than in new? */\n\t\tint dropped = (old_mask & ~new_mask);\n\t\t/* more bits in this fsn_mark than the inode's mask? */\n\t\tint do_inode = (new_mask & ~inode->i_fsnotify_mask);\n\n\t\t/* update the inode with this new fsn_mark */\n\t\tif (dropped || do_inode)\n\t\t\tfsnotify_recalc_inode_mask(inode);\n\n\t}\n\n\t/* return the wd */\n\tret = i_mark->wd;\n\n\t/* match the get from fsnotify_find_mark() */\n\tfsnotify_put_mark(fsn_mark);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&group->mark_mutex"
          ],
          "line": 621
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sysctl.h>\n#include <asm/ioctls.h>\n#include \"../fdinfo.h\"\n#include \"inotify.h\"\n#include <linux/wait.h>\n#include <linux/poll.h>\n#include <linux/uaccess.h>\n#include <linux/anon_inodes.h>\n#include <linux/types.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h> /* struct kmem_cache */\n#include <linux/sched.h> /* struct user */\n#include <linux/namei.h> /* LOOKUP_FOLLOW */\n#include <linux/kernel.h> /* roundup() */\n#include <linux/inotify.h>\n#include <linux/init.h> /* module_init */\n#include <linux/idr.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/fs.h> /* struct inode */\n#include <linux/file.h>\n\nstatic int inotify_update_watch(struct fsnotify_group *group, struct inode *inode, u32 arg)\n{\n\tint ret = 0;\n\n\tmutex_lock(&group->mark_mutex);\n\t/* try to update and existing watch with the new arg */\n\tret = inotify_update_existing_watch(group, inode, arg);\n\t/* no mark present, try to add a new one */\n\tif (ret == -ENOENT)\n\t\tret = inotify_new_watch(group, inode, arg);\n\tmutex_unlock(&group->mark_mutex);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "inotify_new_watch",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/inotify/inotify_user.c",
    "lines": "567-615",
    "snippet": "static int inotify_new_watch(struct fsnotify_group *group,\n\t\t\t     struct inode *inode,\n\t\t\t     u32 arg)\n{\n\tstruct inotify_inode_mark *tmp_i_mark;\n\t__u32 mask;\n\tint ret;\n\tstruct idr *idr = &group->inotify_data.idr;\n\tspinlock_t *idr_lock = &group->inotify_data.idr_lock;\n\n\tmask = inotify_arg_to_mask(arg);\n\n\ttmp_i_mark = kmem_cache_alloc(inotify_inode_mark_cachep, GFP_KERNEL);\n\tif (unlikely(!tmp_i_mark))\n\t\treturn -ENOMEM;\n\n\tfsnotify_init_mark(&tmp_i_mark->fsn_mark, inotify_free_mark);\n\ttmp_i_mark->fsn_mark.mask = mask;\n\ttmp_i_mark->wd = -1;\n\n\tret = -ENOSPC;\n\tif (atomic_read(&group->inotify_data.user->inotify_watches) >= inotify_max_user_watches)\n\t\tgoto out_err;\n\n\tret = inotify_add_to_idr(idr, idr_lock, tmp_i_mark);\n\tif (ret)\n\t\tgoto out_err;\n\n\t/* we are on the idr, now get on the inode */\n\tret = fsnotify_add_mark_locked(&tmp_i_mark->fsn_mark, group, inode,\n\t\t\t\t       NULL, 0);\n\tif (ret) {\n\t\t/* we failed to get on the inode, get off the idr */\n\t\tinotify_remove_from_idr(group, tmp_i_mark);\n\t\tgoto out_err;\n\t}\n\n\t/* increment the number of watches the user has */\n\tatomic_inc(&group->inotify_data.user->inotify_watches);\n\n\t/* return the watch descriptor for this new mark */\n\tret = tmp_i_mark->wd;\n\nout_err:\n\t/* match the ref from fsnotify_init_mark() */\n\tfsnotify_put_mark(&tmp_i_mark->fsn_mark);\n\n\treturn ret;\n}",
    "includes": [
      "#include <linux/sysctl.h>",
      "#include <asm/ioctls.h>",
      "#include \"../fdinfo.h\"",
      "#include \"inotify.h\"",
      "#include <linux/wait.h>",
      "#include <linux/poll.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/types.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h> /* struct kmem_cache */",
      "#include <linux/sched.h> /* struct user */",
      "#include <linux/namei.h> /* LOOKUP_FOLLOW */",
      "#include <linux/kernel.h> /* roundup() */",
      "#include <linux/inotify.h>",
      "#include <linux/init.h> /* module_init */",
      "#include <linux/idr.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/fs.h> /* struct inode */",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int inotify_max_user_watches",
      "static struct kmem_cache *inotify_inode_mark_cachep"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fsnotify_put_mark",
          "args": [
            "&tmp_i_mark->fsn_mark"
          ],
          "line": 612
        },
        "resolved": true,
        "details": {
          "function_name": "fsnotify_put_mark",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/mark.c",
          "lines": "104-111",
          "snippet": "void fsnotify_put_mark(struct fsnotify_mark *mark)\n{\n\tif (atomic_dec_and_test(&mark->refcnt)) {\n\t\tif (mark->group)\n\t\t\tfsnotify_put_group(mark->group);\n\t\tmark->free_mark(mark);\n\t}\n}",
          "includes": [
            "#include \"fsnotify.h\"",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/atomic.h>",
            "#include <linux/srcu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fsnotify.h\"\n#include <linux/fsnotify_backend.h>\n#include <linux/atomic.h>\n#include <linux/srcu.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n\nvoid fsnotify_put_mark(struct fsnotify_mark *mark)\n{\n\tif (atomic_dec_and_test(&mark->refcnt)) {\n\t\tif (mark->group)\n\t\t\tfsnotify_put_group(mark->group);\n\t\tmark->free_mark(mark);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&group->inotify_data.user->inotify_watches"
          ],
          "line": 605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inotify_remove_from_idr",
          "args": [
            "group",
            "tmp_i_mark"
          ],
          "line": 600
        },
        "resolved": true,
        "details": {
          "function_name": "inotify_remove_from_idr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/inotify/inotify_user.c",
          "lines": "419-485",
          "snippet": "static void inotify_remove_from_idr(struct fsnotify_group *group,\n\t\t\t\t    struct inotify_inode_mark *i_mark)\n{\n\tspinlock_t *idr_lock = &group->inotify_data.idr_lock;\n\tstruct inotify_inode_mark *found_i_mark = NULL;\n\tint wd;\n\n\tspin_lock(idr_lock);\n\twd = i_mark->wd;\n\n\t/*\n\t * does this i_mark think it is in the idr?  we shouldn't get called\n\t * if it wasn't....\n\t */\n\tif (wd == -1) {\n\t\tWARN_ONCE(1, \"%s: i_mark=%p i_mark->wd=%d i_mark->group=%p\"\n\t\t\t\" i_mark->inode=%p\\n\", __func__, i_mark, i_mark->wd,\n\t\t\ti_mark->fsn_mark.group, i_mark->fsn_mark.inode);\n\t\tgoto out;\n\t}\n\n\t/* Lets look in the idr to see if we find it */\n\tfound_i_mark = inotify_idr_find_locked(group, wd);\n\tif (unlikely(!found_i_mark)) {\n\t\tWARN_ONCE(1, \"%s: i_mark=%p i_mark->wd=%d i_mark->group=%p\"\n\t\t\t\" i_mark->inode=%p\\n\", __func__, i_mark, i_mark->wd,\n\t\t\ti_mark->fsn_mark.group, i_mark->fsn_mark.inode);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * We found an mark in the idr at the right wd, but it's\n\t * not the mark we were told to remove.  eparis seriously\n\t * fucked up somewhere.\n\t */\n\tif (unlikely(found_i_mark != i_mark)) {\n\t\tWARN_ONCE(1, \"%s: i_mark=%p i_mark->wd=%d i_mark->group=%p \"\n\t\t\t\"mark->inode=%p found_i_mark=%p found_i_mark->wd=%d \"\n\t\t\t\"found_i_mark->group=%p found_i_mark->inode=%p\\n\",\n\t\t\t__func__, i_mark, i_mark->wd, i_mark->fsn_mark.group,\n\t\t\ti_mark->fsn_mark.inode, found_i_mark, found_i_mark->wd,\n\t\t\tfound_i_mark->fsn_mark.group,\n\t\t\tfound_i_mark->fsn_mark.inode);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * One ref for being in the idr\n\t * one ref held by the caller trying to kill us\n\t * one ref grabbed by inotify_idr_find\n\t */\n\tif (unlikely(atomic_read(&i_mark->fsn_mark.refcnt) < 3)) {\n\t\tprintk(KERN_ERR \"%s: i_mark=%p i_mark->wd=%d i_mark->group=%p\"\n\t\t\t\" i_mark->inode=%p\\n\", __func__, i_mark, i_mark->wd,\n\t\t\ti_mark->fsn_mark.group, i_mark->fsn_mark.inode);\n\t\t/* we can't really recover with bad ref cnting.. */\n\t\tBUG();\n\t}\n\n\tdo_inotify_remove_from_idr(group, i_mark);\nout:\n\t/* match the ref taken by inotify_idr_find_locked() */\n\tif (found_i_mark)\n\t\tfsnotify_put_mark(&found_i_mark->fsn_mark);\n\ti_mark->wd = -1;\n\tspin_unlock(idr_lock);\n}",
          "includes": [
            "#include <linux/sysctl.h>",
            "#include <asm/ioctls.h>",
            "#include \"../fdinfo.h\"",
            "#include \"inotify.h\"",
            "#include <linux/wait.h>",
            "#include <linux/poll.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/types.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h> /* struct kmem_cache */",
            "#include <linux/sched.h> /* struct user */",
            "#include <linux/namei.h> /* LOOKUP_FOLLOW */",
            "#include <linux/kernel.h> /* roundup() */",
            "#include <linux/inotify.h>",
            "#include <linux/init.h> /* module_init */",
            "#include <linux/idr.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/fs.h> /* struct inode */",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sysctl.h>\n#include <asm/ioctls.h>\n#include \"../fdinfo.h\"\n#include \"inotify.h\"\n#include <linux/wait.h>\n#include <linux/poll.h>\n#include <linux/uaccess.h>\n#include <linux/anon_inodes.h>\n#include <linux/types.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h> /* struct kmem_cache */\n#include <linux/sched.h> /* struct user */\n#include <linux/namei.h> /* LOOKUP_FOLLOW */\n#include <linux/kernel.h> /* roundup() */\n#include <linux/inotify.h>\n#include <linux/init.h> /* module_init */\n#include <linux/idr.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/fs.h> /* struct inode */\n#include <linux/file.h>\n\nstatic void inotify_remove_from_idr(struct fsnotify_group *group,\n\t\t\t\t    struct inotify_inode_mark *i_mark)\n{\n\tspinlock_t *idr_lock = &group->inotify_data.idr_lock;\n\tstruct inotify_inode_mark *found_i_mark = NULL;\n\tint wd;\n\n\tspin_lock(idr_lock);\n\twd = i_mark->wd;\n\n\t/*\n\t * does this i_mark think it is in the idr?  we shouldn't get called\n\t * if it wasn't....\n\t */\n\tif (wd == -1) {\n\t\tWARN_ONCE(1, \"%s: i_mark=%p i_mark->wd=%d i_mark->group=%p\"\n\t\t\t\" i_mark->inode=%p\\n\", __func__, i_mark, i_mark->wd,\n\t\t\ti_mark->fsn_mark.group, i_mark->fsn_mark.inode);\n\t\tgoto out;\n\t}\n\n\t/* Lets look in the idr to see if we find it */\n\tfound_i_mark = inotify_idr_find_locked(group, wd);\n\tif (unlikely(!found_i_mark)) {\n\t\tWARN_ONCE(1, \"%s: i_mark=%p i_mark->wd=%d i_mark->group=%p\"\n\t\t\t\" i_mark->inode=%p\\n\", __func__, i_mark, i_mark->wd,\n\t\t\ti_mark->fsn_mark.group, i_mark->fsn_mark.inode);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * We found an mark in the idr at the right wd, but it's\n\t * not the mark we were told to remove.  eparis seriously\n\t * fucked up somewhere.\n\t */\n\tif (unlikely(found_i_mark != i_mark)) {\n\t\tWARN_ONCE(1, \"%s: i_mark=%p i_mark->wd=%d i_mark->group=%p \"\n\t\t\t\"mark->inode=%p found_i_mark=%p found_i_mark->wd=%d \"\n\t\t\t\"found_i_mark->group=%p found_i_mark->inode=%p\\n\",\n\t\t\t__func__, i_mark, i_mark->wd, i_mark->fsn_mark.group,\n\t\t\ti_mark->fsn_mark.inode, found_i_mark, found_i_mark->wd,\n\t\t\tfound_i_mark->fsn_mark.group,\n\t\t\tfound_i_mark->fsn_mark.inode);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * One ref for being in the idr\n\t * one ref held by the caller trying to kill us\n\t * one ref grabbed by inotify_idr_find\n\t */\n\tif (unlikely(atomic_read(&i_mark->fsn_mark.refcnt) < 3)) {\n\t\tprintk(KERN_ERR \"%s: i_mark=%p i_mark->wd=%d i_mark->group=%p\"\n\t\t\t\" i_mark->inode=%p\\n\", __func__, i_mark, i_mark->wd,\n\t\t\ti_mark->fsn_mark.group, i_mark->fsn_mark.inode);\n\t\t/* we can't really recover with bad ref cnting.. */\n\t\tBUG();\n\t}\n\n\tdo_inotify_remove_from_idr(group, i_mark);\nout:\n\t/* match the ref taken by inotify_idr_find_locked() */\n\tif (found_i_mark)\n\t\tfsnotify_put_mark(&found_i_mark->fsn_mark);\n\ti_mark->wd = -1;\n\tspin_unlock(idr_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fsnotify_add_mark_locked",
          "args": [
            "&tmp_i_mark->fsn_mark",
            "group",
            "inode",
            "NULL",
            "0"
          ],
          "line": 596
        },
        "resolved": true,
        "details": {
          "function_name": "fsnotify_add_mark_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/mark.c",
          "lines": "318-378",
          "snippet": "int fsnotify_add_mark_locked(struct fsnotify_mark *mark,\n\t\t\t     struct fsnotify_group *group, struct inode *inode,\n\t\t\t     struct vfsmount *mnt, int allow_dups)\n{\n\tint ret = 0;\n\n\tBUG_ON(inode && mnt);\n\tBUG_ON(!inode && !mnt);\n\tBUG_ON(!mutex_is_locked(&group->mark_mutex));\n\n\t/*\n\t * LOCKING ORDER!!!!\n\t * group->mark_mutex\n\t * mark->lock\n\t * inode->i_lock\n\t */\n\tspin_lock(&mark->lock);\n\tmark->flags |= FSNOTIFY_MARK_FLAG_ALIVE;\n\n\tfsnotify_get_group(group);\n\tmark->group = group;\n\tlist_add(&mark->g_list, &group->marks_list);\n\tatomic_inc(&group->num_marks);\n\tfsnotify_get_mark(mark); /* for i_list and g_list */\n\n\tif (inode) {\n\t\tret = fsnotify_add_inode_mark(mark, group, inode, allow_dups);\n\t\tif (ret)\n\t\t\tgoto err;\n\t} else if (mnt) {\n\t\tret = fsnotify_add_vfsmount_mark(mark, group, mnt, allow_dups);\n\t\tif (ret)\n\t\t\tgoto err;\n\t} else {\n\t\tBUG();\n\t}\n\n\t/* this will pin the object if appropriate */\n\tfsnotify_set_mark_mask_locked(mark, mark->mask);\n\tspin_unlock(&mark->lock);\n\n\tif (inode)\n\t\t__fsnotify_update_child_dentry_flags(inode);\n\n\treturn ret;\nerr:\n\tmark->flags &= ~FSNOTIFY_MARK_FLAG_ALIVE;\n\tlist_del_init(&mark->g_list);\n\tfsnotify_put_group(group);\n\tmark->group = NULL;\n\tatomic_dec(&group->num_marks);\n\n\tspin_unlock(&mark->lock);\n\n\tspin_lock(&destroy_lock);\n\tlist_add(&mark->g_list, &destroy_list);\n\tspin_unlock(&destroy_lock);\n\twake_up(&destroy_waitq);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"fsnotify.h\"",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/atomic.h>",
            "#include <linux/srcu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(destroy_lock);",
            "static LIST_HEAD(destroy_list);",
            "static DECLARE_WAIT_QUEUE_HEAD(destroy_waitq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"fsnotify.h\"\n#include <linux/fsnotify_backend.h>\n#include <linux/atomic.h>\n#include <linux/srcu.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n\nstatic DEFINE_SPINLOCK(destroy_lock);\nstatic LIST_HEAD(destroy_list);\nstatic DECLARE_WAIT_QUEUE_HEAD(destroy_waitq);\n\nint fsnotify_add_mark_locked(struct fsnotify_mark *mark,\n\t\t\t     struct fsnotify_group *group, struct inode *inode,\n\t\t\t     struct vfsmount *mnt, int allow_dups)\n{\n\tint ret = 0;\n\n\tBUG_ON(inode && mnt);\n\tBUG_ON(!inode && !mnt);\n\tBUG_ON(!mutex_is_locked(&group->mark_mutex));\n\n\t/*\n\t * LOCKING ORDER!!!!\n\t * group->mark_mutex\n\t * mark->lock\n\t * inode->i_lock\n\t */\n\tspin_lock(&mark->lock);\n\tmark->flags |= FSNOTIFY_MARK_FLAG_ALIVE;\n\n\tfsnotify_get_group(group);\n\tmark->group = group;\n\tlist_add(&mark->g_list, &group->marks_list);\n\tatomic_inc(&group->num_marks);\n\tfsnotify_get_mark(mark); /* for i_list and g_list */\n\n\tif (inode) {\n\t\tret = fsnotify_add_inode_mark(mark, group, inode, allow_dups);\n\t\tif (ret)\n\t\t\tgoto err;\n\t} else if (mnt) {\n\t\tret = fsnotify_add_vfsmount_mark(mark, group, mnt, allow_dups);\n\t\tif (ret)\n\t\t\tgoto err;\n\t} else {\n\t\tBUG();\n\t}\n\n\t/* this will pin the object if appropriate */\n\tfsnotify_set_mark_mask_locked(mark, mark->mask);\n\tspin_unlock(&mark->lock);\n\n\tif (inode)\n\t\t__fsnotify_update_child_dentry_flags(inode);\n\n\treturn ret;\nerr:\n\tmark->flags &= ~FSNOTIFY_MARK_FLAG_ALIVE;\n\tlist_del_init(&mark->g_list);\n\tfsnotify_put_group(group);\n\tmark->group = NULL;\n\tatomic_dec(&group->num_marks);\n\n\tspin_unlock(&mark->lock);\n\n\tspin_lock(&destroy_lock);\n\tlist_add(&mark->g_list, &destroy_list);\n\tspin_unlock(&destroy_lock);\n\twake_up(&destroy_waitq);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "inotify_add_to_idr",
          "args": [
            "idr",
            "idr_lock",
            "tmp_i_mark"
          ],
          "line": 591
        },
        "resolved": true,
        "details": {
          "function_name": "inotify_add_to_idr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/inotify/inotify_user.c",
          "lines": "346-364",
          "snippet": "static int inotify_add_to_idr(struct idr *idr, spinlock_t *idr_lock,\n\t\t\t      struct inotify_inode_mark *i_mark)\n{\n\tint ret;\n\n\tidr_preload(GFP_KERNEL);\n\tspin_lock(idr_lock);\n\n\tret = idr_alloc_cyclic(idr, i_mark, 1, 0, GFP_NOWAIT);\n\tif (ret >= 0) {\n\t\t/* we added the mark to the idr, take a reference */\n\t\ti_mark->wd = ret;\n\t\tfsnotify_get_mark(&i_mark->fsn_mark);\n\t}\n\n\tspin_unlock(idr_lock);\n\tidr_preload_end();\n\treturn ret < 0 ? ret : 0;\n}",
          "includes": [
            "#include <linux/sysctl.h>",
            "#include <asm/ioctls.h>",
            "#include \"../fdinfo.h\"",
            "#include \"inotify.h\"",
            "#include <linux/wait.h>",
            "#include <linux/poll.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/types.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h> /* struct kmem_cache */",
            "#include <linux/sched.h> /* struct user */",
            "#include <linux/namei.h> /* LOOKUP_FOLLOW */",
            "#include <linux/kernel.h> /* roundup() */",
            "#include <linux/inotify.h>",
            "#include <linux/init.h> /* module_init */",
            "#include <linux/idr.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/fs.h> /* struct inode */",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sysctl.h>\n#include <asm/ioctls.h>\n#include \"../fdinfo.h\"\n#include \"inotify.h\"\n#include <linux/wait.h>\n#include <linux/poll.h>\n#include <linux/uaccess.h>\n#include <linux/anon_inodes.h>\n#include <linux/types.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h> /* struct kmem_cache */\n#include <linux/sched.h> /* struct user */\n#include <linux/namei.h> /* LOOKUP_FOLLOW */\n#include <linux/kernel.h> /* roundup() */\n#include <linux/inotify.h>\n#include <linux/init.h> /* module_init */\n#include <linux/idr.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/fs.h> /* struct inode */\n#include <linux/file.h>\n\nstatic int inotify_add_to_idr(struct idr *idr, spinlock_t *idr_lock,\n\t\t\t      struct inotify_inode_mark *i_mark)\n{\n\tint ret;\n\n\tidr_preload(GFP_KERNEL);\n\tspin_lock(idr_lock);\n\n\tret = idr_alloc_cyclic(idr, i_mark, 1, 0, GFP_NOWAIT);\n\tif (ret >= 0) {\n\t\t/* we added the mark to the idr, take a reference */\n\t\ti_mark->wd = ret;\n\t\tfsnotify_get_mark(&i_mark->fsn_mark);\n\t}\n\n\tspin_unlock(idr_lock);\n\tidr_preload_end();\n\treturn ret < 0 ? ret : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&group->inotify_data.user->inotify_watches"
          ],
          "line": 588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fsnotify_init_mark",
          "args": [
            "&tmp_i_mark->fsn_mark",
            "inotify_free_mark"
          ],
          "line": 583
        },
        "resolved": true,
        "details": {
          "function_name": "fsnotify_init_mark",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/mark.c",
          "lines": "450-457",
          "snippet": "void fsnotify_init_mark(struct fsnotify_mark *mark,\n\t\t\tvoid (*free_mark)(struct fsnotify_mark *mark))\n{\n\tmemset(mark, 0, sizeof(*mark));\n\tspin_lock_init(&mark->lock);\n\tatomic_set(&mark->refcnt, 1);\n\tmark->free_mark = free_mark;\n}",
          "includes": [
            "#include \"fsnotify.h\"",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/atomic.h>",
            "#include <linux/srcu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fsnotify.h\"\n#include <linux/fsnotify_backend.h>\n#include <linux/atomic.h>\n#include <linux/srcu.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n\nvoid fsnotify_init_mark(struct fsnotify_mark *mark,\n\t\t\tvoid (*free_mark)(struct fsnotify_mark *mark))\n{\n\tmemset(mark, 0, sizeof(*mark));\n\tspin_lock_init(&mark->lock);\n\tatomic_set(&mark->refcnt, 1);\n\tmark->free_mark = free_mark;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!tmp_i_mark"
          ],
          "line": 580
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_alloc",
          "args": [
            "inotify_inode_mark_cachep",
            "GFP_KERNEL"
          ],
          "line": 579
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_kmem_cache_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1064-1076",
          "snippet": "static inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\nretry:\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry) {\n\t\tcond_resched();\n\t\tgoto retry;\n\t}\n\n\treturn entry;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\nretry:\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry) {\n\t\tcond_resched();\n\t\tgoto retry;\n\t}\n\n\treturn entry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "inotify_arg_to_mask",
          "args": [
            "arg"
          ],
          "line": 577
        },
        "resolved": true,
        "details": {
          "function_name": "inotify_arg_to_mask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/inotify/inotify_user.c",
          "lines": "89-103",
          "snippet": "static inline __u32 inotify_arg_to_mask(u32 arg)\n{\n\t__u32 mask;\n\n\t/*\n\t * everything should accept their own ignored, cares about children,\n\t * and should receive events when the inode is unmounted\n\t */\n\tmask = (FS_IN_IGNORED | FS_EVENT_ON_CHILD | FS_UNMOUNT);\n\n\t/* mask off the flags used to open the fd */\n\tmask |= (arg & (IN_ALL_EVENTS | IN_ONESHOT | IN_EXCL_UNLINK));\n\n\treturn mask;\n}",
          "includes": [
            "#include <linux/sysctl.h>",
            "#include <asm/ioctls.h>",
            "#include \"../fdinfo.h\"",
            "#include \"inotify.h\"",
            "#include <linux/wait.h>",
            "#include <linux/poll.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/types.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h> /* struct kmem_cache */",
            "#include <linux/sched.h> /* struct user */",
            "#include <linux/namei.h> /* LOOKUP_FOLLOW */",
            "#include <linux/kernel.h> /* roundup() */",
            "#include <linux/inotify.h>",
            "#include <linux/init.h> /* module_init */",
            "#include <linux/idr.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/fs.h> /* struct inode */",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sysctl.h>\n#include <asm/ioctls.h>\n#include \"../fdinfo.h\"\n#include \"inotify.h\"\n#include <linux/wait.h>\n#include <linux/poll.h>\n#include <linux/uaccess.h>\n#include <linux/anon_inodes.h>\n#include <linux/types.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h> /* struct kmem_cache */\n#include <linux/sched.h> /* struct user */\n#include <linux/namei.h> /* LOOKUP_FOLLOW */\n#include <linux/kernel.h> /* roundup() */\n#include <linux/inotify.h>\n#include <linux/init.h> /* module_init */\n#include <linux/idr.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/fs.h> /* struct inode */\n#include <linux/file.h>\n\nstatic inline __u32 inotify_arg_to_mask(u32 arg)\n{\n\t__u32 mask;\n\n\t/*\n\t * everything should accept their own ignored, cares about children,\n\t * and should receive events when the inode is unmounted\n\t */\n\tmask = (FS_IN_IGNORED | FS_EVENT_ON_CHILD | FS_UNMOUNT);\n\n\t/* mask off the flags used to open the fd */\n\tmask |= (arg & (IN_ALL_EVENTS | IN_ONESHOT | IN_EXCL_UNLINK));\n\n\treturn mask;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/sysctl.h>\n#include <asm/ioctls.h>\n#include \"../fdinfo.h\"\n#include \"inotify.h\"\n#include <linux/wait.h>\n#include <linux/poll.h>\n#include <linux/uaccess.h>\n#include <linux/anon_inodes.h>\n#include <linux/types.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h> /* struct kmem_cache */\n#include <linux/sched.h> /* struct user */\n#include <linux/namei.h> /* LOOKUP_FOLLOW */\n#include <linux/kernel.h> /* roundup() */\n#include <linux/inotify.h>\n#include <linux/init.h> /* module_init */\n#include <linux/idr.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/fs.h> /* struct inode */\n#include <linux/file.h>\n\nstatic int inotify_max_user_watches;\nstatic struct kmem_cache *inotify_inode_mark_cachep;\n\nstatic int inotify_new_watch(struct fsnotify_group *group,\n\t\t\t     struct inode *inode,\n\t\t\t     u32 arg)\n{\n\tstruct inotify_inode_mark *tmp_i_mark;\n\t__u32 mask;\n\tint ret;\n\tstruct idr *idr = &group->inotify_data.idr;\n\tspinlock_t *idr_lock = &group->inotify_data.idr_lock;\n\n\tmask = inotify_arg_to_mask(arg);\n\n\ttmp_i_mark = kmem_cache_alloc(inotify_inode_mark_cachep, GFP_KERNEL);\n\tif (unlikely(!tmp_i_mark))\n\t\treturn -ENOMEM;\n\n\tfsnotify_init_mark(&tmp_i_mark->fsn_mark, inotify_free_mark);\n\ttmp_i_mark->fsn_mark.mask = mask;\n\ttmp_i_mark->wd = -1;\n\n\tret = -ENOSPC;\n\tif (atomic_read(&group->inotify_data.user->inotify_watches) >= inotify_max_user_watches)\n\t\tgoto out_err;\n\n\tret = inotify_add_to_idr(idr, idr_lock, tmp_i_mark);\n\tif (ret)\n\t\tgoto out_err;\n\n\t/* we are on the idr, now get on the inode */\n\tret = fsnotify_add_mark_locked(&tmp_i_mark->fsn_mark, group, inode,\n\t\t\t\t       NULL, 0);\n\tif (ret) {\n\t\t/* we failed to get on the inode, get off the idr */\n\t\tinotify_remove_from_idr(group, tmp_i_mark);\n\t\tgoto out_err;\n\t}\n\n\t/* increment the number of watches the user has */\n\tatomic_inc(&group->inotify_data.user->inotify_watches);\n\n\t/* return the watch descriptor for this new mark */\n\tret = tmp_i_mark->wd;\n\nout_err:\n\t/* match the ref from fsnotify_init_mark() */\n\tfsnotify_put_mark(&tmp_i_mark->fsn_mark);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "inotify_update_existing_watch",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/inotify/inotify_user.c",
    "lines": "516-565",
    "snippet": "static int inotify_update_existing_watch(struct fsnotify_group *group,\n\t\t\t\t\t struct inode *inode,\n\t\t\t\t\t u32 arg)\n{\n\tstruct fsnotify_mark *fsn_mark;\n\tstruct inotify_inode_mark *i_mark;\n\t__u32 old_mask, new_mask;\n\t__u32 mask;\n\tint add = (arg & IN_MASK_ADD);\n\tint ret;\n\n\tmask = inotify_arg_to_mask(arg);\n\n\tfsn_mark = fsnotify_find_inode_mark(group, inode);\n\tif (!fsn_mark)\n\t\treturn -ENOENT;\n\n\ti_mark = container_of(fsn_mark, struct inotify_inode_mark, fsn_mark);\n\n\tspin_lock(&fsn_mark->lock);\n\n\told_mask = fsn_mark->mask;\n\tif (add)\n\t\tfsnotify_set_mark_mask_locked(fsn_mark, (fsn_mark->mask | mask));\n\telse\n\t\tfsnotify_set_mark_mask_locked(fsn_mark, mask);\n\tnew_mask = fsn_mark->mask;\n\n\tspin_unlock(&fsn_mark->lock);\n\n\tif (old_mask != new_mask) {\n\t\t/* more bits in old than in new? */\n\t\tint dropped = (old_mask & ~new_mask);\n\t\t/* more bits in this fsn_mark than the inode's mask? */\n\t\tint do_inode = (new_mask & ~inode->i_fsnotify_mask);\n\n\t\t/* update the inode with this new fsn_mark */\n\t\tif (dropped || do_inode)\n\t\t\tfsnotify_recalc_inode_mask(inode);\n\n\t}\n\n\t/* return the wd */\n\tret = i_mark->wd;\n\n\t/* match the get from fsnotify_find_mark() */\n\tfsnotify_put_mark(fsn_mark);\n\n\treturn ret;\n}",
    "includes": [
      "#include <linux/sysctl.h>",
      "#include <asm/ioctls.h>",
      "#include \"../fdinfo.h\"",
      "#include \"inotify.h\"",
      "#include <linux/wait.h>",
      "#include <linux/poll.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/types.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h> /* struct kmem_cache */",
      "#include <linux/sched.h> /* struct user */",
      "#include <linux/namei.h> /* LOOKUP_FOLLOW */",
      "#include <linux/kernel.h> /* roundup() */",
      "#include <linux/inotify.h>",
      "#include <linux/init.h> /* module_init */",
      "#include <linux/idr.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/fs.h> /* struct inode */",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fsnotify_put_mark",
          "args": [
            "fsn_mark"
          ],
          "line": 562
        },
        "resolved": true,
        "details": {
          "function_name": "fsnotify_put_mark",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/mark.c",
          "lines": "104-111",
          "snippet": "void fsnotify_put_mark(struct fsnotify_mark *mark)\n{\n\tif (atomic_dec_and_test(&mark->refcnt)) {\n\t\tif (mark->group)\n\t\t\tfsnotify_put_group(mark->group);\n\t\tmark->free_mark(mark);\n\t}\n}",
          "includes": [
            "#include \"fsnotify.h\"",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/atomic.h>",
            "#include <linux/srcu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fsnotify.h\"\n#include <linux/fsnotify_backend.h>\n#include <linux/atomic.h>\n#include <linux/srcu.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n\nvoid fsnotify_put_mark(struct fsnotify_mark *mark)\n{\n\tif (atomic_dec_and_test(&mark->refcnt)) {\n\t\tif (mark->group)\n\t\t\tfsnotify_put_group(mark->group);\n\t\tmark->free_mark(mark);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fsnotify_recalc_inode_mask",
          "args": [
            "inode"
          ],
          "line": 554
        },
        "resolved": true,
        "details": {
          "function_name": "fsnotify_recalc_inode_mask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/inode_mark.c",
          "lines": "37-44",
          "snippet": "void fsnotify_recalc_inode_mask(struct inode *inode)\n{\n\tspin_lock(&inode->i_lock);\n\tinode->i_fsnotify_mask = fsnotify_recalc_mask(&inode->i_fsnotify_marks);\n\tspin_unlock(&inode->i_lock);\n\n\t__fsnotify_update_child_dentry_flags(inode);\n}",
          "includes": [
            "#include \"../internal.h\"",
            "#include \"fsnotify.h\"",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/atomic.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../internal.h\"\n#include \"fsnotify.h\"\n#include <linux/fsnotify_backend.h>\n#include <linux/atomic.h>\n#include <linux/spinlock.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n\nvoid fsnotify_recalc_inode_mask(struct inode *inode)\n{\n\tspin_lock(&inode->i_lock);\n\tinode->i_fsnotify_mask = fsnotify_recalc_mask(&inode->i_fsnotify_marks);\n\tspin_unlock(&inode->i_lock);\n\n\t__fsnotify_update_child_dentry_flags(inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&fsn_mark->lock"
          ],
          "line": 544
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "fsnotify_set_mark_mask_locked",
          "args": [
            "fsn_mark",
            "mask"
          ],
          "line": 541
        },
        "resolved": true,
        "details": {
          "function_name": "fsnotify_set_mark_mask_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/mark.c",
          "lines": "227-235",
          "snippet": "void fsnotify_set_mark_mask_locked(struct fsnotify_mark *mark, __u32 mask)\n{\n\tassert_spin_locked(&mark->lock);\n\n\tmark->mask = mask;\n\n\tif (mark->flags & FSNOTIFY_MARK_FLAG_INODE)\n\t\tfsnotify_set_inode_mark_mask_locked(mark, mask);\n}",
          "includes": [
            "#include \"fsnotify.h\"",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/atomic.h>",
            "#include <linux/srcu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fsnotify.h\"\n#include <linux/fsnotify_backend.h>\n#include <linux/atomic.h>\n#include <linux/srcu.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n\nvoid fsnotify_set_mark_mask_locked(struct fsnotify_mark *mark, __u32 mask)\n{\n\tassert_spin_locked(&mark->lock);\n\n\tmark->mask = mask;\n\n\tif (mark->flags & FSNOTIFY_MARK_FLAG_INODE)\n\t\tfsnotify_set_inode_mark_mask_locked(mark, mask);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&fsn_mark->lock"
          ],
          "line": 535
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "fsn_mark",
            "structinotify_inode_mark",
            "fsn_mark"
          ],
          "line": 533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fsnotify_find_inode_mark",
          "args": [
            "group",
            "inode"
          ],
          "line": 529
        },
        "resolved": true,
        "details": {
          "function_name": "fsnotify_find_inode_mark",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/inode_mark.c",
          "lines": "99-109",
          "snippet": "struct fsnotify_mark *fsnotify_find_inode_mark(struct fsnotify_group *group,\n\t\t\t\t\t       struct inode *inode)\n{\n\tstruct fsnotify_mark *mark;\n\n\tspin_lock(&inode->i_lock);\n\tmark = fsnotify_find_mark(&inode->i_fsnotify_marks, group);\n\tspin_unlock(&inode->i_lock);\n\n\treturn mark;\n}",
          "includes": [
            "#include \"../internal.h\"",
            "#include \"fsnotify.h\"",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/atomic.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../internal.h\"\n#include \"fsnotify.h\"\n#include <linux/fsnotify_backend.h>\n#include <linux/atomic.h>\n#include <linux/spinlock.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n\nstruct fsnotify_mark *fsnotify_find_inode_mark(struct fsnotify_group *group,\n\t\t\t\t\t       struct inode *inode)\n{\n\tstruct fsnotify_mark *mark;\n\n\tspin_lock(&inode->i_lock);\n\tmark = fsnotify_find_mark(&inode->i_fsnotify_marks, group);\n\tspin_unlock(&inode->i_lock);\n\n\treturn mark;\n}"
        }
      },
      {
        "call_info": {
          "callee": "inotify_arg_to_mask",
          "args": [
            "arg"
          ],
          "line": 527
        },
        "resolved": true,
        "details": {
          "function_name": "inotify_arg_to_mask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/inotify/inotify_user.c",
          "lines": "89-103",
          "snippet": "static inline __u32 inotify_arg_to_mask(u32 arg)\n{\n\t__u32 mask;\n\n\t/*\n\t * everything should accept their own ignored, cares about children,\n\t * and should receive events when the inode is unmounted\n\t */\n\tmask = (FS_IN_IGNORED | FS_EVENT_ON_CHILD | FS_UNMOUNT);\n\n\t/* mask off the flags used to open the fd */\n\tmask |= (arg & (IN_ALL_EVENTS | IN_ONESHOT | IN_EXCL_UNLINK));\n\n\treturn mask;\n}",
          "includes": [
            "#include <linux/sysctl.h>",
            "#include <asm/ioctls.h>",
            "#include \"../fdinfo.h\"",
            "#include \"inotify.h\"",
            "#include <linux/wait.h>",
            "#include <linux/poll.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/types.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h> /* struct kmem_cache */",
            "#include <linux/sched.h> /* struct user */",
            "#include <linux/namei.h> /* LOOKUP_FOLLOW */",
            "#include <linux/kernel.h> /* roundup() */",
            "#include <linux/inotify.h>",
            "#include <linux/init.h> /* module_init */",
            "#include <linux/idr.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/fs.h> /* struct inode */",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sysctl.h>\n#include <asm/ioctls.h>\n#include \"../fdinfo.h\"\n#include \"inotify.h\"\n#include <linux/wait.h>\n#include <linux/poll.h>\n#include <linux/uaccess.h>\n#include <linux/anon_inodes.h>\n#include <linux/types.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h> /* struct kmem_cache */\n#include <linux/sched.h> /* struct user */\n#include <linux/namei.h> /* LOOKUP_FOLLOW */\n#include <linux/kernel.h> /* roundup() */\n#include <linux/inotify.h>\n#include <linux/init.h> /* module_init */\n#include <linux/idr.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/fs.h> /* struct inode */\n#include <linux/file.h>\n\nstatic inline __u32 inotify_arg_to_mask(u32 arg)\n{\n\t__u32 mask;\n\n\t/*\n\t * everything should accept their own ignored, cares about children,\n\t * and should receive events when the inode is unmounted\n\t */\n\tmask = (FS_IN_IGNORED | FS_EVENT_ON_CHILD | FS_UNMOUNT);\n\n\t/* mask off the flags used to open the fd */\n\tmask |= (arg & (IN_ALL_EVENTS | IN_ONESHOT | IN_EXCL_UNLINK));\n\n\treturn mask;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/sysctl.h>\n#include <asm/ioctls.h>\n#include \"../fdinfo.h\"\n#include \"inotify.h\"\n#include <linux/wait.h>\n#include <linux/poll.h>\n#include <linux/uaccess.h>\n#include <linux/anon_inodes.h>\n#include <linux/types.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h> /* struct kmem_cache */\n#include <linux/sched.h> /* struct user */\n#include <linux/namei.h> /* LOOKUP_FOLLOW */\n#include <linux/kernel.h> /* roundup() */\n#include <linux/inotify.h>\n#include <linux/init.h> /* module_init */\n#include <linux/idr.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/fs.h> /* struct inode */\n#include <linux/file.h>\n\nstatic int inotify_update_existing_watch(struct fsnotify_group *group,\n\t\t\t\t\t struct inode *inode,\n\t\t\t\t\t u32 arg)\n{\n\tstruct fsnotify_mark *fsn_mark;\n\tstruct inotify_inode_mark *i_mark;\n\t__u32 old_mask, new_mask;\n\t__u32 mask;\n\tint add = (arg & IN_MASK_ADD);\n\tint ret;\n\n\tmask = inotify_arg_to_mask(arg);\n\n\tfsn_mark = fsnotify_find_inode_mark(group, inode);\n\tif (!fsn_mark)\n\t\treturn -ENOENT;\n\n\ti_mark = container_of(fsn_mark, struct inotify_inode_mark, fsn_mark);\n\n\tspin_lock(&fsn_mark->lock);\n\n\told_mask = fsn_mark->mask;\n\tif (add)\n\t\tfsnotify_set_mark_mask_locked(fsn_mark, (fsn_mark->mask | mask));\n\telse\n\t\tfsnotify_set_mark_mask_locked(fsn_mark, mask);\n\tnew_mask = fsn_mark->mask;\n\n\tspin_unlock(&fsn_mark->lock);\n\n\tif (old_mask != new_mask) {\n\t\t/* more bits in old than in new? */\n\t\tint dropped = (old_mask & ~new_mask);\n\t\t/* more bits in this fsn_mark than the inode's mask? */\n\t\tint do_inode = (new_mask & ~inode->i_fsnotify_mask);\n\n\t\t/* update the inode with this new fsn_mark */\n\t\tif (dropped || do_inode)\n\t\t\tfsnotify_recalc_inode_mask(inode);\n\n\t}\n\n\t/* return the wd */\n\tret = i_mark->wd;\n\n\t/* match the get from fsnotify_find_mark() */\n\tfsnotify_put_mark(fsn_mark);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "inotify_free_mark",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/inotify/inotify_user.c",
    "lines": "507-514",
    "snippet": "static void inotify_free_mark(struct fsnotify_mark *fsn_mark)\n{\n\tstruct inotify_inode_mark *i_mark;\n\n\ti_mark = container_of(fsn_mark, struct inotify_inode_mark, fsn_mark);\n\n\tkmem_cache_free(inotify_inode_mark_cachep, i_mark);\n}",
    "includes": [
      "#include <linux/sysctl.h>",
      "#include <asm/ioctls.h>",
      "#include \"../fdinfo.h\"",
      "#include \"inotify.h\"",
      "#include <linux/wait.h>",
      "#include <linux/poll.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/types.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h> /* struct kmem_cache */",
      "#include <linux/sched.h> /* struct user */",
      "#include <linux/namei.h> /* LOOKUP_FOLLOW */",
      "#include <linux/kernel.h> /* roundup() */",
      "#include <linux/inotify.h>",
      "#include <linux/init.h> /* module_init */",
      "#include <linux/idr.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/fs.h> /* struct inode */",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *inotify_inode_mark_cachep"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "inotify_inode_mark_cachep",
            "i_mark"
          ],
          "line": 513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "fsn_mark",
            "structinotify_inode_mark",
            "fsn_mark"
          ],
          "line": 511
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sysctl.h>\n#include <asm/ioctls.h>\n#include \"../fdinfo.h\"\n#include \"inotify.h\"\n#include <linux/wait.h>\n#include <linux/poll.h>\n#include <linux/uaccess.h>\n#include <linux/anon_inodes.h>\n#include <linux/types.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h> /* struct kmem_cache */\n#include <linux/sched.h> /* struct user */\n#include <linux/namei.h> /* LOOKUP_FOLLOW */\n#include <linux/kernel.h> /* roundup() */\n#include <linux/inotify.h>\n#include <linux/init.h> /* module_init */\n#include <linux/idr.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/fs.h> /* struct inode */\n#include <linux/file.h>\n\nstatic struct kmem_cache *inotify_inode_mark_cachep;\n\nstatic void inotify_free_mark(struct fsnotify_mark *fsn_mark)\n{\n\tstruct inotify_inode_mark *i_mark;\n\n\ti_mark = container_of(fsn_mark, struct inotify_inode_mark, fsn_mark);\n\n\tkmem_cache_free(inotify_inode_mark_cachep, i_mark);\n}"
  },
  {
    "function_name": "inotify_ignored_and_remove_idr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/inotify/inotify_user.c",
    "lines": "490-504",
    "snippet": "void inotify_ignored_and_remove_idr(struct fsnotify_mark *fsn_mark,\n\t\t\t\t    struct fsnotify_group *group)\n{\n\tstruct inotify_inode_mark *i_mark;\n\n\t/* Queue ignore event for the watch */\n\tinotify_handle_event(group, NULL, fsn_mark, NULL, FS_IN_IGNORED,\n\t\t\t     NULL, FSNOTIFY_EVENT_NONE, NULL, 0);\n\n\ti_mark = container_of(fsn_mark, struct inotify_inode_mark, fsn_mark);\n\t/* remove this mark from the idr */\n\tinotify_remove_from_idr(group, i_mark);\n\n\tatomic_dec(&group->inotify_data.user->inotify_watches);\n}",
    "includes": [
      "#include <linux/sysctl.h>",
      "#include <asm/ioctls.h>",
      "#include \"../fdinfo.h\"",
      "#include \"inotify.h\"",
      "#include <linux/wait.h>",
      "#include <linux/poll.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/types.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h> /* struct kmem_cache */",
      "#include <linux/sched.h> /* struct user */",
      "#include <linux/namei.h> /* LOOKUP_FOLLOW */",
      "#include <linux/kernel.h> /* roundup() */",
      "#include <linux/inotify.h>",
      "#include <linux/init.h> /* module_init */",
      "#include <linux/idr.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/fs.h> /* struct inode */",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_dec",
          "args": [
            "&group->inotify_data.user->inotify_watches"
          ],
          "line": 503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inotify_remove_from_idr",
          "args": [
            "group",
            "i_mark"
          ],
          "line": 501
        },
        "resolved": true,
        "details": {
          "function_name": "inotify_remove_from_idr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/inotify/inotify_user.c",
          "lines": "419-485",
          "snippet": "static void inotify_remove_from_idr(struct fsnotify_group *group,\n\t\t\t\t    struct inotify_inode_mark *i_mark)\n{\n\tspinlock_t *idr_lock = &group->inotify_data.idr_lock;\n\tstruct inotify_inode_mark *found_i_mark = NULL;\n\tint wd;\n\n\tspin_lock(idr_lock);\n\twd = i_mark->wd;\n\n\t/*\n\t * does this i_mark think it is in the idr?  we shouldn't get called\n\t * if it wasn't....\n\t */\n\tif (wd == -1) {\n\t\tWARN_ONCE(1, \"%s: i_mark=%p i_mark->wd=%d i_mark->group=%p\"\n\t\t\t\" i_mark->inode=%p\\n\", __func__, i_mark, i_mark->wd,\n\t\t\ti_mark->fsn_mark.group, i_mark->fsn_mark.inode);\n\t\tgoto out;\n\t}\n\n\t/* Lets look in the idr to see if we find it */\n\tfound_i_mark = inotify_idr_find_locked(group, wd);\n\tif (unlikely(!found_i_mark)) {\n\t\tWARN_ONCE(1, \"%s: i_mark=%p i_mark->wd=%d i_mark->group=%p\"\n\t\t\t\" i_mark->inode=%p\\n\", __func__, i_mark, i_mark->wd,\n\t\t\ti_mark->fsn_mark.group, i_mark->fsn_mark.inode);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * We found an mark in the idr at the right wd, but it's\n\t * not the mark we were told to remove.  eparis seriously\n\t * fucked up somewhere.\n\t */\n\tif (unlikely(found_i_mark != i_mark)) {\n\t\tWARN_ONCE(1, \"%s: i_mark=%p i_mark->wd=%d i_mark->group=%p \"\n\t\t\t\"mark->inode=%p found_i_mark=%p found_i_mark->wd=%d \"\n\t\t\t\"found_i_mark->group=%p found_i_mark->inode=%p\\n\",\n\t\t\t__func__, i_mark, i_mark->wd, i_mark->fsn_mark.group,\n\t\t\ti_mark->fsn_mark.inode, found_i_mark, found_i_mark->wd,\n\t\t\tfound_i_mark->fsn_mark.group,\n\t\t\tfound_i_mark->fsn_mark.inode);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * One ref for being in the idr\n\t * one ref held by the caller trying to kill us\n\t * one ref grabbed by inotify_idr_find\n\t */\n\tif (unlikely(atomic_read(&i_mark->fsn_mark.refcnt) < 3)) {\n\t\tprintk(KERN_ERR \"%s: i_mark=%p i_mark->wd=%d i_mark->group=%p\"\n\t\t\t\" i_mark->inode=%p\\n\", __func__, i_mark, i_mark->wd,\n\t\t\ti_mark->fsn_mark.group, i_mark->fsn_mark.inode);\n\t\t/* we can't really recover with bad ref cnting.. */\n\t\tBUG();\n\t}\n\n\tdo_inotify_remove_from_idr(group, i_mark);\nout:\n\t/* match the ref taken by inotify_idr_find_locked() */\n\tif (found_i_mark)\n\t\tfsnotify_put_mark(&found_i_mark->fsn_mark);\n\ti_mark->wd = -1;\n\tspin_unlock(idr_lock);\n}",
          "includes": [
            "#include <linux/sysctl.h>",
            "#include <asm/ioctls.h>",
            "#include \"../fdinfo.h\"",
            "#include \"inotify.h\"",
            "#include <linux/wait.h>",
            "#include <linux/poll.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/types.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h> /* struct kmem_cache */",
            "#include <linux/sched.h> /* struct user */",
            "#include <linux/namei.h> /* LOOKUP_FOLLOW */",
            "#include <linux/kernel.h> /* roundup() */",
            "#include <linux/inotify.h>",
            "#include <linux/init.h> /* module_init */",
            "#include <linux/idr.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/fs.h> /* struct inode */",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sysctl.h>\n#include <asm/ioctls.h>\n#include \"../fdinfo.h\"\n#include \"inotify.h\"\n#include <linux/wait.h>\n#include <linux/poll.h>\n#include <linux/uaccess.h>\n#include <linux/anon_inodes.h>\n#include <linux/types.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h> /* struct kmem_cache */\n#include <linux/sched.h> /* struct user */\n#include <linux/namei.h> /* LOOKUP_FOLLOW */\n#include <linux/kernel.h> /* roundup() */\n#include <linux/inotify.h>\n#include <linux/init.h> /* module_init */\n#include <linux/idr.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/fs.h> /* struct inode */\n#include <linux/file.h>\n\nstatic void inotify_remove_from_idr(struct fsnotify_group *group,\n\t\t\t\t    struct inotify_inode_mark *i_mark)\n{\n\tspinlock_t *idr_lock = &group->inotify_data.idr_lock;\n\tstruct inotify_inode_mark *found_i_mark = NULL;\n\tint wd;\n\n\tspin_lock(idr_lock);\n\twd = i_mark->wd;\n\n\t/*\n\t * does this i_mark think it is in the idr?  we shouldn't get called\n\t * if it wasn't....\n\t */\n\tif (wd == -1) {\n\t\tWARN_ONCE(1, \"%s: i_mark=%p i_mark->wd=%d i_mark->group=%p\"\n\t\t\t\" i_mark->inode=%p\\n\", __func__, i_mark, i_mark->wd,\n\t\t\ti_mark->fsn_mark.group, i_mark->fsn_mark.inode);\n\t\tgoto out;\n\t}\n\n\t/* Lets look in the idr to see if we find it */\n\tfound_i_mark = inotify_idr_find_locked(group, wd);\n\tif (unlikely(!found_i_mark)) {\n\t\tWARN_ONCE(1, \"%s: i_mark=%p i_mark->wd=%d i_mark->group=%p\"\n\t\t\t\" i_mark->inode=%p\\n\", __func__, i_mark, i_mark->wd,\n\t\t\ti_mark->fsn_mark.group, i_mark->fsn_mark.inode);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * We found an mark in the idr at the right wd, but it's\n\t * not the mark we were told to remove.  eparis seriously\n\t * fucked up somewhere.\n\t */\n\tif (unlikely(found_i_mark != i_mark)) {\n\t\tWARN_ONCE(1, \"%s: i_mark=%p i_mark->wd=%d i_mark->group=%p \"\n\t\t\t\"mark->inode=%p found_i_mark=%p found_i_mark->wd=%d \"\n\t\t\t\"found_i_mark->group=%p found_i_mark->inode=%p\\n\",\n\t\t\t__func__, i_mark, i_mark->wd, i_mark->fsn_mark.group,\n\t\t\ti_mark->fsn_mark.inode, found_i_mark, found_i_mark->wd,\n\t\t\tfound_i_mark->fsn_mark.group,\n\t\t\tfound_i_mark->fsn_mark.inode);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * One ref for being in the idr\n\t * one ref held by the caller trying to kill us\n\t * one ref grabbed by inotify_idr_find\n\t */\n\tif (unlikely(atomic_read(&i_mark->fsn_mark.refcnt) < 3)) {\n\t\tprintk(KERN_ERR \"%s: i_mark=%p i_mark->wd=%d i_mark->group=%p\"\n\t\t\t\" i_mark->inode=%p\\n\", __func__, i_mark, i_mark->wd,\n\t\t\ti_mark->fsn_mark.group, i_mark->fsn_mark.inode);\n\t\t/* we can't really recover with bad ref cnting.. */\n\t\tBUG();\n\t}\n\n\tdo_inotify_remove_from_idr(group, i_mark);\nout:\n\t/* match the ref taken by inotify_idr_find_locked() */\n\tif (found_i_mark)\n\t\tfsnotify_put_mark(&found_i_mark->fsn_mark);\n\ti_mark->wd = -1;\n\tspin_unlock(idr_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "fsn_mark",
            "structinotify_inode_mark",
            "fsn_mark"
          ],
          "line": 499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inotify_handle_event",
          "args": [
            "group",
            "NULL",
            "fsn_mark",
            "NULL",
            "FS_IN_IGNORED",
            "NULL",
            "FSNOTIFY_EVENT_NONE",
            "NULL",
            "0"
          ],
          "line": 496
        },
        "resolved": true,
        "details": {
          "function_name": "inotify_handle_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/inotify/inotify_fsnotify.c",
          "lines": "65-121",
          "snippet": "int inotify_handle_event(struct fsnotify_group *group,\n\t\t\t struct inode *inode,\n\t\t\t struct fsnotify_mark *inode_mark,\n\t\t\t struct fsnotify_mark *vfsmount_mark,\n\t\t\t u32 mask, void *data, int data_type,\n\t\t\t const unsigned char *file_name, u32 cookie)\n{\n\tstruct inotify_inode_mark *i_mark;\n\tstruct inotify_event_info *event;\n\tstruct fsnotify_event *fsn_event;\n\tint ret;\n\tint len = 0;\n\tint alloc_len = sizeof(struct inotify_event_info);\n\n\tBUG_ON(vfsmount_mark);\n\n\tif ((inode_mark->mask & FS_EXCL_UNLINK) &&\n\t    (data_type == FSNOTIFY_EVENT_PATH)) {\n\t\tstruct path *path = data;\n\n\t\tif (d_unlinked(path->dentry))\n\t\t\treturn 0;\n\t}\n\tif (file_name) {\n\t\tlen = strlen(file_name);\n\t\talloc_len += len + 1;\n\t}\n\n\tpr_debug(\"%s: group=%p inode=%p mask=%x\\n\", __func__, group, inode,\n\t\t mask);\n\n\ti_mark = container_of(inode_mark, struct inotify_inode_mark,\n\t\t\t      fsn_mark);\n\n\tevent = kmalloc(alloc_len, GFP_KERNEL);\n\tif (unlikely(!event))\n\t\treturn -ENOMEM;\n\n\tfsn_event = &event->fse;\n\tfsnotify_init_event(fsn_event, inode, mask);\n\tevent->wd = i_mark->wd;\n\tevent->sync_cookie = cookie;\n\tevent->name_len = len;\n\tif (len)\n\t\tstrcpy(event->name, file_name);\n\n\tret = fsnotify_add_event(group, fsn_event, inotify_merge);\n\tif (ret) {\n\t\t/* Our event wasn't used in the end. Free it. */\n\t\tfsnotify_destroy_event(group, fsn_event);\n\t}\n\n\tif (inode_mark->mask & IN_ONESHOT)\n\t\tfsnotify_destroy_mark(inode_mark, group);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"inotify.h\"",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <linux/slab.h> /* kmem_* */",
            "#include <linux/path.h> /* struct path */",
            "#include <linux/inotify.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/fs.h> /* struct inode */",
            "#include <linux/dcache.h> /* d_unlinked */"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"inotify.h\"\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/slab.h> /* kmem_* */\n#include <linux/path.h> /* struct path */\n#include <linux/inotify.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/fs.h> /* struct inode */\n#include <linux/dcache.h> /* d_unlinked */\n\nint inotify_handle_event(struct fsnotify_group *group,\n\t\t\t struct inode *inode,\n\t\t\t struct fsnotify_mark *inode_mark,\n\t\t\t struct fsnotify_mark *vfsmount_mark,\n\t\t\t u32 mask, void *data, int data_type,\n\t\t\t const unsigned char *file_name, u32 cookie)\n{\n\tstruct inotify_inode_mark *i_mark;\n\tstruct inotify_event_info *event;\n\tstruct fsnotify_event *fsn_event;\n\tint ret;\n\tint len = 0;\n\tint alloc_len = sizeof(struct inotify_event_info);\n\n\tBUG_ON(vfsmount_mark);\n\n\tif ((inode_mark->mask & FS_EXCL_UNLINK) &&\n\t    (data_type == FSNOTIFY_EVENT_PATH)) {\n\t\tstruct path *path = data;\n\n\t\tif (d_unlinked(path->dentry))\n\t\t\treturn 0;\n\t}\n\tif (file_name) {\n\t\tlen = strlen(file_name);\n\t\talloc_len += len + 1;\n\t}\n\n\tpr_debug(\"%s: group=%p inode=%p mask=%x\\n\", __func__, group, inode,\n\t\t mask);\n\n\ti_mark = container_of(inode_mark, struct inotify_inode_mark,\n\t\t\t      fsn_mark);\n\n\tevent = kmalloc(alloc_len, GFP_KERNEL);\n\tif (unlikely(!event))\n\t\treturn -ENOMEM;\n\n\tfsn_event = &event->fse;\n\tfsnotify_init_event(fsn_event, inode, mask);\n\tevent->wd = i_mark->wd;\n\tevent->sync_cookie = cookie;\n\tevent->name_len = len;\n\tif (len)\n\t\tstrcpy(event->name, file_name);\n\n\tret = fsnotify_add_event(group, fsn_event, inotify_merge);\n\tif (ret) {\n\t\t/* Our event wasn't used in the end. Free it. */\n\t\tfsnotify_destroy_event(group, fsn_event);\n\t}\n\n\tif (inode_mark->mask & IN_ONESHOT)\n\t\tfsnotify_destroy_mark(inode_mark, group);\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/sysctl.h>\n#include <asm/ioctls.h>\n#include \"../fdinfo.h\"\n#include \"inotify.h\"\n#include <linux/wait.h>\n#include <linux/poll.h>\n#include <linux/uaccess.h>\n#include <linux/anon_inodes.h>\n#include <linux/types.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h> /* struct kmem_cache */\n#include <linux/sched.h> /* struct user */\n#include <linux/namei.h> /* LOOKUP_FOLLOW */\n#include <linux/kernel.h> /* roundup() */\n#include <linux/inotify.h>\n#include <linux/init.h> /* module_init */\n#include <linux/idr.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/fs.h> /* struct inode */\n#include <linux/file.h>\n\nvoid inotify_ignored_and_remove_idr(struct fsnotify_mark *fsn_mark,\n\t\t\t\t    struct fsnotify_group *group)\n{\n\tstruct inotify_inode_mark *i_mark;\n\n\t/* Queue ignore event for the watch */\n\tinotify_handle_event(group, NULL, fsn_mark, NULL, FS_IN_IGNORED,\n\t\t\t     NULL, FSNOTIFY_EVENT_NONE, NULL, 0);\n\n\ti_mark = container_of(fsn_mark, struct inotify_inode_mark, fsn_mark);\n\t/* remove this mark from the idr */\n\tinotify_remove_from_idr(group, i_mark);\n\n\tatomic_dec(&group->inotify_data.user->inotify_watches);\n}"
  },
  {
    "function_name": "inotify_remove_from_idr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/inotify/inotify_user.c",
    "lines": "419-485",
    "snippet": "static void inotify_remove_from_idr(struct fsnotify_group *group,\n\t\t\t\t    struct inotify_inode_mark *i_mark)\n{\n\tspinlock_t *idr_lock = &group->inotify_data.idr_lock;\n\tstruct inotify_inode_mark *found_i_mark = NULL;\n\tint wd;\n\n\tspin_lock(idr_lock);\n\twd = i_mark->wd;\n\n\t/*\n\t * does this i_mark think it is in the idr?  we shouldn't get called\n\t * if it wasn't....\n\t */\n\tif (wd == -1) {\n\t\tWARN_ONCE(1, \"%s: i_mark=%p i_mark->wd=%d i_mark->group=%p\"\n\t\t\t\" i_mark->inode=%p\\n\", __func__, i_mark, i_mark->wd,\n\t\t\ti_mark->fsn_mark.group, i_mark->fsn_mark.inode);\n\t\tgoto out;\n\t}\n\n\t/* Lets look in the idr to see if we find it */\n\tfound_i_mark = inotify_idr_find_locked(group, wd);\n\tif (unlikely(!found_i_mark)) {\n\t\tWARN_ONCE(1, \"%s: i_mark=%p i_mark->wd=%d i_mark->group=%p\"\n\t\t\t\" i_mark->inode=%p\\n\", __func__, i_mark, i_mark->wd,\n\t\t\ti_mark->fsn_mark.group, i_mark->fsn_mark.inode);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * We found an mark in the idr at the right wd, but it's\n\t * not the mark we were told to remove.  eparis seriously\n\t * fucked up somewhere.\n\t */\n\tif (unlikely(found_i_mark != i_mark)) {\n\t\tWARN_ONCE(1, \"%s: i_mark=%p i_mark->wd=%d i_mark->group=%p \"\n\t\t\t\"mark->inode=%p found_i_mark=%p found_i_mark->wd=%d \"\n\t\t\t\"found_i_mark->group=%p found_i_mark->inode=%p\\n\",\n\t\t\t__func__, i_mark, i_mark->wd, i_mark->fsn_mark.group,\n\t\t\ti_mark->fsn_mark.inode, found_i_mark, found_i_mark->wd,\n\t\t\tfound_i_mark->fsn_mark.group,\n\t\t\tfound_i_mark->fsn_mark.inode);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * One ref for being in the idr\n\t * one ref held by the caller trying to kill us\n\t * one ref grabbed by inotify_idr_find\n\t */\n\tif (unlikely(atomic_read(&i_mark->fsn_mark.refcnt) < 3)) {\n\t\tprintk(KERN_ERR \"%s: i_mark=%p i_mark->wd=%d i_mark->group=%p\"\n\t\t\t\" i_mark->inode=%p\\n\", __func__, i_mark, i_mark->wd,\n\t\t\ti_mark->fsn_mark.group, i_mark->fsn_mark.inode);\n\t\t/* we can't really recover with bad ref cnting.. */\n\t\tBUG();\n\t}\n\n\tdo_inotify_remove_from_idr(group, i_mark);\nout:\n\t/* match the ref taken by inotify_idr_find_locked() */\n\tif (found_i_mark)\n\t\tfsnotify_put_mark(&found_i_mark->fsn_mark);\n\ti_mark->wd = -1;\n\tspin_unlock(idr_lock);\n}",
    "includes": [
      "#include <linux/sysctl.h>",
      "#include <asm/ioctls.h>",
      "#include \"../fdinfo.h\"",
      "#include \"inotify.h\"",
      "#include <linux/wait.h>",
      "#include <linux/poll.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/types.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h> /* struct kmem_cache */",
      "#include <linux/sched.h> /* struct user */",
      "#include <linux/namei.h> /* LOOKUP_FOLLOW */",
      "#include <linux/kernel.h> /* roundup() */",
      "#include <linux/inotify.h>",
      "#include <linux/init.h> /* module_init */",
      "#include <linux/idr.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/fs.h> /* struct inode */",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "idr_lock"
          ],
          "line": 484
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "fsnotify_put_mark",
          "args": [
            "&found_i_mark->fsn_mark"
          ],
          "line": 482
        },
        "resolved": true,
        "details": {
          "function_name": "fsnotify_put_mark",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/mark.c",
          "lines": "104-111",
          "snippet": "void fsnotify_put_mark(struct fsnotify_mark *mark)\n{\n\tif (atomic_dec_and_test(&mark->refcnt)) {\n\t\tif (mark->group)\n\t\t\tfsnotify_put_group(mark->group);\n\t\tmark->free_mark(mark);\n\t}\n}",
          "includes": [
            "#include \"fsnotify.h\"",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/atomic.h>",
            "#include <linux/srcu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fsnotify.h\"\n#include <linux/fsnotify_backend.h>\n#include <linux/atomic.h>\n#include <linux/srcu.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n\nvoid fsnotify_put_mark(struct fsnotify_mark *mark)\n{\n\tif (atomic_dec_and_test(&mark->refcnt)) {\n\t\tif (mark->group)\n\t\t\tfsnotify_put_group(mark->group);\n\t\tmark->free_mark(mark);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_inotify_remove_from_idr",
          "args": [
            "group",
            "i_mark"
          ],
          "line": 478
        },
        "resolved": true,
        "details": {
          "function_name": "do_inotify_remove_from_idr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/inotify/inotify_user.c",
          "lines": "400-413",
          "snippet": "static void do_inotify_remove_from_idr(struct fsnotify_group *group,\n\t\t\t\t       struct inotify_inode_mark *i_mark)\n{\n\tstruct idr *idr = &group->inotify_data.idr;\n\tspinlock_t *idr_lock = &group->inotify_data.idr_lock;\n\tint wd = i_mark->wd;\n\n\tassert_spin_locked(idr_lock);\n\n\tidr_remove(idr, wd);\n\n\t/* removed from the idr, drop that ref */\n\tfsnotify_put_mark(&i_mark->fsn_mark);\n}",
          "includes": [
            "#include <linux/sysctl.h>",
            "#include <asm/ioctls.h>",
            "#include \"../fdinfo.h\"",
            "#include \"inotify.h\"",
            "#include <linux/wait.h>",
            "#include <linux/poll.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/types.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h> /* struct kmem_cache */",
            "#include <linux/sched.h> /* struct user */",
            "#include <linux/namei.h> /* LOOKUP_FOLLOW */",
            "#include <linux/kernel.h> /* roundup() */",
            "#include <linux/inotify.h>",
            "#include <linux/init.h> /* module_init */",
            "#include <linux/idr.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/fs.h> /* struct inode */",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sysctl.h>\n#include <asm/ioctls.h>\n#include \"../fdinfo.h\"\n#include \"inotify.h\"\n#include <linux/wait.h>\n#include <linux/poll.h>\n#include <linux/uaccess.h>\n#include <linux/anon_inodes.h>\n#include <linux/types.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h> /* struct kmem_cache */\n#include <linux/sched.h> /* struct user */\n#include <linux/namei.h> /* LOOKUP_FOLLOW */\n#include <linux/kernel.h> /* roundup() */\n#include <linux/inotify.h>\n#include <linux/init.h> /* module_init */\n#include <linux/idr.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/fs.h> /* struct inode */\n#include <linux/file.h>\n\nstatic void do_inotify_remove_from_idr(struct fsnotify_group *group,\n\t\t\t\t       struct inotify_inode_mark *i_mark)\n{\n\tstruct idr *idr = &group->inotify_data.idr;\n\tspinlock_t *idr_lock = &group->inotify_data.idr_lock;\n\tint wd = i_mark->wd;\n\n\tassert_spin_locked(idr_lock);\n\n\tidr_remove(idr, wd);\n\n\t/* removed from the idr, drop that ref */\n\tfsnotify_put_mark(&i_mark->fsn_mark);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"%s: i_mark=%p i_mark->wd=%d i_mark->group=%p\"\n\t\t\t\" i_mark->inode=%p\\n\"",
            "__func__",
            "i_mark",
            "i_mark->wd",
            "i_mark->fsn_mark.group",
            "i_mark->fsn_mark.inode"
          ],
          "line": 471
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "atomic_read(&i_mark->fsn_mark.refcnt) < 3"
          ],
          "line": 470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&i_mark->fsn_mark.refcnt"
          ],
          "line": 470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ONCE",
          "args": [
            "1",
            "\"%s: i_mark=%p i_mark->wd=%d i_mark->group=%p \"\n\t\t\t\"mark->inode=%p found_i_mark=%p found_i_mark->wd=%d \"\n\t\t\t\"found_i_mark->group=%p found_i_mark->inode=%p\\n\"",
            "__func__",
            "i_mark",
            "i_mark->wd",
            "i_mark->fsn_mark.group",
            "i_mark->fsn_mark.inode",
            "found_i_mark",
            "found_i_mark->wd",
            "found_i_mark->fsn_mark.group",
            "found_i_mark->fsn_mark.inode"
          ],
          "line": 455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "found_i_mark != i_mark"
          ],
          "line": 454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ONCE",
          "args": [
            "1",
            "\"%s: i_mark=%p i_mark->wd=%d i_mark->group=%p\"\n\t\t\t\" i_mark->inode=%p\\n\"",
            "__func__",
            "i_mark",
            "i_mark->wd",
            "i_mark->fsn_mark.group",
            "i_mark->fsn_mark.inode"
          ],
          "line": 443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!found_i_mark"
          ],
          "line": 442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inotify_idr_find_locked",
          "args": [
            "group",
            "wd"
          ],
          "line": 441
        },
        "resolved": true,
        "details": {
          "function_name": "inotify_idr_find_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/inotify/inotify_user.c",
          "lines": "366-385",
          "snippet": "static struct inotify_inode_mark *inotify_idr_find_locked(struct fsnotify_group *group,\n\t\t\t\t\t\t\t\tint wd)\n{\n\tstruct idr *idr = &group->inotify_data.idr;\n\tspinlock_t *idr_lock = &group->inotify_data.idr_lock;\n\tstruct inotify_inode_mark *i_mark;\n\n\tassert_spin_locked(idr_lock);\n\n\ti_mark = idr_find(idr, wd);\n\tif (i_mark) {\n\t\tstruct fsnotify_mark *fsn_mark = &i_mark->fsn_mark;\n\n\t\tfsnotify_get_mark(fsn_mark);\n\t\t/* One ref for being in the idr, one ref we just took */\n\t\tBUG_ON(atomic_read(&fsn_mark->refcnt) < 2);\n\t}\n\n\treturn i_mark;\n}",
          "includes": [
            "#include <linux/sysctl.h>",
            "#include <asm/ioctls.h>",
            "#include \"../fdinfo.h\"",
            "#include \"inotify.h\"",
            "#include <linux/wait.h>",
            "#include <linux/poll.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/types.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h> /* struct kmem_cache */",
            "#include <linux/sched.h> /* struct user */",
            "#include <linux/namei.h> /* LOOKUP_FOLLOW */",
            "#include <linux/kernel.h> /* roundup() */",
            "#include <linux/inotify.h>",
            "#include <linux/init.h> /* module_init */",
            "#include <linux/idr.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/fs.h> /* struct inode */",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sysctl.h>\n#include <asm/ioctls.h>\n#include \"../fdinfo.h\"\n#include \"inotify.h\"\n#include <linux/wait.h>\n#include <linux/poll.h>\n#include <linux/uaccess.h>\n#include <linux/anon_inodes.h>\n#include <linux/types.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h> /* struct kmem_cache */\n#include <linux/sched.h> /* struct user */\n#include <linux/namei.h> /* LOOKUP_FOLLOW */\n#include <linux/kernel.h> /* roundup() */\n#include <linux/inotify.h>\n#include <linux/init.h> /* module_init */\n#include <linux/idr.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/fs.h> /* struct inode */\n#include <linux/file.h>\n\nstatic struct inotify_inode_mark *inotify_idr_find_locked(struct fsnotify_group *group,\n\t\t\t\t\t\t\t\tint wd)\n{\n\tstruct idr *idr = &group->inotify_data.idr;\n\tspinlock_t *idr_lock = &group->inotify_data.idr_lock;\n\tstruct inotify_inode_mark *i_mark;\n\n\tassert_spin_locked(idr_lock);\n\n\ti_mark = idr_find(idr, wd);\n\tif (i_mark) {\n\t\tstruct fsnotify_mark *fsn_mark = &i_mark->fsn_mark;\n\n\t\tfsnotify_get_mark(fsn_mark);\n\t\t/* One ref for being in the idr, one ref we just took */\n\t\tBUG_ON(atomic_read(&fsn_mark->refcnt) < 2);\n\t}\n\n\treturn i_mark;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ONCE",
          "args": [
            "1",
            "\"%s: i_mark=%p i_mark->wd=%d i_mark->group=%p\"\n\t\t\t\" i_mark->inode=%p\\n\"",
            "__func__",
            "i_mark",
            "i_mark->wd",
            "i_mark->fsn_mark.group",
            "i_mark->fsn_mark.inode"
          ],
          "line": 434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "idr_lock"
          ],
          "line": 426
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/sysctl.h>\n#include <asm/ioctls.h>\n#include \"../fdinfo.h\"\n#include \"inotify.h\"\n#include <linux/wait.h>\n#include <linux/poll.h>\n#include <linux/uaccess.h>\n#include <linux/anon_inodes.h>\n#include <linux/types.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h> /* struct kmem_cache */\n#include <linux/sched.h> /* struct user */\n#include <linux/namei.h> /* LOOKUP_FOLLOW */\n#include <linux/kernel.h> /* roundup() */\n#include <linux/inotify.h>\n#include <linux/init.h> /* module_init */\n#include <linux/idr.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/fs.h> /* struct inode */\n#include <linux/file.h>\n\nstatic void inotify_remove_from_idr(struct fsnotify_group *group,\n\t\t\t\t    struct inotify_inode_mark *i_mark)\n{\n\tspinlock_t *idr_lock = &group->inotify_data.idr_lock;\n\tstruct inotify_inode_mark *found_i_mark = NULL;\n\tint wd;\n\n\tspin_lock(idr_lock);\n\twd = i_mark->wd;\n\n\t/*\n\t * does this i_mark think it is in the idr?  we shouldn't get called\n\t * if it wasn't....\n\t */\n\tif (wd == -1) {\n\t\tWARN_ONCE(1, \"%s: i_mark=%p i_mark->wd=%d i_mark->group=%p\"\n\t\t\t\" i_mark->inode=%p\\n\", __func__, i_mark, i_mark->wd,\n\t\t\ti_mark->fsn_mark.group, i_mark->fsn_mark.inode);\n\t\tgoto out;\n\t}\n\n\t/* Lets look in the idr to see if we find it */\n\tfound_i_mark = inotify_idr_find_locked(group, wd);\n\tif (unlikely(!found_i_mark)) {\n\t\tWARN_ONCE(1, \"%s: i_mark=%p i_mark->wd=%d i_mark->group=%p\"\n\t\t\t\" i_mark->inode=%p\\n\", __func__, i_mark, i_mark->wd,\n\t\t\ti_mark->fsn_mark.group, i_mark->fsn_mark.inode);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * We found an mark in the idr at the right wd, but it's\n\t * not the mark we were told to remove.  eparis seriously\n\t * fucked up somewhere.\n\t */\n\tif (unlikely(found_i_mark != i_mark)) {\n\t\tWARN_ONCE(1, \"%s: i_mark=%p i_mark->wd=%d i_mark->group=%p \"\n\t\t\t\"mark->inode=%p found_i_mark=%p found_i_mark->wd=%d \"\n\t\t\t\"found_i_mark->group=%p found_i_mark->inode=%p\\n\",\n\t\t\t__func__, i_mark, i_mark->wd, i_mark->fsn_mark.group,\n\t\t\ti_mark->fsn_mark.inode, found_i_mark, found_i_mark->wd,\n\t\t\tfound_i_mark->fsn_mark.group,\n\t\t\tfound_i_mark->fsn_mark.inode);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * One ref for being in the idr\n\t * one ref held by the caller trying to kill us\n\t * one ref grabbed by inotify_idr_find\n\t */\n\tif (unlikely(atomic_read(&i_mark->fsn_mark.refcnt) < 3)) {\n\t\tprintk(KERN_ERR \"%s: i_mark=%p i_mark->wd=%d i_mark->group=%p\"\n\t\t\t\" i_mark->inode=%p\\n\", __func__, i_mark, i_mark->wd,\n\t\t\ti_mark->fsn_mark.group, i_mark->fsn_mark.inode);\n\t\t/* we can't really recover with bad ref cnting.. */\n\t\tBUG();\n\t}\n\n\tdo_inotify_remove_from_idr(group, i_mark);\nout:\n\t/* match the ref taken by inotify_idr_find_locked() */\n\tif (found_i_mark)\n\t\tfsnotify_put_mark(&found_i_mark->fsn_mark);\n\ti_mark->wd = -1;\n\tspin_unlock(idr_lock);\n}"
  },
  {
    "function_name": "do_inotify_remove_from_idr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/inotify/inotify_user.c",
    "lines": "400-413",
    "snippet": "static void do_inotify_remove_from_idr(struct fsnotify_group *group,\n\t\t\t\t       struct inotify_inode_mark *i_mark)\n{\n\tstruct idr *idr = &group->inotify_data.idr;\n\tspinlock_t *idr_lock = &group->inotify_data.idr_lock;\n\tint wd = i_mark->wd;\n\n\tassert_spin_locked(idr_lock);\n\n\tidr_remove(idr, wd);\n\n\t/* removed from the idr, drop that ref */\n\tfsnotify_put_mark(&i_mark->fsn_mark);\n}",
    "includes": [
      "#include <linux/sysctl.h>",
      "#include <asm/ioctls.h>",
      "#include \"../fdinfo.h\"",
      "#include \"inotify.h\"",
      "#include <linux/wait.h>",
      "#include <linux/poll.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/types.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h> /* struct kmem_cache */",
      "#include <linux/sched.h> /* struct user */",
      "#include <linux/namei.h> /* LOOKUP_FOLLOW */",
      "#include <linux/kernel.h> /* roundup() */",
      "#include <linux/inotify.h>",
      "#include <linux/init.h> /* module_init */",
      "#include <linux/idr.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/fs.h> /* struct inode */",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fsnotify_put_mark",
          "args": [
            "&i_mark->fsn_mark"
          ],
          "line": 412
        },
        "resolved": true,
        "details": {
          "function_name": "fsnotify_put_mark",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/mark.c",
          "lines": "104-111",
          "snippet": "void fsnotify_put_mark(struct fsnotify_mark *mark)\n{\n\tif (atomic_dec_and_test(&mark->refcnt)) {\n\t\tif (mark->group)\n\t\t\tfsnotify_put_group(mark->group);\n\t\tmark->free_mark(mark);\n\t}\n}",
          "includes": [
            "#include \"fsnotify.h\"",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/atomic.h>",
            "#include <linux/srcu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fsnotify.h\"\n#include <linux/fsnotify_backend.h>\n#include <linux/atomic.h>\n#include <linux/srcu.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n\nvoid fsnotify_put_mark(struct fsnotify_mark *mark)\n{\n\tif (atomic_dec_and_test(&mark->refcnt)) {\n\t\tif (mark->group)\n\t\t\tfsnotify_put_group(mark->group);\n\t\tmark->free_mark(mark);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "idr_remove",
          "args": [
            "idr",
            "wd"
          ],
          "line": 409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert_spin_locked",
          "args": [
            "idr_lock"
          ],
          "line": 407
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sysctl.h>\n#include <asm/ioctls.h>\n#include \"../fdinfo.h\"\n#include \"inotify.h\"\n#include <linux/wait.h>\n#include <linux/poll.h>\n#include <linux/uaccess.h>\n#include <linux/anon_inodes.h>\n#include <linux/types.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h> /* struct kmem_cache */\n#include <linux/sched.h> /* struct user */\n#include <linux/namei.h> /* LOOKUP_FOLLOW */\n#include <linux/kernel.h> /* roundup() */\n#include <linux/inotify.h>\n#include <linux/init.h> /* module_init */\n#include <linux/idr.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/fs.h> /* struct inode */\n#include <linux/file.h>\n\nstatic void do_inotify_remove_from_idr(struct fsnotify_group *group,\n\t\t\t\t       struct inotify_inode_mark *i_mark)\n{\n\tstruct idr *idr = &group->inotify_data.idr;\n\tspinlock_t *idr_lock = &group->inotify_data.idr_lock;\n\tint wd = i_mark->wd;\n\n\tassert_spin_locked(idr_lock);\n\n\tidr_remove(idr, wd);\n\n\t/* removed from the idr, drop that ref */\n\tfsnotify_put_mark(&i_mark->fsn_mark);\n}"
  },
  {
    "function_name": "inotify_idr_find",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/inotify/inotify_user.c",
    "lines": "387-398",
    "snippet": "static struct inotify_inode_mark *inotify_idr_find(struct fsnotify_group *group,\n\t\t\t\t\t\t\t int wd)\n{\n\tstruct inotify_inode_mark *i_mark;\n\tspinlock_t *idr_lock = &group->inotify_data.idr_lock;\n\n\tspin_lock(idr_lock);\n\ti_mark = inotify_idr_find_locked(group, wd);\n\tspin_unlock(idr_lock);\n\n\treturn i_mark;\n}",
    "includes": [
      "#include <linux/sysctl.h>",
      "#include <asm/ioctls.h>",
      "#include \"../fdinfo.h\"",
      "#include \"inotify.h\"",
      "#include <linux/wait.h>",
      "#include <linux/poll.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/types.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h> /* struct kmem_cache */",
      "#include <linux/sched.h> /* struct user */",
      "#include <linux/namei.h> /* LOOKUP_FOLLOW */",
      "#include <linux/kernel.h> /* roundup() */",
      "#include <linux/inotify.h>",
      "#include <linux/init.h> /* module_init */",
      "#include <linux/idr.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/fs.h> /* struct inode */",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "idr_lock"
          ],
          "line": 395
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "inotify_idr_find_locked",
          "args": [
            "group",
            "wd"
          ],
          "line": 394
        },
        "resolved": true,
        "details": {
          "function_name": "inotify_idr_find_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/inotify/inotify_user.c",
          "lines": "366-385",
          "snippet": "static struct inotify_inode_mark *inotify_idr_find_locked(struct fsnotify_group *group,\n\t\t\t\t\t\t\t\tint wd)\n{\n\tstruct idr *idr = &group->inotify_data.idr;\n\tspinlock_t *idr_lock = &group->inotify_data.idr_lock;\n\tstruct inotify_inode_mark *i_mark;\n\n\tassert_spin_locked(idr_lock);\n\n\ti_mark = idr_find(idr, wd);\n\tif (i_mark) {\n\t\tstruct fsnotify_mark *fsn_mark = &i_mark->fsn_mark;\n\n\t\tfsnotify_get_mark(fsn_mark);\n\t\t/* One ref for being in the idr, one ref we just took */\n\t\tBUG_ON(atomic_read(&fsn_mark->refcnt) < 2);\n\t}\n\n\treturn i_mark;\n}",
          "includes": [
            "#include <linux/sysctl.h>",
            "#include <asm/ioctls.h>",
            "#include \"../fdinfo.h\"",
            "#include \"inotify.h\"",
            "#include <linux/wait.h>",
            "#include <linux/poll.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/types.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h> /* struct kmem_cache */",
            "#include <linux/sched.h> /* struct user */",
            "#include <linux/namei.h> /* LOOKUP_FOLLOW */",
            "#include <linux/kernel.h> /* roundup() */",
            "#include <linux/inotify.h>",
            "#include <linux/init.h> /* module_init */",
            "#include <linux/idr.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/fs.h> /* struct inode */",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sysctl.h>\n#include <asm/ioctls.h>\n#include \"../fdinfo.h\"\n#include \"inotify.h\"\n#include <linux/wait.h>\n#include <linux/poll.h>\n#include <linux/uaccess.h>\n#include <linux/anon_inodes.h>\n#include <linux/types.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h> /* struct kmem_cache */\n#include <linux/sched.h> /* struct user */\n#include <linux/namei.h> /* LOOKUP_FOLLOW */\n#include <linux/kernel.h> /* roundup() */\n#include <linux/inotify.h>\n#include <linux/init.h> /* module_init */\n#include <linux/idr.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/fs.h> /* struct inode */\n#include <linux/file.h>\n\nstatic struct inotify_inode_mark *inotify_idr_find_locked(struct fsnotify_group *group,\n\t\t\t\t\t\t\t\tint wd)\n{\n\tstruct idr *idr = &group->inotify_data.idr;\n\tspinlock_t *idr_lock = &group->inotify_data.idr_lock;\n\tstruct inotify_inode_mark *i_mark;\n\n\tassert_spin_locked(idr_lock);\n\n\ti_mark = idr_find(idr, wd);\n\tif (i_mark) {\n\t\tstruct fsnotify_mark *fsn_mark = &i_mark->fsn_mark;\n\n\t\tfsnotify_get_mark(fsn_mark);\n\t\t/* One ref for being in the idr, one ref we just took */\n\t\tBUG_ON(atomic_read(&fsn_mark->refcnt) < 2);\n\t}\n\n\treturn i_mark;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "idr_lock"
          ],
          "line": 393
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/sysctl.h>\n#include <asm/ioctls.h>\n#include \"../fdinfo.h\"\n#include \"inotify.h\"\n#include <linux/wait.h>\n#include <linux/poll.h>\n#include <linux/uaccess.h>\n#include <linux/anon_inodes.h>\n#include <linux/types.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h> /* struct kmem_cache */\n#include <linux/sched.h> /* struct user */\n#include <linux/namei.h> /* LOOKUP_FOLLOW */\n#include <linux/kernel.h> /* roundup() */\n#include <linux/inotify.h>\n#include <linux/init.h> /* module_init */\n#include <linux/idr.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/fs.h> /* struct inode */\n#include <linux/file.h>\n\nstatic struct inotify_inode_mark *inotify_idr_find(struct fsnotify_group *group,\n\t\t\t\t\t\t\t int wd)\n{\n\tstruct inotify_inode_mark *i_mark;\n\tspinlock_t *idr_lock = &group->inotify_data.idr_lock;\n\n\tspin_lock(idr_lock);\n\ti_mark = inotify_idr_find_locked(group, wd);\n\tspin_unlock(idr_lock);\n\n\treturn i_mark;\n}"
  },
  {
    "function_name": "inotify_idr_find_locked",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/inotify/inotify_user.c",
    "lines": "366-385",
    "snippet": "static struct inotify_inode_mark *inotify_idr_find_locked(struct fsnotify_group *group,\n\t\t\t\t\t\t\t\tint wd)\n{\n\tstruct idr *idr = &group->inotify_data.idr;\n\tspinlock_t *idr_lock = &group->inotify_data.idr_lock;\n\tstruct inotify_inode_mark *i_mark;\n\n\tassert_spin_locked(idr_lock);\n\n\ti_mark = idr_find(idr, wd);\n\tif (i_mark) {\n\t\tstruct fsnotify_mark *fsn_mark = &i_mark->fsn_mark;\n\n\t\tfsnotify_get_mark(fsn_mark);\n\t\t/* One ref for being in the idr, one ref we just took */\n\t\tBUG_ON(atomic_read(&fsn_mark->refcnt) < 2);\n\t}\n\n\treturn i_mark;\n}",
    "includes": [
      "#include <linux/sysctl.h>",
      "#include <asm/ioctls.h>",
      "#include \"../fdinfo.h\"",
      "#include \"inotify.h\"",
      "#include <linux/wait.h>",
      "#include <linux/poll.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/types.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h> /* struct kmem_cache */",
      "#include <linux/sched.h> /* struct user */",
      "#include <linux/namei.h> /* LOOKUP_FOLLOW */",
      "#include <linux/kernel.h> /* roundup() */",
      "#include <linux/inotify.h>",
      "#include <linux/init.h> /* module_init */",
      "#include <linux/idr.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/fs.h> /* struct inode */",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "atomic_read(&fsn_mark->refcnt) < 2"
          ],
          "line": 381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&fsn_mark->refcnt"
          ],
          "line": 381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fsnotify_get_mark",
          "args": [
            "fsn_mark"
          ],
          "line": 379
        },
        "resolved": true,
        "details": {
          "function_name": "fsnotify_get_mark",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/mark.c",
          "lines": "99-102",
          "snippet": "void fsnotify_get_mark(struct fsnotify_mark *mark)\n{\n\tatomic_inc(&mark->refcnt);\n}",
          "includes": [
            "#include \"fsnotify.h\"",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/atomic.h>",
            "#include <linux/srcu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fsnotify.h\"\n#include <linux/fsnotify_backend.h>\n#include <linux/atomic.h>\n#include <linux/srcu.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n\nvoid fsnotify_get_mark(struct fsnotify_mark *mark)\n{\n\tatomic_inc(&mark->refcnt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "idr_find",
          "args": [
            "idr",
            "wd"
          ],
          "line": 375
        },
        "resolved": true,
        "details": {
          "function_name": "inotify_idr_find",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/inotify/inotify_user.c",
          "lines": "387-398",
          "snippet": "static struct inotify_inode_mark *inotify_idr_find(struct fsnotify_group *group,\n\t\t\t\t\t\t\t int wd)\n{\n\tstruct inotify_inode_mark *i_mark;\n\tspinlock_t *idr_lock = &group->inotify_data.idr_lock;\n\n\tspin_lock(idr_lock);\n\ti_mark = inotify_idr_find_locked(group, wd);\n\tspin_unlock(idr_lock);\n\n\treturn i_mark;\n}",
          "includes": [
            "#include <linux/sysctl.h>",
            "#include <asm/ioctls.h>",
            "#include \"../fdinfo.h\"",
            "#include \"inotify.h\"",
            "#include <linux/wait.h>",
            "#include <linux/poll.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/types.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h> /* struct kmem_cache */",
            "#include <linux/sched.h> /* struct user */",
            "#include <linux/namei.h> /* LOOKUP_FOLLOW */",
            "#include <linux/kernel.h> /* roundup() */",
            "#include <linux/inotify.h>",
            "#include <linux/init.h> /* module_init */",
            "#include <linux/idr.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/fs.h> /* struct inode */",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sysctl.h>\n#include <asm/ioctls.h>\n#include \"../fdinfo.h\"\n#include \"inotify.h\"\n#include <linux/wait.h>\n#include <linux/poll.h>\n#include <linux/uaccess.h>\n#include <linux/anon_inodes.h>\n#include <linux/types.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h> /* struct kmem_cache */\n#include <linux/sched.h> /* struct user */\n#include <linux/namei.h> /* LOOKUP_FOLLOW */\n#include <linux/kernel.h> /* roundup() */\n#include <linux/inotify.h>\n#include <linux/init.h> /* module_init */\n#include <linux/idr.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/fs.h> /* struct inode */\n#include <linux/file.h>\n\nstatic struct inotify_inode_mark *inotify_idr_find(struct fsnotify_group *group,\n\t\t\t\t\t\t\t int wd)\n{\n\tstruct inotify_inode_mark *i_mark;\n\tspinlock_t *idr_lock = &group->inotify_data.idr_lock;\n\n\tspin_lock(idr_lock);\n\ti_mark = inotify_idr_find_locked(group, wd);\n\tspin_unlock(idr_lock);\n\n\treturn i_mark;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert_spin_locked",
          "args": [
            "idr_lock"
          ],
          "line": 373
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sysctl.h>\n#include <asm/ioctls.h>\n#include \"../fdinfo.h\"\n#include \"inotify.h\"\n#include <linux/wait.h>\n#include <linux/poll.h>\n#include <linux/uaccess.h>\n#include <linux/anon_inodes.h>\n#include <linux/types.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h> /* struct kmem_cache */\n#include <linux/sched.h> /* struct user */\n#include <linux/namei.h> /* LOOKUP_FOLLOW */\n#include <linux/kernel.h> /* roundup() */\n#include <linux/inotify.h>\n#include <linux/init.h> /* module_init */\n#include <linux/idr.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/fs.h> /* struct inode */\n#include <linux/file.h>\n\nstatic struct inotify_inode_mark *inotify_idr_find_locked(struct fsnotify_group *group,\n\t\t\t\t\t\t\t\tint wd)\n{\n\tstruct idr *idr = &group->inotify_data.idr;\n\tspinlock_t *idr_lock = &group->inotify_data.idr_lock;\n\tstruct inotify_inode_mark *i_mark;\n\n\tassert_spin_locked(idr_lock);\n\n\ti_mark = idr_find(idr, wd);\n\tif (i_mark) {\n\t\tstruct fsnotify_mark *fsn_mark = &i_mark->fsn_mark;\n\n\t\tfsnotify_get_mark(fsn_mark);\n\t\t/* One ref for being in the idr, one ref we just took */\n\t\tBUG_ON(atomic_read(&fsn_mark->refcnt) < 2);\n\t}\n\n\treturn i_mark;\n}"
  },
  {
    "function_name": "inotify_add_to_idr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/inotify/inotify_user.c",
    "lines": "346-364",
    "snippet": "static int inotify_add_to_idr(struct idr *idr, spinlock_t *idr_lock,\n\t\t\t      struct inotify_inode_mark *i_mark)\n{\n\tint ret;\n\n\tidr_preload(GFP_KERNEL);\n\tspin_lock(idr_lock);\n\n\tret = idr_alloc_cyclic(idr, i_mark, 1, 0, GFP_NOWAIT);\n\tif (ret >= 0) {\n\t\t/* we added the mark to the idr, take a reference */\n\t\ti_mark->wd = ret;\n\t\tfsnotify_get_mark(&i_mark->fsn_mark);\n\t}\n\n\tspin_unlock(idr_lock);\n\tidr_preload_end();\n\treturn ret < 0 ? ret : 0;\n}",
    "includes": [
      "#include <linux/sysctl.h>",
      "#include <asm/ioctls.h>",
      "#include \"../fdinfo.h\"",
      "#include \"inotify.h\"",
      "#include <linux/wait.h>",
      "#include <linux/poll.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/types.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h> /* struct kmem_cache */",
      "#include <linux/sched.h> /* struct user */",
      "#include <linux/namei.h> /* LOOKUP_FOLLOW */",
      "#include <linux/kernel.h> /* roundup() */",
      "#include <linux/inotify.h>",
      "#include <linux/init.h> /* module_init */",
      "#include <linux/idr.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/fs.h> /* struct inode */",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "idr_preload_end",
          "args": [],
          "line": 362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "idr_lock"
          ],
          "line": 361
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "fsnotify_get_mark",
          "args": [
            "&i_mark->fsn_mark"
          ],
          "line": 358
        },
        "resolved": true,
        "details": {
          "function_name": "fsnotify_get_mark",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/mark.c",
          "lines": "99-102",
          "snippet": "void fsnotify_get_mark(struct fsnotify_mark *mark)\n{\n\tatomic_inc(&mark->refcnt);\n}",
          "includes": [
            "#include \"fsnotify.h\"",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/atomic.h>",
            "#include <linux/srcu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fsnotify.h\"\n#include <linux/fsnotify_backend.h>\n#include <linux/atomic.h>\n#include <linux/srcu.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n\nvoid fsnotify_get_mark(struct fsnotify_mark *mark)\n{\n\tatomic_inc(&mark->refcnt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "idr_alloc_cyclic",
          "args": [
            "idr",
            "i_mark",
            "1",
            "0",
            "GFP_NOWAIT"
          ],
          "line": 354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "idr_lock"
          ],
          "line": 352
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "idr_preload",
          "args": [
            "GFP_KERNEL"
          ],
          "line": 351
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sysctl.h>\n#include <asm/ioctls.h>\n#include \"../fdinfo.h\"\n#include \"inotify.h\"\n#include <linux/wait.h>\n#include <linux/poll.h>\n#include <linux/uaccess.h>\n#include <linux/anon_inodes.h>\n#include <linux/types.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h> /* struct kmem_cache */\n#include <linux/sched.h> /* struct user */\n#include <linux/namei.h> /* LOOKUP_FOLLOW */\n#include <linux/kernel.h> /* roundup() */\n#include <linux/inotify.h>\n#include <linux/init.h> /* module_init */\n#include <linux/idr.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/fs.h> /* struct inode */\n#include <linux/file.h>\n\nstatic int inotify_add_to_idr(struct idr *idr, spinlock_t *idr_lock,\n\t\t\t      struct inotify_inode_mark *i_mark)\n{\n\tint ret;\n\n\tidr_preload(GFP_KERNEL);\n\tspin_lock(idr_lock);\n\n\tret = idr_alloc_cyclic(idr, i_mark, 1, 0, GFP_NOWAIT);\n\tif (ret >= 0) {\n\t\t/* we added the mark to the idr, take a reference */\n\t\ti_mark->wd = ret;\n\t\tfsnotify_get_mark(&i_mark->fsn_mark);\n\t}\n\n\tspin_unlock(idr_lock);\n\tidr_preload_end();\n\treturn ret < 0 ? ret : 0;\n}"
  },
  {
    "function_name": "inotify_find_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/inotify/inotify_user.c",
    "lines": "332-344",
    "snippet": "static int inotify_find_inode(const char __user *dirname, struct path *path, unsigned flags)\n{\n\tint error;\n\n\terror = user_path_at(AT_FDCWD, dirname, flags, path);\n\tif (error)\n\t\treturn error;\n\t/* you can only watch an inode if you have read permissions on it */\n\terror = inode_permission(path->dentry->d_inode, MAY_READ);\n\tif (error)\n\t\tpath_put(path);\n\treturn error;\n}",
    "includes": [
      "#include <linux/sysctl.h>",
      "#include <asm/ioctls.h>",
      "#include \"../fdinfo.h\"",
      "#include \"inotify.h\"",
      "#include <linux/wait.h>",
      "#include <linux/poll.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/types.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h> /* struct kmem_cache */",
      "#include <linux/sched.h> /* struct user */",
      "#include <linux/namei.h> /* LOOKUP_FOLLOW */",
      "#include <linux/kernel.h> /* roundup() */",
      "#include <linux/inotify.h>",
      "#include <linux/init.h> /* module_init */",
      "#include <linux/idr.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/fs.h> /* struct inode */",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "path_put",
          "args": [
            "path"
          ],
          "line": 342
        },
        "resolved": true,
        "details": {
          "function_name": "path_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "489-493",
          "snippet": "void path_put(const struct path *path)\n{\n\tdput(path->dentry);\n\tmntput(path->mnt);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nvoid path_put(const struct path *path)\n{\n\tdput(path->dentry);\n\tmntput(path->mnt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_permission",
          "args": [
            "path->dentry->d_inode",
            "MAY_READ"
          ],
          "line": 340
        },
        "resolved": true,
        "details": {
          "function_name": "inode_permission",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "459-467",
          "snippet": "int inode_permission(struct inode *inode, int mask)\n{\n\tint retval;\n\n\tretval = sb_permission(inode->i_sb, inode, mask);\n\tif (retval)\n\t\treturn retval;\n\treturn __inode_permission(inode, mask);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nint inode_permission(struct inode *inode, int mask)\n{\n\tint retval;\n\n\tretval = sb_permission(inode->i_sb, inode, mask);\n\tif (retval)\n\t\treturn retval;\n\treturn __inode_permission(inode, mask);\n}"
        }
      },
      {
        "call_info": {
          "callee": "user_path_at",
          "args": [
            "AT_FDCWD",
            "dirname",
            "flags",
            "path"
          ],
          "line": 336
        },
        "resolved": true,
        "details": {
          "function_name": "user_path_at",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "2205-2209",
          "snippet": "int user_path_at(int dfd, const char __user *name, unsigned flags,\n\t\t struct path *path)\n{\n\treturn user_path_at_empty(dfd, name, flags, path, NULL);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nint user_path_at(int dfd, const char __user *name, unsigned flags,\n\t\t struct path *path)\n{\n\treturn user_path_at_empty(dfd, name, flags, path, NULL);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/sysctl.h>\n#include <asm/ioctls.h>\n#include \"../fdinfo.h\"\n#include \"inotify.h\"\n#include <linux/wait.h>\n#include <linux/poll.h>\n#include <linux/uaccess.h>\n#include <linux/anon_inodes.h>\n#include <linux/types.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h> /* struct kmem_cache */\n#include <linux/sched.h> /* struct user */\n#include <linux/namei.h> /* LOOKUP_FOLLOW */\n#include <linux/kernel.h> /* roundup() */\n#include <linux/inotify.h>\n#include <linux/init.h> /* module_init */\n#include <linux/idr.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/fs.h> /* struct inode */\n#include <linux/file.h>\n\nstatic int inotify_find_inode(const char __user *dirname, struct path *path, unsigned flags)\n{\n\tint error;\n\n\terror = user_path_at(AT_FDCWD, dirname, flags, path);\n\tif (error)\n\t\treturn error;\n\t/* you can only watch an inode if you have read permissions on it */\n\terror = inode_permission(path->dentry->d_inode, MAY_READ);\n\tif (error)\n\t\tpath_put(path);\n\treturn error;\n}"
  },
  {
    "function_name": "inotify_ioctl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/inotify/inotify_user.c",
    "lines": "287-315",
    "snippet": "static long inotify_ioctl(struct file *file, unsigned int cmd,\n\t\t\t  unsigned long arg)\n{\n\tstruct fsnotify_group *group;\n\tstruct fsnotify_event *fsn_event;\n\tvoid __user *p;\n\tint ret = -ENOTTY;\n\tsize_t send_len = 0;\n\n\tgroup = file->private_data;\n\tp = (void __user *) arg;\n\n\tpr_debug(\"%s: group=%p cmd=%u\\n\", __func__, group, cmd);\n\n\tswitch (cmd) {\n\tcase FIONREAD:\n\t\tmutex_lock(&group->notification_mutex);\n\t\tlist_for_each_entry(fsn_event, &group->notification_list,\n\t\t\t\t    list) {\n\t\t\tsend_len += sizeof(struct inotify_event);\n\t\t\tsend_len += round_event_name_len(fsn_event);\n\t\t}\n\t\tmutex_unlock(&group->notification_mutex);\n\t\tret = put_user(send_len, (int __user *) p);\n\t\tbreak;\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include <linux/sysctl.h>",
      "#include <asm/ioctls.h>",
      "#include \"../fdinfo.h\"",
      "#include \"inotify.h\"",
      "#include <linux/wait.h>",
      "#include <linux/poll.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/types.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h> /* struct kmem_cache */",
      "#include <linux/sched.h> /* struct user */",
      "#include <linux/namei.h> /* LOOKUP_FOLLOW */",
      "#include <linux/kernel.h> /* roundup() */",
      "#include <linux/inotify.h>",
      "#include <linux/init.h> /* module_init */",
      "#include <linux/idr.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/fs.h> /* struct inode */",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_user",
          "args": [
            "send_len",
            "(int __user *) p"
          ],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&group->notification_mutex"
          ],
          "line": 309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "round_event_name_len",
          "args": [
            "fsn_event"
          ],
          "line": 307
        },
        "resolved": true,
        "details": {
          "function_name": "round_event_name_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/inotify/inotify_user.c",
          "lines": "126-134",
          "snippet": "static int round_event_name_len(struct fsnotify_event *fsn_event)\n{\n\tstruct inotify_event_info *event;\n\n\tevent = INOTIFY_E(fsn_event);\n\tif (!event->name_len)\n\t\treturn 0;\n\treturn roundup(event->name_len + 1, sizeof(struct inotify_event));\n}",
          "includes": [
            "#include <linux/sysctl.h>",
            "#include <asm/ioctls.h>",
            "#include \"../fdinfo.h\"",
            "#include \"inotify.h\"",
            "#include <linux/wait.h>",
            "#include <linux/poll.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/types.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h> /* struct kmem_cache */",
            "#include <linux/sched.h> /* struct user */",
            "#include <linux/namei.h> /* LOOKUP_FOLLOW */",
            "#include <linux/kernel.h> /* roundup() */",
            "#include <linux/inotify.h>",
            "#include <linux/init.h> /* module_init */",
            "#include <linux/idr.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/fs.h> /* struct inode */",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sysctl.h>\n#include <asm/ioctls.h>\n#include \"../fdinfo.h\"\n#include \"inotify.h\"\n#include <linux/wait.h>\n#include <linux/poll.h>\n#include <linux/uaccess.h>\n#include <linux/anon_inodes.h>\n#include <linux/types.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h> /* struct kmem_cache */\n#include <linux/sched.h> /* struct user */\n#include <linux/namei.h> /* LOOKUP_FOLLOW */\n#include <linux/kernel.h> /* roundup() */\n#include <linux/inotify.h>\n#include <linux/init.h> /* module_init */\n#include <linux/idr.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/fs.h> /* struct inode */\n#include <linux/file.h>\n\nstatic int round_event_name_len(struct fsnotify_event *fsn_event)\n{\n\tstruct inotify_event_info *event;\n\n\tevent = INOTIFY_E(fsn_event);\n\tif (!event->name_len)\n\t\treturn 0;\n\treturn roundup(event->name_len + 1, sizeof(struct inotify_event));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "fsn_event",
            "&group->notification_list",
            "list"
          ],
          "line": 304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&group->notification_mutex"
          ],
          "line": 303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"%s: group=%p cmd=%u\\n\"",
            "__func__",
            "group",
            "cmd"
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sysctl.h>\n#include <asm/ioctls.h>\n#include \"../fdinfo.h\"\n#include \"inotify.h\"\n#include <linux/wait.h>\n#include <linux/poll.h>\n#include <linux/uaccess.h>\n#include <linux/anon_inodes.h>\n#include <linux/types.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h> /* struct kmem_cache */\n#include <linux/sched.h> /* struct user */\n#include <linux/namei.h> /* LOOKUP_FOLLOW */\n#include <linux/kernel.h> /* roundup() */\n#include <linux/inotify.h>\n#include <linux/init.h> /* module_init */\n#include <linux/idr.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/fs.h> /* struct inode */\n#include <linux/file.h>\n\nstatic long inotify_ioctl(struct file *file, unsigned int cmd,\n\t\t\t  unsigned long arg)\n{\n\tstruct fsnotify_group *group;\n\tstruct fsnotify_event *fsn_event;\n\tvoid __user *p;\n\tint ret = -ENOTTY;\n\tsize_t send_len = 0;\n\n\tgroup = file->private_data;\n\tp = (void __user *) arg;\n\n\tpr_debug(\"%s: group=%p cmd=%u\\n\", __func__, group, cmd);\n\n\tswitch (cmd) {\n\tcase FIONREAD:\n\t\tmutex_lock(&group->notification_mutex);\n\t\tlist_for_each_entry(fsn_event, &group->notification_list,\n\t\t\t\t    list) {\n\t\t\tsend_len += sizeof(struct inotify_event);\n\t\t\tsend_len += round_event_name_len(fsn_event);\n\t\t}\n\t\tmutex_unlock(&group->notification_mutex);\n\t\tret = put_user(send_len, (int __user *) p);\n\t\tbreak;\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "inotify_release",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/inotify/inotify_user.c",
    "lines": "275-285",
    "snippet": "static int inotify_release(struct inode *ignored, struct file *file)\n{\n\tstruct fsnotify_group *group = file->private_data;\n\n\tpr_debug(\"%s: group=%p\\n\", __func__, group);\n\n\t/* free this group, matching get was inotify_init->fsnotify_obtain_group */\n\tfsnotify_destroy_group(group);\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/sysctl.h>",
      "#include <asm/ioctls.h>",
      "#include \"../fdinfo.h\"",
      "#include \"inotify.h\"",
      "#include <linux/wait.h>",
      "#include <linux/poll.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/types.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h> /* struct kmem_cache */",
      "#include <linux/sched.h> /* struct user */",
      "#include <linux/namei.h> /* LOOKUP_FOLLOW */",
      "#include <linux/kernel.h> /* roundup() */",
      "#include <linux/inotify.h>",
      "#include <linux/init.h> /* module_init */",
      "#include <linux/idr.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/fs.h> /* struct inode */",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fsnotify_destroy_group",
          "args": [
            "group"
          ],
          "line": 282
        },
        "resolved": true,
        "details": {
          "function_name": "fsnotify_destroy_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/group.c",
          "lines": "48-66",
          "snippet": "void fsnotify_destroy_group(struct fsnotify_group *group)\n{\n\t/* clear all inode marks for this group */\n\tfsnotify_clear_marks_by_group(group);\n\n\tsynchronize_srcu(&fsnotify_mark_srcu);\n\n\t/* clear the notification queue of all events */\n\tfsnotify_flush_notify(group);\n\n\t/*\n\t * Destroy overflow event (we cannot use fsnotify_destroy_event() as\n\t * that deliberately ignores overflow events.\n\t */\n\tif (group->overflow_event)\n\t\tgroup->ops->free_event(group->overflow_event);\n\n\tfsnotify_put_group(group);\n}",
          "includes": [
            "#include <linux/atomic.h>",
            "#include \"fsnotify.h\"",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/wait.h>",
            "#include <linux/rculist.h>",
            "#include <linux/srcu.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/atomic.h>\n#include \"fsnotify.h\"\n#include <linux/fsnotify_backend.h>\n#include <linux/wait.h>\n#include <linux/rculist.h>\n#include <linux/srcu.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/list.h>\n\nvoid fsnotify_destroy_group(struct fsnotify_group *group)\n{\n\t/* clear all inode marks for this group */\n\tfsnotify_clear_marks_by_group(group);\n\n\tsynchronize_srcu(&fsnotify_mark_srcu);\n\n\t/* clear the notification queue of all events */\n\tfsnotify_flush_notify(group);\n\n\t/*\n\t * Destroy overflow event (we cannot use fsnotify_destroy_event() as\n\t * that deliberately ignores overflow events.\n\t */\n\tif (group->overflow_event)\n\t\tgroup->ops->free_event(group->overflow_event);\n\n\tfsnotify_put_group(group);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"%s: group=%p\\n\"",
            "__func__",
            "group"
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sysctl.h>\n#include <asm/ioctls.h>\n#include \"../fdinfo.h\"\n#include \"inotify.h\"\n#include <linux/wait.h>\n#include <linux/poll.h>\n#include <linux/uaccess.h>\n#include <linux/anon_inodes.h>\n#include <linux/types.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h> /* struct kmem_cache */\n#include <linux/sched.h> /* struct user */\n#include <linux/namei.h> /* LOOKUP_FOLLOW */\n#include <linux/kernel.h> /* roundup() */\n#include <linux/inotify.h>\n#include <linux/init.h> /* module_init */\n#include <linux/idr.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/fs.h> /* struct inode */\n#include <linux/file.h>\n\nstatic int inotify_release(struct inode *ignored, struct file *file)\n{\n\tstruct fsnotify_group *group = file->private_data;\n\n\tpr_debug(\"%s: group=%p\\n\", __func__, group);\n\n\t/* free this group, matching get was inotify_init->fsnotify_obtain_group */\n\tfsnotify_destroy_group(group);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "inotify_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/inotify/inotify_user.c",
    "lines": "223-273",
    "snippet": "static ssize_t inotify_read(struct file *file, char __user *buf,\n\t\t\t    size_t count, loff_t *pos)\n{\n\tstruct fsnotify_group *group;\n\tstruct fsnotify_event *kevent;\n\tchar __user *start;\n\tint ret;\n\tDEFINE_WAIT_FUNC(wait, woken_wake_function);\n\n\tstart = buf;\n\tgroup = file->private_data;\n\n\tadd_wait_queue(&group->notification_waitq, &wait);\n\twhile (1) {\n\t\tmutex_lock(&group->notification_mutex);\n\t\tkevent = get_one_event(group, count);\n\t\tmutex_unlock(&group->notification_mutex);\n\n\t\tpr_debug(\"%s: group=%p kevent=%p\\n\", __func__, group, kevent);\n\n\t\tif (kevent) {\n\t\t\tret = PTR_ERR(kevent);\n\t\t\tif (IS_ERR(kevent))\n\t\t\t\tbreak;\n\t\t\tret = copy_event_to_user(group, kevent, buf);\n\t\t\tfsnotify_destroy_event(group, kevent);\n\t\t\tif (ret < 0)\n\t\t\t\tbreak;\n\t\t\tbuf += ret;\n\t\t\tcount -= ret;\n\t\t\tcontinue;\n\t\t}\n\n\t\tret = -EAGAIN;\n\t\tif (file->f_flags & O_NONBLOCK)\n\t\t\tbreak;\n\t\tret = -ERESTARTSYS;\n\t\tif (signal_pending(current))\n\t\t\tbreak;\n\n\t\tif (start != buf)\n\t\t\tbreak;\n\n\t\twait_woken(&wait, TASK_INTERRUPTIBLE, MAX_SCHEDULE_TIMEOUT);\n\t}\n\tremove_wait_queue(&group->notification_waitq, &wait);\n\n\tif (start != buf && ret != -EFAULT)\n\t\tret = buf - start;\n\treturn ret;\n}",
    "includes": [
      "#include <linux/sysctl.h>",
      "#include <asm/ioctls.h>",
      "#include \"../fdinfo.h\"",
      "#include \"inotify.h\"",
      "#include <linux/wait.h>",
      "#include <linux/poll.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/types.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h> /* struct kmem_cache */",
      "#include <linux/sched.h> /* struct user */",
      "#include <linux/namei.h> /* LOOKUP_FOLLOW */",
      "#include <linux/kernel.h> /* roundup() */",
      "#include <linux/inotify.h>",
      "#include <linux/init.h> /* module_init */",
      "#include <linux/idr.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/fs.h> /* struct inode */",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "remove_wait_queue",
          "args": [
            "&group->notification_waitq",
            "&wait"
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_woken",
          "args": [
            "&wait",
            "TASK_INTERRUPTIBLE",
            "MAX_SCHEDULE_TIMEOUT"
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "signal_pending",
          "args": [
            "current"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fsnotify_destroy_event",
          "args": [
            "group",
            "kevent"
          ],
          "line": 248
        },
        "resolved": true,
        "details": {
          "function_name": "fsnotify_destroy_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/notification.c",
          "lines": "70-79",
          "snippet": "void fsnotify_destroy_event(struct fsnotify_group *group,\n\t\t\t    struct fsnotify_event *event)\n{\n\t/* Overflow events are per-group and we don't want to free them */\n\tif (!event || event->mask == FS_Q_OVERFLOW)\n\t\treturn;\n\t/* If the event is still queued, we have a problem... */\n\tWARN_ON(!list_empty(&event->list));\n\tgroup->ops->free_event(event);\n}",
          "includes": [
            "#include \"fsnotify.h\"",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/atomic.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/path.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mount.h>",
            "#include <linux/module.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fsnotify.h\"\n#include <linux/fsnotify_backend.h>\n#include <linux/atomic.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/path.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n\nvoid fsnotify_destroy_event(struct fsnotify_group *group,\n\t\t\t    struct fsnotify_event *event)\n{\n\t/* Overflow events are per-group and we don't want to free them */\n\tif (!event || event->mask == FS_Q_OVERFLOW)\n\t\treturn;\n\t/* If the event is still queued, we have a problem... */\n\tWARN_ON(!list_empty(&event->list));\n\tgroup->ops->free_event(event);\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_event_to_user",
          "args": [
            "group",
            "kevent",
            "buf"
          ],
          "line": 247
        },
        "resolved": true,
        "details": {
          "function_name": "copy_event_to_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/inotify/inotify_user.c",
          "lines": "173-221",
          "snippet": "static ssize_t copy_event_to_user(struct fsnotify_group *group,\n\t\t\t\t  struct fsnotify_event *fsn_event,\n\t\t\t\t  char __user *buf)\n{\n\tstruct inotify_event inotify_event;\n\tstruct inotify_event_info *event;\n\tsize_t event_size = sizeof(struct inotify_event);\n\tsize_t name_len;\n\tsize_t pad_name_len;\n\n\tpr_debug(\"%s: group=%p event=%p\\n\", __func__, group, fsn_event);\n\n\tevent = INOTIFY_E(fsn_event);\n\tname_len = event->name_len;\n\t/*\n\t * round up name length so it is a multiple of event_size\n\t * plus an extra byte for the terminating '\\0'.\n\t */\n\tpad_name_len = round_event_name_len(fsn_event);\n\tinotify_event.len = pad_name_len;\n\tinotify_event.mask = inotify_mask_to_arg(fsn_event->mask);\n\tinotify_event.wd = event->wd;\n\tinotify_event.cookie = event->sync_cookie;\n\n\t/* send the main event */\n\tif (copy_to_user(buf, &inotify_event, event_size))\n\t\treturn -EFAULT;\n\n\tbuf += event_size;\n\n\t/*\n\t * fsnotify only stores the pathname, so here we have to send the pathname\n\t * and then pad that pathname out to a multiple of sizeof(inotify_event)\n\t * with zeros.\n\t */\n\tif (pad_name_len) {\n\t\t/* copy the path name */\n\t\tif (copy_to_user(buf, event->name, name_len))\n\t\t\treturn -EFAULT;\n\t\tbuf += name_len;\n\n\t\t/* fill userspace with 0's */\n\t\tif (clear_user(buf, pad_name_len - name_len))\n\t\t\treturn -EFAULT;\n\t\tevent_size += pad_name_len;\n\t}\n\n\treturn event_size;\n}",
          "includes": [
            "#include <linux/sysctl.h>",
            "#include <asm/ioctls.h>",
            "#include \"../fdinfo.h\"",
            "#include \"inotify.h\"",
            "#include <linux/wait.h>",
            "#include <linux/poll.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/types.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h> /* struct kmem_cache */",
            "#include <linux/sched.h> /* struct user */",
            "#include <linux/namei.h> /* LOOKUP_FOLLOW */",
            "#include <linux/kernel.h> /* roundup() */",
            "#include <linux/inotify.h>",
            "#include <linux/init.h> /* module_init */",
            "#include <linux/idr.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/fs.h> /* struct inode */",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sysctl.h>\n#include <asm/ioctls.h>\n#include \"../fdinfo.h\"\n#include \"inotify.h\"\n#include <linux/wait.h>\n#include <linux/poll.h>\n#include <linux/uaccess.h>\n#include <linux/anon_inodes.h>\n#include <linux/types.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h> /* struct kmem_cache */\n#include <linux/sched.h> /* struct user */\n#include <linux/namei.h> /* LOOKUP_FOLLOW */\n#include <linux/kernel.h> /* roundup() */\n#include <linux/inotify.h>\n#include <linux/init.h> /* module_init */\n#include <linux/idr.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/fs.h> /* struct inode */\n#include <linux/file.h>\n\nstatic ssize_t copy_event_to_user(struct fsnotify_group *group,\n\t\t\t\t  struct fsnotify_event *fsn_event,\n\t\t\t\t  char __user *buf)\n{\n\tstruct inotify_event inotify_event;\n\tstruct inotify_event_info *event;\n\tsize_t event_size = sizeof(struct inotify_event);\n\tsize_t name_len;\n\tsize_t pad_name_len;\n\n\tpr_debug(\"%s: group=%p event=%p\\n\", __func__, group, fsn_event);\n\n\tevent = INOTIFY_E(fsn_event);\n\tname_len = event->name_len;\n\t/*\n\t * round up name length so it is a multiple of event_size\n\t * plus an extra byte for the terminating '\\0'.\n\t */\n\tpad_name_len = round_event_name_len(fsn_event);\n\tinotify_event.len = pad_name_len;\n\tinotify_event.mask = inotify_mask_to_arg(fsn_event->mask);\n\tinotify_event.wd = event->wd;\n\tinotify_event.cookie = event->sync_cookie;\n\n\t/* send the main event */\n\tif (copy_to_user(buf, &inotify_event, event_size))\n\t\treturn -EFAULT;\n\n\tbuf += event_size;\n\n\t/*\n\t * fsnotify only stores the pathname, so here we have to send the pathname\n\t * and then pad that pathname out to a multiple of sizeof(inotify_event)\n\t * with zeros.\n\t */\n\tif (pad_name_len) {\n\t\t/* copy the path name */\n\t\tif (copy_to_user(buf, event->name, name_len))\n\t\t\treturn -EFAULT;\n\t\tbuf += name_len;\n\n\t\t/* fill userspace with 0's */\n\t\tif (clear_user(buf, pad_name_len - name_len))\n\t\t\treturn -EFAULT;\n\t\tevent_size += pad_name_len;\n\t}\n\n\treturn event_size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "kevent"
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "kevent"
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"%s: group=%p kevent=%p\\n\"",
            "__func__",
            "group",
            "kevent"
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&group->notification_mutex"
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_one_event",
          "args": [
            "group",
            "count"
          ],
          "line": 238
        },
        "resolved": true,
        "details": {
          "function_name": "get_one_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/inotify/inotify_user.c",
          "lines": "143-165",
          "snippet": "static struct fsnotify_event *get_one_event(struct fsnotify_group *group,\n\t\t\t\t\t    size_t count)\n{\n\tsize_t event_size = sizeof(struct inotify_event);\n\tstruct fsnotify_event *event;\n\n\tif (fsnotify_notify_queue_is_empty(group))\n\t\treturn NULL;\n\n\tevent = fsnotify_peek_first_event(group);\n\n\tpr_debug(\"%s: group=%p event=%p\\n\", __func__, group, event);\n\n\tevent_size += round_event_name_len(event);\n\tif (event_size > count)\n\t\treturn ERR_PTR(-EINVAL);\n\n\t/* held the notification_mutex the whole time, so this is the\n\t * same event we peeked above */\n\tfsnotify_remove_first_event(group);\n\n\treturn event;\n}",
          "includes": [
            "#include <linux/sysctl.h>",
            "#include <asm/ioctls.h>",
            "#include \"../fdinfo.h\"",
            "#include \"inotify.h\"",
            "#include <linux/wait.h>",
            "#include <linux/poll.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/types.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h> /* struct kmem_cache */",
            "#include <linux/sched.h> /* struct user */",
            "#include <linux/namei.h> /* LOOKUP_FOLLOW */",
            "#include <linux/kernel.h> /* roundup() */",
            "#include <linux/inotify.h>",
            "#include <linux/init.h> /* module_init */",
            "#include <linux/idr.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/fs.h> /* struct inode */",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sysctl.h>\n#include <asm/ioctls.h>\n#include \"../fdinfo.h\"\n#include \"inotify.h\"\n#include <linux/wait.h>\n#include <linux/poll.h>\n#include <linux/uaccess.h>\n#include <linux/anon_inodes.h>\n#include <linux/types.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h> /* struct kmem_cache */\n#include <linux/sched.h> /* struct user */\n#include <linux/namei.h> /* LOOKUP_FOLLOW */\n#include <linux/kernel.h> /* roundup() */\n#include <linux/inotify.h>\n#include <linux/init.h> /* module_init */\n#include <linux/idr.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/fs.h> /* struct inode */\n#include <linux/file.h>\n\nstatic struct fsnotify_event *get_one_event(struct fsnotify_group *group,\n\t\t\t\t\t    size_t count)\n{\n\tsize_t event_size = sizeof(struct inotify_event);\n\tstruct fsnotify_event *event;\n\n\tif (fsnotify_notify_queue_is_empty(group))\n\t\treturn NULL;\n\n\tevent = fsnotify_peek_first_event(group);\n\n\tpr_debug(\"%s: group=%p event=%p\\n\", __func__, group, event);\n\n\tevent_size += round_event_name_len(event);\n\tif (event_size > count)\n\t\treturn ERR_PTR(-EINVAL);\n\n\t/* held the notification_mutex the whole time, so this is the\n\t * same event we peeked above */\n\tfsnotify_remove_first_event(group);\n\n\treturn event;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&group->notification_mutex"
          ],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add_wait_queue",
          "args": [
            "&group->notification_waitq",
            "&wait"
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DEFINE_WAIT_FUNC",
          "args": [
            "wait",
            "woken_wake_function"
          ],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sysctl.h>\n#include <asm/ioctls.h>\n#include \"../fdinfo.h\"\n#include \"inotify.h\"\n#include <linux/wait.h>\n#include <linux/poll.h>\n#include <linux/uaccess.h>\n#include <linux/anon_inodes.h>\n#include <linux/types.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h> /* struct kmem_cache */\n#include <linux/sched.h> /* struct user */\n#include <linux/namei.h> /* LOOKUP_FOLLOW */\n#include <linux/kernel.h> /* roundup() */\n#include <linux/inotify.h>\n#include <linux/init.h> /* module_init */\n#include <linux/idr.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/fs.h> /* struct inode */\n#include <linux/file.h>\n\nstatic ssize_t inotify_read(struct file *file, char __user *buf,\n\t\t\t    size_t count, loff_t *pos)\n{\n\tstruct fsnotify_group *group;\n\tstruct fsnotify_event *kevent;\n\tchar __user *start;\n\tint ret;\n\tDEFINE_WAIT_FUNC(wait, woken_wake_function);\n\n\tstart = buf;\n\tgroup = file->private_data;\n\n\tadd_wait_queue(&group->notification_waitq, &wait);\n\twhile (1) {\n\t\tmutex_lock(&group->notification_mutex);\n\t\tkevent = get_one_event(group, count);\n\t\tmutex_unlock(&group->notification_mutex);\n\n\t\tpr_debug(\"%s: group=%p kevent=%p\\n\", __func__, group, kevent);\n\n\t\tif (kevent) {\n\t\t\tret = PTR_ERR(kevent);\n\t\t\tif (IS_ERR(kevent))\n\t\t\t\tbreak;\n\t\t\tret = copy_event_to_user(group, kevent, buf);\n\t\t\tfsnotify_destroy_event(group, kevent);\n\t\t\tif (ret < 0)\n\t\t\t\tbreak;\n\t\t\tbuf += ret;\n\t\t\tcount -= ret;\n\t\t\tcontinue;\n\t\t}\n\n\t\tret = -EAGAIN;\n\t\tif (file->f_flags & O_NONBLOCK)\n\t\t\tbreak;\n\t\tret = -ERESTARTSYS;\n\t\tif (signal_pending(current))\n\t\t\tbreak;\n\n\t\tif (start != buf)\n\t\t\tbreak;\n\n\t\twait_woken(&wait, TASK_INTERRUPTIBLE, MAX_SCHEDULE_TIMEOUT);\n\t}\n\tremove_wait_queue(&group->notification_waitq, &wait);\n\n\tif (start != buf && ret != -EFAULT)\n\t\tret = buf - start;\n\treturn ret;\n}"
  },
  {
    "function_name": "copy_event_to_user",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/inotify/inotify_user.c",
    "lines": "173-221",
    "snippet": "static ssize_t copy_event_to_user(struct fsnotify_group *group,\n\t\t\t\t  struct fsnotify_event *fsn_event,\n\t\t\t\t  char __user *buf)\n{\n\tstruct inotify_event inotify_event;\n\tstruct inotify_event_info *event;\n\tsize_t event_size = sizeof(struct inotify_event);\n\tsize_t name_len;\n\tsize_t pad_name_len;\n\n\tpr_debug(\"%s: group=%p event=%p\\n\", __func__, group, fsn_event);\n\n\tevent = INOTIFY_E(fsn_event);\n\tname_len = event->name_len;\n\t/*\n\t * round up name length so it is a multiple of event_size\n\t * plus an extra byte for the terminating '\\0'.\n\t */\n\tpad_name_len = round_event_name_len(fsn_event);\n\tinotify_event.len = pad_name_len;\n\tinotify_event.mask = inotify_mask_to_arg(fsn_event->mask);\n\tinotify_event.wd = event->wd;\n\tinotify_event.cookie = event->sync_cookie;\n\n\t/* send the main event */\n\tif (copy_to_user(buf, &inotify_event, event_size))\n\t\treturn -EFAULT;\n\n\tbuf += event_size;\n\n\t/*\n\t * fsnotify only stores the pathname, so here we have to send the pathname\n\t * and then pad that pathname out to a multiple of sizeof(inotify_event)\n\t * with zeros.\n\t */\n\tif (pad_name_len) {\n\t\t/* copy the path name */\n\t\tif (copy_to_user(buf, event->name, name_len))\n\t\t\treturn -EFAULT;\n\t\tbuf += name_len;\n\n\t\t/* fill userspace with 0's */\n\t\tif (clear_user(buf, pad_name_len - name_len))\n\t\t\treturn -EFAULT;\n\t\tevent_size += pad_name_len;\n\t}\n\n\treturn event_size;\n}",
    "includes": [
      "#include <linux/sysctl.h>",
      "#include <asm/ioctls.h>",
      "#include \"../fdinfo.h\"",
      "#include \"inotify.h\"",
      "#include <linux/wait.h>",
      "#include <linux/poll.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/types.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h> /* struct kmem_cache */",
      "#include <linux/sched.h> /* struct user */",
      "#include <linux/namei.h> /* LOOKUP_FOLLOW */",
      "#include <linux/kernel.h> /* roundup() */",
      "#include <linux/inotify.h>",
      "#include <linux/init.h> /* module_init */",
      "#include <linux/idr.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/fs.h> /* struct inode */",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "clear_user",
          "args": [
            "buf",
            "pad_name_len - name_len"
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "buf",
            "event->name",
            "name_len"
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "buf",
            "&inotify_event",
            "event_size"
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inotify_mask_to_arg",
          "args": [
            "fsn_event->mask"
          ],
          "line": 193
        },
        "resolved": true,
        "details": {
          "function_name": "inotify_mask_to_arg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/inotify/inotify_user.c",
          "lines": "105-109",
          "snippet": "static inline u32 inotify_mask_to_arg(__u32 mask)\n{\n\treturn mask & (IN_ALL_EVENTS | IN_ISDIR | IN_UNMOUNT | IN_IGNORED |\n\t\t       IN_Q_OVERFLOW);\n}",
          "includes": [
            "#include <linux/sysctl.h>",
            "#include <asm/ioctls.h>",
            "#include \"../fdinfo.h\"",
            "#include \"inotify.h\"",
            "#include <linux/wait.h>",
            "#include <linux/poll.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/types.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h> /* struct kmem_cache */",
            "#include <linux/sched.h> /* struct user */",
            "#include <linux/namei.h> /* LOOKUP_FOLLOW */",
            "#include <linux/kernel.h> /* roundup() */",
            "#include <linux/inotify.h>",
            "#include <linux/init.h> /* module_init */",
            "#include <linux/idr.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/fs.h> /* struct inode */",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sysctl.h>\n#include <asm/ioctls.h>\n#include \"../fdinfo.h\"\n#include \"inotify.h\"\n#include <linux/wait.h>\n#include <linux/poll.h>\n#include <linux/uaccess.h>\n#include <linux/anon_inodes.h>\n#include <linux/types.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h> /* struct kmem_cache */\n#include <linux/sched.h> /* struct user */\n#include <linux/namei.h> /* LOOKUP_FOLLOW */\n#include <linux/kernel.h> /* roundup() */\n#include <linux/inotify.h>\n#include <linux/init.h> /* module_init */\n#include <linux/idr.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/fs.h> /* struct inode */\n#include <linux/file.h>\n\nstatic inline u32 inotify_mask_to_arg(__u32 mask)\n{\n\treturn mask & (IN_ALL_EVENTS | IN_ISDIR | IN_UNMOUNT | IN_IGNORED |\n\t\t       IN_Q_OVERFLOW);\n}"
        }
      },
      {
        "call_info": {
          "callee": "round_event_name_len",
          "args": [
            "fsn_event"
          ],
          "line": 191
        },
        "resolved": true,
        "details": {
          "function_name": "round_event_name_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/inotify/inotify_user.c",
          "lines": "126-134",
          "snippet": "static int round_event_name_len(struct fsnotify_event *fsn_event)\n{\n\tstruct inotify_event_info *event;\n\n\tevent = INOTIFY_E(fsn_event);\n\tif (!event->name_len)\n\t\treturn 0;\n\treturn roundup(event->name_len + 1, sizeof(struct inotify_event));\n}",
          "includes": [
            "#include <linux/sysctl.h>",
            "#include <asm/ioctls.h>",
            "#include \"../fdinfo.h\"",
            "#include \"inotify.h\"",
            "#include <linux/wait.h>",
            "#include <linux/poll.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/types.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h> /* struct kmem_cache */",
            "#include <linux/sched.h> /* struct user */",
            "#include <linux/namei.h> /* LOOKUP_FOLLOW */",
            "#include <linux/kernel.h> /* roundup() */",
            "#include <linux/inotify.h>",
            "#include <linux/init.h> /* module_init */",
            "#include <linux/idr.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/fs.h> /* struct inode */",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sysctl.h>\n#include <asm/ioctls.h>\n#include \"../fdinfo.h\"\n#include \"inotify.h\"\n#include <linux/wait.h>\n#include <linux/poll.h>\n#include <linux/uaccess.h>\n#include <linux/anon_inodes.h>\n#include <linux/types.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h> /* struct kmem_cache */\n#include <linux/sched.h> /* struct user */\n#include <linux/namei.h> /* LOOKUP_FOLLOW */\n#include <linux/kernel.h> /* roundup() */\n#include <linux/inotify.h>\n#include <linux/init.h> /* module_init */\n#include <linux/idr.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/fs.h> /* struct inode */\n#include <linux/file.h>\n\nstatic int round_event_name_len(struct fsnotify_event *fsn_event)\n{\n\tstruct inotify_event_info *event;\n\n\tevent = INOTIFY_E(fsn_event);\n\tif (!event->name_len)\n\t\treturn 0;\n\treturn roundup(event->name_len + 1, sizeof(struct inotify_event));\n}"
        }
      },
      {
        "call_info": {
          "callee": "INOTIFY_E",
          "args": [
            "fsn_event"
          ],
          "line": 185
        },
        "resolved": true,
        "details": {
          "function_name": "INOTIFY_E",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/inotify/inotify.h",
          "lines": "18-21",
          "snippet": "static inline struct inotify_event_info *INOTIFY_E(struct fsnotify_event *fse)\n{\n\treturn container_of(fse, struct inotify_event_info, fse);\n}",
          "includes": [
            "#include <linux/slab.h> /* struct kmem_cache */",
            "#include <linux/inotify.h>",
            "#include <linux/fsnotify_backend.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h> /* struct kmem_cache */\n#include <linux/inotify.h>\n#include <linux/fsnotify_backend.h>\n\nstatic inline struct inotify_event_info *INOTIFY_E(struct fsnotify_event *fse)\n{\n\treturn container_of(fse, struct inotify_event_info, fse);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"%s: group=%p event=%p\\n\"",
            "__func__",
            "group",
            "fsn_event"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sysctl.h>\n#include <asm/ioctls.h>\n#include \"../fdinfo.h\"\n#include \"inotify.h\"\n#include <linux/wait.h>\n#include <linux/poll.h>\n#include <linux/uaccess.h>\n#include <linux/anon_inodes.h>\n#include <linux/types.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h> /* struct kmem_cache */\n#include <linux/sched.h> /* struct user */\n#include <linux/namei.h> /* LOOKUP_FOLLOW */\n#include <linux/kernel.h> /* roundup() */\n#include <linux/inotify.h>\n#include <linux/init.h> /* module_init */\n#include <linux/idr.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/fs.h> /* struct inode */\n#include <linux/file.h>\n\nstatic ssize_t copy_event_to_user(struct fsnotify_group *group,\n\t\t\t\t  struct fsnotify_event *fsn_event,\n\t\t\t\t  char __user *buf)\n{\n\tstruct inotify_event inotify_event;\n\tstruct inotify_event_info *event;\n\tsize_t event_size = sizeof(struct inotify_event);\n\tsize_t name_len;\n\tsize_t pad_name_len;\n\n\tpr_debug(\"%s: group=%p event=%p\\n\", __func__, group, fsn_event);\n\n\tevent = INOTIFY_E(fsn_event);\n\tname_len = event->name_len;\n\t/*\n\t * round up name length so it is a multiple of event_size\n\t * plus an extra byte for the terminating '\\0'.\n\t */\n\tpad_name_len = round_event_name_len(fsn_event);\n\tinotify_event.len = pad_name_len;\n\tinotify_event.mask = inotify_mask_to_arg(fsn_event->mask);\n\tinotify_event.wd = event->wd;\n\tinotify_event.cookie = event->sync_cookie;\n\n\t/* send the main event */\n\tif (copy_to_user(buf, &inotify_event, event_size))\n\t\treturn -EFAULT;\n\n\tbuf += event_size;\n\n\t/*\n\t * fsnotify only stores the pathname, so here we have to send the pathname\n\t * and then pad that pathname out to a multiple of sizeof(inotify_event)\n\t * with zeros.\n\t */\n\tif (pad_name_len) {\n\t\t/* copy the path name */\n\t\tif (copy_to_user(buf, event->name, name_len))\n\t\t\treturn -EFAULT;\n\t\tbuf += name_len;\n\n\t\t/* fill userspace with 0's */\n\t\tif (clear_user(buf, pad_name_len - name_len))\n\t\t\treturn -EFAULT;\n\t\tevent_size += pad_name_len;\n\t}\n\n\treturn event_size;\n}"
  },
  {
    "function_name": "get_one_event",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/inotify/inotify_user.c",
    "lines": "143-165",
    "snippet": "static struct fsnotify_event *get_one_event(struct fsnotify_group *group,\n\t\t\t\t\t    size_t count)\n{\n\tsize_t event_size = sizeof(struct inotify_event);\n\tstruct fsnotify_event *event;\n\n\tif (fsnotify_notify_queue_is_empty(group))\n\t\treturn NULL;\n\n\tevent = fsnotify_peek_first_event(group);\n\n\tpr_debug(\"%s: group=%p event=%p\\n\", __func__, group, event);\n\n\tevent_size += round_event_name_len(event);\n\tif (event_size > count)\n\t\treturn ERR_PTR(-EINVAL);\n\n\t/* held the notification_mutex the whole time, so this is the\n\t * same event we peeked above */\n\tfsnotify_remove_first_event(group);\n\n\treturn event;\n}",
    "includes": [
      "#include <linux/sysctl.h>",
      "#include <asm/ioctls.h>",
      "#include \"../fdinfo.h\"",
      "#include \"inotify.h\"",
      "#include <linux/wait.h>",
      "#include <linux/poll.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/types.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h> /* struct kmem_cache */",
      "#include <linux/sched.h> /* struct user */",
      "#include <linux/namei.h> /* LOOKUP_FOLLOW */",
      "#include <linux/kernel.h> /* roundup() */",
      "#include <linux/inotify.h>",
      "#include <linux/init.h> /* module_init */",
      "#include <linux/idr.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/fs.h> /* struct inode */",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fsnotify_remove_first_event",
          "args": [
            "group"
          ],
          "line": 162
        },
        "resolved": true,
        "details": {
          "function_name": "fsnotify_remove_first_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/notification.c",
          "lines": "147-165",
          "snippet": "struct fsnotify_event *fsnotify_remove_first_event(struct fsnotify_group *group)\n{\n\tstruct fsnotify_event *event;\n\n\tBUG_ON(!mutex_is_locked(&group->notification_mutex));\n\n\tpr_debug(\"%s: group=%p\\n\", __func__, group);\n\n\tevent = list_first_entry(&group->notification_list,\n\t\t\t\t struct fsnotify_event, list);\n\t/*\n\t * We need to init list head for the case of overflow event so that\n\t * check in fsnotify_add_event() works\n\t */\n\tlist_del_init(&event->list);\n\tgroup->q_len--;\n\n\treturn event;\n}",
          "includes": [
            "#include \"fsnotify.h\"",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/atomic.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/path.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mount.h>",
            "#include <linux/module.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fsnotify.h\"\n#include <linux/fsnotify_backend.h>\n#include <linux/atomic.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/path.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n\nstruct fsnotify_event *fsnotify_remove_first_event(struct fsnotify_group *group)\n{\n\tstruct fsnotify_event *event;\n\n\tBUG_ON(!mutex_is_locked(&group->notification_mutex));\n\n\tpr_debug(\"%s: group=%p\\n\", __func__, group);\n\n\tevent = list_first_entry(&group->notification_list,\n\t\t\t\t struct fsnotify_event, list);\n\t/*\n\t * We need to init list head for the case of overflow event so that\n\t * check in fsnotify_add_event() works\n\t */\n\tlist_del_init(&event->list);\n\tgroup->q_len--;\n\n\treturn event;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EINVAL"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "round_event_name_len",
          "args": [
            "event"
          ],
          "line": 156
        },
        "resolved": true,
        "details": {
          "function_name": "round_event_name_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/inotify/inotify_user.c",
          "lines": "126-134",
          "snippet": "static int round_event_name_len(struct fsnotify_event *fsn_event)\n{\n\tstruct inotify_event_info *event;\n\n\tevent = INOTIFY_E(fsn_event);\n\tif (!event->name_len)\n\t\treturn 0;\n\treturn roundup(event->name_len + 1, sizeof(struct inotify_event));\n}",
          "includes": [
            "#include <linux/sysctl.h>",
            "#include <asm/ioctls.h>",
            "#include \"../fdinfo.h\"",
            "#include \"inotify.h\"",
            "#include <linux/wait.h>",
            "#include <linux/poll.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/types.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h> /* struct kmem_cache */",
            "#include <linux/sched.h> /* struct user */",
            "#include <linux/namei.h> /* LOOKUP_FOLLOW */",
            "#include <linux/kernel.h> /* roundup() */",
            "#include <linux/inotify.h>",
            "#include <linux/init.h> /* module_init */",
            "#include <linux/idr.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/fs.h> /* struct inode */",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sysctl.h>\n#include <asm/ioctls.h>\n#include \"../fdinfo.h\"\n#include \"inotify.h\"\n#include <linux/wait.h>\n#include <linux/poll.h>\n#include <linux/uaccess.h>\n#include <linux/anon_inodes.h>\n#include <linux/types.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h> /* struct kmem_cache */\n#include <linux/sched.h> /* struct user */\n#include <linux/namei.h> /* LOOKUP_FOLLOW */\n#include <linux/kernel.h> /* roundup() */\n#include <linux/inotify.h>\n#include <linux/init.h> /* module_init */\n#include <linux/idr.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/fs.h> /* struct inode */\n#include <linux/file.h>\n\nstatic int round_event_name_len(struct fsnotify_event *fsn_event)\n{\n\tstruct inotify_event_info *event;\n\n\tevent = INOTIFY_E(fsn_event);\n\tif (!event->name_len)\n\t\treturn 0;\n\treturn roundup(event->name_len + 1, sizeof(struct inotify_event));\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"%s: group=%p event=%p\\n\"",
            "__func__",
            "group",
            "event"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fsnotify_peek_first_event",
          "args": [
            "group"
          ],
          "line": 152
        },
        "resolved": true,
        "details": {
          "function_name": "fsnotify_peek_first_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/notification.c",
          "lines": "171-177",
          "snippet": "struct fsnotify_event *fsnotify_peek_first_event(struct fsnotify_group *group)\n{\n\tBUG_ON(!mutex_is_locked(&group->notification_mutex));\n\n\treturn list_first_entry(&group->notification_list,\n\t\t\t\tstruct fsnotify_event, list);\n}",
          "includes": [
            "#include \"fsnotify.h\"",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/atomic.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/path.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mount.h>",
            "#include <linux/module.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fsnotify.h\"\n#include <linux/fsnotify_backend.h>\n#include <linux/atomic.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/path.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n\nstruct fsnotify_event *fsnotify_peek_first_event(struct fsnotify_group *group)\n{\n\tBUG_ON(!mutex_is_locked(&group->notification_mutex));\n\n\treturn list_first_entry(&group->notification_list,\n\t\t\t\tstruct fsnotify_event, list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fsnotify_notify_queue_is_empty",
          "args": [
            "group"
          ],
          "line": 149
        },
        "resolved": true,
        "details": {
          "function_name": "fsnotify_notify_queue_is_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/notification.c",
          "lines": "64-68",
          "snippet": "bool fsnotify_notify_queue_is_empty(struct fsnotify_group *group)\n{\n\tBUG_ON(!mutex_is_locked(&group->notification_mutex));\n\treturn list_empty(&group->notification_list) ? true : false;\n}",
          "includes": [
            "#include \"fsnotify.h\"",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/atomic.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/path.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mount.h>",
            "#include <linux/module.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fsnotify.h\"\n#include <linux/fsnotify_backend.h>\n#include <linux/atomic.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/path.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n\nbool fsnotify_notify_queue_is_empty(struct fsnotify_group *group)\n{\n\tBUG_ON(!mutex_is_locked(&group->notification_mutex));\n\treturn list_empty(&group->notification_list) ? true : false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/sysctl.h>\n#include <asm/ioctls.h>\n#include \"../fdinfo.h\"\n#include \"inotify.h\"\n#include <linux/wait.h>\n#include <linux/poll.h>\n#include <linux/uaccess.h>\n#include <linux/anon_inodes.h>\n#include <linux/types.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h> /* struct kmem_cache */\n#include <linux/sched.h> /* struct user */\n#include <linux/namei.h> /* LOOKUP_FOLLOW */\n#include <linux/kernel.h> /* roundup() */\n#include <linux/inotify.h>\n#include <linux/init.h> /* module_init */\n#include <linux/idr.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/fs.h> /* struct inode */\n#include <linux/file.h>\n\nstatic struct fsnotify_event *get_one_event(struct fsnotify_group *group,\n\t\t\t\t\t    size_t count)\n{\n\tsize_t event_size = sizeof(struct inotify_event);\n\tstruct fsnotify_event *event;\n\n\tif (fsnotify_notify_queue_is_empty(group))\n\t\treturn NULL;\n\n\tevent = fsnotify_peek_first_event(group);\n\n\tpr_debug(\"%s: group=%p event=%p\\n\", __func__, group, event);\n\n\tevent_size += round_event_name_len(event);\n\tif (event_size > count)\n\t\treturn ERR_PTR(-EINVAL);\n\n\t/* held the notification_mutex the whole time, so this is the\n\t * same event we peeked above */\n\tfsnotify_remove_first_event(group);\n\n\treturn event;\n}"
  },
  {
    "function_name": "round_event_name_len",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/inotify/inotify_user.c",
    "lines": "126-134",
    "snippet": "static int round_event_name_len(struct fsnotify_event *fsn_event)\n{\n\tstruct inotify_event_info *event;\n\n\tevent = INOTIFY_E(fsn_event);\n\tif (!event->name_len)\n\t\treturn 0;\n\treturn roundup(event->name_len + 1, sizeof(struct inotify_event));\n}",
    "includes": [
      "#include <linux/sysctl.h>",
      "#include <asm/ioctls.h>",
      "#include \"../fdinfo.h\"",
      "#include \"inotify.h\"",
      "#include <linux/wait.h>",
      "#include <linux/poll.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/types.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h> /* struct kmem_cache */",
      "#include <linux/sched.h> /* struct user */",
      "#include <linux/namei.h> /* LOOKUP_FOLLOW */",
      "#include <linux/kernel.h> /* roundup() */",
      "#include <linux/inotify.h>",
      "#include <linux/init.h> /* module_init */",
      "#include <linux/idr.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/fs.h> /* struct inode */",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "roundup",
          "args": [
            "event->name_len + 1",
            "sizeof(struct inotify_event)"
          ],
          "line": 133
        },
        "resolved": true,
        "details": {
          "function_name": "roundup_64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_linux.h",
          "lines": "333-338",
          "snippet": "static inline __uint64_t roundup_64(__uint64_t x, __uint32_t y)\n{\n\tx += y - 1;\n\tdo_div(x, y);\n\treturn x * y;\n}",
          "includes": [
            "#include \"xfs_message.h\"",
            "#include \"xfs_buf.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_super.h\"",
            "#include \"xfs_aops.h\"",
            "#include \"xfs_iops.h\"",
            "#include \"xfs_sysctl.h\"",
            "#include \"xfs_stats.h\"",
            "#include \"xfs_fs.h\"",
            "#include <asm/unaligned.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/param.h>",
            "#include <asm/div64.h>",
            "#include <asm/page.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/capability.h>",
            "#include <linux/writeback.h>",
            "#include <linux/ctype.h>",
            "#include <linux/random.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/log2.h>",
            "#include <linux/delay.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sort.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/list.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/vfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/major.h>",
            "#include <linux/bitops.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>",
            "#include <linux/swap.h>",
            "#include <linux/file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/crc32c.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mm.h>",
            "#include <linux/semaphore.h>",
            "#include \"uuid.h\"",
            "#include \"mrlock.h\"",
            "#include \"kmem.h\"",
            "#include \"xfs_types.h\"",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_message.h\"\n#include \"xfs_buf.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_super.h\"\n#include \"xfs_aops.h\"\n#include \"xfs_iops.h\"\n#include \"xfs_sysctl.h\"\n#include \"xfs_stats.h\"\n#include \"xfs_fs.h\"\n#include <asm/unaligned.h>\n#include <asm/byteorder.h>\n#include <asm/uaccess.h>\n#include <asm/param.h>\n#include <asm/div64.h>\n#include <asm/page.h>\n#include <linux/ratelimit.h>\n#include <linux/list_sort.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/capability.h>\n#include <linux/writeback.h>\n#include <linux/ctype.h>\n#include <linux/random.h>\n#include <linux/spinlock.h>\n#include <linux/log2.h>\n#include <linux/delay.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/sort.h>\n#include <linux/proc_fs.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/vfs.h>\n#include <linux/pagemap.h>\n#include <linux/major.h>\n#include <linux/bitops.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/swap.h>\n#include <linux/file.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/crc32c.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n#include <linux/mm.h>\n#include <linux/semaphore.h>\n#include \"uuid.h\"\n#include \"mrlock.h\"\n#include \"kmem.h\"\n#include \"xfs_types.h\"\n#include <linux/types.h>\n\nstatic inline __uint64_t roundup_64(__uint64_t x, __uint32_t y)\n{\n\tx += y - 1;\n\tdo_div(x, y);\n\treturn x * y;\n}"
        }
      },
      {
        "call_info": {
          "callee": "INOTIFY_E",
          "args": [
            "fsn_event"
          ],
          "line": 130
        },
        "resolved": true,
        "details": {
          "function_name": "INOTIFY_E",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/inotify/inotify.h",
          "lines": "18-21",
          "snippet": "static inline struct inotify_event_info *INOTIFY_E(struct fsnotify_event *fse)\n{\n\treturn container_of(fse, struct inotify_event_info, fse);\n}",
          "includes": [
            "#include <linux/slab.h> /* struct kmem_cache */",
            "#include <linux/inotify.h>",
            "#include <linux/fsnotify_backend.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h> /* struct kmem_cache */\n#include <linux/inotify.h>\n#include <linux/fsnotify_backend.h>\n\nstatic inline struct inotify_event_info *INOTIFY_E(struct fsnotify_event *fse)\n{\n\treturn container_of(fse, struct inotify_event_info, fse);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/sysctl.h>\n#include <asm/ioctls.h>\n#include \"../fdinfo.h\"\n#include \"inotify.h\"\n#include <linux/wait.h>\n#include <linux/poll.h>\n#include <linux/uaccess.h>\n#include <linux/anon_inodes.h>\n#include <linux/types.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h> /* struct kmem_cache */\n#include <linux/sched.h> /* struct user */\n#include <linux/namei.h> /* LOOKUP_FOLLOW */\n#include <linux/kernel.h> /* roundup() */\n#include <linux/inotify.h>\n#include <linux/init.h> /* module_init */\n#include <linux/idr.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/fs.h> /* struct inode */\n#include <linux/file.h>\n\nstatic int round_event_name_len(struct fsnotify_event *fsn_event)\n{\n\tstruct inotify_event_info *event;\n\n\tevent = INOTIFY_E(fsn_event);\n\tif (!event->name_len)\n\t\treturn 0;\n\treturn roundup(event->name_len + 1, sizeof(struct inotify_event));\n}"
  },
  {
    "function_name": "inotify_poll",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/inotify/inotify_user.c",
    "lines": "112-124",
    "snippet": "static unsigned int inotify_poll(struct file *file, poll_table *wait)\n{\n\tstruct fsnotify_group *group = file->private_data;\n\tint ret = 0;\n\n\tpoll_wait(file, &group->notification_waitq, wait);\n\tmutex_lock(&group->notification_mutex);\n\tif (!fsnotify_notify_queue_is_empty(group))\n\t\tret = POLLIN | POLLRDNORM;\n\tmutex_unlock(&group->notification_mutex);\n\n\treturn ret;\n}",
    "includes": [
      "#include <linux/sysctl.h>",
      "#include <asm/ioctls.h>",
      "#include \"../fdinfo.h\"",
      "#include \"inotify.h\"",
      "#include <linux/wait.h>",
      "#include <linux/poll.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/types.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h> /* struct kmem_cache */",
      "#include <linux/sched.h> /* struct user */",
      "#include <linux/namei.h> /* LOOKUP_FOLLOW */",
      "#include <linux/kernel.h> /* roundup() */",
      "#include <linux/inotify.h>",
      "#include <linux/init.h> /* module_init */",
      "#include <linux/idr.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/fs.h> /* struct inode */",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&group->notification_mutex"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fsnotify_notify_queue_is_empty",
          "args": [
            "group"
          ],
          "line": 119
        },
        "resolved": true,
        "details": {
          "function_name": "fsnotify_notify_queue_is_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/notification.c",
          "lines": "64-68",
          "snippet": "bool fsnotify_notify_queue_is_empty(struct fsnotify_group *group)\n{\n\tBUG_ON(!mutex_is_locked(&group->notification_mutex));\n\treturn list_empty(&group->notification_list) ? true : false;\n}",
          "includes": [
            "#include \"fsnotify.h\"",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/atomic.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/path.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mount.h>",
            "#include <linux/module.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fsnotify.h\"\n#include <linux/fsnotify_backend.h>\n#include <linux/atomic.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/path.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n\nbool fsnotify_notify_queue_is_empty(struct fsnotify_group *group)\n{\n\tBUG_ON(!mutex_is_locked(&group->notification_mutex));\n\treturn list_empty(&group->notification_list) ? true : false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&group->notification_mutex"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "poll_wait",
          "args": [
            "file",
            "&group->notification_waitq",
            "wait"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sysctl.h>\n#include <asm/ioctls.h>\n#include \"../fdinfo.h\"\n#include \"inotify.h\"\n#include <linux/wait.h>\n#include <linux/poll.h>\n#include <linux/uaccess.h>\n#include <linux/anon_inodes.h>\n#include <linux/types.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h> /* struct kmem_cache */\n#include <linux/sched.h> /* struct user */\n#include <linux/namei.h> /* LOOKUP_FOLLOW */\n#include <linux/kernel.h> /* roundup() */\n#include <linux/inotify.h>\n#include <linux/init.h> /* module_init */\n#include <linux/idr.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/fs.h> /* struct inode */\n#include <linux/file.h>\n\nstatic unsigned int inotify_poll(struct file *file, poll_table *wait)\n{\n\tstruct fsnotify_group *group = file->private_data;\n\tint ret = 0;\n\n\tpoll_wait(file, &group->notification_waitq, wait);\n\tmutex_lock(&group->notification_mutex);\n\tif (!fsnotify_notify_queue_is_empty(group))\n\t\tret = POLLIN | POLLRDNORM;\n\tmutex_unlock(&group->notification_mutex);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "inotify_mask_to_arg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/inotify/inotify_user.c",
    "lines": "105-109",
    "snippet": "static inline u32 inotify_mask_to_arg(__u32 mask)\n{\n\treturn mask & (IN_ALL_EVENTS | IN_ISDIR | IN_UNMOUNT | IN_IGNORED |\n\t\t       IN_Q_OVERFLOW);\n}",
    "includes": [
      "#include <linux/sysctl.h>",
      "#include <asm/ioctls.h>",
      "#include \"../fdinfo.h\"",
      "#include \"inotify.h\"",
      "#include <linux/wait.h>",
      "#include <linux/poll.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/types.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h> /* struct kmem_cache */",
      "#include <linux/sched.h> /* struct user */",
      "#include <linux/namei.h> /* LOOKUP_FOLLOW */",
      "#include <linux/kernel.h> /* roundup() */",
      "#include <linux/inotify.h>",
      "#include <linux/init.h> /* module_init */",
      "#include <linux/idr.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/fs.h> /* struct inode */",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/sysctl.h>\n#include <asm/ioctls.h>\n#include \"../fdinfo.h\"\n#include \"inotify.h\"\n#include <linux/wait.h>\n#include <linux/poll.h>\n#include <linux/uaccess.h>\n#include <linux/anon_inodes.h>\n#include <linux/types.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h> /* struct kmem_cache */\n#include <linux/sched.h> /* struct user */\n#include <linux/namei.h> /* LOOKUP_FOLLOW */\n#include <linux/kernel.h> /* roundup() */\n#include <linux/inotify.h>\n#include <linux/init.h> /* module_init */\n#include <linux/idr.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/fs.h> /* struct inode */\n#include <linux/file.h>\n\nstatic inline u32 inotify_mask_to_arg(__u32 mask)\n{\n\treturn mask & (IN_ALL_EVENTS | IN_ISDIR | IN_UNMOUNT | IN_IGNORED |\n\t\t       IN_Q_OVERFLOW);\n}"
  },
  {
    "function_name": "inotify_arg_to_mask",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/inotify/inotify_user.c",
    "lines": "89-103",
    "snippet": "static inline __u32 inotify_arg_to_mask(u32 arg)\n{\n\t__u32 mask;\n\n\t/*\n\t * everything should accept their own ignored, cares about children,\n\t * and should receive events when the inode is unmounted\n\t */\n\tmask = (FS_IN_IGNORED | FS_EVENT_ON_CHILD | FS_UNMOUNT);\n\n\t/* mask off the flags used to open the fd */\n\tmask |= (arg & (IN_ALL_EVENTS | IN_ONESHOT | IN_EXCL_UNLINK));\n\n\treturn mask;\n}",
    "includes": [
      "#include <linux/sysctl.h>",
      "#include <asm/ioctls.h>",
      "#include \"../fdinfo.h\"",
      "#include \"inotify.h\"",
      "#include <linux/wait.h>",
      "#include <linux/poll.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/types.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h> /* struct kmem_cache */",
      "#include <linux/sched.h> /* struct user */",
      "#include <linux/namei.h> /* LOOKUP_FOLLOW */",
      "#include <linux/kernel.h> /* roundup() */",
      "#include <linux/inotify.h>",
      "#include <linux/init.h> /* module_init */",
      "#include <linux/idr.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/fs.h> /* struct inode */",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/sysctl.h>\n#include <asm/ioctls.h>\n#include \"../fdinfo.h\"\n#include \"inotify.h\"\n#include <linux/wait.h>\n#include <linux/poll.h>\n#include <linux/uaccess.h>\n#include <linux/anon_inodes.h>\n#include <linux/types.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h> /* struct kmem_cache */\n#include <linux/sched.h> /* struct user */\n#include <linux/namei.h> /* LOOKUP_FOLLOW */\n#include <linux/kernel.h> /* roundup() */\n#include <linux/inotify.h>\n#include <linux/init.h> /* module_init */\n#include <linux/idr.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/fs.h> /* struct inode */\n#include <linux/file.h>\n\nstatic inline __u32 inotify_arg_to_mask(u32 arg)\n{\n\t__u32 mask;\n\n\t/*\n\t * everything should accept their own ignored, cares about children,\n\t * and should receive events when the inode is unmounted\n\t */\n\tmask = (FS_IN_IGNORED | FS_EVENT_ON_CHILD | FS_UNMOUNT);\n\n\t/* mask off the flags used to open the fd */\n\tmask |= (arg & (IN_ALL_EVENTS | IN_ONESHOT | IN_EXCL_UNLINK));\n\n\treturn mask;\n}"
  }
]