[
  {
    "function_name": "bfs_find_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/bfs/dir.c",
    "lines": "329-365",
    "snippet": "static struct buffer_head *bfs_find_entry(struct inode *dir,\n\t\t\tconst unsigned char *name, int namelen,\n\t\t\tstruct bfs_dirent **res_dir)\n{\n\tunsigned long block = 0, offset = 0;\n\tstruct buffer_head *bh = NULL;\n\tstruct bfs_dirent *de;\n\n\t*res_dir = NULL;\n\tif (namelen > BFS_NAMELEN)\n\t\treturn NULL;\n\n\twhile (block * BFS_BSIZE + offset < dir->i_size) {\n\t\tif (!bh) {\n\t\t\tbh = sb_bread(dir->i_sb, BFS_I(dir)->i_sblock + block);\n\t\t\tif (!bh) {\n\t\t\t\tblock++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tde = (struct bfs_dirent *)(bh->b_data + offset);\n\t\toffset += BFS_DIRENT_SIZE;\n\t\tif (le16_to_cpu(de->ino) &&\n\t\t\t\tbfs_namecmp(namelen, name, de->name)) {\n\t\t\t*res_dir = de;\n\t\t\treturn bh;\n\t\t}\n\t\tif (offset < bh->b_size)\n\t\t\tcontinue;\n\t\tbrelse(bh);\n\t\tbh = NULL;\n\t\toffset = 0;\n\t\tblock++;\n\t}\n\tbrelse(bh);\n\treturn NULL;\n}",
    "includes": [
      "#include \"bfs.h\"",
      "#include <linux/sched.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int bfs_add_entry(struct inode *dir, const unsigned char *name,\n\t\t\t\t\t\tint namelen, int ino);",
      "static struct buffer_head *bfs_find_entry(struct inode *dir,\n\t\t\t\tconst unsigned char *name, int namelen,\n\t\t\t\tstruct bfs_dirent **res_dir);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 363
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "bfs_namecmp",
          "args": [
            "namelen",
            "name",
            "de->name"
          ],
          "line": 352
        },
        "resolved": true,
        "details": {
          "function_name": "bfs_namecmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/bfs/dir.c",
          "lines": "321-327",
          "snippet": "static inline int bfs_namecmp(int len, const unsigned char *name,\n\t\t\t\t\t\t\tconst char *buffer)\n{\n\tif ((len < BFS_NAMELEN) && buffer[len])\n\t\treturn 0;\n\treturn !memcmp(name, buffer, len);\n}",
          "includes": [
            "#include \"bfs.h\"",
            "#include <linux/sched.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bfs.h\"\n#include <linux/sched.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/time.h>\n\nstatic inline int bfs_namecmp(int len, const unsigned char *name,\n\t\t\t\t\t\t\tconst char *buffer)\n{\n\tif ((len < BFS_NAMELEN) && buffer[len])\n\t\treturn 0;\n\treturn !memcmp(name, buffer, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "de->ino"
          ],
          "line": 351
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sb_bread",
          "args": [
            "dir->i_sb",
            "BFS_I(dir)->i_sblock + block"
          ],
          "line": 343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BFS_I",
          "args": [
            "dir"
          ],
          "line": 343
        },
        "resolved": true,
        "details": {
          "function_name": "BFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/bfs/bfs.h",
          "lines": "38-41",
          "snippet": "static inline struct bfs_inode_info *BFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct bfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <linux/bfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bfs_fs.h>\n\nstatic inline struct bfs_inode_info *BFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct bfs_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"bfs.h\"\n#include <linux/sched.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/time.h>\n\nstatic int bfs_add_entry(struct inode *dir, const unsigned char *name,\n\t\t\t\t\t\tint namelen, int ino);\nstatic struct buffer_head *bfs_find_entry(struct inode *dir,\n\t\t\t\tconst unsigned char *name, int namelen,\n\t\t\t\tstruct bfs_dirent **res_dir);\n\nstatic struct buffer_head *bfs_find_entry(struct inode *dir,\n\t\t\tconst unsigned char *name, int namelen,\n\t\t\tstruct bfs_dirent **res_dir)\n{\n\tunsigned long block = 0, offset = 0;\n\tstruct buffer_head *bh = NULL;\n\tstruct bfs_dirent *de;\n\n\t*res_dir = NULL;\n\tif (namelen > BFS_NAMELEN)\n\t\treturn NULL;\n\n\twhile (block * BFS_BSIZE + offset < dir->i_size) {\n\t\tif (!bh) {\n\t\t\tbh = sb_bread(dir->i_sb, BFS_I(dir)->i_sblock + block);\n\t\t\tif (!bh) {\n\t\t\t\tblock++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tde = (struct bfs_dirent *)(bh->b_data + offset);\n\t\toffset += BFS_DIRENT_SIZE;\n\t\tif (le16_to_cpu(de->ino) &&\n\t\t\t\tbfs_namecmp(namelen, name, de->name)) {\n\t\t\t*res_dir = de;\n\t\t\treturn bh;\n\t\t}\n\t\tif (offset < bh->b_size)\n\t\t\tcontinue;\n\t\tbrelse(bh);\n\t\tbh = NULL;\n\t\toffset = 0;\n\t\tblock++;\n\t}\n\tbrelse(bh);\n\treturn NULL;\n}"
  },
  {
    "function_name": "bfs_namecmp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/bfs/dir.c",
    "lines": "321-327",
    "snippet": "static inline int bfs_namecmp(int len, const unsigned char *name,\n\t\t\t\t\t\t\tconst char *buffer)\n{\n\tif ((len < BFS_NAMELEN) && buffer[len])\n\t\treturn 0;\n\treturn !memcmp(name, buffer, len);\n}",
    "includes": [
      "#include \"bfs.h\"",
      "#include <linux/sched.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "name",
            "buffer",
            "len"
          ],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"bfs.h\"\n#include <linux/sched.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/time.h>\n\nstatic inline int bfs_namecmp(int len, const unsigned char *name,\n\t\t\t\t\t\t\tconst char *buffer)\n{\n\tif ((len < BFS_NAMELEN) && buffer[len])\n\t\treturn 0;\n\treturn !memcmp(name, buffer, len);\n}"
  },
  {
    "function_name": "bfs_add_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/bfs/dir.c",
    "lines": "276-319",
    "snippet": "static int bfs_add_entry(struct inode *dir, const unsigned char *name,\n\t\t\t\t\t\t\tint namelen, int ino)\n{\n\tstruct buffer_head *bh;\n\tstruct bfs_dirent *de;\n\tint block, sblock, eblock, off, pos;\n\tint i;\n\n\tdprintf(\"name=%s, namelen=%d\\n\", name, namelen);\n\n\tif (!namelen)\n\t\treturn -ENOENT;\n\tif (namelen > BFS_NAMELEN)\n\t\treturn -ENAMETOOLONG;\n\n\tsblock = BFS_I(dir)->i_sblock;\n\teblock = BFS_I(dir)->i_eblock;\n\tfor (block = sblock; block <= eblock; block++) {\n\t\tbh = sb_bread(dir->i_sb, block);\n\t\tif (!bh)\n\t\t\treturn -ENOSPC;\n\t\tfor (off = 0; off < BFS_BSIZE; off += BFS_DIRENT_SIZE) {\n\t\t\tde = (struct bfs_dirent *)(bh->b_data + off);\n\t\t\tif (!de->ino) {\n\t\t\t\tpos = (block - sblock) * BFS_BSIZE + off;\n\t\t\t\tif (pos >= dir->i_size) {\n\t\t\t\t\tdir->i_size += BFS_DIRENT_SIZE;\n\t\t\t\t\tdir->i_ctime = CURRENT_TIME_SEC;\n\t\t\t\t}\n\t\t\t\tdir->i_mtime = CURRENT_TIME_SEC;\n\t\t\t\tmark_inode_dirty(dir);\n\t\t\t\tde->ino = cpu_to_le16((u16)ino);\n\t\t\t\tfor (i = 0; i < BFS_NAMELEN; i++)\n\t\t\t\t\tde->name[i] =\n\t\t\t\t\t\t(i < namelen) ? name[i] : 0;\n\t\t\t\tmark_buffer_dirty_inode(bh, dir);\n\t\t\t\tbrelse(bh);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\tbrelse(bh);\n\t}\n\treturn -ENOSPC;\n}",
    "includes": [
      "#include \"bfs.h\"",
      "#include <linux/sched.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int bfs_add_entry(struct inode *dir, const unsigned char *name,\n\t\t\t\t\t\tint namelen, int ino);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 316
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_buffer_dirty_inode",
          "args": [
            "bh",
            "dir"
          ],
          "line": 311
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_dirty_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "599-617",
          "snippet": "void mark_buffer_dirty_inode(struct buffer_head *bh, struct inode *inode)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tstruct address_space *buffer_mapping = bh->b_page->mapping;\n\n\tmark_buffer_dirty(bh);\n\tif (!mapping->private_data) {\n\t\tmapping->private_data = buffer_mapping;\n\t} else {\n\t\tBUG_ON(mapping->private_data != buffer_mapping);\n\t}\n\tif (!bh->b_assoc_map) {\n\t\tspin_lock(&buffer_mapping->private_lock);\n\t\tlist_move_tail(&bh->b_assoc_buffers,\n\t\t\t\t&mapping->private_list);\n\t\tbh->b_assoc_map = mapping;\n\t\tspin_unlock(&buffer_mapping->private_lock);\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_dirty_inode(struct buffer_head *bh, struct inode *inode)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tstruct address_space *buffer_mapping = bh->b_page->mapping;\n\n\tmark_buffer_dirty(bh);\n\tif (!mapping->private_data) {\n\t\tmapping->private_data = buffer_mapping;\n\t} else {\n\t\tBUG_ON(mapping->private_data != buffer_mapping);\n\t}\n\tif (!bh->b_assoc_map) {\n\t\tspin_lock(&buffer_mapping->private_lock);\n\t\tlist_move_tail(&bh->b_assoc_buffers,\n\t\t\t\t&mapping->private_list);\n\t\tbh->b_assoc_map = mapping;\n\t\tspin_unlock(&buffer_mapping->private_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "(u16)ino"
          ],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mark_inode_dirty",
          "args": [
            "dir"
          ],
          "line": 306
        },
        "resolved": true,
        "details": {
          "function_name": "block_dump___mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1134-1154",
          "snippet": "static noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sb_bread",
          "args": [
            "dir->i_sb",
            "block"
          ],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BFS_I",
          "args": [
            "dir"
          ],
          "line": 292
        },
        "resolved": true,
        "details": {
          "function_name": "BFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/bfs/bfs.h",
          "lines": "38-41",
          "snippet": "static inline struct bfs_inode_info *BFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct bfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <linux/bfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bfs_fs.h>\n\nstatic inline struct bfs_inode_info *BFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct bfs_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintf",
          "args": [
            "\"name=%s, namelen=%d\\n\"",
            "name",
            "namelen"
          ],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"bfs.h\"\n#include <linux/sched.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/time.h>\n\nstatic int bfs_add_entry(struct inode *dir, const unsigned char *name,\n\t\t\t\t\t\tint namelen, int ino);\n\nstatic int bfs_add_entry(struct inode *dir, const unsigned char *name,\n\t\t\t\t\t\t\tint namelen, int ino)\n{\n\tstruct buffer_head *bh;\n\tstruct bfs_dirent *de;\n\tint block, sblock, eblock, off, pos;\n\tint i;\n\n\tdprintf(\"name=%s, namelen=%d\\n\", name, namelen);\n\n\tif (!namelen)\n\t\treturn -ENOENT;\n\tif (namelen > BFS_NAMELEN)\n\t\treturn -ENAMETOOLONG;\n\n\tsblock = BFS_I(dir)->i_sblock;\n\teblock = BFS_I(dir)->i_eblock;\n\tfor (block = sblock; block <= eblock; block++) {\n\t\tbh = sb_bread(dir->i_sb, block);\n\t\tif (!bh)\n\t\t\treturn -ENOSPC;\n\t\tfor (off = 0; off < BFS_BSIZE; off += BFS_DIRENT_SIZE) {\n\t\t\tde = (struct bfs_dirent *)(bh->b_data + off);\n\t\t\tif (!de->ino) {\n\t\t\t\tpos = (block - sblock) * BFS_BSIZE + off;\n\t\t\t\tif (pos >= dir->i_size) {\n\t\t\t\t\tdir->i_size += BFS_DIRENT_SIZE;\n\t\t\t\t\tdir->i_ctime = CURRENT_TIME_SEC;\n\t\t\t\t}\n\t\t\t\tdir->i_mtime = CURRENT_TIME_SEC;\n\t\t\t\tmark_inode_dirty(dir);\n\t\t\t\tde->ino = cpu_to_le16((u16)ino);\n\t\t\t\tfor (i = 0; i < BFS_NAMELEN; i++)\n\t\t\t\t\tde->name[i] =\n\t\t\t\t\t\t(i < namelen) ? name[i] : 0;\n\t\t\t\tmark_buffer_dirty_inode(bh, dir);\n\t\t\t\tbrelse(bh);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\tbrelse(bh);\n\t}\n\treturn -ENOSPC;\n}"
  },
  {
    "function_name": "bfs_rename",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/bfs/dir.c",
    "lines": "209-266",
    "snippet": "static int bfs_rename(struct inode *old_dir, struct dentry *old_dentry,\n\t\t\tstruct inode *new_dir, struct dentry *new_dentry)\n{\n\tstruct inode *old_inode, *new_inode;\n\tstruct buffer_head *old_bh, *new_bh;\n\tstruct bfs_dirent *old_de, *new_de;\n\tstruct bfs_sb_info *info;\n\tint error = -ENOENT;\n\n\told_bh = new_bh = NULL;\n\told_inode = old_dentry->d_inode;\n\tif (S_ISDIR(old_inode->i_mode))\n\t\treturn -EINVAL;\n\n\tinfo = BFS_SB(old_inode->i_sb);\n\n\tmutex_lock(&info->bfs_lock);\n\told_bh = bfs_find_entry(old_dir, \n\t\t\t\told_dentry->d_name.name, \n\t\t\t\told_dentry->d_name.len, &old_de);\n\n\tif (!old_bh || (le16_to_cpu(old_de->ino) != old_inode->i_ino))\n\t\tgoto end_rename;\n\n\terror = -EPERM;\n\tnew_inode = new_dentry->d_inode;\n\tnew_bh = bfs_find_entry(new_dir, \n\t\t\t\tnew_dentry->d_name.name, \n\t\t\t\tnew_dentry->d_name.len, &new_de);\n\n\tif (new_bh && !new_inode) {\n\t\tbrelse(new_bh);\n\t\tnew_bh = NULL;\n\t}\n\tif (!new_bh) {\n\t\terror = bfs_add_entry(new_dir, \n\t\t\t\t\tnew_dentry->d_name.name,\n\t\t\t\t\tnew_dentry->d_name.len,\n\t\t\t\t\told_inode->i_ino);\n\t\tif (error)\n\t\t\tgoto end_rename;\n\t}\n\told_de->ino = 0;\n\told_dir->i_ctime = old_dir->i_mtime = CURRENT_TIME_SEC;\n\tmark_inode_dirty(old_dir);\n\tif (new_inode) {\n\t\tnew_inode->i_ctime = CURRENT_TIME_SEC;\n\t\tinode_dec_link_count(new_inode);\n\t}\n\tmark_buffer_dirty_inode(old_bh, old_dir);\n\terror = 0;\n\nend_rename:\n\tmutex_unlock(&info->bfs_lock);\n\tbrelse(old_bh);\n\tbrelse(new_bh);\n\treturn error;\n}",
    "includes": [
      "#include \"bfs.h\"",
      "#include <linux/sched.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int bfs_add_entry(struct inode *dir, const unsigned char *name,\n\t\t\t\t\t\tint namelen, int ino);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "new_bh"
          ],
          "line": 264
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&info->bfs_lock"
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mark_buffer_dirty_inode",
          "args": [
            "old_bh",
            "old_dir"
          ],
          "line": 258
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_dirty_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "599-617",
          "snippet": "void mark_buffer_dirty_inode(struct buffer_head *bh, struct inode *inode)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tstruct address_space *buffer_mapping = bh->b_page->mapping;\n\n\tmark_buffer_dirty(bh);\n\tif (!mapping->private_data) {\n\t\tmapping->private_data = buffer_mapping;\n\t} else {\n\t\tBUG_ON(mapping->private_data != buffer_mapping);\n\t}\n\tif (!bh->b_assoc_map) {\n\t\tspin_lock(&buffer_mapping->private_lock);\n\t\tlist_move_tail(&bh->b_assoc_buffers,\n\t\t\t\t&mapping->private_list);\n\t\tbh->b_assoc_map = mapping;\n\t\tspin_unlock(&buffer_mapping->private_lock);\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_dirty_inode(struct buffer_head *bh, struct inode *inode)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tstruct address_space *buffer_mapping = bh->b_page->mapping;\n\n\tmark_buffer_dirty(bh);\n\tif (!mapping->private_data) {\n\t\tmapping->private_data = buffer_mapping;\n\t} else {\n\t\tBUG_ON(mapping->private_data != buffer_mapping);\n\t}\n\tif (!bh->b_assoc_map) {\n\t\tspin_lock(&buffer_mapping->private_lock);\n\t\tlist_move_tail(&bh->b_assoc_buffers,\n\t\t\t\t&mapping->private_list);\n\t\tbh->b_assoc_map = mapping;\n\t\tspin_unlock(&buffer_mapping->private_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_dec_link_count",
          "args": [
            "new_inode"
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mark_inode_dirty",
          "args": [
            "old_dir"
          ],
          "line": 253
        },
        "resolved": true,
        "details": {
          "function_name": "block_dump___mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1134-1154",
          "snippet": "static noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "bfs_add_entry",
          "args": [
            "new_dir",
            "new_dentry->d_name.name",
            "new_dentry->d_name.len",
            "old_inode->i_ino"
          ],
          "line": 244
        },
        "resolved": true,
        "details": {
          "function_name": "bfs_add_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/bfs/dir.c",
          "lines": "276-319",
          "snippet": "static int bfs_add_entry(struct inode *dir, const unsigned char *name,\n\t\t\t\t\t\t\tint namelen, int ino)\n{\n\tstruct buffer_head *bh;\n\tstruct bfs_dirent *de;\n\tint block, sblock, eblock, off, pos;\n\tint i;\n\n\tdprintf(\"name=%s, namelen=%d\\n\", name, namelen);\n\n\tif (!namelen)\n\t\treturn -ENOENT;\n\tif (namelen > BFS_NAMELEN)\n\t\treturn -ENAMETOOLONG;\n\n\tsblock = BFS_I(dir)->i_sblock;\n\teblock = BFS_I(dir)->i_eblock;\n\tfor (block = sblock; block <= eblock; block++) {\n\t\tbh = sb_bread(dir->i_sb, block);\n\t\tif (!bh)\n\t\t\treturn -ENOSPC;\n\t\tfor (off = 0; off < BFS_BSIZE; off += BFS_DIRENT_SIZE) {\n\t\t\tde = (struct bfs_dirent *)(bh->b_data + off);\n\t\t\tif (!de->ino) {\n\t\t\t\tpos = (block - sblock) * BFS_BSIZE + off;\n\t\t\t\tif (pos >= dir->i_size) {\n\t\t\t\t\tdir->i_size += BFS_DIRENT_SIZE;\n\t\t\t\t\tdir->i_ctime = CURRENT_TIME_SEC;\n\t\t\t\t}\n\t\t\t\tdir->i_mtime = CURRENT_TIME_SEC;\n\t\t\t\tmark_inode_dirty(dir);\n\t\t\t\tde->ino = cpu_to_le16((u16)ino);\n\t\t\t\tfor (i = 0; i < BFS_NAMELEN; i++)\n\t\t\t\t\tde->name[i] =\n\t\t\t\t\t\t(i < namelen) ? name[i] : 0;\n\t\t\t\tmark_buffer_dirty_inode(bh, dir);\n\t\t\t\tbrelse(bh);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\tbrelse(bh);\n\t}\n\treturn -ENOSPC;\n}",
          "includes": [
            "#include \"bfs.h\"",
            "#include <linux/sched.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int bfs_add_entry(struct inode *dir, const unsigned char *name,\n\t\t\t\t\t\tint namelen, int ino);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"bfs.h\"\n#include <linux/sched.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/time.h>\n\nstatic int bfs_add_entry(struct inode *dir, const unsigned char *name,\n\t\t\t\t\t\tint namelen, int ino);\n\nstatic int bfs_add_entry(struct inode *dir, const unsigned char *name,\n\t\t\t\t\t\t\tint namelen, int ino)\n{\n\tstruct buffer_head *bh;\n\tstruct bfs_dirent *de;\n\tint block, sblock, eblock, off, pos;\n\tint i;\n\n\tdprintf(\"name=%s, namelen=%d\\n\", name, namelen);\n\n\tif (!namelen)\n\t\treturn -ENOENT;\n\tif (namelen > BFS_NAMELEN)\n\t\treturn -ENAMETOOLONG;\n\n\tsblock = BFS_I(dir)->i_sblock;\n\teblock = BFS_I(dir)->i_eblock;\n\tfor (block = sblock; block <= eblock; block++) {\n\t\tbh = sb_bread(dir->i_sb, block);\n\t\tif (!bh)\n\t\t\treturn -ENOSPC;\n\t\tfor (off = 0; off < BFS_BSIZE; off += BFS_DIRENT_SIZE) {\n\t\t\tde = (struct bfs_dirent *)(bh->b_data + off);\n\t\t\tif (!de->ino) {\n\t\t\t\tpos = (block - sblock) * BFS_BSIZE + off;\n\t\t\t\tif (pos >= dir->i_size) {\n\t\t\t\t\tdir->i_size += BFS_DIRENT_SIZE;\n\t\t\t\t\tdir->i_ctime = CURRENT_TIME_SEC;\n\t\t\t\t}\n\t\t\t\tdir->i_mtime = CURRENT_TIME_SEC;\n\t\t\t\tmark_inode_dirty(dir);\n\t\t\t\tde->ino = cpu_to_le16((u16)ino);\n\t\t\t\tfor (i = 0; i < BFS_NAMELEN; i++)\n\t\t\t\t\tde->name[i] =\n\t\t\t\t\t\t(i < namelen) ? name[i] : 0;\n\t\t\t\tmark_buffer_dirty_inode(bh, dir);\n\t\t\t\tbrelse(bh);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\tbrelse(bh);\n\t}\n\treturn -ENOSPC;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bfs_find_entry",
          "args": [
            "new_dir",
            "new_dentry->d_name.name",
            "new_dentry->d_name.len",
            "&new_de"
          ],
          "line": 235
        },
        "resolved": true,
        "details": {
          "function_name": "bfs_find_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/bfs/dir.c",
          "lines": "329-365",
          "snippet": "static struct buffer_head *bfs_find_entry(struct inode *dir,\n\t\t\tconst unsigned char *name, int namelen,\n\t\t\tstruct bfs_dirent **res_dir)\n{\n\tunsigned long block = 0, offset = 0;\n\tstruct buffer_head *bh = NULL;\n\tstruct bfs_dirent *de;\n\n\t*res_dir = NULL;\n\tif (namelen > BFS_NAMELEN)\n\t\treturn NULL;\n\n\twhile (block * BFS_BSIZE + offset < dir->i_size) {\n\t\tif (!bh) {\n\t\t\tbh = sb_bread(dir->i_sb, BFS_I(dir)->i_sblock + block);\n\t\t\tif (!bh) {\n\t\t\t\tblock++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tde = (struct bfs_dirent *)(bh->b_data + offset);\n\t\toffset += BFS_DIRENT_SIZE;\n\t\tif (le16_to_cpu(de->ino) &&\n\t\t\t\tbfs_namecmp(namelen, name, de->name)) {\n\t\t\t*res_dir = de;\n\t\t\treturn bh;\n\t\t}\n\t\tif (offset < bh->b_size)\n\t\t\tcontinue;\n\t\tbrelse(bh);\n\t\tbh = NULL;\n\t\toffset = 0;\n\t\tblock++;\n\t}\n\tbrelse(bh);\n\treturn NULL;\n}",
          "includes": [
            "#include \"bfs.h\"",
            "#include <linux/sched.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int bfs_add_entry(struct inode *dir, const unsigned char *name,\n\t\t\t\t\t\tint namelen, int ino);",
            "static struct buffer_head *bfs_find_entry(struct inode *dir,\n\t\t\t\tconst unsigned char *name, int namelen,\n\t\t\t\tstruct bfs_dirent **res_dir);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"bfs.h\"\n#include <linux/sched.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/time.h>\n\nstatic int bfs_add_entry(struct inode *dir, const unsigned char *name,\n\t\t\t\t\t\tint namelen, int ino);\nstatic struct buffer_head *bfs_find_entry(struct inode *dir,\n\t\t\t\tconst unsigned char *name, int namelen,\n\t\t\t\tstruct bfs_dirent **res_dir);\n\nstatic struct buffer_head *bfs_find_entry(struct inode *dir,\n\t\t\tconst unsigned char *name, int namelen,\n\t\t\tstruct bfs_dirent **res_dir)\n{\n\tunsigned long block = 0, offset = 0;\n\tstruct buffer_head *bh = NULL;\n\tstruct bfs_dirent *de;\n\n\t*res_dir = NULL;\n\tif (namelen > BFS_NAMELEN)\n\t\treturn NULL;\n\n\twhile (block * BFS_BSIZE + offset < dir->i_size) {\n\t\tif (!bh) {\n\t\t\tbh = sb_bread(dir->i_sb, BFS_I(dir)->i_sblock + block);\n\t\t\tif (!bh) {\n\t\t\t\tblock++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tde = (struct bfs_dirent *)(bh->b_data + offset);\n\t\toffset += BFS_DIRENT_SIZE;\n\t\tif (le16_to_cpu(de->ino) &&\n\t\t\t\tbfs_namecmp(namelen, name, de->name)) {\n\t\t\t*res_dir = de;\n\t\t\treturn bh;\n\t\t}\n\t\tif (offset < bh->b_size)\n\t\t\tcontinue;\n\t\tbrelse(bh);\n\t\tbh = NULL;\n\t\toffset = 0;\n\t\tblock++;\n\t}\n\tbrelse(bh);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "old_de->ino"
          ],
          "line": 230
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&info->bfs_lock"
          ],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BFS_SB",
          "args": [
            "old_inode->i_sb"
          ],
          "line": 223
        },
        "resolved": true,
        "details": {
          "function_name": "BFS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/bfs/bfs.h",
          "lines": "33-36",
          "snippet": "static inline struct bfs_sb_info *BFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/bfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bfs_fs.h>\n\nstatic inline struct bfs_sb_info *BFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "old_inode->i_mode"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"bfs.h\"\n#include <linux/sched.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/time.h>\n\nstatic int bfs_add_entry(struct inode *dir, const unsigned char *name,\n\t\t\t\t\t\tint namelen, int ino);\n\nstatic int bfs_rename(struct inode *old_dir, struct dentry *old_dentry,\n\t\t\tstruct inode *new_dir, struct dentry *new_dentry)\n{\n\tstruct inode *old_inode, *new_inode;\n\tstruct buffer_head *old_bh, *new_bh;\n\tstruct bfs_dirent *old_de, *new_de;\n\tstruct bfs_sb_info *info;\n\tint error = -ENOENT;\n\n\told_bh = new_bh = NULL;\n\told_inode = old_dentry->d_inode;\n\tif (S_ISDIR(old_inode->i_mode))\n\t\treturn -EINVAL;\n\n\tinfo = BFS_SB(old_inode->i_sb);\n\n\tmutex_lock(&info->bfs_lock);\n\told_bh = bfs_find_entry(old_dir, \n\t\t\t\told_dentry->d_name.name, \n\t\t\t\told_dentry->d_name.len, &old_de);\n\n\tif (!old_bh || (le16_to_cpu(old_de->ino) != old_inode->i_ino))\n\t\tgoto end_rename;\n\n\terror = -EPERM;\n\tnew_inode = new_dentry->d_inode;\n\tnew_bh = bfs_find_entry(new_dir, \n\t\t\t\tnew_dentry->d_name.name, \n\t\t\t\tnew_dentry->d_name.len, &new_de);\n\n\tif (new_bh && !new_inode) {\n\t\tbrelse(new_bh);\n\t\tnew_bh = NULL;\n\t}\n\tif (!new_bh) {\n\t\terror = bfs_add_entry(new_dir, \n\t\t\t\t\tnew_dentry->d_name.name,\n\t\t\t\t\tnew_dentry->d_name.len,\n\t\t\t\t\told_inode->i_ino);\n\t\tif (error)\n\t\t\tgoto end_rename;\n\t}\n\told_de->ino = 0;\n\told_dir->i_ctime = old_dir->i_mtime = CURRENT_TIME_SEC;\n\tmark_inode_dirty(old_dir);\n\tif (new_inode) {\n\t\tnew_inode->i_ctime = CURRENT_TIME_SEC;\n\t\tinode_dec_link_count(new_inode);\n\t}\n\tmark_buffer_dirty_inode(old_bh, old_dir);\n\terror = 0;\n\nend_rename:\n\tmutex_unlock(&info->bfs_lock);\n\tbrelse(old_bh);\n\tbrelse(new_bh);\n\treturn error;\n}"
  },
  {
    "function_name": "bfs_unlink",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/bfs/dir.c",
    "lines": "176-207",
    "snippet": "static int bfs_unlink(struct inode *dir, struct dentry *dentry)\n{\n\tint error = -ENOENT;\n\tstruct inode *inode = dentry->d_inode;\n\tstruct buffer_head *bh;\n\tstruct bfs_dirent *de;\n\tstruct bfs_sb_info *info = BFS_SB(inode->i_sb);\n\n\tmutex_lock(&info->bfs_lock);\n\tbh = bfs_find_entry(dir, dentry->d_name.name, dentry->d_name.len, &de);\n\tif (!bh || (le16_to_cpu(de->ino) != inode->i_ino))\n\t\tgoto out_brelse;\n\n\tif (!inode->i_nlink) {\n\t\tprintf(\"unlinking non-existent file %s:%lu (nlink=%d)\\n\",\n\t\t\t\t\tinode->i_sb->s_id, inode->i_ino,\n\t\t\t\t\tinode->i_nlink);\n\t\tset_nlink(inode, 1);\n\t}\n\tde->ino = 0;\n\tmark_buffer_dirty_inode(bh, dir);\n\tdir->i_ctime = dir->i_mtime = CURRENT_TIME_SEC;\n\tmark_inode_dirty(dir);\n\tinode->i_ctime = dir->i_ctime;\n\tinode_dec_link_count(inode);\n\terror = 0;\n\nout_brelse:\n\tbrelse(bh);\n\tmutex_unlock(&info->bfs_lock);\n\treturn error;\n}",
    "includes": [
      "#include \"bfs.h\"",
      "#include <linux/sched.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int bfs_add_entry(struct inode *dir, const unsigned char *name,\n\t\t\t\t\t\tint namelen, int ino);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&info->bfs_lock"
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 204
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_dec_link_count",
          "args": [
            "inode"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mark_inode_dirty",
          "args": [
            "dir"
          ],
          "line": 198
        },
        "resolved": true,
        "details": {
          "function_name": "block_dump___mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1134-1154",
          "snippet": "static noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_buffer_dirty_inode",
          "args": [
            "bh",
            "dir"
          ],
          "line": 196
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_dirty_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "599-617",
          "snippet": "void mark_buffer_dirty_inode(struct buffer_head *bh, struct inode *inode)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tstruct address_space *buffer_mapping = bh->b_page->mapping;\n\n\tmark_buffer_dirty(bh);\n\tif (!mapping->private_data) {\n\t\tmapping->private_data = buffer_mapping;\n\t} else {\n\t\tBUG_ON(mapping->private_data != buffer_mapping);\n\t}\n\tif (!bh->b_assoc_map) {\n\t\tspin_lock(&buffer_mapping->private_lock);\n\t\tlist_move_tail(&bh->b_assoc_buffers,\n\t\t\t\t&mapping->private_list);\n\t\tbh->b_assoc_map = mapping;\n\t\tspin_unlock(&buffer_mapping->private_lock);\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_dirty_inode(struct buffer_head *bh, struct inode *inode)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tstruct address_space *buffer_mapping = bh->b_page->mapping;\n\n\tmark_buffer_dirty(bh);\n\tif (!mapping->private_data) {\n\t\tmapping->private_data = buffer_mapping;\n\t} else {\n\t\tBUG_ON(mapping->private_data != buffer_mapping);\n\t}\n\tif (!bh->b_assoc_map) {\n\t\tspin_lock(&buffer_mapping->private_lock);\n\t\tlist_move_tail(&bh->b_assoc_buffers,\n\t\t\t\t&mapping->private_list);\n\t\tbh->b_assoc_map = mapping;\n\t\tspin_unlock(&buffer_mapping->private_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_nlink",
          "args": [
            "inode",
            "1"
          ],
          "line": 193
        },
        "resolved": true,
        "details": {
          "function_name": "set_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "305-316",
          "snippet": "void set_nlink(struct inode *inode, unsigned int nlink)\n{\n\tif (!nlink) {\n\t\tclear_nlink(inode);\n\t} else {\n\t\t/* Yes, some filesystems do change nlink from zero to one */\n\t\tif (inode->i_nlink == 0)\n\t\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\n\t\tinode->__i_nlink = nlink;\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid set_nlink(struct inode *inode, unsigned int nlink)\n{\n\tif (!nlink) {\n\t\tclear_nlink(inode);\n\t} else {\n\t\t/* Yes, some filesystems do change nlink from zero to one */\n\t\tif (inode->i_nlink == 0)\n\t\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\n\t\tinode->__i_nlink = nlink;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"unlinking non-existent file %s:%lu (nlink=%d)\\n\"",
            "inode->i_sb->s_id",
            "inode->i_ino",
            "inode->i_nlink"
          ],
          "line": 190
        },
        "resolved": true,
        "details": {
          "function_name": "seq_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "416-426",
          "snippet": "int seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tint ret;\n\tva_list args;\n\n\tva_start(args, f);\n\tret = seq_vprintf(m, f, args);\n\tva_end(args);\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tint ret;\n\tva_list args;\n\n\tva_start(args, f);\n\tret = seq_vprintf(m, f, args);\n\tva_end(args);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "de->ino"
          ],
          "line": 186
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bfs_find_entry",
          "args": [
            "dir",
            "dentry->d_name.name",
            "dentry->d_name.len",
            "&de"
          ],
          "line": 185
        },
        "resolved": true,
        "details": {
          "function_name": "bfs_find_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/bfs/dir.c",
          "lines": "329-365",
          "snippet": "static struct buffer_head *bfs_find_entry(struct inode *dir,\n\t\t\tconst unsigned char *name, int namelen,\n\t\t\tstruct bfs_dirent **res_dir)\n{\n\tunsigned long block = 0, offset = 0;\n\tstruct buffer_head *bh = NULL;\n\tstruct bfs_dirent *de;\n\n\t*res_dir = NULL;\n\tif (namelen > BFS_NAMELEN)\n\t\treturn NULL;\n\n\twhile (block * BFS_BSIZE + offset < dir->i_size) {\n\t\tif (!bh) {\n\t\t\tbh = sb_bread(dir->i_sb, BFS_I(dir)->i_sblock + block);\n\t\t\tif (!bh) {\n\t\t\t\tblock++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tde = (struct bfs_dirent *)(bh->b_data + offset);\n\t\toffset += BFS_DIRENT_SIZE;\n\t\tif (le16_to_cpu(de->ino) &&\n\t\t\t\tbfs_namecmp(namelen, name, de->name)) {\n\t\t\t*res_dir = de;\n\t\t\treturn bh;\n\t\t}\n\t\tif (offset < bh->b_size)\n\t\t\tcontinue;\n\t\tbrelse(bh);\n\t\tbh = NULL;\n\t\toffset = 0;\n\t\tblock++;\n\t}\n\tbrelse(bh);\n\treturn NULL;\n}",
          "includes": [
            "#include \"bfs.h\"",
            "#include <linux/sched.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int bfs_add_entry(struct inode *dir, const unsigned char *name,\n\t\t\t\t\t\tint namelen, int ino);",
            "static struct buffer_head *bfs_find_entry(struct inode *dir,\n\t\t\t\tconst unsigned char *name, int namelen,\n\t\t\t\tstruct bfs_dirent **res_dir);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"bfs.h\"\n#include <linux/sched.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/time.h>\n\nstatic int bfs_add_entry(struct inode *dir, const unsigned char *name,\n\t\t\t\t\t\tint namelen, int ino);\nstatic struct buffer_head *bfs_find_entry(struct inode *dir,\n\t\t\t\tconst unsigned char *name, int namelen,\n\t\t\t\tstruct bfs_dirent **res_dir);\n\nstatic struct buffer_head *bfs_find_entry(struct inode *dir,\n\t\t\tconst unsigned char *name, int namelen,\n\t\t\tstruct bfs_dirent **res_dir)\n{\n\tunsigned long block = 0, offset = 0;\n\tstruct buffer_head *bh = NULL;\n\tstruct bfs_dirent *de;\n\n\t*res_dir = NULL;\n\tif (namelen > BFS_NAMELEN)\n\t\treturn NULL;\n\n\twhile (block * BFS_BSIZE + offset < dir->i_size) {\n\t\tif (!bh) {\n\t\t\tbh = sb_bread(dir->i_sb, BFS_I(dir)->i_sblock + block);\n\t\t\tif (!bh) {\n\t\t\t\tblock++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tde = (struct bfs_dirent *)(bh->b_data + offset);\n\t\toffset += BFS_DIRENT_SIZE;\n\t\tif (le16_to_cpu(de->ino) &&\n\t\t\t\tbfs_namecmp(namelen, name, de->name)) {\n\t\t\t*res_dir = de;\n\t\t\treturn bh;\n\t\t}\n\t\tif (offset < bh->b_size)\n\t\t\tcontinue;\n\t\tbrelse(bh);\n\t\tbh = NULL;\n\t\toffset = 0;\n\t\tblock++;\n\t}\n\tbrelse(bh);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&info->bfs_lock"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BFS_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 182
        },
        "resolved": true,
        "details": {
          "function_name": "BFS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/bfs/bfs.h",
          "lines": "33-36",
          "snippet": "static inline struct bfs_sb_info *BFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/bfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bfs_fs.h>\n\nstatic inline struct bfs_sb_info *BFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"bfs.h\"\n#include <linux/sched.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/time.h>\n\nstatic int bfs_add_entry(struct inode *dir, const unsigned char *name,\n\t\t\t\t\t\tint namelen, int ino);\n\nstatic int bfs_unlink(struct inode *dir, struct dentry *dentry)\n{\n\tint error = -ENOENT;\n\tstruct inode *inode = dentry->d_inode;\n\tstruct buffer_head *bh;\n\tstruct bfs_dirent *de;\n\tstruct bfs_sb_info *info = BFS_SB(inode->i_sb);\n\n\tmutex_lock(&info->bfs_lock);\n\tbh = bfs_find_entry(dir, dentry->d_name.name, dentry->d_name.len, &de);\n\tif (!bh || (le16_to_cpu(de->ino) != inode->i_ino))\n\t\tgoto out_brelse;\n\n\tif (!inode->i_nlink) {\n\t\tprintf(\"unlinking non-existent file %s:%lu (nlink=%d)\\n\",\n\t\t\t\t\tinode->i_sb->s_id, inode->i_ino,\n\t\t\t\t\tinode->i_nlink);\n\t\tset_nlink(inode, 1);\n\t}\n\tde->ino = 0;\n\tmark_buffer_dirty_inode(bh, dir);\n\tdir->i_ctime = dir->i_mtime = CURRENT_TIME_SEC;\n\tmark_inode_dirty(dir);\n\tinode->i_ctime = dir->i_ctime;\n\tinode_dec_link_count(inode);\n\terror = 0;\n\nout_brelse:\n\tbrelse(bh);\n\tmutex_unlock(&info->bfs_lock);\n\treturn error;\n}"
  },
  {
    "function_name": "bfs_link",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/bfs/dir.c",
    "lines": "153-174",
    "snippet": "static int bfs_link(struct dentry *old, struct inode *dir,\n\t\t\t\t\t\tstruct dentry *new)\n{\n\tstruct inode *inode = old->d_inode;\n\tstruct bfs_sb_info *info = BFS_SB(inode->i_sb);\n\tint err;\n\n\tmutex_lock(&info->bfs_lock);\n\terr = bfs_add_entry(dir, new->d_name.name, new->d_name.len,\n\t\t\t\t\t\t\tinode->i_ino);\n\tif (err) {\n\t\tmutex_unlock(&info->bfs_lock);\n\t\treturn err;\n\t}\n\tinc_nlink(inode);\n\tinode->i_ctime = CURRENT_TIME_SEC;\n\tmark_inode_dirty(inode);\n\tihold(inode);\n\td_instantiate(new, inode);\n\tmutex_unlock(&info->bfs_lock);\n\treturn 0;\n}",
    "includes": [
      "#include \"bfs.h\"",
      "#include <linux/sched.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&info->bfs_lock"
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_instantiate",
          "args": [
            "new",
            "inode"
          ],
          "line": 171
        },
        "resolved": true,
        "details": {
          "function_name": "d_instantiate_no_diralias",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1839-1854",
          "snippet": "int d_instantiate_no_diralias(struct dentry *entry, struct inode *inode)\n{\n\tBUG_ON(!hlist_unhashed(&entry->d_u.d_alias));\n\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode) && !hlist_empty(&inode->i_dentry)) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tiput(inode);\n\t\treturn -EBUSY;\n\t}\n\t__d_instantiate(entry, inode);\n\tspin_unlock(&inode->i_lock);\n\tsecurity_d_instantiate(entry, inode);\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nint d_instantiate_no_diralias(struct dentry *entry, struct inode *inode)\n{\n\tBUG_ON(!hlist_unhashed(&entry->d_u.d_alias));\n\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode) && !hlist_empty(&inode->i_dentry)) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tiput(inode);\n\t\treturn -EBUSY;\n\t}\n\t__d_instantiate(entry, inode);\n\tspin_unlock(&inode->i_lock);\n\tsecurity_d_instantiate(entry, inode);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ihold",
          "args": [
            "inode"
          ],
          "line": 170
        },
        "resolved": true,
        "details": {
          "function_name": "ihold",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "388-391",
          "snippet": "void ihold(struct inode *inode)\n{\n\tWARN_ON(atomic_inc_return(&inode->i_count) < 2);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid ihold(struct inode *inode)\n{\n\tWARN_ON(atomic_inc_return(&inode->i_count) < 2);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_inode_dirty",
          "args": [
            "inode"
          ],
          "line": 169
        },
        "resolved": true,
        "details": {
          "function_name": "block_dump___mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1134-1154",
          "snippet": "static noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "inc_nlink",
          "args": [
            "inode"
          ],
          "line": 167
        },
        "resolved": true,
        "details": {
          "function_name": "coda_dir_inc_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/dir.c",
          "lines": "121-125",
          "snippet": "static inline void coda_dir_inc_nlink(struct inode *dir)\n{\n\tif (dir->i_nlink >= 2)\n\t\tinc_nlink(dir);\n}",
          "includes": [
            "#include \"coda_int.h\"",
            "#include \"coda_cache.h\"",
            "#include \"coda_linux.h\"",
            "#include <linux/coda_psdev.h>",
            "#include <linux/coda.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"coda_int.h\"\n#include \"coda_cache.h\"\n#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/uaccess.h>\n#include <linux/namei.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic inline void coda_dir_inc_nlink(struct inode *dir)\n{\n\tif (dir->i_nlink >= 2)\n\t\tinc_nlink(dir);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&info->bfs_lock"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bfs_add_entry",
          "args": [
            "dir",
            "new->d_name.name",
            "new->d_name.len",
            "inode->i_ino"
          ],
          "line": 161
        },
        "resolved": true,
        "details": {
          "function_name": "bfs_add_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/bfs/dir.c",
          "lines": "276-319",
          "snippet": "static int bfs_add_entry(struct inode *dir, const unsigned char *name,\n\t\t\t\t\t\t\tint namelen, int ino)\n{\n\tstruct buffer_head *bh;\n\tstruct bfs_dirent *de;\n\tint block, sblock, eblock, off, pos;\n\tint i;\n\n\tdprintf(\"name=%s, namelen=%d\\n\", name, namelen);\n\n\tif (!namelen)\n\t\treturn -ENOENT;\n\tif (namelen > BFS_NAMELEN)\n\t\treturn -ENAMETOOLONG;\n\n\tsblock = BFS_I(dir)->i_sblock;\n\teblock = BFS_I(dir)->i_eblock;\n\tfor (block = sblock; block <= eblock; block++) {\n\t\tbh = sb_bread(dir->i_sb, block);\n\t\tif (!bh)\n\t\t\treturn -ENOSPC;\n\t\tfor (off = 0; off < BFS_BSIZE; off += BFS_DIRENT_SIZE) {\n\t\t\tde = (struct bfs_dirent *)(bh->b_data + off);\n\t\t\tif (!de->ino) {\n\t\t\t\tpos = (block - sblock) * BFS_BSIZE + off;\n\t\t\t\tif (pos >= dir->i_size) {\n\t\t\t\t\tdir->i_size += BFS_DIRENT_SIZE;\n\t\t\t\t\tdir->i_ctime = CURRENT_TIME_SEC;\n\t\t\t\t}\n\t\t\t\tdir->i_mtime = CURRENT_TIME_SEC;\n\t\t\t\tmark_inode_dirty(dir);\n\t\t\t\tde->ino = cpu_to_le16((u16)ino);\n\t\t\t\tfor (i = 0; i < BFS_NAMELEN; i++)\n\t\t\t\t\tde->name[i] =\n\t\t\t\t\t\t(i < namelen) ? name[i] : 0;\n\t\t\t\tmark_buffer_dirty_inode(bh, dir);\n\t\t\t\tbrelse(bh);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\tbrelse(bh);\n\t}\n\treturn -ENOSPC;\n}",
          "includes": [
            "#include \"bfs.h\"",
            "#include <linux/sched.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int bfs_add_entry(struct inode *dir, const unsigned char *name,\n\t\t\t\t\t\tint namelen, int ino);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"bfs.h\"\n#include <linux/sched.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/time.h>\n\nstatic int bfs_add_entry(struct inode *dir, const unsigned char *name,\n\t\t\t\t\t\tint namelen, int ino);\n\nstatic int bfs_add_entry(struct inode *dir, const unsigned char *name,\n\t\t\t\t\t\t\tint namelen, int ino)\n{\n\tstruct buffer_head *bh;\n\tstruct bfs_dirent *de;\n\tint block, sblock, eblock, off, pos;\n\tint i;\n\n\tdprintf(\"name=%s, namelen=%d\\n\", name, namelen);\n\n\tif (!namelen)\n\t\treturn -ENOENT;\n\tif (namelen > BFS_NAMELEN)\n\t\treturn -ENAMETOOLONG;\n\n\tsblock = BFS_I(dir)->i_sblock;\n\teblock = BFS_I(dir)->i_eblock;\n\tfor (block = sblock; block <= eblock; block++) {\n\t\tbh = sb_bread(dir->i_sb, block);\n\t\tif (!bh)\n\t\t\treturn -ENOSPC;\n\t\tfor (off = 0; off < BFS_BSIZE; off += BFS_DIRENT_SIZE) {\n\t\t\tde = (struct bfs_dirent *)(bh->b_data + off);\n\t\t\tif (!de->ino) {\n\t\t\t\tpos = (block - sblock) * BFS_BSIZE + off;\n\t\t\t\tif (pos >= dir->i_size) {\n\t\t\t\t\tdir->i_size += BFS_DIRENT_SIZE;\n\t\t\t\t\tdir->i_ctime = CURRENT_TIME_SEC;\n\t\t\t\t}\n\t\t\t\tdir->i_mtime = CURRENT_TIME_SEC;\n\t\t\t\tmark_inode_dirty(dir);\n\t\t\t\tde->ino = cpu_to_le16((u16)ino);\n\t\t\t\tfor (i = 0; i < BFS_NAMELEN; i++)\n\t\t\t\t\tde->name[i] =\n\t\t\t\t\t\t(i < namelen) ? name[i] : 0;\n\t\t\t\tmark_buffer_dirty_inode(bh, dir);\n\t\t\t\tbrelse(bh);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\tbrelse(bh);\n\t}\n\treturn -ENOSPC;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&info->bfs_lock"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BFS_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 157
        },
        "resolved": true,
        "details": {
          "function_name": "BFS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/bfs/bfs.h",
          "lines": "33-36",
          "snippet": "static inline struct bfs_sb_info *BFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/bfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bfs_fs.h>\n\nstatic inline struct bfs_sb_info *BFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"bfs.h\"\n#include <linux/sched.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/time.h>\n\nstatic int bfs_link(struct dentry *old, struct inode *dir,\n\t\t\t\t\t\tstruct dentry *new)\n{\n\tstruct inode *inode = old->d_inode;\n\tstruct bfs_sb_info *info = BFS_SB(inode->i_sb);\n\tint err;\n\n\tmutex_lock(&info->bfs_lock);\n\terr = bfs_add_entry(dir, new->d_name.name, new->d_name.len,\n\t\t\t\t\t\t\tinode->i_ino);\n\tif (err) {\n\t\tmutex_unlock(&info->bfs_lock);\n\t\treturn err;\n\t}\n\tinc_nlink(inode);\n\tinode->i_ctime = CURRENT_TIME_SEC;\n\tmark_inode_dirty(inode);\n\tihold(inode);\n\td_instantiate(new, inode);\n\tmutex_unlock(&info->bfs_lock);\n\treturn 0;\n}"
  },
  {
    "function_name": "bfs_lookup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/bfs/dir.c",
    "lines": "126-151",
    "snippet": "static struct dentry *bfs_lookup(struct inode *dir, struct dentry *dentry,\n\t\t\t\t\t\tunsigned int flags)\n{\n\tstruct inode *inode = NULL;\n\tstruct buffer_head *bh;\n\tstruct bfs_dirent *de;\n\tstruct bfs_sb_info *info = BFS_SB(dir->i_sb);\n\n\tif (dentry->d_name.len > BFS_NAMELEN)\n\t\treturn ERR_PTR(-ENAMETOOLONG);\n\n\tmutex_lock(&info->bfs_lock);\n\tbh = bfs_find_entry(dir, dentry->d_name.name, dentry->d_name.len, &de);\n\tif (bh) {\n\t\tunsigned long ino = (unsigned long)le16_to_cpu(de->ino);\n\t\tbrelse(bh);\n\t\tinode = bfs_iget(dir->i_sb, ino);\n\t\tif (IS_ERR(inode)) {\n\t\t\tmutex_unlock(&info->bfs_lock);\n\t\t\treturn ERR_CAST(inode);\n\t\t}\n\t}\n\tmutex_unlock(&info->bfs_lock);\n\td_add(dentry, inode);\n\treturn NULL;\n}",
    "includes": [
      "#include \"bfs.h\"",
      "#include <linux/sched.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int bfs_add_entry(struct inode *dir, const unsigned char *name,\n\t\t\t\t\t\tint namelen, int ino);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "d_add",
          "args": [
            "dentry",
            "inode"
          ],
          "line": 149
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_fid_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/fid.c",
          "lines": "49-54",
          "snippet": "void v9fs_fid_add(struct dentry *dentry, struct p9_fid *fid)\n{\n\tspin_lock(&dentry->d_lock);\n\t__add_fid(dentry, fid);\n\tspin_unlock(&dentry->d_lock);\n}",
          "includes": [
            "#include \"fid.h\"",
            "#include \"v9fs_vfs.h\"",
            "#include \"v9fs.h\"",
            "#include <net/9p/client.h>",
            "#include <net/9p/9p.h>",
            "#include <linux/idr.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/idr.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nvoid v9fs_fid_add(struct dentry *dentry, struct p9_fid *fid)\n{\n\tspin_lock(&dentry->d_lock);\n\t__add_fid(dentry, fid);\n\tspin_unlock(&dentry->d_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&info->bfs_lock"
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_CAST",
          "args": [
            "inode"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&info->bfs_lock"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "inode"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bfs_iget",
          "args": [
            "dir->i_sb",
            "ino"
          ],
          "line": 142
        },
        "resolved": true,
        "details": {
          "function_name": "bfs_iget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/bfs/inode.c",
          "lines": "33-96",
          "snippet": "struct inode *bfs_iget(struct super_block *sb, unsigned long ino)\n{\n\tstruct bfs_inode *di;\n\tstruct inode *inode;\n\tstruct buffer_head *bh;\n\tint block, off;\n\n\tinode = iget_locked(sb, ino);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (!(inode->i_state & I_NEW))\n\t\treturn inode;\n\n\tif ((ino < BFS_ROOT_INO) || (ino > BFS_SB(inode->i_sb)->si_lasti)) {\n\t\tprintf(\"Bad inode number %s:%08lx\\n\", inode->i_sb->s_id, ino);\n\t\tgoto error;\n\t}\n\n\tblock = (ino - BFS_ROOT_INO) / BFS_INODES_PER_BLOCK + 1;\n\tbh = sb_bread(inode->i_sb, block);\n\tif (!bh) {\n\t\tprintf(\"Unable to read inode %s:%08lx\\n\", inode->i_sb->s_id,\n\t\t\t\t\t\t\t\t\tino);\n\t\tgoto error;\n\t}\n\n\toff = (ino - BFS_ROOT_INO) % BFS_INODES_PER_BLOCK;\n\tdi = (struct bfs_inode *)bh->b_data + off;\n\n\tinode->i_mode = 0x0000FFFF & le32_to_cpu(di->i_mode);\n\tif (le32_to_cpu(di->i_vtype) == BFS_VDIR) {\n\t\tinode->i_mode |= S_IFDIR;\n\t\tinode->i_op = &bfs_dir_inops;\n\t\tinode->i_fop = &bfs_dir_operations;\n\t} else if (le32_to_cpu(di->i_vtype) == BFS_VREG) {\n\t\tinode->i_mode |= S_IFREG;\n\t\tinode->i_op = &bfs_file_inops;\n\t\tinode->i_fop = &bfs_file_operations;\n\t\tinode->i_mapping->a_ops = &bfs_aops;\n\t}\n\n\tBFS_I(inode)->i_sblock =  le32_to_cpu(di->i_sblock);\n\tBFS_I(inode)->i_eblock =  le32_to_cpu(di->i_eblock);\n\tBFS_I(inode)->i_dsk_ino = le16_to_cpu(di->i_ino);\n\ti_uid_write(inode, le32_to_cpu(di->i_uid));\n\ti_gid_write(inode,  le32_to_cpu(di->i_gid));\n\tset_nlink(inode, le32_to_cpu(di->i_nlink));\n\tinode->i_size = BFS_FILESIZE(di);\n\tinode->i_blocks = BFS_FILEBLOCKS(di);\n\tinode->i_atime.tv_sec =  le32_to_cpu(di->i_atime);\n\tinode->i_mtime.tv_sec =  le32_to_cpu(di->i_mtime);\n\tinode->i_ctime.tv_sec =  le32_to_cpu(di->i_ctime);\n\tinode->i_atime.tv_nsec = 0;\n\tinode->i_mtime.tv_nsec = 0;\n\tinode->i_ctime.tv_nsec = 0;\n\n\tbrelse(bh);\n\tunlock_new_inode(inode);\n\treturn inode;\n\nerror:\n\tiget_failed(inode);\n\treturn ERR_PTR(-EIO);\n}",
          "includes": [
            "#include \"bfs.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/writeback.h>",
            "#include <linux/vfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bfs.h\"\n#include <asm/uaccess.h>\n#include <linux/writeback.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n\nstruct inode *bfs_iget(struct super_block *sb, unsigned long ino)\n{\n\tstruct bfs_inode *di;\n\tstruct inode *inode;\n\tstruct buffer_head *bh;\n\tint block, off;\n\n\tinode = iget_locked(sb, ino);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (!(inode->i_state & I_NEW))\n\t\treturn inode;\n\n\tif ((ino < BFS_ROOT_INO) || (ino > BFS_SB(inode->i_sb)->si_lasti)) {\n\t\tprintf(\"Bad inode number %s:%08lx\\n\", inode->i_sb->s_id, ino);\n\t\tgoto error;\n\t}\n\n\tblock = (ino - BFS_ROOT_INO) / BFS_INODES_PER_BLOCK + 1;\n\tbh = sb_bread(inode->i_sb, block);\n\tif (!bh) {\n\t\tprintf(\"Unable to read inode %s:%08lx\\n\", inode->i_sb->s_id,\n\t\t\t\t\t\t\t\t\tino);\n\t\tgoto error;\n\t}\n\n\toff = (ino - BFS_ROOT_INO) % BFS_INODES_PER_BLOCK;\n\tdi = (struct bfs_inode *)bh->b_data + off;\n\n\tinode->i_mode = 0x0000FFFF & le32_to_cpu(di->i_mode);\n\tif (le32_to_cpu(di->i_vtype) == BFS_VDIR) {\n\t\tinode->i_mode |= S_IFDIR;\n\t\tinode->i_op = &bfs_dir_inops;\n\t\tinode->i_fop = &bfs_dir_operations;\n\t} else if (le32_to_cpu(di->i_vtype) == BFS_VREG) {\n\t\tinode->i_mode |= S_IFREG;\n\t\tinode->i_op = &bfs_file_inops;\n\t\tinode->i_fop = &bfs_file_operations;\n\t\tinode->i_mapping->a_ops = &bfs_aops;\n\t}\n\n\tBFS_I(inode)->i_sblock =  le32_to_cpu(di->i_sblock);\n\tBFS_I(inode)->i_eblock =  le32_to_cpu(di->i_eblock);\n\tBFS_I(inode)->i_dsk_ino = le16_to_cpu(di->i_ino);\n\ti_uid_write(inode, le32_to_cpu(di->i_uid));\n\ti_gid_write(inode,  le32_to_cpu(di->i_gid));\n\tset_nlink(inode, le32_to_cpu(di->i_nlink));\n\tinode->i_size = BFS_FILESIZE(di);\n\tinode->i_blocks = BFS_FILEBLOCKS(di);\n\tinode->i_atime.tv_sec =  le32_to_cpu(di->i_atime);\n\tinode->i_mtime.tv_sec =  le32_to_cpu(di->i_mtime);\n\tinode->i_ctime.tv_sec =  le32_to_cpu(di->i_ctime);\n\tinode->i_atime.tv_nsec = 0;\n\tinode->i_mtime.tv_nsec = 0;\n\tinode->i_ctime.tv_nsec = 0;\n\n\tbrelse(bh);\n\tunlock_new_inode(inode);\n\treturn inode;\n\nerror:\n\tiget_failed(inode);\n\treturn ERR_PTR(-EIO);\n}"
        }
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 141
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "de->ino"
          ],
          "line": 140
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bfs_find_entry",
          "args": [
            "dir",
            "dentry->d_name.name",
            "dentry->d_name.len",
            "&de"
          ],
          "line": 138
        },
        "resolved": true,
        "details": {
          "function_name": "bfs_find_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/bfs/dir.c",
          "lines": "329-365",
          "snippet": "static struct buffer_head *bfs_find_entry(struct inode *dir,\n\t\t\tconst unsigned char *name, int namelen,\n\t\t\tstruct bfs_dirent **res_dir)\n{\n\tunsigned long block = 0, offset = 0;\n\tstruct buffer_head *bh = NULL;\n\tstruct bfs_dirent *de;\n\n\t*res_dir = NULL;\n\tif (namelen > BFS_NAMELEN)\n\t\treturn NULL;\n\n\twhile (block * BFS_BSIZE + offset < dir->i_size) {\n\t\tif (!bh) {\n\t\t\tbh = sb_bread(dir->i_sb, BFS_I(dir)->i_sblock + block);\n\t\t\tif (!bh) {\n\t\t\t\tblock++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tde = (struct bfs_dirent *)(bh->b_data + offset);\n\t\toffset += BFS_DIRENT_SIZE;\n\t\tif (le16_to_cpu(de->ino) &&\n\t\t\t\tbfs_namecmp(namelen, name, de->name)) {\n\t\t\t*res_dir = de;\n\t\t\treturn bh;\n\t\t}\n\t\tif (offset < bh->b_size)\n\t\t\tcontinue;\n\t\tbrelse(bh);\n\t\tbh = NULL;\n\t\toffset = 0;\n\t\tblock++;\n\t}\n\tbrelse(bh);\n\treturn NULL;\n}",
          "includes": [
            "#include \"bfs.h\"",
            "#include <linux/sched.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int bfs_add_entry(struct inode *dir, const unsigned char *name,\n\t\t\t\t\t\tint namelen, int ino);",
            "static struct buffer_head *bfs_find_entry(struct inode *dir,\n\t\t\t\tconst unsigned char *name, int namelen,\n\t\t\t\tstruct bfs_dirent **res_dir);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"bfs.h\"\n#include <linux/sched.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/time.h>\n\nstatic int bfs_add_entry(struct inode *dir, const unsigned char *name,\n\t\t\t\t\t\tint namelen, int ino);\nstatic struct buffer_head *bfs_find_entry(struct inode *dir,\n\t\t\t\tconst unsigned char *name, int namelen,\n\t\t\t\tstruct bfs_dirent **res_dir);\n\nstatic struct buffer_head *bfs_find_entry(struct inode *dir,\n\t\t\tconst unsigned char *name, int namelen,\n\t\t\tstruct bfs_dirent **res_dir)\n{\n\tunsigned long block = 0, offset = 0;\n\tstruct buffer_head *bh = NULL;\n\tstruct bfs_dirent *de;\n\n\t*res_dir = NULL;\n\tif (namelen > BFS_NAMELEN)\n\t\treturn NULL;\n\n\twhile (block * BFS_BSIZE + offset < dir->i_size) {\n\t\tif (!bh) {\n\t\t\tbh = sb_bread(dir->i_sb, BFS_I(dir)->i_sblock + block);\n\t\t\tif (!bh) {\n\t\t\t\tblock++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tde = (struct bfs_dirent *)(bh->b_data + offset);\n\t\toffset += BFS_DIRENT_SIZE;\n\t\tif (le16_to_cpu(de->ino) &&\n\t\t\t\tbfs_namecmp(namelen, name, de->name)) {\n\t\t\t*res_dir = de;\n\t\t\treturn bh;\n\t\t}\n\t\tif (offset < bh->b_size)\n\t\t\tcontinue;\n\t\tbrelse(bh);\n\t\tbh = NULL;\n\t\toffset = 0;\n\t\tblock++;\n\t}\n\tbrelse(bh);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&info->bfs_lock"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENAMETOOLONG"
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BFS_SB",
          "args": [
            "dir->i_sb"
          ],
          "line": 132
        },
        "resolved": true,
        "details": {
          "function_name": "BFS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/bfs/bfs.h",
          "lines": "33-36",
          "snippet": "static inline struct bfs_sb_info *BFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/bfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bfs_fs.h>\n\nstatic inline struct bfs_sb_info *BFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"bfs.h\"\n#include <linux/sched.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/time.h>\n\nstatic int bfs_add_entry(struct inode *dir, const unsigned char *name,\n\t\t\t\t\t\tint namelen, int ino);\n\nstatic struct dentry *bfs_lookup(struct inode *dir, struct dentry *dentry,\n\t\t\t\t\t\tunsigned int flags)\n{\n\tstruct inode *inode = NULL;\n\tstruct buffer_head *bh;\n\tstruct bfs_dirent *de;\n\tstruct bfs_sb_info *info = BFS_SB(dir->i_sb);\n\n\tif (dentry->d_name.len > BFS_NAMELEN)\n\t\treturn ERR_PTR(-ENAMETOOLONG);\n\n\tmutex_lock(&info->bfs_lock);\n\tbh = bfs_find_entry(dir, dentry->d_name.name, dentry->d_name.len, &de);\n\tif (bh) {\n\t\tunsigned long ino = (unsigned long)le16_to_cpu(de->ino);\n\t\tbrelse(bh);\n\t\tinode = bfs_iget(dir->i_sb, ino);\n\t\tif (IS_ERR(inode)) {\n\t\t\tmutex_unlock(&info->bfs_lock);\n\t\t\treturn ERR_CAST(inode);\n\t\t}\n\t}\n\tmutex_unlock(&info->bfs_lock);\n\td_add(dentry, inode);\n\treturn NULL;\n}"
  },
  {
    "function_name": "bfs_create",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/bfs/dir.c",
    "lines": "78-124",
    "snippet": "static int bfs_create(struct inode *dir, struct dentry *dentry, umode_t mode,\n\t\t\t\t\t\tbool excl)\n{\n\tint err;\n\tstruct inode *inode;\n\tstruct super_block *s = dir->i_sb;\n\tstruct bfs_sb_info *info = BFS_SB(s);\n\tunsigned long ino;\n\n\tinode = new_inode(s);\n\tif (!inode)\n\t\treturn -ENOSPC;\n\tmutex_lock(&info->bfs_lock);\n\tino = find_first_zero_bit(info->si_imap, info->si_lasti + 1);\n\tif (ino > info->si_lasti) {\n\t\tmutex_unlock(&info->bfs_lock);\n\t\tiput(inode);\n\t\treturn -ENOSPC;\n\t}\n\tset_bit(ino, info->si_imap);\n\tinfo->si_freei--;\n\tinode_init_owner(inode, dir, mode);\n\tinode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME_SEC;\n\tinode->i_blocks = 0;\n\tinode->i_op = &bfs_file_inops;\n\tinode->i_fop = &bfs_file_operations;\n\tinode->i_mapping->a_ops = &bfs_aops;\n\tinode->i_ino = ino;\n\tBFS_I(inode)->i_dsk_ino = ino;\n\tBFS_I(inode)->i_sblock = 0;\n\tBFS_I(inode)->i_eblock = 0;\n\tinsert_inode_hash(inode);\n        mark_inode_dirty(inode);\n\tbfs_dump_imap(\"create\", s);\n\n\terr = bfs_add_entry(dir, dentry->d_name.name, dentry->d_name.len,\n\t\t\t\t\t\t\tinode->i_ino);\n\tif (err) {\n\t\tinode_dec_link_count(inode);\n\t\tmutex_unlock(&info->bfs_lock);\n\t\tiput(inode);\n\t\treturn err;\n\t}\n\tmutex_unlock(&info->bfs_lock);\n\td_instantiate(dentry, inode);\n\treturn 0;\n}",
    "includes": [
      "#include \"bfs.h\"",
      "#include <linux/sched.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int bfs_add_entry(struct inode *dir, const unsigned char *name,\n\t\t\t\t\t\tint namelen, int ino);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "d_instantiate",
          "args": [
            "dentry",
            "inode"
          ],
          "line": 122
        },
        "resolved": true,
        "details": {
          "function_name": "d_instantiate_no_diralias",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1839-1854",
          "snippet": "int d_instantiate_no_diralias(struct dentry *entry, struct inode *inode)\n{\n\tBUG_ON(!hlist_unhashed(&entry->d_u.d_alias));\n\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode) && !hlist_empty(&inode->i_dentry)) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tiput(inode);\n\t\treturn -EBUSY;\n\t}\n\t__d_instantiate(entry, inode);\n\tspin_unlock(&inode->i_lock);\n\tsecurity_d_instantiate(entry, inode);\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nint d_instantiate_no_diralias(struct dentry *entry, struct inode *inode)\n{\n\tBUG_ON(!hlist_unhashed(&entry->d_u.d_alias));\n\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode) && !hlist_empty(&inode->i_dentry)) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tiput(inode);\n\t\treturn -EBUSY;\n\t}\n\t__d_instantiate(entry, inode);\n\tspin_unlock(&inode->i_lock);\n\tsecurity_d_instantiate(entry, inode);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&info->bfs_lock"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "inode"
          ],
          "line": 118
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&info->bfs_lock"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode_dec_link_count",
          "args": [
            "inode"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bfs_add_entry",
          "args": [
            "dir",
            "dentry->d_name.name",
            "dentry->d_name.len",
            "inode->i_ino"
          ],
          "line": 113
        },
        "resolved": true,
        "details": {
          "function_name": "bfs_add_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/bfs/dir.c",
          "lines": "276-319",
          "snippet": "static int bfs_add_entry(struct inode *dir, const unsigned char *name,\n\t\t\t\t\t\t\tint namelen, int ino)\n{\n\tstruct buffer_head *bh;\n\tstruct bfs_dirent *de;\n\tint block, sblock, eblock, off, pos;\n\tint i;\n\n\tdprintf(\"name=%s, namelen=%d\\n\", name, namelen);\n\n\tif (!namelen)\n\t\treturn -ENOENT;\n\tif (namelen > BFS_NAMELEN)\n\t\treturn -ENAMETOOLONG;\n\n\tsblock = BFS_I(dir)->i_sblock;\n\teblock = BFS_I(dir)->i_eblock;\n\tfor (block = sblock; block <= eblock; block++) {\n\t\tbh = sb_bread(dir->i_sb, block);\n\t\tif (!bh)\n\t\t\treturn -ENOSPC;\n\t\tfor (off = 0; off < BFS_BSIZE; off += BFS_DIRENT_SIZE) {\n\t\t\tde = (struct bfs_dirent *)(bh->b_data + off);\n\t\t\tif (!de->ino) {\n\t\t\t\tpos = (block - sblock) * BFS_BSIZE + off;\n\t\t\t\tif (pos >= dir->i_size) {\n\t\t\t\t\tdir->i_size += BFS_DIRENT_SIZE;\n\t\t\t\t\tdir->i_ctime = CURRENT_TIME_SEC;\n\t\t\t\t}\n\t\t\t\tdir->i_mtime = CURRENT_TIME_SEC;\n\t\t\t\tmark_inode_dirty(dir);\n\t\t\t\tde->ino = cpu_to_le16((u16)ino);\n\t\t\t\tfor (i = 0; i < BFS_NAMELEN; i++)\n\t\t\t\t\tde->name[i] =\n\t\t\t\t\t\t(i < namelen) ? name[i] : 0;\n\t\t\t\tmark_buffer_dirty_inode(bh, dir);\n\t\t\t\tbrelse(bh);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\tbrelse(bh);\n\t}\n\treturn -ENOSPC;\n}",
          "includes": [
            "#include \"bfs.h\"",
            "#include <linux/sched.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int bfs_add_entry(struct inode *dir, const unsigned char *name,\n\t\t\t\t\t\tint namelen, int ino);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"bfs.h\"\n#include <linux/sched.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/time.h>\n\nstatic int bfs_add_entry(struct inode *dir, const unsigned char *name,\n\t\t\t\t\t\tint namelen, int ino);\n\nstatic int bfs_add_entry(struct inode *dir, const unsigned char *name,\n\t\t\t\t\t\t\tint namelen, int ino)\n{\n\tstruct buffer_head *bh;\n\tstruct bfs_dirent *de;\n\tint block, sblock, eblock, off, pos;\n\tint i;\n\n\tdprintf(\"name=%s, namelen=%d\\n\", name, namelen);\n\n\tif (!namelen)\n\t\treturn -ENOENT;\n\tif (namelen > BFS_NAMELEN)\n\t\treturn -ENAMETOOLONG;\n\n\tsblock = BFS_I(dir)->i_sblock;\n\teblock = BFS_I(dir)->i_eblock;\n\tfor (block = sblock; block <= eblock; block++) {\n\t\tbh = sb_bread(dir->i_sb, block);\n\t\tif (!bh)\n\t\t\treturn -ENOSPC;\n\t\tfor (off = 0; off < BFS_BSIZE; off += BFS_DIRENT_SIZE) {\n\t\t\tde = (struct bfs_dirent *)(bh->b_data + off);\n\t\t\tif (!de->ino) {\n\t\t\t\tpos = (block - sblock) * BFS_BSIZE + off;\n\t\t\t\tif (pos >= dir->i_size) {\n\t\t\t\t\tdir->i_size += BFS_DIRENT_SIZE;\n\t\t\t\t\tdir->i_ctime = CURRENT_TIME_SEC;\n\t\t\t\t}\n\t\t\t\tdir->i_mtime = CURRENT_TIME_SEC;\n\t\t\t\tmark_inode_dirty(dir);\n\t\t\t\tde->ino = cpu_to_le16((u16)ino);\n\t\t\t\tfor (i = 0; i < BFS_NAMELEN; i++)\n\t\t\t\t\tde->name[i] =\n\t\t\t\t\t\t(i < namelen) ? name[i] : 0;\n\t\t\t\tmark_buffer_dirty_inode(bh, dir);\n\t\t\t\tbrelse(bh);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\tbrelse(bh);\n\t}\n\treturn -ENOSPC;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bfs_dump_imap",
          "args": [
            "\"create\"",
            "s"
          ],
          "line": 111
        },
        "resolved": true,
        "details": {
          "function_name": "bfs_dump_imap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/bfs/inode.c",
          "lines": "298-317",
          "snippet": "void bfs_dump_imap(const char *prefix, struct super_block *s)\n{\n#ifdef DEBUG\n\tint i;\n\tchar *tmpbuf = (char *)get_zeroed_page(GFP_KERNEL);\n\n\tif (!tmpbuf)\n\t\treturn;\n\tfor (i = BFS_SB(s)->si_lasti; i >= 0; i--) {\n\t\tif (i > PAGE_SIZE - 100) break;\n\t\tif (test_bit(i, BFS_SB(s)->si_imap))\n\t\t\tstrcat(tmpbuf, \"1\");\n\t\telse\n\t\t\tstrcat(tmpbuf, \"0\");\n\t}\n\tprintf(\"BFS-fs: %s: lasti=%08lx <%s>\\n\",\n\t\t\t\tprefix, BFS_SB(s)->si_lasti, tmpbuf);\n\tfree_page((unsigned long)tmpbuf);\n#endif\n}",
          "includes": [
            "#include \"bfs.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/writeback.h>",
            "#include <linux/vfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bfs.h\"\n#include <asm/uaccess.h>\n#include <linux/writeback.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n\nvoid bfs_dump_imap(const char *prefix, struct super_block *s)\n{\n#ifdef DEBUG\n\tint i;\n\tchar *tmpbuf = (char *)get_zeroed_page(GFP_KERNEL);\n\n\tif (!tmpbuf)\n\t\treturn;\n\tfor (i = BFS_SB(s)->si_lasti; i >= 0; i--) {\n\t\tif (i > PAGE_SIZE - 100) break;\n\t\tif (test_bit(i, BFS_SB(s)->si_imap))\n\t\t\tstrcat(tmpbuf, \"1\");\n\t\telse\n\t\t\tstrcat(tmpbuf, \"0\");\n\t}\n\tprintf(\"BFS-fs: %s: lasti=%08lx <%s>\\n\",\n\t\t\t\tprefix, BFS_SB(s)->si_lasti, tmpbuf);\n\tfree_page((unsigned long)tmpbuf);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_inode_dirty",
          "args": [
            "inode"
          ],
          "line": 110
        },
        "resolved": true,
        "details": {
          "function_name": "block_dump___mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1134-1154",
          "snippet": "static noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "insert_inode_hash",
          "args": [
            "inode"
          ],
          "line": 109
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_insert_inode_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "213-218",
          "snippet": "static inline void btrfs_insert_inode_hash(struct inode *inode)\n{\n\tunsigned long h = btrfs_inode_hash(inode->i_ino, BTRFS_I(inode)->root);\n\n\t__insert_inode_hash(inode, h);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline void btrfs_insert_inode_hash(struct inode *inode)\n{\n\tunsigned long h = btrfs_inode_hash(inode->i_ino, BTRFS_I(inode)->root);\n\n\t__insert_inode_hash(inode, h);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BFS_I",
          "args": [
            "inode"
          ],
          "line": 108
        },
        "resolved": true,
        "details": {
          "function_name": "BFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/bfs/bfs.h",
          "lines": "38-41",
          "snippet": "static inline struct bfs_inode_info *BFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct bfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <linux/bfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bfs_fs.h>\n\nstatic inline struct bfs_inode_info *BFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct bfs_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_init_owner",
          "args": [
            "inode",
            "dir",
            "mode"
          ],
          "line": 99
        },
        "resolved": true,
        "details": {
          "function_name": "inode_init_owner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1880-1891",
          "snippet": "void inode_init_owner(struct inode *inode, const struct inode *dir,\n\t\t\tumode_t mode)\n{\n\tinode->i_uid = current_fsuid();\n\tif (dir && dir->i_mode & S_ISGID) {\n\t\tinode->i_gid = dir->i_gid;\n\t\tif (S_ISDIR(mode))\n\t\t\tmode |= S_ISGID;\n\t} else\n\t\tinode->i_gid = current_fsgid();\n\tinode->i_mode = mode;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid inode_init_owner(struct inode *inode, const struct inode *dir,\n\t\t\tumode_t mode)\n{\n\tinode->i_uid = current_fsuid();\n\tif (dir && dir->i_mode & S_ISGID) {\n\t\tinode->i_gid = dir->i_gid;\n\t\tif (S_ISDIR(mode))\n\t\t\tmode |= S_ISGID;\n\t} else\n\t\tinode->i_gid = current_fsgid();\n\tinode->i_mode = mode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "ino",
            "info->si_imap"
          ],
          "line": 97
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&info->bfs_lock"
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_first_zero_bit",
          "args": [
            "info->si_imap",
            "info->si_lasti + 1"
          ],
          "line": 91
        },
        "resolved": true,
        "details": {
          "function_name": "minix_find_first_zero_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/minix/minix.h",
          "lines": "124-140",
          "snippet": "static inline int minix_find_first_zero_bit(const void *vaddr, unsigned size)\n{\n\tconst unsigned short *p = vaddr, *addr = vaddr;\n\tunsigned short num;\n\n\tif (!size)\n\t\treturn 0;\n\n\tsize >>= 4;\n\twhile (*p++ == 0xffff) {\n\t\tif (--size == 0)\n\t\t\treturn (p - addr) << 4;\n\t}\n\n\tnum = *--p;\n\treturn ((p - addr) << 4) + ffz(num);\n}",
          "includes": [
            "#include <linux/minix_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define minix_find_first_zero_bit\tfind_first_zero_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/minix_fs.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\n#define minix_find_first_zero_bit\tfind_first_zero_bit_le\n\nstatic inline int minix_find_first_zero_bit(const void *vaddr, unsigned size)\n{\n\tconst unsigned short *p = vaddr, *addr = vaddr;\n\tunsigned short num;\n\n\tif (!size)\n\t\treturn 0;\n\n\tsize >>= 4;\n\twhile (*p++ == 0xffff) {\n\t\tif (--size == 0)\n\t\t\treturn (p - addr) << 4;\n\t}\n\n\tnum = *--p;\n\treturn ((p - addr) << 4) + ffz(num);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&info->bfs_lock"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "new_inode",
          "args": [
            "s"
          ],
          "line": 87
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_new_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "924-933",
          "snippet": "void unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BFS_SB",
          "args": [
            "s"
          ],
          "line": 84
        },
        "resolved": true,
        "details": {
          "function_name": "BFS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/bfs/bfs.h",
          "lines": "33-36",
          "snippet": "static inline struct bfs_sb_info *BFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/bfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bfs_fs.h>\n\nstatic inline struct bfs_sb_info *BFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"bfs.h\"\n#include <linux/sched.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/time.h>\n\nstatic int bfs_add_entry(struct inode *dir, const unsigned char *name,\n\t\t\t\t\t\tint namelen, int ino);\n\nstatic int bfs_create(struct inode *dir, struct dentry *dentry, umode_t mode,\n\t\t\t\t\t\tbool excl)\n{\n\tint err;\n\tstruct inode *inode;\n\tstruct super_block *s = dir->i_sb;\n\tstruct bfs_sb_info *info = BFS_SB(s);\n\tunsigned long ino;\n\n\tinode = new_inode(s);\n\tif (!inode)\n\t\treturn -ENOSPC;\n\tmutex_lock(&info->bfs_lock);\n\tino = find_first_zero_bit(info->si_imap, info->si_lasti + 1);\n\tif (ino > info->si_lasti) {\n\t\tmutex_unlock(&info->bfs_lock);\n\t\tiput(inode);\n\t\treturn -ENOSPC;\n\t}\n\tset_bit(ino, info->si_imap);\n\tinfo->si_freei--;\n\tinode_init_owner(inode, dir, mode);\n\tinode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME_SEC;\n\tinode->i_blocks = 0;\n\tinode->i_op = &bfs_file_inops;\n\tinode->i_fop = &bfs_file_operations;\n\tinode->i_mapping->a_ops = &bfs_aops;\n\tinode->i_ino = ino;\n\tBFS_I(inode)->i_dsk_ino = ino;\n\tBFS_I(inode)->i_sblock = 0;\n\tBFS_I(inode)->i_eblock = 0;\n\tinsert_inode_hash(inode);\n        mark_inode_dirty(inode);\n\tbfs_dump_imap(\"create\", s);\n\n\terr = bfs_add_entry(dir, dentry->d_name.name, dentry->d_name.len,\n\t\t\t\t\t\t\tinode->i_ino);\n\tif (err) {\n\t\tinode_dec_link_count(inode);\n\t\tmutex_unlock(&info->bfs_lock);\n\t\tiput(inode);\n\t\treturn err;\n\t}\n\tmutex_unlock(&info->bfs_lock);\n\td_instantiate(dentry, inode);\n\treturn 0;\n}"
  },
  {
    "function_name": "bfs_readdir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/bfs/dir.c",
    "lines": "29-69",
    "snippet": "static int bfs_readdir(struct file *f, struct dir_context *ctx)\n{\n\tstruct inode *dir = file_inode(f);\n\tstruct buffer_head *bh;\n\tstruct bfs_dirent *de;\n\tunsigned int offset;\n\tint block;\n\n\tif (ctx->pos & (BFS_DIRENT_SIZE - 1)) {\n\t\tprintf(\"Bad f_pos=%08lx for %s:%08lx\\n\",\n\t\t\t\t\t(unsigned long)ctx->pos,\n\t\t\t\t\tdir->i_sb->s_id, dir->i_ino);\n\t\treturn -EINVAL;\n\t}\n\n\twhile (ctx->pos < dir->i_size) {\n\t\toffset = ctx->pos & (BFS_BSIZE - 1);\n\t\tblock = BFS_I(dir)->i_sblock + (ctx->pos >> BFS_BSIZE_BITS);\n\t\tbh = sb_bread(dir->i_sb, block);\n\t\tif (!bh) {\n\t\t\tctx->pos += BFS_BSIZE - offset;\n\t\t\tcontinue;\n\t\t}\n\t\tdo {\n\t\t\tde = (struct bfs_dirent *)(bh->b_data + offset);\n\t\t\tif (de->ino) {\n\t\t\t\tint size = strnlen(de->name, BFS_NAMELEN);\n\t\t\t\tif (!dir_emit(ctx, de->name, size,\n\t\t\t\t\t\tle16_to_cpu(de->ino),\n\t\t\t\t\t\tDT_UNKNOWN)) {\n\t\t\t\t\tbrelse(bh);\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\toffset += BFS_DIRENT_SIZE;\n\t\t\tctx->pos += BFS_DIRENT_SIZE;\n\t\t} while ((offset < BFS_BSIZE) && (ctx->pos < dir->i_size));\n\t\tbrelse(bh);\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"bfs.h\"",
      "#include <linux/sched.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int bfs_add_entry(struct inode *dir, const unsigned char *name,\n\t\t\t\t\t\tint namelen, int ino);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 66
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "dir_emit",
          "args": [
            "ctx",
            "de->name",
            "size",
            "le16_to_cpu(de->ino)",
            "DT_UNKNOWN"
          ],
          "line": 56
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "de->ino"
          ],
          "line": 57
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strnlen",
          "args": [
            "de->name",
            "BFS_NAMELEN"
          ],
          "line": 55
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_bread",
          "args": [
            "dir->i_sb",
            "block"
          ],
          "line": 47
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BFS_I",
          "args": [
            "dir"
          ],
          "line": 46
        },
        "resolved": true,
        "details": {
          "function_name": "BFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/bfs/bfs.h",
          "lines": "38-41",
          "snippet": "static inline struct bfs_inode_info *BFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct bfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <linux/bfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bfs_fs.h>\n\nstatic inline struct bfs_inode_info *BFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct bfs_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Bad f_pos=%08lx for %s:%08lx\\n\"",
            "(unsigned long)ctx->pos",
            "dir->i_sb->s_id",
            "dir->i_ino"
          ],
          "line": 38
        },
        "resolved": true,
        "details": {
          "function_name": "seq_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "416-426",
          "snippet": "int seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tint ret;\n\tva_list args;\n\n\tva_start(args, f);\n\tret = seq_vprintf(m, f, args);\n\tva_end(args);\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tint ret;\n\tva_list args;\n\n\tva_start(args, f);\n\tret = seq_vprintf(m, f, args);\n\tva_end(args);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "f"
          ],
          "line": 31
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"bfs.h\"\n#include <linux/sched.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/time.h>\n\nstatic int bfs_add_entry(struct inode *dir, const unsigned char *name,\n\t\t\t\t\t\tint namelen, int ino);\n\nstatic int bfs_readdir(struct file *f, struct dir_context *ctx)\n{\n\tstruct inode *dir = file_inode(f);\n\tstruct buffer_head *bh;\n\tstruct bfs_dirent *de;\n\tunsigned int offset;\n\tint block;\n\n\tif (ctx->pos & (BFS_DIRENT_SIZE - 1)) {\n\t\tprintf(\"Bad f_pos=%08lx for %s:%08lx\\n\",\n\t\t\t\t\t(unsigned long)ctx->pos,\n\t\t\t\t\tdir->i_sb->s_id, dir->i_ino);\n\t\treturn -EINVAL;\n\t}\n\n\twhile (ctx->pos < dir->i_size) {\n\t\toffset = ctx->pos & (BFS_BSIZE - 1);\n\t\tblock = BFS_I(dir)->i_sblock + (ctx->pos >> BFS_BSIZE_BITS);\n\t\tbh = sb_bread(dir->i_sb, block);\n\t\tif (!bh) {\n\t\t\tctx->pos += BFS_BSIZE - offset;\n\t\t\tcontinue;\n\t\t}\n\t\tdo {\n\t\t\tde = (struct bfs_dirent *)(bh->b_data + offset);\n\t\t\tif (de->ino) {\n\t\t\t\tint size = strnlen(de->name, BFS_NAMELEN);\n\t\t\t\tif (!dir_emit(ctx, de->name, size,\n\t\t\t\t\t\tle16_to_cpu(de->ino),\n\t\t\t\t\t\tDT_UNKNOWN)) {\n\t\t\t\t\tbrelse(bh);\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\toffset += BFS_DIRENT_SIZE;\n\t\t\tctx->pos += BFS_DIRENT_SIZE;\n\t\t} while ((offset < BFS_BSIZE) && (ctx->pos < dir->i_size));\n\t\tbrelse(bh);\n\t}\n\treturn 0;\n}"
  }
]