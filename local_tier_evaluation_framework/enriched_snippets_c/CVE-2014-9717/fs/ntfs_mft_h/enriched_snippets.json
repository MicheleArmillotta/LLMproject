[
  {
    "function_name": "write_mft_record",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/mft.h",
    "lines": "102-112",
    "snippet": "static inline int write_mft_record(ntfs_inode *ni, MFT_RECORD *m, int sync)\n{\n\tstruct page *page = ni->page;\n\tint err;\n\n\tBUG_ON(!page);\n\tlock_page(page);\n\terr = write_mft_record_nolock(ni, m, sync);\n\tunlock_page(page);\n\treturn err;\n}",
    "includes": [
      "#include \"inode.h\"",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 110
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_mft_record_nolock",
          "args": [
            "ni",
            "m",
            "sync"
          ],
          "line": 109
        },
        "resolved": true,
        "details": {
          "function_name": "write_mft_record_nolock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/mft.c",
          "lines": "669-844",
          "snippet": "int write_mft_record_nolock(ntfs_inode *ni, MFT_RECORD *m, int sync)\n{\n\tntfs_volume *vol = ni->vol;\n\tstruct page *page = ni->page;\n\tunsigned int blocksize = vol->sb->s_blocksize;\n\tunsigned char blocksize_bits = vol->sb->s_blocksize_bits;\n\tint max_bhs = vol->mft_record_size / blocksize;\n\tstruct buffer_head *bhs[max_bhs];\n\tstruct buffer_head *bh, *head;\n\trunlist_element *rl;\n\tunsigned int block_start, block_end, m_start, m_end;\n\tint i_bhs, nr_bhs, err = 0;\n\n\tntfs_debug(\"Entering for inode 0x%lx.\", ni->mft_no);\n\tBUG_ON(NInoAttr(ni));\n\tBUG_ON(!max_bhs);\n\tBUG_ON(!PageLocked(page));\n\t/*\n\t * If the ntfs_inode is clean no need to do anything.  If it is dirty,\n\t * mark it as clean now so that it can be redirtied later on if needed.\n\t * There is no danger of races since the caller is holding the locks\n\t * for the mft record @m and the page it is in.\n\t */\n\tif (!NInoTestClearDirty(ni))\n\t\tgoto done;\n\tbh = head = page_buffers(page);\n\tBUG_ON(!bh);\n\trl = NULL;\n\tnr_bhs = 0;\n\tblock_start = 0;\n\tm_start = ni->page_ofs;\n\tm_end = m_start + vol->mft_record_size;\n\tdo {\n\t\tblock_end = block_start + blocksize;\n\t\t/* If the buffer is outside the mft record, skip it. */\n\t\tif (block_end <= m_start)\n\t\t\tcontinue;\n\t\tif (unlikely(block_start >= m_end))\n\t\t\tbreak;\n\t\t/*\n\t\t * If this block is not the first one in the record, we ignore\n\t\t * the buffer's dirty state because we could have raced with a\n\t\t * parallel mark_ntfs_record_dirty().\n\t\t */\n\t\tif (block_start == m_start) {\n\t\t\t/* This block is the first one in the record. */\n\t\t\tif (!buffer_dirty(bh)) {\n\t\t\t\tBUG_ON(nr_bhs);\n\t\t\t\t/* Clean records are not written out. */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t/* Need to map the buffer if it is not mapped already. */\n\t\tif (unlikely(!buffer_mapped(bh))) {\n\t\t\tVCN vcn;\n\t\t\tLCN lcn;\n\t\t\tunsigned int vcn_ofs;\n\n\t\t\tbh->b_bdev = vol->sb->s_bdev;\n\t\t\t/* Obtain the vcn and offset of the current block. */\n\t\t\tvcn = ((VCN)ni->mft_no << vol->mft_record_size_bits) +\n\t\t\t\t\t(block_start - m_start);\n\t\t\tvcn_ofs = vcn & vol->cluster_size_mask;\n\t\t\tvcn >>= vol->cluster_size_bits;\n\t\t\tif (!rl) {\n\t\t\t\tdown_read(&NTFS_I(vol->mft_ino)->runlist.lock);\n\t\t\t\trl = NTFS_I(vol->mft_ino)->runlist.rl;\n\t\t\t\tBUG_ON(!rl);\n\t\t\t}\n\t\t\t/* Seek to element containing target vcn. */\n\t\t\twhile (rl->length && rl[1].vcn <= vcn)\n\t\t\t\trl++;\n\t\t\tlcn = ntfs_rl_vcn_to_lcn(rl, vcn);\n\t\t\t/* For $MFT, only lcn >= 0 is a successful remap. */\n\t\t\tif (likely(lcn >= 0)) {\n\t\t\t\t/* Setup buffer head to correct block. */\n\t\t\t\tbh->b_blocknr = ((lcn <<\n\t\t\t\t\t\tvol->cluster_size_bits) +\n\t\t\t\t\t\tvcn_ofs) >> blocksize_bits;\n\t\t\t\tset_buffer_mapped(bh);\n\t\t\t} else {\n\t\t\t\tbh->b_blocknr = -1;\n\t\t\t\tntfs_error(vol->sb, \"Cannot write mft record \"\n\t\t\t\t\t\t\"0x%lx because its location \"\n\t\t\t\t\t\t\"on disk could not be \"\n\t\t\t\t\t\t\"determined (error code %lli).\",\n\t\t\t\t\t\tni->mft_no, (long long)lcn);\n\t\t\t\terr = -EIO;\n\t\t\t}\n\t\t}\n\t\tBUG_ON(!buffer_uptodate(bh));\n\t\tBUG_ON(!nr_bhs && (m_start != block_start));\n\t\tBUG_ON(nr_bhs >= max_bhs);\n\t\tbhs[nr_bhs++] = bh;\n\t\tBUG_ON((nr_bhs >= max_bhs) && (m_end != block_end));\n\t} while (block_start = block_end, (bh = bh->b_this_page) != head);\n\tif (unlikely(rl))\n\t\tup_read(&NTFS_I(vol->mft_ino)->runlist.lock);\n\tif (!nr_bhs)\n\t\tgoto done;\n\tif (unlikely(err))\n\t\tgoto cleanup_out;\n\t/* Apply the mst protection fixups. */\n\terr = pre_write_mst_fixup((NTFS_RECORD*)m, vol->mft_record_size);\n\tif (err) {\n\t\tntfs_error(vol->sb, \"Failed to apply mst fixups!\");\n\t\tgoto cleanup_out;\n\t}\n\tflush_dcache_mft_record_page(ni);\n\t/* Lock buffers and start synchronous write i/o on them. */\n\tfor (i_bhs = 0; i_bhs < nr_bhs; i_bhs++) {\n\t\tstruct buffer_head *tbh = bhs[i_bhs];\n\n\t\tif (!trylock_buffer(tbh))\n\t\t\tBUG();\n\t\tBUG_ON(!buffer_uptodate(tbh));\n\t\tclear_buffer_dirty(tbh);\n\t\tget_bh(tbh);\n\t\ttbh->b_end_io = end_buffer_write_sync;\n\t\tsubmit_bh(WRITE, tbh);\n\t}\n\t/* Synchronize the mft mirror now if not @sync. */\n\tif (!sync && ni->mft_no < vol->mftmirr_size)\n\t\tntfs_sync_mft_mirror(vol, ni->mft_no, m, sync);\n\t/* Wait on i/o completion of buffers. */\n\tfor (i_bhs = 0; i_bhs < nr_bhs; i_bhs++) {\n\t\tstruct buffer_head *tbh = bhs[i_bhs];\n\n\t\twait_on_buffer(tbh);\n\t\tif (unlikely(!buffer_uptodate(tbh))) {\n\t\t\terr = -EIO;\n\t\t\t/*\n\t\t\t * Set the buffer uptodate so the page and buffer\n\t\t\t * states do not become out of sync.\n\t\t\t */\n\t\t\tif (PageUptodate(page))\n\t\t\t\tset_buffer_uptodate(tbh);\n\t\t}\n\t}\n\t/* If @sync, now synchronize the mft mirror. */\n\tif (sync && ni->mft_no < vol->mftmirr_size)\n\t\tntfs_sync_mft_mirror(vol, ni->mft_no, m, sync);\n\t/* Remove the mst protection fixups again. */\n\tpost_write_mst_fixup((NTFS_RECORD*)m);\n\tflush_dcache_mft_record_page(ni);\n\tif (unlikely(err)) {\n\t\t/* I/O error during writing.  This is really bad! */\n\t\tntfs_error(vol->sb, \"I/O error while writing mft record \"\n\t\t\t\t\"0x%lx!  Marking base inode as bad.  You \"\n\t\t\t\t\"should unmount the volume and run chkdsk.\",\n\t\t\t\tni->mft_no);\n\t\tgoto err_out;\n\t}\ndone:\n\tntfs_debug(\"Done.\");\n\treturn 0;\ncleanup_out:\n\t/* Clean the buffers. */\n\tfor (i_bhs = 0; i_bhs < nr_bhs; i_bhs++)\n\t\tclear_buffer_dirty(bhs[i_bhs]);\nerr_out:\n\t/*\n\t * Current state: all buffers are clean, unlocked, and uptodate.\n\t * The caller should mark the base inode as bad so that no more i/o\n\t * happens.  ->clear_inode() will still be invoked so all extent inodes\n\t * and other allocated memory will be freed.\n\t */\n\tif (err == -ENOMEM) {\n\t\tntfs_error(vol->sb, \"Not enough memory to write mft record.  \"\n\t\t\t\t\"Redirtying so the write is retried later.\");\n\t\tmark_mft_record_dirty(ni);\n\t\terr = 0;\n\t} else\n\t\tNVolSetErrors(vol);\n\treturn err;\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"dir.h\"",
            "#include \"debug.h\"",
            "#include \"bitmap.h\"",
            "#include \"aops.h\"",
            "#include \"attrib.h\"",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"dir.h\"\n#include \"debug.h\"\n#include \"bitmap.h\"\n#include \"aops.h\"\n#include \"attrib.h\"\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n\nint write_mft_record_nolock(ntfs_inode *ni, MFT_RECORD *m, int sync)\n{\n\tntfs_volume *vol = ni->vol;\n\tstruct page *page = ni->page;\n\tunsigned int blocksize = vol->sb->s_blocksize;\n\tunsigned char blocksize_bits = vol->sb->s_blocksize_bits;\n\tint max_bhs = vol->mft_record_size / blocksize;\n\tstruct buffer_head *bhs[max_bhs];\n\tstruct buffer_head *bh, *head;\n\trunlist_element *rl;\n\tunsigned int block_start, block_end, m_start, m_end;\n\tint i_bhs, nr_bhs, err = 0;\n\n\tntfs_debug(\"Entering for inode 0x%lx.\", ni->mft_no);\n\tBUG_ON(NInoAttr(ni));\n\tBUG_ON(!max_bhs);\n\tBUG_ON(!PageLocked(page));\n\t/*\n\t * If the ntfs_inode is clean no need to do anything.  If it is dirty,\n\t * mark it as clean now so that it can be redirtied later on if needed.\n\t * There is no danger of races since the caller is holding the locks\n\t * for the mft record @m and the page it is in.\n\t */\n\tif (!NInoTestClearDirty(ni))\n\t\tgoto done;\n\tbh = head = page_buffers(page);\n\tBUG_ON(!bh);\n\trl = NULL;\n\tnr_bhs = 0;\n\tblock_start = 0;\n\tm_start = ni->page_ofs;\n\tm_end = m_start + vol->mft_record_size;\n\tdo {\n\t\tblock_end = block_start + blocksize;\n\t\t/* If the buffer is outside the mft record, skip it. */\n\t\tif (block_end <= m_start)\n\t\t\tcontinue;\n\t\tif (unlikely(block_start >= m_end))\n\t\t\tbreak;\n\t\t/*\n\t\t * If this block is not the first one in the record, we ignore\n\t\t * the buffer's dirty state because we could have raced with a\n\t\t * parallel mark_ntfs_record_dirty().\n\t\t */\n\t\tif (block_start == m_start) {\n\t\t\t/* This block is the first one in the record. */\n\t\t\tif (!buffer_dirty(bh)) {\n\t\t\t\tBUG_ON(nr_bhs);\n\t\t\t\t/* Clean records are not written out. */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t/* Need to map the buffer if it is not mapped already. */\n\t\tif (unlikely(!buffer_mapped(bh))) {\n\t\t\tVCN vcn;\n\t\t\tLCN lcn;\n\t\t\tunsigned int vcn_ofs;\n\n\t\t\tbh->b_bdev = vol->sb->s_bdev;\n\t\t\t/* Obtain the vcn and offset of the current block. */\n\t\t\tvcn = ((VCN)ni->mft_no << vol->mft_record_size_bits) +\n\t\t\t\t\t(block_start - m_start);\n\t\t\tvcn_ofs = vcn & vol->cluster_size_mask;\n\t\t\tvcn >>= vol->cluster_size_bits;\n\t\t\tif (!rl) {\n\t\t\t\tdown_read(&NTFS_I(vol->mft_ino)->runlist.lock);\n\t\t\t\trl = NTFS_I(vol->mft_ino)->runlist.rl;\n\t\t\t\tBUG_ON(!rl);\n\t\t\t}\n\t\t\t/* Seek to element containing target vcn. */\n\t\t\twhile (rl->length && rl[1].vcn <= vcn)\n\t\t\t\trl++;\n\t\t\tlcn = ntfs_rl_vcn_to_lcn(rl, vcn);\n\t\t\t/* For $MFT, only lcn >= 0 is a successful remap. */\n\t\t\tif (likely(lcn >= 0)) {\n\t\t\t\t/* Setup buffer head to correct block. */\n\t\t\t\tbh->b_blocknr = ((lcn <<\n\t\t\t\t\t\tvol->cluster_size_bits) +\n\t\t\t\t\t\tvcn_ofs) >> blocksize_bits;\n\t\t\t\tset_buffer_mapped(bh);\n\t\t\t} else {\n\t\t\t\tbh->b_blocknr = -1;\n\t\t\t\tntfs_error(vol->sb, \"Cannot write mft record \"\n\t\t\t\t\t\t\"0x%lx because its location \"\n\t\t\t\t\t\t\"on disk could not be \"\n\t\t\t\t\t\t\"determined (error code %lli).\",\n\t\t\t\t\t\tni->mft_no, (long long)lcn);\n\t\t\t\terr = -EIO;\n\t\t\t}\n\t\t}\n\t\tBUG_ON(!buffer_uptodate(bh));\n\t\tBUG_ON(!nr_bhs && (m_start != block_start));\n\t\tBUG_ON(nr_bhs >= max_bhs);\n\t\tbhs[nr_bhs++] = bh;\n\t\tBUG_ON((nr_bhs >= max_bhs) && (m_end != block_end));\n\t} while (block_start = block_end, (bh = bh->b_this_page) != head);\n\tif (unlikely(rl))\n\t\tup_read(&NTFS_I(vol->mft_ino)->runlist.lock);\n\tif (!nr_bhs)\n\t\tgoto done;\n\tif (unlikely(err))\n\t\tgoto cleanup_out;\n\t/* Apply the mst protection fixups. */\n\terr = pre_write_mst_fixup((NTFS_RECORD*)m, vol->mft_record_size);\n\tif (err) {\n\t\tntfs_error(vol->sb, \"Failed to apply mst fixups!\");\n\t\tgoto cleanup_out;\n\t}\n\tflush_dcache_mft_record_page(ni);\n\t/* Lock buffers and start synchronous write i/o on them. */\n\tfor (i_bhs = 0; i_bhs < nr_bhs; i_bhs++) {\n\t\tstruct buffer_head *tbh = bhs[i_bhs];\n\n\t\tif (!trylock_buffer(tbh))\n\t\t\tBUG();\n\t\tBUG_ON(!buffer_uptodate(tbh));\n\t\tclear_buffer_dirty(tbh);\n\t\tget_bh(tbh);\n\t\ttbh->b_end_io = end_buffer_write_sync;\n\t\tsubmit_bh(WRITE, tbh);\n\t}\n\t/* Synchronize the mft mirror now if not @sync. */\n\tif (!sync && ni->mft_no < vol->mftmirr_size)\n\t\tntfs_sync_mft_mirror(vol, ni->mft_no, m, sync);\n\t/* Wait on i/o completion of buffers. */\n\tfor (i_bhs = 0; i_bhs < nr_bhs; i_bhs++) {\n\t\tstruct buffer_head *tbh = bhs[i_bhs];\n\n\t\twait_on_buffer(tbh);\n\t\tif (unlikely(!buffer_uptodate(tbh))) {\n\t\t\terr = -EIO;\n\t\t\t/*\n\t\t\t * Set the buffer uptodate so the page and buffer\n\t\t\t * states do not become out of sync.\n\t\t\t */\n\t\t\tif (PageUptodate(page))\n\t\t\t\tset_buffer_uptodate(tbh);\n\t\t}\n\t}\n\t/* If @sync, now synchronize the mft mirror. */\n\tif (sync && ni->mft_no < vol->mftmirr_size)\n\t\tntfs_sync_mft_mirror(vol, ni->mft_no, m, sync);\n\t/* Remove the mst protection fixups again. */\n\tpost_write_mst_fixup((NTFS_RECORD*)m);\n\tflush_dcache_mft_record_page(ni);\n\tif (unlikely(err)) {\n\t\t/* I/O error during writing.  This is really bad! */\n\t\tntfs_error(vol->sb, \"I/O error while writing mft record \"\n\t\t\t\t\"0x%lx!  Marking base inode as bad.  You \"\n\t\t\t\t\"should unmount the volume and run chkdsk.\",\n\t\t\t\tni->mft_no);\n\t\tgoto err_out;\n\t}\ndone:\n\tntfs_debug(\"Done.\");\n\treturn 0;\ncleanup_out:\n\t/* Clean the buffers. */\n\tfor (i_bhs = 0; i_bhs < nr_bhs; i_bhs++)\n\t\tclear_buffer_dirty(bhs[i_bhs]);\nerr_out:\n\t/*\n\t * Current state: all buffers are clean, unlocked, and uptodate.\n\t * The caller should mark the base inode as bad so that no more i/o\n\t * happens.  ->clear_inode() will still be invoked so all extent inodes\n\t * and other allocated memory will be freed.\n\t */\n\tif (err == -ENOMEM) {\n\t\tntfs_error(vol->sb, \"Not enough memory to write mft record.  \"\n\t\t\t\t\"Redirtying so the write is retried later.\");\n\t\tmark_mft_record_dirty(ni);\n\t\terr = 0;\n\t} else\n\t\tNVolSetErrors(vol);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!page"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"inode.h\"\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/fs.h>\n\nstatic inline int write_mft_record(ntfs_inode *ni, MFT_RECORD *m, int sync)\n{\n\tstruct page *page = ni->page;\n\tint err;\n\n\tBUG_ON(!page);\n\tlock_page(page);\n\terr = write_mft_record_nolock(ni, m, sync);\n\tunlock_page(page);\n\treturn err;\n}"
  },
  {
    "function_name": "mark_mft_record_dirty",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/mft.h",
    "lines": "73-77",
    "snippet": "static inline void mark_mft_record_dirty(ntfs_inode *ni)\n{\n\tif (!NInoTestSetDirty(ni))\n\t\t__mark_mft_record_dirty(ni);\n}",
    "includes": [
      "#include \"inode.h\"",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__mark_mft_record_dirty",
          "args": [
            "ni"
          ],
          "line": 76
        },
        "resolved": true,
        "details": {
          "function_name": "__mark_mft_record_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/mft.c",
          "lines": "395-410",
          "snippet": "void __mark_mft_record_dirty(ntfs_inode *ni)\n{\n\tntfs_inode *base_ni;\n\n\tntfs_debug(\"Entering for inode 0x%lx.\", ni->mft_no);\n\tBUG_ON(NInoAttr(ni));\n\tmark_ntfs_record_dirty(ni->page, ni->page_ofs);\n\t/* Determine the base vfs inode and mark it dirty, too. */\n\tmutex_lock(&ni->extent_lock);\n\tif (likely(ni->nr_extents >= 0))\n\t\tbase_ni = ni;\n\telse\n\t\tbase_ni = ni->ext.base_ntfs_ino;\n\tmutex_unlock(&ni->extent_lock);\n\t__mark_inode_dirty(VFS_I(base_ni), I_DIRTY_SYNC | I_DIRTY_DATASYNC);\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"dir.h\"",
            "#include \"debug.h\"",
            "#include \"bitmap.h\"",
            "#include \"aops.h\"",
            "#include \"attrib.h\"",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"dir.h\"\n#include \"debug.h\"\n#include \"bitmap.h\"\n#include \"aops.h\"\n#include \"attrib.h\"\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n\nvoid __mark_mft_record_dirty(ntfs_inode *ni)\n{\n\tntfs_inode *base_ni;\n\n\tntfs_debug(\"Entering for inode 0x%lx.\", ni->mft_no);\n\tBUG_ON(NInoAttr(ni));\n\tmark_ntfs_record_dirty(ni->page, ni->page_ofs);\n\t/* Determine the base vfs inode and mark it dirty, too. */\n\tmutex_lock(&ni->extent_lock);\n\tif (likely(ni->nr_extents >= 0))\n\t\tbase_ni = ni;\n\telse\n\t\tbase_ni = ni->ext.base_ntfs_ino;\n\tmutex_unlock(&ni->extent_lock);\n\t__mark_inode_dirty(VFS_I(base_ni), I_DIRTY_SYNC | I_DIRTY_DATASYNC);\n}"
        }
      },
      {
        "call_info": {
          "callee": "NInoTestSetDirty",
          "args": [
            "ni"
          ],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"inode.h\"\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/fs.h>\n\nstatic inline void mark_mft_record_dirty(ntfs_inode *ni)\n{\n\tif (!NInoTestSetDirty(ni))\n\t\t__mark_mft_record_dirty(ni);\n}"
  },
  {
    "function_name": "flush_dcache_mft_record_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/mft.h",
    "lines": "55-58",
    "snippet": "static inline void flush_dcache_mft_record_page(ntfs_inode *ni)\n{\n\tflush_dcache_page(ni->page);\n}",
    "includes": [
      "#include \"inode.h\"",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "flush_dcache_page",
          "args": [
            "ni->page"
          ],
          "line": 57
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_index_entry_flush_dcache_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/index.h",
          "lines": "111-117",
          "snippet": "static inline void ntfs_index_entry_flush_dcache_page(ntfs_index_context *ictx)\n{\n\tif (ictx->is_in_root)\n\t\tflush_dcache_mft_record_page(ictx->actx->ntfs_ino);\n\telse\n\t\tflush_dcache_page(ictx->page);\n}",
          "includes": [
            "#include \"aops.h\"",
            "#include \"mft.h\"",
            "#include \"attrib.h\"",
            "#include \"inode.h\"",
            "#include \"layout.h\"",
            "#include \"types.h\"",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"aops.h\"\n#include \"mft.h\"\n#include \"attrib.h\"\n#include \"inode.h\"\n#include \"layout.h\"\n#include \"types.h\"\n#include <linux/fs.h>\n\nstatic inline void ntfs_index_entry_flush_dcache_page(ntfs_index_context *ictx)\n{\n\tif (ictx->is_in_root)\n\t\tflush_dcache_mft_record_page(ictx->actx->ntfs_ino);\n\telse\n\t\tflush_dcache_page(ictx->page);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"inode.h\"\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/fs.h>\n\nstatic inline void flush_dcache_mft_record_page(ntfs_inode *ni)\n{\n\tflush_dcache_page(ni->page);\n}"
  },
  {
    "function_name": "unmap_extent_mft_record",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/mft.h",
    "lines": "38-42",
    "snippet": "static inline void unmap_extent_mft_record(ntfs_inode *ni)\n{\n\tunmap_mft_record(ni);\n\treturn;\n}",
    "includes": [
      "#include \"inode.h\"",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unmap_mft_record",
          "args": [
            "ni"
          ],
          "line": 40
        },
        "resolved": true,
        "details": {
          "function_name": "unmap_mft_record",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/mft.c",
          "lines": "213-231",
          "snippet": "void unmap_mft_record(ntfs_inode *ni)\n{\n\tstruct page *page = ni->page;\n\n\tBUG_ON(!page);\n\n\tntfs_debug(\"Entering for mft_no 0x%lx.\", ni->mft_no);\n\n\tunmap_mft_record_page(ni);\n\tmutex_unlock(&ni->mrec_lock);\n\tatomic_dec(&ni->count);\n\t/*\n\t * If pure ntfs_inode, i.e. no vfs inode attached, we leave it to\n\t * ntfs_clear_extent_inode() in the extent inode case, and to the\n\t * caller in the non-extent, yet pure ntfs inode case, to do the actual\n\t * tear down of all structures and freeing of all allocated memory.\n\t */\n\treturn;\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"dir.h\"",
            "#include \"debug.h\"",
            "#include \"bitmap.h\"",
            "#include \"aops.h\"",
            "#include \"attrib.h\"",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"dir.h\"\n#include \"debug.h\"\n#include \"bitmap.h\"\n#include \"aops.h\"\n#include \"attrib.h\"\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n\nvoid unmap_mft_record(ntfs_inode *ni)\n{\n\tstruct page *page = ni->page;\n\n\tBUG_ON(!page);\n\n\tntfs_debug(\"Entering for mft_no 0x%lx.\", ni->mft_no);\n\n\tunmap_mft_record_page(ni);\n\tmutex_unlock(&ni->mrec_lock);\n\tatomic_dec(&ni->count);\n\t/*\n\t * If pure ntfs_inode, i.e. no vfs inode attached, we leave it to\n\t * ntfs_clear_extent_inode() in the extent inode case, and to the\n\t * caller in the non-extent, yet pure ntfs inode case, to do the actual\n\t * tear down of all structures and freeing of all allocated memory.\n\t */\n\treturn;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"inode.h\"\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/fs.h>\n\nstatic inline void unmap_extent_mft_record(ntfs_inode *ni)\n{\n\tunmap_mft_record(ni);\n\treturn;\n}"
  }
]