[
  {
    "function_name": "proc_readfdinfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/fd.c",
    "lines": "335-339",
    "snippet": "static int proc_readfdinfo(struct file *file, struct dir_context *ctx)\n{\n\treturn proc_readfd_common(file, ctx,\n\t\t\t\t  proc_fdinfo_instantiate);\n}",
    "includes": [
      "#include \"fd.h\"",
      "#include \"internal.h\"",
      "#include \"../mount.h\"",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/file.h>",
      "#include <linux/security.h>",
      "#include <linux/pid.h>",
      "#include <linux/namei.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/path.h>",
      "#include <linux/dcache.h>",
      "#include <linux/errno.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "proc_readfd_common",
          "args": [
            "file",
            "ctx",
            "proc_fdinfo_instantiate"
          ],
          "line": 337
        },
        "resolved": true,
        "details": {
          "function_name": "proc_readfd_common",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/fd.c",
          "lines": "222-262",
          "snippet": "static int proc_readfd_common(struct file *file, struct dir_context *ctx,\n\t\t\t      instantiate_t instantiate)\n{\n\tstruct task_struct *p = get_proc_task(file_inode(file));\n\tstruct files_struct *files;\n\tunsigned int fd;\n\n\tif (!p)\n\t\treturn -ENOENT;\n\n\tif (!dir_emit_dots(file, ctx))\n\t\tgoto out;\n\tfiles = get_files_struct(p);\n\tif (!files)\n\t\tgoto out;\n\n\trcu_read_lock();\n\tfor (fd = ctx->pos - 2;\n\t     fd < files_fdtable(files)->max_fds;\n\t     fd++, ctx->pos++) {\n\t\tchar name[PROC_NUMBUF];\n\t\tint len;\n\n\t\tif (!fcheck_files(files, fd))\n\t\t\tcontinue;\n\t\trcu_read_unlock();\n\n\t\tlen = snprintf(name, sizeof(name), \"%d\", fd);\n\t\tif (!proc_fill_cache(file, ctx,\n\t\t\t\t     name, len, instantiate, p,\n\t\t\t\t     (void *)(unsigned long)fd))\n\t\t\tgoto out_fd_loop;\n\t\trcu_read_lock();\n\t}\n\trcu_read_unlock();\nout_fd_loop:\n\tput_files_struct(files);\nout:\n\tput_task_struct(p);\n\treturn 0;\n}",
          "includes": [
            "#include \"fd.h\"",
            "#include \"internal.h\"",
            "#include \"../mount.h\"",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/file.h>",
            "#include <linux/security.h>",
            "#include <linux/pid.h>",
            "#include <linux/namei.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/path.h>",
            "#include <linux/dcache.h>",
            "#include <linux/errno.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fd.h\"\n#include \"internal.h\"\n#include \"../mount.h\"\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/file.h>\n#include <linux/security.h>\n#include <linux/pid.h>\n#include <linux/namei.h>\n#include <linux/fdtable.h>\n#include <linux/path.h>\n#include <linux/dcache.h>\n#include <linux/errno.h>\n#include <linux/sched.h>\n\nstatic int proc_readfd_common(struct file *file, struct dir_context *ctx,\n\t\t\t      instantiate_t instantiate)\n{\n\tstruct task_struct *p = get_proc_task(file_inode(file));\n\tstruct files_struct *files;\n\tunsigned int fd;\n\n\tif (!p)\n\t\treturn -ENOENT;\n\n\tif (!dir_emit_dots(file, ctx))\n\t\tgoto out;\n\tfiles = get_files_struct(p);\n\tif (!files)\n\t\tgoto out;\n\n\trcu_read_lock();\n\tfor (fd = ctx->pos - 2;\n\t     fd < files_fdtable(files)->max_fds;\n\t     fd++, ctx->pos++) {\n\t\tchar name[PROC_NUMBUF];\n\t\tint len;\n\n\t\tif (!fcheck_files(files, fd))\n\t\t\tcontinue;\n\t\trcu_read_unlock();\n\n\t\tlen = snprintf(name, sizeof(name), \"%d\", fd);\n\t\tif (!proc_fill_cache(file, ctx,\n\t\t\t\t     name, len, instantiate, p,\n\t\t\t\t     (void *)(unsigned long)fd))\n\t\t\tgoto out_fd_loop;\n\t\trcu_read_lock();\n\t}\n\trcu_read_unlock();\nout_fd_loop:\n\tput_files_struct(files);\nout:\n\tput_task_struct(p);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fd.h\"\n#include \"internal.h\"\n#include \"../mount.h\"\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/file.h>\n#include <linux/security.h>\n#include <linux/pid.h>\n#include <linux/namei.h>\n#include <linux/fdtable.h>\n#include <linux/path.h>\n#include <linux/dcache.h>\n#include <linux/errno.h>\n#include <linux/sched.h>\n\nstatic int proc_readfdinfo(struct file *file, struct dir_context *ctx)\n{\n\treturn proc_readfd_common(file, ctx,\n\t\t\t\t  proc_fdinfo_instantiate);\n}"
  },
  {
    "function_name": "proc_lookupfdinfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/fd.c",
    "lines": "329-333",
    "snippet": "static struct dentry *\nproc_lookupfdinfo(struct inode *dir, struct dentry *dentry, unsigned int flags)\n{\n\treturn proc_lookupfd_common(dir, dentry, proc_fdinfo_instantiate);\n}",
    "includes": [
      "#include \"fd.h\"",
      "#include \"internal.h\"",
      "#include \"../mount.h\"",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/file.h>",
      "#include <linux/security.h>",
      "#include <linux/pid.h>",
      "#include <linux/namei.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/path.h>",
      "#include <linux/dcache.h>",
      "#include <linux/errno.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "proc_lookupfd_common",
          "args": [
            "dir",
            "dentry",
            "proc_fdinfo_instantiate"
          ],
          "line": 332
        },
        "resolved": true,
        "details": {
          "function_name": "proc_lookupfd_common",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/fd.c",
          "lines": "202-220",
          "snippet": "static struct dentry *proc_lookupfd_common(struct inode *dir,\n\t\t\t\t\t   struct dentry *dentry,\n\t\t\t\t\t   instantiate_t instantiate)\n{\n\tstruct task_struct *task = get_proc_task(dir);\n\tint result = -ENOENT;\n\tunsigned fd = name_to_int(&dentry->d_name);\n\n\tif (!task)\n\t\tgoto out_no_task;\n\tif (fd == ~0U)\n\t\tgoto out;\n\n\tresult = instantiate(dir, dentry, task, (void *)(unsigned long)fd);\nout:\n\tput_task_struct(task);\nout_no_task:\n\treturn ERR_PTR(result);\n}",
          "includes": [
            "#include \"fd.h\"",
            "#include \"internal.h\"",
            "#include \"../mount.h\"",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/file.h>",
            "#include <linux/security.h>",
            "#include <linux/pid.h>",
            "#include <linux/namei.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/path.h>",
            "#include <linux/dcache.h>",
            "#include <linux/errno.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fd.h\"\n#include \"internal.h\"\n#include \"../mount.h\"\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/file.h>\n#include <linux/security.h>\n#include <linux/pid.h>\n#include <linux/namei.h>\n#include <linux/fdtable.h>\n#include <linux/path.h>\n#include <linux/dcache.h>\n#include <linux/errno.h>\n#include <linux/sched.h>\n\nstatic struct dentry *proc_lookupfd_common(struct inode *dir,\n\t\t\t\t\t   struct dentry *dentry,\n\t\t\t\t\t   instantiate_t instantiate)\n{\n\tstruct task_struct *task = get_proc_task(dir);\n\tint result = -ENOENT;\n\tunsigned fd = name_to_int(&dentry->d_name);\n\n\tif (!task)\n\t\tgoto out_no_task;\n\tif (fd == ~0U)\n\t\tgoto out;\n\n\tresult = instantiate(dir, dentry, task, (void *)(unsigned long)fd);\nout:\n\tput_task_struct(task);\nout_no_task:\n\treturn ERR_PTR(result);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fd.h\"\n#include \"internal.h\"\n#include \"../mount.h\"\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/file.h>\n#include <linux/security.h>\n#include <linux/pid.h>\n#include <linux/namei.h>\n#include <linux/fdtable.h>\n#include <linux/path.h>\n#include <linux/dcache.h>\n#include <linux/errno.h>\n#include <linux/sched.h>\n\nstatic struct dentry *\nproc_lookupfdinfo(struct inode *dir, struct dentry *dentry, unsigned int flags)\n{\n\treturn proc_lookupfd_common(dir, dentry, proc_fdinfo_instantiate);\n}"
  },
  {
    "function_name": "proc_fdinfo_instantiate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/fd.c",
    "lines": "301-327",
    "snippet": "static int\nproc_fdinfo_instantiate(struct inode *dir, struct dentry *dentry,\n\t\t\tstruct task_struct *task, const void *ptr)\n{\n\tunsigned fd = (unsigned long)ptr;\n\tstruct proc_inode *ei;\n\tstruct inode *inode;\n\n\tinode = proc_pid_make_inode(dir->i_sb, task);\n\tif (!inode)\n\t\tgoto out;\n\n\tei = PROC_I(inode);\n\tei->fd = fd;\n\n\tinode->i_mode = S_IFREG | S_IRUSR;\n\tinode->i_fop = &proc_fdinfo_file_operations;\n\n\td_set_d_op(dentry, &tid_fd_dentry_operations);\n\td_add(dentry, inode);\n\n\t/* Close the race of the process dying before we return the dentry */\n\tif (tid_fd_revalidate(dentry, 0))\n\t\treturn 0;\n out:\n\treturn -ENOENT;\n}",
    "includes": [
      "#include \"fd.h\"",
      "#include \"internal.h\"",
      "#include \"../mount.h\"",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/file.h>",
      "#include <linux/security.h>",
      "#include <linux/pid.h>",
      "#include <linux/namei.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/path.h>",
      "#include <linux/dcache.h>",
      "#include <linux/errno.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct file_operations proc_fdinfo_file_operations = {\n\t.open\t\t= seq_fdinfo_open,\n\t.read\t\t= seq_read,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= single_release,\n};",
      "static const struct dentry_operations tid_fd_dentry_operations = {\n\t.d_revalidate\t= tid_fd_revalidate,\n\t.d_delete\t= pid_delete_dentry,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "tid_fd_revalidate",
          "args": [
            "dentry",
            "0"
          ],
          "line": 323
        },
        "resolved": true,
        "details": {
          "function_name": "tid_fd_revalidate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/fd.c",
          "lines": "76-134",
          "snippet": "static int tid_fd_revalidate(struct dentry *dentry, unsigned int flags)\n{\n\tstruct files_struct *files;\n\tstruct task_struct *task;\n\tconst struct cred *cred;\n\tstruct inode *inode;\n\tint fd;\n\n\tif (flags & LOOKUP_RCU)\n\t\treturn -ECHILD;\n\n\tinode = dentry->d_inode;\n\ttask = get_proc_task(inode);\n\tfd = proc_fd(inode);\n\n\tif (task) {\n\t\tfiles = get_files_struct(task);\n\t\tif (files) {\n\t\t\tstruct file *file;\n\n\t\t\trcu_read_lock();\n\t\t\tfile = fcheck_files(files, fd);\n\t\t\tif (file) {\n\t\t\t\tunsigned f_mode = file->f_mode;\n\n\t\t\t\trcu_read_unlock();\n\t\t\t\tput_files_struct(files);\n\n\t\t\t\tif (task_dumpable(task)) {\n\t\t\t\t\trcu_read_lock();\n\t\t\t\t\tcred = __task_cred(task);\n\t\t\t\t\tinode->i_uid = cred->euid;\n\t\t\t\t\tinode->i_gid = cred->egid;\n\t\t\t\t\trcu_read_unlock();\n\t\t\t\t} else {\n\t\t\t\t\tinode->i_uid = GLOBAL_ROOT_UID;\n\t\t\t\t\tinode->i_gid = GLOBAL_ROOT_GID;\n\t\t\t\t}\n\n\t\t\t\tif (S_ISLNK(inode->i_mode)) {\n\t\t\t\t\tunsigned i_mode = S_IFLNK;\n\t\t\t\t\tif (f_mode & FMODE_READ)\n\t\t\t\t\t\ti_mode |= S_IRUSR | S_IXUSR;\n\t\t\t\t\tif (f_mode & FMODE_WRITE)\n\t\t\t\t\t\ti_mode |= S_IWUSR | S_IXUSR;\n\t\t\t\t\tinode->i_mode = i_mode;\n\t\t\t\t}\n\n\t\t\t\tsecurity_task_to_inode(task, inode);\n\t\t\t\tput_task_struct(task);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\trcu_read_unlock();\n\t\t\tput_files_struct(files);\n\t\t}\n\t\tput_task_struct(task);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"fd.h\"",
            "#include \"internal.h\"",
            "#include \"../mount.h\"",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/file.h>",
            "#include <linux/security.h>",
            "#include <linux/pid.h>",
            "#include <linux/namei.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/path.h>",
            "#include <linux/dcache.h>",
            "#include <linux/errno.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fd.h\"\n#include \"internal.h\"\n#include \"../mount.h\"\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/file.h>\n#include <linux/security.h>\n#include <linux/pid.h>\n#include <linux/namei.h>\n#include <linux/fdtable.h>\n#include <linux/path.h>\n#include <linux/dcache.h>\n#include <linux/errno.h>\n#include <linux/sched.h>\n\nstatic int tid_fd_revalidate(struct dentry *dentry, unsigned int flags)\n{\n\tstruct files_struct *files;\n\tstruct task_struct *task;\n\tconst struct cred *cred;\n\tstruct inode *inode;\n\tint fd;\n\n\tif (flags & LOOKUP_RCU)\n\t\treturn -ECHILD;\n\n\tinode = dentry->d_inode;\n\ttask = get_proc_task(inode);\n\tfd = proc_fd(inode);\n\n\tif (task) {\n\t\tfiles = get_files_struct(task);\n\t\tif (files) {\n\t\t\tstruct file *file;\n\n\t\t\trcu_read_lock();\n\t\t\tfile = fcheck_files(files, fd);\n\t\t\tif (file) {\n\t\t\t\tunsigned f_mode = file->f_mode;\n\n\t\t\t\trcu_read_unlock();\n\t\t\t\tput_files_struct(files);\n\n\t\t\t\tif (task_dumpable(task)) {\n\t\t\t\t\trcu_read_lock();\n\t\t\t\t\tcred = __task_cred(task);\n\t\t\t\t\tinode->i_uid = cred->euid;\n\t\t\t\t\tinode->i_gid = cred->egid;\n\t\t\t\t\trcu_read_unlock();\n\t\t\t\t} else {\n\t\t\t\t\tinode->i_uid = GLOBAL_ROOT_UID;\n\t\t\t\t\tinode->i_gid = GLOBAL_ROOT_GID;\n\t\t\t\t}\n\n\t\t\t\tif (S_ISLNK(inode->i_mode)) {\n\t\t\t\t\tunsigned i_mode = S_IFLNK;\n\t\t\t\t\tif (f_mode & FMODE_READ)\n\t\t\t\t\t\ti_mode |= S_IRUSR | S_IXUSR;\n\t\t\t\t\tif (f_mode & FMODE_WRITE)\n\t\t\t\t\t\ti_mode |= S_IWUSR | S_IXUSR;\n\t\t\t\t\tinode->i_mode = i_mode;\n\t\t\t\t}\n\n\t\t\t\tsecurity_task_to_inode(task, inode);\n\t\t\t\tput_task_struct(task);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\trcu_read_unlock();\n\t\t\tput_files_struct(files);\n\t\t}\n\t\tput_task_struct(task);\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_add",
          "args": [
            "dentry",
            "inode"
          ],
          "line": 320
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_fid_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/fid.c",
          "lines": "49-54",
          "snippet": "void v9fs_fid_add(struct dentry *dentry, struct p9_fid *fid)\n{\n\tspin_lock(&dentry->d_lock);\n\t__add_fid(dentry, fid);\n\tspin_unlock(&dentry->d_lock);\n}",
          "includes": [
            "#include \"fid.h\"",
            "#include \"v9fs_vfs.h\"",
            "#include \"v9fs.h\"",
            "#include <net/9p/client.h>",
            "#include <net/9p/9p.h>",
            "#include <linux/idr.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/idr.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nvoid v9fs_fid_add(struct dentry *dentry, struct p9_fid *fid)\n{\n\tspin_lock(&dentry->d_lock);\n\t__add_fid(dentry, fid);\n\tspin_unlock(&dentry->d_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_set_d_op",
          "args": [
            "dentry",
            "&tid_fd_dentry_operations"
          ],
          "line": 319
        },
        "resolved": true,
        "details": {
          "function_name": "d_set_d_op",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1635-1659",
          "snippet": "void d_set_d_op(struct dentry *dentry, const struct dentry_operations *op)\n{\n\tWARN_ON_ONCE(dentry->d_op);\n\tWARN_ON_ONCE(dentry->d_flags & (DCACHE_OP_HASH\t|\n\t\t\t\tDCACHE_OP_COMPARE\t|\n\t\t\t\tDCACHE_OP_REVALIDATE\t|\n\t\t\t\tDCACHE_OP_WEAK_REVALIDATE\t|\n\t\t\t\tDCACHE_OP_DELETE ));\n\tdentry->d_op = op;\n\tif (!op)\n\t\treturn;\n\tif (op->d_hash)\n\t\tdentry->d_flags |= DCACHE_OP_HASH;\n\tif (op->d_compare)\n\t\tdentry->d_flags |= DCACHE_OP_COMPARE;\n\tif (op->d_revalidate)\n\t\tdentry->d_flags |= DCACHE_OP_REVALIDATE;\n\tif (op->d_weak_revalidate)\n\t\tdentry->d_flags |= DCACHE_OP_WEAK_REVALIDATE;\n\tif (op->d_delete)\n\t\tdentry->d_flags |= DCACHE_OP_DELETE;\n\tif (op->d_prune)\n\t\tdentry->d_flags |= DCACHE_OP_PRUNE;\n\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid d_set_d_op(struct dentry *dentry, const struct dentry_operations *op)\n{\n\tWARN_ON_ONCE(dentry->d_op);\n\tWARN_ON_ONCE(dentry->d_flags & (DCACHE_OP_HASH\t|\n\t\t\t\tDCACHE_OP_COMPARE\t|\n\t\t\t\tDCACHE_OP_REVALIDATE\t|\n\t\t\t\tDCACHE_OP_WEAK_REVALIDATE\t|\n\t\t\t\tDCACHE_OP_DELETE ));\n\tdentry->d_op = op;\n\tif (!op)\n\t\treturn;\n\tif (op->d_hash)\n\t\tdentry->d_flags |= DCACHE_OP_HASH;\n\tif (op->d_compare)\n\t\tdentry->d_flags |= DCACHE_OP_COMPARE;\n\tif (op->d_revalidate)\n\t\tdentry->d_flags |= DCACHE_OP_REVALIDATE;\n\tif (op->d_weak_revalidate)\n\t\tdentry->d_flags |= DCACHE_OP_WEAK_REVALIDATE;\n\tif (op->d_delete)\n\t\tdentry->d_flags |= DCACHE_OP_DELETE;\n\tif (op->d_prune)\n\t\tdentry->d_flags |= DCACHE_OP_PRUNE;\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "PROC_I",
          "args": [
            "inode"
          ],
          "line": 313
        },
        "resolved": true,
        "details": {
          "function_name": "PROC_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/internal.h",
          "lines": "75-78",
          "snippet": "static inline struct proc_inode *PROC_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct proc_inode, vfs_inode);\n}",
          "includes": [
            "#include <linux/binfmts.h>",
            "#include <linux/atomic.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/binfmts.h>\n#include <linux/atomic.h>\n#include <linux/spinlock.h>\n#include <linux/proc_ns.h>\n#include <linux/proc_fs.h>\n\nstatic inline struct proc_inode *PROC_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct proc_inode, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "proc_pid_make_inode",
          "args": [
            "dir->i_sb",
            "task"
          ],
          "line": 309
        },
        "resolved": true,
        "details": {
          "function_name": "proc_pid_make_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/base.c",
          "lines": "1447-1487",
          "snippet": "struct inode *proc_pid_make_inode(struct super_block * sb, struct task_struct *task)\n{\n\tstruct inode * inode;\n\tstruct proc_inode *ei;\n\tconst struct cred *cred;\n\n\t/* We need a new inode */\n\n\tinode = new_inode(sb);\n\tif (!inode)\n\t\tgoto out;\n\n\t/* Common stuff */\n\tei = PROC_I(inode);\n\tinode->i_ino = get_next_ino();\n\tinode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME;\n\tinode->i_op = &proc_def_inode_operations;\n\n\t/*\n\t * grab the reference to task.\n\t */\n\tei->pid = get_task_pid(task, PIDTYPE_PID);\n\tif (!ei->pid)\n\t\tgoto out_unlock;\n\n\tif (task_dumpable(task)) {\n\t\trcu_read_lock();\n\t\tcred = __task_cred(task);\n\t\tinode->i_uid = cred->euid;\n\t\tinode->i_gid = cred->egid;\n\t\trcu_read_unlock();\n\t}\n\tsecurity_task_to_inode(task, inode);\n\nout:\n\treturn inode;\n\nout_unlock:\n\tiput(inode);\n\treturn NULL;\n}",
          "includes": [
            "#include \"fd.h\"",
            "#include \"internal.h\"",
            "#include <trace/events/oom.h>",
            "#include <asm/hardwall.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/flex_array.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/elf.h>",
            "#include <linux/oom.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/poll.h>",
            "#include <linux/audit.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/printk.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/module.h>",
            "#include <linux/resource.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/namei.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/string.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/stat.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <asm/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct inode_operations proc_def_inode_operations = {\n\t.setattr\t= proc_setattr,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"fd.h\"\n#include \"internal.h\"\n#include <trace/events/oom.h>\n#include <asm/hardwall.h>\n#include <linux/posix-timers.h>\n#include <linux/flex_array.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/elf.h>\n#include <linux/oom.h>\n#include <linux/nsproxy.h>\n#include <linux/poll.h>\n#include <linux/audit.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/printk.h>\n#include <linux/tracehook.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/resource.h>\n#include <linux/stacktrace.h>\n#include <linux/kallsyms.h>\n#include <linux/rcupdate.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/mnt_namespace.h>\n#include <linux/namei.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\nstatic const struct inode_operations proc_def_inode_operations = {\n\t.setattr\t= proc_setattr,\n};\n\nstruct inode *proc_pid_make_inode(struct super_block * sb, struct task_struct *task)\n{\n\tstruct inode * inode;\n\tstruct proc_inode *ei;\n\tconst struct cred *cred;\n\n\t/* We need a new inode */\n\n\tinode = new_inode(sb);\n\tif (!inode)\n\t\tgoto out;\n\n\t/* Common stuff */\n\tei = PROC_I(inode);\n\tinode->i_ino = get_next_ino();\n\tinode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME;\n\tinode->i_op = &proc_def_inode_operations;\n\n\t/*\n\t * grab the reference to task.\n\t */\n\tei->pid = get_task_pid(task, PIDTYPE_PID);\n\tif (!ei->pid)\n\t\tgoto out_unlock;\n\n\tif (task_dumpable(task)) {\n\t\trcu_read_lock();\n\t\tcred = __task_cred(task);\n\t\tinode->i_uid = cred->euid;\n\t\tinode->i_gid = cred->egid;\n\t\trcu_read_unlock();\n\t}\n\tsecurity_task_to_inode(task, inode);\n\nout:\n\treturn inode;\n\nout_unlock:\n\tiput(inode);\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fd.h\"\n#include \"internal.h\"\n#include \"../mount.h\"\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/file.h>\n#include <linux/security.h>\n#include <linux/pid.h>\n#include <linux/namei.h>\n#include <linux/fdtable.h>\n#include <linux/path.h>\n#include <linux/dcache.h>\n#include <linux/errno.h>\n#include <linux/sched.h>\n\nstatic const struct file_operations proc_fdinfo_file_operations = {\n\t.open\t\t= seq_fdinfo_open,\n\t.read\t\t= seq_read,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= single_release,\n};\nstatic const struct dentry_operations tid_fd_dentry_operations = {\n\t.d_revalidate\t= tid_fd_revalidate,\n\t.d_delete\t= pid_delete_dentry,\n};\n\nstatic int\nproc_fdinfo_instantiate(struct inode *dir, struct dentry *dentry,\n\t\t\tstruct task_struct *task, const void *ptr)\n{\n\tunsigned fd = (unsigned long)ptr;\n\tstruct proc_inode *ei;\n\tstruct inode *inode;\n\n\tinode = proc_pid_make_inode(dir->i_sb, task);\n\tif (!inode)\n\t\tgoto out;\n\n\tei = PROC_I(inode);\n\tei->fd = fd;\n\n\tinode->i_mode = S_IFREG | S_IRUSR;\n\tinode->i_fop = &proc_fdinfo_file_operations;\n\n\td_set_d_op(dentry, &tid_fd_dentry_operations);\n\td_add(dentry, inode);\n\n\t/* Close the race of the process dying before we return the dentry */\n\tif (tid_fd_revalidate(dentry, 0))\n\t\treturn 0;\n out:\n\treturn -ENOENT;\n}"
  },
  {
    "function_name": "proc_fd_permission",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/fd.c",
    "lines": "285-293",
    "snippet": "int proc_fd_permission(struct inode *inode, int mask)\n{\n\tint rv = generic_permission(inode, mask);\n\tif (rv == 0)\n\t\treturn 0;\n\tif (task_tgid(current) == proc_pid(inode))\n\t\trv = 0;\n\treturn rv;\n}",
    "includes": [
      "#include \"fd.h\"",
      "#include \"internal.h\"",
      "#include \"../mount.h\"",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/file.h>",
      "#include <linux/security.h>",
      "#include <linux/pid.h>",
      "#include <linux/namei.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/path.h>",
      "#include <linux/dcache.h>",
      "#include <linux/errno.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "proc_pid",
          "args": [
            "inode"
          ],
          "line": 290
        },
        "resolved": true,
        "details": {
          "function_name": "proc_pid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/internal.h",
          "lines": "90-93",
          "snippet": "static inline struct pid *proc_pid(struct inode *inode)\n{\n\treturn PROC_I(inode)->pid;\n}",
          "includes": [
            "#include <linux/binfmts.h>",
            "#include <linux/atomic.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/binfmts.h>\n#include <linux/atomic.h>\n#include <linux/spinlock.h>\n#include <linux/proc_ns.h>\n#include <linux/proc_fs.h>\n\nstatic inline struct pid *proc_pid(struct inode *inode)\n{\n\treturn PROC_I(inode)->pid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_tgid",
          "args": [
            "current"
          ],
          "line": 290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "generic_permission",
          "args": [
            "inode",
            "mask"
          ],
          "line": 287
        },
        "resolved": true,
        "details": {
          "function_name": "generic_permission",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "329-368",
          "snippet": "int generic_permission(struct inode *inode, int mask)\n{\n\tint ret;\n\n\t/*\n\t * Do the basic permission checks.\n\t */\n\tret = acl_permission_check(inode, mask);\n\tif (ret != -EACCES)\n\t\treturn ret;\n\n\tif (S_ISDIR(inode->i_mode)) {\n\t\t/* DACs are overridable for directories */\n\t\tif (capable_wrt_inode_uidgid(inode, CAP_DAC_OVERRIDE))\n\t\t\treturn 0;\n\t\tif (!(mask & MAY_WRITE))\n\t\t\tif (capable_wrt_inode_uidgid(inode,\n\t\t\t\t\t\t     CAP_DAC_READ_SEARCH))\n\t\t\t\treturn 0;\n\t\treturn -EACCES;\n\t}\n\t/*\n\t * Read/write DACs are always overridable.\n\t * Executable DACs are overridable when there is\n\t * at least one exec bit set.\n\t */\n\tif (!(mask & MAY_EXEC) || (inode->i_mode & S_IXUGO))\n\t\tif (capable_wrt_inode_uidgid(inode, CAP_DAC_OVERRIDE))\n\t\t\treturn 0;\n\n\t/*\n\t * Searching includes executable on directories, else just read.\n\t */\n\tmask &= MAY_READ | MAY_WRITE | MAY_EXEC;\n\tif (mask == MAY_READ)\n\t\tif (capable_wrt_inode_uidgid(inode, CAP_DAC_READ_SEARCH))\n\t\t\treturn 0;\n\n\treturn -EACCES;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nint generic_permission(struct inode *inode, int mask)\n{\n\tint ret;\n\n\t/*\n\t * Do the basic permission checks.\n\t */\n\tret = acl_permission_check(inode, mask);\n\tif (ret != -EACCES)\n\t\treturn ret;\n\n\tif (S_ISDIR(inode->i_mode)) {\n\t\t/* DACs are overridable for directories */\n\t\tif (capable_wrt_inode_uidgid(inode, CAP_DAC_OVERRIDE))\n\t\t\treturn 0;\n\t\tif (!(mask & MAY_WRITE))\n\t\t\tif (capable_wrt_inode_uidgid(inode,\n\t\t\t\t\t\t     CAP_DAC_READ_SEARCH))\n\t\t\t\treturn 0;\n\t\treturn -EACCES;\n\t}\n\t/*\n\t * Read/write DACs are always overridable.\n\t * Executable DACs are overridable when there is\n\t * at least one exec bit set.\n\t */\n\tif (!(mask & MAY_EXEC) || (inode->i_mode & S_IXUGO))\n\t\tif (capable_wrt_inode_uidgid(inode, CAP_DAC_OVERRIDE))\n\t\t\treturn 0;\n\n\t/*\n\t * Searching includes executable on directories, else just read.\n\t */\n\tmask &= MAY_READ | MAY_WRITE | MAY_EXEC;\n\tif (mask == MAY_READ)\n\t\tif (capable_wrt_inode_uidgid(inode, CAP_DAC_READ_SEARCH))\n\t\t\treturn 0;\n\n\treturn -EACCES;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fd.h\"\n#include \"internal.h\"\n#include \"../mount.h\"\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/file.h>\n#include <linux/security.h>\n#include <linux/pid.h>\n#include <linux/namei.h>\n#include <linux/fdtable.h>\n#include <linux/path.h>\n#include <linux/dcache.h>\n#include <linux/errno.h>\n#include <linux/sched.h>\n\nint proc_fd_permission(struct inode *inode, int mask)\n{\n\tint rv = generic_permission(inode, mask);\n\tif (rv == 0)\n\t\treturn 0;\n\tif (task_tgid(current) == proc_pid(inode))\n\t\trv = 0;\n\treturn rv;\n}"
  },
  {
    "function_name": "proc_lookupfd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/fd.c",
    "lines": "275-279",
    "snippet": "static struct dentry *proc_lookupfd(struct inode *dir, struct dentry *dentry,\n\t\t\t\t    unsigned int flags)\n{\n\treturn proc_lookupfd_common(dir, dentry, proc_fd_instantiate);\n}",
    "includes": [
      "#include \"fd.h\"",
      "#include \"internal.h\"",
      "#include \"../mount.h\"",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/file.h>",
      "#include <linux/security.h>",
      "#include <linux/pid.h>",
      "#include <linux/namei.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/path.h>",
      "#include <linux/dcache.h>",
      "#include <linux/errno.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "proc_lookupfd_common",
          "args": [
            "dir",
            "dentry",
            "proc_fd_instantiate"
          ],
          "line": 278
        },
        "resolved": true,
        "details": {
          "function_name": "proc_lookupfd_common",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/fd.c",
          "lines": "202-220",
          "snippet": "static struct dentry *proc_lookupfd_common(struct inode *dir,\n\t\t\t\t\t   struct dentry *dentry,\n\t\t\t\t\t   instantiate_t instantiate)\n{\n\tstruct task_struct *task = get_proc_task(dir);\n\tint result = -ENOENT;\n\tunsigned fd = name_to_int(&dentry->d_name);\n\n\tif (!task)\n\t\tgoto out_no_task;\n\tif (fd == ~0U)\n\t\tgoto out;\n\n\tresult = instantiate(dir, dentry, task, (void *)(unsigned long)fd);\nout:\n\tput_task_struct(task);\nout_no_task:\n\treturn ERR_PTR(result);\n}",
          "includes": [
            "#include \"fd.h\"",
            "#include \"internal.h\"",
            "#include \"../mount.h\"",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/file.h>",
            "#include <linux/security.h>",
            "#include <linux/pid.h>",
            "#include <linux/namei.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/path.h>",
            "#include <linux/dcache.h>",
            "#include <linux/errno.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fd.h\"\n#include \"internal.h\"\n#include \"../mount.h\"\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/file.h>\n#include <linux/security.h>\n#include <linux/pid.h>\n#include <linux/namei.h>\n#include <linux/fdtable.h>\n#include <linux/path.h>\n#include <linux/dcache.h>\n#include <linux/errno.h>\n#include <linux/sched.h>\n\nstatic struct dentry *proc_lookupfd_common(struct inode *dir,\n\t\t\t\t\t   struct dentry *dentry,\n\t\t\t\t\t   instantiate_t instantiate)\n{\n\tstruct task_struct *task = get_proc_task(dir);\n\tint result = -ENOENT;\n\tunsigned fd = name_to_int(&dentry->d_name);\n\n\tif (!task)\n\t\tgoto out_no_task;\n\tif (fd == ~0U)\n\t\tgoto out;\n\n\tresult = instantiate(dir, dentry, task, (void *)(unsigned long)fd);\nout:\n\tput_task_struct(task);\nout_no_task:\n\treturn ERR_PTR(result);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fd.h\"\n#include \"internal.h\"\n#include \"../mount.h\"\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/file.h>\n#include <linux/security.h>\n#include <linux/pid.h>\n#include <linux/namei.h>\n#include <linux/fdtable.h>\n#include <linux/path.h>\n#include <linux/dcache.h>\n#include <linux/errno.h>\n#include <linux/sched.h>\n\nstatic struct dentry *proc_lookupfd(struct inode *dir, struct dentry *dentry,\n\t\t\t\t    unsigned int flags)\n{\n\treturn proc_lookupfd_common(dir, dentry, proc_fd_instantiate);\n}"
  },
  {
    "function_name": "proc_readfd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/fd.c",
    "lines": "264-267",
    "snippet": "static int proc_readfd(struct file *file, struct dir_context *ctx)\n{\n\treturn proc_readfd_common(file, ctx, proc_fd_instantiate);\n}",
    "includes": [
      "#include \"fd.h\"",
      "#include \"internal.h\"",
      "#include \"../mount.h\"",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/file.h>",
      "#include <linux/security.h>",
      "#include <linux/pid.h>",
      "#include <linux/namei.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/path.h>",
      "#include <linux/dcache.h>",
      "#include <linux/errno.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "proc_readfd_common",
          "args": [
            "file",
            "ctx",
            "proc_fd_instantiate"
          ],
          "line": 266
        },
        "resolved": true,
        "details": {
          "function_name": "proc_readfd_common",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/fd.c",
          "lines": "222-262",
          "snippet": "static int proc_readfd_common(struct file *file, struct dir_context *ctx,\n\t\t\t      instantiate_t instantiate)\n{\n\tstruct task_struct *p = get_proc_task(file_inode(file));\n\tstruct files_struct *files;\n\tunsigned int fd;\n\n\tif (!p)\n\t\treturn -ENOENT;\n\n\tif (!dir_emit_dots(file, ctx))\n\t\tgoto out;\n\tfiles = get_files_struct(p);\n\tif (!files)\n\t\tgoto out;\n\n\trcu_read_lock();\n\tfor (fd = ctx->pos - 2;\n\t     fd < files_fdtable(files)->max_fds;\n\t     fd++, ctx->pos++) {\n\t\tchar name[PROC_NUMBUF];\n\t\tint len;\n\n\t\tif (!fcheck_files(files, fd))\n\t\t\tcontinue;\n\t\trcu_read_unlock();\n\n\t\tlen = snprintf(name, sizeof(name), \"%d\", fd);\n\t\tif (!proc_fill_cache(file, ctx,\n\t\t\t\t     name, len, instantiate, p,\n\t\t\t\t     (void *)(unsigned long)fd))\n\t\t\tgoto out_fd_loop;\n\t\trcu_read_lock();\n\t}\n\trcu_read_unlock();\nout_fd_loop:\n\tput_files_struct(files);\nout:\n\tput_task_struct(p);\n\treturn 0;\n}",
          "includes": [
            "#include \"fd.h\"",
            "#include \"internal.h\"",
            "#include \"../mount.h\"",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/file.h>",
            "#include <linux/security.h>",
            "#include <linux/pid.h>",
            "#include <linux/namei.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/path.h>",
            "#include <linux/dcache.h>",
            "#include <linux/errno.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fd.h\"\n#include \"internal.h\"\n#include \"../mount.h\"\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/file.h>\n#include <linux/security.h>\n#include <linux/pid.h>\n#include <linux/namei.h>\n#include <linux/fdtable.h>\n#include <linux/path.h>\n#include <linux/dcache.h>\n#include <linux/errno.h>\n#include <linux/sched.h>\n\nstatic int proc_readfd_common(struct file *file, struct dir_context *ctx,\n\t\t\t      instantiate_t instantiate)\n{\n\tstruct task_struct *p = get_proc_task(file_inode(file));\n\tstruct files_struct *files;\n\tunsigned int fd;\n\n\tif (!p)\n\t\treturn -ENOENT;\n\n\tif (!dir_emit_dots(file, ctx))\n\t\tgoto out;\n\tfiles = get_files_struct(p);\n\tif (!files)\n\t\tgoto out;\n\n\trcu_read_lock();\n\tfor (fd = ctx->pos - 2;\n\t     fd < files_fdtable(files)->max_fds;\n\t     fd++, ctx->pos++) {\n\t\tchar name[PROC_NUMBUF];\n\t\tint len;\n\n\t\tif (!fcheck_files(files, fd))\n\t\t\tcontinue;\n\t\trcu_read_unlock();\n\n\t\tlen = snprintf(name, sizeof(name), \"%d\", fd);\n\t\tif (!proc_fill_cache(file, ctx,\n\t\t\t\t     name, len, instantiate, p,\n\t\t\t\t     (void *)(unsigned long)fd))\n\t\t\tgoto out_fd_loop;\n\t\trcu_read_lock();\n\t}\n\trcu_read_unlock();\nout_fd_loop:\n\tput_files_struct(files);\nout:\n\tput_task_struct(p);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fd.h\"\n#include \"internal.h\"\n#include \"../mount.h\"\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/file.h>\n#include <linux/security.h>\n#include <linux/pid.h>\n#include <linux/namei.h>\n#include <linux/fdtable.h>\n#include <linux/path.h>\n#include <linux/dcache.h>\n#include <linux/errno.h>\n#include <linux/sched.h>\n\nstatic int proc_readfd(struct file *file, struct dir_context *ctx)\n{\n\treturn proc_readfd_common(file, ctx, proc_fd_instantiate);\n}"
  },
  {
    "function_name": "proc_readfd_common",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/fd.c",
    "lines": "222-262",
    "snippet": "static int proc_readfd_common(struct file *file, struct dir_context *ctx,\n\t\t\t      instantiate_t instantiate)\n{\n\tstruct task_struct *p = get_proc_task(file_inode(file));\n\tstruct files_struct *files;\n\tunsigned int fd;\n\n\tif (!p)\n\t\treturn -ENOENT;\n\n\tif (!dir_emit_dots(file, ctx))\n\t\tgoto out;\n\tfiles = get_files_struct(p);\n\tif (!files)\n\t\tgoto out;\n\n\trcu_read_lock();\n\tfor (fd = ctx->pos - 2;\n\t     fd < files_fdtable(files)->max_fds;\n\t     fd++, ctx->pos++) {\n\t\tchar name[PROC_NUMBUF];\n\t\tint len;\n\n\t\tif (!fcheck_files(files, fd))\n\t\t\tcontinue;\n\t\trcu_read_unlock();\n\n\t\tlen = snprintf(name, sizeof(name), \"%d\", fd);\n\t\tif (!proc_fill_cache(file, ctx,\n\t\t\t\t     name, len, instantiate, p,\n\t\t\t\t     (void *)(unsigned long)fd))\n\t\t\tgoto out_fd_loop;\n\t\trcu_read_lock();\n\t}\n\trcu_read_unlock();\nout_fd_loop:\n\tput_files_struct(files);\nout:\n\tput_task_struct(p);\n\treturn 0;\n}",
    "includes": [
      "#include \"fd.h\"",
      "#include \"internal.h\"",
      "#include \"../mount.h\"",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/file.h>",
      "#include <linux/security.h>",
      "#include <linux/pid.h>",
      "#include <linux/namei.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/path.h>",
      "#include <linux/dcache.h>",
      "#include <linux/errno.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_task_struct",
          "args": [
            "p"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_files_struct",
          "args": [
            "files"
          ],
          "line": 258
        },
        "resolved": true,
        "details": {
          "function_name": "put_files_struct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/file.c",
          "lines": "394-404",
          "snippet": "void put_files_struct(struct files_struct *files)\n{\n\tif (atomic_dec_and_test(&files->count)) {\n\t\tstruct fdtable *fdt = close_files(files);\n\n\t\t/* free the arrays if they are not embedded */\n\t\tif (fdt != &files->fdtab)\n\t\t\t__free_fdtable(fdt);\n\t\tkmem_cache_free(files_cachep, files);\n\t}\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bitops.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/time.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/time.h>\n#include <linux/mmzone.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nvoid put_files_struct(struct files_struct *files)\n{\n\tif (atomic_dec_and_test(&files->count)) {\n\t\tstruct fdtable *fdt = close_files(files);\n\n\t\t/* free the arrays if they are not embedded */\n\t\tif (fdt != &files->fdtab)\n\t\t\t__free_fdtable(fdt);\n\t\tkmem_cache_free(files_cachep, files);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "proc_fill_cache",
          "args": [
            "file",
            "ctx",
            "name",
            "len",
            "instantiate",
            "p",
            "(void *)(unsigned long)fd"
          ],
          "line": 250
        },
        "resolved": true,
        "details": {
          "function_name": "proc_fill_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/base.c",
          "lines": "1605-1633",
          "snippet": "bool proc_fill_cache(struct file *file, struct dir_context *ctx,\n\tconst char *name, int len,\n\tinstantiate_t instantiate, struct task_struct *task, const void *ptr)\n{\n\tstruct dentry *child, *dir = file->f_path.dentry;\n\tstruct qstr qname = QSTR_INIT(name, len);\n\tstruct inode *inode;\n\tunsigned type;\n\tino_t ino;\n\n\tchild = d_hash_and_lookup(dir, &qname);\n\tif (!child) {\n\t\tchild = d_alloc(dir, &qname);\n\t\tif (!child)\n\t\t\tgoto end_instantiate;\n\t\tif (instantiate(dir->d_inode, child, task, ptr) < 0) {\n\t\t\tdput(child);\n\t\t\tgoto end_instantiate;\n\t\t}\n\t}\n\tinode = child->d_inode;\n\tino = inode->i_ino;\n\ttype = inode->i_mode >> 12;\n\tdput(child);\n\treturn dir_emit(ctx, name, len, ino, type);\n\nend_instantiate:\n\treturn dir_emit(ctx, name, len, 1, DT_UNKNOWN);\n}",
          "includes": [
            "#include \"fd.h\"",
            "#include \"internal.h\"",
            "#include <trace/events/oom.h>",
            "#include <asm/hardwall.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/flex_array.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/elf.h>",
            "#include <linux/oom.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/poll.h>",
            "#include <linux/audit.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/printk.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/module.h>",
            "#include <linux/resource.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/namei.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/string.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/stat.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <asm/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fd.h\"\n#include \"internal.h\"\n#include <trace/events/oom.h>\n#include <asm/hardwall.h>\n#include <linux/posix-timers.h>\n#include <linux/flex_array.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/elf.h>\n#include <linux/oom.h>\n#include <linux/nsproxy.h>\n#include <linux/poll.h>\n#include <linux/audit.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/printk.h>\n#include <linux/tracehook.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/resource.h>\n#include <linux/stacktrace.h>\n#include <linux/kallsyms.h>\n#include <linux/rcupdate.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/mnt_namespace.h>\n#include <linux/namei.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\nbool proc_fill_cache(struct file *file, struct dir_context *ctx,\n\tconst char *name, int len,\n\tinstantiate_t instantiate, struct task_struct *task, const void *ptr)\n{\n\tstruct dentry *child, *dir = file->f_path.dentry;\n\tstruct qstr qname = QSTR_INIT(name, len);\n\tstruct inode *inode;\n\tunsigned type;\n\tino_t ino;\n\n\tchild = d_hash_and_lookup(dir, &qname);\n\tif (!child) {\n\t\tchild = d_alloc(dir, &qname);\n\t\tif (!child)\n\t\t\tgoto end_instantiate;\n\t\tif (instantiate(dir->d_inode, child, task, ptr) < 0) {\n\t\t\tdput(child);\n\t\t\tgoto end_instantiate;\n\t\t}\n\t}\n\tinode = child->d_inode;\n\tino = inode->i_ino;\n\ttype = inode->i_mode >> 12;\n\tdput(child);\n\treturn dir_emit(ctx, name, len, ino, type);\n\nend_instantiate:\n\treturn dir_emit(ctx, name, len, 1, DT_UNKNOWN);\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "name",
            "sizeof(name)",
            "\"%d\"",
            "fd"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fcheck_files",
          "args": [
            "files",
            "fd"
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "files_fdtable",
          "args": [
            "files"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_files_struct",
          "args": [
            "p"
          ],
          "line": 234
        },
        "resolved": true,
        "details": {
          "function_name": "get_files_struct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/file.c",
          "lines": "381-392",
          "snippet": "struct files_struct *get_files_struct(struct task_struct *task)\n{\n\tstruct files_struct *files;\n\n\ttask_lock(task);\n\tfiles = task->files;\n\tif (files)\n\t\tatomic_inc(&files->count);\n\ttask_unlock(task);\n\n\treturn files;\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bitops.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/time.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/time.h>\n#include <linux/mmzone.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstruct files_struct *get_files_struct(struct task_struct *task)\n{\n\tstruct files_struct *files;\n\n\ttask_lock(task);\n\tfiles = task->files;\n\tif (files)\n\t\tatomic_inc(&files->count);\n\ttask_unlock(task);\n\n\treturn files;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dir_emit_dots",
          "args": [
            "file",
            "ctx"
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_proc_task",
          "args": [
            "file_inode(file)"
          ],
          "line": 225
        },
        "resolved": true,
        "details": {
          "function_name": "get_proc_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/internal.h",
          "lines": "95-98",
          "snippet": "static inline struct task_struct *get_proc_task(struct inode *inode)\n{\n\treturn get_pid_task(proc_pid(inode), PIDTYPE_PID);\n}",
          "includes": [
            "#include <linux/binfmts.h>",
            "#include <linux/atomic.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int proc_tid_stat(struct seq_file *, struct pid_namespace *,\n\t\t\t struct pid *, struct task_struct *);",
            "extern int proc_tgid_stat(struct seq_file *, struct pid_namespace *,\n\t\t\t  struct pid *, struct task_struct *);",
            "extern int proc_pid_status(struct seq_file *, struct pid_namespace *,\n\t\t\t   struct pid *, struct task_struct *);",
            "extern int proc_pid_statm(struct seq_file *, struct pid_namespace *,\n\t\t\t  struct pid *, struct task_struct *);",
            "extern struct inode *proc_pid_make_inode(struct super_block *, struct task_struct *);",
            "extern bool proc_fill_cache(struct file *, struct dir_context *, const char *, int,\n\t\t\t   instantiate_t, struct task_struct *, const void *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/binfmts.h>\n#include <linux/atomic.h>\n#include <linux/spinlock.h>\n#include <linux/proc_ns.h>\n#include <linux/proc_fs.h>\n\nextern int proc_tid_stat(struct seq_file *, struct pid_namespace *,\n\t\t\t struct pid *, struct task_struct *);\nextern int proc_tgid_stat(struct seq_file *, struct pid_namespace *,\n\t\t\t  struct pid *, struct task_struct *);\nextern int proc_pid_status(struct seq_file *, struct pid_namespace *,\n\t\t\t   struct pid *, struct task_struct *);\nextern int proc_pid_statm(struct seq_file *, struct pid_namespace *,\n\t\t\t  struct pid *, struct task_struct *);\nextern struct inode *proc_pid_make_inode(struct super_block *, struct task_struct *);\nextern bool proc_fill_cache(struct file *, struct dir_context *, const char *, int,\n\t\t\t   instantiate_t, struct task_struct *, const void *);\n\nstatic inline struct task_struct *get_proc_task(struct inode *inode)\n{\n\treturn get_pid_task(proc_pid(inode), PIDTYPE_PID);\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 225
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fd.h\"\n#include \"internal.h\"\n#include \"../mount.h\"\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/file.h>\n#include <linux/security.h>\n#include <linux/pid.h>\n#include <linux/namei.h>\n#include <linux/fdtable.h>\n#include <linux/path.h>\n#include <linux/dcache.h>\n#include <linux/errno.h>\n#include <linux/sched.h>\n\nstatic int proc_readfd_common(struct file *file, struct dir_context *ctx,\n\t\t\t      instantiate_t instantiate)\n{\n\tstruct task_struct *p = get_proc_task(file_inode(file));\n\tstruct files_struct *files;\n\tunsigned int fd;\n\n\tif (!p)\n\t\treturn -ENOENT;\n\n\tif (!dir_emit_dots(file, ctx))\n\t\tgoto out;\n\tfiles = get_files_struct(p);\n\tif (!files)\n\t\tgoto out;\n\n\trcu_read_lock();\n\tfor (fd = ctx->pos - 2;\n\t     fd < files_fdtable(files)->max_fds;\n\t     fd++, ctx->pos++) {\n\t\tchar name[PROC_NUMBUF];\n\t\tint len;\n\n\t\tif (!fcheck_files(files, fd))\n\t\t\tcontinue;\n\t\trcu_read_unlock();\n\n\t\tlen = snprintf(name, sizeof(name), \"%d\", fd);\n\t\tif (!proc_fill_cache(file, ctx,\n\t\t\t\t     name, len, instantiate, p,\n\t\t\t\t     (void *)(unsigned long)fd))\n\t\t\tgoto out_fd_loop;\n\t\trcu_read_lock();\n\t}\n\trcu_read_unlock();\nout_fd_loop:\n\tput_files_struct(files);\nout:\n\tput_task_struct(p);\n\treturn 0;\n}"
  },
  {
    "function_name": "proc_lookupfd_common",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/fd.c",
    "lines": "202-220",
    "snippet": "static struct dentry *proc_lookupfd_common(struct inode *dir,\n\t\t\t\t\t   struct dentry *dentry,\n\t\t\t\t\t   instantiate_t instantiate)\n{\n\tstruct task_struct *task = get_proc_task(dir);\n\tint result = -ENOENT;\n\tunsigned fd = name_to_int(&dentry->d_name);\n\n\tif (!task)\n\t\tgoto out_no_task;\n\tif (fd == ~0U)\n\t\tgoto out;\n\n\tresult = instantiate(dir, dentry, task, (void *)(unsigned long)fd);\nout:\n\tput_task_struct(task);\nout_no_task:\n\treturn ERR_PTR(result);\n}",
    "includes": [
      "#include \"fd.h\"",
      "#include \"internal.h\"",
      "#include \"../mount.h\"",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/file.h>",
      "#include <linux/security.h>",
      "#include <linux/pid.h>",
      "#include <linux/namei.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/path.h>",
      "#include <linux/dcache.h>",
      "#include <linux/errno.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "result"
          ],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_task_struct",
          "args": [
            "task"
          ],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "instantiate",
          "args": [
            "dir",
            "dentry",
            "task",
            "(void *)(unsigned long)fd"
          ],
          "line": 215
        },
        "resolved": true,
        "details": {
          "function_name": "proc_fdinfo_instantiate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/fd.c",
          "lines": "301-327",
          "snippet": "static int\nproc_fdinfo_instantiate(struct inode *dir, struct dentry *dentry,\n\t\t\tstruct task_struct *task, const void *ptr)\n{\n\tunsigned fd = (unsigned long)ptr;\n\tstruct proc_inode *ei;\n\tstruct inode *inode;\n\n\tinode = proc_pid_make_inode(dir->i_sb, task);\n\tif (!inode)\n\t\tgoto out;\n\n\tei = PROC_I(inode);\n\tei->fd = fd;\n\n\tinode->i_mode = S_IFREG | S_IRUSR;\n\tinode->i_fop = &proc_fdinfo_file_operations;\n\n\td_set_d_op(dentry, &tid_fd_dentry_operations);\n\td_add(dentry, inode);\n\n\t/* Close the race of the process dying before we return the dentry */\n\tif (tid_fd_revalidate(dentry, 0))\n\t\treturn 0;\n out:\n\treturn -ENOENT;\n}",
          "includes": [
            "#include \"fd.h\"",
            "#include \"internal.h\"",
            "#include \"../mount.h\"",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/file.h>",
            "#include <linux/security.h>",
            "#include <linux/pid.h>",
            "#include <linux/namei.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/path.h>",
            "#include <linux/dcache.h>",
            "#include <linux/errno.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations proc_fdinfo_file_operations = {\n\t.open\t\t= seq_fdinfo_open,\n\t.read\t\t= seq_read,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= single_release,\n};",
            "static const struct dentry_operations tid_fd_dentry_operations = {\n\t.d_revalidate\t= tid_fd_revalidate,\n\t.d_delete\t= pid_delete_dentry,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"fd.h\"\n#include \"internal.h\"\n#include \"../mount.h\"\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/file.h>\n#include <linux/security.h>\n#include <linux/pid.h>\n#include <linux/namei.h>\n#include <linux/fdtable.h>\n#include <linux/path.h>\n#include <linux/dcache.h>\n#include <linux/errno.h>\n#include <linux/sched.h>\n\nstatic const struct file_operations proc_fdinfo_file_operations = {\n\t.open\t\t= seq_fdinfo_open,\n\t.read\t\t= seq_read,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= single_release,\n};\nstatic const struct dentry_operations tid_fd_dentry_operations = {\n\t.d_revalidate\t= tid_fd_revalidate,\n\t.d_delete\t= pid_delete_dentry,\n};\n\nstatic int\nproc_fdinfo_instantiate(struct inode *dir, struct dentry *dentry,\n\t\t\tstruct task_struct *task, const void *ptr)\n{\n\tunsigned fd = (unsigned long)ptr;\n\tstruct proc_inode *ei;\n\tstruct inode *inode;\n\n\tinode = proc_pid_make_inode(dir->i_sb, task);\n\tif (!inode)\n\t\tgoto out;\n\n\tei = PROC_I(inode);\n\tei->fd = fd;\n\n\tinode->i_mode = S_IFREG | S_IRUSR;\n\tinode->i_fop = &proc_fdinfo_file_operations;\n\n\td_set_d_op(dentry, &tid_fd_dentry_operations);\n\td_add(dentry, inode);\n\n\t/* Close the race of the process dying before we return the dentry */\n\tif (tid_fd_revalidate(dentry, 0))\n\t\treturn 0;\n out:\n\treturn -ENOENT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "name_to_int",
          "args": [
            "&dentry->d_name"
          ],
          "line": 208
        },
        "resolved": true,
        "details": {
          "function_name": "name_to_int",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/internal.h",
          "lines": "115-135",
          "snippet": "static inline unsigned name_to_int(const struct qstr *qstr)\n{\n\tconst char *name = qstr->name;\n\tint len = qstr->len;\n\tunsigned n = 0;\n\n\tif (len > 1 && *name == '0')\n\t\tgoto out;\n\twhile (len-- > 0) {\n\t\tunsigned c = *name++ - '0';\n\t\tif (c > 9)\n\t\t\tgoto out;\n\t\tif (n >= (~0U-9)/10)\n\t\t\tgoto out;\n\t\tn *= 10;\n\t\tn += c;\n\t}\n\treturn n;\nout:\n\treturn ~0U;\n}",
          "includes": [
            "#include <linux/binfmts.h>",
            "#include <linux/atomic.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/binfmts.h>\n#include <linux/atomic.h>\n#include <linux/spinlock.h>\n#include <linux/proc_ns.h>\n#include <linux/proc_fs.h>\n\nstatic inline unsigned name_to_int(const struct qstr *qstr)\n{\n\tconst char *name = qstr->name;\n\tint len = qstr->len;\n\tunsigned n = 0;\n\n\tif (len > 1 && *name == '0')\n\t\tgoto out;\n\twhile (len-- > 0) {\n\t\tunsigned c = *name++ - '0';\n\t\tif (c > 9)\n\t\t\tgoto out;\n\t\tif (n >= (~0U-9)/10)\n\t\t\tgoto out;\n\t\tn *= 10;\n\t\tn += c;\n\t}\n\treturn n;\nout:\n\treturn ~0U;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_proc_task",
          "args": [
            "dir"
          ],
          "line": 206
        },
        "resolved": true,
        "details": {
          "function_name": "get_proc_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/internal.h",
          "lines": "95-98",
          "snippet": "static inline struct task_struct *get_proc_task(struct inode *inode)\n{\n\treturn get_pid_task(proc_pid(inode), PIDTYPE_PID);\n}",
          "includes": [
            "#include <linux/binfmts.h>",
            "#include <linux/atomic.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int proc_tid_stat(struct seq_file *, struct pid_namespace *,\n\t\t\t struct pid *, struct task_struct *);",
            "extern int proc_tgid_stat(struct seq_file *, struct pid_namespace *,\n\t\t\t  struct pid *, struct task_struct *);",
            "extern int proc_pid_status(struct seq_file *, struct pid_namespace *,\n\t\t\t   struct pid *, struct task_struct *);",
            "extern int proc_pid_statm(struct seq_file *, struct pid_namespace *,\n\t\t\t  struct pid *, struct task_struct *);",
            "extern struct inode *proc_pid_make_inode(struct super_block *, struct task_struct *);",
            "extern bool proc_fill_cache(struct file *, struct dir_context *, const char *, int,\n\t\t\t   instantiate_t, struct task_struct *, const void *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/binfmts.h>\n#include <linux/atomic.h>\n#include <linux/spinlock.h>\n#include <linux/proc_ns.h>\n#include <linux/proc_fs.h>\n\nextern int proc_tid_stat(struct seq_file *, struct pid_namespace *,\n\t\t\t struct pid *, struct task_struct *);\nextern int proc_tgid_stat(struct seq_file *, struct pid_namespace *,\n\t\t\t  struct pid *, struct task_struct *);\nextern int proc_pid_status(struct seq_file *, struct pid_namespace *,\n\t\t\t   struct pid *, struct task_struct *);\nextern int proc_pid_statm(struct seq_file *, struct pid_namespace *,\n\t\t\t  struct pid *, struct task_struct *);\nextern struct inode *proc_pid_make_inode(struct super_block *, struct task_struct *);\nextern bool proc_fill_cache(struct file *, struct dir_context *, const char *, int,\n\t\t\t   instantiate_t, struct task_struct *, const void *);\n\nstatic inline struct task_struct *get_proc_task(struct inode *inode)\n{\n\treturn get_pid_task(proc_pid(inode), PIDTYPE_PID);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fd.h\"\n#include \"internal.h\"\n#include \"../mount.h\"\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/file.h>\n#include <linux/security.h>\n#include <linux/pid.h>\n#include <linux/namei.h>\n#include <linux/fdtable.h>\n#include <linux/path.h>\n#include <linux/dcache.h>\n#include <linux/errno.h>\n#include <linux/sched.h>\n\nstatic struct dentry *proc_lookupfd_common(struct inode *dir,\n\t\t\t\t\t   struct dentry *dentry,\n\t\t\t\t\t   instantiate_t instantiate)\n{\n\tstruct task_struct *task = get_proc_task(dir);\n\tint result = -ENOENT;\n\tunsigned fd = name_to_int(&dentry->d_name);\n\n\tif (!task)\n\t\tgoto out_no_task;\n\tif (fd == ~0U)\n\t\tgoto out;\n\n\tresult = instantiate(dir, dentry, task, (void *)(unsigned long)fd);\nout:\n\tput_task_struct(task);\nout_no_task:\n\treturn ERR_PTR(result);\n}"
  },
  {
    "function_name": "proc_fd_instantiate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/fd.c",
    "lines": "171-200",
    "snippet": "static int\nproc_fd_instantiate(struct inode *dir, struct dentry *dentry,\n\t\t    struct task_struct *task, const void *ptr)\n{\n\tunsigned fd = (unsigned long)ptr;\n\tstruct proc_inode *ei;\n\tstruct inode *inode;\n\n\tinode = proc_pid_make_inode(dir->i_sb, task);\n\tif (!inode)\n\t\tgoto out;\n\n\tei = PROC_I(inode);\n\tei->fd = fd;\n\n\tinode->i_mode = S_IFLNK;\n\tinode->i_op = &proc_pid_link_inode_operations;\n\tinode->i_size = 64;\n\n\tei->op.proc_get_link = proc_fd_link;\n\n\td_set_d_op(dentry, &tid_fd_dentry_operations);\n\td_add(dentry, inode);\n\n\t/* Close the race of the process dying before we return the dentry */\n\tif (tid_fd_revalidate(dentry, 0))\n\t\treturn 0;\n out:\n\treturn -ENOENT;\n}",
    "includes": [
      "#include \"fd.h\"",
      "#include \"internal.h\"",
      "#include \"../mount.h\"",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/file.h>",
      "#include <linux/security.h>",
      "#include <linux/pid.h>",
      "#include <linux/namei.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/path.h>",
      "#include <linux/dcache.h>",
      "#include <linux/errno.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct dentry_operations tid_fd_dentry_operations = {\n\t.d_revalidate\t= tid_fd_revalidate,\n\t.d_delete\t= pid_delete_dentry,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "tid_fd_revalidate",
          "args": [
            "dentry",
            "0"
          ],
          "line": 196
        },
        "resolved": true,
        "details": {
          "function_name": "tid_fd_revalidate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/fd.c",
          "lines": "76-134",
          "snippet": "static int tid_fd_revalidate(struct dentry *dentry, unsigned int flags)\n{\n\tstruct files_struct *files;\n\tstruct task_struct *task;\n\tconst struct cred *cred;\n\tstruct inode *inode;\n\tint fd;\n\n\tif (flags & LOOKUP_RCU)\n\t\treturn -ECHILD;\n\n\tinode = dentry->d_inode;\n\ttask = get_proc_task(inode);\n\tfd = proc_fd(inode);\n\n\tif (task) {\n\t\tfiles = get_files_struct(task);\n\t\tif (files) {\n\t\t\tstruct file *file;\n\n\t\t\trcu_read_lock();\n\t\t\tfile = fcheck_files(files, fd);\n\t\t\tif (file) {\n\t\t\t\tunsigned f_mode = file->f_mode;\n\n\t\t\t\trcu_read_unlock();\n\t\t\t\tput_files_struct(files);\n\n\t\t\t\tif (task_dumpable(task)) {\n\t\t\t\t\trcu_read_lock();\n\t\t\t\t\tcred = __task_cred(task);\n\t\t\t\t\tinode->i_uid = cred->euid;\n\t\t\t\t\tinode->i_gid = cred->egid;\n\t\t\t\t\trcu_read_unlock();\n\t\t\t\t} else {\n\t\t\t\t\tinode->i_uid = GLOBAL_ROOT_UID;\n\t\t\t\t\tinode->i_gid = GLOBAL_ROOT_GID;\n\t\t\t\t}\n\n\t\t\t\tif (S_ISLNK(inode->i_mode)) {\n\t\t\t\t\tunsigned i_mode = S_IFLNK;\n\t\t\t\t\tif (f_mode & FMODE_READ)\n\t\t\t\t\t\ti_mode |= S_IRUSR | S_IXUSR;\n\t\t\t\t\tif (f_mode & FMODE_WRITE)\n\t\t\t\t\t\ti_mode |= S_IWUSR | S_IXUSR;\n\t\t\t\t\tinode->i_mode = i_mode;\n\t\t\t\t}\n\n\t\t\t\tsecurity_task_to_inode(task, inode);\n\t\t\t\tput_task_struct(task);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\trcu_read_unlock();\n\t\t\tput_files_struct(files);\n\t\t}\n\t\tput_task_struct(task);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"fd.h\"",
            "#include \"internal.h\"",
            "#include \"../mount.h\"",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/file.h>",
            "#include <linux/security.h>",
            "#include <linux/pid.h>",
            "#include <linux/namei.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/path.h>",
            "#include <linux/dcache.h>",
            "#include <linux/errno.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fd.h\"\n#include \"internal.h\"\n#include \"../mount.h\"\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/file.h>\n#include <linux/security.h>\n#include <linux/pid.h>\n#include <linux/namei.h>\n#include <linux/fdtable.h>\n#include <linux/path.h>\n#include <linux/dcache.h>\n#include <linux/errno.h>\n#include <linux/sched.h>\n\nstatic int tid_fd_revalidate(struct dentry *dentry, unsigned int flags)\n{\n\tstruct files_struct *files;\n\tstruct task_struct *task;\n\tconst struct cred *cred;\n\tstruct inode *inode;\n\tint fd;\n\n\tif (flags & LOOKUP_RCU)\n\t\treturn -ECHILD;\n\n\tinode = dentry->d_inode;\n\ttask = get_proc_task(inode);\n\tfd = proc_fd(inode);\n\n\tif (task) {\n\t\tfiles = get_files_struct(task);\n\t\tif (files) {\n\t\t\tstruct file *file;\n\n\t\t\trcu_read_lock();\n\t\t\tfile = fcheck_files(files, fd);\n\t\t\tif (file) {\n\t\t\t\tunsigned f_mode = file->f_mode;\n\n\t\t\t\trcu_read_unlock();\n\t\t\t\tput_files_struct(files);\n\n\t\t\t\tif (task_dumpable(task)) {\n\t\t\t\t\trcu_read_lock();\n\t\t\t\t\tcred = __task_cred(task);\n\t\t\t\t\tinode->i_uid = cred->euid;\n\t\t\t\t\tinode->i_gid = cred->egid;\n\t\t\t\t\trcu_read_unlock();\n\t\t\t\t} else {\n\t\t\t\t\tinode->i_uid = GLOBAL_ROOT_UID;\n\t\t\t\t\tinode->i_gid = GLOBAL_ROOT_GID;\n\t\t\t\t}\n\n\t\t\t\tif (S_ISLNK(inode->i_mode)) {\n\t\t\t\t\tunsigned i_mode = S_IFLNK;\n\t\t\t\t\tif (f_mode & FMODE_READ)\n\t\t\t\t\t\ti_mode |= S_IRUSR | S_IXUSR;\n\t\t\t\t\tif (f_mode & FMODE_WRITE)\n\t\t\t\t\t\ti_mode |= S_IWUSR | S_IXUSR;\n\t\t\t\t\tinode->i_mode = i_mode;\n\t\t\t\t}\n\n\t\t\t\tsecurity_task_to_inode(task, inode);\n\t\t\t\tput_task_struct(task);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\trcu_read_unlock();\n\t\t\tput_files_struct(files);\n\t\t}\n\t\tput_task_struct(task);\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_add",
          "args": [
            "dentry",
            "inode"
          ],
          "line": 193
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_fid_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/fid.c",
          "lines": "49-54",
          "snippet": "void v9fs_fid_add(struct dentry *dentry, struct p9_fid *fid)\n{\n\tspin_lock(&dentry->d_lock);\n\t__add_fid(dentry, fid);\n\tspin_unlock(&dentry->d_lock);\n}",
          "includes": [
            "#include \"fid.h\"",
            "#include \"v9fs_vfs.h\"",
            "#include \"v9fs.h\"",
            "#include <net/9p/client.h>",
            "#include <net/9p/9p.h>",
            "#include <linux/idr.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/idr.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nvoid v9fs_fid_add(struct dentry *dentry, struct p9_fid *fid)\n{\n\tspin_lock(&dentry->d_lock);\n\t__add_fid(dentry, fid);\n\tspin_unlock(&dentry->d_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_set_d_op",
          "args": [
            "dentry",
            "&tid_fd_dentry_operations"
          ],
          "line": 192
        },
        "resolved": true,
        "details": {
          "function_name": "d_set_d_op",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1635-1659",
          "snippet": "void d_set_d_op(struct dentry *dentry, const struct dentry_operations *op)\n{\n\tWARN_ON_ONCE(dentry->d_op);\n\tWARN_ON_ONCE(dentry->d_flags & (DCACHE_OP_HASH\t|\n\t\t\t\tDCACHE_OP_COMPARE\t|\n\t\t\t\tDCACHE_OP_REVALIDATE\t|\n\t\t\t\tDCACHE_OP_WEAK_REVALIDATE\t|\n\t\t\t\tDCACHE_OP_DELETE ));\n\tdentry->d_op = op;\n\tif (!op)\n\t\treturn;\n\tif (op->d_hash)\n\t\tdentry->d_flags |= DCACHE_OP_HASH;\n\tif (op->d_compare)\n\t\tdentry->d_flags |= DCACHE_OP_COMPARE;\n\tif (op->d_revalidate)\n\t\tdentry->d_flags |= DCACHE_OP_REVALIDATE;\n\tif (op->d_weak_revalidate)\n\t\tdentry->d_flags |= DCACHE_OP_WEAK_REVALIDATE;\n\tif (op->d_delete)\n\t\tdentry->d_flags |= DCACHE_OP_DELETE;\n\tif (op->d_prune)\n\t\tdentry->d_flags |= DCACHE_OP_PRUNE;\n\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid d_set_d_op(struct dentry *dentry, const struct dentry_operations *op)\n{\n\tWARN_ON_ONCE(dentry->d_op);\n\tWARN_ON_ONCE(dentry->d_flags & (DCACHE_OP_HASH\t|\n\t\t\t\tDCACHE_OP_COMPARE\t|\n\t\t\t\tDCACHE_OP_REVALIDATE\t|\n\t\t\t\tDCACHE_OP_WEAK_REVALIDATE\t|\n\t\t\t\tDCACHE_OP_DELETE ));\n\tdentry->d_op = op;\n\tif (!op)\n\t\treturn;\n\tif (op->d_hash)\n\t\tdentry->d_flags |= DCACHE_OP_HASH;\n\tif (op->d_compare)\n\t\tdentry->d_flags |= DCACHE_OP_COMPARE;\n\tif (op->d_revalidate)\n\t\tdentry->d_flags |= DCACHE_OP_REVALIDATE;\n\tif (op->d_weak_revalidate)\n\t\tdentry->d_flags |= DCACHE_OP_WEAK_REVALIDATE;\n\tif (op->d_delete)\n\t\tdentry->d_flags |= DCACHE_OP_DELETE;\n\tif (op->d_prune)\n\t\tdentry->d_flags |= DCACHE_OP_PRUNE;\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "PROC_I",
          "args": [
            "inode"
          ],
          "line": 183
        },
        "resolved": true,
        "details": {
          "function_name": "PROC_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/internal.h",
          "lines": "75-78",
          "snippet": "static inline struct proc_inode *PROC_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct proc_inode, vfs_inode);\n}",
          "includes": [
            "#include <linux/binfmts.h>",
            "#include <linux/atomic.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/binfmts.h>\n#include <linux/atomic.h>\n#include <linux/spinlock.h>\n#include <linux/proc_ns.h>\n#include <linux/proc_fs.h>\n\nstatic inline struct proc_inode *PROC_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct proc_inode, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "proc_pid_make_inode",
          "args": [
            "dir->i_sb",
            "task"
          ],
          "line": 179
        },
        "resolved": true,
        "details": {
          "function_name": "proc_pid_make_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/base.c",
          "lines": "1447-1487",
          "snippet": "struct inode *proc_pid_make_inode(struct super_block * sb, struct task_struct *task)\n{\n\tstruct inode * inode;\n\tstruct proc_inode *ei;\n\tconst struct cred *cred;\n\n\t/* We need a new inode */\n\n\tinode = new_inode(sb);\n\tif (!inode)\n\t\tgoto out;\n\n\t/* Common stuff */\n\tei = PROC_I(inode);\n\tinode->i_ino = get_next_ino();\n\tinode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME;\n\tinode->i_op = &proc_def_inode_operations;\n\n\t/*\n\t * grab the reference to task.\n\t */\n\tei->pid = get_task_pid(task, PIDTYPE_PID);\n\tif (!ei->pid)\n\t\tgoto out_unlock;\n\n\tif (task_dumpable(task)) {\n\t\trcu_read_lock();\n\t\tcred = __task_cred(task);\n\t\tinode->i_uid = cred->euid;\n\t\tinode->i_gid = cred->egid;\n\t\trcu_read_unlock();\n\t}\n\tsecurity_task_to_inode(task, inode);\n\nout:\n\treturn inode;\n\nout_unlock:\n\tiput(inode);\n\treturn NULL;\n}",
          "includes": [
            "#include \"fd.h\"",
            "#include \"internal.h\"",
            "#include <trace/events/oom.h>",
            "#include <asm/hardwall.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/flex_array.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/elf.h>",
            "#include <linux/oom.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/poll.h>",
            "#include <linux/audit.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/printk.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/module.h>",
            "#include <linux/resource.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/namei.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/string.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/stat.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <asm/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct inode_operations proc_def_inode_operations = {\n\t.setattr\t= proc_setattr,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"fd.h\"\n#include \"internal.h\"\n#include <trace/events/oom.h>\n#include <asm/hardwall.h>\n#include <linux/posix-timers.h>\n#include <linux/flex_array.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/elf.h>\n#include <linux/oom.h>\n#include <linux/nsproxy.h>\n#include <linux/poll.h>\n#include <linux/audit.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/printk.h>\n#include <linux/tracehook.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/resource.h>\n#include <linux/stacktrace.h>\n#include <linux/kallsyms.h>\n#include <linux/rcupdate.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/mnt_namespace.h>\n#include <linux/namei.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\nstatic const struct inode_operations proc_def_inode_operations = {\n\t.setattr\t= proc_setattr,\n};\n\nstruct inode *proc_pid_make_inode(struct super_block * sb, struct task_struct *task)\n{\n\tstruct inode * inode;\n\tstruct proc_inode *ei;\n\tconst struct cred *cred;\n\n\t/* We need a new inode */\n\n\tinode = new_inode(sb);\n\tif (!inode)\n\t\tgoto out;\n\n\t/* Common stuff */\n\tei = PROC_I(inode);\n\tinode->i_ino = get_next_ino();\n\tinode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME;\n\tinode->i_op = &proc_def_inode_operations;\n\n\t/*\n\t * grab the reference to task.\n\t */\n\tei->pid = get_task_pid(task, PIDTYPE_PID);\n\tif (!ei->pid)\n\t\tgoto out_unlock;\n\n\tif (task_dumpable(task)) {\n\t\trcu_read_lock();\n\t\tcred = __task_cred(task);\n\t\tinode->i_uid = cred->euid;\n\t\tinode->i_gid = cred->egid;\n\t\trcu_read_unlock();\n\t}\n\tsecurity_task_to_inode(task, inode);\n\nout:\n\treturn inode;\n\nout_unlock:\n\tiput(inode);\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fd.h\"\n#include \"internal.h\"\n#include \"../mount.h\"\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/file.h>\n#include <linux/security.h>\n#include <linux/pid.h>\n#include <linux/namei.h>\n#include <linux/fdtable.h>\n#include <linux/path.h>\n#include <linux/dcache.h>\n#include <linux/errno.h>\n#include <linux/sched.h>\n\nstatic const struct dentry_operations tid_fd_dentry_operations = {\n\t.d_revalidate\t= tid_fd_revalidate,\n\t.d_delete\t= pid_delete_dentry,\n};\n\nstatic int\nproc_fd_instantiate(struct inode *dir, struct dentry *dentry,\n\t\t    struct task_struct *task, const void *ptr)\n{\n\tunsigned fd = (unsigned long)ptr;\n\tstruct proc_inode *ei;\n\tstruct inode *inode;\n\n\tinode = proc_pid_make_inode(dir->i_sb, task);\n\tif (!inode)\n\t\tgoto out;\n\n\tei = PROC_I(inode);\n\tei->fd = fd;\n\n\tinode->i_mode = S_IFLNK;\n\tinode->i_op = &proc_pid_link_inode_operations;\n\tinode->i_size = 64;\n\n\tei->op.proc_get_link = proc_fd_link;\n\n\td_set_d_op(dentry, &tid_fd_dentry_operations);\n\td_add(dentry, inode);\n\n\t/* Close the race of the process dying before we return the dentry */\n\tif (tid_fd_revalidate(dentry, 0))\n\t\treturn 0;\n out:\n\treturn -ENOENT;\n}"
  },
  {
    "function_name": "proc_fd_link",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/fd.c",
    "lines": "141-169",
    "snippet": "static int proc_fd_link(struct dentry *dentry, struct path *path)\n{\n\tstruct files_struct *files = NULL;\n\tstruct task_struct *task;\n\tint ret = -ENOENT;\n\n\ttask = get_proc_task(dentry->d_inode);\n\tif (task) {\n\t\tfiles = get_files_struct(task);\n\t\tput_task_struct(task);\n\t}\n\n\tif (files) {\n\t\tint fd = proc_fd(dentry->d_inode);\n\t\tstruct file *fd_file;\n\n\t\tspin_lock(&files->file_lock);\n\t\tfd_file = fcheck_files(files, fd);\n\t\tif (fd_file) {\n\t\t\t*path = fd_file->f_path;\n\t\t\tpath_get(&fd_file->f_path);\n\t\t\tret = 0;\n\t\t}\n\t\tspin_unlock(&files->file_lock);\n\t\tput_files_struct(files);\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include \"fd.h\"",
      "#include \"internal.h\"",
      "#include \"../mount.h\"",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/file.h>",
      "#include <linux/security.h>",
      "#include <linux/pid.h>",
      "#include <linux/namei.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/path.h>",
      "#include <linux/dcache.h>",
      "#include <linux/errno.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_files_struct",
          "args": [
            "files"
          ],
          "line": 165
        },
        "resolved": true,
        "details": {
          "function_name": "put_files_struct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/file.c",
          "lines": "394-404",
          "snippet": "void put_files_struct(struct files_struct *files)\n{\n\tif (atomic_dec_and_test(&files->count)) {\n\t\tstruct fdtable *fdt = close_files(files);\n\n\t\t/* free the arrays if they are not embedded */\n\t\tif (fdt != &files->fdtab)\n\t\t\t__free_fdtable(fdt);\n\t\tkmem_cache_free(files_cachep, files);\n\t}\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bitops.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/time.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/time.h>\n#include <linux/mmzone.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nvoid put_files_struct(struct files_struct *files)\n{\n\tif (atomic_dec_and_test(&files->count)) {\n\t\tstruct fdtable *fdt = close_files(files);\n\n\t\t/* free the arrays if they are not embedded */\n\t\tif (fdt != &files->fdtab)\n\t\t\t__free_fdtable(fdt);\n\t\tkmem_cache_free(files_cachep, files);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&files->file_lock"
          ],
          "line": 164
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "path_get",
          "args": [
            "&fd_file->f_path"
          ],
          "line": 161
        },
        "resolved": true,
        "details": {
          "function_name": "path_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "476-480",
          "snippet": "void path_get(const struct path *path)\n{\n\tmntget(path->mnt);\n\tdget(path->dentry);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nvoid path_get(const struct path *path)\n{\n\tmntget(path->mnt);\n\tdget(path->dentry);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fcheck_files",
          "args": [
            "files",
            "fd"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&files->file_lock"
          ],
          "line": 157
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "proc_fd",
          "args": [
            "dentry->d_inode"
          ],
          "line": 154
        },
        "resolved": true,
        "details": {
          "function_name": "proc_fd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/fd.h",
          "lines": "14-17",
          "snippet": "static inline int proc_fd(struct inode *inode)\n{\n\treturn PROC_I(inode)->fd;\n}",
          "includes": [
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs.h>\n\nstatic inline int proc_fd(struct inode *inode)\n{\n\treturn PROC_I(inode)->fd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_task_struct",
          "args": [
            "task"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_files_struct",
          "args": [
            "task"
          ],
          "line": 149
        },
        "resolved": true,
        "details": {
          "function_name": "get_files_struct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/file.c",
          "lines": "381-392",
          "snippet": "struct files_struct *get_files_struct(struct task_struct *task)\n{\n\tstruct files_struct *files;\n\n\ttask_lock(task);\n\tfiles = task->files;\n\tif (files)\n\t\tatomic_inc(&files->count);\n\ttask_unlock(task);\n\n\treturn files;\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bitops.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/time.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/time.h>\n#include <linux/mmzone.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstruct files_struct *get_files_struct(struct task_struct *task)\n{\n\tstruct files_struct *files;\n\n\ttask_lock(task);\n\tfiles = task->files;\n\tif (files)\n\t\tatomic_inc(&files->count);\n\ttask_unlock(task);\n\n\treturn files;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_proc_task",
          "args": [
            "dentry->d_inode"
          ],
          "line": 147
        },
        "resolved": true,
        "details": {
          "function_name": "get_proc_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/internal.h",
          "lines": "95-98",
          "snippet": "static inline struct task_struct *get_proc_task(struct inode *inode)\n{\n\treturn get_pid_task(proc_pid(inode), PIDTYPE_PID);\n}",
          "includes": [
            "#include <linux/binfmts.h>",
            "#include <linux/atomic.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int proc_tid_stat(struct seq_file *, struct pid_namespace *,\n\t\t\t struct pid *, struct task_struct *);",
            "extern int proc_tgid_stat(struct seq_file *, struct pid_namespace *,\n\t\t\t  struct pid *, struct task_struct *);",
            "extern int proc_pid_status(struct seq_file *, struct pid_namespace *,\n\t\t\t   struct pid *, struct task_struct *);",
            "extern int proc_pid_statm(struct seq_file *, struct pid_namespace *,\n\t\t\t  struct pid *, struct task_struct *);",
            "extern struct inode *proc_pid_make_inode(struct super_block *, struct task_struct *);",
            "extern bool proc_fill_cache(struct file *, struct dir_context *, const char *, int,\n\t\t\t   instantiate_t, struct task_struct *, const void *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/binfmts.h>\n#include <linux/atomic.h>\n#include <linux/spinlock.h>\n#include <linux/proc_ns.h>\n#include <linux/proc_fs.h>\n\nextern int proc_tid_stat(struct seq_file *, struct pid_namespace *,\n\t\t\t struct pid *, struct task_struct *);\nextern int proc_tgid_stat(struct seq_file *, struct pid_namespace *,\n\t\t\t  struct pid *, struct task_struct *);\nextern int proc_pid_status(struct seq_file *, struct pid_namespace *,\n\t\t\t   struct pid *, struct task_struct *);\nextern int proc_pid_statm(struct seq_file *, struct pid_namespace *,\n\t\t\t  struct pid *, struct task_struct *);\nextern struct inode *proc_pid_make_inode(struct super_block *, struct task_struct *);\nextern bool proc_fill_cache(struct file *, struct dir_context *, const char *, int,\n\t\t\t   instantiate_t, struct task_struct *, const void *);\n\nstatic inline struct task_struct *get_proc_task(struct inode *inode)\n{\n\treturn get_pid_task(proc_pid(inode), PIDTYPE_PID);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fd.h\"\n#include \"internal.h\"\n#include \"../mount.h\"\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/file.h>\n#include <linux/security.h>\n#include <linux/pid.h>\n#include <linux/namei.h>\n#include <linux/fdtable.h>\n#include <linux/path.h>\n#include <linux/dcache.h>\n#include <linux/errno.h>\n#include <linux/sched.h>\n\nstatic int proc_fd_link(struct dentry *dentry, struct path *path)\n{\n\tstruct files_struct *files = NULL;\n\tstruct task_struct *task;\n\tint ret = -ENOENT;\n\n\ttask = get_proc_task(dentry->d_inode);\n\tif (task) {\n\t\tfiles = get_files_struct(task);\n\t\tput_task_struct(task);\n\t}\n\n\tif (files) {\n\t\tint fd = proc_fd(dentry->d_inode);\n\t\tstruct file *fd_file;\n\n\t\tspin_lock(&files->file_lock);\n\t\tfd_file = fcheck_files(files, fd);\n\t\tif (fd_file) {\n\t\t\t*path = fd_file->f_path;\n\t\t\tpath_get(&fd_file->f_path);\n\t\t\tret = 0;\n\t\t}\n\t\tspin_unlock(&files->file_lock);\n\t\tput_files_struct(files);\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "tid_fd_revalidate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/fd.c",
    "lines": "76-134",
    "snippet": "static int tid_fd_revalidate(struct dentry *dentry, unsigned int flags)\n{\n\tstruct files_struct *files;\n\tstruct task_struct *task;\n\tconst struct cred *cred;\n\tstruct inode *inode;\n\tint fd;\n\n\tif (flags & LOOKUP_RCU)\n\t\treturn -ECHILD;\n\n\tinode = dentry->d_inode;\n\ttask = get_proc_task(inode);\n\tfd = proc_fd(inode);\n\n\tif (task) {\n\t\tfiles = get_files_struct(task);\n\t\tif (files) {\n\t\t\tstruct file *file;\n\n\t\t\trcu_read_lock();\n\t\t\tfile = fcheck_files(files, fd);\n\t\t\tif (file) {\n\t\t\t\tunsigned f_mode = file->f_mode;\n\n\t\t\t\trcu_read_unlock();\n\t\t\t\tput_files_struct(files);\n\n\t\t\t\tif (task_dumpable(task)) {\n\t\t\t\t\trcu_read_lock();\n\t\t\t\t\tcred = __task_cred(task);\n\t\t\t\t\tinode->i_uid = cred->euid;\n\t\t\t\t\tinode->i_gid = cred->egid;\n\t\t\t\t\trcu_read_unlock();\n\t\t\t\t} else {\n\t\t\t\t\tinode->i_uid = GLOBAL_ROOT_UID;\n\t\t\t\t\tinode->i_gid = GLOBAL_ROOT_GID;\n\t\t\t\t}\n\n\t\t\t\tif (S_ISLNK(inode->i_mode)) {\n\t\t\t\t\tunsigned i_mode = S_IFLNK;\n\t\t\t\t\tif (f_mode & FMODE_READ)\n\t\t\t\t\t\ti_mode |= S_IRUSR | S_IXUSR;\n\t\t\t\t\tif (f_mode & FMODE_WRITE)\n\t\t\t\t\t\ti_mode |= S_IWUSR | S_IXUSR;\n\t\t\t\t\tinode->i_mode = i_mode;\n\t\t\t\t}\n\n\t\t\t\tsecurity_task_to_inode(task, inode);\n\t\t\t\tput_task_struct(task);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\trcu_read_unlock();\n\t\t\tput_files_struct(files);\n\t\t}\n\t\tput_task_struct(task);\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"fd.h\"",
      "#include \"internal.h\"",
      "#include \"../mount.h\"",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/file.h>",
      "#include <linux/security.h>",
      "#include <linux/pid.h>",
      "#include <linux/namei.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/path.h>",
      "#include <linux/dcache.h>",
      "#include <linux/errno.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_task_struct",
          "args": [
            "task"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_files_struct",
          "args": [
            "files"
          ],
          "line": 129
        },
        "resolved": true,
        "details": {
          "function_name": "put_files_struct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/file.c",
          "lines": "394-404",
          "snippet": "void put_files_struct(struct files_struct *files)\n{\n\tif (atomic_dec_and_test(&files->count)) {\n\t\tstruct fdtable *fdt = close_files(files);\n\n\t\t/* free the arrays if they are not embedded */\n\t\tif (fdt != &files->fdtab)\n\t\t\t__free_fdtable(fdt);\n\t\tkmem_cache_free(files_cachep, files);\n\t}\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bitops.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/time.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/time.h>\n#include <linux/mmzone.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nvoid put_files_struct(struct files_struct *files)\n{\n\tif (atomic_dec_and_test(&files->count)) {\n\t\tstruct fdtable *fdt = close_files(files);\n\n\t\t/* free the arrays if they are not embedded */\n\t\tif (fdt != &files->fdtab)\n\t\t\t__free_fdtable(fdt);\n\t\tkmem_cache_free(files_cachep, files);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_task_struct",
          "args": [
            "task"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "security_task_to_inode",
          "args": [
            "task",
            "inode"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISLNK",
          "args": [
            "inode->i_mode"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__task_cred",
          "args": [
            "task"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_dumpable",
          "args": [
            "task"
          ],
          "line": 104
        },
        "resolved": true,
        "details": {
          "function_name": "task_dumpable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/internal.h",
          "lines": "100-113",
          "snippet": "static inline int task_dumpable(struct task_struct *task)\n{\n\tint dumpable = 0;\n\tstruct mm_struct *mm;\n\n\ttask_lock(task);\n\tmm = task->mm;\n\tif (mm)\n\t\tdumpable = get_dumpable(mm);\n\ttask_unlock(task);\n\tif (dumpable == SUID_DUMP_USER)\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/binfmts.h>",
            "#include <linux/atomic.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int proc_tid_stat(struct seq_file *, struct pid_namespace *,\n\t\t\t struct pid *, struct task_struct *);",
            "extern int proc_tgid_stat(struct seq_file *, struct pid_namespace *,\n\t\t\t  struct pid *, struct task_struct *);",
            "extern int proc_pid_status(struct seq_file *, struct pid_namespace *,\n\t\t\t   struct pid *, struct task_struct *);",
            "extern int proc_pid_statm(struct seq_file *, struct pid_namespace *,\n\t\t\t  struct pid *, struct task_struct *);",
            "extern struct inode *proc_pid_make_inode(struct super_block *, struct task_struct *);",
            "extern bool proc_fill_cache(struct file *, struct dir_context *, const char *, int,\n\t\t\t   instantiate_t, struct task_struct *, const void *);",
            "extern unsigned long task_vsize(struct mm_struct *);",
            "extern unsigned long task_statm(struct mm_struct *,\n\t\t\t\tunsigned long *, unsigned long *,\n\t\t\t\tunsigned long *, unsigned long *);",
            "extern void task_mem(struct seq_file *, struct mm_struct *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/binfmts.h>\n#include <linux/atomic.h>\n#include <linux/spinlock.h>\n#include <linux/proc_ns.h>\n#include <linux/proc_fs.h>\n\nextern int proc_tid_stat(struct seq_file *, struct pid_namespace *,\n\t\t\t struct pid *, struct task_struct *);\nextern int proc_tgid_stat(struct seq_file *, struct pid_namespace *,\n\t\t\t  struct pid *, struct task_struct *);\nextern int proc_pid_status(struct seq_file *, struct pid_namespace *,\n\t\t\t   struct pid *, struct task_struct *);\nextern int proc_pid_statm(struct seq_file *, struct pid_namespace *,\n\t\t\t  struct pid *, struct task_struct *);\nextern struct inode *proc_pid_make_inode(struct super_block *, struct task_struct *);\nextern bool proc_fill_cache(struct file *, struct dir_context *, const char *, int,\n\t\t\t   instantiate_t, struct task_struct *, const void *);\nextern unsigned long task_vsize(struct mm_struct *);\nextern unsigned long task_statm(struct mm_struct *,\n\t\t\t\tunsigned long *, unsigned long *,\n\t\t\t\tunsigned long *, unsigned long *);\nextern void task_mem(struct seq_file *, struct mm_struct *);\n\nstatic inline int task_dumpable(struct task_struct *task)\n{\n\tint dumpable = 0;\n\tstruct mm_struct *mm;\n\n\ttask_lock(task);\n\tmm = task->mm;\n\tif (mm)\n\t\tdumpable = get_dumpable(mm);\n\ttask_unlock(task);\n\tif (dumpable == SUID_DUMP_USER)\n\t\treturn 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fcheck_files",
          "args": [
            "files",
            "fd"
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_files_struct",
          "args": [
            "task"
          ],
          "line": 92
        },
        "resolved": true,
        "details": {
          "function_name": "get_files_struct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/file.c",
          "lines": "381-392",
          "snippet": "struct files_struct *get_files_struct(struct task_struct *task)\n{\n\tstruct files_struct *files;\n\n\ttask_lock(task);\n\tfiles = task->files;\n\tif (files)\n\t\tatomic_inc(&files->count);\n\ttask_unlock(task);\n\n\treturn files;\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bitops.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/time.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/time.h>\n#include <linux/mmzone.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstruct files_struct *get_files_struct(struct task_struct *task)\n{\n\tstruct files_struct *files;\n\n\ttask_lock(task);\n\tfiles = task->files;\n\tif (files)\n\t\tatomic_inc(&files->count);\n\ttask_unlock(task);\n\n\treturn files;\n}"
        }
      },
      {
        "call_info": {
          "callee": "proc_fd",
          "args": [
            "inode"
          ],
          "line": 89
        },
        "resolved": true,
        "details": {
          "function_name": "proc_fd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/fd.h",
          "lines": "14-17",
          "snippet": "static inline int proc_fd(struct inode *inode)\n{\n\treturn PROC_I(inode)->fd;\n}",
          "includes": [
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs.h>\n\nstatic inline int proc_fd(struct inode *inode)\n{\n\treturn PROC_I(inode)->fd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_proc_task",
          "args": [
            "inode"
          ],
          "line": 88
        },
        "resolved": true,
        "details": {
          "function_name": "get_proc_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/internal.h",
          "lines": "95-98",
          "snippet": "static inline struct task_struct *get_proc_task(struct inode *inode)\n{\n\treturn get_pid_task(proc_pid(inode), PIDTYPE_PID);\n}",
          "includes": [
            "#include <linux/binfmts.h>",
            "#include <linux/atomic.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int proc_tid_stat(struct seq_file *, struct pid_namespace *,\n\t\t\t struct pid *, struct task_struct *);",
            "extern int proc_tgid_stat(struct seq_file *, struct pid_namespace *,\n\t\t\t  struct pid *, struct task_struct *);",
            "extern int proc_pid_status(struct seq_file *, struct pid_namespace *,\n\t\t\t   struct pid *, struct task_struct *);",
            "extern int proc_pid_statm(struct seq_file *, struct pid_namespace *,\n\t\t\t  struct pid *, struct task_struct *);",
            "extern struct inode *proc_pid_make_inode(struct super_block *, struct task_struct *);",
            "extern bool proc_fill_cache(struct file *, struct dir_context *, const char *, int,\n\t\t\t   instantiate_t, struct task_struct *, const void *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/binfmts.h>\n#include <linux/atomic.h>\n#include <linux/spinlock.h>\n#include <linux/proc_ns.h>\n#include <linux/proc_fs.h>\n\nextern int proc_tid_stat(struct seq_file *, struct pid_namespace *,\n\t\t\t struct pid *, struct task_struct *);\nextern int proc_tgid_stat(struct seq_file *, struct pid_namespace *,\n\t\t\t  struct pid *, struct task_struct *);\nextern int proc_pid_status(struct seq_file *, struct pid_namespace *,\n\t\t\t   struct pid *, struct task_struct *);\nextern int proc_pid_statm(struct seq_file *, struct pid_namespace *,\n\t\t\t  struct pid *, struct task_struct *);\nextern struct inode *proc_pid_make_inode(struct super_block *, struct task_struct *);\nextern bool proc_fill_cache(struct file *, struct dir_context *, const char *, int,\n\t\t\t   instantiate_t, struct task_struct *, const void *);\n\nstatic inline struct task_struct *get_proc_task(struct inode *inode)\n{\n\treturn get_pid_task(proc_pid(inode), PIDTYPE_PID);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fd.h\"\n#include \"internal.h\"\n#include \"../mount.h\"\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/file.h>\n#include <linux/security.h>\n#include <linux/pid.h>\n#include <linux/namei.h>\n#include <linux/fdtable.h>\n#include <linux/path.h>\n#include <linux/dcache.h>\n#include <linux/errno.h>\n#include <linux/sched.h>\n\nstatic int tid_fd_revalidate(struct dentry *dentry, unsigned int flags)\n{\n\tstruct files_struct *files;\n\tstruct task_struct *task;\n\tconst struct cred *cred;\n\tstruct inode *inode;\n\tint fd;\n\n\tif (flags & LOOKUP_RCU)\n\t\treturn -ECHILD;\n\n\tinode = dentry->d_inode;\n\ttask = get_proc_task(inode);\n\tfd = proc_fd(inode);\n\n\tif (task) {\n\t\tfiles = get_files_struct(task);\n\t\tif (files) {\n\t\t\tstruct file *file;\n\n\t\t\trcu_read_lock();\n\t\t\tfile = fcheck_files(files, fd);\n\t\t\tif (file) {\n\t\t\t\tunsigned f_mode = file->f_mode;\n\n\t\t\t\trcu_read_unlock();\n\t\t\t\tput_files_struct(files);\n\n\t\t\t\tif (task_dumpable(task)) {\n\t\t\t\t\trcu_read_lock();\n\t\t\t\t\tcred = __task_cred(task);\n\t\t\t\t\tinode->i_uid = cred->euid;\n\t\t\t\t\tinode->i_gid = cred->egid;\n\t\t\t\t\trcu_read_unlock();\n\t\t\t\t} else {\n\t\t\t\t\tinode->i_uid = GLOBAL_ROOT_UID;\n\t\t\t\t\tinode->i_gid = GLOBAL_ROOT_GID;\n\t\t\t\t}\n\n\t\t\t\tif (S_ISLNK(inode->i_mode)) {\n\t\t\t\t\tunsigned i_mode = S_IFLNK;\n\t\t\t\t\tif (f_mode & FMODE_READ)\n\t\t\t\t\t\ti_mode |= S_IRUSR | S_IXUSR;\n\t\t\t\t\tif (f_mode & FMODE_WRITE)\n\t\t\t\t\t\ti_mode |= S_IWUSR | S_IXUSR;\n\t\t\t\t\tinode->i_mode = i_mode;\n\t\t\t\t}\n\n\t\t\t\tsecurity_task_to_inode(task, inode);\n\t\t\t\tput_task_struct(task);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\trcu_read_unlock();\n\t\t\tput_files_struct(files);\n\t\t}\n\t\tput_task_struct(task);\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "seq_fdinfo_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/fd.c",
    "lines": "64-67",
    "snippet": "static int seq_fdinfo_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, seq_show, inode);\n}",
    "includes": [
      "#include \"fd.h\"",
      "#include \"internal.h\"",
      "#include \"../mount.h\"",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/file.h>",
      "#include <linux/security.h>",
      "#include <linux/pid.h>",
      "#include <linux/namei.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/path.h>",
      "#include <linux/dcache.h>",
      "#include <linux/errno.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "single_open",
          "args": [
            "file",
            "seq_show",
            "inode"
          ],
          "line": 66
        },
        "resolved": true,
        "details": {
          "function_name": "single_open_net",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/proc_net.c",
          "lines": "63-84",
          "snippet": "int single_open_net(struct inode *inode, struct file *file,\n\t\tint (*show)(struct seq_file *, void *))\n{\n\tint err;\n\tstruct net *net;\n\n\terr = -ENXIO;\n\tnet = get_proc_net(inode);\n\tif (net == NULL)\n\t\tgoto err_net;\n\n\terr = single_open(file, show, net);\n\tif (err < 0)\n\t\tgoto err_open;\n\n\treturn 0;\n\nerr_open:\n\tput_net(net);\nerr_net:\n\treturn err;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/seq_file.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/mount.h>",
            "#include <linux/bitops.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <asm/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/seq_file.h>\n#include <net/net_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/mount.h>\n#include <linux/bitops.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\nint single_open_net(struct inode *inode, struct file *file,\n\t\tint (*show)(struct seq_file *, void *))\n{\n\tint err;\n\tstruct net *net;\n\n\terr = -ENXIO;\n\tnet = get_proc_net(inode);\n\tif (net == NULL)\n\t\tgoto err_net;\n\n\terr = single_open(file, show, net);\n\tif (err < 0)\n\t\tgoto err_open;\n\n\treturn 0;\n\nerr_open:\n\tput_net(net);\nerr_net:\n\treturn err;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fd.h\"\n#include \"internal.h\"\n#include \"../mount.h\"\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/file.h>\n#include <linux/security.h>\n#include <linux/pid.h>\n#include <linux/namei.h>\n#include <linux/fdtable.h>\n#include <linux/path.h>\n#include <linux/dcache.h>\n#include <linux/errno.h>\n#include <linux/sched.h>\n\nstatic int seq_fdinfo_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, seq_show, inode);\n}"
  },
  {
    "function_name": "seq_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/fd.c",
    "lines": "18-62",
    "snippet": "static int seq_show(struct seq_file *m, void *v)\n{\n\tstruct files_struct *files = NULL;\n\tint f_flags = 0, ret = -ENOENT;\n\tstruct file *file = NULL;\n\tstruct task_struct *task;\n\n\ttask = get_proc_task(m->private);\n\tif (!task)\n\t\treturn -ENOENT;\n\n\tfiles = get_files_struct(task);\n\tput_task_struct(task);\n\n\tif (files) {\n\t\tint fd = proc_fd(m->private);\n\n\t\tspin_lock(&files->file_lock);\n\t\tfile = fcheck_files(files, fd);\n\t\tif (file) {\n\t\t\tstruct fdtable *fdt = files_fdtable(files);\n\n\t\t\tf_flags = file->f_flags;\n\t\t\tif (close_on_exec(fd, fdt))\n\t\t\t\tf_flags |= O_CLOEXEC;\n\n\t\t\tget_file(file);\n\t\t\tret = 0;\n\t\t}\n\t\tspin_unlock(&files->file_lock);\n\t\tput_files_struct(files);\n\t}\n\n\tif (!ret) {\n\t\tseq_printf(m, \"pos:\\t%lli\\nflags:\\t0%o\\nmnt_id:\\t%i\\n\",\n\t\t\t   (long long)file->f_pos, f_flags,\n\t\t\t   real_mount(file->f_path.mnt)->mnt_id);\n\t\tif (file->f_op->show_fdinfo)\n\t\t\tfile->f_op->show_fdinfo(m, file);\n\t\tret = seq_has_overflowed(m);\n\t\tfput(file);\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include \"fd.h\"",
      "#include \"internal.h\"",
      "#include \"../mount.h\"",
      "#include <linux/proc_fs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/file.h>",
      "#include <linux/security.h>",
      "#include <linux/pid.h>",
      "#include <linux/namei.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/path.h>",
      "#include <linux/dcache.h>",
      "#include <linux/errno.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fput",
          "args": [
            "file"
          ],
          "line": 58
        },
        "resolved": true,
        "details": {
          "function_name": "__fput_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/file_table.c",
          "lines": "293-300",
          "snippet": "void __fput_sync(struct file *file)\n{\n\tif (atomic_long_dec_and_test(&file->f_count)) {\n\t\tstruct task_struct *task = current;\n\t\tBUG_ON(!(task->flags & PF_KTHREAD));\n\t\t__fput(file);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/atomic.h>",
            "#include <linux/ima.h>",
            "#include <linux/task_work.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/percpu.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/lglock.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/cdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/mount.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/security.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/atomic.h>\n#include <linux/ima.h>\n#include <linux/task_work.h>\n#include <linux/hardirq.h>\n#include <linux/percpu.h>\n#include <linux/percpu_counter.h>\n#include <linux/lglock.h>\n#include <linux/sysctl.h>\n#include <linux/fsnotify.h>\n#include <linux/cdev.h>\n#include <linux/capability.h>\n#include <linux/mount.h>\n#include <linux/rcupdate.h>\n#include <linux/eventpoll.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nvoid __fput_sync(struct file *file)\n{\n\tif (atomic_long_dec_and_test(&file->f_count)) {\n\t\tstruct task_struct *task = current;\n\t\tBUG_ON(!(task->flags & PF_KTHREAD));\n\t\t__fput(file);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_has_overflowed",
          "args": [
            "m"
          ],
          "line": 57
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file->f_op->show_fdinfo",
          "args": [
            "m",
            "file"
          ],
          "line": 56
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"pos:\\t%lli\\nflags:\\t0%o\\nmnt_id:\\t%i\\n\"",
            "(long long)file->f_pos",
            "f_flags",
            "real_mount(file->f_path.mnt)->mnt_id"
          ],
          "line": 52
        },
        "resolved": true,
        "details": {
          "function_name": "seq_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "416-426",
          "snippet": "int seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tint ret;\n\tva_list args;\n\n\tva_start(args, f);\n\tret = seq_vprintf(m, f, args);\n\tva_end(args);\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tint ret;\n\tva_list args;\n\n\tva_start(args, f);\n\tret = seq_vprintf(m, f, args);\n\tva_end(args);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "real_mount",
          "args": [
            "file->f_path.mnt"
          ],
          "line": 54
        },
        "resolved": true,
        "details": {
          "function_name": "real_mount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mount.h",
          "lines": "72-75",
          "snippet": "static inline struct mount *real_mount(struct vfsmount *mnt)\n{\n\treturn container_of(mnt, struct mount, mnt);\n}",
          "includes": [
            "#include <linux/fs_pin.h>",
            "#include <linux/ns_common.h>",
            "#include <linux/poll.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern bool legitimize_mnt(struct vfsmount *, unsigned);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs_pin.h>\n#include <linux/ns_common.h>\n#include <linux/poll.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n\nextern bool legitimize_mnt(struct vfsmount *, unsigned);\n\nstatic inline struct mount *real_mount(struct vfsmount *mnt)\n{\n\treturn container_of(mnt, struct mount, mnt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_files_struct",
          "args": [
            "files"
          ],
          "line": 48
        },
        "resolved": true,
        "details": {
          "function_name": "put_files_struct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/file.c",
          "lines": "394-404",
          "snippet": "void put_files_struct(struct files_struct *files)\n{\n\tif (atomic_dec_and_test(&files->count)) {\n\t\tstruct fdtable *fdt = close_files(files);\n\n\t\t/* free the arrays if they are not embedded */\n\t\tif (fdt != &files->fdtab)\n\t\t\t__free_fdtable(fdt);\n\t\tkmem_cache_free(files_cachep, files);\n\t}\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bitops.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/time.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/time.h>\n#include <linux/mmzone.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nvoid put_files_struct(struct files_struct *files)\n{\n\tif (atomic_dec_and_test(&files->count)) {\n\t\tstruct fdtable *fdt = close_files(files);\n\n\t\t/* free the arrays if they are not embedded */\n\t\tif (fdt != &files->fdtab)\n\t\t\t__free_fdtable(fdt);\n\t\tkmem_cache_free(files_cachep, files);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&files->file_lock"
          ],
          "line": 47
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_file",
          "args": [
            "file"
          ],
          "line": 44
        },
        "resolved": true,
        "details": {
          "function_name": "get_files_struct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/file.c",
          "lines": "381-392",
          "snippet": "struct files_struct *get_files_struct(struct task_struct *task)\n{\n\tstruct files_struct *files;\n\n\ttask_lock(task);\n\tfiles = task->files;\n\tif (files)\n\t\tatomic_inc(&files->count);\n\ttask_unlock(task);\n\n\treturn files;\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bitops.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/time.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/time.h>\n#include <linux/mmzone.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstruct files_struct *get_files_struct(struct task_struct *task)\n{\n\tstruct files_struct *files;\n\n\ttask_lock(task);\n\tfiles = task->files;\n\tif (files)\n\t\tatomic_inc(&files->count);\n\ttask_unlock(task);\n\n\treturn files;\n}"
        }
      },
      {
        "call_info": {
          "callee": "close_on_exec",
          "args": [
            "fd",
            "fdt"
          ],
          "line": 41
        },
        "resolved": true,
        "details": {
          "function_name": "set_close_on_exec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/file.c",
          "lines": "726-737",
          "snippet": "void set_close_on_exec(unsigned int fd, int flag)\n{\n\tstruct files_struct *files = current->files;\n\tstruct fdtable *fdt;\n\tspin_lock(&files->file_lock);\n\tfdt = files_fdtable(files);\n\tif (flag)\n\t\t__set_close_on_exec(fd, fdt);\n\telse\n\t\t__clear_close_on_exec(fd, fdt);\n\tspin_unlock(&files->file_lock);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bitops.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/time.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/time.h>\n#include <linux/mmzone.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nvoid set_close_on_exec(unsigned int fd, int flag)\n{\n\tstruct files_struct *files = current->files;\n\tstruct fdtable *fdt;\n\tspin_lock(&files->file_lock);\n\tfdt = files_fdtable(files);\n\tif (flag)\n\t\t__set_close_on_exec(fd, fdt);\n\telse\n\t\t__clear_close_on_exec(fd, fdt);\n\tspin_unlock(&files->file_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "files_fdtable",
          "args": [
            "files"
          ],
          "line": 38
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fcheck_files",
          "args": [
            "files",
            "fd"
          ],
          "line": 36
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&files->file_lock"
          ],
          "line": 35
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "proc_fd",
          "args": [
            "m->private"
          ],
          "line": 33
        },
        "resolved": true,
        "details": {
          "function_name": "proc_fd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/fd.h",
          "lines": "14-17",
          "snippet": "static inline int proc_fd(struct inode *inode)\n{\n\treturn PROC_I(inode)->fd;\n}",
          "includes": [
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs.h>\n\nstatic inline int proc_fd(struct inode *inode)\n{\n\treturn PROC_I(inode)->fd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_task_struct",
          "args": [
            "task"
          ],
          "line": 30
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_proc_task",
          "args": [
            "m->private"
          ],
          "line": 25
        },
        "resolved": true,
        "details": {
          "function_name": "get_proc_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/internal.h",
          "lines": "95-98",
          "snippet": "static inline struct task_struct *get_proc_task(struct inode *inode)\n{\n\treturn get_pid_task(proc_pid(inode), PIDTYPE_PID);\n}",
          "includes": [
            "#include <linux/binfmts.h>",
            "#include <linux/atomic.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int proc_tid_stat(struct seq_file *, struct pid_namespace *,\n\t\t\t struct pid *, struct task_struct *);",
            "extern int proc_tgid_stat(struct seq_file *, struct pid_namespace *,\n\t\t\t  struct pid *, struct task_struct *);",
            "extern int proc_pid_status(struct seq_file *, struct pid_namespace *,\n\t\t\t   struct pid *, struct task_struct *);",
            "extern int proc_pid_statm(struct seq_file *, struct pid_namespace *,\n\t\t\t  struct pid *, struct task_struct *);",
            "extern struct inode *proc_pid_make_inode(struct super_block *, struct task_struct *);",
            "extern bool proc_fill_cache(struct file *, struct dir_context *, const char *, int,\n\t\t\t   instantiate_t, struct task_struct *, const void *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/binfmts.h>\n#include <linux/atomic.h>\n#include <linux/spinlock.h>\n#include <linux/proc_ns.h>\n#include <linux/proc_fs.h>\n\nextern int proc_tid_stat(struct seq_file *, struct pid_namespace *,\n\t\t\t struct pid *, struct task_struct *);\nextern int proc_tgid_stat(struct seq_file *, struct pid_namespace *,\n\t\t\t  struct pid *, struct task_struct *);\nextern int proc_pid_status(struct seq_file *, struct pid_namespace *,\n\t\t\t   struct pid *, struct task_struct *);\nextern int proc_pid_statm(struct seq_file *, struct pid_namespace *,\n\t\t\t  struct pid *, struct task_struct *);\nextern struct inode *proc_pid_make_inode(struct super_block *, struct task_struct *);\nextern bool proc_fill_cache(struct file *, struct dir_context *, const char *, int,\n\t\t\t   instantiate_t, struct task_struct *, const void *);\n\nstatic inline struct task_struct *get_proc_task(struct inode *inode)\n{\n\treturn get_pid_task(proc_pid(inode), PIDTYPE_PID);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fd.h\"\n#include \"internal.h\"\n#include \"../mount.h\"\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/file.h>\n#include <linux/security.h>\n#include <linux/pid.h>\n#include <linux/namei.h>\n#include <linux/fdtable.h>\n#include <linux/path.h>\n#include <linux/dcache.h>\n#include <linux/errno.h>\n#include <linux/sched.h>\n\nstatic int seq_show(struct seq_file *m, void *v)\n{\n\tstruct files_struct *files = NULL;\n\tint f_flags = 0, ret = -ENOENT;\n\tstruct file *file = NULL;\n\tstruct task_struct *task;\n\n\ttask = get_proc_task(m->private);\n\tif (!task)\n\t\treturn -ENOENT;\n\n\tfiles = get_files_struct(task);\n\tput_task_struct(task);\n\n\tif (files) {\n\t\tint fd = proc_fd(m->private);\n\n\t\tspin_lock(&files->file_lock);\n\t\tfile = fcheck_files(files, fd);\n\t\tif (file) {\n\t\t\tstruct fdtable *fdt = files_fdtable(files);\n\n\t\t\tf_flags = file->f_flags;\n\t\t\tif (close_on_exec(fd, fdt))\n\t\t\t\tf_flags |= O_CLOEXEC;\n\n\t\t\tget_file(file);\n\t\t\tret = 0;\n\t\t}\n\t\tspin_unlock(&files->file_lock);\n\t\tput_files_struct(files);\n\t}\n\n\tif (!ret) {\n\t\tseq_printf(m, \"pos:\\t%lli\\nflags:\\t0%o\\nmnt_id:\\t%i\\n\",\n\t\t\t   (long long)file->f_pos, f_flags,\n\t\t\t   real_mount(file->f_path.mnt)->mnt_id);\n\t\tif (file->f_op->show_fdinfo)\n\t\t\tfile->f_op->show_fdinfo(m, file);\n\t\tret = seq_has_overflowed(m);\n\t\tfput(file);\n\t}\n\n\treturn ret;\n}"
  }
]