[
  {
    "function_name": "dlm_callback_resume",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/ast.c",
    "lines": "293-313",
    "snippet": "void dlm_callback_resume(struct dlm_ls *ls)\n{\n\tstruct dlm_lkb *lkb, *safe;\n\tint count = 0;\n\n\tclear_bit(LSFL_CB_DELAY, &ls->ls_flags);\n\n\tif (!ls->ls_callback_wq)\n\t\treturn;\n\n\tmutex_lock(&ls->ls_cb_mutex);\n\tlist_for_each_entry_safe(lkb, safe, &ls->ls_cb_delay, lkb_cb_list) {\n\t\tlist_del_init(&lkb->lkb_cb_list);\n\t\tqueue_work(ls->ls_callback_wq, &lkb->lkb_cb_work);\n\t\tcount++;\n\t}\n\tmutex_unlock(&ls->ls_cb_mutex);\n\n\tif (count)\n\t\tlog_rinfo(ls, \"dlm_callback_resume %d\", count);\n}",
    "includes": [
      "#include \"ast.h\"",
      "#include \"user.h\"",
      "#include \"lock.h\"",
      "#include \"dlm_internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "log_rinfo",
          "args": [
            "ls",
            "\"dlm_callback_resume %d\"",
            "count"
          ],
          "line": 312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ls->ls_cb_mutex"
          ],
          "line": 309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "queue_work",
          "args": [
            "ls->ls_callback_wq",
            "&lkb->lkb_cb_work"
          ],
          "line": 306
        },
        "resolved": true,
        "details": {
          "function_name": "bdi_queue_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "108-123",
          "snippet": "static void bdi_queue_work(struct backing_dev_info *bdi,\n\t\t\t   struct wb_writeback_work *work)\n{\n\ttrace_writeback_queue(bdi, work);\n\n\tspin_lock_bh(&bdi->wb_lock);\n\tif (!test_bit(BDI_registered, &bdi->state)) {\n\t\tif (work->done)\n\t\t\tcomplete(work->done);\n\t\tgoto out_unlock;\n\t}\n\tlist_add_tail(&work->list, &bdi->work_list);\n\tmod_delayed_work(bdi_wq, &bdi->wb.dwork, 0);\nout_unlock:\n\tspin_unlock_bh(&bdi->wb_lock);\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic void bdi_queue_work(struct backing_dev_info *bdi,\n\t\t\t   struct wb_writeback_work *work)\n{\n\ttrace_writeback_queue(bdi, work);\n\n\tspin_lock_bh(&bdi->wb_lock);\n\tif (!test_bit(BDI_registered, &bdi->state)) {\n\t\tif (work->done)\n\t\t\tcomplete(work->done);\n\t\tgoto out_unlock;\n\t}\n\tlist_add_tail(&work->list, &bdi->work_list);\n\tmod_delayed_work(bdi_wq, &bdi->wb.dwork, 0);\nout_unlock:\n\tspin_unlock_bh(&bdi->wb_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&lkb->lkb_cb_list"
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "lkb",
            "safe",
            "&ls->ls_cb_delay",
            "lkb_cb_list"
          ],
          "line": 304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&ls->ls_cb_mutex"
          ],
          "line": 303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "LSFL_CB_DELAY",
            "&ls->ls_flags"
          ],
          "line": 298
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clear_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "892-896",
          "snippet": "static inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ast.h\"\n#include \"user.h\"\n#include \"lock.h\"\n#include \"dlm_internal.h\"\n\nvoid dlm_callback_resume(struct dlm_ls *ls)\n{\n\tstruct dlm_lkb *lkb, *safe;\n\tint count = 0;\n\n\tclear_bit(LSFL_CB_DELAY, &ls->ls_flags);\n\n\tif (!ls->ls_callback_wq)\n\t\treturn;\n\n\tmutex_lock(&ls->ls_cb_mutex);\n\tlist_for_each_entry_safe(lkb, safe, &ls->ls_cb_delay, lkb_cb_list) {\n\t\tlist_del_init(&lkb->lkb_cb_list);\n\t\tqueue_work(ls->ls_callback_wq, &lkb->lkb_cb_work);\n\t\tcount++;\n\t}\n\tmutex_unlock(&ls->ls_cb_mutex);\n\n\tif (count)\n\t\tlog_rinfo(ls, \"dlm_callback_resume %d\", count);\n}"
  },
  {
    "function_name": "dlm_callback_suspend",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/ast.c",
    "lines": "285-291",
    "snippet": "void dlm_callback_suspend(struct dlm_ls *ls)\n{\n\tset_bit(LSFL_CB_DELAY, &ls->ls_flags);\n\n\tif (ls->ls_callback_wq)\n\t\tflush_workqueue(ls->ls_callback_wq);\n}",
    "includes": [
      "#include \"ast.h\"",
      "#include \"user.h\"",
      "#include \"lock.h\"",
      "#include \"dlm_internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "flush_workqueue",
          "args": [
            "ls->ls_callback_wq"
          ],
          "line": 290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "LSFL_CB_DELAY",
            "&ls->ls_flags"
          ],
          "line": 287
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ast.h\"\n#include \"user.h\"\n#include \"lock.h\"\n#include \"dlm_internal.h\"\n\nvoid dlm_callback_suspend(struct dlm_ls *ls)\n{\n\tset_bit(LSFL_CB_DELAY, &ls->ls_flags);\n\n\tif (ls->ls_callback_wq)\n\t\tflush_workqueue(ls->ls_callback_wq);\n}"
  },
  {
    "function_name": "dlm_callback_stop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/ast.c",
    "lines": "279-283",
    "snippet": "void dlm_callback_stop(struct dlm_ls *ls)\n{\n\tif (ls->ls_callback_wq)\n\t\tdestroy_workqueue(ls->ls_callback_wq);\n}",
    "includes": [
      "#include \"ast.h\"",
      "#include \"user.h\"",
      "#include \"lock.h\"",
      "#include \"dlm_internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "destroy_workqueue",
          "args": [
            "ls->ls_callback_wq"
          ],
          "line": 282
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_destroy_workqueue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/async-thread.c",
          "lines": "343-351",
          "snippet": "void btrfs_destroy_workqueue(struct btrfs_workqueue *wq)\n{\n\tif (!wq)\n\t\treturn;\n\tif (wq->high)\n\t\t__btrfs_destroy_workqueue(wq->high);\n\t__btrfs_destroy_workqueue(wq->normal);\n\tkfree(wq);\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"async-thread.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void\n__btrfs_destroy_workqueue(struct __btrfs_workqueue *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"async-thread.h\"\n#include <linux/freezer.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n\nstatic inline void\n__btrfs_destroy_workqueue(struct __btrfs_workqueue *wq);\n\nvoid btrfs_destroy_workqueue(struct btrfs_workqueue *wq)\n{\n\tif (!wq)\n\t\treturn;\n\tif (wq->high)\n\t\t__btrfs_destroy_workqueue(wq->high);\n\t__btrfs_destroy_workqueue(wq->normal);\n\tkfree(wq);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ast.h\"\n#include \"user.h\"\n#include \"lock.h\"\n#include \"dlm_internal.h\"\n\nvoid dlm_callback_stop(struct dlm_ls *ls)\n{\n\tif (ls->ls_callback_wq)\n\t\tdestroy_workqueue(ls->ls_callback_wq);\n}"
  },
  {
    "function_name": "dlm_callback_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/ast.c",
    "lines": "268-277",
    "snippet": "int dlm_callback_start(struct dlm_ls *ls)\n{\n\tls->ls_callback_wq = alloc_workqueue(\"dlm_callback\",\n\t\t\t\t\t     WQ_UNBOUND | WQ_MEM_RECLAIM, 0);\n\tif (!ls->ls_callback_wq) {\n\t\tlog_print(\"can't start dlm_callback workqueue\");\n\t\treturn -ENOMEM;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"ast.h\"",
      "#include \"user.h\"",
      "#include \"lock.h\"",
      "#include \"dlm_internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "log_print",
          "args": [
            "\"can't start dlm_callback workqueue\""
          ],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_workqueue",
          "args": [
            "\"dlm_callback\"",
            "WQ_UNBOUND | WQ_MEM_RECLAIM",
            "0"
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ast.h\"\n#include \"user.h\"\n#include \"lock.h\"\n#include \"dlm_internal.h\"\n\nint dlm_callback_start(struct dlm_ls *ls)\n{\n\tls->ls_callback_wq = alloc_workqueue(\"dlm_callback\",\n\t\t\t\t\t     WQ_UNBOUND | WQ_MEM_RECLAIM, 0);\n\tif (!ls->ls_callback_wq) {\n\t\tlog_print(\"can't start dlm_callback workqueue\");\n\t\treturn -ENOMEM;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "dlm_callback_work",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/ast.c",
    "lines": "213-266",
    "snippet": "void dlm_callback_work(struct work_struct *work)\n{\n\tstruct dlm_lkb *lkb = container_of(work, struct dlm_lkb, lkb_cb_work);\n\tstruct dlm_ls *ls = lkb->lkb_resource->res_ls;\n\tvoid (*castfn) (void *astparam);\n\tvoid (*bastfn) (void *astparam, int mode);\n\tstruct dlm_callback callbacks[DLM_CALLBACKS_SIZE];\n\tint i, rv, resid;\n\n\tmemset(&callbacks, 0, sizeof(callbacks));\n\n\tmutex_lock(&lkb->lkb_cb_mutex);\n\tif (!lkb->lkb_callbacks[0].seq) {\n\t\t/* no callback work exists, shouldn't happen */\n\t\tlog_error(ls, \"dlm_callback_work %x no work\", lkb->lkb_id);\n\t\tdlm_print_lkb(lkb);\n\t\tdlm_dump_lkb_callbacks(lkb);\n\t}\n\n\tfor (i = 0; i < DLM_CALLBACKS_SIZE; i++) {\n\t\trv = dlm_rem_lkb_callback(ls, lkb, &callbacks[i], &resid);\n\t\tif (rv < 0)\n\t\t\tbreak;\n\t}\n\n\tif (resid) {\n\t\t/* cbs remain, loop should have removed all, shouldn't happen */\n\t\tlog_error(ls, \"dlm_callback_work %x resid %d\", lkb->lkb_id,\n\t\t\t  resid);\n\t\tdlm_print_lkb(lkb);\n\t\tdlm_dump_lkb_callbacks(lkb);\n\t}\n\tmutex_unlock(&lkb->lkb_cb_mutex);\n\n\tcastfn = lkb->lkb_astfn;\n\tbastfn = lkb->lkb_bastfn;\n\n\tfor (i = 0; i < DLM_CALLBACKS_SIZE; i++) {\n\t\tif (!callbacks[i].seq)\n\t\t\tbreak;\n\t\tif (callbacks[i].flags & DLM_CB_SKIP) {\n\t\t\tcontinue;\n\t\t} else if (callbacks[i].flags & DLM_CB_BAST) {\n\t\t\tbastfn(lkb->lkb_astparam, callbacks[i].mode);\n\t\t} else if (callbacks[i].flags & DLM_CB_CAST) {\n\t\t\tlkb->lkb_lksb->sb_status = callbacks[i].sb_status;\n\t\t\tlkb->lkb_lksb->sb_flags = callbacks[i].sb_flags;\n\t\t\tcastfn(lkb->lkb_astparam);\n\t\t}\n\t}\n\n\t/* undo kref_get from dlm_add_callback, may cause lkb to be freed */\n\tdlm_put_lkb(lkb);\n}",
    "includes": [
      "#include \"ast.h\"",
      "#include \"user.h\"",
      "#include \"lock.h\"",
      "#include \"dlm_internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dlm_put_lkb",
          "args": [
            "lkb"
          ],
          "line": 265
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_put_lkb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "1269-1278",
          "snippet": "int dlm_put_lkb(struct dlm_lkb *lkb)\n{\n\tstruct dlm_ls *ls;\n\n\tDLM_ASSERT(lkb->lkb_resource, dlm_print_lkb(lkb););\n\tDLM_ASSERT(lkb->lkb_resource->res_ls, dlm_print_lkb(lkb););\n\n\tls = lkb->lkb_resource->res_ls;\n\treturn __put_lkb(ls, lkb);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nint dlm_put_lkb(struct dlm_lkb *lkb)\n{\n\tstruct dlm_ls *ls;\n\n\tDLM_ASSERT(lkb->lkb_resource, dlm_print_lkb(lkb););\n\tDLM_ASSERT(lkb->lkb_resource->res_ls, dlm_print_lkb(lkb););\n\n\tls = lkb->lkb_resource->res_ls;\n\treturn __put_lkb(ls, lkb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "castfn",
          "args": [
            "lkb->lkb_astparam"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bastfn",
          "args": [
            "lkb->lkb_astparam",
            "callbacks[i].mode"
          ],
          "line": 256
        },
        "resolved": true,
        "details": {
          "function_name": "fake_bastfn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "3904-3907",
          "snippet": "static void fake_bastfn(void *astparam, int mode)\n{\n\tlog_print(\"fake_bastfn should not be called\");\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_bast(struct dlm_rsb *r, struct dlm_lkb *lkb, int mode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_bast(struct dlm_rsb *r, struct dlm_lkb *lkb, int mode);\n\nstatic void fake_bastfn(void *astparam, int mode)\n{\n\tlog_print(\"fake_bastfn should not be called\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&lkb->lkb_cb_mutex"
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_dump_lkb_callbacks",
          "args": [
            "lkb"
          ],
          "line": 243
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dump_lkb_callbacks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/ast.c",
          "lines": "22-51",
          "snippet": "static void dlm_dump_lkb_callbacks(struct dlm_lkb *lkb)\n{\n\tint i;\n\n\tlog_print(\"last_bast %x %llu flags %x mode %d sb %d %x\",\n\t\t  lkb->lkb_id,\n\t\t  (unsigned long long)lkb->lkb_last_bast.seq,\n\t\t  lkb->lkb_last_bast.flags,\n\t\t  lkb->lkb_last_bast.mode,\n\t\t  lkb->lkb_last_bast.sb_status,\n\t\t  lkb->lkb_last_bast.sb_flags);\n\n\tlog_print(\"last_cast %x %llu flags %x mode %d sb %d %x\",\n\t\t  lkb->lkb_id,\n\t\t  (unsigned long long)lkb->lkb_last_cast.seq,\n\t\t  lkb->lkb_last_cast.flags,\n\t\t  lkb->lkb_last_cast.mode,\n\t\t  lkb->lkb_last_cast.sb_status,\n\t\t  lkb->lkb_last_cast.sb_flags);\n\n\tfor (i = 0; i < DLM_CALLBACKS_SIZE; i++) {\n\t\tlog_print(\"cb %x %llu flags %x mode %d sb %d %x\",\n\t\t\t  lkb->lkb_id,\n\t\t\t  (unsigned long long)lkb->lkb_callbacks[i].seq,\n\t\t\t  lkb->lkb_callbacks[i].flags,\n\t\t\t  lkb->lkb_callbacks[i].mode,\n\t\t\t  lkb->lkb_callbacks[i].sb_status,\n\t\t\t  lkb->lkb_callbacks[i].sb_flags);\n\t}\n}",
          "includes": [
            "#include \"ast.h\"",
            "#include \"user.h\"",
            "#include \"lock.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ast.h\"\n#include \"user.h\"\n#include \"lock.h\"\n#include \"dlm_internal.h\"\n\nstatic void dlm_dump_lkb_callbacks(struct dlm_lkb *lkb)\n{\n\tint i;\n\n\tlog_print(\"last_bast %x %llu flags %x mode %d sb %d %x\",\n\t\t  lkb->lkb_id,\n\t\t  (unsigned long long)lkb->lkb_last_bast.seq,\n\t\t  lkb->lkb_last_bast.flags,\n\t\t  lkb->lkb_last_bast.mode,\n\t\t  lkb->lkb_last_bast.sb_status,\n\t\t  lkb->lkb_last_bast.sb_flags);\n\n\tlog_print(\"last_cast %x %llu flags %x mode %d sb %d %x\",\n\t\t  lkb->lkb_id,\n\t\t  (unsigned long long)lkb->lkb_last_cast.seq,\n\t\t  lkb->lkb_last_cast.flags,\n\t\t  lkb->lkb_last_cast.mode,\n\t\t  lkb->lkb_last_cast.sb_status,\n\t\t  lkb->lkb_last_cast.sb_flags);\n\n\tfor (i = 0; i < DLM_CALLBACKS_SIZE; i++) {\n\t\tlog_print(\"cb %x %llu flags %x mode %d sb %d %x\",\n\t\t\t  lkb->lkb_id,\n\t\t\t  (unsigned long long)lkb->lkb_callbacks[i].seq,\n\t\t\t  lkb->lkb_callbacks[i].flags,\n\t\t\t  lkb->lkb_callbacks[i].mode,\n\t\t\t  lkb->lkb_callbacks[i].sb_status,\n\t\t\t  lkb->lkb_callbacks[i].sb_flags);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_print_lkb",
          "args": [
            "lkb"
          ],
          "line": 242
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_print_lkb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "162-170",
          "snippet": "void dlm_print_lkb(struct dlm_lkb *lkb)\n{\n\tprintk(KERN_ERR \"lkb: nodeid %d id %x remid %x exflags %x flags %x \"\n\t       \"sts %d rq %d gr %d wait_type %d wait_nodeid %d seq %llu\\n\",\n\t       lkb->lkb_nodeid, lkb->lkb_id, lkb->lkb_remid, lkb->lkb_exflags,\n\t       lkb->lkb_flags, lkb->lkb_status, lkb->lkb_rqmode,\n\t       lkb->lkb_grmode, lkb->lkb_wait_type, lkb->lkb_wait_nodeid,\n\t       (unsigned long long)lkb->lkb_recover_seq);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nvoid dlm_print_lkb(struct dlm_lkb *lkb)\n{\n\tprintk(KERN_ERR \"lkb: nodeid %d id %x remid %x exflags %x flags %x \"\n\t       \"sts %d rq %d gr %d wait_type %d wait_nodeid %d seq %llu\\n\",\n\t       lkb->lkb_nodeid, lkb->lkb_id, lkb->lkb_remid, lkb->lkb_exflags,\n\t       lkb->lkb_flags, lkb->lkb_status, lkb->lkb_rqmode,\n\t       lkb->lkb_grmode, lkb->lkb_wait_type, lkb->lkb_wait_nodeid,\n\t       (unsigned long long)lkb->lkb_recover_seq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "log_error",
          "args": [
            "ls",
            "\"dlm_callback_work %x resid %d\"",
            "lkb->lkb_id",
            "resid"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_rem_lkb_callback",
          "args": [
            "ls",
            "lkb",
            "&callbacks[i]",
            "&resid"
          ],
          "line": 233
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_rem_lkb_callback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/ast.c",
          "lines": "114-173",
          "snippet": "int dlm_rem_lkb_callback(struct dlm_ls *ls, struct dlm_lkb *lkb,\n\t\t\t struct dlm_callback *cb, int *resid)\n{\n\tint i, rv;\n\n\t*resid = 0;\n\n\tif (!lkb->lkb_callbacks[0].seq) {\n\t\trv = -ENOENT;\n\t\tgoto out;\n\t}\n\n\t/* oldest undelivered cb is callbacks[0] */\n\n\tmemcpy(cb, &lkb->lkb_callbacks[0], sizeof(struct dlm_callback));\n\tmemset(&lkb->lkb_callbacks[0], 0, sizeof(struct dlm_callback));\n\n\t/* shift others down */\n\n\tfor (i = 1; i < DLM_CALLBACKS_SIZE; i++) {\n\t\tif (!lkb->lkb_callbacks[i].seq)\n\t\t\tbreak;\n\t\tmemcpy(&lkb->lkb_callbacks[i-1], &lkb->lkb_callbacks[i],\n\t\t       sizeof(struct dlm_callback));\n\t\tmemset(&lkb->lkb_callbacks[i], 0, sizeof(struct dlm_callback));\n\t\t(*resid)++;\n\t}\n\n\t/* if cb is a bast, it should be skipped if the blocking mode is\n\t   compatible with the last granted mode */\n\n\tif ((cb->flags & DLM_CB_BAST) && lkb->lkb_last_cast.seq) {\n\t\tif (dlm_modes_compat(cb->mode, lkb->lkb_last_cast.mode)) {\n\t\t\tcb->flags |= DLM_CB_SKIP;\n\n\t\t\tlog_debug(ls, \"skip %x bast %llu mode %d \"\n\t\t\t\t  \"for cast %llu mode %d\",\n\t\t\t\t  lkb->lkb_id,\n\t\t\t\t  (unsigned long long)cb->seq,\n\t\t\t\t  cb->mode,\n\t\t\t\t  (unsigned long long)lkb->lkb_last_cast.seq,\n\t\t\t\t  lkb->lkb_last_cast.mode);\n\t\t\trv = 0;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (cb->flags & DLM_CB_CAST) {\n\t\tmemcpy(&lkb->lkb_last_cast, cb, sizeof(struct dlm_callback));\n\t\tlkb->lkb_last_cast_time = ktime_get();\n\t}\n\n\tif (cb->flags & DLM_CB_BAST) {\n\t\tmemcpy(&lkb->lkb_last_bast, cb, sizeof(struct dlm_callback));\n\t\tlkb->lkb_last_bast_time = ktime_get();\n\t}\n\trv = 0;\n out:\n\treturn rv;\n}",
          "includes": [
            "#include \"ast.h\"",
            "#include \"user.h\"",
            "#include \"lock.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ast.h\"\n#include \"user.h\"\n#include \"lock.h\"\n#include \"dlm_internal.h\"\n\nint dlm_rem_lkb_callback(struct dlm_ls *ls, struct dlm_lkb *lkb,\n\t\t\t struct dlm_callback *cb, int *resid)\n{\n\tint i, rv;\n\n\t*resid = 0;\n\n\tif (!lkb->lkb_callbacks[0].seq) {\n\t\trv = -ENOENT;\n\t\tgoto out;\n\t}\n\n\t/* oldest undelivered cb is callbacks[0] */\n\n\tmemcpy(cb, &lkb->lkb_callbacks[0], sizeof(struct dlm_callback));\n\tmemset(&lkb->lkb_callbacks[0], 0, sizeof(struct dlm_callback));\n\n\t/* shift others down */\n\n\tfor (i = 1; i < DLM_CALLBACKS_SIZE; i++) {\n\t\tif (!lkb->lkb_callbacks[i].seq)\n\t\t\tbreak;\n\t\tmemcpy(&lkb->lkb_callbacks[i-1], &lkb->lkb_callbacks[i],\n\t\t       sizeof(struct dlm_callback));\n\t\tmemset(&lkb->lkb_callbacks[i], 0, sizeof(struct dlm_callback));\n\t\t(*resid)++;\n\t}\n\n\t/* if cb is a bast, it should be skipped if the blocking mode is\n\t   compatible with the last granted mode */\n\n\tif ((cb->flags & DLM_CB_BAST) && lkb->lkb_last_cast.seq) {\n\t\tif (dlm_modes_compat(cb->mode, lkb->lkb_last_cast.mode)) {\n\t\t\tcb->flags |= DLM_CB_SKIP;\n\n\t\t\tlog_debug(ls, \"skip %x bast %llu mode %d \"\n\t\t\t\t  \"for cast %llu mode %d\",\n\t\t\t\t  lkb->lkb_id,\n\t\t\t\t  (unsigned long long)cb->seq,\n\t\t\t\t  cb->mode,\n\t\t\t\t  (unsigned long long)lkb->lkb_last_cast.seq,\n\t\t\t\t  lkb->lkb_last_cast.mode);\n\t\t\trv = 0;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (cb->flags & DLM_CB_CAST) {\n\t\tmemcpy(&lkb->lkb_last_cast, cb, sizeof(struct dlm_callback));\n\t\tlkb->lkb_last_cast_time = ktime_get();\n\t}\n\n\tif (cb->flags & DLM_CB_BAST) {\n\t\tmemcpy(&lkb->lkb_last_bast, cb, sizeof(struct dlm_callback));\n\t\tlkb->lkb_last_bast_time = ktime_get();\n\t}\n\trv = 0;\n out:\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "log_error",
          "args": [
            "ls",
            "\"dlm_callback_work %x no work\"",
            "lkb->lkb_id"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&lkb->lkb_cb_mutex"
          ],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&callbacks",
            "0",
            "sizeof(callbacks)"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "work",
            "structdlm_lkb",
            "lkb_cb_work"
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ast.h\"\n#include \"user.h\"\n#include \"lock.h\"\n#include \"dlm_internal.h\"\n\nvoid dlm_callback_work(struct work_struct *work)\n{\n\tstruct dlm_lkb *lkb = container_of(work, struct dlm_lkb, lkb_cb_work);\n\tstruct dlm_ls *ls = lkb->lkb_resource->res_ls;\n\tvoid (*castfn) (void *astparam);\n\tvoid (*bastfn) (void *astparam, int mode);\n\tstruct dlm_callback callbacks[DLM_CALLBACKS_SIZE];\n\tint i, rv, resid;\n\n\tmemset(&callbacks, 0, sizeof(callbacks));\n\n\tmutex_lock(&lkb->lkb_cb_mutex);\n\tif (!lkb->lkb_callbacks[0].seq) {\n\t\t/* no callback work exists, shouldn't happen */\n\t\tlog_error(ls, \"dlm_callback_work %x no work\", lkb->lkb_id);\n\t\tdlm_print_lkb(lkb);\n\t\tdlm_dump_lkb_callbacks(lkb);\n\t}\n\n\tfor (i = 0; i < DLM_CALLBACKS_SIZE; i++) {\n\t\trv = dlm_rem_lkb_callback(ls, lkb, &callbacks[i], &resid);\n\t\tif (rv < 0)\n\t\t\tbreak;\n\t}\n\n\tif (resid) {\n\t\t/* cbs remain, loop should have removed all, shouldn't happen */\n\t\tlog_error(ls, \"dlm_callback_work %x resid %d\", lkb->lkb_id,\n\t\t\t  resid);\n\t\tdlm_print_lkb(lkb);\n\t\tdlm_dump_lkb_callbacks(lkb);\n\t}\n\tmutex_unlock(&lkb->lkb_cb_mutex);\n\n\tcastfn = lkb->lkb_astfn;\n\tbastfn = lkb->lkb_bastfn;\n\n\tfor (i = 0; i < DLM_CALLBACKS_SIZE; i++) {\n\t\tif (!callbacks[i].seq)\n\t\t\tbreak;\n\t\tif (callbacks[i].flags & DLM_CB_SKIP) {\n\t\t\tcontinue;\n\t\t} else if (callbacks[i].flags & DLM_CB_BAST) {\n\t\t\tbastfn(lkb->lkb_astparam, callbacks[i].mode);\n\t\t} else if (callbacks[i].flags & DLM_CB_CAST) {\n\t\t\tlkb->lkb_lksb->sb_status = callbacks[i].sb_status;\n\t\t\tlkb->lkb_lksb->sb_flags = callbacks[i].sb_flags;\n\t\t\tcastfn(lkb->lkb_astparam);\n\t\t}\n\t}\n\n\t/* undo kref_get from dlm_add_callback, may cause lkb to be freed */\n\tdlm_put_lkb(lkb);\n}"
  },
  {
    "function_name": "dlm_add_cb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/ast.c",
    "lines": "175-211",
    "snippet": "void dlm_add_cb(struct dlm_lkb *lkb, uint32_t flags, int mode, int status,\n\t\tuint32_t sbflags)\n{\n\tstruct dlm_ls *ls = lkb->lkb_resource->res_ls;\n\tuint64_t new_seq, prev_seq;\n\tint rv;\n\n\tspin_lock(&dlm_cb_seq_spin);\n\tnew_seq = ++dlm_cb_seq;\n\tspin_unlock(&dlm_cb_seq_spin);\n\n\tif (lkb->lkb_flags & DLM_IFL_USER) {\n\t\tdlm_user_add_ast(lkb, flags, mode, status, sbflags, new_seq);\n\t\treturn;\n\t}\n\n\tmutex_lock(&lkb->lkb_cb_mutex);\n\tprev_seq = lkb->lkb_callbacks[0].seq;\n\n\trv = dlm_add_lkb_callback(lkb, flags, mode, status, sbflags, new_seq);\n\tif (rv < 0)\n\t\tgoto out;\n\n\tif (!prev_seq) {\n\t\tkref_get(&lkb->lkb_ref);\n\n\t\tif (test_bit(LSFL_CB_DELAY, &ls->ls_flags)) {\n\t\t\tmutex_lock(&ls->ls_cb_mutex);\n\t\t\tlist_add(&lkb->lkb_cb_list, &ls->ls_cb_delay);\n\t\t\tmutex_unlock(&ls->ls_cb_mutex);\n\t\t} else {\n\t\t\tqueue_work(ls->ls_callback_wq, &lkb->lkb_cb_work);\n\t\t}\n\t}\n out:\n\tmutex_unlock(&lkb->lkb_cb_mutex);\n}",
    "includes": [
      "#include \"ast.h\"",
      "#include \"user.h\"",
      "#include \"lock.h\"",
      "#include \"dlm_internal.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static uint64_t dlm_cb_seq;",
      "static DEFINE_SPINLOCK(dlm_cb_seq_spin);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&lkb->lkb_cb_mutex"
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "queue_work",
          "args": [
            "ls->ls_callback_wq",
            "&lkb->lkb_cb_work"
          ],
          "line": 206
        },
        "resolved": true,
        "details": {
          "function_name": "bdi_queue_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "108-123",
          "snippet": "static void bdi_queue_work(struct backing_dev_info *bdi,\n\t\t\t   struct wb_writeback_work *work)\n{\n\ttrace_writeback_queue(bdi, work);\n\n\tspin_lock_bh(&bdi->wb_lock);\n\tif (!test_bit(BDI_registered, &bdi->state)) {\n\t\tif (work->done)\n\t\t\tcomplete(work->done);\n\t\tgoto out_unlock;\n\t}\n\tlist_add_tail(&work->list, &bdi->work_list);\n\tmod_delayed_work(bdi_wq, &bdi->wb.dwork, 0);\nout_unlock:\n\tspin_unlock_bh(&bdi->wb_lock);\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic void bdi_queue_work(struct backing_dev_info *bdi,\n\t\t\t   struct wb_writeback_work *work)\n{\n\ttrace_writeback_queue(bdi, work);\n\n\tspin_lock_bh(&bdi->wb_lock);\n\tif (!test_bit(BDI_registered, &bdi->state)) {\n\t\tif (work->done)\n\t\t\tcomplete(work->done);\n\t\tgoto out_unlock;\n\t}\n\tlist_add_tail(&work->list, &bdi->work_list);\n\tmod_delayed_work(bdi_wq, &bdi->wb.dwork, 0);\nout_unlock:\n\tspin_unlock_bh(&bdi->wb_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ls->ls_cb_mutex"
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&lkb->lkb_cb_list",
            "&ls->ls_cb_delay"
          ],
          "line": 203
        },
        "resolved": true,
        "details": {
          "function_name": "simple_xattr_list_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "966-972",
          "snippet": "void simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&ls->ls_cb_mutex"
          ],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "LSFL_CB_DELAY",
            "&ls->ls_flags"
          ],
          "line": 201
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kref_get",
          "args": [
            "&lkb->lkb_ref"
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_add_lkb_callback",
          "args": [
            "lkb",
            "flags",
            "mode",
            "status",
            "sbflags",
            "new_seq"
          ],
          "line": 194
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_add_lkb_callback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/ast.c",
          "lines": "53-112",
          "snippet": "int dlm_add_lkb_callback(struct dlm_lkb *lkb, uint32_t flags, int mode,\n\t\t\t int status, uint32_t sbflags, uint64_t seq)\n{\n\tstruct dlm_ls *ls = lkb->lkb_resource->res_ls;\n\tuint64_t prev_seq;\n\tint prev_mode;\n\tint i, rv;\n\n\tfor (i = 0; i < DLM_CALLBACKS_SIZE; i++) {\n\t\tif (lkb->lkb_callbacks[i].seq)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Suppress some redundant basts here, do more on removal.\n\t\t * Don't even add a bast if the callback just before it\n\t\t * is a bast for the same mode or a more restrictive mode.\n\t\t * (the addional > PR check is needed for PR/CW inversion)\n\t\t */\n\n\t\tif ((i > 0) && (flags & DLM_CB_BAST) &&\n\t\t    (lkb->lkb_callbacks[i-1].flags & DLM_CB_BAST)) {\n\n\t\t\tprev_seq = lkb->lkb_callbacks[i-1].seq;\n\t\t\tprev_mode = lkb->lkb_callbacks[i-1].mode;\n\n\t\t\tif ((prev_mode == mode) ||\n\t\t\t    (prev_mode > mode && prev_mode > DLM_LOCK_PR)) {\n\n\t\t\t\tlog_debug(ls, \"skip %x add bast %llu mode %d \"\n\t\t\t\t\t  \"for bast %llu mode %d\",\n\t\t\t\t\t  lkb->lkb_id,\n\t\t\t\t\t  (unsigned long long)seq,\n\t\t\t\t\t  mode,\n\t\t\t\t\t  (unsigned long long)prev_seq,\n\t\t\t\t\t  prev_mode);\n\t\t\t\trv = 0;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\tlkb->lkb_callbacks[i].seq = seq;\n\t\tlkb->lkb_callbacks[i].flags = flags;\n\t\tlkb->lkb_callbacks[i].mode = mode;\n\t\tlkb->lkb_callbacks[i].sb_status = status;\n\t\tlkb->lkb_callbacks[i].sb_flags = (sbflags & 0x000000FF);\n\t\trv = 0;\n\t\tbreak;\n\t}\n\n\tif (i == DLM_CALLBACKS_SIZE) {\n\t\tlog_error(ls, \"no callbacks %x %llu flags %x mode %d sb %d %x\",\n\t\t\t  lkb->lkb_id, (unsigned long long)seq,\n\t\t\t  flags, mode, status, sbflags);\n\t\tdlm_dump_lkb_callbacks(lkb);\n\t\trv = -1;\n\t\tgoto out;\n\t}\n out:\n\treturn rv;\n}",
          "includes": [
            "#include \"ast.h\"",
            "#include \"user.h\"",
            "#include \"lock.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ast.h\"\n#include \"user.h\"\n#include \"lock.h\"\n#include \"dlm_internal.h\"\n\nint dlm_add_lkb_callback(struct dlm_lkb *lkb, uint32_t flags, int mode,\n\t\t\t int status, uint32_t sbflags, uint64_t seq)\n{\n\tstruct dlm_ls *ls = lkb->lkb_resource->res_ls;\n\tuint64_t prev_seq;\n\tint prev_mode;\n\tint i, rv;\n\n\tfor (i = 0; i < DLM_CALLBACKS_SIZE; i++) {\n\t\tif (lkb->lkb_callbacks[i].seq)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Suppress some redundant basts here, do more on removal.\n\t\t * Don't even add a bast if the callback just before it\n\t\t * is a bast for the same mode or a more restrictive mode.\n\t\t * (the addional > PR check is needed for PR/CW inversion)\n\t\t */\n\n\t\tif ((i > 0) && (flags & DLM_CB_BAST) &&\n\t\t    (lkb->lkb_callbacks[i-1].flags & DLM_CB_BAST)) {\n\n\t\t\tprev_seq = lkb->lkb_callbacks[i-1].seq;\n\t\t\tprev_mode = lkb->lkb_callbacks[i-1].mode;\n\n\t\t\tif ((prev_mode == mode) ||\n\t\t\t    (prev_mode > mode && prev_mode > DLM_LOCK_PR)) {\n\n\t\t\t\tlog_debug(ls, \"skip %x add bast %llu mode %d \"\n\t\t\t\t\t  \"for bast %llu mode %d\",\n\t\t\t\t\t  lkb->lkb_id,\n\t\t\t\t\t  (unsigned long long)seq,\n\t\t\t\t\t  mode,\n\t\t\t\t\t  (unsigned long long)prev_seq,\n\t\t\t\t\t  prev_mode);\n\t\t\t\trv = 0;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\tlkb->lkb_callbacks[i].seq = seq;\n\t\tlkb->lkb_callbacks[i].flags = flags;\n\t\tlkb->lkb_callbacks[i].mode = mode;\n\t\tlkb->lkb_callbacks[i].sb_status = status;\n\t\tlkb->lkb_callbacks[i].sb_flags = (sbflags & 0x000000FF);\n\t\trv = 0;\n\t\tbreak;\n\t}\n\n\tif (i == DLM_CALLBACKS_SIZE) {\n\t\tlog_error(ls, \"no callbacks %x %llu flags %x mode %d sb %d %x\",\n\t\t\t  lkb->lkb_id, (unsigned long long)seq,\n\t\t\t  flags, mode, status, sbflags);\n\t\tdlm_dump_lkb_callbacks(lkb);\n\t\trv = -1;\n\t\tgoto out;\n\t}\n out:\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&lkb->lkb_cb_mutex"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_user_add_ast",
          "args": [
            "lkb",
            "flags",
            "mode",
            "status",
            "sbflags",
            "new_seq"
          ],
          "line": 187
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_user_add_ast",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/user.c",
          "lines": "175-234",
          "snippet": "void dlm_user_add_ast(struct dlm_lkb *lkb, uint32_t flags, int mode,\n\t\t      int status, uint32_t sbflags, uint64_t seq)\n{\n\tstruct dlm_ls *ls;\n\tstruct dlm_user_args *ua;\n\tstruct dlm_user_proc *proc;\n\tint rv;\n\n\tif (lkb->lkb_flags & (DLM_IFL_ORPHAN | DLM_IFL_DEAD))\n\t\treturn;\n\n\tls = lkb->lkb_resource->res_ls;\n\tmutex_lock(&ls->ls_clear_proc_locks);\n\n\t/* If ORPHAN/DEAD flag is set, it means the process is dead so an ast\n\t   can't be delivered.  For ORPHAN's, dlm_clear_proc_locks() freed\n\t   lkb->ua so we can't try to use it.  This second check is necessary\n\t   for cases where a completion ast is received for an operation that\n\t   began before clear_proc_locks did its cancel/unlock. */\n\n\tif (lkb->lkb_flags & (DLM_IFL_ORPHAN | DLM_IFL_DEAD))\n\t\tgoto out;\n\n\tDLM_ASSERT(lkb->lkb_ua, dlm_print_lkb(lkb););\n\tua = lkb->lkb_ua;\n\tproc = ua->proc;\n\n\tif ((flags & DLM_CB_BAST) && ua->bastaddr == NULL)\n\t\tgoto out;\n\n\tif ((flags & DLM_CB_CAST) && lkb_is_endoflife(mode, status))\n\t\tlkb->lkb_flags |= DLM_IFL_ENDOFLIFE;\n\n\tspin_lock(&proc->asts_spin);\n\n\trv = dlm_add_lkb_callback(lkb, flags, mode, status, sbflags, seq);\n\tif (rv < 0) {\n\t\tspin_unlock(&proc->asts_spin);\n\t\tgoto out;\n\t}\n\n\tif (list_empty(&lkb->lkb_cb_list)) {\n\t\tkref_get(&lkb->lkb_ref);\n\t\tlist_add_tail(&lkb->lkb_cb_list, &proc->asts);\n\t\twake_up_interruptible(&proc->wait);\n\t}\n\tspin_unlock(&proc->asts_spin);\n\n\tif (lkb->lkb_flags & DLM_IFL_ENDOFLIFE) {\n\t\t/* N.B. spin_lock locks_spin, not asts_spin */\n\t\tspin_lock(&proc->locks_spin);\n\t\tif (!list_empty(&lkb->lkb_ownqueue)) {\n\t\t\tlist_del_init(&lkb->lkb_ownqueue);\n\t\t\tdlm_put_lkb(lkb);\n\t\t}\n\t\tspin_unlock(&proc->locks_spin);\n\t}\n out:\n\tmutex_unlock(&ls->ls_clear_proc_locks);\n}",
          "includes": [
            "#include \"ast.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"lock.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/dlm_device.h>",
            "#include <linux/dlm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/signal.h>",
            "#include <linux/poll.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/module.h>",
            "#include <linux/wait.h>",
            "#include <linux/init.h>",
            "#include <linux/miscdevice.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ast.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"lock.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/dlm_device.h>\n#include <linux/dlm.h>\n#include <linux/spinlock.h>\n#include <linux/signal.h>\n#include <linux/poll.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/module.h>\n#include <linux/wait.h>\n#include <linux/init.h>\n#include <linux/miscdevice.h>\n\nvoid dlm_user_add_ast(struct dlm_lkb *lkb, uint32_t flags, int mode,\n\t\t      int status, uint32_t sbflags, uint64_t seq)\n{\n\tstruct dlm_ls *ls;\n\tstruct dlm_user_args *ua;\n\tstruct dlm_user_proc *proc;\n\tint rv;\n\n\tif (lkb->lkb_flags & (DLM_IFL_ORPHAN | DLM_IFL_DEAD))\n\t\treturn;\n\n\tls = lkb->lkb_resource->res_ls;\n\tmutex_lock(&ls->ls_clear_proc_locks);\n\n\t/* If ORPHAN/DEAD flag is set, it means the process is dead so an ast\n\t   can't be delivered.  For ORPHAN's, dlm_clear_proc_locks() freed\n\t   lkb->ua so we can't try to use it.  This second check is necessary\n\t   for cases where a completion ast is received for an operation that\n\t   began before clear_proc_locks did its cancel/unlock. */\n\n\tif (lkb->lkb_flags & (DLM_IFL_ORPHAN | DLM_IFL_DEAD))\n\t\tgoto out;\n\n\tDLM_ASSERT(lkb->lkb_ua, dlm_print_lkb(lkb););\n\tua = lkb->lkb_ua;\n\tproc = ua->proc;\n\n\tif ((flags & DLM_CB_BAST) && ua->bastaddr == NULL)\n\t\tgoto out;\n\n\tif ((flags & DLM_CB_CAST) && lkb_is_endoflife(mode, status))\n\t\tlkb->lkb_flags |= DLM_IFL_ENDOFLIFE;\n\n\tspin_lock(&proc->asts_spin);\n\n\trv = dlm_add_lkb_callback(lkb, flags, mode, status, sbflags, seq);\n\tif (rv < 0) {\n\t\tspin_unlock(&proc->asts_spin);\n\t\tgoto out;\n\t}\n\n\tif (list_empty(&lkb->lkb_cb_list)) {\n\t\tkref_get(&lkb->lkb_ref);\n\t\tlist_add_tail(&lkb->lkb_cb_list, &proc->asts);\n\t\twake_up_interruptible(&proc->wait);\n\t}\n\tspin_unlock(&proc->asts_spin);\n\n\tif (lkb->lkb_flags & DLM_IFL_ENDOFLIFE) {\n\t\t/* N.B. spin_lock locks_spin, not asts_spin */\n\t\tspin_lock(&proc->locks_spin);\n\t\tif (!list_empty(&lkb->lkb_ownqueue)) {\n\t\t\tlist_del_init(&lkb->lkb_ownqueue);\n\t\t\tdlm_put_lkb(lkb);\n\t\t}\n\t\tspin_unlock(&proc->locks_spin);\n\t}\n out:\n\tmutex_unlock(&ls->ls_clear_proc_locks);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&dlm_cb_seq_spin"
          ],
          "line": 184
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&dlm_cb_seq_spin"
          ],
          "line": 182
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ast.h\"\n#include \"user.h\"\n#include \"lock.h\"\n#include \"dlm_internal.h\"\n\nstatic uint64_t dlm_cb_seq;\nstatic DEFINE_SPINLOCK(dlm_cb_seq_spin);\n\nvoid dlm_add_cb(struct dlm_lkb *lkb, uint32_t flags, int mode, int status,\n\t\tuint32_t sbflags)\n{\n\tstruct dlm_ls *ls = lkb->lkb_resource->res_ls;\n\tuint64_t new_seq, prev_seq;\n\tint rv;\n\n\tspin_lock(&dlm_cb_seq_spin);\n\tnew_seq = ++dlm_cb_seq;\n\tspin_unlock(&dlm_cb_seq_spin);\n\n\tif (lkb->lkb_flags & DLM_IFL_USER) {\n\t\tdlm_user_add_ast(lkb, flags, mode, status, sbflags, new_seq);\n\t\treturn;\n\t}\n\n\tmutex_lock(&lkb->lkb_cb_mutex);\n\tprev_seq = lkb->lkb_callbacks[0].seq;\n\n\trv = dlm_add_lkb_callback(lkb, flags, mode, status, sbflags, new_seq);\n\tif (rv < 0)\n\t\tgoto out;\n\n\tif (!prev_seq) {\n\t\tkref_get(&lkb->lkb_ref);\n\n\t\tif (test_bit(LSFL_CB_DELAY, &ls->ls_flags)) {\n\t\t\tmutex_lock(&ls->ls_cb_mutex);\n\t\t\tlist_add(&lkb->lkb_cb_list, &ls->ls_cb_delay);\n\t\t\tmutex_unlock(&ls->ls_cb_mutex);\n\t\t} else {\n\t\t\tqueue_work(ls->ls_callback_wq, &lkb->lkb_cb_work);\n\t\t}\n\t}\n out:\n\tmutex_unlock(&lkb->lkb_cb_mutex);\n}"
  },
  {
    "function_name": "dlm_rem_lkb_callback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/ast.c",
    "lines": "114-173",
    "snippet": "int dlm_rem_lkb_callback(struct dlm_ls *ls, struct dlm_lkb *lkb,\n\t\t\t struct dlm_callback *cb, int *resid)\n{\n\tint i, rv;\n\n\t*resid = 0;\n\n\tif (!lkb->lkb_callbacks[0].seq) {\n\t\trv = -ENOENT;\n\t\tgoto out;\n\t}\n\n\t/* oldest undelivered cb is callbacks[0] */\n\n\tmemcpy(cb, &lkb->lkb_callbacks[0], sizeof(struct dlm_callback));\n\tmemset(&lkb->lkb_callbacks[0], 0, sizeof(struct dlm_callback));\n\n\t/* shift others down */\n\n\tfor (i = 1; i < DLM_CALLBACKS_SIZE; i++) {\n\t\tif (!lkb->lkb_callbacks[i].seq)\n\t\t\tbreak;\n\t\tmemcpy(&lkb->lkb_callbacks[i-1], &lkb->lkb_callbacks[i],\n\t\t       sizeof(struct dlm_callback));\n\t\tmemset(&lkb->lkb_callbacks[i], 0, sizeof(struct dlm_callback));\n\t\t(*resid)++;\n\t}\n\n\t/* if cb is a bast, it should be skipped if the blocking mode is\n\t   compatible with the last granted mode */\n\n\tif ((cb->flags & DLM_CB_BAST) && lkb->lkb_last_cast.seq) {\n\t\tif (dlm_modes_compat(cb->mode, lkb->lkb_last_cast.mode)) {\n\t\t\tcb->flags |= DLM_CB_SKIP;\n\n\t\t\tlog_debug(ls, \"skip %x bast %llu mode %d \"\n\t\t\t\t  \"for cast %llu mode %d\",\n\t\t\t\t  lkb->lkb_id,\n\t\t\t\t  (unsigned long long)cb->seq,\n\t\t\t\t  cb->mode,\n\t\t\t\t  (unsigned long long)lkb->lkb_last_cast.seq,\n\t\t\t\t  lkb->lkb_last_cast.mode);\n\t\t\trv = 0;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (cb->flags & DLM_CB_CAST) {\n\t\tmemcpy(&lkb->lkb_last_cast, cb, sizeof(struct dlm_callback));\n\t\tlkb->lkb_last_cast_time = ktime_get();\n\t}\n\n\tif (cb->flags & DLM_CB_BAST) {\n\t\tmemcpy(&lkb->lkb_last_bast, cb, sizeof(struct dlm_callback));\n\t\tlkb->lkb_last_bast_time = ktime_get();\n\t}\n\trv = 0;\n out:\n\treturn rv;\n}",
    "includes": [
      "#include \"ast.h\"",
      "#include \"user.h\"",
      "#include \"lock.h\"",
      "#include \"dlm_internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ktime_get",
          "args": [],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&lkb->lkb_last_bast",
            "cb",
            "sizeof(struct dlm_callback)"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_get",
          "args": [],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&lkb->lkb_last_cast",
            "cb",
            "sizeof(struct dlm_callback)"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "log_debug",
          "args": [
            "ls",
            "\"skip %x bast %llu mode %d \"\n\t\t\t\t  \"for cast %llu mode %d\"",
            "lkb->lkb_id",
            "(unsigned long long)cb->seq",
            "cb->mode",
            "(unsigned long long)lkb->lkb_last_cast.seq",
            "lkb->lkb_last_cast.mode"
          ],
          "line": 149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_modes_compat",
          "args": [
            "cb->mode",
            "lkb->lkb_last_cast.mode"
          ],
          "line": 146
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_modes_compat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "139-142",
          "snippet": "int dlm_modes_compat(int mode1, int mode2)\n{\n\treturn __dlm_compat_matrix[mode1 + 1][mode2 + 1];\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const int __dlm_compat_matrix[8][8] = {\n      /* UN NL CR CW PR PW EX PD */\n        {1, 1, 1, 1, 1, 1, 1, 0},       /* UN */\n        {1, 1, 1, 1, 1, 1, 1, 0},       /* NL */\n        {1, 1, 1, 1, 1, 1, 0, 0},       /* CR */\n        {1, 1, 1, 1, 0, 0, 0, 0},       /* CW */\n        {1, 1, 1, 0, 1, 0, 0, 0},       /* PR */\n        {1, 1, 1, 0, 0, 0, 0, 0},       /* PW */\n        {1, 1, 0, 0, 0, 0, 0, 0},       /* EX */\n        {0, 0, 0, 0, 0, 0, 0, 0}        /* PD */\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic const int __dlm_compat_matrix[8][8] = {\n      /* UN NL CR CW PR PW EX PD */\n        {1, 1, 1, 1, 1, 1, 1, 0},       /* UN */\n        {1, 1, 1, 1, 1, 1, 1, 0},       /* NL */\n        {1, 1, 1, 1, 1, 1, 0, 0},       /* CR */\n        {1, 1, 1, 1, 0, 0, 0, 0},       /* CW */\n        {1, 1, 1, 0, 1, 0, 0, 0},       /* PR */\n        {1, 1, 1, 0, 0, 0, 0, 0},       /* PW */\n        {1, 1, 0, 0, 0, 0, 0, 0},       /* EX */\n        {0, 0, 0, 0, 0, 0, 0, 0}        /* PD */\n};\n\nint dlm_modes_compat(int mode1, int mode2)\n{\n\treturn __dlm_compat_matrix[mode1 + 1][mode2 + 1];\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&lkb->lkb_callbacks[i]",
            "0",
            "sizeof(struct dlm_callback)"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&lkb->lkb_callbacks[i-1]",
            "&lkb->lkb_callbacks[i]",
            "sizeof(struct dlm_callback)"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&lkb->lkb_callbacks[0]",
            "0",
            "sizeof(struct dlm_callback)"
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "cb",
            "&lkb->lkb_callbacks[0]",
            "sizeof(struct dlm_callback)"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ast.h\"\n#include \"user.h\"\n#include \"lock.h\"\n#include \"dlm_internal.h\"\n\nint dlm_rem_lkb_callback(struct dlm_ls *ls, struct dlm_lkb *lkb,\n\t\t\t struct dlm_callback *cb, int *resid)\n{\n\tint i, rv;\n\n\t*resid = 0;\n\n\tif (!lkb->lkb_callbacks[0].seq) {\n\t\trv = -ENOENT;\n\t\tgoto out;\n\t}\n\n\t/* oldest undelivered cb is callbacks[0] */\n\n\tmemcpy(cb, &lkb->lkb_callbacks[0], sizeof(struct dlm_callback));\n\tmemset(&lkb->lkb_callbacks[0], 0, sizeof(struct dlm_callback));\n\n\t/* shift others down */\n\n\tfor (i = 1; i < DLM_CALLBACKS_SIZE; i++) {\n\t\tif (!lkb->lkb_callbacks[i].seq)\n\t\t\tbreak;\n\t\tmemcpy(&lkb->lkb_callbacks[i-1], &lkb->lkb_callbacks[i],\n\t\t       sizeof(struct dlm_callback));\n\t\tmemset(&lkb->lkb_callbacks[i], 0, sizeof(struct dlm_callback));\n\t\t(*resid)++;\n\t}\n\n\t/* if cb is a bast, it should be skipped if the blocking mode is\n\t   compatible with the last granted mode */\n\n\tif ((cb->flags & DLM_CB_BAST) && lkb->lkb_last_cast.seq) {\n\t\tif (dlm_modes_compat(cb->mode, lkb->lkb_last_cast.mode)) {\n\t\t\tcb->flags |= DLM_CB_SKIP;\n\n\t\t\tlog_debug(ls, \"skip %x bast %llu mode %d \"\n\t\t\t\t  \"for cast %llu mode %d\",\n\t\t\t\t  lkb->lkb_id,\n\t\t\t\t  (unsigned long long)cb->seq,\n\t\t\t\t  cb->mode,\n\t\t\t\t  (unsigned long long)lkb->lkb_last_cast.seq,\n\t\t\t\t  lkb->lkb_last_cast.mode);\n\t\t\trv = 0;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (cb->flags & DLM_CB_CAST) {\n\t\tmemcpy(&lkb->lkb_last_cast, cb, sizeof(struct dlm_callback));\n\t\tlkb->lkb_last_cast_time = ktime_get();\n\t}\n\n\tif (cb->flags & DLM_CB_BAST) {\n\t\tmemcpy(&lkb->lkb_last_bast, cb, sizeof(struct dlm_callback));\n\t\tlkb->lkb_last_bast_time = ktime_get();\n\t}\n\trv = 0;\n out:\n\treturn rv;\n}"
  },
  {
    "function_name": "dlm_add_lkb_callback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/ast.c",
    "lines": "53-112",
    "snippet": "int dlm_add_lkb_callback(struct dlm_lkb *lkb, uint32_t flags, int mode,\n\t\t\t int status, uint32_t sbflags, uint64_t seq)\n{\n\tstruct dlm_ls *ls = lkb->lkb_resource->res_ls;\n\tuint64_t prev_seq;\n\tint prev_mode;\n\tint i, rv;\n\n\tfor (i = 0; i < DLM_CALLBACKS_SIZE; i++) {\n\t\tif (lkb->lkb_callbacks[i].seq)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Suppress some redundant basts here, do more on removal.\n\t\t * Don't even add a bast if the callback just before it\n\t\t * is a bast for the same mode or a more restrictive mode.\n\t\t * (the addional > PR check is needed for PR/CW inversion)\n\t\t */\n\n\t\tif ((i > 0) && (flags & DLM_CB_BAST) &&\n\t\t    (lkb->lkb_callbacks[i-1].flags & DLM_CB_BAST)) {\n\n\t\t\tprev_seq = lkb->lkb_callbacks[i-1].seq;\n\t\t\tprev_mode = lkb->lkb_callbacks[i-1].mode;\n\n\t\t\tif ((prev_mode == mode) ||\n\t\t\t    (prev_mode > mode && prev_mode > DLM_LOCK_PR)) {\n\n\t\t\t\tlog_debug(ls, \"skip %x add bast %llu mode %d \"\n\t\t\t\t\t  \"for bast %llu mode %d\",\n\t\t\t\t\t  lkb->lkb_id,\n\t\t\t\t\t  (unsigned long long)seq,\n\t\t\t\t\t  mode,\n\t\t\t\t\t  (unsigned long long)prev_seq,\n\t\t\t\t\t  prev_mode);\n\t\t\t\trv = 0;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\tlkb->lkb_callbacks[i].seq = seq;\n\t\tlkb->lkb_callbacks[i].flags = flags;\n\t\tlkb->lkb_callbacks[i].mode = mode;\n\t\tlkb->lkb_callbacks[i].sb_status = status;\n\t\tlkb->lkb_callbacks[i].sb_flags = (sbflags & 0x000000FF);\n\t\trv = 0;\n\t\tbreak;\n\t}\n\n\tif (i == DLM_CALLBACKS_SIZE) {\n\t\tlog_error(ls, \"no callbacks %x %llu flags %x mode %d sb %d %x\",\n\t\t\t  lkb->lkb_id, (unsigned long long)seq,\n\t\t\t  flags, mode, status, sbflags);\n\t\tdlm_dump_lkb_callbacks(lkb);\n\t\trv = -1;\n\t\tgoto out;\n\t}\n out:\n\treturn rv;\n}",
    "includes": [
      "#include \"ast.h\"",
      "#include \"user.h\"",
      "#include \"lock.h\"",
      "#include \"dlm_internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dlm_dump_lkb_callbacks",
          "args": [
            "lkb"
          ],
          "line": 106
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dump_lkb_callbacks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/ast.c",
          "lines": "22-51",
          "snippet": "static void dlm_dump_lkb_callbacks(struct dlm_lkb *lkb)\n{\n\tint i;\n\n\tlog_print(\"last_bast %x %llu flags %x mode %d sb %d %x\",\n\t\t  lkb->lkb_id,\n\t\t  (unsigned long long)lkb->lkb_last_bast.seq,\n\t\t  lkb->lkb_last_bast.flags,\n\t\t  lkb->lkb_last_bast.mode,\n\t\t  lkb->lkb_last_bast.sb_status,\n\t\t  lkb->lkb_last_bast.sb_flags);\n\n\tlog_print(\"last_cast %x %llu flags %x mode %d sb %d %x\",\n\t\t  lkb->lkb_id,\n\t\t  (unsigned long long)lkb->lkb_last_cast.seq,\n\t\t  lkb->lkb_last_cast.flags,\n\t\t  lkb->lkb_last_cast.mode,\n\t\t  lkb->lkb_last_cast.sb_status,\n\t\t  lkb->lkb_last_cast.sb_flags);\n\n\tfor (i = 0; i < DLM_CALLBACKS_SIZE; i++) {\n\t\tlog_print(\"cb %x %llu flags %x mode %d sb %d %x\",\n\t\t\t  lkb->lkb_id,\n\t\t\t  (unsigned long long)lkb->lkb_callbacks[i].seq,\n\t\t\t  lkb->lkb_callbacks[i].flags,\n\t\t\t  lkb->lkb_callbacks[i].mode,\n\t\t\t  lkb->lkb_callbacks[i].sb_status,\n\t\t\t  lkb->lkb_callbacks[i].sb_flags);\n\t}\n}",
          "includes": [
            "#include \"ast.h\"",
            "#include \"user.h\"",
            "#include \"lock.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ast.h\"\n#include \"user.h\"\n#include \"lock.h\"\n#include \"dlm_internal.h\"\n\nstatic void dlm_dump_lkb_callbacks(struct dlm_lkb *lkb)\n{\n\tint i;\n\n\tlog_print(\"last_bast %x %llu flags %x mode %d sb %d %x\",\n\t\t  lkb->lkb_id,\n\t\t  (unsigned long long)lkb->lkb_last_bast.seq,\n\t\t  lkb->lkb_last_bast.flags,\n\t\t  lkb->lkb_last_bast.mode,\n\t\t  lkb->lkb_last_bast.sb_status,\n\t\t  lkb->lkb_last_bast.sb_flags);\n\n\tlog_print(\"last_cast %x %llu flags %x mode %d sb %d %x\",\n\t\t  lkb->lkb_id,\n\t\t  (unsigned long long)lkb->lkb_last_cast.seq,\n\t\t  lkb->lkb_last_cast.flags,\n\t\t  lkb->lkb_last_cast.mode,\n\t\t  lkb->lkb_last_cast.sb_status,\n\t\t  lkb->lkb_last_cast.sb_flags);\n\n\tfor (i = 0; i < DLM_CALLBACKS_SIZE; i++) {\n\t\tlog_print(\"cb %x %llu flags %x mode %d sb %d %x\",\n\t\t\t  lkb->lkb_id,\n\t\t\t  (unsigned long long)lkb->lkb_callbacks[i].seq,\n\t\t\t  lkb->lkb_callbacks[i].flags,\n\t\t\t  lkb->lkb_callbacks[i].mode,\n\t\t\t  lkb->lkb_callbacks[i].sb_status,\n\t\t\t  lkb->lkb_callbacks[i].sb_flags);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "log_error",
          "args": [
            "ls",
            "\"no callbacks %x %llu flags %x mode %d sb %d %x\"",
            "lkb->lkb_id",
            "(unsigned long long)seq",
            "flags",
            "mode",
            "status",
            "sbflags"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "log_debug",
          "args": [
            "ls",
            "\"skip %x add bast %llu mode %d \"\n\t\t\t\t\t  \"for bast %llu mode %d\"",
            "lkb->lkb_id",
            "(unsigned long long)seq",
            "mode",
            "(unsigned long long)prev_seq",
            "prev_mode"
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ast.h\"\n#include \"user.h\"\n#include \"lock.h\"\n#include \"dlm_internal.h\"\n\nint dlm_add_lkb_callback(struct dlm_lkb *lkb, uint32_t flags, int mode,\n\t\t\t int status, uint32_t sbflags, uint64_t seq)\n{\n\tstruct dlm_ls *ls = lkb->lkb_resource->res_ls;\n\tuint64_t prev_seq;\n\tint prev_mode;\n\tint i, rv;\n\n\tfor (i = 0; i < DLM_CALLBACKS_SIZE; i++) {\n\t\tif (lkb->lkb_callbacks[i].seq)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Suppress some redundant basts here, do more on removal.\n\t\t * Don't even add a bast if the callback just before it\n\t\t * is a bast for the same mode or a more restrictive mode.\n\t\t * (the addional > PR check is needed for PR/CW inversion)\n\t\t */\n\n\t\tif ((i > 0) && (flags & DLM_CB_BAST) &&\n\t\t    (lkb->lkb_callbacks[i-1].flags & DLM_CB_BAST)) {\n\n\t\t\tprev_seq = lkb->lkb_callbacks[i-1].seq;\n\t\t\tprev_mode = lkb->lkb_callbacks[i-1].mode;\n\n\t\t\tif ((prev_mode == mode) ||\n\t\t\t    (prev_mode > mode && prev_mode > DLM_LOCK_PR)) {\n\n\t\t\t\tlog_debug(ls, \"skip %x add bast %llu mode %d \"\n\t\t\t\t\t  \"for bast %llu mode %d\",\n\t\t\t\t\t  lkb->lkb_id,\n\t\t\t\t\t  (unsigned long long)seq,\n\t\t\t\t\t  mode,\n\t\t\t\t\t  (unsigned long long)prev_seq,\n\t\t\t\t\t  prev_mode);\n\t\t\t\trv = 0;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\tlkb->lkb_callbacks[i].seq = seq;\n\t\tlkb->lkb_callbacks[i].flags = flags;\n\t\tlkb->lkb_callbacks[i].mode = mode;\n\t\tlkb->lkb_callbacks[i].sb_status = status;\n\t\tlkb->lkb_callbacks[i].sb_flags = (sbflags & 0x000000FF);\n\t\trv = 0;\n\t\tbreak;\n\t}\n\n\tif (i == DLM_CALLBACKS_SIZE) {\n\t\tlog_error(ls, \"no callbacks %x %llu flags %x mode %d sb %d %x\",\n\t\t\t  lkb->lkb_id, (unsigned long long)seq,\n\t\t\t  flags, mode, status, sbflags);\n\t\tdlm_dump_lkb_callbacks(lkb);\n\t\trv = -1;\n\t\tgoto out;\n\t}\n out:\n\treturn rv;\n}"
  },
  {
    "function_name": "dlm_dump_lkb_callbacks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/ast.c",
    "lines": "22-51",
    "snippet": "static void dlm_dump_lkb_callbacks(struct dlm_lkb *lkb)\n{\n\tint i;\n\n\tlog_print(\"last_bast %x %llu flags %x mode %d sb %d %x\",\n\t\t  lkb->lkb_id,\n\t\t  (unsigned long long)lkb->lkb_last_bast.seq,\n\t\t  lkb->lkb_last_bast.flags,\n\t\t  lkb->lkb_last_bast.mode,\n\t\t  lkb->lkb_last_bast.sb_status,\n\t\t  lkb->lkb_last_bast.sb_flags);\n\n\tlog_print(\"last_cast %x %llu flags %x mode %d sb %d %x\",\n\t\t  lkb->lkb_id,\n\t\t  (unsigned long long)lkb->lkb_last_cast.seq,\n\t\t  lkb->lkb_last_cast.flags,\n\t\t  lkb->lkb_last_cast.mode,\n\t\t  lkb->lkb_last_cast.sb_status,\n\t\t  lkb->lkb_last_cast.sb_flags);\n\n\tfor (i = 0; i < DLM_CALLBACKS_SIZE; i++) {\n\t\tlog_print(\"cb %x %llu flags %x mode %d sb %d %x\",\n\t\t\t  lkb->lkb_id,\n\t\t\t  (unsigned long long)lkb->lkb_callbacks[i].seq,\n\t\t\t  lkb->lkb_callbacks[i].flags,\n\t\t\t  lkb->lkb_callbacks[i].mode,\n\t\t\t  lkb->lkb_callbacks[i].sb_status,\n\t\t\t  lkb->lkb_callbacks[i].sb_flags);\n\t}\n}",
    "includes": [
      "#include \"ast.h\"",
      "#include \"user.h\"",
      "#include \"lock.h\"",
      "#include \"dlm_internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "log_print",
          "args": [
            "\"cb %x %llu flags %x mode %d sb %d %x\"",
            "lkb->lkb_id",
            "(unsigned long long)lkb->lkb_callbacks[i].seq",
            "lkb->lkb_callbacks[i].flags",
            "lkb->lkb_callbacks[i].mode",
            "lkb->lkb_callbacks[i].sb_status",
            "lkb->lkb_callbacks[i].sb_flags"
          ],
          "line": 43
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "log_print",
          "args": [
            "\"last_cast %x %llu flags %x mode %d sb %d %x\"",
            "lkb->lkb_id",
            "(unsigned long long)lkb->lkb_last_cast.seq",
            "lkb->lkb_last_cast.flags",
            "lkb->lkb_last_cast.mode",
            "lkb->lkb_last_cast.sb_status",
            "lkb->lkb_last_cast.sb_flags"
          ],
          "line": 34
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "log_print",
          "args": [
            "\"last_bast %x %llu flags %x mode %d sb %d %x\"",
            "lkb->lkb_id",
            "(unsigned long long)lkb->lkb_last_bast.seq",
            "lkb->lkb_last_bast.flags",
            "lkb->lkb_last_bast.mode",
            "lkb->lkb_last_bast.sb_status",
            "lkb->lkb_last_bast.sb_flags"
          ],
          "line": 26
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ast.h\"\n#include \"user.h\"\n#include \"lock.h\"\n#include \"dlm_internal.h\"\n\nstatic void dlm_dump_lkb_callbacks(struct dlm_lkb *lkb)\n{\n\tint i;\n\n\tlog_print(\"last_bast %x %llu flags %x mode %d sb %d %x\",\n\t\t  lkb->lkb_id,\n\t\t  (unsigned long long)lkb->lkb_last_bast.seq,\n\t\t  lkb->lkb_last_bast.flags,\n\t\t  lkb->lkb_last_bast.mode,\n\t\t  lkb->lkb_last_bast.sb_status,\n\t\t  lkb->lkb_last_bast.sb_flags);\n\n\tlog_print(\"last_cast %x %llu flags %x mode %d sb %d %x\",\n\t\t  lkb->lkb_id,\n\t\t  (unsigned long long)lkb->lkb_last_cast.seq,\n\t\t  lkb->lkb_last_cast.flags,\n\t\t  lkb->lkb_last_cast.mode,\n\t\t  lkb->lkb_last_cast.sb_status,\n\t\t  lkb->lkb_last_cast.sb_flags);\n\n\tfor (i = 0; i < DLM_CALLBACKS_SIZE; i++) {\n\t\tlog_print(\"cb %x %llu flags %x mode %d sb %d %x\",\n\t\t\t  lkb->lkb_id,\n\t\t\t  (unsigned long long)lkb->lkb_callbacks[i].seq,\n\t\t\t  lkb->lkb_callbacks[i].flags,\n\t\t\t  lkb->lkb_callbacks[i].mode,\n\t\t\t  lkb->lkb_callbacks[i].sb_status,\n\t\t\t  lkb->lkb_callbacks[i].sb_flags);\n\t}\n}"
  }
]