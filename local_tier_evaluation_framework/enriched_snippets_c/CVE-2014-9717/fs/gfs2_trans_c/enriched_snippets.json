[
  {
    "function_name": "gfs2_trans_add_unrevoke",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/trans.c",
    "lines": "259-278",
    "snippet": "void gfs2_trans_add_unrevoke(struct gfs2_sbd *sdp, u64 blkno, unsigned int len)\n{\n\tstruct gfs2_bufdata *bd, *tmp;\n\tstruct gfs2_trans *tr = current->journal_info;\n\tunsigned int n = len;\n\n\tgfs2_log_lock(sdp);\n\tlist_for_each_entry_safe(bd, tmp, &sdp->sd_log_le_revoke, bd_list) {\n\t\tif ((bd->bd_blkno >= blkno) && (bd->bd_blkno < (blkno + len))) {\n\t\t\tlist_del_init(&bd->bd_list);\n\t\t\tgfs2_assert_withdraw(sdp, sdp->sd_log_num_revoke);\n\t\t\tsdp->sd_log_num_revoke--;\n\t\t\tkmem_cache_free(gfs2_bufdata_cachep, bd);\n\t\t\ttr->tr_num_revoke_rm++;\n\t\t\tif (--n == 0)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tgfs2_log_unlock(sdp);\n}",
    "includes": [
      "#include \"trace_gfs2.h\"",
      "#include \"util.h\"",
      "#include \"trans.h\"",
      "#include \"meta_io.h\"",
      "#include \"lops.h\"",
      "#include \"log.h\"",
      "#include \"inode.h\"",
      "#include \"glock.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "gfs2_log_unlock",
          "args": [
            "sdp"
          ],
          "line": 277
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_log_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/log.h",
          "lines": "36-40",
          "snippet": "static inline void gfs2_log_unlock(struct gfs2_sbd *sdp)\n__releases(&sdp->sd_log_lock)\n{\n\tspin_unlock(&sdp->sd_log_lock);\n}",
          "includes": [
            "#include \"incore.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"incore.h\"\n#include <linux/writeback.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n\nstatic inline void gfs2_log_unlock(struct gfs2_sbd *sdp)\n__releases(&sdp->sd_log_lock)\n{\n\tspin_unlock(&sdp->sd_log_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "gfs2_bufdata_cachep",
            "bd"
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_assert_withdraw",
          "args": [
            "sdp",
            "sdp->sd_log_num_revoke"
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&bd->bd_list"
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "bd",
            "tmp",
            "&sdp->sd_log_le_revoke",
            "bd_list"
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_log_lock",
          "args": [
            "sdp"
          ],
          "line": 265
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_log_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/log.h",
          "lines": "24-28",
          "snippet": "static inline void gfs2_log_lock(struct gfs2_sbd *sdp)\n__acquires(&sdp->sd_log_lock)\n{\n\tspin_lock(&sdp->sd_log_lock);\n}",
          "includes": [
            "#include \"incore.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"incore.h\"\n#include <linux/writeback.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n\nstatic inline void gfs2_log_lock(struct gfs2_sbd *sdp)\n__acquires(&sdp->sd_log_lock)\n{\n\tspin_lock(&sdp->sd_log_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_trans_add_unrevoke(struct gfs2_sbd *sdp, u64 blkno, unsigned int len)\n{\n\tstruct gfs2_bufdata *bd, *tmp;\n\tstruct gfs2_trans *tr = current->journal_info;\n\tunsigned int n = len;\n\n\tgfs2_log_lock(sdp);\n\tlist_for_each_entry_safe(bd, tmp, &sdp->sd_log_le_revoke, bd_list) {\n\t\tif ((bd->bd_blkno >= blkno) && (bd->bd_blkno < (blkno + len))) {\n\t\t\tlist_del_init(&bd->bd_list);\n\t\t\tgfs2_assert_withdraw(sdp, sdp->sd_log_num_revoke);\n\t\t\tsdp->sd_log_num_revoke--;\n\t\t\tkmem_cache_free(gfs2_bufdata_cachep, bd);\n\t\t\ttr->tr_num_revoke_rm++;\n\t\t\tif (--n == 0)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tgfs2_log_unlock(sdp);\n}"
  },
  {
    "function_name": "gfs2_trans_add_revoke",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/trans.c",
    "lines": "249-257",
    "snippet": "void gfs2_trans_add_revoke(struct gfs2_sbd *sdp, struct gfs2_bufdata *bd)\n{\n\tstruct gfs2_trans *tr = current->journal_info;\n\n\tBUG_ON(!list_empty(&bd->bd_list));\n\tgfs2_add_revoke(sdp, bd);\n\ttr->tr_touched = 1;\n\ttr->tr_num_revoke++;\n}",
    "includes": [
      "#include \"trace_gfs2.h\"",
      "#include \"util.h\"",
      "#include \"trans.h\"",
      "#include \"meta_io.h\"",
      "#include \"lops.h\"",
      "#include \"log.h\"",
      "#include \"inode.h\"",
      "#include \"glock.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "gfs2_add_revoke",
          "args": [
            "sdp",
            "bd"
          ],
          "line": 254
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_add_revoke",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/log.c",
          "lines": "578-592",
          "snippet": "void gfs2_add_revoke(struct gfs2_sbd *sdp, struct gfs2_bufdata *bd)\n{\n\tstruct buffer_head *bh = bd->bd_bh;\n\tstruct gfs2_glock *gl = bd->bd_gl;\n\n\tbh->b_private = NULL;\n\tbd->bd_blkno = bh->b_blocknr;\n\tgfs2_remove_from_ail(bd); /* drops ref on bh */\n\tbd->bd_bh = NULL;\n\tbd->bd_ops = &gfs2_revoke_lops;\n\tsdp->sd_log_num_revoke++;\n\tatomic_inc(&gl->gl_revokes);\n\tset_bit(GLF_LFLUSH, &gl->gl_flags);\n\tlist_add(&bd->bd_list, &sdp->sd_log_le_revoke);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"log.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/list_sort.h>",
            "#include <linux/writeback.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"log.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/list_sort.h>\n#include <linux/writeback.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_add_revoke(struct gfs2_sbd *sdp, struct gfs2_bufdata *bd)\n{\n\tstruct buffer_head *bh = bd->bd_bh;\n\tstruct gfs2_glock *gl = bd->bd_gl;\n\n\tbh->b_private = NULL;\n\tbd->bd_blkno = bh->b_blocknr;\n\tgfs2_remove_from_ail(bd); /* drops ref on bh */\n\tbd->bd_bh = NULL;\n\tbd->bd_ops = &gfs2_revoke_lops;\n\tsdp->sd_log_num_revoke++;\n\tatomic_inc(&gl->gl_revokes);\n\tset_bit(GLF_LFLUSH, &gl->gl_flags);\n\tlist_add(&bd->bd_list, &sdp->sd_log_le_revoke);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!list_empty(&bd->bd_list)"
          ],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&bd->bd_list"
          ],
          "line": 253
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_trans_add_revoke(struct gfs2_sbd *sdp, struct gfs2_bufdata *bd)\n{\n\tstruct gfs2_trans *tr = current->journal_info;\n\n\tBUG_ON(!list_empty(&bd->bd_list));\n\tgfs2_add_revoke(sdp, bd);\n\ttr->tr_touched = 1;\n\ttr->tr_num_revoke++;\n}"
  },
  {
    "function_name": "gfs2_trans_add_meta",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/trans.c",
    "lines": "224-247",
    "snippet": "void gfs2_trans_add_meta(struct gfs2_glock *gl, struct buffer_head *bh)\n{\n\n\tstruct gfs2_sbd *sdp = gl->gl_sbd;\n\tstruct gfs2_bufdata *bd;\n\n\tlock_buffer(bh);\n\tgfs2_log_lock(sdp);\n\tbd = bh->b_private;\n\tif (bd == NULL) {\n\t\tgfs2_log_unlock(sdp);\n\t\tunlock_buffer(bh);\n\t\tlock_page(bh->b_page);\n\t\tif (bh->b_private == NULL)\n\t\t\tbd = gfs2_alloc_bufdata(gl, bh, &gfs2_buf_lops);\n\t\tunlock_page(bh->b_page);\n\t\tlock_buffer(bh);\n\t\tgfs2_log_lock(sdp);\n\t}\n\tgfs2_assert(sdp, bd->bd_gl == gl);\n\tmeta_lo_add(sdp, bd);\n\tgfs2_log_unlock(sdp);\n\tunlock_buffer(bh);\n}",
    "includes": [
      "#include \"trace_gfs2.h\"",
      "#include \"util.h\"",
      "#include \"trans.h\"",
      "#include \"meta_io.h\"",
      "#include \"lops.h\"",
      "#include \"log.h\"",
      "#include \"inode.h\"",
      "#include \"glock.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_buffer",
          "args": [
            "bh"
          ],
          "line": 246
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "70-75",
          "snippet": "void unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_log_unlock",
          "args": [
            "sdp"
          ],
          "line": 245
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_log_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/log.h",
          "lines": "36-40",
          "snippet": "static inline void gfs2_log_unlock(struct gfs2_sbd *sdp)\n__releases(&sdp->sd_log_lock)\n{\n\tspin_unlock(&sdp->sd_log_lock);\n}",
          "includes": [
            "#include \"incore.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"incore.h\"\n#include <linux/writeback.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n\nstatic inline void gfs2_log_unlock(struct gfs2_sbd *sdp)\n__releases(&sdp->sd_log_lock)\n{\n\tspin_unlock(&sdp->sd_log_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "meta_lo_add",
          "args": [
            "sdp",
            "bd"
          ],
          "line": 244
        },
        "resolved": true,
        "details": {
          "function_name": "meta_lo_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/trans.c",
          "lines": "195-222",
          "snippet": "static void meta_lo_add(struct gfs2_sbd *sdp, struct gfs2_bufdata *bd)\n{\n\tstruct gfs2_meta_header *mh;\n\tstruct gfs2_trans *tr;\n\tenum gfs2_freeze_state state = atomic_read(&sdp->sd_freeze_state);\n\n\ttr = current->journal_info;\n\ttr->tr_touched = 1;\n\tif (!list_empty(&bd->bd_list))\n\t\treturn;\n\tset_bit(GLF_LFLUSH, &bd->bd_gl->gl_flags);\n\tset_bit(GLF_DIRTY, &bd->bd_gl->gl_flags);\n\tmh = (struct gfs2_meta_header *)bd->bd_bh->b_data;\n\tif (unlikely(mh->mh_magic != cpu_to_be32(GFS2_MAGIC))) {\n\t\tpr_err(\"Attempting to add uninitialised block to journal (inplace block=%lld)\\n\",\n\t\t       (unsigned long long)bd->bd_bh->b_blocknr);\n\t\tBUG();\n\t}\n\tif (unlikely(state == SFS_FROZEN)) {\n\t\tprintk(KERN_INFO \"GFS2:adding buf while frozen\\n\");\n\t\tgfs2_assert_withdraw(sdp, 0);\n\t}\n\tgfs2_pin(sdp, bd->bd_bh);\n\tmh->__pad0 = cpu_to_be64(0);\n\tmh->mh_jid = cpu_to_be32(sdp->sd_jdesc->jd_jid);\n\tlist_add(&bd->bd_list, &tr->tr_buf);\n\ttr->tr_num_buf_new++;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic void meta_lo_add(struct gfs2_sbd *sdp, struct gfs2_bufdata *bd)\n{\n\tstruct gfs2_meta_header *mh;\n\tstruct gfs2_trans *tr;\n\tenum gfs2_freeze_state state = atomic_read(&sdp->sd_freeze_state);\n\n\ttr = current->journal_info;\n\ttr->tr_touched = 1;\n\tif (!list_empty(&bd->bd_list))\n\t\treturn;\n\tset_bit(GLF_LFLUSH, &bd->bd_gl->gl_flags);\n\tset_bit(GLF_DIRTY, &bd->bd_gl->gl_flags);\n\tmh = (struct gfs2_meta_header *)bd->bd_bh->b_data;\n\tif (unlikely(mh->mh_magic != cpu_to_be32(GFS2_MAGIC))) {\n\t\tpr_err(\"Attempting to add uninitialised block to journal (inplace block=%lld)\\n\",\n\t\t       (unsigned long long)bd->bd_bh->b_blocknr);\n\t\tBUG();\n\t}\n\tif (unlikely(state == SFS_FROZEN)) {\n\t\tprintk(KERN_INFO \"GFS2:adding buf while frozen\\n\");\n\t\tgfs2_assert_withdraw(sdp, 0);\n\t}\n\tgfs2_pin(sdp, bd->bd_bh);\n\tmh->__pad0 = cpu_to_be64(0);\n\tmh->mh_jid = cpu_to_be32(sdp->sd_jdesc->jd_jid);\n\tlist_add(&bd->bd_list, &tr->tr_buf);\n\ttr->tr_num_buf_new++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_assert",
          "args": [
            "sdp",
            "bd->bd_gl == gl"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_log_lock",
          "args": [
            "sdp"
          ],
          "line": 241
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_log_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/log.h",
          "lines": "24-28",
          "snippet": "static inline void gfs2_log_lock(struct gfs2_sbd *sdp)\n__acquires(&sdp->sd_log_lock)\n{\n\tspin_lock(&sdp->sd_log_lock);\n}",
          "includes": [
            "#include \"incore.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"incore.h\"\n#include <linux/writeback.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n\nstatic inline void gfs2_log_lock(struct gfs2_sbd *sdp)\n__acquires(&sdp->sd_log_lock)\n{\n\tspin_lock(&sdp->sd_log_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "bh->b_page"
          ],
          "line": 239
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_alloc_bufdata",
          "args": [
            "gl",
            "bh",
            "&gfs2_buf_lops"
          ],
          "line": 238
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_alloc_bufdata",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/trans.c",
          "lines": "125-138",
          "snippet": "static struct gfs2_bufdata *gfs2_alloc_bufdata(struct gfs2_glock *gl,\n\t\t\t\t\t       struct buffer_head *bh,\n\t\t\t\t\t       const struct gfs2_log_operations *lops)\n{\n\tstruct gfs2_bufdata *bd;\n\n\tbd = kmem_cache_zalloc(gfs2_bufdata_cachep, GFP_NOFS | __GFP_NOFAIL);\n\tbd->bd_bh = bh;\n\tbd->bd_gl = gl;\n\tbd->bd_ops = lops;\n\tINIT_LIST_HEAD(&bd->bd_list);\n\tbh->b_private = bd;\n\treturn bd;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct gfs2_bufdata *gfs2_alloc_bufdata(struct gfs2_glock *gl,\n\t\t\t\t\t       struct buffer_head *bh,\n\t\t\t\t\t       const struct gfs2_log_operations *lops)\n{\n\tstruct gfs2_bufdata *bd;\n\n\tbd = kmem_cache_zalloc(gfs2_bufdata_cachep, GFP_NOFS | __GFP_NOFAIL);\n\tbd->bd_bh = bh;\n\tbd->bd_gl = gl;\n\tbd->bd_ops = lops;\n\tINIT_LIST_HEAD(&bd->bd_list);\n\tbh->b_private = bd;\n\treturn bd;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_trans_add_meta(struct gfs2_glock *gl, struct buffer_head *bh)\n{\n\n\tstruct gfs2_sbd *sdp = gl->gl_sbd;\n\tstruct gfs2_bufdata *bd;\n\n\tlock_buffer(bh);\n\tgfs2_log_lock(sdp);\n\tbd = bh->b_private;\n\tif (bd == NULL) {\n\t\tgfs2_log_unlock(sdp);\n\t\tunlock_buffer(bh);\n\t\tlock_page(bh->b_page);\n\t\tif (bh->b_private == NULL)\n\t\t\tbd = gfs2_alloc_bufdata(gl, bh, &gfs2_buf_lops);\n\t\tunlock_page(bh->b_page);\n\t\tlock_buffer(bh);\n\t\tgfs2_log_lock(sdp);\n\t}\n\tgfs2_assert(sdp, bd->bd_gl == gl);\n\tmeta_lo_add(sdp, bd);\n\tgfs2_log_unlock(sdp);\n\tunlock_buffer(bh);\n}"
  },
  {
    "function_name": "meta_lo_add",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/trans.c",
    "lines": "195-222",
    "snippet": "static void meta_lo_add(struct gfs2_sbd *sdp, struct gfs2_bufdata *bd)\n{\n\tstruct gfs2_meta_header *mh;\n\tstruct gfs2_trans *tr;\n\tenum gfs2_freeze_state state = atomic_read(&sdp->sd_freeze_state);\n\n\ttr = current->journal_info;\n\ttr->tr_touched = 1;\n\tif (!list_empty(&bd->bd_list))\n\t\treturn;\n\tset_bit(GLF_LFLUSH, &bd->bd_gl->gl_flags);\n\tset_bit(GLF_DIRTY, &bd->bd_gl->gl_flags);\n\tmh = (struct gfs2_meta_header *)bd->bd_bh->b_data;\n\tif (unlikely(mh->mh_magic != cpu_to_be32(GFS2_MAGIC))) {\n\t\tpr_err(\"Attempting to add uninitialised block to journal (inplace block=%lld)\\n\",\n\t\t       (unsigned long long)bd->bd_bh->b_blocknr);\n\t\tBUG();\n\t}\n\tif (unlikely(state == SFS_FROZEN)) {\n\t\tprintk(KERN_INFO \"GFS2:adding buf while frozen\\n\");\n\t\tgfs2_assert_withdraw(sdp, 0);\n\t}\n\tgfs2_pin(sdp, bd->bd_bh);\n\tmh->__pad0 = cpu_to_be64(0);\n\tmh->mh_jid = cpu_to_be32(sdp->sd_jdesc->jd_jid);\n\tlist_add(&bd->bd_list, &tr->tr_buf);\n\ttr->tr_num_buf_new++;\n}",
    "includes": [
      "#include \"trace_gfs2.h\"",
      "#include \"util.h\"",
      "#include \"trans.h\"",
      "#include \"meta_io.h\"",
      "#include \"lops.h\"",
      "#include \"log.h\"",
      "#include \"inode.h\"",
      "#include \"glock.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&bd->bd_list",
            "&tr->tr_buf"
          ],
          "line": 220
        },
        "resolved": true,
        "details": {
          "function_name": "simple_xattr_list_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "966-972",
          "snippet": "void simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "sdp->sd_jdesc->jd_jid"
          ],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "0"
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_pin",
          "args": [
            "sdp",
            "bd->bd_bh"
          ],
          "line": 217
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_pin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/lops.c",
          "lines": "41-63",
          "snippet": "void gfs2_pin(struct gfs2_sbd *sdp, struct buffer_head *bh)\n{\n\tstruct gfs2_bufdata *bd;\n\n\tBUG_ON(!current->journal_info);\n\n\tclear_buffer_dirty(bh);\n\tif (test_set_buffer_pinned(bh))\n\t\tgfs2_assert_withdraw(sdp, 0);\n\tif (!buffer_uptodate(bh))\n\t\tgfs2_io_error_bh(sdp, bh);\n\tbd = bh->b_private;\n\t/* If this buffer is in the AIL and it has already been written\n\t * to in-place disk block, remove it from the AIL.\n\t */\n\tspin_lock(&sdp->sd_ail_lock);\n\tif (bd->bd_tr)\n\t\tlist_move(&bd->bd_ail_st_list, &bd->bd_tr->tr_ail2_list);\n\tspin_unlock(&sdp->sd_ail_lock);\n\tget_bh(bh);\n\tatomic_inc(&sdp->sd_log_pinned);\n\ttrace_gfs2_pin(bd, 1);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"recovery.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"log.h\"",
            "#include \"glock.h\"",
            "#include \"inode.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/list_sort.h>",
            "#include <linux/fs.h>",
            "#include <linux/bio.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/mempool.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"recovery.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"log.h\"\n#include \"glock.h\"\n#include \"inode.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/list_sort.h>\n#include <linux/fs.h>\n#include <linux/bio.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/mempool.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_pin(struct gfs2_sbd *sdp, struct buffer_head *bh)\n{\n\tstruct gfs2_bufdata *bd;\n\n\tBUG_ON(!current->journal_info);\n\n\tclear_buffer_dirty(bh);\n\tif (test_set_buffer_pinned(bh))\n\t\tgfs2_assert_withdraw(sdp, 0);\n\tif (!buffer_uptodate(bh))\n\t\tgfs2_io_error_bh(sdp, bh);\n\tbd = bh->b_private;\n\t/* If this buffer is in the AIL and it has already been written\n\t * to in-place disk block, remove it from the AIL.\n\t */\n\tspin_lock(&sdp->sd_ail_lock);\n\tif (bd->bd_tr)\n\t\tlist_move(&bd->bd_ail_st_list, &bd->bd_tr->tr_ail2_list);\n\tspin_unlock(&sdp->sd_ail_lock);\n\tget_bh(bh);\n\tatomic_inc(&sdp->sd_log_pinned);\n\ttrace_gfs2_pin(bd, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_assert_withdraw",
          "args": [
            "sdp",
            "0"
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_INFO \"GFS2:adding buf while frozen\\n\""
          ],
          "line": 214
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "state == SFS_FROZEN"
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Attempting to add uninitialised block to journal (inplace block=%lld)\\n\"",
            "(unsigned long long)bd->bd_bh->b_blocknr"
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "mh->mh_magic != cpu_to_be32(GFS2_MAGIC)"
          ],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "GFS2_MAGIC"
          ],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "GLF_DIRTY",
            "&bd->bd_gl->gl_flags"
          ],
          "line": 206
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&bd->bd_list"
          ],
          "line": 203
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&sdp->sd_freeze_state"
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic void meta_lo_add(struct gfs2_sbd *sdp, struct gfs2_bufdata *bd)\n{\n\tstruct gfs2_meta_header *mh;\n\tstruct gfs2_trans *tr;\n\tenum gfs2_freeze_state state = atomic_read(&sdp->sd_freeze_state);\n\n\ttr = current->journal_info;\n\ttr->tr_touched = 1;\n\tif (!list_empty(&bd->bd_list))\n\t\treturn;\n\tset_bit(GLF_LFLUSH, &bd->bd_gl->gl_flags);\n\tset_bit(GLF_DIRTY, &bd->bd_gl->gl_flags);\n\tmh = (struct gfs2_meta_header *)bd->bd_bh->b_data;\n\tif (unlikely(mh->mh_magic != cpu_to_be32(GFS2_MAGIC))) {\n\t\tpr_err(\"Attempting to add uninitialised block to journal (inplace block=%lld)\\n\",\n\t\t       (unsigned long long)bd->bd_bh->b_blocknr);\n\t\tBUG();\n\t}\n\tif (unlikely(state == SFS_FROZEN)) {\n\t\tprintk(KERN_INFO \"GFS2:adding buf while frozen\\n\");\n\t\tgfs2_assert_withdraw(sdp, 0);\n\t}\n\tgfs2_pin(sdp, bd->bd_bh);\n\tmh->__pad0 = cpu_to_be64(0);\n\tmh->mh_jid = cpu_to_be32(sdp->sd_jdesc->jd_jid);\n\tlist_add(&bd->bd_list, &tr->tr_buf);\n\ttr->tr_num_buf_new++;\n}"
  },
  {
    "function_name": "gfs2_trans_add_data",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/trans.c",
    "lines": "158-193",
    "snippet": "void gfs2_trans_add_data(struct gfs2_glock *gl, struct buffer_head *bh)\n{\n\tstruct gfs2_trans *tr = current->journal_info;\n\tstruct gfs2_sbd *sdp = gl->gl_sbd;\n\tstruct address_space *mapping = bh->b_page->mapping;\n\tstruct gfs2_inode *ip = GFS2_I(mapping->host);\n\tstruct gfs2_bufdata *bd;\n\n\tif (!gfs2_is_jdata(ip)) {\n\t\tgfs2_ordered_add_inode(ip);\n\t\treturn;\n\t}\n\n\tlock_buffer(bh);\n\tgfs2_log_lock(sdp);\n\tbd = bh->b_private;\n\tif (bd == NULL) {\n\t\tgfs2_log_unlock(sdp);\n\t\tunlock_buffer(bh);\n\t\tif (bh->b_private == NULL)\n\t\t\tbd = gfs2_alloc_bufdata(gl, bh, &gfs2_databuf_lops);\n\t\tlock_buffer(bh);\n\t\tgfs2_log_lock(sdp);\n\t}\n\tgfs2_assert(sdp, bd->bd_gl == gl);\n\ttr->tr_touched = 1;\n\tif (list_empty(&bd->bd_list)) {\n\t\tset_bit(GLF_LFLUSH, &bd->bd_gl->gl_flags);\n\t\tset_bit(GLF_DIRTY, &bd->bd_gl->gl_flags);\n\t\tgfs2_pin(sdp, bd->bd_bh);\n\t\ttr->tr_num_databuf_new++;\n\t\tlist_add_tail(&bd->bd_list, &tr->tr_databuf);\n\t}\n\tgfs2_log_unlock(sdp);\n\tunlock_buffer(bh);\n}",
    "includes": [
      "#include \"trace_gfs2.h\"",
      "#include \"util.h\"",
      "#include \"trans.h\"",
      "#include \"meta_io.h\"",
      "#include \"lops.h\"",
      "#include \"log.h\"",
      "#include \"inode.h\"",
      "#include \"glock.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_buffer",
          "args": [
            "bh"
          ],
          "line": 192
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "70-75",
          "snippet": "void unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_log_unlock",
          "args": [
            "sdp"
          ],
          "line": 191
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_log_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/log.h",
          "lines": "36-40",
          "snippet": "static inline void gfs2_log_unlock(struct gfs2_sbd *sdp)\n__releases(&sdp->sd_log_lock)\n{\n\tspin_unlock(&sdp->sd_log_lock);\n}",
          "includes": [
            "#include \"incore.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"incore.h\"\n#include <linux/writeback.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n\nstatic inline void gfs2_log_unlock(struct gfs2_sbd *sdp)\n__releases(&sdp->sd_log_lock)\n{\n\tspin_unlock(&sdp->sd_log_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&bd->bd_list",
            "&tr->tr_databuf"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_pin",
          "args": [
            "sdp",
            "bd->bd_bh"
          ],
          "line": 187
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_pin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/lops.c",
          "lines": "41-63",
          "snippet": "void gfs2_pin(struct gfs2_sbd *sdp, struct buffer_head *bh)\n{\n\tstruct gfs2_bufdata *bd;\n\n\tBUG_ON(!current->journal_info);\n\n\tclear_buffer_dirty(bh);\n\tif (test_set_buffer_pinned(bh))\n\t\tgfs2_assert_withdraw(sdp, 0);\n\tif (!buffer_uptodate(bh))\n\t\tgfs2_io_error_bh(sdp, bh);\n\tbd = bh->b_private;\n\t/* If this buffer is in the AIL and it has already been written\n\t * to in-place disk block, remove it from the AIL.\n\t */\n\tspin_lock(&sdp->sd_ail_lock);\n\tif (bd->bd_tr)\n\t\tlist_move(&bd->bd_ail_st_list, &bd->bd_tr->tr_ail2_list);\n\tspin_unlock(&sdp->sd_ail_lock);\n\tget_bh(bh);\n\tatomic_inc(&sdp->sd_log_pinned);\n\ttrace_gfs2_pin(bd, 1);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"recovery.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"log.h\"",
            "#include \"glock.h\"",
            "#include \"inode.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/list_sort.h>",
            "#include <linux/fs.h>",
            "#include <linux/bio.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/mempool.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"recovery.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"log.h\"\n#include \"glock.h\"\n#include \"inode.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/list_sort.h>\n#include <linux/fs.h>\n#include <linux/bio.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/mempool.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_pin(struct gfs2_sbd *sdp, struct buffer_head *bh)\n{\n\tstruct gfs2_bufdata *bd;\n\n\tBUG_ON(!current->journal_info);\n\n\tclear_buffer_dirty(bh);\n\tif (test_set_buffer_pinned(bh))\n\t\tgfs2_assert_withdraw(sdp, 0);\n\tif (!buffer_uptodate(bh))\n\t\tgfs2_io_error_bh(sdp, bh);\n\tbd = bh->b_private;\n\t/* If this buffer is in the AIL and it has already been written\n\t * to in-place disk block, remove it from the AIL.\n\t */\n\tspin_lock(&sdp->sd_ail_lock);\n\tif (bd->bd_tr)\n\t\tlist_move(&bd->bd_ail_st_list, &bd->bd_tr->tr_ail2_list);\n\tspin_unlock(&sdp->sd_ail_lock);\n\tget_bh(bh);\n\tatomic_inc(&sdp->sd_log_pinned);\n\ttrace_gfs2_pin(bd, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "GLF_DIRTY",
            "&bd->bd_gl->gl_flags"
          ],
          "line": 186
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&bd->bd_list"
          ],
          "line": 184
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_assert",
          "args": [
            "sdp",
            "bd->bd_gl == gl"
          ],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_log_lock",
          "args": [
            "sdp"
          ],
          "line": 180
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_log_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/log.h",
          "lines": "24-28",
          "snippet": "static inline void gfs2_log_lock(struct gfs2_sbd *sdp)\n__acquires(&sdp->sd_log_lock)\n{\n\tspin_lock(&sdp->sd_log_lock);\n}",
          "includes": [
            "#include \"incore.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"incore.h\"\n#include <linux/writeback.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n\nstatic inline void gfs2_log_lock(struct gfs2_sbd *sdp)\n__acquires(&sdp->sd_log_lock)\n{\n\tspin_lock(&sdp->sd_log_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_alloc_bufdata",
          "args": [
            "gl",
            "bh",
            "&gfs2_databuf_lops"
          ],
          "line": 178
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_alloc_bufdata",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/trans.c",
          "lines": "125-138",
          "snippet": "static struct gfs2_bufdata *gfs2_alloc_bufdata(struct gfs2_glock *gl,\n\t\t\t\t\t       struct buffer_head *bh,\n\t\t\t\t\t       const struct gfs2_log_operations *lops)\n{\n\tstruct gfs2_bufdata *bd;\n\n\tbd = kmem_cache_zalloc(gfs2_bufdata_cachep, GFP_NOFS | __GFP_NOFAIL);\n\tbd->bd_bh = bh;\n\tbd->bd_gl = gl;\n\tbd->bd_ops = lops;\n\tINIT_LIST_HEAD(&bd->bd_list);\n\tbh->b_private = bd;\n\treturn bd;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct gfs2_bufdata *gfs2_alloc_bufdata(struct gfs2_glock *gl,\n\t\t\t\t\t       struct buffer_head *bh,\n\t\t\t\t\t       const struct gfs2_log_operations *lops)\n{\n\tstruct gfs2_bufdata *bd;\n\n\tbd = kmem_cache_zalloc(gfs2_bufdata_cachep, GFP_NOFS | __GFP_NOFAIL);\n\tbd->bd_bh = bh;\n\tbd->bd_gl = gl;\n\tbd->bd_ops = lops;\n\tINIT_LIST_HEAD(&bd->bd_list);\n\tbh->b_private = bd;\n\treturn bd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_ordered_add_inode",
          "args": [
            "ip"
          ],
          "line": 167
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ordered_add_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/log.h",
          "lines": "51-61",
          "snippet": "static inline void gfs2_ordered_add_inode(struct gfs2_inode *ip)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\n\tif (!test_bit(GIF_ORDERED, &ip->i_flags)) {\n\t\tspin_lock(&sdp->sd_ordered_lock);\n\t\tif (!test_and_set_bit(GIF_ORDERED, &ip->i_flags))\n\t\t\tlist_add(&ip->i_ordered, &sdp->sd_log_le_ordered);\n\t\tspin_unlock(&sdp->sd_ordered_lock);\n\t}\n}",
          "includes": [
            "#include \"incore.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"incore.h\"\n#include <linux/writeback.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n\nstatic inline void gfs2_ordered_add_inode(struct gfs2_inode *ip)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\n\tif (!test_bit(GIF_ORDERED, &ip->i_flags)) {\n\t\tspin_lock(&sdp->sd_ordered_lock);\n\t\tif (!test_and_set_bit(GIF_ORDERED, &ip->i_flags))\n\t\t\tlist_add(&ip->i_ordered, &sdp->sd_log_le_ordered);\n\t\tspin_unlock(&sdp->sd_ordered_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_is_jdata",
          "args": [
            "ip"
          ],
          "line": 166
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_is_jdata",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/inode.h",
          "lines": "28-31",
          "snippet": "static inline int gfs2_is_jdata(const struct gfs2_inode *ip)\n{\n\treturn ip->i_diskflags & GFS2_DIF_JDATA;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include <linux/mm.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <linux/mm.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic inline int gfs2_is_jdata(const struct gfs2_inode *ip)\n{\n\treturn ip->i_diskflags & GFS2_DIF_JDATA;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GFS2_I",
          "args": [
            "mapping->host"
          ],
          "line": 163
        },
        "resolved": true,
        "details": {
          "function_name": "GFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/incore.h",
          "lines": "408-411",
          "snippet": "static inline struct gfs2_inode *GFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct gfs2_inode, i_inode);\n}",
          "includes": [
            "#include <linux/lockref.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ktime.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/completion.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dlm.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockref.h>\n#include <linux/percpu.h>\n#include <linux/ktime.h>\n#include <linux/rbtree.h>\n#include <linux/completion.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/buffer_head.h>\n#include <linux/dlm.h>\n#include <linux/workqueue.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n\nstatic inline struct gfs2_inode *GFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct gfs2_inode, i_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_trans_add_data(struct gfs2_glock *gl, struct buffer_head *bh)\n{\n\tstruct gfs2_trans *tr = current->journal_info;\n\tstruct gfs2_sbd *sdp = gl->gl_sbd;\n\tstruct address_space *mapping = bh->b_page->mapping;\n\tstruct gfs2_inode *ip = GFS2_I(mapping->host);\n\tstruct gfs2_bufdata *bd;\n\n\tif (!gfs2_is_jdata(ip)) {\n\t\tgfs2_ordered_add_inode(ip);\n\t\treturn;\n\t}\n\n\tlock_buffer(bh);\n\tgfs2_log_lock(sdp);\n\tbd = bh->b_private;\n\tif (bd == NULL) {\n\t\tgfs2_log_unlock(sdp);\n\t\tunlock_buffer(bh);\n\t\tif (bh->b_private == NULL)\n\t\t\tbd = gfs2_alloc_bufdata(gl, bh, &gfs2_databuf_lops);\n\t\tlock_buffer(bh);\n\t\tgfs2_log_lock(sdp);\n\t}\n\tgfs2_assert(sdp, bd->bd_gl == gl);\n\ttr->tr_touched = 1;\n\tif (list_empty(&bd->bd_list)) {\n\t\tset_bit(GLF_LFLUSH, &bd->bd_gl->gl_flags);\n\t\tset_bit(GLF_DIRTY, &bd->bd_gl->gl_flags);\n\t\tgfs2_pin(sdp, bd->bd_bh);\n\t\ttr->tr_num_databuf_new++;\n\t\tlist_add_tail(&bd->bd_list, &tr->tr_databuf);\n\t}\n\tgfs2_log_unlock(sdp);\n\tunlock_buffer(bh);\n}"
  },
  {
    "function_name": "gfs2_alloc_bufdata",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/trans.c",
    "lines": "125-138",
    "snippet": "static struct gfs2_bufdata *gfs2_alloc_bufdata(struct gfs2_glock *gl,\n\t\t\t\t\t       struct buffer_head *bh,\n\t\t\t\t\t       const struct gfs2_log_operations *lops)\n{\n\tstruct gfs2_bufdata *bd;\n\n\tbd = kmem_cache_zalloc(gfs2_bufdata_cachep, GFP_NOFS | __GFP_NOFAIL);\n\tbd->bd_bh = bh;\n\tbd->bd_gl = gl;\n\tbd->bd_ops = lops;\n\tINIT_LIST_HEAD(&bd->bd_list);\n\tbh->b_private = bd;\n\treturn bd;\n}",
    "includes": [
      "#include \"trace_gfs2.h\"",
      "#include \"util.h\"",
      "#include \"trans.h\"",
      "#include \"meta_io.h\"",
      "#include \"lops.h\"",
      "#include \"log.h\"",
      "#include \"inode.h\"",
      "#include \"glock.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&bd->bd_list"
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_zalloc",
          "args": [
            "gfs2_bufdata_cachep",
            "GFP_NOFS | __GFP_NOFAIL"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct gfs2_bufdata *gfs2_alloc_bufdata(struct gfs2_glock *gl,\n\t\t\t\t\t       struct buffer_head *bh,\n\t\t\t\t\t       const struct gfs2_log_operations *lops)\n{\n\tstruct gfs2_bufdata *bd;\n\n\tbd = kmem_cache_zalloc(gfs2_bufdata_cachep, GFP_NOFS | __GFP_NOFAIL);\n\tbd->bd_bh = bh;\n\tbd->bd_gl = gl;\n\tbd->bd_ops = lops;\n\tINIT_LIST_HEAD(&bd->bd_list);\n\tbh->b_private = bd;\n\treturn bd;\n}"
  },
  {
    "function_name": "gfs2_trans_end",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/trans.c",
    "lines": "88-123",
    "snippet": "void gfs2_trans_end(struct gfs2_sbd *sdp)\n{\n\tstruct gfs2_trans *tr = current->journal_info;\n\ts64 nbuf;\n\tint alloced = tr->tr_alloced;\n\n\tBUG_ON(!tr);\n\tcurrent->journal_info = NULL;\n\n\tif (!tr->tr_touched) {\n\t\tgfs2_log_release(sdp, tr->tr_reserved);\n\t\tif (alloced) {\n\t\t\tkfree(tr);\n\t\t\tsb_end_intwrite(sdp->sd_vfs);\n\t\t}\n\t\treturn;\n\t}\n\n\tnbuf = tr->tr_num_buf_new + tr->tr_num_databuf_new;\n\tnbuf -= tr->tr_num_buf_rm;\n\tnbuf -= tr->tr_num_databuf_rm;\n\n\tif (gfs2_assert_withdraw(sdp, (nbuf <= tr->tr_blocks) &&\n\t\t\t\t       (tr->tr_num_revoke <= tr->tr_revokes)))\n\t\tgfs2_print_trans(tr);\n\n\tgfs2_log_commit(sdp, tr);\n\tif (alloced && !tr->tr_attached)\n\t\t\tkfree(tr);\n\tup_read(&sdp->sd_log_flush_lock);\n\n\tif (sdp->sd_vfs->s_flags & MS_SYNCHRONOUS)\n\t\tgfs2_log_flush(sdp, NULL, NORMAL_FLUSH);\n\tif (alloced)\n\t\tsb_end_intwrite(sdp->sd_vfs);\n}",
    "includes": [
      "#include \"trace_gfs2.h\"",
      "#include \"util.h\"",
      "#include \"trans.h\"",
      "#include \"meta_io.h\"",
      "#include \"lops.h\"",
      "#include \"log.h\"",
      "#include \"inode.h\"",
      "#include \"glock.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sb_end_intwrite",
          "args": [
            "sdp->sd_vfs"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_log_flush",
          "args": [
            "sdp",
            "NULL",
            "NORMAL_FLUSH"
          ],
          "line": 120
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_log_flush",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/log.c",
          "lines": "704-787",
          "snippet": "void gfs2_log_flush(struct gfs2_sbd *sdp, struct gfs2_glock *gl,\n\t\t    enum gfs2_flush_type type)\n{\n\tstruct gfs2_trans *tr;\n\tenum gfs2_freeze_state state = atomic_read(&sdp->sd_freeze_state);\n\n\tdown_write(&sdp->sd_log_flush_lock);\n\n\t/* Log might have been flushed while we waited for the flush lock */\n\tif (gl && !test_bit(GLF_LFLUSH, &gl->gl_flags)) {\n\t\tup_write(&sdp->sd_log_flush_lock);\n\t\treturn;\n\t}\n\ttrace_gfs2_log_flush(sdp, 1);\n\n\tsdp->sd_log_flush_head = sdp->sd_log_head;\n\tsdp->sd_log_flush_wrapped = 0;\n\ttr = sdp->sd_log_tr;\n\tif (tr) {\n\t\tsdp->sd_log_tr = NULL;\n\t\tINIT_LIST_HEAD(&tr->tr_ail1_list);\n\t\tINIT_LIST_HEAD(&tr->tr_ail2_list);\n\t\ttr->tr_first = sdp->sd_log_flush_head;\n\t\tif (unlikely (state == SFS_FROZEN))\n\t\t\tgfs2_assert_withdraw(sdp, !tr->tr_num_buf_new && !tr->tr_num_databuf_new);\n\t}\n\n\tif (unlikely(state == SFS_FROZEN))\n\t\tgfs2_assert_withdraw(sdp, !sdp->sd_log_num_revoke);\n\tgfs2_assert_withdraw(sdp,\n\t\t\tsdp->sd_log_num_revoke == sdp->sd_log_commited_revoke);\n\n\tgfs2_ordered_write(sdp);\n\tlops_before_commit(sdp, tr);\n\tgfs2_log_flush_bio(sdp, WRITE);\n\n\tif (sdp->sd_log_head != sdp->sd_log_flush_head) {\n\t\tlog_flush_wait(sdp);\n\t\tlog_write_header(sdp, 0);\n\t} else if (sdp->sd_log_tail != current_tail(sdp) && !sdp->sd_log_idle){\n\t\tatomic_dec(&sdp->sd_log_blks_free); /* Adjust for unreserved buffer */\n\t\ttrace_gfs2_log_blocks(sdp, -1);\n\t\tlog_write_header(sdp, 0);\n\t}\n\tlops_after_commit(sdp, tr);\n\n\tgfs2_log_lock(sdp);\n\tsdp->sd_log_head = sdp->sd_log_flush_head;\n\tsdp->sd_log_blks_reserved = 0;\n\tsdp->sd_log_commited_revoke = 0;\n\n\tspin_lock(&sdp->sd_ail_lock);\n\tif (tr && !list_empty(&tr->tr_ail1_list)) {\n\t\tlist_add(&tr->tr_list, &sdp->sd_ail1_list);\n\t\ttr = NULL;\n\t}\n\tspin_unlock(&sdp->sd_ail_lock);\n\tgfs2_log_unlock(sdp);\n\n\tif (type != NORMAL_FLUSH) {\n\t\tif (!sdp->sd_log_idle) {\n\t\t\tfor (;;) {\n\t\t\t\tgfs2_ail1_start(sdp);\n\t\t\t\tgfs2_ail1_wait(sdp);\n\t\t\t\tif (gfs2_ail1_empty(sdp))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tatomic_dec(&sdp->sd_log_blks_free); /* Adjust for unreserved buffer */\n\t\t\ttrace_gfs2_log_blocks(sdp, -1);\n\t\t\tsdp->sd_log_flush_wrapped = 0;\n\t\t\tlog_write_header(sdp, 0);\n\t\t\tsdp->sd_log_head = sdp->sd_log_flush_head;\n\t\t}\n\t\tif (type == SHUTDOWN_FLUSH || type == FREEZE_FLUSH)\n\t\t\tgfs2_log_shutdown(sdp);\n\t\tif (type == FREEZE_FLUSH)\n\t\t\tatomic_set(&sdp->sd_freeze_state, SFS_FROZEN);\n\t}\n\n\ttrace_gfs2_log_flush(sdp, 0);\n\tup_write(&sdp->sd_log_flush_lock);\n\n\tkfree(tr);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"log.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/list_sort.h>",
            "#include <linux/writeback.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"log.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/list_sort.h>\n#include <linux/writeback.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_log_flush(struct gfs2_sbd *sdp, struct gfs2_glock *gl,\n\t\t    enum gfs2_flush_type type)\n{\n\tstruct gfs2_trans *tr;\n\tenum gfs2_freeze_state state = atomic_read(&sdp->sd_freeze_state);\n\n\tdown_write(&sdp->sd_log_flush_lock);\n\n\t/* Log might have been flushed while we waited for the flush lock */\n\tif (gl && !test_bit(GLF_LFLUSH, &gl->gl_flags)) {\n\t\tup_write(&sdp->sd_log_flush_lock);\n\t\treturn;\n\t}\n\ttrace_gfs2_log_flush(sdp, 1);\n\n\tsdp->sd_log_flush_head = sdp->sd_log_head;\n\tsdp->sd_log_flush_wrapped = 0;\n\ttr = sdp->sd_log_tr;\n\tif (tr) {\n\t\tsdp->sd_log_tr = NULL;\n\t\tINIT_LIST_HEAD(&tr->tr_ail1_list);\n\t\tINIT_LIST_HEAD(&tr->tr_ail2_list);\n\t\ttr->tr_first = sdp->sd_log_flush_head;\n\t\tif (unlikely (state == SFS_FROZEN))\n\t\t\tgfs2_assert_withdraw(sdp, !tr->tr_num_buf_new && !tr->tr_num_databuf_new);\n\t}\n\n\tif (unlikely(state == SFS_FROZEN))\n\t\tgfs2_assert_withdraw(sdp, !sdp->sd_log_num_revoke);\n\tgfs2_assert_withdraw(sdp,\n\t\t\tsdp->sd_log_num_revoke == sdp->sd_log_commited_revoke);\n\n\tgfs2_ordered_write(sdp);\n\tlops_before_commit(sdp, tr);\n\tgfs2_log_flush_bio(sdp, WRITE);\n\n\tif (sdp->sd_log_head != sdp->sd_log_flush_head) {\n\t\tlog_flush_wait(sdp);\n\t\tlog_write_header(sdp, 0);\n\t} else if (sdp->sd_log_tail != current_tail(sdp) && !sdp->sd_log_idle){\n\t\tatomic_dec(&sdp->sd_log_blks_free); /* Adjust for unreserved buffer */\n\t\ttrace_gfs2_log_blocks(sdp, -1);\n\t\tlog_write_header(sdp, 0);\n\t}\n\tlops_after_commit(sdp, tr);\n\n\tgfs2_log_lock(sdp);\n\tsdp->sd_log_head = sdp->sd_log_flush_head;\n\tsdp->sd_log_blks_reserved = 0;\n\tsdp->sd_log_commited_revoke = 0;\n\n\tspin_lock(&sdp->sd_ail_lock);\n\tif (tr && !list_empty(&tr->tr_ail1_list)) {\n\t\tlist_add(&tr->tr_list, &sdp->sd_ail1_list);\n\t\ttr = NULL;\n\t}\n\tspin_unlock(&sdp->sd_ail_lock);\n\tgfs2_log_unlock(sdp);\n\n\tif (type != NORMAL_FLUSH) {\n\t\tif (!sdp->sd_log_idle) {\n\t\t\tfor (;;) {\n\t\t\t\tgfs2_ail1_start(sdp);\n\t\t\t\tgfs2_ail1_wait(sdp);\n\t\t\t\tif (gfs2_ail1_empty(sdp))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tatomic_dec(&sdp->sd_log_blks_free); /* Adjust for unreserved buffer */\n\t\t\ttrace_gfs2_log_blocks(sdp, -1);\n\t\t\tsdp->sd_log_flush_wrapped = 0;\n\t\t\tlog_write_header(sdp, 0);\n\t\t\tsdp->sd_log_head = sdp->sd_log_flush_head;\n\t\t}\n\t\tif (type == SHUTDOWN_FLUSH || type == FREEZE_FLUSH)\n\t\t\tgfs2_log_shutdown(sdp);\n\t\tif (type == FREEZE_FLUSH)\n\t\t\tatomic_set(&sdp->sd_freeze_state, SFS_FROZEN);\n\t}\n\n\ttrace_gfs2_log_flush(sdp, 0);\n\tup_write(&sdp->sd_log_flush_lock);\n\n\tkfree(tr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&sdp->sd_log_flush_lock"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "tr"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_log_commit",
          "args": [
            "sdp",
            "tr"
          ],
          "line": 114
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_log_commit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/log.c",
          "lines": "855-863",
          "snippet": "void gfs2_log_commit(struct gfs2_sbd *sdp, struct gfs2_trans *tr)\n{\n\tlog_refund(sdp, tr);\n\n\tif (atomic_read(&sdp->sd_log_pinned) > atomic_read(&sdp->sd_log_thresh1) ||\n\t    ((sdp->sd_jdesc->jd_blocks - atomic_read(&sdp->sd_log_blks_free)) >\n\t    atomic_read(&sdp->sd_log_thresh2)))\n\t\twake_up(&sdp->sd_logd_waitq);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"log.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/list_sort.h>",
            "#include <linux/writeback.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"log.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/list_sort.h>\n#include <linux/writeback.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_log_commit(struct gfs2_sbd *sdp, struct gfs2_trans *tr)\n{\n\tlog_refund(sdp, tr);\n\n\tif (atomic_read(&sdp->sd_log_pinned) > atomic_read(&sdp->sd_log_thresh1) ||\n\t    ((sdp->sd_jdesc->jd_blocks - atomic_read(&sdp->sd_log_blks_free)) >\n\t    atomic_read(&sdp->sd_log_thresh2)))\n\t\twake_up(&sdp->sd_logd_waitq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_print_trans",
          "args": [
            "tr"
          ],
          "line": 112
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_print_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/trans.c",
          "lines": "77-86",
          "snippet": "static void gfs2_print_trans(const struct gfs2_trans *tr)\n{\n\tpr_warn(\"Transaction created at: %pSR\\n\", (void *)tr->tr_ip);\n\tpr_warn(\"blocks=%u revokes=%u reserved=%u touched=%u\\n\",\n\t\ttr->tr_blocks, tr->tr_revokes, tr->tr_reserved, tr->tr_touched);\n\tpr_warn(\"Buf %u/%u Databuf %u/%u Revoke %u/%u\\n\",\n\t\ttr->tr_num_buf_new, tr->tr_num_buf_rm,\n\t\ttr->tr_num_databuf_new, tr->tr_num_databuf_rm,\n\t\ttr->tr_num_revoke, tr->tr_num_revoke_rm);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic void gfs2_print_trans(const struct gfs2_trans *tr)\n{\n\tpr_warn(\"Transaction created at: %pSR\\n\", (void *)tr->tr_ip);\n\tpr_warn(\"blocks=%u revokes=%u reserved=%u touched=%u\\n\",\n\t\ttr->tr_blocks, tr->tr_revokes, tr->tr_reserved, tr->tr_touched);\n\tpr_warn(\"Buf %u/%u Databuf %u/%u Revoke %u/%u\\n\",\n\t\ttr->tr_num_buf_new, tr->tr_num_buf_rm,\n\t\ttr->tr_num_databuf_new, tr->tr_num_databuf_rm,\n\t\ttr->tr_num_revoke, tr->tr_num_revoke_rm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_assert_withdraw",
          "args": [
            "sdp",
            "(nbuf <= tr->tr_blocks) &&\n\t\t\t\t       (tr->tr_num_revoke <= tr->tr_revokes)"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_end_intwrite",
          "args": [
            "sdp->sd_vfs"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "tr"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_log_release",
          "args": [
            "sdp",
            "tr->tr_reserved"
          ],
          "line": 98
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_log_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/log.c",
          "lines": "310-318",
          "snippet": "void gfs2_log_release(struct gfs2_sbd *sdp, unsigned int blks)\n{\n\n\tatomic_add(blks, &sdp->sd_log_blks_free);\n\ttrace_gfs2_log_blocks(sdp, blks);\n\tgfs2_assert_withdraw(sdp, atomic_read(&sdp->sd_log_blks_free) <=\n\t\t\t\t  sdp->sd_jdesc->jd_blocks);\n\tup_read(&sdp->sd_log_flush_lock);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"log.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/list_sort.h>",
            "#include <linux/writeback.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"log.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/list_sort.h>\n#include <linux/writeback.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_log_release(struct gfs2_sbd *sdp, unsigned int blks)\n{\n\n\tatomic_add(blks, &sdp->sd_log_blks_free);\n\ttrace_gfs2_log_blocks(sdp, blks);\n\tgfs2_assert_withdraw(sdp, atomic_read(&sdp->sd_log_blks_free) <=\n\t\t\t\t  sdp->sd_jdesc->jd_blocks);\n\tup_read(&sdp->sd_log_flush_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!tr"
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_trans_end(struct gfs2_sbd *sdp)\n{\n\tstruct gfs2_trans *tr = current->journal_info;\n\ts64 nbuf;\n\tint alloced = tr->tr_alloced;\n\n\tBUG_ON(!tr);\n\tcurrent->journal_info = NULL;\n\n\tif (!tr->tr_touched) {\n\t\tgfs2_log_release(sdp, tr->tr_reserved);\n\t\tif (alloced) {\n\t\t\tkfree(tr);\n\t\t\tsb_end_intwrite(sdp->sd_vfs);\n\t\t}\n\t\treturn;\n\t}\n\n\tnbuf = tr->tr_num_buf_new + tr->tr_num_databuf_new;\n\tnbuf -= tr->tr_num_buf_rm;\n\tnbuf -= tr->tr_num_databuf_rm;\n\n\tif (gfs2_assert_withdraw(sdp, (nbuf <= tr->tr_blocks) &&\n\t\t\t\t       (tr->tr_num_revoke <= tr->tr_revokes)))\n\t\tgfs2_print_trans(tr);\n\n\tgfs2_log_commit(sdp, tr);\n\tif (alloced && !tr->tr_attached)\n\t\t\tkfree(tr);\n\tup_read(&sdp->sd_log_flush_lock);\n\n\tif (sdp->sd_vfs->s_flags & MS_SYNCHRONOUS)\n\t\tgfs2_log_flush(sdp, NULL, NORMAL_FLUSH);\n\tif (alloced)\n\t\tsb_end_intwrite(sdp->sd_vfs);\n}"
  },
  {
    "function_name": "gfs2_print_trans",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/trans.c",
    "lines": "77-86",
    "snippet": "static void gfs2_print_trans(const struct gfs2_trans *tr)\n{\n\tpr_warn(\"Transaction created at: %pSR\\n\", (void *)tr->tr_ip);\n\tpr_warn(\"blocks=%u revokes=%u reserved=%u touched=%u\\n\",\n\t\ttr->tr_blocks, tr->tr_revokes, tr->tr_reserved, tr->tr_touched);\n\tpr_warn(\"Buf %u/%u Databuf %u/%u Revoke %u/%u\\n\",\n\t\ttr->tr_num_buf_new, tr->tr_num_buf_rm,\n\t\ttr->tr_num_databuf_new, tr->tr_num_databuf_rm,\n\t\ttr->tr_num_revoke, tr->tr_num_revoke_rm);\n}",
    "includes": [
      "#include \"trace_gfs2.h\"",
      "#include \"util.h\"",
      "#include \"trans.h\"",
      "#include \"meta_io.h\"",
      "#include \"lops.h\"",
      "#include \"log.h\"",
      "#include \"inode.h\"",
      "#include \"glock.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"Buf %u/%u Databuf %u/%u Revoke %u/%u\\n\"",
            "tr->tr_num_buf_new",
            "tr->tr_num_buf_rm",
            "tr->tr_num_databuf_new",
            "tr->tr_num_databuf_rm",
            "tr->tr_num_revoke",
            "tr->tr_num_revoke_rm"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"blocks=%u revokes=%u reserved=%u touched=%u\\n\"",
            "tr->tr_blocks",
            "tr->tr_revokes",
            "tr->tr_reserved",
            "tr->tr_touched"
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"Transaction created at: %pSR\\n\"",
            "(void *)tr->tr_ip"
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic void gfs2_print_trans(const struct gfs2_trans *tr)\n{\n\tpr_warn(\"Transaction created at: %pSR\\n\", (void *)tr->tr_ip);\n\tpr_warn(\"blocks=%u revokes=%u reserved=%u touched=%u\\n\",\n\t\ttr->tr_blocks, tr->tr_revokes, tr->tr_reserved, tr->tr_touched);\n\tpr_warn(\"Buf %u/%u Databuf %u/%u Revoke %u/%u\\n\",\n\t\ttr->tr_num_buf_new, tr->tr_num_buf_rm,\n\t\ttr->tr_num_databuf_new, tr->tr_num_databuf_rm,\n\t\ttr->tr_num_revoke, tr->tr_num_revoke_rm);\n}"
  },
  {
    "function_name": "gfs2_trans_begin",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/trans.c",
    "lines": "31-75",
    "snippet": "int gfs2_trans_begin(struct gfs2_sbd *sdp, unsigned int blocks,\n\t\t     unsigned int revokes)\n{\n\tstruct gfs2_trans *tr;\n\tint error;\n\n\tBUG_ON(current->journal_info);\n\tBUG_ON(blocks == 0 && revokes == 0);\n\n\tif (!test_bit(SDF_JOURNAL_LIVE, &sdp->sd_flags))\n\t\treturn -EROFS;\n\n\ttr = kzalloc(sizeof(struct gfs2_trans), GFP_NOFS);\n\tif (!tr)\n\t\treturn -ENOMEM;\n\n\ttr->tr_ip = _RET_IP_;\n\ttr->tr_blocks = blocks;\n\ttr->tr_revokes = revokes;\n\ttr->tr_reserved = 1;\n\ttr->tr_alloced = 1;\n\tif (blocks)\n\t\ttr->tr_reserved += 6 + blocks;\n\tif (revokes)\n\t\ttr->tr_reserved += gfs2_struct2blk(sdp, revokes,\n\t\t\t\t\t\t   sizeof(u64));\n\tINIT_LIST_HEAD(&tr->tr_databuf);\n\tINIT_LIST_HEAD(&tr->tr_buf);\n\n\tsb_start_intwrite(sdp->sd_vfs);\n\n\terror = gfs2_log_reserve(sdp, tr->tr_reserved);\n\tif (error)\n\t\tgoto fail;\n\n\tcurrent->journal_info = tr;\n\n\treturn 0;\n\nfail:\n\tsb_end_intwrite(sdp->sd_vfs);\n\tkfree(tr);\n\n\treturn error;\n}",
    "includes": [
      "#include \"trace_gfs2.h\"",
      "#include \"util.h\"",
      "#include \"trans.h\"",
      "#include \"meta_io.h\"",
      "#include \"lops.h\"",
      "#include \"log.h\"",
      "#include \"inode.h\"",
      "#include \"glock.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "tr"
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_end_intwrite",
          "args": [
            "sdp->sd_vfs"
          ],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_log_reserve",
          "args": [
            "sdp",
            "tr->tr_reserved"
          ],
          "line": 62
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_log_reserve",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/log.c",
          "lines": "340-390",
          "snippet": "int gfs2_log_reserve(struct gfs2_sbd *sdp, unsigned int blks)\n{\n\tint ret = 0;\n\tunsigned reserved_blks = 7 * (4096 / sdp->sd_vfs->s_blocksize);\n\tunsigned wanted = blks + reserved_blks;\n\tDEFINE_WAIT(wait);\n\tint did_wait = 0;\n\tunsigned int free_blocks;\n\n\tif (gfs2_assert_warn(sdp, blks) ||\n\t    gfs2_assert_warn(sdp, blks <= sdp->sd_jdesc->jd_blocks))\n\t\treturn -EINVAL;\nretry:\n\tfree_blocks = atomic_read(&sdp->sd_log_blks_free);\n\tif (unlikely(free_blocks <= wanted)) {\n\t\tdo {\n\t\t\tprepare_to_wait_exclusive(&sdp->sd_log_waitq, &wait,\n\t\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\t\twake_up(&sdp->sd_logd_waitq);\n\t\t\tdid_wait = 1;\n\t\t\tif (atomic_read(&sdp->sd_log_blks_free) <= wanted)\n\t\t\t\tio_schedule();\n\t\t\tfree_blocks = atomic_read(&sdp->sd_log_blks_free);\n\t\t} while(free_blocks <= wanted);\n\t\tfinish_wait(&sdp->sd_log_waitq, &wait);\n\t}\n\tatomic_inc(&sdp->sd_reserving_log);\n\tif (atomic_cmpxchg(&sdp->sd_log_blks_free, free_blocks,\n\t\t\t\tfree_blocks - blks) != free_blocks) {\n\t\tif (atomic_dec_and_test(&sdp->sd_reserving_log))\n\t\t\twake_up(&sdp->sd_reserving_log_wait);\n\t\tgoto retry;\n\t}\n\ttrace_gfs2_log_blocks(sdp, -blks);\n\n\t/*\n\t * If we waited, then so might others, wake them up _after_ we get\n\t * our share of the log.\n\t */\n\tif (unlikely(did_wait))\n\t\twake_up(&sdp->sd_log_waitq);\n\n\tdown_read(&sdp->sd_log_flush_lock);\n\tif (unlikely(!test_bit(SDF_JOURNAL_LIVE, &sdp->sd_flags))) {\n\t\tgfs2_log_release(sdp, blks);\n\t\tret = -EROFS;\n\t}\n\tif (atomic_dec_and_test(&sdp->sd_reserving_log))\n\t\twake_up(&sdp->sd_reserving_log_wait);\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"log.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/list_sort.h>",
            "#include <linux/writeback.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"log.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/list_sort.h>\n#include <linux/writeback.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nint gfs2_log_reserve(struct gfs2_sbd *sdp, unsigned int blks)\n{\n\tint ret = 0;\n\tunsigned reserved_blks = 7 * (4096 / sdp->sd_vfs->s_blocksize);\n\tunsigned wanted = blks + reserved_blks;\n\tDEFINE_WAIT(wait);\n\tint did_wait = 0;\n\tunsigned int free_blocks;\n\n\tif (gfs2_assert_warn(sdp, blks) ||\n\t    gfs2_assert_warn(sdp, blks <= sdp->sd_jdesc->jd_blocks))\n\t\treturn -EINVAL;\nretry:\n\tfree_blocks = atomic_read(&sdp->sd_log_blks_free);\n\tif (unlikely(free_blocks <= wanted)) {\n\t\tdo {\n\t\t\tprepare_to_wait_exclusive(&sdp->sd_log_waitq, &wait,\n\t\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\t\twake_up(&sdp->sd_logd_waitq);\n\t\t\tdid_wait = 1;\n\t\t\tif (atomic_read(&sdp->sd_log_blks_free) <= wanted)\n\t\t\t\tio_schedule();\n\t\t\tfree_blocks = atomic_read(&sdp->sd_log_blks_free);\n\t\t} while(free_blocks <= wanted);\n\t\tfinish_wait(&sdp->sd_log_waitq, &wait);\n\t}\n\tatomic_inc(&sdp->sd_reserving_log);\n\tif (atomic_cmpxchg(&sdp->sd_log_blks_free, free_blocks,\n\t\t\t\tfree_blocks - blks) != free_blocks) {\n\t\tif (atomic_dec_and_test(&sdp->sd_reserving_log))\n\t\t\twake_up(&sdp->sd_reserving_log_wait);\n\t\tgoto retry;\n\t}\n\ttrace_gfs2_log_blocks(sdp, -blks);\n\n\t/*\n\t * If we waited, then so might others, wake them up _after_ we get\n\t * our share of the log.\n\t */\n\tif (unlikely(did_wait))\n\t\twake_up(&sdp->sd_log_waitq);\n\n\tdown_read(&sdp->sd_log_flush_lock);\n\tif (unlikely(!test_bit(SDF_JOURNAL_LIVE, &sdp->sd_flags))) {\n\t\tgfs2_log_release(sdp, blks);\n\t\tret = -EROFS;\n\t}\n\tif (atomic_dec_and_test(&sdp->sd_reserving_log))\n\t\twake_up(&sdp->sd_reserving_log_wait);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sb_start_intwrite",
          "args": [
            "sdp->sd_vfs"
          ],
          "line": 60
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&tr->tr_buf"
          ],
          "line": 58
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&tr->tr_databuf"
          ],
          "line": 57
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_struct2blk",
          "args": [
            "sdp",
            "revokes",
            "sizeof(u64)"
          ],
          "line": 55
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_struct2blk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/log.c",
          "lines": "48-64",
          "snippet": "unsigned int gfs2_struct2blk(struct gfs2_sbd *sdp, unsigned int nstruct,\n\t\t\t     unsigned int ssize)\n{\n\tunsigned int blks;\n\tunsigned int first, second;\n\n\tblks = 1;\n\tfirst = (sdp->sd_sb.sb_bsize - sizeof(struct gfs2_log_descriptor)) / ssize;\n\n\tif (nstruct > first) {\n\t\tsecond = (sdp->sd_sb.sb_bsize -\n\t\t\t  sizeof(struct gfs2_meta_header)) / ssize;\n\t\tblks += DIV_ROUND_UP(nstruct - first, second);\n\t}\n\n\treturn blks;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"log.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/list_sort.h>",
            "#include <linux/writeback.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"log.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/list_sort.h>\n#include <linux/writeback.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nunsigned int gfs2_struct2blk(struct gfs2_sbd *sdp, unsigned int nstruct,\n\t\t\t     unsigned int ssize)\n{\n\tunsigned int blks;\n\tunsigned int first, second;\n\n\tblks = 1;\n\tfirst = (sdp->sd_sb.sb_bsize - sizeof(struct gfs2_log_descriptor)) / ssize;\n\n\tif (nstruct > first) {\n\t\tsecond = (sdp->sd_sb.sb_bsize -\n\t\t\t  sizeof(struct gfs2_meta_header)) / ssize;\n\t\tblks += DIV_ROUND_UP(nstruct - first, second);\n\t}\n\n\treturn blks;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct gfs2_trans)",
            "GFP_NOFS"
          ],
          "line": 43
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "SDF_JOURNAL_LIVE",
            "&sdp->sd_flags"
          ],
          "line": 40
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "blocks == 0 && revokes == 0"
          ],
          "line": 38
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "current->journal_info"
          ],
          "line": 37
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nint gfs2_trans_begin(struct gfs2_sbd *sdp, unsigned int blocks,\n\t\t     unsigned int revokes)\n{\n\tstruct gfs2_trans *tr;\n\tint error;\n\n\tBUG_ON(current->journal_info);\n\tBUG_ON(blocks == 0 && revokes == 0);\n\n\tif (!test_bit(SDF_JOURNAL_LIVE, &sdp->sd_flags))\n\t\treturn -EROFS;\n\n\ttr = kzalloc(sizeof(struct gfs2_trans), GFP_NOFS);\n\tif (!tr)\n\t\treturn -ENOMEM;\n\n\ttr->tr_ip = _RET_IP_;\n\ttr->tr_blocks = blocks;\n\ttr->tr_revokes = revokes;\n\ttr->tr_reserved = 1;\n\ttr->tr_alloced = 1;\n\tif (blocks)\n\t\ttr->tr_reserved += 6 + blocks;\n\tif (revokes)\n\t\ttr->tr_reserved += gfs2_struct2blk(sdp, revokes,\n\t\t\t\t\t\t   sizeof(u64));\n\tINIT_LIST_HEAD(&tr->tr_databuf);\n\tINIT_LIST_HEAD(&tr->tr_buf);\n\n\tsb_start_intwrite(sdp->sd_vfs);\n\n\terror = gfs2_log_reserve(sdp, tr->tr_reserved);\n\tif (error)\n\t\tgoto fail;\n\n\tcurrent->journal_info = tr;\n\n\treturn 0;\n\nfail:\n\tsb_end_intwrite(sdp->sd_vfs);\n\tkfree(tr);\n\n\treturn error;\n}"
  }
]