[
  {
    "function_name": "ceph_mmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/addr.c",
    "lines": "1579-1588",
    "snippet": "int ceph_mmap(struct file *file, struct vm_area_struct *vma)\n{\n\tstruct address_space *mapping = file->f_mapping;\n\n\tif (!mapping->a_ops->readpage)\n\t\treturn -ENOEXEC;\n\tfile_accessed(file);\n\tvma->vm_ops = &ceph_vmops;\n\treturn 0;\n}",
    "includes": [
      "#include <linux/ceph/osd_client.h>",
      "#include \"cache.h\"",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/slab.h>",
      "#include <linux/writeback.h>\t/* generic_writepages */",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct vm_operations_struct ceph_vmops = {\n\t.fault\t\t= ceph_filemap_fault,\n\t.page_mkwrite\t= ceph_page_mkwrite,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "file_accessed",
          "args": [
            "file"
          ],
          "line": 1585
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/ceph/osd_client.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/task_io_accounting_ops.h>\n#include <linux/pagevec.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\t/* generic_writepages */\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/backing-dev.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic struct vm_operations_struct ceph_vmops = {\n\t.fault\t\t= ceph_filemap_fault,\n\t.page_mkwrite\t= ceph_page_mkwrite,\n};\n\nint ceph_mmap(struct file *file, struct vm_area_struct *vma)\n{\n\tstruct address_space *mapping = file->f_mapping;\n\n\tif (!mapping->a_ops->readpage)\n\t\treturn -ENOEXEC;\n\tfile_accessed(file);\n\tvma->vm_ops = &ceph_vmops;\n\treturn 0;\n}"
  },
  {
    "function_name": "ceph_uninline_data",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/addr.c",
    "lines": "1445-1572",
    "snippet": "int ceph_uninline_data(struct file *filp, struct page *locked_page)\n{\n\tstruct inode *inode = file_inode(filp);\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tstruct ceph_fs_client *fsc = ceph_inode_to_client(inode);\n\tstruct ceph_osd_request *req;\n\tstruct page *page = NULL;\n\tu64 len, inline_version;\n\tint err = 0;\n\tbool from_pagecache = false;\n\n\tspin_lock(&ci->i_ceph_lock);\n\tinline_version = ci->i_inline_version;\n\tspin_unlock(&ci->i_ceph_lock);\n\n\tdout(\"uninline_data %p %llx.%llx inline_version %llu\\n\",\n\t     inode, ceph_vinop(inode), inline_version);\n\n\tif (inline_version == 1 || /* initial version, no data */\n\t    inline_version == CEPH_INLINE_NONE)\n\t\tgoto out;\n\n\tif (locked_page) {\n\t\tpage = locked_page;\n\t\tWARN_ON(!PageUptodate(page));\n\t} else if (ceph_caps_issued(ci) &\n\t\t   (CEPH_CAP_FILE_CACHE|CEPH_CAP_FILE_LAZYIO)) {\n\t\tpage = find_get_page(inode->i_mapping, 0);\n\t\tif (page) {\n\t\t\tif (PageUptodate(page)) {\n\t\t\t\tfrom_pagecache = true;\n\t\t\t\tlock_page(page);\n\t\t\t} else {\n\t\t\t\tpage_cache_release(page);\n\t\t\t\tpage = NULL;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (page) {\n\t\tlen = i_size_read(inode);\n\t\tif (len > PAGE_CACHE_SIZE)\n\t\t\tlen = PAGE_CACHE_SIZE;\n\t} else {\n\t\tpage = __page_cache_alloc(GFP_NOFS);\n\t\tif (!page) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\terr = __ceph_do_getattr(inode, page,\n\t\t\t\t\tCEPH_STAT_CAP_INLINE_DATA, true);\n\t\tif (err < 0) {\n\t\t\t/* no inline data */\n\t\t\tif (err == -ENODATA)\n\t\t\t\terr = 0;\n\t\t\tgoto out;\n\t\t}\n\t\tlen = err;\n\t}\n\n\treq = ceph_osdc_new_request(&fsc->client->osdc, &ci->i_layout,\n\t\t\t\t    ceph_vino(inode), 0, &len, 0, 1,\n\t\t\t\t    CEPH_OSD_OP_CREATE,\n\t\t\t\t    CEPH_OSD_FLAG_ONDISK | CEPH_OSD_FLAG_WRITE,\n\t\t\t\t    ci->i_snap_realm->cached_context,\n\t\t\t\t    0, 0, false);\n\tif (IS_ERR(req)) {\n\t\terr = PTR_ERR(req);\n\t\tgoto out;\n\t}\n\n\tceph_osdc_build_request(req, 0, NULL, CEPH_NOSNAP, &inode->i_mtime);\n\terr = ceph_osdc_start_request(&fsc->client->osdc, req, false);\n\tif (!err)\n\t\terr = ceph_osdc_wait_request(&fsc->client->osdc, req);\n\tceph_osdc_put_request(req);\n\tif (err < 0)\n\t\tgoto out;\n\n\treq = ceph_osdc_new_request(&fsc->client->osdc, &ci->i_layout,\n\t\t\t\t    ceph_vino(inode), 0, &len, 1, 3,\n\t\t\t\t    CEPH_OSD_OP_WRITE,\n\t\t\t\t    CEPH_OSD_FLAG_ONDISK | CEPH_OSD_FLAG_WRITE,\n\t\t\t\t    ci->i_snap_realm->cached_context,\n\t\t\t\t    ci->i_truncate_seq, ci->i_truncate_size,\n\t\t\t\t    false);\n\tif (IS_ERR(req)) {\n\t\terr = PTR_ERR(req);\n\t\tgoto out;\n\t}\n\n\tosd_req_op_extent_osd_data_pages(req, 1, &page, len, 0, false, false);\n\n\terr = osd_req_op_xattr_init(req, 0, CEPH_OSD_OP_CMPXATTR,\n\t\t\t\t    \"inline_version\", &inline_version,\n\t\t\t\t    sizeof(inline_version),\n\t\t\t\t    CEPH_OSD_CMPXATTR_OP_GT,\n\t\t\t\t    CEPH_OSD_CMPXATTR_MODE_U64);\n\tif (err)\n\t\tgoto out_put;\n\n\terr = osd_req_op_xattr_init(req, 2, CEPH_OSD_OP_SETXATTR,\n\t\t\t\t    \"inline_version\", &inline_version,\n\t\t\t\t    sizeof(inline_version), 0, 0);\n\tif (err)\n\t\tgoto out_put;\n\n\tceph_osdc_build_request(req, 0, NULL, CEPH_NOSNAP, &inode->i_mtime);\n\terr = ceph_osdc_start_request(&fsc->client->osdc, req, false);\n\tif (!err)\n\t\terr = ceph_osdc_wait_request(&fsc->client->osdc, req);\nout_put:\n\tceph_osdc_put_request(req);\n\tif (err == -ECANCELED)\n\t\terr = 0;\nout:\n\tif (page && page != locked_page) {\n\t\tif (from_pagecache) {\n\t\t\tunlock_page(page);\n\t\t\tpage_cache_release(page);\n\t\t} else\n\t\t\t__free_pages(page, 0);\n\t}\n\n\tdout(\"uninline_data %p %llx.%llx inline_version %llu = %d\\n\",\n\t     inode, ceph_vinop(inode), inline_version, err);\n\treturn err;\n}",
    "includes": [
      "#include <linux/ceph/osd_client.h>",
      "#include \"cache.h\"",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/slab.h>",
      "#include <linux/writeback.h>\t/* generic_writepages */",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"uninline_data %p %llx.%llx inline_version %llu = %d\\n\"",
            "inode",
            "ceph_vinop(inode)",
            "inline_version",
            "err"
          ],
          "line": 1569
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_vinop",
          "args": [
            "inode"
          ],
          "line": 1570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__free_pages",
          "args": [
            "page",
            "0"
          ],
          "line": 1566
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "page"
          ],
          "line": 1564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 1563
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_osdc_put_request",
          "args": [
            "req"
          ],
          "line": 1557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_osdc_wait_request",
          "args": [
            "&fsc->client->osdc",
            "req"
          ],
          "line": 1555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_osdc_start_request",
          "args": [
            "&fsc->client->osdc",
            "req",
            "false"
          ],
          "line": 1553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_osdc_build_request",
          "args": [
            "req",
            "0",
            "NULL",
            "CEPH_NOSNAP",
            "&inode->i_mtime"
          ],
          "line": 1552
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "osd_req_op_xattr_init",
          "args": [
            "req",
            "2",
            "CEPH_OSD_OP_SETXATTR",
            "\"inline_version\"",
            "&inline_version",
            "sizeof(inline_version)",
            "0",
            "0"
          ],
          "line": 1546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "osd_req_op_xattr_init",
          "args": [
            "req",
            "0",
            "CEPH_OSD_OP_CMPXATTR",
            "\"inline_version\"",
            "&inline_version",
            "sizeof(inline_version)",
            "CEPH_OSD_CMPXATTR_OP_GT",
            "CEPH_OSD_CMPXATTR_MODE_U64"
          ],
          "line": 1538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "osd_req_op_extent_osd_data_pages",
          "args": [
            "req",
            "1",
            "&page",
            "len",
            "0",
            "false",
            "false"
          ],
          "line": 1536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "req"
          ],
          "line": 1532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "req"
          ],
          "line": 1531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_osdc_new_request",
          "args": [
            "&fsc->client->osdc",
            "&ci->i_layout",
            "ceph_vino(inode)",
            "0",
            "&len",
            "1",
            "3",
            "CEPH_OSD_OP_WRITE",
            "CEPH_OSD_FLAG_ONDISK | CEPH_OSD_FLAG_WRITE",
            "ci->i_snap_realm->cached_context",
            "ci->i_truncate_seq",
            "ci->i_truncate_size",
            "false"
          ],
          "line": 1524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_vino",
          "args": [
            "inode"
          ],
          "line": 1525
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_vino_to_ino",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.h",
          "lines": "382-389",
          "snippet": "static inline ino_t ceph_vino_to_ino(struct ceph_vino vino)\n{\n#if BITS_PER_LONG == 32\n\treturn ceph_ino_to_ino32(vino.ino);\n#else\n\treturn (ino_t)vino.ino;\n#endif\n}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/ceph/libceph.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/backing-dev.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/ceph/libceph.h>\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n#include <linux/completion.h>\n#include <linux/backing-dev.h>\n#include <asm/unaligned.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline ino_t ceph_vino_to_ino(struct ceph_vino vino)\n{\n#if BITS_PER_LONG == 32\n\treturn ceph_ino_to_ino32(vino.ino);\n#else\n\treturn (ino_t)vino.ino;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_osdc_put_request",
          "args": [
            "req"
          ],
          "line": 1520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_osdc_wait_request",
          "args": [
            "&fsc->client->osdc",
            "req"
          ],
          "line": 1519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_osdc_start_request",
          "args": [
            "&fsc->client->osdc",
            "req",
            "false"
          ],
          "line": 1517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_osdc_build_request",
          "args": [
            "req",
            "0",
            "NULL",
            "CEPH_NOSNAP",
            "&inode->i_mtime"
          ],
          "line": 1516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "req"
          ],
          "line": 1512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "req"
          ],
          "line": 1511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_osdc_new_request",
          "args": [
            "&fsc->client->osdc",
            "&ci->i_layout",
            "ceph_vino(inode)",
            "0",
            "&len",
            "0",
            "1",
            "CEPH_OSD_OP_CREATE",
            "CEPH_OSD_FLAG_ONDISK | CEPH_OSD_FLAG_WRITE",
            "ci->i_snap_realm->cached_context",
            "0",
            "0",
            "false"
          ],
          "line": 1505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__ceph_do_getattr",
          "args": [
            "inode",
            "page",
            "CEPH_STAT_CAP_INLINE_DATA",
            "true"
          ],
          "line": 1494
        },
        "resolved": true,
        "details": {
          "function_name": "__ceph_do_getattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/inode.c",
          "lines": "1924-1965",
          "snippet": "int __ceph_do_getattr(struct inode *inode, struct page *locked_page,\n\t\t      int mask, bool force)\n{\n\tstruct ceph_fs_client *fsc = ceph_sb_to_client(inode->i_sb);\n\tstruct ceph_mds_client *mdsc = fsc->mdsc;\n\tstruct ceph_mds_request *req;\n\tint err;\n\n\tif (ceph_snap(inode) == CEPH_SNAPDIR) {\n\t\tdout(\"do_getattr inode %p SNAPDIR\\n\", inode);\n\t\treturn 0;\n\t}\n\n\tdout(\"do_getattr inode %p mask %s mode 0%o\\n\",\n\t     inode, ceph_cap_string(mask), inode->i_mode);\n\tif (!force && ceph_caps_issued_mask(ceph_inode(inode), mask, 1))\n\t\treturn 0;\n\n\treq = ceph_mdsc_create_request(mdsc, CEPH_MDS_OP_GETATTR, USE_ANY_MDS);\n\tif (IS_ERR(req))\n\t\treturn PTR_ERR(req);\n\treq->r_inode = inode;\n\tihold(inode);\n\treq->r_num_caps = 1;\n\treq->r_args.getattr.mask = cpu_to_le32(mask);\n\treq->r_locked_page = locked_page;\n\terr = ceph_mdsc_do_request(mdsc, NULL, req);\n\tif (locked_page && err == 0) {\n\t\tu64 inline_version = req->r_reply_info.targeti.inline_version;\n\t\tif (inline_version == 0) {\n\t\t\t/* the reply is supposed to contain inline data */\n\t\t\terr = -EINVAL;\n\t\t} else if (inline_version == CEPH_INLINE_NONE) {\n\t\t\terr = -ENODATA;\n\t\t} else {\n\t\t\terr = req->r_reply_info.targeti.inline_len;\n\t\t}\n\t}\n\tceph_mdsc_put_request(req);\n\tdout(\"do_getattr result=%d\\n\", err);\n\treturn err;\n}",
          "includes": [
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/random.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/namei.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/random.h>\n#include <linux/posix_acl.h>\n#include <linux/vmalloc.h>\n#include <linux/writeback.h>\n#include <linux/namei.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/ceph/ceph_debug.h>\n\nint __ceph_do_getattr(struct inode *inode, struct page *locked_page,\n\t\t      int mask, bool force)\n{\n\tstruct ceph_fs_client *fsc = ceph_sb_to_client(inode->i_sb);\n\tstruct ceph_mds_client *mdsc = fsc->mdsc;\n\tstruct ceph_mds_request *req;\n\tint err;\n\n\tif (ceph_snap(inode) == CEPH_SNAPDIR) {\n\t\tdout(\"do_getattr inode %p SNAPDIR\\n\", inode);\n\t\treturn 0;\n\t}\n\n\tdout(\"do_getattr inode %p mask %s mode 0%o\\n\",\n\t     inode, ceph_cap_string(mask), inode->i_mode);\n\tif (!force && ceph_caps_issued_mask(ceph_inode(inode), mask, 1))\n\t\treturn 0;\n\n\treq = ceph_mdsc_create_request(mdsc, CEPH_MDS_OP_GETATTR, USE_ANY_MDS);\n\tif (IS_ERR(req))\n\t\treturn PTR_ERR(req);\n\treq->r_inode = inode;\n\tihold(inode);\n\treq->r_num_caps = 1;\n\treq->r_args.getattr.mask = cpu_to_le32(mask);\n\treq->r_locked_page = locked_page;\n\terr = ceph_mdsc_do_request(mdsc, NULL, req);\n\tif (locked_page && err == 0) {\n\t\tu64 inline_version = req->r_reply_info.targeti.inline_version;\n\t\tif (inline_version == 0) {\n\t\t\t/* the reply is supposed to contain inline data */\n\t\t\terr = -EINVAL;\n\t\t} else if (inline_version == CEPH_INLINE_NONE) {\n\t\t\terr = -ENODATA;\n\t\t} else {\n\t\t\terr = req->r_reply_info.targeti.inline_len;\n\t\t}\n\t}\n\tceph_mdsc_put_request(req);\n\tdout(\"do_getattr result=%d\\n\", err);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__page_cache_alloc",
          "args": [
            "GFP_NOFS"
          ],
          "line": 1489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 1485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "page"
          ],
          "line": 1478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "page"
          ],
          "line": 1474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_get_page",
          "args": [
            "inode->i_mapping",
            "0"
          ],
          "line": 1472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_caps_issued",
          "args": [
            "ci"
          ],
          "line": 1470
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_caps_issued",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.h",
          "lines": "531-538",
          "snippet": "static inline int ceph_caps_issued(struct ceph_inode_info *ci)\n{\n\tint issued;\n\tspin_lock(&ci->i_ceph_lock);\n\tissued = __ceph_caps_issued(ci, NULL);\n\tspin_unlock(&ci->i_ceph_lock);\n\treturn issued;\n}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/ceph/libceph.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/backing-dev.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/ceph/libceph.h>\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n#include <linux/completion.h>\n#include <linux/backing-dev.h>\n#include <asm/unaligned.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline int ceph_caps_issued(struct ceph_inode_info *ci)\n{\n\tint issued;\n\tspin_lock(&ci->i_ceph_lock);\n\tissued = __ceph_caps_issued(ci, NULL);\n\tspin_unlock(&ci->i_ceph_lock);\n\treturn issued;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!PageUptodate(page)"
          ],
          "line": 1469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "page"
          ],
          "line": 1469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"uninline_data %p %llx.%llx inline_version %llu\\n\"",
            "inode",
            "ceph_vinop(inode)",
            "inline_version"
          ],
          "line": 1460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_vinop",
          "args": [
            "inode"
          ],
          "line": 1461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ci->i_ceph_lock"
          ],
          "line": 1458
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ci->i_ceph_lock"
          ],
          "line": 1456
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_inode_to_client",
          "args": [
            "inode"
          ],
          "line": 1449
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_inode_to_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.h",
          "lines": "347-350",
          "snippet": "static inline struct ceph_fs_client *ceph_inode_to_client(struct inode *inode)\n{\n\treturn (struct ceph_fs_client *)inode->i_sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/ceph/libceph.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/backing-dev.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/ceph/libceph.h>\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n#include <linux/completion.h>\n#include <linux/backing-dev.h>\n#include <asm/unaligned.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline struct ceph_fs_client *ceph_inode_to_client(struct inode *inode)\n{\n\treturn (struct ceph_fs_client *)inode->i_sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "filp"
          ],
          "line": 1447
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/ceph/osd_client.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/task_io_accounting_ops.h>\n#include <linux/pagevec.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\t/* generic_writepages */\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/backing-dev.h>\n#include <linux/ceph/ceph_debug.h>\n\nint ceph_uninline_data(struct file *filp, struct page *locked_page)\n{\n\tstruct inode *inode = file_inode(filp);\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tstruct ceph_fs_client *fsc = ceph_inode_to_client(inode);\n\tstruct ceph_osd_request *req;\n\tstruct page *page = NULL;\n\tu64 len, inline_version;\n\tint err = 0;\n\tbool from_pagecache = false;\n\n\tspin_lock(&ci->i_ceph_lock);\n\tinline_version = ci->i_inline_version;\n\tspin_unlock(&ci->i_ceph_lock);\n\n\tdout(\"uninline_data %p %llx.%llx inline_version %llu\\n\",\n\t     inode, ceph_vinop(inode), inline_version);\n\n\tif (inline_version == 1 || /* initial version, no data */\n\t    inline_version == CEPH_INLINE_NONE)\n\t\tgoto out;\n\n\tif (locked_page) {\n\t\tpage = locked_page;\n\t\tWARN_ON(!PageUptodate(page));\n\t} else if (ceph_caps_issued(ci) &\n\t\t   (CEPH_CAP_FILE_CACHE|CEPH_CAP_FILE_LAZYIO)) {\n\t\tpage = find_get_page(inode->i_mapping, 0);\n\t\tif (page) {\n\t\t\tif (PageUptodate(page)) {\n\t\t\t\tfrom_pagecache = true;\n\t\t\t\tlock_page(page);\n\t\t\t} else {\n\t\t\t\tpage_cache_release(page);\n\t\t\t\tpage = NULL;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (page) {\n\t\tlen = i_size_read(inode);\n\t\tif (len > PAGE_CACHE_SIZE)\n\t\t\tlen = PAGE_CACHE_SIZE;\n\t} else {\n\t\tpage = __page_cache_alloc(GFP_NOFS);\n\t\tif (!page) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\terr = __ceph_do_getattr(inode, page,\n\t\t\t\t\tCEPH_STAT_CAP_INLINE_DATA, true);\n\t\tif (err < 0) {\n\t\t\t/* no inline data */\n\t\t\tif (err == -ENODATA)\n\t\t\t\terr = 0;\n\t\t\tgoto out;\n\t\t}\n\t\tlen = err;\n\t}\n\n\treq = ceph_osdc_new_request(&fsc->client->osdc, &ci->i_layout,\n\t\t\t\t    ceph_vino(inode), 0, &len, 0, 1,\n\t\t\t\t    CEPH_OSD_OP_CREATE,\n\t\t\t\t    CEPH_OSD_FLAG_ONDISK | CEPH_OSD_FLAG_WRITE,\n\t\t\t\t    ci->i_snap_realm->cached_context,\n\t\t\t\t    0, 0, false);\n\tif (IS_ERR(req)) {\n\t\terr = PTR_ERR(req);\n\t\tgoto out;\n\t}\n\n\tceph_osdc_build_request(req, 0, NULL, CEPH_NOSNAP, &inode->i_mtime);\n\terr = ceph_osdc_start_request(&fsc->client->osdc, req, false);\n\tif (!err)\n\t\terr = ceph_osdc_wait_request(&fsc->client->osdc, req);\n\tceph_osdc_put_request(req);\n\tif (err < 0)\n\t\tgoto out;\n\n\treq = ceph_osdc_new_request(&fsc->client->osdc, &ci->i_layout,\n\t\t\t\t    ceph_vino(inode), 0, &len, 1, 3,\n\t\t\t\t    CEPH_OSD_OP_WRITE,\n\t\t\t\t    CEPH_OSD_FLAG_ONDISK | CEPH_OSD_FLAG_WRITE,\n\t\t\t\t    ci->i_snap_realm->cached_context,\n\t\t\t\t    ci->i_truncate_seq, ci->i_truncate_size,\n\t\t\t\t    false);\n\tif (IS_ERR(req)) {\n\t\terr = PTR_ERR(req);\n\t\tgoto out;\n\t}\n\n\tosd_req_op_extent_osd_data_pages(req, 1, &page, len, 0, false, false);\n\n\terr = osd_req_op_xattr_init(req, 0, CEPH_OSD_OP_CMPXATTR,\n\t\t\t\t    \"inline_version\", &inline_version,\n\t\t\t\t    sizeof(inline_version),\n\t\t\t\t    CEPH_OSD_CMPXATTR_OP_GT,\n\t\t\t\t    CEPH_OSD_CMPXATTR_MODE_U64);\n\tif (err)\n\t\tgoto out_put;\n\n\terr = osd_req_op_xattr_init(req, 2, CEPH_OSD_OP_SETXATTR,\n\t\t\t\t    \"inline_version\", &inline_version,\n\t\t\t\t    sizeof(inline_version), 0, 0);\n\tif (err)\n\t\tgoto out_put;\n\n\tceph_osdc_build_request(req, 0, NULL, CEPH_NOSNAP, &inode->i_mtime);\n\terr = ceph_osdc_start_request(&fsc->client->osdc, req, false);\n\tif (!err)\n\t\terr = ceph_osdc_wait_request(&fsc->client->osdc, req);\nout_put:\n\tceph_osdc_put_request(req);\n\tif (err == -ECANCELED)\n\t\terr = 0;\nout:\n\tif (page && page != locked_page) {\n\t\tif (from_pagecache) {\n\t\t\tunlock_page(page);\n\t\t\tpage_cache_release(page);\n\t\t} else\n\t\t\t__free_pages(page, 0);\n\t}\n\n\tdout(\"uninline_data %p %llx.%llx inline_version %llu = %d\\n\",\n\t     inode, ceph_vinop(inode), inline_version, err);\n\treturn err;\n}"
  },
  {
    "function_name": "ceph_fill_inline_data",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/addr.c",
    "lines": "1402-1443",
    "snippet": "void ceph_fill_inline_data(struct inode *inode, struct page *locked_page,\n\t\t\t   char\t*data, size_t len)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tstruct page *page;\n\n\tif (locked_page) {\n\t\tpage = locked_page;\n\t} else {\n\t\tif (i_size_read(inode) == 0)\n\t\t\treturn;\n\t\tpage = find_or_create_page(mapping, 0,\n\t\t\t\t\t   mapping_gfp_mask(mapping) & ~__GFP_FS);\n\t\tif (!page)\n\t\t\treturn;\n\t\tif (PageUptodate(page)) {\n\t\t\tunlock_page(page);\n\t\t\tpage_cache_release(page);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tdout(\"fill_inline_data %p %llx.%llx len %zu locked_page %p\\n\",\n\t     inode, ceph_vinop(inode), len, locked_page);\n\n\tif (len > 0) {\n\t\tvoid *kaddr = kmap_atomic(page);\n\t\tmemcpy(kaddr, data, len);\n\t\tkunmap_atomic(kaddr);\n\t}\n\n\tif (page != locked_page) {\n\t\tif (len < PAGE_CACHE_SIZE)\n\t\t\tzero_user_segment(page, len, PAGE_CACHE_SIZE);\n\t\telse\n\t\t\tflush_dcache_page(page);\n\n\t\tSetPageUptodate(page);\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t}\n}",
    "includes": [
      "#include <linux/ceph/osd_client.h>",
      "#include \"cache.h\"",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/slab.h>",
      "#include <linux/writeback.h>\t/* generic_writepages */",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "page"
          ],
          "line": 1441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 1440
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SetPageUptodate",
          "args": [
            "page"
          ],
          "line": 1439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flush_dcache_page",
          "args": [
            "page"
          ],
          "line": 1437
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_index_entry_flush_dcache_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/index.h",
          "lines": "111-117",
          "snippet": "static inline void ntfs_index_entry_flush_dcache_page(ntfs_index_context *ictx)\n{\n\tif (ictx->is_in_root)\n\t\tflush_dcache_mft_record_page(ictx->actx->ntfs_ino);\n\telse\n\t\tflush_dcache_page(ictx->page);\n}",
          "includes": [
            "#include \"aops.h\"",
            "#include \"mft.h\"",
            "#include \"attrib.h\"",
            "#include \"inode.h\"",
            "#include \"layout.h\"",
            "#include \"types.h\"",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"aops.h\"\n#include \"mft.h\"\n#include \"attrib.h\"\n#include \"inode.h\"\n#include \"layout.h\"\n#include \"types.h\"\n#include <linux/fs.h>\n\nstatic inline void ntfs_index_entry_flush_dcache_page(ntfs_index_context *ictx)\n{\n\tif (ictx->is_in_root)\n\t\tflush_dcache_mft_record_page(ictx->actx->ntfs_ino);\n\telse\n\t\tflush_dcache_page(ictx->page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "zero_user_segment",
          "args": [
            "page",
            "len",
            "PAGE_CACHE_SIZE"
          ],
          "line": 1435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kunmap_atomic",
          "args": [
            "kaddr"
          ],
          "line": 1430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "kaddr",
            "data",
            "len"
          ],
          "line": 1429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmap_atomic",
          "args": [
            "page"
          ],
          "line": 1428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"fill_inline_data %p %llx.%llx len %zu locked_page %p\\n\"",
            "inode",
            "ceph_vinop(inode)",
            "len",
            "locked_page"
          ],
          "line": 1424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_vinop",
          "args": [
            "inode"
          ],
          "line": 1425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "page"
          ],
          "line": 1419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "page"
          ],
          "line": 1417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_or_create_page",
          "args": [
            "mapping",
            "0",
            "mapping_gfp_mask(mapping) & ~__GFP_FS"
          ],
          "line": 1413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mapping_gfp_mask",
          "args": [
            "mapping"
          ],
          "line": 1414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 1411
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/ceph/osd_client.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/task_io_accounting_ops.h>\n#include <linux/pagevec.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\t/* generic_writepages */\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/backing-dev.h>\n#include <linux/ceph/ceph_debug.h>\n\nvoid ceph_fill_inline_data(struct inode *inode, struct page *locked_page,\n\t\t\t   char\t*data, size_t len)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tstruct page *page;\n\n\tif (locked_page) {\n\t\tpage = locked_page;\n\t} else {\n\t\tif (i_size_read(inode) == 0)\n\t\t\treturn;\n\t\tpage = find_or_create_page(mapping, 0,\n\t\t\t\t\t   mapping_gfp_mask(mapping) & ~__GFP_FS);\n\t\tif (!page)\n\t\t\treturn;\n\t\tif (PageUptodate(page)) {\n\t\t\tunlock_page(page);\n\t\t\tpage_cache_release(page);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tdout(\"fill_inline_data %p %llx.%llx len %zu locked_page %p\\n\",\n\t     inode, ceph_vinop(inode), len, locked_page);\n\n\tif (len > 0) {\n\t\tvoid *kaddr = kmap_atomic(page);\n\t\tmemcpy(kaddr, data, len);\n\t\tkunmap_atomic(kaddr);\n\t}\n\n\tif (page != locked_page) {\n\t\tif (len < PAGE_CACHE_SIZE)\n\t\t\tzero_user_segment(page, len, PAGE_CACHE_SIZE);\n\t\telse\n\t\t\tflush_dcache_page(page);\n\n\t\tSetPageUptodate(page);\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t}\n}"
  },
  {
    "function_name": "ceph_page_mkwrite",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/addr.c",
    "lines": "1309-1400",
    "snippet": "static int ceph_page_mkwrite(struct vm_area_struct *vma, struct vm_fault *vmf)\n{\n\tstruct inode *inode = file_inode(vma->vm_file);\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tstruct ceph_file_info *fi = vma->vm_file->private_data;\n\tstruct ceph_mds_client *mdsc = ceph_inode_to_client(inode)->mdsc;\n\tstruct page *page = vmf->page;\n\tloff_t off = page_offset(page);\n\tloff_t size = i_size_read(inode);\n\tsize_t len;\n\tint want, got, ret;\n\n\tif (ci->i_inline_version != CEPH_INLINE_NONE) {\n\t\tstruct page *locked_page = NULL;\n\t\tif (off == 0) {\n\t\t\tlock_page(page);\n\t\t\tlocked_page = page;\n\t\t}\n\t\tret = ceph_uninline_data(vma->vm_file, locked_page);\n\t\tif (locked_page)\n\t\t\tunlock_page(locked_page);\n\t\tif (ret < 0)\n\t\t\treturn VM_FAULT_SIGBUS;\n\t}\n\n\tif (off + PAGE_CACHE_SIZE <= size)\n\t\tlen = PAGE_CACHE_SIZE;\n\telse\n\t\tlen = size & ~PAGE_CACHE_MASK;\n\n\tdout(\"page_mkwrite %p %llx.%llx %llu~%zd getting caps i_size %llu\\n\",\n\t     inode, ceph_vinop(inode), off, len, size);\n\tif (fi->fmode & CEPH_FILE_MODE_LAZY)\n\t\twant = CEPH_CAP_FILE_BUFFER | CEPH_CAP_FILE_LAZYIO;\n\telse\n\t\twant = CEPH_CAP_FILE_BUFFER;\n\twhile (1) {\n\t\tgot = 0;\n\t\tret = ceph_get_caps(ci, CEPH_CAP_FILE_WR, want, off + len,\n\t\t\t\t    &got, NULL);\n\t\tif (ret == 0)\n\t\t\tbreak;\n\t\tif (ret != -ERESTARTSYS) {\n\t\t\tWARN_ON(1);\n\t\t\treturn VM_FAULT_SIGBUS;\n\t\t}\n\t}\n\tdout(\"page_mkwrite %p %llu~%zd got cap refs on %s\\n\",\n\t     inode, off, len, ceph_cap_string(got));\n\n\t/* Update time before taking page lock */\n\tfile_update_time(vma->vm_file);\n\n\tlock_page(page);\n\n\tret = VM_FAULT_NOPAGE;\n\tif ((off > size) ||\n\t    (page->mapping != inode->i_mapping))\n\t\tgoto out;\n\n\tret = ceph_update_writeable_page(vma->vm_file, off, len, page);\n\tif (ret == 0) {\n\t\t/* success.  we'll keep the page locked. */\n\t\tset_page_dirty(page);\n\t\tup_read(&mdsc->snap_rwsem);\n\t\tret = VM_FAULT_LOCKED;\n\t} else {\n\t\tif (ret == -ENOMEM)\n\t\t\tret = VM_FAULT_OOM;\n\t\telse\n\t\t\tret = VM_FAULT_SIGBUS;\n\t}\nout:\n\tif (ret != VM_FAULT_LOCKED)\n\t\tunlock_page(page);\n\tif (ret == VM_FAULT_LOCKED ||\n\t    ci->i_inline_version != CEPH_INLINE_NONE) {\n\t\tint dirty;\n\t\tspin_lock(&ci->i_ceph_lock);\n\t\tci->i_inline_version = CEPH_INLINE_NONE;\n\t\tdirty = __ceph_mark_dirty_caps(ci, CEPH_CAP_FILE_WR);\n\t\tspin_unlock(&ci->i_ceph_lock);\n\t\tif (dirty)\n\t\t\t__mark_inode_dirty(inode, dirty);\n\t}\n\n\tdout(\"page_mkwrite %p %llu~%zd dropping cap refs on %s ret %d\\n\",\n\t     inode, off, len, ceph_cap_string(got), ret);\n\tceph_put_cap_refs(ci, got);\n\n\treturn ret;\n}",
    "includes": [
      "#include <linux/ceph/osd_client.h>",
      "#include \"cache.h\"",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/slab.h>",
      "#include <linux/writeback.h>\t/* generic_writepages */",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ceph_put_cap_refs",
          "args": [
            "ci",
            "got"
          ],
          "line": 1397
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_put_cap_refs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
          "lines": "2274-2326",
          "snippet": "void ceph_put_cap_refs(struct ceph_inode_info *ci, int had)\n{\n\tstruct inode *inode = &ci->vfs_inode;\n\tint last = 0, put = 0, flushsnaps = 0, wake = 0;\n\tstruct ceph_cap_snap *capsnap;\n\n\tspin_lock(&ci->i_ceph_lock);\n\tif (had & CEPH_CAP_PIN)\n\t\t--ci->i_pin_ref;\n\tif (had & CEPH_CAP_FILE_RD)\n\t\tif (--ci->i_rd_ref == 0)\n\t\t\tlast++;\n\tif (had & CEPH_CAP_FILE_CACHE)\n\t\tif (--ci->i_rdcache_ref == 0)\n\t\t\tlast++;\n\tif (had & CEPH_CAP_FILE_BUFFER) {\n\t\tif (--ci->i_wb_ref == 0) {\n\t\t\tlast++;\n\t\t\tput++;\n\t\t}\n\t\tdout(\"put_cap_refs %p wb %d -> %d (?)\\n\",\n\t\t     inode, ci->i_wb_ref+1, ci->i_wb_ref);\n\t}\n\tif (had & CEPH_CAP_FILE_WR)\n\t\tif (--ci->i_wr_ref == 0) {\n\t\t\tlast++;\n\t\t\tif (!list_empty(&ci->i_cap_snaps)) {\n\t\t\t\tcapsnap = list_first_entry(&ci->i_cap_snaps,\n\t\t\t\t\t\t     struct ceph_cap_snap,\n\t\t\t\t\t\t     ci_item);\n\t\t\t\tif (capsnap->writing) {\n\t\t\t\t\tcapsnap->writing = 0;\n\t\t\t\t\tflushsnaps =\n\t\t\t\t\t\t__ceph_finish_cap_snap(ci,\n\t\t\t\t\t\t\t\t       capsnap);\n\t\t\t\t\twake = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\tspin_unlock(&ci->i_ceph_lock);\n\n\tdout(\"put_cap_refs %p had %s%s%s\\n\", inode, ceph_cap_string(had),\n\t     last ? \" last\" : \"\", put ? \" put\" : \"\");\n\n\tif (last && !flushsnaps)\n\t\tceph_check_caps(ci, 0, NULL);\n\telse if (flushsnaps)\n\t\tceph_flush_snaps(ci);\n\tif (wake)\n\t\twake_up_all(&ci->i_cap_wq);\n\tif (put)\n\t\tiput(inode);\n}",
          "includes": [
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nvoid ceph_put_cap_refs(struct ceph_inode_info *ci, int had)\n{\n\tstruct inode *inode = &ci->vfs_inode;\n\tint last = 0, put = 0, flushsnaps = 0, wake = 0;\n\tstruct ceph_cap_snap *capsnap;\n\n\tspin_lock(&ci->i_ceph_lock);\n\tif (had & CEPH_CAP_PIN)\n\t\t--ci->i_pin_ref;\n\tif (had & CEPH_CAP_FILE_RD)\n\t\tif (--ci->i_rd_ref == 0)\n\t\t\tlast++;\n\tif (had & CEPH_CAP_FILE_CACHE)\n\t\tif (--ci->i_rdcache_ref == 0)\n\t\t\tlast++;\n\tif (had & CEPH_CAP_FILE_BUFFER) {\n\t\tif (--ci->i_wb_ref == 0) {\n\t\t\tlast++;\n\t\t\tput++;\n\t\t}\n\t\tdout(\"put_cap_refs %p wb %d -> %d (?)\\n\",\n\t\t     inode, ci->i_wb_ref+1, ci->i_wb_ref);\n\t}\n\tif (had & CEPH_CAP_FILE_WR)\n\t\tif (--ci->i_wr_ref == 0) {\n\t\t\tlast++;\n\t\t\tif (!list_empty(&ci->i_cap_snaps)) {\n\t\t\t\tcapsnap = list_first_entry(&ci->i_cap_snaps,\n\t\t\t\t\t\t     struct ceph_cap_snap,\n\t\t\t\t\t\t     ci_item);\n\t\t\t\tif (capsnap->writing) {\n\t\t\t\t\tcapsnap->writing = 0;\n\t\t\t\t\tflushsnaps =\n\t\t\t\t\t\t__ceph_finish_cap_snap(ci,\n\t\t\t\t\t\t\t\t       capsnap);\n\t\t\t\t\twake = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\tspin_unlock(&ci->i_ceph_lock);\n\n\tdout(\"put_cap_refs %p had %s%s%s\\n\", inode, ceph_cap_string(had),\n\t     last ? \" last\" : \"\", put ? \" put\" : \"\");\n\n\tif (last && !flushsnaps)\n\t\tceph_check_caps(ci, 0, NULL);\n\telse if (flushsnaps)\n\t\tceph_flush_snaps(ci);\n\tif (wake)\n\t\twake_up_all(&ci->i_cap_wq);\n\tif (put)\n\t\tiput(inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"page_mkwrite %p %llu~%zd dropping cap refs on %s ret %d\\n\"",
            "inode",
            "off",
            "len",
            "ceph_cap_string(got)",
            "ret"
          ],
          "line": 1395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_cap_string",
          "args": [
            "got"
          ],
          "line": 1396
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_cap_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
          "lines": "71-116",
          "snippet": "const char *ceph_cap_string(int caps)\n{\n\tint i;\n\tchar *s;\n\tint c;\n\n\tspin_lock(&cap_str_lock);\n\ti = last_cap_str++;\n\tif (last_cap_str == MAX_CAP_STR)\n\t\tlast_cap_str = 0;\n\tspin_unlock(&cap_str_lock);\n\n\ts = cap_str[i];\n\n\tif (caps & CEPH_CAP_PIN)\n\t\t*s++ = 'p';\n\n\tc = (caps >> CEPH_CAP_SAUTH) & 3;\n\tif (c) {\n\t\t*s++ = 'A';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tc = (caps >> CEPH_CAP_SLINK) & 3;\n\tif (c) {\n\t\t*s++ = 'L';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tc = (caps >> CEPH_CAP_SXATTR) & 3;\n\tif (c) {\n\t\t*s++ = 'X';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tc = caps >> CEPH_CAP_SFILE;\n\tif (c) {\n\t\t*s++ = 'F';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tif (s == cap_str[i])\n\t\t*s++ = '-';\n\t*s = 0;\n\treturn cap_str[i];\n}",
          "includes": [
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [
            "#define MAX_CAP_STR 20"
          ],
          "globals_used": [
            "static char cap_str[MAX_CAP_STR][40];",
            "static DEFINE_SPINLOCK(cap_str_lock);",
            "static int last_cap_str;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\n#define MAX_CAP_STR 20\n\nstatic char cap_str[MAX_CAP_STR][40];\nstatic DEFINE_SPINLOCK(cap_str_lock);\nstatic int last_cap_str;\n\nconst char *ceph_cap_string(int caps)\n{\n\tint i;\n\tchar *s;\n\tint c;\n\n\tspin_lock(&cap_str_lock);\n\ti = last_cap_str++;\n\tif (last_cap_str == MAX_CAP_STR)\n\t\tlast_cap_str = 0;\n\tspin_unlock(&cap_str_lock);\n\n\ts = cap_str[i];\n\n\tif (caps & CEPH_CAP_PIN)\n\t\t*s++ = 'p';\n\n\tc = (caps >> CEPH_CAP_SAUTH) & 3;\n\tif (c) {\n\t\t*s++ = 'A';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tc = (caps >> CEPH_CAP_SLINK) & 3;\n\tif (c) {\n\t\t*s++ = 'L';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tc = (caps >> CEPH_CAP_SXATTR) & 3;\n\tif (c) {\n\t\t*s++ = 'X';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tc = caps >> CEPH_CAP_SFILE;\n\tif (c) {\n\t\t*s++ = 'F';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tif (s == cap_str[i])\n\t\t*s++ = '-';\n\t*s = 0;\n\treturn cap_str[i];\n}"
        }
      },
      {
        "call_info": {
          "callee": "__mark_inode_dirty",
          "args": [
            "inode",
            "dirty"
          ],
          "line": 1392
        },
        "resolved": true,
        "details": {
          "function_name": "__mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1181-1285",
          "snippet": "void __mark_inode_dirty(struct inode *inode, int flags)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct backing_dev_info *bdi = NULL;\n\tint dirtytime;\n\n\ttrace_writeback_mark_inode_dirty(inode, flags);\n\n\t/*\n\t * Don't do this for I_DIRTY_PAGES - that doesn't actually\n\t * dirty the inode itself\n\t */\n\tif (flags & (I_DIRTY_SYNC | I_DIRTY_DATASYNC | I_DIRTY_TIME)) {\n\t\ttrace_writeback_dirty_inode_start(inode, flags);\n\n\t\tif (sb->s_op->dirty_inode)\n\t\t\tsb->s_op->dirty_inode(inode, flags);\n\n\t\ttrace_writeback_dirty_inode(inode, flags);\n\t}\n\tif (flags & I_DIRTY_INODE)\n\t\tflags &= ~I_DIRTY_TIME;\n\tdirtytime = flags & I_DIRTY_TIME;\n\n\t/*\n\t * Paired with smp_mb() in __writeback_single_inode() for the\n\t * following lockless i_state test.  See there for details.\n\t */\n\tsmp_mb();\n\n\tif (((inode->i_state & flags) == flags) ||\n\t    (dirtytime && (inode->i_state & I_DIRTY_INODE)))\n\t\treturn;\n\n\tif (unlikely(block_dump))\n\t\tblock_dump___mark_inode_dirty(inode);\n\n\tspin_lock(&inode->i_lock);\n\tif (dirtytime && (inode->i_state & I_DIRTY_INODE))\n\t\tgoto out_unlock_inode;\n\tif ((inode->i_state & flags) != flags) {\n\t\tconst int was_dirty = inode->i_state & I_DIRTY;\n\n\t\tif (flags & I_DIRTY_INODE)\n\t\t\tinode->i_state &= ~I_DIRTY_TIME;\n\t\tinode->i_state |= flags;\n\n\t\t/*\n\t\t * If the inode is being synced, just update its dirty state.\n\t\t * The unlocker will place the inode on the appropriate\n\t\t * superblock list, based upon its state.\n\t\t */\n\t\tif (inode->i_state & I_SYNC)\n\t\t\tgoto out_unlock_inode;\n\n\t\t/*\n\t\t * Only add valid (hashed) inodes to the superblock's\n\t\t * dirty list.  Add blockdev inodes as well.\n\t\t */\n\t\tif (!S_ISBLK(inode->i_mode)) {\n\t\t\tif (inode_unhashed(inode))\n\t\t\t\tgoto out_unlock_inode;\n\t\t}\n\t\tif (inode->i_state & I_FREEING)\n\t\t\tgoto out_unlock_inode;\n\n\t\t/*\n\t\t * If the inode was already on b_dirty/b_io/b_more_io, don't\n\t\t * reposition it (that would break b_dirty time-ordering).\n\t\t */\n\t\tif (!was_dirty) {\n\t\t\tbool wakeup_bdi = false;\n\t\t\tbdi = inode_to_bdi(inode);\n\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tspin_lock(&bdi->wb.list_lock);\n\t\t\tif (bdi_cap_writeback_dirty(bdi)) {\n\t\t\t\tWARN(!test_bit(BDI_registered, &bdi->state),\n\t\t\t\t     \"bdi-%s not registered\\n\", bdi->name);\n\n\t\t\t\t/*\n\t\t\t\t * If this is the first dirty inode for this\n\t\t\t\t * bdi, we have to wake-up the corresponding\n\t\t\t\t * bdi thread to make sure background\n\t\t\t\t * write-back happens later.\n\t\t\t\t */\n\t\t\t\tif (!wb_has_dirty_io(&bdi->wb))\n\t\t\t\t\twakeup_bdi = true;\n\t\t\t}\n\n\t\t\tinode->dirtied_when = jiffies;\n\t\t\tlist_move(&inode->i_wb_list, dirtytime ?\n\t\t\t\t  &bdi->wb.b_dirty_time : &bdi->wb.b_dirty);\n\t\t\tspin_unlock(&bdi->wb.list_lock);\n\t\t\ttrace_writeback_dirty_inode_enqueue(inode);\n\n\t\t\tif (wakeup_bdi)\n\t\t\t\tbdi_wakeup_thread_delayed(bdi);\n\t\t\treturn;\n\t\t}\n\t}\nout_unlock_inode:\n\tspin_unlock(&inode->i_lock);\n\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define I_DIRTY_INODE (I_DIRTY_SYNC | I_DIRTY_DATASYNC)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\n#define I_DIRTY_INODE (I_DIRTY_SYNC | I_DIRTY_DATASYNC)\n\nvoid __mark_inode_dirty(struct inode *inode, int flags)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct backing_dev_info *bdi = NULL;\n\tint dirtytime;\n\n\ttrace_writeback_mark_inode_dirty(inode, flags);\n\n\t/*\n\t * Don't do this for I_DIRTY_PAGES - that doesn't actually\n\t * dirty the inode itself\n\t */\n\tif (flags & (I_DIRTY_SYNC | I_DIRTY_DATASYNC | I_DIRTY_TIME)) {\n\t\ttrace_writeback_dirty_inode_start(inode, flags);\n\n\t\tif (sb->s_op->dirty_inode)\n\t\t\tsb->s_op->dirty_inode(inode, flags);\n\n\t\ttrace_writeback_dirty_inode(inode, flags);\n\t}\n\tif (flags & I_DIRTY_INODE)\n\t\tflags &= ~I_DIRTY_TIME;\n\tdirtytime = flags & I_DIRTY_TIME;\n\n\t/*\n\t * Paired with smp_mb() in __writeback_single_inode() for the\n\t * following lockless i_state test.  See there for details.\n\t */\n\tsmp_mb();\n\n\tif (((inode->i_state & flags) == flags) ||\n\t    (dirtytime && (inode->i_state & I_DIRTY_INODE)))\n\t\treturn;\n\n\tif (unlikely(block_dump))\n\t\tblock_dump___mark_inode_dirty(inode);\n\n\tspin_lock(&inode->i_lock);\n\tif (dirtytime && (inode->i_state & I_DIRTY_INODE))\n\t\tgoto out_unlock_inode;\n\tif ((inode->i_state & flags) != flags) {\n\t\tconst int was_dirty = inode->i_state & I_DIRTY;\n\n\t\tif (flags & I_DIRTY_INODE)\n\t\t\tinode->i_state &= ~I_DIRTY_TIME;\n\t\tinode->i_state |= flags;\n\n\t\t/*\n\t\t * If the inode is being synced, just update its dirty state.\n\t\t * The unlocker will place the inode on the appropriate\n\t\t * superblock list, based upon its state.\n\t\t */\n\t\tif (inode->i_state & I_SYNC)\n\t\t\tgoto out_unlock_inode;\n\n\t\t/*\n\t\t * Only add valid (hashed) inodes to the superblock's\n\t\t * dirty list.  Add blockdev inodes as well.\n\t\t */\n\t\tif (!S_ISBLK(inode->i_mode)) {\n\t\t\tif (inode_unhashed(inode))\n\t\t\t\tgoto out_unlock_inode;\n\t\t}\n\t\tif (inode->i_state & I_FREEING)\n\t\t\tgoto out_unlock_inode;\n\n\t\t/*\n\t\t * If the inode was already on b_dirty/b_io/b_more_io, don't\n\t\t * reposition it (that would break b_dirty time-ordering).\n\t\t */\n\t\tif (!was_dirty) {\n\t\t\tbool wakeup_bdi = false;\n\t\t\tbdi = inode_to_bdi(inode);\n\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tspin_lock(&bdi->wb.list_lock);\n\t\t\tif (bdi_cap_writeback_dirty(bdi)) {\n\t\t\t\tWARN(!test_bit(BDI_registered, &bdi->state),\n\t\t\t\t     \"bdi-%s not registered\\n\", bdi->name);\n\n\t\t\t\t/*\n\t\t\t\t * If this is the first dirty inode for this\n\t\t\t\t * bdi, we have to wake-up the corresponding\n\t\t\t\t * bdi thread to make sure background\n\t\t\t\t * write-back happens later.\n\t\t\t\t */\n\t\t\t\tif (!wb_has_dirty_io(&bdi->wb))\n\t\t\t\t\twakeup_bdi = true;\n\t\t\t}\n\n\t\t\tinode->dirtied_when = jiffies;\n\t\t\tlist_move(&inode->i_wb_list, dirtytime ?\n\t\t\t\t  &bdi->wb.b_dirty_time : &bdi->wb.b_dirty);\n\t\t\tspin_unlock(&bdi->wb.list_lock);\n\t\t\ttrace_writeback_dirty_inode_enqueue(inode);\n\n\t\t\tif (wakeup_bdi)\n\t\t\t\tbdi_wakeup_thread_delayed(bdi);\n\t\t\treturn;\n\t\t}\n\t}\nout_unlock_inode:\n\tspin_unlock(&inode->i_lock);\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ci->i_ceph_lock"
          ],
          "line": 1390
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "__ceph_mark_dirty_caps",
          "args": [
            "ci",
            "CEPH_CAP_FILE_WR"
          ],
          "line": 1389
        },
        "resolved": true,
        "details": {
          "function_name": "__ceph_mark_dirty_caps",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
          "lines": "1389-1423",
          "snippet": "int __ceph_mark_dirty_caps(struct ceph_inode_info *ci, int mask)\n{\n\tstruct ceph_mds_client *mdsc =\n\t\tceph_sb_to_client(ci->vfs_inode.i_sb)->mdsc;\n\tstruct inode *inode = &ci->vfs_inode;\n\tint was = ci->i_dirty_caps;\n\tint dirty = 0;\n\n\tdout(\"__mark_dirty_caps %p %s dirty %s -> %s\\n\", &ci->vfs_inode,\n\t     ceph_cap_string(mask), ceph_cap_string(was),\n\t     ceph_cap_string(was | mask));\n\tci->i_dirty_caps |= mask;\n\tif (was == 0) {\n\t\tif (!ci->i_head_snapc)\n\t\t\tci->i_head_snapc = ceph_get_snap_context(\n\t\t\t\tci->i_snap_realm->cached_context);\n\t\tdout(\" inode %p now dirty snapc %p auth cap %p\\n\",\n\t\t     &ci->vfs_inode, ci->i_head_snapc, ci->i_auth_cap);\n\t\tWARN_ON(!ci->i_auth_cap);\n\t\tBUG_ON(!list_empty(&ci->i_dirty_item));\n\t\tspin_lock(&mdsc->cap_dirty_lock);\n\t\tlist_add(&ci->i_dirty_item, &mdsc->cap_dirty);\n\t\tspin_unlock(&mdsc->cap_dirty_lock);\n\t\tif (ci->i_flushing_caps == 0) {\n\t\t\tihold(inode);\n\t\t\tdirty |= I_DIRTY_SYNC;\n\t\t}\n\t}\n\tBUG_ON(list_empty(&ci->i_dirty_item));\n\tif (((was | ci->i_flushing_caps) & CEPH_CAP_FILE_BUFFER) &&\n\t    (mask & CEPH_CAP_FILE_BUFFER))\n\t\tdirty |= I_DIRTY_DATASYNC;\n\t__cap_delay_requeue(mdsc, ci);\n\treturn dirty;\n}",
          "includes": [
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nint __ceph_mark_dirty_caps(struct ceph_inode_info *ci, int mask)\n{\n\tstruct ceph_mds_client *mdsc =\n\t\tceph_sb_to_client(ci->vfs_inode.i_sb)->mdsc;\n\tstruct inode *inode = &ci->vfs_inode;\n\tint was = ci->i_dirty_caps;\n\tint dirty = 0;\n\n\tdout(\"__mark_dirty_caps %p %s dirty %s -> %s\\n\", &ci->vfs_inode,\n\t     ceph_cap_string(mask), ceph_cap_string(was),\n\t     ceph_cap_string(was | mask));\n\tci->i_dirty_caps |= mask;\n\tif (was == 0) {\n\t\tif (!ci->i_head_snapc)\n\t\t\tci->i_head_snapc = ceph_get_snap_context(\n\t\t\t\tci->i_snap_realm->cached_context);\n\t\tdout(\" inode %p now dirty snapc %p auth cap %p\\n\",\n\t\t     &ci->vfs_inode, ci->i_head_snapc, ci->i_auth_cap);\n\t\tWARN_ON(!ci->i_auth_cap);\n\t\tBUG_ON(!list_empty(&ci->i_dirty_item));\n\t\tspin_lock(&mdsc->cap_dirty_lock);\n\t\tlist_add(&ci->i_dirty_item, &mdsc->cap_dirty);\n\t\tspin_unlock(&mdsc->cap_dirty_lock);\n\t\tif (ci->i_flushing_caps == 0) {\n\t\t\tihold(inode);\n\t\t\tdirty |= I_DIRTY_SYNC;\n\t\t}\n\t}\n\tBUG_ON(list_empty(&ci->i_dirty_item));\n\tif (((was | ci->i_flushing_caps) & CEPH_CAP_FILE_BUFFER) &&\n\t    (mask & CEPH_CAP_FILE_BUFFER))\n\t\tdirty |= I_DIRTY_DATASYNC;\n\t__cap_delay_requeue(mdsc, ci);\n\treturn dirty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ci->i_ceph_lock"
          ],
          "line": 1387
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 1383
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&mdsc->snap_rwsem"
          ],
          "line": 1373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_page_dirty",
          "args": [
            "page"
          ],
          "line": 1372
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_set_page_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/addr.c",
          "lines": "69-125",
          "snippet": "static int ceph_set_page_dirty(struct page *page)\n{\n\tstruct address_space *mapping = page->mapping;\n\tstruct inode *inode;\n\tstruct ceph_inode_info *ci;\n\tstruct ceph_snap_context *snapc;\n\tint ret;\n\n\tif (unlikely(!mapping))\n\t\treturn !TestSetPageDirty(page);\n\n\tif (PageDirty(page)) {\n\t\tdout(\"%p set_page_dirty %p idx %lu -- already dirty\\n\",\n\t\t     mapping->host, page, page->index);\n\t\tBUG_ON(!PagePrivate(page));\n\t\treturn 0;\n\t}\n\n\tinode = mapping->host;\n\tci = ceph_inode(inode);\n\n\t/*\n\t * Note that we're grabbing a snapc ref here without holding\n\t * any locks!\n\t */\n\tsnapc = ceph_get_snap_context(ci->i_snap_realm->cached_context);\n\n\t/* dirty the head */\n\tspin_lock(&ci->i_ceph_lock);\n\tif (ci->i_head_snapc == NULL)\n\t\tci->i_head_snapc = ceph_get_snap_context(snapc);\n\t++ci->i_wrbuffer_ref_head;\n\tif (ci->i_wrbuffer_ref == 0)\n\t\tihold(inode);\n\t++ci->i_wrbuffer_ref;\n\tdout(\"%p set_page_dirty %p idx %lu head %d/%d -> %d/%d \"\n\t     \"snapc %p seq %lld (%d snaps)\\n\",\n\t     mapping->host, page, page->index,\n\t     ci->i_wrbuffer_ref-1, ci->i_wrbuffer_ref_head-1,\n\t     ci->i_wrbuffer_ref, ci->i_wrbuffer_ref_head,\n\t     snapc, snapc->seq, snapc->num_snaps);\n\tspin_unlock(&ci->i_ceph_lock);\n\n\t/*\n\t * Reference snap context in page->private.  Also set\n\t * PagePrivate so that we get invalidatepage callback.\n\t */\n\tBUG_ON(PagePrivate(page));\n\tpage->private = (unsigned long)snapc;\n\tSetPagePrivate(page);\n\n\tret = __set_page_dirty_nobuffers(page);\n\tWARN_ON(!PageLocked(page));\n\tWARN_ON(!page->mapping);\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/ceph/osd_client.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>\t/* generic_writepages */",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/osd_client.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/task_io_accounting_ops.h>\n#include <linux/pagevec.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\t/* generic_writepages */\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/backing-dev.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic int ceph_set_page_dirty(struct page *page)\n{\n\tstruct address_space *mapping = page->mapping;\n\tstruct inode *inode;\n\tstruct ceph_inode_info *ci;\n\tstruct ceph_snap_context *snapc;\n\tint ret;\n\n\tif (unlikely(!mapping))\n\t\treturn !TestSetPageDirty(page);\n\n\tif (PageDirty(page)) {\n\t\tdout(\"%p set_page_dirty %p idx %lu -- already dirty\\n\",\n\t\t     mapping->host, page, page->index);\n\t\tBUG_ON(!PagePrivate(page));\n\t\treturn 0;\n\t}\n\n\tinode = mapping->host;\n\tci = ceph_inode(inode);\n\n\t/*\n\t * Note that we're grabbing a snapc ref here without holding\n\t * any locks!\n\t */\n\tsnapc = ceph_get_snap_context(ci->i_snap_realm->cached_context);\n\n\t/* dirty the head */\n\tspin_lock(&ci->i_ceph_lock);\n\tif (ci->i_head_snapc == NULL)\n\t\tci->i_head_snapc = ceph_get_snap_context(snapc);\n\t++ci->i_wrbuffer_ref_head;\n\tif (ci->i_wrbuffer_ref == 0)\n\t\tihold(inode);\n\t++ci->i_wrbuffer_ref;\n\tdout(\"%p set_page_dirty %p idx %lu head %d/%d -> %d/%d \"\n\t     \"snapc %p seq %lld (%d snaps)\\n\",\n\t     mapping->host, page, page->index,\n\t     ci->i_wrbuffer_ref-1, ci->i_wrbuffer_ref_head-1,\n\t     ci->i_wrbuffer_ref, ci->i_wrbuffer_ref_head,\n\t     snapc, snapc->seq, snapc->num_snaps);\n\tspin_unlock(&ci->i_ceph_lock);\n\n\t/*\n\t * Reference snap context in page->private.  Also set\n\t * PagePrivate so that we get invalidatepage callback.\n\t */\n\tBUG_ON(PagePrivate(page));\n\tpage->private = (unsigned long)snapc;\n\tSetPagePrivate(page);\n\n\tret = __set_page_dirty_nobuffers(page);\n\tWARN_ON(!PageLocked(page));\n\tWARN_ON(!page->mapping);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_update_writeable_page",
          "args": [
            "vma->vm_file",
            "off",
            "len",
            "page"
          ],
          "line": 1369
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_update_writeable_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/addr.c",
          "lines": "1029-1123",
          "snippet": "static int ceph_update_writeable_page(struct file *file,\n\t\t\t    loff_t pos, unsigned len,\n\t\t\t    struct page *page)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tstruct ceph_mds_client *mdsc = ceph_inode_to_client(inode)->mdsc;\n\tloff_t page_off = pos & PAGE_CACHE_MASK;\n\tint pos_in_page = pos & ~PAGE_CACHE_MASK;\n\tint end_in_page = pos_in_page + len;\n\tloff_t i_size;\n\tint r;\n\tstruct ceph_snap_context *snapc, *oldest;\n\nretry_locked:\n\t/* writepages currently holds page lock, but if we change that later, */\n\twait_on_page_writeback(page);\n\n\t/* check snap context */\n\tBUG_ON(!ci->i_snap_realm);\n\tdown_read(&mdsc->snap_rwsem);\n\tBUG_ON(!ci->i_snap_realm->cached_context);\n\tsnapc = page_snap_context(page);\n\tif (snapc && snapc != ci->i_head_snapc) {\n\t\t/*\n\t\t * this page is already dirty in another (older) snap\n\t\t * context!  is it writeable now?\n\t\t */\n\t\toldest = get_oldest_context(inode, NULL);\n\t\tup_read(&mdsc->snap_rwsem);\n\n\t\tif (snapc->seq > oldest->seq) {\n\t\t\tceph_put_snap_context(oldest);\n\t\t\tdout(\" page %p snapc %p not current or oldest\\n\",\n\t\t\t     page, snapc);\n\t\t\t/*\n\t\t\t * queue for writeback, and wait for snapc to\n\t\t\t * be writeable or written\n\t\t\t */\n\t\t\tsnapc = ceph_get_snap_context(snapc);\n\t\t\tunlock_page(page);\n\t\t\tceph_queue_writeback(inode);\n\t\t\tr = wait_event_interruptible(ci->i_cap_wq,\n\t\t\t       context_is_writeable_or_written(inode, snapc));\n\t\t\tceph_put_snap_context(snapc);\n\t\t\tif (r == -ERESTARTSYS)\n\t\t\t\treturn r;\n\t\t\treturn -EAGAIN;\n\t\t}\n\t\tceph_put_snap_context(oldest);\n\n\t\t/* yay, writeable, do it now (without dropping page lock) */\n\t\tdout(\" page %p snapc %p not current, but oldest\\n\",\n\t\t     page, snapc);\n\t\tif (!clear_page_dirty_for_io(page))\n\t\t\tgoto retry_locked;\n\t\tr = writepage_nounlock(page, NULL);\n\t\tif (r < 0)\n\t\t\tgoto fail_nosnap;\n\t\tgoto retry_locked;\n\t}\n\n\tif (PageUptodate(page)) {\n\t\tdout(\" page %p already uptodate\\n\", page);\n\t\treturn 0;\n\t}\n\n\t/* full page? */\n\tif (pos_in_page == 0 && len == PAGE_CACHE_SIZE)\n\t\treturn 0;\n\n\t/* past end of file? */\n\ti_size = inode->i_size;   /* caller holds i_mutex */\n\n\tif (page_off >= i_size ||\n\t    (pos_in_page == 0 && (pos+len) >= i_size &&\n\t     end_in_page - pos_in_page != PAGE_CACHE_SIZE)) {\n\t\tdout(\" zeroing %p 0 - %d and %d - %d\\n\",\n\t\t     page, pos_in_page, end_in_page, (int)PAGE_CACHE_SIZE);\n\t\tzero_user_segments(page,\n\t\t\t\t   0, pos_in_page,\n\t\t\t\t   end_in_page, PAGE_CACHE_SIZE);\n\t\treturn 0;\n\t}\n\n\t/* we need to read it. */\n\tup_read(&mdsc->snap_rwsem);\n\tr = readpage_nounlock(file, page);\n\tif (r < 0)\n\t\tgoto fail_nosnap;\n\tgoto retry_locked;\nfail_nosnap:\n\tunlock_page(page);\n\treturn r;\n}",
          "includes": [
            "#include <linux/ceph/osd_client.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>\t/* generic_writepages */",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/osd_client.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/task_io_accounting_ops.h>\n#include <linux/pagevec.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\t/* generic_writepages */\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/backing-dev.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic int ceph_update_writeable_page(struct file *file,\n\t\t\t    loff_t pos, unsigned len,\n\t\t\t    struct page *page)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tstruct ceph_mds_client *mdsc = ceph_inode_to_client(inode)->mdsc;\n\tloff_t page_off = pos & PAGE_CACHE_MASK;\n\tint pos_in_page = pos & ~PAGE_CACHE_MASK;\n\tint end_in_page = pos_in_page + len;\n\tloff_t i_size;\n\tint r;\n\tstruct ceph_snap_context *snapc, *oldest;\n\nretry_locked:\n\t/* writepages currently holds page lock, but if we change that later, */\n\twait_on_page_writeback(page);\n\n\t/* check snap context */\n\tBUG_ON(!ci->i_snap_realm);\n\tdown_read(&mdsc->snap_rwsem);\n\tBUG_ON(!ci->i_snap_realm->cached_context);\n\tsnapc = page_snap_context(page);\n\tif (snapc && snapc != ci->i_head_snapc) {\n\t\t/*\n\t\t * this page is already dirty in another (older) snap\n\t\t * context!  is it writeable now?\n\t\t */\n\t\toldest = get_oldest_context(inode, NULL);\n\t\tup_read(&mdsc->snap_rwsem);\n\n\t\tif (snapc->seq > oldest->seq) {\n\t\t\tceph_put_snap_context(oldest);\n\t\t\tdout(\" page %p snapc %p not current or oldest\\n\",\n\t\t\t     page, snapc);\n\t\t\t/*\n\t\t\t * queue for writeback, and wait for snapc to\n\t\t\t * be writeable or written\n\t\t\t */\n\t\t\tsnapc = ceph_get_snap_context(snapc);\n\t\t\tunlock_page(page);\n\t\t\tceph_queue_writeback(inode);\n\t\t\tr = wait_event_interruptible(ci->i_cap_wq,\n\t\t\t       context_is_writeable_or_written(inode, snapc));\n\t\t\tceph_put_snap_context(snapc);\n\t\t\tif (r == -ERESTARTSYS)\n\t\t\t\treturn r;\n\t\t\treturn -EAGAIN;\n\t\t}\n\t\tceph_put_snap_context(oldest);\n\n\t\t/* yay, writeable, do it now (without dropping page lock) */\n\t\tdout(\" page %p snapc %p not current, but oldest\\n\",\n\t\t     page, snapc);\n\t\tif (!clear_page_dirty_for_io(page))\n\t\t\tgoto retry_locked;\n\t\tr = writepage_nounlock(page, NULL);\n\t\tif (r < 0)\n\t\t\tgoto fail_nosnap;\n\t\tgoto retry_locked;\n\t}\n\n\tif (PageUptodate(page)) {\n\t\tdout(\" page %p already uptodate\\n\", page);\n\t\treturn 0;\n\t}\n\n\t/* full page? */\n\tif (pos_in_page == 0 && len == PAGE_CACHE_SIZE)\n\t\treturn 0;\n\n\t/* past end of file? */\n\ti_size = inode->i_size;   /* caller holds i_mutex */\n\n\tif (page_off >= i_size ||\n\t    (pos_in_page == 0 && (pos+len) >= i_size &&\n\t     end_in_page - pos_in_page != PAGE_CACHE_SIZE)) {\n\t\tdout(\" zeroing %p 0 - %d and %d - %d\\n\",\n\t\t     page, pos_in_page, end_in_page, (int)PAGE_CACHE_SIZE);\n\t\tzero_user_segments(page,\n\t\t\t\t   0, pos_in_page,\n\t\t\t\t   end_in_page, PAGE_CACHE_SIZE);\n\t\treturn 0;\n\t}\n\n\t/* we need to read it. */\n\tup_read(&mdsc->snap_rwsem);\n\tr = readpage_nounlock(file, page);\n\tif (r < 0)\n\t\tgoto fail_nosnap;\n\tgoto retry_locked;\nfail_nosnap:\n\tunlock_page(page);\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_update_time",
          "args": [
            "vma->vm_file"
          ],
          "line": 1360
        },
        "resolved": true,
        "details": {
          "function_name": "file_update_time",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1716-1748",
          "snippet": "int file_update_time(struct file *file)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct timespec now;\n\tint sync_it = 0;\n\tint ret;\n\n\t/* First try to exhaust all avenues to not sync */\n\tif (IS_NOCMTIME(inode))\n\t\treturn 0;\n\n\tnow = current_fs_time(inode->i_sb);\n\tif (!timespec_equal(&inode->i_mtime, &now))\n\t\tsync_it = S_MTIME;\n\n\tif (!timespec_equal(&inode->i_ctime, &now))\n\t\tsync_it |= S_CTIME;\n\n\tif (IS_I_VERSION(inode))\n\t\tsync_it |= S_VERSION;\n\n\tif (!sync_it)\n\t\treturn 0;\n\n\t/* Finally allowed to write? Takes lock. */\n\tif (__mnt_want_write_file(file))\n\t\treturn 0;\n\n\tret = update_time(inode, &now, sync_it);\n\t__mnt_drop_write_file(file);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nint file_update_time(struct file *file)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct timespec now;\n\tint sync_it = 0;\n\tint ret;\n\n\t/* First try to exhaust all avenues to not sync */\n\tif (IS_NOCMTIME(inode))\n\t\treturn 0;\n\n\tnow = current_fs_time(inode->i_sb);\n\tif (!timespec_equal(&inode->i_mtime, &now))\n\t\tsync_it = S_MTIME;\n\n\tif (!timespec_equal(&inode->i_ctime, &now))\n\t\tsync_it |= S_CTIME;\n\n\tif (IS_I_VERSION(inode))\n\t\tsync_it |= S_VERSION;\n\n\tif (!sync_it)\n\t\treturn 0;\n\n\t/* Finally allowed to write? Takes lock. */\n\tif (__mnt_want_write_file(file))\n\t\treturn 0;\n\n\tret = update_time(inode, &now, sync_it);\n\t__mnt_drop_write_file(file);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"page_mkwrite %p %llu~%zd got cap refs on %s\\n\"",
            "inode",
            "off",
            "len",
            "ceph_cap_string(got)"
          ],
          "line": 1356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "1"
          ],
          "line": 1352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_get_caps",
          "args": [
            "ci",
            "CEPH_CAP_FILE_WR",
            "want",
            "off + len",
            "&got",
            "NULL"
          ],
          "line": 1347
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_get_caps",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
          "lines": "2203-2252",
          "snippet": "int ceph_get_caps(struct ceph_inode_info *ci, int need, int want,\n\t\t  loff_t endoff, int *got, struct page **pinned_page)\n{\n\tint _got, check_max, ret, err = 0;\n\nretry:\n\tif (endoff > 0)\n\t\tcheck_max_size(&ci->vfs_inode, endoff);\n\t_got = 0;\n\tcheck_max = 0;\n\tret = wait_event_interruptible(ci->i_cap_wq,\n\t\t\t\ttry_get_cap_refs(ci, need, want, endoff,\n\t\t\t\t\t\t &_got, &check_max, &err));\n\tif (err)\n\t\tret = err;\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (check_max)\n\t\tgoto retry;\n\n\tif (ci->i_inline_version != CEPH_INLINE_NONE &&\n\t    (_got & (CEPH_CAP_FILE_CACHE|CEPH_CAP_FILE_LAZYIO)) &&\n\t    i_size_read(&ci->vfs_inode) > 0) {\n\t\tstruct page *page = find_get_page(ci->vfs_inode.i_mapping, 0);\n\t\tif (page) {\n\t\t\tif (PageUptodate(page)) {\n\t\t\t\t*pinned_page = page;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tpage_cache_release(page);\n\t\t}\n\t\t/*\n\t\t * drop cap refs first because getattr while holding\n\t\t * caps refs can cause deadlock.\n\t\t */\n\t\tceph_put_cap_refs(ci, _got);\n\t\t_got = 0;\n\n\t\t/* getattr request will bring inline data into page cache */\n\t\tret = __ceph_do_getattr(&ci->vfs_inode, NULL,\n\t\t\t\t\tCEPH_STAT_CAP_INLINE_DATA, true);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tgoto retry;\n\t}\nout:\n\t*got = _got;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nint ceph_get_caps(struct ceph_inode_info *ci, int need, int want,\n\t\t  loff_t endoff, int *got, struct page **pinned_page)\n{\n\tint _got, check_max, ret, err = 0;\n\nretry:\n\tif (endoff > 0)\n\t\tcheck_max_size(&ci->vfs_inode, endoff);\n\t_got = 0;\n\tcheck_max = 0;\n\tret = wait_event_interruptible(ci->i_cap_wq,\n\t\t\t\ttry_get_cap_refs(ci, need, want, endoff,\n\t\t\t\t\t\t &_got, &check_max, &err));\n\tif (err)\n\t\tret = err;\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (check_max)\n\t\tgoto retry;\n\n\tif (ci->i_inline_version != CEPH_INLINE_NONE &&\n\t    (_got & (CEPH_CAP_FILE_CACHE|CEPH_CAP_FILE_LAZYIO)) &&\n\t    i_size_read(&ci->vfs_inode) > 0) {\n\t\tstruct page *page = find_get_page(ci->vfs_inode.i_mapping, 0);\n\t\tif (page) {\n\t\t\tif (PageUptodate(page)) {\n\t\t\t\t*pinned_page = page;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tpage_cache_release(page);\n\t\t}\n\t\t/*\n\t\t * drop cap refs first because getattr while holding\n\t\t * caps refs can cause deadlock.\n\t\t */\n\t\tceph_put_cap_refs(ci, _got);\n\t\t_got = 0;\n\n\t\t/* getattr request will bring inline data into page cache */\n\t\tret = __ceph_do_getattr(&ci->vfs_inode, NULL,\n\t\t\t\t\tCEPH_STAT_CAP_INLINE_DATA, true);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tgoto retry;\n\t}\nout:\n\t*got = _got;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"page_mkwrite %p %llx.%llx %llu~%zd getting caps i_size %llu\\n\"",
            "inode",
            "ceph_vinop(inode)",
            "off",
            "len",
            "size"
          ],
          "line": 1339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_vinop",
          "args": [
            "inode"
          ],
          "line": 1340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_uninline_data",
          "args": [
            "vma->vm_file",
            "locked_page"
          ],
          "line": 1327
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_uninline_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/addr.c",
          "lines": "1445-1572",
          "snippet": "int ceph_uninline_data(struct file *filp, struct page *locked_page)\n{\n\tstruct inode *inode = file_inode(filp);\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tstruct ceph_fs_client *fsc = ceph_inode_to_client(inode);\n\tstruct ceph_osd_request *req;\n\tstruct page *page = NULL;\n\tu64 len, inline_version;\n\tint err = 0;\n\tbool from_pagecache = false;\n\n\tspin_lock(&ci->i_ceph_lock);\n\tinline_version = ci->i_inline_version;\n\tspin_unlock(&ci->i_ceph_lock);\n\n\tdout(\"uninline_data %p %llx.%llx inline_version %llu\\n\",\n\t     inode, ceph_vinop(inode), inline_version);\n\n\tif (inline_version == 1 || /* initial version, no data */\n\t    inline_version == CEPH_INLINE_NONE)\n\t\tgoto out;\n\n\tif (locked_page) {\n\t\tpage = locked_page;\n\t\tWARN_ON(!PageUptodate(page));\n\t} else if (ceph_caps_issued(ci) &\n\t\t   (CEPH_CAP_FILE_CACHE|CEPH_CAP_FILE_LAZYIO)) {\n\t\tpage = find_get_page(inode->i_mapping, 0);\n\t\tif (page) {\n\t\t\tif (PageUptodate(page)) {\n\t\t\t\tfrom_pagecache = true;\n\t\t\t\tlock_page(page);\n\t\t\t} else {\n\t\t\t\tpage_cache_release(page);\n\t\t\t\tpage = NULL;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (page) {\n\t\tlen = i_size_read(inode);\n\t\tif (len > PAGE_CACHE_SIZE)\n\t\t\tlen = PAGE_CACHE_SIZE;\n\t} else {\n\t\tpage = __page_cache_alloc(GFP_NOFS);\n\t\tif (!page) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\terr = __ceph_do_getattr(inode, page,\n\t\t\t\t\tCEPH_STAT_CAP_INLINE_DATA, true);\n\t\tif (err < 0) {\n\t\t\t/* no inline data */\n\t\t\tif (err == -ENODATA)\n\t\t\t\terr = 0;\n\t\t\tgoto out;\n\t\t}\n\t\tlen = err;\n\t}\n\n\treq = ceph_osdc_new_request(&fsc->client->osdc, &ci->i_layout,\n\t\t\t\t    ceph_vino(inode), 0, &len, 0, 1,\n\t\t\t\t    CEPH_OSD_OP_CREATE,\n\t\t\t\t    CEPH_OSD_FLAG_ONDISK | CEPH_OSD_FLAG_WRITE,\n\t\t\t\t    ci->i_snap_realm->cached_context,\n\t\t\t\t    0, 0, false);\n\tif (IS_ERR(req)) {\n\t\terr = PTR_ERR(req);\n\t\tgoto out;\n\t}\n\n\tceph_osdc_build_request(req, 0, NULL, CEPH_NOSNAP, &inode->i_mtime);\n\terr = ceph_osdc_start_request(&fsc->client->osdc, req, false);\n\tif (!err)\n\t\terr = ceph_osdc_wait_request(&fsc->client->osdc, req);\n\tceph_osdc_put_request(req);\n\tif (err < 0)\n\t\tgoto out;\n\n\treq = ceph_osdc_new_request(&fsc->client->osdc, &ci->i_layout,\n\t\t\t\t    ceph_vino(inode), 0, &len, 1, 3,\n\t\t\t\t    CEPH_OSD_OP_WRITE,\n\t\t\t\t    CEPH_OSD_FLAG_ONDISK | CEPH_OSD_FLAG_WRITE,\n\t\t\t\t    ci->i_snap_realm->cached_context,\n\t\t\t\t    ci->i_truncate_seq, ci->i_truncate_size,\n\t\t\t\t    false);\n\tif (IS_ERR(req)) {\n\t\terr = PTR_ERR(req);\n\t\tgoto out;\n\t}\n\n\tosd_req_op_extent_osd_data_pages(req, 1, &page, len, 0, false, false);\n\n\terr = osd_req_op_xattr_init(req, 0, CEPH_OSD_OP_CMPXATTR,\n\t\t\t\t    \"inline_version\", &inline_version,\n\t\t\t\t    sizeof(inline_version),\n\t\t\t\t    CEPH_OSD_CMPXATTR_OP_GT,\n\t\t\t\t    CEPH_OSD_CMPXATTR_MODE_U64);\n\tif (err)\n\t\tgoto out_put;\n\n\terr = osd_req_op_xattr_init(req, 2, CEPH_OSD_OP_SETXATTR,\n\t\t\t\t    \"inline_version\", &inline_version,\n\t\t\t\t    sizeof(inline_version), 0, 0);\n\tif (err)\n\t\tgoto out_put;\n\n\tceph_osdc_build_request(req, 0, NULL, CEPH_NOSNAP, &inode->i_mtime);\n\terr = ceph_osdc_start_request(&fsc->client->osdc, req, false);\n\tif (!err)\n\t\terr = ceph_osdc_wait_request(&fsc->client->osdc, req);\nout_put:\n\tceph_osdc_put_request(req);\n\tif (err == -ECANCELED)\n\t\terr = 0;\nout:\n\tif (page && page != locked_page) {\n\t\tif (from_pagecache) {\n\t\t\tunlock_page(page);\n\t\t\tpage_cache_release(page);\n\t\t} else\n\t\t\t__free_pages(page, 0);\n\t}\n\n\tdout(\"uninline_data %p %llx.%llx inline_version %llu = %d\\n\",\n\t     inode, ceph_vinop(inode), inline_version, err);\n\treturn err;\n}",
          "includes": [
            "#include <linux/ceph/osd_client.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>\t/* generic_writepages */",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/osd_client.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/task_io_accounting_ops.h>\n#include <linux/pagevec.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\t/* generic_writepages */\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/backing-dev.h>\n#include <linux/ceph/ceph_debug.h>\n\nint ceph_uninline_data(struct file *filp, struct page *locked_page)\n{\n\tstruct inode *inode = file_inode(filp);\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tstruct ceph_fs_client *fsc = ceph_inode_to_client(inode);\n\tstruct ceph_osd_request *req;\n\tstruct page *page = NULL;\n\tu64 len, inline_version;\n\tint err = 0;\n\tbool from_pagecache = false;\n\n\tspin_lock(&ci->i_ceph_lock);\n\tinline_version = ci->i_inline_version;\n\tspin_unlock(&ci->i_ceph_lock);\n\n\tdout(\"uninline_data %p %llx.%llx inline_version %llu\\n\",\n\t     inode, ceph_vinop(inode), inline_version);\n\n\tif (inline_version == 1 || /* initial version, no data */\n\t    inline_version == CEPH_INLINE_NONE)\n\t\tgoto out;\n\n\tif (locked_page) {\n\t\tpage = locked_page;\n\t\tWARN_ON(!PageUptodate(page));\n\t} else if (ceph_caps_issued(ci) &\n\t\t   (CEPH_CAP_FILE_CACHE|CEPH_CAP_FILE_LAZYIO)) {\n\t\tpage = find_get_page(inode->i_mapping, 0);\n\t\tif (page) {\n\t\t\tif (PageUptodate(page)) {\n\t\t\t\tfrom_pagecache = true;\n\t\t\t\tlock_page(page);\n\t\t\t} else {\n\t\t\t\tpage_cache_release(page);\n\t\t\t\tpage = NULL;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (page) {\n\t\tlen = i_size_read(inode);\n\t\tif (len > PAGE_CACHE_SIZE)\n\t\t\tlen = PAGE_CACHE_SIZE;\n\t} else {\n\t\tpage = __page_cache_alloc(GFP_NOFS);\n\t\tif (!page) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\terr = __ceph_do_getattr(inode, page,\n\t\t\t\t\tCEPH_STAT_CAP_INLINE_DATA, true);\n\t\tif (err < 0) {\n\t\t\t/* no inline data */\n\t\t\tif (err == -ENODATA)\n\t\t\t\terr = 0;\n\t\t\tgoto out;\n\t\t}\n\t\tlen = err;\n\t}\n\n\treq = ceph_osdc_new_request(&fsc->client->osdc, &ci->i_layout,\n\t\t\t\t    ceph_vino(inode), 0, &len, 0, 1,\n\t\t\t\t    CEPH_OSD_OP_CREATE,\n\t\t\t\t    CEPH_OSD_FLAG_ONDISK | CEPH_OSD_FLAG_WRITE,\n\t\t\t\t    ci->i_snap_realm->cached_context,\n\t\t\t\t    0, 0, false);\n\tif (IS_ERR(req)) {\n\t\terr = PTR_ERR(req);\n\t\tgoto out;\n\t}\n\n\tceph_osdc_build_request(req, 0, NULL, CEPH_NOSNAP, &inode->i_mtime);\n\terr = ceph_osdc_start_request(&fsc->client->osdc, req, false);\n\tif (!err)\n\t\terr = ceph_osdc_wait_request(&fsc->client->osdc, req);\n\tceph_osdc_put_request(req);\n\tif (err < 0)\n\t\tgoto out;\n\n\treq = ceph_osdc_new_request(&fsc->client->osdc, &ci->i_layout,\n\t\t\t\t    ceph_vino(inode), 0, &len, 1, 3,\n\t\t\t\t    CEPH_OSD_OP_WRITE,\n\t\t\t\t    CEPH_OSD_FLAG_ONDISK | CEPH_OSD_FLAG_WRITE,\n\t\t\t\t    ci->i_snap_realm->cached_context,\n\t\t\t\t    ci->i_truncate_seq, ci->i_truncate_size,\n\t\t\t\t    false);\n\tif (IS_ERR(req)) {\n\t\terr = PTR_ERR(req);\n\t\tgoto out;\n\t}\n\n\tosd_req_op_extent_osd_data_pages(req, 1, &page, len, 0, false, false);\n\n\terr = osd_req_op_xattr_init(req, 0, CEPH_OSD_OP_CMPXATTR,\n\t\t\t\t    \"inline_version\", &inline_version,\n\t\t\t\t    sizeof(inline_version),\n\t\t\t\t    CEPH_OSD_CMPXATTR_OP_GT,\n\t\t\t\t    CEPH_OSD_CMPXATTR_MODE_U64);\n\tif (err)\n\t\tgoto out_put;\n\n\terr = osd_req_op_xattr_init(req, 2, CEPH_OSD_OP_SETXATTR,\n\t\t\t\t    \"inline_version\", &inline_version,\n\t\t\t\t    sizeof(inline_version), 0, 0);\n\tif (err)\n\t\tgoto out_put;\n\n\tceph_osdc_build_request(req, 0, NULL, CEPH_NOSNAP, &inode->i_mtime);\n\terr = ceph_osdc_start_request(&fsc->client->osdc, req, false);\n\tif (!err)\n\t\terr = ceph_osdc_wait_request(&fsc->client->osdc, req);\nout_put:\n\tceph_osdc_put_request(req);\n\tif (err == -ECANCELED)\n\t\terr = 0;\nout:\n\tif (page && page != locked_page) {\n\t\tif (from_pagecache) {\n\t\t\tunlock_page(page);\n\t\t\tpage_cache_release(page);\n\t\t} else\n\t\t\t__free_pages(page, 0);\n\t}\n\n\tdout(\"uninline_data %p %llx.%llx inline_version %llu = %d\\n\",\n\t     inode, ceph_vinop(inode), inline_version, err);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 1317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_offset",
          "args": [
            "page"
          ],
          "line": 1316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_inode_to_client",
          "args": [
            "inode"
          ],
          "line": 1314
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_inode_to_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.h",
          "lines": "347-350",
          "snippet": "static inline struct ceph_fs_client *ceph_inode_to_client(struct inode *inode)\n{\n\treturn (struct ceph_fs_client *)inode->i_sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/ceph/libceph.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/backing-dev.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/ceph/libceph.h>\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n#include <linux/completion.h>\n#include <linux/backing-dev.h>\n#include <asm/unaligned.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline struct ceph_fs_client *ceph_inode_to_client(struct inode *inode)\n{\n\treturn (struct ceph_fs_client *)inode->i_sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "vma->vm_file"
          ],
          "line": 1311
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/ceph/osd_client.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/task_io_accounting_ops.h>\n#include <linux/pagevec.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\t/* generic_writepages */\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/backing-dev.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic int ceph_page_mkwrite(struct vm_area_struct *vma, struct vm_fault *vmf)\n{\n\tstruct inode *inode = file_inode(vma->vm_file);\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tstruct ceph_file_info *fi = vma->vm_file->private_data;\n\tstruct ceph_mds_client *mdsc = ceph_inode_to_client(inode)->mdsc;\n\tstruct page *page = vmf->page;\n\tloff_t off = page_offset(page);\n\tloff_t size = i_size_read(inode);\n\tsize_t len;\n\tint want, got, ret;\n\n\tif (ci->i_inline_version != CEPH_INLINE_NONE) {\n\t\tstruct page *locked_page = NULL;\n\t\tif (off == 0) {\n\t\t\tlock_page(page);\n\t\t\tlocked_page = page;\n\t\t}\n\t\tret = ceph_uninline_data(vma->vm_file, locked_page);\n\t\tif (locked_page)\n\t\t\tunlock_page(locked_page);\n\t\tif (ret < 0)\n\t\t\treturn VM_FAULT_SIGBUS;\n\t}\n\n\tif (off + PAGE_CACHE_SIZE <= size)\n\t\tlen = PAGE_CACHE_SIZE;\n\telse\n\t\tlen = size & ~PAGE_CACHE_MASK;\n\n\tdout(\"page_mkwrite %p %llx.%llx %llu~%zd getting caps i_size %llu\\n\",\n\t     inode, ceph_vinop(inode), off, len, size);\n\tif (fi->fmode & CEPH_FILE_MODE_LAZY)\n\t\twant = CEPH_CAP_FILE_BUFFER | CEPH_CAP_FILE_LAZYIO;\n\telse\n\t\twant = CEPH_CAP_FILE_BUFFER;\n\twhile (1) {\n\t\tgot = 0;\n\t\tret = ceph_get_caps(ci, CEPH_CAP_FILE_WR, want, off + len,\n\t\t\t\t    &got, NULL);\n\t\tif (ret == 0)\n\t\t\tbreak;\n\t\tif (ret != -ERESTARTSYS) {\n\t\t\tWARN_ON(1);\n\t\t\treturn VM_FAULT_SIGBUS;\n\t\t}\n\t}\n\tdout(\"page_mkwrite %p %llu~%zd got cap refs on %s\\n\",\n\t     inode, off, len, ceph_cap_string(got));\n\n\t/* Update time before taking page lock */\n\tfile_update_time(vma->vm_file);\n\n\tlock_page(page);\n\n\tret = VM_FAULT_NOPAGE;\n\tif ((off > size) ||\n\t    (page->mapping != inode->i_mapping))\n\t\tgoto out;\n\n\tret = ceph_update_writeable_page(vma->vm_file, off, len, page);\n\tif (ret == 0) {\n\t\t/* success.  we'll keep the page locked. */\n\t\tset_page_dirty(page);\n\t\tup_read(&mdsc->snap_rwsem);\n\t\tret = VM_FAULT_LOCKED;\n\t} else {\n\t\tif (ret == -ENOMEM)\n\t\t\tret = VM_FAULT_OOM;\n\t\telse\n\t\t\tret = VM_FAULT_SIGBUS;\n\t}\nout:\n\tif (ret != VM_FAULT_LOCKED)\n\t\tunlock_page(page);\n\tif (ret == VM_FAULT_LOCKED ||\n\t    ci->i_inline_version != CEPH_INLINE_NONE) {\n\t\tint dirty;\n\t\tspin_lock(&ci->i_ceph_lock);\n\t\tci->i_inline_version = CEPH_INLINE_NONE;\n\t\tdirty = __ceph_mark_dirty_caps(ci, CEPH_CAP_FILE_WR);\n\t\tspin_unlock(&ci->i_ceph_lock);\n\t\tif (dirty)\n\t\t\t__mark_inode_dirty(inode, dirty);\n\t}\n\n\tdout(\"page_mkwrite %p %llu~%zd dropping cap refs on %s ret %d\\n\",\n\t     inode, off, len, ceph_cap_string(got), ret);\n\tceph_put_cap_refs(ci, got);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "ceph_filemap_fault",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/addr.c",
    "lines": "1226-1304",
    "snippet": "static int ceph_filemap_fault(struct vm_area_struct *vma, struct vm_fault *vmf)\n{\n\tstruct inode *inode = file_inode(vma->vm_file);\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tstruct ceph_file_info *fi = vma->vm_file->private_data;\n\tstruct page *pinned_page = NULL;\n\tloff_t off = vmf->pgoff << PAGE_CACHE_SHIFT;\n\tint want, got, ret;\n\n\tdout(\"filemap_fault %p %llx.%llx %llu~%zd trying to get caps\\n\",\n\t     inode, ceph_vinop(inode), off, (size_t)PAGE_CACHE_SIZE);\n\tif (fi->fmode & CEPH_FILE_MODE_LAZY)\n\t\twant = CEPH_CAP_FILE_CACHE | CEPH_CAP_FILE_LAZYIO;\n\telse\n\t\twant = CEPH_CAP_FILE_CACHE;\n\twhile (1) {\n\t\tgot = 0;\n\t\tret = ceph_get_caps(ci, CEPH_CAP_FILE_RD, want,\n\t\t\t\t    -1, &got, &pinned_page);\n\t\tif (ret == 0)\n\t\t\tbreak;\n\t\tif (ret != -ERESTARTSYS) {\n\t\t\tWARN_ON(1);\n\t\t\treturn VM_FAULT_SIGBUS;\n\t\t}\n\t}\n\tdout(\"filemap_fault %p %llu~%zd got cap refs on %s\\n\",\n\t     inode, off, (size_t)PAGE_CACHE_SIZE, ceph_cap_string(got));\n\n\tif ((got & (CEPH_CAP_FILE_CACHE | CEPH_CAP_FILE_LAZYIO)) ||\n\t    ci->i_inline_version == CEPH_INLINE_NONE)\n\t\tret = filemap_fault(vma, vmf);\n\telse\n\t\tret = -EAGAIN;\n\n\tdout(\"filemap_fault %p %llu~%zd dropping cap refs on %s ret %d\\n\",\n\t     inode, off, (size_t)PAGE_CACHE_SIZE, ceph_cap_string(got), ret);\n\tif (pinned_page)\n\t\tpage_cache_release(pinned_page);\n\tceph_put_cap_refs(ci, got);\n\n\tif (ret != -EAGAIN)\n\t\treturn ret;\n\n\t/* read inline data */\n\tif (off >= PAGE_CACHE_SIZE) {\n\t\t/* does not support inline data > PAGE_SIZE */\n\t\tret = VM_FAULT_SIGBUS;\n\t} else {\n\t\tint ret1;\n\t\tstruct address_space *mapping = inode->i_mapping;\n\t\tstruct page *page = find_or_create_page(mapping, 0,\n\t\t\t\t\t\tmapping_gfp_mask(mapping) &\n\t\t\t\t\t\t~__GFP_FS);\n\t\tif (!page) {\n\t\t\tret = VM_FAULT_OOM;\n\t\t\tgoto out;\n\t\t}\n\t\tret1 = __ceph_do_getattr(inode, page,\n\t\t\t\t\t CEPH_STAT_CAP_INLINE_DATA, true);\n\t\tif (ret1 < 0 || off >= i_size_read(inode)) {\n\t\t\tunlock_page(page);\n\t\t\tpage_cache_release(page);\n\t\t\tret = VM_FAULT_SIGBUS;\n\t\t\tgoto out;\n\t\t}\n\t\tif (ret1 < PAGE_CACHE_SIZE)\n\t\t\tzero_user_segment(page, ret1, PAGE_CACHE_SIZE);\n\t\telse\n\t\t\tflush_dcache_page(page);\n\t\tSetPageUptodate(page);\n\t\tvmf->page = page;\n\t\tret = VM_FAULT_MAJOR | VM_FAULT_LOCKED;\n\t}\nout:\n\tdout(\"filemap_fault %p %llu~%zd read inline data ret %d\\n\",\n\t     inode, off, (size_t)PAGE_CACHE_SIZE, ret);\n\treturn ret;\n}",
    "includes": [
      "#include <linux/ceph/osd_client.h>",
      "#include \"cache.h\"",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/slab.h>",
      "#include <linux/writeback.h>\t/* generic_writepages */",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"filemap_fault %p %llu~%zd read inline data ret %d\\n\"",
            "inode",
            "off",
            "(size_t)PAGE_CACHE_SIZE",
            "ret"
          ],
          "line": 1301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetPageUptodate",
          "args": [
            "page"
          ],
          "line": 1296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flush_dcache_page",
          "args": [
            "page"
          ],
          "line": 1295
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_index_entry_flush_dcache_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/index.h",
          "lines": "111-117",
          "snippet": "static inline void ntfs_index_entry_flush_dcache_page(ntfs_index_context *ictx)\n{\n\tif (ictx->is_in_root)\n\t\tflush_dcache_mft_record_page(ictx->actx->ntfs_ino);\n\telse\n\t\tflush_dcache_page(ictx->page);\n}",
          "includes": [
            "#include \"aops.h\"",
            "#include \"mft.h\"",
            "#include \"attrib.h\"",
            "#include \"inode.h\"",
            "#include \"layout.h\"",
            "#include \"types.h\"",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"aops.h\"\n#include \"mft.h\"\n#include \"attrib.h\"\n#include \"inode.h\"\n#include \"layout.h\"\n#include \"types.h\"\n#include <linux/fs.h>\n\nstatic inline void ntfs_index_entry_flush_dcache_page(ntfs_index_context *ictx)\n{\n\tif (ictx->is_in_root)\n\t\tflush_dcache_mft_record_page(ictx->actx->ntfs_ino);\n\telse\n\t\tflush_dcache_page(ictx->page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "zero_user_segment",
          "args": [
            "page",
            "ret1",
            "PAGE_CACHE_SIZE"
          ],
          "line": 1293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "page"
          ],
          "line": 1288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 1287
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 1286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__ceph_do_getattr",
          "args": [
            "inode",
            "page",
            "CEPH_STAT_CAP_INLINE_DATA",
            "true"
          ],
          "line": 1284
        },
        "resolved": true,
        "details": {
          "function_name": "__ceph_do_getattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/inode.c",
          "lines": "1924-1965",
          "snippet": "int __ceph_do_getattr(struct inode *inode, struct page *locked_page,\n\t\t      int mask, bool force)\n{\n\tstruct ceph_fs_client *fsc = ceph_sb_to_client(inode->i_sb);\n\tstruct ceph_mds_client *mdsc = fsc->mdsc;\n\tstruct ceph_mds_request *req;\n\tint err;\n\n\tif (ceph_snap(inode) == CEPH_SNAPDIR) {\n\t\tdout(\"do_getattr inode %p SNAPDIR\\n\", inode);\n\t\treturn 0;\n\t}\n\n\tdout(\"do_getattr inode %p mask %s mode 0%o\\n\",\n\t     inode, ceph_cap_string(mask), inode->i_mode);\n\tif (!force && ceph_caps_issued_mask(ceph_inode(inode), mask, 1))\n\t\treturn 0;\n\n\treq = ceph_mdsc_create_request(mdsc, CEPH_MDS_OP_GETATTR, USE_ANY_MDS);\n\tif (IS_ERR(req))\n\t\treturn PTR_ERR(req);\n\treq->r_inode = inode;\n\tihold(inode);\n\treq->r_num_caps = 1;\n\treq->r_args.getattr.mask = cpu_to_le32(mask);\n\treq->r_locked_page = locked_page;\n\terr = ceph_mdsc_do_request(mdsc, NULL, req);\n\tif (locked_page && err == 0) {\n\t\tu64 inline_version = req->r_reply_info.targeti.inline_version;\n\t\tif (inline_version == 0) {\n\t\t\t/* the reply is supposed to contain inline data */\n\t\t\terr = -EINVAL;\n\t\t} else if (inline_version == CEPH_INLINE_NONE) {\n\t\t\terr = -ENODATA;\n\t\t} else {\n\t\t\terr = req->r_reply_info.targeti.inline_len;\n\t\t}\n\t}\n\tceph_mdsc_put_request(req);\n\tdout(\"do_getattr result=%d\\n\", err);\n\treturn err;\n}",
          "includes": [
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/random.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/namei.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/random.h>\n#include <linux/posix_acl.h>\n#include <linux/vmalloc.h>\n#include <linux/writeback.h>\n#include <linux/namei.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/ceph/ceph_debug.h>\n\nint __ceph_do_getattr(struct inode *inode, struct page *locked_page,\n\t\t      int mask, bool force)\n{\n\tstruct ceph_fs_client *fsc = ceph_sb_to_client(inode->i_sb);\n\tstruct ceph_mds_client *mdsc = fsc->mdsc;\n\tstruct ceph_mds_request *req;\n\tint err;\n\n\tif (ceph_snap(inode) == CEPH_SNAPDIR) {\n\t\tdout(\"do_getattr inode %p SNAPDIR\\n\", inode);\n\t\treturn 0;\n\t}\n\n\tdout(\"do_getattr inode %p mask %s mode 0%o\\n\",\n\t     inode, ceph_cap_string(mask), inode->i_mode);\n\tif (!force && ceph_caps_issued_mask(ceph_inode(inode), mask, 1))\n\t\treturn 0;\n\n\treq = ceph_mdsc_create_request(mdsc, CEPH_MDS_OP_GETATTR, USE_ANY_MDS);\n\tif (IS_ERR(req))\n\t\treturn PTR_ERR(req);\n\treq->r_inode = inode;\n\tihold(inode);\n\treq->r_num_caps = 1;\n\treq->r_args.getattr.mask = cpu_to_le32(mask);\n\treq->r_locked_page = locked_page;\n\terr = ceph_mdsc_do_request(mdsc, NULL, req);\n\tif (locked_page && err == 0) {\n\t\tu64 inline_version = req->r_reply_info.targeti.inline_version;\n\t\tif (inline_version == 0) {\n\t\t\t/* the reply is supposed to contain inline data */\n\t\t\terr = -EINVAL;\n\t\t} else if (inline_version == CEPH_INLINE_NONE) {\n\t\t\terr = -ENODATA;\n\t\t} else {\n\t\t\terr = req->r_reply_info.targeti.inline_len;\n\t\t}\n\t}\n\tceph_mdsc_put_request(req);\n\tdout(\"do_getattr result=%d\\n\", err);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_or_create_page",
          "args": [
            "mapping",
            "0",
            "mapping_gfp_mask(mapping) &\n\t\t\t\t\t\t~__GFP_FS"
          ],
          "line": 1277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mapping_gfp_mask",
          "args": [
            "mapping"
          ],
          "line": 1278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_put_cap_refs",
          "args": [
            "ci",
            "got"
          ],
          "line": 1265
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_put_cap_refs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
          "lines": "2274-2326",
          "snippet": "void ceph_put_cap_refs(struct ceph_inode_info *ci, int had)\n{\n\tstruct inode *inode = &ci->vfs_inode;\n\tint last = 0, put = 0, flushsnaps = 0, wake = 0;\n\tstruct ceph_cap_snap *capsnap;\n\n\tspin_lock(&ci->i_ceph_lock);\n\tif (had & CEPH_CAP_PIN)\n\t\t--ci->i_pin_ref;\n\tif (had & CEPH_CAP_FILE_RD)\n\t\tif (--ci->i_rd_ref == 0)\n\t\t\tlast++;\n\tif (had & CEPH_CAP_FILE_CACHE)\n\t\tif (--ci->i_rdcache_ref == 0)\n\t\t\tlast++;\n\tif (had & CEPH_CAP_FILE_BUFFER) {\n\t\tif (--ci->i_wb_ref == 0) {\n\t\t\tlast++;\n\t\t\tput++;\n\t\t}\n\t\tdout(\"put_cap_refs %p wb %d -> %d (?)\\n\",\n\t\t     inode, ci->i_wb_ref+1, ci->i_wb_ref);\n\t}\n\tif (had & CEPH_CAP_FILE_WR)\n\t\tif (--ci->i_wr_ref == 0) {\n\t\t\tlast++;\n\t\t\tif (!list_empty(&ci->i_cap_snaps)) {\n\t\t\t\tcapsnap = list_first_entry(&ci->i_cap_snaps,\n\t\t\t\t\t\t     struct ceph_cap_snap,\n\t\t\t\t\t\t     ci_item);\n\t\t\t\tif (capsnap->writing) {\n\t\t\t\t\tcapsnap->writing = 0;\n\t\t\t\t\tflushsnaps =\n\t\t\t\t\t\t__ceph_finish_cap_snap(ci,\n\t\t\t\t\t\t\t\t       capsnap);\n\t\t\t\t\twake = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\tspin_unlock(&ci->i_ceph_lock);\n\n\tdout(\"put_cap_refs %p had %s%s%s\\n\", inode, ceph_cap_string(had),\n\t     last ? \" last\" : \"\", put ? \" put\" : \"\");\n\n\tif (last && !flushsnaps)\n\t\tceph_check_caps(ci, 0, NULL);\n\telse if (flushsnaps)\n\t\tceph_flush_snaps(ci);\n\tif (wake)\n\t\twake_up_all(&ci->i_cap_wq);\n\tif (put)\n\t\tiput(inode);\n}",
          "includes": [
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nvoid ceph_put_cap_refs(struct ceph_inode_info *ci, int had)\n{\n\tstruct inode *inode = &ci->vfs_inode;\n\tint last = 0, put = 0, flushsnaps = 0, wake = 0;\n\tstruct ceph_cap_snap *capsnap;\n\n\tspin_lock(&ci->i_ceph_lock);\n\tif (had & CEPH_CAP_PIN)\n\t\t--ci->i_pin_ref;\n\tif (had & CEPH_CAP_FILE_RD)\n\t\tif (--ci->i_rd_ref == 0)\n\t\t\tlast++;\n\tif (had & CEPH_CAP_FILE_CACHE)\n\t\tif (--ci->i_rdcache_ref == 0)\n\t\t\tlast++;\n\tif (had & CEPH_CAP_FILE_BUFFER) {\n\t\tif (--ci->i_wb_ref == 0) {\n\t\t\tlast++;\n\t\t\tput++;\n\t\t}\n\t\tdout(\"put_cap_refs %p wb %d -> %d (?)\\n\",\n\t\t     inode, ci->i_wb_ref+1, ci->i_wb_ref);\n\t}\n\tif (had & CEPH_CAP_FILE_WR)\n\t\tif (--ci->i_wr_ref == 0) {\n\t\t\tlast++;\n\t\t\tif (!list_empty(&ci->i_cap_snaps)) {\n\t\t\t\tcapsnap = list_first_entry(&ci->i_cap_snaps,\n\t\t\t\t\t\t     struct ceph_cap_snap,\n\t\t\t\t\t\t     ci_item);\n\t\t\t\tif (capsnap->writing) {\n\t\t\t\t\tcapsnap->writing = 0;\n\t\t\t\t\tflushsnaps =\n\t\t\t\t\t\t__ceph_finish_cap_snap(ci,\n\t\t\t\t\t\t\t\t       capsnap);\n\t\t\t\t\twake = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\tspin_unlock(&ci->i_ceph_lock);\n\n\tdout(\"put_cap_refs %p had %s%s%s\\n\", inode, ceph_cap_string(had),\n\t     last ? \" last\" : \"\", put ? \" put\" : \"\");\n\n\tif (last && !flushsnaps)\n\t\tceph_check_caps(ci, 0, NULL);\n\telse if (flushsnaps)\n\t\tceph_flush_snaps(ci);\n\tif (wake)\n\t\twake_up_all(&ci->i_cap_wq);\n\tif (put)\n\t\tiput(inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "pinned_page"
          ],
          "line": 1264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"filemap_fault %p %llu~%zd dropping cap refs on %s ret %d\\n\"",
            "inode",
            "off",
            "(size_t)PAGE_CACHE_SIZE",
            "ceph_cap_string(got)",
            "ret"
          ],
          "line": 1261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_cap_string",
          "args": [
            "got"
          ],
          "line": 1262
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_cap_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
          "lines": "71-116",
          "snippet": "const char *ceph_cap_string(int caps)\n{\n\tint i;\n\tchar *s;\n\tint c;\n\n\tspin_lock(&cap_str_lock);\n\ti = last_cap_str++;\n\tif (last_cap_str == MAX_CAP_STR)\n\t\tlast_cap_str = 0;\n\tspin_unlock(&cap_str_lock);\n\n\ts = cap_str[i];\n\n\tif (caps & CEPH_CAP_PIN)\n\t\t*s++ = 'p';\n\n\tc = (caps >> CEPH_CAP_SAUTH) & 3;\n\tif (c) {\n\t\t*s++ = 'A';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tc = (caps >> CEPH_CAP_SLINK) & 3;\n\tif (c) {\n\t\t*s++ = 'L';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tc = (caps >> CEPH_CAP_SXATTR) & 3;\n\tif (c) {\n\t\t*s++ = 'X';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tc = caps >> CEPH_CAP_SFILE;\n\tif (c) {\n\t\t*s++ = 'F';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tif (s == cap_str[i])\n\t\t*s++ = '-';\n\t*s = 0;\n\treturn cap_str[i];\n}",
          "includes": [
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [
            "#define MAX_CAP_STR 20"
          ],
          "globals_used": [
            "static char cap_str[MAX_CAP_STR][40];",
            "static DEFINE_SPINLOCK(cap_str_lock);",
            "static int last_cap_str;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\n#define MAX_CAP_STR 20\n\nstatic char cap_str[MAX_CAP_STR][40];\nstatic DEFINE_SPINLOCK(cap_str_lock);\nstatic int last_cap_str;\n\nconst char *ceph_cap_string(int caps)\n{\n\tint i;\n\tchar *s;\n\tint c;\n\n\tspin_lock(&cap_str_lock);\n\ti = last_cap_str++;\n\tif (last_cap_str == MAX_CAP_STR)\n\t\tlast_cap_str = 0;\n\tspin_unlock(&cap_str_lock);\n\n\ts = cap_str[i];\n\n\tif (caps & CEPH_CAP_PIN)\n\t\t*s++ = 'p';\n\n\tc = (caps >> CEPH_CAP_SAUTH) & 3;\n\tif (c) {\n\t\t*s++ = 'A';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tc = (caps >> CEPH_CAP_SLINK) & 3;\n\tif (c) {\n\t\t*s++ = 'L';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tc = (caps >> CEPH_CAP_SXATTR) & 3;\n\tif (c) {\n\t\t*s++ = 'X';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tc = caps >> CEPH_CAP_SFILE;\n\tif (c) {\n\t\t*s++ = 'F';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tif (s == cap_str[i])\n\t\t*s++ = '-';\n\t*s = 0;\n\treturn cap_str[i];\n}"
        }
      },
      {
        "call_info": {
          "callee": "filemap_fault",
          "args": [
            "vma",
            "vmf"
          ],
          "line": 1257
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_filemap_fault",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/addr.c",
          "lines": "1226-1304",
          "snippet": "static int ceph_filemap_fault(struct vm_area_struct *vma, struct vm_fault *vmf)\n{\n\tstruct inode *inode = file_inode(vma->vm_file);\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tstruct ceph_file_info *fi = vma->vm_file->private_data;\n\tstruct page *pinned_page = NULL;\n\tloff_t off = vmf->pgoff << PAGE_CACHE_SHIFT;\n\tint want, got, ret;\n\n\tdout(\"filemap_fault %p %llx.%llx %llu~%zd trying to get caps\\n\",\n\t     inode, ceph_vinop(inode), off, (size_t)PAGE_CACHE_SIZE);\n\tif (fi->fmode & CEPH_FILE_MODE_LAZY)\n\t\twant = CEPH_CAP_FILE_CACHE | CEPH_CAP_FILE_LAZYIO;\n\telse\n\t\twant = CEPH_CAP_FILE_CACHE;\n\twhile (1) {\n\t\tgot = 0;\n\t\tret = ceph_get_caps(ci, CEPH_CAP_FILE_RD, want,\n\t\t\t\t    -1, &got, &pinned_page);\n\t\tif (ret == 0)\n\t\t\tbreak;\n\t\tif (ret != -ERESTARTSYS) {\n\t\t\tWARN_ON(1);\n\t\t\treturn VM_FAULT_SIGBUS;\n\t\t}\n\t}\n\tdout(\"filemap_fault %p %llu~%zd got cap refs on %s\\n\",\n\t     inode, off, (size_t)PAGE_CACHE_SIZE, ceph_cap_string(got));\n\n\tif ((got & (CEPH_CAP_FILE_CACHE | CEPH_CAP_FILE_LAZYIO)) ||\n\t    ci->i_inline_version == CEPH_INLINE_NONE)\n\t\tret = filemap_fault(vma, vmf);\n\telse\n\t\tret = -EAGAIN;\n\n\tdout(\"filemap_fault %p %llu~%zd dropping cap refs on %s ret %d\\n\",\n\t     inode, off, (size_t)PAGE_CACHE_SIZE, ceph_cap_string(got), ret);\n\tif (pinned_page)\n\t\tpage_cache_release(pinned_page);\n\tceph_put_cap_refs(ci, got);\n\n\tif (ret != -EAGAIN)\n\t\treturn ret;\n\n\t/* read inline data */\n\tif (off >= PAGE_CACHE_SIZE) {\n\t\t/* does not support inline data > PAGE_SIZE */\n\t\tret = VM_FAULT_SIGBUS;\n\t} else {\n\t\tint ret1;\n\t\tstruct address_space *mapping = inode->i_mapping;\n\t\tstruct page *page = find_or_create_page(mapping, 0,\n\t\t\t\t\t\tmapping_gfp_mask(mapping) &\n\t\t\t\t\t\t~__GFP_FS);\n\t\tif (!page) {\n\t\t\tret = VM_FAULT_OOM;\n\t\t\tgoto out;\n\t\t}\n\t\tret1 = __ceph_do_getattr(inode, page,\n\t\t\t\t\t CEPH_STAT_CAP_INLINE_DATA, true);\n\t\tif (ret1 < 0 || off >= i_size_read(inode)) {\n\t\t\tunlock_page(page);\n\t\t\tpage_cache_release(page);\n\t\t\tret = VM_FAULT_SIGBUS;\n\t\t\tgoto out;\n\t\t}\n\t\tif (ret1 < PAGE_CACHE_SIZE)\n\t\t\tzero_user_segment(page, ret1, PAGE_CACHE_SIZE);\n\t\telse\n\t\t\tflush_dcache_page(page);\n\t\tSetPageUptodate(page);\n\t\tvmf->page = page;\n\t\tret = VM_FAULT_MAJOR | VM_FAULT_LOCKED;\n\t}\nout:\n\tdout(\"filemap_fault %p %llu~%zd read inline data ret %d\\n\",\n\t     inode, off, (size_t)PAGE_CACHE_SIZE, ret);\n\treturn ret;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"filemap_fault %p %llu~%zd got cap refs on %s\\n\"",
            "inode",
            "off",
            "(size_t)PAGE_CACHE_SIZE",
            "ceph_cap_string(got)"
          ],
          "line": 1252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "1"
          ],
          "line": 1248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_get_caps",
          "args": [
            "ci",
            "CEPH_CAP_FILE_RD",
            "want",
            "-1",
            "&got",
            "&pinned_page"
          ],
          "line": 1243
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_get_caps",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
          "lines": "2203-2252",
          "snippet": "int ceph_get_caps(struct ceph_inode_info *ci, int need, int want,\n\t\t  loff_t endoff, int *got, struct page **pinned_page)\n{\n\tint _got, check_max, ret, err = 0;\n\nretry:\n\tif (endoff > 0)\n\t\tcheck_max_size(&ci->vfs_inode, endoff);\n\t_got = 0;\n\tcheck_max = 0;\n\tret = wait_event_interruptible(ci->i_cap_wq,\n\t\t\t\ttry_get_cap_refs(ci, need, want, endoff,\n\t\t\t\t\t\t &_got, &check_max, &err));\n\tif (err)\n\t\tret = err;\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (check_max)\n\t\tgoto retry;\n\n\tif (ci->i_inline_version != CEPH_INLINE_NONE &&\n\t    (_got & (CEPH_CAP_FILE_CACHE|CEPH_CAP_FILE_LAZYIO)) &&\n\t    i_size_read(&ci->vfs_inode) > 0) {\n\t\tstruct page *page = find_get_page(ci->vfs_inode.i_mapping, 0);\n\t\tif (page) {\n\t\t\tif (PageUptodate(page)) {\n\t\t\t\t*pinned_page = page;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tpage_cache_release(page);\n\t\t}\n\t\t/*\n\t\t * drop cap refs first because getattr while holding\n\t\t * caps refs can cause deadlock.\n\t\t */\n\t\tceph_put_cap_refs(ci, _got);\n\t\t_got = 0;\n\n\t\t/* getattr request will bring inline data into page cache */\n\t\tret = __ceph_do_getattr(&ci->vfs_inode, NULL,\n\t\t\t\t\tCEPH_STAT_CAP_INLINE_DATA, true);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tgoto retry;\n\t}\nout:\n\t*got = _got;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nint ceph_get_caps(struct ceph_inode_info *ci, int need, int want,\n\t\t  loff_t endoff, int *got, struct page **pinned_page)\n{\n\tint _got, check_max, ret, err = 0;\n\nretry:\n\tif (endoff > 0)\n\t\tcheck_max_size(&ci->vfs_inode, endoff);\n\t_got = 0;\n\tcheck_max = 0;\n\tret = wait_event_interruptible(ci->i_cap_wq,\n\t\t\t\ttry_get_cap_refs(ci, need, want, endoff,\n\t\t\t\t\t\t &_got, &check_max, &err));\n\tif (err)\n\t\tret = err;\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (check_max)\n\t\tgoto retry;\n\n\tif (ci->i_inline_version != CEPH_INLINE_NONE &&\n\t    (_got & (CEPH_CAP_FILE_CACHE|CEPH_CAP_FILE_LAZYIO)) &&\n\t    i_size_read(&ci->vfs_inode) > 0) {\n\t\tstruct page *page = find_get_page(ci->vfs_inode.i_mapping, 0);\n\t\tif (page) {\n\t\t\tif (PageUptodate(page)) {\n\t\t\t\t*pinned_page = page;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tpage_cache_release(page);\n\t\t}\n\t\t/*\n\t\t * drop cap refs first because getattr while holding\n\t\t * caps refs can cause deadlock.\n\t\t */\n\t\tceph_put_cap_refs(ci, _got);\n\t\t_got = 0;\n\n\t\t/* getattr request will bring inline data into page cache */\n\t\tret = __ceph_do_getattr(&ci->vfs_inode, NULL,\n\t\t\t\t\tCEPH_STAT_CAP_INLINE_DATA, true);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tgoto retry;\n\t}\nout:\n\t*got = _got;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"filemap_fault %p %llx.%llx %llu~%zd trying to get caps\\n\"",
            "inode",
            "ceph_vinop(inode)",
            "off",
            "(size_t)PAGE_CACHE_SIZE"
          ],
          "line": 1235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_vinop",
          "args": [
            "inode"
          ],
          "line": 1236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_inode",
          "args": [
            "inode"
          ],
          "line": 1229
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_inode_to_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.h",
          "lines": "347-350",
          "snippet": "static inline struct ceph_fs_client *ceph_inode_to_client(struct inode *inode)\n{\n\treturn (struct ceph_fs_client *)inode->i_sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/ceph/libceph.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/backing-dev.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/ceph/libceph.h>\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n#include <linux/completion.h>\n#include <linux/backing-dev.h>\n#include <asm/unaligned.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline struct ceph_fs_client *ceph_inode_to_client(struct inode *inode)\n{\n\treturn (struct ceph_fs_client *)inode->i_sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "vma->vm_file"
          ],
          "line": 1228
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/ceph/osd_client.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/task_io_accounting_ops.h>\n#include <linux/pagevec.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\t/* generic_writepages */\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/backing-dev.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic int ceph_filemap_fault(struct vm_area_struct *vma, struct vm_fault *vmf)\n{\n\tstruct inode *inode = file_inode(vma->vm_file);\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tstruct ceph_file_info *fi = vma->vm_file->private_data;\n\tstruct page *pinned_page = NULL;\n\tloff_t off = vmf->pgoff << PAGE_CACHE_SHIFT;\n\tint want, got, ret;\n\n\tdout(\"filemap_fault %p %llx.%llx %llu~%zd trying to get caps\\n\",\n\t     inode, ceph_vinop(inode), off, (size_t)PAGE_CACHE_SIZE);\n\tif (fi->fmode & CEPH_FILE_MODE_LAZY)\n\t\twant = CEPH_CAP_FILE_CACHE | CEPH_CAP_FILE_LAZYIO;\n\telse\n\t\twant = CEPH_CAP_FILE_CACHE;\n\twhile (1) {\n\t\tgot = 0;\n\t\tret = ceph_get_caps(ci, CEPH_CAP_FILE_RD, want,\n\t\t\t\t    -1, &got, &pinned_page);\n\t\tif (ret == 0)\n\t\t\tbreak;\n\t\tif (ret != -ERESTARTSYS) {\n\t\t\tWARN_ON(1);\n\t\t\treturn VM_FAULT_SIGBUS;\n\t\t}\n\t}\n\tdout(\"filemap_fault %p %llu~%zd got cap refs on %s\\n\",\n\t     inode, off, (size_t)PAGE_CACHE_SIZE, ceph_cap_string(got));\n\n\tif ((got & (CEPH_CAP_FILE_CACHE | CEPH_CAP_FILE_LAZYIO)) ||\n\t    ci->i_inline_version == CEPH_INLINE_NONE)\n\t\tret = filemap_fault(vma, vmf);\n\telse\n\t\tret = -EAGAIN;\n\n\tdout(\"filemap_fault %p %llu~%zd dropping cap refs on %s ret %d\\n\",\n\t     inode, off, (size_t)PAGE_CACHE_SIZE, ceph_cap_string(got), ret);\n\tif (pinned_page)\n\t\tpage_cache_release(pinned_page);\n\tceph_put_cap_refs(ci, got);\n\n\tif (ret != -EAGAIN)\n\t\treturn ret;\n\n\t/* read inline data */\n\tif (off >= PAGE_CACHE_SIZE) {\n\t\t/* does not support inline data > PAGE_SIZE */\n\t\tret = VM_FAULT_SIGBUS;\n\t} else {\n\t\tint ret1;\n\t\tstruct address_space *mapping = inode->i_mapping;\n\t\tstruct page *page = find_or_create_page(mapping, 0,\n\t\t\t\t\t\tmapping_gfp_mask(mapping) &\n\t\t\t\t\t\t~__GFP_FS);\n\t\tif (!page) {\n\t\t\tret = VM_FAULT_OOM;\n\t\t\tgoto out;\n\t\t}\n\t\tret1 = __ceph_do_getattr(inode, page,\n\t\t\t\t\t CEPH_STAT_CAP_INLINE_DATA, true);\n\t\tif (ret1 < 0 || off >= i_size_read(inode)) {\n\t\t\tunlock_page(page);\n\t\t\tpage_cache_release(page);\n\t\t\tret = VM_FAULT_SIGBUS;\n\t\t\tgoto out;\n\t\t}\n\t\tif (ret1 < PAGE_CACHE_SIZE)\n\t\t\tzero_user_segment(page, ret1, PAGE_CACHE_SIZE);\n\t\telse\n\t\t\tflush_dcache_page(page);\n\t\tSetPageUptodate(page);\n\t\tvmf->page = page;\n\t\tret = VM_FAULT_MAJOR | VM_FAULT_LOCKED;\n\t}\nout:\n\tdout(\"filemap_fault %p %llu~%zd read inline data ret %d\\n\",\n\t     inode, off, (size_t)PAGE_CACHE_SIZE, ret);\n\treturn ret;\n}"
  },
  {
    "function_name": "ceph_direct_io",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/addr.c",
    "lines": "1201-1207",
    "snippet": "static ssize_t ceph_direct_io(int rw, struct kiocb *iocb,\n\t\t\t      struct iov_iter *iter,\n\t\t\t      loff_t pos)\n{\n\tWARN_ON(1);\n\treturn -EINVAL;\n}",
    "includes": [
      "#include <linux/ceph/osd_client.h>",
      "#include \"cache.h\"",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/slab.h>",
      "#include <linux/writeback.h>\t/* generic_writepages */",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "1"
          ],
          "line": 1205
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/ceph/osd_client.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/task_io_accounting_ops.h>\n#include <linux/pagevec.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\t/* generic_writepages */\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/backing-dev.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic ssize_t ceph_direct_io(int rw, struct kiocb *iocb,\n\t\t\t      struct iov_iter *iter,\n\t\t\t      loff_t pos)\n{\n\tWARN_ON(1);\n\treturn -EINVAL;\n}"
  },
  {
    "function_name": "ceph_write_end",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/addr.c",
    "lines": "1159-1194",
    "snippet": "static int ceph_write_end(struct file *file, struct address_space *mapping,\n\t\t\t  loff_t pos, unsigned len, unsigned copied,\n\t\t\t  struct page *page, void *fsdata)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct ceph_fs_client *fsc = ceph_inode_to_client(inode);\n\tstruct ceph_mds_client *mdsc = fsc->mdsc;\n\tunsigned from = pos & (PAGE_CACHE_SIZE - 1);\n\tint check_cap = 0;\n\n\tdout(\"write_end file %p inode %p page %p %d~%d (%d)\\n\", file,\n\t     inode, page, (int)pos, (int)copied, (int)len);\n\n\t/* zero the stale part of the page if we did a short copy */\n\tif (copied < len)\n\t\tzero_user_segment(page, from+copied, len);\n\n\t/* did file size increase? */\n\t/* (no need for i_size_read(); we caller holds i_mutex */\n\tif (pos+copied > inode->i_size)\n\t\tcheck_cap = ceph_inode_set_size(inode, pos+copied);\n\n\tif (!PageUptodate(page))\n\t\tSetPageUptodate(page);\n\n\tset_page_dirty(page);\n\n\tunlock_page(page);\n\tup_read(&mdsc->snap_rwsem);\n\tpage_cache_release(page);\n\n\tif (check_cap)\n\t\tceph_check_caps(ceph_inode(inode), CHECK_CAPS_AUTHONLY, NULL);\n\n\treturn copied;\n}",
    "includes": [
      "#include <linux/ceph/osd_client.h>",
      "#include \"cache.h\"",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/slab.h>",
      "#include <linux/writeback.h>\t/* generic_writepages */",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ceph_check_caps",
          "args": [
            "ceph_inode(inode)",
            "CHECK_CAPS_AUTHONLY",
            "NULL"
          ],
          "line": 1191
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_check_caps",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
          "lines": "1504-1751",
          "snippet": "void ceph_check_caps(struct ceph_inode_info *ci, int flags,\n\t\t     struct ceph_mds_session *session)\n{\n\tstruct ceph_fs_client *fsc = ceph_inode_to_client(&ci->vfs_inode);\n\tstruct ceph_mds_client *mdsc = fsc->mdsc;\n\tstruct inode *inode = &ci->vfs_inode;\n\tstruct ceph_cap *cap;\n\tint file_wanted, used, cap_used;\n\tint took_snap_rwsem = 0;             /* true if mdsc->snap_rwsem held */\n\tint issued, implemented, want, retain, revoking, flushing = 0;\n\tint mds = -1;   /* keep track of how far we've gone through i_caps list\n\t\t\t   to avoid an infinite loop on retry */\n\tstruct rb_node *p;\n\tint tried_invalidate = 0;\n\tint delayed = 0, sent = 0, force_requeue = 0, num;\n\tint queue_invalidate = 0;\n\tint is_delayed = flags & CHECK_CAPS_NODELAY;\n\n\t/* if we are unmounting, flush any unused caps immediately. */\n\tif (mdsc->stopping)\n\t\tis_delayed = 1;\n\n\tspin_lock(&ci->i_ceph_lock);\n\n\tif (ci->i_ceph_flags & CEPH_I_FLUSH)\n\t\tflags |= CHECK_CAPS_FLUSH;\n\n\t/* flush snaps first time around only */\n\tif (!list_empty(&ci->i_cap_snaps))\n\t\t__ceph_flush_snaps(ci, &session, 0);\n\tgoto retry_locked;\nretry:\n\tspin_lock(&ci->i_ceph_lock);\nretry_locked:\n\tfile_wanted = __ceph_caps_file_wanted(ci);\n\tused = __ceph_caps_used(ci);\n\twant = file_wanted | used;\n\tissued = __ceph_caps_issued(ci, &implemented);\n\trevoking = implemented & ~issued;\n\n\tretain = want | CEPH_CAP_PIN;\n\tif (!mdsc->stopping && inode->i_nlink > 0) {\n\t\tif (want) {\n\t\t\tretain |= CEPH_CAP_ANY;       /* be greedy */\n\t\t} else {\n\t\t\tretain |= CEPH_CAP_ANY_SHARED;\n\t\t\t/*\n\t\t\t * keep RD only if we didn't have the file open RW,\n\t\t\t * because then the mds would revoke it anyway to\n\t\t\t * journal max_size=0.\n\t\t\t */\n\t\t\tif (ci->i_max_size == 0)\n\t\t\t\tretain |= CEPH_CAP_ANY_RD;\n\t\t}\n\t}\n\n\tdout(\"check_caps %p file_want %s used %s dirty %s flushing %s\"\n\t     \" issued %s revoking %s retain %s %s%s%s\\n\", inode,\n\t     ceph_cap_string(file_wanted),\n\t     ceph_cap_string(used), ceph_cap_string(ci->i_dirty_caps),\n\t     ceph_cap_string(ci->i_flushing_caps),\n\t     ceph_cap_string(issued), ceph_cap_string(revoking),\n\t     ceph_cap_string(retain),\n\t     (flags & CHECK_CAPS_AUTHONLY) ? \" AUTHONLY\" : \"\",\n\t     (flags & CHECK_CAPS_NODELAY) ? \" NODELAY\" : \"\",\n\t     (flags & CHECK_CAPS_FLUSH) ? \" FLUSH\" : \"\");\n\n\t/*\n\t * If we no longer need to hold onto old our caps, and we may\n\t * have cached pages, but don't want them, then try to invalidate.\n\t * If we fail, it's because pages are locked.... try again later.\n\t */\n\tif ((!is_delayed || mdsc->stopping) &&\n\t    ci->i_wrbuffer_ref == 0 &&               /* no dirty pages... */\n\t    inode->i_data.nrpages &&                 /* have cached pages */\n\t    (file_wanted == 0 ||                     /* no open files */\n\t     (revoking & (CEPH_CAP_FILE_CACHE|\n\t\t\t  CEPH_CAP_FILE_LAZYIO))) && /*  or revoking cache */\n\t    !tried_invalidate) {\n\t\tdout(\"check_caps trying to invalidate on %p\\n\", inode);\n\t\tif (try_nonblocking_invalidate(inode) < 0) {\n\t\t\tif (revoking & (CEPH_CAP_FILE_CACHE|\n\t\t\t\t\tCEPH_CAP_FILE_LAZYIO)) {\n\t\t\t\tdout(\"check_caps queuing invalidate\\n\");\n\t\t\t\tqueue_invalidate = 1;\n\t\t\t\tci->i_rdcache_revoking = ci->i_rdcache_gen;\n\t\t\t} else {\n\t\t\t\tdout(\"check_caps failed to invalidate pages\\n\");\n\t\t\t\t/* we failed to invalidate pages.  check these\n\t\t\t\t   caps again later. */\n\t\t\t\tforce_requeue = 1;\n\t\t\t\t__cap_set_timeouts(mdsc, ci);\n\t\t\t}\n\t\t}\n\t\ttried_invalidate = 1;\n\t\tgoto retry_locked;\n\t}\n\n\tnum = 0;\n\tfor (p = rb_first(&ci->i_caps); p; p = rb_next(p)) {\n\t\tcap = rb_entry(p, struct ceph_cap, ci_node);\n\t\tnum++;\n\n\t\t/* avoid looping forever */\n\t\tif (mds >= cap->mds ||\n\t\t    ((flags & CHECK_CAPS_AUTHONLY) && cap != ci->i_auth_cap))\n\t\t\tcontinue;\n\n\t\t/* NOTE: no side-effects allowed, until we take s_mutex */\n\n\t\tcap_used = used;\n\t\tif (ci->i_auth_cap && cap != ci->i_auth_cap)\n\t\t\tcap_used &= ~ci->i_auth_cap->issued;\n\n\t\trevoking = cap->implemented & ~cap->issued;\n\t\tdout(\" mds%d cap %p used %s issued %s implemented %s revoking %s\\n\",\n\t\t     cap->mds, cap, ceph_cap_string(cap->issued),\n\t\t     ceph_cap_string(cap_used),\n\t\t     ceph_cap_string(cap->implemented),\n\t\t     ceph_cap_string(revoking));\n\n\t\tif (cap == ci->i_auth_cap &&\n\t\t    (cap->issued & CEPH_CAP_FILE_WR)) {\n\t\t\t/* request larger max_size from MDS? */\n\t\t\tif (ci->i_wanted_max_size > ci->i_max_size &&\n\t\t\t    ci->i_wanted_max_size > ci->i_requested_max_size) {\n\t\t\t\tdout(\"requesting new max_size\\n\");\n\t\t\t\tgoto ack;\n\t\t\t}\n\n\t\t\t/* approaching file_max? */\n\t\t\tif ((inode->i_size << 1) >= ci->i_max_size &&\n\t\t\t    (ci->i_reported_size << 1) < ci->i_max_size) {\n\t\t\t\tdout(\"i_size approaching max_size\\n\");\n\t\t\t\tgoto ack;\n\t\t\t}\n\t\t}\n\t\t/* flush anything dirty? */\n\t\tif (cap == ci->i_auth_cap && (flags & CHECK_CAPS_FLUSH) &&\n\t\t    ci->i_dirty_caps) {\n\t\t\tdout(\"flushing dirty caps\\n\");\n\t\t\tgoto ack;\n\t\t}\n\n\t\t/* completed revocation? going down and there are no caps? */\n\t\tif (revoking && (revoking & cap_used) == 0) {\n\t\t\tdout(\"completed revocation of %s\\n\",\n\t\t\t     ceph_cap_string(cap->implemented & ~cap->issued));\n\t\t\tgoto ack;\n\t\t}\n\n\t\t/* want more caps from mds? */\n\t\tif (want & ~(cap->mds_wanted | cap->issued))\n\t\t\tgoto ack;\n\n\t\t/* things we might delay */\n\t\tif ((cap->issued & ~retain) == 0 &&\n\t\t    cap->mds_wanted == want)\n\t\t\tcontinue;     /* nope, all good */\n\n\t\tif (is_delayed)\n\t\t\tgoto ack;\n\n\t\t/* delay? */\n\t\tif ((ci->i_ceph_flags & CEPH_I_NODELAY) == 0 &&\n\t\t    time_before(jiffies, ci->i_hold_caps_max)) {\n\t\t\tdout(\" delaying issued %s -> %s, wanted %s -> %s\\n\",\n\t\t\t     ceph_cap_string(cap->issued),\n\t\t\t     ceph_cap_string(cap->issued & retain),\n\t\t\t     ceph_cap_string(cap->mds_wanted),\n\t\t\t     ceph_cap_string(want));\n\t\t\tdelayed++;\n\t\t\tcontinue;\n\t\t}\n\nack:\n\t\tif (ci->i_ceph_flags & CEPH_I_NOFLUSH) {\n\t\t\tdout(\" skipping %p I_NOFLUSH set\\n\", inode);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (session && session != cap->session) {\n\t\t\tdout(\"oops, wrong session %p mutex\\n\", session);\n\t\t\tmutex_unlock(&session->s_mutex);\n\t\t\tsession = NULL;\n\t\t}\n\t\tif (!session) {\n\t\t\tsession = cap->session;\n\t\t\tif (mutex_trylock(&session->s_mutex) == 0) {\n\t\t\t\tdout(\"inverting session/ino locks on %p\\n\",\n\t\t\t\t     session);\n\t\t\t\tspin_unlock(&ci->i_ceph_lock);\n\t\t\t\tif (took_snap_rwsem) {\n\t\t\t\t\tup_read(&mdsc->snap_rwsem);\n\t\t\t\t\ttook_snap_rwsem = 0;\n\t\t\t\t}\n\t\t\t\tmutex_lock(&session->s_mutex);\n\t\t\t\tgoto retry;\n\t\t\t}\n\t\t}\n\t\t/* take snap_rwsem after session mutex */\n\t\tif (!took_snap_rwsem) {\n\t\t\tif (down_read_trylock(&mdsc->snap_rwsem) == 0) {\n\t\t\t\tdout(\"inverting snap/in locks on %p\\n\",\n\t\t\t\t     inode);\n\t\t\t\tspin_unlock(&ci->i_ceph_lock);\n\t\t\t\tdown_read(&mdsc->snap_rwsem);\n\t\t\t\ttook_snap_rwsem = 1;\n\t\t\t\tgoto retry;\n\t\t\t}\n\t\t\ttook_snap_rwsem = 1;\n\t\t}\n\n\t\tif (cap == ci->i_auth_cap && ci->i_dirty_caps)\n\t\t\tflushing = __mark_caps_flushing(inode, session);\n\t\telse\n\t\t\tflushing = 0;\n\n\t\tmds = cap->mds;  /* remember mds, so we don't repeat */\n\t\tsent++;\n\n\t\t/* __send_cap drops i_ceph_lock */\n\t\tdelayed += __send_cap(mdsc, cap, CEPH_CAP_OP_UPDATE, cap_used,\n\t\t\t\t      want, retain, flushing, NULL);\n\t\tgoto retry; /* retake i_ceph_lock and restart our cap scan. */\n\t}\n\n\t/*\n\t * Reschedule delayed caps release if we delayed anything,\n\t * otherwise cancel.\n\t */\n\tif (delayed && is_delayed)\n\t\tforce_requeue = 1;   /* __send_cap delayed release; requeue */\n\tif (!delayed && !is_delayed)\n\t\t__cap_delay_cancel(mdsc, ci);\n\telse if (!is_delayed || force_requeue)\n\t\t__cap_delay_requeue(mdsc, ci);\n\n\tspin_unlock(&ci->i_ceph_lock);\n\n\tif (queue_invalidate)\n\t\tceph_queue_invalidate(inode);\n\n\tif (session)\n\t\tmutex_unlock(&session->s_mutex);\n\tif (took_snap_rwsem)\n\t\tup_read(&mdsc->snap_rwsem);\n}",
          "includes": [
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nvoid ceph_check_caps(struct ceph_inode_info *ci, int flags,\n\t\t     struct ceph_mds_session *session)\n{\n\tstruct ceph_fs_client *fsc = ceph_inode_to_client(&ci->vfs_inode);\n\tstruct ceph_mds_client *mdsc = fsc->mdsc;\n\tstruct inode *inode = &ci->vfs_inode;\n\tstruct ceph_cap *cap;\n\tint file_wanted, used, cap_used;\n\tint took_snap_rwsem = 0;             /* true if mdsc->snap_rwsem held */\n\tint issued, implemented, want, retain, revoking, flushing = 0;\n\tint mds = -1;   /* keep track of how far we've gone through i_caps list\n\t\t\t   to avoid an infinite loop on retry */\n\tstruct rb_node *p;\n\tint tried_invalidate = 0;\n\tint delayed = 0, sent = 0, force_requeue = 0, num;\n\tint queue_invalidate = 0;\n\tint is_delayed = flags & CHECK_CAPS_NODELAY;\n\n\t/* if we are unmounting, flush any unused caps immediately. */\n\tif (mdsc->stopping)\n\t\tis_delayed = 1;\n\n\tspin_lock(&ci->i_ceph_lock);\n\n\tif (ci->i_ceph_flags & CEPH_I_FLUSH)\n\t\tflags |= CHECK_CAPS_FLUSH;\n\n\t/* flush snaps first time around only */\n\tif (!list_empty(&ci->i_cap_snaps))\n\t\t__ceph_flush_snaps(ci, &session, 0);\n\tgoto retry_locked;\nretry:\n\tspin_lock(&ci->i_ceph_lock);\nretry_locked:\n\tfile_wanted = __ceph_caps_file_wanted(ci);\n\tused = __ceph_caps_used(ci);\n\twant = file_wanted | used;\n\tissued = __ceph_caps_issued(ci, &implemented);\n\trevoking = implemented & ~issued;\n\n\tretain = want | CEPH_CAP_PIN;\n\tif (!mdsc->stopping && inode->i_nlink > 0) {\n\t\tif (want) {\n\t\t\tretain |= CEPH_CAP_ANY;       /* be greedy */\n\t\t} else {\n\t\t\tretain |= CEPH_CAP_ANY_SHARED;\n\t\t\t/*\n\t\t\t * keep RD only if we didn't have the file open RW,\n\t\t\t * because then the mds would revoke it anyway to\n\t\t\t * journal max_size=0.\n\t\t\t */\n\t\t\tif (ci->i_max_size == 0)\n\t\t\t\tretain |= CEPH_CAP_ANY_RD;\n\t\t}\n\t}\n\n\tdout(\"check_caps %p file_want %s used %s dirty %s flushing %s\"\n\t     \" issued %s revoking %s retain %s %s%s%s\\n\", inode,\n\t     ceph_cap_string(file_wanted),\n\t     ceph_cap_string(used), ceph_cap_string(ci->i_dirty_caps),\n\t     ceph_cap_string(ci->i_flushing_caps),\n\t     ceph_cap_string(issued), ceph_cap_string(revoking),\n\t     ceph_cap_string(retain),\n\t     (flags & CHECK_CAPS_AUTHONLY) ? \" AUTHONLY\" : \"\",\n\t     (flags & CHECK_CAPS_NODELAY) ? \" NODELAY\" : \"\",\n\t     (flags & CHECK_CAPS_FLUSH) ? \" FLUSH\" : \"\");\n\n\t/*\n\t * If we no longer need to hold onto old our caps, and we may\n\t * have cached pages, but don't want them, then try to invalidate.\n\t * If we fail, it's because pages are locked.... try again later.\n\t */\n\tif ((!is_delayed || mdsc->stopping) &&\n\t    ci->i_wrbuffer_ref == 0 &&               /* no dirty pages... */\n\t    inode->i_data.nrpages &&                 /* have cached pages */\n\t    (file_wanted == 0 ||                     /* no open files */\n\t     (revoking & (CEPH_CAP_FILE_CACHE|\n\t\t\t  CEPH_CAP_FILE_LAZYIO))) && /*  or revoking cache */\n\t    !tried_invalidate) {\n\t\tdout(\"check_caps trying to invalidate on %p\\n\", inode);\n\t\tif (try_nonblocking_invalidate(inode) < 0) {\n\t\t\tif (revoking & (CEPH_CAP_FILE_CACHE|\n\t\t\t\t\tCEPH_CAP_FILE_LAZYIO)) {\n\t\t\t\tdout(\"check_caps queuing invalidate\\n\");\n\t\t\t\tqueue_invalidate = 1;\n\t\t\t\tci->i_rdcache_revoking = ci->i_rdcache_gen;\n\t\t\t} else {\n\t\t\t\tdout(\"check_caps failed to invalidate pages\\n\");\n\t\t\t\t/* we failed to invalidate pages.  check these\n\t\t\t\t   caps again later. */\n\t\t\t\tforce_requeue = 1;\n\t\t\t\t__cap_set_timeouts(mdsc, ci);\n\t\t\t}\n\t\t}\n\t\ttried_invalidate = 1;\n\t\tgoto retry_locked;\n\t}\n\n\tnum = 0;\n\tfor (p = rb_first(&ci->i_caps); p; p = rb_next(p)) {\n\t\tcap = rb_entry(p, struct ceph_cap, ci_node);\n\t\tnum++;\n\n\t\t/* avoid looping forever */\n\t\tif (mds >= cap->mds ||\n\t\t    ((flags & CHECK_CAPS_AUTHONLY) && cap != ci->i_auth_cap))\n\t\t\tcontinue;\n\n\t\t/* NOTE: no side-effects allowed, until we take s_mutex */\n\n\t\tcap_used = used;\n\t\tif (ci->i_auth_cap && cap != ci->i_auth_cap)\n\t\t\tcap_used &= ~ci->i_auth_cap->issued;\n\n\t\trevoking = cap->implemented & ~cap->issued;\n\t\tdout(\" mds%d cap %p used %s issued %s implemented %s revoking %s\\n\",\n\t\t     cap->mds, cap, ceph_cap_string(cap->issued),\n\t\t     ceph_cap_string(cap_used),\n\t\t     ceph_cap_string(cap->implemented),\n\t\t     ceph_cap_string(revoking));\n\n\t\tif (cap == ci->i_auth_cap &&\n\t\t    (cap->issued & CEPH_CAP_FILE_WR)) {\n\t\t\t/* request larger max_size from MDS? */\n\t\t\tif (ci->i_wanted_max_size > ci->i_max_size &&\n\t\t\t    ci->i_wanted_max_size > ci->i_requested_max_size) {\n\t\t\t\tdout(\"requesting new max_size\\n\");\n\t\t\t\tgoto ack;\n\t\t\t}\n\n\t\t\t/* approaching file_max? */\n\t\t\tif ((inode->i_size << 1) >= ci->i_max_size &&\n\t\t\t    (ci->i_reported_size << 1) < ci->i_max_size) {\n\t\t\t\tdout(\"i_size approaching max_size\\n\");\n\t\t\t\tgoto ack;\n\t\t\t}\n\t\t}\n\t\t/* flush anything dirty? */\n\t\tif (cap == ci->i_auth_cap && (flags & CHECK_CAPS_FLUSH) &&\n\t\t    ci->i_dirty_caps) {\n\t\t\tdout(\"flushing dirty caps\\n\");\n\t\t\tgoto ack;\n\t\t}\n\n\t\t/* completed revocation? going down and there are no caps? */\n\t\tif (revoking && (revoking & cap_used) == 0) {\n\t\t\tdout(\"completed revocation of %s\\n\",\n\t\t\t     ceph_cap_string(cap->implemented & ~cap->issued));\n\t\t\tgoto ack;\n\t\t}\n\n\t\t/* want more caps from mds? */\n\t\tif (want & ~(cap->mds_wanted | cap->issued))\n\t\t\tgoto ack;\n\n\t\t/* things we might delay */\n\t\tif ((cap->issued & ~retain) == 0 &&\n\t\t    cap->mds_wanted == want)\n\t\t\tcontinue;     /* nope, all good */\n\n\t\tif (is_delayed)\n\t\t\tgoto ack;\n\n\t\t/* delay? */\n\t\tif ((ci->i_ceph_flags & CEPH_I_NODELAY) == 0 &&\n\t\t    time_before(jiffies, ci->i_hold_caps_max)) {\n\t\t\tdout(\" delaying issued %s -> %s, wanted %s -> %s\\n\",\n\t\t\t     ceph_cap_string(cap->issued),\n\t\t\t     ceph_cap_string(cap->issued & retain),\n\t\t\t     ceph_cap_string(cap->mds_wanted),\n\t\t\t     ceph_cap_string(want));\n\t\t\tdelayed++;\n\t\t\tcontinue;\n\t\t}\n\nack:\n\t\tif (ci->i_ceph_flags & CEPH_I_NOFLUSH) {\n\t\t\tdout(\" skipping %p I_NOFLUSH set\\n\", inode);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (session && session != cap->session) {\n\t\t\tdout(\"oops, wrong session %p mutex\\n\", session);\n\t\t\tmutex_unlock(&session->s_mutex);\n\t\t\tsession = NULL;\n\t\t}\n\t\tif (!session) {\n\t\t\tsession = cap->session;\n\t\t\tif (mutex_trylock(&session->s_mutex) == 0) {\n\t\t\t\tdout(\"inverting session/ino locks on %p\\n\",\n\t\t\t\t     session);\n\t\t\t\tspin_unlock(&ci->i_ceph_lock);\n\t\t\t\tif (took_snap_rwsem) {\n\t\t\t\t\tup_read(&mdsc->snap_rwsem);\n\t\t\t\t\ttook_snap_rwsem = 0;\n\t\t\t\t}\n\t\t\t\tmutex_lock(&session->s_mutex);\n\t\t\t\tgoto retry;\n\t\t\t}\n\t\t}\n\t\t/* take snap_rwsem after session mutex */\n\t\tif (!took_snap_rwsem) {\n\t\t\tif (down_read_trylock(&mdsc->snap_rwsem) == 0) {\n\t\t\t\tdout(\"inverting snap/in locks on %p\\n\",\n\t\t\t\t     inode);\n\t\t\t\tspin_unlock(&ci->i_ceph_lock);\n\t\t\t\tdown_read(&mdsc->snap_rwsem);\n\t\t\t\ttook_snap_rwsem = 1;\n\t\t\t\tgoto retry;\n\t\t\t}\n\t\t\ttook_snap_rwsem = 1;\n\t\t}\n\n\t\tif (cap == ci->i_auth_cap && ci->i_dirty_caps)\n\t\t\tflushing = __mark_caps_flushing(inode, session);\n\t\telse\n\t\t\tflushing = 0;\n\n\t\tmds = cap->mds;  /* remember mds, so we don't repeat */\n\t\tsent++;\n\n\t\t/* __send_cap drops i_ceph_lock */\n\t\tdelayed += __send_cap(mdsc, cap, CEPH_CAP_OP_UPDATE, cap_used,\n\t\t\t\t      want, retain, flushing, NULL);\n\t\tgoto retry; /* retake i_ceph_lock and restart our cap scan. */\n\t}\n\n\t/*\n\t * Reschedule delayed caps release if we delayed anything,\n\t * otherwise cancel.\n\t */\n\tif (delayed && is_delayed)\n\t\tforce_requeue = 1;   /* __send_cap delayed release; requeue */\n\tif (!delayed && !is_delayed)\n\t\t__cap_delay_cancel(mdsc, ci);\n\telse if (!is_delayed || force_requeue)\n\t\t__cap_delay_requeue(mdsc, ci);\n\n\tspin_unlock(&ci->i_ceph_lock);\n\n\tif (queue_invalidate)\n\t\tceph_queue_invalidate(inode);\n\n\tif (session)\n\t\tmutex_unlock(&session->s_mutex);\n\tif (took_snap_rwsem)\n\t\tup_read(&mdsc->snap_rwsem);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_inode",
          "args": [
            "inode"
          ],
          "line": 1191
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_inode_to_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.h",
          "lines": "347-350",
          "snippet": "static inline struct ceph_fs_client *ceph_inode_to_client(struct inode *inode)\n{\n\treturn (struct ceph_fs_client *)inode->i_sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/ceph/libceph.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/backing-dev.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/ceph/libceph.h>\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n#include <linux/completion.h>\n#include <linux/backing-dev.h>\n#include <asm/unaligned.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline struct ceph_fs_client *ceph_inode_to_client(struct inode *inode)\n{\n\treturn (struct ceph_fs_client *)inode->i_sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "page"
          ],
          "line": 1188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&mdsc->snap_rwsem"
          ],
          "line": 1187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 1186
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_page_dirty",
          "args": [
            "page"
          ],
          "line": 1184
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_set_page_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/addr.c",
          "lines": "69-125",
          "snippet": "static int ceph_set_page_dirty(struct page *page)\n{\n\tstruct address_space *mapping = page->mapping;\n\tstruct inode *inode;\n\tstruct ceph_inode_info *ci;\n\tstruct ceph_snap_context *snapc;\n\tint ret;\n\n\tif (unlikely(!mapping))\n\t\treturn !TestSetPageDirty(page);\n\n\tif (PageDirty(page)) {\n\t\tdout(\"%p set_page_dirty %p idx %lu -- already dirty\\n\",\n\t\t     mapping->host, page, page->index);\n\t\tBUG_ON(!PagePrivate(page));\n\t\treturn 0;\n\t}\n\n\tinode = mapping->host;\n\tci = ceph_inode(inode);\n\n\t/*\n\t * Note that we're grabbing a snapc ref here without holding\n\t * any locks!\n\t */\n\tsnapc = ceph_get_snap_context(ci->i_snap_realm->cached_context);\n\n\t/* dirty the head */\n\tspin_lock(&ci->i_ceph_lock);\n\tif (ci->i_head_snapc == NULL)\n\t\tci->i_head_snapc = ceph_get_snap_context(snapc);\n\t++ci->i_wrbuffer_ref_head;\n\tif (ci->i_wrbuffer_ref == 0)\n\t\tihold(inode);\n\t++ci->i_wrbuffer_ref;\n\tdout(\"%p set_page_dirty %p idx %lu head %d/%d -> %d/%d \"\n\t     \"snapc %p seq %lld (%d snaps)\\n\",\n\t     mapping->host, page, page->index,\n\t     ci->i_wrbuffer_ref-1, ci->i_wrbuffer_ref_head-1,\n\t     ci->i_wrbuffer_ref, ci->i_wrbuffer_ref_head,\n\t     snapc, snapc->seq, snapc->num_snaps);\n\tspin_unlock(&ci->i_ceph_lock);\n\n\t/*\n\t * Reference snap context in page->private.  Also set\n\t * PagePrivate so that we get invalidatepage callback.\n\t */\n\tBUG_ON(PagePrivate(page));\n\tpage->private = (unsigned long)snapc;\n\tSetPagePrivate(page);\n\n\tret = __set_page_dirty_nobuffers(page);\n\tWARN_ON(!PageLocked(page));\n\tWARN_ON(!page->mapping);\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/ceph/osd_client.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>\t/* generic_writepages */",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/osd_client.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/task_io_accounting_ops.h>\n#include <linux/pagevec.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\t/* generic_writepages */\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/backing-dev.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic int ceph_set_page_dirty(struct page *page)\n{\n\tstruct address_space *mapping = page->mapping;\n\tstruct inode *inode;\n\tstruct ceph_inode_info *ci;\n\tstruct ceph_snap_context *snapc;\n\tint ret;\n\n\tif (unlikely(!mapping))\n\t\treturn !TestSetPageDirty(page);\n\n\tif (PageDirty(page)) {\n\t\tdout(\"%p set_page_dirty %p idx %lu -- already dirty\\n\",\n\t\t     mapping->host, page, page->index);\n\t\tBUG_ON(!PagePrivate(page));\n\t\treturn 0;\n\t}\n\n\tinode = mapping->host;\n\tci = ceph_inode(inode);\n\n\t/*\n\t * Note that we're grabbing a snapc ref here without holding\n\t * any locks!\n\t */\n\tsnapc = ceph_get_snap_context(ci->i_snap_realm->cached_context);\n\n\t/* dirty the head */\n\tspin_lock(&ci->i_ceph_lock);\n\tif (ci->i_head_snapc == NULL)\n\t\tci->i_head_snapc = ceph_get_snap_context(snapc);\n\t++ci->i_wrbuffer_ref_head;\n\tif (ci->i_wrbuffer_ref == 0)\n\t\tihold(inode);\n\t++ci->i_wrbuffer_ref;\n\tdout(\"%p set_page_dirty %p idx %lu head %d/%d -> %d/%d \"\n\t     \"snapc %p seq %lld (%d snaps)\\n\",\n\t     mapping->host, page, page->index,\n\t     ci->i_wrbuffer_ref-1, ci->i_wrbuffer_ref_head-1,\n\t     ci->i_wrbuffer_ref, ci->i_wrbuffer_ref_head,\n\t     snapc, snapc->seq, snapc->num_snaps);\n\tspin_unlock(&ci->i_ceph_lock);\n\n\t/*\n\t * Reference snap context in page->private.  Also set\n\t * PagePrivate so that we get invalidatepage callback.\n\t */\n\tBUG_ON(PagePrivate(page));\n\tpage->private = (unsigned long)snapc;\n\tSetPagePrivate(page);\n\n\tret = __set_page_dirty_nobuffers(page);\n\tWARN_ON(!PageLocked(page));\n\tWARN_ON(!page->mapping);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SetPageUptodate",
          "args": [
            "page"
          ],
          "line": 1182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "page"
          ],
          "line": 1181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_inode_set_size",
          "args": [
            "inode",
            "pos+copied"
          ],
          "line": 1179
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_inode_set_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/inode.c",
          "lines": "1482-1499",
          "snippet": "int ceph_inode_set_size(struct inode *inode, loff_t size)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tint ret = 0;\n\n\tspin_lock(&ci->i_ceph_lock);\n\tdout(\"set_size %p %llu -> %llu\\n\", inode, inode->i_size, size);\n\tinode->i_size = size;\n\tinode->i_blocks = (size + (1 << 9) - 1) >> 9;\n\n\t/* tell the MDS if we are approaching max_size */\n\tif ((size << 1) >= ci->i_max_size &&\n\t    (ci->i_reported_size << 1) < ci->i_max_size)\n\t\tret = 1;\n\n\tspin_unlock(&ci->i_ceph_lock);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/random.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/namei.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/random.h>\n#include <linux/posix_acl.h>\n#include <linux/vmalloc.h>\n#include <linux/writeback.h>\n#include <linux/namei.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/ceph/ceph_debug.h>\n\nint ceph_inode_set_size(struct inode *inode, loff_t size)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tint ret = 0;\n\n\tspin_lock(&ci->i_ceph_lock);\n\tdout(\"set_size %p %llu -> %llu\\n\", inode, inode->i_size, size);\n\tinode->i_size = size;\n\tinode->i_blocks = (size + (1 << 9) - 1) >> 9;\n\n\t/* tell the MDS if we are approaching max_size */\n\tif ((size << 1) >= ci->i_max_size &&\n\t    (ci->i_reported_size << 1) < ci->i_max_size)\n\t\tret = 1;\n\n\tspin_unlock(&ci->i_ceph_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "zero_user_segment",
          "args": [
            "page",
            "from+copied",
            "len"
          ],
          "line": 1174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"write_end file %p inode %p page %p %d~%d (%d)\\n\"",
            "file",
            "inode",
            "page",
            "(int)pos",
            "(int)copied",
            "(int)len"
          ],
          "line": 1169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 1163
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/ceph/osd_client.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/task_io_accounting_ops.h>\n#include <linux/pagevec.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\t/* generic_writepages */\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/backing-dev.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic int ceph_write_end(struct file *file, struct address_space *mapping,\n\t\t\t  loff_t pos, unsigned len, unsigned copied,\n\t\t\t  struct page *page, void *fsdata)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct ceph_fs_client *fsc = ceph_inode_to_client(inode);\n\tstruct ceph_mds_client *mdsc = fsc->mdsc;\n\tunsigned from = pos & (PAGE_CACHE_SIZE - 1);\n\tint check_cap = 0;\n\n\tdout(\"write_end file %p inode %p page %p %d~%d (%d)\\n\", file,\n\t     inode, page, (int)pos, (int)copied, (int)len);\n\n\t/* zero the stale part of the page if we did a short copy */\n\tif (copied < len)\n\t\tzero_user_segment(page, from+copied, len);\n\n\t/* did file size increase? */\n\t/* (no need for i_size_read(); we caller holds i_mutex */\n\tif (pos+copied > inode->i_size)\n\t\tcheck_cap = ceph_inode_set_size(inode, pos+copied);\n\n\tif (!PageUptodate(page))\n\t\tSetPageUptodate(page);\n\n\tset_page_dirty(page);\n\n\tunlock_page(page);\n\tup_read(&mdsc->snap_rwsem);\n\tpage_cache_release(page);\n\n\tif (check_cap)\n\t\tceph_check_caps(ceph_inode(inode), CHECK_CAPS_AUTHONLY, NULL);\n\n\treturn copied;\n}"
  },
  {
    "function_name": "ceph_write_begin",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/addr.c",
    "lines": "1129-1152",
    "snippet": "static int ceph_write_begin(struct file *file, struct address_space *mapping,\n\t\t\t    loff_t pos, unsigned len, unsigned flags,\n\t\t\t    struct page **pagep, void **fsdata)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct page *page;\n\tpgoff_t index = pos >> PAGE_CACHE_SHIFT;\n\tint r;\n\n\tdo {\n\t\t/* get a page */\n\t\tpage = grab_cache_page_write_begin(mapping, index, 0);\n\t\tif (!page)\n\t\t\treturn -ENOMEM;\n\t\t*pagep = page;\n\n\t\tdout(\"write_begin file %p inode %p page %p %d~%d\\n\", file,\n\t\t     inode, page, (int)pos, (int)len);\n\n\t\tr = ceph_update_writeable_page(file, pos, len, page);\n\t} while (r == -EAGAIN);\n\n\treturn r;\n}",
    "includes": [
      "#include <linux/ceph/osd_client.h>",
      "#include \"cache.h\"",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/slab.h>",
      "#include <linux/writeback.h>\t/* generic_writepages */",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ceph_update_writeable_page",
          "args": [
            "file",
            "pos",
            "len",
            "page"
          ],
          "line": 1148
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_update_writeable_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/addr.c",
          "lines": "1029-1123",
          "snippet": "static int ceph_update_writeable_page(struct file *file,\n\t\t\t    loff_t pos, unsigned len,\n\t\t\t    struct page *page)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tstruct ceph_mds_client *mdsc = ceph_inode_to_client(inode)->mdsc;\n\tloff_t page_off = pos & PAGE_CACHE_MASK;\n\tint pos_in_page = pos & ~PAGE_CACHE_MASK;\n\tint end_in_page = pos_in_page + len;\n\tloff_t i_size;\n\tint r;\n\tstruct ceph_snap_context *snapc, *oldest;\n\nretry_locked:\n\t/* writepages currently holds page lock, but if we change that later, */\n\twait_on_page_writeback(page);\n\n\t/* check snap context */\n\tBUG_ON(!ci->i_snap_realm);\n\tdown_read(&mdsc->snap_rwsem);\n\tBUG_ON(!ci->i_snap_realm->cached_context);\n\tsnapc = page_snap_context(page);\n\tif (snapc && snapc != ci->i_head_snapc) {\n\t\t/*\n\t\t * this page is already dirty in another (older) snap\n\t\t * context!  is it writeable now?\n\t\t */\n\t\toldest = get_oldest_context(inode, NULL);\n\t\tup_read(&mdsc->snap_rwsem);\n\n\t\tif (snapc->seq > oldest->seq) {\n\t\t\tceph_put_snap_context(oldest);\n\t\t\tdout(\" page %p snapc %p not current or oldest\\n\",\n\t\t\t     page, snapc);\n\t\t\t/*\n\t\t\t * queue for writeback, and wait for snapc to\n\t\t\t * be writeable or written\n\t\t\t */\n\t\t\tsnapc = ceph_get_snap_context(snapc);\n\t\t\tunlock_page(page);\n\t\t\tceph_queue_writeback(inode);\n\t\t\tr = wait_event_interruptible(ci->i_cap_wq,\n\t\t\t       context_is_writeable_or_written(inode, snapc));\n\t\t\tceph_put_snap_context(snapc);\n\t\t\tif (r == -ERESTARTSYS)\n\t\t\t\treturn r;\n\t\t\treturn -EAGAIN;\n\t\t}\n\t\tceph_put_snap_context(oldest);\n\n\t\t/* yay, writeable, do it now (without dropping page lock) */\n\t\tdout(\" page %p snapc %p not current, but oldest\\n\",\n\t\t     page, snapc);\n\t\tif (!clear_page_dirty_for_io(page))\n\t\t\tgoto retry_locked;\n\t\tr = writepage_nounlock(page, NULL);\n\t\tif (r < 0)\n\t\t\tgoto fail_nosnap;\n\t\tgoto retry_locked;\n\t}\n\n\tif (PageUptodate(page)) {\n\t\tdout(\" page %p already uptodate\\n\", page);\n\t\treturn 0;\n\t}\n\n\t/* full page? */\n\tif (pos_in_page == 0 && len == PAGE_CACHE_SIZE)\n\t\treturn 0;\n\n\t/* past end of file? */\n\ti_size = inode->i_size;   /* caller holds i_mutex */\n\n\tif (page_off >= i_size ||\n\t    (pos_in_page == 0 && (pos+len) >= i_size &&\n\t     end_in_page - pos_in_page != PAGE_CACHE_SIZE)) {\n\t\tdout(\" zeroing %p 0 - %d and %d - %d\\n\",\n\t\t     page, pos_in_page, end_in_page, (int)PAGE_CACHE_SIZE);\n\t\tzero_user_segments(page,\n\t\t\t\t   0, pos_in_page,\n\t\t\t\t   end_in_page, PAGE_CACHE_SIZE);\n\t\treturn 0;\n\t}\n\n\t/* we need to read it. */\n\tup_read(&mdsc->snap_rwsem);\n\tr = readpage_nounlock(file, page);\n\tif (r < 0)\n\t\tgoto fail_nosnap;\n\tgoto retry_locked;\nfail_nosnap:\n\tunlock_page(page);\n\treturn r;\n}",
          "includes": [
            "#include <linux/ceph/osd_client.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>\t/* generic_writepages */",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/osd_client.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/task_io_accounting_ops.h>\n#include <linux/pagevec.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\t/* generic_writepages */\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/backing-dev.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic int ceph_update_writeable_page(struct file *file,\n\t\t\t    loff_t pos, unsigned len,\n\t\t\t    struct page *page)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tstruct ceph_mds_client *mdsc = ceph_inode_to_client(inode)->mdsc;\n\tloff_t page_off = pos & PAGE_CACHE_MASK;\n\tint pos_in_page = pos & ~PAGE_CACHE_MASK;\n\tint end_in_page = pos_in_page + len;\n\tloff_t i_size;\n\tint r;\n\tstruct ceph_snap_context *snapc, *oldest;\n\nretry_locked:\n\t/* writepages currently holds page lock, but if we change that later, */\n\twait_on_page_writeback(page);\n\n\t/* check snap context */\n\tBUG_ON(!ci->i_snap_realm);\n\tdown_read(&mdsc->snap_rwsem);\n\tBUG_ON(!ci->i_snap_realm->cached_context);\n\tsnapc = page_snap_context(page);\n\tif (snapc && snapc != ci->i_head_snapc) {\n\t\t/*\n\t\t * this page is already dirty in another (older) snap\n\t\t * context!  is it writeable now?\n\t\t */\n\t\toldest = get_oldest_context(inode, NULL);\n\t\tup_read(&mdsc->snap_rwsem);\n\n\t\tif (snapc->seq > oldest->seq) {\n\t\t\tceph_put_snap_context(oldest);\n\t\t\tdout(\" page %p snapc %p not current or oldest\\n\",\n\t\t\t     page, snapc);\n\t\t\t/*\n\t\t\t * queue for writeback, and wait for snapc to\n\t\t\t * be writeable or written\n\t\t\t */\n\t\t\tsnapc = ceph_get_snap_context(snapc);\n\t\t\tunlock_page(page);\n\t\t\tceph_queue_writeback(inode);\n\t\t\tr = wait_event_interruptible(ci->i_cap_wq,\n\t\t\t       context_is_writeable_or_written(inode, snapc));\n\t\t\tceph_put_snap_context(snapc);\n\t\t\tif (r == -ERESTARTSYS)\n\t\t\t\treturn r;\n\t\t\treturn -EAGAIN;\n\t\t}\n\t\tceph_put_snap_context(oldest);\n\n\t\t/* yay, writeable, do it now (without dropping page lock) */\n\t\tdout(\" page %p snapc %p not current, but oldest\\n\",\n\t\t     page, snapc);\n\t\tif (!clear_page_dirty_for_io(page))\n\t\t\tgoto retry_locked;\n\t\tr = writepage_nounlock(page, NULL);\n\t\tif (r < 0)\n\t\t\tgoto fail_nosnap;\n\t\tgoto retry_locked;\n\t}\n\n\tif (PageUptodate(page)) {\n\t\tdout(\" page %p already uptodate\\n\", page);\n\t\treturn 0;\n\t}\n\n\t/* full page? */\n\tif (pos_in_page == 0 && len == PAGE_CACHE_SIZE)\n\t\treturn 0;\n\n\t/* past end of file? */\n\ti_size = inode->i_size;   /* caller holds i_mutex */\n\n\tif (page_off >= i_size ||\n\t    (pos_in_page == 0 && (pos+len) >= i_size &&\n\t     end_in_page - pos_in_page != PAGE_CACHE_SIZE)) {\n\t\tdout(\" zeroing %p 0 - %d and %d - %d\\n\",\n\t\t     page, pos_in_page, end_in_page, (int)PAGE_CACHE_SIZE);\n\t\tzero_user_segments(page,\n\t\t\t\t   0, pos_in_page,\n\t\t\t\t   end_in_page, PAGE_CACHE_SIZE);\n\t\treturn 0;\n\t}\n\n\t/* we need to read it. */\n\tup_read(&mdsc->snap_rwsem);\n\tr = readpage_nounlock(file, page);\n\tif (r < 0)\n\t\tgoto fail_nosnap;\n\tgoto retry_locked;\nfail_nosnap:\n\tunlock_page(page);\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"write_begin file %p inode %p page %p %d~%d\\n\"",
            "file",
            "inode",
            "page",
            "(int)pos",
            "(int)len"
          ],
          "line": 1145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "grab_cache_page_write_begin",
          "args": [
            "mapping",
            "index",
            "0"
          ],
          "line": 1140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 1133
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/ceph/osd_client.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/task_io_accounting_ops.h>\n#include <linux/pagevec.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\t/* generic_writepages */\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/backing-dev.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic int ceph_write_begin(struct file *file, struct address_space *mapping,\n\t\t\t    loff_t pos, unsigned len, unsigned flags,\n\t\t\t    struct page **pagep, void **fsdata)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct page *page;\n\tpgoff_t index = pos >> PAGE_CACHE_SHIFT;\n\tint r;\n\n\tdo {\n\t\t/* get a page */\n\t\tpage = grab_cache_page_write_begin(mapping, index, 0);\n\t\tif (!page)\n\t\t\treturn -ENOMEM;\n\t\t*pagep = page;\n\n\t\tdout(\"write_begin file %p inode %p page %p %d~%d\\n\", file,\n\t\t     inode, page, (int)pos, (int)len);\n\n\t\tr = ceph_update_writeable_page(file, pos, len, page);\n\t} while (r == -EAGAIN);\n\n\treturn r;\n}"
  },
  {
    "function_name": "ceph_update_writeable_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/addr.c",
    "lines": "1029-1123",
    "snippet": "static int ceph_update_writeable_page(struct file *file,\n\t\t\t    loff_t pos, unsigned len,\n\t\t\t    struct page *page)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tstruct ceph_mds_client *mdsc = ceph_inode_to_client(inode)->mdsc;\n\tloff_t page_off = pos & PAGE_CACHE_MASK;\n\tint pos_in_page = pos & ~PAGE_CACHE_MASK;\n\tint end_in_page = pos_in_page + len;\n\tloff_t i_size;\n\tint r;\n\tstruct ceph_snap_context *snapc, *oldest;\n\nretry_locked:\n\t/* writepages currently holds page lock, but if we change that later, */\n\twait_on_page_writeback(page);\n\n\t/* check snap context */\n\tBUG_ON(!ci->i_snap_realm);\n\tdown_read(&mdsc->snap_rwsem);\n\tBUG_ON(!ci->i_snap_realm->cached_context);\n\tsnapc = page_snap_context(page);\n\tif (snapc && snapc != ci->i_head_snapc) {\n\t\t/*\n\t\t * this page is already dirty in another (older) snap\n\t\t * context!  is it writeable now?\n\t\t */\n\t\toldest = get_oldest_context(inode, NULL);\n\t\tup_read(&mdsc->snap_rwsem);\n\n\t\tif (snapc->seq > oldest->seq) {\n\t\t\tceph_put_snap_context(oldest);\n\t\t\tdout(\" page %p snapc %p not current or oldest\\n\",\n\t\t\t     page, snapc);\n\t\t\t/*\n\t\t\t * queue for writeback, and wait for snapc to\n\t\t\t * be writeable or written\n\t\t\t */\n\t\t\tsnapc = ceph_get_snap_context(snapc);\n\t\t\tunlock_page(page);\n\t\t\tceph_queue_writeback(inode);\n\t\t\tr = wait_event_interruptible(ci->i_cap_wq,\n\t\t\t       context_is_writeable_or_written(inode, snapc));\n\t\t\tceph_put_snap_context(snapc);\n\t\t\tif (r == -ERESTARTSYS)\n\t\t\t\treturn r;\n\t\t\treturn -EAGAIN;\n\t\t}\n\t\tceph_put_snap_context(oldest);\n\n\t\t/* yay, writeable, do it now (without dropping page lock) */\n\t\tdout(\" page %p snapc %p not current, but oldest\\n\",\n\t\t     page, snapc);\n\t\tif (!clear_page_dirty_for_io(page))\n\t\t\tgoto retry_locked;\n\t\tr = writepage_nounlock(page, NULL);\n\t\tif (r < 0)\n\t\t\tgoto fail_nosnap;\n\t\tgoto retry_locked;\n\t}\n\n\tif (PageUptodate(page)) {\n\t\tdout(\" page %p already uptodate\\n\", page);\n\t\treturn 0;\n\t}\n\n\t/* full page? */\n\tif (pos_in_page == 0 && len == PAGE_CACHE_SIZE)\n\t\treturn 0;\n\n\t/* past end of file? */\n\ti_size = inode->i_size;   /* caller holds i_mutex */\n\n\tif (page_off >= i_size ||\n\t    (pos_in_page == 0 && (pos+len) >= i_size &&\n\t     end_in_page - pos_in_page != PAGE_CACHE_SIZE)) {\n\t\tdout(\" zeroing %p 0 - %d and %d - %d\\n\",\n\t\t     page, pos_in_page, end_in_page, (int)PAGE_CACHE_SIZE);\n\t\tzero_user_segments(page,\n\t\t\t\t   0, pos_in_page,\n\t\t\t\t   end_in_page, PAGE_CACHE_SIZE);\n\t\treturn 0;\n\t}\n\n\t/* we need to read it. */\n\tup_read(&mdsc->snap_rwsem);\n\tr = readpage_nounlock(file, page);\n\tif (r < 0)\n\t\tgoto fail_nosnap;\n\tgoto retry_locked;\nfail_nosnap:\n\tunlock_page(page);\n\treturn r;\n}",
    "includes": [
      "#include <linux/ceph/osd_client.h>",
      "#include \"cache.h\"",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/slab.h>",
      "#include <linux/writeback.h>\t/* generic_writepages */",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 1121
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "readpage_nounlock",
          "args": [
            "file",
            "page"
          ],
          "line": 1116
        },
        "resolved": true,
        "details": {
          "function_name": "readpage_nounlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/addr.c",
          "lines": "188-244",
          "snippet": "static int readpage_nounlock(struct file *filp, struct page *page)\n{\n\tstruct inode *inode = file_inode(filp);\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tstruct ceph_osd_client *osdc =\n\t\t&ceph_inode_to_client(inode)->client->osdc;\n\tint err = 0;\n\tu64 off = page_offset(page);\n\tu64 len = PAGE_CACHE_SIZE;\n\n\tif (off >= i_size_read(inode)) {\n\t\tzero_user_segment(page, 0, PAGE_CACHE_SIZE);\n\t\tSetPageUptodate(page);\n\t\treturn 0;\n\t}\n\n\tif (ci->i_inline_version != CEPH_INLINE_NONE) {\n\t\t/*\n\t\t * Uptodate inline data should have been added\n\t\t * into page cache while getting Fcr caps.\n\t\t */\n\t\tif (off == 0)\n\t\t\treturn -EINVAL;\n\t\tzero_user_segment(page, 0, PAGE_CACHE_SIZE);\n\t\tSetPageUptodate(page);\n\t\treturn 0;\n\t}\n\n\terr = ceph_readpage_from_fscache(inode, page);\n\tif (err == 0)\n\t\tgoto out;\n\n\tdout(\"readpage inode %p file %p page %p index %lu\\n\",\n\t     inode, filp, page, page->index);\n\terr = ceph_osdc_readpages(osdc, ceph_vino(inode), &ci->i_layout,\n\t\t\t\t  off, &len,\n\t\t\t\t  ci->i_truncate_seq, ci->i_truncate_size,\n\t\t\t\t  &page, 1, 0);\n\tif (err == -ENOENT)\n\t\terr = 0;\n\tif (err < 0) {\n\t\tSetPageError(page);\n\t\tceph_fscache_readpage_cancel(inode, page);\n\t\tgoto out;\n\t}\n\tif (err < PAGE_CACHE_SIZE)\n\t\t/* zero fill remainder of page */\n\t\tzero_user_segment(page, err, PAGE_CACHE_SIZE);\n\telse\n\t\tflush_dcache_page(page);\n\n\tSetPageUptodate(page);\n\tceph_readpage_to_fscache(inode, page);\n\nout:\n\treturn err < 0 ? err : 0;\n}",
          "includes": [
            "#include <linux/ceph/osd_client.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>\t/* generic_writepages */",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/osd_client.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/task_io_accounting_ops.h>\n#include <linux/pagevec.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\t/* generic_writepages */\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/backing-dev.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic int readpage_nounlock(struct file *filp, struct page *page)\n{\n\tstruct inode *inode = file_inode(filp);\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tstruct ceph_osd_client *osdc =\n\t\t&ceph_inode_to_client(inode)->client->osdc;\n\tint err = 0;\n\tu64 off = page_offset(page);\n\tu64 len = PAGE_CACHE_SIZE;\n\n\tif (off >= i_size_read(inode)) {\n\t\tzero_user_segment(page, 0, PAGE_CACHE_SIZE);\n\t\tSetPageUptodate(page);\n\t\treturn 0;\n\t}\n\n\tif (ci->i_inline_version != CEPH_INLINE_NONE) {\n\t\t/*\n\t\t * Uptodate inline data should have been added\n\t\t * into page cache while getting Fcr caps.\n\t\t */\n\t\tif (off == 0)\n\t\t\treturn -EINVAL;\n\t\tzero_user_segment(page, 0, PAGE_CACHE_SIZE);\n\t\tSetPageUptodate(page);\n\t\treturn 0;\n\t}\n\n\terr = ceph_readpage_from_fscache(inode, page);\n\tif (err == 0)\n\t\tgoto out;\n\n\tdout(\"readpage inode %p file %p page %p index %lu\\n\",\n\t     inode, filp, page, page->index);\n\terr = ceph_osdc_readpages(osdc, ceph_vino(inode), &ci->i_layout,\n\t\t\t\t  off, &len,\n\t\t\t\t  ci->i_truncate_seq, ci->i_truncate_size,\n\t\t\t\t  &page, 1, 0);\n\tif (err == -ENOENT)\n\t\terr = 0;\n\tif (err < 0) {\n\t\tSetPageError(page);\n\t\tceph_fscache_readpage_cancel(inode, page);\n\t\tgoto out;\n\t}\n\tif (err < PAGE_CACHE_SIZE)\n\t\t/* zero fill remainder of page */\n\t\tzero_user_segment(page, err, PAGE_CACHE_SIZE);\n\telse\n\t\tflush_dcache_page(page);\n\n\tSetPageUptodate(page);\n\tceph_readpage_to_fscache(inode, page);\n\nout:\n\treturn err < 0 ? err : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&mdsc->snap_rwsem"
          ],
          "line": 1115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zero_user_segments",
          "args": [
            "page",
            "0",
            "pos_in_page",
            "end_in_page",
            "PAGE_CACHE_SIZE"
          ],
          "line": 1108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\" zeroing %p 0 - %d and %d - %d\\n\"",
            "page",
            "pos_in_page",
            "end_in_page",
            "(int)PAGE_CACHE_SIZE"
          ],
          "line": 1106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\" page %p already uptodate\\n\"",
            "page"
          ],
          "line": 1092
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "page"
          ],
          "line": 1091
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "writepage_nounlock",
          "args": [
            "page",
            "NULL"
          ],
          "line": 1085
        },
        "resolved": true,
        "details": {
          "function_name": "writepage_nounlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/addr.c",
          "lines": "471-560",
          "snippet": "static int writepage_nounlock(struct page *page, struct writeback_control *wbc)\n{\n\tstruct inode *inode;\n\tstruct ceph_inode_info *ci;\n\tstruct ceph_fs_client *fsc;\n\tstruct ceph_osd_client *osdc;\n\tstruct ceph_snap_context *snapc, *oldest;\n\tloff_t page_off = page_offset(page);\n\tlong writeback_stat;\n\tu64 truncate_size, snap_size = 0;\n\tu32 truncate_seq;\n\tint err = 0, len = PAGE_CACHE_SIZE;\n\n\tdout(\"writepage %p idx %lu\\n\", page, page->index);\n\n\tif (!page->mapping || !page->mapping->host) {\n\t\tdout(\"writepage %p - no mapping\\n\", page);\n\t\treturn -EFAULT;\n\t}\n\tinode = page->mapping->host;\n\tci = ceph_inode(inode);\n\tfsc = ceph_inode_to_client(inode);\n\tosdc = &fsc->client->osdc;\n\n\t/* verify this is a writeable snap context */\n\tsnapc = page_snap_context(page);\n\tif (snapc == NULL) {\n\t\tdout(\"writepage %p page %p not dirty?\\n\", inode, page);\n\t\tgoto out;\n\t}\n\toldest = get_oldest_context(inode, &snap_size);\n\tif (snapc->seq > oldest->seq) {\n\t\tdout(\"writepage %p page %p snapc %p not writeable - noop\\n\",\n\t\t     inode, page, snapc);\n\t\t/* we should only noop if called by kswapd */\n\t\tWARN_ON((current->flags & PF_MEMALLOC) == 0);\n\t\tceph_put_snap_context(oldest);\n\t\tgoto out;\n\t}\n\tceph_put_snap_context(oldest);\n\n\tspin_lock(&ci->i_ceph_lock);\n\ttruncate_seq = ci->i_truncate_seq;\n\ttruncate_size = ci->i_truncate_size;\n\tif (!snap_size)\n\t\tsnap_size = i_size_read(inode);\n\tspin_unlock(&ci->i_ceph_lock);\n\n\t/* is this a partial page at end of file? */\n\tif (page_off >= snap_size) {\n\t\tdout(\"%p page eof %llu\\n\", page, snap_size);\n\t\tgoto out;\n\t}\n\tif (snap_size < page_off + len)\n\t\tlen = snap_size - page_off;\n\n\tdout(\"writepage %p page %p index %lu on %llu~%u snapc %p\\n\",\n\t     inode, page, page->index, page_off, len, snapc);\n\n\twriteback_stat = atomic_long_inc_return(&fsc->writeback_count);\n\tif (writeback_stat >\n\t    CONGESTION_ON_THRESH(fsc->mount_options->congestion_kb))\n\t\tset_bdi_congested(&fsc->backing_dev_info, BLK_RW_ASYNC);\n\n\tceph_readpage_to_fscache(inode, page);\n\n\tset_page_writeback(page);\n\terr = ceph_osdc_writepages(osdc, ceph_vino(inode),\n\t\t\t\t   &ci->i_layout, snapc,\n\t\t\t\t   page_off, len,\n\t\t\t\t   truncate_seq, truncate_size,\n\t\t\t\t   &inode->i_mtime, &page, 1);\n\tif (err < 0) {\n\t\tdout(\"writepage setting page/mapping error %d %p\\n\", err, page);\n\t\tSetPageError(page);\n\t\tmapping_set_error(&inode->i_data, err);\n\t\tif (wbc)\n\t\t\twbc->pages_skipped++;\n\t} else {\n\t\tdout(\"writepage cleaned page %p\\n\", page);\n\t\terr = 0;  /* vfs expects us to return 0 */\n\t}\n\tpage->private = 0;\n\tClearPagePrivate(page);\n\tend_page_writeback(page);\n\tceph_put_wrbuffer_cap_refs(ci, 1, snapc);\n\tceph_put_snap_context(snapc);  /* page's reference */\nout:\n\treturn err;\n}",
          "includes": [
            "#include <linux/ceph/osd_client.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>\t/* generic_writepages */",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/osd_client.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/task_io_accounting_ops.h>\n#include <linux/pagevec.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\t/* generic_writepages */\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/backing-dev.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic int writepage_nounlock(struct page *page, struct writeback_control *wbc)\n{\n\tstruct inode *inode;\n\tstruct ceph_inode_info *ci;\n\tstruct ceph_fs_client *fsc;\n\tstruct ceph_osd_client *osdc;\n\tstruct ceph_snap_context *snapc, *oldest;\n\tloff_t page_off = page_offset(page);\n\tlong writeback_stat;\n\tu64 truncate_size, snap_size = 0;\n\tu32 truncate_seq;\n\tint err = 0, len = PAGE_CACHE_SIZE;\n\n\tdout(\"writepage %p idx %lu\\n\", page, page->index);\n\n\tif (!page->mapping || !page->mapping->host) {\n\t\tdout(\"writepage %p - no mapping\\n\", page);\n\t\treturn -EFAULT;\n\t}\n\tinode = page->mapping->host;\n\tci = ceph_inode(inode);\n\tfsc = ceph_inode_to_client(inode);\n\tosdc = &fsc->client->osdc;\n\n\t/* verify this is a writeable snap context */\n\tsnapc = page_snap_context(page);\n\tif (snapc == NULL) {\n\t\tdout(\"writepage %p page %p not dirty?\\n\", inode, page);\n\t\tgoto out;\n\t}\n\toldest = get_oldest_context(inode, &snap_size);\n\tif (snapc->seq > oldest->seq) {\n\t\tdout(\"writepage %p page %p snapc %p not writeable - noop\\n\",\n\t\t     inode, page, snapc);\n\t\t/* we should only noop if called by kswapd */\n\t\tWARN_ON((current->flags & PF_MEMALLOC) == 0);\n\t\tceph_put_snap_context(oldest);\n\t\tgoto out;\n\t}\n\tceph_put_snap_context(oldest);\n\n\tspin_lock(&ci->i_ceph_lock);\n\ttruncate_seq = ci->i_truncate_seq;\n\ttruncate_size = ci->i_truncate_size;\n\tif (!snap_size)\n\t\tsnap_size = i_size_read(inode);\n\tspin_unlock(&ci->i_ceph_lock);\n\n\t/* is this a partial page at end of file? */\n\tif (page_off >= snap_size) {\n\t\tdout(\"%p page eof %llu\\n\", page, snap_size);\n\t\tgoto out;\n\t}\n\tif (snap_size < page_off + len)\n\t\tlen = snap_size - page_off;\n\n\tdout(\"writepage %p page %p index %lu on %llu~%u snapc %p\\n\",\n\t     inode, page, page->index, page_off, len, snapc);\n\n\twriteback_stat = atomic_long_inc_return(&fsc->writeback_count);\n\tif (writeback_stat >\n\t    CONGESTION_ON_THRESH(fsc->mount_options->congestion_kb))\n\t\tset_bdi_congested(&fsc->backing_dev_info, BLK_RW_ASYNC);\n\n\tceph_readpage_to_fscache(inode, page);\n\n\tset_page_writeback(page);\n\terr = ceph_osdc_writepages(osdc, ceph_vino(inode),\n\t\t\t\t   &ci->i_layout, snapc,\n\t\t\t\t   page_off, len,\n\t\t\t\t   truncate_seq, truncate_size,\n\t\t\t\t   &inode->i_mtime, &page, 1);\n\tif (err < 0) {\n\t\tdout(\"writepage setting page/mapping error %d %p\\n\", err, page);\n\t\tSetPageError(page);\n\t\tmapping_set_error(&inode->i_data, err);\n\t\tif (wbc)\n\t\t\twbc->pages_skipped++;\n\t} else {\n\t\tdout(\"writepage cleaned page %p\\n\", page);\n\t\terr = 0;  /* vfs expects us to return 0 */\n\t}\n\tpage->private = 0;\n\tClearPagePrivate(page);\n\tend_page_writeback(page);\n\tceph_put_wrbuffer_cap_refs(ci, 1, snapc);\n\tceph_put_snap_context(snapc);  /* page's reference */\nout:\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_page_dirty_for_io",
          "args": [
            "page"
          ],
          "line": 1083
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\" page %p snapc %p not current, but oldest\\n\"",
            "page",
            "snapc"
          ],
          "line": 1081
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_put_snap_context",
          "args": [
            "oldest"
          ],
          "line": 1078
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_put_snap_context",
          "args": [
            "snapc"
          ],
          "line": 1073
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_event_interruptible",
          "args": [
            "ci->i_cap_wq",
            "context_is_writeable_or_written(inode, snapc)"
          ],
          "line": 1071
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context_is_writeable_or_written",
          "args": [
            "inode",
            "snapc"
          ],
          "line": 1072
        },
        "resolved": true,
        "details": {
          "function_name": "context_is_writeable_or_written",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/addr.c",
          "lines": "1011-1019",
          "snippet": "static int context_is_writeable_or_written(struct inode *inode,\n\t\t\t\t\t   struct ceph_snap_context *snapc)\n{\n\tstruct ceph_snap_context *oldest = get_oldest_context(inode, NULL);\n\tint ret = !oldest || snapc->seq <= oldest->seq;\n\n\tceph_put_snap_context(oldest);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/ceph/osd_client.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>\t/* generic_writepages */",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/osd_client.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/task_io_accounting_ops.h>\n#include <linux/pagevec.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\t/* generic_writepages */\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/backing-dev.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic int context_is_writeable_or_written(struct inode *inode,\n\t\t\t\t\t   struct ceph_snap_context *snapc)\n{\n\tstruct ceph_snap_context *oldest = get_oldest_context(inode, NULL);\n\tint ret = !oldest || snapc->seq <= oldest->seq;\n\n\tceph_put_snap_context(oldest);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_queue_writeback",
          "args": [
            "inode"
          ],
          "line": 1070
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_queue_writeback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/inode.c",
          "lines": "1505-1515",
          "snippet": "void ceph_queue_writeback(struct inode *inode)\n{\n\tihold(inode);\n\tif (queue_work(ceph_inode_to_client(inode)->wb_wq,\n\t\t       &ceph_inode(inode)->i_wb_work)) {\n\t\tdout(\"ceph_queue_writeback %p\\n\", inode);\n\t} else {\n\t\tdout(\"ceph_queue_writeback %p failed\\n\", inode);\n\t\tiput(inode);\n\t}\n}",
          "includes": [
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/random.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/namei.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/random.h>\n#include <linux/posix_acl.h>\n#include <linux/vmalloc.h>\n#include <linux/writeback.h>\n#include <linux/namei.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/ceph/ceph_debug.h>\n\nvoid ceph_queue_writeback(struct inode *inode)\n{\n\tihold(inode);\n\tif (queue_work(ceph_inode_to_client(inode)->wb_wq,\n\t\t       &ceph_inode(inode)->i_wb_work)) {\n\t\tdout(\"ceph_queue_writeback %p\\n\", inode);\n\t} else {\n\t\tdout(\"ceph_queue_writeback %p failed\\n\", inode);\n\t\tiput(inode);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_get_snap_context",
          "args": [
            "snapc"
          ],
          "line": 1068
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\" page %p snapc %p not current or oldest\\n\"",
            "page",
            "snapc"
          ],
          "line": 1062
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_put_snap_context",
          "args": [
            "oldest"
          ],
          "line": 1061
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&mdsc->snap_rwsem"
          ],
          "line": 1058
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_oldest_context",
          "args": [
            "inode",
            "NULL"
          ],
          "line": 1057
        },
        "resolved": true,
        "details": {
          "function_name": "get_oldest_context",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/addr.c",
          "lines": "438-463",
          "snippet": "static struct ceph_snap_context *get_oldest_context(struct inode *inode,\n\t\t\t\t\t\t    u64 *snap_size)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tstruct ceph_snap_context *snapc = NULL;\n\tstruct ceph_cap_snap *capsnap = NULL;\n\n\tspin_lock(&ci->i_ceph_lock);\n\tlist_for_each_entry(capsnap, &ci->i_cap_snaps, ci_item) {\n\t\tdout(\" cap_snap %p snapc %p has %d dirty pages\\n\", capsnap,\n\t\t     capsnap->context, capsnap->dirty_pages);\n\t\tif (capsnap->dirty_pages) {\n\t\t\tsnapc = ceph_get_snap_context(capsnap->context);\n\t\t\tif (snap_size)\n\t\t\t\t*snap_size = capsnap->size;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!snapc && ci->i_wrbuffer_ref_head) {\n\t\tsnapc = ceph_get_snap_context(ci->i_head_snapc);\n\t\tdout(\" head snapc %p has %d dirty pages\\n\",\n\t\t     snapc, ci->i_wrbuffer_ref_head);\n\t}\n\tspin_unlock(&ci->i_ceph_lock);\n\treturn snapc;\n}",
          "includes": [
            "#include <linux/ceph/osd_client.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>\t/* generic_writepages */",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/osd_client.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/task_io_accounting_ops.h>\n#include <linux/pagevec.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\t/* generic_writepages */\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/backing-dev.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic struct ceph_snap_context *get_oldest_context(struct inode *inode,\n\t\t\t\t\t\t    u64 *snap_size)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tstruct ceph_snap_context *snapc = NULL;\n\tstruct ceph_cap_snap *capsnap = NULL;\n\n\tspin_lock(&ci->i_ceph_lock);\n\tlist_for_each_entry(capsnap, &ci->i_cap_snaps, ci_item) {\n\t\tdout(\" cap_snap %p snapc %p has %d dirty pages\\n\", capsnap,\n\t\t     capsnap->context, capsnap->dirty_pages);\n\t\tif (capsnap->dirty_pages) {\n\t\t\tsnapc = ceph_get_snap_context(capsnap->context);\n\t\t\tif (snap_size)\n\t\t\t\t*snap_size = capsnap->size;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!snapc && ci->i_wrbuffer_ref_head) {\n\t\tsnapc = ceph_get_snap_context(ci->i_head_snapc);\n\t\tdout(\" head snapc %p has %d dirty pages\\n\",\n\t\t     snapc, ci->i_wrbuffer_ref_head);\n\t}\n\tspin_unlock(&ci->i_ceph_lock);\n\treturn snapc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_snap_context",
          "args": [
            "page"
          ],
          "line": 1051
        },
        "resolved": true,
        "details": {
          "function_name": "page_snap_context",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/addr.c",
          "lines": "58-63",
          "snippet": "static inline struct ceph_snap_context *page_snap_context(struct page *page)\n{\n\tif (PagePrivate(page))\n\t\treturn (void *)page->private;\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/ceph/osd_client.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>\t/* generic_writepages */",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/osd_client.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/task_io_accounting_ops.h>\n#include <linux/pagevec.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\t/* generic_writepages */\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/backing-dev.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline struct ceph_snap_context *page_snap_context(struct page *page)\n{\n\tif (PagePrivate(page))\n\t\treturn (void *)page->private;\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!ci->i_snap_realm->cached_context"
          ],
          "line": 1050
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_read",
          "args": [
            "&mdsc->snap_rwsem"
          ],
          "line": 1049
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!ci->i_snap_realm"
          ],
          "line": 1048
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_on_page_writeback",
          "args": [
            "page"
          ],
          "line": 1045
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_inode_to_client",
          "args": [
            "inode"
          ],
          "line": 1035
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_inode_to_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.h",
          "lines": "347-350",
          "snippet": "static inline struct ceph_fs_client *ceph_inode_to_client(struct inode *inode)\n{\n\treturn (struct ceph_fs_client *)inode->i_sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/ceph/libceph.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/backing-dev.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/ceph/libceph.h>\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n#include <linux/completion.h>\n#include <linux/backing-dev.h>\n#include <asm/unaligned.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline struct ceph_fs_client *ceph_inode_to_client(struct inode *inode)\n{\n\treturn (struct ceph_fs_client *)inode->i_sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 1033
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/ceph/osd_client.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/task_io_accounting_ops.h>\n#include <linux/pagevec.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\t/* generic_writepages */\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/backing-dev.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic int ceph_update_writeable_page(struct file *file,\n\t\t\t    loff_t pos, unsigned len,\n\t\t\t    struct page *page)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tstruct ceph_mds_client *mdsc = ceph_inode_to_client(inode)->mdsc;\n\tloff_t page_off = pos & PAGE_CACHE_MASK;\n\tint pos_in_page = pos & ~PAGE_CACHE_MASK;\n\tint end_in_page = pos_in_page + len;\n\tloff_t i_size;\n\tint r;\n\tstruct ceph_snap_context *snapc, *oldest;\n\nretry_locked:\n\t/* writepages currently holds page lock, but if we change that later, */\n\twait_on_page_writeback(page);\n\n\t/* check snap context */\n\tBUG_ON(!ci->i_snap_realm);\n\tdown_read(&mdsc->snap_rwsem);\n\tBUG_ON(!ci->i_snap_realm->cached_context);\n\tsnapc = page_snap_context(page);\n\tif (snapc && snapc != ci->i_head_snapc) {\n\t\t/*\n\t\t * this page is already dirty in another (older) snap\n\t\t * context!  is it writeable now?\n\t\t */\n\t\toldest = get_oldest_context(inode, NULL);\n\t\tup_read(&mdsc->snap_rwsem);\n\n\t\tif (snapc->seq > oldest->seq) {\n\t\t\tceph_put_snap_context(oldest);\n\t\t\tdout(\" page %p snapc %p not current or oldest\\n\",\n\t\t\t     page, snapc);\n\t\t\t/*\n\t\t\t * queue for writeback, and wait for snapc to\n\t\t\t * be writeable or written\n\t\t\t */\n\t\t\tsnapc = ceph_get_snap_context(snapc);\n\t\t\tunlock_page(page);\n\t\t\tceph_queue_writeback(inode);\n\t\t\tr = wait_event_interruptible(ci->i_cap_wq,\n\t\t\t       context_is_writeable_or_written(inode, snapc));\n\t\t\tceph_put_snap_context(snapc);\n\t\t\tif (r == -ERESTARTSYS)\n\t\t\t\treturn r;\n\t\t\treturn -EAGAIN;\n\t\t}\n\t\tceph_put_snap_context(oldest);\n\n\t\t/* yay, writeable, do it now (without dropping page lock) */\n\t\tdout(\" page %p snapc %p not current, but oldest\\n\",\n\t\t     page, snapc);\n\t\tif (!clear_page_dirty_for_io(page))\n\t\t\tgoto retry_locked;\n\t\tr = writepage_nounlock(page, NULL);\n\t\tif (r < 0)\n\t\t\tgoto fail_nosnap;\n\t\tgoto retry_locked;\n\t}\n\n\tif (PageUptodate(page)) {\n\t\tdout(\" page %p already uptodate\\n\", page);\n\t\treturn 0;\n\t}\n\n\t/* full page? */\n\tif (pos_in_page == 0 && len == PAGE_CACHE_SIZE)\n\t\treturn 0;\n\n\t/* past end of file? */\n\ti_size = inode->i_size;   /* caller holds i_mutex */\n\n\tif (page_off >= i_size ||\n\t    (pos_in_page == 0 && (pos+len) >= i_size &&\n\t     end_in_page - pos_in_page != PAGE_CACHE_SIZE)) {\n\t\tdout(\" zeroing %p 0 - %d and %d - %d\\n\",\n\t\t     page, pos_in_page, end_in_page, (int)PAGE_CACHE_SIZE);\n\t\tzero_user_segments(page,\n\t\t\t\t   0, pos_in_page,\n\t\t\t\t   end_in_page, PAGE_CACHE_SIZE);\n\t\treturn 0;\n\t}\n\n\t/* we need to read it. */\n\tup_read(&mdsc->snap_rwsem);\n\tr = readpage_nounlock(file, page);\n\tif (r < 0)\n\t\tgoto fail_nosnap;\n\tgoto retry_locked;\nfail_nosnap:\n\tunlock_page(page);\n\treturn r;\n}"
  },
  {
    "function_name": "context_is_writeable_or_written",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/addr.c",
    "lines": "1011-1019",
    "snippet": "static int context_is_writeable_or_written(struct inode *inode,\n\t\t\t\t\t   struct ceph_snap_context *snapc)\n{\n\tstruct ceph_snap_context *oldest = get_oldest_context(inode, NULL);\n\tint ret = !oldest || snapc->seq <= oldest->seq;\n\n\tceph_put_snap_context(oldest);\n\treturn ret;\n}",
    "includes": [
      "#include <linux/ceph/osd_client.h>",
      "#include \"cache.h\"",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/slab.h>",
      "#include <linux/writeback.h>\t/* generic_writepages */",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ceph_put_snap_context",
          "args": [
            "oldest"
          ],
          "line": 1017
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_oldest_context",
          "args": [
            "inode",
            "NULL"
          ],
          "line": 1014
        },
        "resolved": true,
        "details": {
          "function_name": "get_oldest_context",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/addr.c",
          "lines": "438-463",
          "snippet": "static struct ceph_snap_context *get_oldest_context(struct inode *inode,\n\t\t\t\t\t\t    u64 *snap_size)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tstruct ceph_snap_context *snapc = NULL;\n\tstruct ceph_cap_snap *capsnap = NULL;\n\n\tspin_lock(&ci->i_ceph_lock);\n\tlist_for_each_entry(capsnap, &ci->i_cap_snaps, ci_item) {\n\t\tdout(\" cap_snap %p snapc %p has %d dirty pages\\n\", capsnap,\n\t\t     capsnap->context, capsnap->dirty_pages);\n\t\tif (capsnap->dirty_pages) {\n\t\t\tsnapc = ceph_get_snap_context(capsnap->context);\n\t\t\tif (snap_size)\n\t\t\t\t*snap_size = capsnap->size;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!snapc && ci->i_wrbuffer_ref_head) {\n\t\tsnapc = ceph_get_snap_context(ci->i_head_snapc);\n\t\tdout(\" head snapc %p has %d dirty pages\\n\",\n\t\t     snapc, ci->i_wrbuffer_ref_head);\n\t}\n\tspin_unlock(&ci->i_ceph_lock);\n\treturn snapc;\n}",
          "includes": [
            "#include <linux/ceph/osd_client.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>\t/* generic_writepages */",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/osd_client.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/task_io_accounting_ops.h>\n#include <linux/pagevec.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\t/* generic_writepages */\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/backing-dev.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic struct ceph_snap_context *get_oldest_context(struct inode *inode,\n\t\t\t\t\t\t    u64 *snap_size)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tstruct ceph_snap_context *snapc = NULL;\n\tstruct ceph_cap_snap *capsnap = NULL;\n\n\tspin_lock(&ci->i_ceph_lock);\n\tlist_for_each_entry(capsnap, &ci->i_cap_snaps, ci_item) {\n\t\tdout(\" cap_snap %p snapc %p has %d dirty pages\\n\", capsnap,\n\t\t     capsnap->context, capsnap->dirty_pages);\n\t\tif (capsnap->dirty_pages) {\n\t\t\tsnapc = ceph_get_snap_context(capsnap->context);\n\t\t\tif (snap_size)\n\t\t\t\t*snap_size = capsnap->size;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!snapc && ci->i_wrbuffer_ref_head) {\n\t\tsnapc = ceph_get_snap_context(ci->i_head_snapc);\n\t\tdout(\" head snapc %p has %d dirty pages\\n\",\n\t\t     snapc, ci->i_wrbuffer_ref_head);\n\t}\n\tspin_unlock(&ci->i_ceph_lock);\n\treturn snapc;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/ceph/osd_client.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/task_io_accounting_ops.h>\n#include <linux/pagevec.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\t/* generic_writepages */\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/backing-dev.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic int context_is_writeable_or_written(struct inode *inode,\n\t\t\t\t\t   struct ceph_snap_context *snapc)\n{\n\tstruct ceph_snap_context *oldest = get_oldest_context(inode, NULL);\n\tint ret = !oldest || snapc->seq <= oldest->seq;\n\n\tceph_put_snap_context(oldest);\n\treturn ret;\n}"
  },
  {
    "function_name": "ceph_writepages_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/addr.c",
    "lines": "680-1004",
    "snippet": "static int ceph_writepages_start(struct address_space *mapping,\n\t\t\t\t struct writeback_control *wbc)\n{\n\tstruct inode *inode = mapping->host;\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tstruct ceph_fs_client *fsc = ceph_inode_to_client(inode);\n\tstruct ceph_vino vino = ceph_vino(inode);\n\tpgoff_t index, start, end;\n\tint range_whole = 0;\n\tint should_loop = 1;\n\tpgoff_t max_pages = 0, max_pages_ever = 0;\n\tstruct ceph_snap_context *snapc = NULL, *last_snapc = NULL, *pgsnapc;\n\tstruct pagevec pvec;\n\tint done = 0;\n\tint rc = 0;\n\tunsigned wsize = 1 << inode->i_blkbits;\n\tstruct ceph_osd_request *req = NULL;\n\tint do_sync = 0;\n\tu64 truncate_size, snap_size;\n\tu32 truncate_seq;\n\n\t/*\n\t * Include a 'sync' in the OSD request if this is a data\n\t * integrity write (e.g., O_SYNC write or fsync()), or if our\n\t * cap is being revoked.\n\t */\n\tif ((wbc->sync_mode == WB_SYNC_ALL) ||\n\t\tceph_caps_revoking(ci, CEPH_CAP_FILE_BUFFER))\n\t\tdo_sync = 1;\n\tdout(\"writepages_start %p dosync=%d (mode=%s)\\n\",\n\t     inode, do_sync,\n\t     wbc->sync_mode == WB_SYNC_NONE ? \"NONE\" :\n\t     (wbc->sync_mode == WB_SYNC_ALL ? \"ALL\" : \"HOLD\"));\n\n\tif (fsc->mount_state == CEPH_MOUNT_SHUTDOWN) {\n\t\tpr_warn(\"writepage_start %p on forced umount\\n\", inode);\n\t\treturn -EIO; /* we're in a forced umount, don't write! */\n\t}\n\tif (fsc->mount_options->wsize && fsc->mount_options->wsize < wsize)\n\t\twsize = fsc->mount_options->wsize;\n\tif (wsize < PAGE_CACHE_SIZE)\n\t\twsize = PAGE_CACHE_SIZE;\n\tmax_pages_ever = wsize >> PAGE_CACHE_SHIFT;\n\n\tpagevec_init(&pvec, 0);\n\n\t/* where to start/end? */\n\tif (wbc->range_cyclic) {\n\t\tstart = mapping->writeback_index; /* Start from prev offset */\n\t\tend = -1;\n\t\tdout(\" cyclic, start at %lu\\n\", start);\n\t} else {\n\t\tstart = wbc->range_start >> PAGE_CACHE_SHIFT;\n\t\tend = wbc->range_end >> PAGE_CACHE_SHIFT;\n\t\tif (wbc->range_start == 0 && wbc->range_end == LLONG_MAX)\n\t\t\trange_whole = 1;\n\t\tshould_loop = 0;\n\t\tdout(\" not cyclic, %lu to %lu\\n\", start, end);\n\t}\n\tindex = start;\n\nretry:\n\t/* find oldest snap context with dirty data */\n\tceph_put_snap_context(snapc);\n\tsnap_size = 0;\n\tsnapc = get_oldest_context(inode, &snap_size);\n\tif (!snapc) {\n\t\t/* hmm, why does writepages get called when there\n\t\t   is no dirty data? */\n\t\tdout(\" no snap context with dirty data?\\n\");\n\t\tgoto out;\n\t}\n\tif (snap_size == 0)\n\t\tsnap_size = i_size_read(inode);\n\tdout(\" oldest snapc is %p seq %lld (%d snaps)\\n\",\n\t     snapc, snapc->seq, snapc->num_snaps);\n\n\tspin_lock(&ci->i_ceph_lock);\n\ttruncate_seq = ci->i_truncate_seq;\n\ttruncate_size = ci->i_truncate_size;\n\tif (!snap_size)\n\t\tsnap_size = i_size_read(inode);\n\tspin_unlock(&ci->i_ceph_lock);\n\n\tif (last_snapc && snapc != last_snapc) {\n\t\t/* if we switched to a newer snapc, restart our scan at the\n\t\t * start of the original file range. */\n\t\tdout(\"  snapc differs from last pass, restarting at %lu\\n\",\n\t\t     index);\n\t\tindex = start;\n\t}\n\tlast_snapc = snapc;\n\n\twhile (!done && index <= end) {\n\t\tunsigned i;\n\t\tint first;\n\t\tpgoff_t next;\n\t\tint pvec_pages, locked_pages;\n\t\tstruct page **pages = NULL;\n\t\tmempool_t *pool = NULL;\t/* Becomes non-null if mempool used */\n\t\tstruct page *page;\n\t\tint want;\n\t\tu64 offset, len;\n\t\tlong writeback_stat;\n\n\t\tnext = 0;\n\t\tlocked_pages = 0;\n\t\tmax_pages = max_pages_ever;\n\nget_more_pages:\n\t\tfirst = -1;\n\t\twant = min(end - index,\n\t\t\t   min((pgoff_t)PAGEVEC_SIZE,\n\t\t\t       max_pages - (pgoff_t)locked_pages) - 1)\n\t\t\t+ 1;\n\t\tpvec_pages = pagevec_lookup_tag(&pvec, mapping, &index,\n\t\t\t\t\t\tPAGECACHE_TAG_DIRTY,\n\t\t\t\t\t\twant);\n\t\tdout(\"pagevec_lookup_tag got %d\\n\", pvec_pages);\n\t\tif (!pvec_pages && !locked_pages)\n\t\t\tbreak;\n\t\tfor (i = 0; i < pvec_pages && locked_pages < max_pages; i++) {\n\t\t\tpage = pvec.pages[i];\n\t\t\tdout(\"? %p idx %lu\\n\", page, page->index);\n\t\t\tif (locked_pages == 0)\n\t\t\t\tlock_page(page);  /* first page */\n\t\t\telse if (!trylock_page(page))\n\t\t\t\tbreak;\n\n\t\t\t/* only dirty pages, or our accounting breaks */\n\t\t\tif (unlikely(!PageDirty(page)) ||\n\t\t\t    unlikely(page->mapping != mapping)) {\n\t\t\t\tdout(\"!dirty or !mapping %p\\n\", page);\n\t\t\t\tunlock_page(page);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!wbc->range_cyclic && page->index > end) {\n\t\t\t\tdout(\"end of range %p\\n\", page);\n\t\t\t\tdone = 1;\n\t\t\t\tunlock_page(page);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (next && (page->index != next)) {\n\t\t\t\tdout(\"not consecutive %p\\n\", page);\n\t\t\t\tunlock_page(page);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (wbc->sync_mode != WB_SYNC_NONE) {\n\t\t\t\tdout(\"waiting on writeback %p\\n\", page);\n\t\t\t\twait_on_page_writeback(page);\n\t\t\t}\n\t\t\tif (page_offset(page) >= snap_size) {\n\t\t\t\tdout(\"%p page eof %llu\\n\", page, snap_size);\n\t\t\t\tdone = 1;\n\t\t\t\tunlock_page(page);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (PageWriteback(page)) {\n\t\t\t\tdout(\"%p under writeback\\n\", page);\n\t\t\t\tunlock_page(page);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* only if matching snap context */\n\t\t\tpgsnapc = page_snap_context(page);\n\t\t\tif (pgsnapc->seq > snapc->seq) {\n\t\t\t\tdout(\"page snapc %p %lld > oldest %p %lld\\n\",\n\t\t\t\t     pgsnapc, pgsnapc->seq, snapc, snapc->seq);\n\t\t\t\tunlock_page(page);\n\t\t\t\tif (!locked_pages)\n\t\t\t\t\tcontinue; /* keep looking for snap */\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (!clear_page_dirty_for_io(page)) {\n\t\t\t\tdout(\"%p !clear_page_dirty_for_io\\n\", page);\n\t\t\t\tunlock_page(page);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * We have something to write.  If this is\n\t\t\t * the first locked page this time through,\n\t\t\t * allocate an osd request and a page array\n\t\t\t * that it will use.\n\t\t\t */\n\t\t\tif (locked_pages == 0) {\n\t\t\t\tBUG_ON(pages);\n\t\t\t\t/* prepare async write request */\n\t\t\t\toffset = (u64)page_offset(page);\n\t\t\t\tlen = wsize;\n\t\t\t\treq = ceph_osdc_new_request(&fsc->client->osdc,\n\t\t\t\t\t\t\t&ci->i_layout, vino,\n\t\t\t\t\t\t\toffset, &len, 0,\n\t\t\t\t\t\t\tdo_sync ? 2 : 1,\n\t\t\t\t\t\t\tCEPH_OSD_OP_WRITE,\n\t\t\t\t\t\t\tCEPH_OSD_FLAG_WRITE |\n\t\t\t\t\t\t\tCEPH_OSD_FLAG_ONDISK,\n\t\t\t\t\t\t\tsnapc, truncate_seq,\n\t\t\t\t\t\t\ttruncate_size, true);\n\t\t\t\tif (IS_ERR(req)) {\n\t\t\t\t\trc = PTR_ERR(req);\n\t\t\t\t\tunlock_page(page);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (do_sync)\n\t\t\t\t\tosd_req_op_init(req, 1, CEPH_OSD_OP_STARTSYNC);\n\n\t\t\t\treq->r_callback = writepages_finish;\n\t\t\t\treq->r_inode = inode;\n\n\t\t\t\tmax_pages = calc_pages_for(0, (u64)len);\n\t\t\t\tpages = kmalloc(max_pages * sizeof (*pages),\n\t\t\t\t\t\tGFP_NOFS);\n\t\t\t\tif (!pages) {\n\t\t\t\t\tpool = fsc->wb_pagevec_pool;\n\t\t\t\t\tpages = mempool_alloc(pool, GFP_NOFS);\n\t\t\t\t\tBUG_ON(!pages);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* note position of first page in pvec */\n\t\t\tif (first < 0)\n\t\t\t\tfirst = i;\n\t\t\tdout(\"%p will write page %p idx %lu\\n\",\n\t\t\t     inode, page, page->index);\n\n\t\t\twriteback_stat =\n\t\t\t       atomic_long_inc_return(&fsc->writeback_count);\n\t\t\tif (writeback_stat > CONGESTION_ON_THRESH(\n\t\t\t\t    fsc->mount_options->congestion_kb)) {\n\t\t\t\tset_bdi_congested(&fsc->backing_dev_info,\n\t\t\t\t\t\t  BLK_RW_ASYNC);\n\t\t\t}\n\n\t\t\tset_page_writeback(page);\n\t\t\tpages[locked_pages] = page;\n\t\t\tlocked_pages++;\n\t\t\tnext = page->index + 1;\n\t\t}\n\n\t\t/* did we get anything? */\n\t\tif (!locked_pages)\n\t\t\tgoto release_pvec_pages;\n\t\tif (i) {\n\t\t\tint j;\n\t\t\tBUG_ON(!locked_pages || first < 0);\n\n\t\t\tif (pvec_pages && i == pvec_pages &&\n\t\t\t    locked_pages < max_pages) {\n\t\t\t\tdout(\"reached end pvec, trying for more\\n\");\n\t\t\t\tpagevec_reinit(&pvec);\n\t\t\t\tgoto get_more_pages;\n\t\t\t}\n\n\t\t\t/* shift unused pages over in the pvec...  we\n\t\t\t * will need to release them below. */\n\t\t\tfor (j = i; j < pvec_pages; j++) {\n\t\t\t\tdout(\" pvec leftover page %p\\n\",\n\t\t\t\t     pvec.pages[j]);\n\t\t\t\tpvec.pages[j-i+first] = pvec.pages[j];\n\t\t\t}\n\t\t\tpvec.nr -= i-first;\n\t\t}\n\n\t\t/* Format the osd request message and submit the write */\n\n\t\toffset = page_offset(pages[0]);\n\t\tlen = min(snap_size - offset,\n\t\t\t  (u64)locked_pages << PAGE_CACHE_SHIFT);\n\t\tdout(\"writepages got %d pages at %llu~%llu\\n\",\n\t\t     locked_pages, offset, len);\n\n\t\tosd_req_op_extent_osd_data_pages(req, 0, pages, len, 0,\n\t\t\t\t\t\t\t!!pool, false);\n\n\t\tpages = NULL;\t/* request message now owns the pages array */\n\t\tpool = NULL;\n\n\t\t/* Update the write op length in case we changed it */\n\n\t\tosd_req_op_extent_update(req, 0, len);\n\n\t\tvino = ceph_vino(inode);\n\t\tceph_osdc_build_request(req, offset, snapc, vino.snap,\n\t\t\t\t\t&inode->i_mtime);\n\n\t\trc = ceph_osdc_start_request(&fsc->client->osdc, req, true);\n\t\tBUG_ON(rc);\n\t\treq = NULL;\n\n\t\t/* continue? */\n\t\tindex = next;\n\t\twbc->nr_to_write -= locked_pages;\n\t\tif (wbc->nr_to_write <= 0)\n\t\t\tdone = 1;\n\nrelease_pvec_pages:\n\t\tdout(\"pagevec_release on %d pages (%p)\\n\", (int)pvec.nr,\n\t\t     pvec.nr ? pvec.pages[0] : NULL);\n\t\tpagevec_release(&pvec);\n\n\t\tif (locked_pages && !done)\n\t\t\tgoto retry;\n\t}\n\n\tif (should_loop && !done) {\n\t\t/* more to do; loop back to beginning of file */\n\t\tdout(\"writepages looping back to beginning of file\\n\");\n\t\tshould_loop = 0;\n\t\tindex = 0;\n\t\tgoto retry;\n\t}\n\n\tif (wbc->range_cyclic || (range_whole && wbc->nr_to_write > 0))\n\t\tmapping->writeback_index = index;\n\nout:\n\tif (req)\n\t\tceph_osdc_put_request(req);\n\tceph_put_snap_context(snapc);\n\tdout(\"writepages done, rc = %d\\n\", rc);\n\treturn rc;\n}",
    "includes": [
      "#include <linux/ceph/osd_client.h>",
      "#include \"cache.h\"",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/slab.h>",
      "#include <linux/writeback.h>\t/* generic_writepages */",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"writepages done, rc = %d\\n\"",
            "rc"
          ],
          "line": 1002
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_put_snap_context",
          "args": [
            "snapc"
          ],
          "line": 1001
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_osdc_put_request",
          "args": [
            "req"
          ],
          "line": 1000
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"writepages looping back to beginning of file\\n\""
          ],
          "line": 989
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pagevec_release",
          "args": [
            "&pvec"
          ],
          "line": 981
        },
        "resolved": true,
        "details": {
          "function_name": "huge_pagevec_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hugetlbfs/inode.c",
          "lines": "84-92",
          "snippet": "static void huge_pagevec_release(struct pagevec *pvec)\n{\n\tint i;\n\n\tfor (i = 0; i < pagevec_count(pvec); ++i)\n\t\tput_page(pvec->pages[i]);\n\n\tpagevec_reinit(pvec);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/migrate.h>",
            "#include <linux/magic.h>",
            "#include <linux/security.h>",
            "#include <linux/statfs.h>",
            "#include <linux/dnotify.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/parser.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/ctype.h>",
            "#include <linux/capability.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kernel.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>\t\t/* remove ASAP */",
            "#include <asm/current.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/migrate.h>\n#include <linux/magic.h>\n#include <linux/security.h>\n#include <linux/statfs.h>\n#include <linux/dnotify.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/parser.h>\n#include <linux/pagevec.h>\n#include <linux/hugetlb.h>\n#include <linux/backing-dev.h>\n#include <linux/ctype.h>\n#include <linux/capability.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/kernel.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\t\t/* remove ASAP */\n#include <asm/current.h>\n#include <linux/thread_info.h>\n#include <linux/module.h>\n\nstatic void huge_pagevec_release(struct pagevec *pvec)\n{\n\tint i;\n\n\tfor (i = 0; i < pagevec_count(pvec); ++i)\n\t\tput_page(pvec->pages[i]);\n\n\tpagevec_reinit(pvec);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"pagevec_release on %d pages (%p)\\n\"",
            "(int)pvec.nr",
            "pvec.nr ? pvec.pages[0] : NULL"
          ],
          "line": 979
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "rc"
          ],
          "line": 969
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_osdc_start_request",
          "args": [
            "&fsc->client->osdc",
            "req",
            "true"
          ],
          "line": 968
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_osdc_build_request",
          "args": [
            "req",
            "offset",
            "snapc",
            "vino.snap",
            "&inode->i_mtime"
          ],
          "line": 965
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_vino",
          "args": [
            "inode"
          ],
          "line": 964
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_vino_to_ino",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.h",
          "lines": "382-389",
          "snippet": "static inline ino_t ceph_vino_to_ino(struct ceph_vino vino)\n{\n#if BITS_PER_LONG == 32\n\treturn ceph_ino_to_ino32(vino.ino);\n#else\n\treturn (ino_t)vino.ino;\n#endif\n}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/ceph/libceph.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/backing-dev.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/ceph/libceph.h>\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n#include <linux/completion.h>\n#include <linux/backing-dev.h>\n#include <asm/unaligned.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline ino_t ceph_vino_to_ino(struct ceph_vino vino)\n{\n#if BITS_PER_LONG == 32\n\treturn ceph_ino_to_ino32(vino.ino);\n#else\n\treturn (ino_t)vino.ino;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "osd_req_op_extent_update",
          "args": [
            "req",
            "0",
            "len"
          ],
          "line": 962
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "osd_req_op_extent_osd_data_pages",
          "args": [
            "req",
            "0",
            "pages",
            "len",
            "0",
            "!!pool",
            "false"
          ],
          "line": 954
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"writepages got %d pages at %llu~%llu\\n\"",
            "locked_pages",
            "offset",
            "len"
          ],
          "line": 951
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "snap_size - offset",
            "(u64)locked_pages << PAGE_CACHE_SHIFT"
          ],
          "line": 949
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_adjust_min_caps",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
          "lines": "143-149",
          "snippet": "void ceph_adjust_min_caps(struct ceph_mds_client *mdsc, int delta)\n{\n\tspin_lock(&mdsc->caps_list_lock);\n\tmdsc->caps_min_count += delta;\n\tBUG_ON(mdsc->caps_min_count < 0);\n\tspin_unlock(&mdsc->caps_list_lock);\n}",
          "includes": [
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nvoid ceph_adjust_min_caps(struct ceph_mds_client *mdsc, int delta)\n{\n\tspin_lock(&mdsc->caps_list_lock);\n\tmdsc->caps_min_count += delta;\n\tBUG_ON(mdsc->caps_min_count < 0);\n\tspin_unlock(&mdsc->caps_list_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_offset",
          "args": [
            "pages[0]"
          ],
          "line": 948
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\" pvec leftover page %p\\n\"",
            "pvec.pages[j]"
          ],
          "line": 939
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pagevec_reinit",
          "args": [
            "&pvec"
          ],
          "line": 932
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"reached end pvec, trying for more\\n\""
          ],
          "line": 931
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!locked_pages || first < 0"
          ],
          "line": 927
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_page_writeback",
          "args": [
            "page"
          ],
          "line": 916
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_set_page_writeback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
          "lines": "265-277",
          "snippet": "static void nfs_set_page_writeback(struct page *page)\n{\n\tstruct nfs_server *nfss = NFS_SERVER(page_file_mapping(page)->host);\n\tint ret = test_set_page_writeback(page);\n\n\tWARN_ON_ONCE(ret != 0);\n\n\tif (atomic_long_inc_return(&nfss->writeback) >\n\t\t\tNFS_CONGESTION_ON_THRESH) {\n\t\tset_bdi_congested(&nfss->backing_dev_info,\n\t\t\t\t\tBLK_RW_ASYNC);\n\t}\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define NFS_CONGESTION_ON_THRESH \t(nfs_congestion_kb >> (PAGE_SHIFT-10))"
          ],
          "globals_used": [
            "static struct nfs_page *\nnfs_page_search_commits_for_head_request_locked(struct nfs_inode *nfsi,\n\t\t\t\t\t\tstruct page *page);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\n#define NFS_CONGESTION_ON_THRESH \t(nfs_congestion_kb >> (PAGE_SHIFT-10))\n\nstatic struct nfs_page *\nnfs_page_search_commits_for_head_request_locked(struct nfs_inode *nfsi,\n\t\t\t\t\t\tstruct page *page);\n\nstatic void nfs_set_page_writeback(struct page *page)\n{\n\tstruct nfs_server *nfss = NFS_SERVER(page_file_mapping(page)->host);\n\tint ret = test_set_page_writeback(page);\n\n\tWARN_ON_ONCE(ret != 0);\n\n\tif (atomic_long_inc_return(&nfss->writeback) >\n\t\t\tNFS_CONGESTION_ON_THRESH) {\n\t\tset_bdi_congested(&nfss->backing_dev_info,\n\t\t\t\t\tBLK_RW_ASYNC);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_bdi_congested",
          "args": [
            "&fsc->backing_dev_info",
            "BLK_RW_ASYNC"
          ],
          "line": 912
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CONGESTION_ON_THRESH",
          "args": [
            "fsc->mount_options->congestion_kb"
          ],
          "line": 910
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_long_inc_return",
          "args": [
            "&fsc->writeback_count"
          ],
          "line": 909
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"%p will write page %p idx %lu\\n\"",
            "inode",
            "page",
            "page->index"
          ],
          "line": 905
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!pages"
          ],
          "line": 898
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mempool_alloc",
          "args": [
            "pool",
            "GFP_NOFS"
          ],
          "line": 897
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "max_pages * sizeof (*pages)",
            "GFP_NOFS"
          ],
          "line": 893
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "calc_pages_for",
          "args": [
            "0",
            "(u64)len"
          ],
          "line": 892
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "osd_req_op_init",
          "args": [
            "req",
            "1",
            "CEPH_OSD_OP_STARTSYNC"
          ],
          "line": 887
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 882
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "req"
          ],
          "line": 881
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "req"
          ],
          "line": 880
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_osdc_new_request",
          "args": [
            "&fsc->client->osdc",
            "&ci->i_layout",
            "vino",
            "offset",
            "&len",
            "0",
            "do_sync ? 2 : 1",
            "CEPH_OSD_OP_WRITE",
            "CEPH_OSD_FLAG_WRITE |\n\t\t\t\t\t\t\tCEPH_OSD_FLAG_ONDISK",
            "snapc",
            "truncate_seq",
            "truncate_size",
            "true"
          ],
          "line": 871
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_offset",
          "args": [
            "page"
          ],
          "line": 869
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "pages"
          ],
          "line": 867
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"%p !clear_page_dirty_for_io\\n\"",
            "page"
          ],
          "line": 855
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_page_dirty_for_io",
          "args": [
            "page"
          ],
          "line": 854
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"page snapc %p %lld > oldest %p %lld\\n\"",
            "pgsnapc",
            "pgsnapc->seq",
            "snapc",
            "snapc->seq"
          ],
          "line": 846
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_snap_context",
          "args": [
            "page"
          ],
          "line": 844
        },
        "resolved": true,
        "details": {
          "function_name": "page_snap_context",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/addr.c",
          "lines": "58-63",
          "snippet": "static inline struct ceph_snap_context *page_snap_context(struct page *page)\n{\n\tif (PagePrivate(page))\n\t\treturn (void *)page->private;\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/ceph/osd_client.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>\t/* generic_writepages */",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/osd_client.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/task_io_accounting_ops.h>\n#include <linux/pagevec.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\t/* generic_writepages */\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/backing-dev.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline struct ceph_snap_context *page_snap_context(struct page *page)\n{\n\tif (PagePrivate(page))\n\t\treturn (void *)page->private;\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"%p under writeback\\n\"",
            "page"
          ],
          "line": 838
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageWriteback",
          "args": [
            "page"
          ],
          "line": 837
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"%p page eof %llu\\n\"",
            "page",
            "snap_size"
          ],
          "line": 832
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_offset",
          "args": [
            "page"
          ],
          "line": 831
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_on_page_writeback",
          "args": [
            "page"
          ],
          "line": 829
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"waiting on writeback %p\\n\"",
            "page"
          ],
          "line": 828
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"not consecutive %p\\n\"",
            "page"
          ],
          "line": 823
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"end of range %p\\n\"",
            "page"
          ],
          "line": 817
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"!dirty or !mapping %p\\n\"",
            "page"
          ],
          "line": 812
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "page->mapping != mapping"
          ],
          "line": 811
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!PageDirty(page)"
          ],
          "line": 810
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageDirty",
          "args": [
            "page"
          ],
          "line": 810
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trylock_page",
          "args": [
            "page"
          ],
          "line": 806
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"? %p idx %lu\\n\"",
            "page",
            "page->index"
          ],
          "line": 803
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"pagevec_lookup_tag got %d\\n\"",
            "pvec_pages"
          ],
          "line": 798
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pagevec_lookup_tag",
          "args": [
            "&pvec",
            "mapping",
            "&index",
            "PAGECACHE_TAG_DIRTY",
            "want"
          ],
          "line": 795
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"  snapc differs from last pass, restarting at %lu\\n\"",
            "index"
          ],
          "line": 767
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ci->i_ceph_lock"
          ],
          "line": 762
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 761
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ci->i_ceph_lock"
          ],
          "line": 757
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\" oldest snapc is %p seq %lld (%d snaps)\\n\"",
            "snapc",
            "snapc->seq",
            "snapc->num_snaps"
          ],
          "line": 754
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 753
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\" no snap context with dirty data?\\n\""
          ],
          "line": 749
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_oldest_context",
          "args": [
            "inode",
            "&snap_size"
          ],
          "line": 745
        },
        "resolved": true,
        "details": {
          "function_name": "get_oldest_context",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/addr.c",
          "lines": "438-463",
          "snippet": "static struct ceph_snap_context *get_oldest_context(struct inode *inode,\n\t\t\t\t\t\t    u64 *snap_size)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tstruct ceph_snap_context *snapc = NULL;\n\tstruct ceph_cap_snap *capsnap = NULL;\n\n\tspin_lock(&ci->i_ceph_lock);\n\tlist_for_each_entry(capsnap, &ci->i_cap_snaps, ci_item) {\n\t\tdout(\" cap_snap %p snapc %p has %d dirty pages\\n\", capsnap,\n\t\t     capsnap->context, capsnap->dirty_pages);\n\t\tif (capsnap->dirty_pages) {\n\t\t\tsnapc = ceph_get_snap_context(capsnap->context);\n\t\t\tif (snap_size)\n\t\t\t\t*snap_size = capsnap->size;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!snapc && ci->i_wrbuffer_ref_head) {\n\t\tsnapc = ceph_get_snap_context(ci->i_head_snapc);\n\t\tdout(\" head snapc %p has %d dirty pages\\n\",\n\t\t     snapc, ci->i_wrbuffer_ref_head);\n\t}\n\tspin_unlock(&ci->i_ceph_lock);\n\treturn snapc;\n}",
          "includes": [
            "#include <linux/ceph/osd_client.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>\t/* generic_writepages */",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/osd_client.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/task_io_accounting_ops.h>\n#include <linux/pagevec.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\t/* generic_writepages */\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/backing-dev.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic struct ceph_snap_context *get_oldest_context(struct inode *inode,\n\t\t\t\t\t\t    u64 *snap_size)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tstruct ceph_snap_context *snapc = NULL;\n\tstruct ceph_cap_snap *capsnap = NULL;\n\n\tspin_lock(&ci->i_ceph_lock);\n\tlist_for_each_entry(capsnap, &ci->i_cap_snaps, ci_item) {\n\t\tdout(\" cap_snap %p snapc %p has %d dirty pages\\n\", capsnap,\n\t\t     capsnap->context, capsnap->dirty_pages);\n\t\tif (capsnap->dirty_pages) {\n\t\t\tsnapc = ceph_get_snap_context(capsnap->context);\n\t\t\tif (snap_size)\n\t\t\t\t*snap_size = capsnap->size;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!snapc && ci->i_wrbuffer_ref_head) {\n\t\tsnapc = ceph_get_snap_context(ci->i_head_snapc);\n\t\tdout(\" head snapc %p has %d dirty pages\\n\",\n\t\t     snapc, ci->i_wrbuffer_ref_head);\n\t}\n\tspin_unlock(&ci->i_ceph_lock);\n\treturn snapc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_put_snap_context",
          "args": [
            "snapc"
          ],
          "line": 743
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\" not cyclic, %lu to %lu\\n\"",
            "start",
            "end"
          ],
          "line": 737
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\" cyclic, start at %lu\\n\"",
            "start"
          ],
          "line": 730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pagevec_init",
          "args": [
            "&pvec",
            "0"
          ],
          "line": 724
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"writepage_start %p on forced umount\\n\"",
            "inode"
          ],
          "line": 715
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"writepages_start %p dosync=%d (mode=%s)\\n\"",
            "inode",
            "do_sync",
            "wbc->sync_mode == WB_SYNC_NONE ? \"NONE\" :\n\t     (wbc->sync_mode == WB_SYNC_ALL ? \"ALL\" : \"HOLD\")"
          ],
          "line": 709
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_caps_revoking",
          "args": [
            "ci",
            "CEPH_CAP_FILE_BUFFER"
          ],
          "line": 707
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_caps_revoking",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
          "lines": "816-827",
          "snippet": "int ceph_caps_revoking(struct ceph_inode_info *ci, int mask)\n{\n\tstruct inode *inode = &ci->vfs_inode;\n\tint ret;\n\n\tspin_lock(&ci->i_ceph_lock);\n\tret = __ceph_caps_revoking_other(ci, NULL, mask);\n\tspin_unlock(&ci->i_ceph_lock);\n\tdout(\"ceph_caps_revoking %p %s = %d\\n\", inode,\n\t     ceph_cap_string(mask), ret);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nint ceph_caps_revoking(struct ceph_inode_info *ci, int mask)\n{\n\tstruct inode *inode = &ci->vfs_inode;\n\tint ret;\n\n\tspin_lock(&ci->i_ceph_lock);\n\tret = __ceph_caps_revoking_other(ci, NULL, mask);\n\tspin_unlock(&ci->i_ceph_lock);\n\tdout(\"ceph_caps_revoking %p %s = %d\\n\", inode,\n\t     ceph_cap_string(mask), ret);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_inode_to_client",
          "args": [
            "inode"
          ],
          "line": 685
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_inode_to_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.h",
          "lines": "347-350",
          "snippet": "static inline struct ceph_fs_client *ceph_inode_to_client(struct inode *inode)\n{\n\treturn (struct ceph_fs_client *)inode->i_sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/ceph/libceph.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/backing-dev.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/ceph/libceph.h>\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n#include <linux/completion.h>\n#include <linux/backing-dev.h>\n#include <asm/unaligned.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline struct ceph_fs_client *ceph_inode_to_client(struct inode *inode)\n{\n\treturn (struct ceph_fs_client *)inode->i_sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/ceph/osd_client.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/task_io_accounting_ops.h>\n#include <linux/pagevec.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\t/* generic_writepages */\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/backing-dev.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic int ceph_writepages_start(struct address_space *mapping,\n\t\t\t\t struct writeback_control *wbc)\n{\n\tstruct inode *inode = mapping->host;\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tstruct ceph_fs_client *fsc = ceph_inode_to_client(inode);\n\tstruct ceph_vino vino = ceph_vino(inode);\n\tpgoff_t index, start, end;\n\tint range_whole = 0;\n\tint should_loop = 1;\n\tpgoff_t max_pages = 0, max_pages_ever = 0;\n\tstruct ceph_snap_context *snapc = NULL, *last_snapc = NULL, *pgsnapc;\n\tstruct pagevec pvec;\n\tint done = 0;\n\tint rc = 0;\n\tunsigned wsize = 1 << inode->i_blkbits;\n\tstruct ceph_osd_request *req = NULL;\n\tint do_sync = 0;\n\tu64 truncate_size, snap_size;\n\tu32 truncate_seq;\n\n\t/*\n\t * Include a 'sync' in the OSD request if this is a data\n\t * integrity write (e.g., O_SYNC write or fsync()), or if our\n\t * cap is being revoked.\n\t */\n\tif ((wbc->sync_mode == WB_SYNC_ALL) ||\n\t\tceph_caps_revoking(ci, CEPH_CAP_FILE_BUFFER))\n\t\tdo_sync = 1;\n\tdout(\"writepages_start %p dosync=%d (mode=%s)\\n\",\n\t     inode, do_sync,\n\t     wbc->sync_mode == WB_SYNC_NONE ? \"NONE\" :\n\t     (wbc->sync_mode == WB_SYNC_ALL ? \"ALL\" : \"HOLD\"));\n\n\tif (fsc->mount_state == CEPH_MOUNT_SHUTDOWN) {\n\t\tpr_warn(\"writepage_start %p on forced umount\\n\", inode);\n\t\treturn -EIO; /* we're in a forced umount, don't write! */\n\t}\n\tif (fsc->mount_options->wsize && fsc->mount_options->wsize < wsize)\n\t\twsize = fsc->mount_options->wsize;\n\tif (wsize < PAGE_CACHE_SIZE)\n\t\twsize = PAGE_CACHE_SIZE;\n\tmax_pages_ever = wsize >> PAGE_CACHE_SHIFT;\n\n\tpagevec_init(&pvec, 0);\n\n\t/* where to start/end? */\n\tif (wbc->range_cyclic) {\n\t\tstart = mapping->writeback_index; /* Start from prev offset */\n\t\tend = -1;\n\t\tdout(\" cyclic, start at %lu\\n\", start);\n\t} else {\n\t\tstart = wbc->range_start >> PAGE_CACHE_SHIFT;\n\t\tend = wbc->range_end >> PAGE_CACHE_SHIFT;\n\t\tif (wbc->range_start == 0 && wbc->range_end == LLONG_MAX)\n\t\t\trange_whole = 1;\n\t\tshould_loop = 0;\n\t\tdout(\" not cyclic, %lu to %lu\\n\", start, end);\n\t}\n\tindex = start;\n\nretry:\n\t/* find oldest snap context with dirty data */\n\tceph_put_snap_context(snapc);\n\tsnap_size = 0;\n\tsnapc = get_oldest_context(inode, &snap_size);\n\tif (!snapc) {\n\t\t/* hmm, why does writepages get called when there\n\t\t   is no dirty data? */\n\t\tdout(\" no snap context with dirty data?\\n\");\n\t\tgoto out;\n\t}\n\tif (snap_size == 0)\n\t\tsnap_size = i_size_read(inode);\n\tdout(\" oldest snapc is %p seq %lld (%d snaps)\\n\",\n\t     snapc, snapc->seq, snapc->num_snaps);\n\n\tspin_lock(&ci->i_ceph_lock);\n\ttruncate_seq = ci->i_truncate_seq;\n\ttruncate_size = ci->i_truncate_size;\n\tif (!snap_size)\n\t\tsnap_size = i_size_read(inode);\n\tspin_unlock(&ci->i_ceph_lock);\n\n\tif (last_snapc && snapc != last_snapc) {\n\t\t/* if we switched to a newer snapc, restart our scan at the\n\t\t * start of the original file range. */\n\t\tdout(\"  snapc differs from last pass, restarting at %lu\\n\",\n\t\t     index);\n\t\tindex = start;\n\t}\n\tlast_snapc = snapc;\n\n\twhile (!done && index <= end) {\n\t\tunsigned i;\n\t\tint first;\n\t\tpgoff_t next;\n\t\tint pvec_pages, locked_pages;\n\t\tstruct page **pages = NULL;\n\t\tmempool_t *pool = NULL;\t/* Becomes non-null if mempool used */\n\t\tstruct page *page;\n\t\tint want;\n\t\tu64 offset, len;\n\t\tlong writeback_stat;\n\n\t\tnext = 0;\n\t\tlocked_pages = 0;\n\t\tmax_pages = max_pages_ever;\n\nget_more_pages:\n\t\tfirst = -1;\n\t\twant = min(end - index,\n\t\t\t   min((pgoff_t)PAGEVEC_SIZE,\n\t\t\t       max_pages - (pgoff_t)locked_pages) - 1)\n\t\t\t+ 1;\n\t\tpvec_pages = pagevec_lookup_tag(&pvec, mapping, &index,\n\t\t\t\t\t\tPAGECACHE_TAG_DIRTY,\n\t\t\t\t\t\twant);\n\t\tdout(\"pagevec_lookup_tag got %d\\n\", pvec_pages);\n\t\tif (!pvec_pages && !locked_pages)\n\t\t\tbreak;\n\t\tfor (i = 0; i < pvec_pages && locked_pages < max_pages; i++) {\n\t\t\tpage = pvec.pages[i];\n\t\t\tdout(\"? %p idx %lu\\n\", page, page->index);\n\t\t\tif (locked_pages == 0)\n\t\t\t\tlock_page(page);  /* first page */\n\t\t\telse if (!trylock_page(page))\n\t\t\t\tbreak;\n\n\t\t\t/* only dirty pages, or our accounting breaks */\n\t\t\tif (unlikely(!PageDirty(page)) ||\n\t\t\t    unlikely(page->mapping != mapping)) {\n\t\t\t\tdout(\"!dirty or !mapping %p\\n\", page);\n\t\t\t\tunlock_page(page);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!wbc->range_cyclic && page->index > end) {\n\t\t\t\tdout(\"end of range %p\\n\", page);\n\t\t\t\tdone = 1;\n\t\t\t\tunlock_page(page);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (next && (page->index != next)) {\n\t\t\t\tdout(\"not consecutive %p\\n\", page);\n\t\t\t\tunlock_page(page);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (wbc->sync_mode != WB_SYNC_NONE) {\n\t\t\t\tdout(\"waiting on writeback %p\\n\", page);\n\t\t\t\twait_on_page_writeback(page);\n\t\t\t}\n\t\t\tif (page_offset(page) >= snap_size) {\n\t\t\t\tdout(\"%p page eof %llu\\n\", page, snap_size);\n\t\t\t\tdone = 1;\n\t\t\t\tunlock_page(page);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (PageWriteback(page)) {\n\t\t\t\tdout(\"%p under writeback\\n\", page);\n\t\t\t\tunlock_page(page);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* only if matching snap context */\n\t\t\tpgsnapc = page_snap_context(page);\n\t\t\tif (pgsnapc->seq > snapc->seq) {\n\t\t\t\tdout(\"page snapc %p %lld > oldest %p %lld\\n\",\n\t\t\t\t     pgsnapc, pgsnapc->seq, snapc, snapc->seq);\n\t\t\t\tunlock_page(page);\n\t\t\t\tif (!locked_pages)\n\t\t\t\t\tcontinue; /* keep looking for snap */\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (!clear_page_dirty_for_io(page)) {\n\t\t\t\tdout(\"%p !clear_page_dirty_for_io\\n\", page);\n\t\t\t\tunlock_page(page);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * We have something to write.  If this is\n\t\t\t * the first locked page this time through,\n\t\t\t * allocate an osd request and a page array\n\t\t\t * that it will use.\n\t\t\t */\n\t\t\tif (locked_pages == 0) {\n\t\t\t\tBUG_ON(pages);\n\t\t\t\t/* prepare async write request */\n\t\t\t\toffset = (u64)page_offset(page);\n\t\t\t\tlen = wsize;\n\t\t\t\treq = ceph_osdc_new_request(&fsc->client->osdc,\n\t\t\t\t\t\t\t&ci->i_layout, vino,\n\t\t\t\t\t\t\toffset, &len, 0,\n\t\t\t\t\t\t\tdo_sync ? 2 : 1,\n\t\t\t\t\t\t\tCEPH_OSD_OP_WRITE,\n\t\t\t\t\t\t\tCEPH_OSD_FLAG_WRITE |\n\t\t\t\t\t\t\tCEPH_OSD_FLAG_ONDISK,\n\t\t\t\t\t\t\tsnapc, truncate_seq,\n\t\t\t\t\t\t\ttruncate_size, true);\n\t\t\t\tif (IS_ERR(req)) {\n\t\t\t\t\trc = PTR_ERR(req);\n\t\t\t\t\tunlock_page(page);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (do_sync)\n\t\t\t\t\tosd_req_op_init(req, 1, CEPH_OSD_OP_STARTSYNC);\n\n\t\t\t\treq->r_callback = writepages_finish;\n\t\t\t\treq->r_inode = inode;\n\n\t\t\t\tmax_pages = calc_pages_for(0, (u64)len);\n\t\t\t\tpages = kmalloc(max_pages * sizeof (*pages),\n\t\t\t\t\t\tGFP_NOFS);\n\t\t\t\tif (!pages) {\n\t\t\t\t\tpool = fsc->wb_pagevec_pool;\n\t\t\t\t\tpages = mempool_alloc(pool, GFP_NOFS);\n\t\t\t\t\tBUG_ON(!pages);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* note position of first page in pvec */\n\t\t\tif (first < 0)\n\t\t\t\tfirst = i;\n\t\t\tdout(\"%p will write page %p idx %lu\\n\",\n\t\t\t     inode, page, page->index);\n\n\t\t\twriteback_stat =\n\t\t\t       atomic_long_inc_return(&fsc->writeback_count);\n\t\t\tif (writeback_stat > CONGESTION_ON_THRESH(\n\t\t\t\t    fsc->mount_options->congestion_kb)) {\n\t\t\t\tset_bdi_congested(&fsc->backing_dev_info,\n\t\t\t\t\t\t  BLK_RW_ASYNC);\n\t\t\t}\n\n\t\t\tset_page_writeback(page);\n\t\t\tpages[locked_pages] = page;\n\t\t\tlocked_pages++;\n\t\t\tnext = page->index + 1;\n\t\t}\n\n\t\t/* did we get anything? */\n\t\tif (!locked_pages)\n\t\t\tgoto release_pvec_pages;\n\t\tif (i) {\n\t\t\tint j;\n\t\t\tBUG_ON(!locked_pages || first < 0);\n\n\t\t\tif (pvec_pages && i == pvec_pages &&\n\t\t\t    locked_pages < max_pages) {\n\t\t\t\tdout(\"reached end pvec, trying for more\\n\");\n\t\t\t\tpagevec_reinit(&pvec);\n\t\t\t\tgoto get_more_pages;\n\t\t\t}\n\n\t\t\t/* shift unused pages over in the pvec...  we\n\t\t\t * will need to release them below. */\n\t\t\tfor (j = i; j < pvec_pages; j++) {\n\t\t\t\tdout(\" pvec leftover page %p\\n\",\n\t\t\t\t     pvec.pages[j]);\n\t\t\t\tpvec.pages[j-i+first] = pvec.pages[j];\n\t\t\t}\n\t\t\tpvec.nr -= i-first;\n\t\t}\n\n\t\t/* Format the osd request message and submit the write */\n\n\t\toffset = page_offset(pages[0]);\n\t\tlen = min(snap_size - offset,\n\t\t\t  (u64)locked_pages << PAGE_CACHE_SHIFT);\n\t\tdout(\"writepages got %d pages at %llu~%llu\\n\",\n\t\t     locked_pages, offset, len);\n\n\t\tosd_req_op_extent_osd_data_pages(req, 0, pages, len, 0,\n\t\t\t\t\t\t\t!!pool, false);\n\n\t\tpages = NULL;\t/* request message now owns the pages array */\n\t\tpool = NULL;\n\n\t\t/* Update the write op length in case we changed it */\n\n\t\tosd_req_op_extent_update(req, 0, len);\n\n\t\tvino = ceph_vino(inode);\n\t\tceph_osdc_build_request(req, offset, snapc, vino.snap,\n\t\t\t\t\t&inode->i_mtime);\n\n\t\trc = ceph_osdc_start_request(&fsc->client->osdc, req, true);\n\t\tBUG_ON(rc);\n\t\treq = NULL;\n\n\t\t/* continue? */\n\t\tindex = next;\n\t\twbc->nr_to_write -= locked_pages;\n\t\tif (wbc->nr_to_write <= 0)\n\t\t\tdone = 1;\n\nrelease_pvec_pages:\n\t\tdout(\"pagevec_release on %d pages (%p)\\n\", (int)pvec.nr,\n\t\t     pvec.nr ? pvec.pages[0] : NULL);\n\t\tpagevec_release(&pvec);\n\n\t\tif (locked_pages && !done)\n\t\t\tgoto retry;\n\t}\n\n\tif (should_loop && !done) {\n\t\t/* more to do; loop back to beginning of file */\n\t\tdout(\"writepages looping back to beginning of file\\n\");\n\t\tshould_loop = 0;\n\t\tindex = 0;\n\t\tgoto retry;\n\t}\n\n\tif (wbc->range_cyclic || (range_whole && wbc->nr_to_write > 0))\n\t\tmapping->writeback_index = index;\n\nout:\n\tif (req)\n\t\tceph_osdc_put_request(req);\n\tceph_put_snap_context(snapc);\n\tdout(\"writepages done, rc = %d\\n\", rc);\n\treturn rc;\n}"
  },
  {
    "function_name": "writepages_finish",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/addr.c",
    "lines": "598-675",
    "snippet": "static void writepages_finish(struct ceph_osd_request *req,\n\t\t\t      struct ceph_msg *msg)\n{\n\tstruct inode *inode = req->r_inode;\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tstruct ceph_osd_data *osd_data;\n\tunsigned wrote;\n\tstruct page *page;\n\tint num_pages;\n\tint i;\n\tstruct ceph_snap_context *snapc = req->r_snapc;\n\tstruct address_space *mapping = inode->i_mapping;\n\tint rc = req->r_result;\n\tu64 bytes = req->r_ops[0].extent.length;\n\tstruct ceph_fs_client *fsc = ceph_inode_to_client(inode);\n\tlong writeback_stat;\n\tunsigned issued = ceph_caps_issued(ci);\n\n\tosd_data = osd_req_op_extent_osd_data(req, 0);\n\tBUG_ON(osd_data->type != CEPH_OSD_DATA_TYPE_PAGES);\n\tnum_pages = calc_pages_for((u64)osd_data->alignment,\n\t\t\t\t\t(u64)osd_data->length);\n\tif (rc >= 0) {\n\t\t/*\n\t\t * Assume we wrote the pages we originally sent.  The\n\t\t * osd might reply with fewer pages if our writeback\n\t\t * raced with a truncation and was adjusted at the osd,\n\t\t * so don't believe the reply.\n\t\t */\n\t\twrote = num_pages;\n\t} else {\n\t\twrote = 0;\n\t\tmapping_set_error(mapping, rc);\n\t}\n\tdout(\"writepages_finish %p rc %d bytes %llu wrote %d (pages)\\n\",\n\t     inode, rc, bytes, wrote);\n\n\t/* clean all pages */\n\tfor (i = 0; i < num_pages; i++) {\n\t\tpage = osd_data->pages[i];\n\t\tBUG_ON(!page);\n\t\tWARN_ON(!PageUptodate(page));\n\n\t\twriteback_stat =\n\t\t\tatomic_long_dec_return(&fsc->writeback_count);\n\t\tif (writeback_stat <\n\t\t    CONGESTION_OFF_THRESH(fsc->mount_options->congestion_kb))\n\t\t\tclear_bdi_congested(&fsc->backing_dev_info,\n\t\t\t\t\t    BLK_RW_ASYNC);\n\n\t\tceph_put_snap_context(page_snap_context(page));\n\t\tpage->private = 0;\n\t\tClearPagePrivate(page);\n\t\tdout(\"unlocking %d %p\\n\", i, page);\n\t\tend_page_writeback(page);\n\n\t\t/*\n\t\t * We lost the cache cap, need to truncate the page before\n\t\t * it is unlocked, otherwise we'd truncate it later in the\n\t\t * page truncation thread, possibly losing some data that\n\t\t * raced its way in\n\t\t */\n\t\tif ((issued & (CEPH_CAP_FILE_CACHE|CEPH_CAP_FILE_LAZYIO)) == 0)\n\t\t\tgeneric_error_remove_page(inode->i_mapping, page);\n\n\t\tunlock_page(page);\n\t}\n\tdout(\"%p wrote+cleaned %d pages\\n\", inode, wrote);\n\tceph_put_wrbuffer_cap_refs(ci, num_pages, snapc);\n\n\tceph_release_pages(osd_data->pages, num_pages);\n\tif (osd_data->pages_from_pool)\n\t\tmempool_free(osd_data->pages,\n\t\t\t     ceph_sb_to_client(inode->i_sb)->wb_pagevec_pool);\n\telse\n\t\tkfree(osd_data->pages);\n\tceph_osdc_put_request(req);\n}",
    "includes": [
      "#include <linux/ceph/osd_client.h>",
      "#include \"cache.h\"",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/slab.h>",
      "#include <linux/writeback.h>\t/* generic_writepages */",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ceph_osdc_put_request",
          "args": [
            "req"
          ],
          "line": 674
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "osd_data->pages"
          ],
          "line": 673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mempool_free",
          "args": [
            "osd_data->pages",
            "ceph_sb_to_client(inode->i_sb)->wb_pagevec_pool"
          ],
          "line": 670
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_sb_to_client",
          "args": [
            "inode->i_sb"
          ],
          "line": 671
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_sb_to_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.h",
          "lines": "352-355",
          "snippet": "static inline struct ceph_fs_client *ceph_sb_to_client(struct super_block *sb)\n{\n\treturn (struct ceph_fs_client *)sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/ceph/libceph.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/backing-dev.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/ceph/libceph.h>\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n#include <linux/completion.h>\n#include <linux/backing-dev.h>\n#include <asm/unaligned.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline struct ceph_fs_client *ceph_sb_to_client(struct super_block *sb)\n{\n\treturn (struct ceph_fs_client *)sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_release_pages",
          "args": [
            "osd_data->pages",
            "num_pages"
          ],
          "line": 668
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_release_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/addr.c",
          "lines": "579-590",
          "snippet": "static void ceph_release_pages(struct page **pages, int num)\n{\n\tstruct pagevec pvec;\n\tint i;\n\n\tpagevec_init(&pvec, 0);\n\tfor (i = 0; i < num; i++) {\n\t\tif (pagevec_add(&pvec, pages[i]) == 0)\n\t\t\tpagevec_release(&pvec);\n\t}\n\tpagevec_release(&pvec);\n}",
          "includes": [
            "#include <linux/ceph/osd_client.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>\t/* generic_writepages */",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/osd_client.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/task_io_accounting_ops.h>\n#include <linux/pagevec.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\t/* generic_writepages */\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/backing-dev.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void ceph_release_pages(struct page **pages, int num)\n{\n\tstruct pagevec pvec;\n\tint i;\n\n\tpagevec_init(&pvec, 0);\n\tfor (i = 0; i < num; i++) {\n\t\tif (pagevec_add(&pvec, pages[i]) == 0)\n\t\t\tpagevec_release(&pvec);\n\t}\n\tpagevec_release(&pvec);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_put_wrbuffer_cap_refs",
          "args": [
            "ci",
            "num_pages",
            "snapc"
          ],
          "line": 666
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_put_wrbuffer_cap_refs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
          "lines": "2335-2405",
          "snippet": "void ceph_put_wrbuffer_cap_refs(struct ceph_inode_info *ci, int nr,\n\t\t\t\tstruct ceph_snap_context *snapc)\n{\n\tstruct inode *inode = &ci->vfs_inode;\n\tint last = 0;\n\tint complete_capsnap = 0;\n\tint drop_capsnap = 0;\n\tint found = 0;\n\tstruct ceph_cap_snap *capsnap = NULL;\n\n\tspin_lock(&ci->i_ceph_lock);\n\tci->i_wrbuffer_ref -= nr;\n\tlast = !ci->i_wrbuffer_ref;\n\n\tif (ci->i_head_snapc == snapc) {\n\t\tci->i_wrbuffer_ref_head -= nr;\n\t\tif (ci->i_wrbuffer_ref_head == 0 &&\n\t\t    ci->i_dirty_caps == 0 && ci->i_flushing_caps == 0) {\n\t\t\tBUG_ON(!ci->i_head_snapc);\n\t\t\tceph_put_snap_context(ci->i_head_snapc);\n\t\t\tci->i_head_snapc = NULL;\n\t\t}\n\t\tdout(\"put_wrbuffer_cap_refs on %p head %d/%d -> %d/%d %s\\n\",\n\t\t     inode,\n\t\t     ci->i_wrbuffer_ref+nr, ci->i_wrbuffer_ref_head+nr,\n\t\t     ci->i_wrbuffer_ref, ci->i_wrbuffer_ref_head,\n\t\t     last ? \" LAST\" : \"\");\n\t} else {\n\t\tlist_for_each_entry(capsnap, &ci->i_cap_snaps, ci_item) {\n\t\t\tif (capsnap->context == snapc) {\n\t\t\t\tfound = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tBUG_ON(!found);\n\t\tcapsnap->dirty_pages -= nr;\n\t\tif (capsnap->dirty_pages == 0) {\n\t\t\tcomplete_capsnap = 1;\n\t\t\tif (capsnap->dirty == 0)\n\t\t\t\t/* cap writeback completed before we created\n\t\t\t\t * the cap_snap; no FLUSHSNAP is needed */\n\t\t\t\tdrop_capsnap = 1;\n\t\t}\n\t\tdout(\"put_wrbuffer_cap_refs on %p cap_snap %p \"\n\t\t     \" snap %lld %d/%d -> %d/%d %s%s%s\\n\",\n\t\t     inode, capsnap, capsnap->context->seq,\n\t\t     ci->i_wrbuffer_ref+nr, capsnap->dirty_pages + nr,\n\t\t     ci->i_wrbuffer_ref, capsnap->dirty_pages,\n\t\t     last ? \" (wrbuffer last)\" : \"\",\n\t\t     complete_capsnap ? \" (complete capsnap)\" : \"\",\n\t\t     drop_capsnap ? \" (drop capsnap)\" : \"\");\n\t\tif (drop_capsnap) {\n\t\t\tceph_put_snap_context(capsnap->context);\n\t\t\tlist_del(&capsnap->ci_item);\n\t\t\tlist_del(&capsnap->flushing_item);\n\t\t\tceph_put_cap_snap(capsnap);\n\t\t}\n\t}\n\n\tspin_unlock(&ci->i_ceph_lock);\n\n\tif (last) {\n\t\tceph_check_caps(ci, CHECK_CAPS_AUTHONLY, NULL);\n\t\tiput(inode);\n\t} else if (complete_capsnap) {\n\t\tceph_flush_snaps(ci);\n\t\twake_up_all(&ci->i_cap_wq);\n\t}\n\tif (drop_capsnap)\n\t\tiput(inode);\n}",
          "includes": [
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nvoid ceph_put_wrbuffer_cap_refs(struct ceph_inode_info *ci, int nr,\n\t\t\t\tstruct ceph_snap_context *snapc)\n{\n\tstruct inode *inode = &ci->vfs_inode;\n\tint last = 0;\n\tint complete_capsnap = 0;\n\tint drop_capsnap = 0;\n\tint found = 0;\n\tstruct ceph_cap_snap *capsnap = NULL;\n\n\tspin_lock(&ci->i_ceph_lock);\n\tci->i_wrbuffer_ref -= nr;\n\tlast = !ci->i_wrbuffer_ref;\n\n\tif (ci->i_head_snapc == snapc) {\n\t\tci->i_wrbuffer_ref_head -= nr;\n\t\tif (ci->i_wrbuffer_ref_head == 0 &&\n\t\t    ci->i_dirty_caps == 0 && ci->i_flushing_caps == 0) {\n\t\t\tBUG_ON(!ci->i_head_snapc);\n\t\t\tceph_put_snap_context(ci->i_head_snapc);\n\t\t\tci->i_head_snapc = NULL;\n\t\t}\n\t\tdout(\"put_wrbuffer_cap_refs on %p head %d/%d -> %d/%d %s\\n\",\n\t\t     inode,\n\t\t     ci->i_wrbuffer_ref+nr, ci->i_wrbuffer_ref_head+nr,\n\t\t     ci->i_wrbuffer_ref, ci->i_wrbuffer_ref_head,\n\t\t     last ? \" LAST\" : \"\");\n\t} else {\n\t\tlist_for_each_entry(capsnap, &ci->i_cap_snaps, ci_item) {\n\t\t\tif (capsnap->context == snapc) {\n\t\t\t\tfound = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tBUG_ON(!found);\n\t\tcapsnap->dirty_pages -= nr;\n\t\tif (capsnap->dirty_pages == 0) {\n\t\t\tcomplete_capsnap = 1;\n\t\t\tif (capsnap->dirty == 0)\n\t\t\t\t/* cap writeback completed before we created\n\t\t\t\t * the cap_snap; no FLUSHSNAP is needed */\n\t\t\t\tdrop_capsnap = 1;\n\t\t}\n\t\tdout(\"put_wrbuffer_cap_refs on %p cap_snap %p \"\n\t\t     \" snap %lld %d/%d -> %d/%d %s%s%s\\n\",\n\t\t     inode, capsnap, capsnap->context->seq,\n\t\t     ci->i_wrbuffer_ref+nr, capsnap->dirty_pages + nr,\n\t\t     ci->i_wrbuffer_ref, capsnap->dirty_pages,\n\t\t     last ? \" (wrbuffer last)\" : \"\",\n\t\t     complete_capsnap ? \" (complete capsnap)\" : \"\",\n\t\t     drop_capsnap ? \" (drop capsnap)\" : \"\");\n\t\tif (drop_capsnap) {\n\t\t\tceph_put_snap_context(capsnap->context);\n\t\t\tlist_del(&capsnap->ci_item);\n\t\t\tlist_del(&capsnap->flushing_item);\n\t\t\tceph_put_cap_snap(capsnap);\n\t\t}\n\t}\n\n\tspin_unlock(&ci->i_ceph_lock);\n\n\tif (last) {\n\t\tceph_check_caps(ci, CHECK_CAPS_AUTHONLY, NULL);\n\t\tiput(inode);\n\t} else if (complete_capsnap) {\n\t\tceph_flush_snaps(ci);\n\t\twake_up_all(&ci->i_cap_wq);\n\t}\n\tif (drop_capsnap)\n\t\tiput(inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"%p wrote+cleaned %d pages\\n\"",
            "inode",
            "wrote"
          ],
          "line": 665
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 663
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "generic_error_remove_page",
          "args": [
            "inode->i_mapping",
            "page"
          ],
          "line": 661
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "end_page_writeback",
          "args": [
            "page"
          ],
          "line": 652
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_end_page_writeback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
          "lines": "279-290",
          "snippet": "static void nfs_end_page_writeback(struct nfs_page *req)\n{\n\tstruct inode *inode = page_file_mapping(req->wb_page)->host;\n\tstruct nfs_server *nfss = NFS_SERVER(inode);\n\n\tif (!nfs_page_group_sync_on_bit(req, PG_WB_END))\n\t\treturn;\n\n\tend_page_writeback(req->wb_page);\n\tif (atomic_long_dec_return(&nfss->writeback) < NFS_CONGESTION_OFF_THRESH)\n\t\tclear_bdi_congested(&nfss->backing_dev_info, BLK_RW_ASYNC);\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define NFS_CONGESTION_OFF_THRESH\t\\\n\t(NFS_CONGESTION_ON_THRESH - (NFS_CONGESTION_ON_THRESH >> 2))"
          ],
          "globals_used": [
            "static void nfs_redirty_request(struct nfs_page *req);",
            "static void nfs_clear_request_commit(struct nfs_page *req);",
            "static void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\n#define NFS_CONGESTION_OFF_THRESH\t\\\n\t(NFS_CONGESTION_ON_THRESH - (NFS_CONGESTION_ON_THRESH >> 2))\n\nstatic void nfs_redirty_request(struct nfs_page *req);\nstatic void nfs_clear_request_commit(struct nfs_page *req);\nstatic void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);\n\nstatic void nfs_end_page_writeback(struct nfs_page *req)\n{\n\tstruct inode *inode = page_file_mapping(req->wb_page)->host;\n\tstruct nfs_server *nfss = NFS_SERVER(inode);\n\n\tif (!nfs_page_group_sync_on_bit(req, PG_WB_END))\n\t\treturn;\n\n\tend_page_writeback(req->wb_page);\n\tif (atomic_long_dec_return(&nfss->writeback) < NFS_CONGESTION_OFF_THRESH)\n\t\tclear_bdi_congested(&nfss->backing_dev_info, BLK_RW_ASYNC);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"unlocking %d %p\\n\"",
            "i",
            "page"
          ],
          "line": 651
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ClearPagePrivate",
          "args": [
            "page"
          ],
          "line": 650
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_put_snap_context",
          "args": [
            "page_snap_context(page)"
          ],
          "line": 648
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_snap_context",
          "args": [
            "page"
          ],
          "line": 648
        },
        "resolved": true,
        "details": {
          "function_name": "page_snap_context",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/addr.c",
          "lines": "58-63",
          "snippet": "static inline struct ceph_snap_context *page_snap_context(struct page *page)\n{\n\tif (PagePrivate(page))\n\t\treturn (void *)page->private;\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/ceph/osd_client.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>\t/* generic_writepages */",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/osd_client.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/task_io_accounting_ops.h>\n#include <linux/pagevec.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\t/* generic_writepages */\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/backing-dev.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline struct ceph_snap_context *page_snap_context(struct page *page)\n{\n\tif (PagePrivate(page))\n\t\treturn (void *)page->private;\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_bdi_congested",
          "args": [
            "&fsc->backing_dev_info",
            "BLK_RW_ASYNC"
          ],
          "line": 645
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CONGESTION_OFF_THRESH",
          "args": [
            "fsc->mount_options->congestion_kb"
          ],
          "line": 644
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_long_dec_return",
          "args": [
            "&fsc->writeback_count"
          ],
          "line": 642
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!PageUptodate(page)"
          ],
          "line": 639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "page"
          ],
          "line": 639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!page"
          ],
          "line": 638
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"writepages_finish %p rc %d bytes %llu wrote %d (pages)\\n\"",
            "inode",
            "rc",
            "bytes",
            "wrote"
          ],
          "line": 632
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mapping_set_error",
          "args": [
            "mapping",
            "rc"
          ],
          "line": 630
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "calc_pages_for",
          "args": [
            "(u64)osd_data->alignment",
            "(u64)osd_data->length"
          ],
          "line": 618
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "osd_data->type != CEPH_OSD_DATA_TYPE_PAGES"
          ],
          "line": 617
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "osd_req_op_extent_osd_data",
          "args": [
            "req",
            "0"
          ],
          "line": 616
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_caps_issued",
          "args": [
            "ci"
          ],
          "line": 614
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_caps_issued",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.h",
          "lines": "531-538",
          "snippet": "static inline int ceph_caps_issued(struct ceph_inode_info *ci)\n{\n\tint issued;\n\tspin_lock(&ci->i_ceph_lock);\n\tissued = __ceph_caps_issued(ci, NULL);\n\tspin_unlock(&ci->i_ceph_lock);\n\treturn issued;\n}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/ceph/libceph.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/backing-dev.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/ceph/libceph.h>\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n#include <linux/completion.h>\n#include <linux/backing-dev.h>\n#include <asm/unaligned.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline int ceph_caps_issued(struct ceph_inode_info *ci)\n{\n\tint issued;\n\tspin_lock(&ci->i_ceph_lock);\n\tissued = __ceph_caps_issued(ci, NULL);\n\tspin_unlock(&ci->i_ceph_lock);\n\treturn issued;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_inode_to_client",
          "args": [
            "inode"
          ],
          "line": 612
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_inode_to_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.h",
          "lines": "347-350",
          "snippet": "static inline struct ceph_fs_client *ceph_inode_to_client(struct inode *inode)\n{\n\treturn (struct ceph_fs_client *)inode->i_sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/ceph/libceph.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/backing-dev.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/ceph/libceph.h>\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n#include <linux/completion.h>\n#include <linux/backing-dev.h>\n#include <asm/unaligned.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline struct ceph_fs_client *ceph_inode_to_client(struct inode *inode)\n{\n\treturn (struct ceph_fs_client *)inode->i_sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/ceph/osd_client.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/task_io_accounting_ops.h>\n#include <linux/pagevec.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\t/* generic_writepages */\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/backing-dev.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void writepages_finish(struct ceph_osd_request *req,\n\t\t\t      struct ceph_msg *msg)\n{\n\tstruct inode *inode = req->r_inode;\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tstruct ceph_osd_data *osd_data;\n\tunsigned wrote;\n\tstruct page *page;\n\tint num_pages;\n\tint i;\n\tstruct ceph_snap_context *snapc = req->r_snapc;\n\tstruct address_space *mapping = inode->i_mapping;\n\tint rc = req->r_result;\n\tu64 bytes = req->r_ops[0].extent.length;\n\tstruct ceph_fs_client *fsc = ceph_inode_to_client(inode);\n\tlong writeback_stat;\n\tunsigned issued = ceph_caps_issued(ci);\n\n\tosd_data = osd_req_op_extent_osd_data(req, 0);\n\tBUG_ON(osd_data->type != CEPH_OSD_DATA_TYPE_PAGES);\n\tnum_pages = calc_pages_for((u64)osd_data->alignment,\n\t\t\t\t\t(u64)osd_data->length);\n\tif (rc >= 0) {\n\t\t/*\n\t\t * Assume we wrote the pages we originally sent.  The\n\t\t * osd might reply with fewer pages if our writeback\n\t\t * raced with a truncation and was adjusted at the osd,\n\t\t * so don't believe the reply.\n\t\t */\n\t\twrote = num_pages;\n\t} else {\n\t\twrote = 0;\n\t\tmapping_set_error(mapping, rc);\n\t}\n\tdout(\"writepages_finish %p rc %d bytes %llu wrote %d (pages)\\n\",\n\t     inode, rc, bytes, wrote);\n\n\t/* clean all pages */\n\tfor (i = 0; i < num_pages; i++) {\n\t\tpage = osd_data->pages[i];\n\t\tBUG_ON(!page);\n\t\tWARN_ON(!PageUptodate(page));\n\n\t\twriteback_stat =\n\t\t\tatomic_long_dec_return(&fsc->writeback_count);\n\t\tif (writeback_stat <\n\t\t    CONGESTION_OFF_THRESH(fsc->mount_options->congestion_kb))\n\t\t\tclear_bdi_congested(&fsc->backing_dev_info,\n\t\t\t\t\t    BLK_RW_ASYNC);\n\n\t\tceph_put_snap_context(page_snap_context(page));\n\t\tpage->private = 0;\n\t\tClearPagePrivate(page);\n\t\tdout(\"unlocking %d %p\\n\", i, page);\n\t\tend_page_writeback(page);\n\n\t\t/*\n\t\t * We lost the cache cap, need to truncate the page before\n\t\t * it is unlocked, otherwise we'd truncate it later in the\n\t\t * page truncation thread, possibly losing some data that\n\t\t * raced its way in\n\t\t */\n\t\tif ((issued & (CEPH_CAP_FILE_CACHE|CEPH_CAP_FILE_LAZYIO)) == 0)\n\t\t\tgeneric_error_remove_page(inode->i_mapping, page);\n\n\t\tunlock_page(page);\n\t}\n\tdout(\"%p wrote+cleaned %d pages\\n\", inode, wrote);\n\tceph_put_wrbuffer_cap_refs(ci, num_pages, snapc);\n\n\tceph_release_pages(osd_data->pages, num_pages);\n\tif (osd_data->pages_from_pool)\n\t\tmempool_free(osd_data->pages,\n\t\t\t     ceph_sb_to_client(inode->i_sb)->wb_pagevec_pool);\n\telse\n\t\tkfree(osd_data->pages);\n\tceph_osdc_put_request(req);\n}"
  },
  {
    "function_name": "ceph_release_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/addr.c",
    "lines": "579-590",
    "snippet": "static void ceph_release_pages(struct page **pages, int num)\n{\n\tstruct pagevec pvec;\n\tint i;\n\n\tpagevec_init(&pvec, 0);\n\tfor (i = 0; i < num; i++) {\n\t\tif (pagevec_add(&pvec, pages[i]) == 0)\n\t\t\tpagevec_release(&pvec);\n\t}\n\tpagevec_release(&pvec);\n}",
    "includes": [
      "#include <linux/ceph/osd_client.h>",
      "#include \"cache.h\"",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/slab.h>",
      "#include <linux/writeback.h>\t/* generic_writepages */",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pagevec_release",
          "args": [
            "&pvec"
          ],
          "line": 589
        },
        "resolved": true,
        "details": {
          "function_name": "huge_pagevec_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hugetlbfs/inode.c",
          "lines": "84-92",
          "snippet": "static void huge_pagevec_release(struct pagevec *pvec)\n{\n\tint i;\n\n\tfor (i = 0; i < pagevec_count(pvec); ++i)\n\t\tput_page(pvec->pages[i]);\n\n\tpagevec_reinit(pvec);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/migrate.h>",
            "#include <linux/magic.h>",
            "#include <linux/security.h>",
            "#include <linux/statfs.h>",
            "#include <linux/dnotify.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/parser.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/ctype.h>",
            "#include <linux/capability.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kernel.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>\t\t/* remove ASAP */",
            "#include <asm/current.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/migrate.h>\n#include <linux/magic.h>\n#include <linux/security.h>\n#include <linux/statfs.h>\n#include <linux/dnotify.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/parser.h>\n#include <linux/pagevec.h>\n#include <linux/hugetlb.h>\n#include <linux/backing-dev.h>\n#include <linux/ctype.h>\n#include <linux/capability.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/kernel.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\t\t/* remove ASAP */\n#include <asm/current.h>\n#include <linux/thread_info.h>\n#include <linux/module.h>\n\nstatic void huge_pagevec_release(struct pagevec *pvec)\n{\n\tint i;\n\n\tfor (i = 0; i < pagevec_count(pvec); ++i)\n\t\tput_page(pvec->pages[i]);\n\n\tpagevec_reinit(pvec);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pagevec_add",
          "args": [
            "&pvec",
            "pages[i]"
          ],
          "line": 586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pagevec_init",
          "args": [
            "&pvec",
            "0"
          ],
          "line": 584
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/ceph/osd_client.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/task_io_accounting_ops.h>\n#include <linux/pagevec.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\t/* generic_writepages */\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/backing-dev.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void ceph_release_pages(struct page **pages, int num)\n{\n\tstruct pagevec pvec;\n\tint i;\n\n\tpagevec_init(&pvec, 0);\n\tfor (i = 0; i < num; i++) {\n\t\tif (pagevec_add(&pvec, pages[i]) == 0)\n\t\t\tpagevec_release(&pvec);\n\t}\n\tpagevec_release(&pvec);\n}"
  },
  {
    "function_name": "ceph_writepage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/addr.c",
    "lines": "562-572",
    "snippet": "static int ceph_writepage(struct page *page, struct writeback_control *wbc)\n{\n\tint err;\n\tstruct inode *inode = page->mapping->host;\n\tBUG_ON(!inode);\n\tihold(inode);\n\terr = writepage_nounlock(page, wbc);\n\tunlock_page(page);\n\tiput(inode);\n\treturn err;\n}",
    "includes": [
      "#include <linux/ceph/osd_client.h>",
      "#include \"cache.h\"",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/slab.h>",
      "#include <linux/writeback.h>\t/* generic_writepages */",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "inode"
          ],
          "line": 570
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 569
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "writepage_nounlock",
          "args": [
            "page",
            "wbc"
          ],
          "line": 568
        },
        "resolved": true,
        "details": {
          "function_name": "writepage_nounlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/addr.c",
          "lines": "471-560",
          "snippet": "static int writepage_nounlock(struct page *page, struct writeback_control *wbc)\n{\n\tstruct inode *inode;\n\tstruct ceph_inode_info *ci;\n\tstruct ceph_fs_client *fsc;\n\tstruct ceph_osd_client *osdc;\n\tstruct ceph_snap_context *snapc, *oldest;\n\tloff_t page_off = page_offset(page);\n\tlong writeback_stat;\n\tu64 truncate_size, snap_size = 0;\n\tu32 truncate_seq;\n\tint err = 0, len = PAGE_CACHE_SIZE;\n\n\tdout(\"writepage %p idx %lu\\n\", page, page->index);\n\n\tif (!page->mapping || !page->mapping->host) {\n\t\tdout(\"writepage %p - no mapping\\n\", page);\n\t\treturn -EFAULT;\n\t}\n\tinode = page->mapping->host;\n\tci = ceph_inode(inode);\n\tfsc = ceph_inode_to_client(inode);\n\tosdc = &fsc->client->osdc;\n\n\t/* verify this is a writeable snap context */\n\tsnapc = page_snap_context(page);\n\tif (snapc == NULL) {\n\t\tdout(\"writepage %p page %p not dirty?\\n\", inode, page);\n\t\tgoto out;\n\t}\n\toldest = get_oldest_context(inode, &snap_size);\n\tif (snapc->seq > oldest->seq) {\n\t\tdout(\"writepage %p page %p snapc %p not writeable - noop\\n\",\n\t\t     inode, page, snapc);\n\t\t/* we should only noop if called by kswapd */\n\t\tWARN_ON((current->flags & PF_MEMALLOC) == 0);\n\t\tceph_put_snap_context(oldest);\n\t\tgoto out;\n\t}\n\tceph_put_snap_context(oldest);\n\n\tspin_lock(&ci->i_ceph_lock);\n\ttruncate_seq = ci->i_truncate_seq;\n\ttruncate_size = ci->i_truncate_size;\n\tif (!snap_size)\n\t\tsnap_size = i_size_read(inode);\n\tspin_unlock(&ci->i_ceph_lock);\n\n\t/* is this a partial page at end of file? */\n\tif (page_off >= snap_size) {\n\t\tdout(\"%p page eof %llu\\n\", page, snap_size);\n\t\tgoto out;\n\t}\n\tif (snap_size < page_off + len)\n\t\tlen = snap_size - page_off;\n\n\tdout(\"writepage %p page %p index %lu on %llu~%u snapc %p\\n\",\n\t     inode, page, page->index, page_off, len, snapc);\n\n\twriteback_stat = atomic_long_inc_return(&fsc->writeback_count);\n\tif (writeback_stat >\n\t    CONGESTION_ON_THRESH(fsc->mount_options->congestion_kb))\n\t\tset_bdi_congested(&fsc->backing_dev_info, BLK_RW_ASYNC);\n\n\tceph_readpage_to_fscache(inode, page);\n\n\tset_page_writeback(page);\n\terr = ceph_osdc_writepages(osdc, ceph_vino(inode),\n\t\t\t\t   &ci->i_layout, snapc,\n\t\t\t\t   page_off, len,\n\t\t\t\t   truncate_seq, truncate_size,\n\t\t\t\t   &inode->i_mtime, &page, 1);\n\tif (err < 0) {\n\t\tdout(\"writepage setting page/mapping error %d %p\\n\", err, page);\n\t\tSetPageError(page);\n\t\tmapping_set_error(&inode->i_data, err);\n\t\tif (wbc)\n\t\t\twbc->pages_skipped++;\n\t} else {\n\t\tdout(\"writepage cleaned page %p\\n\", page);\n\t\terr = 0;  /* vfs expects us to return 0 */\n\t}\n\tpage->private = 0;\n\tClearPagePrivate(page);\n\tend_page_writeback(page);\n\tceph_put_wrbuffer_cap_refs(ci, 1, snapc);\n\tceph_put_snap_context(snapc);  /* page's reference */\nout:\n\treturn err;\n}",
          "includes": [
            "#include <linux/ceph/osd_client.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>\t/* generic_writepages */",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/osd_client.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/task_io_accounting_ops.h>\n#include <linux/pagevec.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\t/* generic_writepages */\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/backing-dev.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic int writepage_nounlock(struct page *page, struct writeback_control *wbc)\n{\n\tstruct inode *inode;\n\tstruct ceph_inode_info *ci;\n\tstruct ceph_fs_client *fsc;\n\tstruct ceph_osd_client *osdc;\n\tstruct ceph_snap_context *snapc, *oldest;\n\tloff_t page_off = page_offset(page);\n\tlong writeback_stat;\n\tu64 truncate_size, snap_size = 0;\n\tu32 truncate_seq;\n\tint err = 0, len = PAGE_CACHE_SIZE;\n\n\tdout(\"writepage %p idx %lu\\n\", page, page->index);\n\n\tif (!page->mapping || !page->mapping->host) {\n\t\tdout(\"writepage %p - no mapping\\n\", page);\n\t\treturn -EFAULT;\n\t}\n\tinode = page->mapping->host;\n\tci = ceph_inode(inode);\n\tfsc = ceph_inode_to_client(inode);\n\tosdc = &fsc->client->osdc;\n\n\t/* verify this is a writeable snap context */\n\tsnapc = page_snap_context(page);\n\tif (snapc == NULL) {\n\t\tdout(\"writepage %p page %p not dirty?\\n\", inode, page);\n\t\tgoto out;\n\t}\n\toldest = get_oldest_context(inode, &snap_size);\n\tif (snapc->seq > oldest->seq) {\n\t\tdout(\"writepage %p page %p snapc %p not writeable - noop\\n\",\n\t\t     inode, page, snapc);\n\t\t/* we should only noop if called by kswapd */\n\t\tWARN_ON((current->flags & PF_MEMALLOC) == 0);\n\t\tceph_put_snap_context(oldest);\n\t\tgoto out;\n\t}\n\tceph_put_snap_context(oldest);\n\n\tspin_lock(&ci->i_ceph_lock);\n\ttruncate_seq = ci->i_truncate_seq;\n\ttruncate_size = ci->i_truncate_size;\n\tif (!snap_size)\n\t\tsnap_size = i_size_read(inode);\n\tspin_unlock(&ci->i_ceph_lock);\n\n\t/* is this a partial page at end of file? */\n\tif (page_off >= snap_size) {\n\t\tdout(\"%p page eof %llu\\n\", page, snap_size);\n\t\tgoto out;\n\t}\n\tif (snap_size < page_off + len)\n\t\tlen = snap_size - page_off;\n\n\tdout(\"writepage %p page %p index %lu on %llu~%u snapc %p\\n\",\n\t     inode, page, page->index, page_off, len, snapc);\n\n\twriteback_stat = atomic_long_inc_return(&fsc->writeback_count);\n\tif (writeback_stat >\n\t    CONGESTION_ON_THRESH(fsc->mount_options->congestion_kb))\n\t\tset_bdi_congested(&fsc->backing_dev_info, BLK_RW_ASYNC);\n\n\tceph_readpage_to_fscache(inode, page);\n\n\tset_page_writeback(page);\n\terr = ceph_osdc_writepages(osdc, ceph_vino(inode),\n\t\t\t\t   &ci->i_layout, snapc,\n\t\t\t\t   page_off, len,\n\t\t\t\t   truncate_seq, truncate_size,\n\t\t\t\t   &inode->i_mtime, &page, 1);\n\tif (err < 0) {\n\t\tdout(\"writepage setting page/mapping error %d %p\\n\", err, page);\n\t\tSetPageError(page);\n\t\tmapping_set_error(&inode->i_data, err);\n\t\tif (wbc)\n\t\t\twbc->pages_skipped++;\n\t} else {\n\t\tdout(\"writepage cleaned page %p\\n\", page);\n\t\terr = 0;  /* vfs expects us to return 0 */\n\t}\n\tpage->private = 0;\n\tClearPagePrivate(page);\n\tend_page_writeback(page);\n\tceph_put_wrbuffer_cap_refs(ci, 1, snapc);\n\tceph_put_snap_context(snapc);  /* page's reference */\nout:\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ihold",
          "args": [
            "inode"
          ],
          "line": 567
        },
        "resolved": true,
        "details": {
          "function_name": "ihold",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "388-391",
          "snippet": "void ihold(struct inode *inode)\n{\n\tWARN_ON(atomic_inc_return(&inode->i_count) < 2);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid ihold(struct inode *inode)\n{\n\tWARN_ON(atomic_inc_return(&inode->i_count) < 2);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!inode"
          ],
          "line": 566
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/ceph/osd_client.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/task_io_accounting_ops.h>\n#include <linux/pagevec.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\t/* generic_writepages */\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/backing-dev.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic int ceph_writepage(struct page *page, struct writeback_control *wbc)\n{\n\tint err;\n\tstruct inode *inode = page->mapping->host;\n\tBUG_ON(!inode);\n\tihold(inode);\n\terr = writepage_nounlock(page, wbc);\n\tunlock_page(page);\n\tiput(inode);\n\treturn err;\n}"
  },
  {
    "function_name": "writepage_nounlock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/addr.c",
    "lines": "471-560",
    "snippet": "static int writepage_nounlock(struct page *page, struct writeback_control *wbc)\n{\n\tstruct inode *inode;\n\tstruct ceph_inode_info *ci;\n\tstruct ceph_fs_client *fsc;\n\tstruct ceph_osd_client *osdc;\n\tstruct ceph_snap_context *snapc, *oldest;\n\tloff_t page_off = page_offset(page);\n\tlong writeback_stat;\n\tu64 truncate_size, snap_size = 0;\n\tu32 truncate_seq;\n\tint err = 0, len = PAGE_CACHE_SIZE;\n\n\tdout(\"writepage %p idx %lu\\n\", page, page->index);\n\n\tif (!page->mapping || !page->mapping->host) {\n\t\tdout(\"writepage %p - no mapping\\n\", page);\n\t\treturn -EFAULT;\n\t}\n\tinode = page->mapping->host;\n\tci = ceph_inode(inode);\n\tfsc = ceph_inode_to_client(inode);\n\tosdc = &fsc->client->osdc;\n\n\t/* verify this is a writeable snap context */\n\tsnapc = page_snap_context(page);\n\tif (snapc == NULL) {\n\t\tdout(\"writepage %p page %p not dirty?\\n\", inode, page);\n\t\tgoto out;\n\t}\n\toldest = get_oldest_context(inode, &snap_size);\n\tif (snapc->seq > oldest->seq) {\n\t\tdout(\"writepage %p page %p snapc %p not writeable - noop\\n\",\n\t\t     inode, page, snapc);\n\t\t/* we should only noop if called by kswapd */\n\t\tWARN_ON((current->flags & PF_MEMALLOC) == 0);\n\t\tceph_put_snap_context(oldest);\n\t\tgoto out;\n\t}\n\tceph_put_snap_context(oldest);\n\n\tspin_lock(&ci->i_ceph_lock);\n\ttruncate_seq = ci->i_truncate_seq;\n\ttruncate_size = ci->i_truncate_size;\n\tif (!snap_size)\n\t\tsnap_size = i_size_read(inode);\n\tspin_unlock(&ci->i_ceph_lock);\n\n\t/* is this a partial page at end of file? */\n\tif (page_off >= snap_size) {\n\t\tdout(\"%p page eof %llu\\n\", page, snap_size);\n\t\tgoto out;\n\t}\n\tif (snap_size < page_off + len)\n\t\tlen = snap_size - page_off;\n\n\tdout(\"writepage %p page %p index %lu on %llu~%u snapc %p\\n\",\n\t     inode, page, page->index, page_off, len, snapc);\n\n\twriteback_stat = atomic_long_inc_return(&fsc->writeback_count);\n\tif (writeback_stat >\n\t    CONGESTION_ON_THRESH(fsc->mount_options->congestion_kb))\n\t\tset_bdi_congested(&fsc->backing_dev_info, BLK_RW_ASYNC);\n\n\tceph_readpage_to_fscache(inode, page);\n\n\tset_page_writeback(page);\n\terr = ceph_osdc_writepages(osdc, ceph_vino(inode),\n\t\t\t\t   &ci->i_layout, snapc,\n\t\t\t\t   page_off, len,\n\t\t\t\t   truncate_seq, truncate_size,\n\t\t\t\t   &inode->i_mtime, &page, 1);\n\tif (err < 0) {\n\t\tdout(\"writepage setting page/mapping error %d %p\\n\", err, page);\n\t\tSetPageError(page);\n\t\tmapping_set_error(&inode->i_data, err);\n\t\tif (wbc)\n\t\t\twbc->pages_skipped++;\n\t} else {\n\t\tdout(\"writepage cleaned page %p\\n\", page);\n\t\terr = 0;  /* vfs expects us to return 0 */\n\t}\n\tpage->private = 0;\n\tClearPagePrivate(page);\n\tend_page_writeback(page);\n\tceph_put_wrbuffer_cap_refs(ci, 1, snapc);\n\tceph_put_snap_context(snapc);  /* page's reference */\nout:\n\treturn err;\n}",
    "includes": [
      "#include <linux/ceph/osd_client.h>",
      "#include \"cache.h\"",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/slab.h>",
      "#include <linux/writeback.h>\t/* generic_writepages */",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ceph_put_snap_context",
          "args": [
            "snapc"
          ],
          "line": 557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_put_wrbuffer_cap_refs",
          "args": [
            "ci",
            "1",
            "snapc"
          ],
          "line": 556
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_put_wrbuffer_cap_refs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
          "lines": "2335-2405",
          "snippet": "void ceph_put_wrbuffer_cap_refs(struct ceph_inode_info *ci, int nr,\n\t\t\t\tstruct ceph_snap_context *snapc)\n{\n\tstruct inode *inode = &ci->vfs_inode;\n\tint last = 0;\n\tint complete_capsnap = 0;\n\tint drop_capsnap = 0;\n\tint found = 0;\n\tstruct ceph_cap_snap *capsnap = NULL;\n\n\tspin_lock(&ci->i_ceph_lock);\n\tci->i_wrbuffer_ref -= nr;\n\tlast = !ci->i_wrbuffer_ref;\n\n\tif (ci->i_head_snapc == snapc) {\n\t\tci->i_wrbuffer_ref_head -= nr;\n\t\tif (ci->i_wrbuffer_ref_head == 0 &&\n\t\t    ci->i_dirty_caps == 0 && ci->i_flushing_caps == 0) {\n\t\t\tBUG_ON(!ci->i_head_snapc);\n\t\t\tceph_put_snap_context(ci->i_head_snapc);\n\t\t\tci->i_head_snapc = NULL;\n\t\t}\n\t\tdout(\"put_wrbuffer_cap_refs on %p head %d/%d -> %d/%d %s\\n\",\n\t\t     inode,\n\t\t     ci->i_wrbuffer_ref+nr, ci->i_wrbuffer_ref_head+nr,\n\t\t     ci->i_wrbuffer_ref, ci->i_wrbuffer_ref_head,\n\t\t     last ? \" LAST\" : \"\");\n\t} else {\n\t\tlist_for_each_entry(capsnap, &ci->i_cap_snaps, ci_item) {\n\t\t\tif (capsnap->context == snapc) {\n\t\t\t\tfound = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tBUG_ON(!found);\n\t\tcapsnap->dirty_pages -= nr;\n\t\tif (capsnap->dirty_pages == 0) {\n\t\t\tcomplete_capsnap = 1;\n\t\t\tif (capsnap->dirty == 0)\n\t\t\t\t/* cap writeback completed before we created\n\t\t\t\t * the cap_snap; no FLUSHSNAP is needed */\n\t\t\t\tdrop_capsnap = 1;\n\t\t}\n\t\tdout(\"put_wrbuffer_cap_refs on %p cap_snap %p \"\n\t\t     \" snap %lld %d/%d -> %d/%d %s%s%s\\n\",\n\t\t     inode, capsnap, capsnap->context->seq,\n\t\t     ci->i_wrbuffer_ref+nr, capsnap->dirty_pages + nr,\n\t\t     ci->i_wrbuffer_ref, capsnap->dirty_pages,\n\t\t     last ? \" (wrbuffer last)\" : \"\",\n\t\t     complete_capsnap ? \" (complete capsnap)\" : \"\",\n\t\t     drop_capsnap ? \" (drop capsnap)\" : \"\");\n\t\tif (drop_capsnap) {\n\t\t\tceph_put_snap_context(capsnap->context);\n\t\t\tlist_del(&capsnap->ci_item);\n\t\t\tlist_del(&capsnap->flushing_item);\n\t\t\tceph_put_cap_snap(capsnap);\n\t\t}\n\t}\n\n\tspin_unlock(&ci->i_ceph_lock);\n\n\tif (last) {\n\t\tceph_check_caps(ci, CHECK_CAPS_AUTHONLY, NULL);\n\t\tiput(inode);\n\t} else if (complete_capsnap) {\n\t\tceph_flush_snaps(ci);\n\t\twake_up_all(&ci->i_cap_wq);\n\t}\n\tif (drop_capsnap)\n\t\tiput(inode);\n}",
          "includes": [
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nvoid ceph_put_wrbuffer_cap_refs(struct ceph_inode_info *ci, int nr,\n\t\t\t\tstruct ceph_snap_context *snapc)\n{\n\tstruct inode *inode = &ci->vfs_inode;\n\tint last = 0;\n\tint complete_capsnap = 0;\n\tint drop_capsnap = 0;\n\tint found = 0;\n\tstruct ceph_cap_snap *capsnap = NULL;\n\n\tspin_lock(&ci->i_ceph_lock);\n\tci->i_wrbuffer_ref -= nr;\n\tlast = !ci->i_wrbuffer_ref;\n\n\tif (ci->i_head_snapc == snapc) {\n\t\tci->i_wrbuffer_ref_head -= nr;\n\t\tif (ci->i_wrbuffer_ref_head == 0 &&\n\t\t    ci->i_dirty_caps == 0 && ci->i_flushing_caps == 0) {\n\t\t\tBUG_ON(!ci->i_head_snapc);\n\t\t\tceph_put_snap_context(ci->i_head_snapc);\n\t\t\tci->i_head_snapc = NULL;\n\t\t}\n\t\tdout(\"put_wrbuffer_cap_refs on %p head %d/%d -> %d/%d %s\\n\",\n\t\t     inode,\n\t\t     ci->i_wrbuffer_ref+nr, ci->i_wrbuffer_ref_head+nr,\n\t\t     ci->i_wrbuffer_ref, ci->i_wrbuffer_ref_head,\n\t\t     last ? \" LAST\" : \"\");\n\t} else {\n\t\tlist_for_each_entry(capsnap, &ci->i_cap_snaps, ci_item) {\n\t\t\tif (capsnap->context == snapc) {\n\t\t\t\tfound = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tBUG_ON(!found);\n\t\tcapsnap->dirty_pages -= nr;\n\t\tif (capsnap->dirty_pages == 0) {\n\t\t\tcomplete_capsnap = 1;\n\t\t\tif (capsnap->dirty == 0)\n\t\t\t\t/* cap writeback completed before we created\n\t\t\t\t * the cap_snap; no FLUSHSNAP is needed */\n\t\t\t\tdrop_capsnap = 1;\n\t\t}\n\t\tdout(\"put_wrbuffer_cap_refs on %p cap_snap %p \"\n\t\t     \" snap %lld %d/%d -> %d/%d %s%s%s\\n\",\n\t\t     inode, capsnap, capsnap->context->seq,\n\t\t     ci->i_wrbuffer_ref+nr, capsnap->dirty_pages + nr,\n\t\t     ci->i_wrbuffer_ref, capsnap->dirty_pages,\n\t\t     last ? \" (wrbuffer last)\" : \"\",\n\t\t     complete_capsnap ? \" (complete capsnap)\" : \"\",\n\t\t     drop_capsnap ? \" (drop capsnap)\" : \"\");\n\t\tif (drop_capsnap) {\n\t\t\tceph_put_snap_context(capsnap->context);\n\t\t\tlist_del(&capsnap->ci_item);\n\t\t\tlist_del(&capsnap->flushing_item);\n\t\t\tceph_put_cap_snap(capsnap);\n\t\t}\n\t}\n\n\tspin_unlock(&ci->i_ceph_lock);\n\n\tif (last) {\n\t\tceph_check_caps(ci, CHECK_CAPS_AUTHONLY, NULL);\n\t\tiput(inode);\n\t} else if (complete_capsnap) {\n\t\tceph_flush_snaps(ci);\n\t\twake_up_all(&ci->i_cap_wq);\n\t}\n\tif (drop_capsnap)\n\t\tiput(inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "end_page_writeback",
          "args": [
            "page"
          ],
          "line": 555
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_end_page_writeback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
          "lines": "279-290",
          "snippet": "static void nfs_end_page_writeback(struct nfs_page *req)\n{\n\tstruct inode *inode = page_file_mapping(req->wb_page)->host;\n\tstruct nfs_server *nfss = NFS_SERVER(inode);\n\n\tif (!nfs_page_group_sync_on_bit(req, PG_WB_END))\n\t\treturn;\n\n\tend_page_writeback(req->wb_page);\n\tif (atomic_long_dec_return(&nfss->writeback) < NFS_CONGESTION_OFF_THRESH)\n\t\tclear_bdi_congested(&nfss->backing_dev_info, BLK_RW_ASYNC);\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define NFS_CONGESTION_OFF_THRESH\t\\\n\t(NFS_CONGESTION_ON_THRESH - (NFS_CONGESTION_ON_THRESH >> 2))"
          ],
          "globals_used": [
            "static void nfs_redirty_request(struct nfs_page *req);",
            "static void nfs_clear_request_commit(struct nfs_page *req);",
            "static void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\n#define NFS_CONGESTION_OFF_THRESH\t\\\n\t(NFS_CONGESTION_ON_THRESH - (NFS_CONGESTION_ON_THRESH >> 2))\n\nstatic void nfs_redirty_request(struct nfs_page *req);\nstatic void nfs_clear_request_commit(struct nfs_page *req);\nstatic void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);\n\nstatic void nfs_end_page_writeback(struct nfs_page *req)\n{\n\tstruct inode *inode = page_file_mapping(req->wb_page)->host;\n\tstruct nfs_server *nfss = NFS_SERVER(inode);\n\n\tif (!nfs_page_group_sync_on_bit(req, PG_WB_END))\n\t\treturn;\n\n\tend_page_writeback(req->wb_page);\n\tif (atomic_long_dec_return(&nfss->writeback) < NFS_CONGESTION_OFF_THRESH)\n\t\tclear_bdi_congested(&nfss->backing_dev_info, BLK_RW_ASYNC);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ClearPagePrivate",
          "args": [
            "page"
          ],
          "line": 554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"writepage cleaned page %p\\n\"",
            "page"
          ],
          "line": 550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mapping_set_error",
          "args": [
            "&inode->i_data",
            "err"
          ],
          "line": 546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetPageError",
          "args": [
            "page"
          ],
          "line": 545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"writepage setting page/mapping error %d %p\\n\"",
            "err",
            "page"
          ],
          "line": 544
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_osdc_writepages",
          "args": [
            "osdc",
            "ceph_vino(inode)",
            "&ci->i_layout",
            "snapc",
            "page_off",
            "len",
            "truncate_seq",
            "truncate_size",
            "&inode->i_mtime",
            "&page",
            "1"
          ],
          "line": 538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_vino",
          "args": [
            "inode"
          ],
          "line": 538
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_vino_to_ino",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.h",
          "lines": "382-389",
          "snippet": "static inline ino_t ceph_vino_to_ino(struct ceph_vino vino)\n{\n#if BITS_PER_LONG == 32\n\treturn ceph_ino_to_ino32(vino.ino);\n#else\n\treturn (ino_t)vino.ino;\n#endif\n}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/ceph/libceph.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/backing-dev.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/ceph/libceph.h>\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n#include <linux/completion.h>\n#include <linux/backing-dev.h>\n#include <asm/unaligned.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline ino_t ceph_vino_to_ino(struct ceph_vino vino)\n{\n#if BITS_PER_LONG == 32\n\treturn ceph_ino_to_ino32(vino.ino);\n#else\n\treturn (ino_t)vino.ino;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_page_writeback",
          "args": [
            "page"
          ],
          "line": 537
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_set_page_writeback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
          "lines": "265-277",
          "snippet": "static void nfs_set_page_writeback(struct page *page)\n{\n\tstruct nfs_server *nfss = NFS_SERVER(page_file_mapping(page)->host);\n\tint ret = test_set_page_writeback(page);\n\n\tWARN_ON_ONCE(ret != 0);\n\n\tif (atomic_long_inc_return(&nfss->writeback) >\n\t\t\tNFS_CONGESTION_ON_THRESH) {\n\t\tset_bdi_congested(&nfss->backing_dev_info,\n\t\t\t\t\tBLK_RW_ASYNC);\n\t}\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define NFS_CONGESTION_ON_THRESH \t(nfs_congestion_kb >> (PAGE_SHIFT-10))"
          ],
          "globals_used": [
            "static struct nfs_page *\nnfs_page_search_commits_for_head_request_locked(struct nfs_inode *nfsi,\n\t\t\t\t\t\tstruct page *page);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\n#define NFS_CONGESTION_ON_THRESH \t(nfs_congestion_kb >> (PAGE_SHIFT-10))\n\nstatic struct nfs_page *\nnfs_page_search_commits_for_head_request_locked(struct nfs_inode *nfsi,\n\t\t\t\t\t\tstruct page *page);\n\nstatic void nfs_set_page_writeback(struct page *page)\n{\n\tstruct nfs_server *nfss = NFS_SERVER(page_file_mapping(page)->host);\n\tint ret = test_set_page_writeback(page);\n\n\tWARN_ON_ONCE(ret != 0);\n\n\tif (atomic_long_inc_return(&nfss->writeback) >\n\t\t\tNFS_CONGESTION_ON_THRESH) {\n\t\tset_bdi_congested(&nfss->backing_dev_info,\n\t\t\t\t\tBLK_RW_ASYNC);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_readpage_to_fscache",
          "args": [
            "inode",
            "page"
          ],
          "line": 535
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_readpage_to_fscache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/cache.c",
          "lines": "308-322",
          "snippet": "void ceph_readpage_to_fscache(struct inode *inode, struct page *page)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tint ret;\n\n\tif (!PageFsCache(page))\n\t\treturn;\n\n\tif (!cache_valid(ci))\n\t\treturn;\n\n\tret = fscache_write_page(ci->fscache, page, GFP_KERNEL);\n\tif (ret)\n\t\t fscache_uncache_page(ci->fscache, page);\n}",
          "includes": [
            "#include \"cache.h\"",
            "#include \"super.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cache.h\"\n#include \"super.h\"\n\nvoid ceph_readpage_to_fscache(struct inode *inode, struct page *page)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tint ret;\n\n\tif (!PageFsCache(page))\n\t\treturn;\n\n\tif (!cache_valid(ci))\n\t\treturn;\n\n\tret = fscache_write_page(ci->fscache, page, GFP_KERNEL);\n\tif (ret)\n\t\t fscache_uncache_page(ci->fscache, page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_bdi_congested",
          "args": [
            "&fsc->backing_dev_info",
            "BLK_RW_ASYNC"
          ],
          "line": 533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CONGESTION_ON_THRESH",
          "args": [
            "fsc->mount_options->congestion_kb"
          ],
          "line": 532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_long_inc_return",
          "args": [
            "&fsc->writeback_count"
          ],
          "line": 530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"writepage %p page %p index %lu on %llu~%u snapc %p\\n\"",
            "inode",
            "page",
            "page->index",
            "page_off",
            "len",
            "snapc"
          ],
          "line": 527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"%p page eof %llu\\n\"",
            "page",
            "snap_size"
          ],
          "line": 521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ci->i_ceph_lock"
          ],
          "line": 517
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ci->i_ceph_lock"
          ],
          "line": 512
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_put_snap_context",
          "args": [
            "oldest"
          ],
          "line": 510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_put_snap_context",
          "args": [
            "oldest"
          ],
          "line": 507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "(current->flags & PF_MEMALLOC) == 0"
          ],
          "line": 506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"writepage %p page %p snapc %p not writeable - noop\\n\"",
            "inode",
            "page",
            "snapc"
          ],
          "line": 503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_oldest_context",
          "args": [
            "inode",
            "&snap_size"
          ],
          "line": 501
        },
        "resolved": true,
        "details": {
          "function_name": "get_oldest_context",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/addr.c",
          "lines": "438-463",
          "snippet": "static struct ceph_snap_context *get_oldest_context(struct inode *inode,\n\t\t\t\t\t\t    u64 *snap_size)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tstruct ceph_snap_context *snapc = NULL;\n\tstruct ceph_cap_snap *capsnap = NULL;\n\n\tspin_lock(&ci->i_ceph_lock);\n\tlist_for_each_entry(capsnap, &ci->i_cap_snaps, ci_item) {\n\t\tdout(\" cap_snap %p snapc %p has %d dirty pages\\n\", capsnap,\n\t\t     capsnap->context, capsnap->dirty_pages);\n\t\tif (capsnap->dirty_pages) {\n\t\t\tsnapc = ceph_get_snap_context(capsnap->context);\n\t\t\tif (snap_size)\n\t\t\t\t*snap_size = capsnap->size;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!snapc && ci->i_wrbuffer_ref_head) {\n\t\tsnapc = ceph_get_snap_context(ci->i_head_snapc);\n\t\tdout(\" head snapc %p has %d dirty pages\\n\",\n\t\t     snapc, ci->i_wrbuffer_ref_head);\n\t}\n\tspin_unlock(&ci->i_ceph_lock);\n\treturn snapc;\n}",
          "includes": [
            "#include <linux/ceph/osd_client.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>\t/* generic_writepages */",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/osd_client.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/task_io_accounting_ops.h>\n#include <linux/pagevec.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\t/* generic_writepages */\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/backing-dev.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic struct ceph_snap_context *get_oldest_context(struct inode *inode,\n\t\t\t\t\t\t    u64 *snap_size)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tstruct ceph_snap_context *snapc = NULL;\n\tstruct ceph_cap_snap *capsnap = NULL;\n\n\tspin_lock(&ci->i_ceph_lock);\n\tlist_for_each_entry(capsnap, &ci->i_cap_snaps, ci_item) {\n\t\tdout(\" cap_snap %p snapc %p has %d dirty pages\\n\", capsnap,\n\t\t     capsnap->context, capsnap->dirty_pages);\n\t\tif (capsnap->dirty_pages) {\n\t\t\tsnapc = ceph_get_snap_context(capsnap->context);\n\t\t\tif (snap_size)\n\t\t\t\t*snap_size = capsnap->size;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!snapc && ci->i_wrbuffer_ref_head) {\n\t\tsnapc = ceph_get_snap_context(ci->i_head_snapc);\n\t\tdout(\" head snapc %p has %d dirty pages\\n\",\n\t\t     snapc, ci->i_wrbuffer_ref_head);\n\t}\n\tspin_unlock(&ci->i_ceph_lock);\n\treturn snapc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"writepage %p page %p not dirty?\\n\"",
            "inode",
            "page"
          ],
          "line": 498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_snap_context",
          "args": [
            "page"
          ],
          "line": 496
        },
        "resolved": true,
        "details": {
          "function_name": "page_snap_context",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/addr.c",
          "lines": "58-63",
          "snippet": "static inline struct ceph_snap_context *page_snap_context(struct page *page)\n{\n\tif (PagePrivate(page))\n\t\treturn (void *)page->private;\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/ceph/osd_client.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>\t/* generic_writepages */",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/osd_client.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/task_io_accounting_ops.h>\n#include <linux/pagevec.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\t/* generic_writepages */\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/backing-dev.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline struct ceph_snap_context *page_snap_context(struct page *page)\n{\n\tif (PagePrivate(page))\n\t\treturn (void *)page->private;\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_inode_to_client",
          "args": [
            "inode"
          ],
          "line": 492
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_inode_to_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.h",
          "lines": "347-350",
          "snippet": "static inline struct ceph_fs_client *ceph_inode_to_client(struct inode *inode)\n{\n\treturn (struct ceph_fs_client *)inode->i_sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/ceph/libceph.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/backing-dev.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/ceph/libceph.h>\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n#include <linux/completion.h>\n#include <linux/backing-dev.h>\n#include <asm/unaligned.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline struct ceph_fs_client *ceph_inode_to_client(struct inode *inode)\n{\n\treturn (struct ceph_fs_client *)inode->i_sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"writepage %p - no mapping\\n\"",
            "page"
          ],
          "line": 487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"writepage %p idx %lu\\n\"",
            "page",
            "page->index"
          ],
          "line": 484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_offset",
          "args": [
            "page"
          ],
          "line": 478
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/ceph/osd_client.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/task_io_accounting_ops.h>\n#include <linux/pagevec.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\t/* generic_writepages */\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/backing-dev.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic int writepage_nounlock(struct page *page, struct writeback_control *wbc)\n{\n\tstruct inode *inode;\n\tstruct ceph_inode_info *ci;\n\tstruct ceph_fs_client *fsc;\n\tstruct ceph_osd_client *osdc;\n\tstruct ceph_snap_context *snapc, *oldest;\n\tloff_t page_off = page_offset(page);\n\tlong writeback_stat;\n\tu64 truncate_size, snap_size = 0;\n\tu32 truncate_seq;\n\tint err = 0, len = PAGE_CACHE_SIZE;\n\n\tdout(\"writepage %p idx %lu\\n\", page, page->index);\n\n\tif (!page->mapping || !page->mapping->host) {\n\t\tdout(\"writepage %p - no mapping\\n\", page);\n\t\treturn -EFAULT;\n\t}\n\tinode = page->mapping->host;\n\tci = ceph_inode(inode);\n\tfsc = ceph_inode_to_client(inode);\n\tosdc = &fsc->client->osdc;\n\n\t/* verify this is a writeable snap context */\n\tsnapc = page_snap_context(page);\n\tif (snapc == NULL) {\n\t\tdout(\"writepage %p page %p not dirty?\\n\", inode, page);\n\t\tgoto out;\n\t}\n\toldest = get_oldest_context(inode, &snap_size);\n\tif (snapc->seq > oldest->seq) {\n\t\tdout(\"writepage %p page %p snapc %p not writeable - noop\\n\",\n\t\t     inode, page, snapc);\n\t\t/* we should only noop if called by kswapd */\n\t\tWARN_ON((current->flags & PF_MEMALLOC) == 0);\n\t\tceph_put_snap_context(oldest);\n\t\tgoto out;\n\t}\n\tceph_put_snap_context(oldest);\n\n\tspin_lock(&ci->i_ceph_lock);\n\ttruncate_seq = ci->i_truncate_seq;\n\ttruncate_size = ci->i_truncate_size;\n\tif (!snap_size)\n\t\tsnap_size = i_size_read(inode);\n\tspin_unlock(&ci->i_ceph_lock);\n\n\t/* is this a partial page at end of file? */\n\tif (page_off >= snap_size) {\n\t\tdout(\"%p page eof %llu\\n\", page, snap_size);\n\t\tgoto out;\n\t}\n\tif (snap_size < page_off + len)\n\t\tlen = snap_size - page_off;\n\n\tdout(\"writepage %p page %p index %lu on %llu~%u snapc %p\\n\",\n\t     inode, page, page->index, page_off, len, snapc);\n\n\twriteback_stat = atomic_long_inc_return(&fsc->writeback_count);\n\tif (writeback_stat >\n\t    CONGESTION_ON_THRESH(fsc->mount_options->congestion_kb))\n\t\tset_bdi_congested(&fsc->backing_dev_info, BLK_RW_ASYNC);\n\n\tceph_readpage_to_fscache(inode, page);\n\n\tset_page_writeback(page);\n\terr = ceph_osdc_writepages(osdc, ceph_vino(inode),\n\t\t\t\t   &ci->i_layout, snapc,\n\t\t\t\t   page_off, len,\n\t\t\t\t   truncate_seq, truncate_size,\n\t\t\t\t   &inode->i_mtime, &page, 1);\n\tif (err < 0) {\n\t\tdout(\"writepage setting page/mapping error %d %p\\n\", err, page);\n\t\tSetPageError(page);\n\t\tmapping_set_error(&inode->i_data, err);\n\t\tif (wbc)\n\t\t\twbc->pages_skipped++;\n\t} else {\n\t\tdout(\"writepage cleaned page %p\\n\", page);\n\t\terr = 0;  /* vfs expects us to return 0 */\n\t}\n\tpage->private = 0;\n\tClearPagePrivate(page);\n\tend_page_writeback(page);\n\tceph_put_wrbuffer_cap_refs(ci, 1, snapc);\n\tceph_put_snap_context(snapc);  /* page's reference */\nout:\n\treturn err;\n}"
  },
  {
    "function_name": "get_oldest_context",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/addr.c",
    "lines": "438-463",
    "snippet": "static struct ceph_snap_context *get_oldest_context(struct inode *inode,\n\t\t\t\t\t\t    u64 *snap_size)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tstruct ceph_snap_context *snapc = NULL;\n\tstruct ceph_cap_snap *capsnap = NULL;\n\n\tspin_lock(&ci->i_ceph_lock);\n\tlist_for_each_entry(capsnap, &ci->i_cap_snaps, ci_item) {\n\t\tdout(\" cap_snap %p snapc %p has %d dirty pages\\n\", capsnap,\n\t\t     capsnap->context, capsnap->dirty_pages);\n\t\tif (capsnap->dirty_pages) {\n\t\t\tsnapc = ceph_get_snap_context(capsnap->context);\n\t\t\tif (snap_size)\n\t\t\t\t*snap_size = capsnap->size;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!snapc && ci->i_wrbuffer_ref_head) {\n\t\tsnapc = ceph_get_snap_context(ci->i_head_snapc);\n\t\tdout(\" head snapc %p has %d dirty pages\\n\",\n\t\t     snapc, ci->i_wrbuffer_ref_head);\n\t}\n\tspin_unlock(&ci->i_ceph_lock);\n\treturn snapc;\n}",
    "includes": [
      "#include <linux/ceph/osd_client.h>",
      "#include \"cache.h\"",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/slab.h>",
      "#include <linux/writeback.h>\t/* generic_writepages */",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ci->i_ceph_lock"
          ],
          "line": 461
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\" head snapc %p has %d dirty pages\\n\"",
            "snapc",
            "ci->i_wrbuffer_ref_head"
          ],
          "line": 458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_get_snap_context",
          "args": [
            "ci->i_head_snapc"
          ],
          "line": 457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_get_snap_context",
          "args": [
            "capsnap->context"
          ],
          "line": 450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\" cap_snap %p snapc %p has %d dirty pages\\n\"",
            "capsnap",
            "capsnap->context",
            "capsnap->dirty_pages"
          ],
          "line": 447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "capsnap",
            "&ci->i_cap_snaps",
            "ci_item"
          ],
          "line": 446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ci->i_ceph_lock"
          ],
          "line": 445
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_inode",
          "args": [
            "inode"
          ],
          "line": 441
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_inode_to_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.h",
          "lines": "347-350",
          "snippet": "static inline struct ceph_fs_client *ceph_inode_to_client(struct inode *inode)\n{\n\treturn (struct ceph_fs_client *)inode->i_sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/ceph/libceph.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/backing-dev.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/ceph/libceph.h>\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n#include <linux/completion.h>\n#include <linux/backing-dev.h>\n#include <asm/unaligned.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline struct ceph_fs_client *ceph_inode_to_client(struct inode *inode)\n{\n\treturn (struct ceph_fs_client *)inode->i_sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/ceph/osd_client.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/task_io_accounting_ops.h>\n#include <linux/pagevec.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\t/* generic_writepages */\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/backing-dev.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic struct ceph_snap_context *get_oldest_context(struct inode *inode,\n\t\t\t\t\t\t    u64 *snap_size)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tstruct ceph_snap_context *snapc = NULL;\n\tstruct ceph_cap_snap *capsnap = NULL;\n\n\tspin_lock(&ci->i_ceph_lock);\n\tlist_for_each_entry(capsnap, &ci->i_cap_snaps, ci_item) {\n\t\tdout(\" cap_snap %p snapc %p has %d dirty pages\\n\", capsnap,\n\t\t     capsnap->context, capsnap->dirty_pages);\n\t\tif (capsnap->dirty_pages) {\n\t\t\tsnapc = ceph_get_snap_context(capsnap->context);\n\t\t\tif (snap_size)\n\t\t\t\t*snap_size = capsnap->size;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!snapc && ci->i_wrbuffer_ref_head) {\n\t\tsnapc = ceph_get_snap_context(ci->i_head_snapc);\n\t\tdout(\" head snapc %p has %d dirty pages\\n\",\n\t\t     snapc, ci->i_wrbuffer_ref_head);\n\t}\n\tspin_unlock(&ci->i_ceph_lock);\n\treturn snapc;\n}"
  },
  {
    "function_name": "ceph_readpages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/addr.c",
    "lines": "397-432",
    "snippet": "static int ceph_readpages(struct file *file, struct address_space *mapping,\n\t\t\t  struct list_head *page_list, unsigned nr_pages)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct ceph_fs_client *fsc = ceph_inode_to_client(inode);\n\tint rc = 0;\n\tint max = 0;\n\n\tif (ceph_inode(inode)->i_inline_version != CEPH_INLINE_NONE)\n\t\treturn -EINVAL;\n\n\trc = ceph_readpages_from_fscache(mapping->host, mapping, page_list,\n\t\t\t\t\t &nr_pages);\n\n\tif (rc == 0)\n\t\tgoto out;\n\n\tif (fsc->mount_options->rsize >= PAGE_CACHE_SIZE)\n\t\tmax = (fsc->mount_options->rsize + PAGE_CACHE_SIZE - 1)\n\t\t\t>> PAGE_SHIFT;\n\n\tdout(\"readpages %p file %p nr_pages %d max %d\\n\", inode,\n\t\tfile, nr_pages,\n\t     max);\n\twhile (!list_empty(page_list)) {\n\t\trc = start_read(inode, page_list, max);\n\t\tif (rc < 0)\n\t\t\tgoto out;\n\t\tBUG_ON(rc == 0);\n\t}\nout:\n\tceph_fscache_readpages_cancel(inode, page_list);\n\n\tdout(\"readpages %p file %p ret %d\\n\", inode, file, rc);\n\treturn rc;\n}",
    "includes": [
      "#include <linux/ceph/osd_client.h>",
      "#include \"cache.h\"",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/slab.h>",
      "#include <linux/writeback.h>\t/* generic_writepages */",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"readpages %p file %p ret %d\\n\"",
            "inode",
            "file",
            "rc"
          ],
          "line": 430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_fscache_readpages_cancel",
          "args": [
            "inode",
            "page_list"
          ],
          "line": 428
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_fscache_readpages_cancel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/cache.h",
          "lines": "171-174",
          "snippet": "static inline void ceph_fscache_readpages_cancel(struct inode *inode,\n\t\t\t\t\t\t struct list_head *pages)\n{\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void ceph_fscache_readpages_cancel(struct inode *inode,\n\t\t\t\t\t\t struct list_head *pages)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "rc == 0"
          ],
          "line": 425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "start_read",
          "args": [
            "inode",
            "page_list",
            "max"
          ],
          "line": 422
        },
        "resolved": true,
        "details": {
          "function_name": "start_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/addr.c",
          "lines": "307-390",
          "snippet": "static int start_read(struct inode *inode, struct list_head *page_list, int max)\n{\n\tstruct ceph_osd_client *osdc =\n\t\t&ceph_inode_to_client(inode)->client->osdc;\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tstruct page *page = list_entry(page_list->prev, struct page, lru);\n\tstruct ceph_vino vino;\n\tstruct ceph_osd_request *req;\n\tu64 off;\n\tu64 len;\n\tint i;\n\tstruct page **pages;\n\tpgoff_t next_index;\n\tint nr_pages = 0;\n\tint ret;\n\n\toff = (u64) page_offset(page);\n\n\t/* count pages */\n\tnext_index = page->index;\n\tlist_for_each_entry_reverse(page, page_list, lru) {\n\t\tif (page->index != next_index)\n\t\t\tbreak;\n\t\tnr_pages++;\n\t\tnext_index++;\n\t\tif (max && nr_pages == max)\n\t\t\tbreak;\n\t}\n\tlen = nr_pages << PAGE_CACHE_SHIFT;\n\tdout(\"start_read %p nr_pages %d is %lld~%lld\\n\", inode, nr_pages,\n\t     off, len);\n\tvino = ceph_vino(inode);\n\treq = ceph_osdc_new_request(osdc, &ci->i_layout, vino, off, &len,\n\t\t\t\t    0, 1, CEPH_OSD_OP_READ,\n\t\t\t\t    CEPH_OSD_FLAG_READ, NULL,\n\t\t\t\t    ci->i_truncate_seq, ci->i_truncate_size,\n\t\t\t\t    false);\n\tif (IS_ERR(req))\n\t\treturn PTR_ERR(req);\n\n\t/* build page vector */\n\tnr_pages = calc_pages_for(0, len);\n\tpages = kmalloc(sizeof(*pages) * nr_pages, GFP_NOFS);\n\tret = -ENOMEM;\n\tif (!pages)\n\t\tgoto out;\n\tfor (i = 0; i < nr_pages; ++i) {\n\t\tpage = list_entry(page_list->prev, struct page, lru);\n\t\tBUG_ON(PageLocked(page));\n\t\tlist_del(&page->lru);\n\n \t\tdout(\"start_read %p adding %p idx %lu\\n\", inode, page,\n\t\t     page->index);\n\t\tif (add_to_page_cache_lru(page, &inode->i_data, page->index,\n\t\t\t\t\t  GFP_NOFS)) {\n\t\t\tceph_fscache_uncache_page(inode, page);\n\t\t\tpage_cache_release(page);\n\t\t\tdout(\"start_read %p add_to_page_cache failed %p\\n\",\n\t\t\t     inode, page);\n\t\t\tnr_pages = i;\n\t\t\tgoto out_pages;\n\t\t}\n\t\tpages[i] = page;\n\t}\n\tosd_req_op_extent_osd_data_pages(req, 0, pages, len, 0, false, false);\n\treq->r_callback = finish_read;\n\treq->r_inode = inode;\n\n\tceph_osdc_build_request(req, off, NULL, vino.snap, NULL);\n\n\tdout(\"start_read %p starting %p %lld~%lld\\n\", inode, req, off, len);\n\tret = ceph_osdc_start_request(osdc, req, false);\n\tif (ret < 0)\n\t\tgoto out_pages;\n\tceph_osdc_put_request(req);\n\treturn nr_pages;\n\nout_pages:\n\tceph_unlock_page_vector(pages, nr_pages);\n\tceph_release_page_vector(pages, nr_pages);\nout:\n\tceph_osdc_put_request(req);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/ceph/osd_client.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>\t/* generic_writepages */",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/osd_client.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/task_io_accounting_ops.h>\n#include <linux/pagevec.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\t/* generic_writepages */\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/backing-dev.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic int start_read(struct inode *inode, struct list_head *page_list, int max)\n{\n\tstruct ceph_osd_client *osdc =\n\t\t&ceph_inode_to_client(inode)->client->osdc;\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tstruct page *page = list_entry(page_list->prev, struct page, lru);\n\tstruct ceph_vino vino;\n\tstruct ceph_osd_request *req;\n\tu64 off;\n\tu64 len;\n\tint i;\n\tstruct page **pages;\n\tpgoff_t next_index;\n\tint nr_pages = 0;\n\tint ret;\n\n\toff = (u64) page_offset(page);\n\n\t/* count pages */\n\tnext_index = page->index;\n\tlist_for_each_entry_reverse(page, page_list, lru) {\n\t\tif (page->index != next_index)\n\t\t\tbreak;\n\t\tnr_pages++;\n\t\tnext_index++;\n\t\tif (max && nr_pages == max)\n\t\t\tbreak;\n\t}\n\tlen = nr_pages << PAGE_CACHE_SHIFT;\n\tdout(\"start_read %p nr_pages %d is %lld~%lld\\n\", inode, nr_pages,\n\t     off, len);\n\tvino = ceph_vino(inode);\n\treq = ceph_osdc_new_request(osdc, &ci->i_layout, vino, off, &len,\n\t\t\t\t    0, 1, CEPH_OSD_OP_READ,\n\t\t\t\t    CEPH_OSD_FLAG_READ, NULL,\n\t\t\t\t    ci->i_truncate_seq, ci->i_truncate_size,\n\t\t\t\t    false);\n\tif (IS_ERR(req))\n\t\treturn PTR_ERR(req);\n\n\t/* build page vector */\n\tnr_pages = calc_pages_for(0, len);\n\tpages = kmalloc(sizeof(*pages) * nr_pages, GFP_NOFS);\n\tret = -ENOMEM;\n\tif (!pages)\n\t\tgoto out;\n\tfor (i = 0; i < nr_pages; ++i) {\n\t\tpage = list_entry(page_list->prev, struct page, lru);\n\t\tBUG_ON(PageLocked(page));\n\t\tlist_del(&page->lru);\n\n \t\tdout(\"start_read %p adding %p idx %lu\\n\", inode, page,\n\t\t     page->index);\n\t\tif (add_to_page_cache_lru(page, &inode->i_data, page->index,\n\t\t\t\t\t  GFP_NOFS)) {\n\t\t\tceph_fscache_uncache_page(inode, page);\n\t\t\tpage_cache_release(page);\n\t\t\tdout(\"start_read %p add_to_page_cache failed %p\\n\",\n\t\t\t     inode, page);\n\t\t\tnr_pages = i;\n\t\t\tgoto out_pages;\n\t\t}\n\t\tpages[i] = page;\n\t}\n\tosd_req_op_extent_osd_data_pages(req, 0, pages, len, 0, false, false);\n\treq->r_callback = finish_read;\n\treq->r_inode = inode;\n\n\tceph_osdc_build_request(req, off, NULL, vino.snap, NULL);\n\n\tdout(\"start_read %p starting %p %lld~%lld\\n\", inode, req, off, len);\n\tret = ceph_osdc_start_request(osdc, req, false);\n\tif (ret < 0)\n\t\tgoto out_pages;\n\tceph_osdc_put_request(req);\n\treturn nr_pages;\n\nout_pages:\n\tceph_unlock_page_vector(pages, nr_pages);\n\tceph_release_page_vector(pages, nr_pages);\nout:\n\tceph_osdc_put_request(req);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "page_list"
          ],
          "line": 421
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"readpages %p file %p nr_pages %d max %d\\n\"",
            "inode",
            "file",
            "nr_pages",
            "max"
          ],
          "line": 418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_readpages_from_fscache",
          "args": [
            "mapping->host",
            "mapping",
            "page_list",
            "&nr_pages"
          ],
          "line": 408
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_readpages_from_fscache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/cache.c",
          "lines": "279-306",
          "snippet": "int ceph_readpages_from_fscache(struct inode *inode,\n\t\t\t\t  struct address_space *mapping,\n\t\t\t\t  struct list_head *pages,\n\t\t\t\t  unsigned *nr_pages)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tint ret;\n\n\tif (!cache_valid(ci))\n\t\treturn -ENOBUFS;\n\n\tret = fscache_read_or_alloc_pages(ci->fscache, mapping, pages, nr_pages,\n\t\t\t\t\t  ceph_vfs_readpage_complete_unlock,\n\t\t\t\t\t  NULL, mapping_gfp_mask(mapping));\n\n\tswitch (ret) {\n\t\tcase 0: /* All pages found */\n\t\t\tdout(\"all-page read submitted\\n\");\n\t\t\treturn 0;\n\t\tcase -ENOBUFS: /* Some pages were not found, and can't be */\n\t\tcase -ENODATA: /* some pages were not found */\n\t\t\tdout(\"page/inode not in cache\\n\");\n\t\t\treturn ret;\n\t\tdefault:\n\t\t\tdout(\"%s: unknown error ret = %i\\n\", __func__, ret);\n\t\t\treturn ret;\n\t}\n}",
          "includes": [
            "#include \"cache.h\"",
            "#include \"super.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cache.h\"\n#include \"super.h\"\n\nint ceph_readpages_from_fscache(struct inode *inode,\n\t\t\t\t  struct address_space *mapping,\n\t\t\t\t  struct list_head *pages,\n\t\t\t\t  unsigned *nr_pages)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tint ret;\n\n\tif (!cache_valid(ci))\n\t\treturn -ENOBUFS;\n\n\tret = fscache_read_or_alloc_pages(ci->fscache, mapping, pages, nr_pages,\n\t\t\t\t\t  ceph_vfs_readpage_complete_unlock,\n\t\t\t\t\t  NULL, mapping_gfp_mask(mapping));\n\n\tswitch (ret) {\n\t\tcase 0: /* All pages found */\n\t\t\tdout(\"all-page read submitted\\n\");\n\t\t\treturn 0;\n\t\tcase -ENOBUFS: /* Some pages were not found, and can't be */\n\t\tcase -ENODATA: /* some pages were not found */\n\t\t\tdout(\"page/inode not in cache\\n\");\n\t\t\treturn ret;\n\t\tdefault:\n\t\t\tdout(\"%s: unknown error ret = %i\\n\", __func__, ret);\n\t\t\treturn ret;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_inode",
          "args": [
            "inode"
          ],
          "line": 405
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_inode_to_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.h",
          "lines": "347-350",
          "snippet": "static inline struct ceph_fs_client *ceph_inode_to_client(struct inode *inode)\n{\n\treturn (struct ceph_fs_client *)inode->i_sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/ceph/libceph.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/backing-dev.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/ceph/libceph.h>\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n#include <linux/completion.h>\n#include <linux/backing-dev.h>\n#include <asm/unaligned.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline struct ceph_fs_client *ceph_inode_to_client(struct inode *inode)\n{\n\treturn (struct ceph_fs_client *)inode->i_sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 400
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/ceph/osd_client.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/task_io_accounting_ops.h>\n#include <linux/pagevec.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\t/* generic_writepages */\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/backing-dev.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic int ceph_readpages(struct file *file, struct address_space *mapping,\n\t\t\t  struct list_head *page_list, unsigned nr_pages)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct ceph_fs_client *fsc = ceph_inode_to_client(inode);\n\tint rc = 0;\n\tint max = 0;\n\n\tif (ceph_inode(inode)->i_inline_version != CEPH_INLINE_NONE)\n\t\treturn -EINVAL;\n\n\trc = ceph_readpages_from_fscache(mapping->host, mapping, page_list,\n\t\t\t\t\t &nr_pages);\n\n\tif (rc == 0)\n\t\tgoto out;\n\n\tif (fsc->mount_options->rsize >= PAGE_CACHE_SIZE)\n\t\tmax = (fsc->mount_options->rsize + PAGE_CACHE_SIZE - 1)\n\t\t\t>> PAGE_SHIFT;\n\n\tdout(\"readpages %p file %p nr_pages %d max %d\\n\", inode,\n\t\tfile, nr_pages,\n\t     max);\n\twhile (!list_empty(page_list)) {\n\t\trc = start_read(inode, page_list, max);\n\t\tif (rc < 0)\n\t\t\tgoto out;\n\t\tBUG_ON(rc == 0);\n\t}\nout:\n\tceph_fscache_readpages_cancel(inode, page_list);\n\n\tdout(\"readpages %p file %p ret %d\\n\", inode, file, rc);\n\treturn rc;\n}"
  },
  {
    "function_name": "start_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/addr.c",
    "lines": "307-390",
    "snippet": "static int start_read(struct inode *inode, struct list_head *page_list, int max)\n{\n\tstruct ceph_osd_client *osdc =\n\t\t&ceph_inode_to_client(inode)->client->osdc;\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tstruct page *page = list_entry(page_list->prev, struct page, lru);\n\tstruct ceph_vino vino;\n\tstruct ceph_osd_request *req;\n\tu64 off;\n\tu64 len;\n\tint i;\n\tstruct page **pages;\n\tpgoff_t next_index;\n\tint nr_pages = 0;\n\tint ret;\n\n\toff = (u64) page_offset(page);\n\n\t/* count pages */\n\tnext_index = page->index;\n\tlist_for_each_entry_reverse(page, page_list, lru) {\n\t\tif (page->index != next_index)\n\t\t\tbreak;\n\t\tnr_pages++;\n\t\tnext_index++;\n\t\tif (max && nr_pages == max)\n\t\t\tbreak;\n\t}\n\tlen = nr_pages << PAGE_CACHE_SHIFT;\n\tdout(\"start_read %p nr_pages %d is %lld~%lld\\n\", inode, nr_pages,\n\t     off, len);\n\tvino = ceph_vino(inode);\n\treq = ceph_osdc_new_request(osdc, &ci->i_layout, vino, off, &len,\n\t\t\t\t    0, 1, CEPH_OSD_OP_READ,\n\t\t\t\t    CEPH_OSD_FLAG_READ, NULL,\n\t\t\t\t    ci->i_truncate_seq, ci->i_truncate_size,\n\t\t\t\t    false);\n\tif (IS_ERR(req))\n\t\treturn PTR_ERR(req);\n\n\t/* build page vector */\n\tnr_pages = calc_pages_for(0, len);\n\tpages = kmalloc(sizeof(*pages) * nr_pages, GFP_NOFS);\n\tret = -ENOMEM;\n\tif (!pages)\n\t\tgoto out;\n\tfor (i = 0; i < nr_pages; ++i) {\n\t\tpage = list_entry(page_list->prev, struct page, lru);\n\t\tBUG_ON(PageLocked(page));\n\t\tlist_del(&page->lru);\n\n \t\tdout(\"start_read %p adding %p idx %lu\\n\", inode, page,\n\t\t     page->index);\n\t\tif (add_to_page_cache_lru(page, &inode->i_data, page->index,\n\t\t\t\t\t  GFP_NOFS)) {\n\t\t\tceph_fscache_uncache_page(inode, page);\n\t\t\tpage_cache_release(page);\n\t\t\tdout(\"start_read %p add_to_page_cache failed %p\\n\",\n\t\t\t     inode, page);\n\t\t\tnr_pages = i;\n\t\t\tgoto out_pages;\n\t\t}\n\t\tpages[i] = page;\n\t}\n\tosd_req_op_extent_osd_data_pages(req, 0, pages, len, 0, false, false);\n\treq->r_callback = finish_read;\n\treq->r_inode = inode;\n\n\tceph_osdc_build_request(req, off, NULL, vino.snap, NULL);\n\n\tdout(\"start_read %p starting %p %lld~%lld\\n\", inode, req, off, len);\n\tret = ceph_osdc_start_request(osdc, req, false);\n\tif (ret < 0)\n\t\tgoto out_pages;\n\tceph_osdc_put_request(req);\n\treturn nr_pages;\n\nout_pages:\n\tceph_unlock_page_vector(pages, nr_pages);\n\tceph_release_page_vector(pages, nr_pages);\nout:\n\tceph_osdc_put_request(req);\n\treturn ret;\n}",
    "includes": [
      "#include <linux/ceph/osd_client.h>",
      "#include \"cache.h\"",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/slab.h>",
      "#include <linux/writeback.h>\t/* generic_writepages */",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ceph_osdc_put_request",
          "args": [
            "req"
          ],
          "line": 388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_release_page_vector",
          "args": [
            "pages",
            "nr_pages"
          ],
          "line": 386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_unlock_page_vector",
          "args": [
            "pages",
            "nr_pages"
          ],
          "line": 385
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_unlock_page_vector",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/addr.c",
          "lines": "295-301",
          "snippet": "static void ceph_unlock_page_vector(struct page **pages, int num_pages)\n{\n\tint i;\n\n\tfor (i = 0; i < num_pages; i++)\n\t\tunlock_page(pages[i]);\n}",
          "includes": [
            "#include <linux/ceph/osd_client.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>\t/* generic_writepages */",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/osd_client.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/task_io_accounting_ops.h>\n#include <linux/pagevec.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\t/* generic_writepages */\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/backing-dev.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void ceph_unlock_page_vector(struct page **pages, int num_pages)\n{\n\tint i;\n\n\tfor (i = 0; i < num_pages; i++)\n\t\tunlock_page(pages[i]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_osdc_put_request",
          "args": [
            "req"
          ],
          "line": 381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_osdc_start_request",
          "args": [
            "osdc",
            "req",
            "false"
          ],
          "line": 378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"start_read %p starting %p %lld~%lld\\n\"",
            "inode",
            "req",
            "off",
            "len"
          ],
          "line": 377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_osdc_build_request",
          "args": [
            "req",
            "off",
            "NULL",
            "vino.snap",
            "NULL"
          ],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "osd_req_op_extent_osd_data_pages",
          "args": [
            "req",
            "0",
            "pages",
            "len",
            "0",
            "false",
            "false"
          ],
          "line": 371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"start_read %p add_to_page_cache failed %p\\n\"",
            "inode",
            "page"
          ],
          "line": 364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "page"
          ],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_fscache_uncache_page",
          "args": [
            "inode",
            "page"
          ],
          "line": 362
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_fscache_uncache_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/cache.h",
          "lines": "120-123",
          "snippet": "static inline void ceph_fscache_uncache_page(struct inode *inode,\n\t\t\t\t\t     struct page *pages)\n{\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void ceph_fscache_uncache_page(struct inode *inode,\n\t\t\t\t\t     struct page *pages)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "add_to_page_cache_lru",
          "args": [
            "page",
            "&inode->i_data",
            "page->index",
            "GFP_NOFS"
          ],
          "line": 360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"start_read %p adding %p idx %lu\\n\"",
            "inode",
            "page",
            "page->index"
          ],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&page->lru"
          ],
          "line": 356
        },
        "resolved": true,
        "details": {
          "function_name": "inode_sb_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "433-440",
          "snippet": "static inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\n__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "PageLocked(page)"
          ],
          "line": 355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageLocked",
          "args": [
            "page"
          ],
          "line": 355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "page_list->prev",
            "structpage",
            "lru"
          ],
          "line": 354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(*pages) * nr_pages",
            "GFP_NOFS"
          ],
          "line": 349
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "calc_pages_for",
          "args": [
            "0",
            "len"
          ],
          "line": 348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "req"
          ],
          "line": 345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "req"
          ],
          "line": 344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_osdc_new_request",
          "args": [
            "osdc",
            "&ci->i_layout",
            "vino",
            "off",
            "&len",
            "0",
            "1",
            "CEPH_OSD_OP_READ",
            "CEPH_OSD_FLAG_READ",
            "NULL",
            "ci->i_truncate_seq",
            "ci->i_truncate_size",
            "false"
          ],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_vino",
          "args": [
            "inode"
          ],
          "line": 338
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_vino_to_ino",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.h",
          "lines": "382-389",
          "snippet": "static inline ino_t ceph_vino_to_ino(struct ceph_vino vino)\n{\n#if BITS_PER_LONG == 32\n\treturn ceph_ino_to_ino32(vino.ino);\n#else\n\treturn (ino_t)vino.ino;\n#endif\n}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/ceph/libceph.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/backing-dev.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/ceph/libceph.h>\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n#include <linux/completion.h>\n#include <linux/backing-dev.h>\n#include <asm/unaligned.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline ino_t ceph_vino_to_ino(struct ceph_vino vino)\n{\n#if BITS_PER_LONG == 32\n\treturn ceph_ino_to_ino32(vino.ino);\n#else\n\treturn (ino_t)vino.ino;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"start_read %p nr_pages %d is %lld~%lld\\n\"",
            "inode",
            "nr_pages",
            "off",
            "len"
          ],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_reverse",
          "args": [
            "page",
            "page_list",
            "lru"
          ],
          "line": 327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_offset",
          "args": [
            "page"
          ],
          "line": 323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "page_list->prev",
            "structpage",
            "lru"
          ],
          "line": 312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_inode",
          "args": [
            "inode"
          ],
          "line": 311
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_inode_to_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.h",
          "lines": "347-350",
          "snippet": "static inline struct ceph_fs_client *ceph_inode_to_client(struct inode *inode)\n{\n\treturn (struct ceph_fs_client *)inode->i_sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/ceph/libceph.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/backing-dev.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/ceph/libceph.h>\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n#include <linux/completion.h>\n#include <linux/backing-dev.h>\n#include <asm/unaligned.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline struct ceph_fs_client *ceph_inode_to_client(struct inode *inode)\n{\n\treturn (struct ceph_fs_client *)inode->i_sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/ceph/osd_client.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/task_io_accounting_ops.h>\n#include <linux/pagevec.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\t/* generic_writepages */\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/backing-dev.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic int start_read(struct inode *inode, struct list_head *page_list, int max)\n{\n\tstruct ceph_osd_client *osdc =\n\t\t&ceph_inode_to_client(inode)->client->osdc;\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tstruct page *page = list_entry(page_list->prev, struct page, lru);\n\tstruct ceph_vino vino;\n\tstruct ceph_osd_request *req;\n\tu64 off;\n\tu64 len;\n\tint i;\n\tstruct page **pages;\n\tpgoff_t next_index;\n\tint nr_pages = 0;\n\tint ret;\n\n\toff = (u64) page_offset(page);\n\n\t/* count pages */\n\tnext_index = page->index;\n\tlist_for_each_entry_reverse(page, page_list, lru) {\n\t\tif (page->index != next_index)\n\t\t\tbreak;\n\t\tnr_pages++;\n\t\tnext_index++;\n\t\tif (max && nr_pages == max)\n\t\t\tbreak;\n\t}\n\tlen = nr_pages << PAGE_CACHE_SHIFT;\n\tdout(\"start_read %p nr_pages %d is %lld~%lld\\n\", inode, nr_pages,\n\t     off, len);\n\tvino = ceph_vino(inode);\n\treq = ceph_osdc_new_request(osdc, &ci->i_layout, vino, off, &len,\n\t\t\t\t    0, 1, CEPH_OSD_OP_READ,\n\t\t\t\t    CEPH_OSD_FLAG_READ, NULL,\n\t\t\t\t    ci->i_truncate_seq, ci->i_truncate_size,\n\t\t\t\t    false);\n\tif (IS_ERR(req))\n\t\treturn PTR_ERR(req);\n\n\t/* build page vector */\n\tnr_pages = calc_pages_for(0, len);\n\tpages = kmalloc(sizeof(*pages) * nr_pages, GFP_NOFS);\n\tret = -ENOMEM;\n\tif (!pages)\n\t\tgoto out;\n\tfor (i = 0; i < nr_pages; ++i) {\n\t\tpage = list_entry(page_list->prev, struct page, lru);\n\t\tBUG_ON(PageLocked(page));\n\t\tlist_del(&page->lru);\n\n \t\tdout(\"start_read %p adding %p idx %lu\\n\", inode, page,\n\t\t     page->index);\n\t\tif (add_to_page_cache_lru(page, &inode->i_data, page->index,\n\t\t\t\t\t  GFP_NOFS)) {\n\t\t\tceph_fscache_uncache_page(inode, page);\n\t\t\tpage_cache_release(page);\n\t\t\tdout(\"start_read %p add_to_page_cache failed %p\\n\",\n\t\t\t     inode, page);\n\t\t\tnr_pages = i;\n\t\t\tgoto out_pages;\n\t\t}\n\t\tpages[i] = page;\n\t}\n\tosd_req_op_extent_osd_data_pages(req, 0, pages, len, 0, false, false);\n\treq->r_callback = finish_read;\n\treq->r_inode = inode;\n\n\tceph_osdc_build_request(req, off, NULL, vino.snap, NULL);\n\n\tdout(\"start_read %p starting %p %lld~%lld\\n\", inode, req, off, len);\n\tret = ceph_osdc_start_request(osdc, req, false);\n\tif (ret < 0)\n\t\tgoto out_pages;\n\tceph_osdc_put_request(req);\n\treturn nr_pages;\n\nout_pages:\n\tceph_unlock_page_vector(pages, nr_pages);\n\tceph_release_page_vector(pages, nr_pages);\nout:\n\tceph_osdc_put_request(req);\n\treturn ret;\n}"
  },
  {
    "function_name": "ceph_unlock_page_vector",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/addr.c",
    "lines": "295-301",
    "snippet": "static void ceph_unlock_page_vector(struct page **pages, int num_pages)\n{\n\tint i;\n\n\tfor (i = 0; i < num_pages; i++)\n\t\tunlock_page(pages[i]);\n}",
    "includes": [
      "#include <linux/ceph/osd_client.h>",
      "#include \"cache.h\"",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/slab.h>",
      "#include <linux/writeback.h>\t/* generic_writepages */",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "pages[i]"
          ],
          "line": 300
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/ceph/osd_client.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/task_io_accounting_ops.h>\n#include <linux/pagevec.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\t/* generic_writepages */\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/backing-dev.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void ceph_unlock_page_vector(struct page **pages, int num_pages)\n{\n\tint i;\n\n\tfor (i = 0; i < num_pages; i++)\n\t\tunlock_page(pages[i]);\n}"
  },
  {
    "function_name": "finish_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/addr.c",
    "lines": "256-293",
    "snippet": "static void finish_read(struct ceph_osd_request *req, struct ceph_msg *msg)\n{\n\tstruct inode *inode = req->r_inode;\n\tstruct ceph_osd_data *osd_data;\n\tint rc = req->r_result;\n\tint bytes = le32_to_cpu(msg->hdr.data_len);\n\tint num_pages;\n\tint i;\n\n\tdout(\"finish_read %p req %p rc %d bytes %d\\n\", inode, req, rc, bytes);\n\n\t/* unlock all pages, zeroing any data we didn't read */\n\tosd_data = osd_req_op_extent_osd_data(req, 0);\n\tBUG_ON(osd_data->type != CEPH_OSD_DATA_TYPE_PAGES);\n\tnum_pages = calc_pages_for((u64)osd_data->alignment,\n\t\t\t\t\t(u64)osd_data->length);\n\tfor (i = 0; i < num_pages; i++) {\n\t\tstruct page *page = osd_data->pages[i];\n\n\t\tif (rc < 0)\n\t\t\tgoto unlock;\n\t\tif (bytes < (int)PAGE_CACHE_SIZE) {\n\t\t\t/* zero (remainder of) page */\n\t\t\tint s = bytes < 0 ? 0 : bytes;\n\t\t\tzero_user_segment(page, s, PAGE_CACHE_SIZE);\n\t\t}\n \t\tdout(\"finish_read %p uptodate %p idx %lu\\n\", inode, page,\n\t\t     page->index);\n\t\tflush_dcache_page(page);\n\t\tSetPageUptodate(page);\n\t\tceph_readpage_to_fscache(inode, page);\nunlock:\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t\tbytes -= PAGE_CACHE_SIZE;\n\t}\n\tkfree(osd_data->pages);\n}",
    "includes": [
      "#include <linux/ceph/osd_client.h>",
      "#include \"cache.h\"",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/slab.h>",
      "#include <linux/writeback.h>\t/* generic_writepages */",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "osd_data->pages"
          ],
          "line": 292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "page"
          ],
          "line": 289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 288
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_readpage_to_fscache",
          "args": [
            "inode",
            "page"
          ],
          "line": 286
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_readpage_to_fscache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/cache.c",
          "lines": "308-322",
          "snippet": "void ceph_readpage_to_fscache(struct inode *inode, struct page *page)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tint ret;\n\n\tif (!PageFsCache(page))\n\t\treturn;\n\n\tif (!cache_valid(ci))\n\t\treturn;\n\n\tret = fscache_write_page(ci->fscache, page, GFP_KERNEL);\n\tif (ret)\n\t\t fscache_uncache_page(ci->fscache, page);\n}",
          "includes": [
            "#include \"cache.h\"",
            "#include \"super.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cache.h\"\n#include \"super.h\"\n\nvoid ceph_readpage_to_fscache(struct inode *inode, struct page *page)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tint ret;\n\n\tif (!PageFsCache(page))\n\t\treturn;\n\n\tif (!cache_valid(ci))\n\t\treturn;\n\n\tret = fscache_write_page(ci->fscache, page, GFP_KERNEL);\n\tif (ret)\n\t\t fscache_uncache_page(ci->fscache, page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SetPageUptodate",
          "args": [
            "page"
          ],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flush_dcache_page",
          "args": [
            "page"
          ],
          "line": 284
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_index_entry_flush_dcache_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/index.h",
          "lines": "111-117",
          "snippet": "static inline void ntfs_index_entry_flush_dcache_page(ntfs_index_context *ictx)\n{\n\tif (ictx->is_in_root)\n\t\tflush_dcache_mft_record_page(ictx->actx->ntfs_ino);\n\telse\n\t\tflush_dcache_page(ictx->page);\n}",
          "includes": [
            "#include \"aops.h\"",
            "#include \"mft.h\"",
            "#include \"attrib.h\"",
            "#include \"inode.h\"",
            "#include \"layout.h\"",
            "#include \"types.h\"",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"aops.h\"\n#include \"mft.h\"\n#include \"attrib.h\"\n#include \"inode.h\"\n#include \"layout.h\"\n#include \"types.h\"\n#include <linux/fs.h>\n\nstatic inline void ntfs_index_entry_flush_dcache_page(ntfs_index_context *ictx)\n{\n\tif (ictx->is_in_root)\n\t\tflush_dcache_mft_record_page(ictx->actx->ntfs_ino);\n\telse\n\t\tflush_dcache_page(ictx->page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"finish_read %p uptodate %p idx %lu\\n\"",
            "inode",
            "page",
            "page->index"
          ],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zero_user_segment",
          "args": [
            "page",
            "s",
            "PAGE_CACHE_SIZE"
          ],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "calc_pages_for",
          "args": [
            "(u64)osd_data->alignment",
            "(u64)osd_data->length"
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "osd_data->type != CEPH_OSD_DATA_TYPE_PAGES"
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "osd_req_op_extent_osd_data",
          "args": [
            "req",
            "0"
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"finish_read %p req %p rc %d bytes %d\\n\"",
            "inode",
            "req",
            "rc",
            "bytes"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "msg->hdr.data_len"
          ],
          "line": 261
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/ceph/osd_client.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/task_io_accounting_ops.h>\n#include <linux/pagevec.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\t/* generic_writepages */\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/backing-dev.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void finish_read(struct ceph_osd_request *req, struct ceph_msg *msg)\n{\n\tstruct inode *inode = req->r_inode;\n\tstruct ceph_osd_data *osd_data;\n\tint rc = req->r_result;\n\tint bytes = le32_to_cpu(msg->hdr.data_len);\n\tint num_pages;\n\tint i;\n\n\tdout(\"finish_read %p req %p rc %d bytes %d\\n\", inode, req, rc, bytes);\n\n\t/* unlock all pages, zeroing any data we didn't read */\n\tosd_data = osd_req_op_extent_osd_data(req, 0);\n\tBUG_ON(osd_data->type != CEPH_OSD_DATA_TYPE_PAGES);\n\tnum_pages = calc_pages_for((u64)osd_data->alignment,\n\t\t\t\t\t(u64)osd_data->length);\n\tfor (i = 0; i < num_pages; i++) {\n\t\tstruct page *page = osd_data->pages[i];\n\n\t\tif (rc < 0)\n\t\t\tgoto unlock;\n\t\tif (bytes < (int)PAGE_CACHE_SIZE) {\n\t\t\t/* zero (remainder of) page */\n\t\t\tint s = bytes < 0 ? 0 : bytes;\n\t\t\tzero_user_segment(page, s, PAGE_CACHE_SIZE);\n\t\t}\n \t\tdout(\"finish_read %p uptodate %p idx %lu\\n\", inode, page,\n\t\t     page->index);\n\t\tflush_dcache_page(page);\n\t\tSetPageUptodate(page);\n\t\tceph_readpage_to_fscache(inode, page);\nunlock:\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t\tbytes -= PAGE_CACHE_SIZE;\n\t}\n\tkfree(osd_data->pages);\n}"
  },
  {
    "function_name": "ceph_readpage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/addr.c",
    "lines": "246-251",
    "snippet": "static int ceph_readpage(struct file *filp, struct page *page)\n{\n\tint r = readpage_nounlock(filp, page);\n\tunlock_page(page);\n\treturn r;\n}",
    "includes": [
      "#include <linux/ceph/osd_client.h>",
      "#include \"cache.h\"",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/slab.h>",
      "#include <linux/writeback.h>\t/* generic_writepages */",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 249
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "readpage_nounlock",
          "args": [
            "filp",
            "page"
          ],
          "line": 248
        },
        "resolved": true,
        "details": {
          "function_name": "readpage_nounlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/addr.c",
          "lines": "188-244",
          "snippet": "static int readpage_nounlock(struct file *filp, struct page *page)\n{\n\tstruct inode *inode = file_inode(filp);\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tstruct ceph_osd_client *osdc =\n\t\t&ceph_inode_to_client(inode)->client->osdc;\n\tint err = 0;\n\tu64 off = page_offset(page);\n\tu64 len = PAGE_CACHE_SIZE;\n\n\tif (off >= i_size_read(inode)) {\n\t\tzero_user_segment(page, 0, PAGE_CACHE_SIZE);\n\t\tSetPageUptodate(page);\n\t\treturn 0;\n\t}\n\n\tif (ci->i_inline_version != CEPH_INLINE_NONE) {\n\t\t/*\n\t\t * Uptodate inline data should have been added\n\t\t * into page cache while getting Fcr caps.\n\t\t */\n\t\tif (off == 0)\n\t\t\treturn -EINVAL;\n\t\tzero_user_segment(page, 0, PAGE_CACHE_SIZE);\n\t\tSetPageUptodate(page);\n\t\treturn 0;\n\t}\n\n\terr = ceph_readpage_from_fscache(inode, page);\n\tif (err == 0)\n\t\tgoto out;\n\n\tdout(\"readpage inode %p file %p page %p index %lu\\n\",\n\t     inode, filp, page, page->index);\n\terr = ceph_osdc_readpages(osdc, ceph_vino(inode), &ci->i_layout,\n\t\t\t\t  off, &len,\n\t\t\t\t  ci->i_truncate_seq, ci->i_truncate_size,\n\t\t\t\t  &page, 1, 0);\n\tif (err == -ENOENT)\n\t\terr = 0;\n\tif (err < 0) {\n\t\tSetPageError(page);\n\t\tceph_fscache_readpage_cancel(inode, page);\n\t\tgoto out;\n\t}\n\tif (err < PAGE_CACHE_SIZE)\n\t\t/* zero fill remainder of page */\n\t\tzero_user_segment(page, err, PAGE_CACHE_SIZE);\n\telse\n\t\tflush_dcache_page(page);\n\n\tSetPageUptodate(page);\n\tceph_readpage_to_fscache(inode, page);\n\nout:\n\treturn err < 0 ? err : 0;\n}",
          "includes": [
            "#include <linux/ceph/osd_client.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>\t/* generic_writepages */",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/osd_client.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/task_io_accounting_ops.h>\n#include <linux/pagevec.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\t/* generic_writepages */\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/backing-dev.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic int readpage_nounlock(struct file *filp, struct page *page)\n{\n\tstruct inode *inode = file_inode(filp);\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tstruct ceph_osd_client *osdc =\n\t\t&ceph_inode_to_client(inode)->client->osdc;\n\tint err = 0;\n\tu64 off = page_offset(page);\n\tu64 len = PAGE_CACHE_SIZE;\n\n\tif (off >= i_size_read(inode)) {\n\t\tzero_user_segment(page, 0, PAGE_CACHE_SIZE);\n\t\tSetPageUptodate(page);\n\t\treturn 0;\n\t}\n\n\tif (ci->i_inline_version != CEPH_INLINE_NONE) {\n\t\t/*\n\t\t * Uptodate inline data should have been added\n\t\t * into page cache while getting Fcr caps.\n\t\t */\n\t\tif (off == 0)\n\t\t\treturn -EINVAL;\n\t\tzero_user_segment(page, 0, PAGE_CACHE_SIZE);\n\t\tSetPageUptodate(page);\n\t\treturn 0;\n\t}\n\n\terr = ceph_readpage_from_fscache(inode, page);\n\tif (err == 0)\n\t\tgoto out;\n\n\tdout(\"readpage inode %p file %p page %p index %lu\\n\",\n\t     inode, filp, page, page->index);\n\terr = ceph_osdc_readpages(osdc, ceph_vino(inode), &ci->i_layout,\n\t\t\t\t  off, &len,\n\t\t\t\t  ci->i_truncate_seq, ci->i_truncate_size,\n\t\t\t\t  &page, 1, 0);\n\tif (err == -ENOENT)\n\t\terr = 0;\n\tif (err < 0) {\n\t\tSetPageError(page);\n\t\tceph_fscache_readpage_cancel(inode, page);\n\t\tgoto out;\n\t}\n\tif (err < PAGE_CACHE_SIZE)\n\t\t/* zero fill remainder of page */\n\t\tzero_user_segment(page, err, PAGE_CACHE_SIZE);\n\telse\n\t\tflush_dcache_page(page);\n\n\tSetPageUptodate(page);\n\tceph_readpage_to_fscache(inode, page);\n\nout:\n\treturn err < 0 ? err : 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/ceph/osd_client.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/task_io_accounting_ops.h>\n#include <linux/pagevec.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\t/* generic_writepages */\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/backing-dev.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic int ceph_readpage(struct file *filp, struct page *page)\n{\n\tint r = readpage_nounlock(filp, page);\n\tunlock_page(page);\n\treturn r;\n}"
  },
  {
    "function_name": "readpage_nounlock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/addr.c",
    "lines": "188-244",
    "snippet": "static int readpage_nounlock(struct file *filp, struct page *page)\n{\n\tstruct inode *inode = file_inode(filp);\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tstruct ceph_osd_client *osdc =\n\t\t&ceph_inode_to_client(inode)->client->osdc;\n\tint err = 0;\n\tu64 off = page_offset(page);\n\tu64 len = PAGE_CACHE_SIZE;\n\n\tif (off >= i_size_read(inode)) {\n\t\tzero_user_segment(page, 0, PAGE_CACHE_SIZE);\n\t\tSetPageUptodate(page);\n\t\treturn 0;\n\t}\n\n\tif (ci->i_inline_version != CEPH_INLINE_NONE) {\n\t\t/*\n\t\t * Uptodate inline data should have been added\n\t\t * into page cache while getting Fcr caps.\n\t\t */\n\t\tif (off == 0)\n\t\t\treturn -EINVAL;\n\t\tzero_user_segment(page, 0, PAGE_CACHE_SIZE);\n\t\tSetPageUptodate(page);\n\t\treturn 0;\n\t}\n\n\terr = ceph_readpage_from_fscache(inode, page);\n\tif (err == 0)\n\t\tgoto out;\n\n\tdout(\"readpage inode %p file %p page %p index %lu\\n\",\n\t     inode, filp, page, page->index);\n\terr = ceph_osdc_readpages(osdc, ceph_vino(inode), &ci->i_layout,\n\t\t\t\t  off, &len,\n\t\t\t\t  ci->i_truncate_seq, ci->i_truncate_size,\n\t\t\t\t  &page, 1, 0);\n\tif (err == -ENOENT)\n\t\terr = 0;\n\tif (err < 0) {\n\t\tSetPageError(page);\n\t\tceph_fscache_readpage_cancel(inode, page);\n\t\tgoto out;\n\t}\n\tif (err < PAGE_CACHE_SIZE)\n\t\t/* zero fill remainder of page */\n\t\tzero_user_segment(page, err, PAGE_CACHE_SIZE);\n\telse\n\t\tflush_dcache_page(page);\n\n\tSetPageUptodate(page);\n\tceph_readpage_to_fscache(inode, page);\n\nout:\n\treturn err < 0 ? err : 0;\n}",
    "includes": [
      "#include <linux/ceph/osd_client.h>",
      "#include \"cache.h\"",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/slab.h>",
      "#include <linux/writeback.h>\t/* generic_writepages */",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ceph_readpage_to_fscache",
          "args": [
            "inode",
            "page"
          ],
          "line": 240
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_readpage_to_fscache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/cache.c",
          "lines": "308-322",
          "snippet": "void ceph_readpage_to_fscache(struct inode *inode, struct page *page)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tint ret;\n\n\tif (!PageFsCache(page))\n\t\treturn;\n\n\tif (!cache_valid(ci))\n\t\treturn;\n\n\tret = fscache_write_page(ci->fscache, page, GFP_KERNEL);\n\tif (ret)\n\t\t fscache_uncache_page(ci->fscache, page);\n}",
          "includes": [
            "#include \"cache.h\"",
            "#include \"super.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cache.h\"\n#include \"super.h\"\n\nvoid ceph_readpage_to_fscache(struct inode *inode, struct page *page)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tint ret;\n\n\tif (!PageFsCache(page))\n\t\treturn;\n\n\tif (!cache_valid(ci))\n\t\treturn;\n\n\tret = fscache_write_page(ci->fscache, page, GFP_KERNEL);\n\tif (ret)\n\t\t fscache_uncache_page(ci->fscache, page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SetPageUptodate",
          "args": [
            "page"
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flush_dcache_page",
          "args": [
            "page"
          ],
          "line": 237
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_index_entry_flush_dcache_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/index.h",
          "lines": "111-117",
          "snippet": "static inline void ntfs_index_entry_flush_dcache_page(ntfs_index_context *ictx)\n{\n\tif (ictx->is_in_root)\n\t\tflush_dcache_mft_record_page(ictx->actx->ntfs_ino);\n\telse\n\t\tflush_dcache_page(ictx->page);\n}",
          "includes": [
            "#include \"aops.h\"",
            "#include \"mft.h\"",
            "#include \"attrib.h\"",
            "#include \"inode.h\"",
            "#include \"layout.h\"",
            "#include \"types.h\"",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"aops.h\"\n#include \"mft.h\"\n#include \"attrib.h\"\n#include \"inode.h\"\n#include \"layout.h\"\n#include \"types.h\"\n#include <linux/fs.h>\n\nstatic inline void ntfs_index_entry_flush_dcache_page(ntfs_index_context *ictx)\n{\n\tif (ictx->is_in_root)\n\t\tflush_dcache_mft_record_page(ictx->actx->ntfs_ino);\n\telse\n\t\tflush_dcache_page(ictx->page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "zero_user_segment",
          "args": [
            "page",
            "err",
            "PAGE_CACHE_SIZE"
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_fscache_readpage_cancel",
          "args": [
            "inode",
            "page"
          ],
          "line": 230
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_fscache_readpage_cancel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/cache.h",
          "lines": "166-169",
          "snippet": "static inline void ceph_fscache_readpage_cancel(struct inode *inode,\n\t\t\t\t\t\tstruct page *page)\n{\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void ceph_fscache_readpage_cancel(struct inode *inode,\n\t\t\t\t\t\tstruct page *page)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "SetPageError",
          "args": [
            "page"
          ],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_osdc_readpages",
          "args": [
            "osdc",
            "ceph_vino(inode)",
            "&ci->i_layout",
            "off",
            "&len",
            "ci->i_truncate_seq",
            "ci->i_truncate_size",
            "&page",
            "1",
            "0"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_vino",
          "args": [
            "inode"
          ],
          "line": 222
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_vino_to_ino",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.h",
          "lines": "382-389",
          "snippet": "static inline ino_t ceph_vino_to_ino(struct ceph_vino vino)\n{\n#if BITS_PER_LONG == 32\n\treturn ceph_ino_to_ino32(vino.ino);\n#else\n\treturn (ino_t)vino.ino;\n#endif\n}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/ceph/libceph.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/backing-dev.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/ceph/libceph.h>\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n#include <linux/completion.h>\n#include <linux/backing-dev.h>\n#include <asm/unaligned.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline ino_t ceph_vino_to_ino(struct ceph_vino vino)\n{\n#if BITS_PER_LONG == 32\n\treturn ceph_ino_to_ino32(vino.ino);\n#else\n\treturn (ino_t)vino.ino;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"readpage inode %p file %p page %p index %lu\\n\"",
            "inode",
            "filp",
            "page",
            "page->index"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_readpage_from_fscache",
          "args": [
            "inode",
            "page"
          ],
          "line": 216
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_readpage_from_fscache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/cache.c",
          "lines": "253-277",
          "snippet": "int ceph_readpage_from_fscache(struct inode *inode, struct page *page)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tint ret;\n\n\tif (!cache_valid(ci))\n\t\treturn -ENOBUFS;\n\n\tret = fscache_read_or_alloc_page(ci->fscache, page,\n\t\t\t\t\t ceph_vfs_readpage_complete, NULL,\n\t\t\t\t\t GFP_KERNEL);\n\n\tswitch (ret) {\n\t\tcase 0: /* Page found */\n\t\t\tdout(\"page read submitted\\n\");\n\t\t\treturn 0;\n\t\tcase -ENOBUFS: /* Pages were not found, and can't be */\n\t\tcase -ENODATA: /* Pages were not found */\n\t\t\tdout(\"page/inode not in cache\\n\");\n\t\t\treturn ret;\n\t\tdefault:\n\t\t\tdout(\"%s: unknown error ret = %i\\n\", __func__, ret);\n\t\t\treturn ret;\n\t}\n}",
          "includes": [
            "#include \"cache.h\"",
            "#include \"super.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cache.h\"\n#include \"super.h\"\n\nint ceph_readpage_from_fscache(struct inode *inode, struct page *page)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tint ret;\n\n\tif (!cache_valid(ci))\n\t\treturn -ENOBUFS;\n\n\tret = fscache_read_or_alloc_page(ci->fscache, page,\n\t\t\t\t\t ceph_vfs_readpage_complete, NULL,\n\t\t\t\t\t GFP_KERNEL);\n\n\tswitch (ret) {\n\t\tcase 0: /* Page found */\n\t\t\tdout(\"page read submitted\\n\");\n\t\t\treturn 0;\n\t\tcase -ENOBUFS: /* Pages were not found, and can't be */\n\t\tcase -ENODATA: /* Pages were not found */\n\t\t\tdout(\"page/inode not in cache\\n\");\n\t\t\treturn ret;\n\t\tdefault:\n\t\t\tdout(\"%s: unknown error ret = %i\\n\", __func__, ret);\n\t\t\treturn ret;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "SetPageUptodate",
          "args": [
            "page"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zero_user_segment",
          "args": [
            "page",
            "0",
            "PAGE_CACHE_SIZE"
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetPageUptodate",
          "args": [
            "page"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zero_user_segment",
          "args": [
            "page",
            "0",
            "PAGE_CACHE_SIZE"
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_offset",
          "args": [
            "page"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_inode_to_client",
          "args": [
            "inode"
          ],
          "line": 193
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_inode_to_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.h",
          "lines": "347-350",
          "snippet": "static inline struct ceph_fs_client *ceph_inode_to_client(struct inode *inode)\n{\n\treturn (struct ceph_fs_client *)inode->i_sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/ceph/libceph.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/backing-dev.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/ceph/libceph.h>\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n#include <linux/completion.h>\n#include <linux/backing-dev.h>\n#include <asm/unaligned.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline struct ceph_fs_client *ceph_inode_to_client(struct inode *inode)\n{\n\treturn (struct ceph_fs_client *)inode->i_sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "filp"
          ],
          "line": 190
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/ceph/osd_client.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/task_io_accounting_ops.h>\n#include <linux/pagevec.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\t/* generic_writepages */\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/backing-dev.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic int readpage_nounlock(struct file *filp, struct page *page)\n{\n\tstruct inode *inode = file_inode(filp);\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tstruct ceph_osd_client *osdc =\n\t\t&ceph_inode_to_client(inode)->client->osdc;\n\tint err = 0;\n\tu64 off = page_offset(page);\n\tu64 len = PAGE_CACHE_SIZE;\n\n\tif (off >= i_size_read(inode)) {\n\t\tzero_user_segment(page, 0, PAGE_CACHE_SIZE);\n\t\tSetPageUptodate(page);\n\t\treturn 0;\n\t}\n\n\tif (ci->i_inline_version != CEPH_INLINE_NONE) {\n\t\t/*\n\t\t * Uptodate inline data should have been added\n\t\t * into page cache while getting Fcr caps.\n\t\t */\n\t\tif (off == 0)\n\t\t\treturn -EINVAL;\n\t\tzero_user_segment(page, 0, PAGE_CACHE_SIZE);\n\t\tSetPageUptodate(page);\n\t\treturn 0;\n\t}\n\n\terr = ceph_readpage_from_fscache(inode, page);\n\tif (err == 0)\n\t\tgoto out;\n\n\tdout(\"readpage inode %p file %p page %p index %lu\\n\",\n\t     inode, filp, page, page->index);\n\terr = ceph_osdc_readpages(osdc, ceph_vino(inode), &ci->i_layout,\n\t\t\t\t  off, &len,\n\t\t\t\t  ci->i_truncate_seq, ci->i_truncate_size,\n\t\t\t\t  &page, 1, 0);\n\tif (err == -ENOENT)\n\t\terr = 0;\n\tif (err < 0) {\n\t\tSetPageError(page);\n\t\tceph_fscache_readpage_cancel(inode, page);\n\t\tgoto out;\n\t}\n\tif (err < PAGE_CACHE_SIZE)\n\t\t/* zero fill remainder of page */\n\t\tzero_user_segment(page, err, PAGE_CACHE_SIZE);\n\telse\n\t\tflush_dcache_page(page);\n\n\tSetPageUptodate(page);\n\tceph_readpage_to_fscache(inode, page);\n\nout:\n\treturn err < 0 ? err : 0;\n}"
  },
  {
    "function_name": "ceph_releasepage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/addr.c",
    "lines": "172-183",
    "snippet": "static int ceph_releasepage(struct page *page, gfp_t g)\n{\n\tstruct inode *inode = page->mapping ? page->mapping->host : NULL;\n\tdout(\"%p releasepage %p idx %lu\\n\", inode, page, page->index);\n\tWARN_ON(PageDirty(page));\n\n\t/* Can we release the page from the cache? */\n\tif (!ceph_release_fscache_page(page, g))\n\t\treturn 0;\n\n\treturn !PagePrivate(page);\n}",
    "includes": [
      "#include <linux/ceph/osd_client.h>",
      "#include \"cache.h\"",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/slab.h>",
      "#include <linux/writeback.h>\t/* generic_writepages */",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PagePrivate",
          "args": [
            "page"
          ],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_release_fscache_page",
          "args": [
            "page",
            "g"
          ],
          "line": 179
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_release_fscache_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/cache.h",
          "lines": "161-164",
          "snippet": "static inline int ceph_release_fscache_page(struct page *page, gfp_t gfp)\n{\n\treturn 1;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int ceph_release_fscache_page(struct page *page, gfp_t gfp)\n{\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "PageDirty(page)"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageDirty",
          "args": [
            "page"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"%p releasepage %p idx %lu\\n\"",
            "inode",
            "page",
            "page->index"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/ceph/osd_client.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/task_io_accounting_ops.h>\n#include <linux/pagevec.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\t/* generic_writepages */\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/backing-dev.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic int ceph_releasepage(struct page *page, gfp_t g)\n{\n\tstruct inode *inode = page->mapping ? page->mapping->host : NULL;\n\tdout(\"%p releasepage %p idx %lu\\n\", inode, page, page->index);\n\tWARN_ON(PageDirty(page));\n\n\t/* Can we release the page from the cache? */\n\tif (!ceph_release_fscache_page(page, g))\n\t\treturn 0;\n\n\treturn !PagePrivate(page);\n}"
  },
  {
    "function_name": "ceph_invalidatepage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/addr.c",
    "lines": "132-170",
    "snippet": "static void ceph_invalidatepage(struct page *page, unsigned int offset,\n\t\t\t\tunsigned int length)\n{\n\tstruct inode *inode;\n\tstruct ceph_inode_info *ci;\n\tstruct ceph_snap_context *snapc = page_snap_context(page);\n\n\tinode = page->mapping->host;\n\tci = ceph_inode(inode);\n\n\tif (offset != 0 || length != PAGE_CACHE_SIZE) {\n\t\tdout(\"%p invalidatepage %p idx %lu partial dirty page %u~%u\\n\",\n\t\t     inode, page, page->index, offset, length);\n\t\treturn;\n\t}\n\n\tceph_invalidate_fscache_page(inode, page);\n\n\tif (!PagePrivate(page))\n\t\treturn;\n\n\t/*\n\t * We can get non-dirty pages here due to races between\n\t * set_page_dirty and truncate_complete_page; just spit out a\n\t * warning, in case we end up with accounting problems later.\n\t */\n\tif (!PageDirty(page))\n\t\tpr_err(\"%p invalidatepage %p page not dirty\\n\", inode, page);\n\n\tClearPageChecked(page);\n\n\tdout(\"%p invalidatepage %p idx %lu full dirty page\\n\",\n\t     inode, page, page->index);\n\n\tceph_put_wrbuffer_cap_refs(ci, 1, snapc);\n\tceph_put_snap_context(snapc);\n\tpage->private = 0;\n\tClearPagePrivate(page);\n}",
    "includes": [
      "#include <linux/ceph/osd_client.h>",
      "#include \"cache.h\"",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/slab.h>",
      "#include <linux/writeback.h>\t/* generic_writepages */",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ClearPagePrivate",
          "args": [
            "page"
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_put_snap_context",
          "args": [
            "snapc"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_put_wrbuffer_cap_refs",
          "args": [
            "ci",
            "1",
            "snapc"
          ],
          "line": 166
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_put_wrbuffer_cap_refs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
          "lines": "2335-2405",
          "snippet": "void ceph_put_wrbuffer_cap_refs(struct ceph_inode_info *ci, int nr,\n\t\t\t\tstruct ceph_snap_context *snapc)\n{\n\tstruct inode *inode = &ci->vfs_inode;\n\tint last = 0;\n\tint complete_capsnap = 0;\n\tint drop_capsnap = 0;\n\tint found = 0;\n\tstruct ceph_cap_snap *capsnap = NULL;\n\n\tspin_lock(&ci->i_ceph_lock);\n\tci->i_wrbuffer_ref -= nr;\n\tlast = !ci->i_wrbuffer_ref;\n\n\tif (ci->i_head_snapc == snapc) {\n\t\tci->i_wrbuffer_ref_head -= nr;\n\t\tif (ci->i_wrbuffer_ref_head == 0 &&\n\t\t    ci->i_dirty_caps == 0 && ci->i_flushing_caps == 0) {\n\t\t\tBUG_ON(!ci->i_head_snapc);\n\t\t\tceph_put_snap_context(ci->i_head_snapc);\n\t\t\tci->i_head_snapc = NULL;\n\t\t}\n\t\tdout(\"put_wrbuffer_cap_refs on %p head %d/%d -> %d/%d %s\\n\",\n\t\t     inode,\n\t\t     ci->i_wrbuffer_ref+nr, ci->i_wrbuffer_ref_head+nr,\n\t\t     ci->i_wrbuffer_ref, ci->i_wrbuffer_ref_head,\n\t\t     last ? \" LAST\" : \"\");\n\t} else {\n\t\tlist_for_each_entry(capsnap, &ci->i_cap_snaps, ci_item) {\n\t\t\tif (capsnap->context == snapc) {\n\t\t\t\tfound = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tBUG_ON(!found);\n\t\tcapsnap->dirty_pages -= nr;\n\t\tif (capsnap->dirty_pages == 0) {\n\t\t\tcomplete_capsnap = 1;\n\t\t\tif (capsnap->dirty == 0)\n\t\t\t\t/* cap writeback completed before we created\n\t\t\t\t * the cap_snap; no FLUSHSNAP is needed */\n\t\t\t\tdrop_capsnap = 1;\n\t\t}\n\t\tdout(\"put_wrbuffer_cap_refs on %p cap_snap %p \"\n\t\t     \" snap %lld %d/%d -> %d/%d %s%s%s\\n\",\n\t\t     inode, capsnap, capsnap->context->seq,\n\t\t     ci->i_wrbuffer_ref+nr, capsnap->dirty_pages + nr,\n\t\t     ci->i_wrbuffer_ref, capsnap->dirty_pages,\n\t\t     last ? \" (wrbuffer last)\" : \"\",\n\t\t     complete_capsnap ? \" (complete capsnap)\" : \"\",\n\t\t     drop_capsnap ? \" (drop capsnap)\" : \"\");\n\t\tif (drop_capsnap) {\n\t\t\tceph_put_snap_context(capsnap->context);\n\t\t\tlist_del(&capsnap->ci_item);\n\t\t\tlist_del(&capsnap->flushing_item);\n\t\t\tceph_put_cap_snap(capsnap);\n\t\t}\n\t}\n\n\tspin_unlock(&ci->i_ceph_lock);\n\n\tif (last) {\n\t\tceph_check_caps(ci, CHECK_CAPS_AUTHONLY, NULL);\n\t\tiput(inode);\n\t} else if (complete_capsnap) {\n\t\tceph_flush_snaps(ci);\n\t\twake_up_all(&ci->i_cap_wq);\n\t}\n\tif (drop_capsnap)\n\t\tiput(inode);\n}",
          "includes": [
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nvoid ceph_put_wrbuffer_cap_refs(struct ceph_inode_info *ci, int nr,\n\t\t\t\tstruct ceph_snap_context *snapc)\n{\n\tstruct inode *inode = &ci->vfs_inode;\n\tint last = 0;\n\tint complete_capsnap = 0;\n\tint drop_capsnap = 0;\n\tint found = 0;\n\tstruct ceph_cap_snap *capsnap = NULL;\n\n\tspin_lock(&ci->i_ceph_lock);\n\tci->i_wrbuffer_ref -= nr;\n\tlast = !ci->i_wrbuffer_ref;\n\n\tif (ci->i_head_snapc == snapc) {\n\t\tci->i_wrbuffer_ref_head -= nr;\n\t\tif (ci->i_wrbuffer_ref_head == 0 &&\n\t\t    ci->i_dirty_caps == 0 && ci->i_flushing_caps == 0) {\n\t\t\tBUG_ON(!ci->i_head_snapc);\n\t\t\tceph_put_snap_context(ci->i_head_snapc);\n\t\t\tci->i_head_snapc = NULL;\n\t\t}\n\t\tdout(\"put_wrbuffer_cap_refs on %p head %d/%d -> %d/%d %s\\n\",\n\t\t     inode,\n\t\t     ci->i_wrbuffer_ref+nr, ci->i_wrbuffer_ref_head+nr,\n\t\t     ci->i_wrbuffer_ref, ci->i_wrbuffer_ref_head,\n\t\t     last ? \" LAST\" : \"\");\n\t} else {\n\t\tlist_for_each_entry(capsnap, &ci->i_cap_snaps, ci_item) {\n\t\t\tif (capsnap->context == snapc) {\n\t\t\t\tfound = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tBUG_ON(!found);\n\t\tcapsnap->dirty_pages -= nr;\n\t\tif (capsnap->dirty_pages == 0) {\n\t\t\tcomplete_capsnap = 1;\n\t\t\tif (capsnap->dirty == 0)\n\t\t\t\t/* cap writeback completed before we created\n\t\t\t\t * the cap_snap; no FLUSHSNAP is needed */\n\t\t\t\tdrop_capsnap = 1;\n\t\t}\n\t\tdout(\"put_wrbuffer_cap_refs on %p cap_snap %p \"\n\t\t     \" snap %lld %d/%d -> %d/%d %s%s%s\\n\",\n\t\t     inode, capsnap, capsnap->context->seq,\n\t\t     ci->i_wrbuffer_ref+nr, capsnap->dirty_pages + nr,\n\t\t     ci->i_wrbuffer_ref, capsnap->dirty_pages,\n\t\t     last ? \" (wrbuffer last)\" : \"\",\n\t\t     complete_capsnap ? \" (complete capsnap)\" : \"\",\n\t\t     drop_capsnap ? \" (drop capsnap)\" : \"\");\n\t\tif (drop_capsnap) {\n\t\t\tceph_put_snap_context(capsnap->context);\n\t\t\tlist_del(&capsnap->ci_item);\n\t\t\tlist_del(&capsnap->flushing_item);\n\t\t\tceph_put_cap_snap(capsnap);\n\t\t}\n\t}\n\n\tspin_unlock(&ci->i_ceph_lock);\n\n\tif (last) {\n\t\tceph_check_caps(ci, CHECK_CAPS_AUTHONLY, NULL);\n\t\tiput(inode);\n\t} else if (complete_capsnap) {\n\t\tceph_flush_snaps(ci);\n\t\twake_up_all(&ci->i_cap_wq);\n\t}\n\tif (drop_capsnap)\n\t\tiput(inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"%p invalidatepage %p idx %lu full dirty page\\n\"",
            "inode",
            "page",
            "page->index"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ClearPageChecked",
          "args": [
            "page"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%p invalidatepage %p page not dirty\\n\"",
            "inode",
            "page"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageDirty",
          "args": [
            "page"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PagePrivate",
          "args": [
            "page"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_invalidate_fscache_page",
          "args": [
            "inode",
            "page"
          ],
          "line": 148
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_invalidate_fscache_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/cache.c",
          "lines": "324-333",
          "snippet": "void ceph_invalidate_fscache_page(struct inode* inode, struct page *page)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\n\tif (!PageFsCache(page))\n\t\treturn;\n\n\tfscache_wait_on_page_write(ci->fscache, page);\n\tfscache_uncache_page(ci->fscache, page);\n}",
          "includes": [
            "#include \"cache.h\"",
            "#include \"super.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cache.h\"\n#include \"super.h\"\n\nvoid ceph_invalidate_fscache_page(struct inode* inode, struct page *page)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\n\tif (!PageFsCache(page))\n\t\treturn;\n\n\tfscache_wait_on_page_write(ci->fscache, page);\n\tfscache_uncache_page(ci->fscache, page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"%p invalidatepage %p idx %lu partial dirty page %u~%u\\n\"",
            "inode",
            "page",
            "page->index",
            "offset",
            "length"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_inode",
          "args": [
            "inode"
          ],
          "line": 140
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_inode_to_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.h",
          "lines": "347-350",
          "snippet": "static inline struct ceph_fs_client *ceph_inode_to_client(struct inode *inode)\n{\n\treturn (struct ceph_fs_client *)inode->i_sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/ceph/libceph.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/backing-dev.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/ceph/libceph.h>\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n#include <linux/completion.h>\n#include <linux/backing-dev.h>\n#include <asm/unaligned.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline struct ceph_fs_client *ceph_inode_to_client(struct inode *inode)\n{\n\treturn (struct ceph_fs_client *)inode->i_sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_snap_context",
          "args": [
            "page"
          ],
          "line": 137
        },
        "resolved": true,
        "details": {
          "function_name": "page_snap_context",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/addr.c",
          "lines": "58-63",
          "snippet": "static inline struct ceph_snap_context *page_snap_context(struct page *page)\n{\n\tif (PagePrivate(page))\n\t\treturn (void *)page->private;\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/ceph/osd_client.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>\t/* generic_writepages */",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/osd_client.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/task_io_accounting_ops.h>\n#include <linux/pagevec.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\t/* generic_writepages */\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/backing-dev.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline struct ceph_snap_context *page_snap_context(struct page *page)\n{\n\tif (PagePrivate(page))\n\t\treturn (void *)page->private;\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/ceph/osd_client.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/task_io_accounting_ops.h>\n#include <linux/pagevec.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\t/* generic_writepages */\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/backing-dev.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void ceph_invalidatepage(struct page *page, unsigned int offset,\n\t\t\t\tunsigned int length)\n{\n\tstruct inode *inode;\n\tstruct ceph_inode_info *ci;\n\tstruct ceph_snap_context *snapc = page_snap_context(page);\n\n\tinode = page->mapping->host;\n\tci = ceph_inode(inode);\n\n\tif (offset != 0 || length != PAGE_CACHE_SIZE) {\n\t\tdout(\"%p invalidatepage %p idx %lu partial dirty page %u~%u\\n\",\n\t\t     inode, page, page->index, offset, length);\n\t\treturn;\n\t}\n\n\tceph_invalidate_fscache_page(inode, page);\n\n\tif (!PagePrivate(page))\n\t\treturn;\n\n\t/*\n\t * We can get non-dirty pages here due to races between\n\t * set_page_dirty and truncate_complete_page; just spit out a\n\t * warning, in case we end up with accounting problems later.\n\t */\n\tif (!PageDirty(page))\n\t\tpr_err(\"%p invalidatepage %p page not dirty\\n\", inode, page);\n\n\tClearPageChecked(page);\n\n\tdout(\"%p invalidatepage %p idx %lu full dirty page\\n\",\n\t     inode, page, page->index);\n\n\tceph_put_wrbuffer_cap_refs(ci, 1, snapc);\n\tceph_put_snap_context(snapc);\n\tpage->private = 0;\n\tClearPagePrivate(page);\n}"
  },
  {
    "function_name": "ceph_set_page_dirty",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/addr.c",
    "lines": "69-125",
    "snippet": "static int ceph_set_page_dirty(struct page *page)\n{\n\tstruct address_space *mapping = page->mapping;\n\tstruct inode *inode;\n\tstruct ceph_inode_info *ci;\n\tstruct ceph_snap_context *snapc;\n\tint ret;\n\n\tif (unlikely(!mapping))\n\t\treturn !TestSetPageDirty(page);\n\n\tif (PageDirty(page)) {\n\t\tdout(\"%p set_page_dirty %p idx %lu -- already dirty\\n\",\n\t\t     mapping->host, page, page->index);\n\t\tBUG_ON(!PagePrivate(page));\n\t\treturn 0;\n\t}\n\n\tinode = mapping->host;\n\tci = ceph_inode(inode);\n\n\t/*\n\t * Note that we're grabbing a snapc ref here without holding\n\t * any locks!\n\t */\n\tsnapc = ceph_get_snap_context(ci->i_snap_realm->cached_context);\n\n\t/* dirty the head */\n\tspin_lock(&ci->i_ceph_lock);\n\tif (ci->i_head_snapc == NULL)\n\t\tci->i_head_snapc = ceph_get_snap_context(snapc);\n\t++ci->i_wrbuffer_ref_head;\n\tif (ci->i_wrbuffer_ref == 0)\n\t\tihold(inode);\n\t++ci->i_wrbuffer_ref;\n\tdout(\"%p set_page_dirty %p idx %lu head %d/%d -> %d/%d \"\n\t     \"snapc %p seq %lld (%d snaps)\\n\",\n\t     mapping->host, page, page->index,\n\t     ci->i_wrbuffer_ref-1, ci->i_wrbuffer_ref_head-1,\n\t     ci->i_wrbuffer_ref, ci->i_wrbuffer_ref_head,\n\t     snapc, snapc->seq, snapc->num_snaps);\n\tspin_unlock(&ci->i_ceph_lock);\n\n\t/*\n\t * Reference snap context in page->private.  Also set\n\t * PagePrivate so that we get invalidatepage callback.\n\t */\n\tBUG_ON(PagePrivate(page));\n\tpage->private = (unsigned long)snapc;\n\tSetPagePrivate(page);\n\n\tret = __set_page_dirty_nobuffers(page);\n\tWARN_ON(!PageLocked(page));\n\tWARN_ON(!page->mapping);\n\n\treturn ret;\n}",
    "includes": [
      "#include <linux/ceph/osd_client.h>",
      "#include \"cache.h\"",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/slab.h>",
      "#include <linux/writeback.h>\t/* generic_writepages */",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!page->mapping"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!PageLocked(page)"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageLocked",
          "args": [
            "page"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__set_page_dirty_nobuffers",
          "args": [
            "page"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetPagePrivate",
          "args": [
            "page"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "PagePrivate(page)"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PagePrivate",
          "args": [
            "page"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ci->i_ceph_lock"
          ],
          "line": 110
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"%p set_page_dirty %p idx %lu head %d/%d -> %d/%d \"\n\t     \"snapc %p seq %lld (%d snaps)\\n\"",
            "mapping->host",
            "page",
            "page->index",
            "ci->i_wrbuffer_ref-1",
            "ci->i_wrbuffer_ref_head-1",
            "ci->i_wrbuffer_ref",
            "ci->i_wrbuffer_ref_head",
            "snapc",
            "snapc->seq",
            "snapc->num_snaps"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ihold",
          "args": [
            "inode"
          ],
          "line": 102
        },
        "resolved": true,
        "details": {
          "function_name": "ihold",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "388-391",
          "snippet": "void ihold(struct inode *inode)\n{\n\tWARN_ON(atomic_inc_return(&inode->i_count) < 2);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid ihold(struct inode *inode)\n{\n\tWARN_ON(atomic_inc_return(&inode->i_count) < 2);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_get_snap_context",
          "args": [
            "snapc"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ci->i_ceph_lock"
          ],
          "line": 97
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_get_snap_context",
          "args": [
            "ci->i_snap_realm->cached_context"
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_inode",
          "args": [
            "inode"
          ],
          "line": 88
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_inode_to_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.h",
          "lines": "347-350",
          "snippet": "static inline struct ceph_fs_client *ceph_inode_to_client(struct inode *inode)\n{\n\treturn (struct ceph_fs_client *)inode->i_sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/ceph/libceph.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/backing-dev.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/ceph/libceph.h>\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n#include <linux/completion.h>\n#include <linux/backing-dev.h>\n#include <asm/unaligned.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline struct ceph_fs_client *ceph_inode_to_client(struct inode *inode)\n{\n\treturn (struct ceph_fs_client *)inode->i_sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!PagePrivate(page)"
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PagePrivate",
          "args": [
            "page"
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"%p set_page_dirty %p idx %lu -- already dirty\\n\"",
            "mapping->host",
            "page",
            "page->index"
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageDirty",
          "args": [
            "page"
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TestSetPageDirty",
          "args": [
            "page"
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!mapping"
          ],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/ceph/osd_client.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/task_io_accounting_ops.h>\n#include <linux/pagevec.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\t/* generic_writepages */\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/backing-dev.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic int ceph_set_page_dirty(struct page *page)\n{\n\tstruct address_space *mapping = page->mapping;\n\tstruct inode *inode;\n\tstruct ceph_inode_info *ci;\n\tstruct ceph_snap_context *snapc;\n\tint ret;\n\n\tif (unlikely(!mapping))\n\t\treturn !TestSetPageDirty(page);\n\n\tif (PageDirty(page)) {\n\t\tdout(\"%p set_page_dirty %p idx %lu -- already dirty\\n\",\n\t\t     mapping->host, page, page->index);\n\t\tBUG_ON(!PagePrivate(page));\n\t\treturn 0;\n\t}\n\n\tinode = mapping->host;\n\tci = ceph_inode(inode);\n\n\t/*\n\t * Note that we're grabbing a snapc ref here without holding\n\t * any locks!\n\t */\n\tsnapc = ceph_get_snap_context(ci->i_snap_realm->cached_context);\n\n\t/* dirty the head */\n\tspin_lock(&ci->i_ceph_lock);\n\tif (ci->i_head_snapc == NULL)\n\t\tci->i_head_snapc = ceph_get_snap_context(snapc);\n\t++ci->i_wrbuffer_ref_head;\n\tif (ci->i_wrbuffer_ref == 0)\n\t\tihold(inode);\n\t++ci->i_wrbuffer_ref;\n\tdout(\"%p set_page_dirty %p idx %lu head %d/%d -> %d/%d \"\n\t     \"snapc %p seq %lld (%d snaps)\\n\",\n\t     mapping->host, page, page->index,\n\t     ci->i_wrbuffer_ref-1, ci->i_wrbuffer_ref_head-1,\n\t     ci->i_wrbuffer_ref, ci->i_wrbuffer_ref_head,\n\t     snapc, snapc->seq, snapc->num_snaps);\n\tspin_unlock(&ci->i_ceph_lock);\n\n\t/*\n\t * Reference snap context in page->private.  Also set\n\t * PagePrivate so that we get invalidatepage callback.\n\t */\n\tBUG_ON(PagePrivate(page));\n\tpage->private = (unsigned long)snapc;\n\tSetPagePrivate(page);\n\n\tret = __set_page_dirty_nobuffers(page);\n\tWARN_ON(!PageLocked(page));\n\tWARN_ON(!page->mapping);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "page_snap_context",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/addr.c",
    "lines": "58-63",
    "snippet": "static inline struct ceph_snap_context *page_snap_context(struct page *page)\n{\n\tif (PagePrivate(page))\n\t\treturn (void *)page->private;\n\treturn NULL;\n}",
    "includes": [
      "#include <linux/ceph/osd_client.h>",
      "#include \"cache.h\"",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/slab.h>",
      "#include <linux/writeback.h>\t/* generic_writepages */",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PagePrivate",
          "args": [
            "page"
          ],
          "line": 60
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/ceph/osd_client.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/task_io_accounting_ops.h>\n#include <linux/pagevec.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\t/* generic_writepages */\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/backing-dev.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline struct ceph_snap_context *page_snap_context(struct page *page)\n{\n\tif (PagePrivate(page))\n\t\treturn (void *)page->private;\n\treturn NULL;\n}"
  }
]