[
  {
    "function_name": "btrfs_apply_pending_changes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
    "lines": "2139-2166",
    "snippet": "void btrfs_apply_pending_changes(struct btrfs_fs_info *fs_info)\n{\n\tunsigned long prev;\n\tunsigned long bit;\n\n\tprev = xchg(&fs_info->pending_changes, 0);\n\tif (!prev)\n\t\treturn;\n\n\tbit = 1 << BTRFS_PENDING_SET_INODE_MAP_CACHE;\n\tif (prev & bit)\n\t\tbtrfs_set_opt(fs_info->mount_opt, INODE_MAP_CACHE);\n\tprev &= ~bit;\n\n\tbit = 1 << BTRFS_PENDING_CLEAR_INODE_MAP_CACHE;\n\tif (prev & bit)\n\t\tbtrfs_clear_opt(fs_info->mount_opt, INODE_MAP_CACHE);\n\tprev &= ~bit;\n\n\tbit = 1 << BTRFS_PENDING_COMMIT;\n\tif (prev & bit)\n\t\tbtrfs_debug(fs_info, \"pending commit done\");\n\tprev &= ~bit;\n\n\tif (prev)\n\t\tbtrfs_warn(fs_info,\n\t\t\t\"unknown pending changes left 0x%lx, ignoring\", prev);\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"dev-replace.h\"",
      "#include \"volumes.h\"",
      "#include \"inode-map.h\"",
      "#include \"tree-log.h\"",
      "#include \"locking.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/uuid.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/writeback.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_warn",
          "args": [
            "fs_info",
            "\"unknown pending changes left 0x%lx, ignoring\"",
            "prev"
          ],
          "line": 2164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_debug",
          "args": [
            "fs_info",
            "\"pending commit done\""
          ],
          "line": 2160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_clear_opt",
          "args": [
            "fs_info->mount_opt",
            "INODE_MAP_CACHE"
          ],
          "line": 2155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_opt",
          "args": [
            "fs_info->mount_opt",
            "INODE_MAP_CACHE"
          ],
          "line": 2150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xchg",
          "args": [
            "&fs_info->pending_changes",
            "0"
          ],
          "line": 2144
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid btrfs_apply_pending_changes(struct btrfs_fs_info *fs_info)\n{\n\tunsigned long prev;\n\tunsigned long bit;\n\n\tprev = xchg(&fs_info->pending_changes, 0);\n\tif (!prev)\n\t\treturn;\n\n\tbit = 1 << BTRFS_PENDING_SET_INODE_MAP_CACHE;\n\tif (prev & bit)\n\t\tbtrfs_set_opt(fs_info->mount_opt, INODE_MAP_CACHE);\n\tprev &= ~bit;\n\n\tbit = 1 << BTRFS_PENDING_CLEAR_INODE_MAP_CACHE;\n\tif (prev & bit)\n\t\tbtrfs_clear_opt(fs_info->mount_opt, INODE_MAP_CACHE);\n\tprev &= ~bit;\n\n\tbit = 1 << BTRFS_PENDING_COMMIT;\n\tif (prev & bit)\n\t\tbtrfs_debug(fs_info, \"pending commit done\");\n\tprev &= ~bit;\n\n\tif (prev)\n\t\tbtrfs_warn(fs_info,\n\t\t\t\"unknown pending changes left 0x%lx, ignoring\", prev);\n}"
  },
  {
    "function_name": "btrfs_clean_one_deleted_snapshot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
    "lines": "2111-2137",
    "snippet": "int btrfs_clean_one_deleted_snapshot(struct btrfs_root *root)\n{\n\tint ret;\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\n\tspin_lock(&fs_info->trans_lock);\n\tif (list_empty(&fs_info->dead_roots)) {\n\t\tspin_unlock(&fs_info->trans_lock);\n\t\treturn 0;\n\t}\n\troot = list_first_entry(&fs_info->dead_roots,\n\t\t\tstruct btrfs_root, root_list);\n\tlist_del_init(&root->root_list);\n\tspin_unlock(&fs_info->trans_lock);\n\n\tpr_debug(\"BTRFS: cleaner removing %llu\\n\", root->objectid);\n\n\tbtrfs_kill_all_delayed_nodes(root);\n\n\tif (btrfs_header_backref_rev(root->node) <\n\t\t\tBTRFS_MIXED_BACKREF_REV)\n\t\tret = btrfs_drop_snapshot(root, NULL, 0, 0);\n\telse\n\t\tret = btrfs_drop_snapshot(root, NULL, 1, 0);\n\n\treturn (ret < 0) ? 0 : 1;\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"dev-replace.h\"",
      "#include \"volumes.h\"",
      "#include \"inode-map.h\"",
      "#include \"tree-log.h\"",
      "#include \"locking.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/uuid.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/writeback.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_drop_snapshot",
          "args": [
            "root",
            "NULL",
            "1",
            "0"
          ],
          "line": 2134
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_drop_snapshot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent-tree.c",
          "lines": "8121-8359",
          "snippet": "int btrfs_drop_snapshot(struct btrfs_root *root,\n\t\t\t struct btrfs_block_rsv *block_rsv, int update_ref,\n\t\t\t int for_reloc)\n{\n\tstruct btrfs_path *path;\n\tstruct btrfs_trans_handle *trans;\n\tstruct btrfs_root *tree_root = root->fs_info->tree_root;\n\tstruct btrfs_root_item *root_item = &root->root_item;\n\tstruct walk_control *wc;\n\tstruct btrfs_key key;\n\tint err = 0;\n\tint ret;\n\tint level;\n\tbool root_dropped = false;\n\n\tbtrfs_debug(root->fs_info, \"Drop subvolume %llu\", root->objectid);\n\n\tpath = btrfs_alloc_path();\n\tif (!path) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\twc = kzalloc(sizeof(*wc), GFP_NOFS);\n\tif (!wc) {\n\t\tbtrfs_free_path(path);\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\ttrans = btrfs_start_transaction(tree_root, 0);\n\tif (IS_ERR(trans)) {\n\t\terr = PTR_ERR(trans);\n\t\tgoto out_free;\n\t}\n\n\tif (block_rsv)\n\t\ttrans->block_rsv = block_rsv;\n\n\tif (btrfs_disk_key_objectid(&root_item->drop_progress) == 0) {\n\t\tlevel = btrfs_header_level(root->node);\n\t\tpath->nodes[level] = btrfs_lock_root_node(root);\n\t\tbtrfs_set_lock_blocking(path->nodes[level]);\n\t\tpath->slots[level] = 0;\n\t\tpath->locks[level] = BTRFS_WRITE_LOCK_BLOCKING;\n\t\tmemset(&wc->update_progress, 0,\n\t\t       sizeof(wc->update_progress));\n\t} else {\n\t\tbtrfs_disk_key_to_cpu(&key, &root_item->drop_progress);\n\t\tmemcpy(&wc->update_progress, &key,\n\t\t       sizeof(wc->update_progress));\n\n\t\tlevel = root_item->drop_level;\n\t\tBUG_ON(level == 0);\n\t\tpath->lowest_level = level;\n\t\tret = btrfs_search_slot(NULL, root, &key, path, 0, 0);\n\t\tpath->lowest_level = 0;\n\t\tif (ret < 0) {\n\t\t\terr = ret;\n\t\t\tgoto out_end_trans;\n\t\t}\n\t\tWARN_ON(ret > 0);\n\n\t\t/*\n\t\t * unlock our path, this is safe because only this\n\t\t * function is allowed to delete this snapshot\n\t\t */\n\t\tbtrfs_unlock_up_safe(path, 0);\n\n\t\tlevel = btrfs_header_level(root->node);\n\t\twhile (1) {\n\t\t\tbtrfs_tree_lock(path->nodes[level]);\n\t\t\tbtrfs_set_lock_blocking(path->nodes[level]);\n\t\t\tpath->locks[level] = BTRFS_WRITE_LOCK_BLOCKING;\n\n\t\t\tret = btrfs_lookup_extent_info(trans, root,\n\t\t\t\t\t\tpath->nodes[level]->start,\n\t\t\t\t\t\tlevel, 1, &wc->refs[level],\n\t\t\t\t\t\t&wc->flags[level]);\n\t\t\tif (ret < 0) {\n\t\t\t\terr = ret;\n\t\t\t\tgoto out_end_trans;\n\t\t\t}\n\t\t\tBUG_ON(wc->refs[level] == 0);\n\n\t\t\tif (level == root_item->drop_level)\n\t\t\t\tbreak;\n\n\t\t\tbtrfs_tree_unlock(path->nodes[level]);\n\t\t\tpath->locks[level] = 0;\n\t\t\tWARN_ON(wc->refs[level] != 1);\n\t\t\tlevel--;\n\t\t}\n\t}\n\n\twc->level = level;\n\twc->shared_level = -1;\n\twc->stage = DROP_REFERENCE;\n\twc->update_ref = update_ref;\n\twc->keep_locks = 0;\n\twc->for_reloc = for_reloc;\n\twc->reada_count = BTRFS_NODEPTRS_PER_BLOCK(root);\n\n\twhile (1) {\n\n\t\tret = walk_down_tree(trans, root, path, wc);\n\t\tif (ret < 0) {\n\t\t\terr = ret;\n\t\t\tbreak;\n\t\t}\n\n\t\tret = walk_up_tree(trans, root, path, wc, BTRFS_MAX_LEVEL);\n\t\tif (ret < 0) {\n\t\t\terr = ret;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (ret > 0) {\n\t\t\tBUG_ON(wc->stage != DROP_REFERENCE);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (wc->stage == DROP_REFERENCE) {\n\t\t\tlevel = wc->level;\n\t\t\tbtrfs_node_key(path->nodes[level],\n\t\t\t\t       &root_item->drop_progress,\n\t\t\t\t       path->slots[level]);\n\t\t\troot_item->drop_level = level;\n\t\t}\n\n\t\tBUG_ON(wc->level == 0);\n\t\tif (btrfs_should_end_transaction(trans, tree_root) ||\n\t\t    (!for_reloc && btrfs_need_cleaner_sleep(root))) {\n\t\t\tret = btrfs_update_root(trans, tree_root,\n\t\t\t\t\t\t&root->root_key,\n\t\t\t\t\t\troot_item);\n\t\t\tif (ret) {\n\t\t\t\tbtrfs_abort_transaction(trans, tree_root, ret);\n\t\t\t\terr = ret;\n\t\t\t\tgoto out_end_trans;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Qgroup update accounting is run from\n\t\t\t * delayed ref handling. This usually works\n\t\t\t * out because delayed refs are normally the\n\t\t\t * only way qgroup updates are added. However,\n\t\t\t * we may have added updates during our tree\n\t\t\t * walk so run qgroups here to make sure we\n\t\t\t * don't lose any updates.\n\t\t\t */\n\t\t\tret = btrfs_delayed_qgroup_accounting(trans,\n\t\t\t\t\t\t\t      root->fs_info);\n\t\t\tif (ret)\n\t\t\t\tprintk_ratelimited(KERN_ERR \"BTRFS: Failure %d \"\n\t\t\t\t\t\t   \"running qgroup updates \"\n\t\t\t\t\t\t   \"during snapshot delete. \"\n\t\t\t\t\t\t   \"Quota is out of sync, \"\n\t\t\t\t\t\t   \"rescan required.\\n\", ret);\n\n\t\t\tbtrfs_end_transaction_throttle(trans, tree_root);\n\t\t\tif (!for_reloc && btrfs_need_cleaner_sleep(root)) {\n\t\t\t\tpr_debug(\"BTRFS: drop snapshot early exit\\n\");\n\t\t\t\terr = -EAGAIN;\n\t\t\t\tgoto out_free;\n\t\t\t}\n\n\t\t\ttrans = btrfs_start_transaction(tree_root, 0);\n\t\t\tif (IS_ERR(trans)) {\n\t\t\t\terr = PTR_ERR(trans);\n\t\t\t\tgoto out_free;\n\t\t\t}\n\t\t\tif (block_rsv)\n\t\t\t\ttrans->block_rsv = block_rsv;\n\t\t}\n\t}\n\tbtrfs_release_path(path);\n\tif (err)\n\t\tgoto out_end_trans;\n\n\tret = btrfs_del_root(trans, tree_root, &root->root_key);\n\tif (ret) {\n\t\tbtrfs_abort_transaction(trans, tree_root, ret);\n\t\tgoto out_end_trans;\n\t}\n\n\tif (root->root_key.objectid != BTRFS_TREE_RELOC_OBJECTID) {\n\t\tret = btrfs_find_root(tree_root, &root->root_key, path,\n\t\t\t\t      NULL, NULL);\n\t\tif (ret < 0) {\n\t\t\tbtrfs_abort_transaction(trans, tree_root, ret);\n\t\t\terr = ret;\n\t\t\tgoto out_end_trans;\n\t\t} else if (ret > 0) {\n\t\t\t/* if we fail to delete the orphan item this time\n\t\t\t * around, it'll get picked up the next time.\n\t\t\t *\n\t\t\t * The most common failure here is just -ENOENT.\n\t\t\t */\n\t\t\tbtrfs_del_orphan_item(trans, tree_root,\n\t\t\t\t\t      root->root_key.objectid);\n\t\t}\n\t}\n\n\tif (test_bit(BTRFS_ROOT_IN_RADIX, &root->state)) {\n\t\tbtrfs_drop_and_free_fs_root(tree_root->fs_info, root);\n\t} else {\n\t\tfree_extent_buffer(root->node);\n\t\tfree_extent_buffer(root->commit_root);\n\t\tbtrfs_put_fs_root(root);\n\t}\n\troot_dropped = true;\nout_end_trans:\n\tret = btrfs_delayed_qgroup_accounting(trans, tree_root->fs_info);\n\tif (ret)\n\t\tprintk_ratelimited(KERN_ERR \"BTRFS: Failure %d \"\n\t\t\t\t   \"running qgroup updates \"\n\t\t\t\t   \"during snapshot delete. \"\n\t\t\t\t   \"Quota is out of sync, \"\n\t\t\t\t   \"rescan required.\\n\", ret);\n\n\tbtrfs_end_transaction_throttle(trans, tree_root);\nout_free:\n\tkfree(wc);\n\tbtrfs_free_path(path);\nout:\n\t/*\n\t * So if we need to stop dropping the snapshot for whatever reason we\n\t * need to make sure to add it back to the dead root list so that we\n\t * keep trying to do the work later.  This also cleans up roots if we\n\t * don't have it in the radix (like when we recover after a power fail\n\t * or unmount) so we don't leak memory.\n\t */\n\tif (!for_reloc && root_dropped == false)\n\t\tbtrfs_add_dead_root(root);\n\tif (err && err != -EAGAIN)\n\t\tbtrfs_std_error(root->fs_info, err);\n\treturn err;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"math.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include \"hash.h\"",
            "#include <linux/percpu_counter.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define DROP_REFERENCE\t1"
          ],
          "globals_used": [
            "static int find_next_key(struct btrfs_path *path, int level,\n\t\t\t struct btrfs_key *key);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"math.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include \"hash.h\"\n#include <linux/percpu_counter.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n#include <linux/rcupdate.h>\n#include <linux/sort.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\n#define DROP_REFERENCE\t1\n\nstatic int find_next_key(struct btrfs_path *path, int level,\n\t\t\t struct btrfs_key *key);\nstatic noinline struct;\n\nint btrfs_drop_snapshot(struct btrfs_root *root,\n\t\t\t struct btrfs_block_rsv *block_rsv, int update_ref,\n\t\t\t int for_reloc)\n{\n\tstruct btrfs_path *path;\n\tstruct btrfs_trans_handle *trans;\n\tstruct btrfs_root *tree_root = root->fs_info->tree_root;\n\tstruct btrfs_root_item *root_item = &root->root_item;\n\tstruct walk_control *wc;\n\tstruct btrfs_key key;\n\tint err = 0;\n\tint ret;\n\tint level;\n\tbool root_dropped = false;\n\n\tbtrfs_debug(root->fs_info, \"Drop subvolume %llu\", root->objectid);\n\n\tpath = btrfs_alloc_path();\n\tif (!path) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\twc = kzalloc(sizeof(*wc), GFP_NOFS);\n\tif (!wc) {\n\t\tbtrfs_free_path(path);\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\ttrans = btrfs_start_transaction(tree_root, 0);\n\tif (IS_ERR(trans)) {\n\t\terr = PTR_ERR(trans);\n\t\tgoto out_free;\n\t}\n\n\tif (block_rsv)\n\t\ttrans->block_rsv = block_rsv;\n\n\tif (btrfs_disk_key_objectid(&root_item->drop_progress) == 0) {\n\t\tlevel = btrfs_header_level(root->node);\n\t\tpath->nodes[level] = btrfs_lock_root_node(root);\n\t\tbtrfs_set_lock_blocking(path->nodes[level]);\n\t\tpath->slots[level] = 0;\n\t\tpath->locks[level] = BTRFS_WRITE_LOCK_BLOCKING;\n\t\tmemset(&wc->update_progress, 0,\n\t\t       sizeof(wc->update_progress));\n\t} else {\n\t\tbtrfs_disk_key_to_cpu(&key, &root_item->drop_progress);\n\t\tmemcpy(&wc->update_progress, &key,\n\t\t       sizeof(wc->update_progress));\n\n\t\tlevel = root_item->drop_level;\n\t\tBUG_ON(level == 0);\n\t\tpath->lowest_level = level;\n\t\tret = btrfs_search_slot(NULL, root, &key, path, 0, 0);\n\t\tpath->lowest_level = 0;\n\t\tif (ret < 0) {\n\t\t\terr = ret;\n\t\t\tgoto out_end_trans;\n\t\t}\n\t\tWARN_ON(ret > 0);\n\n\t\t/*\n\t\t * unlock our path, this is safe because only this\n\t\t * function is allowed to delete this snapshot\n\t\t */\n\t\tbtrfs_unlock_up_safe(path, 0);\n\n\t\tlevel = btrfs_header_level(root->node);\n\t\twhile (1) {\n\t\t\tbtrfs_tree_lock(path->nodes[level]);\n\t\t\tbtrfs_set_lock_blocking(path->nodes[level]);\n\t\t\tpath->locks[level] = BTRFS_WRITE_LOCK_BLOCKING;\n\n\t\t\tret = btrfs_lookup_extent_info(trans, root,\n\t\t\t\t\t\tpath->nodes[level]->start,\n\t\t\t\t\t\tlevel, 1, &wc->refs[level],\n\t\t\t\t\t\t&wc->flags[level]);\n\t\t\tif (ret < 0) {\n\t\t\t\terr = ret;\n\t\t\t\tgoto out_end_trans;\n\t\t\t}\n\t\t\tBUG_ON(wc->refs[level] == 0);\n\n\t\t\tif (level == root_item->drop_level)\n\t\t\t\tbreak;\n\n\t\t\tbtrfs_tree_unlock(path->nodes[level]);\n\t\t\tpath->locks[level] = 0;\n\t\t\tWARN_ON(wc->refs[level] != 1);\n\t\t\tlevel--;\n\t\t}\n\t}\n\n\twc->level = level;\n\twc->shared_level = -1;\n\twc->stage = DROP_REFERENCE;\n\twc->update_ref = update_ref;\n\twc->keep_locks = 0;\n\twc->for_reloc = for_reloc;\n\twc->reada_count = BTRFS_NODEPTRS_PER_BLOCK(root);\n\n\twhile (1) {\n\n\t\tret = walk_down_tree(trans, root, path, wc);\n\t\tif (ret < 0) {\n\t\t\terr = ret;\n\t\t\tbreak;\n\t\t}\n\n\t\tret = walk_up_tree(trans, root, path, wc, BTRFS_MAX_LEVEL);\n\t\tif (ret < 0) {\n\t\t\terr = ret;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (ret > 0) {\n\t\t\tBUG_ON(wc->stage != DROP_REFERENCE);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (wc->stage == DROP_REFERENCE) {\n\t\t\tlevel = wc->level;\n\t\t\tbtrfs_node_key(path->nodes[level],\n\t\t\t\t       &root_item->drop_progress,\n\t\t\t\t       path->slots[level]);\n\t\t\troot_item->drop_level = level;\n\t\t}\n\n\t\tBUG_ON(wc->level == 0);\n\t\tif (btrfs_should_end_transaction(trans, tree_root) ||\n\t\t    (!for_reloc && btrfs_need_cleaner_sleep(root))) {\n\t\t\tret = btrfs_update_root(trans, tree_root,\n\t\t\t\t\t\t&root->root_key,\n\t\t\t\t\t\troot_item);\n\t\t\tif (ret) {\n\t\t\t\tbtrfs_abort_transaction(trans, tree_root, ret);\n\t\t\t\terr = ret;\n\t\t\t\tgoto out_end_trans;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Qgroup update accounting is run from\n\t\t\t * delayed ref handling. This usually works\n\t\t\t * out because delayed refs are normally the\n\t\t\t * only way qgroup updates are added. However,\n\t\t\t * we may have added updates during our tree\n\t\t\t * walk so run qgroups here to make sure we\n\t\t\t * don't lose any updates.\n\t\t\t */\n\t\t\tret = btrfs_delayed_qgroup_accounting(trans,\n\t\t\t\t\t\t\t      root->fs_info);\n\t\t\tif (ret)\n\t\t\t\tprintk_ratelimited(KERN_ERR \"BTRFS: Failure %d \"\n\t\t\t\t\t\t   \"running qgroup updates \"\n\t\t\t\t\t\t   \"during snapshot delete. \"\n\t\t\t\t\t\t   \"Quota is out of sync, \"\n\t\t\t\t\t\t   \"rescan required.\\n\", ret);\n\n\t\t\tbtrfs_end_transaction_throttle(trans, tree_root);\n\t\t\tif (!for_reloc && btrfs_need_cleaner_sleep(root)) {\n\t\t\t\tpr_debug(\"BTRFS: drop snapshot early exit\\n\");\n\t\t\t\terr = -EAGAIN;\n\t\t\t\tgoto out_free;\n\t\t\t}\n\n\t\t\ttrans = btrfs_start_transaction(tree_root, 0);\n\t\t\tif (IS_ERR(trans)) {\n\t\t\t\terr = PTR_ERR(trans);\n\t\t\t\tgoto out_free;\n\t\t\t}\n\t\t\tif (block_rsv)\n\t\t\t\ttrans->block_rsv = block_rsv;\n\t\t}\n\t}\n\tbtrfs_release_path(path);\n\tif (err)\n\t\tgoto out_end_trans;\n\n\tret = btrfs_del_root(trans, tree_root, &root->root_key);\n\tif (ret) {\n\t\tbtrfs_abort_transaction(trans, tree_root, ret);\n\t\tgoto out_end_trans;\n\t}\n\n\tif (root->root_key.objectid != BTRFS_TREE_RELOC_OBJECTID) {\n\t\tret = btrfs_find_root(tree_root, &root->root_key, path,\n\t\t\t\t      NULL, NULL);\n\t\tif (ret < 0) {\n\t\t\tbtrfs_abort_transaction(trans, tree_root, ret);\n\t\t\terr = ret;\n\t\t\tgoto out_end_trans;\n\t\t} else if (ret > 0) {\n\t\t\t/* if we fail to delete the orphan item this time\n\t\t\t * around, it'll get picked up the next time.\n\t\t\t *\n\t\t\t * The most common failure here is just -ENOENT.\n\t\t\t */\n\t\t\tbtrfs_del_orphan_item(trans, tree_root,\n\t\t\t\t\t      root->root_key.objectid);\n\t\t}\n\t}\n\n\tif (test_bit(BTRFS_ROOT_IN_RADIX, &root->state)) {\n\t\tbtrfs_drop_and_free_fs_root(tree_root->fs_info, root);\n\t} else {\n\t\tfree_extent_buffer(root->node);\n\t\tfree_extent_buffer(root->commit_root);\n\t\tbtrfs_put_fs_root(root);\n\t}\n\troot_dropped = true;\nout_end_trans:\n\tret = btrfs_delayed_qgroup_accounting(trans, tree_root->fs_info);\n\tif (ret)\n\t\tprintk_ratelimited(KERN_ERR \"BTRFS: Failure %d \"\n\t\t\t\t   \"running qgroup updates \"\n\t\t\t\t   \"during snapshot delete. \"\n\t\t\t\t   \"Quota is out of sync, \"\n\t\t\t\t   \"rescan required.\\n\", ret);\n\n\tbtrfs_end_transaction_throttle(trans, tree_root);\nout_free:\n\tkfree(wc);\n\tbtrfs_free_path(path);\nout:\n\t/*\n\t * So if we need to stop dropping the snapshot for whatever reason we\n\t * need to make sure to add it back to the dead root list so that we\n\t * keep trying to do the work later.  This also cleans up roots if we\n\t * don't have it in the radix (like when we recover after a power fail\n\t * or unmount) so we don't leak memory.\n\t */\n\tif (!for_reloc && root_dropped == false)\n\t\tbtrfs_add_dead_root(root);\n\tif (err && err != -EAGAIN)\n\t\tbtrfs_std_error(root->fs_info, err);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_header_backref_rev",
          "args": [
            "root->node"
          ],
          "line": 2130
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_header_backref_rev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2817-2821",
          "snippet": "static inline int btrfs_header_backref_rev(struct extent_buffer *eb)\n{\n\tu64 flags = btrfs_header_flags(eb);\n\treturn flags >> BTRFS_BACKREF_REV_SHIFT;\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [
            "#define BTRFS_BACKREF_REV_SHIFT\t\t56"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\n#define BTRFS_BACKREF_REV_SHIFT\t\t56\n\nstatic inline int btrfs_header_backref_rev(struct extent_buffer *eb)\n{\n\tu64 flags = btrfs_header_flags(eb);\n\treturn flags >> BTRFS_BACKREF_REV_SHIFT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_kill_all_delayed_nodes",
          "args": [
            "root"
          ],
          "line": 2128
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_kill_all_delayed_nodes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-inode.c",
          "lines": "1949-1976",
          "snippet": "void btrfs_kill_all_delayed_nodes(struct btrfs_root *root)\n{\n\tu64 inode_id = 0;\n\tstruct btrfs_delayed_node *delayed_nodes[8];\n\tint i, n;\n\n\twhile (1) {\n\t\tspin_lock(&root->inode_lock);\n\t\tn = radix_tree_gang_lookup(&root->delayed_nodes_tree,\n\t\t\t\t\t   (void **)delayed_nodes, inode_id,\n\t\t\t\t\t   ARRAY_SIZE(delayed_nodes));\n\t\tif (!n) {\n\t\t\tspin_unlock(&root->inode_lock);\n\t\t\tbreak;\n\t\t}\n\n\t\tinode_id = delayed_nodes[n - 1]->inode_id + 1;\n\n\t\tfor (i = 0; i < n; i++)\n\t\t\tatomic_inc(&delayed_nodes[i]->refs);\n\t\tspin_unlock(&root->inode_lock);\n\n\t\tfor (i = 0; i < n; i++) {\n\t\t\t__btrfs_kill_delayed_node(delayed_nodes[i]);\n\t\t\tbtrfs_release_delayed_node(delayed_nodes[i]);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"delayed-inode.h\"\n#include <linux/slab.h>\n\nvoid btrfs_kill_all_delayed_nodes(struct btrfs_root *root)\n{\n\tu64 inode_id = 0;\n\tstruct btrfs_delayed_node *delayed_nodes[8];\n\tint i, n;\n\n\twhile (1) {\n\t\tspin_lock(&root->inode_lock);\n\t\tn = radix_tree_gang_lookup(&root->delayed_nodes_tree,\n\t\t\t\t\t   (void **)delayed_nodes, inode_id,\n\t\t\t\t\t   ARRAY_SIZE(delayed_nodes));\n\t\tif (!n) {\n\t\t\tspin_unlock(&root->inode_lock);\n\t\t\tbreak;\n\t\t}\n\n\t\tinode_id = delayed_nodes[n - 1]->inode_id + 1;\n\n\t\tfor (i = 0; i < n; i++)\n\t\t\tatomic_inc(&delayed_nodes[i]->refs);\n\t\tspin_unlock(&root->inode_lock);\n\n\t\tfor (i = 0; i < n; i++) {\n\t\t\t__btrfs_kill_delayed_node(delayed_nodes[i]);\n\t\t\tbtrfs_release_delayed_node(delayed_nodes[i]);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"BTRFS: cleaner removing %llu\\n\"",
            "root->objectid"
          ],
          "line": 2126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&fs_info->trans_lock"
          ],
          "line": 2124
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&root->root_list"
          ],
          "line": 2123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_first_entry",
          "args": [
            "&fs_info->dead_roots",
            "structbtrfs_root",
            "root_list"
          ],
          "line": 2121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&fs_info->dead_roots"
          ],
          "line": 2117
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&fs_info->trans_lock"
          ],
          "line": 2116
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint btrfs_clean_one_deleted_snapshot(struct btrfs_root *root)\n{\n\tint ret;\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\n\tspin_lock(&fs_info->trans_lock);\n\tif (list_empty(&fs_info->dead_roots)) {\n\t\tspin_unlock(&fs_info->trans_lock);\n\t\treturn 0;\n\t}\n\troot = list_first_entry(&fs_info->dead_roots,\n\t\t\tstruct btrfs_root, root_list);\n\tlist_del_init(&root->root_list);\n\tspin_unlock(&fs_info->trans_lock);\n\n\tpr_debug(\"BTRFS: cleaner removing %llu\\n\", root->objectid);\n\n\tbtrfs_kill_all_delayed_nodes(root);\n\n\tif (btrfs_header_backref_rev(root->node) <\n\t\t\tBTRFS_MIXED_BACKREF_REV)\n\t\tret = btrfs_drop_snapshot(root, NULL, 0, 0);\n\telse\n\t\tret = btrfs_drop_snapshot(root, NULL, 1, 0);\n\n\treturn (ret < 0) ? 0 : 1;\n}"
  },
  {
    "function_name": "btrfs_commit_transaction",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
    "lines": "1764-2099",
    "snippet": "int btrfs_commit_transaction(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root)\n{\n\tstruct btrfs_transaction *cur_trans = trans->transaction;\n\tstruct btrfs_transaction *prev_trans = NULL;\n\tstruct btrfs_inode *btree_ino = BTRFS_I(root->fs_info->btree_inode);\n\tint ret;\n\n\t/* Stop the commit early if ->aborted is set */\n\tif (unlikely(ACCESS_ONCE(cur_trans->aborted))) {\n\t\tret = cur_trans->aborted;\n\t\tbtrfs_end_transaction(trans, root);\n\t\treturn ret;\n\t}\n\n\t/* make a pass through all the delayed refs we have so far\n\t * any runnings procs may add more while we are here\n\t */\n\tret = btrfs_run_delayed_refs(trans, root, 0);\n\tif (ret) {\n\t\tbtrfs_end_transaction(trans, root);\n\t\treturn ret;\n\t}\n\n\tbtrfs_trans_release_metadata(trans, root);\n\ttrans->block_rsv = NULL;\n\tif (trans->qgroup_reserved) {\n\t\tbtrfs_qgroup_free(root, trans->qgroup_reserved);\n\t\ttrans->qgroup_reserved = 0;\n\t}\n\n\tcur_trans = trans->transaction;\n\n\t/*\n\t * set the flushing flag so procs in this transaction have to\n\t * start sending their work down.\n\t */\n\tcur_trans->delayed_refs.flushing = 1;\n\tsmp_wmb();\n\n\tif (!list_empty(&trans->new_bgs))\n\t\tbtrfs_create_pending_block_groups(trans, root);\n\n\tret = btrfs_run_delayed_refs(trans, root, 0);\n\tif (ret) {\n\t\tbtrfs_end_transaction(trans, root);\n\t\treturn ret;\n\t}\n\n\tspin_lock(&root->fs_info->trans_lock);\n\tlist_splice(&trans->ordered, &cur_trans->pending_ordered);\n\tif (cur_trans->state >= TRANS_STATE_COMMIT_START) {\n\t\tspin_unlock(&root->fs_info->trans_lock);\n\t\tatomic_inc(&cur_trans->use_count);\n\t\tret = btrfs_end_transaction(trans, root);\n\n\t\twait_for_commit(root, cur_trans);\n\n\t\tif (unlikely(cur_trans->aborted))\n\t\t\tret = cur_trans->aborted;\n\n\t\tbtrfs_put_transaction(cur_trans);\n\n\t\treturn ret;\n\t}\n\n\tcur_trans->state = TRANS_STATE_COMMIT_START;\n\twake_up(&root->fs_info->transaction_blocked_wait);\n\n\tif (cur_trans->list.prev != &root->fs_info->trans_list) {\n\t\tprev_trans = list_entry(cur_trans->list.prev,\n\t\t\t\t\tstruct btrfs_transaction, list);\n\t\tif (prev_trans->state != TRANS_STATE_COMPLETED) {\n\t\t\tatomic_inc(&prev_trans->use_count);\n\t\t\tspin_unlock(&root->fs_info->trans_lock);\n\n\t\t\twait_for_commit(root, prev_trans);\n\n\t\t\tbtrfs_put_transaction(prev_trans);\n\t\t} else {\n\t\t\tspin_unlock(&root->fs_info->trans_lock);\n\t\t}\n\t} else {\n\t\tspin_unlock(&root->fs_info->trans_lock);\n\t}\n\n\textwriter_counter_dec(cur_trans, trans->type);\n\n\tret = btrfs_start_delalloc_flush(root->fs_info);\n\tif (ret)\n\t\tgoto cleanup_transaction;\n\n\tret = btrfs_run_delayed_items(trans, root);\n\tif (ret)\n\t\tgoto cleanup_transaction;\n\n\twait_event(cur_trans->writer_wait,\n\t\t   extwriter_counter_read(cur_trans) == 0);\n\n\t/* some pending stuffs might be added after the previous flush. */\n\tret = btrfs_run_delayed_items(trans, root);\n\tif (ret)\n\t\tgoto cleanup_transaction;\n\n\tbtrfs_wait_delalloc_flush(root->fs_info);\n\n\tbtrfs_wait_pending_ordered(cur_trans, root->fs_info);\n\n\tbtrfs_scrub_pause(root);\n\t/*\n\t * Ok now we need to make sure to block out any other joins while we\n\t * commit the transaction.  We could have started a join before setting\n\t * COMMIT_DOING so make sure to wait for num_writers to == 1 again.\n\t */\n\tspin_lock(&root->fs_info->trans_lock);\n\tcur_trans->state = TRANS_STATE_COMMIT_DOING;\n\tspin_unlock(&root->fs_info->trans_lock);\n\twait_event(cur_trans->writer_wait,\n\t\t   atomic_read(&cur_trans->num_writers) == 1);\n\n\t/* ->aborted might be set after the previous check, so check it */\n\tif (unlikely(ACCESS_ONCE(cur_trans->aborted))) {\n\t\tret = cur_trans->aborted;\n\t\tgoto scrub_continue;\n\t}\n\t/*\n\t * the reloc mutex makes sure that we stop\n\t * the balancing code from coming in and moving\n\t * extents around in the middle of the commit\n\t */\n\tmutex_lock(&root->fs_info->reloc_mutex);\n\n\t/*\n\t * We needn't worry about the delayed items because we will\n\t * deal with them in create_pending_snapshot(), which is the\n\t * core function of the snapshot creation.\n\t */\n\tret = create_pending_snapshots(trans, root->fs_info);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * We insert the dir indexes of the snapshots and update the inode\n\t * of the snapshots' parents after the snapshot creation, so there\n\t * are some delayed items which are not dealt with. Now deal with\n\t * them.\n\t *\n\t * We needn't worry that this operation will corrupt the snapshots,\n\t * because all the tree which are snapshoted will be forced to COW\n\t * the nodes and leaves.\n\t */\n\tret = btrfs_run_delayed_items(trans, root);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\tret = btrfs_run_delayed_refs(trans, root, (unsigned long)-1);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * make sure none of the code above managed to slip in a\n\t * delayed item\n\t */\n\tbtrfs_assert_delayed_root_empty(root);\n\n\tWARN_ON(cur_trans != trans->transaction);\n\n\t/* btrfs_commit_tree_roots is responsible for getting the\n\t * various roots consistent with each other.  Every pointer\n\t * in the tree of tree roots has to point to the most up to date\n\t * root for every subvolume and other tree.  So, we have to keep\n\t * the tree logging code from jumping in and changing any\n\t * of the trees.\n\t *\n\t * At this point in the commit, there can't be any tree-log\n\t * writers, but a little lower down we drop the trans mutex\n\t * and let new people in.  By holding the tree_log_mutex\n\t * from now until after the super is written, we avoid races\n\t * with the tree-log code.\n\t */\n\tmutex_lock(&root->fs_info->tree_log_mutex);\n\n\tret = commit_fs_roots(trans, root);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * Since the transaction is done, we can apply the pending changes\n\t * before the next transaction.\n\t */\n\tbtrfs_apply_pending_changes(root->fs_info);\n\n\t/* commit_fs_roots gets rid of all the tree log roots, it is now\n\t * safe to free the root of tree log roots\n\t */\n\tbtrfs_free_log_root_tree(trans, root->fs_info);\n\n\tret = commit_cowonly_roots(trans, root);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * The tasks which save the space cache and inode cache may also\n\t * update ->aborted, check it.\n\t */\n\tif (unlikely(ACCESS_ONCE(cur_trans->aborted))) {\n\t\tret = cur_trans->aborted;\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\tbtrfs_prepare_extent_commit(trans, root);\n\n\tcur_trans = root->fs_info->running_transaction;\n\n\tbtrfs_set_root_node(&root->fs_info->tree_root->root_item,\n\t\t\t    root->fs_info->tree_root->node);\n\tlist_add_tail(&root->fs_info->tree_root->dirty_list,\n\t\t      &cur_trans->switch_commits);\n\n\tbtrfs_set_root_node(&root->fs_info->chunk_root->root_item,\n\t\t\t    root->fs_info->chunk_root->node);\n\tlist_add_tail(&root->fs_info->chunk_root->dirty_list,\n\t\t      &cur_trans->switch_commits);\n\n\tswitch_commit_roots(cur_trans, root->fs_info);\n\n\tassert_qgroups_uptodate(trans);\n\tASSERT(list_empty(&cur_trans->dirty_bgs));\n\tupdate_super_roots(root);\n\n\tbtrfs_set_super_log_root(root->fs_info->super_copy, 0);\n\tbtrfs_set_super_log_root_level(root->fs_info->super_copy, 0);\n\tmemcpy(root->fs_info->super_for_commit, root->fs_info->super_copy,\n\t       sizeof(*root->fs_info->super_copy));\n\n\tbtrfs_update_commit_device_size(root->fs_info);\n\tbtrfs_update_commit_device_bytes_used(root, cur_trans);\n\n\tclear_bit(BTRFS_INODE_BTREE_LOG1_ERR, &btree_ino->runtime_flags);\n\tclear_bit(BTRFS_INODE_BTREE_LOG2_ERR, &btree_ino->runtime_flags);\n\n\tspin_lock(&root->fs_info->trans_lock);\n\tcur_trans->state = TRANS_STATE_UNBLOCKED;\n\troot->fs_info->running_transaction = NULL;\n\tspin_unlock(&root->fs_info->trans_lock);\n\tmutex_unlock(&root->fs_info->reloc_mutex);\n\n\twake_up(&root->fs_info->transaction_wait);\n\n\tret = btrfs_write_and_wait_transaction(trans, root);\n\tif (ret) {\n\t\tbtrfs_error(root->fs_info, ret,\n\t\t\t    \"Error while writing out transaction\");\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\tret = write_ctree_super(trans, root, 0);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * the super is written, we can safely allow the tree-loggers\n\t * to go about their business\n\t */\n\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\n\tbtrfs_finish_extent_commit(trans, root);\n\n\tif (cur_trans->have_free_bgs)\n\t\tbtrfs_clear_space_info_full(root->fs_info);\n\n\troot->fs_info->last_trans_committed = cur_trans->transid;\n\t/*\n\t * We needn't acquire the lock here because there is no other task\n\t * which can change it.\n\t */\n\tcur_trans->state = TRANS_STATE_COMPLETED;\n\twake_up(&cur_trans->commit_wait);\n\n\tspin_lock(&root->fs_info->trans_lock);\n\tlist_del_init(&cur_trans->list);\n\tspin_unlock(&root->fs_info->trans_lock);\n\n\tbtrfs_put_transaction(cur_trans);\n\tbtrfs_put_transaction(cur_trans);\n\n\tif (trans->type & __TRANS_FREEZABLE)\n\t\tsb_end_intwrite(root->fs_info->sb);\n\n\ttrace_btrfs_transaction_commit(root);\n\n\tbtrfs_scrub_continue(root);\n\n\tif (current->journal_info == trans)\n\t\tcurrent->journal_info = NULL;\n\n\tkmem_cache_free(btrfs_trans_handle_cachep, trans);\n\n\tif (current != root->fs_info->transaction_kthread)\n\t\tbtrfs_run_delayed_iputs(root);\n\n\treturn ret;\n\nscrub_continue:\n\tbtrfs_scrub_continue(root);\ncleanup_transaction:\n\tbtrfs_trans_release_metadata(trans, root);\n\ttrans->block_rsv = NULL;\n\tif (trans->qgroup_reserved) {\n\t\tbtrfs_qgroup_free(root, trans->qgroup_reserved);\n\t\ttrans->qgroup_reserved = 0;\n\t}\n\tbtrfs_warn(root->fs_info, \"Skipping commit of aborted transaction.\");\n\tif (current->journal_info == trans)\n\t\tcurrent->journal_info = NULL;\n\tcleanup_transaction(trans, root, ret);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"dev-replace.h\"",
      "#include \"volumes.h\"",
      "#include \"inode-map.h\"",
      "#include \"tree-log.h\"",
      "#include \"locking.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/uuid.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/writeback.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cleanup_transaction",
          "args": [
            "trans",
            "root",
            "ret"
          ],
          "line": 2096
        },
        "resolved": true,
        "details": {
          "function_name": "cleanup_transaction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
          "lines": "1678-1727",
          "snippet": "static void cleanup_transaction(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root, int err)\n{\n\tstruct btrfs_transaction *cur_trans = trans->transaction;\n\tDEFINE_WAIT(wait);\n\n\tWARN_ON(trans->use_count > 1);\n\n\tbtrfs_abort_transaction(trans, root, err);\n\n\tspin_lock(&root->fs_info->trans_lock);\n\n\t/*\n\t * If the transaction is removed from the list, it means this\n\t * transaction has been committed successfully, so it is impossible\n\t * to call the cleanup function.\n\t */\n\tBUG_ON(list_empty(&cur_trans->list));\n\n\tlist_del_init(&cur_trans->list);\n\tif (cur_trans == root->fs_info->running_transaction) {\n\t\tcur_trans->state = TRANS_STATE_COMMIT_DOING;\n\t\tspin_unlock(&root->fs_info->trans_lock);\n\t\twait_event(cur_trans->writer_wait,\n\t\t\t   atomic_read(&cur_trans->num_writers) == 1);\n\n\t\tspin_lock(&root->fs_info->trans_lock);\n\t}\n\tspin_unlock(&root->fs_info->trans_lock);\n\n\tbtrfs_cleanup_one_transaction(trans->transaction, root);\n\n\tspin_lock(&root->fs_info->trans_lock);\n\tif (cur_trans == root->fs_info->running_transaction)\n\t\troot->fs_info->running_transaction = NULL;\n\tspin_unlock(&root->fs_info->trans_lock);\n\n\tif (trans->type & __TRANS_FREEZABLE)\n\t\tsb_end_intwrite(root->fs_info->sb);\n\tbtrfs_put_transaction(cur_trans);\n\tbtrfs_put_transaction(cur_trans);\n\n\ttrace_btrfs_transaction_commit(root);\n\n\tif (current->journal_info == trans)\n\t\tcurrent->journal_info = NULL;\n\tbtrfs_scrub_cancel(root->fs_info);\n\n\tkmem_cache_free(btrfs_trans_handle_cachep, trans);\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"dev-replace.h\"",
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void cleanup_transaction(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root, int err)\n{\n\tstruct btrfs_transaction *cur_trans = trans->transaction;\n\tDEFINE_WAIT(wait);\n\n\tWARN_ON(trans->use_count > 1);\n\n\tbtrfs_abort_transaction(trans, root, err);\n\n\tspin_lock(&root->fs_info->trans_lock);\n\n\t/*\n\t * If the transaction is removed from the list, it means this\n\t * transaction has been committed successfully, so it is impossible\n\t * to call the cleanup function.\n\t */\n\tBUG_ON(list_empty(&cur_trans->list));\n\n\tlist_del_init(&cur_trans->list);\n\tif (cur_trans == root->fs_info->running_transaction) {\n\t\tcur_trans->state = TRANS_STATE_COMMIT_DOING;\n\t\tspin_unlock(&root->fs_info->trans_lock);\n\t\twait_event(cur_trans->writer_wait,\n\t\t\t   atomic_read(&cur_trans->num_writers) == 1);\n\n\t\tspin_lock(&root->fs_info->trans_lock);\n\t}\n\tspin_unlock(&root->fs_info->trans_lock);\n\n\tbtrfs_cleanup_one_transaction(trans->transaction, root);\n\n\tspin_lock(&root->fs_info->trans_lock);\n\tif (cur_trans == root->fs_info->running_transaction)\n\t\troot->fs_info->running_transaction = NULL;\n\tspin_unlock(&root->fs_info->trans_lock);\n\n\tif (trans->type & __TRANS_FREEZABLE)\n\t\tsb_end_intwrite(root->fs_info->sb);\n\tbtrfs_put_transaction(cur_trans);\n\tbtrfs_put_transaction(cur_trans);\n\n\ttrace_btrfs_transaction_commit(root);\n\n\tif (current->journal_info == trans)\n\t\tcurrent->journal_info = NULL;\n\tbtrfs_scrub_cancel(root->fs_info);\n\n\tkmem_cache_free(btrfs_trans_handle_cachep, trans);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_warn",
          "args": [
            "root->fs_info",
            "\"Skipping commit of aborted transaction.\""
          ],
          "line": 2093
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_qgroup_free",
          "args": [
            "root",
            "trans->qgroup_reserved"
          ],
          "line": 2090
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_qgroup_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/qgroup.c",
          "lines": "2448-2499",
          "snippet": "void btrfs_qgroup_free(struct btrfs_root *root, u64 num_bytes)\n{\n\tstruct btrfs_root *quota_root;\n\tstruct btrfs_qgroup *qgroup;\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tstruct ulist_node *unode;\n\tstruct ulist_iterator uiter;\n\tu64 ref_root = root->root_key.objectid;\n\tint ret = 0;\n\n\tif (!is_fstree(ref_root))\n\t\treturn;\n\n\tif (num_bytes == 0)\n\t\treturn;\n\n\tspin_lock(&fs_info->qgroup_lock);\n\n\tquota_root = fs_info->quota_root;\n\tif (!quota_root)\n\t\tgoto out;\n\n\tqgroup = find_qgroup_rb(fs_info, ref_root);\n\tif (!qgroup)\n\t\tgoto out;\n\n\tulist_reinit(fs_info->qgroup_ulist);\n\tret = ulist_add(fs_info->qgroup_ulist, qgroup->qgroupid,\n\t\t\t(uintptr_t)qgroup, GFP_ATOMIC);\n\tif (ret < 0)\n\t\tgoto out;\n\tULIST_ITER_INIT(&uiter);\n\twhile ((unode = ulist_next(fs_info->qgroup_ulist, &uiter))) {\n\t\tstruct btrfs_qgroup *qg;\n\t\tstruct btrfs_qgroup_list *glist;\n\n\t\tqg = u64_to_ptr(unode->aux);\n\n\t\tqg->reserved -= num_bytes;\n\n\t\tlist_for_each_entry(glist, &qg->groups, next_group) {\n\t\t\tret = ulist_add(fs_info->qgroup_ulist,\n\t\t\t\t\tglist->group->qgroupid,\n\t\t\t\t\t(uintptr_t)glist->group, GFP_ATOMIC);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\tspin_unlock(&fs_info->qgroup_lock);\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"ulist.h\"",
            "#include \"locking.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"ctree.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"ulist.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);\n\nvoid btrfs_qgroup_free(struct btrfs_root *root, u64 num_bytes)\n{\n\tstruct btrfs_root *quota_root;\n\tstruct btrfs_qgroup *qgroup;\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tstruct ulist_node *unode;\n\tstruct ulist_iterator uiter;\n\tu64 ref_root = root->root_key.objectid;\n\tint ret = 0;\n\n\tif (!is_fstree(ref_root))\n\t\treturn;\n\n\tif (num_bytes == 0)\n\t\treturn;\n\n\tspin_lock(&fs_info->qgroup_lock);\n\n\tquota_root = fs_info->quota_root;\n\tif (!quota_root)\n\t\tgoto out;\n\n\tqgroup = find_qgroup_rb(fs_info, ref_root);\n\tif (!qgroup)\n\t\tgoto out;\n\n\tulist_reinit(fs_info->qgroup_ulist);\n\tret = ulist_add(fs_info->qgroup_ulist, qgroup->qgroupid,\n\t\t\t(uintptr_t)qgroup, GFP_ATOMIC);\n\tif (ret < 0)\n\t\tgoto out;\n\tULIST_ITER_INIT(&uiter);\n\twhile ((unode = ulist_next(fs_info->qgroup_ulist, &uiter))) {\n\t\tstruct btrfs_qgroup *qg;\n\t\tstruct btrfs_qgroup_list *glist;\n\n\t\tqg = u64_to_ptr(unode->aux);\n\n\t\tqg->reserved -= num_bytes;\n\n\t\tlist_for_each_entry(glist, &qg->groups, next_group) {\n\t\t\tret = ulist_add(fs_info->qgroup_ulist,\n\t\t\t\t\tglist->group->qgroupid,\n\t\t\t\t\t(uintptr_t)glist->group, GFP_ATOMIC);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\tspin_unlock(&fs_info->qgroup_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_trans_release_metadata",
          "args": [
            "trans",
            "root"
          ],
          "line": 2087
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_trans_release_metadata",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent-tree.c",
          "lines": "4900-4913",
          "snippet": "void btrfs_trans_release_metadata(struct btrfs_trans_handle *trans,\n\t\t\t\t  struct btrfs_root *root)\n{\n\tif (!trans->block_rsv)\n\t\treturn;\n\n\tif (!trans->bytes_reserved)\n\t\treturn;\n\n\ttrace_btrfs_space_reservation(root->fs_info, \"transaction\",\n\t\t\t\t      trans->transid, trans->bytes_reserved, 0);\n\tbtrfs_block_rsv_release(root, trans->block_rsv, trans->bytes_reserved);\n\ttrans->bytes_reserved = 0;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"math.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include \"hash.h\"",
            "#include <linux/percpu_counter.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"math.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include \"hash.h\"\n#include <linux/percpu_counter.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n#include <linux/rcupdate.h>\n#include <linux/sort.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nvoid btrfs_trans_release_metadata(struct btrfs_trans_handle *trans,\n\t\t\t\t  struct btrfs_root *root)\n{\n\tif (!trans->block_rsv)\n\t\treturn;\n\n\tif (!trans->bytes_reserved)\n\t\treturn;\n\n\ttrace_btrfs_space_reservation(root->fs_info, \"transaction\",\n\t\t\t\t      trans->transid, trans->bytes_reserved, 0);\n\tbtrfs_block_rsv_release(root, trans->block_rsv, trans->bytes_reserved);\n\ttrans->bytes_reserved = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_scrub_continue",
          "args": [
            "root"
          ],
          "line": 2085
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_scrub_continue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/scrub.c",
          "lines": "3773-3779",
          "snippet": "void btrfs_scrub_continue(struct btrfs_root *root)\n{\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\n\tatomic_dec(&fs_info->scrub_pause_req);\n\twake_up(&fs_info->scrub_pause_wait);\n}",
          "includes": [
            "#include \"raid56.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"dev-replace.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"transaction.h\"",
            "#include \"ordered-data.h\"",
            "#include \"disk-io.h\"",
            "#include \"volumes.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);",
            "static void scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);",
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"raid56.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"dev-replace.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"transaction.h\"\n#include \"ordered-data.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/blkdev.h>\n\nstatic void __scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);\nstatic void scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);\nstatic noinline_for_stack\nstruct;\n\nvoid btrfs_scrub_continue(struct btrfs_root *root)\n{\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\n\tatomic_dec(&fs_info->scrub_pause_req);\n\twake_up(&fs_info->scrub_pause_wait);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_run_delayed_iputs",
          "args": [
            "root"
          ],
          "line": 2080
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_run_delayed_iputs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/inode.c",
          "lines": "3100-3123",
          "snippet": "void btrfs_run_delayed_iputs(struct btrfs_root *root)\n{\n\tLIST_HEAD(list);\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tstruct delayed_iput *delayed;\n\tint empty;\n\n\tspin_lock(&fs_info->delayed_iput_lock);\n\tempty = list_empty(&fs_info->delayed_iputs);\n\tspin_unlock(&fs_info->delayed_iput_lock);\n\tif (empty)\n\t\treturn;\n\n\tspin_lock(&fs_info->delayed_iput_lock);\n\tlist_splice_init(&fs_info->delayed_iputs, &list);\n\tspin_unlock(&fs_info->delayed_iput_lock);\n\n\twhile (!list_empty(&list)) {\n\t\tdelayed = list_entry(list.next, struct delayed_iput, list);\n\t\tlist_del(&delayed->list);\n\t\tiput(delayed->inode);\n\t\tkfree(delayed);\n\t}\n}",
          "includes": [
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"compression.h\"",
            "#include \"volumes.h\"",
            "#include \"tree-log.h\"",
            "#include \"xattr.h\"",
            "#include \"ordered-data.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/falloc.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/aio.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btrfs_truncate(struct inode *inode);",
            "static int btrfs_dirty_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"props.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"compression.h\"\n#include \"volumes.h\"\n#include \"tree-log.h\"\n#include \"xattr.h\"\n#include \"ordered-data.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/blkdev.h>\n#include <linux/btrfs.h>\n#include <linux/mount.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/bit_spinlock.h>\n#include <linux/aio.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic int btrfs_truncate(struct inode *inode);\nstatic int btrfs_dirty_inode(struct inode *inode);\n\nvoid btrfs_run_delayed_iputs(struct btrfs_root *root)\n{\n\tLIST_HEAD(list);\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tstruct delayed_iput *delayed;\n\tint empty;\n\n\tspin_lock(&fs_info->delayed_iput_lock);\n\tempty = list_empty(&fs_info->delayed_iputs);\n\tspin_unlock(&fs_info->delayed_iput_lock);\n\tif (empty)\n\t\treturn;\n\n\tspin_lock(&fs_info->delayed_iput_lock);\n\tlist_splice_init(&fs_info->delayed_iputs, &list);\n\tspin_unlock(&fs_info->delayed_iput_lock);\n\n\twhile (!list_empty(&list)) {\n\t\tdelayed = list_entry(list.next, struct delayed_iput, list);\n\t\tlist_del(&delayed->list);\n\t\tiput(delayed->inode);\n\t\tkfree(delayed);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "btrfs_trans_handle_cachep",
            "trans"
          ],
          "line": 2077
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_btrfs_transaction_commit",
          "args": [
            "root"
          ],
          "line": 2070
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_end_intwrite",
          "args": [
            "root->fs_info->sb"
          ],
          "line": 2068
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_put_transaction",
          "args": [
            "cur_trans"
          ],
          "line": 2065
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_put_transaction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
          "lines": "61-77",
          "snippet": "void btrfs_put_transaction(struct btrfs_transaction *transaction)\n{\n\tWARN_ON(atomic_read(&transaction->use_count) == 0);\n\tif (atomic_dec_and_test(&transaction->use_count)) {\n\t\tBUG_ON(!list_empty(&transaction->list));\n\t\tWARN_ON(!RB_EMPTY_ROOT(&transaction->delayed_refs.href_root));\n\t\twhile (!list_empty(&transaction->pending_chunks)) {\n\t\t\tstruct extent_map *em;\n\n\t\t\tem = list_first_entry(&transaction->pending_chunks,\n\t\t\t\t\t      struct extent_map, list);\n\t\t\tlist_del_init(&em->list);\n\t\t\tfree_extent_map(em);\n\t\t}\n\t\tkmem_cache_free(btrfs_transaction_cachep, transaction);\n\t}\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"dev-replace.h\"",
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid btrfs_put_transaction(struct btrfs_transaction *transaction)\n{\n\tWARN_ON(atomic_read(&transaction->use_count) == 0);\n\tif (atomic_dec_and_test(&transaction->use_count)) {\n\t\tBUG_ON(!list_empty(&transaction->list));\n\t\tWARN_ON(!RB_EMPTY_ROOT(&transaction->delayed_refs.href_root));\n\t\twhile (!list_empty(&transaction->pending_chunks)) {\n\t\t\tstruct extent_map *em;\n\n\t\t\tem = list_first_entry(&transaction->pending_chunks,\n\t\t\t\t\t      struct extent_map, list);\n\t\t\tlist_del_init(&em->list);\n\t\t\tfree_extent_map(em);\n\t\t}\n\t\tkmem_cache_free(btrfs_transaction_cachep, transaction);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&root->fs_info->trans_lock"
          ],
          "line": 2062
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&cur_trans->list"
          ],
          "line": 2061
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&root->fs_info->trans_lock"
          ],
          "line": 2060
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "wake_up",
          "args": [
            "&cur_trans->commit_wait"
          ],
          "line": 2058
        },
        "resolved": true,
        "details": {
          "function_name": "locks_wake_up_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "656-681",
          "snippet": "static void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(blocked_lock_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic DEFINE_SPINLOCK(blocked_lock_lock);\n\nstatic void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_clear_space_info_full",
          "args": [
            "root->fs_info"
          ],
          "line": 2050
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_clear_space_info_full",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent-tree.c",
          "lines": "703-712",
          "snippet": "void btrfs_clear_space_info_full(struct btrfs_fs_info *info)\n{\n\tstruct list_head *head = &info->space_info;\n\tstruct btrfs_space_info *found;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(found, head, list)\n\t\tfound->full = 0;\n\trcu_read_unlock();\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"math.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include \"hash.h\"",
            "#include <linux/percpu_counter.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"math.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include \"hash.h\"\n#include <linux/percpu_counter.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n#include <linux/rcupdate.h>\n#include <linux/sort.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nvoid btrfs_clear_space_info_full(struct btrfs_fs_info *info)\n{\n\tstruct list_head *head = &info->space_info;\n\tstruct btrfs_space_info *found;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(found, head, list)\n\t\tfound->full = 0;\n\trcu_read_unlock();\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_finish_extent_commit",
          "args": [
            "trans",
            "root"
          ],
          "line": 2047
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_finish_extent_commit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent-tree.c",
          "lines": "5775-5812",
          "snippet": "int btrfs_finish_extent_commit(struct btrfs_trans_handle *trans,\n\t\t\t       struct btrfs_root *root)\n{\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tstruct extent_io_tree *unpin;\n\tu64 start;\n\tu64 end;\n\tint ret;\n\n\tif (trans->aborted)\n\t\treturn 0;\n\n\tif (fs_info->pinned_extents == &fs_info->freed_extents[0])\n\t\tunpin = &fs_info->freed_extents[1];\n\telse\n\t\tunpin = &fs_info->freed_extents[0];\n\n\twhile (1) {\n\t\tmutex_lock(&fs_info->unused_bg_unpin_mutex);\n\t\tret = find_first_extent_bit(unpin, 0, &start, &end,\n\t\t\t\t\t    EXTENT_DIRTY, NULL);\n\t\tif (ret) {\n\t\t\tmutex_unlock(&fs_info->unused_bg_unpin_mutex);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (btrfs_test_opt(root, DISCARD))\n\t\t\tret = btrfs_discard_extent(root, start,\n\t\t\t\t\t\t   end + 1 - start, NULL);\n\n\t\tclear_extent_dirty(unpin, start, end, GFP_NOFS);\n\t\tunpin_extent_range(root, start, end, true);\n\t\tmutex_unlock(&fs_info->unused_bg_unpin_mutex);\n\t\tcond_resched();\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"math.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include \"hash.h\"",
            "#include <linux/percpu_counter.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"math.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include \"hash.h\"\n#include <linux/percpu_counter.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n#include <linux/rcupdate.h>\n#include <linux/sort.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nint btrfs_finish_extent_commit(struct btrfs_trans_handle *trans,\n\t\t\t       struct btrfs_root *root)\n{\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tstruct extent_io_tree *unpin;\n\tu64 start;\n\tu64 end;\n\tint ret;\n\n\tif (trans->aborted)\n\t\treturn 0;\n\n\tif (fs_info->pinned_extents == &fs_info->freed_extents[0])\n\t\tunpin = &fs_info->freed_extents[1];\n\telse\n\t\tunpin = &fs_info->freed_extents[0];\n\n\twhile (1) {\n\t\tmutex_lock(&fs_info->unused_bg_unpin_mutex);\n\t\tret = find_first_extent_bit(unpin, 0, &start, &end,\n\t\t\t\t\t    EXTENT_DIRTY, NULL);\n\t\tif (ret) {\n\t\t\tmutex_unlock(&fs_info->unused_bg_unpin_mutex);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (btrfs_test_opt(root, DISCARD))\n\t\t\tret = btrfs_discard_extent(root, start,\n\t\t\t\t\t\t   end + 1 - start, NULL);\n\n\t\tclear_extent_dirty(unpin, start, end, GFP_NOFS);\n\t\tunpin_extent_range(root, start, end, true);\n\t\tmutex_unlock(&fs_info->unused_bg_unpin_mutex);\n\t\tcond_resched();\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&root->fs_info->tree_log_mutex"
          ],
          "line": 2045
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&root->fs_info->tree_log_mutex"
          ],
          "line": 2037
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_ctree_super",
          "args": [
            "trans",
            "root",
            "0"
          ],
          "line": 2035
        },
        "resolved": true,
        "details": {
          "function_name": "write_ctree_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3518-3522",
          "snippet": "int write_ctree_super(struct btrfs_trans_handle *trans,\n\t\t      struct btrfs_root *root, int max_mirrors)\n{\n\treturn write_all_supers(root, max_mirrors);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_fs_root(struct btrfs_root *root);",
            "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
            "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
            "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
            "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
            "static void btrfs_error_commit_super(struct btrfs_root *root);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nint write_ctree_super(struct btrfs_trans_handle *trans,\n\t\t      struct btrfs_root *root, int max_mirrors)\n{\n\treturn write_all_supers(root, max_mirrors);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&root->fs_info->tree_log_mutex"
          ],
          "line": 2031
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_error",
          "args": [
            "root->fs_info",
            "ret",
            "\"Error while writing out transaction\""
          ],
          "line": 2029
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_error_unpin_extent_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent-tree.c",
          "lines": "9705-9708",
          "snippet": "int btrfs_error_unpin_extent_range(struct btrfs_root *root, u64 start, u64 end)\n{\n\treturn unpin_extent_range(root, start, end, false);\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"math.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include \"hash.h\"",
            "#include <linux/percpu_counter.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"math.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include \"hash.h\"\n#include <linux/percpu_counter.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n#include <linux/rcupdate.h>\n#include <linux/sort.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nint btrfs_error_unpin_extent_range(struct btrfs_root *root, u64 start, u64 end)\n{\n\treturn unpin_extent_range(root, start, end, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_write_and_wait_transaction",
          "args": [
            "trans",
            "root"
          ],
          "line": 2027
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_write_and_wait_transaction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
          "lines": "996-1007",
          "snippet": "static int btrfs_write_and_wait_transaction(struct btrfs_trans_handle *trans,\n\t\t\t\t     struct btrfs_root *root)\n{\n\tint ret;\n\n\tret = btrfs_write_and_wait_marked_extents(root,\n\t\t\t\t\t   &trans->transaction->dirty_pages,\n\t\t\t\t\t   EXTENT_DIRTY);\n\tclear_btree_io_tree(&trans->transaction->dirty_pages);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"dev-replace.h\"",
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic int btrfs_write_and_wait_transaction(struct btrfs_trans_handle *trans,\n\t\t\t\t     struct btrfs_root *root)\n{\n\tint ret;\n\n\tret = btrfs_write_and_wait_marked_extents(root,\n\t\t\t\t\t   &trans->transaction->dirty_pages,\n\t\t\t\t\t   EXTENT_DIRTY);\n\tclear_btree_io_tree(&trans->transaction->dirty_pages);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&root->fs_info->reloc_mutex"
          ],
          "line": 2023
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "BTRFS_INODE_BTREE_LOG2_ERR",
            "&btree_ino->runtime_flags"
          ],
          "line": 2017
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clear_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "892-896",
          "snippet": "static inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_update_commit_device_bytes_used",
          "args": [
            "root",
            "cur_trans"
          ],
          "line": 2014
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_update_commit_device_bytes_used",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
          "lines": "6712-6734",
          "snippet": "void btrfs_update_commit_device_bytes_used(struct btrfs_root *root,\n\t\t\t\t\tstruct btrfs_transaction *transaction)\n{\n\tstruct extent_map *em;\n\tstruct map_lookup *map;\n\tstruct btrfs_device *dev;\n\tint i;\n\n\tif (list_empty(&transaction->pending_chunks))\n\t\treturn;\n\n\t/* In order to kick the device replace finish process */\n\tlock_chunks(root);\n\tlist_for_each_entry(em, &transaction->pending_chunks, list) {\n\t\tmap = (struct map_lookup *)em->bdev;\n\n\t\tfor (i = 0; i < map->num_stripes; i++) {\n\t\t\tdev = map->stripes[i].dev;\n\t\t\tdev->commit_bytes_used = dev->bytes_used;\n\t\t}\n\t}\n\tunlock_chunks(root);\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);",
            "static int btrfs_relocate_sys_chunks(struct btrfs_root *root);",
            "static void __btrfs_reset_dev_stats(struct btrfs_device *dev);",
            "static void btrfs_dev_stat_print_on_error(struct btrfs_device *dev);",
            "static void btrfs_dev_stat_print_on_load(struct btrfs_device *device);",
            "static noinline struct",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);\nstatic int btrfs_relocate_sys_chunks(struct btrfs_root *root);\nstatic void __btrfs_reset_dev_stats(struct btrfs_device *dev);\nstatic void btrfs_dev_stat_print_on_error(struct btrfs_device *dev);\nstatic void btrfs_dev_stat_print_on_load(struct btrfs_device *device);\nstatic noinline struct;\nstatic noinline struct;\n\nvoid btrfs_update_commit_device_bytes_used(struct btrfs_root *root,\n\t\t\t\t\tstruct btrfs_transaction *transaction)\n{\n\tstruct extent_map *em;\n\tstruct map_lookup *map;\n\tstruct btrfs_device *dev;\n\tint i;\n\n\tif (list_empty(&transaction->pending_chunks))\n\t\treturn;\n\n\t/* In order to kick the device replace finish process */\n\tlock_chunks(root);\n\tlist_for_each_entry(em, &transaction->pending_chunks, list) {\n\t\tmap = (struct map_lookup *)em->bdev;\n\n\t\tfor (i = 0; i < map->num_stripes; i++) {\n\t\t\tdev = map->stripes[i].dev;\n\t\t\tdev->commit_bytes_used = dev->bytes_used;\n\t\t}\n\t}\n\tunlock_chunks(root);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_update_commit_device_size",
          "args": [
            "root->fs_info"
          ],
          "line": 2013
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_update_commit_device_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
          "lines": "6692-6709",
          "snippet": "void btrfs_update_commit_device_size(struct btrfs_fs_info *fs_info)\n{\n\tstruct btrfs_fs_devices *fs_devices = fs_info->fs_devices;\n\tstruct btrfs_device *curr, *next;\n\n\tif (list_empty(&fs_devices->resized_devices))\n\t\treturn;\n\n\tmutex_lock(&fs_devices->device_list_mutex);\n\tlock_chunks(fs_info->dev_root);\n\tlist_for_each_entry_safe(curr, next, &fs_devices->resized_devices,\n\t\t\t\t resized_list) {\n\t\tlist_del_init(&curr->resized_list);\n\t\tcurr->commit_total_bytes = curr->disk_total_bytes;\n\t}\n\tunlock_chunks(fs_info->dev_root);\n\tmutex_unlock(&fs_devices->device_list_mutex);\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\nstatic noinline struct;\n\nvoid btrfs_update_commit_device_size(struct btrfs_fs_info *fs_info)\n{\n\tstruct btrfs_fs_devices *fs_devices = fs_info->fs_devices;\n\tstruct btrfs_device *curr, *next;\n\n\tif (list_empty(&fs_devices->resized_devices))\n\t\treturn;\n\n\tmutex_lock(&fs_devices->device_list_mutex);\n\tlock_chunks(fs_info->dev_root);\n\tlist_for_each_entry_safe(curr, next, &fs_devices->resized_devices,\n\t\t\t\t resized_list) {\n\t\tlist_del_init(&curr->resized_list);\n\t\tcurr->commit_total_bytes = curr->disk_total_bytes;\n\t}\n\tunlock_chunks(fs_info->dev_root);\n\tmutex_unlock(&fs_devices->device_list_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "root->fs_info->super_for_commit",
            "root->fs_info->super_copy",
            "sizeof(*root->fs_info->super_copy)"
          ],
          "line": 2010
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_super_log_root_level",
          "args": [
            "root->fs_info->super_copy",
            "0"
          ],
          "line": 2009
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_super_log_root",
          "args": [
            "root->fs_info->super_copy",
            "0"
          ],
          "line": 2008
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "update_super_roots",
          "args": [
            "root"
          ],
          "line": 2006
        },
        "resolved": true,
        "details": {
          "function_name": "update_super_roots",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
          "lines": "1525-1545",
          "snippet": "static void update_super_roots(struct btrfs_root *root)\n{\n\tstruct btrfs_root_item *root_item;\n\tstruct btrfs_super_block *super;\n\n\tsuper = root->fs_info->super_copy;\n\n\troot_item = &root->fs_info->chunk_root->root_item;\n\tsuper->chunk_root = root_item->bytenr;\n\tsuper->chunk_root_generation = root_item->generation;\n\tsuper->chunk_root_level = root_item->level;\n\n\troot_item = &root->fs_info->tree_root->root_item;\n\tsuper->root = root_item->bytenr;\n\tsuper->generation = root_item->generation;\n\tsuper->root_level = root_item->level;\n\tif (btrfs_test_opt(root, SPACE_CACHE))\n\t\tsuper->cache_generation = root_item->generation;\n\tif (root->fs_info->update_uuid_tree_gen)\n\t\tsuper->uuid_tree_generation = root_item->generation;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"dev-replace.h\"",
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void update_super_roots(struct btrfs_root *root)\n{\n\tstruct btrfs_root_item *root_item;\n\tstruct btrfs_super_block *super;\n\n\tsuper = root->fs_info->super_copy;\n\n\troot_item = &root->fs_info->chunk_root->root_item;\n\tsuper->chunk_root = root_item->bytenr;\n\tsuper->chunk_root_generation = root_item->generation;\n\tsuper->chunk_root_level = root_item->level;\n\n\troot_item = &root->fs_info->tree_root->root_item;\n\tsuper->root = root_item->bytenr;\n\tsuper->generation = root_item->generation;\n\tsuper->root_level = root_item->level;\n\tif (btrfs_test_opt(root, SPACE_CACHE))\n\t\tsuper->cache_generation = root_item->generation;\n\tif (root->fs_info->update_uuid_tree_gen)\n\t\tsuper->uuid_tree_generation = root_item->generation;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "list_empty(&cur_trans->dirty_bgs)"
          ],
          "line": 2005
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&cur_trans->dirty_bgs"
          ],
          "line": 2005
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert_qgroups_uptodate",
          "args": [
            "trans"
          ],
          "line": 2004
        },
        "resolved": true,
        "details": {
          "function_name": "assert_qgroups_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/qgroup.c",
          "lines": "2501-2512",
          "snippet": "void assert_qgroups_uptodate(struct btrfs_trans_handle *trans)\n{\n\tif (list_empty(&trans->qgroup_ref_list) && !trans->delayed_ref_elem.seq)\n\t\treturn;\n\tbtrfs_err(trans->root->fs_info,\n\t\t\"qgroups not uptodate in trans handle %p:  list is%s empty, \"\n\t\t\"seq is %#x.%x\",\n\t\ttrans, list_empty(&trans->qgroup_ref_list) ? \"\" : \" not\",\n\t\t(u32)(trans->delayed_ref_elem.seq >> 32),\n\t\t(u32)trans->delayed_ref_elem.seq);\n\tBUG();\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"ulist.h\"",
            "#include \"locking.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"ctree.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"ulist.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);\n\nvoid assert_qgroups_uptodate(struct btrfs_trans_handle *trans)\n{\n\tif (list_empty(&trans->qgroup_ref_list) && !trans->delayed_ref_elem.seq)\n\t\treturn;\n\tbtrfs_err(trans->root->fs_info,\n\t\t\"qgroups not uptodate in trans handle %p:  list is%s empty, \"\n\t\t\"seq is %#x.%x\",\n\t\ttrans, list_empty(&trans->qgroup_ref_list) ? \"\" : \" not\",\n\t\t(u32)(trans->delayed_ref_elem.seq >> 32),\n\t\t(u32)trans->delayed_ref_elem.seq);\n\tBUG();\n}"
        }
      },
      {
        "call_info": {
          "callee": "switch_commit_roots",
          "args": [
            "cur_trans",
            "root->fs_info"
          ],
          "line": 2002
        },
        "resolved": true,
        "details": {
          "function_name": "switch_commit_roots",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
          "lines": "105-121",
          "snippet": "static noinline void switch_commit_roots(struct btrfs_transaction *trans,\n\t\t\t\t\t struct btrfs_fs_info *fs_info)\n{\n\tstruct btrfs_root *root, *tmp;\n\n\tdown_write(&fs_info->commit_root_sem);\n\tlist_for_each_entry_safe(root, tmp, &trans->switch_commits,\n\t\t\t\t dirty_list) {\n\t\tlist_del_init(&root->dirty_list);\n\t\tfree_extent_buffer(root->commit_root);\n\t\troot->commit_root = btrfs_root_node(root);\n\t\tif (is_fstree(root->objectid))\n\t\t\tbtrfs_unpin_free_ino(root);\n\t\tclear_btree_io_tree(&root->dirty_log_pages);\n\t}\n\tup_write(&fs_info->commit_root_sem);\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"dev-replace.h\"",
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic noinline void switch_commit_roots(struct btrfs_transaction *trans,\n\t\t\t\t\t struct btrfs_fs_info *fs_info)\n{\n\tstruct btrfs_root *root, *tmp;\n\n\tdown_write(&fs_info->commit_root_sem);\n\tlist_for_each_entry_safe(root, tmp, &trans->switch_commits,\n\t\t\t\t dirty_list) {\n\t\tlist_del_init(&root->dirty_list);\n\t\tfree_extent_buffer(root->commit_root);\n\t\troot->commit_root = btrfs_root_node(root);\n\t\tif (is_fstree(root->objectid))\n\t\t\tbtrfs_unpin_free_ino(root);\n\t\tclear_btree_io_tree(&root->dirty_log_pages);\n\t}\n\tup_write(&fs_info->commit_root_sem);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&root->fs_info->chunk_root->dirty_list",
            "&cur_trans->switch_commits"
          ],
          "line": 1999
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_root_node",
          "args": [
            "&root->fs_info->chunk_root->root_item",
            "root->fs_info->chunk_root->node"
          ],
          "line": 1997
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_root_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/root-tree.c",
          "lines": "124-130",
          "snippet": "void btrfs_set_root_node(struct btrfs_root_item *item,\n\t\t\t struct extent_buffer *node)\n{\n\tbtrfs_set_root_bytenr(item, node->start);\n\tbtrfs_set_root_level(item, btrfs_header_level(node));\n\tbtrfs_set_root_generation(item, btrfs_header_generation(node));\n}",
          "includes": [
            "#include \"print-tree.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uuid.h>",
            "#include <linux/err.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"print-tree.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/err.h>\n\nvoid btrfs_set_root_node(struct btrfs_root_item *item,\n\t\t\t struct extent_buffer *node)\n{\n\tbtrfs_set_root_bytenr(item, node->start);\n\tbtrfs_set_root_level(item, btrfs_header_level(node));\n\tbtrfs_set_root_generation(item, btrfs_header_generation(node));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&root->fs_info->tree_root->dirty_list",
            "&cur_trans->switch_commits"
          ],
          "line": 1994
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_prepare_extent_commit",
          "args": [
            "trans",
            "root"
          ],
          "line": 1988
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_prepare_extent_commit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent-tree.c",
          "lines": "5681-5711",
          "snippet": "void btrfs_prepare_extent_commit(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root)\n{\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tstruct btrfs_caching_control *next;\n\tstruct btrfs_caching_control *caching_ctl;\n\tstruct btrfs_block_group_cache *cache;\n\n\tdown_write(&fs_info->commit_root_sem);\n\n\tlist_for_each_entry_safe(caching_ctl, next,\n\t\t\t\t &fs_info->caching_block_groups, list) {\n\t\tcache = caching_ctl->block_group;\n\t\tif (block_group_cache_done(cache)) {\n\t\t\tcache->last_byte_to_unpin = (u64)-1;\n\t\t\tlist_del_init(&caching_ctl->list);\n\t\t\tput_caching_control(caching_ctl);\n\t\t} else {\n\t\t\tcache->last_byte_to_unpin = caching_ctl->progress;\n\t\t}\n\t}\n\n\tif (fs_info->pinned_extents == &fs_info->freed_extents[0])\n\t\tfs_info->pinned_extents = &fs_info->freed_extents[1];\n\telse\n\t\tfs_info->pinned_extents = &fs_info->freed_extents[0];\n\n\tup_write(&fs_info->commit_root_sem);\n\n\tupdate_global_block_rsv(fs_info);\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"math.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include \"hash.h\"",
            "#include <linux/percpu_counter.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"math.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include \"hash.h\"\n#include <linux/percpu_counter.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n#include <linux/rcupdate.h>\n#include <linux/sort.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nvoid btrfs_prepare_extent_commit(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root)\n{\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tstruct btrfs_caching_control *next;\n\tstruct btrfs_caching_control *caching_ctl;\n\tstruct btrfs_block_group_cache *cache;\n\n\tdown_write(&fs_info->commit_root_sem);\n\n\tlist_for_each_entry_safe(caching_ctl, next,\n\t\t\t\t &fs_info->caching_block_groups, list) {\n\t\tcache = caching_ctl->block_group;\n\t\tif (block_group_cache_done(cache)) {\n\t\t\tcache->last_byte_to_unpin = (u64)-1;\n\t\t\tlist_del_init(&caching_ctl->list);\n\t\t\tput_caching_control(caching_ctl);\n\t\t} else {\n\t\t\tcache->last_byte_to_unpin = caching_ctl->progress;\n\t\t}\n\t}\n\n\tif (fs_info->pinned_extents == &fs_info->freed_extents[0])\n\t\tfs_info->pinned_extents = &fs_info->freed_extents[1];\n\telse\n\t\tfs_info->pinned_extents = &fs_info->freed_extents[0];\n\n\tup_write(&fs_info->commit_root_sem);\n\n\tupdate_global_block_rsv(fs_info);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&root->fs_info->reloc_mutex"
          ],
          "line": 1984
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&root->fs_info->tree_log_mutex"
          ],
          "line": 1983
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ACCESS_ONCE(cur_trans->aborted)"
          ],
          "line": 1981
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ACCESS_ONCE",
          "args": [
            "cur_trans->aborted"
          ],
          "line": 1981
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&root->fs_info->reloc_mutex"
          ],
          "line": 1973
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&root->fs_info->tree_log_mutex"
          ],
          "line": 1972
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "commit_cowonly_roots",
          "args": [
            "trans",
            "root"
          ],
          "line": 1970
        },
        "resolved": true,
        "details": {
          "function_name": "commit_cowonly_roots",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
          "lines": "1055-1130",
          "snippet": "static noinline int commit_cowonly_roots(struct btrfs_trans_handle *trans,\n\t\t\t\t\t struct btrfs_root *root)\n{\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tstruct list_head *dirty_bgs = &trans->transaction->dirty_bgs;\n\tstruct list_head *next;\n\tstruct extent_buffer *eb;\n\tint ret;\n\n\teb = btrfs_lock_root_node(fs_info->tree_root);\n\tret = btrfs_cow_block(trans, fs_info->tree_root, eb, NULL,\n\t\t\t      0, &eb);\n\tbtrfs_tree_unlock(eb);\n\tfree_extent_buffer(eb);\n\n\tif (ret)\n\t\treturn ret;\n\n\tret = btrfs_run_delayed_refs(trans, root, (unsigned long)-1);\n\tif (ret)\n\t\treturn ret;\n\n\tret = btrfs_run_dev_stats(trans, root->fs_info);\n\tif (ret)\n\t\treturn ret;\n\tret = btrfs_run_dev_replace(trans, root->fs_info);\n\tif (ret)\n\t\treturn ret;\n\tret = btrfs_run_qgroups(trans, root->fs_info);\n\tif (ret)\n\t\treturn ret;\n\n\tret = btrfs_setup_space_cache(trans, root);\n\tif (ret)\n\t\treturn ret;\n\n\t/* run_qgroups might have added some more refs */\n\tret = btrfs_run_delayed_refs(trans, root, (unsigned long)-1);\n\tif (ret)\n\t\treturn ret;\nagain:\n\twhile (!list_empty(&fs_info->dirty_cowonly_roots)) {\n\t\tnext = fs_info->dirty_cowonly_roots.next;\n\t\tlist_del_init(next);\n\t\troot = list_entry(next, struct btrfs_root, dirty_list);\n\t\tclear_bit(BTRFS_ROOT_DIRTY, &root->state);\n\n\t\tif (root != fs_info->extent_root)\n\t\t\tlist_add_tail(&root->dirty_list,\n\t\t\t\t      &trans->transaction->switch_commits);\n\t\tret = update_cowonly_root(trans, root);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tret = btrfs_run_delayed_refs(trans, root, (unsigned long)-1);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\twhile (!list_empty(dirty_bgs)) {\n\t\tret = btrfs_write_dirty_block_groups(trans, root);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tret = btrfs_run_delayed_refs(trans, root, (unsigned long)-1);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (!list_empty(&fs_info->dirty_cowonly_roots))\n\t\tgoto again;\n\n\tlist_add_tail(&fs_info->extent_root->dirty_list,\n\t\t      &trans->transaction->switch_commits);\n\tbtrfs_after_dev_replace_commit(fs_info);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"dev-replace.h\"",
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic noinline int commit_cowonly_roots(struct btrfs_trans_handle *trans,\n\t\t\t\t\t struct btrfs_root *root)\n{\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tstruct list_head *dirty_bgs = &trans->transaction->dirty_bgs;\n\tstruct list_head *next;\n\tstruct extent_buffer *eb;\n\tint ret;\n\n\teb = btrfs_lock_root_node(fs_info->tree_root);\n\tret = btrfs_cow_block(trans, fs_info->tree_root, eb, NULL,\n\t\t\t      0, &eb);\n\tbtrfs_tree_unlock(eb);\n\tfree_extent_buffer(eb);\n\n\tif (ret)\n\t\treturn ret;\n\n\tret = btrfs_run_delayed_refs(trans, root, (unsigned long)-1);\n\tif (ret)\n\t\treturn ret;\n\n\tret = btrfs_run_dev_stats(trans, root->fs_info);\n\tif (ret)\n\t\treturn ret;\n\tret = btrfs_run_dev_replace(trans, root->fs_info);\n\tif (ret)\n\t\treturn ret;\n\tret = btrfs_run_qgroups(trans, root->fs_info);\n\tif (ret)\n\t\treturn ret;\n\n\tret = btrfs_setup_space_cache(trans, root);\n\tif (ret)\n\t\treturn ret;\n\n\t/* run_qgroups might have added some more refs */\n\tret = btrfs_run_delayed_refs(trans, root, (unsigned long)-1);\n\tif (ret)\n\t\treturn ret;\nagain:\n\twhile (!list_empty(&fs_info->dirty_cowonly_roots)) {\n\t\tnext = fs_info->dirty_cowonly_roots.next;\n\t\tlist_del_init(next);\n\t\troot = list_entry(next, struct btrfs_root, dirty_list);\n\t\tclear_bit(BTRFS_ROOT_DIRTY, &root->state);\n\n\t\tif (root != fs_info->extent_root)\n\t\t\tlist_add_tail(&root->dirty_list,\n\t\t\t\t      &trans->transaction->switch_commits);\n\t\tret = update_cowonly_root(trans, root);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tret = btrfs_run_delayed_refs(trans, root, (unsigned long)-1);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\twhile (!list_empty(dirty_bgs)) {\n\t\tret = btrfs_write_dirty_block_groups(trans, root);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tret = btrfs_run_delayed_refs(trans, root, (unsigned long)-1);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (!list_empty(&fs_info->dirty_cowonly_roots))\n\t\tgoto again;\n\n\tlist_add_tail(&fs_info->extent_root->dirty_list,\n\t\t      &trans->transaction->switch_commits);\n\tbtrfs_after_dev_replace_commit(fs_info);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_free_log_root_tree",
          "args": [
            "trans",
            "root->fs_info"
          ],
          "line": 1968
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_free_log_root_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tree-log.c",
          "lines": "2811-2819",
          "snippet": "int btrfs_free_log_root_tree(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_fs_info *fs_info)\n{\n\tif (fs_info->log_root_tree) {\n\t\tfree_log_tree(trans, fs_info->log_root_tree);\n\t\tfs_info->log_root_tree = NULL;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"print-tree.h\"",
            "#include \"locking.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include <linux/list_sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hash.h\"\n#include \"backref.h\"\n#include \"print-tree.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include <linux/list_sort.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nint btrfs_free_log_root_tree(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_fs_info *fs_info)\n{\n\tif (fs_info->log_root_tree) {\n\t\tfree_log_tree(trans, fs_info->log_root_tree);\n\t\tfs_info->log_root_tree = NULL;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_apply_pending_changes",
          "args": [
            "root->fs_info"
          ],
          "line": 1963
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_apply_pending_changes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
          "lines": "2139-2166",
          "snippet": "void btrfs_apply_pending_changes(struct btrfs_fs_info *fs_info)\n{\n\tunsigned long prev;\n\tunsigned long bit;\n\n\tprev = xchg(&fs_info->pending_changes, 0);\n\tif (!prev)\n\t\treturn;\n\n\tbit = 1 << BTRFS_PENDING_SET_INODE_MAP_CACHE;\n\tif (prev & bit)\n\t\tbtrfs_set_opt(fs_info->mount_opt, INODE_MAP_CACHE);\n\tprev &= ~bit;\n\n\tbit = 1 << BTRFS_PENDING_CLEAR_INODE_MAP_CACHE;\n\tif (prev & bit)\n\t\tbtrfs_clear_opt(fs_info->mount_opt, INODE_MAP_CACHE);\n\tprev &= ~bit;\n\n\tbit = 1 << BTRFS_PENDING_COMMIT;\n\tif (prev & bit)\n\t\tbtrfs_debug(fs_info, \"pending commit done\");\n\tprev &= ~bit;\n\n\tif (prev)\n\t\tbtrfs_warn(fs_info,\n\t\t\t\"unknown pending changes left 0x%lx, ignoring\", prev);\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"dev-replace.h\"",
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid btrfs_apply_pending_changes(struct btrfs_fs_info *fs_info)\n{\n\tunsigned long prev;\n\tunsigned long bit;\n\n\tprev = xchg(&fs_info->pending_changes, 0);\n\tif (!prev)\n\t\treturn;\n\n\tbit = 1 << BTRFS_PENDING_SET_INODE_MAP_CACHE;\n\tif (prev & bit)\n\t\tbtrfs_set_opt(fs_info->mount_opt, INODE_MAP_CACHE);\n\tprev &= ~bit;\n\n\tbit = 1 << BTRFS_PENDING_CLEAR_INODE_MAP_CACHE;\n\tif (prev & bit)\n\t\tbtrfs_clear_opt(fs_info->mount_opt, INODE_MAP_CACHE);\n\tprev &= ~bit;\n\n\tbit = 1 << BTRFS_PENDING_COMMIT;\n\tif (prev & bit)\n\t\tbtrfs_debug(fs_info, \"pending commit done\");\n\tprev &= ~bit;\n\n\tif (prev)\n\t\tbtrfs_warn(fs_info,\n\t\t\t\"unknown pending changes left 0x%lx, ignoring\", prev);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&root->fs_info->reloc_mutex"
          ],
          "line": 1955
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&root->fs_info->tree_log_mutex"
          ],
          "line": 1954
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "commit_fs_roots",
          "args": [
            "trans",
            "root"
          ],
          "line": 1952
        },
        "resolved": true,
        "details": {
          "function_name": "commit_fs_roots",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
          "lines": "1148-1199",
          "snippet": "static noinline int commit_fs_roots(struct btrfs_trans_handle *trans,\n\t\t\t\t    struct btrfs_root *root)\n{\n\tstruct btrfs_root *gang[8];\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tint i;\n\tint ret;\n\tint err = 0;\n\n\tspin_lock(&fs_info->fs_roots_radix_lock);\n\twhile (1) {\n\t\tret = radix_tree_gang_lookup_tag(&fs_info->fs_roots_radix,\n\t\t\t\t\t\t (void **)gang, 0,\n\t\t\t\t\t\t ARRAY_SIZE(gang),\n\t\t\t\t\t\t BTRFS_ROOT_TRANS_TAG);\n\t\tif (ret == 0)\n\t\t\tbreak;\n\t\tfor (i = 0; i < ret; i++) {\n\t\t\troot = gang[i];\n\t\t\tradix_tree_tag_clear(&fs_info->fs_roots_radix,\n\t\t\t\t\t(unsigned long)root->root_key.objectid,\n\t\t\t\t\tBTRFS_ROOT_TRANS_TAG);\n\t\t\tspin_unlock(&fs_info->fs_roots_radix_lock);\n\n\t\t\tbtrfs_free_log(trans, root);\n\t\t\tbtrfs_update_reloc_root(trans, root);\n\t\t\tbtrfs_orphan_commit_root(trans, root);\n\n\t\t\tbtrfs_save_ino_cache(root, trans);\n\n\t\t\t/* see comments in should_cow_block() */\n\t\t\tclear_bit(BTRFS_ROOT_FORCE_COW, &root->state);\n\t\t\tsmp_mb__after_atomic();\n\n\t\t\tif (root->commit_root != root->node) {\n\t\t\t\tlist_add_tail(&root->dirty_list,\n\t\t\t\t\t&trans->transaction->switch_commits);\n\t\t\t\tbtrfs_set_root_node(&root->root_item,\n\t\t\t\t\t\t    root->node);\n\t\t\t}\n\n\t\t\terr = btrfs_update_root(trans, fs_info->tree_root,\n\t\t\t\t\t\t&root->root_key,\n\t\t\t\t\t\t&root->root_item);\n\t\t\tspin_lock(&fs_info->fs_roots_radix_lock);\n\t\t\tif (err)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&fs_info->fs_roots_radix_lock);\n\treturn err;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"dev-replace.h\"",
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define BTRFS_ROOT_TRANS_TAG 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\n#define BTRFS_ROOT_TRANS_TAG 0\n\nstatic noinline int commit_fs_roots(struct btrfs_trans_handle *trans,\n\t\t\t\t    struct btrfs_root *root)\n{\n\tstruct btrfs_root *gang[8];\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tint i;\n\tint ret;\n\tint err = 0;\n\n\tspin_lock(&fs_info->fs_roots_radix_lock);\n\twhile (1) {\n\t\tret = radix_tree_gang_lookup_tag(&fs_info->fs_roots_radix,\n\t\t\t\t\t\t (void **)gang, 0,\n\t\t\t\t\t\t ARRAY_SIZE(gang),\n\t\t\t\t\t\t BTRFS_ROOT_TRANS_TAG);\n\t\tif (ret == 0)\n\t\t\tbreak;\n\t\tfor (i = 0; i < ret; i++) {\n\t\t\troot = gang[i];\n\t\t\tradix_tree_tag_clear(&fs_info->fs_roots_radix,\n\t\t\t\t\t(unsigned long)root->root_key.objectid,\n\t\t\t\t\tBTRFS_ROOT_TRANS_TAG);\n\t\t\tspin_unlock(&fs_info->fs_roots_radix_lock);\n\n\t\t\tbtrfs_free_log(trans, root);\n\t\t\tbtrfs_update_reloc_root(trans, root);\n\t\t\tbtrfs_orphan_commit_root(trans, root);\n\n\t\t\tbtrfs_save_ino_cache(root, trans);\n\n\t\t\t/* see comments in should_cow_block() */\n\t\t\tclear_bit(BTRFS_ROOT_FORCE_COW, &root->state);\n\t\t\tsmp_mb__after_atomic();\n\n\t\t\tif (root->commit_root != root->node) {\n\t\t\t\tlist_add_tail(&root->dirty_list,\n\t\t\t\t\t&trans->transaction->switch_commits);\n\t\t\t\tbtrfs_set_root_node(&root->root_item,\n\t\t\t\t\t\t    root->node);\n\t\t\t}\n\n\t\t\terr = btrfs_update_root(trans, fs_info->tree_root,\n\t\t\t\t\t\t&root->root_key,\n\t\t\t\t\t\t&root->root_item);\n\t\t\tspin_lock(&fs_info->fs_roots_radix_lock);\n\t\t\tif (err)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&fs_info->fs_roots_radix_lock);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&root->fs_info->tree_log_mutex"
          ],
          "line": 1950
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "cur_trans != trans->transaction"
          ],
          "line": 1935
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_assert_delayed_root_empty",
          "args": [
            "root"
          ],
          "line": 1933
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_assert_delayed_root_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-inode.c",
          "lines": "1406-1411",
          "snippet": "void btrfs_assert_delayed_root_empty(struct btrfs_root *root)\n{\n\tstruct btrfs_delayed_root *delayed_root;\n\tdelayed_root = btrfs_get_delayed_root(root);\n\tWARN_ON(btrfs_first_delayed_node(delayed_root));\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"delayed-inode.h\"\n#include <linux/slab.h>\n\nvoid btrfs_assert_delayed_root_empty(struct btrfs_root *root)\n{\n\tstruct btrfs_delayed_root *delayed_root;\n\tdelayed_root = btrfs_get_delayed_root(root);\n\tWARN_ON(btrfs_first_delayed_node(delayed_root));\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&root->fs_info->reloc_mutex"
          ],
          "line": 1925
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_run_delayed_refs",
          "args": [
            "trans",
            "root",
            "(unsigned long)-1"
          ],
          "line": 1923
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_run_delayed_refs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent-tree.c",
          "lines": "2764-2841",
          "snippet": "int btrfs_run_delayed_refs(struct btrfs_trans_handle *trans,\n\t\t\t   struct btrfs_root *root, unsigned long count)\n{\n\tstruct rb_node *node;\n\tstruct btrfs_delayed_ref_root *delayed_refs;\n\tstruct btrfs_delayed_ref_head *head;\n\tint ret;\n\tint run_all = count == (unsigned long)-1;\n\n\t/* We'll clean this up in btrfs_cleanup_transaction */\n\tif (trans->aborted)\n\t\treturn 0;\n\n\tif (root == root->fs_info->extent_root)\n\t\troot = root->fs_info->tree_root;\n\n\tdelayed_refs = &trans->transaction->delayed_refs;\n\tif (count == 0)\n\t\tcount = atomic_read(&delayed_refs->num_entries) * 2;\n\nagain:\n#ifdef SCRAMBLE_DELAYED_REFS\n\tdelayed_refs->run_delayed_start = find_middle(&delayed_refs->root);\n#endif\n\tret = __btrfs_run_delayed_refs(trans, root, count);\n\tif (ret < 0) {\n\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\treturn ret;\n\t}\n\n\tif (run_all) {\n\t\tif (!list_empty(&trans->new_bgs))\n\t\t\tbtrfs_create_pending_block_groups(trans, root);\n\n\t\tspin_lock(&delayed_refs->lock);\n\t\tnode = rb_first(&delayed_refs->href_root);\n\t\tif (!node) {\n\t\t\tspin_unlock(&delayed_refs->lock);\n\t\t\tgoto out;\n\t\t}\n\t\tcount = (unsigned long)-1;\n\n\t\twhile (node) {\n\t\t\thead = rb_entry(node, struct btrfs_delayed_ref_head,\n\t\t\t\t\thref_node);\n\t\t\tif (btrfs_delayed_ref_is_head(&head->node)) {\n\t\t\t\tstruct btrfs_delayed_ref_node *ref;\n\n\t\t\t\tref = &head->node;\n\t\t\t\tatomic_inc(&ref->refs);\n\n\t\t\t\tspin_unlock(&delayed_refs->lock);\n\t\t\t\t/*\n\t\t\t\t * Mutex was contended, block until it's\n\t\t\t\t * released and try again\n\t\t\t\t */\n\t\t\t\tmutex_lock(&head->mutex);\n\t\t\t\tmutex_unlock(&head->mutex);\n\n\t\t\t\tbtrfs_put_delayed_ref(ref);\n\t\t\t\tcond_resched();\n\t\t\t\tgoto again;\n\t\t\t} else {\n\t\t\t\tWARN_ON(1);\n\t\t\t}\n\t\t\tnode = rb_next(node);\n\t\t}\n\t\tspin_unlock(&delayed_refs->lock);\n\t\tcond_resched();\n\t\tgoto again;\n\t}\nout:\n\tret = btrfs_delayed_qgroup_accounting(trans, root->fs_info);\n\tif (ret)\n\t\treturn ret;\n\tassert_qgroups_uptodate(trans);\n\treturn 0;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"math.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include \"hash.h\"",
            "#include <linux/percpu_counter.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"math.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include \"hash.h\"\n#include <linux/percpu_counter.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n#include <linux/rcupdate.h>\n#include <linux/sort.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nint btrfs_run_delayed_refs(struct btrfs_trans_handle *trans,\n\t\t\t   struct btrfs_root *root, unsigned long count)\n{\n\tstruct rb_node *node;\n\tstruct btrfs_delayed_ref_root *delayed_refs;\n\tstruct btrfs_delayed_ref_head *head;\n\tint ret;\n\tint run_all = count == (unsigned long)-1;\n\n\t/* We'll clean this up in btrfs_cleanup_transaction */\n\tif (trans->aborted)\n\t\treturn 0;\n\n\tif (root == root->fs_info->extent_root)\n\t\troot = root->fs_info->tree_root;\n\n\tdelayed_refs = &trans->transaction->delayed_refs;\n\tif (count == 0)\n\t\tcount = atomic_read(&delayed_refs->num_entries) * 2;\n\nagain:\n#ifdef SCRAMBLE_DELAYED_REFS\n\tdelayed_refs->run_delayed_start = find_middle(&delayed_refs->root);\n#endif\n\tret = __btrfs_run_delayed_refs(trans, root, count);\n\tif (ret < 0) {\n\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\treturn ret;\n\t}\n\n\tif (run_all) {\n\t\tif (!list_empty(&trans->new_bgs))\n\t\t\tbtrfs_create_pending_block_groups(trans, root);\n\n\t\tspin_lock(&delayed_refs->lock);\n\t\tnode = rb_first(&delayed_refs->href_root);\n\t\tif (!node) {\n\t\t\tspin_unlock(&delayed_refs->lock);\n\t\t\tgoto out;\n\t\t}\n\t\tcount = (unsigned long)-1;\n\n\t\twhile (node) {\n\t\t\thead = rb_entry(node, struct btrfs_delayed_ref_head,\n\t\t\t\t\thref_node);\n\t\t\tif (btrfs_delayed_ref_is_head(&head->node)) {\n\t\t\t\tstruct btrfs_delayed_ref_node *ref;\n\n\t\t\t\tref = &head->node;\n\t\t\t\tatomic_inc(&ref->refs);\n\n\t\t\t\tspin_unlock(&delayed_refs->lock);\n\t\t\t\t/*\n\t\t\t\t * Mutex was contended, block until it's\n\t\t\t\t * released and try again\n\t\t\t\t */\n\t\t\t\tmutex_lock(&head->mutex);\n\t\t\t\tmutex_unlock(&head->mutex);\n\n\t\t\t\tbtrfs_put_delayed_ref(ref);\n\t\t\t\tcond_resched();\n\t\t\t\tgoto again;\n\t\t\t} else {\n\t\t\t\tWARN_ON(1);\n\t\t\t}\n\t\t\tnode = rb_next(node);\n\t\t}\n\t\tspin_unlock(&delayed_refs->lock);\n\t\tcond_resched();\n\t\tgoto again;\n\t}\nout:\n\tret = btrfs_delayed_qgroup_accounting(trans, root->fs_info);\n\tif (ret)\n\t\treturn ret;\n\tassert_qgroups_uptodate(trans);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&root->fs_info->reloc_mutex"
          ],
          "line": 1919
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_run_delayed_items",
          "args": [
            "trans",
            "root"
          ],
          "line": 1917
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_run_delayed_items",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-inode.c",
          "lines": "1205-1209",
          "snippet": "int btrfs_run_delayed_items(struct btrfs_trans_handle *trans,\n\t\t\t    struct btrfs_root *root)\n{\n\treturn __btrfs_run_delayed_items(trans, root, -1);\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"delayed-inode.h\"\n#include <linux/slab.h>\n\nint btrfs_run_delayed_items(struct btrfs_trans_handle *trans,\n\t\t\t    struct btrfs_root *root)\n{\n\treturn __btrfs_run_delayed_items(trans, root, -1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&root->fs_info->reloc_mutex"
          ],
          "line": 1903
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "create_pending_snapshots",
          "args": [
            "trans",
            "root->fs_info"
          ],
          "line": 1901
        },
        "resolved": true,
        "details": {
          "function_name": "create_pending_snapshots",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
          "lines": "1509-1523",
          "snippet": "static noinline int create_pending_snapshots(struct btrfs_trans_handle *trans,\n\t\t\t\t\t     struct btrfs_fs_info *fs_info)\n{\n\tstruct btrfs_pending_snapshot *pending, *next;\n\tstruct list_head *head = &trans->transaction->pending_snapshots;\n\tint ret = 0;\n\n\tlist_for_each_entry_safe(pending, next, head, list) {\n\t\tlist_del(&pending->list);\n\t\tret = create_pending_snapshot(trans, fs_info, pending);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"dev-replace.h\"",
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic noinline int create_pending_snapshots(struct btrfs_trans_handle *trans,\n\t\t\t\t\t     struct btrfs_fs_info *fs_info)\n{\n\tstruct btrfs_pending_snapshot *pending, *next;\n\tstruct list_head *head = &trans->transaction->pending_snapshots;\n\tint ret = 0;\n\n\tlist_for_each_entry_safe(pending, next, head, list) {\n\t\tlist_del(&pending->list);\n\t\tret = create_pending_snapshot(trans, fs_info, pending);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&root->fs_info->reloc_mutex"
          ],
          "line": 1894
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ACCESS_ONCE(cur_trans->aborted)"
          ],
          "line": 1885
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ACCESS_ONCE",
          "args": [
            "cur_trans->aborted"
          ],
          "line": 1885
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_event",
          "args": [
            "cur_trans->writer_wait",
            "atomic_read(&cur_trans->num_writers) == 1"
          ],
          "line": 1881
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&cur_trans->num_writers"
          ],
          "line": 1882
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_scrub_pause",
          "args": [
            "root"
          ],
          "line": 1872
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_scrub_pause",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/scrub.c",
          "lines": "3756-3771",
          "snippet": "void btrfs_scrub_pause(struct btrfs_root *root)\n{\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\n\tmutex_lock(&fs_info->scrub_lock);\n\tatomic_inc(&fs_info->scrub_pause_req);\n\twhile (atomic_read(&fs_info->scrubs_paused) !=\n\t       atomic_read(&fs_info->scrubs_running)) {\n\t\tmutex_unlock(&fs_info->scrub_lock);\n\t\twait_event(fs_info->scrub_pause_wait,\n\t\t\t   atomic_read(&fs_info->scrubs_paused) ==\n\t\t\t   atomic_read(&fs_info->scrubs_running));\n\t\tmutex_lock(&fs_info->scrub_lock);\n\t}\n\tmutex_unlock(&fs_info->scrub_lock);\n}",
          "includes": [
            "#include \"raid56.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"dev-replace.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"transaction.h\"",
            "#include \"ordered-data.h\"",
            "#include \"disk-io.h\"",
            "#include \"volumes.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);",
            "static void scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);",
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"raid56.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"dev-replace.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"transaction.h\"\n#include \"ordered-data.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/blkdev.h>\n\nstatic void __scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);\nstatic void scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);\nstatic noinline_for_stack\nstruct;\n\nvoid btrfs_scrub_pause(struct btrfs_root *root)\n{\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\n\tmutex_lock(&fs_info->scrub_lock);\n\tatomic_inc(&fs_info->scrub_pause_req);\n\twhile (atomic_read(&fs_info->scrubs_paused) !=\n\t       atomic_read(&fs_info->scrubs_running)) {\n\t\tmutex_unlock(&fs_info->scrub_lock);\n\t\twait_event(fs_info->scrub_pause_wait,\n\t\t\t   atomic_read(&fs_info->scrubs_paused) ==\n\t\t\t   atomic_read(&fs_info->scrubs_running));\n\t\tmutex_lock(&fs_info->scrub_lock);\n\t}\n\tmutex_unlock(&fs_info->scrub_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_wait_pending_ordered",
          "args": [
            "cur_trans",
            "root->fs_info"
          ],
          "line": 1870
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_wait_pending_ordered",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
          "lines": "1742-1762",
          "snippet": "static inline void\nbtrfs_wait_pending_ordered(struct btrfs_transaction *cur_trans,\n\t\t\t   struct btrfs_fs_info *fs_info)\n{\n\tstruct btrfs_ordered_extent *ordered;\n\n\tspin_lock(&fs_info->trans_lock);\n\twhile (!list_empty(&cur_trans->pending_ordered)) {\n\t\tordered = list_first_entry(&cur_trans->pending_ordered,\n\t\t\t\t\t   struct btrfs_ordered_extent,\n\t\t\t\t\t   trans_list);\n\t\tlist_del_init(&ordered->trans_list);\n\t\tspin_unlock(&fs_info->trans_lock);\n\n\t\twait_event(ordered->wait, test_bit(BTRFS_ORDERED_COMPLETE,\n\t\t\t\t\t\t   &ordered->flags));\n\t\tbtrfs_put_ordered_extent(ordered);\n\t\tspin_lock(&fs_info->trans_lock);\n\t}\n\tspin_unlock(&fs_info->trans_lock);\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"dev-replace.h\"",
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic inline void\nbtrfs_wait_pending_ordered(struct btrfs_transaction *cur_trans,\n\t\t\t   struct btrfs_fs_info *fs_info)\n{\n\tstruct btrfs_ordered_extent *ordered;\n\n\tspin_lock(&fs_info->trans_lock);\n\twhile (!list_empty(&cur_trans->pending_ordered)) {\n\t\tordered = list_first_entry(&cur_trans->pending_ordered,\n\t\t\t\t\t   struct btrfs_ordered_extent,\n\t\t\t\t\t   trans_list);\n\t\tlist_del_init(&ordered->trans_list);\n\t\tspin_unlock(&fs_info->trans_lock);\n\n\t\twait_event(ordered->wait, test_bit(BTRFS_ORDERED_COMPLETE,\n\t\t\t\t\t\t   &ordered->flags));\n\t\tbtrfs_put_ordered_extent(ordered);\n\t\tspin_lock(&fs_info->trans_lock);\n\t}\n\tspin_unlock(&fs_info->trans_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_wait_delalloc_flush",
          "args": [
            "root->fs_info"
          ],
          "line": 1868
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_wait_delalloc_flush",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
          "lines": "1736-1740",
          "snippet": "static inline void btrfs_wait_delalloc_flush(struct btrfs_fs_info *fs_info)\n{\n\tif (btrfs_test_opt(fs_info->tree_root, FLUSHONCOMMIT))\n\t\tbtrfs_wait_ordered_roots(fs_info, -1);\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"dev-replace.h\"",
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic inline void btrfs_wait_delalloc_flush(struct btrfs_fs_info *fs_info)\n{\n\tif (btrfs_test_opt(fs_info->tree_root, FLUSHONCOMMIT))\n\t\tbtrfs_wait_ordered_roots(fs_info, -1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_event",
          "args": [
            "cur_trans->writer_wait",
            "extwriter_counter_read(cur_trans) == 0"
          ],
          "line": 1860
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "extwriter_counter_read",
          "args": [
            "cur_trans"
          ],
          "line": 1861
        },
        "resolved": true,
        "details": {
          "function_name": "extwriter_counter_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
          "lines": "143-146",
          "snippet": "static inline int extwriter_counter_read(struct btrfs_transaction *trans)\n{\n\treturn atomic_read(&trans->num_extwriters);\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"dev-replace.h\"",
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic inline int extwriter_counter_read(struct btrfs_transaction *trans)\n{\n\treturn atomic_read(&trans->num_extwriters);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_start_delalloc_flush",
          "args": [
            "root->fs_info"
          ],
          "line": 1852
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_start_delalloc_flush",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
          "lines": "1729-1734",
          "snippet": "static inline int btrfs_start_delalloc_flush(struct btrfs_fs_info *fs_info)\n{\n\tif (btrfs_test_opt(fs_info->tree_root, FLUSHONCOMMIT))\n\t\treturn btrfs_start_delalloc_roots(fs_info, 1, -1);\n\treturn 0;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"dev-replace.h\"",
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic inline int btrfs_start_delalloc_flush(struct btrfs_fs_info *fs_info)\n{\n\tif (btrfs_test_opt(fs_info->tree_root, FLUSHONCOMMIT))\n\t\treturn btrfs_start_delalloc_roots(fs_info, 1, -1);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "extwriter_counter_dec",
          "args": [
            "cur_trans",
            "trans->type"
          ],
          "line": 1850
        },
        "resolved": true,
        "details": {
          "function_name": "extwriter_counter_dec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
          "lines": "130-135",
          "snippet": "static inline void extwriter_counter_dec(struct btrfs_transaction *trans,\n\t\t\t\t\t unsigned int type)\n{\n\tif (type & TRANS_EXTWRITERS)\n\t\tatomic_dec(&trans->num_extwriters);\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"dev-replace.h\"",
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic inline void extwriter_counter_dec(struct btrfs_transaction *trans,\n\t\t\t\t\t unsigned int type)\n{\n\tif (type & TRANS_EXTWRITERS)\n\t\tatomic_dec(&trans->num_extwriters);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_for_commit",
          "args": [
            "root",
            "prev_trans"
          ],
          "line": 1840
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_wait_for_commit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
          "lines": "635-691",
          "snippet": "int btrfs_wait_for_commit(struct btrfs_root *root, u64 transid)\n{\n\tstruct btrfs_transaction *cur_trans = NULL, *t;\n\tint ret = 0;\n\n\tif (transid) {\n\t\tif (transid <= root->fs_info->last_trans_committed)\n\t\t\tgoto out;\n\n\t\t/* find specified transaction */\n\t\tspin_lock(&root->fs_info->trans_lock);\n\t\tlist_for_each_entry(t, &root->fs_info->trans_list, list) {\n\t\t\tif (t->transid == transid) {\n\t\t\t\tcur_trans = t;\n\t\t\t\tatomic_inc(&cur_trans->use_count);\n\t\t\t\tret = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (t->transid > transid) {\n\t\t\t\tret = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tspin_unlock(&root->fs_info->trans_lock);\n\n\t\t/*\n\t\t * The specified transaction doesn't exist, or we\n\t\t * raced with btrfs_commit_transaction\n\t\t */\n\t\tif (!cur_trans) {\n\t\t\tif (transid > root->fs_info->last_trans_committed)\n\t\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\t/* find newest transaction that is committing | committed */\n\t\tspin_lock(&root->fs_info->trans_lock);\n\t\tlist_for_each_entry_reverse(t, &root->fs_info->trans_list,\n\t\t\t\t\t    list) {\n\t\t\tif (t->state >= TRANS_STATE_COMMIT_START) {\n\t\t\t\tif (t->state == TRANS_STATE_COMPLETED)\n\t\t\t\t\tbreak;\n\t\t\t\tcur_trans = t;\n\t\t\t\tatomic_inc(&cur_trans->use_count);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tspin_unlock(&root->fs_info->trans_lock);\n\t\tif (!cur_trans)\n\t\t\tgoto out;  /* nothing committing|committed */\n\t}\n\n\twait_for_commit(root, cur_trans);\n\tbtrfs_put_transaction(cur_trans);\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"dev-replace.h\"",
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint btrfs_wait_for_commit(struct btrfs_root *root, u64 transid)\n{\n\tstruct btrfs_transaction *cur_trans = NULL, *t;\n\tint ret = 0;\n\n\tif (transid) {\n\t\tif (transid <= root->fs_info->last_trans_committed)\n\t\t\tgoto out;\n\n\t\t/* find specified transaction */\n\t\tspin_lock(&root->fs_info->trans_lock);\n\t\tlist_for_each_entry(t, &root->fs_info->trans_list, list) {\n\t\t\tif (t->transid == transid) {\n\t\t\t\tcur_trans = t;\n\t\t\t\tatomic_inc(&cur_trans->use_count);\n\t\t\t\tret = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (t->transid > transid) {\n\t\t\t\tret = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tspin_unlock(&root->fs_info->trans_lock);\n\n\t\t/*\n\t\t * The specified transaction doesn't exist, or we\n\t\t * raced with btrfs_commit_transaction\n\t\t */\n\t\tif (!cur_trans) {\n\t\t\tif (transid > root->fs_info->last_trans_committed)\n\t\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\t/* find newest transaction that is committing | committed */\n\t\tspin_lock(&root->fs_info->trans_lock);\n\t\tlist_for_each_entry_reverse(t, &root->fs_info->trans_list,\n\t\t\t\t\t    list) {\n\t\t\tif (t->state >= TRANS_STATE_COMMIT_START) {\n\t\t\t\tif (t->state == TRANS_STATE_COMPLETED)\n\t\t\t\t\tbreak;\n\t\t\t\tcur_trans = t;\n\t\t\t\tatomic_inc(&cur_trans->use_count);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tspin_unlock(&root->fs_info->trans_lock);\n\t\tif (!cur_trans)\n\t\t\tgoto out;  /* nothing committing|committed */\n\t}\n\n\twait_for_commit(root, cur_trans);\n\tbtrfs_put_transaction(cur_trans);\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&prev_trans->use_count"
          ],
          "line": 1837
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "cur_trans->list.prev",
            "structbtrfs_transaction",
            "list"
          ],
          "line": 1834
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "cur_trans->aborted"
          ],
          "line": 1822
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_end_transaction",
          "args": [
            "trans",
            "root"
          ],
          "line": 1818
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_end_transaction_throttle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
          "lines": "846-850",
          "snippet": "int btrfs_end_transaction_throttle(struct btrfs_trans_handle *trans,\n\t\t\t\t   struct btrfs_root *root)\n{\n\treturn __btrfs_end_transaction(trans, root, 1);\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"dev-replace.h\"",
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint btrfs_end_transaction_throttle(struct btrfs_trans_handle *trans,\n\t\t\t\t   struct btrfs_root *root)\n{\n\treturn __btrfs_end_transaction(trans, root, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&cur_trans->use_count"
          ],
          "line": 1817
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_splice",
          "args": [
            "&trans->ordered",
            "&cur_trans->pending_ordered"
          ],
          "line": 1814
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_create_pending_block_groups",
          "args": [
            "trans",
            "root"
          ],
          "line": 1805
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_create_pending_block_groups",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent-tree.c",
          "lines": "9179-9208",
          "snippet": "void btrfs_create_pending_block_groups(struct btrfs_trans_handle *trans,\n\t\t\t\t       struct btrfs_root *root)\n{\n\tstruct btrfs_block_group_cache *block_group, *tmp;\n\tstruct btrfs_root *extent_root = root->fs_info->extent_root;\n\tstruct btrfs_block_group_item item;\n\tstruct btrfs_key key;\n\tint ret = 0;\n\n\tlist_for_each_entry_safe(block_group, tmp, &trans->new_bgs, bg_list) {\n\t\tif (ret)\n\t\t\tgoto next;\n\n\t\tspin_lock(&block_group->lock);\n\t\tmemcpy(&item, &block_group->item, sizeof(item));\n\t\tmemcpy(&key, &block_group->key, sizeof(key));\n\t\tspin_unlock(&block_group->lock);\n\n\t\tret = btrfs_insert_item(trans, extent_root, &key, &item,\n\t\t\t\t\tsizeof(item));\n\t\tif (ret)\n\t\t\tbtrfs_abort_transaction(trans, extent_root, ret);\n\t\tret = btrfs_finish_chunk_alloc(trans, extent_root,\n\t\t\t\t\t       key.objectid, key.offset);\n\t\tif (ret)\n\t\t\tbtrfs_abort_transaction(trans, extent_root, ret);\nnext:\n\t\tlist_del_init(&block_group->bg_list);\n\t}\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"math.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include \"hash.h\"",
            "#include <linux/percpu_counter.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int find_next_key(struct btrfs_path *path, int level,\n\t\t\t struct btrfs_key *key);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"math.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include \"hash.h\"\n#include <linux/percpu_counter.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n#include <linux/rcupdate.h>\n#include <linux/sort.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic int find_next_key(struct btrfs_path *path, int level,\n\t\t\t struct btrfs_key *key);\nstatic noinline struct;\n\nvoid btrfs_create_pending_block_groups(struct btrfs_trans_handle *trans,\n\t\t\t\t       struct btrfs_root *root)\n{\n\tstruct btrfs_block_group_cache *block_group, *tmp;\n\tstruct btrfs_root *extent_root = root->fs_info->extent_root;\n\tstruct btrfs_block_group_item item;\n\tstruct btrfs_key key;\n\tint ret = 0;\n\n\tlist_for_each_entry_safe(block_group, tmp, &trans->new_bgs, bg_list) {\n\t\tif (ret)\n\t\t\tgoto next;\n\n\t\tspin_lock(&block_group->lock);\n\t\tmemcpy(&item, &block_group->item, sizeof(item));\n\t\tmemcpy(&key, &block_group->key, sizeof(key));\n\t\tspin_unlock(&block_group->lock);\n\n\t\tret = btrfs_insert_item(trans, extent_root, &key, &item,\n\t\t\t\t\tsizeof(item));\n\t\tif (ret)\n\t\t\tbtrfs_abort_transaction(trans, extent_root, ret);\n\t\tret = btrfs_finish_chunk_alloc(trans, extent_root,\n\t\t\t\t\t       key.objectid, key.offset);\n\t\tif (ret)\n\t\t\tbtrfs_abort_transaction(trans, extent_root, ret);\nnext:\n\t\tlist_del_init(&block_group->bg_list);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_wmb",
          "args": [],
          "line": 1802
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ACCESS_ONCE(cur_trans->aborted)"
          ],
          "line": 1773
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ACCESS_ONCE",
          "args": [
            "cur_trans->aborted"
          ],
          "line": 1773
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BTRFS_I",
          "args": [
            "root->fs_info->btree_inode"
          ],
          "line": 1769
        },
        "resolved": true,
        "details": {
          "function_name": "BTRFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "196-199",
          "snippet": "static inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint btrfs_commit_transaction(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root)\n{\n\tstruct btrfs_transaction *cur_trans = trans->transaction;\n\tstruct btrfs_transaction *prev_trans = NULL;\n\tstruct btrfs_inode *btree_ino = BTRFS_I(root->fs_info->btree_inode);\n\tint ret;\n\n\t/* Stop the commit early if ->aborted is set */\n\tif (unlikely(ACCESS_ONCE(cur_trans->aborted))) {\n\t\tret = cur_trans->aborted;\n\t\tbtrfs_end_transaction(trans, root);\n\t\treturn ret;\n\t}\n\n\t/* make a pass through all the delayed refs we have so far\n\t * any runnings procs may add more while we are here\n\t */\n\tret = btrfs_run_delayed_refs(trans, root, 0);\n\tif (ret) {\n\t\tbtrfs_end_transaction(trans, root);\n\t\treturn ret;\n\t}\n\n\tbtrfs_trans_release_metadata(trans, root);\n\ttrans->block_rsv = NULL;\n\tif (trans->qgroup_reserved) {\n\t\tbtrfs_qgroup_free(root, trans->qgroup_reserved);\n\t\ttrans->qgroup_reserved = 0;\n\t}\n\n\tcur_trans = trans->transaction;\n\n\t/*\n\t * set the flushing flag so procs in this transaction have to\n\t * start sending their work down.\n\t */\n\tcur_trans->delayed_refs.flushing = 1;\n\tsmp_wmb();\n\n\tif (!list_empty(&trans->new_bgs))\n\t\tbtrfs_create_pending_block_groups(trans, root);\n\n\tret = btrfs_run_delayed_refs(trans, root, 0);\n\tif (ret) {\n\t\tbtrfs_end_transaction(trans, root);\n\t\treturn ret;\n\t}\n\n\tspin_lock(&root->fs_info->trans_lock);\n\tlist_splice(&trans->ordered, &cur_trans->pending_ordered);\n\tif (cur_trans->state >= TRANS_STATE_COMMIT_START) {\n\t\tspin_unlock(&root->fs_info->trans_lock);\n\t\tatomic_inc(&cur_trans->use_count);\n\t\tret = btrfs_end_transaction(trans, root);\n\n\t\twait_for_commit(root, cur_trans);\n\n\t\tif (unlikely(cur_trans->aborted))\n\t\t\tret = cur_trans->aborted;\n\n\t\tbtrfs_put_transaction(cur_trans);\n\n\t\treturn ret;\n\t}\n\n\tcur_trans->state = TRANS_STATE_COMMIT_START;\n\twake_up(&root->fs_info->transaction_blocked_wait);\n\n\tif (cur_trans->list.prev != &root->fs_info->trans_list) {\n\t\tprev_trans = list_entry(cur_trans->list.prev,\n\t\t\t\t\tstruct btrfs_transaction, list);\n\t\tif (prev_trans->state != TRANS_STATE_COMPLETED) {\n\t\t\tatomic_inc(&prev_trans->use_count);\n\t\t\tspin_unlock(&root->fs_info->trans_lock);\n\n\t\t\twait_for_commit(root, prev_trans);\n\n\t\t\tbtrfs_put_transaction(prev_trans);\n\t\t} else {\n\t\t\tspin_unlock(&root->fs_info->trans_lock);\n\t\t}\n\t} else {\n\t\tspin_unlock(&root->fs_info->trans_lock);\n\t}\n\n\textwriter_counter_dec(cur_trans, trans->type);\n\n\tret = btrfs_start_delalloc_flush(root->fs_info);\n\tif (ret)\n\t\tgoto cleanup_transaction;\n\n\tret = btrfs_run_delayed_items(trans, root);\n\tif (ret)\n\t\tgoto cleanup_transaction;\n\n\twait_event(cur_trans->writer_wait,\n\t\t   extwriter_counter_read(cur_trans) == 0);\n\n\t/* some pending stuffs might be added after the previous flush. */\n\tret = btrfs_run_delayed_items(trans, root);\n\tif (ret)\n\t\tgoto cleanup_transaction;\n\n\tbtrfs_wait_delalloc_flush(root->fs_info);\n\n\tbtrfs_wait_pending_ordered(cur_trans, root->fs_info);\n\n\tbtrfs_scrub_pause(root);\n\t/*\n\t * Ok now we need to make sure to block out any other joins while we\n\t * commit the transaction.  We could have started a join before setting\n\t * COMMIT_DOING so make sure to wait for num_writers to == 1 again.\n\t */\n\tspin_lock(&root->fs_info->trans_lock);\n\tcur_trans->state = TRANS_STATE_COMMIT_DOING;\n\tspin_unlock(&root->fs_info->trans_lock);\n\twait_event(cur_trans->writer_wait,\n\t\t   atomic_read(&cur_trans->num_writers) == 1);\n\n\t/* ->aborted might be set after the previous check, so check it */\n\tif (unlikely(ACCESS_ONCE(cur_trans->aborted))) {\n\t\tret = cur_trans->aborted;\n\t\tgoto scrub_continue;\n\t}\n\t/*\n\t * the reloc mutex makes sure that we stop\n\t * the balancing code from coming in and moving\n\t * extents around in the middle of the commit\n\t */\n\tmutex_lock(&root->fs_info->reloc_mutex);\n\n\t/*\n\t * We needn't worry about the delayed items because we will\n\t * deal with them in create_pending_snapshot(), which is the\n\t * core function of the snapshot creation.\n\t */\n\tret = create_pending_snapshots(trans, root->fs_info);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * We insert the dir indexes of the snapshots and update the inode\n\t * of the snapshots' parents after the snapshot creation, so there\n\t * are some delayed items which are not dealt with. Now deal with\n\t * them.\n\t *\n\t * We needn't worry that this operation will corrupt the snapshots,\n\t * because all the tree which are snapshoted will be forced to COW\n\t * the nodes and leaves.\n\t */\n\tret = btrfs_run_delayed_items(trans, root);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\tret = btrfs_run_delayed_refs(trans, root, (unsigned long)-1);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * make sure none of the code above managed to slip in a\n\t * delayed item\n\t */\n\tbtrfs_assert_delayed_root_empty(root);\n\n\tWARN_ON(cur_trans != trans->transaction);\n\n\t/* btrfs_commit_tree_roots is responsible for getting the\n\t * various roots consistent with each other.  Every pointer\n\t * in the tree of tree roots has to point to the most up to date\n\t * root for every subvolume and other tree.  So, we have to keep\n\t * the tree logging code from jumping in and changing any\n\t * of the trees.\n\t *\n\t * At this point in the commit, there can't be any tree-log\n\t * writers, but a little lower down we drop the trans mutex\n\t * and let new people in.  By holding the tree_log_mutex\n\t * from now until after the super is written, we avoid races\n\t * with the tree-log code.\n\t */\n\tmutex_lock(&root->fs_info->tree_log_mutex);\n\n\tret = commit_fs_roots(trans, root);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * Since the transaction is done, we can apply the pending changes\n\t * before the next transaction.\n\t */\n\tbtrfs_apply_pending_changes(root->fs_info);\n\n\t/* commit_fs_roots gets rid of all the tree log roots, it is now\n\t * safe to free the root of tree log roots\n\t */\n\tbtrfs_free_log_root_tree(trans, root->fs_info);\n\n\tret = commit_cowonly_roots(trans, root);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * The tasks which save the space cache and inode cache may also\n\t * update ->aborted, check it.\n\t */\n\tif (unlikely(ACCESS_ONCE(cur_trans->aborted))) {\n\t\tret = cur_trans->aborted;\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\tbtrfs_prepare_extent_commit(trans, root);\n\n\tcur_trans = root->fs_info->running_transaction;\n\n\tbtrfs_set_root_node(&root->fs_info->tree_root->root_item,\n\t\t\t    root->fs_info->tree_root->node);\n\tlist_add_tail(&root->fs_info->tree_root->dirty_list,\n\t\t      &cur_trans->switch_commits);\n\n\tbtrfs_set_root_node(&root->fs_info->chunk_root->root_item,\n\t\t\t    root->fs_info->chunk_root->node);\n\tlist_add_tail(&root->fs_info->chunk_root->dirty_list,\n\t\t      &cur_trans->switch_commits);\n\n\tswitch_commit_roots(cur_trans, root->fs_info);\n\n\tassert_qgroups_uptodate(trans);\n\tASSERT(list_empty(&cur_trans->dirty_bgs));\n\tupdate_super_roots(root);\n\n\tbtrfs_set_super_log_root(root->fs_info->super_copy, 0);\n\tbtrfs_set_super_log_root_level(root->fs_info->super_copy, 0);\n\tmemcpy(root->fs_info->super_for_commit, root->fs_info->super_copy,\n\t       sizeof(*root->fs_info->super_copy));\n\n\tbtrfs_update_commit_device_size(root->fs_info);\n\tbtrfs_update_commit_device_bytes_used(root, cur_trans);\n\n\tclear_bit(BTRFS_INODE_BTREE_LOG1_ERR, &btree_ino->runtime_flags);\n\tclear_bit(BTRFS_INODE_BTREE_LOG2_ERR, &btree_ino->runtime_flags);\n\n\tspin_lock(&root->fs_info->trans_lock);\n\tcur_trans->state = TRANS_STATE_UNBLOCKED;\n\troot->fs_info->running_transaction = NULL;\n\tspin_unlock(&root->fs_info->trans_lock);\n\tmutex_unlock(&root->fs_info->reloc_mutex);\n\n\twake_up(&root->fs_info->transaction_wait);\n\n\tret = btrfs_write_and_wait_transaction(trans, root);\n\tif (ret) {\n\t\tbtrfs_error(root->fs_info, ret,\n\t\t\t    \"Error while writing out transaction\");\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\tret = write_ctree_super(trans, root, 0);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * the super is written, we can safely allow the tree-loggers\n\t * to go about their business\n\t */\n\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\n\tbtrfs_finish_extent_commit(trans, root);\n\n\tif (cur_trans->have_free_bgs)\n\t\tbtrfs_clear_space_info_full(root->fs_info);\n\n\troot->fs_info->last_trans_committed = cur_trans->transid;\n\t/*\n\t * We needn't acquire the lock here because there is no other task\n\t * which can change it.\n\t */\n\tcur_trans->state = TRANS_STATE_COMPLETED;\n\twake_up(&cur_trans->commit_wait);\n\n\tspin_lock(&root->fs_info->trans_lock);\n\tlist_del_init(&cur_trans->list);\n\tspin_unlock(&root->fs_info->trans_lock);\n\n\tbtrfs_put_transaction(cur_trans);\n\tbtrfs_put_transaction(cur_trans);\n\n\tif (trans->type & __TRANS_FREEZABLE)\n\t\tsb_end_intwrite(root->fs_info->sb);\n\n\ttrace_btrfs_transaction_commit(root);\n\n\tbtrfs_scrub_continue(root);\n\n\tif (current->journal_info == trans)\n\t\tcurrent->journal_info = NULL;\n\n\tkmem_cache_free(btrfs_trans_handle_cachep, trans);\n\n\tif (current != root->fs_info->transaction_kthread)\n\t\tbtrfs_run_delayed_iputs(root);\n\n\treturn ret;\n\nscrub_continue:\n\tbtrfs_scrub_continue(root);\ncleanup_transaction:\n\tbtrfs_trans_release_metadata(trans, root);\n\ttrans->block_rsv = NULL;\n\tif (trans->qgroup_reserved) {\n\t\tbtrfs_qgroup_free(root, trans->qgroup_reserved);\n\t\ttrans->qgroup_reserved = 0;\n\t}\n\tbtrfs_warn(root->fs_info, \"Skipping commit of aborted transaction.\");\n\tif (current->journal_info == trans)\n\t\tcurrent->journal_info = NULL;\n\tcleanup_transaction(trans, root, ret);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "btrfs_wait_pending_ordered",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
    "lines": "1742-1762",
    "snippet": "static inline void\nbtrfs_wait_pending_ordered(struct btrfs_transaction *cur_trans,\n\t\t\t   struct btrfs_fs_info *fs_info)\n{\n\tstruct btrfs_ordered_extent *ordered;\n\n\tspin_lock(&fs_info->trans_lock);\n\twhile (!list_empty(&cur_trans->pending_ordered)) {\n\t\tordered = list_first_entry(&cur_trans->pending_ordered,\n\t\t\t\t\t   struct btrfs_ordered_extent,\n\t\t\t\t\t   trans_list);\n\t\tlist_del_init(&ordered->trans_list);\n\t\tspin_unlock(&fs_info->trans_lock);\n\n\t\twait_event(ordered->wait, test_bit(BTRFS_ORDERED_COMPLETE,\n\t\t\t\t\t\t   &ordered->flags));\n\t\tbtrfs_put_ordered_extent(ordered);\n\t\tspin_lock(&fs_info->trans_lock);\n\t}\n\tspin_unlock(&fs_info->trans_lock);\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"dev-replace.h\"",
      "#include \"volumes.h\"",
      "#include \"inode-map.h\"",
      "#include \"tree-log.h\"",
      "#include \"locking.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/uuid.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/writeback.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&fs_info->trans_lock"
          ],
          "line": 1761
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&fs_info->trans_lock"
          ],
          "line": 1759
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_put_ordered_extent",
          "args": [
            "ordered"
          ],
          "line": 1758
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_put_ordered_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ordered-data.c",
          "lines": "540-558",
          "snippet": "void btrfs_put_ordered_extent(struct btrfs_ordered_extent *entry)\n{\n\tstruct list_head *cur;\n\tstruct btrfs_ordered_sum *sum;\n\n\ttrace_btrfs_ordered_extent_put(entry->inode, entry);\n\n\tif (atomic_dec_and_test(&entry->refs)) {\n\t\tif (entry->inode)\n\t\t\tbtrfs_add_delayed_iput(entry->inode);\n\t\twhile (!list_empty(&entry->list)) {\n\t\t\tcur = entry->list.next;\n\t\t\tsum = list_entry(cur, struct btrfs_ordered_sum, list);\n\t\t\tlist_del(&sum->list);\n\t\t\tkfree(sum);\n\t\t}\n\t\tkmem_cache_free(btrfs_ordered_extent_cache, entry);\n\t}\n}",
          "includes": [
            "#include \"disk-io.h\"",
            "#include \"extent_io.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"ctree.h\"",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *btrfs_ordered_extent_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"disk-io.h\"\n#include \"extent_io.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n\nstatic struct kmem_cache *btrfs_ordered_extent_cache;\n\nvoid btrfs_put_ordered_extent(struct btrfs_ordered_extent *entry)\n{\n\tstruct list_head *cur;\n\tstruct btrfs_ordered_sum *sum;\n\n\ttrace_btrfs_ordered_extent_put(entry->inode, entry);\n\n\tif (atomic_dec_and_test(&entry->refs)) {\n\t\tif (entry->inode)\n\t\t\tbtrfs_add_delayed_iput(entry->inode);\n\t\twhile (!list_empty(&entry->list)) {\n\t\t\tcur = entry->list.next;\n\t\t\tsum = list_entry(cur, struct btrfs_ordered_sum, list);\n\t\t\tlist_del(&sum->list);\n\t\t\tkfree(sum);\n\t\t}\n\t\tkmem_cache_free(btrfs_ordered_extent_cache, entry);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_event",
          "args": [
            "ordered->wait",
            "test_bit(BTRFS_ORDERED_COMPLETE,\n\t\t\t\t\t\t   &ordered->flags)"
          ],
          "line": 1756
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "BTRFS_ORDERED_COMPLETE",
            "&ordered->flags"
          ],
          "line": 1756
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&ordered->trans_list"
          ],
          "line": 1753
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_first_entry",
          "args": [
            "&cur_trans->pending_ordered",
            "structbtrfs_ordered_extent",
            "trans_list"
          ],
          "line": 1750
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&cur_trans->pending_ordered"
          ],
          "line": 1749
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic inline void\nbtrfs_wait_pending_ordered(struct btrfs_transaction *cur_trans,\n\t\t\t   struct btrfs_fs_info *fs_info)\n{\n\tstruct btrfs_ordered_extent *ordered;\n\n\tspin_lock(&fs_info->trans_lock);\n\twhile (!list_empty(&cur_trans->pending_ordered)) {\n\t\tordered = list_first_entry(&cur_trans->pending_ordered,\n\t\t\t\t\t   struct btrfs_ordered_extent,\n\t\t\t\t\t   trans_list);\n\t\tlist_del_init(&ordered->trans_list);\n\t\tspin_unlock(&fs_info->trans_lock);\n\n\t\twait_event(ordered->wait, test_bit(BTRFS_ORDERED_COMPLETE,\n\t\t\t\t\t\t   &ordered->flags));\n\t\tbtrfs_put_ordered_extent(ordered);\n\t\tspin_lock(&fs_info->trans_lock);\n\t}\n\tspin_unlock(&fs_info->trans_lock);\n}"
  },
  {
    "function_name": "btrfs_wait_delalloc_flush",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
    "lines": "1736-1740",
    "snippet": "static inline void btrfs_wait_delalloc_flush(struct btrfs_fs_info *fs_info)\n{\n\tif (btrfs_test_opt(fs_info->tree_root, FLUSHONCOMMIT))\n\t\tbtrfs_wait_ordered_roots(fs_info, -1);\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"dev-replace.h\"",
      "#include \"volumes.h\"",
      "#include \"inode-map.h\"",
      "#include \"tree-log.h\"",
      "#include \"locking.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/uuid.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/writeback.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_wait_ordered_roots",
          "args": [
            "fs_info",
            "-1"
          ],
          "line": 1739
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_wait_ordered_roots",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ordered-data.c",
          "lines": "656-688",
          "snippet": "void btrfs_wait_ordered_roots(struct btrfs_fs_info *fs_info, int nr)\n{\n\tstruct btrfs_root *root;\n\tstruct list_head splice;\n\tint done;\n\n\tINIT_LIST_HEAD(&splice);\n\n\tmutex_lock(&fs_info->ordered_operations_mutex);\n\tspin_lock(&fs_info->ordered_root_lock);\n\tlist_splice_init(&fs_info->ordered_roots, &splice);\n\twhile (!list_empty(&splice) && nr) {\n\t\troot = list_first_entry(&splice, struct btrfs_root,\n\t\t\t\t\tordered_root);\n\t\troot = btrfs_grab_fs_root(root);\n\t\tBUG_ON(!root);\n\t\tlist_move_tail(&root->ordered_root,\n\t\t\t       &fs_info->ordered_roots);\n\t\tspin_unlock(&fs_info->ordered_root_lock);\n\n\t\tdone = btrfs_wait_ordered_extents(root, nr);\n\t\tbtrfs_put_fs_root(root);\n\n\t\tspin_lock(&fs_info->ordered_root_lock);\n\t\tif (nr != -1) {\n\t\t\tnr -= done;\n\t\t\tWARN_ON(nr < 0);\n\t\t}\n\t}\n\tlist_splice_tail(&splice, &fs_info->ordered_roots);\n\tspin_unlock(&fs_info->ordered_root_lock);\n\tmutex_unlock(&fs_info->ordered_operations_mutex);\n}",
          "includes": [
            "#include \"disk-io.h\"",
            "#include \"extent_io.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"ctree.h\"",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"disk-io.h\"\n#include \"extent_io.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n\nvoid btrfs_wait_ordered_roots(struct btrfs_fs_info *fs_info, int nr)\n{\n\tstruct btrfs_root *root;\n\tstruct list_head splice;\n\tint done;\n\n\tINIT_LIST_HEAD(&splice);\n\n\tmutex_lock(&fs_info->ordered_operations_mutex);\n\tspin_lock(&fs_info->ordered_root_lock);\n\tlist_splice_init(&fs_info->ordered_roots, &splice);\n\twhile (!list_empty(&splice) && nr) {\n\t\troot = list_first_entry(&splice, struct btrfs_root,\n\t\t\t\t\tordered_root);\n\t\troot = btrfs_grab_fs_root(root);\n\t\tBUG_ON(!root);\n\t\tlist_move_tail(&root->ordered_root,\n\t\t\t       &fs_info->ordered_roots);\n\t\tspin_unlock(&fs_info->ordered_root_lock);\n\n\t\tdone = btrfs_wait_ordered_extents(root, nr);\n\t\tbtrfs_put_fs_root(root);\n\n\t\tspin_lock(&fs_info->ordered_root_lock);\n\t\tif (nr != -1) {\n\t\t\tnr -= done;\n\t\t\tWARN_ON(nr < 0);\n\t\t}\n\t}\n\tlist_splice_tail(&splice, &fs_info->ordered_roots);\n\tspin_unlock(&fs_info->ordered_root_lock);\n\tmutex_unlock(&fs_info->ordered_operations_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_test_opt",
          "args": [
            "fs_info->tree_root",
            "FLUSHONCOMMIT"
          ],
          "line": 1738
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic inline void btrfs_wait_delalloc_flush(struct btrfs_fs_info *fs_info)\n{\n\tif (btrfs_test_opt(fs_info->tree_root, FLUSHONCOMMIT))\n\t\tbtrfs_wait_ordered_roots(fs_info, -1);\n}"
  },
  {
    "function_name": "btrfs_start_delalloc_flush",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
    "lines": "1729-1734",
    "snippet": "static inline int btrfs_start_delalloc_flush(struct btrfs_fs_info *fs_info)\n{\n\tif (btrfs_test_opt(fs_info->tree_root, FLUSHONCOMMIT))\n\t\treturn btrfs_start_delalloc_roots(fs_info, 1, -1);\n\treturn 0;\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"dev-replace.h\"",
      "#include \"volumes.h\"",
      "#include \"inode-map.h\"",
      "#include \"tree-log.h\"",
      "#include \"locking.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/uuid.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/writeback.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_start_delalloc_roots",
          "args": [
            "fs_info",
            "1",
            "-1"
          ],
          "line": 1732
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_start_delalloc_roots",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/inode.c",
          "lines": "9228-9282",
          "snippet": "int btrfs_start_delalloc_roots(struct btrfs_fs_info *fs_info, int delay_iput,\n\t\t\t       int nr)\n{\n\tstruct btrfs_root *root;\n\tstruct list_head splice;\n\tint ret;\n\n\tif (test_bit(BTRFS_FS_STATE_ERROR, &fs_info->fs_state))\n\t\treturn -EROFS;\n\n\tINIT_LIST_HEAD(&splice);\n\n\tmutex_lock(&fs_info->delalloc_root_mutex);\n\tspin_lock(&fs_info->delalloc_root_lock);\n\tlist_splice_init(&fs_info->delalloc_roots, &splice);\n\twhile (!list_empty(&splice) && nr) {\n\t\troot = list_first_entry(&splice, struct btrfs_root,\n\t\t\t\t\tdelalloc_root);\n\t\troot = btrfs_grab_fs_root(root);\n\t\tBUG_ON(!root);\n\t\tlist_move_tail(&root->delalloc_root,\n\t\t\t       &fs_info->delalloc_roots);\n\t\tspin_unlock(&fs_info->delalloc_root_lock);\n\n\t\tret = __start_delalloc_inodes(root, delay_iput, nr);\n\t\tbtrfs_put_fs_root(root);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\tif (nr != -1) {\n\t\t\tnr -= ret;\n\t\t\tWARN_ON(nr < 0);\n\t\t}\n\t\tspin_lock(&fs_info->delalloc_root_lock);\n\t}\n\tspin_unlock(&fs_info->delalloc_root_lock);\n\n\tret = 0;\n\tatomic_inc(&fs_info->async_submit_draining);\n\twhile (atomic_read(&fs_info->nr_async_submits) ||\n\t      atomic_read(&fs_info->async_delalloc_pages)) {\n\t\twait_event(fs_info->async_submit_wait,\n\t\t   (atomic_read(&fs_info->nr_async_submits) == 0 &&\n\t\t    atomic_read(&fs_info->async_delalloc_pages) == 0));\n\t}\n\tatomic_dec(&fs_info->async_submit_draining);\nout:\n\tif (!list_empty_careful(&splice)) {\n\t\tspin_lock(&fs_info->delalloc_root_lock);\n\t\tlist_splice_tail(&splice, &fs_info->delalloc_roots);\n\t\tspin_unlock(&fs_info->delalloc_root_lock);\n\t}\n\tmutex_unlock(&fs_info->delalloc_root_mutex);\n\treturn ret;\n}",
          "includes": [
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"compression.h\"",
            "#include \"volumes.h\"",
            "#include \"tree-log.h\"",
            "#include \"xattr.h\"",
            "#include \"ordered-data.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/falloc.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/aio.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"props.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"compression.h\"\n#include \"volumes.h\"\n#include \"tree-log.h\"\n#include \"xattr.h\"\n#include \"ordered-data.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/blkdev.h>\n#include <linux/btrfs.h>\n#include <linux/mount.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/bit_spinlock.h>\n#include <linux/aio.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nint btrfs_start_delalloc_roots(struct btrfs_fs_info *fs_info, int delay_iput,\n\t\t\t       int nr)\n{\n\tstruct btrfs_root *root;\n\tstruct list_head splice;\n\tint ret;\n\n\tif (test_bit(BTRFS_FS_STATE_ERROR, &fs_info->fs_state))\n\t\treturn -EROFS;\n\n\tINIT_LIST_HEAD(&splice);\n\n\tmutex_lock(&fs_info->delalloc_root_mutex);\n\tspin_lock(&fs_info->delalloc_root_lock);\n\tlist_splice_init(&fs_info->delalloc_roots, &splice);\n\twhile (!list_empty(&splice) && nr) {\n\t\troot = list_first_entry(&splice, struct btrfs_root,\n\t\t\t\t\tdelalloc_root);\n\t\troot = btrfs_grab_fs_root(root);\n\t\tBUG_ON(!root);\n\t\tlist_move_tail(&root->delalloc_root,\n\t\t\t       &fs_info->delalloc_roots);\n\t\tspin_unlock(&fs_info->delalloc_root_lock);\n\n\t\tret = __start_delalloc_inodes(root, delay_iput, nr);\n\t\tbtrfs_put_fs_root(root);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\tif (nr != -1) {\n\t\t\tnr -= ret;\n\t\t\tWARN_ON(nr < 0);\n\t\t}\n\t\tspin_lock(&fs_info->delalloc_root_lock);\n\t}\n\tspin_unlock(&fs_info->delalloc_root_lock);\n\n\tret = 0;\n\tatomic_inc(&fs_info->async_submit_draining);\n\twhile (atomic_read(&fs_info->nr_async_submits) ||\n\t      atomic_read(&fs_info->async_delalloc_pages)) {\n\t\twait_event(fs_info->async_submit_wait,\n\t\t   (atomic_read(&fs_info->nr_async_submits) == 0 &&\n\t\t    atomic_read(&fs_info->async_delalloc_pages) == 0));\n\t}\n\tatomic_dec(&fs_info->async_submit_draining);\nout:\n\tif (!list_empty_careful(&splice)) {\n\t\tspin_lock(&fs_info->delalloc_root_lock);\n\t\tlist_splice_tail(&splice, &fs_info->delalloc_roots);\n\t\tspin_unlock(&fs_info->delalloc_root_lock);\n\t}\n\tmutex_unlock(&fs_info->delalloc_root_mutex);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_test_opt",
          "args": [
            "fs_info->tree_root",
            "FLUSHONCOMMIT"
          ],
          "line": 1731
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic inline int btrfs_start_delalloc_flush(struct btrfs_fs_info *fs_info)\n{\n\tif (btrfs_test_opt(fs_info->tree_root, FLUSHONCOMMIT))\n\t\treturn btrfs_start_delalloc_roots(fs_info, 1, -1);\n\treturn 0;\n}"
  },
  {
    "function_name": "cleanup_transaction",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
    "lines": "1678-1727",
    "snippet": "static void cleanup_transaction(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root, int err)\n{\n\tstruct btrfs_transaction *cur_trans = trans->transaction;\n\tDEFINE_WAIT(wait);\n\n\tWARN_ON(trans->use_count > 1);\n\n\tbtrfs_abort_transaction(trans, root, err);\n\n\tspin_lock(&root->fs_info->trans_lock);\n\n\t/*\n\t * If the transaction is removed from the list, it means this\n\t * transaction has been committed successfully, so it is impossible\n\t * to call the cleanup function.\n\t */\n\tBUG_ON(list_empty(&cur_trans->list));\n\n\tlist_del_init(&cur_trans->list);\n\tif (cur_trans == root->fs_info->running_transaction) {\n\t\tcur_trans->state = TRANS_STATE_COMMIT_DOING;\n\t\tspin_unlock(&root->fs_info->trans_lock);\n\t\twait_event(cur_trans->writer_wait,\n\t\t\t   atomic_read(&cur_trans->num_writers) == 1);\n\n\t\tspin_lock(&root->fs_info->trans_lock);\n\t}\n\tspin_unlock(&root->fs_info->trans_lock);\n\n\tbtrfs_cleanup_one_transaction(trans->transaction, root);\n\n\tspin_lock(&root->fs_info->trans_lock);\n\tif (cur_trans == root->fs_info->running_transaction)\n\t\troot->fs_info->running_transaction = NULL;\n\tspin_unlock(&root->fs_info->trans_lock);\n\n\tif (trans->type & __TRANS_FREEZABLE)\n\t\tsb_end_intwrite(root->fs_info->sb);\n\tbtrfs_put_transaction(cur_trans);\n\tbtrfs_put_transaction(cur_trans);\n\n\ttrace_btrfs_transaction_commit(root);\n\n\tif (current->journal_info == trans)\n\t\tcurrent->journal_info = NULL;\n\tbtrfs_scrub_cancel(root->fs_info);\n\n\tkmem_cache_free(btrfs_trans_handle_cachep, trans);\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"dev-replace.h\"",
      "#include \"volumes.h\"",
      "#include \"inode-map.h\"",
      "#include \"tree-log.h\"",
      "#include \"locking.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/uuid.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/writeback.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "btrfs_trans_handle_cachep",
            "trans"
          ],
          "line": 1726
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_scrub_cancel",
          "args": [
            "root->fs_info"
          ],
          "line": 1724
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_scrub_cancel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/scrub.c",
          "lines": "3781-3800",
          "snippet": "int btrfs_scrub_cancel(struct btrfs_fs_info *fs_info)\n{\n\tmutex_lock(&fs_info->scrub_lock);\n\tif (!atomic_read(&fs_info->scrubs_running)) {\n\t\tmutex_unlock(&fs_info->scrub_lock);\n\t\treturn -ENOTCONN;\n\t}\n\n\tatomic_inc(&fs_info->scrub_cancel_req);\n\twhile (atomic_read(&fs_info->scrubs_running)) {\n\t\tmutex_unlock(&fs_info->scrub_lock);\n\t\twait_event(fs_info->scrub_pause_wait,\n\t\t\t   atomic_read(&fs_info->scrubs_running) == 0);\n\t\tmutex_lock(&fs_info->scrub_lock);\n\t}\n\tatomic_dec(&fs_info->scrub_cancel_req);\n\tmutex_unlock(&fs_info->scrub_lock);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"raid56.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"dev-replace.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"transaction.h\"",
            "#include \"ordered-data.h\"",
            "#include \"disk-io.h\"",
            "#include \"volumes.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);",
            "static void scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);",
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"raid56.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"dev-replace.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"transaction.h\"\n#include \"ordered-data.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/blkdev.h>\n\nstatic void __scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);\nstatic void scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);\nstatic noinline_for_stack\nstruct;\n\nint btrfs_scrub_cancel(struct btrfs_fs_info *fs_info)\n{\n\tmutex_lock(&fs_info->scrub_lock);\n\tif (!atomic_read(&fs_info->scrubs_running)) {\n\t\tmutex_unlock(&fs_info->scrub_lock);\n\t\treturn -ENOTCONN;\n\t}\n\n\tatomic_inc(&fs_info->scrub_cancel_req);\n\twhile (atomic_read(&fs_info->scrubs_running)) {\n\t\tmutex_unlock(&fs_info->scrub_lock);\n\t\twait_event(fs_info->scrub_pause_wait,\n\t\t\t   atomic_read(&fs_info->scrubs_running) == 0);\n\t\tmutex_lock(&fs_info->scrub_lock);\n\t}\n\tatomic_dec(&fs_info->scrub_cancel_req);\n\tmutex_unlock(&fs_info->scrub_lock);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_btrfs_transaction_commit",
          "args": [
            "root"
          ],
          "line": 1720
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_put_transaction",
          "args": [
            "cur_trans"
          ],
          "line": 1718
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_put_transaction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
          "lines": "61-77",
          "snippet": "void btrfs_put_transaction(struct btrfs_transaction *transaction)\n{\n\tWARN_ON(atomic_read(&transaction->use_count) == 0);\n\tif (atomic_dec_and_test(&transaction->use_count)) {\n\t\tBUG_ON(!list_empty(&transaction->list));\n\t\tWARN_ON(!RB_EMPTY_ROOT(&transaction->delayed_refs.href_root));\n\t\twhile (!list_empty(&transaction->pending_chunks)) {\n\t\t\tstruct extent_map *em;\n\n\t\t\tem = list_first_entry(&transaction->pending_chunks,\n\t\t\t\t\t      struct extent_map, list);\n\t\t\tlist_del_init(&em->list);\n\t\t\tfree_extent_map(em);\n\t\t}\n\t\tkmem_cache_free(btrfs_transaction_cachep, transaction);\n\t}\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"dev-replace.h\"",
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid btrfs_put_transaction(struct btrfs_transaction *transaction)\n{\n\tWARN_ON(atomic_read(&transaction->use_count) == 0);\n\tif (atomic_dec_and_test(&transaction->use_count)) {\n\t\tBUG_ON(!list_empty(&transaction->list));\n\t\tWARN_ON(!RB_EMPTY_ROOT(&transaction->delayed_refs.href_root));\n\t\twhile (!list_empty(&transaction->pending_chunks)) {\n\t\t\tstruct extent_map *em;\n\n\t\t\tem = list_first_entry(&transaction->pending_chunks,\n\t\t\t\t\t      struct extent_map, list);\n\t\t\tlist_del_init(&em->list);\n\t\t\tfree_extent_map(em);\n\t\t}\n\t\tkmem_cache_free(btrfs_transaction_cachep, transaction);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sb_end_intwrite",
          "args": [
            "root->fs_info->sb"
          ],
          "line": 1716
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&root->fs_info->trans_lock"
          ],
          "line": 1713
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&root->fs_info->trans_lock"
          ],
          "line": 1710
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_cleanup_one_transaction",
          "args": [
            "trans->transaction",
            "root"
          ],
          "line": 1708
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_cleanup_one_transaction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "4206-4233",
          "snippet": "void btrfs_cleanup_one_transaction(struct btrfs_transaction *cur_trans,\n\t\t\t\t   struct btrfs_root *root)\n{\n\tbtrfs_destroy_delayed_refs(cur_trans, root);\n\n\tcur_trans->state = TRANS_STATE_COMMIT_START;\n\twake_up(&root->fs_info->transaction_blocked_wait);\n\n\tcur_trans->state = TRANS_STATE_UNBLOCKED;\n\twake_up(&root->fs_info->transaction_wait);\n\n\tbtrfs_free_pending_ordered(cur_trans, root->fs_info);\n\tbtrfs_destroy_delayed_inodes(root);\n\tbtrfs_assert_delayed_root_empty(root);\n\n\tbtrfs_destroy_marked_extents(root, &cur_trans->dirty_pages,\n\t\t\t\t     EXTENT_DIRTY);\n\tbtrfs_destroy_pinned_extent(root,\n\t\t\t\t    root->fs_info->pinned_extents);\n\n\tcur_trans->state =TRANS_STATE_COMPLETED;\n\twake_up(&cur_trans->commit_wait);\n\n\t/*\n\tmemset(cur_trans, 0, sizeof(*cur_trans));\n\tkmem_cache_free(btrfs_transaction_cachep, cur_trans);\n\t*/\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_fs_root(struct btrfs_root *root);",
            "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
            "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
            "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
            "static int btrfs_destroy_pinned_extent(struct btrfs_root *root,\n\t\t\t\t       struct extent_io_tree *pinned_extents);",
            "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
            "static void btrfs_error_commit_super(struct btrfs_root *root);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_destroy_pinned_extent(struct btrfs_root *root,\n\t\t\t\t       struct extent_io_tree *pinned_extents);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nvoid btrfs_cleanup_one_transaction(struct btrfs_transaction *cur_trans,\n\t\t\t\t   struct btrfs_root *root)\n{\n\tbtrfs_destroy_delayed_refs(cur_trans, root);\n\n\tcur_trans->state = TRANS_STATE_COMMIT_START;\n\twake_up(&root->fs_info->transaction_blocked_wait);\n\n\tcur_trans->state = TRANS_STATE_UNBLOCKED;\n\twake_up(&root->fs_info->transaction_wait);\n\n\tbtrfs_free_pending_ordered(cur_trans, root->fs_info);\n\tbtrfs_destroy_delayed_inodes(root);\n\tbtrfs_assert_delayed_root_empty(root);\n\n\tbtrfs_destroy_marked_extents(root, &cur_trans->dirty_pages,\n\t\t\t\t     EXTENT_DIRTY);\n\tbtrfs_destroy_pinned_extent(root,\n\t\t\t\t    root->fs_info->pinned_extents);\n\n\tcur_trans->state =TRANS_STATE_COMPLETED;\n\twake_up(&cur_trans->commit_wait);\n\n\t/*\n\tmemset(cur_trans, 0, sizeof(*cur_trans));\n\tkmem_cache_free(btrfs_transaction_cachep, cur_trans);\n\t*/\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_event",
          "args": [
            "cur_trans->writer_wait",
            "atomic_read(&cur_trans->num_writers) == 1"
          ],
          "line": 1701
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&cur_trans->num_writers"
          ],
          "line": 1702
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&cur_trans->list"
          ],
          "line": 1697
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "list_empty(&cur_trans->list)"
          ],
          "line": 1695
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&cur_trans->list"
          ],
          "line": 1695
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_abort_transaction",
          "args": [
            "trans",
            "root",
            "err"
          ],
          "line": 1686
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "trans->use_count > 1"
          ],
          "line": 1684
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DEFINE_WAIT",
          "args": [
            "wait"
          ],
          "line": 1682
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void cleanup_transaction(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root, int err)\n{\n\tstruct btrfs_transaction *cur_trans = trans->transaction;\n\tDEFINE_WAIT(wait);\n\n\tWARN_ON(trans->use_count > 1);\n\n\tbtrfs_abort_transaction(trans, root, err);\n\n\tspin_lock(&root->fs_info->trans_lock);\n\n\t/*\n\t * If the transaction is removed from the list, it means this\n\t * transaction has been committed successfully, so it is impossible\n\t * to call the cleanup function.\n\t */\n\tBUG_ON(list_empty(&cur_trans->list));\n\n\tlist_del_init(&cur_trans->list);\n\tif (cur_trans == root->fs_info->running_transaction) {\n\t\tcur_trans->state = TRANS_STATE_COMMIT_DOING;\n\t\tspin_unlock(&root->fs_info->trans_lock);\n\t\twait_event(cur_trans->writer_wait,\n\t\t\t   atomic_read(&cur_trans->num_writers) == 1);\n\n\t\tspin_lock(&root->fs_info->trans_lock);\n\t}\n\tspin_unlock(&root->fs_info->trans_lock);\n\n\tbtrfs_cleanup_one_transaction(trans->transaction, root);\n\n\tspin_lock(&root->fs_info->trans_lock);\n\tif (cur_trans == root->fs_info->running_transaction)\n\t\troot->fs_info->running_transaction = NULL;\n\tspin_unlock(&root->fs_info->trans_lock);\n\n\tif (trans->type & __TRANS_FREEZABLE)\n\t\tsb_end_intwrite(root->fs_info->sb);\n\tbtrfs_put_transaction(cur_trans);\n\tbtrfs_put_transaction(cur_trans);\n\n\ttrace_btrfs_transaction_commit(root);\n\n\tif (current->journal_info == trans)\n\t\tcurrent->journal_info = NULL;\n\tbtrfs_scrub_cancel(root->fs_info);\n\n\tkmem_cache_free(btrfs_trans_handle_cachep, trans);\n}"
  },
  {
    "function_name": "btrfs_commit_transaction_async",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
    "lines": "1627-1675",
    "snippet": "int btrfs_commit_transaction_async(struct btrfs_trans_handle *trans,\n\t\t\t\t   struct btrfs_root *root,\n\t\t\t\t   int wait_for_unblock)\n{\n\tstruct btrfs_async_commit *ac;\n\tstruct btrfs_transaction *cur_trans;\n\n\tac = kmalloc(sizeof(*ac), GFP_NOFS);\n\tif (!ac)\n\t\treturn -ENOMEM;\n\n\tINIT_WORK(&ac->work, do_async_commit);\n\tac->root = root;\n\tac->newtrans = btrfs_join_transaction(root);\n\tif (IS_ERR(ac->newtrans)) {\n\t\tint err = PTR_ERR(ac->newtrans);\n\t\tkfree(ac);\n\t\treturn err;\n\t}\n\n\t/* take transaction reference */\n\tcur_trans = trans->transaction;\n\tatomic_inc(&cur_trans->use_count);\n\n\tbtrfs_end_transaction(trans, root);\n\n\t/*\n\t * Tell lockdep we've released the freeze rwsem, since the\n\t * async commit thread will be the one to unlock it.\n\t */\n\tif (ac->newtrans->type & __TRANS_FREEZABLE)\n\t\trwsem_release(\n\t\t\t&root->fs_info->sb->s_writers.lock_map[SB_FREEZE_FS-1],\n\t\t\t1, _THIS_IP_);\n\n\tschedule_work(&ac->work);\n\n\t/* wait for transaction to start and unblock */\n\tif (wait_for_unblock)\n\t\twait_current_trans_commit_start_and_unblock(root, cur_trans);\n\telse\n\t\twait_current_trans_commit_start(root, cur_trans);\n\n\tif (current->journal_info == trans)\n\t\tcurrent->journal_info = NULL;\n\n\tbtrfs_put_transaction(cur_trans);\n\treturn 0;\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"dev-replace.h\"",
      "#include \"volumes.h\"",
      "#include \"inode-map.h\"",
      "#include \"tree-log.h\"",
      "#include \"locking.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/uuid.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/writeback.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_put_transaction",
          "args": [
            "cur_trans"
          ],
          "line": 1673
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_put_transaction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
          "lines": "61-77",
          "snippet": "void btrfs_put_transaction(struct btrfs_transaction *transaction)\n{\n\tWARN_ON(atomic_read(&transaction->use_count) == 0);\n\tif (atomic_dec_and_test(&transaction->use_count)) {\n\t\tBUG_ON(!list_empty(&transaction->list));\n\t\tWARN_ON(!RB_EMPTY_ROOT(&transaction->delayed_refs.href_root));\n\t\twhile (!list_empty(&transaction->pending_chunks)) {\n\t\t\tstruct extent_map *em;\n\n\t\t\tem = list_first_entry(&transaction->pending_chunks,\n\t\t\t\t\t      struct extent_map, list);\n\t\t\tlist_del_init(&em->list);\n\t\t\tfree_extent_map(em);\n\t\t}\n\t\tkmem_cache_free(btrfs_transaction_cachep, transaction);\n\t}\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"dev-replace.h\"",
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid btrfs_put_transaction(struct btrfs_transaction *transaction)\n{\n\tWARN_ON(atomic_read(&transaction->use_count) == 0);\n\tif (atomic_dec_and_test(&transaction->use_count)) {\n\t\tBUG_ON(!list_empty(&transaction->list));\n\t\tWARN_ON(!RB_EMPTY_ROOT(&transaction->delayed_refs.href_root));\n\t\twhile (!list_empty(&transaction->pending_chunks)) {\n\t\t\tstruct extent_map *em;\n\n\t\t\tem = list_first_entry(&transaction->pending_chunks,\n\t\t\t\t\t      struct extent_map, list);\n\t\t\tlist_del_init(&em->list);\n\t\t\tfree_extent_map(em);\n\t\t}\n\t\tkmem_cache_free(btrfs_transaction_cachep, transaction);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_current_trans_commit_start",
          "args": [
            "root",
            "cur_trans"
          ],
          "line": 1668
        },
        "resolved": true,
        "details": {
          "function_name": "wait_current_trans_commit_start_and_unblock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
          "lines": "1589-1595",
          "snippet": "static void wait_current_trans_commit_start_and_unblock(struct btrfs_root *root,\n\t\t\t\t\t struct btrfs_transaction *trans)\n{\n\twait_event(root->fs_info->transaction_wait,\n\t\t   trans->state >= TRANS_STATE_UNBLOCKED ||\n\t\t   trans->aborted);\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"dev-replace.h\"",
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void wait_current_trans_commit_start_and_unblock(struct btrfs_root *root,\n\t\t\t\t\t struct btrfs_transaction *trans)\n{\n\twait_event(root->fs_info->transaction_wait,\n\t\t   trans->state >= TRANS_STATE_UNBLOCKED ||\n\t\t   trans->aborted);\n}"
        }
      },
      {
        "call_info": {
          "callee": "schedule_work",
          "args": [
            "&ac->work"
          ],
          "line": 1662
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_direct_write_schedule_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/direct.c",
          "lines": "755-771",
          "snippet": "static void nfs_direct_write_schedule_work(struct work_struct *work)\n{\n\tstruct nfs_direct_req *dreq = container_of(work, struct nfs_direct_req, work);\n\tint flags = dreq->flags;\n\n\tdreq->flags = 0;\n\tswitch (flags) {\n\t\tcase NFS_ODIRECT_DO_COMMIT:\n\t\t\tnfs_direct_commit_schedule(dreq);\n\t\t\tbreak;\n\t\tcase NFS_ODIRECT_RESCHED_WRITES:\n\t\t\tnfs_direct_write_reschedule(dreq);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tnfs_direct_complete(dreq, true);\n\t}\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include <linux/atomic.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/slab.h>",
            "#include <linux/kref.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [
            "#define NFS_ODIRECT_RESCHED_WRITES\t(2)\t/* write verification failed */",
            "#define NFS_ODIRECT_DO_COMMIT\t\t(1)\t/* an unstable reply was received */"
          ],
          "globals_used": [
            "static void nfs_direct_write_schedule_work(struct work_struct *work);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include <linux/atomic.h>\n#include <asm/uaccess.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n#include <linux/module.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/slab.h>\n#include <linux/kref.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\n#define NFS_ODIRECT_RESCHED_WRITES\t(2)\t/* write verification failed */\n#define NFS_ODIRECT_DO_COMMIT\t\t(1)\t/* an unstable reply was received */\n\nstatic void nfs_direct_write_schedule_work(struct work_struct *work);\n\nstatic void nfs_direct_write_schedule_work(struct work_struct *work)\n{\n\tstruct nfs_direct_req *dreq = container_of(work, struct nfs_direct_req, work);\n\tint flags = dreq->flags;\n\n\tdreq->flags = 0;\n\tswitch (flags) {\n\t\tcase NFS_ODIRECT_DO_COMMIT:\n\t\t\tnfs_direct_commit_schedule(dreq);\n\t\t\tbreak;\n\t\tcase NFS_ODIRECT_RESCHED_WRITES:\n\t\t\tnfs_direct_write_reschedule(dreq);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tnfs_direct_complete(dreq, true);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rwsem_release",
          "args": [
            "&root->fs_info->sb->s_writers.lock_map[SB_FREEZE_FS-1]",
            "1",
            "_THIS_IP_"
          ],
          "line": 1658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_end_transaction",
          "args": [
            "trans",
            "root"
          ],
          "line": 1651
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_end_transaction_throttle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
          "lines": "846-850",
          "snippet": "int btrfs_end_transaction_throttle(struct btrfs_trans_handle *trans,\n\t\t\t\t   struct btrfs_root *root)\n{\n\treturn __btrfs_end_transaction(trans, root, 1);\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"dev-replace.h\"",
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint btrfs_end_transaction_throttle(struct btrfs_trans_handle *trans,\n\t\t\t\t   struct btrfs_root *root)\n{\n\treturn __btrfs_end_transaction(trans, root, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&cur_trans->use_count"
          ],
          "line": 1649
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ac"
          ],
          "line": 1643
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "ac->newtrans"
          ],
          "line": 1642
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "ac->newtrans"
          ],
          "line": 1641
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_join_transaction",
          "args": [
            "root"
          ],
          "line": 1640
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_join_transaction_nolock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
          "lines": "581-584",
          "snippet": "struct btrfs_trans_handle *btrfs_join_transaction_nolock(struct btrfs_root *root)\n{\n\treturn start_transaction(root, 0, TRANS_JOIN_NOLOCK, 0);\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"dev-replace.h\"",
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstruct btrfs_trans_handle *btrfs_join_transaction_nolock(struct btrfs_root *root)\n{\n\treturn start_transaction(root, 0, TRANS_JOIN_NOLOCK, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_WORK",
          "args": [
            "&ac->work",
            "do_async_commit"
          ],
          "line": 1638
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(*ac)",
            "GFP_NOFS"
          ],
          "line": 1634
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint btrfs_commit_transaction_async(struct btrfs_trans_handle *trans,\n\t\t\t\t   struct btrfs_root *root,\n\t\t\t\t   int wait_for_unblock)\n{\n\tstruct btrfs_async_commit *ac;\n\tstruct btrfs_transaction *cur_trans;\n\n\tac = kmalloc(sizeof(*ac), GFP_NOFS);\n\tif (!ac)\n\t\treturn -ENOMEM;\n\n\tINIT_WORK(&ac->work, do_async_commit);\n\tac->root = root;\n\tac->newtrans = btrfs_join_transaction(root);\n\tif (IS_ERR(ac->newtrans)) {\n\t\tint err = PTR_ERR(ac->newtrans);\n\t\tkfree(ac);\n\t\treturn err;\n\t}\n\n\t/* take transaction reference */\n\tcur_trans = trans->transaction;\n\tatomic_inc(&cur_trans->use_count);\n\n\tbtrfs_end_transaction(trans, root);\n\n\t/*\n\t * Tell lockdep we've released the freeze rwsem, since the\n\t * async commit thread will be the one to unlock it.\n\t */\n\tif (ac->newtrans->type & __TRANS_FREEZABLE)\n\t\trwsem_release(\n\t\t\t&root->fs_info->sb->s_writers.lock_map[SB_FREEZE_FS-1],\n\t\t\t1, _THIS_IP_);\n\n\tschedule_work(&ac->work);\n\n\t/* wait for transaction to start and unblock */\n\tif (wait_for_unblock)\n\t\twait_current_trans_commit_start_and_unblock(root, cur_trans);\n\telse\n\t\twait_current_trans_commit_start(root, cur_trans);\n\n\tif (current->journal_info == trans)\n\t\tcurrent->journal_info = NULL;\n\n\tbtrfs_put_transaction(cur_trans);\n\treturn 0;\n}"
  },
  {
    "function_name": "do_async_commit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
    "lines": "1607-1625",
    "snippet": "static void do_async_commit(struct work_struct *work)\n{\n\tstruct btrfs_async_commit *ac =\n\t\tcontainer_of(work, struct btrfs_async_commit, work);\n\n\t/*\n\t * We've got freeze protection passed with the transaction.\n\t * Tell lockdep about it.\n\t */\n\tif (ac->newtrans->type & __TRANS_FREEZABLE)\n\t\trwsem_acquire_read(\n\t\t     &ac->root->fs_info->sb->s_writers.lock_map[SB_FREEZE_FS-1],\n\t\t     0, 1, _THIS_IP_);\n\n\tcurrent->journal_info = ac->newtrans;\n\n\tbtrfs_commit_transaction(ac->newtrans, ac->root);\n\tkfree(ac);\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"dev-replace.h\"",
      "#include \"volumes.h\"",
      "#include \"inode-map.h\"",
      "#include \"tree-log.h\"",
      "#include \"locking.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/uuid.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/writeback.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ac"
          ],
          "line": 1624
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_commit_transaction",
          "args": [
            "ac->newtrans",
            "ac->root"
          ],
          "line": 1623
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_commit_transaction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
          "lines": "1764-2099",
          "snippet": "int btrfs_commit_transaction(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root)\n{\n\tstruct btrfs_transaction *cur_trans = trans->transaction;\n\tstruct btrfs_transaction *prev_trans = NULL;\n\tstruct btrfs_inode *btree_ino = BTRFS_I(root->fs_info->btree_inode);\n\tint ret;\n\n\t/* Stop the commit early if ->aborted is set */\n\tif (unlikely(ACCESS_ONCE(cur_trans->aborted))) {\n\t\tret = cur_trans->aborted;\n\t\tbtrfs_end_transaction(trans, root);\n\t\treturn ret;\n\t}\n\n\t/* make a pass through all the delayed refs we have so far\n\t * any runnings procs may add more while we are here\n\t */\n\tret = btrfs_run_delayed_refs(trans, root, 0);\n\tif (ret) {\n\t\tbtrfs_end_transaction(trans, root);\n\t\treturn ret;\n\t}\n\n\tbtrfs_trans_release_metadata(trans, root);\n\ttrans->block_rsv = NULL;\n\tif (trans->qgroup_reserved) {\n\t\tbtrfs_qgroup_free(root, trans->qgroup_reserved);\n\t\ttrans->qgroup_reserved = 0;\n\t}\n\n\tcur_trans = trans->transaction;\n\n\t/*\n\t * set the flushing flag so procs in this transaction have to\n\t * start sending their work down.\n\t */\n\tcur_trans->delayed_refs.flushing = 1;\n\tsmp_wmb();\n\n\tif (!list_empty(&trans->new_bgs))\n\t\tbtrfs_create_pending_block_groups(trans, root);\n\n\tret = btrfs_run_delayed_refs(trans, root, 0);\n\tif (ret) {\n\t\tbtrfs_end_transaction(trans, root);\n\t\treturn ret;\n\t}\n\n\tspin_lock(&root->fs_info->trans_lock);\n\tlist_splice(&trans->ordered, &cur_trans->pending_ordered);\n\tif (cur_trans->state >= TRANS_STATE_COMMIT_START) {\n\t\tspin_unlock(&root->fs_info->trans_lock);\n\t\tatomic_inc(&cur_trans->use_count);\n\t\tret = btrfs_end_transaction(trans, root);\n\n\t\twait_for_commit(root, cur_trans);\n\n\t\tif (unlikely(cur_trans->aborted))\n\t\t\tret = cur_trans->aborted;\n\n\t\tbtrfs_put_transaction(cur_trans);\n\n\t\treturn ret;\n\t}\n\n\tcur_trans->state = TRANS_STATE_COMMIT_START;\n\twake_up(&root->fs_info->transaction_blocked_wait);\n\n\tif (cur_trans->list.prev != &root->fs_info->trans_list) {\n\t\tprev_trans = list_entry(cur_trans->list.prev,\n\t\t\t\t\tstruct btrfs_transaction, list);\n\t\tif (prev_trans->state != TRANS_STATE_COMPLETED) {\n\t\t\tatomic_inc(&prev_trans->use_count);\n\t\t\tspin_unlock(&root->fs_info->trans_lock);\n\n\t\t\twait_for_commit(root, prev_trans);\n\n\t\t\tbtrfs_put_transaction(prev_trans);\n\t\t} else {\n\t\t\tspin_unlock(&root->fs_info->trans_lock);\n\t\t}\n\t} else {\n\t\tspin_unlock(&root->fs_info->trans_lock);\n\t}\n\n\textwriter_counter_dec(cur_trans, trans->type);\n\n\tret = btrfs_start_delalloc_flush(root->fs_info);\n\tif (ret)\n\t\tgoto cleanup_transaction;\n\n\tret = btrfs_run_delayed_items(trans, root);\n\tif (ret)\n\t\tgoto cleanup_transaction;\n\n\twait_event(cur_trans->writer_wait,\n\t\t   extwriter_counter_read(cur_trans) == 0);\n\n\t/* some pending stuffs might be added after the previous flush. */\n\tret = btrfs_run_delayed_items(trans, root);\n\tif (ret)\n\t\tgoto cleanup_transaction;\n\n\tbtrfs_wait_delalloc_flush(root->fs_info);\n\n\tbtrfs_wait_pending_ordered(cur_trans, root->fs_info);\n\n\tbtrfs_scrub_pause(root);\n\t/*\n\t * Ok now we need to make sure to block out any other joins while we\n\t * commit the transaction.  We could have started a join before setting\n\t * COMMIT_DOING so make sure to wait for num_writers to == 1 again.\n\t */\n\tspin_lock(&root->fs_info->trans_lock);\n\tcur_trans->state = TRANS_STATE_COMMIT_DOING;\n\tspin_unlock(&root->fs_info->trans_lock);\n\twait_event(cur_trans->writer_wait,\n\t\t   atomic_read(&cur_trans->num_writers) == 1);\n\n\t/* ->aborted might be set after the previous check, so check it */\n\tif (unlikely(ACCESS_ONCE(cur_trans->aborted))) {\n\t\tret = cur_trans->aborted;\n\t\tgoto scrub_continue;\n\t}\n\t/*\n\t * the reloc mutex makes sure that we stop\n\t * the balancing code from coming in and moving\n\t * extents around in the middle of the commit\n\t */\n\tmutex_lock(&root->fs_info->reloc_mutex);\n\n\t/*\n\t * We needn't worry about the delayed items because we will\n\t * deal with them in create_pending_snapshot(), which is the\n\t * core function of the snapshot creation.\n\t */\n\tret = create_pending_snapshots(trans, root->fs_info);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * We insert the dir indexes of the snapshots and update the inode\n\t * of the snapshots' parents after the snapshot creation, so there\n\t * are some delayed items which are not dealt with. Now deal with\n\t * them.\n\t *\n\t * We needn't worry that this operation will corrupt the snapshots,\n\t * because all the tree which are snapshoted will be forced to COW\n\t * the nodes and leaves.\n\t */\n\tret = btrfs_run_delayed_items(trans, root);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\tret = btrfs_run_delayed_refs(trans, root, (unsigned long)-1);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * make sure none of the code above managed to slip in a\n\t * delayed item\n\t */\n\tbtrfs_assert_delayed_root_empty(root);\n\n\tWARN_ON(cur_trans != trans->transaction);\n\n\t/* btrfs_commit_tree_roots is responsible for getting the\n\t * various roots consistent with each other.  Every pointer\n\t * in the tree of tree roots has to point to the most up to date\n\t * root for every subvolume and other tree.  So, we have to keep\n\t * the tree logging code from jumping in and changing any\n\t * of the trees.\n\t *\n\t * At this point in the commit, there can't be any tree-log\n\t * writers, but a little lower down we drop the trans mutex\n\t * and let new people in.  By holding the tree_log_mutex\n\t * from now until after the super is written, we avoid races\n\t * with the tree-log code.\n\t */\n\tmutex_lock(&root->fs_info->tree_log_mutex);\n\n\tret = commit_fs_roots(trans, root);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * Since the transaction is done, we can apply the pending changes\n\t * before the next transaction.\n\t */\n\tbtrfs_apply_pending_changes(root->fs_info);\n\n\t/* commit_fs_roots gets rid of all the tree log roots, it is now\n\t * safe to free the root of tree log roots\n\t */\n\tbtrfs_free_log_root_tree(trans, root->fs_info);\n\n\tret = commit_cowonly_roots(trans, root);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * The tasks which save the space cache and inode cache may also\n\t * update ->aborted, check it.\n\t */\n\tif (unlikely(ACCESS_ONCE(cur_trans->aborted))) {\n\t\tret = cur_trans->aborted;\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\tbtrfs_prepare_extent_commit(trans, root);\n\n\tcur_trans = root->fs_info->running_transaction;\n\n\tbtrfs_set_root_node(&root->fs_info->tree_root->root_item,\n\t\t\t    root->fs_info->tree_root->node);\n\tlist_add_tail(&root->fs_info->tree_root->dirty_list,\n\t\t      &cur_trans->switch_commits);\n\n\tbtrfs_set_root_node(&root->fs_info->chunk_root->root_item,\n\t\t\t    root->fs_info->chunk_root->node);\n\tlist_add_tail(&root->fs_info->chunk_root->dirty_list,\n\t\t      &cur_trans->switch_commits);\n\n\tswitch_commit_roots(cur_trans, root->fs_info);\n\n\tassert_qgroups_uptodate(trans);\n\tASSERT(list_empty(&cur_trans->dirty_bgs));\n\tupdate_super_roots(root);\n\n\tbtrfs_set_super_log_root(root->fs_info->super_copy, 0);\n\tbtrfs_set_super_log_root_level(root->fs_info->super_copy, 0);\n\tmemcpy(root->fs_info->super_for_commit, root->fs_info->super_copy,\n\t       sizeof(*root->fs_info->super_copy));\n\n\tbtrfs_update_commit_device_size(root->fs_info);\n\tbtrfs_update_commit_device_bytes_used(root, cur_trans);\n\n\tclear_bit(BTRFS_INODE_BTREE_LOG1_ERR, &btree_ino->runtime_flags);\n\tclear_bit(BTRFS_INODE_BTREE_LOG2_ERR, &btree_ino->runtime_flags);\n\n\tspin_lock(&root->fs_info->trans_lock);\n\tcur_trans->state = TRANS_STATE_UNBLOCKED;\n\troot->fs_info->running_transaction = NULL;\n\tspin_unlock(&root->fs_info->trans_lock);\n\tmutex_unlock(&root->fs_info->reloc_mutex);\n\n\twake_up(&root->fs_info->transaction_wait);\n\n\tret = btrfs_write_and_wait_transaction(trans, root);\n\tif (ret) {\n\t\tbtrfs_error(root->fs_info, ret,\n\t\t\t    \"Error while writing out transaction\");\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\tret = write_ctree_super(trans, root, 0);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * the super is written, we can safely allow the tree-loggers\n\t * to go about their business\n\t */\n\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\n\tbtrfs_finish_extent_commit(trans, root);\n\n\tif (cur_trans->have_free_bgs)\n\t\tbtrfs_clear_space_info_full(root->fs_info);\n\n\troot->fs_info->last_trans_committed = cur_trans->transid;\n\t/*\n\t * We needn't acquire the lock here because there is no other task\n\t * which can change it.\n\t */\n\tcur_trans->state = TRANS_STATE_COMPLETED;\n\twake_up(&cur_trans->commit_wait);\n\n\tspin_lock(&root->fs_info->trans_lock);\n\tlist_del_init(&cur_trans->list);\n\tspin_unlock(&root->fs_info->trans_lock);\n\n\tbtrfs_put_transaction(cur_trans);\n\tbtrfs_put_transaction(cur_trans);\n\n\tif (trans->type & __TRANS_FREEZABLE)\n\t\tsb_end_intwrite(root->fs_info->sb);\n\n\ttrace_btrfs_transaction_commit(root);\n\n\tbtrfs_scrub_continue(root);\n\n\tif (current->journal_info == trans)\n\t\tcurrent->journal_info = NULL;\n\n\tkmem_cache_free(btrfs_trans_handle_cachep, trans);\n\n\tif (current != root->fs_info->transaction_kthread)\n\t\tbtrfs_run_delayed_iputs(root);\n\n\treturn ret;\n\nscrub_continue:\n\tbtrfs_scrub_continue(root);\ncleanup_transaction:\n\tbtrfs_trans_release_metadata(trans, root);\n\ttrans->block_rsv = NULL;\n\tif (trans->qgroup_reserved) {\n\t\tbtrfs_qgroup_free(root, trans->qgroup_reserved);\n\t\ttrans->qgroup_reserved = 0;\n\t}\n\tbtrfs_warn(root->fs_info, \"Skipping commit of aborted transaction.\");\n\tif (current->journal_info == trans)\n\t\tcurrent->journal_info = NULL;\n\tcleanup_transaction(trans, root, ret);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"dev-replace.h\"",
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint btrfs_commit_transaction(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root)\n{\n\tstruct btrfs_transaction *cur_trans = trans->transaction;\n\tstruct btrfs_transaction *prev_trans = NULL;\n\tstruct btrfs_inode *btree_ino = BTRFS_I(root->fs_info->btree_inode);\n\tint ret;\n\n\t/* Stop the commit early if ->aborted is set */\n\tif (unlikely(ACCESS_ONCE(cur_trans->aborted))) {\n\t\tret = cur_trans->aborted;\n\t\tbtrfs_end_transaction(trans, root);\n\t\treturn ret;\n\t}\n\n\t/* make a pass through all the delayed refs we have so far\n\t * any runnings procs may add more while we are here\n\t */\n\tret = btrfs_run_delayed_refs(trans, root, 0);\n\tif (ret) {\n\t\tbtrfs_end_transaction(trans, root);\n\t\treturn ret;\n\t}\n\n\tbtrfs_trans_release_metadata(trans, root);\n\ttrans->block_rsv = NULL;\n\tif (trans->qgroup_reserved) {\n\t\tbtrfs_qgroup_free(root, trans->qgroup_reserved);\n\t\ttrans->qgroup_reserved = 0;\n\t}\n\n\tcur_trans = trans->transaction;\n\n\t/*\n\t * set the flushing flag so procs in this transaction have to\n\t * start sending their work down.\n\t */\n\tcur_trans->delayed_refs.flushing = 1;\n\tsmp_wmb();\n\n\tif (!list_empty(&trans->new_bgs))\n\t\tbtrfs_create_pending_block_groups(trans, root);\n\n\tret = btrfs_run_delayed_refs(trans, root, 0);\n\tif (ret) {\n\t\tbtrfs_end_transaction(trans, root);\n\t\treturn ret;\n\t}\n\n\tspin_lock(&root->fs_info->trans_lock);\n\tlist_splice(&trans->ordered, &cur_trans->pending_ordered);\n\tif (cur_trans->state >= TRANS_STATE_COMMIT_START) {\n\t\tspin_unlock(&root->fs_info->trans_lock);\n\t\tatomic_inc(&cur_trans->use_count);\n\t\tret = btrfs_end_transaction(trans, root);\n\n\t\twait_for_commit(root, cur_trans);\n\n\t\tif (unlikely(cur_trans->aborted))\n\t\t\tret = cur_trans->aborted;\n\n\t\tbtrfs_put_transaction(cur_trans);\n\n\t\treturn ret;\n\t}\n\n\tcur_trans->state = TRANS_STATE_COMMIT_START;\n\twake_up(&root->fs_info->transaction_blocked_wait);\n\n\tif (cur_trans->list.prev != &root->fs_info->trans_list) {\n\t\tprev_trans = list_entry(cur_trans->list.prev,\n\t\t\t\t\tstruct btrfs_transaction, list);\n\t\tif (prev_trans->state != TRANS_STATE_COMPLETED) {\n\t\t\tatomic_inc(&prev_trans->use_count);\n\t\t\tspin_unlock(&root->fs_info->trans_lock);\n\n\t\t\twait_for_commit(root, prev_trans);\n\n\t\t\tbtrfs_put_transaction(prev_trans);\n\t\t} else {\n\t\t\tspin_unlock(&root->fs_info->trans_lock);\n\t\t}\n\t} else {\n\t\tspin_unlock(&root->fs_info->trans_lock);\n\t}\n\n\textwriter_counter_dec(cur_trans, trans->type);\n\n\tret = btrfs_start_delalloc_flush(root->fs_info);\n\tif (ret)\n\t\tgoto cleanup_transaction;\n\n\tret = btrfs_run_delayed_items(trans, root);\n\tif (ret)\n\t\tgoto cleanup_transaction;\n\n\twait_event(cur_trans->writer_wait,\n\t\t   extwriter_counter_read(cur_trans) == 0);\n\n\t/* some pending stuffs might be added after the previous flush. */\n\tret = btrfs_run_delayed_items(trans, root);\n\tif (ret)\n\t\tgoto cleanup_transaction;\n\n\tbtrfs_wait_delalloc_flush(root->fs_info);\n\n\tbtrfs_wait_pending_ordered(cur_trans, root->fs_info);\n\n\tbtrfs_scrub_pause(root);\n\t/*\n\t * Ok now we need to make sure to block out any other joins while we\n\t * commit the transaction.  We could have started a join before setting\n\t * COMMIT_DOING so make sure to wait for num_writers to == 1 again.\n\t */\n\tspin_lock(&root->fs_info->trans_lock);\n\tcur_trans->state = TRANS_STATE_COMMIT_DOING;\n\tspin_unlock(&root->fs_info->trans_lock);\n\twait_event(cur_trans->writer_wait,\n\t\t   atomic_read(&cur_trans->num_writers) == 1);\n\n\t/* ->aborted might be set after the previous check, so check it */\n\tif (unlikely(ACCESS_ONCE(cur_trans->aborted))) {\n\t\tret = cur_trans->aborted;\n\t\tgoto scrub_continue;\n\t}\n\t/*\n\t * the reloc mutex makes sure that we stop\n\t * the balancing code from coming in and moving\n\t * extents around in the middle of the commit\n\t */\n\tmutex_lock(&root->fs_info->reloc_mutex);\n\n\t/*\n\t * We needn't worry about the delayed items because we will\n\t * deal with them in create_pending_snapshot(), which is the\n\t * core function of the snapshot creation.\n\t */\n\tret = create_pending_snapshots(trans, root->fs_info);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * We insert the dir indexes of the snapshots and update the inode\n\t * of the snapshots' parents after the snapshot creation, so there\n\t * are some delayed items which are not dealt with. Now deal with\n\t * them.\n\t *\n\t * We needn't worry that this operation will corrupt the snapshots,\n\t * because all the tree which are snapshoted will be forced to COW\n\t * the nodes and leaves.\n\t */\n\tret = btrfs_run_delayed_items(trans, root);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\tret = btrfs_run_delayed_refs(trans, root, (unsigned long)-1);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * make sure none of the code above managed to slip in a\n\t * delayed item\n\t */\n\tbtrfs_assert_delayed_root_empty(root);\n\n\tWARN_ON(cur_trans != trans->transaction);\n\n\t/* btrfs_commit_tree_roots is responsible for getting the\n\t * various roots consistent with each other.  Every pointer\n\t * in the tree of tree roots has to point to the most up to date\n\t * root for every subvolume and other tree.  So, we have to keep\n\t * the tree logging code from jumping in and changing any\n\t * of the trees.\n\t *\n\t * At this point in the commit, there can't be any tree-log\n\t * writers, but a little lower down we drop the trans mutex\n\t * and let new people in.  By holding the tree_log_mutex\n\t * from now until after the super is written, we avoid races\n\t * with the tree-log code.\n\t */\n\tmutex_lock(&root->fs_info->tree_log_mutex);\n\n\tret = commit_fs_roots(trans, root);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * Since the transaction is done, we can apply the pending changes\n\t * before the next transaction.\n\t */\n\tbtrfs_apply_pending_changes(root->fs_info);\n\n\t/* commit_fs_roots gets rid of all the tree log roots, it is now\n\t * safe to free the root of tree log roots\n\t */\n\tbtrfs_free_log_root_tree(trans, root->fs_info);\n\n\tret = commit_cowonly_roots(trans, root);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * The tasks which save the space cache and inode cache may also\n\t * update ->aborted, check it.\n\t */\n\tif (unlikely(ACCESS_ONCE(cur_trans->aborted))) {\n\t\tret = cur_trans->aborted;\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\tbtrfs_prepare_extent_commit(trans, root);\n\n\tcur_trans = root->fs_info->running_transaction;\n\n\tbtrfs_set_root_node(&root->fs_info->tree_root->root_item,\n\t\t\t    root->fs_info->tree_root->node);\n\tlist_add_tail(&root->fs_info->tree_root->dirty_list,\n\t\t      &cur_trans->switch_commits);\n\n\tbtrfs_set_root_node(&root->fs_info->chunk_root->root_item,\n\t\t\t    root->fs_info->chunk_root->node);\n\tlist_add_tail(&root->fs_info->chunk_root->dirty_list,\n\t\t      &cur_trans->switch_commits);\n\n\tswitch_commit_roots(cur_trans, root->fs_info);\n\n\tassert_qgroups_uptodate(trans);\n\tASSERT(list_empty(&cur_trans->dirty_bgs));\n\tupdate_super_roots(root);\n\n\tbtrfs_set_super_log_root(root->fs_info->super_copy, 0);\n\tbtrfs_set_super_log_root_level(root->fs_info->super_copy, 0);\n\tmemcpy(root->fs_info->super_for_commit, root->fs_info->super_copy,\n\t       sizeof(*root->fs_info->super_copy));\n\n\tbtrfs_update_commit_device_size(root->fs_info);\n\tbtrfs_update_commit_device_bytes_used(root, cur_trans);\n\n\tclear_bit(BTRFS_INODE_BTREE_LOG1_ERR, &btree_ino->runtime_flags);\n\tclear_bit(BTRFS_INODE_BTREE_LOG2_ERR, &btree_ino->runtime_flags);\n\n\tspin_lock(&root->fs_info->trans_lock);\n\tcur_trans->state = TRANS_STATE_UNBLOCKED;\n\troot->fs_info->running_transaction = NULL;\n\tspin_unlock(&root->fs_info->trans_lock);\n\tmutex_unlock(&root->fs_info->reloc_mutex);\n\n\twake_up(&root->fs_info->transaction_wait);\n\n\tret = btrfs_write_and_wait_transaction(trans, root);\n\tif (ret) {\n\t\tbtrfs_error(root->fs_info, ret,\n\t\t\t    \"Error while writing out transaction\");\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\tret = write_ctree_super(trans, root, 0);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * the super is written, we can safely allow the tree-loggers\n\t * to go about their business\n\t */\n\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\n\tbtrfs_finish_extent_commit(trans, root);\n\n\tif (cur_trans->have_free_bgs)\n\t\tbtrfs_clear_space_info_full(root->fs_info);\n\n\troot->fs_info->last_trans_committed = cur_trans->transid;\n\t/*\n\t * We needn't acquire the lock here because there is no other task\n\t * which can change it.\n\t */\n\tcur_trans->state = TRANS_STATE_COMPLETED;\n\twake_up(&cur_trans->commit_wait);\n\n\tspin_lock(&root->fs_info->trans_lock);\n\tlist_del_init(&cur_trans->list);\n\tspin_unlock(&root->fs_info->trans_lock);\n\n\tbtrfs_put_transaction(cur_trans);\n\tbtrfs_put_transaction(cur_trans);\n\n\tif (trans->type & __TRANS_FREEZABLE)\n\t\tsb_end_intwrite(root->fs_info->sb);\n\n\ttrace_btrfs_transaction_commit(root);\n\n\tbtrfs_scrub_continue(root);\n\n\tif (current->journal_info == trans)\n\t\tcurrent->journal_info = NULL;\n\n\tkmem_cache_free(btrfs_trans_handle_cachep, trans);\n\n\tif (current != root->fs_info->transaction_kthread)\n\t\tbtrfs_run_delayed_iputs(root);\n\n\treturn ret;\n\nscrub_continue:\n\tbtrfs_scrub_continue(root);\ncleanup_transaction:\n\tbtrfs_trans_release_metadata(trans, root);\n\ttrans->block_rsv = NULL;\n\tif (trans->qgroup_reserved) {\n\t\tbtrfs_qgroup_free(root, trans->qgroup_reserved);\n\t\ttrans->qgroup_reserved = 0;\n\t}\n\tbtrfs_warn(root->fs_info, \"Skipping commit of aborted transaction.\");\n\tif (current->journal_info == trans)\n\t\tcurrent->journal_info = NULL;\n\tcleanup_transaction(trans, root, ret);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rwsem_acquire_read",
          "args": [
            "&ac->root->fs_info->sb->s_writers.lock_map[SB_FREEZE_FS-1]",
            "0",
            "1",
            "_THIS_IP_"
          ],
          "line": 1617
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "work",
            "structbtrfs_async_commit",
            "work"
          ],
          "line": 1610
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void do_async_commit(struct work_struct *work)\n{\n\tstruct btrfs_async_commit *ac =\n\t\tcontainer_of(work, struct btrfs_async_commit, work);\n\n\t/*\n\t * We've got freeze protection passed with the transaction.\n\t * Tell lockdep about it.\n\t */\n\tif (ac->newtrans->type & __TRANS_FREEZABLE)\n\t\trwsem_acquire_read(\n\t\t     &ac->root->fs_info->sb->s_writers.lock_map[SB_FREEZE_FS-1],\n\t\t     0, 1, _THIS_IP_);\n\n\tcurrent->journal_info = ac->newtrans;\n\n\tbtrfs_commit_transaction(ac->newtrans, ac->root);\n\tkfree(ac);\n}"
  },
  {
    "function_name": "wait_current_trans_commit_start_and_unblock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
    "lines": "1589-1595",
    "snippet": "static void wait_current_trans_commit_start_and_unblock(struct btrfs_root *root,\n\t\t\t\t\t struct btrfs_transaction *trans)\n{\n\twait_event(root->fs_info->transaction_wait,\n\t\t   trans->state >= TRANS_STATE_UNBLOCKED ||\n\t\t   trans->aborted);\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"dev-replace.h\"",
      "#include \"volumes.h\"",
      "#include \"inode-map.h\"",
      "#include \"tree-log.h\"",
      "#include \"locking.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/uuid.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/writeback.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wait_event",
          "args": [
            "root->fs_info->transaction_wait",
            "trans->state >= TRANS_STATE_UNBLOCKED ||\n\t\t   trans->aborted"
          ],
          "line": 1592
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void wait_current_trans_commit_start_and_unblock(struct btrfs_root *root,\n\t\t\t\t\t struct btrfs_transaction *trans)\n{\n\twait_event(root->fs_info->transaction_wait,\n\t\t   trans->state >= TRANS_STATE_UNBLOCKED ||\n\t\t   trans->aborted);\n}"
  },
  {
    "function_name": "wait_current_trans_commit_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
    "lines": "1577-1583",
    "snippet": "static void wait_current_trans_commit_start(struct btrfs_root *root,\n\t\t\t\t\t    struct btrfs_transaction *trans)\n{\n\twait_event(root->fs_info->transaction_blocked_wait,\n\t\t   trans->state >= TRANS_STATE_COMMIT_START ||\n\t\t   trans->aborted);\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"dev-replace.h\"",
      "#include \"volumes.h\"",
      "#include \"inode-map.h\"",
      "#include \"tree-log.h\"",
      "#include \"locking.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/uuid.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/writeback.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wait_event",
          "args": [
            "root->fs_info->transaction_blocked_wait",
            "trans->state >= TRANS_STATE_COMMIT_START ||\n\t\t   trans->aborted"
          ],
          "line": 1580
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void wait_current_trans_commit_start(struct btrfs_root *root,\n\t\t\t\t\t    struct btrfs_transaction *trans)\n{\n\twait_event(root->fs_info->transaction_blocked_wait,\n\t\t   trans->state >= TRANS_STATE_COMMIT_START ||\n\t\t   trans->aborted);\n}"
  },
  {
    "function_name": "btrfs_transaction_blocked",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
    "lines": "1560-1571",
    "snippet": "int btrfs_transaction_blocked(struct btrfs_fs_info *info)\n{\n\tstruct btrfs_transaction *trans;\n\tint ret = 0;\n\n\tspin_lock(&info->trans_lock);\n\ttrans = info->running_transaction;\n\tif (trans)\n\t\tret = is_transaction_blocked(trans);\n\tspin_unlock(&info->trans_lock);\n\treturn ret;\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"dev-replace.h\"",
      "#include \"volumes.h\"",
      "#include \"inode-map.h\"",
      "#include \"tree-log.h\"",
      "#include \"locking.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/uuid.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/writeback.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&info->trans_lock"
          ],
          "line": 1569
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_transaction_blocked",
          "args": [
            "trans"
          ],
          "line": 1568
        },
        "resolved": true,
        "details": {
          "function_name": "is_transaction_blocked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
          "lines": "352-357",
          "snippet": "static inline int is_transaction_blocked(struct btrfs_transaction *trans)\n{\n\treturn (trans->state >= TRANS_STATE_BLOCKED &&\n\t\ttrans->state < TRANS_STATE_UNBLOCKED &&\n\t\t!trans->aborted);\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"dev-replace.h\"",
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic inline int is_transaction_blocked(struct btrfs_transaction *trans)\n{\n\treturn (trans->state >= TRANS_STATE_BLOCKED &&\n\t\ttrans->state < TRANS_STATE_UNBLOCKED &&\n\t\t!trans->aborted);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&info->trans_lock"
          ],
          "line": 1565
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint btrfs_transaction_blocked(struct btrfs_fs_info *info)\n{\n\tstruct btrfs_transaction *trans;\n\tint ret = 0;\n\n\tspin_lock(&info->trans_lock);\n\ttrans = info->running_transaction;\n\tif (trans)\n\t\tret = is_transaction_blocked(trans);\n\tspin_unlock(&info->trans_lock);\n\treturn ret;\n}"
  },
  {
    "function_name": "btrfs_transaction_in_commit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
    "lines": "1547-1558",
    "snippet": "int btrfs_transaction_in_commit(struct btrfs_fs_info *info)\n{\n\tstruct btrfs_transaction *trans;\n\tint ret = 0;\n\n\tspin_lock(&info->trans_lock);\n\ttrans = info->running_transaction;\n\tif (trans)\n\t\tret = (trans->state >= TRANS_STATE_COMMIT_START);\n\tspin_unlock(&info->trans_lock);\n\treturn ret;\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"dev-replace.h\"",
      "#include \"volumes.h\"",
      "#include \"inode-map.h\"",
      "#include \"tree-log.h\"",
      "#include \"locking.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/uuid.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/writeback.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&info->trans_lock"
          ],
          "line": 1556
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&info->trans_lock"
          ],
          "line": 1552
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint btrfs_transaction_in_commit(struct btrfs_fs_info *info)\n{\n\tstruct btrfs_transaction *trans;\n\tint ret = 0;\n\n\tspin_lock(&info->trans_lock);\n\ttrans = info->running_transaction;\n\tif (trans)\n\t\tret = (trans->state >= TRANS_STATE_COMMIT_START);\n\tspin_unlock(&info->trans_lock);\n\treturn ret;\n}"
  },
  {
    "function_name": "update_super_roots",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
    "lines": "1525-1545",
    "snippet": "static void update_super_roots(struct btrfs_root *root)\n{\n\tstruct btrfs_root_item *root_item;\n\tstruct btrfs_super_block *super;\n\n\tsuper = root->fs_info->super_copy;\n\n\troot_item = &root->fs_info->chunk_root->root_item;\n\tsuper->chunk_root = root_item->bytenr;\n\tsuper->chunk_root_generation = root_item->generation;\n\tsuper->chunk_root_level = root_item->level;\n\n\troot_item = &root->fs_info->tree_root->root_item;\n\tsuper->root = root_item->bytenr;\n\tsuper->generation = root_item->generation;\n\tsuper->root_level = root_item->level;\n\tif (btrfs_test_opt(root, SPACE_CACHE))\n\t\tsuper->cache_generation = root_item->generation;\n\tif (root->fs_info->update_uuid_tree_gen)\n\t\tsuper->uuid_tree_generation = root_item->generation;\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"dev-replace.h\"",
      "#include \"volumes.h\"",
      "#include \"inode-map.h\"",
      "#include \"tree-log.h\"",
      "#include \"locking.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/uuid.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/writeback.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_test_opt",
          "args": [
            "root",
            "SPACE_CACHE"
          ],
          "line": 1541
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void update_super_roots(struct btrfs_root *root)\n{\n\tstruct btrfs_root_item *root_item;\n\tstruct btrfs_super_block *super;\n\n\tsuper = root->fs_info->super_copy;\n\n\troot_item = &root->fs_info->chunk_root->root_item;\n\tsuper->chunk_root = root_item->bytenr;\n\tsuper->chunk_root_generation = root_item->generation;\n\tsuper->chunk_root_level = root_item->level;\n\n\troot_item = &root->fs_info->tree_root->root_item;\n\tsuper->root = root_item->bytenr;\n\tsuper->generation = root_item->generation;\n\tsuper->root_level = root_item->level;\n\tif (btrfs_test_opt(root, SPACE_CACHE))\n\t\tsuper->cache_generation = root_item->generation;\n\tif (root->fs_info->update_uuid_tree_gen)\n\t\tsuper->uuid_tree_generation = root_item->generation;\n}"
  },
  {
    "function_name": "create_pending_snapshots",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
    "lines": "1509-1523",
    "snippet": "static noinline int create_pending_snapshots(struct btrfs_trans_handle *trans,\n\t\t\t\t\t     struct btrfs_fs_info *fs_info)\n{\n\tstruct btrfs_pending_snapshot *pending, *next;\n\tstruct list_head *head = &trans->transaction->pending_snapshots;\n\tint ret = 0;\n\n\tlist_for_each_entry_safe(pending, next, head, list) {\n\t\tlist_del(&pending->list);\n\t\tret = create_pending_snapshot(trans, fs_info, pending);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"dev-replace.h\"",
      "#include \"volumes.h\"",
      "#include \"inode-map.h\"",
      "#include \"tree-log.h\"",
      "#include \"locking.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/uuid.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/writeback.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "create_pending_snapshot",
          "args": [
            "trans",
            "fs_info",
            "pending"
          ],
          "line": 1518
        },
        "resolved": true,
        "details": {
          "function_name": "create_pending_snapshot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
          "lines": "1247-1504",
          "snippet": "static noinline int create_pending_snapshot(struct btrfs_trans_handle *trans,\n\t\t\t\t   struct btrfs_fs_info *fs_info,\n\t\t\t\t   struct btrfs_pending_snapshot *pending)\n{\n\tstruct btrfs_key key;\n\tstruct btrfs_root_item *new_root_item;\n\tstruct btrfs_root *tree_root = fs_info->tree_root;\n\tstruct btrfs_root *root = pending->root;\n\tstruct btrfs_root *parent_root;\n\tstruct btrfs_block_rsv *rsv;\n\tstruct inode *parent_inode;\n\tstruct btrfs_path *path;\n\tstruct btrfs_dir_item *dir_item;\n\tstruct dentry *dentry;\n\tstruct extent_buffer *tmp;\n\tstruct extent_buffer *old;\n\tstruct timespec cur_time = CURRENT_TIME;\n\tint ret = 0;\n\tu64 to_reserve = 0;\n\tu64 index = 0;\n\tu64 objectid;\n\tu64 root_flags;\n\tuuid_le new_uuid;\n\n\tpath = btrfs_alloc_path();\n\tif (!path) {\n\t\tpending->error = -ENOMEM;\n\t\treturn 0;\n\t}\n\n\tnew_root_item = kmalloc(sizeof(*new_root_item), GFP_NOFS);\n\tif (!new_root_item) {\n\t\tpending->error = -ENOMEM;\n\t\tgoto root_item_alloc_fail;\n\t}\n\n\tpending->error = btrfs_find_free_objectid(tree_root, &objectid);\n\tif (pending->error)\n\t\tgoto no_free_objectid;\n\n\tbtrfs_reloc_pre_snapshot(trans, pending, &to_reserve);\n\n\tif (to_reserve > 0) {\n\t\tpending->error = btrfs_block_rsv_add(root,\n\t\t\t\t\t\t     &pending->block_rsv,\n\t\t\t\t\t\t     to_reserve,\n\t\t\t\t\t\t     BTRFS_RESERVE_NO_FLUSH);\n\t\tif (pending->error)\n\t\t\tgoto no_free_objectid;\n\t}\n\n\tkey.objectid = objectid;\n\tkey.offset = (u64)-1;\n\tkey.type = BTRFS_ROOT_ITEM_KEY;\n\n\trsv = trans->block_rsv;\n\ttrans->block_rsv = &pending->block_rsv;\n\ttrans->bytes_reserved = trans->block_rsv->reserved;\n\n\tdentry = pending->dentry;\n\tparent_inode = pending->dir;\n\tparent_root = BTRFS_I(parent_inode)->root;\n\trecord_root_in_trans(trans, parent_root);\n\n\t/*\n\t * insert the directory item\n\t */\n\tret = btrfs_set_inode_index(parent_inode, &index);\n\tBUG_ON(ret); /* -ENOMEM */\n\n\t/* check if there is a file/dir which has the same name. */\n\tdir_item = btrfs_lookup_dir_item(NULL, parent_root, path,\n\t\t\t\t\t btrfs_ino(parent_inode),\n\t\t\t\t\t dentry->d_name.name,\n\t\t\t\t\t dentry->d_name.len, 0);\n\tif (dir_item != NULL && !IS_ERR(dir_item)) {\n\t\tpending->error = -EEXIST;\n\t\tgoto dir_item_existed;\n\t} else if (IS_ERR(dir_item)) {\n\t\tret = PTR_ERR(dir_item);\n\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\tgoto fail;\n\t}\n\tbtrfs_release_path(path);\n\n\t/*\n\t * pull in the delayed directory update\n\t * and the delayed inode item\n\t * otherwise we corrupt the FS during\n\t * snapshot\n\t */\n\tret = btrfs_run_delayed_items(trans, root);\n\tif (ret) {\t/* Transaction aborted */\n\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\tgoto fail;\n\t}\n\n\trecord_root_in_trans(trans, root);\n\tbtrfs_set_root_last_snapshot(&root->root_item, trans->transid);\n\tmemcpy(new_root_item, &root->root_item, sizeof(*new_root_item));\n\tbtrfs_check_and_init_root_item(new_root_item);\n\n\troot_flags = btrfs_root_flags(new_root_item);\n\tif (pending->readonly)\n\t\troot_flags |= BTRFS_ROOT_SUBVOL_RDONLY;\n\telse\n\t\troot_flags &= ~BTRFS_ROOT_SUBVOL_RDONLY;\n\tbtrfs_set_root_flags(new_root_item, root_flags);\n\n\tbtrfs_set_root_generation_v2(new_root_item,\n\t\t\ttrans->transid);\n\tuuid_le_gen(&new_uuid);\n\tmemcpy(new_root_item->uuid, new_uuid.b, BTRFS_UUID_SIZE);\n\tmemcpy(new_root_item->parent_uuid, root->root_item.uuid,\n\t\t\tBTRFS_UUID_SIZE);\n\tif (!(root_flags & BTRFS_ROOT_SUBVOL_RDONLY)) {\n\t\tmemset(new_root_item->received_uuid, 0,\n\t\t       sizeof(new_root_item->received_uuid));\n\t\tmemset(&new_root_item->stime, 0, sizeof(new_root_item->stime));\n\t\tmemset(&new_root_item->rtime, 0, sizeof(new_root_item->rtime));\n\t\tbtrfs_set_root_stransid(new_root_item, 0);\n\t\tbtrfs_set_root_rtransid(new_root_item, 0);\n\t}\n\tbtrfs_set_stack_timespec_sec(&new_root_item->otime, cur_time.tv_sec);\n\tbtrfs_set_stack_timespec_nsec(&new_root_item->otime, cur_time.tv_nsec);\n\tbtrfs_set_root_otransid(new_root_item, trans->transid);\n\n\told = btrfs_lock_root_node(root);\n\tret = btrfs_cow_block(trans, root, old, NULL, 0, &old);\n\tif (ret) {\n\t\tbtrfs_tree_unlock(old);\n\t\tfree_extent_buffer(old);\n\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\tgoto fail;\n\t}\n\n\tbtrfs_set_lock_blocking(old);\n\n\tret = btrfs_copy_root(trans, root, old, &tmp, objectid);\n\t/* clean up in any case */\n\tbtrfs_tree_unlock(old);\n\tfree_extent_buffer(old);\n\tif (ret) {\n\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\tgoto fail;\n\t}\n\n\t/*\n\t * We need to flush delayed refs in order to make sure all of our quota\n\t * operations have been done before we call btrfs_qgroup_inherit.\n\t */\n\tret = btrfs_run_delayed_refs(trans, root, (unsigned long)-1);\n\tif (ret) {\n\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\tgoto fail;\n\t}\n\n\tret = btrfs_qgroup_inherit(trans, fs_info,\n\t\t\t\t   root->root_key.objectid,\n\t\t\t\t   objectid, pending->inherit);\n\tif (ret) {\n\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\tgoto fail;\n\t}\n\n\t/* see comments in should_cow_block() */\n\tset_bit(BTRFS_ROOT_FORCE_COW, &root->state);\n\tsmp_wmb();\n\n\tbtrfs_set_root_node(new_root_item, tmp);\n\t/* record when the snapshot was created in key.offset */\n\tkey.offset = trans->transid;\n\tret = btrfs_insert_root(trans, tree_root, &key, new_root_item);\n\tbtrfs_tree_unlock(tmp);\n\tfree_extent_buffer(tmp);\n\tif (ret) {\n\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\tgoto fail;\n\t}\n\n\t/*\n\t * insert root back/forward references\n\t */\n\tret = btrfs_add_root_ref(trans, tree_root, objectid,\n\t\t\t\t parent_root->root_key.objectid,\n\t\t\t\t btrfs_ino(parent_inode), index,\n\t\t\t\t dentry->d_name.name, dentry->d_name.len);\n\tif (ret) {\n\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\tgoto fail;\n\t}\n\n\tkey.offset = (u64)-1;\n\tpending->snap = btrfs_read_fs_root_no_name(root->fs_info, &key);\n\tif (IS_ERR(pending->snap)) {\n\t\tret = PTR_ERR(pending->snap);\n\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\tgoto fail;\n\t}\n\n\tret = btrfs_reloc_post_snapshot(trans, pending);\n\tif (ret) {\n\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\tgoto fail;\n\t}\n\n\tret = btrfs_run_delayed_refs(trans, root, (unsigned long)-1);\n\tif (ret) {\n\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\tgoto fail;\n\t}\n\n\tret = btrfs_insert_dir_item(trans, parent_root,\n\t\t\t\t    dentry->d_name.name, dentry->d_name.len,\n\t\t\t\t    parent_inode, &key,\n\t\t\t\t    BTRFS_FT_DIR, index);\n\t/* We have check then name at the beginning, so it is impossible. */\n\tBUG_ON(ret == -EEXIST || ret == -EOVERFLOW);\n\tif (ret) {\n\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\tgoto fail;\n\t}\n\n\tbtrfs_i_size_write(parent_inode, parent_inode->i_size +\n\t\t\t\t\t dentry->d_name.len * 2);\n\tparent_inode->i_mtime = parent_inode->i_ctime = CURRENT_TIME;\n\tret = btrfs_update_inode_fallback(trans, parent_root, parent_inode);\n\tif (ret) {\n\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\tgoto fail;\n\t}\n\tret = btrfs_uuid_tree_add(trans, fs_info->uuid_root, new_uuid.b,\n\t\t\t\t  BTRFS_UUID_KEY_SUBVOL, objectid);\n\tif (ret) {\n\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\tgoto fail;\n\t}\n\tif (!btrfs_is_empty_uuid(new_root_item->received_uuid)) {\n\t\tret = btrfs_uuid_tree_add(trans, fs_info->uuid_root,\n\t\t\t\t\t  new_root_item->received_uuid,\n\t\t\t\t\t  BTRFS_UUID_KEY_RECEIVED_SUBVOL,\n\t\t\t\t\t  objectid);\n\t\tif (ret && ret != -EEXIST) {\n\t\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\t\tgoto fail;\n\t\t}\n\t}\nfail:\n\tpending->error = ret;\ndir_item_existed:\n\ttrans->block_rsv = rsv;\n\ttrans->bytes_reserved = 0;\nno_free_objectid:\n\tkfree(new_root_item);\nroot_item_alloc_fail:\n\tbtrfs_free_path(path);\n\treturn ret;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"dev-replace.h\"",
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic noinline int create_pending_snapshot(struct btrfs_trans_handle *trans,\n\t\t\t\t   struct btrfs_fs_info *fs_info,\n\t\t\t\t   struct btrfs_pending_snapshot *pending)\n{\n\tstruct btrfs_key key;\n\tstruct btrfs_root_item *new_root_item;\n\tstruct btrfs_root *tree_root = fs_info->tree_root;\n\tstruct btrfs_root *root = pending->root;\n\tstruct btrfs_root *parent_root;\n\tstruct btrfs_block_rsv *rsv;\n\tstruct inode *parent_inode;\n\tstruct btrfs_path *path;\n\tstruct btrfs_dir_item *dir_item;\n\tstruct dentry *dentry;\n\tstruct extent_buffer *tmp;\n\tstruct extent_buffer *old;\n\tstruct timespec cur_time = CURRENT_TIME;\n\tint ret = 0;\n\tu64 to_reserve = 0;\n\tu64 index = 0;\n\tu64 objectid;\n\tu64 root_flags;\n\tuuid_le new_uuid;\n\n\tpath = btrfs_alloc_path();\n\tif (!path) {\n\t\tpending->error = -ENOMEM;\n\t\treturn 0;\n\t}\n\n\tnew_root_item = kmalloc(sizeof(*new_root_item), GFP_NOFS);\n\tif (!new_root_item) {\n\t\tpending->error = -ENOMEM;\n\t\tgoto root_item_alloc_fail;\n\t}\n\n\tpending->error = btrfs_find_free_objectid(tree_root, &objectid);\n\tif (pending->error)\n\t\tgoto no_free_objectid;\n\n\tbtrfs_reloc_pre_snapshot(trans, pending, &to_reserve);\n\n\tif (to_reserve > 0) {\n\t\tpending->error = btrfs_block_rsv_add(root,\n\t\t\t\t\t\t     &pending->block_rsv,\n\t\t\t\t\t\t     to_reserve,\n\t\t\t\t\t\t     BTRFS_RESERVE_NO_FLUSH);\n\t\tif (pending->error)\n\t\t\tgoto no_free_objectid;\n\t}\n\n\tkey.objectid = objectid;\n\tkey.offset = (u64)-1;\n\tkey.type = BTRFS_ROOT_ITEM_KEY;\n\n\trsv = trans->block_rsv;\n\ttrans->block_rsv = &pending->block_rsv;\n\ttrans->bytes_reserved = trans->block_rsv->reserved;\n\n\tdentry = pending->dentry;\n\tparent_inode = pending->dir;\n\tparent_root = BTRFS_I(parent_inode)->root;\n\trecord_root_in_trans(trans, parent_root);\n\n\t/*\n\t * insert the directory item\n\t */\n\tret = btrfs_set_inode_index(parent_inode, &index);\n\tBUG_ON(ret); /* -ENOMEM */\n\n\t/* check if there is a file/dir which has the same name. */\n\tdir_item = btrfs_lookup_dir_item(NULL, parent_root, path,\n\t\t\t\t\t btrfs_ino(parent_inode),\n\t\t\t\t\t dentry->d_name.name,\n\t\t\t\t\t dentry->d_name.len, 0);\n\tif (dir_item != NULL && !IS_ERR(dir_item)) {\n\t\tpending->error = -EEXIST;\n\t\tgoto dir_item_existed;\n\t} else if (IS_ERR(dir_item)) {\n\t\tret = PTR_ERR(dir_item);\n\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\tgoto fail;\n\t}\n\tbtrfs_release_path(path);\n\n\t/*\n\t * pull in the delayed directory update\n\t * and the delayed inode item\n\t * otherwise we corrupt the FS during\n\t * snapshot\n\t */\n\tret = btrfs_run_delayed_items(trans, root);\n\tif (ret) {\t/* Transaction aborted */\n\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\tgoto fail;\n\t}\n\n\trecord_root_in_trans(trans, root);\n\tbtrfs_set_root_last_snapshot(&root->root_item, trans->transid);\n\tmemcpy(new_root_item, &root->root_item, sizeof(*new_root_item));\n\tbtrfs_check_and_init_root_item(new_root_item);\n\n\troot_flags = btrfs_root_flags(new_root_item);\n\tif (pending->readonly)\n\t\troot_flags |= BTRFS_ROOT_SUBVOL_RDONLY;\n\telse\n\t\troot_flags &= ~BTRFS_ROOT_SUBVOL_RDONLY;\n\tbtrfs_set_root_flags(new_root_item, root_flags);\n\n\tbtrfs_set_root_generation_v2(new_root_item,\n\t\t\ttrans->transid);\n\tuuid_le_gen(&new_uuid);\n\tmemcpy(new_root_item->uuid, new_uuid.b, BTRFS_UUID_SIZE);\n\tmemcpy(new_root_item->parent_uuid, root->root_item.uuid,\n\t\t\tBTRFS_UUID_SIZE);\n\tif (!(root_flags & BTRFS_ROOT_SUBVOL_RDONLY)) {\n\t\tmemset(new_root_item->received_uuid, 0,\n\t\t       sizeof(new_root_item->received_uuid));\n\t\tmemset(&new_root_item->stime, 0, sizeof(new_root_item->stime));\n\t\tmemset(&new_root_item->rtime, 0, sizeof(new_root_item->rtime));\n\t\tbtrfs_set_root_stransid(new_root_item, 0);\n\t\tbtrfs_set_root_rtransid(new_root_item, 0);\n\t}\n\tbtrfs_set_stack_timespec_sec(&new_root_item->otime, cur_time.tv_sec);\n\tbtrfs_set_stack_timespec_nsec(&new_root_item->otime, cur_time.tv_nsec);\n\tbtrfs_set_root_otransid(new_root_item, trans->transid);\n\n\told = btrfs_lock_root_node(root);\n\tret = btrfs_cow_block(trans, root, old, NULL, 0, &old);\n\tif (ret) {\n\t\tbtrfs_tree_unlock(old);\n\t\tfree_extent_buffer(old);\n\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\tgoto fail;\n\t}\n\n\tbtrfs_set_lock_blocking(old);\n\n\tret = btrfs_copy_root(trans, root, old, &tmp, objectid);\n\t/* clean up in any case */\n\tbtrfs_tree_unlock(old);\n\tfree_extent_buffer(old);\n\tif (ret) {\n\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\tgoto fail;\n\t}\n\n\t/*\n\t * We need to flush delayed refs in order to make sure all of our quota\n\t * operations have been done before we call btrfs_qgroup_inherit.\n\t */\n\tret = btrfs_run_delayed_refs(trans, root, (unsigned long)-1);\n\tif (ret) {\n\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\tgoto fail;\n\t}\n\n\tret = btrfs_qgroup_inherit(trans, fs_info,\n\t\t\t\t   root->root_key.objectid,\n\t\t\t\t   objectid, pending->inherit);\n\tif (ret) {\n\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\tgoto fail;\n\t}\n\n\t/* see comments in should_cow_block() */\n\tset_bit(BTRFS_ROOT_FORCE_COW, &root->state);\n\tsmp_wmb();\n\n\tbtrfs_set_root_node(new_root_item, tmp);\n\t/* record when the snapshot was created in key.offset */\n\tkey.offset = trans->transid;\n\tret = btrfs_insert_root(trans, tree_root, &key, new_root_item);\n\tbtrfs_tree_unlock(tmp);\n\tfree_extent_buffer(tmp);\n\tif (ret) {\n\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\tgoto fail;\n\t}\n\n\t/*\n\t * insert root back/forward references\n\t */\n\tret = btrfs_add_root_ref(trans, tree_root, objectid,\n\t\t\t\t parent_root->root_key.objectid,\n\t\t\t\t btrfs_ino(parent_inode), index,\n\t\t\t\t dentry->d_name.name, dentry->d_name.len);\n\tif (ret) {\n\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\tgoto fail;\n\t}\n\n\tkey.offset = (u64)-1;\n\tpending->snap = btrfs_read_fs_root_no_name(root->fs_info, &key);\n\tif (IS_ERR(pending->snap)) {\n\t\tret = PTR_ERR(pending->snap);\n\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\tgoto fail;\n\t}\n\n\tret = btrfs_reloc_post_snapshot(trans, pending);\n\tif (ret) {\n\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\tgoto fail;\n\t}\n\n\tret = btrfs_run_delayed_refs(trans, root, (unsigned long)-1);\n\tif (ret) {\n\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\tgoto fail;\n\t}\n\n\tret = btrfs_insert_dir_item(trans, parent_root,\n\t\t\t\t    dentry->d_name.name, dentry->d_name.len,\n\t\t\t\t    parent_inode, &key,\n\t\t\t\t    BTRFS_FT_DIR, index);\n\t/* We have check then name at the beginning, so it is impossible. */\n\tBUG_ON(ret == -EEXIST || ret == -EOVERFLOW);\n\tif (ret) {\n\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\tgoto fail;\n\t}\n\n\tbtrfs_i_size_write(parent_inode, parent_inode->i_size +\n\t\t\t\t\t dentry->d_name.len * 2);\n\tparent_inode->i_mtime = parent_inode->i_ctime = CURRENT_TIME;\n\tret = btrfs_update_inode_fallback(trans, parent_root, parent_inode);\n\tif (ret) {\n\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\tgoto fail;\n\t}\n\tret = btrfs_uuid_tree_add(trans, fs_info->uuid_root, new_uuid.b,\n\t\t\t\t  BTRFS_UUID_KEY_SUBVOL, objectid);\n\tif (ret) {\n\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\tgoto fail;\n\t}\n\tif (!btrfs_is_empty_uuid(new_root_item->received_uuid)) {\n\t\tret = btrfs_uuid_tree_add(trans, fs_info->uuid_root,\n\t\t\t\t\t  new_root_item->received_uuid,\n\t\t\t\t\t  BTRFS_UUID_KEY_RECEIVED_SUBVOL,\n\t\t\t\t\t  objectid);\n\t\tif (ret && ret != -EEXIST) {\n\t\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\t\tgoto fail;\n\t\t}\n\t}\nfail:\n\tpending->error = ret;\ndir_item_existed:\n\ttrans->block_rsv = rsv;\n\ttrans->bytes_reserved = 0;\nno_free_objectid:\n\tkfree(new_root_item);\nroot_item_alloc_fail:\n\tbtrfs_free_path(path);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&pending->list"
          ],
          "line": 1517
        },
        "resolved": true,
        "details": {
          "function_name": "inode_sb_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "433-440",
          "snippet": "static inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\n__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "pending",
            "next",
            "head",
            "list"
          ],
          "line": 1516
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic noinline int create_pending_snapshots(struct btrfs_trans_handle *trans,\n\t\t\t\t\t     struct btrfs_fs_info *fs_info)\n{\n\tstruct btrfs_pending_snapshot *pending, *next;\n\tstruct list_head *head = &trans->transaction->pending_snapshots;\n\tint ret = 0;\n\n\tlist_for_each_entry_safe(pending, next, head, list) {\n\t\tlist_del(&pending->list);\n\t\tret = create_pending_snapshot(trans, fs_info, pending);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "create_pending_snapshot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
    "lines": "1247-1504",
    "snippet": "static noinline int create_pending_snapshot(struct btrfs_trans_handle *trans,\n\t\t\t\t   struct btrfs_fs_info *fs_info,\n\t\t\t\t   struct btrfs_pending_snapshot *pending)\n{\n\tstruct btrfs_key key;\n\tstruct btrfs_root_item *new_root_item;\n\tstruct btrfs_root *tree_root = fs_info->tree_root;\n\tstruct btrfs_root *root = pending->root;\n\tstruct btrfs_root *parent_root;\n\tstruct btrfs_block_rsv *rsv;\n\tstruct inode *parent_inode;\n\tstruct btrfs_path *path;\n\tstruct btrfs_dir_item *dir_item;\n\tstruct dentry *dentry;\n\tstruct extent_buffer *tmp;\n\tstruct extent_buffer *old;\n\tstruct timespec cur_time = CURRENT_TIME;\n\tint ret = 0;\n\tu64 to_reserve = 0;\n\tu64 index = 0;\n\tu64 objectid;\n\tu64 root_flags;\n\tuuid_le new_uuid;\n\n\tpath = btrfs_alloc_path();\n\tif (!path) {\n\t\tpending->error = -ENOMEM;\n\t\treturn 0;\n\t}\n\n\tnew_root_item = kmalloc(sizeof(*new_root_item), GFP_NOFS);\n\tif (!new_root_item) {\n\t\tpending->error = -ENOMEM;\n\t\tgoto root_item_alloc_fail;\n\t}\n\n\tpending->error = btrfs_find_free_objectid(tree_root, &objectid);\n\tif (pending->error)\n\t\tgoto no_free_objectid;\n\n\tbtrfs_reloc_pre_snapshot(trans, pending, &to_reserve);\n\n\tif (to_reserve > 0) {\n\t\tpending->error = btrfs_block_rsv_add(root,\n\t\t\t\t\t\t     &pending->block_rsv,\n\t\t\t\t\t\t     to_reserve,\n\t\t\t\t\t\t     BTRFS_RESERVE_NO_FLUSH);\n\t\tif (pending->error)\n\t\t\tgoto no_free_objectid;\n\t}\n\n\tkey.objectid = objectid;\n\tkey.offset = (u64)-1;\n\tkey.type = BTRFS_ROOT_ITEM_KEY;\n\n\trsv = trans->block_rsv;\n\ttrans->block_rsv = &pending->block_rsv;\n\ttrans->bytes_reserved = trans->block_rsv->reserved;\n\n\tdentry = pending->dentry;\n\tparent_inode = pending->dir;\n\tparent_root = BTRFS_I(parent_inode)->root;\n\trecord_root_in_trans(trans, parent_root);\n\n\t/*\n\t * insert the directory item\n\t */\n\tret = btrfs_set_inode_index(parent_inode, &index);\n\tBUG_ON(ret); /* -ENOMEM */\n\n\t/* check if there is a file/dir which has the same name. */\n\tdir_item = btrfs_lookup_dir_item(NULL, parent_root, path,\n\t\t\t\t\t btrfs_ino(parent_inode),\n\t\t\t\t\t dentry->d_name.name,\n\t\t\t\t\t dentry->d_name.len, 0);\n\tif (dir_item != NULL && !IS_ERR(dir_item)) {\n\t\tpending->error = -EEXIST;\n\t\tgoto dir_item_existed;\n\t} else if (IS_ERR(dir_item)) {\n\t\tret = PTR_ERR(dir_item);\n\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\tgoto fail;\n\t}\n\tbtrfs_release_path(path);\n\n\t/*\n\t * pull in the delayed directory update\n\t * and the delayed inode item\n\t * otherwise we corrupt the FS during\n\t * snapshot\n\t */\n\tret = btrfs_run_delayed_items(trans, root);\n\tif (ret) {\t/* Transaction aborted */\n\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\tgoto fail;\n\t}\n\n\trecord_root_in_trans(trans, root);\n\tbtrfs_set_root_last_snapshot(&root->root_item, trans->transid);\n\tmemcpy(new_root_item, &root->root_item, sizeof(*new_root_item));\n\tbtrfs_check_and_init_root_item(new_root_item);\n\n\troot_flags = btrfs_root_flags(new_root_item);\n\tif (pending->readonly)\n\t\troot_flags |= BTRFS_ROOT_SUBVOL_RDONLY;\n\telse\n\t\troot_flags &= ~BTRFS_ROOT_SUBVOL_RDONLY;\n\tbtrfs_set_root_flags(new_root_item, root_flags);\n\n\tbtrfs_set_root_generation_v2(new_root_item,\n\t\t\ttrans->transid);\n\tuuid_le_gen(&new_uuid);\n\tmemcpy(new_root_item->uuid, new_uuid.b, BTRFS_UUID_SIZE);\n\tmemcpy(new_root_item->parent_uuid, root->root_item.uuid,\n\t\t\tBTRFS_UUID_SIZE);\n\tif (!(root_flags & BTRFS_ROOT_SUBVOL_RDONLY)) {\n\t\tmemset(new_root_item->received_uuid, 0,\n\t\t       sizeof(new_root_item->received_uuid));\n\t\tmemset(&new_root_item->stime, 0, sizeof(new_root_item->stime));\n\t\tmemset(&new_root_item->rtime, 0, sizeof(new_root_item->rtime));\n\t\tbtrfs_set_root_stransid(new_root_item, 0);\n\t\tbtrfs_set_root_rtransid(new_root_item, 0);\n\t}\n\tbtrfs_set_stack_timespec_sec(&new_root_item->otime, cur_time.tv_sec);\n\tbtrfs_set_stack_timespec_nsec(&new_root_item->otime, cur_time.tv_nsec);\n\tbtrfs_set_root_otransid(new_root_item, trans->transid);\n\n\told = btrfs_lock_root_node(root);\n\tret = btrfs_cow_block(trans, root, old, NULL, 0, &old);\n\tif (ret) {\n\t\tbtrfs_tree_unlock(old);\n\t\tfree_extent_buffer(old);\n\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\tgoto fail;\n\t}\n\n\tbtrfs_set_lock_blocking(old);\n\n\tret = btrfs_copy_root(trans, root, old, &tmp, objectid);\n\t/* clean up in any case */\n\tbtrfs_tree_unlock(old);\n\tfree_extent_buffer(old);\n\tif (ret) {\n\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\tgoto fail;\n\t}\n\n\t/*\n\t * We need to flush delayed refs in order to make sure all of our quota\n\t * operations have been done before we call btrfs_qgroup_inherit.\n\t */\n\tret = btrfs_run_delayed_refs(trans, root, (unsigned long)-1);\n\tif (ret) {\n\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\tgoto fail;\n\t}\n\n\tret = btrfs_qgroup_inherit(trans, fs_info,\n\t\t\t\t   root->root_key.objectid,\n\t\t\t\t   objectid, pending->inherit);\n\tif (ret) {\n\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\tgoto fail;\n\t}\n\n\t/* see comments in should_cow_block() */\n\tset_bit(BTRFS_ROOT_FORCE_COW, &root->state);\n\tsmp_wmb();\n\n\tbtrfs_set_root_node(new_root_item, tmp);\n\t/* record when the snapshot was created in key.offset */\n\tkey.offset = trans->transid;\n\tret = btrfs_insert_root(trans, tree_root, &key, new_root_item);\n\tbtrfs_tree_unlock(tmp);\n\tfree_extent_buffer(tmp);\n\tif (ret) {\n\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\tgoto fail;\n\t}\n\n\t/*\n\t * insert root back/forward references\n\t */\n\tret = btrfs_add_root_ref(trans, tree_root, objectid,\n\t\t\t\t parent_root->root_key.objectid,\n\t\t\t\t btrfs_ino(parent_inode), index,\n\t\t\t\t dentry->d_name.name, dentry->d_name.len);\n\tif (ret) {\n\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\tgoto fail;\n\t}\n\n\tkey.offset = (u64)-1;\n\tpending->snap = btrfs_read_fs_root_no_name(root->fs_info, &key);\n\tif (IS_ERR(pending->snap)) {\n\t\tret = PTR_ERR(pending->snap);\n\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\tgoto fail;\n\t}\n\n\tret = btrfs_reloc_post_snapshot(trans, pending);\n\tif (ret) {\n\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\tgoto fail;\n\t}\n\n\tret = btrfs_run_delayed_refs(trans, root, (unsigned long)-1);\n\tif (ret) {\n\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\tgoto fail;\n\t}\n\n\tret = btrfs_insert_dir_item(trans, parent_root,\n\t\t\t\t    dentry->d_name.name, dentry->d_name.len,\n\t\t\t\t    parent_inode, &key,\n\t\t\t\t    BTRFS_FT_DIR, index);\n\t/* We have check then name at the beginning, so it is impossible. */\n\tBUG_ON(ret == -EEXIST || ret == -EOVERFLOW);\n\tif (ret) {\n\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\tgoto fail;\n\t}\n\n\tbtrfs_i_size_write(parent_inode, parent_inode->i_size +\n\t\t\t\t\t dentry->d_name.len * 2);\n\tparent_inode->i_mtime = parent_inode->i_ctime = CURRENT_TIME;\n\tret = btrfs_update_inode_fallback(trans, parent_root, parent_inode);\n\tif (ret) {\n\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\tgoto fail;\n\t}\n\tret = btrfs_uuid_tree_add(trans, fs_info->uuid_root, new_uuid.b,\n\t\t\t\t  BTRFS_UUID_KEY_SUBVOL, objectid);\n\tif (ret) {\n\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\tgoto fail;\n\t}\n\tif (!btrfs_is_empty_uuid(new_root_item->received_uuid)) {\n\t\tret = btrfs_uuid_tree_add(trans, fs_info->uuid_root,\n\t\t\t\t\t  new_root_item->received_uuid,\n\t\t\t\t\t  BTRFS_UUID_KEY_RECEIVED_SUBVOL,\n\t\t\t\t\t  objectid);\n\t\tif (ret && ret != -EEXIST) {\n\t\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\t\tgoto fail;\n\t\t}\n\t}\nfail:\n\tpending->error = ret;\ndir_item_existed:\n\ttrans->block_rsv = rsv;\n\ttrans->bytes_reserved = 0;\nno_free_objectid:\n\tkfree(new_root_item);\nroot_item_alloc_fail:\n\tbtrfs_free_path(path);\n\treturn ret;\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"dev-replace.h\"",
      "#include \"volumes.h\"",
      "#include \"inode-map.h\"",
      "#include \"tree-log.h\"",
      "#include \"locking.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/uuid.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/writeback.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_free_path",
          "args": [
            "path"
          ],
          "line": 1502
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_free_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "107-113",
          "snippet": "void btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nvoid btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "new_root_item"
          ],
          "line": 1500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_abort_transaction",
          "args": [
            "trans",
            "root",
            "ret"
          ],
          "line": 1490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_uuid_tree_add",
          "args": [
            "trans",
            "fs_info->uuid_root",
            "new_root_item->received_uuid",
            "BTRFS_UUID_KEY_RECEIVED_SUBVOL",
            "objectid"
          ],
          "line": 1485
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_uuid_tree_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/uuid-tree.c",
          "lines": "93-155",
          "snippet": "int btrfs_uuid_tree_add(struct btrfs_trans_handle *trans,\n\t\t\tstruct btrfs_root *uuid_root, u8 *uuid, u8 type,\n\t\t\tu64 subid_cpu)\n{\n\tint ret;\n\tstruct btrfs_path *path = NULL;\n\tstruct btrfs_key key;\n\tstruct extent_buffer *eb;\n\tint slot;\n\tunsigned long offset;\n\t__le64 subid_le;\n\n\tret = btrfs_uuid_tree_lookup(uuid_root, uuid, type, subid_cpu);\n\tif (ret != -ENOENT)\n\t\treturn ret;\n\n\tif (WARN_ON_ONCE(!uuid_root)) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tbtrfs_uuid_to_key(uuid, type, &key);\n\n\tpath = btrfs_alloc_path();\n\tif (!path) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tret = btrfs_insert_empty_item(trans, uuid_root, path, &key,\n\t\t\t\t      sizeof(subid_le));\n\tif (ret >= 0) {\n\t\t/* Add an item for the type for the first time */\n\t\teb = path->nodes[0];\n\t\tslot = path->slots[0];\n\t\toffset = btrfs_item_ptr_offset(eb, slot);\n\t} else if (ret == -EEXIST) {\n\t\t/*\n\t\t * An item with that type already exists.\n\t\t * Extend the item and store the new subid at the end.\n\t\t */\n\t\tbtrfs_extend_item(uuid_root, path, sizeof(subid_le));\n\t\teb = path->nodes[0];\n\t\tslot = path->slots[0];\n\t\toffset = btrfs_item_ptr_offset(eb, slot);\n\t\toffset += btrfs_item_size_nr(eb, slot) - sizeof(subid_le);\n\t} else if (ret < 0) {\n\t\tbtrfs_warn(uuid_root->fs_info, \"insert uuid item failed %d \"\n\t\t\t\"(0x%016llx, 0x%016llx) type %u!\",\n\t\t\tret, (unsigned long long)key.objectid,\n\t\t\t(unsigned long long)key.offset, type);\n\t\tgoto out;\n\t}\n\n\tret = 0;\n\tsubid_le = cpu_to_le64(subid_cpu);\n\twrite_extent_buffer(eb, &subid_le, offset, sizeof(subid_le));\n\tbtrfs_mark_buffer_dirty(eb);\n\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}",
          "includes": [
            "#include \"print-tree.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/uuid.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"print-tree.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/uuid.h>\n\nint btrfs_uuid_tree_add(struct btrfs_trans_handle *trans,\n\t\t\tstruct btrfs_root *uuid_root, u8 *uuid, u8 type,\n\t\t\tu64 subid_cpu)\n{\n\tint ret;\n\tstruct btrfs_path *path = NULL;\n\tstruct btrfs_key key;\n\tstruct extent_buffer *eb;\n\tint slot;\n\tunsigned long offset;\n\t__le64 subid_le;\n\n\tret = btrfs_uuid_tree_lookup(uuid_root, uuid, type, subid_cpu);\n\tif (ret != -ENOENT)\n\t\treturn ret;\n\n\tif (WARN_ON_ONCE(!uuid_root)) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tbtrfs_uuid_to_key(uuid, type, &key);\n\n\tpath = btrfs_alloc_path();\n\tif (!path) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tret = btrfs_insert_empty_item(trans, uuid_root, path, &key,\n\t\t\t\t      sizeof(subid_le));\n\tif (ret >= 0) {\n\t\t/* Add an item for the type for the first time */\n\t\teb = path->nodes[0];\n\t\tslot = path->slots[0];\n\t\toffset = btrfs_item_ptr_offset(eb, slot);\n\t} else if (ret == -EEXIST) {\n\t\t/*\n\t\t * An item with that type already exists.\n\t\t * Extend the item and store the new subid at the end.\n\t\t */\n\t\tbtrfs_extend_item(uuid_root, path, sizeof(subid_le));\n\t\teb = path->nodes[0];\n\t\tslot = path->slots[0];\n\t\toffset = btrfs_item_ptr_offset(eb, slot);\n\t\toffset += btrfs_item_size_nr(eb, slot) - sizeof(subid_le);\n\t} else if (ret < 0) {\n\t\tbtrfs_warn(uuid_root->fs_info, \"insert uuid item failed %d \"\n\t\t\t\"(0x%016llx, 0x%016llx) type %u!\",\n\t\t\tret, (unsigned long long)key.objectid,\n\t\t\t(unsigned long long)key.offset, type);\n\t\tgoto out;\n\t}\n\n\tret = 0;\n\tsubid_le = cpu_to_le64(subid_cpu);\n\twrite_extent_buffer(eb, &subid_le, offset, sizeof(subid_le));\n\tbtrfs_mark_buffer_dirty(eb);\n\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_is_empty_uuid",
          "args": [
            "new_root_item->received_uuid"
          ],
          "line": 1484
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_is_empty_uuid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ioctl.c",
          "lines": "420-429",
          "snippet": "int btrfs_is_empty_uuid(u8 *uuid)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_UUID_SIZE; i++) {\n\t\tif (uuid[i])\n\t\t\treturn 0;\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"props.h\"",
            "#include \"dev-replace.h\"",
            "#include \"send.h\"",
            "#include \"rcu-string.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/xattr.h>",
            "#include <linux/security.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"props.h\"\n#include \"dev-replace.h\"\n#include \"send.h\"\n#include \"rcu-string.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uaccess.h>\n#include <linux/btrfs.h>\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/xattr.h>\n#include <linux/security.h>\n#include <linux/bit_spinlock.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nint btrfs_is_empty_uuid(u8 *uuid)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_UUID_SIZE; i++) {\n\t\tif (uuid[i])\n\t\t\treturn 0;\n\t}\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_abort_transaction",
          "args": [
            "trans",
            "root",
            "ret"
          ],
          "line": 1481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_abort_transaction",
          "args": [
            "trans",
            "root",
            "ret"
          ],
          "line": 1475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_update_inode_fallback",
          "args": [
            "trans",
            "parent_root",
            "parent_inode"
          ],
          "line": 1473
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_update_inode_fallback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/inode.c",
          "lines": "3841-3851",
          "snippet": "noinline int btrfs_update_inode_fallback(struct btrfs_trans_handle *trans,\n\t\t\t\t\t struct btrfs_root *root,\n\t\t\t\t\t struct inode *inode)\n{\n\tint ret;\n\n\tret = btrfs_update_inode(trans, root, inode);\n\tif (ret == -ENOSPC)\n\t\treturn btrfs_update_inode_item(trans, root, inode);\n\treturn ret;\n}",
          "includes": [
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"compression.h\"",
            "#include \"volumes.h\"",
            "#include \"tree-log.h\"",
            "#include \"xattr.h\"",
            "#include \"ordered-data.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/falloc.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/aio.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btrfs_truncate(struct inode *inode);",
            "static int btrfs_dirty_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"props.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"compression.h\"\n#include \"volumes.h\"\n#include \"tree-log.h\"\n#include \"xattr.h\"\n#include \"ordered-data.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/blkdev.h>\n#include <linux/btrfs.h>\n#include <linux/mount.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/bit_spinlock.h>\n#include <linux/aio.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic int btrfs_truncate(struct inode *inode);\nstatic int btrfs_dirty_inode(struct inode *inode);\n\nnoinline int btrfs_update_inode_fallback(struct btrfs_trans_handle *trans,\n\t\t\t\t\t struct btrfs_root *root,\n\t\t\t\t\t struct inode *inode)\n{\n\tint ret;\n\n\tret = btrfs_update_inode(trans, root, inode);\n\tif (ret == -ENOSPC)\n\t\treturn btrfs_update_inode_item(trans, root, inode);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_i_size_write",
          "args": [
            "parent_inode",
            "parent_inode->i_size +\n\t\t\t\t\t dentry->d_name.len * 2"
          ],
          "line": 1470
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_i_size_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "233-237",
          "snippet": "static inline void btrfs_i_size_write(struct inode *inode, u64 size)\n{\n\ti_size_write(inode, size);\n\tBTRFS_I(inode)->disk_i_size = size;\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline void btrfs_i_size_write(struct inode *inode, u64 size)\n{\n\ti_size_write(inode, size);\n\tBTRFS_I(inode)->disk_i_size = size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_abort_transaction",
          "args": [
            "trans",
            "root",
            "ret"
          ],
          "line": 1466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "ret == -EEXIST || ret == -EOVERFLOW"
          ],
          "line": 1464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_insert_dir_item",
          "args": [
            "trans",
            "parent_root",
            "dentry->d_name.name",
            "dentry->d_name.len",
            "parent_inode",
            "&key",
            "BTRFS_FT_DIR",
            "index"
          ],
          "line": 1459
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_insert_dir_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/dir-item.c",
          "lines": "120-184",
          "snippet": "int btrfs_insert_dir_item(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t\t  *root, const char *name, int name_len,\n\t\t\t  struct inode *dir, struct btrfs_key *location,\n\t\t\t  u8 type, u64 index)\n{\n\tint ret = 0;\n\tint ret2 = 0;\n\tstruct btrfs_path *path;\n\tstruct btrfs_dir_item *dir_item;\n\tstruct extent_buffer *leaf;\n\tunsigned long name_ptr;\n\tstruct btrfs_key key;\n\tstruct btrfs_disk_key disk_key;\n\tu32 data_size;\n\n\tkey.objectid = btrfs_ino(dir);\n\tkey.type = BTRFS_DIR_ITEM_KEY;\n\tkey.offset = btrfs_name_hash(name, name_len);\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\tpath->leave_spinning = 1;\n\n\tbtrfs_cpu_key_to_disk(&disk_key, location);\n\n\tdata_size = sizeof(*dir_item) + name_len;\n\tdir_item = insert_with_overflow(trans, root, path, &key, data_size,\n\t\t\t\t\tname, name_len);\n\tif (IS_ERR(dir_item)) {\n\t\tret = PTR_ERR(dir_item);\n\t\tif (ret == -EEXIST)\n\t\t\tgoto second_insert;\n\t\tgoto out_free;\n\t}\n\n\tleaf = path->nodes[0];\n\tbtrfs_set_dir_item_key(leaf, dir_item, &disk_key);\n\tbtrfs_set_dir_type(leaf, dir_item, type);\n\tbtrfs_set_dir_data_len(leaf, dir_item, 0);\n\tbtrfs_set_dir_name_len(leaf, dir_item, name_len);\n\tbtrfs_set_dir_transid(leaf, dir_item, trans->transid);\n\tname_ptr = (unsigned long)(dir_item + 1);\n\n\twrite_extent_buffer(leaf, name, name_ptr, name_len);\n\tbtrfs_mark_buffer_dirty(leaf);\n\nsecond_insert:\n\t/* FIXME, use some real flag for selecting the extra index */\n\tif (root == root->fs_info->tree_root) {\n\t\tret = 0;\n\t\tgoto out_free;\n\t}\n\tbtrfs_release_path(path);\n\n\tret2 = btrfs_insert_delayed_dir_index(trans, root, name, name_len, dir,\n\t\t\t\t\t      &disk_key, type, index);\nout_free:\n\tbtrfs_free_path(path);\n\tif (ret)\n\t\treturn ret;\n\tif (ret2)\n\t\treturn ret2;\n\treturn 0;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n\nint btrfs_insert_dir_item(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t\t  *root, const char *name, int name_len,\n\t\t\t  struct inode *dir, struct btrfs_key *location,\n\t\t\t  u8 type, u64 index)\n{\n\tint ret = 0;\n\tint ret2 = 0;\n\tstruct btrfs_path *path;\n\tstruct btrfs_dir_item *dir_item;\n\tstruct extent_buffer *leaf;\n\tunsigned long name_ptr;\n\tstruct btrfs_key key;\n\tstruct btrfs_disk_key disk_key;\n\tu32 data_size;\n\n\tkey.objectid = btrfs_ino(dir);\n\tkey.type = BTRFS_DIR_ITEM_KEY;\n\tkey.offset = btrfs_name_hash(name, name_len);\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\tpath->leave_spinning = 1;\n\n\tbtrfs_cpu_key_to_disk(&disk_key, location);\n\n\tdata_size = sizeof(*dir_item) + name_len;\n\tdir_item = insert_with_overflow(trans, root, path, &key, data_size,\n\t\t\t\t\tname, name_len);\n\tif (IS_ERR(dir_item)) {\n\t\tret = PTR_ERR(dir_item);\n\t\tif (ret == -EEXIST)\n\t\t\tgoto second_insert;\n\t\tgoto out_free;\n\t}\n\n\tleaf = path->nodes[0];\n\tbtrfs_set_dir_item_key(leaf, dir_item, &disk_key);\n\tbtrfs_set_dir_type(leaf, dir_item, type);\n\tbtrfs_set_dir_data_len(leaf, dir_item, 0);\n\tbtrfs_set_dir_name_len(leaf, dir_item, name_len);\n\tbtrfs_set_dir_transid(leaf, dir_item, trans->transid);\n\tname_ptr = (unsigned long)(dir_item + 1);\n\n\twrite_extent_buffer(leaf, name, name_ptr, name_len);\n\tbtrfs_mark_buffer_dirty(leaf);\n\nsecond_insert:\n\t/* FIXME, use some real flag for selecting the extra index */\n\tif (root == root->fs_info->tree_root) {\n\t\tret = 0;\n\t\tgoto out_free;\n\t}\n\tbtrfs_release_path(path);\n\n\tret2 = btrfs_insert_delayed_dir_index(trans, root, name, name_len, dir,\n\t\t\t\t\t      &disk_key, type, index);\nout_free:\n\tbtrfs_free_path(path);\n\tif (ret)\n\t\treturn ret;\n\tif (ret2)\n\t\treturn ret2;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_abort_transaction",
          "args": [
            "trans",
            "root",
            "ret"
          ],
          "line": 1455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_run_delayed_refs",
          "args": [
            "trans",
            "root",
            "(unsigned long)-1"
          ],
          "line": 1453
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_run_delayed_refs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent-tree.c",
          "lines": "2764-2841",
          "snippet": "int btrfs_run_delayed_refs(struct btrfs_trans_handle *trans,\n\t\t\t   struct btrfs_root *root, unsigned long count)\n{\n\tstruct rb_node *node;\n\tstruct btrfs_delayed_ref_root *delayed_refs;\n\tstruct btrfs_delayed_ref_head *head;\n\tint ret;\n\tint run_all = count == (unsigned long)-1;\n\n\t/* We'll clean this up in btrfs_cleanup_transaction */\n\tif (trans->aborted)\n\t\treturn 0;\n\n\tif (root == root->fs_info->extent_root)\n\t\troot = root->fs_info->tree_root;\n\n\tdelayed_refs = &trans->transaction->delayed_refs;\n\tif (count == 0)\n\t\tcount = atomic_read(&delayed_refs->num_entries) * 2;\n\nagain:\n#ifdef SCRAMBLE_DELAYED_REFS\n\tdelayed_refs->run_delayed_start = find_middle(&delayed_refs->root);\n#endif\n\tret = __btrfs_run_delayed_refs(trans, root, count);\n\tif (ret < 0) {\n\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\treturn ret;\n\t}\n\n\tif (run_all) {\n\t\tif (!list_empty(&trans->new_bgs))\n\t\t\tbtrfs_create_pending_block_groups(trans, root);\n\n\t\tspin_lock(&delayed_refs->lock);\n\t\tnode = rb_first(&delayed_refs->href_root);\n\t\tif (!node) {\n\t\t\tspin_unlock(&delayed_refs->lock);\n\t\t\tgoto out;\n\t\t}\n\t\tcount = (unsigned long)-1;\n\n\t\twhile (node) {\n\t\t\thead = rb_entry(node, struct btrfs_delayed_ref_head,\n\t\t\t\t\thref_node);\n\t\t\tif (btrfs_delayed_ref_is_head(&head->node)) {\n\t\t\t\tstruct btrfs_delayed_ref_node *ref;\n\n\t\t\t\tref = &head->node;\n\t\t\t\tatomic_inc(&ref->refs);\n\n\t\t\t\tspin_unlock(&delayed_refs->lock);\n\t\t\t\t/*\n\t\t\t\t * Mutex was contended, block until it's\n\t\t\t\t * released and try again\n\t\t\t\t */\n\t\t\t\tmutex_lock(&head->mutex);\n\t\t\t\tmutex_unlock(&head->mutex);\n\n\t\t\t\tbtrfs_put_delayed_ref(ref);\n\t\t\t\tcond_resched();\n\t\t\t\tgoto again;\n\t\t\t} else {\n\t\t\t\tWARN_ON(1);\n\t\t\t}\n\t\t\tnode = rb_next(node);\n\t\t}\n\t\tspin_unlock(&delayed_refs->lock);\n\t\tcond_resched();\n\t\tgoto again;\n\t}\nout:\n\tret = btrfs_delayed_qgroup_accounting(trans, root->fs_info);\n\tif (ret)\n\t\treturn ret;\n\tassert_qgroups_uptodate(trans);\n\treturn 0;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"math.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include \"hash.h\"",
            "#include <linux/percpu_counter.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"math.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include \"hash.h\"\n#include <linux/percpu_counter.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n#include <linux/rcupdate.h>\n#include <linux/sort.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nint btrfs_run_delayed_refs(struct btrfs_trans_handle *trans,\n\t\t\t   struct btrfs_root *root, unsigned long count)\n{\n\tstruct rb_node *node;\n\tstruct btrfs_delayed_ref_root *delayed_refs;\n\tstruct btrfs_delayed_ref_head *head;\n\tint ret;\n\tint run_all = count == (unsigned long)-1;\n\n\t/* We'll clean this up in btrfs_cleanup_transaction */\n\tif (trans->aborted)\n\t\treturn 0;\n\n\tif (root == root->fs_info->extent_root)\n\t\troot = root->fs_info->tree_root;\n\n\tdelayed_refs = &trans->transaction->delayed_refs;\n\tif (count == 0)\n\t\tcount = atomic_read(&delayed_refs->num_entries) * 2;\n\nagain:\n#ifdef SCRAMBLE_DELAYED_REFS\n\tdelayed_refs->run_delayed_start = find_middle(&delayed_refs->root);\n#endif\n\tret = __btrfs_run_delayed_refs(trans, root, count);\n\tif (ret < 0) {\n\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\treturn ret;\n\t}\n\n\tif (run_all) {\n\t\tif (!list_empty(&trans->new_bgs))\n\t\t\tbtrfs_create_pending_block_groups(trans, root);\n\n\t\tspin_lock(&delayed_refs->lock);\n\t\tnode = rb_first(&delayed_refs->href_root);\n\t\tif (!node) {\n\t\t\tspin_unlock(&delayed_refs->lock);\n\t\t\tgoto out;\n\t\t}\n\t\tcount = (unsigned long)-1;\n\n\t\twhile (node) {\n\t\t\thead = rb_entry(node, struct btrfs_delayed_ref_head,\n\t\t\t\t\thref_node);\n\t\t\tif (btrfs_delayed_ref_is_head(&head->node)) {\n\t\t\t\tstruct btrfs_delayed_ref_node *ref;\n\n\t\t\t\tref = &head->node;\n\t\t\t\tatomic_inc(&ref->refs);\n\n\t\t\t\tspin_unlock(&delayed_refs->lock);\n\t\t\t\t/*\n\t\t\t\t * Mutex was contended, block until it's\n\t\t\t\t * released and try again\n\t\t\t\t */\n\t\t\t\tmutex_lock(&head->mutex);\n\t\t\t\tmutex_unlock(&head->mutex);\n\n\t\t\t\tbtrfs_put_delayed_ref(ref);\n\t\t\t\tcond_resched();\n\t\t\t\tgoto again;\n\t\t\t} else {\n\t\t\t\tWARN_ON(1);\n\t\t\t}\n\t\t\tnode = rb_next(node);\n\t\t}\n\t\tspin_unlock(&delayed_refs->lock);\n\t\tcond_resched();\n\t\tgoto again;\n\t}\nout:\n\tret = btrfs_delayed_qgroup_accounting(trans, root->fs_info);\n\tif (ret)\n\t\treturn ret;\n\tassert_qgroups_uptodate(trans);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_abort_transaction",
          "args": [
            "trans",
            "root",
            "ret"
          ],
          "line": 1449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_reloc_post_snapshot",
          "args": [
            "trans",
            "pending"
          ],
          "line": 1447
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_reloc_post_snapshot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/relocation.c",
          "lines": "4619-4655",
          "snippet": "int btrfs_reloc_post_snapshot(struct btrfs_trans_handle *trans,\n\t\t\t       struct btrfs_pending_snapshot *pending)\n{\n\tstruct btrfs_root *root = pending->root;\n\tstruct btrfs_root *reloc_root;\n\tstruct btrfs_root *new_root;\n\tstruct reloc_control *rc;\n\tint ret;\n\n\tif (!root->reloc_root)\n\t\treturn 0;\n\n\trc = root->fs_info->reloc_ctl;\n\trc->merging_rsv_size += rc->nodes_relocated;\n\n\tif (rc->merge_reloc_tree) {\n\t\tret = btrfs_block_rsv_migrate(&pending->block_rsv,\n\t\t\t\t\t      rc->block_rsv,\n\t\t\t\t\t      rc->nodes_relocated);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tnew_root = pending->snap;\n\treloc_root = create_reloc_root(trans, root->reloc_root,\n\t\t\t\t       new_root->root_key.objectid);\n\tif (IS_ERR(reloc_root))\n\t\treturn PTR_ERR(reloc_root);\n\n\tret = __add_reloc_root(reloc_root);\n\tBUG_ON(ret < 0);\n\tnew_root->reloc_root = reloc_root;\n\n\tif (rc->create_reloc_tree)\n\t\tret = clone_backref_node(trans, rc, root, reloc_root);\n\treturn ret;\n}",
          "includes": [
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"async-thread.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"async-thread.h\"\n#include \"btrfs_inode.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic noinline_for_stack\nstruct;\n\nint btrfs_reloc_post_snapshot(struct btrfs_trans_handle *trans,\n\t\t\t       struct btrfs_pending_snapshot *pending)\n{\n\tstruct btrfs_root *root = pending->root;\n\tstruct btrfs_root *reloc_root;\n\tstruct btrfs_root *new_root;\n\tstruct reloc_control *rc;\n\tint ret;\n\n\tif (!root->reloc_root)\n\t\treturn 0;\n\n\trc = root->fs_info->reloc_ctl;\n\trc->merging_rsv_size += rc->nodes_relocated;\n\n\tif (rc->merge_reloc_tree) {\n\t\tret = btrfs_block_rsv_migrate(&pending->block_rsv,\n\t\t\t\t\t      rc->block_rsv,\n\t\t\t\t\t      rc->nodes_relocated);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tnew_root = pending->snap;\n\treloc_root = create_reloc_root(trans, root->reloc_root,\n\t\t\t\t       new_root->root_key.objectid);\n\tif (IS_ERR(reloc_root))\n\t\treturn PTR_ERR(reloc_root);\n\n\tret = __add_reloc_root(reloc_root);\n\tBUG_ON(ret < 0);\n\tnew_root->reloc_root = reloc_root;\n\n\tif (rc->create_reloc_tree)\n\t\tret = clone_backref_node(trans, rc, root, reloc_root);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_abort_transaction",
          "args": [
            "trans",
            "root",
            "ret"
          ],
          "line": 1443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "pending->snap"
          ],
          "line": 1442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "pending->snap"
          ],
          "line": 1441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_read_fs_root_no_name",
          "args": [
            "root->fs_info",
            "&key"
          ],
          "line": 1440
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_read_fs_root_no_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.h",
          "lines": "76-81",
          "snippet": "static inline struct btrfs_root *\nbtrfs_read_fs_root_no_name(struct btrfs_fs_info *fs_info,\n\t\t\t   struct btrfs_key *location)\n{\n\treturn btrfs_get_fs_root(fs_info, location, true);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline struct btrfs_root *\nbtrfs_read_fs_root_no_name(struct btrfs_fs_info *fs_info,\n\t\t\t   struct btrfs_key *location)\n{\n\treturn btrfs_get_fs_root(fs_info, location, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_abort_transaction",
          "args": [
            "trans",
            "root",
            "ret"
          ],
          "line": 1435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_add_root_ref",
          "args": [
            "trans",
            "tree_root",
            "objectid",
            "parent_root->root_key.objectid",
            "btrfs_ino(parent_inode)",
            "index",
            "dentry->d_name.name",
            "dentry->d_name.len"
          ],
          "line": 1430
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_add_root_ref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/root-tree.c",
          "lines": "419-466",
          "snippet": "int btrfs_add_root_ref(struct btrfs_trans_handle *trans,\n\t\t       struct btrfs_root *tree_root,\n\t\t       u64 root_id, u64 ref_id, u64 dirid, u64 sequence,\n\t\t       const char *name, int name_len)\n{\n\tstruct btrfs_key key;\n\tint ret;\n\tstruct btrfs_path *path;\n\tstruct btrfs_root_ref *ref;\n\tstruct extent_buffer *leaf;\n\tunsigned long ptr;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tkey.objectid = root_id;\n\tkey.type = BTRFS_ROOT_BACKREF_KEY;\n\tkey.offset = ref_id;\nagain:\n\tret = btrfs_insert_empty_item(trans, tree_root, path, &key,\n\t\t\t\t      sizeof(*ref) + name_len);\n\tif (ret) {\n\t\tbtrfs_abort_transaction(trans, tree_root, ret);\n\t\tbtrfs_free_path(path);\n\t\treturn ret;\n\t}\n\n\tleaf = path->nodes[0];\n\tref = btrfs_item_ptr(leaf, path->slots[0], struct btrfs_root_ref);\n\tbtrfs_set_root_ref_dirid(leaf, ref, dirid);\n\tbtrfs_set_root_ref_sequence(leaf, ref, sequence);\n\tbtrfs_set_root_ref_name_len(leaf, ref, name_len);\n\tptr = (unsigned long)(ref + 1);\n\twrite_extent_buffer(leaf, name, ptr, name_len);\n\tbtrfs_mark_buffer_dirty(leaf);\n\n\tif (key.type == BTRFS_ROOT_BACKREF_KEY) {\n\t\tbtrfs_release_path(path);\n\t\tkey.objectid = ref_id;\n\t\tkey.type = BTRFS_ROOT_REF_KEY;\n\t\tkey.offset = root_id;\n\t\tgoto again;\n\t}\n\n\tbtrfs_free_path(path);\n\treturn 0;\n}",
          "includes": [
            "#include \"print-tree.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uuid.h>",
            "#include <linux/err.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"print-tree.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/err.h>\n\nint btrfs_add_root_ref(struct btrfs_trans_handle *trans,\n\t\t       struct btrfs_root *tree_root,\n\t\t       u64 root_id, u64 ref_id, u64 dirid, u64 sequence,\n\t\t       const char *name, int name_len)\n{\n\tstruct btrfs_key key;\n\tint ret;\n\tstruct btrfs_path *path;\n\tstruct btrfs_root_ref *ref;\n\tstruct extent_buffer *leaf;\n\tunsigned long ptr;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tkey.objectid = root_id;\n\tkey.type = BTRFS_ROOT_BACKREF_KEY;\n\tkey.offset = ref_id;\nagain:\n\tret = btrfs_insert_empty_item(trans, tree_root, path, &key,\n\t\t\t\t      sizeof(*ref) + name_len);\n\tif (ret) {\n\t\tbtrfs_abort_transaction(trans, tree_root, ret);\n\t\tbtrfs_free_path(path);\n\t\treturn ret;\n\t}\n\n\tleaf = path->nodes[0];\n\tref = btrfs_item_ptr(leaf, path->slots[0], struct btrfs_root_ref);\n\tbtrfs_set_root_ref_dirid(leaf, ref, dirid);\n\tbtrfs_set_root_ref_sequence(leaf, ref, sequence);\n\tbtrfs_set_root_ref_name_len(leaf, ref, name_len);\n\tptr = (unsigned long)(ref + 1);\n\twrite_extent_buffer(leaf, name, ptr, name_len);\n\tbtrfs_mark_buffer_dirty(leaf);\n\n\tif (key.type == BTRFS_ROOT_BACKREF_KEY) {\n\t\tbtrfs_release_path(path);\n\t\tkey.objectid = ref_id;\n\t\tkey.type = BTRFS_ROOT_REF_KEY;\n\t\tkey.offset = root_id;\n\t\tgoto again;\n\t}\n\n\tbtrfs_free_path(path);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_ino",
          "args": [
            "parent_inode"
          ],
          "line": 1432
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_inode_resume_unlocked_dio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "311-316",
          "snippet": "static inline void btrfs_inode_resume_unlocked_dio(struct inode *inode)\n{\n\tsmp_mb__before_atomic();\n\tclear_bit(BTRFS_INODE_READDIO_NEED_LOCK,\n\t\t  &BTRFS_I(inode)->runtime_flags);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [
            "#define BTRFS_INODE_READDIO_NEED_LOCK\t\t10"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\n#define BTRFS_INODE_READDIO_NEED_LOCK\t\t10\n\nstatic inline void btrfs_inode_resume_unlocked_dio(struct inode *inode)\n{\n\tsmp_mb__before_atomic();\n\tclear_bit(BTRFS_INODE_READDIO_NEED_LOCK,\n\t\t  &BTRFS_I(inode)->runtime_flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_abort_transaction",
          "args": [
            "trans",
            "root",
            "ret"
          ],
          "line": 1423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_extent_buffer",
          "args": [
            "tmp"
          ],
          "line": 1421
        },
        "resolved": true,
        "details": {
          "function_name": "free_extent_buffer_stale",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "5019-5031",
          "snippet": "void free_extent_buffer_stale(struct extent_buffer *eb)\n{\n\tif (!eb)\n\t\treturn;\n\n\tspin_lock(&eb->refs_lock);\n\tset_bit(EXTENT_BUFFER_STALE, &eb->bflags);\n\n\tif (atomic_read(&eb->refs) == 2 && !extent_buffer_under_io(eb) &&\n\t    test_and_clear_bit(EXTENT_BUFFER_TREE_REF, &eb->bflags))\n\t\tatomic_dec(&eb->refs);\n\trelease_extent_buffer(eb);\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nvoid free_extent_buffer_stale(struct extent_buffer *eb)\n{\n\tif (!eb)\n\t\treturn;\n\n\tspin_lock(&eb->refs_lock);\n\tset_bit(EXTENT_BUFFER_STALE, &eb->bflags);\n\n\tif (atomic_read(&eb->refs) == 2 && !extent_buffer_under_io(eb) &&\n\t    test_and_clear_bit(EXTENT_BUFFER_TREE_REF, &eb->bflags))\n\t\tatomic_dec(&eb->refs);\n\trelease_extent_buffer(eb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_tree_unlock",
          "args": [
            "tmp"
          ],
          "line": 1420
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_tree_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/locking.c",
          "lines": "269-290",
          "snippet": "void btrfs_tree_unlock(struct extent_buffer *eb)\n{\n\tint blockers = atomic_read(&eb->blocking_writers);\n\n\tBUG_ON(blockers > 1);\n\n\tbtrfs_assert_tree_locked(eb);\n\teb->lock_owner = 0;\n\tatomic_dec(&eb->write_locks);\n\n\tif (blockers) {\n\t\tWARN_ON(atomic_read(&eb->spinning_writers));\n\t\tatomic_dec(&eb->blocking_writers);\n\t\tsmp_mb();\n\t\tif (waitqueue_active(&eb->write_lock_wq))\n\t\t\twake_up(&eb->write_lock_wq);\n\t} else {\n\t\tWARN_ON(atomic_read(&eb->spinning_writers) != 1);\n\t\tatomic_dec(&eb->spinning_writers);\n\t\twrite_unlock(&eb->lock);\n\t}\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"extent_io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/bug.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void btrfs_assert_tree_read_locked(struct extent_buffer *eb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"extent_io.h\"\n#include \"ctree.h\"\n#include <asm/bug.h>\n#include <linux/page-flags.h>\n#include <linux/spinlock.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void btrfs_assert_tree_read_locked(struct extent_buffer *eb);\n\nvoid btrfs_tree_unlock(struct extent_buffer *eb)\n{\n\tint blockers = atomic_read(&eb->blocking_writers);\n\n\tBUG_ON(blockers > 1);\n\n\tbtrfs_assert_tree_locked(eb);\n\teb->lock_owner = 0;\n\tatomic_dec(&eb->write_locks);\n\n\tif (blockers) {\n\t\tWARN_ON(atomic_read(&eb->spinning_writers));\n\t\tatomic_dec(&eb->blocking_writers);\n\t\tsmp_mb();\n\t\tif (waitqueue_active(&eb->write_lock_wq))\n\t\t\twake_up(&eb->write_lock_wq);\n\t} else {\n\t\tWARN_ON(atomic_read(&eb->spinning_writers) != 1);\n\t\tatomic_dec(&eb->spinning_writers);\n\t\twrite_unlock(&eb->lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_insert_root",
          "args": [
            "trans",
            "tree_root",
            "&key",
            "new_root_item"
          ],
          "line": 1419
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_insert_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/root-tree.c",
          "lines": "212-220",
          "snippet": "int btrfs_insert_root(struct btrfs_trans_handle *trans, struct btrfs_root *root,\n\t\t      struct btrfs_key *key, struct btrfs_root_item *item)\n{\n\t/*\n\t * Make sure generation v1 and v2 match. See update_root for details.\n\t */\n\tbtrfs_set_root_generation_v2(item, btrfs_root_generation(item));\n\treturn btrfs_insert_item(trans, root, key, item, sizeof(*item));\n}",
          "includes": [
            "#include \"print-tree.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uuid.h>",
            "#include <linux/err.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"print-tree.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/err.h>\n\nint btrfs_insert_root(struct btrfs_trans_handle *trans, struct btrfs_root *root,\n\t\t      struct btrfs_key *key, struct btrfs_root_item *item)\n{\n\t/*\n\t * Make sure generation v1 and v2 match. See update_root for details.\n\t */\n\tbtrfs_set_root_generation_v2(item, btrfs_root_generation(item));\n\treturn btrfs_insert_item(trans, root, key, item, sizeof(*item));\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_set_root_node",
          "args": [
            "new_root_item",
            "tmp"
          ],
          "line": 1416
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_root_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/root-tree.c",
          "lines": "124-130",
          "snippet": "void btrfs_set_root_node(struct btrfs_root_item *item,\n\t\t\t struct extent_buffer *node)\n{\n\tbtrfs_set_root_bytenr(item, node->start);\n\tbtrfs_set_root_level(item, btrfs_header_level(node));\n\tbtrfs_set_root_generation(item, btrfs_header_generation(node));\n}",
          "includes": [
            "#include \"print-tree.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uuid.h>",
            "#include <linux/err.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"print-tree.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/err.h>\n\nvoid btrfs_set_root_node(struct btrfs_root_item *item,\n\t\t\t struct extent_buffer *node)\n{\n\tbtrfs_set_root_bytenr(item, node->start);\n\tbtrfs_set_root_level(item, btrfs_header_level(node));\n\tbtrfs_set_root_generation(item, btrfs_header_generation(node));\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_wmb",
          "args": [],
          "line": 1414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "BTRFS_ROOT_FORCE_COW",
            "&root->state"
          ],
          "line": 1413
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_abort_transaction",
          "args": [
            "trans",
            "root",
            "ret"
          ],
          "line": 1408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_qgroup_inherit",
          "args": [
            "trans",
            "fs_info",
            "root->root_key.objectid",
            "objectid",
            "pending->inherit"
          ],
          "line": 1404
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_qgroup_inherit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/qgroup.c",
          "lines": "2190-2359",
          "snippet": "int btrfs_qgroup_inherit(struct btrfs_trans_handle *trans,\n\t\t\t struct btrfs_fs_info *fs_info, u64 srcid, u64 objectid,\n\t\t\t struct btrfs_qgroup_inherit *inherit)\n{\n\tint ret = 0;\n\tint i;\n\tu64 *i_qgroups;\n\tstruct btrfs_root *quota_root = fs_info->quota_root;\n\tstruct btrfs_qgroup *srcgroup;\n\tstruct btrfs_qgroup *dstgroup;\n\tu32 level_size = 0;\n\tu64 nums;\n\n\tmutex_lock(&fs_info->qgroup_ioctl_lock);\n\tif (!fs_info->quota_enabled)\n\t\tgoto out;\n\n\tif (!quota_root) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (inherit) {\n\t\ti_qgroups = (u64 *)(inherit + 1);\n\t\tnums = inherit->num_qgroups + 2 * inherit->num_ref_copies +\n\t\t       2 * inherit->num_excl_copies;\n\t\tfor (i = 0; i < nums; ++i) {\n\t\t\tsrcgroup = find_qgroup_rb(fs_info, *i_qgroups);\n\t\t\tif (!srcgroup) {\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\t++i_qgroups;\n\t\t}\n\t}\n\n\t/*\n\t * create a tracking group for the subvol itself\n\t */\n\tret = add_qgroup_item(trans, quota_root, objectid);\n\tif (ret)\n\t\tgoto out;\n\n\tif (inherit && inherit->flags & BTRFS_QGROUP_INHERIT_SET_LIMITS) {\n\t\tret = update_qgroup_limit_item(trans, quota_root, objectid,\n\t\t\t\t\t       inherit->lim.flags,\n\t\t\t\t\t       inherit->lim.max_rfer,\n\t\t\t\t\t       inherit->lim.max_excl,\n\t\t\t\t\t       inherit->lim.rsv_rfer,\n\t\t\t\t\t       inherit->lim.rsv_excl);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\tif (srcid) {\n\t\tstruct btrfs_root *srcroot;\n\t\tstruct btrfs_key srckey;\n\n\t\tsrckey.objectid = srcid;\n\t\tsrckey.type = BTRFS_ROOT_ITEM_KEY;\n\t\tsrckey.offset = (u64)-1;\n\t\tsrcroot = btrfs_read_fs_root_no_name(fs_info, &srckey);\n\t\tif (IS_ERR(srcroot)) {\n\t\t\tret = PTR_ERR(srcroot);\n\t\t\tgoto out;\n\t\t}\n\n\t\trcu_read_lock();\n\t\tlevel_size = srcroot->nodesize;\n\t\trcu_read_unlock();\n\t}\n\n\t/*\n\t * add qgroup to all inherited groups\n\t */\n\tif (inherit) {\n\t\ti_qgroups = (u64 *)(inherit + 1);\n\t\tfor (i = 0; i < inherit->num_qgroups; ++i) {\n\t\t\tret = add_qgroup_relation_item(trans, quota_root,\n\t\t\t\t\t\t       objectid, *i_qgroups);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t\tret = add_qgroup_relation_item(trans, quota_root,\n\t\t\t\t\t\t       *i_qgroups, objectid);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t\t++i_qgroups;\n\t\t}\n\t}\n\n\n\tspin_lock(&fs_info->qgroup_lock);\n\n\tdstgroup = add_qgroup_rb(fs_info, objectid);\n\tif (IS_ERR(dstgroup)) {\n\t\tret = PTR_ERR(dstgroup);\n\t\tgoto unlock;\n\t}\n\n\tif (srcid) {\n\t\tsrcgroup = find_qgroup_rb(fs_info, srcid);\n\t\tif (!srcgroup)\n\t\t\tgoto unlock;\n\n\t\t/*\n\t\t * We call inherit after we clone the root in order to make sure\n\t\t * our counts don't go crazy, so at this point the only\n\t\t * difference between the two roots should be the root node.\n\t\t */\n\t\tdstgroup->rfer = srcgroup->rfer;\n\t\tdstgroup->rfer_cmpr = srcgroup->rfer_cmpr;\n\t\tdstgroup->excl = level_size;\n\t\tdstgroup->excl_cmpr = level_size;\n\t\tsrcgroup->excl = level_size;\n\t\tsrcgroup->excl_cmpr = level_size;\n\t\tqgroup_dirty(fs_info, dstgroup);\n\t\tqgroup_dirty(fs_info, srcgroup);\n\t}\n\n\tif (!inherit)\n\t\tgoto unlock;\n\n\ti_qgroups = (u64 *)(inherit + 1);\n\tfor (i = 0; i < inherit->num_qgroups; ++i) {\n\t\tret = add_relation_rb(quota_root->fs_info, objectid,\n\t\t\t\t      *i_qgroups);\n\t\tif (ret)\n\t\t\tgoto unlock;\n\t\t++i_qgroups;\n\t}\n\n\tfor (i = 0; i <  inherit->num_ref_copies; ++i) {\n\t\tstruct btrfs_qgroup *src;\n\t\tstruct btrfs_qgroup *dst;\n\n\t\tsrc = find_qgroup_rb(fs_info, i_qgroups[0]);\n\t\tdst = find_qgroup_rb(fs_info, i_qgroups[1]);\n\n\t\tif (!src || !dst) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto unlock;\n\t\t}\n\n\t\tdst->rfer = src->rfer - level_size;\n\t\tdst->rfer_cmpr = src->rfer_cmpr - level_size;\n\t\ti_qgroups += 2;\n\t}\n\tfor (i = 0; i <  inherit->num_excl_copies; ++i) {\n\t\tstruct btrfs_qgroup *src;\n\t\tstruct btrfs_qgroup *dst;\n\n\t\tsrc = find_qgroup_rb(fs_info, i_qgroups[0]);\n\t\tdst = find_qgroup_rb(fs_info, i_qgroups[1]);\n\n\t\tif (!src || !dst) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto unlock;\n\t\t}\n\n\t\tdst->excl = src->excl + level_size;\n\t\tdst->excl_cmpr = src->excl_cmpr + level_size;\n\t\ti_qgroups += 2;\n\t}\n\nunlock:\n\tspin_unlock(&fs_info->qgroup_lock);\nout:\n\tmutex_unlock(&fs_info->qgroup_ioctl_lock);\n\treturn ret;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"ulist.h\"",
            "#include \"locking.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"ctree.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"ulist.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);\n\nint btrfs_qgroup_inherit(struct btrfs_trans_handle *trans,\n\t\t\t struct btrfs_fs_info *fs_info, u64 srcid, u64 objectid,\n\t\t\t struct btrfs_qgroup_inherit *inherit)\n{\n\tint ret = 0;\n\tint i;\n\tu64 *i_qgroups;\n\tstruct btrfs_root *quota_root = fs_info->quota_root;\n\tstruct btrfs_qgroup *srcgroup;\n\tstruct btrfs_qgroup *dstgroup;\n\tu32 level_size = 0;\n\tu64 nums;\n\n\tmutex_lock(&fs_info->qgroup_ioctl_lock);\n\tif (!fs_info->quota_enabled)\n\t\tgoto out;\n\n\tif (!quota_root) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (inherit) {\n\t\ti_qgroups = (u64 *)(inherit + 1);\n\t\tnums = inherit->num_qgroups + 2 * inherit->num_ref_copies +\n\t\t       2 * inherit->num_excl_copies;\n\t\tfor (i = 0; i < nums; ++i) {\n\t\t\tsrcgroup = find_qgroup_rb(fs_info, *i_qgroups);\n\t\t\tif (!srcgroup) {\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\t++i_qgroups;\n\t\t}\n\t}\n\n\t/*\n\t * create a tracking group for the subvol itself\n\t */\n\tret = add_qgroup_item(trans, quota_root, objectid);\n\tif (ret)\n\t\tgoto out;\n\n\tif (inherit && inherit->flags & BTRFS_QGROUP_INHERIT_SET_LIMITS) {\n\t\tret = update_qgroup_limit_item(trans, quota_root, objectid,\n\t\t\t\t\t       inherit->lim.flags,\n\t\t\t\t\t       inherit->lim.max_rfer,\n\t\t\t\t\t       inherit->lim.max_excl,\n\t\t\t\t\t       inherit->lim.rsv_rfer,\n\t\t\t\t\t       inherit->lim.rsv_excl);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\tif (srcid) {\n\t\tstruct btrfs_root *srcroot;\n\t\tstruct btrfs_key srckey;\n\n\t\tsrckey.objectid = srcid;\n\t\tsrckey.type = BTRFS_ROOT_ITEM_KEY;\n\t\tsrckey.offset = (u64)-1;\n\t\tsrcroot = btrfs_read_fs_root_no_name(fs_info, &srckey);\n\t\tif (IS_ERR(srcroot)) {\n\t\t\tret = PTR_ERR(srcroot);\n\t\t\tgoto out;\n\t\t}\n\n\t\trcu_read_lock();\n\t\tlevel_size = srcroot->nodesize;\n\t\trcu_read_unlock();\n\t}\n\n\t/*\n\t * add qgroup to all inherited groups\n\t */\n\tif (inherit) {\n\t\ti_qgroups = (u64 *)(inherit + 1);\n\t\tfor (i = 0; i < inherit->num_qgroups; ++i) {\n\t\t\tret = add_qgroup_relation_item(trans, quota_root,\n\t\t\t\t\t\t       objectid, *i_qgroups);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t\tret = add_qgroup_relation_item(trans, quota_root,\n\t\t\t\t\t\t       *i_qgroups, objectid);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t\t++i_qgroups;\n\t\t}\n\t}\n\n\n\tspin_lock(&fs_info->qgroup_lock);\n\n\tdstgroup = add_qgroup_rb(fs_info, objectid);\n\tif (IS_ERR(dstgroup)) {\n\t\tret = PTR_ERR(dstgroup);\n\t\tgoto unlock;\n\t}\n\n\tif (srcid) {\n\t\tsrcgroup = find_qgroup_rb(fs_info, srcid);\n\t\tif (!srcgroup)\n\t\t\tgoto unlock;\n\n\t\t/*\n\t\t * We call inherit after we clone the root in order to make sure\n\t\t * our counts don't go crazy, so at this point the only\n\t\t * difference between the two roots should be the root node.\n\t\t */\n\t\tdstgroup->rfer = srcgroup->rfer;\n\t\tdstgroup->rfer_cmpr = srcgroup->rfer_cmpr;\n\t\tdstgroup->excl = level_size;\n\t\tdstgroup->excl_cmpr = level_size;\n\t\tsrcgroup->excl = level_size;\n\t\tsrcgroup->excl_cmpr = level_size;\n\t\tqgroup_dirty(fs_info, dstgroup);\n\t\tqgroup_dirty(fs_info, srcgroup);\n\t}\n\n\tif (!inherit)\n\t\tgoto unlock;\n\n\ti_qgroups = (u64 *)(inherit + 1);\n\tfor (i = 0; i < inherit->num_qgroups; ++i) {\n\t\tret = add_relation_rb(quota_root->fs_info, objectid,\n\t\t\t\t      *i_qgroups);\n\t\tif (ret)\n\t\t\tgoto unlock;\n\t\t++i_qgroups;\n\t}\n\n\tfor (i = 0; i <  inherit->num_ref_copies; ++i) {\n\t\tstruct btrfs_qgroup *src;\n\t\tstruct btrfs_qgroup *dst;\n\n\t\tsrc = find_qgroup_rb(fs_info, i_qgroups[0]);\n\t\tdst = find_qgroup_rb(fs_info, i_qgroups[1]);\n\n\t\tif (!src || !dst) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto unlock;\n\t\t}\n\n\t\tdst->rfer = src->rfer - level_size;\n\t\tdst->rfer_cmpr = src->rfer_cmpr - level_size;\n\t\ti_qgroups += 2;\n\t}\n\tfor (i = 0; i <  inherit->num_excl_copies; ++i) {\n\t\tstruct btrfs_qgroup *src;\n\t\tstruct btrfs_qgroup *dst;\n\n\t\tsrc = find_qgroup_rb(fs_info, i_qgroups[0]);\n\t\tdst = find_qgroup_rb(fs_info, i_qgroups[1]);\n\n\t\tif (!src || !dst) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto unlock;\n\t\t}\n\n\t\tdst->excl = src->excl + level_size;\n\t\tdst->excl_cmpr = src->excl_cmpr + level_size;\n\t\ti_qgroups += 2;\n\t}\n\nunlock:\n\tspin_unlock(&fs_info->qgroup_lock);\nout:\n\tmutex_unlock(&fs_info->qgroup_ioctl_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_abort_transaction",
          "args": [
            "trans",
            "root",
            "ret"
          ],
          "line": 1400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_abort_transaction",
          "args": [
            "trans",
            "root",
            "ret"
          ],
          "line": 1390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_copy_root",
          "args": [
            "trans",
            "root",
            "old",
            "&tmp",
            "objectid"
          ],
          "line": 1385
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_copy_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "238-290",
          "snippet": "int btrfs_copy_root(struct btrfs_trans_handle *trans,\n\t\t      struct btrfs_root *root,\n\t\t      struct extent_buffer *buf,\n\t\t      struct extent_buffer **cow_ret, u64 new_root_objectid)\n{\n\tstruct extent_buffer *cow;\n\tint ret = 0;\n\tint level;\n\tstruct btrfs_disk_key disk_key;\n\n\tWARN_ON(test_bit(BTRFS_ROOT_REF_COWS, &root->state) &&\n\t\ttrans->transid != root->fs_info->running_transaction->transid);\n\tWARN_ON(test_bit(BTRFS_ROOT_REF_COWS, &root->state) &&\n\t\ttrans->transid != root->last_trans);\n\n\tlevel = btrfs_header_level(buf);\n\tif (level == 0)\n\t\tbtrfs_item_key(buf, &disk_key, 0);\n\telse\n\t\tbtrfs_node_key(buf, &disk_key, 0);\n\n\tcow = btrfs_alloc_tree_block(trans, root, 0, new_root_objectid,\n\t\t\t&disk_key, level, buf->start, 0);\n\tif (IS_ERR(cow))\n\t\treturn PTR_ERR(cow);\n\n\tcopy_extent_buffer(cow, buf, 0, 0, cow->len);\n\tbtrfs_set_header_bytenr(cow, cow->start);\n\tbtrfs_set_header_generation(cow, trans->transid);\n\tbtrfs_set_header_backref_rev(cow, BTRFS_MIXED_BACKREF_REV);\n\tbtrfs_clear_header_flag(cow, BTRFS_HEADER_FLAG_WRITTEN |\n\t\t\t\t     BTRFS_HEADER_FLAG_RELOC);\n\tif (new_root_objectid == BTRFS_TREE_RELOC_OBJECTID)\n\t\tbtrfs_set_header_flag(cow, BTRFS_HEADER_FLAG_RELOC);\n\telse\n\t\tbtrfs_set_header_owner(cow, new_root_objectid);\n\n\twrite_extent_buffer(cow, root->fs_info->fsid, btrfs_header_fsid(),\n\t\t\t    BTRFS_FSID_SIZE);\n\n\tWARN_ON(btrfs_header_generation(buf) > trans->transid);\n\tif (new_root_objectid == BTRFS_TREE_RELOC_OBJECTID)\n\t\tret = btrfs_inc_ref(trans, root, cow, 1);\n\telse\n\t\tret = btrfs_inc_ref(trans, root, cow, 0);\n\n\tif (ret)\n\t\treturn ret;\n\n\tbtrfs_mark_buffer_dirty(cow);\n\t*cow_ret = cow;\n\treturn 0;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);\nstatic noinline struct;\n\nint btrfs_copy_root(struct btrfs_trans_handle *trans,\n\t\t      struct btrfs_root *root,\n\t\t      struct extent_buffer *buf,\n\t\t      struct extent_buffer **cow_ret, u64 new_root_objectid)\n{\n\tstruct extent_buffer *cow;\n\tint ret = 0;\n\tint level;\n\tstruct btrfs_disk_key disk_key;\n\n\tWARN_ON(test_bit(BTRFS_ROOT_REF_COWS, &root->state) &&\n\t\ttrans->transid != root->fs_info->running_transaction->transid);\n\tWARN_ON(test_bit(BTRFS_ROOT_REF_COWS, &root->state) &&\n\t\ttrans->transid != root->last_trans);\n\n\tlevel = btrfs_header_level(buf);\n\tif (level == 0)\n\t\tbtrfs_item_key(buf, &disk_key, 0);\n\telse\n\t\tbtrfs_node_key(buf, &disk_key, 0);\n\n\tcow = btrfs_alloc_tree_block(trans, root, 0, new_root_objectid,\n\t\t\t&disk_key, level, buf->start, 0);\n\tif (IS_ERR(cow))\n\t\treturn PTR_ERR(cow);\n\n\tcopy_extent_buffer(cow, buf, 0, 0, cow->len);\n\tbtrfs_set_header_bytenr(cow, cow->start);\n\tbtrfs_set_header_generation(cow, trans->transid);\n\tbtrfs_set_header_backref_rev(cow, BTRFS_MIXED_BACKREF_REV);\n\tbtrfs_clear_header_flag(cow, BTRFS_HEADER_FLAG_WRITTEN |\n\t\t\t\t     BTRFS_HEADER_FLAG_RELOC);\n\tif (new_root_objectid == BTRFS_TREE_RELOC_OBJECTID)\n\t\tbtrfs_set_header_flag(cow, BTRFS_HEADER_FLAG_RELOC);\n\telse\n\t\tbtrfs_set_header_owner(cow, new_root_objectid);\n\n\twrite_extent_buffer(cow, root->fs_info->fsid, btrfs_header_fsid(),\n\t\t\t    BTRFS_FSID_SIZE);\n\n\tWARN_ON(btrfs_header_generation(buf) > trans->transid);\n\tif (new_root_objectid == BTRFS_TREE_RELOC_OBJECTID)\n\t\tret = btrfs_inc_ref(trans, root, cow, 1);\n\telse\n\t\tret = btrfs_inc_ref(trans, root, cow, 0);\n\n\tif (ret)\n\t\treturn ret;\n\n\tbtrfs_mark_buffer_dirty(cow);\n\t*cow_ret = cow;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_set_lock_blocking",
          "args": [
            "old"
          ],
          "line": 1383
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_lock_blocking",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/locking.h",
          "lines": "53-56",
          "snippet": "static inline void btrfs_set_lock_blocking(struct extent_buffer *eb)\n{\n\tbtrfs_set_lock_blocking_rw(eb, BTRFS_WRITE_LOCK);\n}",
          "includes": [],
          "macros_used": [
            "#define BTRFS_WRITE_LOCK 1"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define BTRFS_WRITE_LOCK 1\n\nstatic inline void btrfs_set_lock_blocking(struct extent_buffer *eb)\n{\n\tbtrfs_set_lock_blocking_rw(eb, BTRFS_WRITE_LOCK);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_abort_transaction",
          "args": [
            "trans",
            "root",
            "ret"
          ],
          "line": 1379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_cow_block",
          "args": [
            "trans",
            "root",
            "old",
            "NULL",
            "0",
            "&old"
          ],
          "line": 1375
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_cow_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "1534-1568",
          "snippet": "noinline int btrfs_cow_block(struct btrfs_trans_handle *trans,\n\t\t    struct btrfs_root *root, struct extent_buffer *buf,\n\t\t    struct extent_buffer *parent, int parent_slot,\n\t\t    struct extent_buffer **cow_ret)\n{\n\tu64 search_start;\n\tint ret;\n\n\tif (trans->transaction != root->fs_info->running_transaction)\n\t\tWARN(1, KERN_CRIT \"trans %llu running %llu\\n\",\n\t\t       trans->transid,\n\t\t       root->fs_info->running_transaction->transid);\n\n\tif (trans->transid != root->fs_info->generation)\n\t\tWARN(1, KERN_CRIT \"trans %llu running %llu\\n\",\n\t\t       trans->transid, root->fs_info->generation);\n\n\tif (!should_cow_block(trans, root, buf)) {\n\t\t*cow_ret = buf;\n\t\treturn 0;\n\t}\n\n\tsearch_start = buf->start & ~((u64)(1024 * 1024 * 1024) - 1);\n\n\tif (parent)\n\t\tbtrfs_set_lock_blocking(parent);\n\tbtrfs_set_lock_blocking(buf);\n\n\tret = __btrfs_cow_block(trans, root, buf, parent,\n\t\t\t\t parent_slot, cow_ret, search_start, 0);\n\n\ttrace_btrfs_cow_block(root, buf, *cow_ret);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nnoinline int btrfs_cow_block(struct btrfs_trans_handle *trans,\n\t\t    struct btrfs_root *root, struct extent_buffer *buf,\n\t\t    struct extent_buffer *parent, int parent_slot,\n\t\t    struct extent_buffer **cow_ret)\n{\n\tu64 search_start;\n\tint ret;\n\n\tif (trans->transaction != root->fs_info->running_transaction)\n\t\tWARN(1, KERN_CRIT \"trans %llu running %llu\\n\",\n\t\t       trans->transid,\n\t\t       root->fs_info->running_transaction->transid);\n\n\tif (trans->transid != root->fs_info->generation)\n\t\tWARN(1, KERN_CRIT \"trans %llu running %llu\\n\",\n\t\t       trans->transid, root->fs_info->generation);\n\n\tif (!should_cow_block(trans, root, buf)) {\n\t\t*cow_ret = buf;\n\t\treturn 0;\n\t}\n\n\tsearch_start = buf->start & ~((u64)(1024 * 1024 * 1024) - 1);\n\n\tif (parent)\n\t\tbtrfs_set_lock_blocking(parent);\n\tbtrfs_set_lock_blocking(buf);\n\n\tret = __btrfs_cow_block(trans, root, buf, parent,\n\t\t\t\t parent_slot, cow_ret, search_start, 0);\n\n\ttrace_btrfs_cow_block(root, buf, *cow_ret);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_lock_root_node",
          "args": [
            "root"
          ],
          "line": 1374
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_lock_root_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "176-189",
          "snippet": "struct extent_buffer *btrfs_lock_root_node(struct btrfs_root *root)\n{\n\tstruct extent_buffer *eb;\n\n\twhile (1) {\n\t\teb = btrfs_root_node(root);\n\t\tbtrfs_tree_lock(eb);\n\t\tif (eb == root->node)\n\t\t\tbreak;\n\t\tbtrfs_tree_unlock(eb);\n\t\tfree_extent_buffer(eb);\n\t}\n\treturn eb;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int tree_mod_log_free_eb(struct btrfs_fs_info *fs_info,\n\t\t\t\t struct extent_buffer *eb);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int tree_mod_log_free_eb(struct btrfs_fs_info *fs_info,\n\t\t\t\t struct extent_buffer *eb);\nstatic noinline struct;\n\nstruct extent_buffer *btrfs_lock_root_node(struct btrfs_root *root)\n{\n\tstruct extent_buffer *eb;\n\n\twhile (1) {\n\t\teb = btrfs_root_node(root);\n\t\tbtrfs_tree_lock(eb);\n\t\tif (eb == root->node)\n\t\t\tbreak;\n\t\tbtrfs_tree_unlock(eb);\n\t\tfree_extent_buffer(eb);\n\t}\n\treturn eb;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_set_root_otransid",
          "args": [
            "new_root_item",
            "trans->transid"
          ],
          "line": 1372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_stack_timespec_nsec",
          "args": [
            "&new_root_item->otime",
            "cur_time.tv_nsec"
          ],
          "line": 1371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_stack_timespec_sec",
          "args": [
            "&new_root_item->otime",
            "cur_time.tv_sec"
          ],
          "line": 1370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_root_rtransid",
          "args": [
            "new_root_item",
            "0"
          ],
          "line": 1368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_root_stransid",
          "args": [
            "new_root_item",
            "0"
          ],
          "line": 1367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&new_root_item->rtime",
            "0",
            "sizeof(new_root_item->rtime)"
          ],
          "line": 1366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&new_root_item->stime",
            "0",
            "sizeof(new_root_item->stime)"
          ],
          "line": 1365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "new_root_item->received_uuid",
            "0",
            "sizeof(new_root_item->received_uuid)"
          ],
          "line": 1363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "new_root_item->parent_uuid",
            "root->root_item.uuid",
            "BTRFS_UUID_SIZE"
          ],
          "line": 1360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "new_root_item->uuid",
            "new_uuid.b",
            "BTRFS_UUID_SIZE"
          ],
          "line": 1359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uuid_le_gen",
          "args": [
            "&new_uuid"
          ],
          "line": 1358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_root_generation_v2",
          "args": [
            "new_root_item",
            "trans->transid"
          ],
          "line": 1356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_root_flags",
          "args": [
            "new_root_item",
            "root_flags"
          ],
          "line": 1354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_root_flags",
          "args": [
            "new_root_item"
          ],
          "line": 1349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_check_and_init_root_item",
          "args": [
            "new_root_item"
          ],
          "line": 1347
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_check_and_init_root_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/root-tree.c",
          "lines": "474-484",
          "snippet": "void btrfs_check_and_init_root_item(struct btrfs_root_item *root_item)\n{\n\tu64 inode_flags = btrfs_stack_inode_flags(&root_item->inode);\n\n\tif (!(inode_flags & BTRFS_INODE_ROOT_ITEM_INIT)) {\n\t\tinode_flags |= BTRFS_INODE_ROOT_ITEM_INIT;\n\t\tbtrfs_set_stack_inode_flags(&root_item->inode, inode_flags);\n\t\tbtrfs_set_root_flags(root_item, 0);\n\t\tbtrfs_set_root_limit(root_item, 0);\n\t}\n}",
          "includes": [
            "#include \"print-tree.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uuid.h>",
            "#include <linux/err.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"print-tree.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/err.h>\n\nvoid btrfs_check_and_init_root_item(struct btrfs_root_item *root_item)\n{\n\tu64 inode_flags = btrfs_stack_inode_flags(&root_item->inode);\n\n\tif (!(inode_flags & BTRFS_INODE_ROOT_ITEM_INIT)) {\n\t\tinode_flags |= BTRFS_INODE_ROOT_ITEM_INIT;\n\t\tbtrfs_set_stack_inode_flags(&root_item->inode, inode_flags);\n\t\tbtrfs_set_root_flags(root_item, 0);\n\t\tbtrfs_set_root_limit(root_item, 0);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "new_root_item",
            "&root->root_item",
            "sizeof(*new_root_item)"
          ],
          "line": 1346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_root_last_snapshot",
          "args": [
            "&root->root_item",
            "trans->transid"
          ],
          "line": 1345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "record_root_in_trans",
          "args": [
            "trans",
            "root"
          ],
          "line": 1344
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_record_root_in_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
          "lines": "330-350",
          "snippet": "int btrfs_record_root_in_trans(struct btrfs_trans_handle *trans,\n\t\t\t       struct btrfs_root *root)\n{\n\tif (!test_bit(BTRFS_ROOT_REF_COWS, &root->state))\n\t\treturn 0;\n\n\t/*\n\t * see record_root_in_trans for comments about IN_TRANS_SETUP usage\n\t * and barriers\n\t */\n\tsmp_rmb();\n\tif (root->last_trans == trans->transid &&\n\t    !test_bit(BTRFS_ROOT_IN_TRANS_SETUP, &root->state))\n\t\treturn 0;\n\n\tmutex_lock(&root->fs_info->reloc_mutex);\n\trecord_root_in_trans(trans, root);\n\tmutex_unlock(&root->fs_info->reloc_mutex);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"dev-replace.h\"",
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint btrfs_record_root_in_trans(struct btrfs_trans_handle *trans,\n\t\t\t       struct btrfs_root *root)\n{\n\tif (!test_bit(BTRFS_ROOT_REF_COWS, &root->state))\n\t\treturn 0;\n\n\t/*\n\t * see record_root_in_trans for comments about IN_TRANS_SETUP usage\n\t * and barriers\n\t */\n\tsmp_rmb();\n\tif (root->last_trans == trans->transid &&\n\t    !test_bit(BTRFS_ROOT_IN_TRANS_SETUP, &root->state))\n\t\treturn 0;\n\n\tmutex_lock(&root->fs_info->reloc_mutex);\n\trecord_root_in_trans(trans, root);\n\tmutex_unlock(&root->fs_info->reloc_mutex);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_abort_transaction",
          "args": [
            "trans",
            "root",
            "ret"
          ],
          "line": 1340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_run_delayed_items",
          "args": [
            "trans",
            "root"
          ],
          "line": 1338
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_run_delayed_items",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-inode.c",
          "lines": "1205-1209",
          "snippet": "int btrfs_run_delayed_items(struct btrfs_trans_handle *trans,\n\t\t\t    struct btrfs_root *root)\n{\n\treturn __btrfs_run_delayed_items(trans, root, -1);\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"delayed-inode.h\"\n#include <linux/slab.h>\n\nint btrfs_run_delayed_items(struct btrfs_trans_handle *trans,\n\t\t\t    struct btrfs_root *root)\n{\n\treturn __btrfs_run_delayed_items(trans, root, -1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_release_path",
          "args": [
            "path"
          ],
          "line": 1330
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_release_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "121-136",
          "snippet": "noinline void btrfs_release_path(struct btrfs_path *p)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tp->slots[i] = 0;\n\t\tif (!p->nodes[i])\n\t\t\tcontinue;\n\t\tif (p->locks[i]) {\n\t\t\tbtrfs_tree_unlock_rw(p->nodes[i], p->locks[i]);\n\t\t\tp->locks[i] = 0;\n\t\t}\n\t\tfree_extent_buffer(p->nodes[i]);\n\t\tp->nodes[i] = NULL;\n\t}\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nnoinline void btrfs_release_path(struct btrfs_path *p)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tp->slots[i] = 0;\n\t\tif (!p->nodes[i])\n\t\t\tcontinue;\n\t\tif (p->locks[i]) {\n\t\t\tbtrfs_tree_unlock_rw(p->nodes[i], p->locks[i]);\n\t\t\tp->locks[i] = 0;\n\t\t}\n\t\tfree_extent_buffer(p->nodes[i]);\n\t\tp->nodes[i] = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_abort_transaction",
          "args": [
            "trans",
            "root",
            "ret"
          ],
          "line": 1327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "dir_item"
          ],
          "line": 1326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "dir_item"
          ],
          "line": 1325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "dir_item"
          ],
          "line": 1322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_lookup_dir_item",
          "args": [
            "NULL",
            "parent_root",
            "path",
            "btrfs_ino(parent_inode)",
            "dentry->d_name.name",
            "dentry->d_name.len",
            "0"
          ],
          "line": 1318
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_lookup_dir_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/dir-item.c",
          "lines": "191-214",
          "snippet": "struct btrfs_dir_item *btrfs_lookup_dir_item(struct btrfs_trans_handle *trans,\n\t\t\t\t\t     struct btrfs_root *root,\n\t\t\t\t\t     struct btrfs_path *path, u64 dir,\n\t\t\t\t\t     const char *name, int name_len,\n\t\t\t\t\t     int mod)\n{\n\tint ret;\n\tstruct btrfs_key key;\n\tint ins_len = mod < 0 ? -1 : 0;\n\tint cow = mod != 0;\n\n\tkey.objectid = dir;\n\tkey.type = BTRFS_DIR_ITEM_KEY;\n\n\tkey.offset = btrfs_name_hash(name, name_len);\n\n\tret = btrfs_search_slot(trans, root, &key, path, ins_len, cow);\n\tif (ret < 0)\n\t\treturn ERR_PTR(ret);\n\tif (ret > 0)\n\t\treturn NULL;\n\n\treturn btrfs_match_dir_item_name(root, path, name, name_len);\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n\nstruct btrfs_dir_item *btrfs_lookup_dir_item(struct btrfs_trans_handle *trans,\n\t\t\t\t\t     struct btrfs_root *root,\n\t\t\t\t\t     struct btrfs_path *path, u64 dir,\n\t\t\t\t\t     const char *name, int name_len,\n\t\t\t\t\t     int mod)\n{\n\tint ret;\n\tstruct btrfs_key key;\n\tint ins_len = mod < 0 ? -1 : 0;\n\tint cow = mod != 0;\n\n\tkey.objectid = dir;\n\tkey.type = BTRFS_DIR_ITEM_KEY;\n\n\tkey.offset = btrfs_name_hash(name, name_len);\n\n\tret = btrfs_search_slot(trans, root, &key, path, ins_len, cow);\n\tif (ret < 0)\n\t\treturn ERR_PTR(ret);\n\tif (ret > 0)\n\t\treturn NULL;\n\n\treturn btrfs_match_dir_item_name(root, path, name, name_len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "ret"
          ],
          "line": 1315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_inode_index",
          "args": [
            "parent_inode",
            "&index"
          ],
          "line": 1314
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_inode_index",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/inode.c",
          "lines": "5788-5805",
          "snippet": "int btrfs_set_inode_index(struct inode *dir, u64 *index)\n{\n\tint ret = 0;\n\n\tif (BTRFS_I(dir)->index_cnt == (u64)-1) {\n\t\tret = btrfs_inode_delayed_dir_index_count(dir);\n\t\tif (ret) {\n\t\t\tret = btrfs_set_inode_index_count(dir);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\t*index = BTRFS_I(dir)->index_cnt;\n\tBTRFS_I(dir)->index_cnt++;\n\n\treturn ret;\n}",
          "includes": [
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"compression.h\"",
            "#include \"volumes.h\"",
            "#include \"tree-log.h\"",
            "#include \"xattr.h\"",
            "#include \"ordered-data.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/falloc.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/aio.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btrfs_truncate(struct inode *inode);",
            "static int btrfs_dirty_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"props.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"compression.h\"\n#include \"volumes.h\"\n#include \"tree-log.h\"\n#include \"xattr.h\"\n#include \"ordered-data.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/blkdev.h>\n#include <linux/btrfs.h>\n#include <linux/mount.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/bit_spinlock.h>\n#include <linux/aio.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic int btrfs_truncate(struct inode *inode);\nstatic int btrfs_dirty_inode(struct inode *inode);\n\nint btrfs_set_inode_index(struct inode *dir, u64 *index)\n{\n\tint ret = 0;\n\n\tif (BTRFS_I(dir)->index_cnt == (u64)-1) {\n\t\tret = btrfs_inode_delayed_dir_index_count(dir);\n\t\tif (ret) {\n\t\t\tret = btrfs_set_inode_index_count(dir);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\t*index = BTRFS_I(dir)->index_cnt;\n\tBTRFS_I(dir)->index_cnt++;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BTRFS_I",
          "args": [
            "parent_inode"
          ],
          "line": 1308
        },
        "resolved": true,
        "details": {
          "function_name": "BTRFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "196-199",
          "snippet": "static inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_block_rsv_add",
          "args": [
            "root",
            "&pending->block_rsv",
            "to_reserve",
            "BTRFS_RESERVE_NO_FLUSH"
          ],
          "line": 1290
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_block_rsv_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent-tree.c",
          "lines": "4703-4719",
          "snippet": "int btrfs_block_rsv_add(struct btrfs_root *root,\n\t\t\tstruct btrfs_block_rsv *block_rsv, u64 num_bytes,\n\t\t\tenum btrfs_reserve_flush_enum flush)\n{\n\tint ret;\n\n\tif (num_bytes == 0)\n\t\treturn 0;\n\n\tret = reserve_metadata_bytes(root, block_rsv, num_bytes, flush);\n\tif (!ret) {\n\t\tblock_rsv_add_bytes(block_rsv, num_bytes, 1);\n\t\treturn 0;\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"math.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include \"hash.h\"",
            "#include <linux/percpu_counter.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int block_rsv_use_bytes(struct btrfs_block_rsv *block_rsv,\n\t\t\t       u64 num_bytes);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"math.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include \"hash.h\"\n#include <linux/percpu_counter.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n#include <linux/rcupdate.h>\n#include <linux/sort.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic int block_rsv_use_bytes(struct btrfs_block_rsv *block_rsv,\n\t\t\t       u64 num_bytes);\nstatic noinline struct;\n\nint btrfs_block_rsv_add(struct btrfs_root *root,\n\t\t\tstruct btrfs_block_rsv *block_rsv, u64 num_bytes,\n\t\t\tenum btrfs_reserve_flush_enum flush)\n{\n\tint ret;\n\n\tif (num_bytes == 0)\n\t\treturn 0;\n\n\tret = reserve_metadata_bytes(root, block_rsv, num_bytes, flush);\n\tif (!ret) {\n\t\tblock_rsv_add_bytes(block_rsv, num_bytes, 1);\n\t\treturn 0;\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_reloc_pre_snapshot",
          "args": [
            "trans",
            "pending",
            "&to_reserve"
          ],
          "line": 1287
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_reloc_pre_snapshot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/relocation.c",
          "lines": "4585-4613",
          "snippet": "void btrfs_reloc_pre_snapshot(struct btrfs_trans_handle *trans,\n\t\t\t      struct btrfs_pending_snapshot *pending,\n\t\t\t      u64 *bytes_to_reserve)\n{\n\tstruct btrfs_root *root;\n\tstruct reloc_control *rc;\n\n\troot = pending->root;\n\tif (!root->reloc_root)\n\t\treturn;\n\n\trc = root->fs_info->reloc_ctl;\n\tif (!rc->merge_reloc_tree)\n\t\treturn;\n\n\troot = root->reloc_root;\n\tBUG_ON(btrfs_root_refs(&root->root_item) == 0);\n\t/*\n\t * relocation is in the stage of merging trees. the space\n\t * used by merging a reloc tree is twice the size of\n\t * relocated tree nodes in the worst case. half for cowing\n\t * the reloc tree, half for cowing the fs tree. the space\n\t * used by cowing the reloc tree will be freed after the\n\t * tree is dropped. if we create snapshot, cowing the fs\n\t * tree may use more space than it frees. so we need\n\t * reserve extra space.\n\t */\n\t*bytes_to_reserve += rc->nodes_relocated;\n}",
          "includes": [
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"async-thread.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"async-thread.h\"\n#include \"btrfs_inode.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic noinline_for_stack\nstruct;\n\nvoid btrfs_reloc_pre_snapshot(struct btrfs_trans_handle *trans,\n\t\t\t      struct btrfs_pending_snapshot *pending,\n\t\t\t      u64 *bytes_to_reserve)\n{\n\tstruct btrfs_root *root;\n\tstruct reloc_control *rc;\n\n\troot = pending->root;\n\tif (!root->reloc_root)\n\t\treturn;\n\n\trc = root->fs_info->reloc_ctl;\n\tif (!rc->merge_reloc_tree)\n\t\treturn;\n\n\troot = root->reloc_root;\n\tBUG_ON(btrfs_root_refs(&root->root_item) == 0);\n\t/*\n\t * relocation is in the stage of merging trees. the space\n\t * used by merging a reloc tree is twice the size of\n\t * relocated tree nodes in the worst case. half for cowing\n\t * the reloc tree, half for cowing the fs tree. the space\n\t * used by cowing the reloc tree will be freed after the\n\t * tree is dropped. if we create snapshot, cowing the fs\n\t * tree may use more space than it frees. so we need\n\t * reserve extra space.\n\t */\n\t*bytes_to_reserve += rc->nodes_relocated;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_find_free_objectid",
          "args": [
            "tree_root",
            "&objectid"
          ],
          "line": 1283
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_find_free_objectid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/inode-map.c",
          "lines": "546-568",
          "snippet": "int btrfs_find_free_objectid(struct btrfs_root *root, u64 *objectid)\n{\n\tint ret;\n\tmutex_lock(&root->objectid_mutex);\n\n\tif (unlikely(root->highest_objectid < BTRFS_FIRST_FREE_OBJECTID)) {\n\t\tret = btrfs_find_highest_objectid(root,\n\t\t\t\t\t\t  &root->highest_objectid);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\tif (unlikely(root->highest_objectid >= BTRFS_LAST_FREE_OBJECTID)) {\n\t\tret = -ENOSPC;\n\t\tgoto out;\n\t}\n\n\t*objectid = ++root->highest_objectid;\n\tret = 0;\nout:\n\tmutex_unlock(&root->objectid_mutex);\n\treturn ret;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n\nint btrfs_find_free_objectid(struct btrfs_root *root, u64 *objectid)\n{\n\tint ret;\n\tmutex_lock(&root->objectid_mutex);\n\n\tif (unlikely(root->highest_objectid < BTRFS_FIRST_FREE_OBJECTID)) {\n\t\tret = btrfs_find_highest_objectid(root,\n\t\t\t\t\t\t  &root->highest_objectid);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\tif (unlikely(root->highest_objectid >= BTRFS_LAST_FREE_OBJECTID)) {\n\t\tret = -ENOSPC;\n\t\tgoto out;\n\t}\n\n\t*objectid = ++root->highest_objectid;\n\tret = 0;\nout:\n\tmutex_unlock(&root->objectid_mutex);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(*new_root_item)",
            "GFP_NOFS"
          ],
          "line": 1277
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_alloc_path",
          "args": [],
          "line": 1271
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_alloc_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "45-50",
          "snippet": "struct btrfs_path *btrfs_alloc_path(void)\n{\n\tstruct btrfs_path *path;\n\tpath = kmem_cache_zalloc(btrfs_path_cachep, GFP_NOFS);\n\treturn path;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstruct btrfs_path *btrfs_alloc_path(void)\n{\n\tstruct btrfs_path *path;\n\tpath = kmem_cache_zalloc(btrfs_path_cachep, GFP_NOFS);\n\treturn path;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic noinline int create_pending_snapshot(struct btrfs_trans_handle *trans,\n\t\t\t\t   struct btrfs_fs_info *fs_info,\n\t\t\t\t   struct btrfs_pending_snapshot *pending)\n{\n\tstruct btrfs_key key;\n\tstruct btrfs_root_item *new_root_item;\n\tstruct btrfs_root *tree_root = fs_info->tree_root;\n\tstruct btrfs_root *root = pending->root;\n\tstruct btrfs_root *parent_root;\n\tstruct btrfs_block_rsv *rsv;\n\tstruct inode *parent_inode;\n\tstruct btrfs_path *path;\n\tstruct btrfs_dir_item *dir_item;\n\tstruct dentry *dentry;\n\tstruct extent_buffer *tmp;\n\tstruct extent_buffer *old;\n\tstruct timespec cur_time = CURRENT_TIME;\n\tint ret = 0;\n\tu64 to_reserve = 0;\n\tu64 index = 0;\n\tu64 objectid;\n\tu64 root_flags;\n\tuuid_le new_uuid;\n\n\tpath = btrfs_alloc_path();\n\tif (!path) {\n\t\tpending->error = -ENOMEM;\n\t\treturn 0;\n\t}\n\n\tnew_root_item = kmalloc(sizeof(*new_root_item), GFP_NOFS);\n\tif (!new_root_item) {\n\t\tpending->error = -ENOMEM;\n\t\tgoto root_item_alloc_fail;\n\t}\n\n\tpending->error = btrfs_find_free_objectid(tree_root, &objectid);\n\tif (pending->error)\n\t\tgoto no_free_objectid;\n\n\tbtrfs_reloc_pre_snapshot(trans, pending, &to_reserve);\n\n\tif (to_reserve > 0) {\n\t\tpending->error = btrfs_block_rsv_add(root,\n\t\t\t\t\t\t     &pending->block_rsv,\n\t\t\t\t\t\t     to_reserve,\n\t\t\t\t\t\t     BTRFS_RESERVE_NO_FLUSH);\n\t\tif (pending->error)\n\t\t\tgoto no_free_objectid;\n\t}\n\n\tkey.objectid = objectid;\n\tkey.offset = (u64)-1;\n\tkey.type = BTRFS_ROOT_ITEM_KEY;\n\n\trsv = trans->block_rsv;\n\ttrans->block_rsv = &pending->block_rsv;\n\ttrans->bytes_reserved = trans->block_rsv->reserved;\n\n\tdentry = pending->dentry;\n\tparent_inode = pending->dir;\n\tparent_root = BTRFS_I(parent_inode)->root;\n\trecord_root_in_trans(trans, parent_root);\n\n\t/*\n\t * insert the directory item\n\t */\n\tret = btrfs_set_inode_index(parent_inode, &index);\n\tBUG_ON(ret); /* -ENOMEM */\n\n\t/* check if there is a file/dir which has the same name. */\n\tdir_item = btrfs_lookup_dir_item(NULL, parent_root, path,\n\t\t\t\t\t btrfs_ino(parent_inode),\n\t\t\t\t\t dentry->d_name.name,\n\t\t\t\t\t dentry->d_name.len, 0);\n\tif (dir_item != NULL && !IS_ERR(dir_item)) {\n\t\tpending->error = -EEXIST;\n\t\tgoto dir_item_existed;\n\t} else if (IS_ERR(dir_item)) {\n\t\tret = PTR_ERR(dir_item);\n\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\tgoto fail;\n\t}\n\tbtrfs_release_path(path);\n\n\t/*\n\t * pull in the delayed directory update\n\t * and the delayed inode item\n\t * otherwise we corrupt the FS during\n\t * snapshot\n\t */\n\tret = btrfs_run_delayed_items(trans, root);\n\tif (ret) {\t/* Transaction aborted */\n\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\tgoto fail;\n\t}\n\n\trecord_root_in_trans(trans, root);\n\tbtrfs_set_root_last_snapshot(&root->root_item, trans->transid);\n\tmemcpy(new_root_item, &root->root_item, sizeof(*new_root_item));\n\tbtrfs_check_and_init_root_item(new_root_item);\n\n\troot_flags = btrfs_root_flags(new_root_item);\n\tif (pending->readonly)\n\t\troot_flags |= BTRFS_ROOT_SUBVOL_RDONLY;\n\telse\n\t\troot_flags &= ~BTRFS_ROOT_SUBVOL_RDONLY;\n\tbtrfs_set_root_flags(new_root_item, root_flags);\n\n\tbtrfs_set_root_generation_v2(new_root_item,\n\t\t\ttrans->transid);\n\tuuid_le_gen(&new_uuid);\n\tmemcpy(new_root_item->uuid, new_uuid.b, BTRFS_UUID_SIZE);\n\tmemcpy(new_root_item->parent_uuid, root->root_item.uuid,\n\t\t\tBTRFS_UUID_SIZE);\n\tif (!(root_flags & BTRFS_ROOT_SUBVOL_RDONLY)) {\n\t\tmemset(new_root_item->received_uuid, 0,\n\t\t       sizeof(new_root_item->received_uuid));\n\t\tmemset(&new_root_item->stime, 0, sizeof(new_root_item->stime));\n\t\tmemset(&new_root_item->rtime, 0, sizeof(new_root_item->rtime));\n\t\tbtrfs_set_root_stransid(new_root_item, 0);\n\t\tbtrfs_set_root_rtransid(new_root_item, 0);\n\t}\n\tbtrfs_set_stack_timespec_sec(&new_root_item->otime, cur_time.tv_sec);\n\tbtrfs_set_stack_timespec_nsec(&new_root_item->otime, cur_time.tv_nsec);\n\tbtrfs_set_root_otransid(new_root_item, trans->transid);\n\n\told = btrfs_lock_root_node(root);\n\tret = btrfs_cow_block(trans, root, old, NULL, 0, &old);\n\tif (ret) {\n\t\tbtrfs_tree_unlock(old);\n\t\tfree_extent_buffer(old);\n\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\tgoto fail;\n\t}\n\n\tbtrfs_set_lock_blocking(old);\n\n\tret = btrfs_copy_root(trans, root, old, &tmp, objectid);\n\t/* clean up in any case */\n\tbtrfs_tree_unlock(old);\n\tfree_extent_buffer(old);\n\tif (ret) {\n\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\tgoto fail;\n\t}\n\n\t/*\n\t * We need to flush delayed refs in order to make sure all of our quota\n\t * operations have been done before we call btrfs_qgroup_inherit.\n\t */\n\tret = btrfs_run_delayed_refs(trans, root, (unsigned long)-1);\n\tif (ret) {\n\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\tgoto fail;\n\t}\n\n\tret = btrfs_qgroup_inherit(trans, fs_info,\n\t\t\t\t   root->root_key.objectid,\n\t\t\t\t   objectid, pending->inherit);\n\tif (ret) {\n\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\tgoto fail;\n\t}\n\n\t/* see comments in should_cow_block() */\n\tset_bit(BTRFS_ROOT_FORCE_COW, &root->state);\n\tsmp_wmb();\n\n\tbtrfs_set_root_node(new_root_item, tmp);\n\t/* record when the snapshot was created in key.offset */\n\tkey.offset = trans->transid;\n\tret = btrfs_insert_root(trans, tree_root, &key, new_root_item);\n\tbtrfs_tree_unlock(tmp);\n\tfree_extent_buffer(tmp);\n\tif (ret) {\n\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\tgoto fail;\n\t}\n\n\t/*\n\t * insert root back/forward references\n\t */\n\tret = btrfs_add_root_ref(trans, tree_root, objectid,\n\t\t\t\t parent_root->root_key.objectid,\n\t\t\t\t btrfs_ino(parent_inode), index,\n\t\t\t\t dentry->d_name.name, dentry->d_name.len);\n\tif (ret) {\n\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\tgoto fail;\n\t}\n\n\tkey.offset = (u64)-1;\n\tpending->snap = btrfs_read_fs_root_no_name(root->fs_info, &key);\n\tif (IS_ERR(pending->snap)) {\n\t\tret = PTR_ERR(pending->snap);\n\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\tgoto fail;\n\t}\n\n\tret = btrfs_reloc_post_snapshot(trans, pending);\n\tif (ret) {\n\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\tgoto fail;\n\t}\n\n\tret = btrfs_run_delayed_refs(trans, root, (unsigned long)-1);\n\tif (ret) {\n\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\tgoto fail;\n\t}\n\n\tret = btrfs_insert_dir_item(trans, parent_root,\n\t\t\t\t    dentry->d_name.name, dentry->d_name.len,\n\t\t\t\t    parent_inode, &key,\n\t\t\t\t    BTRFS_FT_DIR, index);\n\t/* We have check then name at the beginning, so it is impossible. */\n\tBUG_ON(ret == -EEXIST || ret == -EOVERFLOW);\n\tif (ret) {\n\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\tgoto fail;\n\t}\n\n\tbtrfs_i_size_write(parent_inode, parent_inode->i_size +\n\t\t\t\t\t dentry->d_name.len * 2);\n\tparent_inode->i_mtime = parent_inode->i_ctime = CURRENT_TIME;\n\tret = btrfs_update_inode_fallback(trans, parent_root, parent_inode);\n\tif (ret) {\n\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\tgoto fail;\n\t}\n\tret = btrfs_uuid_tree_add(trans, fs_info->uuid_root, new_uuid.b,\n\t\t\t\t  BTRFS_UUID_KEY_SUBVOL, objectid);\n\tif (ret) {\n\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\tgoto fail;\n\t}\n\tif (!btrfs_is_empty_uuid(new_root_item->received_uuid)) {\n\t\tret = btrfs_uuid_tree_add(trans, fs_info->uuid_root,\n\t\t\t\t\t  new_root_item->received_uuid,\n\t\t\t\t\t  BTRFS_UUID_KEY_RECEIVED_SUBVOL,\n\t\t\t\t\t  objectid);\n\t\tif (ret && ret != -EEXIST) {\n\t\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\t\tgoto fail;\n\t\t}\n\t}\nfail:\n\tpending->error = ret;\ndir_item_existed:\n\ttrans->block_rsv = rsv;\n\ttrans->bytes_reserved = 0;\nno_free_objectid:\n\tkfree(new_root_item);\nroot_item_alloc_fail:\n\tbtrfs_free_path(path);\n\treturn ret;\n}"
  },
  {
    "function_name": "btrfs_defrag_root",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
    "lines": "1205-1236",
    "snippet": "int btrfs_defrag_root(struct btrfs_root *root)\n{\n\tstruct btrfs_fs_info *info = root->fs_info;\n\tstruct btrfs_trans_handle *trans;\n\tint ret;\n\n\tif (test_and_set_bit(BTRFS_ROOT_DEFRAG_RUNNING, &root->state))\n\t\treturn 0;\n\n\twhile (1) {\n\t\ttrans = btrfs_start_transaction(root, 0);\n\t\tif (IS_ERR(trans))\n\t\t\treturn PTR_ERR(trans);\n\n\t\tret = btrfs_defrag_leaves(trans, root);\n\n\t\tbtrfs_end_transaction(trans, root);\n\t\tbtrfs_btree_balance_dirty(info->tree_root);\n\t\tcond_resched();\n\n\t\tif (btrfs_fs_closing(root->fs_info) || ret != -EAGAIN)\n\t\t\tbreak;\n\n\t\tif (btrfs_defrag_cancelled(root->fs_info)) {\n\t\t\tpr_debug(\"BTRFS: defrag_root cancelled\\n\");\n\t\t\tret = -EAGAIN;\n\t\t\tbreak;\n\t\t}\n\t}\n\tclear_bit(BTRFS_ROOT_DEFRAG_RUNNING, &root->state);\n\treturn ret;\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"dev-replace.h\"",
      "#include \"volumes.h\"",
      "#include \"inode-map.h\"",
      "#include \"tree-log.h\"",
      "#include \"locking.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/uuid.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/writeback.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "BTRFS_ROOT_DEFRAG_RUNNING",
            "&root->state"
          ],
          "line": 1234
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clear_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "892-896",
          "snippet": "static inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"BTRFS: defrag_root cancelled\\n\""
          ],
          "line": 1229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_defrag_cancelled",
          "args": [
            "root->fs_info"
          ],
          "line": 1228
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_defrag_cancelled",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "4188-4191",
          "snippet": "static inline int btrfs_defrag_cancelled(struct btrfs_fs_info *fs_info)\n{\n\treturn signal_pending(current);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline int btrfs_defrag_cancelled(struct btrfs_fs_info *fs_info)\n{\n\treturn signal_pending(current);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_fs_closing",
          "args": [
            "root->fs_info"
          ],
          "line": 1225
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_fs_closing",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "3612-3619",
          "snippet": "static inline int btrfs_fs_closing(struct btrfs_fs_info *fs_info)\n{\n\t/*\n\t * Get synced with close_ctree()\n\t */\n\tsmp_mb();\n\treturn fs_info->closing;\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline int btrfs_fs_closing(struct btrfs_fs_info *fs_info)\n{\n\t/*\n\t * Get synced with close_ctree()\n\t */\n\tsmp_mb();\n\treturn fs_info->closing;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 1223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_btree_balance_dirty",
          "args": [
            "info->tree_root"
          ],
          "line": 1222
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_btree_balance_dirty_nodelay",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3826-3829",
          "snippet": "void btrfs_btree_balance_dirty_nodelay(struct btrfs_root *root)\n{\n\t__btrfs_btree_balance_dirty(root, 0);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_fs_root(struct btrfs_root *root);",
            "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
            "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
            "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
            "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
            "static void btrfs_error_commit_super(struct btrfs_root *root);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nvoid btrfs_btree_balance_dirty_nodelay(struct btrfs_root *root)\n{\n\t__btrfs_btree_balance_dirty(root, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_end_transaction",
          "args": [
            "trans",
            "root"
          ],
          "line": 1221
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_end_transaction_throttle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
          "lines": "846-850",
          "snippet": "int btrfs_end_transaction_throttle(struct btrfs_trans_handle *trans,\n\t\t\t\t   struct btrfs_root *root)\n{\n\treturn __btrfs_end_transaction(trans, root, 1);\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"dev-replace.h\"",
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint btrfs_end_transaction_throttle(struct btrfs_trans_handle *trans,\n\t\t\t\t   struct btrfs_root *root)\n{\n\treturn __btrfs_end_transaction(trans, root, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_defrag_leaves",
          "args": [
            "trans",
            "root"
          ],
          "line": 1219
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_defrag_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tree-defrag.c",
          "lines": "32-139",
          "snippet": "int btrfs_defrag_leaves(struct btrfs_trans_handle *trans,\n\t\t\tstruct btrfs_root *root)\n{\n\tstruct btrfs_path *path = NULL;\n\tstruct btrfs_key key;\n\tint ret = 0;\n\tint wret;\n\tint level;\n\tint next_key_ret = 0;\n\tu64 last_ret = 0;\n\tu64 min_trans = 0;\n\n\tif (root->fs_info->extent_root == root) {\n\t\t/*\n\t\t * there's recursion here right now in the tree locking,\n\t\t * we can't defrag the extent root without deadlock\n\t\t */\n\t\tgoto out;\n\t}\n\n\tif (!test_bit(BTRFS_ROOT_REF_COWS, &root->state))\n\t\tgoto out;\n\n\tif (btrfs_test_opt(root, SSD))\n\t\tgoto out;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tlevel = btrfs_header_level(root->node);\n\n\tif (level == 0)\n\t\tgoto out;\n\n\tif (root->defrag_progress.objectid == 0) {\n\t\tstruct extent_buffer *root_node;\n\t\tu32 nritems;\n\n\t\troot_node = btrfs_lock_root_node(root);\n\t\tbtrfs_set_lock_blocking(root_node);\n\t\tnritems = btrfs_header_nritems(root_node);\n\t\troot->defrag_max.objectid = 0;\n\t\t/* from above we know this is not a leaf */\n\t\tbtrfs_node_key_to_cpu(root_node, &root->defrag_max,\n\t\t\t\t      nritems - 1);\n\t\tbtrfs_tree_unlock(root_node);\n\t\tfree_extent_buffer(root_node);\n\t\tmemset(&key, 0, sizeof(key));\n\t} else {\n\t\tmemcpy(&key, &root->defrag_progress, sizeof(key));\n\t}\n\n\tpath->keep_locks = 1;\n\n\tret = btrfs_search_forward(root, &key, path, min_trans);\n\tif (ret < 0)\n\t\tgoto out;\n\tif (ret > 0) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\tbtrfs_release_path(path);\n\twret = btrfs_search_slot(trans, root, &key, path, 0, 1);\n\n\tif (wret < 0) {\n\t\tret = wret;\n\t\tgoto out;\n\t}\n\tif (!path->nodes[1]) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\tpath->slots[1] = btrfs_header_nritems(path->nodes[1]);\n\tnext_key_ret = btrfs_find_next_key(root, path, &key, 1,\n\t\t\t\t\t   min_trans);\n\tret = btrfs_realloc_node(trans, root,\n\t\t\t\t path->nodes[1], 0,\n\t\t\t\t &last_ret,\n\t\t\t\t &root->defrag_progress);\n\tif (ret) {\n\t\tWARN_ON(ret == -EAGAIN);\n\t\tgoto out;\n\t}\n\tif (next_key_ret == 0) {\n\t\tmemcpy(&root->defrag_progress, &key, sizeof(key));\n\t\tret = -EAGAIN;\n\t}\nout:\n\tif (path)\n\t\tbtrfs_free_path(path);\n\tif (ret == -EAGAIN) {\n\t\tif (root->defrag_max.objectid > root->defrag_progress.objectid)\n\t\t\tgoto done;\n\t\tif (root->defrag_max.type > root->defrag_progress.type)\n\t\t\tgoto done;\n\t\tif (root->defrag_max.offset > root->defrag_progress.offset)\n\t\t\tgoto done;\n\t\tret = 0;\n\t}\ndone:\n\tif (ret != -EAGAIN) {\n\t\tmemset(&root->defrag_progress, 0,\n\t\t       sizeof(root->defrag_progress));\n\t\troot->defrag_trans_start = trans->transid;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"transaction.h\"",
            "#include \"print-tree.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"transaction.h\"\n#include \"print-tree.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/sched.h>\n\nint btrfs_defrag_leaves(struct btrfs_trans_handle *trans,\n\t\t\tstruct btrfs_root *root)\n{\n\tstruct btrfs_path *path = NULL;\n\tstruct btrfs_key key;\n\tint ret = 0;\n\tint wret;\n\tint level;\n\tint next_key_ret = 0;\n\tu64 last_ret = 0;\n\tu64 min_trans = 0;\n\n\tif (root->fs_info->extent_root == root) {\n\t\t/*\n\t\t * there's recursion here right now in the tree locking,\n\t\t * we can't defrag the extent root without deadlock\n\t\t */\n\t\tgoto out;\n\t}\n\n\tif (!test_bit(BTRFS_ROOT_REF_COWS, &root->state))\n\t\tgoto out;\n\n\tif (btrfs_test_opt(root, SSD))\n\t\tgoto out;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tlevel = btrfs_header_level(root->node);\n\n\tif (level == 0)\n\t\tgoto out;\n\n\tif (root->defrag_progress.objectid == 0) {\n\t\tstruct extent_buffer *root_node;\n\t\tu32 nritems;\n\n\t\troot_node = btrfs_lock_root_node(root);\n\t\tbtrfs_set_lock_blocking(root_node);\n\t\tnritems = btrfs_header_nritems(root_node);\n\t\troot->defrag_max.objectid = 0;\n\t\t/* from above we know this is not a leaf */\n\t\tbtrfs_node_key_to_cpu(root_node, &root->defrag_max,\n\t\t\t\t      nritems - 1);\n\t\tbtrfs_tree_unlock(root_node);\n\t\tfree_extent_buffer(root_node);\n\t\tmemset(&key, 0, sizeof(key));\n\t} else {\n\t\tmemcpy(&key, &root->defrag_progress, sizeof(key));\n\t}\n\n\tpath->keep_locks = 1;\n\n\tret = btrfs_search_forward(root, &key, path, min_trans);\n\tif (ret < 0)\n\t\tgoto out;\n\tif (ret > 0) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\tbtrfs_release_path(path);\n\twret = btrfs_search_slot(trans, root, &key, path, 0, 1);\n\n\tif (wret < 0) {\n\t\tret = wret;\n\t\tgoto out;\n\t}\n\tif (!path->nodes[1]) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\tpath->slots[1] = btrfs_header_nritems(path->nodes[1]);\n\tnext_key_ret = btrfs_find_next_key(root, path, &key, 1,\n\t\t\t\t\t   min_trans);\n\tret = btrfs_realloc_node(trans, root,\n\t\t\t\t path->nodes[1], 0,\n\t\t\t\t &last_ret,\n\t\t\t\t &root->defrag_progress);\n\tif (ret) {\n\t\tWARN_ON(ret == -EAGAIN);\n\t\tgoto out;\n\t}\n\tif (next_key_ret == 0) {\n\t\tmemcpy(&root->defrag_progress, &key, sizeof(key));\n\t\tret = -EAGAIN;\n\t}\nout:\n\tif (path)\n\t\tbtrfs_free_path(path);\n\tif (ret == -EAGAIN) {\n\t\tif (root->defrag_max.objectid > root->defrag_progress.objectid)\n\t\t\tgoto done;\n\t\tif (root->defrag_max.type > root->defrag_progress.type)\n\t\t\tgoto done;\n\t\tif (root->defrag_max.offset > root->defrag_progress.offset)\n\t\t\tgoto done;\n\t\tret = 0;\n\t}\ndone:\n\tif (ret != -EAGAIN) {\n\t\tmemset(&root->defrag_progress, 0,\n\t\t       sizeof(root->defrag_progress));\n\t\troot->defrag_trans_start = trans->transid;\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "trans"
          ],
          "line": 1217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "trans"
          ],
          "line": 1216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_start_transaction",
          "args": [
            "root",
            "0"
          ],
          "line": 1215
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_start_transaction_lflush",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
          "lines": "569-574",
          "snippet": "struct btrfs_trans_handle *btrfs_start_transaction_lflush(\n\t\t\t\t\tstruct btrfs_root *root, int num_items)\n{\n\treturn start_transaction(root, num_items, TRANS_START,\n\t\t\t\t BTRFS_RESERVE_FLUSH_LIMIT);\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"dev-replace.h\"",
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstruct btrfs_trans_handle *btrfs_start_transaction_lflush(\n\t\t\t\t\tstruct btrfs_root *root, int num_items)\n{\n\treturn start_transaction(root, num_items, TRANS_START,\n\t\t\t\t BTRFS_RESERVE_FLUSH_LIMIT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_and_set_bit",
          "args": [
            "BTRFS_ROOT_DEFRAG_RUNNING",
            "&root->state"
          ],
          "line": 1211
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_test_and_set_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1117-1127",
          "snippet": "static inline int f2fs_test_and_set_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr |= mask;\n\treturn ret;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int f2fs_test_and_set_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr |= mask;\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint btrfs_defrag_root(struct btrfs_root *root)\n{\n\tstruct btrfs_fs_info *info = root->fs_info;\n\tstruct btrfs_trans_handle *trans;\n\tint ret;\n\n\tif (test_and_set_bit(BTRFS_ROOT_DEFRAG_RUNNING, &root->state))\n\t\treturn 0;\n\n\twhile (1) {\n\t\ttrans = btrfs_start_transaction(root, 0);\n\t\tif (IS_ERR(trans))\n\t\t\treturn PTR_ERR(trans);\n\n\t\tret = btrfs_defrag_leaves(trans, root);\n\n\t\tbtrfs_end_transaction(trans, root);\n\t\tbtrfs_btree_balance_dirty(info->tree_root);\n\t\tcond_resched();\n\n\t\tif (btrfs_fs_closing(root->fs_info) || ret != -EAGAIN)\n\t\t\tbreak;\n\n\t\tif (btrfs_defrag_cancelled(root->fs_info)) {\n\t\t\tpr_debug(\"BTRFS: defrag_root cancelled\\n\");\n\t\t\tret = -EAGAIN;\n\t\t\tbreak;\n\t\t}\n\t}\n\tclear_bit(BTRFS_ROOT_DEFRAG_RUNNING, &root->state);\n\treturn ret;\n}"
  },
  {
    "function_name": "commit_fs_roots",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
    "lines": "1148-1199",
    "snippet": "static noinline int commit_fs_roots(struct btrfs_trans_handle *trans,\n\t\t\t\t    struct btrfs_root *root)\n{\n\tstruct btrfs_root *gang[8];\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tint i;\n\tint ret;\n\tint err = 0;\n\n\tspin_lock(&fs_info->fs_roots_radix_lock);\n\twhile (1) {\n\t\tret = radix_tree_gang_lookup_tag(&fs_info->fs_roots_radix,\n\t\t\t\t\t\t (void **)gang, 0,\n\t\t\t\t\t\t ARRAY_SIZE(gang),\n\t\t\t\t\t\t BTRFS_ROOT_TRANS_TAG);\n\t\tif (ret == 0)\n\t\t\tbreak;\n\t\tfor (i = 0; i < ret; i++) {\n\t\t\troot = gang[i];\n\t\t\tradix_tree_tag_clear(&fs_info->fs_roots_radix,\n\t\t\t\t\t(unsigned long)root->root_key.objectid,\n\t\t\t\t\tBTRFS_ROOT_TRANS_TAG);\n\t\t\tspin_unlock(&fs_info->fs_roots_radix_lock);\n\n\t\t\tbtrfs_free_log(trans, root);\n\t\t\tbtrfs_update_reloc_root(trans, root);\n\t\t\tbtrfs_orphan_commit_root(trans, root);\n\n\t\t\tbtrfs_save_ino_cache(root, trans);\n\n\t\t\t/* see comments in should_cow_block() */\n\t\t\tclear_bit(BTRFS_ROOT_FORCE_COW, &root->state);\n\t\t\tsmp_mb__after_atomic();\n\n\t\t\tif (root->commit_root != root->node) {\n\t\t\t\tlist_add_tail(&root->dirty_list,\n\t\t\t\t\t&trans->transaction->switch_commits);\n\t\t\t\tbtrfs_set_root_node(&root->root_item,\n\t\t\t\t\t\t    root->node);\n\t\t\t}\n\n\t\t\terr = btrfs_update_root(trans, fs_info->tree_root,\n\t\t\t\t\t\t&root->root_key,\n\t\t\t\t\t\t&root->root_item);\n\t\t\tspin_lock(&fs_info->fs_roots_radix_lock);\n\t\t\tif (err)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&fs_info->fs_roots_radix_lock);\n\treturn err;\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"dev-replace.h\"",
      "#include \"volumes.h\"",
      "#include \"inode-map.h\"",
      "#include \"tree-log.h\"",
      "#include \"locking.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/uuid.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/writeback.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [
      "#define BTRFS_ROOT_TRANS_TAG 0"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&fs_info->fs_roots_radix_lock"
          ],
          "line": 1197
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&fs_info->fs_roots_radix_lock"
          ],
          "line": 1192
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_update_root",
          "args": [
            "trans",
            "fs_info->tree_root",
            "&root->root_key",
            "&root->root_item"
          ],
          "line": 1189
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_update_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/root-tree.c",
          "lines": "135-210",
          "snippet": "int btrfs_update_root(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_key *key, struct btrfs_root_item\n\t\t      *item)\n{\n\tstruct btrfs_path *path;\n\tstruct extent_buffer *l;\n\tint ret;\n\tint slot;\n\tunsigned long ptr;\n\tint old_len;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tret = btrfs_search_slot(trans, root, key, path, 0, 1);\n\tif (ret < 0) {\n\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\tgoto out;\n\t}\n\n\tif (ret != 0) {\n\t\tbtrfs_print_leaf(root, path->nodes[0]);\n\t\tbtrfs_crit(root->fs_info, \"unable to update root key %llu %u %llu\",\n\t\t       key->objectid, key->type, key->offset);\n\t\tBUG_ON(1);\n\t}\n\n\tl = path->nodes[0];\n\tslot = path->slots[0];\n\tptr = btrfs_item_ptr_offset(l, slot);\n\told_len = btrfs_item_size_nr(l, slot);\n\n\t/*\n\t * If this is the first time we update the root item which originated\n\t * from an older kernel, we need to enlarge the item size to make room\n\t * for the added fields.\n\t */\n\tif (old_len < sizeof(*item)) {\n\t\tbtrfs_release_path(path);\n\t\tret = btrfs_search_slot(trans, root, key, path,\n\t\t\t\t-1, 1);\n\t\tif (ret < 0) {\n\t\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = btrfs_del_item(trans, root, path);\n\t\tif (ret < 0) {\n\t\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\t\tgoto out;\n\t\t}\n\t\tbtrfs_release_path(path);\n\t\tret = btrfs_insert_empty_item(trans, root, path,\n\t\t\t\tkey, sizeof(*item));\n\t\tif (ret < 0) {\n\t\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\t\tgoto out;\n\t\t}\n\t\tl = path->nodes[0];\n\t\tslot = path->slots[0];\n\t\tptr = btrfs_item_ptr_offset(l, slot);\n\t}\n\n\t/*\n\t * Update generation_v2 so at the next mount we know the new root\n\t * fields are valid.\n\t */\n\tbtrfs_set_root_generation_v2(item, btrfs_root_generation(item));\n\n\twrite_extent_buffer(l, item, ptr, sizeof(*item));\n\tbtrfs_mark_buffer_dirty(path->nodes[0]);\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}",
          "includes": [
            "#include \"print-tree.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uuid.h>",
            "#include <linux/err.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"print-tree.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/err.h>\n\nint btrfs_update_root(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_key *key, struct btrfs_root_item\n\t\t      *item)\n{\n\tstruct btrfs_path *path;\n\tstruct extent_buffer *l;\n\tint ret;\n\tint slot;\n\tunsigned long ptr;\n\tint old_len;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tret = btrfs_search_slot(trans, root, key, path, 0, 1);\n\tif (ret < 0) {\n\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\tgoto out;\n\t}\n\n\tif (ret != 0) {\n\t\tbtrfs_print_leaf(root, path->nodes[0]);\n\t\tbtrfs_crit(root->fs_info, \"unable to update root key %llu %u %llu\",\n\t\t       key->objectid, key->type, key->offset);\n\t\tBUG_ON(1);\n\t}\n\n\tl = path->nodes[0];\n\tslot = path->slots[0];\n\tptr = btrfs_item_ptr_offset(l, slot);\n\told_len = btrfs_item_size_nr(l, slot);\n\n\t/*\n\t * If this is the first time we update the root item which originated\n\t * from an older kernel, we need to enlarge the item size to make room\n\t * for the added fields.\n\t */\n\tif (old_len < sizeof(*item)) {\n\t\tbtrfs_release_path(path);\n\t\tret = btrfs_search_slot(trans, root, key, path,\n\t\t\t\t-1, 1);\n\t\tif (ret < 0) {\n\t\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = btrfs_del_item(trans, root, path);\n\t\tif (ret < 0) {\n\t\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\t\tgoto out;\n\t\t}\n\t\tbtrfs_release_path(path);\n\t\tret = btrfs_insert_empty_item(trans, root, path,\n\t\t\t\tkey, sizeof(*item));\n\t\tif (ret < 0) {\n\t\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\t\tgoto out;\n\t\t}\n\t\tl = path->nodes[0];\n\t\tslot = path->slots[0];\n\t\tptr = btrfs_item_ptr_offset(l, slot);\n\t}\n\n\t/*\n\t * Update generation_v2 so at the next mount we know the new root\n\t * fields are valid.\n\t */\n\tbtrfs_set_root_generation_v2(item, btrfs_root_generation(item));\n\n\twrite_extent_buffer(l, item, ptr, sizeof(*item));\n\tbtrfs_mark_buffer_dirty(path->nodes[0]);\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_set_root_node",
          "args": [
            "&root->root_item",
            "root->node"
          ],
          "line": 1185
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_root_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/root-tree.c",
          "lines": "124-130",
          "snippet": "void btrfs_set_root_node(struct btrfs_root_item *item,\n\t\t\t struct extent_buffer *node)\n{\n\tbtrfs_set_root_bytenr(item, node->start);\n\tbtrfs_set_root_level(item, btrfs_header_level(node));\n\tbtrfs_set_root_generation(item, btrfs_header_generation(node));\n}",
          "includes": [
            "#include \"print-tree.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uuid.h>",
            "#include <linux/err.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"print-tree.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/err.h>\n\nvoid btrfs_set_root_node(struct btrfs_root_item *item,\n\t\t\t struct extent_buffer *node)\n{\n\tbtrfs_set_root_bytenr(item, node->start);\n\tbtrfs_set_root_level(item, btrfs_header_level(node));\n\tbtrfs_set_root_generation(item, btrfs_header_generation(node));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&root->dirty_list",
            "&trans->transaction->switch_commits"
          ],
          "line": 1183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_mb__after_atomic",
          "args": [],
          "line": 1180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "BTRFS_ROOT_FORCE_COW",
            "&root->state"
          ],
          "line": 1179
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clear_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "892-896",
          "snippet": "static inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_save_ino_cache",
          "args": [
            "root",
            "trans"
          ],
          "line": 1176
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_save_ino_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/inode-map.c",
          "lines": "385-509",
          "snippet": "int btrfs_save_ino_cache(struct btrfs_root *root,\n\t\t\t struct btrfs_trans_handle *trans)\n{\n\tstruct btrfs_free_space_ctl *ctl = root->free_ino_ctl;\n\tstruct btrfs_path *path;\n\tstruct inode *inode;\n\tstruct btrfs_block_rsv *rsv;\n\tu64 num_bytes;\n\tu64 alloc_hint = 0;\n\tint ret;\n\tint prealloc;\n\tbool retry = false;\n\n\t/* only fs tree and subvol/snap needs ino cache */\n\tif (root->root_key.objectid != BTRFS_FS_TREE_OBJECTID &&\n\t    (root->root_key.objectid < BTRFS_FIRST_FREE_OBJECTID ||\n\t     root->root_key.objectid > BTRFS_LAST_FREE_OBJECTID))\n\t\treturn 0;\n\n\t/* Don't save inode cache if we are deleting this root */\n\tif (btrfs_root_refs(&root->root_item) == 0)\n\t\treturn 0;\n\n\tif (!btrfs_test_opt(root, INODE_MAP_CACHE))\n\t\treturn 0;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\trsv = trans->block_rsv;\n\ttrans->block_rsv = &root->fs_info->trans_block_rsv;\n\n\tnum_bytes = trans->bytes_reserved;\n\t/*\n\t * 1 item for inode item insertion if need\n\t * 4 items for inode item update (in the worst case)\n\t * 1 items for slack space if we need do truncation\n\t * 1 item for free space object\n\t * 3 items for pre-allocation\n\t */\n\ttrans->bytes_reserved = btrfs_calc_trans_metadata_size(root, 10);\n\tret = btrfs_block_rsv_add(root, trans->block_rsv,\n\t\t\t\t  trans->bytes_reserved,\n\t\t\t\t  BTRFS_RESERVE_NO_FLUSH);\n\tif (ret)\n\t\tgoto out;\n\ttrace_btrfs_space_reservation(root->fs_info, \"ino_cache\",\n\t\t\t\t      trans->transid, trans->bytes_reserved, 1);\nagain:\n\tinode = lookup_free_ino_inode(root, path);\n\tif (IS_ERR(inode) && (PTR_ERR(inode) != -ENOENT || retry)) {\n\t\tret = PTR_ERR(inode);\n\t\tgoto out_release;\n\t}\n\n\tif (IS_ERR(inode)) {\n\t\tBUG_ON(retry); /* Logic error */\n\t\tretry = true;\n\n\t\tret = create_free_ino_inode(root, trans, path);\n\t\tif (ret)\n\t\t\tgoto out_release;\n\t\tgoto again;\n\t}\n\n\tBTRFS_I(inode)->generation = 0;\n\tret = btrfs_update_inode(trans, root, inode);\n\tif (ret) {\n\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\tgoto out_put;\n\t}\n\n\tif (i_size_read(inode) > 0) {\n\t\tret = btrfs_truncate_free_space_cache(root, trans, inode);\n\t\tif (ret) {\n\t\t\tif (ret != -ENOSPC)\n\t\t\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\t\tgoto out_put;\n\t\t}\n\t}\n\n\tspin_lock(&root->ino_cache_lock);\n\tif (root->ino_cache_state != BTRFS_CACHE_FINISHED) {\n\t\tret = -1;\n\t\tspin_unlock(&root->ino_cache_lock);\n\t\tgoto out_put;\n\t}\n\tspin_unlock(&root->ino_cache_lock);\n\n\tspin_lock(&ctl->tree_lock);\n\tprealloc = sizeof(struct btrfs_free_space) * ctl->free_extents;\n\tprealloc = ALIGN(prealloc, PAGE_CACHE_SIZE);\n\tprealloc += ctl->total_bitmaps * PAGE_CACHE_SIZE;\n\tspin_unlock(&ctl->tree_lock);\n\n\t/* Just to make sure we have enough space */\n\tprealloc += 8 * PAGE_CACHE_SIZE;\n\n\tret = btrfs_delalloc_reserve_space(inode, prealloc);\n\tif (ret)\n\t\tgoto out_put;\n\n\tret = btrfs_prealloc_file_range_trans(inode, trans, 0, 0, prealloc,\n\t\t\t\t\t      prealloc, prealloc, &alloc_hint);\n\tif (ret) {\n\t\tbtrfs_delalloc_release_space(inode, prealloc);\n\t\tgoto out_put;\n\t}\n\tbtrfs_free_reserved_data_space(inode, prealloc);\n\n\tret = btrfs_write_out_ino_cache(root, trans, path, inode);\nout_put:\n\tiput(inode);\nout_release:\n\ttrace_btrfs_space_reservation(root->fs_info, \"ino_cache\",\n\t\t\t\t      trans->transid, trans->bytes_reserved, 0);\n\tbtrfs_block_rsv_release(root, trans->block_rsv, trans->bytes_reserved);\nout:\n\ttrans->block_rsv = rsv;\n\ttrans->bytes_reserved = num_bytes;\n\n\tbtrfs_free_path(path);\n\treturn ret;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n\nint btrfs_save_ino_cache(struct btrfs_root *root,\n\t\t\t struct btrfs_trans_handle *trans)\n{\n\tstruct btrfs_free_space_ctl *ctl = root->free_ino_ctl;\n\tstruct btrfs_path *path;\n\tstruct inode *inode;\n\tstruct btrfs_block_rsv *rsv;\n\tu64 num_bytes;\n\tu64 alloc_hint = 0;\n\tint ret;\n\tint prealloc;\n\tbool retry = false;\n\n\t/* only fs tree and subvol/snap needs ino cache */\n\tif (root->root_key.objectid != BTRFS_FS_TREE_OBJECTID &&\n\t    (root->root_key.objectid < BTRFS_FIRST_FREE_OBJECTID ||\n\t     root->root_key.objectid > BTRFS_LAST_FREE_OBJECTID))\n\t\treturn 0;\n\n\t/* Don't save inode cache if we are deleting this root */\n\tif (btrfs_root_refs(&root->root_item) == 0)\n\t\treturn 0;\n\n\tif (!btrfs_test_opt(root, INODE_MAP_CACHE))\n\t\treturn 0;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\trsv = trans->block_rsv;\n\ttrans->block_rsv = &root->fs_info->trans_block_rsv;\n\n\tnum_bytes = trans->bytes_reserved;\n\t/*\n\t * 1 item for inode item insertion if need\n\t * 4 items for inode item update (in the worst case)\n\t * 1 items for slack space if we need do truncation\n\t * 1 item for free space object\n\t * 3 items for pre-allocation\n\t */\n\ttrans->bytes_reserved = btrfs_calc_trans_metadata_size(root, 10);\n\tret = btrfs_block_rsv_add(root, trans->block_rsv,\n\t\t\t\t  trans->bytes_reserved,\n\t\t\t\t  BTRFS_RESERVE_NO_FLUSH);\n\tif (ret)\n\t\tgoto out;\n\ttrace_btrfs_space_reservation(root->fs_info, \"ino_cache\",\n\t\t\t\t      trans->transid, trans->bytes_reserved, 1);\nagain:\n\tinode = lookup_free_ino_inode(root, path);\n\tif (IS_ERR(inode) && (PTR_ERR(inode) != -ENOENT || retry)) {\n\t\tret = PTR_ERR(inode);\n\t\tgoto out_release;\n\t}\n\n\tif (IS_ERR(inode)) {\n\t\tBUG_ON(retry); /* Logic error */\n\t\tretry = true;\n\n\t\tret = create_free_ino_inode(root, trans, path);\n\t\tif (ret)\n\t\t\tgoto out_release;\n\t\tgoto again;\n\t}\n\n\tBTRFS_I(inode)->generation = 0;\n\tret = btrfs_update_inode(trans, root, inode);\n\tif (ret) {\n\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\tgoto out_put;\n\t}\n\n\tif (i_size_read(inode) > 0) {\n\t\tret = btrfs_truncate_free_space_cache(root, trans, inode);\n\t\tif (ret) {\n\t\t\tif (ret != -ENOSPC)\n\t\t\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\t\tgoto out_put;\n\t\t}\n\t}\n\n\tspin_lock(&root->ino_cache_lock);\n\tif (root->ino_cache_state != BTRFS_CACHE_FINISHED) {\n\t\tret = -1;\n\t\tspin_unlock(&root->ino_cache_lock);\n\t\tgoto out_put;\n\t}\n\tspin_unlock(&root->ino_cache_lock);\n\n\tspin_lock(&ctl->tree_lock);\n\tprealloc = sizeof(struct btrfs_free_space) * ctl->free_extents;\n\tprealloc = ALIGN(prealloc, PAGE_CACHE_SIZE);\n\tprealloc += ctl->total_bitmaps * PAGE_CACHE_SIZE;\n\tspin_unlock(&ctl->tree_lock);\n\n\t/* Just to make sure we have enough space */\n\tprealloc += 8 * PAGE_CACHE_SIZE;\n\n\tret = btrfs_delalloc_reserve_space(inode, prealloc);\n\tif (ret)\n\t\tgoto out_put;\n\n\tret = btrfs_prealloc_file_range_trans(inode, trans, 0, 0, prealloc,\n\t\t\t\t\t      prealloc, prealloc, &alloc_hint);\n\tif (ret) {\n\t\tbtrfs_delalloc_release_space(inode, prealloc);\n\t\tgoto out_put;\n\t}\n\tbtrfs_free_reserved_data_space(inode, prealloc);\n\n\tret = btrfs_write_out_ino_cache(root, trans, path, inode);\nout_put:\n\tiput(inode);\nout_release:\n\ttrace_btrfs_space_reservation(root->fs_info, \"ino_cache\",\n\t\t\t\t      trans->transid, trans->bytes_reserved, 0);\n\tbtrfs_block_rsv_release(root, trans->block_rsv, trans->bytes_reserved);\nout:\n\ttrans->block_rsv = rsv;\n\ttrans->bytes_reserved = num_bytes;\n\n\tbtrfs_free_path(path);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_orphan_commit_root",
          "args": [
            "trans",
            "root"
          ],
          "line": 1174
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_orphan_commit_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/inode.c",
          "lines": "3130-3170",
          "snippet": "void btrfs_orphan_commit_root(struct btrfs_trans_handle *trans,\n\t\t\t      struct btrfs_root *root)\n{\n\tstruct btrfs_block_rsv *block_rsv;\n\tint ret;\n\n\tif (atomic_read(&root->orphan_inodes) ||\n\t    root->orphan_cleanup_state != ORPHAN_CLEANUP_DONE)\n\t\treturn;\n\n\tspin_lock(&root->orphan_lock);\n\tif (atomic_read(&root->orphan_inodes)) {\n\t\tspin_unlock(&root->orphan_lock);\n\t\treturn;\n\t}\n\n\tif (root->orphan_cleanup_state != ORPHAN_CLEANUP_DONE) {\n\t\tspin_unlock(&root->orphan_lock);\n\t\treturn;\n\t}\n\n\tblock_rsv = root->orphan_block_rsv;\n\troot->orphan_block_rsv = NULL;\n\tspin_unlock(&root->orphan_lock);\n\n\tif (test_bit(BTRFS_ROOT_ORPHAN_ITEM_INSERTED, &root->state) &&\n\t    btrfs_root_refs(&root->root_item) > 0) {\n\t\tret = btrfs_del_orphan_item(trans, root->fs_info->tree_root,\n\t\t\t\t\t    root->root_key.objectid);\n\t\tif (ret)\n\t\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\telse\n\t\t\tclear_bit(BTRFS_ROOT_ORPHAN_ITEM_INSERTED,\n\t\t\t\t  &root->state);\n\t}\n\n\tif (block_rsv) {\n\t\tWARN_ON(block_rsv->size > 0);\n\t\tbtrfs_free_block_rsv(root, block_rsv);\n\t}\n}",
          "includes": [
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"compression.h\"",
            "#include \"volumes.h\"",
            "#include \"tree-log.h\"",
            "#include \"xattr.h\"",
            "#include \"ordered-data.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/falloc.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/aio.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"props.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"compression.h\"\n#include \"volumes.h\"\n#include \"tree-log.h\"\n#include \"xattr.h\"\n#include \"ordered-data.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/blkdev.h>\n#include <linux/btrfs.h>\n#include <linux/mount.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/bit_spinlock.h>\n#include <linux/aio.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nvoid btrfs_orphan_commit_root(struct btrfs_trans_handle *trans,\n\t\t\t      struct btrfs_root *root)\n{\n\tstruct btrfs_block_rsv *block_rsv;\n\tint ret;\n\n\tif (atomic_read(&root->orphan_inodes) ||\n\t    root->orphan_cleanup_state != ORPHAN_CLEANUP_DONE)\n\t\treturn;\n\n\tspin_lock(&root->orphan_lock);\n\tif (atomic_read(&root->orphan_inodes)) {\n\t\tspin_unlock(&root->orphan_lock);\n\t\treturn;\n\t}\n\n\tif (root->orphan_cleanup_state != ORPHAN_CLEANUP_DONE) {\n\t\tspin_unlock(&root->orphan_lock);\n\t\treturn;\n\t}\n\n\tblock_rsv = root->orphan_block_rsv;\n\troot->orphan_block_rsv = NULL;\n\tspin_unlock(&root->orphan_lock);\n\n\tif (test_bit(BTRFS_ROOT_ORPHAN_ITEM_INSERTED, &root->state) &&\n\t    btrfs_root_refs(&root->root_item) > 0) {\n\t\tret = btrfs_del_orphan_item(trans, root->fs_info->tree_root,\n\t\t\t\t\t    root->root_key.objectid);\n\t\tif (ret)\n\t\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\telse\n\t\t\tclear_bit(BTRFS_ROOT_ORPHAN_ITEM_INSERTED,\n\t\t\t\t  &root->state);\n\t}\n\n\tif (block_rsv) {\n\t\tWARN_ON(block_rsv->size > 0);\n\t\tbtrfs_free_block_rsv(root, block_rsv);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_update_reloc_root",
          "args": [
            "trans",
            "root"
          ],
          "line": 1173
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_update_reloc_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/relocation.c",
          "lines": "1478-1509",
          "snippet": "int btrfs_update_reloc_root(struct btrfs_trans_handle *trans,\n\t\t\t    struct btrfs_root *root)\n{\n\tstruct btrfs_root *reloc_root;\n\tstruct btrfs_root_item *root_item;\n\tint ret;\n\n\tif (!root->reloc_root)\n\t\tgoto out;\n\n\treloc_root = root->reloc_root;\n\troot_item = &reloc_root->root_item;\n\n\tif (root->fs_info->reloc_ctl->merge_reloc_tree &&\n\t    btrfs_root_refs(root_item) == 0) {\n\t\troot->reloc_root = NULL;\n\t\t__del_reloc_root(reloc_root);\n\t}\n\n\tif (reloc_root->commit_root != reloc_root->node) {\n\t\tbtrfs_set_root_node(root_item, reloc_root->node);\n\t\tfree_extent_buffer(reloc_root->commit_root);\n\t\treloc_root->commit_root = btrfs_root_node(reloc_root);\n\t}\n\n\tret = btrfs_update_root(trans, root->fs_info->tree_root,\n\t\t\t\t&reloc_root->root_key, root_item);\n\tBUG_ON(ret);\n\nout:\n\treturn 0;\n}",
          "includes": [
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"async-thread.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void remove_backref_node(struct backref_cache *cache,\n\t\t\t\tstruct backref_node *node);",
            "static void __mark_block_processed(struct reloc_control *rc,\n\t\t\t\t   struct backref_node *node);",
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"async-thread.h\"\n#include \"btrfs_inode.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void remove_backref_node(struct backref_cache *cache,\n\t\t\t\tstruct backref_node *node);\nstatic void __mark_block_processed(struct reloc_control *rc,\n\t\t\t\t   struct backref_node *node);\nstatic noinline_for_stack\nstruct;\n\nint btrfs_update_reloc_root(struct btrfs_trans_handle *trans,\n\t\t\t    struct btrfs_root *root)\n{\n\tstruct btrfs_root *reloc_root;\n\tstruct btrfs_root_item *root_item;\n\tint ret;\n\n\tif (!root->reloc_root)\n\t\tgoto out;\n\n\treloc_root = root->reloc_root;\n\troot_item = &reloc_root->root_item;\n\n\tif (root->fs_info->reloc_ctl->merge_reloc_tree &&\n\t    btrfs_root_refs(root_item) == 0) {\n\t\troot->reloc_root = NULL;\n\t\t__del_reloc_root(reloc_root);\n\t}\n\n\tif (reloc_root->commit_root != reloc_root->node) {\n\t\tbtrfs_set_root_node(root_item, reloc_root->node);\n\t\tfree_extent_buffer(reloc_root->commit_root);\n\t\treloc_root->commit_root = btrfs_root_node(reloc_root);\n\t}\n\n\tret = btrfs_update_root(trans, root->fs_info->tree_root,\n\t\t\t\t&reloc_root->root_key, root_item);\n\tBUG_ON(ret);\n\nout:\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_free_log",
          "args": [
            "trans",
            "root"
          ],
          "line": 1172
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_free_log_root_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tree-log.c",
          "lines": "2811-2819",
          "snippet": "int btrfs_free_log_root_tree(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_fs_info *fs_info)\n{\n\tif (fs_info->log_root_tree) {\n\t\tfree_log_tree(trans, fs_info->log_root_tree);\n\t\tfs_info->log_root_tree = NULL;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"print-tree.h\"",
            "#include \"locking.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include <linux/list_sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hash.h\"\n#include \"backref.h\"\n#include \"print-tree.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include <linux/list_sort.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nint btrfs_free_log_root_tree(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_fs_info *fs_info)\n{\n\tif (fs_info->log_root_tree) {\n\t\tfree_log_tree(trans, fs_info->log_root_tree);\n\t\tfs_info->log_root_tree = NULL;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "radix_tree_tag_clear",
          "args": [
            "&fs_info->fs_roots_radix",
            "(unsigned long)root->root_key.objectid",
            "BTRFS_ROOT_TRANS_TAG"
          ],
          "line": 1167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "radix_tree_gang_lookup_tag",
          "args": [
            "&fs_info->fs_roots_radix",
            "(void **)gang",
            "0",
            "ARRAY_SIZE(gang)",
            "BTRFS_ROOT_TRANS_TAG"
          ],
          "line": 1159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "gang"
          ],
          "line": 1161
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\n#define BTRFS_ROOT_TRANS_TAG 0\n\nstatic noinline int commit_fs_roots(struct btrfs_trans_handle *trans,\n\t\t\t\t    struct btrfs_root *root)\n{\n\tstruct btrfs_root *gang[8];\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tint i;\n\tint ret;\n\tint err = 0;\n\n\tspin_lock(&fs_info->fs_roots_radix_lock);\n\twhile (1) {\n\t\tret = radix_tree_gang_lookup_tag(&fs_info->fs_roots_radix,\n\t\t\t\t\t\t (void **)gang, 0,\n\t\t\t\t\t\t ARRAY_SIZE(gang),\n\t\t\t\t\t\t BTRFS_ROOT_TRANS_TAG);\n\t\tif (ret == 0)\n\t\t\tbreak;\n\t\tfor (i = 0; i < ret; i++) {\n\t\t\troot = gang[i];\n\t\t\tradix_tree_tag_clear(&fs_info->fs_roots_radix,\n\t\t\t\t\t(unsigned long)root->root_key.objectid,\n\t\t\t\t\tBTRFS_ROOT_TRANS_TAG);\n\t\t\tspin_unlock(&fs_info->fs_roots_radix_lock);\n\n\t\t\tbtrfs_free_log(trans, root);\n\t\t\tbtrfs_update_reloc_root(trans, root);\n\t\t\tbtrfs_orphan_commit_root(trans, root);\n\n\t\t\tbtrfs_save_ino_cache(root, trans);\n\n\t\t\t/* see comments in should_cow_block() */\n\t\t\tclear_bit(BTRFS_ROOT_FORCE_COW, &root->state);\n\t\t\tsmp_mb__after_atomic();\n\n\t\t\tif (root->commit_root != root->node) {\n\t\t\t\tlist_add_tail(&root->dirty_list,\n\t\t\t\t\t&trans->transaction->switch_commits);\n\t\t\t\tbtrfs_set_root_node(&root->root_item,\n\t\t\t\t\t\t    root->node);\n\t\t\t}\n\n\t\t\terr = btrfs_update_root(trans, fs_info->tree_root,\n\t\t\t\t\t\t&root->root_key,\n\t\t\t\t\t\t&root->root_item);\n\t\t\tspin_lock(&fs_info->fs_roots_radix_lock);\n\t\t\tif (err)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&fs_info->fs_roots_radix_lock);\n\treturn err;\n}"
  },
  {
    "function_name": "btrfs_add_dead_root",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
    "lines": "1137-1143",
    "snippet": "void btrfs_add_dead_root(struct btrfs_root *root)\n{\n\tspin_lock(&root->fs_info->trans_lock);\n\tif (list_empty(&root->root_list))\n\t\tlist_add_tail(&root->root_list, &root->fs_info->dead_roots);\n\tspin_unlock(&root->fs_info->trans_lock);\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"dev-replace.h\"",
      "#include \"volumes.h\"",
      "#include \"inode-map.h\"",
      "#include \"tree-log.h\"",
      "#include \"locking.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/uuid.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/writeback.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&root->fs_info->trans_lock"
          ],
          "line": 1142
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&root->root_list",
            "&root->fs_info->dead_roots"
          ],
          "line": 1141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&root->root_list"
          ],
          "line": 1140
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&root->fs_info->trans_lock"
          ],
          "line": 1139
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid btrfs_add_dead_root(struct btrfs_root *root)\n{\n\tspin_lock(&root->fs_info->trans_lock);\n\tif (list_empty(&root->root_list))\n\t\tlist_add_tail(&root->root_list, &root->fs_info->dead_roots);\n\tspin_unlock(&root->fs_info->trans_lock);\n}"
  },
  {
    "function_name": "commit_cowonly_roots",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
    "lines": "1055-1130",
    "snippet": "static noinline int commit_cowonly_roots(struct btrfs_trans_handle *trans,\n\t\t\t\t\t struct btrfs_root *root)\n{\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tstruct list_head *dirty_bgs = &trans->transaction->dirty_bgs;\n\tstruct list_head *next;\n\tstruct extent_buffer *eb;\n\tint ret;\n\n\teb = btrfs_lock_root_node(fs_info->tree_root);\n\tret = btrfs_cow_block(trans, fs_info->tree_root, eb, NULL,\n\t\t\t      0, &eb);\n\tbtrfs_tree_unlock(eb);\n\tfree_extent_buffer(eb);\n\n\tif (ret)\n\t\treturn ret;\n\n\tret = btrfs_run_delayed_refs(trans, root, (unsigned long)-1);\n\tif (ret)\n\t\treturn ret;\n\n\tret = btrfs_run_dev_stats(trans, root->fs_info);\n\tif (ret)\n\t\treturn ret;\n\tret = btrfs_run_dev_replace(trans, root->fs_info);\n\tif (ret)\n\t\treturn ret;\n\tret = btrfs_run_qgroups(trans, root->fs_info);\n\tif (ret)\n\t\treturn ret;\n\n\tret = btrfs_setup_space_cache(trans, root);\n\tif (ret)\n\t\treturn ret;\n\n\t/* run_qgroups might have added some more refs */\n\tret = btrfs_run_delayed_refs(trans, root, (unsigned long)-1);\n\tif (ret)\n\t\treturn ret;\nagain:\n\twhile (!list_empty(&fs_info->dirty_cowonly_roots)) {\n\t\tnext = fs_info->dirty_cowonly_roots.next;\n\t\tlist_del_init(next);\n\t\troot = list_entry(next, struct btrfs_root, dirty_list);\n\t\tclear_bit(BTRFS_ROOT_DIRTY, &root->state);\n\n\t\tif (root != fs_info->extent_root)\n\t\t\tlist_add_tail(&root->dirty_list,\n\t\t\t\t      &trans->transaction->switch_commits);\n\t\tret = update_cowonly_root(trans, root);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tret = btrfs_run_delayed_refs(trans, root, (unsigned long)-1);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\twhile (!list_empty(dirty_bgs)) {\n\t\tret = btrfs_write_dirty_block_groups(trans, root);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tret = btrfs_run_delayed_refs(trans, root, (unsigned long)-1);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (!list_empty(&fs_info->dirty_cowonly_roots))\n\t\tgoto again;\n\n\tlist_add_tail(&fs_info->extent_root->dirty_list,\n\t\t      &trans->transaction->switch_commits);\n\tbtrfs_after_dev_replace_commit(fs_info);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"dev-replace.h\"",
      "#include \"volumes.h\"",
      "#include \"inode-map.h\"",
      "#include \"tree-log.h\"",
      "#include \"locking.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/uuid.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/writeback.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_after_dev_replace_commit",
          "args": [
            "fs_info"
          ],
          "line": 1127
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_after_dev_replace_commit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/dev-replace.c",
          "lines": "301-307",
          "snippet": "void btrfs_after_dev_replace_commit(struct btrfs_fs_info *fs_info)\n{\n\tstruct btrfs_dev_replace *dev_replace = &fs_info->dev_replace;\n\n\tdev_replace->committed_cursor_left =\n\t\tdev_replace->cursor_left_last_write_of_item;\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/math64.h>",
            "#include <linux/kthread.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 __btrfs_dev_replace_cancel(struct btrfs_fs_info *fs_info);",
            "static int btrfs_dev_replace_continue_on_mount(struct btrfs_fs_info *fs_info);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/math64.h>\n#include <linux/kthread.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic u64 __btrfs_dev_replace_cancel(struct btrfs_fs_info *fs_info);\nstatic int btrfs_dev_replace_continue_on_mount(struct btrfs_fs_info *fs_info);\n\nvoid btrfs_after_dev_replace_commit(struct btrfs_fs_info *fs_info)\n{\n\tstruct btrfs_dev_replace *dev_replace = &fs_info->dev_replace;\n\n\tdev_replace->committed_cursor_left =\n\t\tdev_replace->cursor_left_last_write_of_item;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&fs_info->extent_root->dirty_list",
            "&trans->transaction->switch_commits"
          ],
          "line": 1125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&fs_info->dirty_cowonly_roots"
          ],
          "line": 1122
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_run_delayed_refs",
          "args": [
            "trans",
            "root",
            "(unsigned long)-1"
          ],
          "line": 1117
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_run_delayed_refs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent-tree.c",
          "lines": "2764-2841",
          "snippet": "int btrfs_run_delayed_refs(struct btrfs_trans_handle *trans,\n\t\t\t   struct btrfs_root *root, unsigned long count)\n{\n\tstruct rb_node *node;\n\tstruct btrfs_delayed_ref_root *delayed_refs;\n\tstruct btrfs_delayed_ref_head *head;\n\tint ret;\n\tint run_all = count == (unsigned long)-1;\n\n\t/* We'll clean this up in btrfs_cleanup_transaction */\n\tif (trans->aborted)\n\t\treturn 0;\n\n\tif (root == root->fs_info->extent_root)\n\t\troot = root->fs_info->tree_root;\n\n\tdelayed_refs = &trans->transaction->delayed_refs;\n\tif (count == 0)\n\t\tcount = atomic_read(&delayed_refs->num_entries) * 2;\n\nagain:\n#ifdef SCRAMBLE_DELAYED_REFS\n\tdelayed_refs->run_delayed_start = find_middle(&delayed_refs->root);\n#endif\n\tret = __btrfs_run_delayed_refs(trans, root, count);\n\tif (ret < 0) {\n\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\treturn ret;\n\t}\n\n\tif (run_all) {\n\t\tif (!list_empty(&trans->new_bgs))\n\t\t\tbtrfs_create_pending_block_groups(trans, root);\n\n\t\tspin_lock(&delayed_refs->lock);\n\t\tnode = rb_first(&delayed_refs->href_root);\n\t\tif (!node) {\n\t\t\tspin_unlock(&delayed_refs->lock);\n\t\t\tgoto out;\n\t\t}\n\t\tcount = (unsigned long)-1;\n\n\t\twhile (node) {\n\t\t\thead = rb_entry(node, struct btrfs_delayed_ref_head,\n\t\t\t\t\thref_node);\n\t\t\tif (btrfs_delayed_ref_is_head(&head->node)) {\n\t\t\t\tstruct btrfs_delayed_ref_node *ref;\n\n\t\t\t\tref = &head->node;\n\t\t\t\tatomic_inc(&ref->refs);\n\n\t\t\t\tspin_unlock(&delayed_refs->lock);\n\t\t\t\t/*\n\t\t\t\t * Mutex was contended, block until it's\n\t\t\t\t * released and try again\n\t\t\t\t */\n\t\t\t\tmutex_lock(&head->mutex);\n\t\t\t\tmutex_unlock(&head->mutex);\n\n\t\t\t\tbtrfs_put_delayed_ref(ref);\n\t\t\t\tcond_resched();\n\t\t\t\tgoto again;\n\t\t\t} else {\n\t\t\t\tWARN_ON(1);\n\t\t\t}\n\t\t\tnode = rb_next(node);\n\t\t}\n\t\tspin_unlock(&delayed_refs->lock);\n\t\tcond_resched();\n\t\tgoto again;\n\t}\nout:\n\tret = btrfs_delayed_qgroup_accounting(trans, root->fs_info);\n\tif (ret)\n\t\treturn ret;\n\tassert_qgroups_uptodate(trans);\n\treturn 0;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"math.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include \"hash.h\"",
            "#include <linux/percpu_counter.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"math.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include \"hash.h\"\n#include <linux/percpu_counter.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n#include <linux/rcupdate.h>\n#include <linux/sort.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nint btrfs_run_delayed_refs(struct btrfs_trans_handle *trans,\n\t\t\t   struct btrfs_root *root, unsigned long count)\n{\n\tstruct rb_node *node;\n\tstruct btrfs_delayed_ref_root *delayed_refs;\n\tstruct btrfs_delayed_ref_head *head;\n\tint ret;\n\tint run_all = count == (unsigned long)-1;\n\n\t/* We'll clean this up in btrfs_cleanup_transaction */\n\tif (trans->aborted)\n\t\treturn 0;\n\n\tif (root == root->fs_info->extent_root)\n\t\troot = root->fs_info->tree_root;\n\n\tdelayed_refs = &trans->transaction->delayed_refs;\n\tif (count == 0)\n\t\tcount = atomic_read(&delayed_refs->num_entries) * 2;\n\nagain:\n#ifdef SCRAMBLE_DELAYED_REFS\n\tdelayed_refs->run_delayed_start = find_middle(&delayed_refs->root);\n#endif\n\tret = __btrfs_run_delayed_refs(trans, root, count);\n\tif (ret < 0) {\n\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\treturn ret;\n\t}\n\n\tif (run_all) {\n\t\tif (!list_empty(&trans->new_bgs))\n\t\t\tbtrfs_create_pending_block_groups(trans, root);\n\n\t\tspin_lock(&delayed_refs->lock);\n\t\tnode = rb_first(&delayed_refs->href_root);\n\t\tif (!node) {\n\t\t\tspin_unlock(&delayed_refs->lock);\n\t\t\tgoto out;\n\t\t}\n\t\tcount = (unsigned long)-1;\n\n\t\twhile (node) {\n\t\t\thead = rb_entry(node, struct btrfs_delayed_ref_head,\n\t\t\t\t\thref_node);\n\t\t\tif (btrfs_delayed_ref_is_head(&head->node)) {\n\t\t\t\tstruct btrfs_delayed_ref_node *ref;\n\n\t\t\t\tref = &head->node;\n\t\t\t\tatomic_inc(&ref->refs);\n\n\t\t\t\tspin_unlock(&delayed_refs->lock);\n\t\t\t\t/*\n\t\t\t\t * Mutex was contended, block until it's\n\t\t\t\t * released and try again\n\t\t\t\t */\n\t\t\t\tmutex_lock(&head->mutex);\n\t\t\t\tmutex_unlock(&head->mutex);\n\n\t\t\t\tbtrfs_put_delayed_ref(ref);\n\t\t\t\tcond_resched();\n\t\t\t\tgoto again;\n\t\t\t} else {\n\t\t\t\tWARN_ON(1);\n\t\t\t}\n\t\t\tnode = rb_next(node);\n\t\t}\n\t\tspin_unlock(&delayed_refs->lock);\n\t\tcond_resched();\n\t\tgoto again;\n\t}\nout:\n\tret = btrfs_delayed_qgroup_accounting(trans, root->fs_info);\n\tif (ret)\n\t\treturn ret;\n\tassert_qgroups_uptodate(trans);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_write_dirty_block_groups",
          "args": [
            "trans",
            "root"
          ],
          "line": 1114
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_write_dirty_block_groups",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent-tree.c",
          "lines": "3354-3394",
          "snippet": "int btrfs_write_dirty_block_groups(struct btrfs_trans_handle *trans,\n\t\t\t\t   struct btrfs_root *root)\n{\n\tstruct btrfs_block_group_cache *cache;\n\tstruct btrfs_transaction *cur_trans = trans->transaction;\n\tint ret = 0;\n\tstruct btrfs_path *path;\n\n\tif (list_empty(&cur_trans->dirty_bgs))\n\t\treturn 0;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\t/*\n\t * We don't need the lock here since we are protected by the transaction\n\t * commit.  We want to do the cache_save_setup first and then run the\n\t * delayed refs to make sure we have the best chance at doing this all\n\t * in one shot.\n\t */\n\twhile (!list_empty(&cur_trans->dirty_bgs)) {\n\t\tcache = list_first_entry(&cur_trans->dirty_bgs,\n\t\t\t\t\t struct btrfs_block_group_cache,\n\t\t\t\t\t dirty_list);\n\t\tlist_del_init(&cache->dirty_list);\n\t\tif (cache->disk_cache_state == BTRFS_DC_CLEAR)\n\t\t\tcache_save_setup(cache, trans, path);\n\t\tif (!ret)\n\t\t\tret = btrfs_run_delayed_refs(trans, root,\n\t\t\t\t\t\t     (unsigned long) -1);\n\t\tif (!ret && cache->disk_cache_state == BTRFS_DC_SETUP)\n\t\t\tbtrfs_write_out_cache(root, trans, cache, path);\n\t\tif (!ret)\n\t\t\tret = write_one_cache_group(trans, root, path, cache);\n\t\tbtrfs_put_block_group(cache);\n\t}\n\n\tbtrfs_free_path(path);\n\treturn ret;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"math.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include \"hash.h\"",
            "#include <linux/percpu_counter.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"math.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include \"hash.h\"\n#include <linux/percpu_counter.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n#include <linux/rcupdate.h>\n#include <linux/sort.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nint btrfs_write_dirty_block_groups(struct btrfs_trans_handle *trans,\n\t\t\t\t   struct btrfs_root *root)\n{\n\tstruct btrfs_block_group_cache *cache;\n\tstruct btrfs_transaction *cur_trans = trans->transaction;\n\tint ret = 0;\n\tstruct btrfs_path *path;\n\n\tif (list_empty(&cur_trans->dirty_bgs))\n\t\treturn 0;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\t/*\n\t * We don't need the lock here since we are protected by the transaction\n\t * commit.  We want to do the cache_save_setup first and then run the\n\t * delayed refs to make sure we have the best chance at doing this all\n\t * in one shot.\n\t */\n\twhile (!list_empty(&cur_trans->dirty_bgs)) {\n\t\tcache = list_first_entry(&cur_trans->dirty_bgs,\n\t\t\t\t\t struct btrfs_block_group_cache,\n\t\t\t\t\t dirty_list);\n\t\tlist_del_init(&cache->dirty_list);\n\t\tif (cache->disk_cache_state == BTRFS_DC_CLEAR)\n\t\t\tcache_save_setup(cache, trans, path);\n\t\tif (!ret)\n\t\t\tret = btrfs_run_delayed_refs(trans, root,\n\t\t\t\t\t\t     (unsigned long) -1);\n\t\tif (!ret && cache->disk_cache_state == BTRFS_DC_SETUP)\n\t\t\tbtrfs_write_out_cache(root, trans, cache, path);\n\t\tif (!ret)\n\t\t\tret = write_one_cache_group(trans, root, path, cache);\n\t\tbtrfs_put_block_group(cache);\n\t}\n\n\tbtrfs_free_path(path);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_cowonly_root",
          "args": [
            "trans",
            "root"
          ],
          "line": 1105
        },
        "resolved": true,
        "details": {
          "function_name": "update_cowonly_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
          "lines": "1019-1046",
          "snippet": "static int update_cowonly_root(struct btrfs_trans_handle *trans,\n\t\t\t       struct btrfs_root *root)\n{\n\tint ret;\n\tu64 old_root_bytenr;\n\tu64 old_root_used;\n\tstruct btrfs_root *tree_root = root->fs_info->tree_root;\n\n\told_root_used = btrfs_root_used(&root->root_item);\n\n\twhile (1) {\n\t\told_root_bytenr = btrfs_root_bytenr(&root->root_item);\n\t\tif (old_root_bytenr == root->node->start &&\n\t\t    old_root_used == btrfs_root_used(&root->root_item))\n\t\t\tbreak;\n\n\t\tbtrfs_set_root_node(&root->root_item, root->node);\n\t\tret = btrfs_update_root(trans, tree_root,\n\t\t\t\t\t&root->root_key,\n\t\t\t\t\t&root->root_item);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\told_root_used = btrfs_root_used(&root->root_item);\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"dev-replace.h\"",
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic int update_cowonly_root(struct btrfs_trans_handle *trans,\n\t\t\t       struct btrfs_root *root)\n{\n\tint ret;\n\tu64 old_root_bytenr;\n\tu64 old_root_used;\n\tstruct btrfs_root *tree_root = root->fs_info->tree_root;\n\n\told_root_used = btrfs_root_used(&root->root_item);\n\n\twhile (1) {\n\t\told_root_bytenr = btrfs_root_bytenr(&root->root_item);\n\t\tif (old_root_bytenr == root->node->start &&\n\t\t    old_root_used == btrfs_root_used(&root->root_item))\n\t\t\tbreak;\n\n\t\tbtrfs_set_root_node(&root->root_item, root->node);\n\t\tret = btrfs_update_root(trans, tree_root,\n\t\t\t\t\t&root->root_key,\n\t\t\t\t\t&root->root_item);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\told_root_used = btrfs_root_used(&root->root_item);\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&root->dirty_list",
            "&trans->transaction->switch_commits"
          ],
          "line": 1103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "BTRFS_ROOT_DIRTY",
            "&root->state"
          ],
          "line": 1100
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clear_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "892-896",
          "snippet": "static inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "next",
            "structbtrfs_root",
            "dirty_list"
          ],
          "line": 1099
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "next"
          ],
          "line": 1098
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_setup_space_cache",
          "args": [
            "trans",
            "root"
          ],
          "line": 1087
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_setup_space_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent-tree.c",
          "lines": "3328-3352",
          "snippet": "int btrfs_setup_space_cache(struct btrfs_trans_handle *trans,\n\t\t\t    struct btrfs_root *root)\n{\n\tstruct btrfs_block_group_cache *cache, *tmp;\n\tstruct btrfs_transaction *cur_trans = trans->transaction;\n\tstruct btrfs_path *path;\n\n\tif (list_empty(&cur_trans->dirty_bgs) ||\n\t    !btrfs_test_opt(root, SPACE_CACHE))\n\t\treturn 0;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\t/* Could add new block groups, use _safe just in case */\n\tlist_for_each_entry_safe(cache, tmp, &cur_trans->dirty_bgs,\n\t\t\t\t dirty_list) {\n\t\tif (cache->disk_cache_state == BTRFS_DC_CLEAR)\n\t\t\tcache_save_setup(cache, trans, path);\n\t}\n\n\tbtrfs_free_path(path);\n\treturn 0;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"math.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include \"hash.h\"",
            "#include <linux/percpu_counter.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"math.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include \"hash.h\"\n#include <linux/percpu_counter.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n#include <linux/rcupdate.h>\n#include <linux/sort.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nint btrfs_setup_space_cache(struct btrfs_trans_handle *trans,\n\t\t\t    struct btrfs_root *root)\n{\n\tstruct btrfs_block_group_cache *cache, *tmp;\n\tstruct btrfs_transaction *cur_trans = trans->transaction;\n\tstruct btrfs_path *path;\n\n\tif (list_empty(&cur_trans->dirty_bgs) ||\n\t    !btrfs_test_opt(root, SPACE_CACHE))\n\t\treturn 0;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\t/* Could add new block groups, use _safe just in case */\n\tlist_for_each_entry_safe(cache, tmp, &cur_trans->dirty_bgs,\n\t\t\t\t dirty_list) {\n\t\tif (cache->disk_cache_state == BTRFS_DC_CLEAR)\n\t\t\tcache_save_setup(cache, trans, path);\n\t}\n\n\tbtrfs_free_path(path);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_run_qgroups",
          "args": [
            "trans",
            "root->fs_info"
          ],
          "line": 1083
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_run_qgroups",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/qgroup.c",
          "lines": "2133-2184",
          "snippet": "int btrfs_run_qgroups(struct btrfs_trans_handle *trans,\n\t\t      struct btrfs_fs_info *fs_info)\n{\n\tstruct btrfs_root *quota_root = fs_info->quota_root;\n\tint ret = 0;\n\tint start_rescan_worker = 0;\n\n\tif (!quota_root)\n\t\tgoto out;\n\n\tif (!fs_info->quota_enabled && fs_info->pending_quota_state)\n\t\tstart_rescan_worker = 1;\n\n\tfs_info->quota_enabled = fs_info->pending_quota_state;\n\n\tspin_lock(&fs_info->qgroup_lock);\n\twhile (!list_empty(&fs_info->dirty_qgroups)) {\n\t\tstruct btrfs_qgroup *qgroup;\n\t\tqgroup = list_first_entry(&fs_info->dirty_qgroups,\n\t\t\t\t\t  struct btrfs_qgroup, dirty);\n\t\tlist_del_init(&qgroup->dirty);\n\t\tspin_unlock(&fs_info->qgroup_lock);\n\t\tret = update_qgroup_info_item(trans, quota_root, qgroup);\n\t\tif (ret)\n\t\t\tfs_info->qgroup_flags |=\n\t\t\t\t\tBTRFS_QGROUP_STATUS_FLAG_INCONSISTENT;\n\t\tspin_lock(&fs_info->qgroup_lock);\n\t}\n\tif (fs_info->quota_enabled)\n\t\tfs_info->qgroup_flags |= BTRFS_QGROUP_STATUS_FLAG_ON;\n\telse\n\t\tfs_info->qgroup_flags &= ~BTRFS_QGROUP_STATUS_FLAG_ON;\n\tspin_unlock(&fs_info->qgroup_lock);\n\n\tret = update_qgroup_status_item(trans, fs_info, quota_root);\n\tif (ret)\n\t\tfs_info->qgroup_flags |= BTRFS_QGROUP_STATUS_FLAG_INCONSISTENT;\n\n\tif (!ret && start_rescan_worker) {\n\t\tret = qgroup_rescan_init(fs_info, 0, 1);\n\t\tif (!ret) {\n\t\t\tqgroup_rescan_zero_tracking(fs_info);\n\t\t\tbtrfs_queue_work(fs_info->qgroup_rescan_workers,\n\t\t\t\t\t &fs_info->qgroup_rescan_work);\n\t\t}\n\t\tret = 0;\n\t}\n\nout:\n\n\treturn ret;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"ulist.h\"",
            "#include \"locking.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"ctree.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"ulist.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);\n\nint btrfs_run_qgroups(struct btrfs_trans_handle *trans,\n\t\t      struct btrfs_fs_info *fs_info)\n{\n\tstruct btrfs_root *quota_root = fs_info->quota_root;\n\tint ret = 0;\n\tint start_rescan_worker = 0;\n\n\tif (!quota_root)\n\t\tgoto out;\n\n\tif (!fs_info->quota_enabled && fs_info->pending_quota_state)\n\t\tstart_rescan_worker = 1;\n\n\tfs_info->quota_enabled = fs_info->pending_quota_state;\n\n\tspin_lock(&fs_info->qgroup_lock);\n\twhile (!list_empty(&fs_info->dirty_qgroups)) {\n\t\tstruct btrfs_qgroup *qgroup;\n\t\tqgroup = list_first_entry(&fs_info->dirty_qgroups,\n\t\t\t\t\t  struct btrfs_qgroup, dirty);\n\t\tlist_del_init(&qgroup->dirty);\n\t\tspin_unlock(&fs_info->qgroup_lock);\n\t\tret = update_qgroup_info_item(trans, quota_root, qgroup);\n\t\tif (ret)\n\t\t\tfs_info->qgroup_flags |=\n\t\t\t\t\tBTRFS_QGROUP_STATUS_FLAG_INCONSISTENT;\n\t\tspin_lock(&fs_info->qgroup_lock);\n\t}\n\tif (fs_info->quota_enabled)\n\t\tfs_info->qgroup_flags |= BTRFS_QGROUP_STATUS_FLAG_ON;\n\telse\n\t\tfs_info->qgroup_flags &= ~BTRFS_QGROUP_STATUS_FLAG_ON;\n\tspin_unlock(&fs_info->qgroup_lock);\n\n\tret = update_qgroup_status_item(trans, fs_info, quota_root);\n\tif (ret)\n\t\tfs_info->qgroup_flags |= BTRFS_QGROUP_STATUS_FLAG_INCONSISTENT;\n\n\tif (!ret && start_rescan_worker) {\n\t\tret = qgroup_rescan_init(fs_info, 0, 1);\n\t\tif (!ret) {\n\t\t\tqgroup_rescan_zero_tracking(fs_info);\n\t\t\tbtrfs_queue_work(fs_info->qgroup_rescan_workers,\n\t\t\t\t\t &fs_info->qgroup_rescan_work);\n\t\t}\n\t\tret = 0;\n\t}\n\nout:\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_run_dev_replace",
          "args": [
            "trans",
            "root->fs_info"
          ],
          "line": 1080
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_run_dev_replace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/dev-replace.c",
          "lines": "195-299",
          "snippet": "int btrfs_run_dev_replace(struct btrfs_trans_handle *trans,\n\t\t\t  struct btrfs_fs_info *fs_info)\n{\n\tint ret;\n\tstruct btrfs_root *dev_root = fs_info->dev_root;\n\tstruct btrfs_path *path;\n\tstruct btrfs_key key;\n\tstruct extent_buffer *eb;\n\tstruct btrfs_dev_replace_item *ptr;\n\tstruct btrfs_dev_replace *dev_replace = &fs_info->dev_replace;\n\n\tbtrfs_dev_replace_lock(dev_replace);\n\tif (!dev_replace->is_valid ||\n\t    !dev_replace->item_needs_writeback) {\n\t\tbtrfs_dev_replace_unlock(dev_replace);\n\t\treturn 0;\n\t}\n\tbtrfs_dev_replace_unlock(dev_replace);\n\n\tkey.objectid = 0;\n\tkey.type = BTRFS_DEV_REPLACE_KEY;\n\tkey.offset = 0;\n\n\tpath = btrfs_alloc_path();\n\tif (!path) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tret = btrfs_search_slot(trans, dev_root, &key, path, -1, 1);\n\tif (ret < 0) {\n\t\tbtrfs_warn(fs_info, \"error %d while searching for dev_replace item!\",\n\t\t\tret);\n\t\tgoto out;\n\t}\n\n\tif (ret == 0 &&\n\t    btrfs_item_size_nr(path->nodes[0], path->slots[0]) < sizeof(*ptr)) {\n\t\t/*\n\t\t * need to delete old one and insert a new one.\n\t\t * Since no attempt is made to recover any old state, if the\n\t\t * dev_replace state is 'running', the data on the target\n\t\t * drive is lost.\n\t\t * It would be possible to recover the state: just make sure\n\t\t * that the beginning of the item is never changed and always\n\t\t * contains all the essential information. Then read this\n\t\t * minimal set of information and use it as a base for the\n\t\t * new state.\n\t\t */\n\t\tret = btrfs_del_item(trans, dev_root, path);\n\t\tif (ret != 0) {\n\t\t\tbtrfs_warn(fs_info, \"delete too small dev_replace item failed %d!\",\n\t\t\t\tret);\n\t\t\tgoto out;\n\t\t}\n\t\tret = 1;\n\t}\n\n\tif (ret == 1) {\n\t\t/* need to insert a new item */\n\t\tbtrfs_release_path(path);\n\t\tret = btrfs_insert_empty_item(trans, dev_root, path,\n\t\t\t\t\t      &key, sizeof(*ptr));\n\t\tif (ret < 0) {\n\t\t\tbtrfs_warn(fs_info, \"insert dev_replace item failed %d!\",\n\t\t\t\tret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\teb = path->nodes[0];\n\tptr = btrfs_item_ptr(eb, path->slots[0],\n\t\t\t     struct btrfs_dev_replace_item);\n\n\tbtrfs_dev_replace_lock(dev_replace);\n\tif (dev_replace->srcdev)\n\t\tbtrfs_set_dev_replace_src_devid(eb, ptr,\n\t\t\tdev_replace->srcdev->devid);\n\telse\n\t\tbtrfs_set_dev_replace_src_devid(eb, ptr, (u64)-1);\n\tbtrfs_set_dev_replace_cont_reading_from_srcdev_mode(eb, ptr,\n\t\tdev_replace->cont_reading_from_srcdev_mode);\n\tbtrfs_set_dev_replace_replace_state(eb, ptr,\n\t\tdev_replace->replace_state);\n\tbtrfs_set_dev_replace_time_started(eb, ptr, dev_replace->time_started);\n\tbtrfs_set_dev_replace_time_stopped(eb, ptr, dev_replace->time_stopped);\n\tbtrfs_set_dev_replace_num_write_errors(eb, ptr,\n\t\tatomic64_read(&dev_replace->num_write_errors));\n\tbtrfs_set_dev_replace_num_uncorrectable_read_errors(eb, ptr,\n\t\tatomic64_read(&dev_replace->num_uncorrectable_read_errors));\n\tdev_replace->cursor_left_last_write_of_item =\n\t\tdev_replace->cursor_left;\n\tbtrfs_set_dev_replace_cursor_left(eb, ptr,\n\t\tdev_replace->cursor_left_last_write_of_item);\n\tbtrfs_set_dev_replace_cursor_right(eb, ptr,\n\t\tdev_replace->cursor_right);\n\tdev_replace->item_needs_writeback = 0;\n\tbtrfs_dev_replace_unlock(dev_replace);\n\n\tbtrfs_mark_buffer_dirty(eb);\n\nout:\n\tbtrfs_free_path(path);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/math64.h>",
            "#include <linux/kthread.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 __btrfs_dev_replace_cancel(struct btrfs_fs_info *fs_info);",
            "static int btrfs_dev_replace_kthread(void *data);",
            "static int btrfs_dev_replace_continue_on_mount(struct btrfs_fs_info *fs_info);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/math64.h>\n#include <linux/kthread.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic u64 __btrfs_dev_replace_cancel(struct btrfs_fs_info *fs_info);\nstatic int btrfs_dev_replace_kthread(void *data);\nstatic int btrfs_dev_replace_continue_on_mount(struct btrfs_fs_info *fs_info);\n\nint btrfs_run_dev_replace(struct btrfs_trans_handle *trans,\n\t\t\t  struct btrfs_fs_info *fs_info)\n{\n\tint ret;\n\tstruct btrfs_root *dev_root = fs_info->dev_root;\n\tstruct btrfs_path *path;\n\tstruct btrfs_key key;\n\tstruct extent_buffer *eb;\n\tstruct btrfs_dev_replace_item *ptr;\n\tstruct btrfs_dev_replace *dev_replace = &fs_info->dev_replace;\n\n\tbtrfs_dev_replace_lock(dev_replace);\n\tif (!dev_replace->is_valid ||\n\t    !dev_replace->item_needs_writeback) {\n\t\tbtrfs_dev_replace_unlock(dev_replace);\n\t\treturn 0;\n\t}\n\tbtrfs_dev_replace_unlock(dev_replace);\n\n\tkey.objectid = 0;\n\tkey.type = BTRFS_DEV_REPLACE_KEY;\n\tkey.offset = 0;\n\n\tpath = btrfs_alloc_path();\n\tif (!path) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tret = btrfs_search_slot(trans, dev_root, &key, path, -1, 1);\n\tif (ret < 0) {\n\t\tbtrfs_warn(fs_info, \"error %d while searching for dev_replace item!\",\n\t\t\tret);\n\t\tgoto out;\n\t}\n\n\tif (ret == 0 &&\n\t    btrfs_item_size_nr(path->nodes[0], path->slots[0]) < sizeof(*ptr)) {\n\t\t/*\n\t\t * need to delete old one and insert a new one.\n\t\t * Since no attempt is made to recover any old state, if the\n\t\t * dev_replace state is 'running', the data on the target\n\t\t * drive is lost.\n\t\t * It would be possible to recover the state: just make sure\n\t\t * that the beginning of the item is never changed and always\n\t\t * contains all the essential information. Then read this\n\t\t * minimal set of information and use it as a base for the\n\t\t * new state.\n\t\t */\n\t\tret = btrfs_del_item(trans, dev_root, path);\n\t\tif (ret != 0) {\n\t\t\tbtrfs_warn(fs_info, \"delete too small dev_replace item failed %d!\",\n\t\t\t\tret);\n\t\t\tgoto out;\n\t\t}\n\t\tret = 1;\n\t}\n\n\tif (ret == 1) {\n\t\t/* need to insert a new item */\n\t\tbtrfs_release_path(path);\n\t\tret = btrfs_insert_empty_item(trans, dev_root, path,\n\t\t\t\t\t      &key, sizeof(*ptr));\n\t\tif (ret < 0) {\n\t\t\tbtrfs_warn(fs_info, \"insert dev_replace item failed %d!\",\n\t\t\t\tret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\teb = path->nodes[0];\n\tptr = btrfs_item_ptr(eb, path->slots[0],\n\t\t\t     struct btrfs_dev_replace_item);\n\n\tbtrfs_dev_replace_lock(dev_replace);\n\tif (dev_replace->srcdev)\n\t\tbtrfs_set_dev_replace_src_devid(eb, ptr,\n\t\t\tdev_replace->srcdev->devid);\n\telse\n\t\tbtrfs_set_dev_replace_src_devid(eb, ptr, (u64)-1);\n\tbtrfs_set_dev_replace_cont_reading_from_srcdev_mode(eb, ptr,\n\t\tdev_replace->cont_reading_from_srcdev_mode);\n\tbtrfs_set_dev_replace_replace_state(eb, ptr,\n\t\tdev_replace->replace_state);\n\tbtrfs_set_dev_replace_time_started(eb, ptr, dev_replace->time_started);\n\tbtrfs_set_dev_replace_time_stopped(eb, ptr, dev_replace->time_stopped);\n\tbtrfs_set_dev_replace_num_write_errors(eb, ptr,\n\t\tatomic64_read(&dev_replace->num_write_errors));\n\tbtrfs_set_dev_replace_num_uncorrectable_read_errors(eb, ptr,\n\t\tatomic64_read(&dev_replace->num_uncorrectable_read_errors));\n\tdev_replace->cursor_left_last_write_of_item =\n\t\tdev_replace->cursor_left;\n\tbtrfs_set_dev_replace_cursor_left(eb, ptr,\n\t\tdev_replace->cursor_left_last_write_of_item);\n\tbtrfs_set_dev_replace_cursor_right(eb, ptr,\n\t\tdev_replace->cursor_right);\n\tdev_replace->item_needs_writeback = 0;\n\tbtrfs_dev_replace_unlock(dev_replace);\n\n\tbtrfs_mark_buffer_dirty(eb);\n\nout:\n\tbtrfs_free_path(path);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_run_dev_stats",
          "args": [
            "trans",
            "root->fs_info"
          ],
          "line": 1077
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_run_dev_stats",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
          "lines": "6571-6593",
          "snippet": "int btrfs_run_dev_stats(struct btrfs_trans_handle *trans,\n\t\t\tstruct btrfs_fs_info *fs_info)\n{\n\tstruct btrfs_root *dev_root = fs_info->dev_root;\n\tstruct btrfs_fs_devices *fs_devices = fs_info->fs_devices;\n\tstruct btrfs_device *device;\n\tint stats_cnt;\n\tint ret = 0;\n\n\tmutex_lock(&fs_devices->device_list_mutex);\n\tlist_for_each_entry(device, &fs_devices->devices, dev_list) {\n\t\tif (!device->dev_stats_valid || !btrfs_dev_stats_dirty(device))\n\t\t\tcontinue;\n\n\t\tstats_cnt = atomic_read(&device->dev_stats_ccnt);\n\t\tret = update_dev_stat_item(trans, dev_root, device);\n\t\tif (!ret)\n\t\t\tatomic_sub(stats_cnt, &device->dev_stats_ccnt);\n\t}\n\tmutex_unlock(&fs_devices->device_list_mutex);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);",
            "static void btrfs_dev_stat_print_on_load(struct btrfs_device *device);",
            "static noinline struct",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);\nstatic void btrfs_dev_stat_print_on_load(struct btrfs_device *device);\nstatic noinline struct;\nstatic noinline struct;\n\nint btrfs_run_dev_stats(struct btrfs_trans_handle *trans,\n\t\t\tstruct btrfs_fs_info *fs_info)\n{\n\tstruct btrfs_root *dev_root = fs_info->dev_root;\n\tstruct btrfs_fs_devices *fs_devices = fs_info->fs_devices;\n\tstruct btrfs_device *device;\n\tint stats_cnt;\n\tint ret = 0;\n\n\tmutex_lock(&fs_devices->device_list_mutex);\n\tlist_for_each_entry(device, &fs_devices->devices, dev_list) {\n\t\tif (!device->dev_stats_valid || !btrfs_dev_stats_dirty(device))\n\t\t\tcontinue;\n\n\t\tstats_cnt = atomic_read(&device->dev_stats_ccnt);\n\t\tret = update_dev_stat_item(trans, dev_root, device);\n\t\tif (!ret)\n\t\t\tatomic_sub(stats_cnt, &device->dev_stats_ccnt);\n\t}\n\tmutex_unlock(&fs_devices->device_list_mutex);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_extent_buffer",
          "args": [
            "eb"
          ],
          "line": 1068
        },
        "resolved": true,
        "details": {
          "function_name": "free_extent_buffer_stale",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "5019-5031",
          "snippet": "void free_extent_buffer_stale(struct extent_buffer *eb)\n{\n\tif (!eb)\n\t\treturn;\n\n\tspin_lock(&eb->refs_lock);\n\tset_bit(EXTENT_BUFFER_STALE, &eb->bflags);\n\n\tif (atomic_read(&eb->refs) == 2 && !extent_buffer_under_io(eb) &&\n\t    test_and_clear_bit(EXTENT_BUFFER_TREE_REF, &eb->bflags))\n\t\tatomic_dec(&eb->refs);\n\trelease_extent_buffer(eb);\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nvoid free_extent_buffer_stale(struct extent_buffer *eb)\n{\n\tif (!eb)\n\t\treturn;\n\n\tspin_lock(&eb->refs_lock);\n\tset_bit(EXTENT_BUFFER_STALE, &eb->bflags);\n\n\tif (atomic_read(&eb->refs) == 2 && !extent_buffer_under_io(eb) &&\n\t    test_and_clear_bit(EXTENT_BUFFER_TREE_REF, &eb->bflags))\n\t\tatomic_dec(&eb->refs);\n\trelease_extent_buffer(eb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_tree_unlock",
          "args": [
            "eb"
          ],
          "line": 1067
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_tree_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/locking.c",
          "lines": "269-290",
          "snippet": "void btrfs_tree_unlock(struct extent_buffer *eb)\n{\n\tint blockers = atomic_read(&eb->blocking_writers);\n\n\tBUG_ON(blockers > 1);\n\n\tbtrfs_assert_tree_locked(eb);\n\teb->lock_owner = 0;\n\tatomic_dec(&eb->write_locks);\n\n\tif (blockers) {\n\t\tWARN_ON(atomic_read(&eb->spinning_writers));\n\t\tatomic_dec(&eb->blocking_writers);\n\t\tsmp_mb();\n\t\tif (waitqueue_active(&eb->write_lock_wq))\n\t\t\twake_up(&eb->write_lock_wq);\n\t} else {\n\t\tWARN_ON(atomic_read(&eb->spinning_writers) != 1);\n\t\tatomic_dec(&eb->spinning_writers);\n\t\twrite_unlock(&eb->lock);\n\t}\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"extent_io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/bug.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void btrfs_assert_tree_read_locked(struct extent_buffer *eb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"extent_io.h\"\n#include \"ctree.h\"\n#include <asm/bug.h>\n#include <linux/page-flags.h>\n#include <linux/spinlock.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void btrfs_assert_tree_read_locked(struct extent_buffer *eb);\n\nvoid btrfs_tree_unlock(struct extent_buffer *eb)\n{\n\tint blockers = atomic_read(&eb->blocking_writers);\n\n\tBUG_ON(blockers > 1);\n\n\tbtrfs_assert_tree_locked(eb);\n\teb->lock_owner = 0;\n\tatomic_dec(&eb->write_locks);\n\n\tif (blockers) {\n\t\tWARN_ON(atomic_read(&eb->spinning_writers));\n\t\tatomic_dec(&eb->blocking_writers);\n\t\tsmp_mb();\n\t\tif (waitqueue_active(&eb->write_lock_wq))\n\t\t\twake_up(&eb->write_lock_wq);\n\t} else {\n\t\tWARN_ON(atomic_read(&eb->spinning_writers) != 1);\n\t\tatomic_dec(&eb->spinning_writers);\n\t\twrite_unlock(&eb->lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_cow_block",
          "args": [
            "trans",
            "fs_info->tree_root",
            "eb",
            "NULL",
            "0",
            "&eb"
          ],
          "line": 1065
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_cow_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "1534-1568",
          "snippet": "noinline int btrfs_cow_block(struct btrfs_trans_handle *trans,\n\t\t    struct btrfs_root *root, struct extent_buffer *buf,\n\t\t    struct extent_buffer *parent, int parent_slot,\n\t\t    struct extent_buffer **cow_ret)\n{\n\tu64 search_start;\n\tint ret;\n\n\tif (trans->transaction != root->fs_info->running_transaction)\n\t\tWARN(1, KERN_CRIT \"trans %llu running %llu\\n\",\n\t\t       trans->transid,\n\t\t       root->fs_info->running_transaction->transid);\n\n\tif (trans->transid != root->fs_info->generation)\n\t\tWARN(1, KERN_CRIT \"trans %llu running %llu\\n\",\n\t\t       trans->transid, root->fs_info->generation);\n\n\tif (!should_cow_block(trans, root, buf)) {\n\t\t*cow_ret = buf;\n\t\treturn 0;\n\t}\n\n\tsearch_start = buf->start & ~((u64)(1024 * 1024 * 1024) - 1);\n\n\tif (parent)\n\t\tbtrfs_set_lock_blocking(parent);\n\tbtrfs_set_lock_blocking(buf);\n\n\tret = __btrfs_cow_block(trans, root, buf, parent,\n\t\t\t\t parent_slot, cow_ret, search_start, 0);\n\n\ttrace_btrfs_cow_block(root, buf, *cow_ret);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nnoinline int btrfs_cow_block(struct btrfs_trans_handle *trans,\n\t\t    struct btrfs_root *root, struct extent_buffer *buf,\n\t\t    struct extent_buffer *parent, int parent_slot,\n\t\t    struct extent_buffer **cow_ret)\n{\n\tu64 search_start;\n\tint ret;\n\n\tif (trans->transaction != root->fs_info->running_transaction)\n\t\tWARN(1, KERN_CRIT \"trans %llu running %llu\\n\",\n\t\t       trans->transid,\n\t\t       root->fs_info->running_transaction->transid);\n\n\tif (trans->transid != root->fs_info->generation)\n\t\tWARN(1, KERN_CRIT \"trans %llu running %llu\\n\",\n\t\t       trans->transid, root->fs_info->generation);\n\n\tif (!should_cow_block(trans, root, buf)) {\n\t\t*cow_ret = buf;\n\t\treturn 0;\n\t}\n\n\tsearch_start = buf->start & ~((u64)(1024 * 1024 * 1024) - 1);\n\n\tif (parent)\n\t\tbtrfs_set_lock_blocking(parent);\n\tbtrfs_set_lock_blocking(buf);\n\n\tret = __btrfs_cow_block(trans, root, buf, parent,\n\t\t\t\t parent_slot, cow_ret, search_start, 0);\n\n\ttrace_btrfs_cow_block(root, buf, *cow_ret);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_lock_root_node",
          "args": [
            "fs_info->tree_root"
          ],
          "line": 1064
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_lock_root_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "176-189",
          "snippet": "struct extent_buffer *btrfs_lock_root_node(struct btrfs_root *root)\n{\n\tstruct extent_buffer *eb;\n\n\twhile (1) {\n\t\teb = btrfs_root_node(root);\n\t\tbtrfs_tree_lock(eb);\n\t\tif (eb == root->node)\n\t\t\tbreak;\n\t\tbtrfs_tree_unlock(eb);\n\t\tfree_extent_buffer(eb);\n\t}\n\treturn eb;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int tree_mod_log_free_eb(struct btrfs_fs_info *fs_info,\n\t\t\t\t struct extent_buffer *eb);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int tree_mod_log_free_eb(struct btrfs_fs_info *fs_info,\n\t\t\t\t struct extent_buffer *eb);\nstatic noinline struct;\n\nstruct extent_buffer *btrfs_lock_root_node(struct btrfs_root *root)\n{\n\tstruct extent_buffer *eb;\n\n\twhile (1) {\n\t\teb = btrfs_root_node(root);\n\t\tbtrfs_tree_lock(eb);\n\t\tif (eb == root->node)\n\t\t\tbreak;\n\t\tbtrfs_tree_unlock(eb);\n\t\tfree_extent_buffer(eb);\n\t}\n\treturn eb;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic noinline int commit_cowonly_roots(struct btrfs_trans_handle *trans,\n\t\t\t\t\t struct btrfs_root *root)\n{\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tstruct list_head *dirty_bgs = &trans->transaction->dirty_bgs;\n\tstruct list_head *next;\n\tstruct extent_buffer *eb;\n\tint ret;\n\n\teb = btrfs_lock_root_node(fs_info->tree_root);\n\tret = btrfs_cow_block(trans, fs_info->tree_root, eb, NULL,\n\t\t\t      0, &eb);\n\tbtrfs_tree_unlock(eb);\n\tfree_extent_buffer(eb);\n\n\tif (ret)\n\t\treturn ret;\n\n\tret = btrfs_run_delayed_refs(trans, root, (unsigned long)-1);\n\tif (ret)\n\t\treturn ret;\n\n\tret = btrfs_run_dev_stats(trans, root->fs_info);\n\tif (ret)\n\t\treturn ret;\n\tret = btrfs_run_dev_replace(trans, root->fs_info);\n\tif (ret)\n\t\treturn ret;\n\tret = btrfs_run_qgroups(trans, root->fs_info);\n\tif (ret)\n\t\treturn ret;\n\n\tret = btrfs_setup_space_cache(trans, root);\n\tif (ret)\n\t\treturn ret;\n\n\t/* run_qgroups might have added some more refs */\n\tret = btrfs_run_delayed_refs(trans, root, (unsigned long)-1);\n\tif (ret)\n\t\treturn ret;\nagain:\n\twhile (!list_empty(&fs_info->dirty_cowonly_roots)) {\n\t\tnext = fs_info->dirty_cowonly_roots.next;\n\t\tlist_del_init(next);\n\t\troot = list_entry(next, struct btrfs_root, dirty_list);\n\t\tclear_bit(BTRFS_ROOT_DIRTY, &root->state);\n\n\t\tif (root != fs_info->extent_root)\n\t\t\tlist_add_tail(&root->dirty_list,\n\t\t\t\t      &trans->transaction->switch_commits);\n\t\tret = update_cowonly_root(trans, root);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tret = btrfs_run_delayed_refs(trans, root, (unsigned long)-1);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\twhile (!list_empty(dirty_bgs)) {\n\t\tret = btrfs_write_dirty_block_groups(trans, root);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tret = btrfs_run_delayed_refs(trans, root, (unsigned long)-1);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (!list_empty(&fs_info->dirty_cowonly_roots))\n\t\tgoto again;\n\n\tlist_add_tail(&fs_info->extent_root->dirty_list,\n\t\t      &trans->transaction->switch_commits);\n\tbtrfs_after_dev_replace_commit(fs_info);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "update_cowonly_root",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
    "lines": "1019-1046",
    "snippet": "static int update_cowonly_root(struct btrfs_trans_handle *trans,\n\t\t\t       struct btrfs_root *root)\n{\n\tint ret;\n\tu64 old_root_bytenr;\n\tu64 old_root_used;\n\tstruct btrfs_root *tree_root = root->fs_info->tree_root;\n\n\told_root_used = btrfs_root_used(&root->root_item);\n\n\twhile (1) {\n\t\told_root_bytenr = btrfs_root_bytenr(&root->root_item);\n\t\tif (old_root_bytenr == root->node->start &&\n\t\t    old_root_used == btrfs_root_used(&root->root_item))\n\t\t\tbreak;\n\n\t\tbtrfs_set_root_node(&root->root_item, root->node);\n\t\tret = btrfs_update_root(trans, tree_root,\n\t\t\t\t\t&root->root_key,\n\t\t\t\t\t&root->root_item);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\told_root_used = btrfs_root_used(&root->root_item);\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"dev-replace.h\"",
      "#include \"volumes.h\"",
      "#include \"inode-map.h\"",
      "#include \"tree-log.h\"",
      "#include \"locking.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/uuid.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/writeback.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_root_used",
          "args": [
            "&root->root_item"
          ],
          "line": 1042
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_update_root",
          "args": [
            "trans",
            "tree_root",
            "&root->root_key",
            "&root->root_item"
          ],
          "line": 1036
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_update_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/root-tree.c",
          "lines": "135-210",
          "snippet": "int btrfs_update_root(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_key *key, struct btrfs_root_item\n\t\t      *item)\n{\n\tstruct btrfs_path *path;\n\tstruct extent_buffer *l;\n\tint ret;\n\tint slot;\n\tunsigned long ptr;\n\tint old_len;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tret = btrfs_search_slot(trans, root, key, path, 0, 1);\n\tif (ret < 0) {\n\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\tgoto out;\n\t}\n\n\tif (ret != 0) {\n\t\tbtrfs_print_leaf(root, path->nodes[0]);\n\t\tbtrfs_crit(root->fs_info, \"unable to update root key %llu %u %llu\",\n\t\t       key->objectid, key->type, key->offset);\n\t\tBUG_ON(1);\n\t}\n\n\tl = path->nodes[0];\n\tslot = path->slots[0];\n\tptr = btrfs_item_ptr_offset(l, slot);\n\told_len = btrfs_item_size_nr(l, slot);\n\n\t/*\n\t * If this is the first time we update the root item which originated\n\t * from an older kernel, we need to enlarge the item size to make room\n\t * for the added fields.\n\t */\n\tif (old_len < sizeof(*item)) {\n\t\tbtrfs_release_path(path);\n\t\tret = btrfs_search_slot(trans, root, key, path,\n\t\t\t\t-1, 1);\n\t\tif (ret < 0) {\n\t\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = btrfs_del_item(trans, root, path);\n\t\tif (ret < 0) {\n\t\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\t\tgoto out;\n\t\t}\n\t\tbtrfs_release_path(path);\n\t\tret = btrfs_insert_empty_item(trans, root, path,\n\t\t\t\tkey, sizeof(*item));\n\t\tif (ret < 0) {\n\t\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\t\tgoto out;\n\t\t}\n\t\tl = path->nodes[0];\n\t\tslot = path->slots[0];\n\t\tptr = btrfs_item_ptr_offset(l, slot);\n\t}\n\n\t/*\n\t * Update generation_v2 so at the next mount we know the new root\n\t * fields are valid.\n\t */\n\tbtrfs_set_root_generation_v2(item, btrfs_root_generation(item));\n\n\twrite_extent_buffer(l, item, ptr, sizeof(*item));\n\tbtrfs_mark_buffer_dirty(path->nodes[0]);\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}",
          "includes": [
            "#include \"print-tree.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uuid.h>",
            "#include <linux/err.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"print-tree.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/err.h>\n\nint btrfs_update_root(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_key *key, struct btrfs_root_item\n\t\t      *item)\n{\n\tstruct btrfs_path *path;\n\tstruct extent_buffer *l;\n\tint ret;\n\tint slot;\n\tunsigned long ptr;\n\tint old_len;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tret = btrfs_search_slot(trans, root, key, path, 0, 1);\n\tif (ret < 0) {\n\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\tgoto out;\n\t}\n\n\tif (ret != 0) {\n\t\tbtrfs_print_leaf(root, path->nodes[0]);\n\t\tbtrfs_crit(root->fs_info, \"unable to update root key %llu %u %llu\",\n\t\t       key->objectid, key->type, key->offset);\n\t\tBUG_ON(1);\n\t}\n\n\tl = path->nodes[0];\n\tslot = path->slots[0];\n\tptr = btrfs_item_ptr_offset(l, slot);\n\told_len = btrfs_item_size_nr(l, slot);\n\n\t/*\n\t * If this is the first time we update the root item which originated\n\t * from an older kernel, we need to enlarge the item size to make room\n\t * for the added fields.\n\t */\n\tif (old_len < sizeof(*item)) {\n\t\tbtrfs_release_path(path);\n\t\tret = btrfs_search_slot(trans, root, key, path,\n\t\t\t\t-1, 1);\n\t\tif (ret < 0) {\n\t\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = btrfs_del_item(trans, root, path);\n\t\tif (ret < 0) {\n\t\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\t\tgoto out;\n\t\t}\n\t\tbtrfs_release_path(path);\n\t\tret = btrfs_insert_empty_item(trans, root, path,\n\t\t\t\tkey, sizeof(*item));\n\t\tif (ret < 0) {\n\t\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\t\tgoto out;\n\t\t}\n\t\tl = path->nodes[0];\n\t\tslot = path->slots[0];\n\t\tptr = btrfs_item_ptr_offset(l, slot);\n\t}\n\n\t/*\n\t * Update generation_v2 so at the next mount we know the new root\n\t * fields are valid.\n\t */\n\tbtrfs_set_root_generation_v2(item, btrfs_root_generation(item));\n\n\twrite_extent_buffer(l, item, ptr, sizeof(*item));\n\tbtrfs_mark_buffer_dirty(path->nodes[0]);\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_set_root_node",
          "args": [
            "&root->root_item",
            "root->node"
          ],
          "line": 1035
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_root_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/root-tree.c",
          "lines": "124-130",
          "snippet": "void btrfs_set_root_node(struct btrfs_root_item *item,\n\t\t\t struct extent_buffer *node)\n{\n\tbtrfs_set_root_bytenr(item, node->start);\n\tbtrfs_set_root_level(item, btrfs_header_level(node));\n\tbtrfs_set_root_generation(item, btrfs_header_generation(node));\n}",
          "includes": [
            "#include \"print-tree.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uuid.h>",
            "#include <linux/err.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"print-tree.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/err.h>\n\nvoid btrfs_set_root_node(struct btrfs_root_item *item,\n\t\t\t struct extent_buffer *node)\n{\n\tbtrfs_set_root_bytenr(item, node->start);\n\tbtrfs_set_root_level(item, btrfs_header_level(node));\n\tbtrfs_set_root_generation(item, btrfs_header_generation(node));\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_root_used",
          "args": [
            "&root->root_item"
          ],
          "line": 1032
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_root_bytenr",
          "args": [
            "&root->root_item"
          ],
          "line": 1030
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_root_used",
          "args": [
            "&root->root_item"
          ],
          "line": 1027
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic int update_cowonly_root(struct btrfs_trans_handle *trans,\n\t\t\t       struct btrfs_root *root)\n{\n\tint ret;\n\tu64 old_root_bytenr;\n\tu64 old_root_used;\n\tstruct btrfs_root *tree_root = root->fs_info->tree_root;\n\n\told_root_used = btrfs_root_used(&root->root_item);\n\n\twhile (1) {\n\t\told_root_bytenr = btrfs_root_bytenr(&root->root_item);\n\t\tif (old_root_bytenr == root->node->start &&\n\t\t    old_root_used == btrfs_root_used(&root->root_item))\n\t\t\tbreak;\n\n\t\tbtrfs_set_root_node(&root->root_item, root->node);\n\t\tret = btrfs_update_root(trans, tree_root,\n\t\t\t\t\t&root->root_key,\n\t\t\t\t\t&root->root_item);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\told_root_used = btrfs_root_used(&root->root_item);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "btrfs_write_and_wait_transaction",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
    "lines": "996-1007",
    "snippet": "static int btrfs_write_and_wait_transaction(struct btrfs_trans_handle *trans,\n\t\t\t\t     struct btrfs_root *root)\n{\n\tint ret;\n\n\tret = btrfs_write_and_wait_marked_extents(root,\n\t\t\t\t\t   &trans->transaction->dirty_pages,\n\t\t\t\t\t   EXTENT_DIRTY);\n\tclear_btree_io_tree(&trans->transaction->dirty_pages);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"dev-replace.h\"",
      "#include \"volumes.h\"",
      "#include \"inode-map.h\"",
      "#include \"tree-log.h\"",
      "#include \"locking.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/uuid.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/writeback.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "clear_btree_io_tree",
          "args": [
            "&trans->transaction->dirty_pages"
          ],
          "line": 1004
        },
        "resolved": true,
        "details": {
          "function_name": "clear_btree_io_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
          "lines": "79-103",
          "snippet": "static void clear_btree_io_tree(struct extent_io_tree *tree)\n{\n\tspin_lock(&tree->lock);\n\twhile (!RB_EMPTY_ROOT(&tree->state)) {\n\t\tstruct rb_node *node;\n\t\tstruct extent_state *state;\n\n\t\tnode = rb_first(&tree->state);\n\t\tstate = rb_entry(node, struct extent_state, rb_node);\n\t\trb_erase(&state->rb_node, &tree->state);\n\t\tRB_CLEAR_NODE(&state->rb_node);\n\t\t/*\n\t\t * btree io trees aren't supposed to have tasks waiting for\n\t\t * changes in the flags of extent states ever.\n\t\t */\n\t\tASSERT(!waitqueue_active(&state->wq));\n\t\tfree_extent_state(state);\n\t\tif (need_resched()) {\n\t\t\tspin_unlock(&tree->lock);\n\t\t\tcond_resched();\n\t\t\tspin_lock(&tree->lock);\n\t\t}\n\t}\n\tspin_unlock(&tree->lock);\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"dev-replace.h\"",
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void clear_btree_io_tree(struct extent_io_tree *tree)\n{\n\tspin_lock(&tree->lock);\n\twhile (!RB_EMPTY_ROOT(&tree->state)) {\n\t\tstruct rb_node *node;\n\t\tstruct extent_state *state;\n\n\t\tnode = rb_first(&tree->state);\n\t\tstate = rb_entry(node, struct extent_state, rb_node);\n\t\trb_erase(&state->rb_node, &tree->state);\n\t\tRB_CLEAR_NODE(&state->rb_node);\n\t\t/*\n\t\t * btree io trees aren't supposed to have tasks waiting for\n\t\t * changes in the flags of extent states ever.\n\t\t */\n\t\tASSERT(!waitqueue_active(&state->wq));\n\t\tfree_extent_state(state);\n\t\tif (need_resched()) {\n\t\t\tspin_unlock(&tree->lock);\n\t\t\tcond_resched();\n\t\t\tspin_lock(&tree->lock);\n\t\t}\n\t}\n\tspin_unlock(&tree->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_write_and_wait_marked_extents",
          "args": [
            "root",
            "&trans->transaction->dirty_pages",
            "EXTENT_DIRTY"
          ],
          "line": 1001
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_write_and_wait_marked_extents",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
          "lines": "977-994",
          "snippet": "static int btrfs_write_and_wait_marked_extents(struct btrfs_root *root,\n\t\t\t\tstruct extent_io_tree *dirty_pages, int mark)\n{\n\tint ret;\n\tint ret2;\n\tstruct blk_plug plug;\n\n\tblk_start_plug(&plug);\n\tret = btrfs_write_marked_extents(root, dirty_pages, mark);\n\tblk_finish_plug(&plug);\n\tret2 = btrfs_wait_marked_extents(root, dirty_pages, mark);\n\n\tif (ret)\n\t\treturn ret;\n\tif (ret2)\n\t\treturn ret2;\n\treturn 0;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"dev-replace.h\"",
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic int btrfs_write_and_wait_marked_extents(struct btrfs_root *root,\n\t\t\t\tstruct extent_io_tree *dirty_pages, int mark)\n{\n\tint ret;\n\tint ret2;\n\tstruct blk_plug plug;\n\n\tblk_start_plug(&plug);\n\tret = btrfs_write_marked_extents(root, dirty_pages, mark);\n\tblk_finish_plug(&plug);\n\tret2 = btrfs_wait_marked_extents(root, dirty_pages, mark);\n\n\tif (ret)\n\t\treturn ret;\n\tif (ret2)\n\t\treturn ret2;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic int btrfs_write_and_wait_transaction(struct btrfs_trans_handle *trans,\n\t\t\t\t     struct btrfs_root *root)\n{\n\tint ret;\n\n\tret = btrfs_write_and_wait_marked_extents(root,\n\t\t\t\t\t   &trans->transaction->dirty_pages,\n\t\t\t\t\t   EXTENT_DIRTY);\n\tclear_btree_io_tree(&trans->transaction->dirty_pages);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "btrfs_write_and_wait_marked_extents",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
    "lines": "977-994",
    "snippet": "static int btrfs_write_and_wait_marked_extents(struct btrfs_root *root,\n\t\t\t\tstruct extent_io_tree *dirty_pages, int mark)\n{\n\tint ret;\n\tint ret2;\n\tstruct blk_plug plug;\n\n\tblk_start_plug(&plug);\n\tret = btrfs_write_marked_extents(root, dirty_pages, mark);\n\tblk_finish_plug(&plug);\n\tret2 = btrfs_wait_marked_extents(root, dirty_pages, mark);\n\n\tif (ret)\n\t\treturn ret;\n\tif (ret2)\n\t\treturn ret2;\n\treturn 0;\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"dev-replace.h\"",
      "#include \"volumes.h\"",
      "#include \"inode-map.h\"",
      "#include \"tree-log.h\"",
      "#include \"locking.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/uuid.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/writeback.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_wait_marked_extents",
          "args": [
            "root",
            "dirty_pages",
            "mark"
          ],
          "line": 987
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_wait_marked_extents",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
          "lines": "911-970",
          "snippet": "int btrfs_wait_marked_extents(struct btrfs_root *root,\n\t\t\t      struct extent_io_tree *dirty_pages, int mark)\n{\n\tint err = 0;\n\tint werr = 0;\n\tstruct address_space *mapping = root->fs_info->btree_inode->i_mapping;\n\tstruct extent_state *cached_state = NULL;\n\tu64 start = 0;\n\tu64 end;\n\tstruct btrfs_inode *btree_ino = BTRFS_I(root->fs_info->btree_inode);\n\tbool errors = false;\n\n\twhile (!find_first_extent_bit(dirty_pages, start, &start, &end,\n\t\t\t\t      EXTENT_NEED_WAIT, &cached_state)) {\n\t\t/*\n\t\t * Ignore -ENOMEM errors returned by clear_extent_bit().\n\t\t * When committing the transaction, we'll remove any entries\n\t\t * left in the io tree. For a log commit, we don't remove them\n\t\t * after committing the log because the tree can be accessed\n\t\t * concurrently - we do it only at transaction commit time when\n\t\t * it's safe to do it (through clear_btree_io_tree()).\n\t\t */\n\t\terr = clear_extent_bit(dirty_pages, start, end,\n\t\t\t\t       EXTENT_NEED_WAIT,\n\t\t\t\t       0, 0, &cached_state, GFP_NOFS);\n\t\tif (err == -ENOMEM)\n\t\t\terr = 0;\n\t\tif (!err)\n\t\t\terr = filemap_fdatawait_range(mapping, start, end);\n\t\tif (err)\n\t\t\twerr = err;\n\t\tfree_extent_state(cached_state);\n\t\tcached_state = NULL;\n\t\tcond_resched();\n\t\tstart = end + 1;\n\t}\n\tif (err)\n\t\twerr = err;\n\n\tif (root->root_key.objectid == BTRFS_TREE_LOG_OBJECTID) {\n\t\tif ((mark & EXTENT_DIRTY) &&\n\t\t    test_and_clear_bit(BTRFS_INODE_BTREE_LOG1_ERR,\n\t\t\t\t       &btree_ino->runtime_flags))\n\t\t\terrors = true;\n\n\t\tif ((mark & EXTENT_NEW) &&\n\t\t    test_and_clear_bit(BTRFS_INODE_BTREE_LOG2_ERR,\n\t\t\t\t       &btree_ino->runtime_flags))\n\t\t\terrors = true;\n\t} else {\n\t\tif (test_and_clear_bit(BTRFS_INODE_BTREE_ERR,\n\t\t\t\t       &btree_ino->runtime_flags))\n\t\t\terrors = true;\n\t}\n\n\tif (errors && !werr)\n\t\twerr = -EIO;\n\n\treturn werr;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"dev-replace.h\"",
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint btrfs_wait_marked_extents(struct btrfs_root *root,\n\t\t\t      struct extent_io_tree *dirty_pages, int mark)\n{\n\tint err = 0;\n\tint werr = 0;\n\tstruct address_space *mapping = root->fs_info->btree_inode->i_mapping;\n\tstruct extent_state *cached_state = NULL;\n\tu64 start = 0;\n\tu64 end;\n\tstruct btrfs_inode *btree_ino = BTRFS_I(root->fs_info->btree_inode);\n\tbool errors = false;\n\n\twhile (!find_first_extent_bit(dirty_pages, start, &start, &end,\n\t\t\t\t      EXTENT_NEED_WAIT, &cached_state)) {\n\t\t/*\n\t\t * Ignore -ENOMEM errors returned by clear_extent_bit().\n\t\t * When committing the transaction, we'll remove any entries\n\t\t * left in the io tree. For a log commit, we don't remove them\n\t\t * after committing the log because the tree can be accessed\n\t\t * concurrently - we do it only at transaction commit time when\n\t\t * it's safe to do it (through clear_btree_io_tree()).\n\t\t */\n\t\terr = clear_extent_bit(dirty_pages, start, end,\n\t\t\t\t       EXTENT_NEED_WAIT,\n\t\t\t\t       0, 0, &cached_state, GFP_NOFS);\n\t\tif (err == -ENOMEM)\n\t\t\terr = 0;\n\t\tif (!err)\n\t\t\terr = filemap_fdatawait_range(mapping, start, end);\n\t\tif (err)\n\t\t\twerr = err;\n\t\tfree_extent_state(cached_state);\n\t\tcached_state = NULL;\n\t\tcond_resched();\n\t\tstart = end + 1;\n\t}\n\tif (err)\n\t\twerr = err;\n\n\tif (root->root_key.objectid == BTRFS_TREE_LOG_OBJECTID) {\n\t\tif ((mark & EXTENT_DIRTY) &&\n\t\t    test_and_clear_bit(BTRFS_INODE_BTREE_LOG1_ERR,\n\t\t\t\t       &btree_ino->runtime_flags))\n\t\t\terrors = true;\n\n\t\tif ((mark & EXTENT_NEW) &&\n\t\t    test_and_clear_bit(BTRFS_INODE_BTREE_LOG2_ERR,\n\t\t\t\t       &btree_ino->runtime_flags))\n\t\t\terrors = true;\n\t} else {\n\t\tif (test_and_clear_bit(BTRFS_INODE_BTREE_ERR,\n\t\t\t\t       &btree_ino->runtime_flags))\n\t\t\terrors = true;\n\t}\n\n\tif (errors && !werr)\n\t\twerr = -EIO;\n\n\treturn werr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "blk_finish_plug",
          "args": [
            "&plug"
          ],
          "line": 986
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_write_marked_extents",
          "args": [
            "root",
            "dirty_pages",
            "mark"
          ],
          "line": 985
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_write_marked_extents",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
          "lines": "857-903",
          "snippet": "int btrfs_write_marked_extents(struct btrfs_root *root,\n\t\t\t       struct extent_io_tree *dirty_pages, int mark)\n{\n\tint err = 0;\n\tint werr = 0;\n\tstruct address_space *mapping = root->fs_info->btree_inode->i_mapping;\n\tstruct extent_state *cached_state = NULL;\n\tu64 start = 0;\n\tu64 end;\n\n\twhile (!find_first_extent_bit(dirty_pages, start, &start, &end,\n\t\t\t\t      mark, &cached_state)) {\n\t\tbool wait_writeback = false;\n\n\t\terr = convert_extent_bit(dirty_pages, start, end,\n\t\t\t\t\t EXTENT_NEED_WAIT,\n\t\t\t\t\t mark, &cached_state, GFP_NOFS);\n\t\t/*\n\t\t * convert_extent_bit can return -ENOMEM, which is most of the\n\t\t * time a temporary error. So when it happens, ignore the error\n\t\t * and wait for writeback of this range to finish - because we\n\t\t * failed to set the bit EXTENT_NEED_WAIT for the range, a call\n\t\t * to btrfs_wait_marked_extents() would not know that writeback\n\t\t * for this range started and therefore wouldn't wait for it to\n\t\t * finish - we don't want to commit a superblock that points to\n\t\t * btree nodes/leafs for which writeback hasn't finished yet\n\t\t * (and without errors).\n\t\t * We cleanup any entries left in the io tree when committing\n\t\t * the transaction (through clear_btree_io_tree()).\n\t\t */\n\t\tif (err == -ENOMEM) {\n\t\t\terr = 0;\n\t\t\twait_writeback = true;\n\t\t}\n\t\tif (!err)\n\t\t\terr = filemap_fdatawrite_range(mapping, start, end);\n\t\tif (err)\n\t\t\twerr = err;\n\t\telse if (wait_writeback)\n\t\t\twerr = filemap_fdatawait_range(mapping, start, end);\n\t\tfree_extent_state(cached_state);\n\t\tcached_state = NULL;\n\t\tcond_resched();\n\t\tstart = end + 1;\n\t}\n\treturn werr;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"dev-replace.h\"",
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint btrfs_write_marked_extents(struct btrfs_root *root,\n\t\t\t       struct extent_io_tree *dirty_pages, int mark)\n{\n\tint err = 0;\n\tint werr = 0;\n\tstruct address_space *mapping = root->fs_info->btree_inode->i_mapping;\n\tstruct extent_state *cached_state = NULL;\n\tu64 start = 0;\n\tu64 end;\n\n\twhile (!find_first_extent_bit(dirty_pages, start, &start, &end,\n\t\t\t\t      mark, &cached_state)) {\n\t\tbool wait_writeback = false;\n\n\t\terr = convert_extent_bit(dirty_pages, start, end,\n\t\t\t\t\t EXTENT_NEED_WAIT,\n\t\t\t\t\t mark, &cached_state, GFP_NOFS);\n\t\t/*\n\t\t * convert_extent_bit can return -ENOMEM, which is most of the\n\t\t * time a temporary error. So when it happens, ignore the error\n\t\t * and wait for writeback of this range to finish - because we\n\t\t * failed to set the bit EXTENT_NEED_WAIT for the range, a call\n\t\t * to btrfs_wait_marked_extents() would not know that writeback\n\t\t * for this range started and therefore wouldn't wait for it to\n\t\t * finish - we don't want to commit a superblock that points to\n\t\t * btree nodes/leafs for which writeback hasn't finished yet\n\t\t * (and without errors).\n\t\t * We cleanup any entries left in the io tree when committing\n\t\t * the transaction (through clear_btree_io_tree()).\n\t\t */\n\t\tif (err == -ENOMEM) {\n\t\t\terr = 0;\n\t\t\twait_writeback = true;\n\t\t}\n\t\tif (!err)\n\t\t\terr = filemap_fdatawrite_range(mapping, start, end);\n\t\tif (err)\n\t\t\twerr = err;\n\t\telse if (wait_writeback)\n\t\t\twerr = filemap_fdatawait_range(mapping, start, end);\n\t\tfree_extent_state(cached_state);\n\t\tcached_state = NULL;\n\t\tcond_resched();\n\t\tstart = end + 1;\n\t}\n\treturn werr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "blk_start_plug",
          "args": [
            "&plug"
          ],
          "line": 984
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic int btrfs_write_and_wait_marked_extents(struct btrfs_root *root,\n\t\t\t\tstruct extent_io_tree *dirty_pages, int mark)\n{\n\tint ret;\n\tint ret2;\n\tstruct blk_plug plug;\n\n\tblk_start_plug(&plug);\n\tret = btrfs_write_marked_extents(root, dirty_pages, mark);\n\tblk_finish_plug(&plug);\n\tret2 = btrfs_wait_marked_extents(root, dirty_pages, mark);\n\n\tif (ret)\n\t\treturn ret;\n\tif (ret2)\n\t\treturn ret2;\n\treturn 0;\n}"
  },
  {
    "function_name": "btrfs_wait_marked_extents",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
    "lines": "911-970",
    "snippet": "int btrfs_wait_marked_extents(struct btrfs_root *root,\n\t\t\t      struct extent_io_tree *dirty_pages, int mark)\n{\n\tint err = 0;\n\tint werr = 0;\n\tstruct address_space *mapping = root->fs_info->btree_inode->i_mapping;\n\tstruct extent_state *cached_state = NULL;\n\tu64 start = 0;\n\tu64 end;\n\tstruct btrfs_inode *btree_ino = BTRFS_I(root->fs_info->btree_inode);\n\tbool errors = false;\n\n\twhile (!find_first_extent_bit(dirty_pages, start, &start, &end,\n\t\t\t\t      EXTENT_NEED_WAIT, &cached_state)) {\n\t\t/*\n\t\t * Ignore -ENOMEM errors returned by clear_extent_bit().\n\t\t * When committing the transaction, we'll remove any entries\n\t\t * left in the io tree. For a log commit, we don't remove them\n\t\t * after committing the log because the tree can be accessed\n\t\t * concurrently - we do it only at transaction commit time when\n\t\t * it's safe to do it (through clear_btree_io_tree()).\n\t\t */\n\t\terr = clear_extent_bit(dirty_pages, start, end,\n\t\t\t\t       EXTENT_NEED_WAIT,\n\t\t\t\t       0, 0, &cached_state, GFP_NOFS);\n\t\tif (err == -ENOMEM)\n\t\t\terr = 0;\n\t\tif (!err)\n\t\t\terr = filemap_fdatawait_range(mapping, start, end);\n\t\tif (err)\n\t\t\twerr = err;\n\t\tfree_extent_state(cached_state);\n\t\tcached_state = NULL;\n\t\tcond_resched();\n\t\tstart = end + 1;\n\t}\n\tif (err)\n\t\twerr = err;\n\n\tif (root->root_key.objectid == BTRFS_TREE_LOG_OBJECTID) {\n\t\tif ((mark & EXTENT_DIRTY) &&\n\t\t    test_and_clear_bit(BTRFS_INODE_BTREE_LOG1_ERR,\n\t\t\t\t       &btree_ino->runtime_flags))\n\t\t\terrors = true;\n\n\t\tif ((mark & EXTENT_NEW) &&\n\t\t    test_and_clear_bit(BTRFS_INODE_BTREE_LOG2_ERR,\n\t\t\t\t       &btree_ino->runtime_flags))\n\t\t\terrors = true;\n\t} else {\n\t\tif (test_and_clear_bit(BTRFS_INODE_BTREE_ERR,\n\t\t\t\t       &btree_ino->runtime_flags))\n\t\t\terrors = true;\n\t}\n\n\tif (errors && !werr)\n\t\twerr = -EIO;\n\n\treturn werr;\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"dev-replace.h\"",
      "#include \"volumes.h\"",
      "#include \"inode-map.h\"",
      "#include \"tree-log.h\"",
      "#include \"locking.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/uuid.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/writeback.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "test_and_clear_bit",
          "args": [
            "BTRFS_INODE_BTREE_ERR",
            "&btree_ino->runtime_flags"
          ],
          "line": 961
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_test_and_clear_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1129-1139",
          "snippet": "static inline int f2fs_test_and_clear_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr &= ~mask;\n\treturn ret;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int f2fs_test_and_clear_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr &= ~mask;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 944
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_extent_state",
          "args": [
            "cached_state"
          ],
          "line": 942
        },
        "resolved": true,
        "details": {
          "function_name": "free_extent_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "225-235",
          "snippet": "void free_extent_state(struct extent_state *state)\n{\n\tif (!state)\n\t\treturn;\n\tif (atomic_dec_and_test(&state->refs)) {\n\t\tWARN_ON(extent_state_in_tree(state));\n\t\tbtrfs_leak_debug_del(&state->leak_list);\n\t\ttrace_free_extent_state(state, _RET_IP_);\n\t\tkmem_cache_free(extent_state_cache, state);\n\t}\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *extent_state_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic struct kmem_cache *extent_state_cache;\n\nvoid free_extent_state(struct extent_state *state)\n{\n\tif (!state)\n\t\treturn;\n\tif (atomic_dec_and_test(&state->refs)) {\n\t\tWARN_ON(extent_state_in_tree(state));\n\t\tbtrfs_leak_debug_del(&state->leak_list);\n\t\ttrace_free_extent_state(state, _RET_IP_);\n\t\tkmem_cache_free(extent_state_cache, state);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "filemap_fdatawait_range",
          "args": [
            "mapping",
            "start",
            "end"
          ],
          "line": 939
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_extent_bit",
          "args": [
            "dirty_pages",
            "start",
            "end",
            "EXTENT_NEED_WAIT",
            "0",
            "0",
            "&cached_state",
            "GFP_NOFS"
          ],
          "line": 933
        },
        "resolved": true,
        "details": {
          "function_name": "clear_extent_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "572-724",
          "snippet": "int clear_extent_bit(struct extent_io_tree *tree, u64 start, u64 end,\n\t\t     unsigned bits, int wake, int delete,\n\t\t     struct extent_state **cached_state,\n\t\t     gfp_t mask)\n{\n\tstruct extent_state *state;\n\tstruct extent_state *cached;\n\tstruct extent_state *prealloc = NULL;\n\tstruct rb_node *node;\n\tu64 last_end;\n\tint err;\n\tint clear = 0;\n\n\tbtrfs_debug_check_extent_io_range(tree, start, end);\n\n\tif (bits & EXTENT_DELALLOC)\n\t\tbits |= EXTENT_NORESERVE;\n\n\tif (delete)\n\t\tbits |= ~EXTENT_CTLBITS;\n\tbits |= EXTENT_FIRST_DELALLOC;\n\n\tif (bits & (EXTENT_IOBITS | EXTENT_BOUNDARY))\n\t\tclear = 1;\nagain:\n\tif (!prealloc && (mask & __GFP_WAIT)) {\n\t\t/*\n\t\t * Don't care for allocation failure here because we might end\n\t\t * up not needing the pre-allocated extent state at all, which\n\t\t * is the case if we only have in the tree extent states that\n\t\t * cover our input range and don't cover too any other range.\n\t\t * If we end up needing a new extent state we allocate it later.\n\t\t */\n\t\tprealloc = alloc_extent_state(mask);\n\t}\n\n\tspin_lock(&tree->lock);\n\tif (cached_state) {\n\t\tcached = *cached_state;\n\n\t\tif (clear) {\n\t\t\t*cached_state = NULL;\n\t\t\tcached_state = NULL;\n\t\t}\n\n\t\tif (cached && extent_state_in_tree(cached) &&\n\t\t    cached->start <= start && cached->end > start) {\n\t\t\tif (clear)\n\t\t\t\tatomic_dec(&cached->refs);\n\t\t\tstate = cached;\n\t\t\tgoto hit_next;\n\t\t}\n\t\tif (clear)\n\t\t\tfree_extent_state(cached);\n\t}\n\t/*\n\t * this search will find the extents that end after\n\t * our range starts\n\t */\n\tnode = tree_search(tree, start);\n\tif (!node)\n\t\tgoto out;\n\tstate = rb_entry(node, struct extent_state, rb_node);\nhit_next:\n\tif (state->start > end)\n\t\tgoto out;\n\tWARN_ON(state->end < start);\n\tlast_end = state->end;\n\n\t/* the state doesn't have the wanted bits, go ahead */\n\tif (!(state->state & bits)) {\n\t\tstate = next_state(state);\n\t\tgoto next;\n\t}\n\n\t/*\n\t *     | ---- desired range ---- |\n\t *  | state | or\n\t *  | ------------- state -------------- |\n\t *\n\t * We need to split the extent we found, and may flip\n\t * bits on second half.\n\t *\n\t * If the extent we found extends past our range, we\n\t * just split and search again.  It'll get split again\n\t * the next time though.\n\t *\n\t * If the extent we found is inside our range, we clear\n\t * the desired bit on it.\n\t */\n\n\tif (state->start < start) {\n\t\tprealloc = alloc_extent_state_atomic(prealloc);\n\t\tBUG_ON(!prealloc);\n\t\terr = split_state(tree, state, prealloc, start);\n\t\tif (err)\n\t\t\textent_io_tree_panic(tree, err);\n\n\t\tprealloc = NULL;\n\t\tif (err)\n\t\t\tgoto out;\n\t\tif (state->end <= end) {\n\t\t\tstate = clear_state_bit(tree, state, &bits, wake);\n\t\t\tgoto next;\n\t\t}\n\t\tgoto search_again;\n\t}\n\t/*\n\t * | ---- desired range ---- |\n\t *                        | state |\n\t * We need to split the extent, and clear the bit\n\t * on the first half\n\t */\n\tif (state->start <= end && state->end > end) {\n\t\tprealloc = alloc_extent_state_atomic(prealloc);\n\t\tBUG_ON(!prealloc);\n\t\terr = split_state(tree, state, prealloc, end + 1);\n\t\tif (err)\n\t\t\textent_io_tree_panic(tree, err);\n\n\t\tif (wake)\n\t\t\twake_up(&state->wq);\n\n\t\tclear_state_bit(tree, prealloc, &bits, wake);\n\n\t\tprealloc = NULL;\n\t\tgoto out;\n\t}\n\n\tstate = clear_state_bit(tree, state, &bits, wake);\nnext:\n\tif (last_end == (u64)-1)\n\t\tgoto out;\n\tstart = last_end + 1;\n\tif (start <= end && state && !need_resched())\n\t\tgoto hit_next;\n\tgoto search_again;\n\nout:\n\tspin_unlock(&tree->lock);\n\tif (prealloc)\n\t\tfree_extent_state(prealloc);\n\n\treturn 0;\n\nsearch_again:\n\tif (start > end)\n\t\tgoto out;\n\tspin_unlock(&tree->lock);\n\tif (mask & __GFP_WAIT)\n\t\tcond_resched();\n\tgoto again;\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void set_state_bits(struct extent_io_tree *tree,\n\t\t\t   struct extent_state *state, unsigned *bits);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic void set_state_bits(struct extent_io_tree *tree,\n\t\t\t   struct extent_state *state, unsigned *bits);\n\nint clear_extent_bit(struct extent_io_tree *tree, u64 start, u64 end,\n\t\t     unsigned bits, int wake, int delete,\n\t\t     struct extent_state **cached_state,\n\t\t     gfp_t mask)\n{\n\tstruct extent_state *state;\n\tstruct extent_state *cached;\n\tstruct extent_state *prealloc = NULL;\n\tstruct rb_node *node;\n\tu64 last_end;\n\tint err;\n\tint clear = 0;\n\n\tbtrfs_debug_check_extent_io_range(tree, start, end);\n\n\tif (bits & EXTENT_DELALLOC)\n\t\tbits |= EXTENT_NORESERVE;\n\n\tif (delete)\n\t\tbits |= ~EXTENT_CTLBITS;\n\tbits |= EXTENT_FIRST_DELALLOC;\n\n\tif (bits & (EXTENT_IOBITS | EXTENT_BOUNDARY))\n\t\tclear = 1;\nagain:\n\tif (!prealloc && (mask & __GFP_WAIT)) {\n\t\t/*\n\t\t * Don't care for allocation failure here because we might end\n\t\t * up not needing the pre-allocated extent state at all, which\n\t\t * is the case if we only have in the tree extent states that\n\t\t * cover our input range and don't cover too any other range.\n\t\t * If we end up needing a new extent state we allocate it later.\n\t\t */\n\t\tprealloc = alloc_extent_state(mask);\n\t}\n\n\tspin_lock(&tree->lock);\n\tif (cached_state) {\n\t\tcached = *cached_state;\n\n\t\tif (clear) {\n\t\t\t*cached_state = NULL;\n\t\t\tcached_state = NULL;\n\t\t}\n\n\t\tif (cached && extent_state_in_tree(cached) &&\n\t\t    cached->start <= start && cached->end > start) {\n\t\t\tif (clear)\n\t\t\t\tatomic_dec(&cached->refs);\n\t\t\tstate = cached;\n\t\t\tgoto hit_next;\n\t\t}\n\t\tif (clear)\n\t\t\tfree_extent_state(cached);\n\t}\n\t/*\n\t * this search will find the extents that end after\n\t * our range starts\n\t */\n\tnode = tree_search(tree, start);\n\tif (!node)\n\t\tgoto out;\n\tstate = rb_entry(node, struct extent_state, rb_node);\nhit_next:\n\tif (state->start > end)\n\t\tgoto out;\n\tWARN_ON(state->end < start);\n\tlast_end = state->end;\n\n\t/* the state doesn't have the wanted bits, go ahead */\n\tif (!(state->state & bits)) {\n\t\tstate = next_state(state);\n\t\tgoto next;\n\t}\n\n\t/*\n\t *     | ---- desired range ---- |\n\t *  | state | or\n\t *  | ------------- state -------------- |\n\t *\n\t * We need to split the extent we found, and may flip\n\t * bits on second half.\n\t *\n\t * If the extent we found extends past our range, we\n\t * just split and search again.  It'll get split again\n\t * the next time though.\n\t *\n\t * If the extent we found is inside our range, we clear\n\t * the desired bit on it.\n\t */\n\n\tif (state->start < start) {\n\t\tprealloc = alloc_extent_state_atomic(prealloc);\n\t\tBUG_ON(!prealloc);\n\t\terr = split_state(tree, state, prealloc, start);\n\t\tif (err)\n\t\t\textent_io_tree_panic(tree, err);\n\n\t\tprealloc = NULL;\n\t\tif (err)\n\t\t\tgoto out;\n\t\tif (state->end <= end) {\n\t\t\tstate = clear_state_bit(tree, state, &bits, wake);\n\t\t\tgoto next;\n\t\t}\n\t\tgoto search_again;\n\t}\n\t/*\n\t * | ---- desired range ---- |\n\t *                        | state |\n\t * We need to split the extent, and clear the bit\n\t * on the first half\n\t */\n\tif (state->start <= end && state->end > end) {\n\t\tprealloc = alloc_extent_state_atomic(prealloc);\n\t\tBUG_ON(!prealloc);\n\t\terr = split_state(tree, state, prealloc, end + 1);\n\t\tif (err)\n\t\t\textent_io_tree_panic(tree, err);\n\n\t\tif (wake)\n\t\t\twake_up(&state->wq);\n\n\t\tclear_state_bit(tree, prealloc, &bits, wake);\n\n\t\tprealloc = NULL;\n\t\tgoto out;\n\t}\n\n\tstate = clear_state_bit(tree, state, &bits, wake);\nnext:\n\tif (last_end == (u64)-1)\n\t\tgoto out;\n\tstart = last_end + 1;\n\tif (start <= end && state && !need_resched())\n\t\tgoto hit_next;\n\tgoto search_again;\n\nout:\n\tspin_unlock(&tree->lock);\n\tif (prealloc)\n\t\tfree_extent_state(prealloc);\n\n\treturn 0;\n\nsearch_again:\n\tif (start > end)\n\t\tgoto out;\n\tspin_unlock(&tree->lock);\n\tif (mask & __GFP_WAIT)\n\t\tcond_resched();\n\tgoto again;\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_first_extent_bit",
          "args": [
            "dirty_pages",
            "start",
            "&start",
            "&end",
            "EXTENT_NEED_WAIT",
            "&cached_state"
          ],
          "line": 923
        },
        "resolved": true,
        "details": {
          "function_name": "find_first_extent_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "1477-1516",
          "snippet": "int find_first_extent_bit(struct extent_io_tree *tree, u64 start,\n\t\t\t  u64 *start_ret, u64 *end_ret, unsigned bits,\n\t\t\t  struct extent_state **cached_state)\n{\n\tstruct extent_state *state;\n\tstruct rb_node *n;\n\tint ret = 1;\n\n\tspin_lock(&tree->lock);\n\tif (cached_state && *cached_state) {\n\t\tstate = *cached_state;\n\t\tif (state->end == start - 1 && extent_state_in_tree(state)) {\n\t\t\tn = rb_next(&state->rb_node);\n\t\t\twhile (n) {\n\t\t\t\tstate = rb_entry(n, struct extent_state,\n\t\t\t\t\t\t rb_node);\n\t\t\t\tif (state->state & bits)\n\t\t\t\t\tgoto got_it;\n\t\t\t\tn = rb_next(n);\n\t\t\t}\n\t\t\tfree_extent_state(*cached_state);\n\t\t\t*cached_state = NULL;\n\t\t\tgoto out;\n\t\t}\n\t\tfree_extent_state(*cached_state);\n\t\t*cached_state = NULL;\n\t}\n\n\tstate = find_first_extent_bit_state(tree, start, bits);\ngot_it:\n\tif (state) {\n\t\tcache_state_if_flags(state, cached_state, 0);\n\t\t*start_ret = state->start;\n\t\t*end_ret = state->end;\n\t\tret = 0;\n\t}\nout:\n\tspin_unlock(&tree->lock);\n\treturn ret;\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void set_state_bits(struct extent_io_tree *tree,\n\t\t\t   struct extent_state *state, unsigned *bits);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic void set_state_bits(struct extent_io_tree *tree,\n\t\t\t   struct extent_state *state, unsigned *bits);\n\nint find_first_extent_bit(struct extent_io_tree *tree, u64 start,\n\t\t\t  u64 *start_ret, u64 *end_ret, unsigned bits,\n\t\t\t  struct extent_state **cached_state)\n{\n\tstruct extent_state *state;\n\tstruct rb_node *n;\n\tint ret = 1;\n\n\tspin_lock(&tree->lock);\n\tif (cached_state && *cached_state) {\n\t\tstate = *cached_state;\n\t\tif (state->end == start - 1 && extent_state_in_tree(state)) {\n\t\t\tn = rb_next(&state->rb_node);\n\t\t\twhile (n) {\n\t\t\t\tstate = rb_entry(n, struct extent_state,\n\t\t\t\t\t\t rb_node);\n\t\t\t\tif (state->state & bits)\n\t\t\t\t\tgoto got_it;\n\t\t\t\tn = rb_next(n);\n\t\t\t}\n\t\t\tfree_extent_state(*cached_state);\n\t\t\t*cached_state = NULL;\n\t\t\tgoto out;\n\t\t}\n\t\tfree_extent_state(*cached_state);\n\t\t*cached_state = NULL;\n\t}\n\n\tstate = find_first_extent_bit_state(tree, start, bits);\ngot_it:\n\tif (state) {\n\t\tcache_state_if_flags(state, cached_state, 0);\n\t\t*start_ret = state->start;\n\t\t*end_ret = state->end;\n\t\tret = 0;\n\t}\nout:\n\tspin_unlock(&tree->lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BTRFS_I",
          "args": [
            "root->fs_info->btree_inode"
          ],
          "line": 920
        },
        "resolved": true,
        "details": {
          "function_name": "BTRFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "196-199",
          "snippet": "static inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint btrfs_wait_marked_extents(struct btrfs_root *root,\n\t\t\t      struct extent_io_tree *dirty_pages, int mark)\n{\n\tint err = 0;\n\tint werr = 0;\n\tstruct address_space *mapping = root->fs_info->btree_inode->i_mapping;\n\tstruct extent_state *cached_state = NULL;\n\tu64 start = 0;\n\tu64 end;\n\tstruct btrfs_inode *btree_ino = BTRFS_I(root->fs_info->btree_inode);\n\tbool errors = false;\n\n\twhile (!find_first_extent_bit(dirty_pages, start, &start, &end,\n\t\t\t\t      EXTENT_NEED_WAIT, &cached_state)) {\n\t\t/*\n\t\t * Ignore -ENOMEM errors returned by clear_extent_bit().\n\t\t * When committing the transaction, we'll remove any entries\n\t\t * left in the io tree. For a log commit, we don't remove them\n\t\t * after committing the log because the tree can be accessed\n\t\t * concurrently - we do it only at transaction commit time when\n\t\t * it's safe to do it (through clear_btree_io_tree()).\n\t\t */\n\t\terr = clear_extent_bit(dirty_pages, start, end,\n\t\t\t\t       EXTENT_NEED_WAIT,\n\t\t\t\t       0, 0, &cached_state, GFP_NOFS);\n\t\tif (err == -ENOMEM)\n\t\t\terr = 0;\n\t\tif (!err)\n\t\t\terr = filemap_fdatawait_range(mapping, start, end);\n\t\tif (err)\n\t\t\twerr = err;\n\t\tfree_extent_state(cached_state);\n\t\tcached_state = NULL;\n\t\tcond_resched();\n\t\tstart = end + 1;\n\t}\n\tif (err)\n\t\twerr = err;\n\n\tif (root->root_key.objectid == BTRFS_TREE_LOG_OBJECTID) {\n\t\tif ((mark & EXTENT_DIRTY) &&\n\t\t    test_and_clear_bit(BTRFS_INODE_BTREE_LOG1_ERR,\n\t\t\t\t       &btree_ino->runtime_flags))\n\t\t\terrors = true;\n\n\t\tif ((mark & EXTENT_NEW) &&\n\t\t    test_and_clear_bit(BTRFS_INODE_BTREE_LOG2_ERR,\n\t\t\t\t       &btree_ino->runtime_flags))\n\t\t\terrors = true;\n\t} else {\n\t\tif (test_and_clear_bit(BTRFS_INODE_BTREE_ERR,\n\t\t\t\t       &btree_ino->runtime_flags))\n\t\t\terrors = true;\n\t}\n\n\tif (errors && !werr)\n\t\twerr = -EIO;\n\n\treturn werr;\n}"
  },
  {
    "function_name": "btrfs_write_marked_extents",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
    "lines": "857-903",
    "snippet": "int btrfs_write_marked_extents(struct btrfs_root *root,\n\t\t\t       struct extent_io_tree *dirty_pages, int mark)\n{\n\tint err = 0;\n\tint werr = 0;\n\tstruct address_space *mapping = root->fs_info->btree_inode->i_mapping;\n\tstruct extent_state *cached_state = NULL;\n\tu64 start = 0;\n\tu64 end;\n\n\twhile (!find_first_extent_bit(dirty_pages, start, &start, &end,\n\t\t\t\t      mark, &cached_state)) {\n\t\tbool wait_writeback = false;\n\n\t\terr = convert_extent_bit(dirty_pages, start, end,\n\t\t\t\t\t EXTENT_NEED_WAIT,\n\t\t\t\t\t mark, &cached_state, GFP_NOFS);\n\t\t/*\n\t\t * convert_extent_bit can return -ENOMEM, which is most of the\n\t\t * time a temporary error. So when it happens, ignore the error\n\t\t * and wait for writeback of this range to finish - because we\n\t\t * failed to set the bit EXTENT_NEED_WAIT for the range, a call\n\t\t * to btrfs_wait_marked_extents() would not know that writeback\n\t\t * for this range started and therefore wouldn't wait for it to\n\t\t * finish - we don't want to commit a superblock that points to\n\t\t * btree nodes/leafs for which writeback hasn't finished yet\n\t\t * (and without errors).\n\t\t * We cleanup any entries left in the io tree when committing\n\t\t * the transaction (through clear_btree_io_tree()).\n\t\t */\n\t\tif (err == -ENOMEM) {\n\t\t\terr = 0;\n\t\t\twait_writeback = true;\n\t\t}\n\t\tif (!err)\n\t\t\terr = filemap_fdatawrite_range(mapping, start, end);\n\t\tif (err)\n\t\t\twerr = err;\n\t\telse if (wait_writeback)\n\t\t\twerr = filemap_fdatawait_range(mapping, start, end);\n\t\tfree_extent_state(cached_state);\n\t\tcached_state = NULL;\n\t\tcond_resched();\n\t\tstart = end + 1;\n\t}\n\treturn werr;\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"dev-replace.h\"",
      "#include \"volumes.h\"",
      "#include \"inode-map.h\"",
      "#include \"tree-log.h\"",
      "#include \"locking.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/uuid.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/writeback.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 899
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_extent_state",
          "args": [
            "cached_state"
          ],
          "line": 897
        },
        "resolved": true,
        "details": {
          "function_name": "free_extent_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "225-235",
          "snippet": "void free_extent_state(struct extent_state *state)\n{\n\tif (!state)\n\t\treturn;\n\tif (atomic_dec_and_test(&state->refs)) {\n\t\tWARN_ON(extent_state_in_tree(state));\n\t\tbtrfs_leak_debug_del(&state->leak_list);\n\t\ttrace_free_extent_state(state, _RET_IP_);\n\t\tkmem_cache_free(extent_state_cache, state);\n\t}\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *extent_state_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic struct kmem_cache *extent_state_cache;\n\nvoid free_extent_state(struct extent_state *state)\n{\n\tif (!state)\n\t\treturn;\n\tif (atomic_dec_and_test(&state->refs)) {\n\t\tWARN_ON(extent_state_in_tree(state));\n\t\tbtrfs_leak_debug_del(&state->leak_list);\n\t\ttrace_free_extent_state(state, _RET_IP_);\n\t\tkmem_cache_free(extent_state_cache, state);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "filemap_fdatawait_range",
          "args": [
            "mapping",
            "start",
            "end"
          ],
          "line": 896
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "filemap_fdatawrite_range",
          "args": [
            "mapping",
            "start",
            "end"
          ],
          "line": 892
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "convert_extent_bit",
          "args": [
            "dirty_pages",
            "start",
            "end",
            "EXTENT_NEED_WAIT",
            "mark",
            "&cached_state",
            "GFP_NOFS"
          ],
          "line": 871
        },
        "resolved": true,
        "details": {
          "function_name": "convert_extent_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "1062-1260",
          "snippet": "int convert_extent_bit(struct extent_io_tree *tree, u64 start, u64 end,\n\t\t       unsigned bits, unsigned clear_bits,\n\t\t       struct extent_state **cached_state, gfp_t mask)\n{\n\tstruct extent_state *state;\n\tstruct extent_state *prealloc = NULL;\n\tstruct rb_node *node;\n\tstruct rb_node **p;\n\tstruct rb_node *parent;\n\tint err = 0;\n\tu64 last_start;\n\tu64 last_end;\n\tbool first_iteration = true;\n\n\tbtrfs_debug_check_extent_io_range(tree, start, end);\n\nagain:\n\tif (!prealloc && (mask & __GFP_WAIT)) {\n\t\t/*\n\t\t * Best effort, don't worry if extent state allocation fails\n\t\t * here for the first iteration. We might have a cached state\n\t\t * that matches exactly the target range, in which case no\n\t\t * extent state allocations are needed. We'll only know this\n\t\t * after locking the tree.\n\t\t */\n\t\tprealloc = alloc_extent_state(mask);\n\t\tif (!prealloc && !first_iteration)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tspin_lock(&tree->lock);\n\tif (cached_state && *cached_state) {\n\t\tstate = *cached_state;\n\t\tif (state->start <= start && state->end > start &&\n\t\t    extent_state_in_tree(state)) {\n\t\t\tnode = &state->rb_node;\n\t\t\tgoto hit_next;\n\t\t}\n\t}\n\n\t/*\n\t * this search will find all the extents that end after\n\t * our range starts.\n\t */\n\tnode = tree_search_for_insert(tree, start, &p, &parent);\n\tif (!node) {\n\t\tprealloc = alloc_extent_state_atomic(prealloc);\n\t\tif (!prealloc) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\terr = insert_state(tree, prealloc, start, end,\n\t\t\t\t   &p, &parent, &bits);\n\t\tif (err)\n\t\t\textent_io_tree_panic(tree, err);\n\t\tcache_state(prealloc, cached_state);\n\t\tprealloc = NULL;\n\t\tgoto out;\n\t}\n\tstate = rb_entry(node, struct extent_state, rb_node);\nhit_next:\n\tlast_start = state->start;\n\tlast_end = state->end;\n\n\t/*\n\t * | ---- desired range ---- |\n\t * | state |\n\t *\n\t * Just lock what we found and keep going\n\t */\n\tif (state->start == start && state->end <= end) {\n\t\tset_state_bits(tree, state, &bits);\n\t\tcache_state(state, cached_state);\n\t\tstate = clear_state_bit(tree, state, &clear_bits, 0);\n\t\tif (last_end == (u64)-1)\n\t\t\tgoto out;\n\t\tstart = last_end + 1;\n\t\tif (start < end && state && state->start == start &&\n\t\t    !need_resched())\n\t\t\tgoto hit_next;\n\t\tgoto search_again;\n\t}\n\n\t/*\n\t *     | ---- desired range ---- |\n\t * | state |\n\t *   or\n\t * | ------------- state -------------- |\n\t *\n\t * We need to split the extent we found, and may flip bits on\n\t * second half.\n\t *\n\t * If the extent we found extends past our\n\t * range, we just split and search again.  It'll get split\n\t * again the next time though.\n\t *\n\t * If the extent we found is inside our range, we set the\n\t * desired bit on it.\n\t */\n\tif (state->start < start) {\n\t\tprealloc = alloc_extent_state_atomic(prealloc);\n\t\tif (!prealloc) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\terr = split_state(tree, state, prealloc, start);\n\t\tif (err)\n\t\t\textent_io_tree_panic(tree, err);\n\t\tprealloc = NULL;\n\t\tif (err)\n\t\t\tgoto out;\n\t\tif (state->end <= end) {\n\t\t\tset_state_bits(tree, state, &bits);\n\t\t\tcache_state(state, cached_state);\n\t\t\tstate = clear_state_bit(tree, state, &clear_bits, 0);\n\t\t\tif (last_end == (u64)-1)\n\t\t\t\tgoto out;\n\t\t\tstart = last_end + 1;\n\t\t\tif (start < end && state && state->start == start &&\n\t\t\t    !need_resched())\n\t\t\t\tgoto hit_next;\n\t\t}\n\t\tgoto search_again;\n\t}\n\t/*\n\t * | ---- desired range ---- |\n\t *     | state | or               | state |\n\t *\n\t * There's a hole, we need to insert something in it and\n\t * ignore the extent we found.\n\t */\n\tif (state->start > start) {\n\t\tu64 this_end;\n\t\tif (end < last_start)\n\t\t\tthis_end = end;\n\t\telse\n\t\t\tthis_end = last_start - 1;\n\n\t\tprealloc = alloc_extent_state_atomic(prealloc);\n\t\tif (!prealloc) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\n\t\t/*\n\t\t * Avoid to free 'prealloc' if it can be merged with\n\t\t * the later extent.\n\t\t */\n\t\terr = insert_state(tree, prealloc, start, this_end,\n\t\t\t\t   NULL, NULL, &bits);\n\t\tif (err)\n\t\t\textent_io_tree_panic(tree, err);\n\t\tcache_state(prealloc, cached_state);\n\t\tprealloc = NULL;\n\t\tstart = this_end + 1;\n\t\tgoto search_again;\n\t}\n\t/*\n\t * | ---- desired range ---- |\n\t *                        | state |\n\t * We need to split the extent, and set the bit\n\t * on the first half\n\t */\n\tif (state->start <= end && state->end > end) {\n\t\tprealloc = alloc_extent_state_atomic(prealloc);\n\t\tif (!prealloc) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\n\t\terr = split_state(tree, state, prealloc, end + 1);\n\t\tif (err)\n\t\t\textent_io_tree_panic(tree, err);\n\n\t\tset_state_bits(tree, prealloc, &bits);\n\t\tcache_state(prealloc, cached_state);\n\t\tclear_state_bit(tree, prealloc, &clear_bits, 0);\n\t\tprealloc = NULL;\n\t\tgoto out;\n\t}\n\n\tgoto search_again;\n\nout:\n\tspin_unlock(&tree->lock);\n\tif (prealloc)\n\t\tfree_extent_state(prealloc);\n\n\treturn err;\n\nsearch_again:\n\tif (start > end)\n\t\tgoto out;\n\tspin_unlock(&tree->lock);\n\tif (mask & __GFP_WAIT)\n\t\tcond_resched();\n\tfirst_iteration = false;\n\tgoto again;\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void set_state_bits(struct extent_io_tree *tree,\n\t\t\t   struct extent_state *state, unsigned *bits);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic void set_state_bits(struct extent_io_tree *tree,\n\t\t\t   struct extent_state *state, unsigned *bits);\n\nint convert_extent_bit(struct extent_io_tree *tree, u64 start, u64 end,\n\t\t       unsigned bits, unsigned clear_bits,\n\t\t       struct extent_state **cached_state, gfp_t mask)\n{\n\tstruct extent_state *state;\n\tstruct extent_state *prealloc = NULL;\n\tstruct rb_node *node;\n\tstruct rb_node **p;\n\tstruct rb_node *parent;\n\tint err = 0;\n\tu64 last_start;\n\tu64 last_end;\n\tbool first_iteration = true;\n\n\tbtrfs_debug_check_extent_io_range(tree, start, end);\n\nagain:\n\tif (!prealloc && (mask & __GFP_WAIT)) {\n\t\t/*\n\t\t * Best effort, don't worry if extent state allocation fails\n\t\t * here for the first iteration. We might have a cached state\n\t\t * that matches exactly the target range, in which case no\n\t\t * extent state allocations are needed. We'll only know this\n\t\t * after locking the tree.\n\t\t */\n\t\tprealloc = alloc_extent_state(mask);\n\t\tif (!prealloc && !first_iteration)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tspin_lock(&tree->lock);\n\tif (cached_state && *cached_state) {\n\t\tstate = *cached_state;\n\t\tif (state->start <= start && state->end > start &&\n\t\t    extent_state_in_tree(state)) {\n\t\t\tnode = &state->rb_node;\n\t\t\tgoto hit_next;\n\t\t}\n\t}\n\n\t/*\n\t * this search will find all the extents that end after\n\t * our range starts.\n\t */\n\tnode = tree_search_for_insert(tree, start, &p, &parent);\n\tif (!node) {\n\t\tprealloc = alloc_extent_state_atomic(prealloc);\n\t\tif (!prealloc) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\terr = insert_state(tree, prealloc, start, end,\n\t\t\t\t   &p, &parent, &bits);\n\t\tif (err)\n\t\t\textent_io_tree_panic(tree, err);\n\t\tcache_state(prealloc, cached_state);\n\t\tprealloc = NULL;\n\t\tgoto out;\n\t}\n\tstate = rb_entry(node, struct extent_state, rb_node);\nhit_next:\n\tlast_start = state->start;\n\tlast_end = state->end;\n\n\t/*\n\t * | ---- desired range ---- |\n\t * | state |\n\t *\n\t * Just lock what we found and keep going\n\t */\n\tif (state->start == start && state->end <= end) {\n\t\tset_state_bits(tree, state, &bits);\n\t\tcache_state(state, cached_state);\n\t\tstate = clear_state_bit(tree, state, &clear_bits, 0);\n\t\tif (last_end == (u64)-1)\n\t\t\tgoto out;\n\t\tstart = last_end + 1;\n\t\tif (start < end && state && state->start == start &&\n\t\t    !need_resched())\n\t\t\tgoto hit_next;\n\t\tgoto search_again;\n\t}\n\n\t/*\n\t *     | ---- desired range ---- |\n\t * | state |\n\t *   or\n\t * | ------------- state -------------- |\n\t *\n\t * We need to split the extent we found, and may flip bits on\n\t * second half.\n\t *\n\t * If the extent we found extends past our\n\t * range, we just split and search again.  It'll get split\n\t * again the next time though.\n\t *\n\t * If the extent we found is inside our range, we set the\n\t * desired bit on it.\n\t */\n\tif (state->start < start) {\n\t\tprealloc = alloc_extent_state_atomic(prealloc);\n\t\tif (!prealloc) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\terr = split_state(tree, state, prealloc, start);\n\t\tif (err)\n\t\t\textent_io_tree_panic(tree, err);\n\t\tprealloc = NULL;\n\t\tif (err)\n\t\t\tgoto out;\n\t\tif (state->end <= end) {\n\t\t\tset_state_bits(tree, state, &bits);\n\t\t\tcache_state(state, cached_state);\n\t\t\tstate = clear_state_bit(tree, state, &clear_bits, 0);\n\t\t\tif (last_end == (u64)-1)\n\t\t\t\tgoto out;\n\t\t\tstart = last_end + 1;\n\t\t\tif (start < end && state && state->start == start &&\n\t\t\t    !need_resched())\n\t\t\t\tgoto hit_next;\n\t\t}\n\t\tgoto search_again;\n\t}\n\t/*\n\t * | ---- desired range ---- |\n\t *     | state | or               | state |\n\t *\n\t * There's a hole, we need to insert something in it and\n\t * ignore the extent we found.\n\t */\n\tif (state->start > start) {\n\t\tu64 this_end;\n\t\tif (end < last_start)\n\t\t\tthis_end = end;\n\t\telse\n\t\t\tthis_end = last_start - 1;\n\n\t\tprealloc = alloc_extent_state_atomic(prealloc);\n\t\tif (!prealloc) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\n\t\t/*\n\t\t * Avoid to free 'prealloc' if it can be merged with\n\t\t * the later extent.\n\t\t */\n\t\terr = insert_state(tree, prealloc, start, this_end,\n\t\t\t\t   NULL, NULL, &bits);\n\t\tif (err)\n\t\t\textent_io_tree_panic(tree, err);\n\t\tcache_state(prealloc, cached_state);\n\t\tprealloc = NULL;\n\t\tstart = this_end + 1;\n\t\tgoto search_again;\n\t}\n\t/*\n\t * | ---- desired range ---- |\n\t *                        | state |\n\t * We need to split the extent, and set the bit\n\t * on the first half\n\t */\n\tif (state->start <= end && state->end > end) {\n\t\tprealloc = alloc_extent_state_atomic(prealloc);\n\t\tif (!prealloc) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\n\t\terr = split_state(tree, state, prealloc, end + 1);\n\t\tif (err)\n\t\t\textent_io_tree_panic(tree, err);\n\n\t\tset_state_bits(tree, prealloc, &bits);\n\t\tcache_state(prealloc, cached_state);\n\t\tclear_state_bit(tree, prealloc, &clear_bits, 0);\n\t\tprealloc = NULL;\n\t\tgoto out;\n\t}\n\n\tgoto search_again;\n\nout:\n\tspin_unlock(&tree->lock);\n\tif (prealloc)\n\t\tfree_extent_state(prealloc);\n\n\treturn err;\n\nsearch_again:\n\tif (start > end)\n\t\tgoto out;\n\tspin_unlock(&tree->lock);\n\tif (mask & __GFP_WAIT)\n\t\tcond_resched();\n\tfirst_iteration = false;\n\tgoto again;\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_first_extent_bit",
          "args": [
            "dirty_pages",
            "start",
            "&start",
            "&end",
            "mark",
            "&cached_state"
          ],
          "line": 867
        },
        "resolved": true,
        "details": {
          "function_name": "find_first_extent_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "1477-1516",
          "snippet": "int find_first_extent_bit(struct extent_io_tree *tree, u64 start,\n\t\t\t  u64 *start_ret, u64 *end_ret, unsigned bits,\n\t\t\t  struct extent_state **cached_state)\n{\n\tstruct extent_state *state;\n\tstruct rb_node *n;\n\tint ret = 1;\n\n\tspin_lock(&tree->lock);\n\tif (cached_state && *cached_state) {\n\t\tstate = *cached_state;\n\t\tif (state->end == start - 1 && extent_state_in_tree(state)) {\n\t\t\tn = rb_next(&state->rb_node);\n\t\t\twhile (n) {\n\t\t\t\tstate = rb_entry(n, struct extent_state,\n\t\t\t\t\t\t rb_node);\n\t\t\t\tif (state->state & bits)\n\t\t\t\t\tgoto got_it;\n\t\t\t\tn = rb_next(n);\n\t\t\t}\n\t\t\tfree_extent_state(*cached_state);\n\t\t\t*cached_state = NULL;\n\t\t\tgoto out;\n\t\t}\n\t\tfree_extent_state(*cached_state);\n\t\t*cached_state = NULL;\n\t}\n\n\tstate = find_first_extent_bit_state(tree, start, bits);\ngot_it:\n\tif (state) {\n\t\tcache_state_if_flags(state, cached_state, 0);\n\t\t*start_ret = state->start;\n\t\t*end_ret = state->end;\n\t\tret = 0;\n\t}\nout:\n\tspin_unlock(&tree->lock);\n\treturn ret;\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void set_state_bits(struct extent_io_tree *tree,\n\t\t\t   struct extent_state *state, unsigned *bits);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic void set_state_bits(struct extent_io_tree *tree,\n\t\t\t   struct extent_state *state, unsigned *bits);\n\nint find_first_extent_bit(struct extent_io_tree *tree, u64 start,\n\t\t\t  u64 *start_ret, u64 *end_ret, unsigned bits,\n\t\t\t  struct extent_state **cached_state)\n{\n\tstruct extent_state *state;\n\tstruct rb_node *n;\n\tint ret = 1;\n\n\tspin_lock(&tree->lock);\n\tif (cached_state && *cached_state) {\n\t\tstate = *cached_state;\n\t\tif (state->end == start - 1 && extent_state_in_tree(state)) {\n\t\t\tn = rb_next(&state->rb_node);\n\t\t\twhile (n) {\n\t\t\t\tstate = rb_entry(n, struct extent_state,\n\t\t\t\t\t\t rb_node);\n\t\t\t\tif (state->state & bits)\n\t\t\t\t\tgoto got_it;\n\t\t\t\tn = rb_next(n);\n\t\t\t}\n\t\t\tfree_extent_state(*cached_state);\n\t\t\t*cached_state = NULL;\n\t\t\tgoto out;\n\t\t}\n\t\tfree_extent_state(*cached_state);\n\t\t*cached_state = NULL;\n\t}\n\n\tstate = find_first_extent_bit_state(tree, start, bits);\ngot_it:\n\tif (state) {\n\t\tcache_state_if_flags(state, cached_state, 0);\n\t\t*start_ret = state->start;\n\t\t*end_ret = state->end;\n\t\tret = 0;\n\t}\nout:\n\tspin_unlock(&tree->lock);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint btrfs_write_marked_extents(struct btrfs_root *root,\n\t\t\t       struct extent_io_tree *dirty_pages, int mark)\n{\n\tint err = 0;\n\tint werr = 0;\n\tstruct address_space *mapping = root->fs_info->btree_inode->i_mapping;\n\tstruct extent_state *cached_state = NULL;\n\tu64 start = 0;\n\tu64 end;\n\n\twhile (!find_first_extent_bit(dirty_pages, start, &start, &end,\n\t\t\t\t      mark, &cached_state)) {\n\t\tbool wait_writeback = false;\n\n\t\terr = convert_extent_bit(dirty_pages, start, end,\n\t\t\t\t\t EXTENT_NEED_WAIT,\n\t\t\t\t\t mark, &cached_state, GFP_NOFS);\n\t\t/*\n\t\t * convert_extent_bit can return -ENOMEM, which is most of the\n\t\t * time a temporary error. So when it happens, ignore the error\n\t\t * and wait for writeback of this range to finish - because we\n\t\t * failed to set the bit EXTENT_NEED_WAIT for the range, a call\n\t\t * to btrfs_wait_marked_extents() would not know that writeback\n\t\t * for this range started and therefore wouldn't wait for it to\n\t\t * finish - we don't want to commit a superblock that points to\n\t\t * btree nodes/leafs for which writeback hasn't finished yet\n\t\t * (and without errors).\n\t\t * We cleanup any entries left in the io tree when committing\n\t\t * the transaction (through clear_btree_io_tree()).\n\t\t */\n\t\tif (err == -ENOMEM) {\n\t\t\terr = 0;\n\t\t\twait_writeback = true;\n\t\t}\n\t\tif (!err)\n\t\t\terr = filemap_fdatawrite_range(mapping, start, end);\n\t\tif (err)\n\t\t\twerr = err;\n\t\telse if (wait_writeback)\n\t\t\twerr = filemap_fdatawait_range(mapping, start, end);\n\t\tfree_extent_state(cached_state);\n\t\tcached_state = NULL;\n\t\tcond_resched();\n\t\tstart = end + 1;\n\t}\n\treturn werr;\n}"
  },
  {
    "function_name": "btrfs_end_transaction_throttle",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
    "lines": "846-850",
    "snippet": "int btrfs_end_transaction_throttle(struct btrfs_trans_handle *trans,\n\t\t\t\t   struct btrfs_root *root)\n{\n\treturn __btrfs_end_transaction(trans, root, 1);\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"dev-replace.h\"",
      "#include \"volumes.h\"",
      "#include \"inode-map.h\"",
      "#include \"tree-log.h\"",
      "#include \"locking.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/uuid.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/writeback.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__btrfs_end_transaction",
          "args": [
            "trans",
            "root",
            "1"
          ],
          "line": 849
        },
        "resolved": true,
        "details": {
          "function_name": "__btrfs_end_transaction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
          "lines": "732-838",
          "snippet": "static int __btrfs_end_transaction(struct btrfs_trans_handle *trans,\n\t\t\t  struct btrfs_root *root, int throttle)\n{\n\tstruct btrfs_transaction *cur_trans = trans->transaction;\n\tstruct btrfs_fs_info *info = root->fs_info;\n\tunsigned long cur = trans->delayed_ref_updates;\n\tint lock = (trans->type != TRANS_JOIN_NOLOCK);\n\tint err = 0;\n\tint must_run_delayed_refs = 0;\n\n\tif (trans->use_count > 1) {\n\t\ttrans->use_count--;\n\t\ttrans->block_rsv = trans->orig_rsv;\n\t\treturn 0;\n\t}\n\n\tbtrfs_trans_release_metadata(trans, root);\n\ttrans->block_rsv = NULL;\n\n\tif (!list_empty(&trans->new_bgs))\n\t\tbtrfs_create_pending_block_groups(trans, root);\n\n\tif (!list_empty(&trans->ordered)) {\n\t\tspin_lock(&info->trans_lock);\n\t\tlist_splice(&trans->ordered, &cur_trans->pending_ordered);\n\t\tspin_unlock(&info->trans_lock);\n\t}\n\n\ttrans->delayed_ref_updates = 0;\n\tif (!trans->sync) {\n\t\tmust_run_delayed_refs =\n\t\t\tbtrfs_should_throttle_delayed_refs(trans, root);\n\t\tcur = max_t(unsigned long, cur, 32);\n\n\t\t/*\n\t\t * don't make the caller wait if they are from a NOLOCK\n\t\t * or ATTACH transaction, it will deadlock with commit\n\t\t */\n\t\tif (must_run_delayed_refs == 1 &&\n\t\t    (trans->type & (__TRANS_JOIN_NOLOCK | __TRANS_ATTACH)))\n\t\t\tmust_run_delayed_refs = 2;\n\t}\n\n\tif (trans->qgroup_reserved) {\n\t\t/*\n\t\t * the same root has to be passed here between start_transaction\n\t\t * and end_transaction. Subvolume quota depends on this.\n\t\t */\n\t\tbtrfs_qgroup_free(trans->root, trans->qgroup_reserved);\n\t\ttrans->qgroup_reserved = 0;\n\t}\n\n\tbtrfs_trans_release_metadata(trans, root);\n\ttrans->block_rsv = NULL;\n\n\tif (!list_empty(&trans->new_bgs))\n\t\tbtrfs_create_pending_block_groups(trans, root);\n\n\tif (lock && !atomic_read(&root->fs_info->open_ioctl_trans) &&\n\t    should_end_transaction(trans, root) &&\n\t    ACCESS_ONCE(cur_trans->state) == TRANS_STATE_RUNNING) {\n\t\tspin_lock(&info->trans_lock);\n\t\tif (cur_trans->state == TRANS_STATE_RUNNING)\n\t\t\tcur_trans->state = TRANS_STATE_BLOCKED;\n\t\tspin_unlock(&info->trans_lock);\n\t}\n\n\tif (lock && ACCESS_ONCE(cur_trans->state) == TRANS_STATE_BLOCKED) {\n\t\tif (throttle)\n\t\t\treturn btrfs_commit_transaction(trans, root);\n\t\telse\n\t\t\twake_up_process(info->transaction_kthread);\n\t}\n\n\tif (trans->type & __TRANS_FREEZABLE)\n\t\tsb_end_intwrite(root->fs_info->sb);\n\n\tWARN_ON(cur_trans != info->running_transaction);\n\tWARN_ON(atomic_read(&cur_trans->num_writers) < 1);\n\tatomic_dec(&cur_trans->num_writers);\n\textwriter_counter_dec(cur_trans, trans->type);\n\n\tsmp_mb();\n\tif (waitqueue_active(&cur_trans->writer_wait))\n\t\twake_up(&cur_trans->writer_wait);\n\tbtrfs_put_transaction(cur_trans);\n\n\tif (current->journal_info == trans)\n\t\tcurrent->journal_info = NULL;\n\n\tif (throttle)\n\t\tbtrfs_run_delayed_iputs(root);\n\n\tif (trans->aborted ||\n\t    test_bit(BTRFS_FS_STATE_ERROR, &root->fs_info->fs_state)) {\n\t\twake_up_process(info->transaction_kthread);\n\t\terr = -EIO;\n\t}\n\tassert_qgroups_uptodate(trans);\n\n\tkmem_cache_free(btrfs_trans_handle_cachep, trans);\n\tif (must_run_delayed_refs) {\n\t\tbtrfs_async_run_delayed_refs(root, cur,\n\t\t\t\t\t     must_run_delayed_refs == 1);\n\t}\n\treturn err;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"dev-replace.h\"",
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic int __btrfs_end_transaction(struct btrfs_trans_handle *trans,\n\t\t\t  struct btrfs_root *root, int throttle)\n{\n\tstruct btrfs_transaction *cur_trans = trans->transaction;\n\tstruct btrfs_fs_info *info = root->fs_info;\n\tunsigned long cur = trans->delayed_ref_updates;\n\tint lock = (trans->type != TRANS_JOIN_NOLOCK);\n\tint err = 0;\n\tint must_run_delayed_refs = 0;\n\n\tif (trans->use_count > 1) {\n\t\ttrans->use_count--;\n\t\ttrans->block_rsv = trans->orig_rsv;\n\t\treturn 0;\n\t}\n\n\tbtrfs_trans_release_metadata(trans, root);\n\ttrans->block_rsv = NULL;\n\n\tif (!list_empty(&trans->new_bgs))\n\t\tbtrfs_create_pending_block_groups(trans, root);\n\n\tif (!list_empty(&trans->ordered)) {\n\t\tspin_lock(&info->trans_lock);\n\t\tlist_splice(&trans->ordered, &cur_trans->pending_ordered);\n\t\tspin_unlock(&info->trans_lock);\n\t}\n\n\ttrans->delayed_ref_updates = 0;\n\tif (!trans->sync) {\n\t\tmust_run_delayed_refs =\n\t\t\tbtrfs_should_throttle_delayed_refs(trans, root);\n\t\tcur = max_t(unsigned long, cur, 32);\n\n\t\t/*\n\t\t * don't make the caller wait if they are from a NOLOCK\n\t\t * or ATTACH transaction, it will deadlock with commit\n\t\t */\n\t\tif (must_run_delayed_refs == 1 &&\n\t\t    (trans->type & (__TRANS_JOIN_NOLOCK | __TRANS_ATTACH)))\n\t\t\tmust_run_delayed_refs = 2;\n\t}\n\n\tif (trans->qgroup_reserved) {\n\t\t/*\n\t\t * the same root has to be passed here between start_transaction\n\t\t * and end_transaction. Subvolume quota depends on this.\n\t\t */\n\t\tbtrfs_qgroup_free(trans->root, trans->qgroup_reserved);\n\t\ttrans->qgroup_reserved = 0;\n\t}\n\n\tbtrfs_trans_release_metadata(trans, root);\n\ttrans->block_rsv = NULL;\n\n\tif (!list_empty(&trans->new_bgs))\n\t\tbtrfs_create_pending_block_groups(trans, root);\n\n\tif (lock && !atomic_read(&root->fs_info->open_ioctl_trans) &&\n\t    should_end_transaction(trans, root) &&\n\t    ACCESS_ONCE(cur_trans->state) == TRANS_STATE_RUNNING) {\n\t\tspin_lock(&info->trans_lock);\n\t\tif (cur_trans->state == TRANS_STATE_RUNNING)\n\t\t\tcur_trans->state = TRANS_STATE_BLOCKED;\n\t\tspin_unlock(&info->trans_lock);\n\t}\n\n\tif (lock && ACCESS_ONCE(cur_trans->state) == TRANS_STATE_BLOCKED) {\n\t\tif (throttle)\n\t\t\treturn btrfs_commit_transaction(trans, root);\n\t\telse\n\t\t\twake_up_process(info->transaction_kthread);\n\t}\n\n\tif (trans->type & __TRANS_FREEZABLE)\n\t\tsb_end_intwrite(root->fs_info->sb);\n\n\tWARN_ON(cur_trans != info->running_transaction);\n\tWARN_ON(atomic_read(&cur_trans->num_writers) < 1);\n\tatomic_dec(&cur_trans->num_writers);\n\textwriter_counter_dec(cur_trans, trans->type);\n\n\tsmp_mb();\n\tif (waitqueue_active(&cur_trans->writer_wait))\n\t\twake_up(&cur_trans->writer_wait);\n\tbtrfs_put_transaction(cur_trans);\n\n\tif (current->journal_info == trans)\n\t\tcurrent->journal_info = NULL;\n\n\tif (throttle)\n\t\tbtrfs_run_delayed_iputs(root);\n\n\tif (trans->aborted ||\n\t    test_bit(BTRFS_FS_STATE_ERROR, &root->fs_info->fs_state)) {\n\t\twake_up_process(info->transaction_kthread);\n\t\terr = -EIO;\n\t}\n\tassert_qgroups_uptodate(trans);\n\n\tkmem_cache_free(btrfs_trans_handle_cachep, trans);\n\tif (must_run_delayed_refs) {\n\t\tbtrfs_async_run_delayed_refs(root, cur,\n\t\t\t\t\t     must_run_delayed_refs == 1);\n\t}\n\treturn err;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint btrfs_end_transaction_throttle(struct btrfs_trans_handle *trans,\n\t\t\t\t   struct btrfs_root *root)\n{\n\treturn __btrfs_end_transaction(trans, root, 1);\n}"
  },
  {
    "function_name": "btrfs_end_transaction",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
    "lines": "840-844",
    "snippet": "int btrfs_end_transaction(struct btrfs_trans_handle *trans,\n\t\t\t  struct btrfs_root *root)\n{\n\treturn __btrfs_end_transaction(trans, root, 0);\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"dev-replace.h\"",
      "#include \"volumes.h\"",
      "#include \"inode-map.h\"",
      "#include \"tree-log.h\"",
      "#include \"locking.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/uuid.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/writeback.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__btrfs_end_transaction",
          "args": [
            "trans",
            "root",
            "0"
          ],
          "line": 843
        },
        "resolved": true,
        "details": {
          "function_name": "__btrfs_end_transaction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
          "lines": "732-838",
          "snippet": "static int __btrfs_end_transaction(struct btrfs_trans_handle *trans,\n\t\t\t  struct btrfs_root *root, int throttle)\n{\n\tstruct btrfs_transaction *cur_trans = trans->transaction;\n\tstruct btrfs_fs_info *info = root->fs_info;\n\tunsigned long cur = trans->delayed_ref_updates;\n\tint lock = (trans->type != TRANS_JOIN_NOLOCK);\n\tint err = 0;\n\tint must_run_delayed_refs = 0;\n\n\tif (trans->use_count > 1) {\n\t\ttrans->use_count--;\n\t\ttrans->block_rsv = trans->orig_rsv;\n\t\treturn 0;\n\t}\n\n\tbtrfs_trans_release_metadata(trans, root);\n\ttrans->block_rsv = NULL;\n\n\tif (!list_empty(&trans->new_bgs))\n\t\tbtrfs_create_pending_block_groups(trans, root);\n\n\tif (!list_empty(&trans->ordered)) {\n\t\tspin_lock(&info->trans_lock);\n\t\tlist_splice(&trans->ordered, &cur_trans->pending_ordered);\n\t\tspin_unlock(&info->trans_lock);\n\t}\n\n\ttrans->delayed_ref_updates = 0;\n\tif (!trans->sync) {\n\t\tmust_run_delayed_refs =\n\t\t\tbtrfs_should_throttle_delayed_refs(trans, root);\n\t\tcur = max_t(unsigned long, cur, 32);\n\n\t\t/*\n\t\t * don't make the caller wait if they are from a NOLOCK\n\t\t * or ATTACH transaction, it will deadlock with commit\n\t\t */\n\t\tif (must_run_delayed_refs == 1 &&\n\t\t    (trans->type & (__TRANS_JOIN_NOLOCK | __TRANS_ATTACH)))\n\t\t\tmust_run_delayed_refs = 2;\n\t}\n\n\tif (trans->qgroup_reserved) {\n\t\t/*\n\t\t * the same root has to be passed here between start_transaction\n\t\t * and end_transaction. Subvolume quota depends on this.\n\t\t */\n\t\tbtrfs_qgroup_free(trans->root, trans->qgroup_reserved);\n\t\ttrans->qgroup_reserved = 0;\n\t}\n\n\tbtrfs_trans_release_metadata(trans, root);\n\ttrans->block_rsv = NULL;\n\n\tif (!list_empty(&trans->new_bgs))\n\t\tbtrfs_create_pending_block_groups(trans, root);\n\n\tif (lock && !atomic_read(&root->fs_info->open_ioctl_trans) &&\n\t    should_end_transaction(trans, root) &&\n\t    ACCESS_ONCE(cur_trans->state) == TRANS_STATE_RUNNING) {\n\t\tspin_lock(&info->trans_lock);\n\t\tif (cur_trans->state == TRANS_STATE_RUNNING)\n\t\t\tcur_trans->state = TRANS_STATE_BLOCKED;\n\t\tspin_unlock(&info->trans_lock);\n\t}\n\n\tif (lock && ACCESS_ONCE(cur_trans->state) == TRANS_STATE_BLOCKED) {\n\t\tif (throttle)\n\t\t\treturn btrfs_commit_transaction(trans, root);\n\t\telse\n\t\t\twake_up_process(info->transaction_kthread);\n\t}\n\n\tif (trans->type & __TRANS_FREEZABLE)\n\t\tsb_end_intwrite(root->fs_info->sb);\n\n\tWARN_ON(cur_trans != info->running_transaction);\n\tWARN_ON(atomic_read(&cur_trans->num_writers) < 1);\n\tatomic_dec(&cur_trans->num_writers);\n\textwriter_counter_dec(cur_trans, trans->type);\n\n\tsmp_mb();\n\tif (waitqueue_active(&cur_trans->writer_wait))\n\t\twake_up(&cur_trans->writer_wait);\n\tbtrfs_put_transaction(cur_trans);\n\n\tif (current->journal_info == trans)\n\t\tcurrent->journal_info = NULL;\n\n\tif (throttle)\n\t\tbtrfs_run_delayed_iputs(root);\n\n\tif (trans->aborted ||\n\t    test_bit(BTRFS_FS_STATE_ERROR, &root->fs_info->fs_state)) {\n\t\twake_up_process(info->transaction_kthread);\n\t\terr = -EIO;\n\t}\n\tassert_qgroups_uptodate(trans);\n\n\tkmem_cache_free(btrfs_trans_handle_cachep, trans);\n\tif (must_run_delayed_refs) {\n\t\tbtrfs_async_run_delayed_refs(root, cur,\n\t\t\t\t\t     must_run_delayed_refs == 1);\n\t}\n\treturn err;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"dev-replace.h\"",
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic int __btrfs_end_transaction(struct btrfs_trans_handle *trans,\n\t\t\t  struct btrfs_root *root, int throttle)\n{\n\tstruct btrfs_transaction *cur_trans = trans->transaction;\n\tstruct btrfs_fs_info *info = root->fs_info;\n\tunsigned long cur = trans->delayed_ref_updates;\n\tint lock = (trans->type != TRANS_JOIN_NOLOCK);\n\tint err = 0;\n\tint must_run_delayed_refs = 0;\n\n\tif (trans->use_count > 1) {\n\t\ttrans->use_count--;\n\t\ttrans->block_rsv = trans->orig_rsv;\n\t\treturn 0;\n\t}\n\n\tbtrfs_trans_release_metadata(trans, root);\n\ttrans->block_rsv = NULL;\n\n\tif (!list_empty(&trans->new_bgs))\n\t\tbtrfs_create_pending_block_groups(trans, root);\n\n\tif (!list_empty(&trans->ordered)) {\n\t\tspin_lock(&info->trans_lock);\n\t\tlist_splice(&trans->ordered, &cur_trans->pending_ordered);\n\t\tspin_unlock(&info->trans_lock);\n\t}\n\n\ttrans->delayed_ref_updates = 0;\n\tif (!trans->sync) {\n\t\tmust_run_delayed_refs =\n\t\t\tbtrfs_should_throttle_delayed_refs(trans, root);\n\t\tcur = max_t(unsigned long, cur, 32);\n\n\t\t/*\n\t\t * don't make the caller wait if they are from a NOLOCK\n\t\t * or ATTACH transaction, it will deadlock with commit\n\t\t */\n\t\tif (must_run_delayed_refs == 1 &&\n\t\t    (trans->type & (__TRANS_JOIN_NOLOCK | __TRANS_ATTACH)))\n\t\t\tmust_run_delayed_refs = 2;\n\t}\n\n\tif (trans->qgroup_reserved) {\n\t\t/*\n\t\t * the same root has to be passed here between start_transaction\n\t\t * and end_transaction. Subvolume quota depends on this.\n\t\t */\n\t\tbtrfs_qgroup_free(trans->root, trans->qgroup_reserved);\n\t\ttrans->qgroup_reserved = 0;\n\t}\n\n\tbtrfs_trans_release_metadata(trans, root);\n\ttrans->block_rsv = NULL;\n\n\tif (!list_empty(&trans->new_bgs))\n\t\tbtrfs_create_pending_block_groups(trans, root);\n\n\tif (lock && !atomic_read(&root->fs_info->open_ioctl_trans) &&\n\t    should_end_transaction(trans, root) &&\n\t    ACCESS_ONCE(cur_trans->state) == TRANS_STATE_RUNNING) {\n\t\tspin_lock(&info->trans_lock);\n\t\tif (cur_trans->state == TRANS_STATE_RUNNING)\n\t\t\tcur_trans->state = TRANS_STATE_BLOCKED;\n\t\tspin_unlock(&info->trans_lock);\n\t}\n\n\tif (lock && ACCESS_ONCE(cur_trans->state) == TRANS_STATE_BLOCKED) {\n\t\tif (throttle)\n\t\t\treturn btrfs_commit_transaction(trans, root);\n\t\telse\n\t\t\twake_up_process(info->transaction_kthread);\n\t}\n\n\tif (trans->type & __TRANS_FREEZABLE)\n\t\tsb_end_intwrite(root->fs_info->sb);\n\n\tWARN_ON(cur_trans != info->running_transaction);\n\tWARN_ON(atomic_read(&cur_trans->num_writers) < 1);\n\tatomic_dec(&cur_trans->num_writers);\n\textwriter_counter_dec(cur_trans, trans->type);\n\n\tsmp_mb();\n\tif (waitqueue_active(&cur_trans->writer_wait))\n\t\twake_up(&cur_trans->writer_wait);\n\tbtrfs_put_transaction(cur_trans);\n\n\tif (current->journal_info == trans)\n\t\tcurrent->journal_info = NULL;\n\n\tif (throttle)\n\t\tbtrfs_run_delayed_iputs(root);\n\n\tif (trans->aborted ||\n\t    test_bit(BTRFS_FS_STATE_ERROR, &root->fs_info->fs_state)) {\n\t\twake_up_process(info->transaction_kthread);\n\t\terr = -EIO;\n\t}\n\tassert_qgroups_uptodate(trans);\n\n\tkmem_cache_free(btrfs_trans_handle_cachep, trans);\n\tif (must_run_delayed_refs) {\n\t\tbtrfs_async_run_delayed_refs(root, cur,\n\t\t\t\t\t     must_run_delayed_refs == 1);\n\t}\n\treturn err;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint btrfs_end_transaction(struct btrfs_trans_handle *trans,\n\t\t\t  struct btrfs_root *root)\n{\n\treturn __btrfs_end_transaction(trans, root, 0);\n}"
  },
  {
    "function_name": "__btrfs_end_transaction",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
    "lines": "732-838",
    "snippet": "static int __btrfs_end_transaction(struct btrfs_trans_handle *trans,\n\t\t\t  struct btrfs_root *root, int throttle)\n{\n\tstruct btrfs_transaction *cur_trans = trans->transaction;\n\tstruct btrfs_fs_info *info = root->fs_info;\n\tunsigned long cur = trans->delayed_ref_updates;\n\tint lock = (trans->type != TRANS_JOIN_NOLOCK);\n\tint err = 0;\n\tint must_run_delayed_refs = 0;\n\n\tif (trans->use_count > 1) {\n\t\ttrans->use_count--;\n\t\ttrans->block_rsv = trans->orig_rsv;\n\t\treturn 0;\n\t}\n\n\tbtrfs_trans_release_metadata(trans, root);\n\ttrans->block_rsv = NULL;\n\n\tif (!list_empty(&trans->new_bgs))\n\t\tbtrfs_create_pending_block_groups(trans, root);\n\n\tif (!list_empty(&trans->ordered)) {\n\t\tspin_lock(&info->trans_lock);\n\t\tlist_splice(&trans->ordered, &cur_trans->pending_ordered);\n\t\tspin_unlock(&info->trans_lock);\n\t}\n\n\ttrans->delayed_ref_updates = 0;\n\tif (!trans->sync) {\n\t\tmust_run_delayed_refs =\n\t\t\tbtrfs_should_throttle_delayed_refs(trans, root);\n\t\tcur = max_t(unsigned long, cur, 32);\n\n\t\t/*\n\t\t * don't make the caller wait if they are from a NOLOCK\n\t\t * or ATTACH transaction, it will deadlock with commit\n\t\t */\n\t\tif (must_run_delayed_refs == 1 &&\n\t\t    (trans->type & (__TRANS_JOIN_NOLOCK | __TRANS_ATTACH)))\n\t\t\tmust_run_delayed_refs = 2;\n\t}\n\n\tif (trans->qgroup_reserved) {\n\t\t/*\n\t\t * the same root has to be passed here between start_transaction\n\t\t * and end_transaction. Subvolume quota depends on this.\n\t\t */\n\t\tbtrfs_qgroup_free(trans->root, trans->qgroup_reserved);\n\t\ttrans->qgroup_reserved = 0;\n\t}\n\n\tbtrfs_trans_release_metadata(trans, root);\n\ttrans->block_rsv = NULL;\n\n\tif (!list_empty(&trans->new_bgs))\n\t\tbtrfs_create_pending_block_groups(trans, root);\n\n\tif (lock && !atomic_read(&root->fs_info->open_ioctl_trans) &&\n\t    should_end_transaction(trans, root) &&\n\t    ACCESS_ONCE(cur_trans->state) == TRANS_STATE_RUNNING) {\n\t\tspin_lock(&info->trans_lock);\n\t\tif (cur_trans->state == TRANS_STATE_RUNNING)\n\t\t\tcur_trans->state = TRANS_STATE_BLOCKED;\n\t\tspin_unlock(&info->trans_lock);\n\t}\n\n\tif (lock && ACCESS_ONCE(cur_trans->state) == TRANS_STATE_BLOCKED) {\n\t\tif (throttle)\n\t\t\treturn btrfs_commit_transaction(trans, root);\n\t\telse\n\t\t\twake_up_process(info->transaction_kthread);\n\t}\n\n\tif (trans->type & __TRANS_FREEZABLE)\n\t\tsb_end_intwrite(root->fs_info->sb);\n\n\tWARN_ON(cur_trans != info->running_transaction);\n\tWARN_ON(atomic_read(&cur_trans->num_writers) < 1);\n\tatomic_dec(&cur_trans->num_writers);\n\textwriter_counter_dec(cur_trans, trans->type);\n\n\tsmp_mb();\n\tif (waitqueue_active(&cur_trans->writer_wait))\n\t\twake_up(&cur_trans->writer_wait);\n\tbtrfs_put_transaction(cur_trans);\n\n\tif (current->journal_info == trans)\n\t\tcurrent->journal_info = NULL;\n\n\tif (throttle)\n\t\tbtrfs_run_delayed_iputs(root);\n\n\tif (trans->aborted ||\n\t    test_bit(BTRFS_FS_STATE_ERROR, &root->fs_info->fs_state)) {\n\t\twake_up_process(info->transaction_kthread);\n\t\terr = -EIO;\n\t}\n\tassert_qgroups_uptodate(trans);\n\n\tkmem_cache_free(btrfs_trans_handle_cachep, trans);\n\tif (must_run_delayed_refs) {\n\t\tbtrfs_async_run_delayed_refs(root, cur,\n\t\t\t\t\t     must_run_delayed_refs == 1);\n\t}\n\treturn err;\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"dev-replace.h\"",
      "#include \"volumes.h\"",
      "#include \"inode-map.h\"",
      "#include \"tree-log.h\"",
      "#include \"locking.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/uuid.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/writeback.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_async_run_delayed_refs",
          "args": [
            "root",
            "cur",
            "must_run_delayed_refs == 1"
          ],
          "line": 834
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_async_run_delayed_refs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent-tree.c",
          "lines": "2721-2752",
          "snippet": "int btrfs_async_run_delayed_refs(struct btrfs_root *root,\n\t\t\t\t unsigned long count, int wait)\n{\n\tstruct async_delayed_refs *async;\n\tint ret;\n\n\tasync = kmalloc(sizeof(*async), GFP_NOFS);\n\tif (!async)\n\t\treturn -ENOMEM;\n\n\tasync->root = root->fs_info->tree_root;\n\tasync->count = count;\n\tasync->error = 0;\n\tif (wait)\n\t\tasync->sync = 1;\n\telse\n\t\tasync->sync = 0;\n\tinit_completion(&async->wait);\n\n\tbtrfs_init_work(&async->work, btrfs_extent_refs_helper,\n\t\t\tdelayed_ref_async_start, NULL, NULL);\n\n\tbtrfs_queue_work(root->fs_info->extent_workers, &async->work);\n\n\tif (wait) {\n\t\twait_for_completion(&async->wait);\n\t\tret = async->error;\n\t\tkfree(async);\n\t\treturn ret;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"math.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include \"hash.h\"",
            "#include <linux/percpu_counter.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"math.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include \"hash.h\"\n#include <linux/percpu_counter.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n#include <linux/rcupdate.h>\n#include <linux/sort.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nint btrfs_async_run_delayed_refs(struct btrfs_root *root,\n\t\t\t\t unsigned long count, int wait)\n{\n\tstruct async_delayed_refs *async;\n\tint ret;\n\n\tasync = kmalloc(sizeof(*async), GFP_NOFS);\n\tif (!async)\n\t\treturn -ENOMEM;\n\n\tasync->root = root->fs_info->tree_root;\n\tasync->count = count;\n\tasync->error = 0;\n\tif (wait)\n\t\tasync->sync = 1;\n\telse\n\t\tasync->sync = 0;\n\tinit_completion(&async->wait);\n\n\tbtrfs_init_work(&async->work, btrfs_extent_refs_helper,\n\t\t\tdelayed_ref_async_start, NULL, NULL);\n\n\tbtrfs_queue_work(root->fs_info->extent_workers, &async->work);\n\n\tif (wait) {\n\t\twait_for_completion(&async->wait);\n\t\tret = async->error;\n\t\tkfree(async);\n\t\treturn ret;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "btrfs_trans_handle_cachep",
            "trans"
          ],
          "line": 832
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert_qgroups_uptodate",
          "args": [
            "trans"
          ],
          "line": 830
        },
        "resolved": true,
        "details": {
          "function_name": "assert_qgroups_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/qgroup.c",
          "lines": "2501-2512",
          "snippet": "void assert_qgroups_uptodate(struct btrfs_trans_handle *trans)\n{\n\tif (list_empty(&trans->qgroup_ref_list) && !trans->delayed_ref_elem.seq)\n\t\treturn;\n\tbtrfs_err(trans->root->fs_info,\n\t\t\"qgroups not uptodate in trans handle %p:  list is%s empty, \"\n\t\t\"seq is %#x.%x\",\n\t\ttrans, list_empty(&trans->qgroup_ref_list) ? \"\" : \" not\",\n\t\t(u32)(trans->delayed_ref_elem.seq >> 32),\n\t\t(u32)trans->delayed_ref_elem.seq);\n\tBUG();\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"ulist.h\"",
            "#include \"locking.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"ctree.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"ulist.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);\n\nvoid assert_qgroups_uptodate(struct btrfs_trans_handle *trans)\n{\n\tif (list_empty(&trans->qgroup_ref_list) && !trans->delayed_ref_elem.seq)\n\t\treturn;\n\tbtrfs_err(trans->root->fs_info,\n\t\t\"qgroups not uptodate in trans handle %p:  list is%s empty, \"\n\t\t\"seq is %#x.%x\",\n\t\ttrans, list_empty(&trans->qgroup_ref_list) ? \"\" : \" not\",\n\t\t(u32)(trans->delayed_ref_elem.seq >> 32),\n\t\t(u32)trans->delayed_ref_elem.seq);\n\tBUG();\n}"
        }
      },
      {
        "call_info": {
          "callee": "wake_up_process",
          "args": [
            "info->transaction_kthread"
          ],
          "line": 827
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "BTRFS_FS_STATE_ERROR",
            "&root->fs_info->fs_state"
          ],
          "line": 826
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_run_delayed_iputs",
          "args": [
            "root"
          ],
          "line": 823
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_run_delayed_iputs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/inode.c",
          "lines": "3100-3123",
          "snippet": "void btrfs_run_delayed_iputs(struct btrfs_root *root)\n{\n\tLIST_HEAD(list);\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tstruct delayed_iput *delayed;\n\tint empty;\n\n\tspin_lock(&fs_info->delayed_iput_lock);\n\tempty = list_empty(&fs_info->delayed_iputs);\n\tspin_unlock(&fs_info->delayed_iput_lock);\n\tif (empty)\n\t\treturn;\n\n\tspin_lock(&fs_info->delayed_iput_lock);\n\tlist_splice_init(&fs_info->delayed_iputs, &list);\n\tspin_unlock(&fs_info->delayed_iput_lock);\n\n\twhile (!list_empty(&list)) {\n\t\tdelayed = list_entry(list.next, struct delayed_iput, list);\n\t\tlist_del(&delayed->list);\n\t\tiput(delayed->inode);\n\t\tkfree(delayed);\n\t}\n}",
          "includes": [
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"compression.h\"",
            "#include \"volumes.h\"",
            "#include \"tree-log.h\"",
            "#include \"xattr.h\"",
            "#include \"ordered-data.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/falloc.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/aio.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btrfs_truncate(struct inode *inode);",
            "static int btrfs_dirty_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"props.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"compression.h\"\n#include \"volumes.h\"\n#include \"tree-log.h\"\n#include \"xattr.h\"\n#include \"ordered-data.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/blkdev.h>\n#include <linux/btrfs.h>\n#include <linux/mount.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/bit_spinlock.h>\n#include <linux/aio.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic int btrfs_truncate(struct inode *inode);\nstatic int btrfs_dirty_inode(struct inode *inode);\n\nvoid btrfs_run_delayed_iputs(struct btrfs_root *root)\n{\n\tLIST_HEAD(list);\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tstruct delayed_iput *delayed;\n\tint empty;\n\n\tspin_lock(&fs_info->delayed_iput_lock);\n\tempty = list_empty(&fs_info->delayed_iputs);\n\tspin_unlock(&fs_info->delayed_iput_lock);\n\tif (empty)\n\t\treturn;\n\n\tspin_lock(&fs_info->delayed_iput_lock);\n\tlist_splice_init(&fs_info->delayed_iputs, &list);\n\tspin_unlock(&fs_info->delayed_iput_lock);\n\n\twhile (!list_empty(&list)) {\n\t\tdelayed = list_entry(list.next, struct delayed_iput, list);\n\t\tlist_del(&delayed->list);\n\t\tiput(delayed->inode);\n\t\tkfree(delayed);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_put_transaction",
          "args": [
            "cur_trans"
          ],
          "line": 817
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_put_transaction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
          "lines": "61-77",
          "snippet": "void btrfs_put_transaction(struct btrfs_transaction *transaction)\n{\n\tWARN_ON(atomic_read(&transaction->use_count) == 0);\n\tif (atomic_dec_and_test(&transaction->use_count)) {\n\t\tBUG_ON(!list_empty(&transaction->list));\n\t\tWARN_ON(!RB_EMPTY_ROOT(&transaction->delayed_refs.href_root));\n\t\twhile (!list_empty(&transaction->pending_chunks)) {\n\t\t\tstruct extent_map *em;\n\n\t\t\tem = list_first_entry(&transaction->pending_chunks,\n\t\t\t\t\t      struct extent_map, list);\n\t\t\tlist_del_init(&em->list);\n\t\t\tfree_extent_map(em);\n\t\t}\n\t\tkmem_cache_free(btrfs_transaction_cachep, transaction);\n\t}\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"dev-replace.h\"",
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid btrfs_put_transaction(struct btrfs_transaction *transaction)\n{\n\tWARN_ON(atomic_read(&transaction->use_count) == 0);\n\tif (atomic_dec_and_test(&transaction->use_count)) {\n\t\tBUG_ON(!list_empty(&transaction->list));\n\t\tWARN_ON(!RB_EMPTY_ROOT(&transaction->delayed_refs.href_root));\n\t\twhile (!list_empty(&transaction->pending_chunks)) {\n\t\t\tstruct extent_map *em;\n\n\t\t\tem = list_first_entry(&transaction->pending_chunks,\n\t\t\t\t\t      struct extent_map, list);\n\t\t\tlist_del_init(&em->list);\n\t\t\tfree_extent_map(em);\n\t\t}\n\t\tkmem_cache_free(btrfs_transaction_cachep, transaction);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "wake_up",
          "args": [
            "&cur_trans->writer_wait"
          ],
          "line": 816
        },
        "resolved": true,
        "details": {
          "function_name": "locks_wake_up_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "656-681",
          "snippet": "static void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(blocked_lock_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic DEFINE_SPINLOCK(blocked_lock_lock);\n\nstatic void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "waitqueue_active",
          "args": [
            "&cur_trans->writer_wait"
          ],
          "line": 815
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_mb",
          "args": [],
          "line": 814
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "extwriter_counter_dec",
          "args": [
            "cur_trans",
            "trans->type"
          ],
          "line": 812
        },
        "resolved": true,
        "details": {
          "function_name": "extwriter_counter_dec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
          "lines": "130-135",
          "snippet": "static inline void extwriter_counter_dec(struct btrfs_transaction *trans,\n\t\t\t\t\t unsigned int type)\n{\n\tif (type & TRANS_EXTWRITERS)\n\t\tatomic_dec(&trans->num_extwriters);\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"dev-replace.h\"",
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic inline void extwriter_counter_dec(struct btrfs_transaction *trans,\n\t\t\t\t\t unsigned int type)\n{\n\tif (type & TRANS_EXTWRITERS)\n\t\tatomic_dec(&trans->num_extwriters);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_dec",
          "args": [
            "&cur_trans->num_writers"
          ],
          "line": 811
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "atomic_read(&cur_trans->num_writers) < 1"
          ],
          "line": 810
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&cur_trans->num_writers"
          ],
          "line": 810
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "cur_trans != info->running_transaction"
          ],
          "line": 809
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_end_intwrite",
          "args": [
            "root->fs_info->sb"
          ],
          "line": 807
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wake_up_process",
          "args": [
            "info->transaction_kthread"
          ],
          "line": 803
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_commit_transaction",
          "args": [
            "trans",
            "root"
          ],
          "line": 801
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_commit_transaction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
          "lines": "1764-2099",
          "snippet": "int btrfs_commit_transaction(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root)\n{\n\tstruct btrfs_transaction *cur_trans = trans->transaction;\n\tstruct btrfs_transaction *prev_trans = NULL;\n\tstruct btrfs_inode *btree_ino = BTRFS_I(root->fs_info->btree_inode);\n\tint ret;\n\n\t/* Stop the commit early if ->aborted is set */\n\tif (unlikely(ACCESS_ONCE(cur_trans->aborted))) {\n\t\tret = cur_trans->aborted;\n\t\tbtrfs_end_transaction(trans, root);\n\t\treturn ret;\n\t}\n\n\t/* make a pass through all the delayed refs we have so far\n\t * any runnings procs may add more while we are here\n\t */\n\tret = btrfs_run_delayed_refs(trans, root, 0);\n\tif (ret) {\n\t\tbtrfs_end_transaction(trans, root);\n\t\treturn ret;\n\t}\n\n\tbtrfs_trans_release_metadata(trans, root);\n\ttrans->block_rsv = NULL;\n\tif (trans->qgroup_reserved) {\n\t\tbtrfs_qgroup_free(root, trans->qgroup_reserved);\n\t\ttrans->qgroup_reserved = 0;\n\t}\n\n\tcur_trans = trans->transaction;\n\n\t/*\n\t * set the flushing flag so procs in this transaction have to\n\t * start sending their work down.\n\t */\n\tcur_trans->delayed_refs.flushing = 1;\n\tsmp_wmb();\n\n\tif (!list_empty(&trans->new_bgs))\n\t\tbtrfs_create_pending_block_groups(trans, root);\n\n\tret = btrfs_run_delayed_refs(trans, root, 0);\n\tif (ret) {\n\t\tbtrfs_end_transaction(trans, root);\n\t\treturn ret;\n\t}\n\n\tspin_lock(&root->fs_info->trans_lock);\n\tlist_splice(&trans->ordered, &cur_trans->pending_ordered);\n\tif (cur_trans->state >= TRANS_STATE_COMMIT_START) {\n\t\tspin_unlock(&root->fs_info->trans_lock);\n\t\tatomic_inc(&cur_trans->use_count);\n\t\tret = btrfs_end_transaction(trans, root);\n\n\t\twait_for_commit(root, cur_trans);\n\n\t\tif (unlikely(cur_trans->aborted))\n\t\t\tret = cur_trans->aborted;\n\n\t\tbtrfs_put_transaction(cur_trans);\n\n\t\treturn ret;\n\t}\n\n\tcur_trans->state = TRANS_STATE_COMMIT_START;\n\twake_up(&root->fs_info->transaction_blocked_wait);\n\n\tif (cur_trans->list.prev != &root->fs_info->trans_list) {\n\t\tprev_trans = list_entry(cur_trans->list.prev,\n\t\t\t\t\tstruct btrfs_transaction, list);\n\t\tif (prev_trans->state != TRANS_STATE_COMPLETED) {\n\t\t\tatomic_inc(&prev_trans->use_count);\n\t\t\tspin_unlock(&root->fs_info->trans_lock);\n\n\t\t\twait_for_commit(root, prev_trans);\n\n\t\t\tbtrfs_put_transaction(prev_trans);\n\t\t} else {\n\t\t\tspin_unlock(&root->fs_info->trans_lock);\n\t\t}\n\t} else {\n\t\tspin_unlock(&root->fs_info->trans_lock);\n\t}\n\n\textwriter_counter_dec(cur_trans, trans->type);\n\n\tret = btrfs_start_delalloc_flush(root->fs_info);\n\tif (ret)\n\t\tgoto cleanup_transaction;\n\n\tret = btrfs_run_delayed_items(trans, root);\n\tif (ret)\n\t\tgoto cleanup_transaction;\n\n\twait_event(cur_trans->writer_wait,\n\t\t   extwriter_counter_read(cur_trans) == 0);\n\n\t/* some pending stuffs might be added after the previous flush. */\n\tret = btrfs_run_delayed_items(trans, root);\n\tif (ret)\n\t\tgoto cleanup_transaction;\n\n\tbtrfs_wait_delalloc_flush(root->fs_info);\n\n\tbtrfs_wait_pending_ordered(cur_trans, root->fs_info);\n\n\tbtrfs_scrub_pause(root);\n\t/*\n\t * Ok now we need to make sure to block out any other joins while we\n\t * commit the transaction.  We could have started a join before setting\n\t * COMMIT_DOING so make sure to wait for num_writers to == 1 again.\n\t */\n\tspin_lock(&root->fs_info->trans_lock);\n\tcur_trans->state = TRANS_STATE_COMMIT_DOING;\n\tspin_unlock(&root->fs_info->trans_lock);\n\twait_event(cur_trans->writer_wait,\n\t\t   atomic_read(&cur_trans->num_writers) == 1);\n\n\t/* ->aborted might be set after the previous check, so check it */\n\tif (unlikely(ACCESS_ONCE(cur_trans->aborted))) {\n\t\tret = cur_trans->aborted;\n\t\tgoto scrub_continue;\n\t}\n\t/*\n\t * the reloc mutex makes sure that we stop\n\t * the balancing code from coming in and moving\n\t * extents around in the middle of the commit\n\t */\n\tmutex_lock(&root->fs_info->reloc_mutex);\n\n\t/*\n\t * We needn't worry about the delayed items because we will\n\t * deal with them in create_pending_snapshot(), which is the\n\t * core function of the snapshot creation.\n\t */\n\tret = create_pending_snapshots(trans, root->fs_info);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * We insert the dir indexes of the snapshots and update the inode\n\t * of the snapshots' parents after the snapshot creation, so there\n\t * are some delayed items which are not dealt with. Now deal with\n\t * them.\n\t *\n\t * We needn't worry that this operation will corrupt the snapshots,\n\t * because all the tree which are snapshoted will be forced to COW\n\t * the nodes and leaves.\n\t */\n\tret = btrfs_run_delayed_items(trans, root);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\tret = btrfs_run_delayed_refs(trans, root, (unsigned long)-1);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * make sure none of the code above managed to slip in a\n\t * delayed item\n\t */\n\tbtrfs_assert_delayed_root_empty(root);\n\n\tWARN_ON(cur_trans != trans->transaction);\n\n\t/* btrfs_commit_tree_roots is responsible for getting the\n\t * various roots consistent with each other.  Every pointer\n\t * in the tree of tree roots has to point to the most up to date\n\t * root for every subvolume and other tree.  So, we have to keep\n\t * the tree logging code from jumping in and changing any\n\t * of the trees.\n\t *\n\t * At this point in the commit, there can't be any tree-log\n\t * writers, but a little lower down we drop the trans mutex\n\t * and let new people in.  By holding the tree_log_mutex\n\t * from now until after the super is written, we avoid races\n\t * with the tree-log code.\n\t */\n\tmutex_lock(&root->fs_info->tree_log_mutex);\n\n\tret = commit_fs_roots(trans, root);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * Since the transaction is done, we can apply the pending changes\n\t * before the next transaction.\n\t */\n\tbtrfs_apply_pending_changes(root->fs_info);\n\n\t/* commit_fs_roots gets rid of all the tree log roots, it is now\n\t * safe to free the root of tree log roots\n\t */\n\tbtrfs_free_log_root_tree(trans, root->fs_info);\n\n\tret = commit_cowonly_roots(trans, root);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * The tasks which save the space cache and inode cache may also\n\t * update ->aborted, check it.\n\t */\n\tif (unlikely(ACCESS_ONCE(cur_trans->aborted))) {\n\t\tret = cur_trans->aborted;\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\tbtrfs_prepare_extent_commit(trans, root);\n\n\tcur_trans = root->fs_info->running_transaction;\n\n\tbtrfs_set_root_node(&root->fs_info->tree_root->root_item,\n\t\t\t    root->fs_info->tree_root->node);\n\tlist_add_tail(&root->fs_info->tree_root->dirty_list,\n\t\t      &cur_trans->switch_commits);\n\n\tbtrfs_set_root_node(&root->fs_info->chunk_root->root_item,\n\t\t\t    root->fs_info->chunk_root->node);\n\tlist_add_tail(&root->fs_info->chunk_root->dirty_list,\n\t\t      &cur_trans->switch_commits);\n\n\tswitch_commit_roots(cur_trans, root->fs_info);\n\n\tassert_qgroups_uptodate(trans);\n\tASSERT(list_empty(&cur_trans->dirty_bgs));\n\tupdate_super_roots(root);\n\n\tbtrfs_set_super_log_root(root->fs_info->super_copy, 0);\n\tbtrfs_set_super_log_root_level(root->fs_info->super_copy, 0);\n\tmemcpy(root->fs_info->super_for_commit, root->fs_info->super_copy,\n\t       sizeof(*root->fs_info->super_copy));\n\n\tbtrfs_update_commit_device_size(root->fs_info);\n\tbtrfs_update_commit_device_bytes_used(root, cur_trans);\n\n\tclear_bit(BTRFS_INODE_BTREE_LOG1_ERR, &btree_ino->runtime_flags);\n\tclear_bit(BTRFS_INODE_BTREE_LOG2_ERR, &btree_ino->runtime_flags);\n\n\tspin_lock(&root->fs_info->trans_lock);\n\tcur_trans->state = TRANS_STATE_UNBLOCKED;\n\troot->fs_info->running_transaction = NULL;\n\tspin_unlock(&root->fs_info->trans_lock);\n\tmutex_unlock(&root->fs_info->reloc_mutex);\n\n\twake_up(&root->fs_info->transaction_wait);\n\n\tret = btrfs_write_and_wait_transaction(trans, root);\n\tif (ret) {\n\t\tbtrfs_error(root->fs_info, ret,\n\t\t\t    \"Error while writing out transaction\");\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\tret = write_ctree_super(trans, root, 0);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * the super is written, we can safely allow the tree-loggers\n\t * to go about their business\n\t */\n\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\n\tbtrfs_finish_extent_commit(trans, root);\n\n\tif (cur_trans->have_free_bgs)\n\t\tbtrfs_clear_space_info_full(root->fs_info);\n\n\troot->fs_info->last_trans_committed = cur_trans->transid;\n\t/*\n\t * We needn't acquire the lock here because there is no other task\n\t * which can change it.\n\t */\n\tcur_trans->state = TRANS_STATE_COMPLETED;\n\twake_up(&cur_trans->commit_wait);\n\n\tspin_lock(&root->fs_info->trans_lock);\n\tlist_del_init(&cur_trans->list);\n\tspin_unlock(&root->fs_info->trans_lock);\n\n\tbtrfs_put_transaction(cur_trans);\n\tbtrfs_put_transaction(cur_trans);\n\n\tif (trans->type & __TRANS_FREEZABLE)\n\t\tsb_end_intwrite(root->fs_info->sb);\n\n\ttrace_btrfs_transaction_commit(root);\n\n\tbtrfs_scrub_continue(root);\n\n\tif (current->journal_info == trans)\n\t\tcurrent->journal_info = NULL;\n\n\tkmem_cache_free(btrfs_trans_handle_cachep, trans);\n\n\tif (current != root->fs_info->transaction_kthread)\n\t\tbtrfs_run_delayed_iputs(root);\n\n\treturn ret;\n\nscrub_continue:\n\tbtrfs_scrub_continue(root);\ncleanup_transaction:\n\tbtrfs_trans_release_metadata(trans, root);\n\ttrans->block_rsv = NULL;\n\tif (trans->qgroup_reserved) {\n\t\tbtrfs_qgroup_free(root, trans->qgroup_reserved);\n\t\ttrans->qgroup_reserved = 0;\n\t}\n\tbtrfs_warn(root->fs_info, \"Skipping commit of aborted transaction.\");\n\tif (current->journal_info == trans)\n\t\tcurrent->journal_info = NULL;\n\tcleanup_transaction(trans, root, ret);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"dev-replace.h\"",
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint btrfs_commit_transaction(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root)\n{\n\tstruct btrfs_transaction *cur_trans = trans->transaction;\n\tstruct btrfs_transaction *prev_trans = NULL;\n\tstruct btrfs_inode *btree_ino = BTRFS_I(root->fs_info->btree_inode);\n\tint ret;\n\n\t/* Stop the commit early if ->aborted is set */\n\tif (unlikely(ACCESS_ONCE(cur_trans->aborted))) {\n\t\tret = cur_trans->aborted;\n\t\tbtrfs_end_transaction(trans, root);\n\t\treturn ret;\n\t}\n\n\t/* make a pass through all the delayed refs we have so far\n\t * any runnings procs may add more while we are here\n\t */\n\tret = btrfs_run_delayed_refs(trans, root, 0);\n\tif (ret) {\n\t\tbtrfs_end_transaction(trans, root);\n\t\treturn ret;\n\t}\n\n\tbtrfs_trans_release_metadata(trans, root);\n\ttrans->block_rsv = NULL;\n\tif (trans->qgroup_reserved) {\n\t\tbtrfs_qgroup_free(root, trans->qgroup_reserved);\n\t\ttrans->qgroup_reserved = 0;\n\t}\n\n\tcur_trans = trans->transaction;\n\n\t/*\n\t * set the flushing flag so procs in this transaction have to\n\t * start sending their work down.\n\t */\n\tcur_trans->delayed_refs.flushing = 1;\n\tsmp_wmb();\n\n\tif (!list_empty(&trans->new_bgs))\n\t\tbtrfs_create_pending_block_groups(trans, root);\n\n\tret = btrfs_run_delayed_refs(trans, root, 0);\n\tif (ret) {\n\t\tbtrfs_end_transaction(trans, root);\n\t\treturn ret;\n\t}\n\n\tspin_lock(&root->fs_info->trans_lock);\n\tlist_splice(&trans->ordered, &cur_trans->pending_ordered);\n\tif (cur_trans->state >= TRANS_STATE_COMMIT_START) {\n\t\tspin_unlock(&root->fs_info->trans_lock);\n\t\tatomic_inc(&cur_trans->use_count);\n\t\tret = btrfs_end_transaction(trans, root);\n\n\t\twait_for_commit(root, cur_trans);\n\n\t\tif (unlikely(cur_trans->aborted))\n\t\t\tret = cur_trans->aborted;\n\n\t\tbtrfs_put_transaction(cur_trans);\n\n\t\treturn ret;\n\t}\n\n\tcur_trans->state = TRANS_STATE_COMMIT_START;\n\twake_up(&root->fs_info->transaction_blocked_wait);\n\n\tif (cur_trans->list.prev != &root->fs_info->trans_list) {\n\t\tprev_trans = list_entry(cur_trans->list.prev,\n\t\t\t\t\tstruct btrfs_transaction, list);\n\t\tif (prev_trans->state != TRANS_STATE_COMPLETED) {\n\t\t\tatomic_inc(&prev_trans->use_count);\n\t\t\tspin_unlock(&root->fs_info->trans_lock);\n\n\t\t\twait_for_commit(root, prev_trans);\n\n\t\t\tbtrfs_put_transaction(prev_trans);\n\t\t} else {\n\t\t\tspin_unlock(&root->fs_info->trans_lock);\n\t\t}\n\t} else {\n\t\tspin_unlock(&root->fs_info->trans_lock);\n\t}\n\n\textwriter_counter_dec(cur_trans, trans->type);\n\n\tret = btrfs_start_delalloc_flush(root->fs_info);\n\tif (ret)\n\t\tgoto cleanup_transaction;\n\n\tret = btrfs_run_delayed_items(trans, root);\n\tif (ret)\n\t\tgoto cleanup_transaction;\n\n\twait_event(cur_trans->writer_wait,\n\t\t   extwriter_counter_read(cur_trans) == 0);\n\n\t/* some pending stuffs might be added after the previous flush. */\n\tret = btrfs_run_delayed_items(trans, root);\n\tif (ret)\n\t\tgoto cleanup_transaction;\n\n\tbtrfs_wait_delalloc_flush(root->fs_info);\n\n\tbtrfs_wait_pending_ordered(cur_trans, root->fs_info);\n\n\tbtrfs_scrub_pause(root);\n\t/*\n\t * Ok now we need to make sure to block out any other joins while we\n\t * commit the transaction.  We could have started a join before setting\n\t * COMMIT_DOING so make sure to wait for num_writers to == 1 again.\n\t */\n\tspin_lock(&root->fs_info->trans_lock);\n\tcur_trans->state = TRANS_STATE_COMMIT_DOING;\n\tspin_unlock(&root->fs_info->trans_lock);\n\twait_event(cur_trans->writer_wait,\n\t\t   atomic_read(&cur_trans->num_writers) == 1);\n\n\t/* ->aborted might be set after the previous check, so check it */\n\tif (unlikely(ACCESS_ONCE(cur_trans->aborted))) {\n\t\tret = cur_trans->aborted;\n\t\tgoto scrub_continue;\n\t}\n\t/*\n\t * the reloc mutex makes sure that we stop\n\t * the balancing code from coming in and moving\n\t * extents around in the middle of the commit\n\t */\n\tmutex_lock(&root->fs_info->reloc_mutex);\n\n\t/*\n\t * We needn't worry about the delayed items because we will\n\t * deal with them in create_pending_snapshot(), which is the\n\t * core function of the snapshot creation.\n\t */\n\tret = create_pending_snapshots(trans, root->fs_info);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * We insert the dir indexes of the snapshots and update the inode\n\t * of the snapshots' parents after the snapshot creation, so there\n\t * are some delayed items which are not dealt with. Now deal with\n\t * them.\n\t *\n\t * We needn't worry that this operation will corrupt the snapshots,\n\t * because all the tree which are snapshoted will be forced to COW\n\t * the nodes and leaves.\n\t */\n\tret = btrfs_run_delayed_items(trans, root);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\tret = btrfs_run_delayed_refs(trans, root, (unsigned long)-1);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * make sure none of the code above managed to slip in a\n\t * delayed item\n\t */\n\tbtrfs_assert_delayed_root_empty(root);\n\n\tWARN_ON(cur_trans != trans->transaction);\n\n\t/* btrfs_commit_tree_roots is responsible for getting the\n\t * various roots consistent with each other.  Every pointer\n\t * in the tree of tree roots has to point to the most up to date\n\t * root for every subvolume and other tree.  So, we have to keep\n\t * the tree logging code from jumping in and changing any\n\t * of the trees.\n\t *\n\t * At this point in the commit, there can't be any tree-log\n\t * writers, but a little lower down we drop the trans mutex\n\t * and let new people in.  By holding the tree_log_mutex\n\t * from now until after the super is written, we avoid races\n\t * with the tree-log code.\n\t */\n\tmutex_lock(&root->fs_info->tree_log_mutex);\n\n\tret = commit_fs_roots(trans, root);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * Since the transaction is done, we can apply the pending changes\n\t * before the next transaction.\n\t */\n\tbtrfs_apply_pending_changes(root->fs_info);\n\n\t/* commit_fs_roots gets rid of all the tree log roots, it is now\n\t * safe to free the root of tree log roots\n\t */\n\tbtrfs_free_log_root_tree(trans, root->fs_info);\n\n\tret = commit_cowonly_roots(trans, root);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * The tasks which save the space cache and inode cache may also\n\t * update ->aborted, check it.\n\t */\n\tif (unlikely(ACCESS_ONCE(cur_trans->aborted))) {\n\t\tret = cur_trans->aborted;\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\tbtrfs_prepare_extent_commit(trans, root);\n\n\tcur_trans = root->fs_info->running_transaction;\n\n\tbtrfs_set_root_node(&root->fs_info->tree_root->root_item,\n\t\t\t    root->fs_info->tree_root->node);\n\tlist_add_tail(&root->fs_info->tree_root->dirty_list,\n\t\t      &cur_trans->switch_commits);\n\n\tbtrfs_set_root_node(&root->fs_info->chunk_root->root_item,\n\t\t\t    root->fs_info->chunk_root->node);\n\tlist_add_tail(&root->fs_info->chunk_root->dirty_list,\n\t\t      &cur_trans->switch_commits);\n\n\tswitch_commit_roots(cur_trans, root->fs_info);\n\n\tassert_qgroups_uptodate(trans);\n\tASSERT(list_empty(&cur_trans->dirty_bgs));\n\tupdate_super_roots(root);\n\n\tbtrfs_set_super_log_root(root->fs_info->super_copy, 0);\n\tbtrfs_set_super_log_root_level(root->fs_info->super_copy, 0);\n\tmemcpy(root->fs_info->super_for_commit, root->fs_info->super_copy,\n\t       sizeof(*root->fs_info->super_copy));\n\n\tbtrfs_update_commit_device_size(root->fs_info);\n\tbtrfs_update_commit_device_bytes_used(root, cur_trans);\n\n\tclear_bit(BTRFS_INODE_BTREE_LOG1_ERR, &btree_ino->runtime_flags);\n\tclear_bit(BTRFS_INODE_BTREE_LOG2_ERR, &btree_ino->runtime_flags);\n\n\tspin_lock(&root->fs_info->trans_lock);\n\tcur_trans->state = TRANS_STATE_UNBLOCKED;\n\troot->fs_info->running_transaction = NULL;\n\tspin_unlock(&root->fs_info->trans_lock);\n\tmutex_unlock(&root->fs_info->reloc_mutex);\n\n\twake_up(&root->fs_info->transaction_wait);\n\n\tret = btrfs_write_and_wait_transaction(trans, root);\n\tif (ret) {\n\t\tbtrfs_error(root->fs_info, ret,\n\t\t\t    \"Error while writing out transaction\");\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\tret = write_ctree_super(trans, root, 0);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * the super is written, we can safely allow the tree-loggers\n\t * to go about their business\n\t */\n\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\n\tbtrfs_finish_extent_commit(trans, root);\n\n\tif (cur_trans->have_free_bgs)\n\t\tbtrfs_clear_space_info_full(root->fs_info);\n\n\troot->fs_info->last_trans_committed = cur_trans->transid;\n\t/*\n\t * We needn't acquire the lock here because there is no other task\n\t * which can change it.\n\t */\n\tcur_trans->state = TRANS_STATE_COMPLETED;\n\twake_up(&cur_trans->commit_wait);\n\n\tspin_lock(&root->fs_info->trans_lock);\n\tlist_del_init(&cur_trans->list);\n\tspin_unlock(&root->fs_info->trans_lock);\n\n\tbtrfs_put_transaction(cur_trans);\n\tbtrfs_put_transaction(cur_trans);\n\n\tif (trans->type & __TRANS_FREEZABLE)\n\t\tsb_end_intwrite(root->fs_info->sb);\n\n\ttrace_btrfs_transaction_commit(root);\n\n\tbtrfs_scrub_continue(root);\n\n\tif (current->journal_info == trans)\n\t\tcurrent->journal_info = NULL;\n\n\tkmem_cache_free(btrfs_trans_handle_cachep, trans);\n\n\tif (current != root->fs_info->transaction_kthread)\n\t\tbtrfs_run_delayed_iputs(root);\n\n\treturn ret;\n\nscrub_continue:\n\tbtrfs_scrub_continue(root);\ncleanup_transaction:\n\tbtrfs_trans_release_metadata(trans, root);\n\ttrans->block_rsv = NULL;\n\tif (trans->qgroup_reserved) {\n\t\tbtrfs_qgroup_free(root, trans->qgroup_reserved);\n\t\ttrans->qgroup_reserved = 0;\n\t}\n\tbtrfs_warn(root->fs_info, \"Skipping commit of aborted transaction.\");\n\tif (current->journal_info == trans)\n\t\tcurrent->journal_info = NULL;\n\tcleanup_transaction(trans, root, ret);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ACCESS_ONCE",
          "args": [
            "cur_trans->state"
          ],
          "line": 799
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&info->trans_lock"
          ],
          "line": 796
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&info->trans_lock"
          ],
          "line": 793
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ACCESS_ONCE",
          "args": [
            "cur_trans->state"
          ],
          "line": 792
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "should_end_transaction",
          "args": [
            "trans",
            "root"
          ],
          "line": 791
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_should_end_transaction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
          "lines": "709-730",
          "snippet": "int btrfs_should_end_transaction(struct btrfs_trans_handle *trans,\n\t\t\t\t struct btrfs_root *root)\n{\n\tstruct btrfs_transaction *cur_trans = trans->transaction;\n\tint updates;\n\tint err;\n\n\tsmp_mb();\n\tif (cur_trans->state >= TRANS_STATE_BLOCKED ||\n\t    cur_trans->delayed_refs.flushing)\n\t\treturn 1;\n\n\tupdates = trans->delayed_ref_updates;\n\ttrans->delayed_ref_updates = 0;\n\tif (updates) {\n\t\terr = btrfs_run_delayed_refs(trans, root, updates);\n\t\tif (err) /* Error code will also eval true */\n\t\t\treturn err;\n\t}\n\n\treturn should_end_transaction(trans, root);\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"dev-replace.h\"",
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint btrfs_should_end_transaction(struct btrfs_trans_handle *trans,\n\t\t\t\t struct btrfs_root *root)\n{\n\tstruct btrfs_transaction *cur_trans = trans->transaction;\n\tint updates;\n\tint err;\n\n\tsmp_mb();\n\tif (cur_trans->state >= TRANS_STATE_BLOCKED ||\n\t    cur_trans->delayed_refs.flushing)\n\t\treturn 1;\n\n\tupdates = trans->delayed_ref_updates;\n\ttrans->delayed_ref_updates = 0;\n\tif (updates) {\n\t\terr = btrfs_run_delayed_refs(trans, root, updates);\n\t\tif (err) /* Error code will also eval true */\n\t\t\treturn err;\n\t}\n\n\treturn should_end_transaction(trans, root);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&root->fs_info->open_ioctl_trans"
          ],
          "line": 790
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_create_pending_block_groups",
          "args": [
            "trans",
            "root"
          ],
          "line": 788
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_create_pending_block_groups",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent-tree.c",
          "lines": "9179-9208",
          "snippet": "void btrfs_create_pending_block_groups(struct btrfs_trans_handle *trans,\n\t\t\t\t       struct btrfs_root *root)\n{\n\tstruct btrfs_block_group_cache *block_group, *tmp;\n\tstruct btrfs_root *extent_root = root->fs_info->extent_root;\n\tstruct btrfs_block_group_item item;\n\tstruct btrfs_key key;\n\tint ret = 0;\n\n\tlist_for_each_entry_safe(block_group, tmp, &trans->new_bgs, bg_list) {\n\t\tif (ret)\n\t\t\tgoto next;\n\n\t\tspin_lock(&block_group->lock);\n\t\tmemcpy(&item, &block_group->item, sizeof(item));\n\t\tmemcpy(&key, &block_group->key, sizeof(key));\n\t\tspin_unlock(&block_group->lock);\n\n\t\tret = btrfs_insert_item(trans, extent_root, &key, &item,\n\t\t\t\t\tsizeof(item));\n\t\tif (ret)\n\t\t\tbtrfs_abort_transaction(trans, extent_root, ret);\n\t\tret = btrfs_finish_chunk_alloc(trans, extent_root,\n\t\t\t\t\t       key.objectid, key.offset);\n\t\tif (ret)\n\t\t\tbtrfs_abort_transaction(trans, extent_root, ret);\nnext:\n\t\tlist_del_init(&block_group->bg_list);\n\t}\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"math.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include \"hash.h\"",
            "#include <linux/percpu_counter.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int find_next_key(struct btrfs_path *path, int level,\n\t\t\t struct btrfs_key *key);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"math.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include \"hash.h\"\n#include <linux/percpu_counter.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n#include <linux/rcupdate.h>\n#include <linux/sort.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic int find_next_key(struct btrfs_path *path, int level,\n\t\t\t struct btrfs_key *key);\nstatic noinline struct;\n\nvoid btrfs_create_pending_block_groups(struct btrfs_trans_handle *trans,\n\t\t\t\t       struct btrfs_root *root)\n{\n\tstruct btrfs_block_group_cache *block_group, *tmp;\n\tstruct btrfs_root *extent_root = root->fs_info->extent_root;\n\tstruct btrfs_block_group_item item;\n\tstruct btrfs_key key;\n\tint ret = 0;\n\n\tlist_for_each_entry_safe(block_group, tmp, &trans->new_bgs, bg_list) {\n\t\tif (ret)\n\t\t\tgoto next;\n\n\t\tspin_lock(&block_group->lock);\n\t\tmemcpy(&item, &block_group->item, sizeof(item));\n\t\tmemcpy(&key, &block_group->key, sizeof(key));\n\t\tspin_unlock(&block_group->lock);\n\n\t\tret = btrfs_insert_item(trans, extent_root, &key, &item,\n\t\t\t\t\tsizeof(item));\n\t\tif (ret)\n\t\t\tbtrfs_abort_transaction(trans, extent_root, ret);\n\t\tret = btrfs_finish_chunk_alloc(trans, extent_root,\n\t\t\t\t\t       key.objectid, key.offset);\n\t\tif (ret)\n\t\t\tbtrfs_abort_transaction(trans, extent_root, ret);\nnext:\n\t\tlist_del_init(&block_group->bg_list);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&trans->new_bgs"
          ],
          "line": 787
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_trans_release_metadata",
          "args": [
            "trans",
            "root"
          ],
          "line": 784
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_trans_release_metadata",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent-tree.c",
          "lines": "4900-4913",
          "snippet": "void btrfs_trans_release_metadata(struct btrfs_trans_handle *trans,\n\t\t\t\t  struct btrfs_root *root)\n{\n\tif (!trans->block_rsv)\n\t\treturn;\n\n\tif (!trans->bytes_reserved)\n\t\treturn;\n\n\ttrace_btrfs_space_reservation(root->fs_info, \"transaction\",\n\t\t\t\t      trans->transid, trans->bytes_reserved, 0);\n\tbtrfs_block_rsv_release(root, trans->block_rsv, trans->bytes_reserved);\n\ttrans->bytes_reserved = 0;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"math.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include \"hash.h\"",
            "#include <linux/percpu_counter.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"math.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include \"hash.h\"\n#include <linux/percpu_counter.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n#include <linux/rcupdate.h>\n#include <linux/sort.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nvoid btrfs_trans_release_metadata(struct btrfs_trans_handle *trans,\n\t\t\t\t  struct btrfs_root *root)\n{\n\tif (!trans->block_rsv)\n\t\treturn;\n\n\tif (!trans->bytes_reserved)\n\t\treturn;\n\n\ttrace_btrfs_space_reservation(root->fs_info, \"transaction\",\n\t\t\t\t      trans->transid, trans->bytes_reserved, 0);\n\tbtrfs_block_rsv_release(root, trans->block_rsv, trans->bytes_reserved);\n\ttrans->bytes_reserved = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_qgroup_free",
          "args": [
            "trans->root",
            "trans->qgroup_reserved"
          ],
          "line": 780
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_qgroup_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/qgroup.c",
          "lines": "2448-2499",
          "snippet": "void btrfs_qgroup_free(struct btrfs_root *root, u64 num_bytes)\n{\n\tstruct btrfs_root *quota_root;\n\tstruct btrfs_qgroup *qgroup;\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tstruct ulist_node *unode;\n\tstruct ulist_iterator uiter;\n\tu64 ref_root = root->root_key.objectid;\n\tint ret = 0;\n\n\tif (!is_fstree(ref_root))\n\t\treturn;\n\n\tif (num_bytes == 0)\n\t\treturn;\n\n\tspin_lock(&fs_info->qgroup_lock);\n\n\tquota_root = fs_info->quota_root;\n\tif (!quota_root)\n\t\tgoto out;\n\n\tqgroup = find_qgroup_rb(fs_info, ref_root);\n\tif (!qgroup)\n\t\tgoto out;\n\n\tulist_reinit(fs_info->qgroup_ulist);\n\tret = ulist_add(fs_info->qgroup_ulist, qgroup->qgroupid,\n\t\t\t(uintptr_t)qgroup, GFP_ATOMIC);\n\tif (ret < 0)\n\t\tgoto out;\n\tULIST_ITER_INIT(&uiter);\n\twhile ((unode = ulist_next(fs_info->qgroup_ulist, &uiter))) {\n\t\tstruct btrfs_qgroup *qg;\n\t\tstruct btrfs_qgroup_list *glist;\n\n\t\tqg = u64_to_ptr(unode->aux);\n\n\t\tqg->reserved -= num_bytes;\n\n\t\tlist_for_each_entry(glist, &qg->groups, next_group) {\n\t\t\tret = ulist_add(fs_info->qgroup_ulist,\n\t\t\t\t\tglist->group->qgroupid,\n\t\t\t\t\t(uintptr_t)glist->group, GFP_ATOMIC);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\tspin_unlock(&fs_info->qgroup_lock);\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"ulist.h\"",
            "#include \"locking.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"ctree.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"ulist.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);\n\nvoid btrfs_qgroup_free(struct btrfs_root *root, u64 num_bytes)\n{\n\tstruct btrfs_root *quota_root;\n\tstruct btrfs_qgroup *qgroup;\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tstruct ulist_node *unode;\n\tstruct ulist_iterator uiter;\n\tu64 ref_root = root->root_key.objectid;\n\tint ret = 0;\n\n\tif (!is_fstree(ref_root))\n\t\treturn;\n\n\tif (num_bytes == 0)\n\t\treturn;\n\n\tspin_lock(&fs_info->qgroup_lock);\n\n\tquota_root = fs_info->quota_root;\n\tif (!quota_root)\n\t\tgoto out;\n\n\tqgroup = find_qgroup_rb(fs_info, ref_root);\n\tif (!qgroup)\n\t\tgoto out;\n\n\tulist_reinit(fs_info->qgroup_ulist);\n\tret = ulist_add(fs_info->qgroup_ulist, qgroup->qgroupid,\n\t\t\t(uintptr_t)qgroup, GFP_ATOMIC);\n\tif (ret < 0)\n\t\tgoto out;\n\tULIST_ITER_INIT(&uiter);\n\twhile ((unode = ulist_next(fs_info->qgroup_ulist, &uiter))) {\n\t\tstruct btrfs_qgroup *qg;\n\t\tstruct btrfs_qgroup_list *glist;\n\n\t\tqg = u64_to_ptr(unode->aux);\n\n\t\tqg->reserved -= num_bytes;\n\n\t\tlist_for_each_entry(glist, &qg->groups, next_group) {\n\t\t\tret = ulist_add(fs_info->qgroup_ulist,\n\t\t\t\t\tglist->group->qgroupid,\n\t\t\t\t\t(uintptr_t)glist->group, GFP_ATOMIC);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\tspin_unlock(&fs_info->qgroup_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "max_t",
          "args": [
            "unsignedlong",
            "cur",
            "32"
          ],
          "line": 764
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_should_throttle_delayed_refs",
          "args": [
            "trans",
            "root"
          ],
          "line": 763
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_should_throttle_delayed_refs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent-tree.c",
          "lines": "2659-2677",
          "snippet": "int btrfs_should_throttle_delayed_refs(struct btrfs_trans_handle *trans,\n\t\t\t\t       struct btrfs_root *root)\n{\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tu64 num_entries =\n\t\tatomic_read(&trans->transaction->delayed_refs.num_entries);\n\tu64 avg_runtime;\n\tu64 val;\n\n\tsmp_mb();\n\tavg_runtime = fs_info->avg_delayed_ref_runtime;\n\tval = num_entries * avg_runtime;\n\tif (num_entries * avg_runtime >= NSEC_PER_SEC)\n\t\treturn 1;\n\tif (val >= NSEC_PER_SEC / 2)\n\t\treturn 2;\n\n\treturn btrfs_check_space_for_delayed_refs(trans, root);\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"math.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include \"hash.h\"",
            "#include <linux/percpu_counter.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"math.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include \"hash.h\"\n#include <linux/percpu_counter.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n#include <linux/rcupdate.h>\n#include <linux/sort.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nint btrfs_should_throttle_delayed_refs(struct btrfs_trans_handle *trans,\n\t\t\t\t       struct btrfs_root *root)\n{\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tu64 num_entries =\n\t\tatomic_read(&trans->transaction->delayed_refs.num_entries);\n\tu64 avg_runtime;\n\tu64 val;\n\n\tsmp_mb();\n\tavg_runtime = fs_info->avg_delayed_ref_runtime;\n\tval = num_entries * avg_runtime;\n\tif (num_entries * avg_runtime >= NSEC_PER_SEC)\n\t\treturn 1;\n\tif (val >= NSEC_PER_SEC / 2)\n\t\treturn 2;\n\n\treturn btrfs_check_space_for_delayed_refs(trans, root);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_splice",
          "args": [
            "&trans->ordered",
            "&cur_trans->pending_ordered"
          ],
          "line": 756
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic int __btrfs_end_transaction(struct btrfs_trans_handle *trans,\n\t\t\t  struct btrfs_root *root, int throttle)\n{\n\tstruct btrfs_transaction *cur_trans = trans->transaction;\n\tstruct btrfs_fs_info *info = root->fs_info;\n\tunsigned long cur = trans->delayed_ref_updates;\n\tint lock = (trans->type != TRANS_JOIN_NOLOCK);\n\tint err = 0;\n\tint must_run_delayed_refs = 0;\n\n\tif (trans->use_count > 1) {\n\t\ttrans->use_count--;\n\t\ttrans->block_rsv = trans->orig_rsv;\n\t\treturn 0;\n\t}\n\n\tbtrfs_trans_release_metadata(trans, root);\n\ttrans->block_rsv = NULL;\n\n\tif (!list_empty(&trans->new_bgs))\n\t\tbtrfs_create_pending_block_groups(trans, root);\n\n\tif (!list_empty(&trans->ordered)) {\n\t\tspin_lock(&info->trans_lock);\n\t\tlist_splice(&trans->ordered, &cur_trans->pending_ordered);\n\t\tspin_unlock(&info->trans_lock);\n\t}\n\n\ttrans->delayed_ref_updates = 0;\n\tif (!trans->sync) {\n\t\tmust_run_delayed_refs =\n\t\t\tbtrfs_should_throttle_delayed_refs(trans, root);\n\t\tcur = max_t(unsigned long, cur, 32);\n\n\t\t/*\n\t\t * don't make the caller wait if they are from a NOLOCK\n\t\t * or ATTACH transaction, it will deadlock with commit\n\t\t */\n\t\tif (must_run_delayed_refs == 1 &&\n\t\t    (trans->type & (__TRANS_JOIN_NOLOCK | __TRANS_ATTACH)))\n\t\t\tmust_run_delayed_refs = 2;\n\t}\n\n\tif (trans->qgroup_reserved) {\n\t\t/*\n\t\t * the same root has to be passed here between start_transaction\n\t\t * and end_transaction. Subvolume quota depends on this.\n\t\t */\n\t\tbtrfs_qgroup_free(trans->root, trans->qgroup_reserved);\n\t\ttrans->qgroup_reserved = 0;\n\t}\n\n\tbtrfs_trans_release_metadata(trans, root);\n\ttrans->block_rsv = NULL;\n\n\tif (!list_empty(&trans->new_bgs))\n\t\tbtrfs_create_pending_block_groups(trans, root);\n\n\tif (lock && !atomic_read(&root->fs_info->open_ioctl_trans) &&\n\t    should_end_transaction(trans, root) &&\n\t    ACCESS_ONCE(cur_trans->state) == TRANS_STATE_RUNNING) {\n\t\tspin_lock(&info->trans_lock);\n\t\tif (cur_trans->state == TRANS_STATE_RUNNING)\n\t\t\tcur_trans->state = TRANS_STATE_BLOCKED;\n\t\tspin_unlock(&info->trans_lock);\n\t}\n\n\tif (lock && ACCESS_ONCE(cur_trans->state) == TRANS_STATE_BLOCKED) {\n\t\tif (throttle)\n\t\t\treturn btrfs_commit_transaction(trans, root);\n\t\telse\n\t\t\twake_up_process(info->transaction_kthread);\n\t}\n\n\tif (trans->type & __TRANS_FREEZABLE)\n\t\tsb_end_intwrite(root->fs_info->sb);\n\n\tWARN_ON(cur_trans != info->running_transaction);\n\tWARN_ON(atomic_read(&cur_trans->num_writers) < 1);\n\tatomic_dec(&cur_trans->num_writers);\n\textwriter_counter_dec(cur_trans, trans->type);\n\n\tsmp_mb();\n\tif (waitqueue_active(&cur_trans->writer_wait))\n\t\twake_up(&cur_trans->writer_wait);\n\tbtrfs_put_transaction(cur_trans);\n\n\tif (current->journal_info == trans)\n\t\tcurrent->journal_info = NULL;\n\n\tif (throttle)\n\t\tbtrfs_run_delayed_iputs(root);\n\n\tif (trans->aborted ||\n\t    test_bit(BTRFS_FS_STATE_ERROR, &root->fs_info->fs_state)) {\n\t\twake_up_process(info->transaction_kthread);\n\t\terr = -EIO;\n\t}\n\tassert_qgroups_uptodate(trans);\n\n\tkmem_cache_free(btrfs_trans_handle_cachep, trans);\n\tif (must_run_delayed_refs) {\n\t\tbtrfs_async_run_delayed_refs(root, cur,\n\t\t\t\t\t     must_run_delayed_refs == 1);\n\t}\n\treturn err;\n}"
  },
  {
    "function_name": "btrfs_should_end_transaction",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
    "lines": "709-730",
    "snippet": "int btrfs_should_end_transaction(struct btrfs_trans_handle *trans,\n\t\t\t\t struct btrfs_root *root)\n{\n\tstruct btrfs_transaction *cur_trans = trans->transaction;\n\tint updates;\n\tint err;\n\n\tsmp_mb();\n\tif (cur_trans->state >= TRANS_STATE_BLOCKED ||\n\t    cur_trans->delayed_refs.flushing)\n\t\treturn 1;\n\n\tupdates = trans->delayed_ref_updates;\n\ttrans->delayed_ref_updates = 0;\n\tif (updates) {\n\t\terr = btrfs_run_delayed_refs(trans, root, updates);\n\t\tif (err) /* Error code will also eval true */\n\t\t\treturn err;\n\t}\n\n\treturn should_end_transaction(trans, root);\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"dev-replace.h\"",
      "#include \"volumes.h\"",
      "#include \"inode-map.h\"",
      "#include \"tree-log.h\"",
      "#include \"locking.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/uuid.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/writeback.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "should_end_transaction",
          "args": [
            "trans",
            "root"
          ],
          "line": 729
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_should_end_transaction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
          "lines": "709-730",
          "snippet": "int btrfs_should_end_transaction(struct btrfs_trans_handle *trans,\n\t\t\t\t struct btrfs_root *root)\n{\n\tstruct btrfs_transaction *cur_trans = trans->transaction;\n\tint updates;\n\tint err;\n\n\tsmp_mb();\n\tif (cur_trans->state >= TRANS_STATE_BLOCKED ||\n\t    cur_trans->delayed_refs.flushing)\n\t\treturn 1;\n\n\tupdates = trans->delayed_ref_updates;\n\ttrans->delayed_ref_updates = 0;\n\tif (updates) {\n\t\terr = btrfs_run_delayed_refs(trans, root, updates);\n\t\tif (err) /* Error code will also eval true */\n\t\t\treturn err;\n\t}\n\n\treturn should_end_transaction(trans, root);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_run_delayed_refs",
          "args": [
            "trans",
            "root",
            "updates"
          ],
          "line": 724
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_run_delayed_refs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent-tree.c",
          "lines": "2764-2841",
          "snippet": "int btrfs_run_delayed_refs(struct btrfs_trans_handle *trans,\n\t\t\t   struct btrfs_root *root, unsigned long count)\n{\n\tstruct rb_node *node;\n\tstruct btrfs_delayed_ref_root *delayed_refs;\n\tstruct btrfs_delayed_ref_head *head;\n\tint ret;\n\tint run_all = count == (unsigned long)-1;\n\n\t/* We'll clean this up in btrfs_cleanup_transaction */\n\tif (trans->aborted)\n\t\treturn 0;\n\n\tif (root == root->fs_info->extent_root)\n\t\troot = root->fs_info->tree_root;\n\n\tdelayed_refs = &trans->transaction->delayed_refs;\n\tif (count == 0)\n\t\tcount = atomic_read(&delayed_refs->num_entries) * 2;\n\nagain:\n#ifdef SCRAMBLE_DELAYED_REFS\n\tdelayed_refs->run_delayed_start = find_middle(&delayed_refs->root);\n#endif\n\tret = __btrfs_run_delayed_refs(trans, root, count);\n\tif (ret < 0) {\n\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\treturn ret;\n\t}\n\n\tif (run_all) {\n\t\tif (!list_empty(&trans->new_bgs))\n\t\t\tbtrfs_create_pending_block_groups(trans, root);\n\n\t\tspin_lock(&delayed_refs->lock);\n\t\tnode = rb_first(&delayed_refs->href_root);\n\t\tif (!node) {\n\t\t\tspin_unlock(&delayed_refs->lock);\n\t\t\tgoto out;\n\t\t}\n\t\tcount = (unsigned long)-1;\n\n\t\twhile (node) {\n\t\t\thead = rb_entry(node, struct btrfs_delayed_ref_head,\n\t\t\t\t\thref_node);\n\t\t\tif (btrfs_delayed_ref_is_head(&head->node)) {\n\t\t\t\tstruct btrfs_delayed_ref_node *ref;\n\n\t\t\t\tref = &head->node;\n\t\t\t\tatomic_inc(&ref->refs);\n\n\t\t\t\tspin_unlock(&delayed_refs->lock);\n\t\t\t\t/*\n\t\t\t\t * Mutex was contended, block until it's\n\t\t\t\t * released and try again\n\t\t\t\t */\n\t\t\t\tmutex_lock(&head->mutex);\n\t\t\t\tmutex_unlock(&head->mutex);\n\n\t\t\t\tbtrfs_put_delayed_ref(ref);\n\t\t\t\tcond_resched();\n\t\t\t\tgoto again;\n\t\t\t} else {\n\t\t\t\tWARN_ON(1);\n\t\t\t}\n\t\t\tnode = rb_next(node);\n\t\t}\n\t\tspin_unlock(&delayed_refs->lock);\n\t\tcond_resched();\n\t\tgoto again;\n\t}\nout:\n\tret = btrfs_delayed_qgroup_accounting(trans, root->fs_info);\n\tif (ret)\n\t\treturn ret;\n\tassert_qgroups_uptodate(trans);\n\treturn 0;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"math.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include \"hash.h\"",
            "#include <linux/percpu_counter.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"math.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include \"hash.h\"\n#include <linux/percpu_counter.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n#include <linux/rcupdate.h>\n#include <linux/sort.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nint btrfs_run_delayed_refs(struct btrfs_trans_handle *trans,\n\t\t\t   struct btrfs_root *root, unsigned long count)\n{\n\tstruct rb_node *node;\n\tstruct btrfs_delayed_ref_root *delayed_refs;\n\tstruct btrfs_delayed_ref_head *head;\n\tint ret;\n\tint run_all = count == (unsigned long)-1;\n\n\t/* We'll clean this up in btrfs_cleanup_transaction */\n\tif (trans->aborted)\n\t\treturn 0;\n\n\tif (root == root->fs_info->extent_root)\n\t\troot = root->fs_info->tree_root;\n\n\tdelayed_refs = &trans->transaction->delayed_refs;\n\tif (count == 0)\n\t\tcount = atomic_read(&delayed_refs->num_entries) * 2;\n\nagain:\n#ifdef SCRAMBLE_DELAYED_REFS\n\tdelayed_refs->run_delayed_start = find_middle(&delayed_refs->root);\n#endif\n\tret = __btrfs_run_delayed_refs(trans, root, count);\n\tif (ret < 0) {\n\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\treturn ret;\n\t}\n\n\tif (run_all) {\n\t\tif (!list_empty(&trans->new_bgs))\n\t\t\tbtrfs_create_pending_block_groups(trans, root);\n\n\t\tspin_lock(&delayed_refs->lock);\n\t\tnode = rb_first(&delayed_refs->href_root);\n\t\tif (!node) {\n\t\t\tspin_unlock(&delayed_refs->lock);\n\t\t\tgoto out;\n\t\t}\n\t\tcount = (unsigned long)-1;\n\n\t\twhile (node) {\n\t\t\thead = rb_entry(node, struct btrfs_delayed_ref_head,\n\t\t\t\t\thref_node);\n\t\t\tif (btrfs_delayed_ref_is_head(&head->node)) {\n\t\t\t\tstruct btrfs_delayed_ref_node *ref;\n\n\t\t\t\tref = &head->node;\n\t\t\t\tatomic_inc(&ref->refs);\n\n\t\t\t\tspin_unlock(&delayed_refs->lock);\n\t\t\t\t/*\n\t\t\t\t * Mutex was contended, block until it's\n\t\t\t\t * released and try again\n\t\t\t\t */\n\t\t\t\tmutex_lock(&head->mutex);\n\t\t\t\tmutex_unlock(&head->mutex);\n\n\t\t\t\tbtrfs_put_delayed_ref(ref);\n\t\t\t\tcond_resched();\n\t\t\t\tgoto again;\n\t\t\t} else {\n\t\t\t\tWARN_ON(1);\n\t\t\t}\n\t\t\tnode = rb_next(node);\n\t\t}\n\t\tspin_unlock(&delayed_refs->lock);\n\t\tcond_resched();\n\t\tgoto again;\n\t}\nout:\n\tret = btrfs_delayed_qgroup_accounting(trans, root->fs_info);\n\tif (ret)\n\t\treturn ret;\n\tassert_qgroups_uptodate(trans);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_mb",
          "args": [],
          "line": 716
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint btrfs_should_end_transaction(struct btrfs_trans_handle *trans,\n\t\t\t\t struct btrfs_root *root)\n{\n\tstruct btrfs_transaction *cur_trans = trans->transaction;\n\tint updates;\n\tint err;\n\n\tsmp_mb();\n\tif (cur_trans->state >= TRANS_STATE_BLOCKED ||\n\t    cur_trans->delayed_refs.flushing)\n\t\treturn 1;\n\n\tupdates = trans->delayed_ref_updates;\n\ttrans->delayed_ref_updates = 0;\n\tif (updates) {\n\t\terr = btrfs_run_delayed_refs(trans, root, updates);\n\t\tif (err) /* Error code will also eval true */\n\t\t\treturn err;\n\t}\n\n\treturn should_end_transaction(trans, root);\n}"
  },
  {
    "function_name": "should_end_transaction",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
    "lines": "699-707",
    "snippet": "static int should_end_transaction(struct btrfs_trans_handle *trans,\n\t\t\t\t  struct btrfs_root *root)\n{\n\tif (root->fs_info->global_block_rsv.space_info->full &&\n\t    btrfs_check_space_for_delayed_refs(trans, root))\n\t\treturn 1;\n\n\treturn !!btrfs_block_rsv_check(root, &root->fs_info->global_block_rsv, 5);\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"dev-replace.h\"",
      "#include \"volumes.h\"",
      "#include \"inode-map.h\"",
      "#include \"tree-log.h\"",
      "#include \"locking.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/uuid.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/writeback.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_block_rsv_check",
          "args": [
            "root",
            "&root->fs_info->global_block_rsv",
            "5"
          ],
          "line": 706
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_block_rsv_check",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent-tree.c",
          "lines": "4721-4737",
          "snippet": "int btrfs_block_rsv_check(struct btrfs_root *root,\n\t\t\t  struct btrfs_block_rsv *block_rsv, int min_factor)\n{\n\tu64 num_bytes = 0;\n\tint ret = -ENOSPC;\n\n\tif (!block_rsv)\n\t\treturn 0;\n\n\tspin_lock(&block_rsv->lock);\n\tnum_bytes = div_factor(block_rsv->size, min_factor);\n\tif (block_rsv->reserved >= num_bytes)\n\t\tret = 0;\n\tspin_unlock(&block_rsv->lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"math.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include \"hash.h\"",
            "#include <linux/percpu_counter.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int block_rsv_use_bytes(struct btrfs_block_rsv *block_rsv,\n\t\t\t       u64 num_bytes);",
            "int btrfs_pin_extent(struct btrfs_root *root,\n\t\t     u64 bytenr, u64 num_bytes, int reserved);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"math.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include \"hash.h\"\n#include <linux/percpu_counter.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n#include <linux/rcupdate.h>\n#include <linux/sort.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic int block_rsv_use_bytes(struct btrfs_block_rsv *block_rsv,\n\t\t\t       u64 num_bytes);\nint btrfs_pin_extent(struct btrfs_root *root,\n\t\t     u64 bytenr, u64 num_bytes, int reserved);\nstatic noinline struct;\n\nint btrfs_block_rsv_check(struct btrfs_root *root,\n\t\t\t  struct btrfs_block_rsv *block_rsv, int min_factor)\n{\n\tu64 num_bytes = 0;\n\tint ret = -ENOSPC;\n\n\tif (!block_rsv)\n\t\treturn 0;\n\n\tspin_lock(&block_rsv->lock);\n\tnum_bytes = div_factor(block_rsv->size, min_factor);\n\tif (block_rsv->reserved >= num_bytes)\n\t\tret = 0;\n\tspin_unlock(&block_rsv->lock);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_check_space_for_delayed_refs",
          "args": [
            "trans",
            "root"
          ],
          "line": 703
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_check_space_for_delayed_refs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent-tree.c",
          "lines": "2630-2657",
          "snippet": "int btrfs_check_space_for_delayed_refs(struct btrfs_trans_handle *trans,\n\t\t\t\t       struct btrfs_root *root)\n{\n\tstruct btrfs_block_rsv *global_rsv;\n\tu64 num_heads = trans->transaction->delayed_refs.num_heads_ready;\n\tu64 num_bytes;\n\tint ret = 0;\n\n\tnum_bytes = btrfs_calc_trans_metadata_size(root, 1);\n\tnum_heads = heads_to_leaves(root, num_heads);\n\tif (num_heads > 1)\n\t\tnum_bytes += (num_heads - 1) * root->nodesize;\n\tnum_bytes <<= 1;\n\tglobal_rsv = &root->fs_info->global_block_rsv;\n\n\t/*\n\t * If we can't allocate any more chunks lets make sure we have _lots_ of\n\t * wiggle room since running delayed refs can create more delayed refs.\n\t */\n\tif (global_rsv->space_info->full)\n\t\tnum_bytes <<= 1;\n\n\tspin_lock(&global_rsv->lock);\n\tif (global_rsv->reserved <= num_bytes)\n\t\tret = 1;\n\tspin_unlock(&global_rsv->lock);\n\treturn ret;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"math.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include \"hash.h\"",
            "#include <linux/percpu_counter.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int block_rsv_use_bytes(struct btrfs_block_rsv *block_rsv,\n\t\t\t       u64 num_bytes);",
            "int btrfs_pin_extent(struct btrfs_root *root,\n\t\t     u64 bytenr, u64 num_bytes, int reserved);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"math.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include \"hash.h\"\n#include <linux/percpu_counter.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n#include <linux/rcupdate.h>\n#include <linux/sort.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic int block_rsv_use_bytes(struct btrfs_block_rsv *block_rsv,\n\t\t\t       u64 num_bytes);\nint btrfs_pin_extent(struct btrfs_root *root,\n\t\t     u64 bytenr, u64 num_bytes, int reserved);\nstatic noinline struct;\n\nint btrfs_check_space_for_delayed_refs(struct btrfs_trans_handle *trans,\n\t\t\t\t       struct btrfs_root *root)\n{\n\tstruct btrfs_block_rsv *global_rsv;\n\tu64 num_heads = trans->transaction->delayed_refs.num_heads_ready;\n\tu64 num_bytes;\n\tint ret = 0;\n\n\tnum_bytes = btrfs_calc_trans_metadata_size(root, 1);\n\tnum_heads = heads_to_leaves(root, num_heads);\n\tif (num_heads > 1)\n\t\tnum_bytes += (num_heads - 1) * root->nodesize;\n\tnum_bytes <<= 1;\n\tglobal_rsv = &root->fs_info->global_block_rsv;\n\n\t/*\n\t * If we can't allocate any more chunks lets make sure we have _lots_ of\n\t * wiggle room since running delayed refs can create more delayed refs.\n\t */\n\tif (global_rsv->space_info->full)\n\t\tnum_bytes <<= 1;\n\n\tspin_lock(&global_rsv->lock);\n\tif (global_rsv->reserved <= num_bytes)\n\t\tret = 1;\n\tspin_unlock(&global_rsv->lock);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic int should_end_transaction(struct btrfs_trans_handle *trans,\n\t\t\t\t  struct btrfs_root *root)\n{\n\tif (root->fs_info->global_block_rsv.space_info->full &&\n\t    btrfs_check_space_for_delayed_refs(trans, root))\n\t\treturn 1;\n\n\treturn !!btrfs_block_rsv_check(root, &root->fs_info->global_block_rsv, 5);\n}"
  },
  {
    "function_name": "btrfs_throttle",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
    "lines": "693-697",
    "snippet": "void btrfs_throttle(struct btrfs_root *root)\n{\n\tif (!atomic_read(&root->fs_info->open_ioctl_trans))\n\t\twait_current_trans(root);\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"dev-replace.h\"",
      "#include \"volumes.h\"",
      "#include \"inode-map.h\"",
      "#include \"tree-log.h\"",
      "#include \"locking.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/uuid.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/writeback.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wait_current_trans",
          "args": [
            "root"
          ],
          "line": 696
        },
        "resolved": true,
        "details": {
          "function_name": "wait_current_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
          "lines": "363-380",
          "snippet": "static void wait_current_trans(struct btrfs_root *root)\n{\n\tstruct btrfs_transaction *cur_trans;\n\n\tspin_lock(&root->fs_info->trans_lock);\n\tcur_trans = root->fs_info->running_transaction;\n\tif (cur_trans && is_transaction_blocked(cur_trans)) {\n\t\tatomic_inc(&cur_trans->use_count);\n\t\tspin_unlock(&root->fs_info->trans_lock);\n\n\t\twait_event(root->fs_info->transaction_wait,\n\t\t\t   cur_trans->state >= TRANS_STATE_UNBLOCKED ||\n\t\t\t   cur_trans->aborted);\n\t\tbtrfs_put_transaction(cur_trans);\n\t} else {\n\t\tspin_unlock(&root->fs_info->trans_lock);\n\t}\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"dev-replace.h\"",
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void wait_current_trans(struct btrfs_root *root)\n{\n\tstruct btrfs_transaction *cur_trans;\n\n\tspin_lock(&root->fs_info->trans_lock);\n\tcur_trans = root->fs_info->running_transaction;\n\tif (cur_trans && is_transaction_blocked(cur_trans)) {\n\t\tatomic_inc(&cur_trans->use_count);\n\t\tspin_unlock(&root->fs_info->trans_lock);\n\n\t\twait_event(root->fs_info->transaction_wait,\n\t\t\t   cur_trans->state >= TRANS_STATE_UNBLOCKED ||\n\t\t\t   cur_trans->aborted);\n\t\tbtrfs_put_transaction(cur_trans);\n\t} else {\n\t\tspin_unlock(&root->fs_info->trans_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&root->fs_info->open_ioctl_trans"
          ],
          "line": 695
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid btrfs_throttle(struct btrfs_root *root)\n{\n\tif (!atomic_read(&root->fs_info->open_ioctl_trans))\n\t\twait_current_trans(root);\n}"
  },
  {
    "function_name": "btrfs_wait_for_commit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
    "lines": "635-691",
    "snippet": "int btrfs_wait_for_commit(struct btrfs_root *root, u64 transid)\n{\n\tstruct btrfs_transaction *cur_trans = NULL, *t;\n\tint ret = 0;\n\n\tif (transid) {\n\t\tif (transid <= root->fs_info->last_trans_committed)\n\t\t\tgoto out;\n\n\t\t/* find specified transaction */\n\t\tspin_lock(&root->fs_info->trans_lock);\n\t\tlist_for_each_entry(t, &root->fs_info->trans_list, list) {\n\t\t\tif (t->transid == transid) {\n\t\t\t\tcur_trans = t;\n\t\t\t\tatomic_inc(&cur_trans->use_count);\n\t\t\t\tret = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (t->transid > transid) {\n\t\t\t\tret = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tspin_unlock(&root->fs_info->trans_lock);\n\n\t\t/*\n\t\t * The specified transaction doesn't exist, or we\n\t\t * raced with btrfs_commit_transaction\n\t\t */\n\t\tif (!cur_trans) {\n\t\t\tif (transid > root->fs_info->last_trans_committed)\n\t\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\t/* find newest transaction that is committing | committed */\n\t\tspin_lock(&root->fs_info->trans_lock);\n\t\tlist_for_each_entry_reverse(t, &root->fs_info->trans_list,\n\t\t\t\t\t    list) {\n\t\t\tif (t->state >= TRANS_STATE_COMMIT_START) {\n\t\t\t\tif (t->state == TRANS_STATE_COMPLETED)\n\t\t\t\t\tbreak;\n\t\t\t\tcur_trans = t;\n\t\t\t\tatomic_inc(&cur_trans->use_count);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tspin_unlock(&root->fs_info->trans_lock);\n\t\tif (!cur_trans)\n\t\t\tgoto out;  /* nothing committing|committed */\n\t}\n\n\twait_for_commit(root, cur_trans);\n\tbtrfs_put_transaction(cur_trans);\nout:\n\treturn ret;\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"dev-replace.h\"",
      "#include \"volumes.h\"",
      "#include \"inode-map.h\"",
      "#include \"tree-log.h\"",
      "#include \"locking.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/uuid.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/writeback.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_put_transaction",
          "args": [
            "cur_trans"
          ],
          "line": 688
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_put_transaction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
          "lines": "61-77",
          "snippet": "void btrfs_put_transaction(struct btrfs_transaction *transaction)\n{\n\tWARN_ON(atomic_read(&transaction->use_count) == 0);\n\tif (atomic_dec_and_test(&transaction->use_count)) {\n\t\tBUG_ON(!list_empty(&transaction->list));\n\t\tWARN_ON(!RB_EMPTY_ROOT(&transaction->delayed_refs.href_root));\n\t\twhile (!list_empty(&transaction->pending_chunks)) {\n\t\t\tstruct extent_map *em;\n\n\t\t\tem = list_first_entry(&transaction->pending_chunks,\n\t\t\t\t\t      struct extent_map, list);\n\t\t\tlist_del_init(&em->list);\n\t\t\tfree_extent_map(em);\n\t\t}\n\t\tkmem_cache_free(btrfs_transaction_cachep, transaction);\n\t}\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"dev-replace.h\"",
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid btrfs_put_transaction(struct btrfs_transaction *transaction)\n{\n\tWARN_ON(atomic_read(&transaction->use_count) == 0);\n\tif (atomic_dec_and_test(&transaction->use_count)) {\n\t\tBUG_ON(!list_empty(&transaction->list));\n\t\tWARN_ON(!RB_EMPTY_ROOT(&transaction->delayed_refs.href_root));\n\t\twhile (!list_empty(&transaction->pending_chunks)) {\n\t\t\tstruct extent_map *em;\n\n\t\t\tem = list_first_entry(&transaction->pending_chunks,\n\t\t\t\t\t      struct extent_map, list);\n\t\t\tlist_del_init(&em->list);\n\t\t\tfree_extent_map(em);\n\t\t}\n\t\tkmem_cache_free(btrfs_transaction_cachep, transaction);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_for_commit",
          "args": [
            "root",
            "cur_trans"
          ],
          "line": 687
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_wait_for_commit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
          "lines": "635-691",
          "snippet": "int btrfs_wait_for_commit(struct btrfs_root *root, u64 transid)\n{\n\tstruct btrfs_transaction *cur_trans = NULL, *t;\n\tint ret = 0;\n\n\tif (transid) {\n\t\tif (transid <= root->fs_info->last_trans_committed)\n\t\t\tgoto out;\n\n\t\t/* find specified transaction */\n\t\tspin_lock(&root->fs_info->trans_lock);\n\t\tlist_for_each_entry(t, &root->fs_info->trans_list, list) {\n\t\t\tif (t->transid == transid) {\n\t\t\t\tcur_trans = t;\n\t\t\t\tatomic_inc(&cur_trans->use_count);\n\t\t\t\tret = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (t->transid > transid) {\n\t\t\t\tret = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tspin_unlock(&root->fs_info->trans_lock);\n\n\t\t/*\n\t\t * The specified transaction doesn't exist, or we\n\t\t * raced with btrfs_commit_transaction\n\t\t */\n\t\tif (!cur_trans) {\n\t\t\tif (transid > root->fs_info->last_trans_committed)\n\t\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\t/* find newest transaction that is committing | committed */\n\t\tspin_lock(&root->fs_info->trans_lock);\n\t\tlist_for_each_entry_reverse(t, &root->fs_info->trans_list,\n\t\t\t\t\t    list) {\n\t\t\tif (t->state >= TRANS_STATE_COMMIT_START) {\n\t\t\t\tif (t->state == TRANS_STATE_COMPLETED)\n\t\t\t\t\tbreak;\n\t\t\t\tcur_trans = t;\n\t\t\t\tatomic_inc(&cur_trans->use_count);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tspin_unlock(&root->fs_info->trans_lock);\n\t\tif (!cur_trans)\n\t\t\tgoto out;  /* nothing committing|committed */\n\t}\n\n\twait_for_commit(root, cur_trans);\n\tbtrfs_put_transaction(cur_trans);\nout:\n\treturn ret;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&root->fs_info->trans_lock"
          ],
          "line": 682
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&cur_trans->use_count"
          ],
          "line": 678
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_reverse",
          "args": [
            "t",
            "&root->fs_info->trans_list",
            "list"
          ],
          "line": 672
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&root->fs_info->trans_lock"
          ],
          "line": 671
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&cur_trans->use_count"
          ],
          "line": 649
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "t",
            "&root->fs_info->trans_list",
            "list"
          ],
          "line": 646
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint btrfs_wait_for_commit(struct btrfs_root *root, u64 transid)\n{\n\tstruct btrfs_transaction *cur_trans = NULL, *t;\n\tint ret = 0;\n\n\tif (transid) {\n\t\tif (transid <= root->fs_info->last_trans_committed)\n\t\t\tgoto out;\n\n\t\t/* find specified transaction */\n\t\tspin_lock(&root->fs_info->trans_lock);\n\t\tlist_for_each_entry(t, &root->fs_info->trans_list, list) {\n\t\t\tif (t->transid == transid) {\n\t\t\t\tcur_trans = t;\n\t\t\t\tatomic_inc(&cur_trans->use_count);\n\t\t\t\tret = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (t->transid > transid) {\n\t\t\t\tret = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tspin_unlock(&root->fs_info->trans_lock);\n\n\t\t/*\n\t\t * The specified transaction doesn't exist, or we\n\t\t * raced with btrfs_commit_transaction\n\t\t */\n\t\tif (!cur_trans) {\n\t\t\tif (transid > root->fs_info->last_trans_committed)\n\t\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\t/* find newest transaction that is committing | committed */\n\t\tspin_lock(&root->fs_info->trans_lock);\n\t\tlist_for_each_entry_reverse(t, &root->fs_info->trans_list,\n\t\t\t\t\t    list) {\n\t\t\tif (t->state >= TRANS_STATE_COMMIT_START) {\n\t\t\t\tif (t->state == TRANS_STATE_COMPLETED)\n\t\t\t\t\tbreak;\n\t\t\t\tcur_trans = t;\n\t\t\t\tatomic_inc(&cur_trans->use_count);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tspin_unlock(&root->fs_info->trans_lock);\n\t\tif (!cur_trans)\n\t\t\tgoto out;  /* nothing committing|committed */\n\t}\n\n\twait_for_commit(root, cur_trans);\n\tbtrfs_put_transaction(cur_trans);\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "wait_for_commit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
    "lines": "629-633",
    "snippet": "static noinline void wait_for_commit(struct btrfs_root *root,\n\t\t\t\t    struct btrfs_transaction *commit)\n{\n\twait_event(commit->commit_wait, commit->state == TRANS_STATE_COMPLETED);\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"dev-replace.h\"",
      "#include \"volumes.h\"",
      "#include \"inode-map.h\"",
      "#include \"tree-log.h\"",
      "#include \"locking.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/uuid.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/writeback.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wait_event",
          "args": [
            "commit->commit_wait",
            "commit->state == TRANS_STATE_COMPLETED"
          ],
          "line": 632
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic noinline void wait_for_commit(struct btrfs_root *root,\n\t\t\t\t    struct btrfs_transaction *commit)\n{\n\twait_event(commit->commit_wait, commit->state == TRANS_STATE_COMPLETED);\n}"
  },
  {
    "function_name": "btrfs_attach_transaction_barrier",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
    "lines": "616-626",
    "snippet": "struct btrfs_trans_handle *\nbtrfs_attach_transaction_barrier(struct btrfs_root *root)\n{\n\tstruct btrfs_trans_handle *trans;\n\n\ttrans = start_transaction(root, 0, TRANS_ATTACH, 0);\n\tif (IS_ERR(trans) && PTR_ERR(trans) == -ENOENT)\n\t\tbtrfs_wait_for_commit(root, 0);\n\n\treturn trans;\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"dev-replace.h\"",
      "#include \"volumes.h\"",
      "#include \"inode-map.h\"",
      "#include \"tree-log.h\"",
      "#include \"locking.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/uuid.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/writeback.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_wait_for_commit",
          "args": [
            "root",
            "0"
          ],
          "line": 623
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_wait_for_commit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
          "lines": "635-691",
          "snippet": "int btrfs_wait_for_commit(struct btrfs_root *root, u64 transid)\n{\n\tstruct btrfs_transaction *cur_trans = NULL, *t;\n\tint ret = 0;\n\n\tif (transid) {\n\t\tif (transid <= root->fs_info->last_trans_committed)\n\t\t\tgoto out;\n\n\t\t/* find specified transaction */\n\t\tspin_lock(&root->fs_info->trans_lock);\n\t\tlist_for_each_entry(t, &root->fs_info->trans_list, list) {\n\t\t\tif (t->transid == transid) {\n\t\t\t\tcur_trans = t;\n\t\t\t\tatomic_inc(&cur_trans->use_count);\n\t\t\t\tret = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (t->transid > transid) {\n\t\t\t\tret = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tspin_unlock(&root->fs_info->trans_lock);\n\n\t\t/*\n\t\t * The specified transaction doesn't exist, or we\n\t\t * raced with btrfs_commit_transaction\n\t\t */\n\t\tif (!cur_trans) {\n\t\t\tif (transid > root->fs_info->last_trans_committed)\n\t\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\t/* find newest transaction that is committing | committed */\n\t\tspin_lock(&root->fs_info->trans_lock);\n\t\tlist_for_each_entry_reverse(t, &root->fs_info->trans_list,\n\t\t\t\t\t    list) {\n\t\t\tif (t->state >= TRANS_STATE_COMMIT_START) {\n\t\t\t\tif (t->state == TRANS_STATE_COMPLETED)\n\t\t\t\t\tbreak;\n\t\t\t\tcur_trans = t;\n\t\t\t\tatomic_inc(&cur_trans->use_count);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tspin_unlock(&root->fs_info->trans_lock);\n\t\tif (!cur_trans)\n\t\t\tgoto out;  /* nothing committing|committed */\n\t}\n\n\twait_for_commit(root, cur_trans);\n\tbtrfs_put_transaction(cur_trans);\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"dev-replace.h\"",
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint btrfs_wait_for_commit(struct btrfs_root *root, u64 transid)\n{\n\tstruct btrfs_transaction *cur_trans = NULL, *t;\n\tint ret = 0;\n\n\tif (transid) {\n\t\tif (transid <= root->fs_info->last_trans_committed)\n\t\t\tgoto out;\n\n\t\t/* find specified transaction */\n\t\tspin_lock(&root->fs_info->trans_lock);\n\t\tlist_for_each_entry(t, &root->fs_info->trans_list, list) {\n\t\t\tif (t->transid == transid) {\n\t\t\t\tcur_trans = t;\n\t\t\t\tatomic_inc(&cur_trans->use_count);\n\t\t\t\tret = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (t->transid > transid) {\n\t\t\t\tret = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tspin_unlock(&root->fs_info->trans_lock);\n\n\t\t/*\n\t\t * The specified transaction doesn't exist, or we\n\t\t * raced with btrfs_commit_transaction\n\t\t */\n\t\tif (!cur_trans) {\n\t\t\tif (transid > root->fs_info->last_trans_committed)\n\t\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\t/* find newest transaction that is committing | committed */\n\t\tspin_lock(&root->fs_info->trans_lock);\n\t\tlist_for_each_entry_reverse(t, &root->fs_info->trans_list,\n\t\t\t\t\t    list) {\n\t\t\tif (t->state >= TRANS_STATE_COMMIT_START) {\n\t\t\t\tif (t->state == TRANS_STATE_COMPLETED)\n\t\t\t\t\tbreak;\n\t\t\t\tcur_trans = t;\n\t\t\t\tatomic_inc(&cur_trans->use_count);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tspin_unlock(&root->fs_info->trans_lock);\n\t\tif (!cur_trans)\n\t\t\tgoto out;  /* nothing committing|committed */\n\t}\n\n\twait_for_commit(root, cur_trans);\n\tbtrfs_put_transaction(cur_trans);\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "trans"
          ],
          "line": 622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "trans"
          ],
          "line": 622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "start_transaction",
          "args": [
            "root",
            "0",
            "TRANS_ATTACH",
            "0"
          ],
          "line": 621
        },
        "resolved": true,
        "details": {
          "function_name": "start_transaction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
          "lines": "408-560",
          "snippet": "static struct btrfs_trans_handle *\nstart_transaction(struct btrfs_root *root, u64 num_items, unsigned int type,\n\t\t  enum btrfs_reserve_flush_enum flush)\n{\n\tstruct btrfs_trans_handle *h;\n\tstruct btrfs_transaction *cur_trans;\n\tu64 num_bytes = 0;\n\tu64 qgroup_reserved = 0;\n\tbool reloc_reserved = false;\n\tint ret;\n\n\t/* Send isn't supposed to start transactions. */\n\tASSERT(current->journal_info != BTRFS_SEND_TRANS_STUB);\n\n\tif (test_bit(BTRFS_FS_STATE_ERROR, &root->fs_info->fs_state))\n\t\treturn ERR_PTR(-EROFS);\n\n\tif (current->journal_info) {\n\t\tWARN_ON(type & TRANS_EXTWRITERS);\n\t\th = current->journal_info;\n\t\th->use_count++;\n\t\tWARN_ON(h->use_count > 2);\n\t\th->orig_rsv = h->block_rsv;\n\t\th->block_rsv = NULL;\n\t\tgoto got_it;\n\t}\n\n\t/*\n\t * Do the reservation before we join the transaction so we can do all\n\t * the appropriate flushing if need be.\n\t */\n\tif (num_items > 0 && root != root->fs_info->chunk_root) {\n\t\tif (root->fs_info->quota_enabled &&\n\t\t    is_fstree(root->root_key.objectid)) {\n\t\t\tqgroup_reserved = num_items * root->nodesize;\n\t\t\tret = btrfs_qgroup_reserve(root, qgroup_reserved);\n\t\t\tif (ret)\n\t\t\t\treturn ERR_PTR(ret);\n\t\t}\n\n\t\tnum_bytes = btrfs_calc_trans_metadata_size(root, num_items);\n\t\t/*\n\t\t * Do the reservation for the relocation root creation\n\t\t */\n\t\tif (need_reserve_reloc_root(root)) {\n\t\t\tnum_bytes += root->nodesize;\n\t\t\treloc_reserved = true;\n\t\t}\n\n\t\tret = btrfs_block_rsv_add(root,\n\t\t\t\t\t  &root->fs_info->trans_block_rsv,\n\t\t\t\t\t  num_bytes, flush);\n\t\tif (ret)\n\t\t\tgoto reserve_fail;\n\t}\nagain:\n\th = kmem_cache_alloc(btrfs_trans_handle_cachep, GFP_NOFS);\n\tif (!h) {\n\t\tret = -ENOMEM;\n\t\tgoto alloc_fail;\n\t}\n\n\t/*\n\t * If we are JOIN_NOLOCK we're already committing a transaction and\n\t * waiting on this guy, so we don't need to do the sb_start_intwrite\n\t * because we're already holding a ref.  We need this because we could\n\t * have raced in and did an fsync() on a file which can kick a commit\n\t * and then we deadlock with somebody doing a freeze.\n\t *\n\t * If we are ATTACH, it means we just want to catch the current\n\t * transaction and commit it, so we needn't do sb_start_intwrite(). \n\t */\n\tif (type & __TRANS_FREEZABLE)\n\t\tsb_start_intwrite(root->fs_info->sb);\n\n\tif (may_wait_transaction(root, type))\n\t\twait_current_trans(root);\n\n\tdo {\n\t\tret = join_transaction(root, type);\n\t\tif (ret == -EBUSY) {\n\t\t\twait_current_trans(root);\n\t\t\tif (unlikely(type == TRANS_ATTACH))\n\t\t\t\tret = -ENOENT;\n\t\t}\n\t} while (ret == -EBUSY);\n\n\tif (ret < 0) {\n\t\t/* We must get the transaction if we are JOIN_NOLOCK. */\n\t\tBUG_ON(type == TRANS_JOIN_NOLOCK);\n\t\tgoto join_fail;\n\t}\n\n\tcur_trans = root->fs_info->running_transaction;\n\n\th->transid = cur_trans->transid;\n\th->transaction = cur_trans;\n\th->blocks_used = 0;\n\th->bytes_reserved = 0;\n\th->root = root;\n\th->delayed_ref_updates = 0;\n\th->use_count = 1;\n\th->adding_csums = 0;\n\th->block_rsv = NULL;\n\th->orig_rsv = NULL;\n\th->aborted = 0;\n\th->qgroup_reserved = 0;\n\th->delayed_ref_elem.seq = 0;\n\th->type = type;\n\th->allocating_chunk = false;\n\th->reloc_reserved = false;\n\th->sync = false;\n\tINIT_LIST_HEAD(&h->qgroup_ref_list);\n\tINIT_LIST_HEAD(&h->new_bgs);\n\tINIT_LIST_HEAD(&h->ordered);\n\n\tsmp_mb();\n\tif (cur_trans->state >= TRANS_STATE_BLOCKED &&\n\t    may_wait_transaction(root, type)) {\n\t\tcurrent->journal_info = h;\n\t\tbtrfs_commit_transaction(h, root);\n\t\tgoto again;\n\t}\n\n\tif (num_bytes) {\n\t\ttrace_btrfs_space_reservation(root->fs_info, \"transaction\",\n\t\t\t\t\t      h->transid, num_bytes, 1);\n\t\th->block_rsv = &root->fs_info->trans_block_rsv;\n\t\th->bytes_reserved = num_bytes;\n\t\th->reloc_reserved = reloc_reserved;\n\t}\n\th->qgroup_reserved = qgroup_reserved;\n\ngot_it:\n\tbtrfs_record_root_in_trans(h, root);\n\n\tif (!current->journal_info && type != TRANS_USERSPACE)\n\t\tcurrent->journal_info = h;\n\treturn h;\n\njoin_fail:\n\tif (type & __TRANS_FREEZABLE)\n\t\tsb_end_intwrite(root->fs_info->sb);\n\tkmem_cache_free(btrfs_trans_handle_cachep, h);\nalloc_fail:\n\tif (num_bytes)\n\t\tbtrfs_block_rsv_release(root, &root->fs_info->trans_block_rsv,\n\t\t\t\t\tnum_bytes);\nreserve_fail:\n\tif (qgroup_reserved)\n\t\tbtrfs_qgroup_free(root, qgroup_reserved);\n\treturn ERR_PTR(ret);\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"dev-replace.h\"",
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic struct btrfs_trans_handle *\nstart_transaction(struct btrfs_root *root, u64 num_items, unsigned int type,\n\t\t  enum btrfs_reserve_flush_enum flush)\n{\n\tstruct btrfs_trans_handle *h;\n\tstruct btrfs_transaction *cur_trans;\n\tu64 num_bytes = 0;\n\tu64 qgroup_reserved = 0;\n\tbool reloc_reserved = false;\n\tint ret;\n\n\t/* Send isn't supposed to start transactions. */\n\tASSERT(current->journal_info != BTRFS_SEND_TRANS_STUB);\n\n\tif (test_bit(BTRFS_FS_STATE_ERROR, &root->fs_info->fs_state))\n\t\treturn ERR_PTR(-EROFS);\n\n\tif (current->journal_info) {\n\t\tWARN_ON(type & TRANS_EXTWRITERS);\n\t\th = current->journal_info;\n\t\th->use_count++;\n\t\tWARN_ON(h->use_count > 2);\n\t\th->orig_rsv = h->block_rsv;\n\t\th->block_rsv = NULL;\n\t\tgoto got_it;\n\t}\n\n\t/*\n\t * Do the reservation before we join the transaction so we can do all\n\t * the appropriate flushing if need be.\n\t */\n\tif (num_items > 0 && root != root->fs_info->chunk_root) {\n\t\tif (root->fs_info->quota_enabled &&\n\t\t    is_fstree(root->root_key.objectid)) {\n\t\t\tqgroup_reserved = num_items * root->nodesize;\n\t\t\tret = btrfs_qgroup_reserve(root, qgroup_reserved);\n\t\t\tif (ret)\n\t\t\t\treturn ERR_PTR(ret);\n\t\t}\n\n\t\tnum_bytes = btrfs_calc_trans_metadata_size(root, num_items);\n\t\t/*\n\t\t * Do the reservation for the relocation root creation\n\t\t */\n\t\tif (need_reserve_reloc_root(root)) {\n\t\t\tnum_bytes += root->nodesize;\n\t\t\treloc_reserved = true;\n\t\t}\n\n\t\tret = btrfs_block_rsv_add(root,\n\t\t\t\t\t  &root->fs_info->trans_block_rsv,\n\t\t\t\t\t  num_bytes, flush);\n\t\tif (ret)\n\t\t\tgoto reserve_fail;\n\t}\nagain:\n\th = kmem_cache_alloc(btrfs_trans_handle_cachep, GFP_NOFS);\n\tif (!h) {\n\t\tret = -ENOMEM;\n\t\tgoto alloc_fail;\n\t}\n\n\t/*\n\t * If we are JOIN_NOLOCK we're already committing a transaction and\n\t * waiting on this guy, so we don't need to do the sb_start_intwrite\n\t * because we're already holding a ref.  We need this because we could\n\t * have raced in and did an fsync() on a file which can kick a commit\n\t * and then we deadlock with somebody doing a freeze.\n\t *\n\t * If we are ATTACH, it means we just want to catch the current\n\t * transaction and commit it, so we needn't do sb_start_intwrite(). \n\t */\n\tif (type & __TRANS_FREEZABLE)\n\t\tsb_start_intwrite(root->fs_info->sb);\n\n\tif (may_wait_transaction(root, type))\n\t\twait_current_trans(root);\n\n\tdo {\n\t\tret = join_transaction(root, type);\n\t\tif (ret == -EBUSY) {\n\t\t\twait_current_trans(root);\n\t\t\tif (unlikely(type == TRANS_ATTACH))\n\t\t\t\tret = -ENOENT;\n\t\t}\n\t} while (ret == -EBUSY);\n\n\tif (ret < 0) {\n\t\t/* We must get the transaction if we are JOIN_NOLOCK. */\n\t\tBUG_ON(type == TRANS_JOIN_NOLOCK);\n\t\tgoto join_fail;\n\t}\n\n\tcur_trans = root->fs_info->running_transaction;\n\n\th->transid = cur_trans->transid;\n\th->transaction = cur_trans;\n\th->blocks_used = 0;\n\th->bytes_reserved = 0;\n\th->root = root;\n\th->delayed_ref_updates = 0;\n\th->use_count = 1;\n\th->adding_csums = 0;\n\th->block_rsv = NULL;\n\th->orig_rsv = NULL;\n\th->aborted = 0;\n\th->qgroup_reserved = 0;\n\th->delayed_ref_elem.seq = 0;\n\th->type = type;\n\th->allocating_chunk = false;\n\th->reloc_reserved = false;\n\th->sync = false;\n\tINIT_LIST_HEAD(&h->qgroup_ref_list);\n\tINIT_LIST_HEAD(&h->new_bgs);\n\tINIT_LIST_HEAD(&h->ordered);\n\n\tsmp_mb();\n\tif (cur_trans->state >= TRANS_STATE_BLOCKED &&\n\t    may_wait_transaction(root, type)) {\n\t\tcurrent->journal_info = h;\n\t\tbtrfs_commit_transaction(h, root);\n\t\tgoto again;\n\t}\n\n\tif (num_bytes) {\n\t\ttrace_btrfs_space_reservation(root->fs_info, \"transaction\",\n\t\t\t\t\t      h->transid, num_bytes, 1);\n\t\th->block_rsv = &root->fs_info->trans_block_rsv;\n\t\th->bytes_reserved = num_bytes;\n\t\th->reloc_reserved = reloc_reserved;\n\t}\n\th->qgroup_reserved = qgroup_reserved;\n\ngot_it:\n\tbtrfs_record_root_in_trans(h, root);\n\n\tif (!current->journal_info && type != TRANS_USERSPACE)\n\t\tcurrent->journal_info = h;\n\treturn h;\n\njoin_fail:\n\tif (type & __TRANS_FREEZABLE)\n\t\tsb_end_intwrite(root->fs_info->sb);\n\tkmem_cache_free(btrfs_trans_handle_cachep, h);\nalloc_fail:\n\tif (num_bytes)\n\t\tbtrfs_block_rsv_release(root, &root->fs_info->trans_block_rsv,\n\t\t\t\t\tnum_bytes);\nreserve_fail:\n\tif (qgroup_reserved)\n\t\tbtrfs_qgroup_free(root, qgroup_reserved);\n\treturn ERR_PTR(ret);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstruct btrfs_trans_handle *\nbtrfs_attach_transaction_barrier(struct btrfs_root *root)\n{\n\tstruct btrfs_trans_handle *trans;\n\n\ttrans = start_transaction(root, 0, TRANS_ATTACH, 0);\n\tif (IS_ERR(trans) && PTR_ERR(trans) == -ENOENT)\n\t\tbtrfs_wait_for_commit(root, 0);\n\n\treturn trans;\n}"
  },
  {
    "function_name": "btrfs_attach_transaction",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
    "lines": "604-607",
    "snippet": "struct btrfs_trans_handle *btrfs_attach_transaction(struct btrfs_root *root)\n{\n\treturn start_transaction(root, 0, TRANS_ATTACH, 0);\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"dev-replace.h\"",
      "#include \"volumes.h\"",
      "#include \"inode-map.h\"",
      "#include \"tree-log.h\"",
      "#include \"locking.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/uuid.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/writeback.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "start_transaction",
          "args": [
            "root",
            "0",
            "TRANS_ATTACH",
            "0"
          ],
          "line": 606
        },
        "resolved": true,
        "details": {
          "function_name": "start_transaction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
          "lines": "408-560",
          "snippet": "static struct btrfs_trans_handle *\nstart_transaction(struct btrfs_root *root, u64 num_items, unsigned int type,\n\t\t  enum btrfs_reserve_flush_enum flush)\n{\n\tstruct btrfs_trans_handle *h;\n\tstruct btrfs_transaction *cur_trans;\n\tu64 num_bytes = 0;\n\tu64 qgroup_reserved = 0;\n\tbool reloc_reserved = false;\n\tint ret;\n\n\t/* Send isn't supposed to start transactions. */\n\tASSERT(current->journal_info != BTRFS_SEND_TRANS_STUB);\n\n\tif (test_bit(BTRFS_FS_STATE_ERROR, &root->fs_info->fs_state))\n\t\treturn ERR_PTR(-EROFS);\n\n\tif (current->journal_info) {\n\t\tWARN_ON(type & TRANS_EXTWRITERS);\n\t\th = current->journal_info;\n\t\th->use_count++;\n\t\tWARN_ON(h->use_count > 2);\n\t\th->orig_rsv = h->block_rsv;\n\t\th->block_rsv = NULL;\n\t\tgoto got_it;\n\t}\n\n\t/*\n\t * Do the reservation before we join the transaction so we can do all\n\t * the appropriate flushing if need be.\n\t */\n\tif (num_items > 0 && root != root->fs_info->chunk_root) {\n\t\tif (root->fs_info->quota_enabled &&\n\t\t    is_fstree(root->root_key.objectid)) {\n\t\t\tqgroup_reserved = num_items * root->nodesize;\n\t\t\tret = btrfs_qgroup_reserve(root, qgroup_reserved);\n\t\t\tif (ret)\n\t\t\t\treturn ERR_PTR(ret);\n\t\t}\n\n\t\tnum_bytes = btrfs_calc_trans_metadata_size(root, num_items);\n\t\t/*\n\t\t * Do the reservation for the relocation root creation\n\t\t */\n\t\tif (need_reserve_reloc_root(root)) {\n\t\t\tnum_bytes += root->nodesize;\n\t\t\treloc_reserved = true;\n\t\t}\n\n\t\tret = btrfs_block_rsv_add(root,\n\t\t\t\t\t  &root->fs_info->trans_block_rsv,\n\t\t\t\t\t  num_bytes, flush);\n\t\tif (ret)\n\t\t\tgoto reserve_fail;\n\t}\nagain:\n\th = kmem_cache_alloc(btrfs_trans_handle_cachep, GFP_NOFS);\n\tif (!h) {\n\t\tret = -ENOMEM;\n\t\tgoto alloc_fail;\n\t}\n\n\t/*\n\t * If we are JOIN_NOLOCK we're already committing a transaction and\n\t * waiting on this guy, so we don't need to do the sb_start_intwrite\n\t * because we're already holding a ref.  We need this because we could\n\t * have raced in and did an fsync() on a file which can kick a commit\n\t * and then we deadlock with somebody doing a freeze.\n\t *\n\t * If we are ATTACH, it means we just want to catch the current\n\t * transaction and commit it, so we needn't do sb_start_intwrite(). \n\t */\n\tif (type & __TRANS_FREEZABLE)\n\t\tsb_start_intwrite(root->fs_info->sb);\n\n\tif (may_wait_transaction(root, type))\n\t\twait_current_trans(root);\n\n\tdo {\n\t\tret = join_transaction(root, type);\n\t\tif (ret == -EBUSY) {\n\t\t\twait_current_trans(root);\n\t\t\tif (unlikely(type == TRANS_ATTACH))\n\t\t\t\tret = -ENOENT;\n\t\t}\n\t} while (ret == -EBUSY);\n\n\tif (ret < 0) {\n\t\t/* We must get the transaction if we are JOIN_NOLOCK. */\n\t\tBUG_ON(type == TRANS_JOIN_NOLOCK);\n\t\tgoto join_fail;\n\t}\n\n\tcur_trans = root->fs_info->running_transaction;\n\n\th->transid = cur_trans->transid;\n\th->transaction = cur_trans;\n\th->blocks_used = 0;\n\th->bytes_reserved = 0;\n\th->root = root;\n\th->delayed_ref_updates = 0;\n\th->use_count = 1;\n\th->adding_csums = 0;\n\th->block_rsv = NULL;\n\th->orig_rsv = NULL;\n\th->aborted = 0;\n\th->qgroup_reserved = 0;\n\th->delayed_ref_elem.seq = 0;\n\th->type = type;\n\th->allocating_chunk = false;\n\th->reloc_reserved = false;\n\th->sync = false;\n\tINIT_LIST_HEAD(&h->qgroup_ref_list);\n\tINIT_LIST_HEAD(&h->new_bgs);\n\tINIT_LIST_HEAD(&h->ordered);\n\n\tsmp_mb();\n\tif (cur_trans->state >= TRANS_STATE_BLOCKED &&\n\t    may_wait_transaction(root, type)) {\n\t\tcurrent->journal_info = h;\n\t\tbtrfs_commit_transaction(h, root);\n\t\tgoto again;\n\t}\n\n\tif (num_bytes) {\n\t\ttrace_btrfs_space_reservation(root->fs_info, \"transaction\",\n\t\t\t\t\t      h->transid, num_bytes, 1);\n\t\th->block_rsv = &root->fs_info->trans_block_rsv;\n\t\th->bytes_reserved = num_bytes;\n\t\th->reloc_reserved = reloc_reserved;\n\t}\n\th->qgroup_reserved = qgroup_reserved;\n\ngot_it:\n\tbtrfs_record_root_in_trans(h, root);\n\n\tif (!current->journal_info && type != TRANS_USERSPACE)\n\t\tcurrent->journal_info = h;\n\treturn h;\n\njoin_fail:\n\tif (type & __TRANS_FREEZABLE)\n\t\tsb_end_intwrite(root->fs_info->sb);\n\tkmem_cache_free(btrfs_trans_handle_cachep, h);\nalloc_fail:\n\tif (num_bytes)\n\t\tbtrfs_block_rsv_release(root, &root->fs_info->trans_block_rsv,\n\t\t\t\t\tnum_bytes);\nreserve_fail:\n\tif (qgroup_reserved)\n\t\tbtrfs_qgroup_free(root, qgroup_reserved);\n\treturn ERR_PTR(ret);\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"dev-replace.h\"",
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic struct btrfs_trans_handle *\nstart_transaction(struct btrfs_root *root, u64 num_items, unsigned int type,\n\t\t  enum btrfs_reserve_flush_enum flush)\n{\n\tstruct btrfs_trans_handle *h;\n\tstruct btrfs_transaction *cur_trans;\n\tu64 num_bytes = 0;\n\tu64 qgroup_reserved = 0;\n\tbool reloc_reserved = false;\n\tint ret;\n\n\t/* Send isn't supposed to start transactions. */\n\tASSERT(current->journal_info != BTRFS_SEND_TRANS_STUB);\n\n\tif (test_bit(BTRFS_FS_STATE_ERROR, &root->fs_info->fs_state))\n\t\treturn ERR_PTR(-EROFS);\n\n\tif (current->journal_info) {\n\t\tWARN_ON(type & TRANS_EXTWRITERS);\n\t\th = current->journal_info;\n\t\th->use_count++;\n\t\tWARN_ON(h->use_count > 2);\n\t\th->orig_rsv = h->block_rsv;\n\t\th->block_rsv = NULL;\n\t\tgoto got_it;\n\t}\n\n\t/*\n\t * Do the reservation before we join the transaction so we can do all\n\t * the appropriate flushing if need be.\n\t */\n\tif (num_items > 0 && root != root->fs_info->chunk_root) {\n\t\tif (root->fs_info->quota_enabled &&\n\t\t    is_fstree(root->root_key.objectid)) {\n\t\t\tqgroup_reserved = num_items * root->nodesize;\n\t\t\tret = btrfs_qgroup_reserve(root, qgroup_reserved);\n\t\t\tif (ret)\n\t\t\t\treturn ERR_PTR(ret);\n\t\t}\n\n\t\tnum_bytes = btrfs_calc_trans_metadata_size(root, num_items);\n\t\t/*\n\t\t * Do the reservation for the relocation root creation\n\t\t */\n\t\tif (need_reserve_reloc_root(root)) {\n\t\t\tnum_bytes += root->nodesize;\n\t\t\treloc_reserved = true;\n\t\t}\n\n\t\tret = btrfs_block_rsv_add(root,\n\t\t\t\t\t  &root->fs_info->trans_block_rsv,\n\t\t\t\t\t  num_bytes, flush);\n\t\tif (ret)\n\t\t\tgoto reserve_fail;\n\t}\nagain:\n\th = kmem_cache_alloc(btrfs_trans_handle_cachep, GFP_NOFS);\n\tif (!h) {\n\t\tret = -ENOMEM;\n\t\tgoto alloc_fail;\n\t}\n\n\t/*\n\t * If we are JOIN_NOLOCK we're already committing a transaction and\n\t * waiting on this guy, so we don't need to do the sb_start_intwrite\n\t * because we're already holding a ref.  We need this because we could\n\t * have raced in and did an fsync() on a file which can kick a commit\n\t * and then we deadlock with somebody doing a freeze.\n\t *\n\t * If we are ATTACH, it means we just want to catch the current\n\t * transaction and commit it, so we needn't do sb_start_intwrite(). \n\t */\n\tif (type & __TRANS_FREEZABLE)\n\t\tsb_start_intwrite(root->fs_info->sb);\n\n\tif (may_wait_transaction(root, type))\n\t\twait_current_trans(root);\n\n\tdo {\n\t\tret = join_transaction(root, type);\n\t\tif (ret == -EBUSY) {\n\t\t\twait_current_trans(root);\n\t\t\tif (unlikely(type == TRANS_ATTACH))\n\t\t\t\tret = -ENOENT;\n\t\t}\n\t} while (ret == -EBUSY);\n\n\tif (ret < 0) {\n\t\t/* We must get the transaction if we are JOIN_NOLOCK. */\n\t\tBUG_ON(type == TRANS_JOIN_NOLOCK);\n\t\tgoto join_fail;\n\t}\n\n\tcur_trans = root->fs_info->running_transaction;\n\n\th->transid = cur_trans->transid;\n\th->transaction = cur_trans;\n\th->blocks_used = 0;\n\th->bytes_reserved = 0;\n\th->root = root;\n\th->delayed_ref_updates = 0;\n\th->use_count = 1;\n\th->adding_csums = 0;\n\th->block_rsv = NULL;\n\th->orig_rsv = NULL;\n\th->aborted = 0;\n\th->qgroup_reserved = 0;\n\th->delayed_ref_elem.seq = 0;\n\th->type = type;\n\th->allocating_chunk = false;\n\th->reloc_reserved = false;\n\th->sync = false;\n\tINIT_LIST_HEAD(&h->qgroup_ref_list);\n\tINIT_LIST_HEAD(&h->new_bgs);\n\tINIT_LIST_HEAD(&h->ordered);\n\n\tsmp_mb();\n\tif (cur_trans->state >= TRANS_STATE_BLOCKED &&\n\t    may_wait_transaction(root, type)) {\n\t\tcurrent->journal_info = h;\n\t\tbtrfs_commit_transaction(h, root);\n\t\tgoto again;\n\t}\n\n\tif (num_bytes) {\n\t\ttrace_btrfs_space_reservation(root->fs_info, \"transaction\",\n\t\t\t\t\t      h->transid, num_bytes, 1);\n\t\th->block_rsv = &root->fs_info->trans_block_rsv;\n\t\th->bytes_reserved = num_bytes;\n\t\th->reloc_reserved = reloc_reserved;\n\t}\n\th->qgroup_reserved = qgroup_reserved;\n\ngot_it:\n\tbtrfs_record_root_in_trans(h, root);\n\n\tif (!current->journal_info && type != TRANS_USERSPACE)\n\t\tcurrent->journal_info = h;\n\treturn h;\n\njoin_fail:\n\tif (type & __TRANS_FREEZABLE)\n\t\tsb_end_intwrite(root->fs_info->sb);\n\tkmem_cache_free(btrfs_trans_handle_cachep, h);\nalloc_fail:\n\tif (num_bytes)\n\t\tbtrfs_block_rsv_release(root, &root->fs_info->trans_block_rsv,\n\t\t\t\t\tnum_bytes);\nreserve_fail:\n\tif (qgroup_reserved)\n\t\tbtrfs_qgroup_free(root, qgroup_reserved);\n\treturn ERR_PTR(ret);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstruct btrfs_trans_handle *btrfs_attach_transaction(struct btrfs_root *root)\n{\n\treturn start_transaction(root, 0, TRANS_ATTACH, 0);\n}"
  },
  {
    "function_name": "btrfs_start_ioctl_transaction",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
    "lines": "586-589",
    "snippet": "struct btrfs_trans_handle *btrfs_start_ioctl_transaction(struct btrfs_root *root)\n{\n\treturn start_transaction(root, 0, TRANS_USERSPACE, 0);\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"dev-replace.h\"",
      "#include \"volumes.h\"",
      "#include \"inode-map.h\"",
      "#include \"tree-log.h\"",
      "#include \"locking.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/uuid.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/writeback.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "start_transaction",
          "args": [
            "root",
            "0",
            "TRANS_USERSPACE",
            "0"
          ],
          "line": 588
        },
        "resolved": true,
        "details": {
          "function_name": "start_transaction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
          "lines": "408-560",
          "snippet": "static struct btrfs_trans_handle *\nstart_transaction(struct btrfs_root *root, u64 num_items, unsigned int type,\n\t\t  enum btrfs_reserve_flush_enum flush)\n{\n\tstruct btrfs_trans_handle *h;\n\tstruct btrfs_transaction *cur_trans;\n\tu64 num_bytes = 0;\n\tu64 qgroup_reserved = 0;\n\tbool reloc_reserved = false;\n\tint ret;\n\n\t/* Send isn't supposed to start transactions. */\n\tASSERT(current->journal_info != BTRFS_SEND_TRANS_STUB);\n\n\tif (test_bit(BTRFS_FS_STATE_ERROR, &root->fs_info->fs_state))\n\t\treturn ERR_PTR(-EROFS);\n\n\tif (current->journal_info) {\n\t\tWARN_ON(type & TRANS_EXTWRITERS);\n\t\th = current->journal_info;\n\t\th->use_count++;\n\t\tWARN_ON(h->use_count > 2);\n\t\th->orig_rsv = h->block_rsv;\n\t\th->block_rsv = NULL;\n\t\tgoto got_it;\n\t}\n\n\t/*\n\t * Do the reservation before we join the transaction so we can do all\n\t * the appropriate flushing if need be.\n\t */\n\tif (num_items > 0 && root != root->fs_info->chunk_root) {\n\t\tif (root->fs_info->quota_enabled &&\n\t\t    is_fstree(root->root_key.objectid)) {\n\t\t\tqgroup_reserved = num_items * root->nodesize;\n\t\t\tret = btrfs_qgroup_reserve(root, qgroup_reserved);\n\t\t\tif (ret)\n\t\t\t\treturn ERR_PTR(ret);\n\t\t}\n\n\t\tnum_bytes = btrfs_calc_trans_metadata_size(root, num_items);\n\t\t/*\n\t\t * Do the reservation for the relocation root creation\n\t\t */\n\t\tif (need_reserve_reloc_root(root)) {\n\t\t\tnum_bytes += root->nodesize;\n\t\t\treloc_reserved = true;\n\t\t}\n\n\t\tret = btrfs_block_rsv_add(root,\n\t\t\t\t\t  &root->fs_info->trans_block_rsv,\n\t\t\t\t\t  num_bytes, flush);\n\t\tif (ret)\n\t\t\tgoto reserve_fail;\n\t}\nagain:\n\th = kmem_cache_alloc(btrfs_trans_handle_cachep, GFP_NOFS);\n\tif (!h) {\n\t\tret = -ENOMEM;\n\t\tgoto alloc_fail;\n\t}\n\n\t/*\n\t * If we are JOIN_NOLOCK we're already committing a transaction and\n\t * waiting on this guy, so we don't need to do the sb_start_intwrite\n\t * because we're already holding a ref.  We need this because we could\n\t * have raced in and did an fsync() on a file which can kick a commit\n\t * and then we deadlock with somebody doing a freeze.\n\t *\n\t * If we are ATTACH, it means we just want to catch the current\n\t * transaction and commit it, so we needn't do sb_start_intwrite(). \n\t */\n\tif (type & __TRANS_FREEZABLE)\n\t\tsb_start_intwrite(root->fs_info->sb);\n\n\tif (may_wait_transaction(root, type))\n\t\twait_current_trans(root);\n\n\tdo {\n\t\tret = join_transaction(root, type);\n\t\tif (ret == -EBUSY) {\n\t\t\twait_current_trans(root);\n\t\t\tif (unlikely(type == TRANS_ATTACH))\n\t\t\t\tret = -ENOENT;\n\t\t}\n\t} while (ret == -EBUSY);\n\n\tif (ret < 0) {\n\t\t/* We must get the transaction if we are JOIN_NOLOCK. */\n\t\tBUG_ON(type == TRANS_JOIN_NOLOCK);\n\t\tgoto join_fail;\n\t}\n\n\tcur_trans = root->fs_info->running_transaction;\n\n\th->transid = cur_trans->transid;\n\th->transaction = cur_trans;\n\th->blocks_used = 0;\n\th->bytes_reserved = 0;\n\th->root = root;\n\th->delayed_ref_updates = 0;\n\th->use_count = 1;\n\th->adding_csums = 0;\n\th->block_rsv = NULL;\n\th->orig_rsv = NULL;\n\th->aborted = 0;\n\th->qgroup_reserved = 0;\n\th->delayed_ref_elem.seq = 0;\n\th->type = type;\n\th->allocating_chunk = false;\n\th->reloc_reserved = false;\n\th->sync = false;\n\tINIT_LIST_HEAD(&h->qgroup_ref_list);\n\tINIT_LIST_HEAD(&h->new_bgs);\n\tINIT_LIST_HEAD(&h->ordered);\n\n\tsmp_mb();\n\tif (cur_trans->state >= TRANS_STATE_BLOCKED &&\n\t    may_wait_transaction(root, type)) {\n\t\tcurrent->journal_info = h;\n\t\tbtrfs_commit_transaction(h, root);\n\t\tgoto again;\n\t}\n\n\tif (num_bytes) {\n\t\ttrace_btrfs_space_reservation(root->fs_info, \"transaction\",\n\t\t\t\t\t      h->transid, num_bytes, 1);\n\t\th->block_rsv = &root->fs_info->trans_block_rsv;\n\t\th->bytes_reserved = num_bytes;\n\t\th->reloc_reserved = reloc_reserved;\n\t}\n\th->qgroup_reserved = qgroup_reserved;\n\ngot_it:\n\tbtrfs_record_root_in_trans(h, root);\n\n\tif (!current->journal_info && type != TRANS_USERSPACE)\n\t\tcurrent->journal_info = h;\n\treturn h;\n\njoin_fail:\n\tif (type & __TRANS_FREEZABLE)\n\t\tsb_end_intwrite(root->fs_info->sb);\n\tkmem_cache_free(btrfs_trans_handle_cachep, h);\nalloc_fail:\n\tif (num_bytes)\n\t\tbtrfs_block_rsv_release(root, &root->fs_info->trans_block_rsv,\n\t\t\t\t\tnum_bytes);\nreserve_fail:\n\tif (qgroup_reserved)\n\t\tbtrfs_qgroup_free(root, qgroup_reserved);\n\treturn ERR_PTR(ret);\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"dev-replace.h\"",
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic struct btrfs_trans_handle *\nstart_transaction(struct btrfs_root *root, u64 num_items, unsigned int type,\n\t\t  enum btrfs_reserve_flush_enum flush)\n{\n\tstruct btrfs_trans_handle *h;\n\tstruct btrfs_transaction *cur_trans;\n\tu64 num_bytes = 0;\n\tu64 qgroup_reserved = 0;\n\tbool reloc_reserved = false;\n\tint ret;\n\n\t/* Send isn't supposed to start transactions. */\n\tASSERT(current->journal_info != BTRFS_SEND_TRANS_STUB);\n\n\tif (test_bit(BTRFS_FS_STATE_ERROR, &root->fs_info->fs_state))\n\t\treturn ERR_PTR(-EROFS);\n\n\tif (current->journal_info) {\n\t\tWARN_ON(type & TRANS_EXTWRITERS);\n\t\th = current->journal_info;\n\t\th->use_count++;\n\t\tWARN_ON(h->use_count > 2);\n\t\th->orig_rsv = h->block_rsv;\n\t\th->block_rsv = NULL;\n\t\tgoto got_it;\n\t}\n\n\t/*\n\t * Do the reservation before we join the transaction so we can do all\n\t * the appropriate flushing if need be.\n\t */\n\tif (num_items > 0 && root != root->fs_info->chunk_root) {\n\t\tif (root->fs_info->quota_enabled &&\n\t\t    is_fstree(root->root_key.objectid)) {\n\t\t\tqgroup_reserved = num_items * root->nodesize;\n\t\t\tret = btrfs_qgroup_reserve(root, qgroup_reserved);\n\t\t\tif (ret)\n\t\t\t\treturn ERR_PTR(ret);\n\t\t}\n\n\t\tnum_bytes = btrfs_calc_trans_metadata_size(root, num_items);\n\t\t/*\n\t\t * Do the reservation for the relocation root creation\n\t\t */\n\t\tif (need_reserve_reloc_root(root)) {\n\t\t\tnum_bytes += root->nodesize;\n\t\t\treloc_reserved = true;\n\t\t}\n\n\t\tret = btrfs_block_rsv_add(root,\n\t\t\t\t\t  &root->fs_info->trans_block_rsv,\n\t\t\t\t\t  num_bytes, flush);\n\t\tif (ret)\n\t\t\tgoto reserve_fail;\n\t}\nagain:\n\th = kmem_cache_alloc(btrfs_trans_handle_cachep, GFP_NOFS);\n\tif (!h) {\n\t\tret = -ENOMEM;\n\t\tgoto alloc_fail;\n\t}\n\n\t/*\n\t * If we are JOIN_NOLOCK we're already committing a transaction and\n\t * waiting on this guy, so we don't need to do the sb_start_intwrite\n\t * because we're already holding a ref.  We need this because we could\n\t * have raced in and did an fsync() on a file which can kick a commit\n\t * and then we deadlock with somebody doing a freeze.\n\t *\n\t * If we are ATTACH, it means we just want to catch the current\n\t * transaction and commit it, so we needn't do sb_start_intwrite(). \n\t */\n\tif (type & __TRANS_FREEZABLE)\n\t\tsb_start_intwrite(root->fs_info->sb);\n\n\tif (may_wait_transaction(root, type))\n\t\twait_current_trans(root);\n\n\tdo {\n\t\tret = join_transaction(root, type);\n\t\tif (ret == -EBUSY) {\n\t\t\twait_current_trans(root);\n\t\t\tif (unlikely(type == TRANS_ATTACH))\n\t\t\t\tret = -ENOENT;\n\t\t}\n\t} while (ret == -EBUSY);\n\n\tif (ret < 0) {\n\t\t/* We must get the transaction if we are JOIN_NOLOCK. */\n\t\tBUG_ON(type == TRANS_JOIN_NOLOCK);\n\t\tgoto join_fail;\n\t}\n\n\tcur_trans = root->fs_info->running_transaction;\n\n\th->transid = cur_trans->transid;\n\th->transaction = cur_trans;\n\th->blocks_used = 0;\n\th->bytes_reserved = 0;\n\th->root = root;\n\th->delayed_ref_updates = 0;\n\th->use_count = 1;\n\th->adding_csums = 0;\n\th->block_rsv = NULL;\n\th->orig_rsv = NULL;\n\th->aborted = 0;\n\th->qgroup_reserved = 0;\n\th->delayed_ref_elem.seq = 0;\n\th->type = type;\n\th->allocating_chunk = false;\n\th->reloc_reserved = false;\n\th->sync = false;\n\tINIT_LIST_HEAD(&h->qgroup_ref_list);\n\tINIT_LIST_HEAD(&h->new_bgs);\n\tINIT_LIST_HEAD(&h->ordered);\n\n\tsmp_mb();\n\tif (cur_trans->state >= TRANS_STATE_BLOCKED &&\n\t    may_wait_transaction(root, type)) {\n\t\tcurrent->journal_info = h;\n\t\tbtrfs_commit_transaction(h, root);\n\t\tgoto again;\n\t}\n\n\tif (num_bytes) {\n\t\ttrace_btrfs_space_reservation(root->fs_info, \"transaction\",\n\t\t\t\t\t      h->transid, num_bytes, 1);\n\t\th->block_rsv = &root->fs_info->trans_block_rsv;\n\t\th->bytes_reserved = num_bytes;\n\t\th->reloc_reserved = reloc_reserved;\n\t}\n\th->qgroup_reserved = qgroup_reserved;\n\ngot_it:\n\tbtrfs_record_root_in_trans(h, root);\n\n\tif (!current->journal_info && type != TRANS_USERSPACE)\n\t\tcurrent->journal_info = h;\n\treturn h;\n\njoin_fail:\n\tif (type & __TRANS_FREEZABLE)\n\t\tsb_end_intwrite(root->fs_info->sb);\n\tkmem_cache_free(btrfs_trans_handle_cachep, h);\nalloc_fail:\n\tif (num_bytes)\n\t\tbtrfs_block_rsv_release(root, &root->fs_info->trans_block_rsv,\n\t\t\t\t\tnum_bytes);\nreserve_fail:\n\tif (qgroup_reserved)\n\t\tbtrfs_qgroup_free(root, qgroup_reserved);\n\treturn ERR_PTR(ret);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstruct btrfs_trans_handle *btrfs_start_ioctl_transaction(struct btrfs_root *root)\n{\n\treturn start_transaction(root, 0, TRANS_USERSPACE, 0);\n}"
  },
  {
    "function_name": "btrfs_join_transaction_nolock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
    "lines": "581-584",
    "snippet": "struct btrfs_trans_handle *btrfs_join_transaction_nolock(struct btrfs_root *root)\n{\n\treturn start_transaction(root, 0, TRANS_JOIN_NOLOCK, 0);\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"dev-replace.h\"",
      "#include \"volumes.h\"",
      "#include \"inode-map.h\"",
      "#include \"tree-log.h\"",
      "#include \"locking.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/uuid.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/writeback.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "start_transaction",
          "args": [
            "root",
            "0",
            "TRANS_JOIN_NOLOCK",
            "0"
          ],
          "line": 583
        },
        "resolved": true,
        "details": {
          "function_name": "start_transaction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
          "lines": "408-560",
          "snippet": "static struct btrfs_trans_handle *\nstart_transaction(struct btrfs_root *root, u64 num_items, unsigned int type,\n\t\t  enum btrfs_reserve_flush_enum flush)\n{\n\tstruct btrfs_trans_handle *h;\n\tstruct btrfs_transaction *cur_trans;\n\tu64 num_bytes = 0;\n\tu64 qgroup_reserved = 0;\n\tbool reloc_reserved = false;\n\tint ret;\n\n\t/* Send isn't supposed to start transactions. */\n\tASSERT(current->journal_info != BTRFS_SEND_TRANS_STUB);\n\n\tif (test_bit(BTRFS_FS_STATE_ERROR, &root->fs_info->fs_state))\n\t\treturn ERR_PTR(-EROFS);\n\n\tif (current->journal_info) {\n\t\tWARN_ON(type & TRANS_EXTWRITERS);\n\t\th = current->journal_info;\n\t\th->use_count++;\n\t\tWARN_ON(h->use_count > 2);\n\t\th->orig_rsv = h->block_rsv;\n\t\th->block_rsv = NULL;\n\t\tgoto got_it;\n\t}\n\n\t/*\n\t * Do the reservation before we join the transaction so we can do all\n\t * the appropriate flushing if need be.\n\t */\n\tif (num_items > 0 && root != root->fs_info->chunk_root) {\n\t\tif (root->fs_info->quota_enabled &&\n\t\t    is_fstree(root->root_key.objectid)) {\n\t\t\tqgroup_reserved = num_items * root->nodesize;\n\t\t\tret = btrfs_qgroup_reserve(root, qgroup_reserved);\n\t\t\tif (ret)\n\t\t\t\treturn ERR_PTR(ret);\n\t\t}\n\n\t\tnum_bytes = btrfs_calc_trans_metadata_size(root, num_items);\n\t\t/*\n\t\t * Do the reservation for the relocation root creation\n\t\t */\n\t\tif (need_reserve_reloc_root(root)) {\n\t\t\tnum_bytes += root->nodesize;\n\t\t\treloc_reserved = true;\n\t\t}\n\n\t\tret = btrfs_block_rsv_add(root,\n\t\t\t\t\t  &root->fs_info->trans_block_rsv,\n\t\t\t\t\t  num_bytes, flush);\n\t\tif (ret)\n\t\t\tgoto reserve_fail;\n\t}\nagain:\n\th = kmem_cache_alloc(btrfs_trans_handle_cachep, GFP_NOFS);\n\tif (!h) {\n\t\tret = -ENOMEM;\n\t\tgoto alloc_fail;\n\t}\n\n\t/*\n\t * If we are JOIN_NOLOCK we're already committing a transaction and\n\t * waiting on this guy, so we don't need to do the sb_start_intwrite\n\t * because we're already holding a ref.  We need this because we could\n\t * have raced in and did an fsync() on a file which can kick a commit\n\t * and then we deadlock with somebody doing a freeze.\n\t *\n\t * If we are ATTACH, it means we just want to catch the current\n\t * transaction and commit it, so we needn't do sb_start_intwrite(). \n\t */\n\tif (type & __TRANS_FREEZABLE)\n\t\tsb_start_intwrite(root->fs_info->sb);\n\n\tif (may_wait_transaction(root, type))\n\t\twait_current_trans(root);\n\n\tdo {\n\t\tret = join_transaction(root, type);\n\t\tif (ret == -EBUSY) {\n\t\t\twait_current_trans(root);\n\t\t\tif (unlikely(type == TRANS_ATTACH))\n\t\t\t\tret = -ENOENT;\n\t\t}\n\t} while (ret == -EBUSY);\n\n\tif (ret < 0) {\n\t\t/* We must get the transaction if we are JOIN_NOLOCK. */\n\t\tBUG_ON(type == TRANS_JOIN_NOLOCK);\n\t\tgoto join_fail;\n\t}\n\n\tcur_trans = root->fs_info->running_transaction;\n\n\th->transid = cur_trans->transid;\n\th->transaction = cur_trans;\n\th->blocks_used = 0;\n\th->bytes_reserved = 0;\n\th->root = root;\n\th->delayed_ref_updates = 0;\n\th->use_count = 1;\n\th->adding_csums = 0;\n\th->block_rsv = NULL;\n\th->orig_rsv = NULL;\n\th->aborted = 0;\n\th->qgroup_reserved = 0;\n\th->delayed_ref_elem.seq = 0;\n\th->type = type;\n\th->allocating_chunk = false;\n\th->reloc_reserved = false;\n\th->sync = false;\n\tINIT_LIST_HEAD(&h->qgroup_ref_list);\n\tINIT_LIST_HEAD(&h->new_bgs);\n\tINIT_LIST_HEAD(&h->ordered);\n\n\tsmp_mb();\n\tif (cur_trans->state >= TRANS_STATE_BLOCKED &&\n\t    may_wait_transaction(root, type)) {\n\t\tcurrent->journal_info = h;\n\t\tbtrfs_commit_transaction(h, root);\n\t\tgoto again;\n\t}\n\n\tif (num_bytes) {\n\t\ttrace_btrfs_space_reservation(root->fs_info, \"transaction\",\n\t\t\t\t\t      h->transid, num_bytes, 1);\n\t\th->block_rsv = &root->fs_info->trans_block_rsv;\n\t\th->bytes_reserved = num_bytes;\n\t\th->reloc_reserved = reloc_reserved;\n\t}\n\th->qgroup_reserved = qgroup_reserved;\n\ngot_it:\n\tbtrfs_record_root_in_trans(h, root);\n\n\tif (!current->journal_info && type != TRANS_USERSPACE)\n\t\tcurrent->journal_info = h;\n\treturn h;\n\njoin_fail:\n\tif (type & __TRANS_FREEZABLE)\n\t\tsb_end_intwrite(root->fs_info->sb);\n\tkmem_cache_free(btrfs_trans_handle_cachep, h);\nalloc_fail:\n\tif (num_bytes)\n\t\tbtrfs_block_rsv_release(root, &root->fs_info->trans_block_rsv,\n\t\t\t\t\tnum_bytes);\nreserve_fail:\n\tif (qgroup_reserved)\n\t\tbtrfs_qgroup_free(root, qgroup_reserved);\n\treturn ERR_PTR(ret);\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"dev-replace.h\"",
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic struct btrfs_trans_handle *\nstart_transaction(struct btrfs_root *root, u64 num_items, unsigned int type,\n\t\t  enum btrfs_reserve_flush_enum flush)\n{\n\tstruct btrfs_trans_handle *h;\n\tstruct btrfs_transaction *cur_trans;\n\tu64 num_bytes = 0;\n\tu64 qgroup_reserved = 0;\n\tbool reloc_reserved = false;\n\tint ret;\n\n\t/* Send isn't supposed to start transactions. */\n\tASSERT(current->journal_info != BTRFS_SEND_TRANS_STUB);\n\n\tif (test_bit(BTRFS_FS_STATE_ERROR, &root->fs_info->fs_state))\n\t\treturn ERR_PTR(-EROFS);\n\n\tif (current->journal_info) {\n\t\tWARN_ON(type & TRANS_EXTWRITERS);\n\t\th = current->journal_info;\n\t\th->use_count++;\n\t\tWARN_ON(h->use_count > 2);\n\t\th->orig_rsv = h->block_rsv;\n\t\th->block_rsv = NULL;\n\t\tgoto got_it;\n\t}\n\n\t/*\n\t * Do the reservation before we join the transaction so we can do all\n\t * the appropriate flushing if need be.\n\t */\n\tif (num_items > 0 && root != root->fs_info->chunk_root) {\n\t\tif (root->fs_info->quota_enabled &&\n\t\t    is_fstree(root->root_key.objectid)) {\n\t\t\tqgroup_reserved = num_items * root->nodesize;\n\t\t\tret = btrfs_qgroup_reserve(root, qgroup_reserved);\n\t\t\tif (ret)\n\t\t\t\treturn ERR_PTR(ret);\n\t\t}\n\n\t\tnum_bytes = btrfs_calc_trans_metadata_size(root, num_items);\n\t\t/*\n\t\t * Do the reservation for the relocation root creation\n\t\t */\n\t\tif (need_reserve_reloc_root(root)) {\n\t\t\tnum_bytes += root->nodesize;\n\t\t\treloc_reserved = true;\n\t\t}\n\n\t\tret = btrfs_block_rsv_add(root,\n\t\t\t\t\t  &root->fs_info->trans_block_rsv,\n\t\t\t\t\t  num_bytes, flush);\n\t\tif (ret)\n\t\t\tgoto reserve_fail;\n\t}\nagain:\n\th = kmem_cache_alloc(btrfs_trans_handle_cachep, GFP_NOFS);\n\tif (!h) {\n\t\tret = -ENOMEM;\n\t\tgoto alloc_fail;\n\t}\n\n\t/*\n\t * If we are JOIN_NOLOCK we're already committing a transaction and\n\t * waiting on this guy, so we don't need to do the sb_start_intwrite\n\t * because we're already holding a ref.  We need this because we could\n\t * have raced in and did an fsync() on a file which can kick a commit\n\t * and then we deadlock with somebody doing a freeze.\n\t *\n\t * If we are ATTACH, it means we just want to catch the current\n\t * transaction and commit it, so we needn't do sb_start_intwrite(). \n\t */\n\tif (type & __TRANS_FREEZABLE)\n\t\tsb_start_intwrite(root->fs_info->sb);\n\n\tif (may_wait_transaction(root, type))\n\t\twait_current_trans(root);\n\n\tdo {\n\t\tret = join_transaction(root, type);\n\t\tif (ret == -EBUSY) {\n\t\t\twait_current_trans(root);\n\t\t\tif (unlikely(type == TRANS_ATTACH))\n\t\t\t\tret = -ENOENT;\n\t\t}\n\t} while (ret == -EBUSY);\n\n\tif (ret < 0) {\n\t\t/* We must get the transaction if we are JOIN_NOLOCK. */\n\t\tBUG_ON(type == TRANS_JOIN_NOLOCK);\n\t\tgoto join_fail;\n\t}\n\n\tcur_trans = root->fs_info->running_transaction;\n\n\th->transid = cur_trans->transid;\n\th->transaction = cur_trans;\n\th->blocks_used = 0;\n\th->bytes_reserved = 0;\n\th->root = root;\n\th->delayed_ref_updates = 0;\n\th->use_count = 1;\n\th->adding_csums = 0;\n\th->block_rsv = NULL;\n\th->orig_rsv = NULL;\n\th->aborted = 0;\n\th->qgroup_reserved = 0;\n\th->delayed_ref_elem.seq = 0;\n\th->type = type;\n\th->allocating_chunk = false;\n\th->reloc_reserved = false;\n\th->sync = false;\n\tINIT_LIST_HEAD(&h->qgroup_ref_list);\n\tINIT_LIST_HEAD(&h->new_bgs);\n\tINIT_LIST_HEAD(&h->ordered);\n\n\tsmp_mb();\n\tif (cur_trans->state >= TRANS_STATE_BLOCKED &&\n\t    may_wait_transaction(root, type)) {\n\t\tcurrent->journal_info = h;\n\t\tbtrfs_commit_transaction(h, root);\n\t\tgoto again;\n\t}\n\n\tif (num_bytes) {\n\t\ttrace_btrfs_space_reservation(root->fs_info, \"transaction\",\n\t\t\t\t\t      h->transid, num_bytes, 1);\n\t\th->block_rsv = &root->fs_info->trans_block_rsv;\n\t\th->bytes_reserved = num_bytes;\n\t\th->reloc_reserved = reloc_reserved;\n\t}\n\th->qgroup_reserved = qgroup_reserved;\n\ngot_it:\n\tbtrfs_record_root_in_trans(h, root);\n\n\tif (!current->journal_info && type != TRANS_USERSPACE)\n\t\tcurrent->journal_info = h;\n\treturn h;\n\njoin_fail:\n\tif (type & __TRANS_FREEZABLE)\n\t\tsb_end_intwrite(root->fs_info->sb);\n\tkmem_cache_free(btrfs_trans_handle_cachep, h);\nalloc_fail:\n\tif (num_bytes)\n\t\tbtrfs_block_rsv_release(root, &root->fs_info->trans_block_rsv,\n\t\t\t\t\tnum_bytes);\nreserve_fail:\n\tif (qgroup_reserved)\n\t\tbtrfs_qgroup_free(root, qgroup_reserved);\n\treturn ERR_PTR(ret);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstruct btrfs_trans_handle *btrfs_join_transaction_nolock(struct btrfs_root *root)\n{\n\treturn start_transaction(root, 0, TRANS_JOIN_NOLOCK, 0);\n}"
  },
  {
    "function_name": "btrfs_join_transaction",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
    "lines": "576-579",
    "snippet": "struct btrfs_trans_handle *btrfs_join_transaction(struct btrfs_root *root)\n{\n\treturn start_transaction(root, 0, TRANS_JOIN, 0);\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"dev-replace.h\"",
      "#include \"volumes.h\"",
      "#include \"inode-map.h\"",
      "#include \"tree-log.h\"",
      "#include \"locking.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/uuid.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/writeback.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "start_transaction",
          "args": [
            "root",
            "0",
            "TRANS_JOIN",
            "0"
          ],
          "line": 578
        },
        "resolved": true,
        "details": {
          "function_name": "start_transaction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
          "lines": "408-560",
          "snippet": "static struct btrfs_trans_handle *\nstart_transaction(struct btrfs_root *root, u64 num_items, unsigned int type,\n\t\t  enum btrfs_reserve_flush_enum flush)\n{\n\tstruct btrfs_trans_handle *h;\n\tstruct btrfs_transaction *cur_trans;\n\tu64 num_bytes = 0;\n\tu64 qgroup_reserved = 0;\n\tbool reloc_reserved = false;\n\tint ret;\n\n\t/* Send isn't supposed to start transactions. */\n\tASSERT(current->journal_info != BTRFS_SEND_TRANS_STUB);\n\n\tif (test_bit(BTRFS_FS_STATE_ERROR, &root->fs_info->fs_state))\n\t\treturn ERR_PTR(-EROFS);\n\n\tif (current->journal_info) {\n\t\tWARN_ON(type & TRANS_EXTWRITERS);\n\t\th = current->journal_info;\n\t\th->use_count++;\n\t\tWARN_ON(h->use_count > 2);\n\t\th->orig_rsv = h->block_rsv;\n\t\th->block_rsv = NULL;\n\t\tgoto got_it;\n\t}\n\n\t/*\n\t * Do the reservation before we join the transaction so we can do all\n\t * the appropriate flushing if need be.\n\t */\n\tif (num_items > 0 && root != root->fs_info->chunk_root) {\n\t\tif (root->fs_info->quota_enabled &&\n\t\t    is_fstree(root->root_key.objectid)) {\n\t\t\tqgroup_reserved = num_items * root->nodesize;\n\t\t\tret = btrfs_qgroup_reserve(root, qgroup_reserved);\n\t\t\tif (ret)\n\t\t\t\treturn ERR_PTR(ret);\n\t\t}\n\n\t\tnum_bytes = btrfs_calc_trans_metadata_size(root, num_items);\n\t\t/*\n\t\t * Do the reservation for the relocation root creation\n\t\t */\n\t\tif (need_reserve_reloc_root(root)) {\n\t\t\tnum_bytes += root->nodesize;\n\t\t\treloc_reserved = true;\n\t\t}\n\n\t\tret = btrfs_block_rsv_add(root,\n\t\t\t\t\t  &root->fs_info->trans_block_rsv,\n\t\t\t\t\t  num_bytes, flush);\n\t\tif (ret)\n\t\t\tgoto reserve_fail;\n\t}\nagain:\n\th = kmem_cache_alloc(btrfs_trans_handle_cachep, GFP_NOFS);\n\tif (!h) {\n\t\tret = -ENOMEM;\n\t\tgoto alloc_fail;\n\t}\n\n\t/*\n\t * If we are JOIN_NOLOCK we're already committing a transaction and\n\t * waiting on this guy, so we don't need to do the sb_start_intwrite\n\t * because we're already holding a ref.  We need this because we could\n\t * have raced in and did an fsync() on a file which can kick a commit\n\t * and then we deadlock with somebody doing a freeze.\n\t *\n\t * If we are ATTACH, it means we just want to catch the current\n\t * transaction and commit it, so we needn't do sb_start_intwrite(). \n\t */\n\tif (type & __TRANS_FREEZABLE)\n\t\tsb_start_intwrite(root->fs_info->sb);\n\n\tif (may_wait_transaction(root, type))\n\t\twait_current_trans(root);\n\n\tdo {\n\t\tret = join_transaction(root, type);\n\t\tif (ret == -EBUSY) {\n\t\t\twait_current_trans(root);\n\t\t\tif (unlikely(type == TRANS_ATTACH))\n\t\t\t\tret = -ENOENT;\n\t\t}\n\t} while (ret == -EBUSY);\n\n\tif (ret < 0) {\n\t\t/* We must get the transaction if we are JOIN_NOLOCK. */\n\t\tBUG_ON(type == TRANS_JOIN_NOLOCK);\n\t\tgoto join_fail;\n\t}\n\n\tcur_trans = root->fs_info->running_transaction;\n\n\th->transid = cur_trans->transid;\n\th->transaction = cur_trans;\n\th->blocks_used = 0;\n\th->bytes_reserved = 0;\n\th->root = root;\n\th->delayed_ref_updates = 0;\n\th->use_count = 1;\n\th->adding_csums = 0;\n\th->block_rsv = NULL;\n\th->orig_rsv = NULL;\n\th->aborted = 0;\n\th->qgroup_reserved = 0;\n\th->delayed_ref_elem.seq = 0;\n\th->type = type;\n\th->allocating_chunk = false;\n\th->reloc_reserved = false;\n\th->sync = false;\n\tINIT_LIST_HEAD(&h->qgroup_ref_list);\n\tINIT_LIST_HEAD(&h->new_bgs);\n\tINIT_LIST_HEAD(&h->ordered);\n\n\tsmp_mb();\n\tif (cur_trans->state >= TRANS_STATE_BLOCKED &&\n\t    may_wait_transaction(root, type)) {\n\t\tcurrent->journal_info = h;\n\t\tbtrfs_commit_transaction(h, root);\n\t\tgoto again;\n\t}\n\n\tif (num_bytes) {\n\t\ttrace_btrfs_space_reservation(root->fs_info, \"transaction\",\n\t\t\t\t\t      h->transid, num_bytes, 1);\n\t\th->block_rsv = &root->fs_info->trans_block_rsv;\n\t\th->bytes_reserved = num_bytes;\n\t\th->reloc_reserved = reloc_reserved;\n\t}\n\th->qgroup_reserved = qgroup_reserved;\n\ngot_it:\n\tbtrfs_record_root_in_trans(h, root);\n\n\tif (!current->journal_info && type != TRANS_USERSPACE)\n\t\tcurrent->journal_info = h;\n\treturn h;\n\njoin_fail:\n\tif (type & __TRANS_FREEZABLE)\n\t\tsb_end_intwrite(root->fs_info->sb);\n\tkmem_cache_free(btrfs_trans_handle_cachep, h);\nalloc_fail:\n\tif (num_bytes)\n\t\tbtrfs_block_rsv_release(root, &root->fs_info->trans_block_rsv,\n\t\t\t\t\tnum_bytes);\nreserve_fail:\n\tif (qgroup_reserved)\n\t\tbtrfs_qgroup_free(root, qgroup_reserved);\n\treturn ERR_PTR(ret);\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"dev-replace.h\"",
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic struct btrfs_trans_handle *\nstart_transaction(struct btrfs_root *root, u64 num_items, unsigned int type,\n\t\t  enum btrfs_reserve_flush_enum flush)\n{\n\tstruct btrfs_trans_handle *h;\n\tstruct btrfs_transaction *cur_trans;\n\tu64 num_bytes = 0;\n\tu64 qgroup_reserved = 0;\n\tbool reloc_reserved = false;\n\tint ret;\n\n\t/* Send isn't supposed to start transactions. */\n\tASSERT(current->journal_info != BTRFS_SEND_TRANS_STUB);\n\n\tif (test_bit(BTRFS_FS_STATE_ERROR, &root->fs_info->fs_state))\n\t\treturn ERR_PTR(-EROFS);\n\n\tif (current->journal_info) {\n\t\tWARN_ON(type & TRANS_EXTWRITERS);\n\t\th = current->journal_info;\n\t\th->use_count++;\n\t\tWARN_ON(h->use_count > 2);\n\t\th->orig_rsv = h->block_rsv;\n\t\th->block_rsv = NULL;\n\t\tgoto got_it;\n\t}\n\n\t/*\n\t * Do the reservation before we join the transaction so we can do all\n\t * the appropriate flushing if need be.\n\t */\n\tif (num_items > 0 && root != root->fs_info->chunk_root) {\n\t\tif (root->fs_info->quota_enabled &&\n\t\t    is_fstree(root->root_key.objectid)) {\n\t\t\tqgroup_reserved = num_items * root->nodesize;\n\t\t\tret = btrfs_qgroup_reserve(root, qgroup_reserved);\n\t\t\tif (ret)\n\t\t\t\treturn ERR_PTR(ret);\n\t\t}\n\n\t\tnum_bytes = btrfs_calc_trans_metadata_size(root, num_items);\n\t\t/*\n\t\t * Do the reservation for the relocation root creation\n\t\t */\n\t\tif (need_reserve_reloc_root(root)) {\n\t\t\tnum_bytes += root->nodesize;\n\t\t\treloc_reserved = true;\n\t\t}\n\n\t\tret = btrfs_block_rsv_add(root,\n\t\t\t\t\t  &root->fs_info->trans_block_rsv,\n\t\t\t\t\t  num_bytes, flush);\n\t\tif (ret)\n\t\t\tgoto reserve_fail;\n\t}\nagain:\n\th = kmem_cache_alloc(btrfs_trans_handle_cachep, GFP_NOFS);\n\tif (!h) {\n\t\tret = -ENOMEM;\n\t\tgoto alloc_fail;\n\t}\n\n\t/*\n\t * If we are JOIN_NOLOCK we're already committing a transaction and\n\t * waiting on this guy, so we don't need to do the sb_start_intwrite\n\t * because we're already holding a ref.  We need this because we could\n\t * have raced in and did an fsync() on a file which can kick a commit\n\t * and then we deadlock with somebody doing a freeze.\n\t *\n\t * If we are ATTACH, it means we just want to catch the current\n\t * transaction and commit it, so we needn't do sb_start_intwrite(). \n\t */\n\tif (type & __TRANS_FREEZABLE)\n\t\tsb_start_intwrite(root->fs_info->sb);\n\n\tif (may_wait_transaction(root, type))\n\t\twait_current_trans(root);\n\n\tdo {\n\t\tret = join_transaction(root, type);\n\t\tif (ret == -EBUSY) {\n\t\t\twait_current_trans(root);\n\t\t\tif (unlikely(type == TRANS_ATTACH))\n\t\t\t\tret = -ENOENT;\n\t\t}\n\t} while (ret == -EBUSY);\n\n\tif (ret < 0) {\n\t\t/* We must get the transaction if we are JOIN_NOLOCK. */\n\t\tBUG_ON(type == TRANS_JOIN_NOLOCK);\n\t\tgoto join_fail;\n\t}\n\n\tcur_trans = root->fs_info->running_transaction;\n\n\th->transid = cur_trans->transid;\n\th->transaction = cur_trans;\n\th->blocks_used = 0;\n\th->bytes_reserved = 0;\n\th->root = root;\n\th->delayed_ref_updates = 0;\n\th->use_count = 1;\n\th->adding_csums = 0;\n\th->block_rsv = NULL;\n\th->orig_rsv = NULL;\n\th->aborted = 0;\n\th->qgroup_reserved = 0;\n\th->delayed_ref_elem.seq = 0;\n\th->type = type;\n\th->allocating_chunk = false;\n\th->reloc_reserved = false;\n\th->sync = false;\n\tINIT_LIST_HEAD(&h->qgroup_ref_list);\n\tINIT_LIST_HEAD(&h->new_bgs);\n\tINIT_LIST_HEAD(&h->ordered);\n\n\tsmp_mb();\n\tif (cur_trans->state >= TRANS_STATE_BLOCKED &&\n\t    may_wait_transaction(root, type)) {\n\t\tcurrent->journal_info = h;\n\t\tbtrfs_commit_transaction(h, root);\n\t\tgoto again;\n\t}\n\n\tif (num_bytes) {\n\t\ttrace_btrfs_space_reservation(root->fs_info, \"transaction\",\n\t\t\t\t\t      h->transid, num_bytes, 1);\n\t\th->block_rsv = &root->fs_info->trans_block_rsv;\n\t\th->bytes_reserved = num_bytes;\n\t\th->reloc_reserved = reloc_reserved;\n\t}\n\th->qgroup_reserved = qgroup_reserved;\n\ngot_it:\n\tbtrfs_record_root_in_trans(h, root);\n\n\tif (!current->journal_info && type != TRANS_USERSPACE)\n\t\tcurrent->journal_info = h;\n\treturn h;\n\njoin_fail:\n\tif (type & __TRANS_FREEZABLE)\n\t\tsb_end_intwrite(root->fs_info->sb);\n\tkmem_cache_free(btrfs_trans_handle_cachep, h);\nalloc_fail:\n\tif (num_bytes)\n\t\tbtrfs_block_rsv_release(root, &root->fs_info->trans_block_rsv,\n\t\t\t\t\tnum_bytes);\nreserve_fail:\n\tif (qgroup_reserved)\n\t\tbtrfs_qgroup_free(root, qgroup_reserved);\n\treturn ERR_PTR(ret);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstruct btrfs_trans_handle *btrfs_join_transaction(struct btrfs_root *root)\n{\n\treturn start_transaction(root, 0, TRANS_JOIN, 0);\n}"
  },
  {
    "function_name": "btrfs_start_transaction_lflush",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
    "lines": "569-574",
    "snippet": "struct btrfs_trans_handle *btrfs_start_transaction_lflush(\n\t\t\t\t\tstruct btrfs_root *root, int num_items)\n{\n\treturn start_transaction(root, num_items, TRANS_START,\n\t\t\t\t BTRFS_RESERVE_FLUSH_LIMIT);\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"dev-replace.h\"",
      "#include \"volumes.h\"",
      "#include \"inode-map.h\"",
      "#include \"tree-log.h\"",
      "#include \"locking.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/uuid.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/writeback.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "start_transaction",
          "args": [
            "root",
            "num_items",
            "TRANS_START",
            "BTRFS_RESERVE_FLUSH_LIMIT"
          ],
          "line": 572
        },
        "resolved": true,
        "details": {
          "function_name": "start_transaction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
          "lines": "408-560",
          "snippet": "static struct btrfs_trans_handle *\nstart_transaction(struct btrfs_root *root, u64 num_items, unsigned int type,\n\t\t  enum btrfs_reserve_flush_enum flush)\n{\n\tstruct btrfs_trans_handle *h;\n\tstruct btrfs_transaction *cur_trans;\n\tu64 num_bytes = 0;\n\tu64 qgroup_reserved = 0;\n\tbool reloc_reserved = false;\n\tint ret;\n\n\t/* Send isn't supposed to start transactions. */\n\tASSERT(current->journal_info != BTRFS_SEND_TRANS_STUB);\n\n\tif (test_bit(BTRFS_FS_STATE_ERROR, &root->fs_info->fs_state))\n\t\treturn ERR_PTR(-EROFS);\n\n\tif (current->journal_info) {\n\t\tWARN_ON(type & TRANS_EXTWRITERS);\n\t\th = current->journal_info;\n\t\th->use_count++;\n\t\tWARN_ON(h->use_count > 2);\n\t\th->orig_rsv = h->block_rsv;\n\t\th->block_rsv = NULL;\n\t\tgoto got_it;\n\t}\n\n\t/*\n\t * Do the reservation before we join the transaction so we can do all\n\t * the appropriate flushing if need be.\n\t */\n\tif (num_items > 0 && root != root->fs_info->chunk_root) {\n\t\tif (root->fs_info->quota_enabled &&\n\t\t    is_fstree(root->root_key.objectid)) {\n\t\t\tqgroup_reserved = num_items * root->nodesize;\n\t\t\tret = btrfs_qgroup_reserve(root, qgroup_reserved);\n\t\t\tif (ret)\n\t\t\t\treturn ERR_PTR(ret);\n\t\t}\n\n\t\tnum_bytes = btrfs_calc_trans_metadata_size(root, num_items);\n\t\t/*\n\t\t * Do the reservation for the relocation root creation\n\t\t */\n\t\tif (need_reserve_reloc_root(root)) {\n\t\t\tnum_bytes += root->nodesize;\n\t\t\treloc_reserved = true;\n\t\t}\n\n\t\tret = btrfs_block_rsv_add(root,\n\t\t\t\t\t  &root->fs_info->trans_block_rsv,\n\t\t\t\t\t  num_bytes, flush);\n\t\tif (ret)\n\t\t\tgoto reserve_fail;\n\t}\nagain:\n\th = kmem_cache_alloc(btrfs_trans_handle_cachep, GFP_NOFS);\n\tif (!h) {\n\t\tret = -ENOMEM;\n\t\tgoto alloc_fail;\n\t}\n\n\t/*\n\t * If we are JOIN_NOLOCK we're already committing a transaction and\n\t * waiting on this guy, so we don't need to do the sb_start_intwrite\n\t * because we're already holding a ref.  We need this because we could\n\t * have raced in and did an fsync() on a file which can kick a commit\n\t * and then we deadlock with somebody doing a freeze.\n\t *\n\t * If we are ATTACH, it means we just want to catch the current\n\t * transaction and commit it, so we needn't do sb_start_intwrite(). \n\t */\n\tif (type & __TRANS_FREEZABLE)\n\t\tsb_start_intwrite(root->fs_info->sb);\n\n\tif (may_wait_transaction(root, type))\n\t\twait_current_trans(root);\n\n\tdo {\n\t\tret = join_transaction(root, type);\n\t\tif (ret == -EBUSY) {\n\t\t\twait_current_trans(root);\n\t\t\tif (unlikely(type == TRANS_ATTACH))\n\t\t\t\tret = -ENOENT;\n\t\t}\n\t} while (ret == -EBUSY);\n\n\tif (ret < 0) {\n\t\t/* We must get the transaction if we are JOIN_NOLOCK. */\n\t\tBUG_ON(type == TRANS_JOIN_NOLOCK);\n\t\tgoto join_fail;\n\t}\n\n\tcur_trans = root->fs_info->running_transaction;\n\n\th->transid = cur_trans->transid;\n\th->transaction = cur_trans;\n\th->blocks_used = 0;\n\th->bytes_reserved = 0;\n\th->root = root;\n\th->delayed_ref_updates = 0;\n\th->use_count = 1;\n\th->adding_csums = 0;\n\th->block_rsv = NULL;\n\th->orig_rsv = NULL;\n\th->aborted = 0;\n\th->qgroup_reserved = 0;\n\th->delayed_ref_elem.seq = 0;\n\th->type = type;\n\th->allocating_chunk = false;\n\th->reloc_reserved = false;\n\th->sync = false;\n\tINIT_LIST_HEAD(&h->qgroup_ref_list);\n\tINIT_LIST_HEAD(&h->new_bgs);\n\tINIT_LIST_HEAD(&h->ordered);\n\n\tsmp_mb();\n\tif (cur_trans->state >= TRANS_STATE_BLOCKED &&\n\t    may_wait_transaction(root, type)) {\n\t\tcurrent->journal_info = h;\n\t\tbtrfs_commit_transaction(h, root);\n\t\tgoto again;\n\t}\n\n\tif (num_bytes) {\n\t\ttrace_btrfs_space_reservation(root->fs_info, \"transaction\",\n\t\t\t\t\t      h->transid, num_bytes, 1);\n\t\th->block_rsv = &root->fs_info->trans_block_rsv;\n\t\th->bytes_reserved = num_bytes;\n\t\th->reloc_reserved = reloc_reserved;\n\t}\n\th->qgroup_reserved = qgroup_reserved;\n\ngot_it:\n\tbtrfs_record_root_in_trans(h, root);\n\n\tif (!current->journal_info && type != TRANS_USERSPACE)\n\t\tcurrent->journal_info = h;\n\treturn h;\n\njoin_fail:\n\tif (type & __TRANS_FREEZABLE)\n\t\tsb_end_intwrite(root->fs_info->sb);\n\tkmem_cache_free(btrfs_trans_handle_cachep, h);\nalloc_fail:\n\tif (num_bytes)\n\t\tbtrfs_block_rsv_release(root, &root->fs_info->trans_block_rsv,\n\t\t\t\t\tnum_bytes);\nreserve_fail:\n\tif (qgroup_reserved)\n\t\tbtrfs_qgroup_free(root, qgroup_reserved);\n\treturn ERR_PTR(ret);\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"dev-replace.h\"",
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic struct btrfs_trans_handle *\nstart_transaction(struct btrfs_root *root, u64 num_items, unsigned int type,\n\t\t  enum btrfs_reserve_flush_enum flush)\n{\n\tstruct btrfs_trans_handle *h;\n\tstruct btrfs_transaction *cur_trans;\n\tu64 num_bytes = 0;\n\tu64 qgroup_reserved = 0;\n\tbool reloc_reserved = false;\n\tint ret;\n\n\t/* Send isn't supposed to start transactions. */\n\tASSERT(current->journal_info != BTRFS_SEND_TRANS_STUB);\n\n\tif (test_bit(BTRFS_FS_STATE_ERROR, &root->fs_info->fs_state))\n\t\treturn ERR_PTR(-EROFS);\n\n\tif (current->journal_info) {\n\t\tWARN_ON(type & TRANS_EXTWRITERS);\n\t\th = current->journal_info;\n\t\th->use_count++;\n\t\tWARN_ON(h->use_count > 2);\n\t\th->orig_rsv = h->block_rsv;\n\t\th->block_rsv = NULL;\n\t\tgoto got_it;\n\t}\n\n\t/*\n\t * Do the reservation before we join the transaction so we can do all\n\t * the appropriate flushing if need be.\n\t */\n\tif (num_items > 0 && root != root->fs_info->chunk_root) {\n\t\tif (root->fs_info->quota_enabled &&\n\t\t    is_fstree(root->root_key.objectid)) {\n\t\t\tqgroup_reserved = num_items * root->nodesize;\n\t\t\tret = btrfs_qgroup_reserve(root, qgroup_reserved);\n\t\t\tif (ret)\n\t\t\t\treturn ERR_PTR(ret);\n\t\t}\n\n\t\tnum_bytes = btrfs_calc_trans_metadata_size(root, num_items);\n\t\t/*\n\t\t * Do the reservation for the relocation root creation\n\t\t */\n\t\tif (need_reserve_reloc_root(root)) {\n\t\t\tnum_bytes += root->nodesize;\n\t\t\treloc_reserved = true;\n\t\t}\n\n\t\tret = btrfs_block_rsv_add(root,\n\t\t\t\t\t  &root->fs_info->trans_block_rsv,\n\t\t\t\t\t  num_bytes, flush);\n\t\tif (ret)\n\t\t\tgoto reserve_fail;\n\t}\nagain:\n\th = kmem_cache_alloc(btrfs_trans_handle_cachep, GFP_NOFS);\n\tif (!h) {\n\t\tret = -ENOMEM;\n\t\tgoto alloc_fail;\n\t}\n\n\t/*\n\t * If we are JOIN_NOLOCK we're already committing a transaction and\n\t * waiting on this guy, so we don't need to do the sb_start_intwrite\n\t * because we're already holding a ref.  We need this because we could\n\t * have raced in and did an fsync() on a file which can kick a commit\n\t * and then we deadlock with somebody doing a freeze.\n\t *\n\t * If we are ATTACH, it means we just want to catch the current\n\t * transaction and commit it, so we needn't do sb_start_intwrite(). \n\t */\n\tif (type & __TRANS_FREEZABLE)\n\t\tsb_start_intwrite(root->fs_info->sb);\n\n\tif (may_wait_transaction(root, type))\n\t\twait_current_trans(root);\n\n\tdo {\n\t\tret = join_transaction(root, type);\n\t\tif (ret == -EBUSY) {\n\t\t\twait_current_trans(root);\n\t\t\tif (unlikely(type == TRANS_ATTACH))\n\t\t\t\tret = -ENOENT;\n\t\t}\n\t} while (ret == -EBUSY);\n\n\tif (ret < 0) {\n\t\t/* We must get the transaction if we are JOIN_NOLOCK. */\n\t\tBUG_ON(type == TRANS_JOIN_NOLOCK);\n\t\tgoto join_fail;\n\t}\n\n\tcur_trans = root->fs_info->running_transaction;\n\n\th->transid = cur_trans->transid;\n\th->transaction = cur_trans;\n\th->blocks_used = 0;\n\th->bytes_reserved = 0;\n\th->root = root;\n\th->delayed_ref_updates = 0;\n\th->use_count = 1;\n\th->adding_csums = 0;\n\th->block_rsv = NULL;\n\th->orig_rsv = NULL;\n\th->aborted = 0;\n\th->qgroup_reserved = 0;\n\th->delayed_ref_elem.seq = 0;\n\th->type = type;\n\th->allocating_chunk = false;\n\th->reloc_reserved = false;\n\th->sync = false;\n\tINIT_LIST_HEAD(&h->qgroup_ref_list);\n\tINIT_LIST_HEAD(&h->new_bgs);\n\tINIT_LIST_HEAD(&h->ordered);\n\n\tsmp_mb();\n\tif (cur_trans->state >= TRANS_STATE_BLOCKED &&\n\t    may_wait_transaction(root, type)) {\n\t\tcurrent->journal_info = h;\n\t\tbtrfs_commit_transaction(h, root);\n\t\tgoto again;\n\t}\n\n\tif (num_bytes) {\n\t\ttrace_btrfs_space_reservation(root->fs_info, \"transaction\",\n\t\t\t\t\t      h->transid, num_bytes, 1);\n\t\th->block_rsv = &root->fs_info->trans_block_rsv;\n\t\th->bytes_reserved = num_bytes;\n\t\th->reloc_reserved = reloc_reserved;\n\t}\n\th->qgroup_reserved = qgroup_reserved;\n\ngot_it:\n\tbtrfs_record_root_in_trans(h, root);\n\n\tif (!current->journal_info && type != TRANS_USERSPACE)\n\t\tcurrent->journal_info = h;\n\treturn h;\n\njoin_fail:\n\tif (type & __TRANS_FREEZABLE)\n\t\tsb_end_intwrite(root->fs_info->sb);\n\tkmem_cache_free(btrfs_trans_handle_cachep, h);\nalloc_fail:\n\tif (num_bytes)\n\t\tbtrfs_block_rsv_release(root, &root->fs_info->trans_block_rsv,\n\t\t\t\t\tnum_bytes);\nreserve_fail:\n\tif (qgroup_reserved)\n\t\tbtrfs_qgroup_free(root, qgroup_reserved);\n\treturn ERR_PTR(ret);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstruct btrfs_trans_handle *btrfs_start_transaction_lflush(\n\t\t\t\t\tstruct btrfs_root *root, int num_items)\n{\n\treturn start_transaction(root, num_items, TRANS_START,\n\t\t\t\t BTRFS_RESERVE_FLUSH_LIMIT);\n}"
  },
  {
    "function_name": "btrfs_start_transaction",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
    "lines": "562-567",
    "snippet": "struct btrfs_trans_handle *btrfs_start_transaction(struct btrfs_root *root,\n\t\t\t\t\t\t   int num_items)\n{\n\treturn start_transaction(root, num_items, TRANS_START,\n\t\t\t\t BTRFS_RESERVE_FLUSH_ALL);\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"dev-replace.h\"",
      "#include \"volumes.h\"",
      "#include \"inode-map.h\"",
      "#include \"tree-log.h\"",
      "#include \"locking.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/uuid.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/writeback.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "start_transaction",
          "args": [
            "root",
            "num_items",
            "TRANS_START",
            "BTRFS_RESERVE_FLUSH_ALL"
          ],
          "line": 565
        },
        "resolved": true,
        "details": {
          "function_name": "start_transaction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
          "lines": "408-560",
          "snippet": "static struct btrfs_trans_handle *\nstart_transaction(struct btrfs_root *root, u64 num_items, unsigned int type,\n\t\t  enum btrfs_reserve_flush_enum flush)\n{\n\tstruct btrfs_trans_handle *h;\n\tstruct btrfs_transaction *cur_trans;\n\tu64 num_bytes = 0;\n\tu64 qgroup_reserved = 0;\n\tbool reloc_reserved = false;\n\tint ret;\n\n\t/* Send isn't supposed to start transactions. */\n\tASSERT(current->journal_info != BTRFS_SEND_TRANS_STUB);\n\n\tif (test_bit(BTRFS_FS_STATE_ERROR, &root->fs_info->fs_state))\n\t\treturn ERR_PTR(-EROFS);\n\n\tif (current->journal_info) {\n\t\tWARN_ON(type & TRANS_EXTWRITERS);\n\t\th = current->journal_info;\n\t\th->use_count++;\n\t\tWARN_ON(h->use_count > 2);\n\t\th->orig_rsv = h->block_rsv;\n\t\th->block_rsv = NULL;\n\t\tgoto got_it;\n\t}\n\n\t/*\n\t * Do the reservation before we join the transaction so we can do all\n\t * the appropriate flushing if need be.\n\t */\n\tif (num_items > 0 && root != root->fs_info->chunk_root) {\n\t\tif (root->fs_info->quota_enabled &&\n\t\t    is_fstree(root->root_key.objectid)) {\n\t\t\tqgroup_reserved = num_items * root->nodesize;\n\t\t\tret = btrfs_qgroup_reserve(root, qgroup_reserved);\n\t\t\tif (ret)\n\t\t\t\treturn ERR_PTR(ret);\n\t\t}\n\n\t\tnum_bytes = btrfs_calc_trans_metadata_size(root, num_items);\n\t\t/*\n\t\t * Do the reservation for the relocation root creation\n\t\t */\n\t\tif (need_reserve_reloc_root(root)) {\n\t\t\tnum_bytes += root->nodesize;\n\t\t\treloc_reserved = true;\n\t\t}\n\n\t\tret = btrfs_block_rsv_add(root,\n\t\t\t\t\t  &root->fs_info->trans_block_rsv,\n\t\t\t\t\t  num_bytes, flush);\n\t\tif (ret)\n\t\t\tgoto reserve_fail;\n\t}\nagain:\n\th = kmem_cache_alloc(btrfs_trans_handle_cachep, GFP_NOFS);\n\tif (!h) {\n\t\tret = -ENOMEM;\n\t\tgoto alloc_fail;\n\t}\n\n\t/*\n\t * If we are JOIN_NOLOCK we're already committing a transaction and\n\t * waiting on this guy, so we don't need to do the sb_start_intwrite\n\t * because we're already holding a ref.  We need this because we could\n\t * have raced in and did an fsync() on a file which can kick a commit\n\t * and then we deadlock with somebody doing a freeze.\n\t *\n\t * If we are ATTACH, it means we just want to catch the current\n\t * transaction and commit it, so we needn't do sb_start_intwrite(). \n\t */\n\tif (type & __TRANS_FREEZABLE)\n\t\tsb_start_intwrite(root->fs_info->sb);\n\n\tif (may_wait_transaction(root, type))\n\t\twait_current_trans(root);\n\n\tdo {\n\t\tret = join_transaction(root, type);\n\t\tif (ret == -EBUSY) {\n\t\t\twait_current_trans(root);\n\t\t\tif (unlikely(type == TRANS_ATTACH))\n\t\t\t\tret = -ENOENT;\n\t\t}\n\t} while (ret == -EBUSY);\n\n\tif (ret < 0) {\n\t\t/* We must get the transaction if we are JOIN_NOLOCK. */\n\t\tBUG_ON(type == TRANS_JOIN_NOLOCK);\n\t\tgoto join_fail;\n\t}\n\n\tcur_trans = root->fs_info->running_transaction;\n\n\th->transid = cur_trans->transid;\n\th->transaction = cur_trans;\n\th->blocks_used = 0;\n\th->bytes_reserved = 0;\n\th->root = root;\n\th->delayed_ref_updates = 0;\n\th->use_count = 1;\n\th->adding_csums = 0;\n\th->block_rsv = NULL;\n\th->orig_rsv = NULL;\n\th->aborted = 0;\n\th->qgroup_reserved = 0;\n\th->delayed_ref_elem.seq = 0;\n\th->type = type;\n\th->allocating_chunk = false;\n\th->reloc_reserved = false;\n\th->sync = false;\n\tINIT_LIST_HEAD(&h->qgroup_ref_list);\n\tINIT_LIST_HEAD(&h->new_bgs);\n\tINIT_LIST_HEAD(&h->ordered);\n\n\tsmp_mb();\n\tif (cur_trans->state >= TRANS_STATE_BLOCKED &&\n\t    may_wait_transaction(root, type)) {\n\t\tcurrent->journal_info = h;\n\t\tbtrfs_commit_transaction(h, root);\n\t\tgoto again;\n\t}\n\n\tif (num_bytes) {\n\t\ttrace_btrfs_space_reservation(root->fs_info, \"transaction\",\n\t\t\t\t\t      h->transid, num_bytes, 1);\n\t\th->block_rsv = &root->fs_info->trans_block_rsv;\n\t\th->bytes_reserved = num_bytes;\n\t\th->reloc_reserved = reloc_reserved;\n\t}\n\th->qgroup_reserved = qgroup_reserved;\n\ngot_it:\n\tbtrfs_record_root_in_trans(h, root);\n\n\tif (!current->journal_info && type != TRANS_USERSPACE)\n\t\tcurrent->journal_info = h;\n\treturn h;\n\njoin_fail:\n\tif (type & __TRANS_FREEZABLE)\n\t\tsb_end_intwrite(root->fs_info->sb);\n\tkmem_cache_free(btrfs_trans_handle_cachep, h);\nalloc_fail:\n\tif (num_bytes)\n\t\tbtrfs_block_rsv_release(root, &root->fs_info->trans_block_rsv,\n\t\t\t\t\tnum_bytes);\nreserve_fail:\n\tif (qgroup_reserved)\n\t\tbtrfs_qgroup_free(root, qgroup_reserved);\n\treturn ERR_PTR(ret);\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"dev-replace.h\"",
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic struct btrfs_trans_handle *\nstart_transaction(struct btrfs_root *root, u64 num_items, unsigned int type,\n\t\t  enum btrfs_reserve_flush_enum flush)\n{\n\tstruct btrfs_trans_handle *h;\n\tstruct btrfs_transaction *cur_trans;\n\tu64 num_bytes = 0;\n\tu64 qgroup_reserved = 0;\n\tbool reloc_reserved = false;\n\tint ret;\n\n\t/* Send isn't supposed to start transactions. */\n\tASSERT(current->journal_info != BTRFS_SEND_TRANS_STUB);\n\n\tif (test_bit(BTRFS_FS_STATE_ERROR, &root->fs_info->fs_state))\n\t\treturn ERR_PTR(-EROFS);\n\n\tif (current->journal_info) {\n\t\tWARN_ON(type & TRANS_EXTWRITERS);\n\t\th = current->journal_info;\n\t\th->use_count++;\n\t\tWARN_ON(h->use_count > 2);\n\t\th->orig_rsv = h->block_rsv;\n\t\th->block_rsv = NULL;\n\t\tgoto got_it;\n\t}\n\n\t/*\n\t * Do the reservation before we join the transaction so we can do all\n\t * the appropriate flushing if need be.\n\t */\n\tif (num_items > 0 && root != root->fs_info->chunk_root) {\n\t\tif (root->fs_info->quota_enabled &&\n\t\t    is_fstree(root->root_key.objectid)) {\n\t\t\tqgroup_reserved = num_items * root->nodesize;\n\t\t\tret = btrfs_qgroup_reserve(root, qgroup_reserved);\n\t\t\tif (ret)\n\t\t\t\treturn ERR_PTR(ret);\n\t\t}\n\n\t\tnum_bytes = btrfs_calc_trans_metadata_size(root, num_items);\n\t\t/*\n\t\t * Do the reservation for the relocation root creation\n\t\t */\n\t\tif (need_reserve_reloc_root(root)) {\n\t\t\tnum_bytes += root->nodesize;\n\t\t\treloc_reserved = true;\n\t\t}\n\n\t\tret = btrfs_block_rsv_add(root,\n\t\t\t\t\t  &root->fs_info->trans_block_rsv,\n\t\t\t\t\t  num_bytes, flush);\n\t\tif (ret)\n\t\t\tgoto reserve_fail;\n\t}\nagain:\n\th = kmem_cache_alloc(btrfs_trans_handle_cachep, GFP_NOFS);\n\tif (!h) {\n\t\tret = -ENOMEM;\n\t\tgoto alloc_fail;\n\t}\n\n\t/*\n\t * If we are JOIN_NOLOCK we're already committing a transaction and\n\t * waiting on this guy, so we don't need to do the sb_start_intwrite\n\t * because we're already holding a ref.  We need this because we could\n\t * have raced in and did an fsync() on a file which can kick a commit\n\t * and then we deadlock with somebody doing a freeze.\n\t *\n\t * If we are ATTACH, it means we just want to catch the current\n\t * transaction and commit it, so we needn't do sb_start_intwrite(). \n\t */\n\tif (type & __TRANS_FREEZABLE)\n\t\tsb_start_intwrite(root->fs_info->sb);\n\n\tif (may_wait_transaction(root, type))\n\t\twait_current_trans(root);\n\n\tdo {\n\t\tret = join_transaction(root, type);\n\t\tif (ret == -EBUSY) {\n\t\t\twait_current_trans(root);\n\t\t\tif (unlikely(type == TRANS_ATTACH))\n\t\t\t\tret = -ENOENT;\n\t\t}\n\t} while (ret == -EBUSY);\n\n\tif (ret < 0) {\n\t\t/* We must get the transaction if we are JOIN_NOLOCK. */\n\t\tBUG_ON(type == TRANS_JOIN_NOLOCK);\n\t\tgoto join_fail;\n\t}\n\n\tcur_trans = root->fs_info->running_transaction;\n\n\th->transid = cur_trans->transid;\n\th->transaction = cur_trans;\n\th->blocks_used = 0;\n\th->bytes_reserved = 0;\n\th->root = root;\n\th->delayed_ref_updates = 0;\n\th->use_count = 1;\n\th->adding_csums = 0;\n\th->block_rsv = NULL;\n\th->orig_rsv = NULL;\n\th->aborted = 0;\n\th->qgroup_reserved = 0;\n\th->delayed_ref_elem.seq = 0;\n\th->type = type;\n\th->allocating_chunk = false;\n\th->reloc_reserved = false;\n\th->sync = false;\n\tINIT_LIST_HEAD(&h->qgroup_ref_list);\n\tINIT_LIST_HEAD(&h->new_bgs);\n\tINIT_LIST_HEAD(&h->ordered);\n\n\tsmp_mb();\n\tif (cur_trans->state >= TRANS_STATE_BLOCKED &&\n\t    may_wait_transaction(root, type)) {\n\t\tcurrent->journal_info = h;\n\t\tbtrfs_commit_transaction(h, root);\n\t\tgoto again;\n\t}\n\n\tif (num_bytes) {\n\t\ttrace_btrfs_space_reservation(root->fs_info, \"transaction\",\n\t\t\t\t\t      h->transid, num_bytes, 1);\n\t\th->block_rsv = &root->fs_info->trans_block_rsv;\n\t\th->bytes_reserved = num_bytes;\n\t\th->reloc_reserved = reloc_reserved;\n\t}\n\th->qgroup_reserved = qgroup_reserved;\n\ngot_it:\n\tbtrfs_record_root_in_trans(h, root);\n\n\tif (!current->journal_info && type != TRANS_USERSPACE)\n\t\tcurrent->journal_info = h;\n\treturn h;\n\njoin_fail:\n\tif (type & __TRANS_FREEZABLE)\n\t\tsb_end_intwrite(root->fs_info->sb);\n\tkmem_cache_free(btrfs_trans_handle_cachep, h);\nalloc_fail:\n\tif (num_bytes)\n\t\tbtrfs_block_rsv_release(root, &root->fs_info->trans_block_rsv,\n\t\t\t\t\tnum_bytes);\nreserve_fail:\n\tif (qgroup_reserved)\n\t\tbtrfs_qgroup_free(root, qgroup_reserved);\n\treturn ERR_PTR(ret);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstruct btrfs_trans_handle *btrfs_start_transaction(struct btrfs_root *root,\n\t\t\t\t\t\t   int num_items)\n{\n\treturn start_transaction(root, num_items, TRANS_START,\n\t\t\t\t BTRFS_RESERVE_FLUSH_ALL);\n}"
  },
  {
    "function_name": "start_transaction",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
    "lines": "408-560",
    "snippet": "static struct btrfs_trans_handle *\nstart_transaction(struct btrfs_root *root, u64 num_items, unsigned int type,\n\t\t  enum btrfs_reserve_flush_enum flush)\n{\n\tstruct btrfs_trans_handle *h;\n\tstruct btrfs_transaction *cur_trans;\n\tu64 num_bytes = 0;\n\tu64 qgroup_reserved = 0;\n\tbool reloc_reserved = false;\n\tint ret;\n\n\t/* Send isn't supposed to start transactions. */\n\tASSERT(current->journal_info != BTRFS_SEND_TRANS_STUB);\n\n\tif (test_bit(BTRFS_FS_STATE_ERROR, &root->fs_info->fs_state))\n\t\treturn ERR_PTR(-EROFS);\n\n\tif (current->journal_info) {\n\t\tWARN_ON(type & TRANS_EXTWRITERS);\n\t\th = current->journal_info;\n\t\th->use_count++;\n\t\tWARN_ON(h->use_count > 2);\n\t\th->orig_rsv = h->block_rsv;\n\t\th->block_rsv = NULL;\n\t\tgoto got_it;\n\t}\n\n\t/*\n\t * Do the reservation before we join the transaction so we can do all\n\t * the appropriate flushing if need be.\n\t */\n\tif (num_items > 0 && root != root->fs_info->chunk_root) {\n\t\tif (root->fs_info->quota_enabled &&\n\t\t    is_fstree(root->root_key.objectid)) {\n\t\t\tqgroup_reserved = num_items * root->nodesize;\n\t\t\tret = btrfs_qgroup_reserve(root, qgroup_reserved);\n\t\t\tif (ret)\n\t\t\t\treturn ERR_PTR(ret);\n\t\t}\n\n\t\tnum_bytes = btrfs_calc_trans_metadata_size(root, num_items);\n\t\t/*\n\t\t * Do the reservation for the relocation root creation\n\t\t */\n\t\tif (need_reserve_reloc_root(root)) {\n\t\t\tnum_bytes += root->nodesize;\n\t\t\treloc_reserved = true;\n\t\t}\n\n\t\tret = btrfs_block_rsv_add(root,\n\t\t\t\t\t  &root->fs_info->trans_block_rsv,\n\t\t\t\t\t  num_bytes, flush);\n\t\tif (ret)\n\t\t\tgoto reserve_fail;\n\t}\nagain:\n\th = kmem_cache_alloc(btrfs_trans_handle_cachep, GFP_NOFS);\n\tif (!h) {\n\t\tret = -ENOMEM;\n\t\tgoto alloc_fail;\n\t}\n\n\t/*\n\t * If we are JOIN_NOLOCK we're already committing a transaction and\n\t * waiting on this guy, so we don't need to do the sb_start_intwrite\n\t * because we're already holding a ref.  We need this because we could\n\t * have raced in and did an fsync() on a file which can kick a commit\n\t * and then we deadlock with somebody doing a freeze.\n\t *\n\t * If we are ATTACH, it means we just want to catch the current\n\t * transaction and commit it, so we needn't do sb_start_intwrite(). \n\t */\n\tif (type & __TRANS_FREEZABLE)\n\t\tsb_start_intwrite(root->fs_info->sb);\n\n\tif (may_wait_transaction(root, type))\n\t\twait_current_trans(root);\n\n\tdo {\n\t\tret = join_transaction(root, type);\n\t\tif (ret == -EBUSY) {\n\t\t\twait_current_trans(root);\n\t\t\tif (unlikely(type == TRANS_ATTACH))\n\t\t\t\tret = -ENOENT;\n\t\t}\n\t} while (ret == -EBUSY);\n\n\tif (ret < 0) {\n\t\t/* We must get the transaction if we are JOIN_NOLOCK. */\n\t\tBUG_ON(type == TRANS_JOIN_NOLOCK);\n\t\tgoto join_fail;\n\t}\n\n\tcur_trans = root->fs_info->running_transaction;\n\n\th->transid = cur_trans->transid;\n\th->transaction = cur_trans;\n\th->blocks_used = 0;\n\th->bytes_reserved = 0;\n\th->root = root;\n\th->delayed_ref_updates = 0;\n\th->use_count = 1;\n\th->adding_csums = 0;\n\th->block_rsv = NULL;\n\th->orig_rsv = NULL;\n\th->aborted = 0;\n\th->qgroup_reserved = 0;\n\th->delayed_ref_elem.seq = 0;\n\th->type = type;\n\th->allocating_chunk = false;\n\th->reloc_reserved = false;\n\th->sync = false;\n\tINIT_LIST_HEAD(&h->qgroup_ref_list);\n\tINIT_LIST_HEAD(&h->new_bgs);\n\tINIT_LIST_HEAD(&h->ordered);\n\n\tsmp_mb();\n\tif (cur_trans->state >= TRANS_STATE_BLOCKED &&\n\t    may_wait_transaction(root, type)) {\n\t\tcurrent->journal_info = h;\n\t\tbtrfs_commit_transaction(h, root);\n\t\tgoto again;\n\t}\n\n\tif (num_bytes) {\n\t\ttrace_btrfs_space_reservation(root->fs_info, \"transaction\",\n\t\t\t\t\t      h->transid, num_bytes, 1);\n\t\th->block_rsv = &root->fs_info->trans_block_rsv;\n\t\th->bytes_reserved = num_bytes;\n\t\th->reloc_reserved = reloc_reserved;\n\t}\n\th->qgroup_reserved = qgroup_reserved;\n\ngot_it:\n\tbtrfs_record_root_in_trans(h, root);\n\n\tif (!current->journal_info && type != TRANS_USERSPACE)\n\t\tcurrent->journal_info = h;\n\treturn h;\n\njoin_fail:\n\tif (type & __TRANS_FREEZABLE)\n\t\tsb_end_intwrite(root->fs_info->sb);\n\tkmem_cache_free(btrfs_trans_handle_cachep, h);\nalloc_fail:\n\tif (num_bytes)\n\t\tbtrfs_block_rsv_release(root, &root->fs_info->trans_block_rsv,\n\t\t\t\t\tnum_bytes);\nreserve_fail:\n\tif (qgroup_reserved)\n\t\tbtrfs_qgroup_free(root, qgroup_reserved);\n\treturn ERR_PTR(ret);\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"dev-replace.h\"",
      "#include \"volumes.h\"",
      "#include \"inode-map.h\"",
      "#include \"tree-log.h\"",
      "#include \"locking.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/uuid.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/writeback.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "ret"
          ],
          "line": 559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_qgroup_free",
          "args": [
            "root",
            "qgroup_reserved"
          ],
          "line": 558
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_qgroup_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/qgroup.c",
          "lines": "2448-2499",
          "snippet": "void btrfs_qgroup_free(struct btrfs_root *root, u64 num_bytes)\n{\n\tstruct btrfs_root *quota_root;\n\tstruct btrfs_qgroup *qgroup;\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tstruct ulist_node *unode;\n\tstruct ulist_iterator uiter;\n\tu64 ref_root = root->root_key.objectid;\n\tint ret = 0;\n\n\tif (!is_fstree(ref_root))\n\t\treturn;\n\n\tif (num_bytes == 0)\n\t\treturn;\n\n\tspin_lock(&fs_info->qgroup_lock);\n\n\tquota_root = fs_info->quota_root;\n\tif (!quota_root)\n\t\tgoto out;\n\n\tqgroup = find_qgroup_rb(fs_info, ref_root);\n\tif (!qgroup)\n\t\tgoto out;\n\n\tulist_reinit(fs_info->qgroup_ulist);\n\tret = ulist_add(fs_info->qgroup_ulist, qgroup->qgroupid,\n\t\t\t(uintptr_t)qgroup, GFP_ATOMIC);\n\tif (ret < 0)\n\t\tgoto out;\n\tULIST_ITER_INIT(&uiter);\n\twhile ((unode = ulist_next(fs_info->qgroup_ulist, &uiter))) {\n\t\tstruct btrfs_qgroup *qg;\n\t\tstruct btrfs_qgroup_list *glist;\n\n\t\tqg = u64_to_ptr(unode->aux);\n\n\t\tqg->reserved -= num_bytes;\n\n\t\tlist_for_each_entry(glist, &qg->groups, next_group) {\n\t\t\tret = ulist_add(fs_info->qgroup_ulist,\n\t\t\t\t\tglist->group->qgroupid,\n\t\t\t\t\t(uintptr_t)glist->group, GFP_ATOMIC);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\tspin_unlock(&fs_info->qgroup_lock);\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"ulist.h\"",
            "#include \"locking.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"ctree.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"ulist.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);\n\nvoid btrfs_qgroup_free(struct btrfs_root *root, u64 num_bytes)\n{\n\tstruct btrfs_root *quota_root;\n\tstruct btrfs_qgroup *qgroup;\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tstruct ulist_node *unode;\n\tstruct ulist_iterator uiter;\n\tu64 ref_root = root->root_key.objectid;\n\tint ret = 0;\n\n\tif (!is_fstree(ref_root))\n\t\treturn;\n\n\tif (num_bytes == 0)\n\t\treturn;\n\n\tspin_lock(&fs_info->qgroup_lock);\n\n\tquota_root = fs_info->quota_root;\n\tif (!quota_root)\n\t\tgoto out;\n\n\tqgroup = find_qgroup_rb(fs_info, ref_root);\n\tif (!qgroup)\n\t\tgoto out;\n\n\tulist_reinit(fs_info->qgroup_ulist);\n\tret = ulist_add(fs_info->qgroup_ulist, qgroup->qgroupid,\n\t\t\t(uintptr_t)qgroup, GFP_ATOMIC);\n\tif (ret < 0)\n\t\tgoto out;\n\tULIST_ITER_INIT(&uiter);\n\twhile ((unode = ulist_next(fs_info->qgroup_ulist, &uiter))) {\n\t\tstruct btrfs_qgroup *qg;\n\t\tstruct btrfs_qgroup_list *glist;\n\n\t\tqg = u64_to_ptr(unode->aux);\n\n\t\tqg->reserved -= num_bytes;\n\n\t\tlist_for_each_entry(glist, &qg->groups, next_group) {\n\t\t\tret = ulist_add(fs_info->qgroup_ulist,\n\t\t\t\t\tglist->group->qgroupid,\n\t\t\t\t\t(uintptr_t)glist->group, GFP_ATOMIC);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\tspin_unlock(&fs_info->qgroup_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_block_rsv_release",
          "args": [
            "root",
            "&root->fs_info->trans_block_rsv",
            "num_bytes"
          ],
          "line": 554
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_block_rsv_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent-tree.c",
          "lines": "4776-4786",
          "snippet": "void btrfs_block_rsv_release(struct btrfs_root *root,\n\t\t\t     struct btrfs_block_rsv *block_rsv,\n\t\t\t     u64 num_bytes)\n{\n\tstruct btrfs_block_rsv *global_rsv = &root->fs_info->global_block_rsv;\n\tif (global_rsv == block_rsv ||\n\t    block_rsv->space_info != global_rsv->space_info)\n\t\tglobal_rsv = NULL;\n\tblock_rsv_release_bytes(root->fs_info, block_rsv, global_rsv,\n\t\t\t\tnum_bytes);\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"math.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include \"hash.h\"",
            "#include <linux/percpu_counter.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int block_rsv_use_bytes(struct btrfs_block_rsv *block_rsv,\n\t\t\t       u64 num_bytes);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"math.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include \"hash.h\"\n#include <linux/percpu_counter.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n#include <linux/rcupdate.h>\n#include <linux/sort.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic int block_rsv_use_bytes(struct btrfs_block_rsv *block_rsv,\n\t\t\t       u64 num_bytes);\nstatic noinline struct;\n\nvoid btrfs_block_rsv_release(struct btrfs_root *root,\n\t\t\t     struct btrfs_block_rsv *block_rsv,\n\t\t\t     u64 num_bytes)\n{\n\tstruct btrfs_block_rsv *global_rsv = &root->fs_info->global_block_rsv;\n\tif (global_rsv == block_rsv ||\n\t    block_rsv->space_info != global_rsv->space_info)\n\t\tglobal_rsv = NULL;\n\tblock_rsv_release_bytes(root->fs_info, block_rsv, global_rsv,\n\t\t\t\tnum_bytes);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "btrfs_trans_handle_cachep",
            "h"
          ],
          "line": 551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_end_intwrite",
          "args": [
            "root->fs_info->sb"
          ],
          "line": 550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_record_root_in_trans",
          "args": [
            "h",
            "root"
          ],
          "line": 542
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_record_root_in_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
          "lines": "330-350",
          "snippet": "int btrfs_record_root_in_trans(struct btrfs_trans_handle *trans,\n\t\t\t       struct btrfs_root *root)\n{\n\tif (!test_bit(BTRFS_ROOT_REF_COWS, &root->state))\n\t\treturn 0;\n\n\t/*\n\t * see record_root_in_trans for comments about IN_TRANS_SETUP usage\n\t * and barriers\n\t */\n\tsmp_rmb();\n\tif (root->last_trans == trans->transid &&\n\t    !test_bit(BTRFS_ROOT_IN_TRANS_SETUP, &root->state))\n\t\treturn 0;\n\n\tmutex_lock(&root->fs_info->reloc_mutex);\n\trecord_root_in_trans(trans, root);\n\tmutex_unlock(&root->fs_info->reloc_mutex);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"dev-replace.h\"",
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint btrfs_record_root_in_trans(struct btrfs_trans_handle *trans,\n\t\t\t       struct btrfs_root *root)\n{\n\tif (!test_bit(BTRFS_ROOT_REF_COWS, &root->state))\n\t\treturn 0;\n\n\t/*\n\t * see record_root_in_trans for comments about IN_TRANS_SETUP usage\n\t * and barriers\n\t */\n\tsmp_rmb();\n\tif (root->last_trans == trans->transid &&\n\t    !test_bit(BTRFS_ROOT_IN_TRANS_SETUP, &root->state))\n\t\treturn 0;\n\n\tmutex_lock(&root->fs_info->reloc_mutex);\n\trecord_root_in_trans(trans, root);\n\tmutex_unlock(&root->fs_info->reloc_mutex);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_btrfs_space_reservation",
          "args": [
            "root->fs_info",
            "\"transaction\"",
            "h->transid",
            "num_bytes",
            "1"
          ],
          "line": 533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_commit_transaction",
          "args": [
            "h",
            "root"
          ],
          "line": 528
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_commit_transaction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
          "lines": "1764-2099",
          "snippet": "int btrfs_commit_transaction(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root)\n{\n\tstruct btrfs_transaction *cur_trans = trans->transaction;\n\tstruct btrfs_transaction *prev_trans = NULL;\n\tstruct btrfs_inode *btree_ino = BTRFS_I(root->fs_info->btree_inode);\n\tint ret;\n\n\t/* Stop the commit early if ->aborted is set */\n\tif (unlikely(ACCESS_ONCE(cur_trans->aborted))) {\n\t\tret = cur_trans->aborted;\n\t\tbtrfs_end_transaction(trans, root);\n\t\treturn ret;\n\t}\n\n\t/* make a pass through all the delayed refs we have so far\n\t * any runnings procs may add more while we are here\n\t */\n\tret = btrfs_run_delayed_refs(trans, root, 0);\n\tif (ret) {\n\t\tbtrfs_end_transaction(trans, root);\n\t\treturn ret;\n\t}\n\n\tbtrfs_trans_release_metadata(trans, root);\n\ttrans->block_rsv = NULL;\n\tif (trans->qgroup_reserved) {\n\t\tbtrfs_qgroup_free(root, trans->qgroup_reserved);\n\t\ttrans->qgroup_reserved = 0;\n\t}\n\n\tcur_trans = trans->transaction;\n\n\t/*\n\t * set the flushing flag so procs in this transaction have to\n\t * start sending their work down.\n\t */\n\tcur_trans->delayed_refs.flushing = 1;\n\tsmp_wmb();\n\n\tif (!list_empty(&trans->new_bgs))\n\t\tbtrfs_create_pending_block_groups(trans, root);\n\n\tret = btrfs_run_delayed_refs(trans, root, 0);\n\tif (ret) {\n\t\tbtrfs_end_transaction(trans, root);\n\t\treturn ret;\n\t}\n\n\tspin_lock(&root->fs_info->trans_lock);\n\tlist_splice(&trans->ordered, &cur_trans->pending_ordered);\n\tif (cur_trans->state >= TRANS_STATE_COMMIT_START) {\n\t\tspin_unlock(&root->fs_info->trans_lock);\n\t\tatomic_inc(&cur_trans->use_count);\n\t\tret = btrfs_end_transaction(trans, root);\n\n\t\twait_for_commit(root, cur_trans);\n\n\t\tif (unlikely(cur_trans->aborted))\n\t\t\tret = cur_trans->aborted;\n\n\t\tbtrfs_put_transaction(cur_trans);\n\n\t\treturn ret;\n\t}\n\n\tcur_trans->state = TRANS_STATE_COMMIT_START;\n\twake_up(&root->fs_info->transaction_blocked_wait);\n\n\tif (cur_trans->list.prev != &root->fs_info->trans_list) {\n\t\tprev_trans = list_entry(cur_trans->list.prev,\n\t\t\t\t\tstruct btrfs_transaction, list);\n\t\tif (prev_trans->state != TRANS_STATE_COMPLETED) {\n\t\t\tatomic_inc(&prev_trans->use_count);\n\t\t\tspin_unlock(&root->fs_info->trans_lock);\n\n\t\t\twait_for_commit(root, prev_trans);\n\n\t\t\tbtrfs_put_transaction(prev_trans);\n\t\t} else {\n\t\t\tspin_unlock(&root->fs_info->trans_lock);\n\t\t}\n\t} else {\n\t\tspin_unlock(&root->fs_info->trans_lock);\n\t}\n\n\textwriter_counter_dec(cur_trans, trans->type);\n\n\tret = btrfs_start_delalloc_flush(root->fs_info);\n\tif (ret)\n\t\tgoto cleanup_transaction;\n\n\tret = btrfs_run_delayed_items(trans, root);\n\tif (ret)\n\t\tgoto cleanup_transaction;\n\n\twait_event(cur_trans->writer_wait,\n\t\t   extwriter_counter_read(cur_trans) == 0);\n\n\t/* some pending stuffs might be added after the previous flush. */\n\tret = btrfs_run_delayed_items(trans, root);\n\tif (ret)\n\t\tgoto cleanup_transaction;\n\n\tbtrfs_wait_delalloc_flush(root->fs_info);\n\n\tbtrfs_wait_pending_ordered(cur_trans, root->fs_info);\n\n\tbtrfs_scrub_pause(root);\n\t/*\n\t * Ok now we need to make sure to block out any other joins while we\n\t * commit the transaction.  We could have started a join before setting\n\t * COMMIT_DOING so make sure to wait for num_writers to == 1 again.\n\t */\n\tspin_lock(&root->fs_info->trans_lock);\n\tcur_trans->state = TRANS_STATE_COMMIT_DOING;\n\tspin_unlock(&root->fs_info->trans_lock);\n\twait_event(cur_trans->writer_wait,\n\t\t   atomic_read(&cur_trans->num_writers) == 1);\n\n\t/* ->aborted might be set after the previous check, so check it */\n\tif (unlikely(ACCESS_ONCE(cur_trans->aborted))) {\n\t\tret = cur_trans->aborted;\n\t\tgoto scrub_continue;\n\t}\n\t/*\n\t * the reloc mutex makes sure that we stop\n\t * the balancing code from coming in and moving\n\t * extents around in the middle of the commit\n\t */\n\tmutex_lock(&root->fs_info->reloc_mutex);\n\n\t/*\n\t * We needn't worry about the delayed items because we will\n\t * deal with them in create_pending_snapshot(), which is the\n\t * core function of the snapshot creation.\n\t */\n\tret = create_pending_snapshots(trans, root->fs_info);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * We insert the dir indexes of the snapshots and update the inode\n\t * of the snapshots' parents after the snapshot creation, so there\n\t * are some delayed items which are not dealt with. Now deal with\n\t * them.\n\t *\n\t * We needn't worry that this operation will corrupt the snapshots,\n\t * because all the tree which are snapshoted will be forced to COW\n\t * the nodes and leaves.\n\t */\n\tret = btrfs_run_delayed_items(trans, root);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\tret = btrfs_run_delayed_refs(trans, root, (unsigned long)-1);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * make sure none of the code above managed to slip in a\n\t * delayed item\n\t */\n\tbtrfs_assert_delayed_root_empty(root);\n\n\tWARN_ON(cur_trans != trans->transaction);\n\n\t/* btrfs_commit_tree_roots is responsible for getting the\n\t * various roots consistent with each other.  Every pointer\n\t * in the tree of tree roots has to point to the most up to date\n\t * root for every subvolume and other tree.  So, we have to keep\n\t * the tree logging code from jumping in and changing any\n\t * of the trees.\n\t *\n\t * At this point in the commit, there can't be any tree-log\n\t * writers, but a little lower down we drop the trans mutex\n\t * and let new people in.  By holding the tree_log_mutex\n\t * from now until after the super is written, we avoid races\n\t * with the tree-log code.\n\t */\n\tmutex_lock(&root->fs_info->tree_log_mutex);\n\n\tret = commit_fs_roots(trans, root);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * Since the transaction is done, we can apply the pending changes\n\t * before the next transaction.\n\t */\n\tbtrfs_apply_pending_changes(root->fs_info);\n\n\t/* commit_fs_roots gets rid of all the tree log roots, it is now\n\t * safe to free the root of tree log roots\n\t */\n\tbtrfs_free_log_root_tree(trans, root->fs_info);\n\n\tret = commit_cowonly_roots(trans, root);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * The tasks which save the space cache and inode cache may also\n\t * update ->aborted, check it.\n\t */\n\tif (unlikely(ACCESS_ONCE(cur_trans->aborted))) {\n\t\tret = cur_trans->aborted;\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\tbtrfs_prepare_extent_commit(trans, root);\n\n\tcur_trans = root->fs_info->running_transaction;\n\n\tbtrfs_set_root_node(&root->fs_info->tree_root->root_item,\n\t\t\t    root->fs_info->tree_root->node);\n\tlist_add_tail(&root->fs_info->tree_root->dirty_list,\n\t\t      &cur_trans->switch_commits);\n\n\tbtrfs_set_root_node(&root->fs_info->chunk_root->root_item,\n\t\t\t    root->fs_info->chunk_root->node);\n\tlist_add_tail(&root->fs_info->chunk_root->dirty_list,\n\t\t      &cur_trans->switch_commits);\n\n\tswitch_commit_roots(cur_trans, root->fs_info);\n\n\tassert_qgroups_uptodate(trans);\n\tASSERT(list_empty(&cur_trans->dirty_bgs));\n\tupdate_super_roots(root);\n\n\tbtrfs_set_super_log_root(root->fs_info->super_copy, 0);\n\tbtrfs_set_super_log_root_level(root->fs_info->super_copy, 0);\n\tmemcpy(root->fs_info->super_for_commit, root->fs_info->super_copy,\n\t       sizeof(*root->fs_info->super_copy));\n\n\tbtrfs_update_commit_device_size(root->fs_info);\n\tbtrfs_update_commit_device_bytes_used(root, cur_trans);\n\n\tclear_bit(BTRFS_INODE_BTREE_LOG1_ERR, &btree_ino->runtime_flags);\n\tclear_bit(BTRFS_INODE_BTREE_LOG2_ERR, &btree_ino->runtime_flags);\n\n\tspin_lock(&root->fs_info->trans_lock);\n\tcur_trans->state = TRANS_STATE_UNBLOCKED;\n\troot->fs_info->running_transaction = NULL;\n\tspin_unlock(&root->fs_info->trans_lock);\n\tmutex_unlock(&root->fs_info->reloc_mutex);\n\n\twake_up(&root->fs_info->transaction_wait);\n\n\tret = btrfs_write_and_wait_transaction(trans, root);\n\tif (ret) {\n\t\tbtrfs_error(root->fs_info, ret,\n\t\t\t    \"Error while writing out transaction\");\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\tret = write_ctree_super(trans, root, 0);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * the super is written, we can safely allow the tree-loggers\n\t * to go about their business\n\t */\n\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\n\tbtrfs_finish_extent_commit(trans, root);\n\n\tif (cur_trans->have_free_bgs)\n\t\tbtrfs_clear_space_info_full(root->fs_info);\n\n\troot->fs_info->last_trans_committed = cur_trans->transid;\n\t/*\n\t * We needn't acquire the lock here because there is no other task\n\t * which can change it.\n\t */\n\tcur_trans->state = TRANS_STATE_COMPLETED;\n\twake_up(&cur_trans->commit_wait);\n\n\tspin_lock(&root->fs_info->trans_lock);\n\tlist_del_init(&cur_trans->list);\n\tspin_unlock(&root->fs_info->trans_lock);\n\n\tbtrfs_put_transaction(cur_trans);\n\tbtrfs_put_transaction(cur_trans);\n\n\tif (trans->type & __TRANS_FREEZABLE)\n\t\tsb_end_intwrite(root->fs_info->sb);\n\n\ttrace_btrfs_transaction_commit(root);\n\n\tbtrfs_scrub_continue(root);\n\n\tif (current->journal_info == trans)\n\t\tcurrent->journal_info = NULL;\n\n\tkmem_cache_free(btrfs_trans_handle_cachep, trans);\n\n\tif (current != root->fs_info->transaction_kthread)\n\t\tbtrfs_run_delayed_iputs(root);\n\n\treturn ret;\n\nscrub_continue:\n\tbtrfs_scrub_continue(root);\ncleanup_transaction:\n\tbtrfs_trans_release_metadata(trans, root);\n\ttrans->block_rsv = NULL;\n\tif (trans->qgroup_reserved) {\n\t\tbtrfs_qgroup_free(root, trans->qgroup_reserved);\n\t\ttrans->qgroup_reserved = 0;\n\t}\n\tbtrfs_warn(root->fs_info, \"Skipping commit of aborted transaction.\");\n\tif (current->journal_info == trans)\n\t\tcurrent->journal_info = NULL;\n\tcleanup_transaction(trans, root, ret);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"dev-replace.h\"",
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint btrfs_commit_transaction(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root)\n{\n\tstruct btrfs_transaction *cur_trans = trans->transaction;\n\tstruct btrfs_transaction *prev_trans = NULL;\n\tstruct btrfs_inode *btree_ino = BTRFS_I(root->fs_info->btree_inode);\n\tint ret;\n\n\t/* Stop the commit early if ->aborted is set */\n\tif (unlikely(ACCESS_ONCE(cur_trans->aborted))) {\n\t\tret = cur_trans->aborted;\n\t\tbtrfs_end_transaction(trans, root);\n\t\treturn ret;\n\t}\n\n\t/* make a pass through all the delayed refs we have so far\n\t * any runnings procs may add more while we are here\n\t */\n\tret = btrfs_run_delayed_refs(trans, root, 0);\n\tif (ret) {\n\t\tbtrfs_end_transaction(trans, root);\n\t\treturn ret;\n\t}\n\n\tbtrfs_trans_release_metadata(trans, root);\n\ttrans->block_rsv = NULL;\n\tif (trans->qgroup_reserved) {\n\t\tbtrfs_qgroup_free(root, trans->qgroup_reserved);\n\t\ttrans->qgroup_reserved = 0;\n\t}\n\n\tcur_trans = trans->transaction;\n\n\t/*\n\t * set the flushing flag so procs in this transaction have to\n\t * start sending their work down.\n\t */\n\tcur_trans->delayed_refs.flushing = 1;\n\tsmp_wmb();\n\n\tif (!list_empty(&trans->new_bgs))\n\t\tbtrfs_create_pending_block_groups(trans, root);\n\n\tret = btrfs_run_delayed_refs(trans, root, 0);\n\tif (ret) {\n\t\tbtrfs_end_transaction(trans, root);\n\t\treturn ret;\n\t}\n\n\tspin_lock(&root->fs_info->trans_lock);\n\tlist_splice(&trans->ordered, &cur_trans->pending_ordered);\n\tif (cur_trans->state >= TRANS_STATE_COMMIT_START) {\n\t\tspin_unlock(&root->fs_info->trans_lock);\n\t\tatomic_inc(&cur_trans->use_count);\n\t\tret = btrfs_end_transaction(trans, root);\n\n\t\twait_for_commit(root, cur_trans);\n\n\t\tif (unlikely(cur_trans->aborted))\n\t\t\tret = cur_trans->aborted;\n\n\t\tbtrfs_put_transaction(cur_trans);\n\n\t\treturn ret;\n\t}\n\n\tcur_trans->state = TRANS_STATE_COMMIT_START;\n\twake_up(&root->fs_info->transaction_blocked_wait);\n\n\tif (cur_trans->list.prev != &root->fs_info->trans_list) {\n\t\tprev_trans = list_entry(cur_trans->list.prev,\n\t\t\t\t\tstruct btrfs_transaction, list);\n\t\tif (prev_trans->state != TRANS_STATE_COMPLETED) {\n\t\t\tatomic_inc(&prev_trans->use_count);\n\t\t\tspin_unlock(&root->fs_info->trans_lock);\n\n\t\t\twait_for_commit(root, prev_trans);\n\n\t\t\tbtrfs_put_transaction(prev_trans);\n\t\t} else {\n\t\t\tspin_unlock(&root->fs_info->trans_lock);\n\t\t}\n\t} else {\n\t\tspin_unlock(&root->fs_info->trans_lock);\n\t}\n\n\textwriter_counter_dec(cur_trans, trans->type);\n\n\tret = btrfs_start_delalloc_flush(root->fs_info);\n\tif (ret)\n\t\tgoto cleanup_transaction;\n\n\tret = btrfs_run_delayed_items(trans, root);\n\tif (ret)\n\t\tgoto cleanup_transaction;\n\n\twait_event(cur_trans->writer_wait,\n\t\t   extwriter_counter_read(cur_trans) == 0);\n\n\t/* some pending stuffs might be added after the previous flush. */\n\tret = btrfs_run_delayed_items(trans, root);\n\tif (ret)\n\t\tgoto cleanup_transaction;\n\n\tbtrfs_wait_delalloc_flush(root->fs_info);\n\n\tbtrfs_wait_pending_ordered(cur_trans, root->fs_info);\n\n\tbtrfs_scrub_pause(root);\n\t/*\n\t * Ok now we need to make sure to block out any other joins while we\n\t * commit the transaction.  We could have started a join before setting\n\t * COMMIT_DOING so make sure to wait for num_writers to == 1 again.\n\t */\n\tspin_lock(&root->fs_info->trans_lock);\n\tcur_trans->state = TRANS_STATE_COMMIT_DOING;\n\tspin_unlock(&root->fs_info->trans_lock);\n\twait_event(cur_trans->writer_wait,\n\t\t   atomic_read(&cur_trans->num_writers) == 1);\n\n\t/* ->aborted might be set after the previous check, so check it */\n\tif (unlikely(ACCESS_ONCE(cur_trans->aborted))) {\n\t\tret = cur_trans->aborted;\n\t\tgoto scrub_continue;\n\t}\n\t/*\n\t * the reloc mutex makes sure that we stop\n\t * the balancing code from coming in and moving\n\t * extents around in the middle of the commit\n\t */\n\tmutex_lock(&root->fs_info->reloc_mutex);\n\n\t/*\n\t * We needn't worry about the delayed items because we will\n\t * deal with them in create_pending_snapshot(), which is the\n\t * core function of the snapshot creation.\n\t */\n\tret = create_pending_snapshots(trans, root->fs_info);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * We insert the dir indexes of the snapshots and update the inode\n\t * of the snapshots' parents after the snapshot creation, so there\n\t * are some delayed items which are not dealt with. Now deal with\n\t * them.\n\t *\n\t * We needn't worry that this operation will corrupt the snapshots,\n\t * because all the tree which are snapshoted will be forced to COW\n\t * the nodes and leaves.\n\t */\n\tret = btrfs_run_delayed_items(trans, root);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\tret = btrfs_run_delayed_refs(trans, root, (unsigned long)-1);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * make sure none of the code above managed to slip in a\n\t * delayed item\n\t */\n\tbtrfs_assert_delayed_root_empty(root);\n\n\tWARN_ON(cur_trans != trans->transaction);\n\n\t/* btrfs_commit_tree_roots is responsible for getting the\n\t * various roots consistent with each other.  Every pointer\n\t * in the tree of tree roots has to point to the most up to date\n\t * root for every subvolume and other tree.  So, we have to keep\n\t * the tree logging code from jumping in and changing any\n\t * of the trees.\n\t *\n\t * At this point in the commit, there can't be any tree-log\n\t * writers, but a little lower down we drop the trans mutex\n\t * and let new people in.  By holding the tree_log_mutex\n\t * from now until after the super is written, we avoid races\n\t * with the tree-log code.\n\t */\n\tmutex_lock(&root->fs_info->tree_log_mutex);\n\n\tret = commit_fs_roots(trans, root);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * Since the transaction is done, we can apply the pending changes\n\t * before the next transaction.\n\t */\n\tbtrfs_apply_pending_changes(root->fs_info);\n\n\t/* commit_fs_roots gets rid of all the tree log roots, it is now\n\t * safe to free the root of tree log roots\n\t */\n\tbtrfs_free_log_root_tree(trans, root->fs_info);\n\n\tret = commit_cowonly_roots(trans, root);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * The tasks which save the space cache and inode cache may also\n\t * update ->aborted, check it.\n\t */\n\tif (unlikely(ACCESS_ONCE(cur_trans->aborted))) {\n\t\tret = cur_trans->aborted;\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\tbtrfs_prepare_extent_commit(trans, root);\n\n\tcur_trans = root->fs_info->running_transaction;\n\n\tbtrfs_set_root_node(&root->fs_info->tree_root->root_item,\n\t\t\t    root->fs_info->tree_root->node);\n\tlist_add_tail(&root->fs_info->tree_root->dirty_list,\n\t\t      &cur_trans->switch_commits);\n\n\tbtrfs_set_root_node(&root->fs_info->chunk_root->root_item,\n\t\t\t    root->fs_info->chunk_root->node);\n\tlist_add_tail(&root->fs_info->chunk_root->dirty_list,\n\t\t      &cur_trans->switch_commits);\n\n\tswitch_commit_roots(cur_trans, root->fs_info);\n\n\tassert_qgroups_uptodate(trans);\n\tASSERT(list_empty(&cur_trans->dirty_bgs));\n\tupdate_super_roots(root);\n\n\tbtrfs_set_super_log_root(root->fs_info->super_copy, 0);\n\tbtrfs_set_super_log_root_level(root->fs_info->super_copy, 0);\n\tmemcpy(root->fs_info->super_for_commit, root->fs_info->super_copy,\n\t       sizeof(*root->fs_info->super_copy));\n\n\tbtrfs_update_commit_device_size(root->fs_info);\n\tbtrfs_update_commit_device_bytes_used(root, cur_trans);\n\n\tclear_bit(BTRFS_INODE_BTREE_LOG1_ERR, &btree_ino->runtime_flags);\n\tclear_bit(BTRFS_INODE_BTREE_LOG2_ERR, &btree_ino->runtime_flags);\n\n\tspin_lock(&root->fs_info->trans_lock);\n\tcur_trans->state = TRANS_STATE_UNBLOCKED;\n\troot->fs_info->running_transaction = NULL;\n\tspin_unlock(&root->fs_info->trans_lock);\n\tmutex_unlock(&root->fs_info->reloc_mutex);\n\n\twake_up(&root->fs_info->transaction_wait);\n\n\tret = btrfs_write_and_wait_transaction(trans, root);\n\tif (ret) {\n\t\tbtrfs_error(root->fs_info, ret,\n\t\t\t    \"Error while writing out transaction\");\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\tret = write_ctree_super(trans, root, 0);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * the super is written, we can safely allow the tree-loggers\n\t * to go about their business\n\t */\n\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\n\tbtrfs_finish_extent_commit(trans, root);\n\n\tif (cur_trans->have_free_bgs)\n\t\tbtrfs_clear_space_info_full(root->fs_info);\n\n\troot->fs_info->last_trans_committed = cur_trans->transid;\n\t/*\n\t * We needn't acquire the lock here because there is no other task\n\t * which can change it.\n\t */\n\tcur_trans->state = TRANS_STATE_COMPLETED;\n\twake_up(&cur_trans->commit_wait);\n\n\tspin_lock(&root->fs_info->trans_lock);\n\tlist_del_init(&cur_trans->list);\n\tspin_unlock(&root->fs_info->trans_lock);\n\n\tbtrfs_put_transaction(cur_trans);\n\tbtrfs_put_transaction(cur_trans);\n\n\tif (trans->type & __TRANS_FREEZABLE)\n\t\tsb_end_intwrite(root->fs_info->sb);\n\n\ttrace_btrfs_transaction_commit(root);\n\n\tbtrfs_scrub_continue(root);\n\n\tif (current->journal_info == trans)\n\t\tcurrent->journal_info = NULL;\n\n\tkmem_cache_free(btrfs_trans_handle_cachep, trans);\n\n\tif (current != root->fs_info->transaction_kthread)\n\t\tbtrfs_run_delayed_iputs(root);\n\n\treturn ret;\n\nscrub_continue:\n\tbtrfs_scrub_continue(root);\ncleanup_transaction:\n\tbtrfs_trans_release_metadata(trans, root);\n\ttrans->block_rsv = NULL;\n\tif (trans->qgroup_reserved) {\n\t\tbtrfs_qgroup_free(root, trans->qgroup_reserved);\n\t\ttrans->qgroup_reserved = 0;\n\t}\n\tbtrfs_warn(root->fs_info, \"Skipping commit of aborted transaction.\");\n\tif (current->journal_info == trans)\n\t\tcurrent->journal_info = NULL;\n\tcleanup_transaction(trans, root, ret);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "may_wait_transaction",
          "args": [
            "root",
            "type"
          ],
          "line": 526
        },
        "resolved": true,
        "details": {
          "function_name": "may_wait_transaction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
          "lines": "382-395",
          "snippet": "static int may_wait_transaction(struct btrfs_root *root, int type)\n{\n\tif (root->fs_info->log_root_recovering)\n\t\treturn 0;\n\n\tif (type == TRANS_USERSPACE)\n\t\treturn 1;\n\n\tif (type == TRANS_START &&\n\t    !atomic_read(&root->fs_info->open_ioctl_trans))\n\t\treturn 1;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"dev-replace.h\"",
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic int may_wait_transaction(struct btrfs_root *root, int type)\n{\n\tif (root->fs_info->log_root_recovering)\n\t\treturn 0;\n\n\tif (type == TRANS_USERSPACE)\n\t\treturn 1;\n\n\tif (type == TRANS_START &&\n\t    !atomic_read(&root->fs_info->open_ioctl_trans))\n\t\treturn 1;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_mb",
          "args": [],
          "line": 524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&h->ordered"
          ],
          "line": 522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&h->new_bgs"
          ],
          "line": 521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&h->qgroup_ref_list"
          ],
          "line": 520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "type == TRANS_JOIN_NOLOCK"
          ],
          "line": 497
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "type == TRANS_ATTACH"
          ],
          "line": 490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_current_trans",
          "args": [
            "root"
          ],
          "line": 489
        },
        "resolved": true,
        "details": {
          "function_name": "wait_current_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
          "lines": "363-380",
          "snippet": "static void wait_current_trans(struct btrfs_root *root)\n{\n\tstruct btrfs_transaction *cur_trans;\n\n\tspin_lock(&root->fs_info->trans_lock);\n\tcur_trans = root->fs_info->running_transaction;\n\tif (cur_trans && is_transaction_blocked(cur_trans)) {\n\t\tatomic_inc(&cur_trans->use_count);\n\t\tspin_unlock(&root->fs_info->trans_lock);\n\n\t\twait_event(root->fs_info->transaction_wait,\n\t\t\t   cur_trans->state >= TRANS_STATE_UNBLOCKED ||\n\t\t\t   cur_trans->aborted);\n\t\tbtrfs_put_transaction(cur_trans);\n\t} else {\n\t\tspin_unlock(&root->fs_info->trans_lock);\n\t}\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"dev-replace.h\"",
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void wait_current_trans(struct btrfs_root *root)\n{\n\tstruct btrfs_transaction *cur_trans;\n\n\tspin_lock(&root->fs_info->trans_lock);\n\tcur_trans = root->fs_info->running_transaction;\n\tif (cur_trans && is_transaction_blocked(cur_trans)) {\n\t\tatomic_inc(&cur_trans->use_count);\n\t\tspin_unlock(&root->fs_info->trans_lock);\n\n\t\twait_event(root->fs_info->transaction_wait,\n\t\t\t   cur_trans->state >= TRANS_STATE_UNBLOCKED ||\n\t\t\t   cur_trans->aborted);\n\t\tbtrfs_put_transaction(cur_trans);\n\t} else {\n\t\tspin_unlock(&root->fs_info->trans_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "join_transaction",
          "args": [
            "root",
            "type"
          ],
          "line": 487
        },
        "resolved": true,
        "details": {
          "function_name": "join_transaction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
          "lines": "151-264",
          "snippet": "static noinline int join_transaction(struct btrfs_root *root, unsigned int type)\n{\n\tstruct btrfs_transaction *cur_trans;\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\n\tspin_lock(&fs_info->trans_lock);\nloop:\n\t/* The file system has been taken offline. No new transactions. */\n\tif (test_bit(BTRFS_FS_STATE_ERROR, &fs_info->fs_state)) {\n\t\tspin_unlock(&fs_info->trans_lock);\n\t\treturn -EROFS;\n\t}\n\n\tcur_trans = fs_info->running_transaction;\n\tif (cur_trans) {\n\t\tif (cur_trans->aborted) {\n\t\t\tspin_unlock(&fs_info->trans_lock);\n\t\t\treturn cur_trans->aborted;\n\t\t}\n\t\tif (btrfs_blocked_trans_types[cur_trans->state] & type) {\n\t\t\tspin_unlock(&fs_info->trans_lock);\n\t\t\treturn -EBUSY;\n\t\t}\n\t\tatomic_inc(&cur_trans->use_count);\n\t\tatomic_inc(&cur_trans->num_writers);\n\t\textwriter_counter_inc(cur_trans, type);\n\t\tspin_unlock(&fs_info->trans_lock);\n\t\treturn 0;\n\t}\n\tspin_unlock(&fs_info->trans_lock);\n\n\t/*\n\t * If we are ATTACH, we just want to catch the current transaction,\n\t * and commit it. If there is no transaction, just return ENOENT.\n\t */\n\tif (type == TRANS_ATTACH)\n\t\treturn -ENOENT;\n\n\t/*\n\t * JOIN_NOLOCK only happens during the transaction commit, so\n\t * it is impossible that ->running_transaction is NULL\n\t */\n\tBUG_ON(type == TRANS_JOIN_NOLOCK);\n\n\tcur_trans = kmem_cache_alloc(btrfs_transaction_cachep, GFP_NOFS);\n\tif (!cur_trans)\n\t\treturn -ENOMEM;\n\n\tspin_lock(&fs_info->trans_lock);\n\tif (fs_info->running_transaction) {\n\t\t/*\n\t\t * someone started a transaction after we unlocked.  Make sure\n\t\t * to redo the checks above\n\t\t */\n\t\tkmem_cache_free(btrfs_transaction_cachep, cur_trans);\n\t\tgoto loop;\n\t} else if (test_bit(BTRFS_FS_STATE_ERROR, &fs_info->fs_state)) {\n\t\tspin_unlock(&fs_info->trans_lock);\n\t\tkmem_cache_free(btrfs_transaction_cachep, cur_trans);\n\t\treturn -EROFS;\n\t}\n\n\tatomic_set(&cur_trans->num_writers, 1);\n\textwriter_counter_init(cur_trans, type);\n\tinit_waitqueue_head(&cur_trans->writer_wait);\n\tinit_waitqueue_head(&cur_trans->commit_wait);\n\tcur_trans->state = TRANS_STATE_RUNNING;\n\t/*\n\t * One for this trans handle, one so it will live on until we\n\t * commit the transaction.\n\t */\n\tatomic_set(&cur_trans->use_count, 2);\n\tcur_trans->have_free_bgs = 0;\n\tcur_trans->start_time = get_seconds();\n\n\tcur_trans->delayed_refs.href_root = RB_ROOT;\n\tatomic_set(&cur_trans->delayed_refs.num_entries, 0);\n\tcur_trans->delayed_refs.num_heads_ready = 0;\n\tcur_trans->delayed_refs.num_heads = 0;\n\tcur_trans->delayed_refs.flushing = 0;\n\tcur_trans->delayed_refs.run_delayed_start = 0;\n\n\t/*\n\t * although the tree mod log is per file system and not per transaction,\n\t * the log must never go across transaction boundaries.\n\t */\n\tsmp_mb();\n\tif (!list_empty(&fs_info->tree_mod_seq_list))\n\t\tWARN(1, KERN_ERR \"BTRFS: tree_mod_seq_list not empty when \"\n\t\t\t\"creating a fresh transaction\\n\");\n\tif (!RB_EMPTY_ROOT(&fs_info->tree_mod_log))\n\t\tWARN(1, KERN_ERR \"BTRFS: tree_mod_log rb tree not empty when \"\n\t\t\t\"creating a fresh transaction\\n\");\n\tatomic64_set(&fs_info->tree_mod_seq, 0);\n\n\tspin_lock_init(&cur_trans->delayed_refs.lock);\n\n\tINIT_LIST_HEAD(&cur_trans->pending_snapshots);\n\tINIT_LIST_HEAD(&cur_trans->pending_chunks);\n\tINIT_LIST_HEAD(&cur_trans->switch_commits);\n\tINIT_LIST_HEAD(&cur_trans->pending_ordered);\n\tINIT_LIST_HEAD(&cur_trans->dirty_bgs);\n\tspin_lock_init(&cur_trans->dirty_bgs_lock);\n\tlist_add_tail(&cur_trans->list, &fs_info->trans_list);\n\textent_io_tree_init(&cur_trans->dirty_pages,\n\t\t\t     fs_info->btree_inode->i_mapping);\n\tfs_info->generation++;\n\tcur_trans->transid = fs_info->generation;\n\tfs_info->running_transaction = cur_trans;\n\tcur_trans->aborted = 0;\n\tspin_unlock(&fs_info->trans_lock);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"dev-replace.h\"",
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned int btrfs_blocked_trans_types[TRANS_STATE_MAX] = {\n\t[TRANS_STATE_RUNNING]\t\t= 0U,\n\t[TRANS_STATE_BLOCKED]\t\t= (__TRANS_USERSPACE |\n\t\t\t\t\t   __TRANS_START),\n\t[TRANS_STATE_COMMIT_START]\t= (__TRANS_USERSPACE |\n\t\t\t\t\t   __TRANS_START |\n\t\t\t\t\t   __TRANS_ATTACH),\n\t[TRANS_STATE_COMMIT_DOING]\t= (__TRANS_USERSPACE |\n\t\t\t\t\t   __TRANS_START |\n\t\t\t\t\t   __TRANS_ATTACH |\n\t\t\t\t\t   __TRANS_JOIN),\n\t[TRANS_STATE_UNBLOCKED]\t\t= (__TRANS_USERSPACE |\n\t\t\t\t\t   __TRANS_START |\n\t\t\t\t\t   __TRANS_ATTACH |\n\t\t\t\t\t   __TRANS_JOIN |\n\t\t\t\t\t   __TRANS_JOIN_NOLOCK),\n\t[TRANS_STATE_COMPLETED]\t\t= (__TRANS_USERSPACE |\n\t\t\t\t\t   __TRANS_START |\n\t\t\t\t\t   __TRANS_ATTACH |\n\t\t\t\t\t   __TRANS_JOIN |\n\t\t\t\t\t   __TRANS_JOIN_NOLOCK),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic unsigned int btrfs_blocked_trans_types[TRANS_STATE_MAX] = {\n\t[TRANS_STATE_RUNNING]\t\t= 0U,\n\t[TRANS_STATE_BLOCKED]\t\t= (__TRANS_USERSPACE |\n\t\t\t\t\t   __TRANS_START),\n\t[TRANS_STATE_COMMIT_START]\t= (__TRANS_USERSPACE |\n\t\t\t\t\t   __TRANS_START |\n\t\t\t\t\t   __TRANS_ATTACH),\n\t[TRANS_STATE_COMMIT_DOING]\t= (__TRANS_USERSPACE |\n\t\t\t\t\t   __TRANS_START |\n\t\t\t\t\t   __TRANS_ATTACH |\n\t\t\t\t\t   __TRANS_JOIN),\n\t[TRANS_STATE_UNBLOCKED]\t\t= (__TRANS_USERSPACE |\n\t\t\t\t\t   __TRANS_START |\n\t\t\t\t\t   __TRANS_ATTACH |\n\t\t\t\t\t   __TRANS_JOIN |\n\t\t\t\t\t   __TRANS_JOIN_NOLOCK),\n\t[TRANS_STATE_COMPLETED]\t\t= (__TRANS_USERSPACE |\n\t\t\t\t\t   __TRANS_START |\n\t\t\t\t\t   __TRANS_ATTACH |\n\t\t\t\t\t   __TRANS_JOIN |\n\t\t\t\t\t   __TRANS_JOIN_NOLOCK),\n};\n\nstatic noinline int join_transaction(struct btrfs_root *root, unsigned int type)\n{\n\tstruct btrfs_transaction *cur_trans;\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\n\tspin_lock(&fs_info->trans_lock);\nloop:\n\t/* The file system has been taken offline. No new transactions. */\n\tif (test_bit(BTRFS_FS_STATE_ERROR, &fs_info->fs_state)) {\n\t\tspin_unlock(&fs_info->trans_lock);\n\t\treturn -EROFS;\n\t}\n\n\tcur_trans = fs_info->running_transaction;\n\tif (cur_trans) {\n\t\tif (cur_trans->aborted) {\n\t\t\tspin_unlock(&fs_info->trans_lock);\n\t\t\treturn cur_trans->aborted;\n\t\t}\n\t\tif (btrfs_blocked_trans_types[cur_trans->state] & type) {\n\t\t\tspin_unlock(&fs_info->trans_lock);\n\t\t\treturn -EBUSY;\n\t\t}\n\t\tatomic_inc(&cur_trans->use_count);\n\t\tatomic_inc(&cur_trans->num_writers);\n\t\textwriter_counter_inc(cur_trans, type);\n\t\tspin_unlock(&fs_info->trans_lock);\n\t\treturn 0;\n\t}\n\tspin_unlock(&fs_info->trans_lock);\n\n\t/*\n\t * If we are ATTACH, we just want to catch the current transaction,\n\t * and commit it. If there is no transaction, just return ENOENT.\n\t */\n\tif (type == TRANS_ATTACH)\n\t\treturn -ENOENT;\n\n\t/*\n\t * JOIN_NOLOCK only happens during the transaction commit, so\n\t * it is impossible that ->running_transaction is NULL\n\t */\n\tBUG_ON(type == TRANS_JOIN_NOLOCK);\n\n\tcur_trans = kmem_cache_alloc(btrfs_transaction_cachep, GFP_NOFS);\n\tif (!cur_trans)\n\t\treturn -ENOMEM;\n\n\tspin_lock(&fs_info->trans_lock);\n\tif (fs_info->running_transaction) {\n\t\t/*\n\t\t * someone started a transaction after we unlocked.  Make sure\n\t\t * to redo the checks above\n\t\t */\n\t\tkmem_cache_free(btrfs_transaction_cachep, cur_trans);\n\t\tgoto loop;\n\t} else if (test_bit(BTRFS_FS_STATE_ERROR, &fs_info->fs_state)) {\n\t\tspin_unlock(&fs_info->trans_lock);\n\t\tkmem_cache_free(btrfs_transaction_cachep, cur_trans);\n\t\treturn -EROFS;\n\t}\n\n\tatomic_set(&cur_trans->num_writers, 1);\n\textwriter_counter_init(cur_trans, type);\n\tinit_waitqueue_head(&cur_trans->writer_wait);\n\tinit_waitqueue_head(&cur_trans->commit_wait);\n\tcur_trans->state = TRANS_STATE_RUNNING;\n\t/*\n\t * One for this trans handle, one so it will live on until we\n\t * commit the transaction.\n\t */\n\tatomic_set(&cur_trans->use_count, 2);\n\tcur_trans->have_free_bgs = 0;\n\tcur_trans->start_time = get_seconds();\n\n\tcur_trans->delayed_refs.href_root = RB_ROOT;\n\tatomic_set(&cur_trans->delayed_refs.num_entries, 0);\n\tcur_trans->delayed_refs.num_heads_ready = 0;\n\tcur_trans->delayed_refs.num_heads = 0;\n\tcur_trans->delayed_refs.flushing = 0;\n\tcur_trans->delayed_refs.run_delayed_start = 0;\n\n\t/*\n\t * although the tree mod log is per file system and not per transaction,\n\t * the log must never go across transaction boundaries.\n\t */\n\tsmp_mb();\n\tif (!list_empty(&fs_info->tree_mod_seq_list))\n\t\tWARN(1, KERN_ERR \"BTRFS: tree_mod_seq_list not empty when \"\n\t\t\t\"creating a fresh transaction\\n\");\n\tif (!RB_EMPTY_ROOT(&fs_info->tree_mod_log))\n\t\tWARN(1, KERN_ERR \"BTRFS: tree_mod_log rb tree not empty when \"\n\t\t\t\"creating a fresh transaction\\n\");\n\tatomic64_set(&fs_info->tree_mod_seq, 0);\n\n\tspin_lock_init(&cur_trans->delayed_refs.lock);\n\n\tINIT_LIST_HEAD(&cur_trans->pending_snapshots);\n\tINIT_LIST_HEAD(&cur_trans->pending_chunks);\n\tINIT_LIST_HEAD(&cur_trans->switch_commits);\n\tINIT_LIST_HEAD(&cur_trans->pending_ordered);\n\tINIT_LIST_HEAD(&cur_trans->dirty_bgs);\n\tspin_lock_init(&cur_trans->dirty_bgs_lock);\n\tlist_add_tail(&cur_trans->list, &fs_info->trans_list);\n\textent_io_tree_init(&cur_trans->dirty_pages,\n\t\t\t     fs_info->btree_inode->i_mapping);\n\tfs_info->generation++;\n\tcur_trans->transid = fs_info->generation;\n\tfs_info->running_transaction = cur_trans;\n\tcur_trans->aborted = 0;\n\tspin_unlock(&fs_info->trans_lock);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sb_start_intwrite",
          "args": [
            "root->fs_info->sb"
          ],
          "line": 481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_alloc",
          "args": [
            "btrfs_trans_handle_cachep",
            "GFP_NOFS"
          ],
          "line": 464
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_kmem_cache_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1064-1076",
          "snippet": "static inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\nretry:\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry) {\n\t\tcond_resched();\n\t\tgoto retry;\n\t}\n\n\treturn entry;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\nretry:\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry) {\n\t\tcond_resched();\n\t\tgoto retry;\n\t}\n\n\treturn entry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_block_rsv_add",
          "args": [
            "root",
            "&root->fs_info->trans_block_rsv",
            "num_bytes",
            "flush"
          ],
          "line": 457
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_block_rsv_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent-tree.c",
          "lines": "4703-4719",
          "snippet": "int btrfs_block_rsv_add(struct btrfs_root *root,\n\t\t\tstruct btrfs_block_rsv *block_rsv, u64 num_bytes,\n\t\t\tenum btrfs_reserve_flush_enum flush)\n{\n\tint ret;\n\n\tif (num_bytes == 0)\n\t\treturn 0;\n\n\tret = reserve_metadata_bytes(root, block_rsv, num_bytes, flush);\n\tif (!ret) {\n\t\tblock_rsv_add_bytes(block_rsv, num_bytes, 1);\n\t\treturn 0;\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"math.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include \"hash.h\"",
            "#include <linux/percpu_counter.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int block_rsv_use_bytes(struct btrfs_block_rsv *block_rsv,\n\t\t\t       u64 num_bytes);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"math.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include \"hash.h\"\n#include <linux/percpu_counter.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n#include <linux/rcupdate.h>\n#include <linux/sort.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic int block_rsv_use_bytes(struct btrfs_block_rsv *block_rsv,\n\t\t\t       u64 num_bytes);\nstatic noinline struct;\n\nint btrfs_block_rsv_add(struct btrfs_root *root,\n\t\t\tstruct btrfs_block_rsv *block_rsv, u64 num_bytes,\n\t\t\tenum btrfs_reserve_flush_enum flush)\n{\n\tint ret;\n\n\tif (num_bytes == 0)\n\t\treturn 0;\n\n\tret = reserve_metadata_bytes(root, block_rsv, num_bytes, flush);\n\tif (!ret) {\n\t\tblock_rsv_add_bytes(block_rsv, num_bytes, 1);\n\t\treturn 0;\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "need_reserve_reloc_root",
          "args": [
            "root"
          ],
          "line": 452
        },
        "resolved": true,
        "details": {
          "function_name": "need_reserve_reloc_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
          "lines": "397-406",
          "snippet": "static inline bool need_reserve_reloc_root(struct btrfs_root *root)\n{\n\tif (!root->fs_info->reloc_ctl ||\n\t    !test_bit(BTRFS_ROOT_REF_COWS, &root->state) ||\n\t    root->root_key.objectid == BTRFS_TREE_RELOC_OBJECTID ||\n\t    root->reloc_root)\n\t\treturn false;\n\n\treturn true;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"dev-replace.h\"",
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic inline bool need_reserve_reloc_root(struct btrfs_root *root)\n{\n\tif (!root->fs_info->reloc_ctl ||\n\t    !test_bit(BTRFS_ROOT_REF_COWS, &root->state) ||\n\t    root->root_key.objectid == BTRFS_TREE_RELOC_OBJECTID ||\n\t    root->reloc_root)\n\t\treturn false;\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_calc_trans_metadata_size",
          "args": [
            "root",
            "num_items"
          ],
          "line": 448
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_calc_trans_metadata_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "3298-3303",
          "snippet": "static inline u64 btrfs_calc_trans_metadata_size(struct btrfs_root *root,\n\t\t\t\t\t\t unsigned num_items)\n{\n\treturn (root->nodesize + root->nodesize * (BTRFS_MAX_LEVEL - 1)) *\n\t\t2 * num_items;\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [
            "#define BTRFS_MAX_LEVEL 8"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\n#define BTRFS_MAX_LEVEL 8\n\nstatic inline u64 btrfs_calc_trans_metadata_size(struct btrfs_root *root,\n\t\t\t\t\t\t unsigned num_items)\n{\n\treturn (root->nodesize + root->nodesize * (BTRFS_MAX_LEVEL - 1)) *\n\t\t2 * num_items;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "ret"
          ],
          "line": 445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_qgroup_reserve",
          "args": [
            "root",
            "qgroup_reserved"
          ],
          "line": 443
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_qgroup_reserve",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/qgroup.c",
          "lines": "2367-2446",
          "snippet": "int btrfs_qgroup_reserve(struct btrfs_root *root, u64 num_bytes)\n{\n\tstruct btrfs_root *quota_root;\n\tstruct btrfs_qgroup *qgroup;\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tu64 ref_root = root->root_key.objectid;\n\tint ret = 0;\n\tstruct ulist_node *unode;\n\tstruct ulist_iterator uiter;\n\n\tif (!is_fstree(ref_root))\n\t\treturn 0;\n\n\tif (num_bytes == 0)\n\t\treturn 0;\n\n\tspin_lock(&fs_info->qgroup_lock);\n\tquota_root = fs_info->quota_root;\n\tif (!quota_root)\n\t\tgoto out;\n\n\tqgroup = find_qgroup_rb(fs_info, ref_root);\n\tif (!qgroup)\n\t\tgoto out;\n\n\t/*\n\t * in a first step, we check all affected qgroups if any limits would\n\t * be exceeded\n\t */\n\tulist_reinit(fs_info->qgroup_ulist);\n\tret = ulist_add(fs_info->qgroup_ulist, qgroup->qgroupid,\n\t\t\t(uintptr_t)qgroup, GFP_ATOMIC);\n\tif (ret < 0)\n\t\tgoto out;\n\tULIST_ITER_INIT(&uiter);\n\twhile ((unode = ulist_next(fs_info->qgroup_ulist, &uiter))) {\n\t\tstruct btrfs_qgroup *qg;\n\t\tstruct btrfs_qgroup_list *glist;\n\n\t\tqg = u64_to_ptr(unode->aux);\n\n\t\tif ((qg->lim_flags & BTRFS_QGROUP_LIMIT_MAX_RFER) &&\n\t\t    qg->reserved + (s64)qg->rfer + num_bytes >\n\t\t    qg->max_rfer) {\n\t\t\tret = -EDQUOT;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif ((qg->lim_flags & BTRFS_QGROUP_LIMIT_MAX_EXCL) &&\n\t\t    qg->reserved + (s64)qg->excl + num_bytes >\n\t\t    qg->max_excl) {\n\t\t\tret = -EDQUOT;\n\t\t\tgoto out;\n\t\t}\n\n\t\tlist_for_each_entry(glist, &qg->groups, next_group) {\n\t\t\tret = ulist_add(fs_info->qgroup_ulist,\n\t\t\t\t\tglist->group->qgroupid,\n\t\t\t\t\t(uintptr_t)glist->group, GFP_ATOMIC);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t}\n\t}\n\tret = 0;\n\t/*\n\t * no limits exceeded, now record the reservation into all qgroups\n\t */\n\tULIST_ITER_INIT(&uiter);\n\twhile ((unode = ulist_next(fs_info->qgroup_ulist, &uiter))) {\n\t\tstruct btrfs_qgroup *qg;\n\n\t\tqg = u64_to_ptr(unode->aux);\n\n\t\tqg->reserved += num_bytes;\n\t}\n\nout:\n\tspin_unlock(&fs_info->qgroup_lock);\n\treturn ret;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"ulist.h\"",
            "#include \"locking.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"ctree.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"ulist.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);\n\nint btrfs_qgroup_reserve(struct btrfs_root *root, u64 num_bytes)\n{\n\tstruct btrfs_root *quota_root;\n\tstruct btrfs_qgroup *qgroup;\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tu64 ref_root = root->root_key.objectid;\n\tint ret = 0;\n\tstruct ulist_node *unode;\n\tstruct ulist_iterator uiter;\n\n\tif (!is_fstree(ref_root))\n\t\treturn 0;\n\n\tif (num_bytes == 0)\n\t\treturn 0;\n\n\tspin_lock(&fs_info->qgroup_lock);\n\tquota_root = fs_info->quota_root;\n\tif (!quota_root)\n\t\tgoto out;\n\n\tqgroup = find_qgroup_rb(fs_info, ref_root);\n\tif (!qgroup)\n\t\tgoto out;\n\n\t/*\n\t * in a first step, we check all affected qgroups if any limits would\n\t * be exceeded\n\t */\n\tulist_reinit(fs_info->qgroup_ulist);\n\tret = ulist_add(fs_info->qgroup_ulist, qgroup->qgroupid,\n\t\t\t(uintptr_t)qgroup, GFP_ATOMIC);\n\tif (ret < 0)\n\t\tgoto out;\n\tULIST_ITER_INIT(&uiter);\n\twhile ((unode = ulist_next(fs_info->qgroup_ulist, &uiter))) {\n\t\tstruct btrfs_qgroup *qg;\n\t\tstruct btrfs_qgroup_list *glist;\n\n\t\tqg = u64_to_ptr(unode->aux);\n\n\t\tif ((qg->lim_flags & BTRFS_QGROUP_LIMIT_MAX_RFER) &&\n\t\t    qg->reserved + (s64)qg->rfer + num_bytes >\n\t\t    qg->max_rfer) {\n\t\t\tret = -EDQUOT;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif ((qg->lim_flags & BTRFS_QGROUP_LIMIT_MAX_EXCL) &&\n\t\t    qg->reserved + (s64)qg->excl + num_bytes >\n\t\t    qg->max_excl) {\n\t\t\tret = -EDQUOT;\n\t\t\tgoto out;\n\t\t}\n\n\t\tlist_for_each_entry(glist, &qg->groups, next_group) {\n\t\t\tret = ulist_add(fs_info->qgroup_ulist,\n\t\t\t\t\tglist->group->qgroupid,\n\t\t\t\t\t(uintptr_t)glist->group, GFP_ATOMIC);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t}\n\t}\n\tret = 0;\n\t/*\n\t * no limits exceeded, now record the reservation into all qgroups\n\t */\n\tULIST_ITER_INIT(&uiter);\n\twhile ((unode = ulist_next(fs_info->qgroup_ulist, &uiter))) {\n\t\tstruct btrfs_qgroup *qg;\n\n\t\tqg = u64_to_ptr(unode->aux);\n\n\t\tqg->reserved += num_bytes;\n\t}\n\nout:\n\tspin_unlock(&fs_info->qgroup_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_fstree",
          "args": [
            "root->root_key.objectid"
          ],
          "line": 441
        },
        "resolved": true,
        "details": {
          "function_name": "is_fstree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "4180-4186",
          "snippet": "static inline int is_fstree(u64 rootid)\n{\n\tif (rootid == BTRFS_FS_TREE_OBJECTID ||\n\t    (s64)rootid >= (s64)BTRFS_FIRST_FREE_OBJECTID)\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [
            "#define BTRFS_FIRST_FREE_OBJECTID 256ULL",
            "#define BTRFS_FS_TREE_OBJECTID 5ULL"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\n#define BTRFS_FIRST_FREE_OBJECTID 256ULL\n#define BTRFS_FS_TREE_OBJECTID 5ULL\n\nstatic inline int is_fstree(u64 rootid)\n{\n\tif (rootid == BTRFS_FS_TREE_OBJECTID ||\n\t    (s64)rootid >= (s64)BTRFS_FIRST_FREE_OBJECTID)\n\t\treturn 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "h->use_count > 2"
          ],
          "line": 429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "type & TRANS_EXTWRITERS"
          ],
          "line": 426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EROFS"
          ],
          "line": 423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "BTRFS_FS_STATE_ERROR",
            "&root->fs_info->fs_state"
          ],
          "line": 422
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "current->journal_info != BTRFS_SEND_TRANS_STUB"
          ],
          "line": 420
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic struct btrfs_trans_handle *\nstart_transaction(struct btrfs_root *root, u64 num_items, unsigned int type,\n\t\t  enum btrfs_reserve_flush_enum flush)\n{\n\tstruct btrfs_trans_handle *h;\n\tstruct btrfs_transaction *cur_trans;\n\tu64 num_bytes = 0;\n\tu64 qgroup_reserved = 0;\n\tbool reloc_reserved = false;\n\tint ret;\n\n\t/* Send isn't supposed to start transactions. */\n\tASSERT(current->journal_info != BTRFS_SEND_TRANS_STUB);\n\n\tif (test_bit(BTRFS_FS_STATE_ERROR, &root->fs_info->fs_state))\n\t\treturn ERR_PTR(-EROFS);\n\n\tif (current->journal_info) {\n\t\tWARN_ON(type & TRANS_EXTWRITERS);\n\t\th = current->journal_info;\n\t\th->use_count++;\n\t\tWARN_ON(h->use_count > 2);\n\t\th->orig_rsv = h->block_rsv;\n\t\th->block_rsv = NULL;\n\t\tgoto got_it;\n\t}\n\n\t/*\n\t * Do the reservation before we join the transaction so we can do all\n\t * the appropriate flushing if need be.\n\t */\n\tif (num_items > 0 && root != root->fs_info->chunk_root) {\n\t\tif (root->fs_info->quota_enabled &&\n\t\t    is_fstree(root->root_key.objectid)) {\n\t\t\tqgroup_reserved = num_items * root->nodesize;\n\t\t\tret = btrfs_qgroup_reserve(root, qgroup_reserved);\n\t\t\tif (ret)\n\t\t\t\treturn ERR_PTR(ret);\n\t\t}\n\n\t\tnum_bytes = btrfs_calc_trans_metadata_size(root, num_items);\n\t\t/*\n\t\t * Do the reservation for the relocation root creation\n\t\t */\n\t\tif (need_reserve_reloc_root(root)) {\n\t\t\tnum_bytes += root->nodesize;\n\t\t\treloc_reserved = true;\n\t\t}\n\n\t\tret = btrfs_block_rsv_add(root,\n\t\t\t\t\t  &root->fs_info->trans_block_rsv,\n\t\t\t\t\t  num_bytes, flush);\n\t\tif (ret)\n\t\t\tgoto reserve_fail;\n\t}\nagain:\n\th = kmem_cache_alloc(btrfs_trans_handle_cachep, GFP_NOFS);\n\tif (!h) {\n\t\tret = -ENOMEM;\n\t\tgoto alloc_fail;\n\t}\n\n\t/*\n\t * If we are JOIN_NOLOCK we're already committing a transaction and\n\t * waiting on this guy, so we don't need to do the sb_start_intwrite\n\t * because we're already holding a ref.  We need this because we could\n\t * have raced in and did an fsync() on a file which can kick a commit\n\t * and then we deadlock with somebody doing a freeze.\n\t *\n\t * If we are ATTACH, it means we just want to catch the current\n\t * transaction and commit it, so we needn't do sb_start_intwrite(). \n\t */\n\tif (type & __TRANS_FREEZABLE)\n\t\tsb_start_intwrite(root->fs_info->sb);\n\n\tif (may_wait_transaction(root, type))\n\t\twait_current_trans(root);\n\n\tdo {\n\t\tret = join_transaction(root, type);\n\t\tif (ret == -EBUSY) {\n\t\t\twait_current_trans(root);\n\t\t\tif (unlikely(type == TRANS_ATTACH))\n\t\t\t\tret = -ENOENT;\n\t\t}\n\t} while (ret == -EBUSY);\n\n\tif (ret < 0) {\n\t\t/* We must get the transaction if we are JOIN_NOLOCK. */\n\t\tBUG_ON(type == TRANS_JOIN_NOLOCK);\n\t\tgoto join_fail;\n\t}\n\n\tcur_trans = root->fs_info->running_transaction;\n\n\th->transid = cur_trans->transid;\n\th->transaction = cur_trans;\n\th->blocks_used = 0;\n\th->bytes_reserved = 0;\n\th->root = root;\n\th->delayed_ref_updates = 0;\n\th->use_count = 1;\n\th->adding_csums = 0;\n\th->block_rsv = NULL;\n\th->orig_rsv = NULL;\n\th->aborted = 0;\n\th->qgroup_reserved = 0;\n\th->delayed_ref_elem.seq = 0;\n\th->type = type;\n\th->allocating_chunk = false;\n\th->reloc_reserved = false;\n\th->sync = false;\n\tINIT_LIST_HEAD(&h->qgroup_ref_list);\n\tINIT_LIST_HEAD(&h->new_bgs);\n\tINIT_LIST_HEAD(&h->ordered);\n\n\tsmp_mb();\n\tif (cur_trans->state >= TRANS_STATE_BLOCKED &&\n\t    may_wait_transaction(root, type)) {\n\t\tcurrent->journal_info = h;\n\t\tbtrfs_commit_transaction(h, root);\n\t\tgoto again;\n\t}\n\n\tif (num_bytes) {\n\t\ttrace_btrfs_space_reservation(root->fs_info, \"transaction\",\n\t\t\t\t\t      h->transid, num_bytes, 1);\n\t\th->block_rsv = &root->fs_info->trans_block_rsv;\n\t\th->bytes_reserved = num_bytes;\n\t\th->reloc_reserved = reloc_reserved;\n\t}\n\th->qgroup_reserved = qgroup_reserved;\n\ngot_it:\n\tbtrfs_record_root_in_trans(h, root);\n\n\tif (!current->journal_info && type != TRANS_USERSPACE)\n\t\tcurrent->journal_info = h;\n\treturn h;\n\njoin_fail:\n\tif (type & __TRANS_FREEZABLE)\n\t\tsb_end_intwrite(root->fs_info->sb);\n\tkmem_cache_free(btrfs_trans_handle_cachep, h);\nalloc_fail:\n\tif (num_bytes)\n\t\tbtrfs_block_rsv_release(root, &root->fs_info->trans_block_rsv,\n\t\t\t\t\tnum_bytes);\nreserve_fail:\n\tif (qgroup_reserved)\n\t\tbtrfs_qgroup_free(root, qgroup_reserved);\n\treturn ERR_PTR(ret);\n}"
  },
  {
    "function_name": "need_reserve_reloc_root",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
    "lines": "397-406",
    "snippet": "static inline bool need_reserve_reloc_root(struct btrfs_root *root)\n{\n\tif (!root->fs_info->reloc_ctl ||\n\t    !test_bit(BTRFS_ROOT_REF_COWS, &root->state) ||\n\t    root->root_key.objectid == BTRFS_TREE_RELOC_OBJECTID ||\n\t    root->reloc_root)\n\t\treturn false;\n\n\treturn true;\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"dev-replace.h\"",
      "#include \"volumes.h\"",
      "#include \"inode-map.h\"",
      "#include \"tree-log.h\"",
      "#include \"locking.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/uuid.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/writeback.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "BTRFS_ROOT_REF_COWS",
            "&root->state"
          ],
          "line": 400
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic inline bool need_reserve_reloc_root(struct btrfs_root *root)\n{\n\tif (!root->fs_info->reloc_ctl ||\n\t    !test_bit(BTRFS_ROOT_REF_COWS, &root->state) ||\n\t    root->root_key.objectid == BTRFS_TREE_RELOC_OBJECTID ||\n\t    root->reloc_root)\n\t\treturn false;\n\n\treturn true;\n}"
  },
  {
    "function_name": "may_wait_transaction",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
    "lines": "382-395",
    "snippet": "static int may_wait_transaction(struct btrfs_root *root, int type)\n{\n\tif (root->fs_info->log_root_recovering)\n\t\treturn 0;\n\n\tif (type == TRANS_USERSPACE)\n\t\treturn 1;\n\n\tif (type == TRANS_START &&\n\t    !atomic_read(&root->fs_info->open_ioctl_trans))\n\t\treturn 1;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"dev-replace.h\"",
      "#include \"volumes.h\"",
      "#include \"inode-map.h\"",
      "#include \"tree-log.h\"",
      "#include \"locking.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/uuid.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/writeback.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&root->fs_info->open_ioctl_trans"
          ],
          "line": 391
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic int may_wait_transaction(struct btrfs_root *root, int type)\n{\n\tif (root->fs_info->log_root_recovering)\n\t\treturn 0;\n\n\tif (type == TRANS_USERSPACE)\n\t\treturn 1;\n\n\tif (type == TRANS_START &&\n\t    !atomic_read(&root->fs_info->open_ioctl_trans))\n\t\treturn 1;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "wait_current_trans",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
    "lines": "363-380",
    "snippet": "static void wait_current_trans(struct btrfs_root *root)\n{\n\tstruct btrfs_transaction *cur_trans;\n\n\tspin_lock(&root->fs_info->trans_lock);\n\tcur_trans = root->fs_info->running_transaction;\n\tif (cur_trans && is_transaction_blocked(cur_trans)) {\n\t\tatomic_inc(&cur_trans->use_count);\n\t\tspin_unlock(&root->fs_info->trans_lock);\n\n\t\twait_event(root->fs_info->transaction_wait,\n\t\t\t   cur_trans->state >= TRANS_STATE_UNBLOCKED ||\n\t\t\t   cur_trans->aborted);\n\t\tbtrfs_put_transaction(cur_trans);\n\t} else {\n\t\tspin_unlock(&root->fs_info->trans_lock);\n\t}\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"dev-replace.h\"",
      "#include \"volumes.h\"",
      "#include \"inode-map.h\"",
      "#include \"tree-log.h\"",
      "#include \"locking.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/uuid.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/writeback.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&root->fs_info->trans_lock"
          ],
          "line": 378
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_put_transaction",
          "args": [
            "cur_trans"
          ],
          "line": 376
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_put_transaction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
          "lines": "61-77",
          "snippet": "void btrfs_put_transaction(struct btrfs_transaction *transaction)\n{\n\tWARN_ON(atomic_read(&transaction->use_count) == 0);\n\tif (atomic_dec_and_test(&transaction->use_count)) {\n\t\tBUG_ON(!list_empty(&transaction->list));\n\t\tWARN_ON(!RB_EMPTY_ROOT(&transaction->delayed_refs.href_root));\n\t\twhile (!list_empty(&transaction->pending_chunks)) {\n\t\t\tstruct extent_map *em;\n\n\t\t\tem = list_first_entry(&transaction->pending_chunks,\n\t\t\t\t\t      struct extent_map, list);\n\t\t\tlist_del_init(&em->list);\n\t\t\tfree_extent_map(em);\n\t\t}\n\t\tkmem_cache_free(btrfs_transaction_cachep, transaction);\n\t}\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"dev-replace.h\"",
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid btrfs_put_transaction(struct btrfs_transaction *transaction)\n{\n\tWARN_ON(atomic_read(&transaction->use_count) == 0);\n\tif (atomic_dec_and_test(&transaction->use_count)) {\n\t\tBUG_ON(!list_empty(&transaction->list));\n\t\tWARN_ON(!RB_EMPTY_ROOT(&transaction->delayed_refs.href_root));\n\t\twhile (!list_empty(&transaction->pending_chunks)) {\n\t\t\tstruct extent_map *em;\n\n\t\t\tem = list_first_entry(&transaction->pending_chunks,\n\t\t\t\t\t      struct extent_map, list);\n\t\t\tlist_del_init(&em->list);\n\t\t\tfree_extent_map(em);\n\t\t}\n\t\tkmem_cache_free(btrfs_transaction_cachep, transaction);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_event",
          "args": [
            "root->fs_info->transaction_wait",
            "cur_trans->state >= TRANS_STATE_UNBLOCKED ||\n\t\t\t   cur_trans->aborted"
          ],
          "line": 373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&cur_trans->use_count"
          ],
          "line": 370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_transaction_blocked",
          "args": [
            "cur_trans"
          ],
          "line": 369
        },
        "resolved": true,
        "details": {
          "function_name": "is_transaction_blocked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
          "lines": "352-357",
          "snippet": "static inline int is_transaction_blocked(struct btrfs_transaction *trans)\n{\n\treturn (trans->state >= TRANS_STATE_BLOCKED &&\n\t\ttrans->state < TRANS_STATE_UNBLOCKED &&\n\t\t!trans->aborted);\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"dev-replace.h\"",
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic inline int is_transaction_blocked(struct btrfs_transaction *trans)\n{\n\treturn (trans->state >= TRANS_STATE_BLOCKED &&\n\t\ttrans->state < TRANS_STATE_UNBLOCKED &&\n\t\t!trans->aborted);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&root->fs_info->trans_lock"
          ],
          "line": 367
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void wait_current_trans(struct btrfs_root *root)\n{\n\tstruct btrfs_transaction *cur_trans;\n\n\tspin_lock(&root->fs_info->trans_lock);\n\tcur_trans = root->fs_info->running_transaction;\n\tif (cur_trans && is_transaction_blocked(cur_trans)) {\n\t\tatomic_inc(&cur_trans->use_count);\n\t\tspin_unlock(&root->fs_info->trans_lock);\n\n\t\twait_event(root->fs_info->transaction_wait,\n\t\t\t   cur_trans->state >= TRANS_STATE_UNBLOCKED ||\n\t\t\t   cur_trans->aborted);\n\t\tbtrfs_put_transaction(cur_trans);\n\t} else {\n\t\tspin_unlock(&root->fs_info->trans_lock);\n\t}\n}"
  },
  {
    "function_name": "is_transaction_blocked",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
    "lines": "352-357",
    "snippet": "static inline int is_transaction_blocked(struct btrfs_transaction *trans)\n{\n\treturn (trans->state >= TRANS_STATE_BLOCKED &&\n\t\ttrans->state < TRANS_STATE_UNBLOCKED &&\n\t\t!trans->aborted);\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"dev-replace.h\"",
      "#include \"volumes.h\"",
      "#include \"inode-map.h\"",
      "#include \"tree-log.h\"",
      "#include \"locking.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/uuid.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/writeback.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic inline int is_transaction_blocked(struct btrfs_transaction *trans)\n{\n\treturn (trans->state >= TRANS_STATE_BLOCKED &&\n\t\ttrans->state < TRANS_STATE_UNBLOCKED &&\n\t\t!trans->aborted);\n}"
  },
  {
    "function_name": "btrfs_record_root_in_trans",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
    "lines": "330-350",
    "snippet": "int btrfs_record_root_in_trans(struct btrfs_trans_handle *trans,\n\t\t\t       struct btrfs_root *root)\n{\n\tif (!test_bit(BTRFS_ROOT_REF_COWS, &root->state))\n\t\treturn 0;\n\n\t/*\n\t * see record_root_in_trans for comments about IN_TRANS_SETUP usage\n\t * and barriers\n\t */\n\tsmp_rmb();\n\tif (root->last_trans == trans->transid &&\n\t    !test_bit(BTRFS_ROOT_IN_TRANS_SETUP, &root->state))\n\t\treturn 0;\n\n\tmutex_lock(&root->fs_info->reloc_mutex);\n\trecord_root_in_trans(trans, root);\n\tmutex_unlock(&root->fs_info->reloc_mutex);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"dev-replace.h\"",
      "#include \"volumes.h\"",
      "#include \"inode-map.h\"",
      "#include \"tree-log.h\"",
      "#include \"locking.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/uuid.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/writeback.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&root->fs_info->reloc_mutex"
          ],
          "line": 347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "record_root_in_trans",
          "args": [
            "trans",
            "root"
          ],
          "line": 346
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_record_root_in_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
          "lines": "330-350",
          "snippet": "int btrfs_record_root_in_trans(struct btrfs_trans_handle *trans,\n\t\t\t       struct btrfs_root *root)\n{\n\tif (!test_bit(BTRFS_ROOT_REF_COWS, &root->state))\n\t\treturn 0;\n\n\t/*\n\t * see record_root_in_trans for comments about IN_TRANS_SETUP usage\n\t * and barriers\n\t */\n\tsmp_rmb();\n\tif (root->last_trans == trans->transid &&\n\t    !test_bit(BTRFS_ROOT_IN_TRANS_SETUP, &root->state))\n\t\treturn 0;\n\n\tmutex_lock(&root->fs_info->reloc_mutex);\n\trecord_root_in_trans(trans, root);\n\tmutex_unlock(&root->fs_info->reloc_mutex);\n\n\treturn 0;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&root->fs_info->reloc_mutex"
          ],
          "line": 345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "BTRFS_ROOT_IN_TRANS_SETUP",
            "&root->state"
          ],
          "line": 342
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_rmb",
          "args": [],
          "line": 340
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint btrfs_record_root_in_trans(struct btrfs_trans_handle *trans,\n\t\t\t       struct btrfs_root *root)\n{\n\tif (!test_bit(BTRFS_ROOT_REF_COWS, &root->state))\n\t\treturn 0;\n\n\t/*\n\t * see record_root_in_trans for comments about IN_TRANS_SETUP usage\n\t * and barriers\n\t */\n\tsmp_rmb();\n\tif (root->last_trans == trans->transid &&\n\t    !test_bit(BTRFS_ROOT_IN_TRANS_SETUP, &root->state))\n\t\treturn 0;\n\n\tmutex_lock(&root->fs_info->reloc_mutex);\n\trecord_root_in_trans(trans, root);\n\tmutex_unlock(&root->fs_info->reloc_mutex);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "record_root_in_trans",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
    "lines": "272-327",
    "snippet": "static int record_root_in_trans(struct btrfs_trans_handle *trans,\n\t\t\t       struct btrfs_root *root)\n{\n\tif (test_bit(BTRFS_ROOT_REF_COWS, &root->state) &&\n\t    root->last_trans < trans->transid) {\n\t\tWARN_ON(root == root->fs_info->extent_root);\n\t\tWARN_ON(root->commit_root != root->node);\n\n\t\t/*\n\t\t * see below for IN_TRANS_SETUP usage rules\n\t\t * we have the reloc mutex held now, so there\n\t\t * is only one writer in this function\n\t\t */\n\t\tset_bit(BTRFS_ROOT_IN_TRANS_SETUP, &root->state);\n\n\t\t/* make sure readers find IN_TRANS_SETUP before\n\t\t * they find our root->last_trans update\n\t\t */\n\t\tsmp_wmb();\n\n\t\tspin_lock(&root->fs_info->fs_roots_radix_lock);\n\t\tif (root->last_trans == trans->transid) {\n\t\t\tspin_unlock(&root->fs_info->fs_roots_radix_lock);\n\t\t\treturn 0;\n\t\t}\n\t\tradix_tree_tag_set(&root->fs_info->fs_roots_radix,\n\t\t\t   (unsigned long)root->root_key.objectid,\n\t\t\t   BTRFS_ROOT_TRANS_TAG);\n\t\tspin_unlock(&root->fs_info->fs_roots_radix_lock);\n\t\troot->last_trans = trans->transid;\n\n\t\t/* this is pretty tricky.  We don't want to\n\t\t * take the relocation lock in btrfs_record_root_in_trans\n\t\t * unless we're really doing the first setup for this root in\n\t\t * this transaction.\n\t\t *\n\t\t * Normally we'd use root->last_trans as a flag to decide\n\t\t * if we want to take the expensive mutex.\n\t\t *\n\t\t * But, we have to set root->last_trans before we\n\t\t * init the relocation root, otherwise, we trip over warnings\n\t\t * in ctree.c.  The solution used here is to flag ourselves\n\t\t * with root IN_TRANS_SETUP.  When this is 1, we're still\n\t\t * fixing up the reloc trees and everyone must wait.\n\t\t *\n\t\t * When this is zero, they can trust root->last_trans and fly\n\t\t * through btrfs_record_root_in_trans without having to take the\n\t\t * lock.  smp_wmb() makes sure that all the writes above are\n\t\t * done before we pop in the zero below\n\t\t */\n\t\tbtrfs_init_reloc_root(trans, root);\n\t\tsmp_mb__before_atomic();\n\t\tclear_bit(BTRFS_ROOT_IN_TRANS_SETUP, &root->state);\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"dev-replace.h\"",
      "#include \"volumes.h\"",
      "#include \"inode-map.h\"",
      "#include \"tree-log.h\"",
      "#include \"locking.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/uuid.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/writeback.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [
      "#define BTRFS_ROOT_TRANS_TAG 0"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "BTRFS_ROOT_IN_TRANS_SETUP",
            "&root->state"
          ],
          "line": 324
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clear_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "892-896",
          "snippet": "static inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_mb__before_atomic",
          "args": [],
          "line": 323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_init_reloc_root",
          "args": [
            "trans",
            "root"
          ],
          "line": 322
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_init_reloc_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/relocation.c",
          "lines": "1441-1473",
          "snippet": "int btrfs_init_reloc_root(struct btrfs_trans_handle *trans,\n\t\t\t  struct btrfs_root *root)\n{\n\tstruct btrfs_root *reloc_root;\n\tstruct reloc_control *rc = root->fs_info->reloc_ctl;\n\tstruct btrfs_block_rsv *rsv;\n\tint clear_rsv = 0;\n\tint ret;\n\n\tif (root->reloc_root) {\n\t\treloc_root = root->reloc_root;\n\t\treloc_root->last_trans = trans->transid;\n\t\treturn 0;\n\t}\n\n\tif (!rc || !rc->create_reloc_tree ||\n\t    root->root_key.objectid == BTRFS_TREE_RELOC_OBJECTID)\n\t\treturn 0;\n\n\tif (!trans->reloc_reserved) {\n\t\trsv = trans->block_rsv;\n\t\ttrans->block_rsv = rc->block_rsv;\n\t\tclear_rsv = 1;\n\t}\n\treloc_root = create_reloc_root(trans, root, root->root_key.objectid);\n\tif (clear_rsv)\n\t\ttrans->block_rsv = rsv;\n\n\tret = __add_reloc_root(reloc_root);\n\tBUG_ON(ret < 0);\n\troot->reloc_root = reloc_root;\n\treturn 0;\n}",
          "includes": [
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"async-thread.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"async-thread.h\"\n#include \"btrfs_inode.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic noinline_for_stack\nstruct;\n\nint btrfs_init_reloc_root(struct btrfs_trans_handle *trans,\n\t\t\t  struct btrfs_root *root)\n{\n\tstruct btrfs_root *reloc_root;\n\tstruct reloc_control *rc = root->fs_info->reloc_ctl;\n\tstruct btrfs_block_rsv *rsv;\n\tint clear_rsv = 0;\n\tint ret;\n\n\tif (root->reloc_root) {\n\t\treloc_root = root->reloc_root;\n\t\treloc_root->last_trans = trans->transid;\n\t\treturn 0;\n\t}\n\n\tif (!rc || !rc->create_reloc_tree ||\n\t    root->root_key.objectid == BTRFS_TREE_RELOC_OBJECTID)\n\t\treturn 0;\n\n\tif (!trans->reloc_reserved) {\n\t\trsv = trans->block_rsv;\n\t\ttrans->block_rsv = rc->block_rsv;\n\t\tclear_rsv = 1;\n\t}\n\treloc_root = create_reloc_root(trans, root, root->root_key.objectid);\n\tif (clear_rsv)\n\t\ttrans->block_rsv = rsv;\n\n\tret = __add_reloc_root(reloc_root);\n\tBUG_ON(ret < 0);\n\troot->reloc_root = reloc_root;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&root->fs_info->fs_roots_radix_lock"
          ],
          "line": 300
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "radix_tree_tag_set",
          "args": [
            "&root->fs_info->fs_roots_radix",
            "(unsigned long)root->root_key.objectid",
            "BTRFS_ROOT_TRANS_TAG"
          ],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&root->fs_info->fs_roots_radix_lock"
          ],
          "line": 292
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_wmb",
          "args": [],
          "line": 290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "BTRFS_ROOT_IN_TRANS_SETUP",
            "&root->state"
          ],
          "line": 285
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "root->commit_root != root->node"
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "root == root->fs_info->extent_root"
          ],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "BTRFS_ROOT_REF_COWS",
            "&root->state"
          ],
          "line": 275
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\n#define BTRFS_ROOT_TRANS_TAG 0\n\nstatic int record_root_in_trans(struct btrfs_trans_handle *trans,\n\t\t\t       struct btrfs_root *root)\n{\n\tif (test_bit(BTRFS_ROOT_REF_COWS, &root->state) &&\n\t    root->last_trans < trans->transid) {\n\t\tWARN_ON(root == root->fs_info->extent_root);\n\t\tWARN_ON(root->commit_root != root->node);\n\n\t\t/*\n\t\t * see below for IN_TRANS_SETUP usage rules\n\t\t * we have the reloc mutex held now, so there\n\t\t * is only one writer in this function\n\t\t */\n\t\tset_bit(BTRFS_ROOT_IN_TRANS_SETUP, &root->state);\n\n\t\t/* make sure readers find IN_TRANS_SETUP before\n\t\t * they find our root->last_trans update\n\t\t */\n\t\tsmp_wmb();\n\n\t\tspin_lock(&root->fs_info->fs_roots_radix_lock);\n\t\tif (root->last_trans == trans->transid) {\n\t\t\tspin_unlock(&root->fs_info->fs_roots_radix_lock);\n\t\t\treturn 0;\n\t\t}\n\t\tradix_tree_tag_set(&root->fs_info->fs_roots_radix,\n\t\t\t   (unsigned long)root->root_key.objectid,\n\t\t\t   BTRFS_ROOT_TRANS_TAG);\n\t\tspin_unlock(&root->fs_info->fs_roots_radix_lock);\n\t\troot->last_trans = trans->transid;\n\n\t\t/* this is pretty tricky.  We don't want to\n\t\t * take the relocation lock in btrfs_record_root_in_trans\n\t\t * unless we're really doing the first setup for this root in\n\t\t * this transaction.\n\t\t *\n\t\t * Normally we'd use root->last_trans as a flag to decide\n\t\t * if we want to take the expensive mutex.\n\t\t *\n\t\t * But, we have to set root->last_trans before we\n\t\t * init the relocation root, otherwise, we trip over warnings\n\t\t * in ctree.c.  The solution used here is to flag ourselves\n\t\t * with root IN_TRANS_SETUP.  When this is 1, we're still\n\t\t * fixing up the reloc trees and everyone must wait.\n\t\t *\n\t\t * When this is zero, they can trust root->last_trans and fly\n\t\t * through btrfs_record_root_in_trans without having to take the\n\t\t * lock.  smp_wmb() makes sure that all the writes above are\n\t\t * done before we pop in the zero below\n\t\t */\n\t\tbtrfs_init_reloc_root(trans, root);\n\t\tsmp_mb__before_atomic();\n\t\tclear_bit(BTRFS_ROOT_IN_TRANS_SETUP, &root->state);\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "join_transaction",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
    "lines": "151-264",
    "snippet": "static noinline int join_transaction(struct btrfs_root *root, unsigned int type)\n{\n\tstruct btrfs_transaction *cur_trans;\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\n\tspin_lock(&fs_info->trans_lock);\nloop:\n\t/* The file system has been taken offline. No new transactions. */\n\tif (test_bit(BTRFS_FS_STATE_ERROR, &fs_info->fs_state)) {\n\t\tspin_unlock(&fs_info->trans_lock);\n\t\treturn -EROFS;\n\t}\n\n\tcur_trans = fs_info->running_transaction;\n\tif (cur_trans) {\n\t\tif (cur_trans->aborted) {\n\t\t\tspin_unlock(&fs_info->trans_lock);\n\t\t\treturn cur_trans->aborted;\n\t\t}\n\t\tif (btrfs_blocked_trans_types[cur_trans->state] & type) {\n\t\t\tspin_unlock(&fs_info->trans_lock);\n\t\t\treturn -EBUSY;\n\t\t}\n\t\tatomic_inc(&cur_trans->use_count);\n\t\tatomic_inc(&cur_trans->num_writers);\n\t\textwriter_counter_inc(cur_trans, type);\n\t\tspin_unlock(&fs_info->trans_lock);\n\t\treturn 0;\n\t}\n\tspin_unlock(&fs_info->trans_lock);\n\n\t/*\n\t * If we are ATTACH, we just want to catch the current transaction,\n\t * and commit it. If there is no transaction, just return ENOENT.\n\t */\n\tif (type == TRANS_ATTACH)\n\t\treturn -ENOENT;\n\n\t/*\n\t * JOIN_NOLOCK only happens during the transaction commit, so\n\t * it is impossible that ->running_transaction is NULL\n\t */\n\tBUG_ON(type == TRANS_JOIN_NOLOCK);\n\n\tcur_trans = kmem_cache_alloc(btrfs_transaction_cachep, GFP_NOFS);\n\tif (!cur_trans)\n\t\treturn -ENOMEM;\n\n\tspin_lock(&fs_info->trans_lock);\n\tif (fs_info->running_transaction) {\n\t\t/*\n\t\t * someone started a transaction after we unlocked.  Make sure\n\t\t * to redo the checks above\n\t\t */\n\t\tkmem_cache_free(btrfs_transaction_cachep, cur_trans);\n\t\tgoto loop;\n\t} else if (test_bit(BTRFS_FS_STATE_ERROR, &fs_info->fs_state)) {\n\t\tspin_unlock(&fs_info->trans_lock);\n\t\tkmem_cache_free(btrfs_transaction_cachep, cur_trans);\n\t\treturn -EROFS;\n\t}\n\n\tatomic_set(&cur_trans->num_writers, 1);\n\textwriter_counter_init(cur_trans, type);\n\tinit_waitqueue_head(&cur_trans->writer_wait);\n\tinit_waitqueue_head(&cur_trans->commit_wait);\n\tcur_trans->state = TRANS_STATE_RUNNING;\n\t/*\n\t * One for this trans handle, one so it will live on until we\n\t * commit the transaction.\n\t */\n\tatomic_set(&cur_trans->use_count, 2);\n\tcur_trans->have_free_bgs = 0;\n\tcur_trans->start_time = get_seconds();\n\n\tcur_trans->delayed_refs.href_root = RB_ROOT;\n\tatomic_set(&cur_trans->delayed_refs.num_entries, 0);\n\tcur_trans->delayed_refs.num_heads_ready = 0;\n\tcur_trans->delayed_refs.num_heads = 0;\n\tcur_trans->delayed_refs.flushing = 0;\n\tcur_trans->delayed_refs.run_delayed_start = 0;\n\n\t/*\n\t * although the tree mod log is per file system and not per transaction,\n\t * the log must never go across transaction boundaries.\n\t */\n\tsmp_mb();\n\tif (!list_empty(&fs_info->tree_mod_seq_list))\n\t\tWARN(1, KERN_ERR \"BTRFS: tree_mod_seq_list not empty when \"\n\t\t\t\"creating a fresh transaction\\n\");\n\tif (!RB_EMPTY_ROOT(&fs_info->tree_mod_log))\n\t\tWARN(1, KERN_ERR \"BTRFS: tree_mod_log rb tree not empty when \"\n\t\t\t\"creating a fresh transaction\\n\");\n\tatomic64_set(&fs_info->tree_mod_seq, 0);\n\n\tspin_lock_init(&cur_trans->delayed_refs.lock);\n\n\tINIT_LIST_HEAD(&cur_trans->pending_snapshots);\n\tINIT_LIST_HEAD(&cur_trans->pending_chunks);\n\tINIT_LIST_HEAD(&cur_trans->switch_commits);\n\tINIT_LIST_HEAD(&cur_trans->pending_ordered);\n\tINIT_LIST_HEAD(&cur_trans->dirty_bgs);\n\tspin_lock_init(&cur_trans->dirty_bgs_lock);\n\tlist_add_tail(&cur_trans->list, &fs_info->trans_list);\n\textent_io_tree_init(&cur_trans->dirty_pages,\n\t\t\t     fs_info->btree_inode->i_mapping);\n\tfs_info->generation++;\n\tcur_trans->transid = fs_info->generation;\n\tfs_info->running_transaction = cur_trans;\n\tcur_trans->aborted = 0;\n\tspin_unlock(&fs_info->trans_lock);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"dev-replace.h\"",
      "#include \"volumes.h\"",
      "#include \"inode-map.h\"",
      "#include \"tree-log.h\"",
      "#include \"locking.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/uuid.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/writeback.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned int btrfs_blocked_trans_types[TRANS_STATE_MAX] = {\n\t[TRANS_STATE_RUNNING]\t\t= 0U,\n\t[TRANS_STATE_BLOCKED]\t\t= (__TRANS_USERSPACE |\n\t\t\t\t\t   __TRANS_START),\n\t[TRANS_STATE_COMMIT_START]\t= (__TRANS_USERSPACE |\n\t\t\t\t\t   __TRANS_START |\n\t\t\t\t\t   __TRANS_ATTACH),\n\t[TRANS_STATE_COMMIT_DOING]\t= (__TRANS_USERSPACE |\n\t\t\t\t\t   __TRANS_START |\n\t\t\t\t\t   __TRANS_ATTACH |\n\t\t\t\t\t   __TRANS_JOIN),\n\t[TRANS_STATE_UNBLOCKED]\t\t= (__TRANS_USERSPACE |\n\t\t\t\t\t   __TRANS_START |\n\t\t\t\t\t   __TRANS_ATTACH |\n\t\t\t\t\t   __TRANS_JOIN |\n\t\t\t\t\t   __TRANS_JOIN_NOLOCK),\n\t[TRANS_STATE_COMPLETED]\t\t= (__TRANS_USERSPACE |\n\t\t\t\t\t   __TRANS_START |\n\t\t\t\t\t   __TRANS_ATTACH |\n\t\t\t\t\t   __TRANS_JOIN |\n\t\t\t\t\t   __TRANS_JOIN_NOLOCK),\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&fs_info->trans_lock"
          ],
          "line": 261
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "extent_io_tree_init",
          "args": [
            "&cur_trans->dirty_pages",
            "fs_info->btree_inode->i_mapping"
          ],
          "line": 255
        },
        "resolved": true,
        "details": {
          "function_name": "extent_io_tree_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "198-206",
          "snippet": "void extent_io_tree_init(struct extent_io_tree *tree,\n\t\t\t struct address_space *mapping)\n{\n\ttree->state = RB_ROOT;\n\ttree->ops = NULL;\n\ttree->dirty_bytes = 0;\n\tspin_lock_init(&tree->lock);\n\ttree->mapping = mapping;\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nvoid extent_io_tree_init(struct extent_io_tree *tree,\n\t\t\t struct address_space *mapping)\n{\n\ttree->state = RB_ROOT;\n\ttree->ops = NULL;\n\ttree->dirty_bytes = 0;\n\tspin_lock_init(&tree->lock);\n\ttree->mapping = mapping;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&cur_trans->list",
            "&fs_info->trans_list"
          ],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&cur_trans->dirty_bgs_lock"
          ],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&cur_trans->dirty_bgs"
          ],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&cur_trans->pending_ordered"
          ],
          "line": 251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&cur_trans->switch_commits"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&cur_trans->pending_chunks"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&cur_trans->pending_snapshots"
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&cur_trans->delayed_refs.lock"
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic64_set",
          "args": [
            "&fs_info->tree_mod_seq",
            "0"
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "1",
            "KERN_ERR \"BTRFS: tree_mod_log rb tree not empty when \"\n\t\t\t\"creating a fresh transaction\\n\""
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RB_EMPTY_ROOT",
          "args": [
            "&fs_info->tree_mod_log"
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "1",
            "KERN_ERR \"BTRFS: tree_mod_seq_list not empty when \"\n\t\t\t\"creating a fresh transaction\\n\""
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&fs_info->tree_mod_seq_list"
          ],
          "line": 238
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_mb",
          "args": [],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&cur_trans->delayed_refs.num_entries",
            "0"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_seconds",
          "args": [],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&cur_trans->use_count",
            "2"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_waitqueue_head",
          "args": [
            "&cur_trans->commit_wait"
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_waitqueue_head",
          "args": [
            "&cur_trans->writer_wait"
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "extwriter_counter_init",
          "args": [
            "cur_trans",
            "type"
          ],
          "line": 214
        },
        "resolved": true,
        "details": {
          "function_name": "extwriter_counter_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
          "lines": "137-141",
          "snippet": "static inline void extwriter_counter_init(struct btrfs_transaction *trans,\n\t\t\t\t\t  unsigned int type)\n{\n\tatomic_set(&trans->num_extwriters, ((type & TRANS_EXTWRITERS) ? 1 : 0));\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"dev-replace.h\"",
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic inline void extwriter_counter_init(struct btrfs_transaction *trans,\n\t\t\t\t\t  unsigned int type)\n{\n\tatomic_set(&trans->num_extwriters, ((type & TRANS_EXTWRITERS) ? 1 : 0));\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&cur_trans->num_writers",
            "1"
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "btrfs_transaction_cachep",
            "cur_trans"
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "BTRFS_FS_STATE_ERROR",
            "&fs_info->fs_state"
          ],
          "line": 207
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "btrfs_transaction_cachep",
            "cur_trans"
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&fs_info->trans_lock"
          ],
          "line": 199
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmem_cache_alloc",
          "args": [
            "btrfs_transaction_cachep",
            "GFP_NOFS"
          ],
          "line": 195
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_kmem_cache_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1064-1076",
          "snippet": "static inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\nretry:\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry) {\n\t\tcond_resched();\n\t\tgoto retry;\n\t}\n\n\treturn entry;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\nretry:\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry) {\n\t\tcond_resched();\n\t\tgoto retry;\n\t}\n\n\treturn entry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "type == TRANS_JOIN_NOLOCK"
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "extwriter_counter_inc",
          "args": [
            "cur_trans",
            "type"
          ],
          "line": 176
        },
        "resolved": true,
        "details": {
          "function_name": "extwriter_counter_inc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
          "lines": "123-128",
          "snippet": "static inline void extwriter_counter_inc(struct btrfs_transaction *trans,\n\t\t\t\t\t unsigned int type)\n{\n\tif (type & TRANS_EXTWRITERS)\n\t\tatomic_inc(&trans->num_extwriters);\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"dev-replace.h\"",
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic inline void extwriter_counter_inc(struct btrfs_transaction *trans,\n\t\t\t\t\t unsigned int type)\n{\n\tif (type & TRANS_EXTWRITERS)\n\t\tatomic_inc(&trans->num_extwriters);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&cur_trans->num_writers"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&cur_trans->use_count"
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic unsigned int btrfs_blocked_trans_types[TRANS_STATE_MAX] = {\n\t[TRANS_STATE_RUNNING]\t\t= 0U,\n\t[TRANS_STATE_BLOCKED]\t\t= (__TRANS_USERSPACE |\n\t\t\t\t\t   __TRANS_START),\n\t[TRANS_STATE_COMMIT_START]\t= (__TRANS_USERSPACE |\n\t\t\t\t\t   __TRANS_START |\n\t\t\t\t\t   __TRANS_ATTACH),\n\t[TRANS_STATE_COMMIT_DOING]\t= (__TRANS_USERSPACE |\n\t\t\t\t\t   __TRANS_START |\n\t\t\t\t\t   __TRANS_ATTACH |\n\t\t\t\t\t   __TRANS_JOIN),\n\t[TRANS_STATE_UNBLOCKED]\t\t= (__TRANS_USERSPACE |\n\t\t\t\t\t   __TRANS_START |\n\t\t\t\t\t   __TRANS_ATTACH |\n\t\t\t\t\t   __TRANS_JOIN |\n\t\t\t\t\t   __TRANS_JOIN_NOLOCK),\n\t[TRANS_STATE_COMPLETED]\t\t= (__TRANS_USERSPACE |\n\t\t\t\t\t   __TRANS_START |\n\t\t\t\t\t   __TRANS_ATTACH |\n\t\t\t\t\t   __TRANS_JOIN |\n\t\t\t\t\t   __TRANS_JOIN_NOLOCK),\n};\n\nstatic noinline int join_transaction(struct btrfs_root *root, unsigned int type)\n{\n\tstruct btrfs_transaction *cur_trans;\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\n\tspin_lock(&fs_info->trans_lock);\nloop:\n\t/* The file system has been taken offline. No new transactions. */\n\tif (test_bit(BTRFS_FS_STATE_ERROR, &fs_info->fs_state)) {\n\t\tspin_unlock(&fs_info->trans_lock);\n\t\treturn -EROFS;\n\t}\n\n\tcur_trans = fs_info->running_transaction;\n\tif (cur_trans) {\n\t\tif (cur_trans->aborted) {\n\t\t\tspin_unlock(&fs_info->trans_lock);\n\t\t\treturn cur_trans->aborted;\n\t\t}\n\t\tif (btrfs_blocked_trans_types[cur_trans->state] & type) {\n\t\t\tspin_unlock(&fs_info->trans_lock);\n\t\t\treturn -EBUSY;\n\t\t}\n\t\tatomic_inc(&cur_trans->use_count);\n\t\tatomic_inc(&cur_trans->num_writers);\n\t\textwriter_counter_inc(cur_trans, type);\n\t\tspin_unlock(&fs_info->trans_lock);\n\t\treturn 0;\n\t}\n\tspin_unlock(&fs_info->trans_lock);\n\n\t/*\n\t * If we are ATTACH, we just want to catch the current transaction,\n\t * and commit it. If there is no transaction, just return ENOENT.\n\t */\n\tif (type == TRANS_ATTACH)\n\t\treturn -ENOENT;\n\n\t/*\n\t * JOIN_NOLOCK only happens during the transaction commit, so\n\t * it is impossible that ->running_transaction is NULL\n\t */\n\tBUG_ON(type == TRANS_JOIN_NOLOCK);\n\n\tcur_trans = kmem_cache_alloc(btrfs_transaction_cachep, GFP_NOFS);\n\tif (!cur_trans)\n\t\treturn -ENOMEM;\n\n\tspin_lock(&fs_info->trans_lock);\n\tif (fs_info->running_transaction) {\n\t\t/*\n\t\t * someone started a transaction after we unlocked.  Make sure\n\t\t * to redo the checks above\n\t\t */\n\t\tkmem_cache_free(btrfs_transaction_cachep, cur_trans);\n\t\tgoto loop;\n\t} else if (test_bit(BTRFS_FS_STATE_ERROR, &fs_info->fs_state)) {\n\t\tspin_unlock(&fs_info->trans_lock);\n\t\tkmem_cache_free(btrfs_transaction_cachep, cur_trans);\n\t\treturn -EROFS;\n\t}\n\n\tatomic_set(&cur_trans->num_writers, 1);\n\textwriter_counter_init(cur_trans, type);\n\tinit_waitqueue_head(&cur_trans->writer_wait);\n\tinit_waitqueue_head(&cur_trans->commit_wait);\n\tcur_trans->state = TRANS_STATE_RUNNING;\n\t/*\n\t * One for this trans handle, one so it will live on until we\n\t * commit the transaction.\n\t */\n\tatomic_set(&cur_trans->use_count, 2);\n\tcur_trans->have_free_bgs = 0;\n\tcur_trans->start_time = get_seconds();\n\n\tcur_trans->delayed_refs.href_root = RB_ROOT;\n\tatomic_set(&cur_trans->delayed_refs.num_entries, 0);\n\tcur_trans->delayed_refs.num_heads_ready = 0;\n\tcur_trans->delayed_refs.num_heads = 0;\n\tcur_trans->delayed_refs.flushing = 0;\n\tcur_trans->delayed_refs.run_delayed_start = 0;\n\n\t/*\n\t * although the tree mod log is per file system and not per transaction,\n\t * the log must never go across transaction boundaries.\n\t */\n\tsmp_mb();\n\tif (!list_empty(&fs_info->tree_mod_seq_list))\n\t\tWARN(1, KERN_ERR \"BTRFS: tree_mod_seq_list not empty when \"\n\t\t\t\"creating a fresh transaction\\n\");\n\tif (!RB_EMPTY_ROOT(&fs_info->tree_mod_log))\n\t\tWARN(1, KERN_ERR \"BTRFS: tree_mod_log rb tree not empty when \"\n\t\t\t\"creating a fresh transaction\\n\");\n\tatomic64_set(&fs_info->tree_mod_seq, 0);\n\n\tspin_lock_init(&cur_trans->delayed_refs.lock);\n\n\tINIT_LIST_HEAD(&cur_trans->pending_snapshots);\n\tINIT_LIST_HEAD(&cur_trans->pending_chunks);\n\tINIT_LIST_HEAD(&cur_trans->switch_commits);\n\tINIT_LIST_HEAD(&cur_trans->pending_ordered);\n\tINIT_LIST_HEAD(&cur_trans->dirty_bgs);\n\tspin_lock_init(&cur_trans->dirty_bgs_lock);\n\tlist_add_tail(&cur_trans->list, &fs_info->trans_list);\n\textent_io_tree_init(&cur_trans->dirty_pages,\n\t\t\t     fs_info->btree_inode->i_mapping);\n\tfs_info->generation++;\n\tcur_trans->transid = fs_info->generation;\n\tfs_info->running_transaction = cur_trans;\n\tcur_trans->aborted = 0;\n\tspin_unlock(&fs_info->trans_lock);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "extwriter_counter_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
    "lines": "143-146",
    "snippet": "static inline int extwriter_counter_read(struct btrfs_transaction *trans)\n{\n\treturn atomic_read(&trans->num_extwriters);\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"dev-replace.h\"",
      "#include \"volumes.h\"",
      "#include \"inode-map.h\"",
      "#include \"tree-log.h\"",
      "#include \"locking.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/uuid.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/writeback.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&trans->num_extwriters"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic inline int extwriter_counter_read(struct btrfs_transaction *trans)\n{\n\treturn atomic_read(&trans->num_extwriters);\n}"
  },
  {
    "function_name": "extwriter_counter_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
    "lines": "137-141",
    "snippet": "static inline void extwriter_counter_init(struct btrfs_transaction *trans,\n\t\t\t\t\t  unsigned int type)\n{\n\tatomic_set(&trans->num_extwriters, ((type & TRANS_EXTWRITERS) ? 1 : 0));\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"dev-replace.h\"",
      "#include \"volumes.h\"",
      "#include \"inode-map.h\"",
      "#include \"tree-log.h\"",
      "#include \"locking.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/uuid.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/writeback.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&trans->num_extwriters",
            "((type & TRANS_EXTWRITERS) ? 1 : 0)"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic inline void extwriter_counter_init(struct btrfs_transaction *trans,\n\t\t\t\t\t  unsigned int type)\n{\n\tatomic_set(&trans->num_extwriters, ((type & TRANS_EXTWRITERS) ? 1 : 0));\n}"
  },
  {
    "function_name": "extwriter_counter_dec",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
    "lines": "130-135",
    "snippet": "static inline void extwriter_counter_dec(struct btrfs_transaction *trans,\n\t\t\t\t\t unsigned int type)\n{\n\tif (type & TRANS_EXTWRITERS)\n\t\tatomic_dec(&trans->num_extwriters);\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"dev-replace.h\"",
      "#include \"volumes.h\"",
      "#include \"inode-map.h\"",
      "#include \"tree-log.h\"",
      "#include \"locking.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/uuid.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/writeback.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_dec",
          "args": [
            "&trans->num_extwriters"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic inline void extwriter_counter_dec(struct btrfs_transaction *trans,\n\t\t\t\t\t unsigned int type)\n{\n\tif (type & TRANS_EXTWRITERS)\n\t\tatomic_dec(&trans->num_extwriters);\n}"
  },
  {
    "function_name": "extwriter_counter_inc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
    "lines": "123-128",
    "snippet": "static inline void extwriter_counter_inc(struct btrfs_transaction *trans,\n\t\t\t\t\t unsigned int type)\n{\n\tif (type & TRANS_EXTWRITERS)\n\t\tatomic_inc(&trans->num_extwriters);\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"dev-replace.h\"",
      "#include \"volumes.h\"",
      "#include \"inode-map.h\"",
      "#include \"tree-log.h\"",
      "#include \"locking.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/uuid.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/writeback.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&trans->num_extwriters"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic inline void extwriter_counter_inc(struct btrfs_transaction *trans,\n\t\t\t\t\t unsigned int type)\n{\n\tif (type & TRANS_EXTWRITERS)\n\t\tatomic_inc(&trans->num_extwriters);\n}"
  },
  {
    "function_name": "switch_commit_roots",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
    "lines": "105-121",
    "snippet": "static noinline void switch_commit_roots(struct btrfs_transaction *trans,\n\t\t\t\t\t struct btrfs_fs_info *fs_info)\n{\n\tstruct btrfs_root *root, *tmp;\n\n\tdown_write(&fs_info->commit_root_sem);\n\tlist_for_each_entry_safe(root, tmp, &trans->switch_commits,\n\t\t\t\t dirty_list) {\n\t\tlist_del_init(&root->dirty_list);\n\t\tfree_extent_buffer(root->commit_root);\n\t\troot->commit_root = btrfs_root_node(root);\n\t\tif (is_fstree(root->objectid))\n\t\t\tbtrfs_unpin_free_ino(root);\n\t\tclear_btree_io_tree(&root->dirty_log_pages);\n\t}\n\tup_write(&fs_info->commit_root_sem);\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"dev-replace.h\"",
      "#include \"volumes.h\"",
      "#include \"inode-map.h\"",
      "#include \"tree-log.h\"",
      "#include \"locking.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/uuid.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/writeback.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&fs_info->commit_root_sem"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_btree_io_tree",
          "args": [
            "&root->dirty_log_pages"
          ],
          "line": 118
        },
        "resolved": true,
        "details": {
          "function_name": "clear_btree_io_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
          "lines": "79-103",
          "snippet": "static void clear_btree_io_tree(struct extent_io_tree *tree)\n{\n\tspin_lock(&tree->lock);\n\twhile (!RB_EMPTY_ROOT(&tree->state)) {\n\t\tstruct rb_node *node;\n\t\tstruct extent_state *state;\n\n\t\tnode = rb_first(&tree->state);\n\t\tstate = rb_entry(node, struct extent_state, rb_node);\n\t\trb_erase(&state->rb_node, &tree->state);\n\t\tRB_CLEAR_NODE(&state->rb_node);\n\t\t/*\n\t\t * btree io trees aren't supposed to have tasks waiting for\n\t\t * changes in the flags of extent states ever.\n\t\t */\n\t\tASSERT(!waitqueue_active(&state->wq));\n\t\tfree_extent_state(state);\n\t\tif (need_resched()) {\n\t\t\tspin_unlock(&tree->lock);\n\t\t\tcond_resched();\n\t\t\tspin_lock(&tree->lock);\n\t\t}\n\t}\n\tspin_unlock(&tree->lock);\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"dev-replace.h\"",
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void clear_btree_io_tree(struct extent_io_tree *tree)\n{\n\tspin_lock(&tree->lock);\n\twhile (!RB_EMPTY_ROOT(&tree->state)) {\n\t\tstruct rb_node *node;\n\t\tstruct extent_state *state;\n\n\t\tnode = rb_first(&tree->state);\n\t\tstate = rb_entry(node, struct extent_state, rb_node);\n\t\trb_erase(&state->rb_node, &tree->state);\n\t\tRB_CLEAR_NODE(&state->rb_node);\n\t\t/*\n\t\t * btree io trees aren't supposed to have tasks waiting for\n\t\t * changes in the flags of extent states ever.\n\t\t */\n\t\tASSERT(!waitqueue_active(&state->wq));\n\t\tfree_extent_state(state);\n\t\tif (need_resched()) {\n\t\t\tspin_unlock(&tree->lock);\n\t\t\tcond_resched();\n\t\t\tspin_lock(&tree->lock);\n\t\t}\n\t}\n\tspin_unlock(&tree->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_unpin_free_ino",
          "args": [
            "root"
          ],
          "line": 117
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_unpin_free_ino",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/inode-map.c",
          "lines": "245-276",
          "snippet": "void btrfs_unpin_free_ino(struct btrfs_root *root)\n{\n\tstruct btrfs_free_space_ctl *ctl = root->free_ino_ctl;\n\tstruct rb_root *rbroot = &root->free_ino_pinned->free_space_offset;\n\tstruct btrfs_free_space *info;\n\tstruct rb_node *n;\n\tu64 count;\n\n\tif (!btrfs_test_opt(root, INODE_MAP_CACHE))\n\t\treturn;\n\n\twhile (1) {\n\t\tn = rb_first(rbroot);\n\t\tif (!n)\n\t\t\tbreak;\n\n\t\tinfo = rb_entry(n, struct btrfs_free_space, offset_index);\n\t\tBUG_ON(info->bitmap); /* Logic error */\n\n\t\tif (info->offset > root->ino_cache_progress)\n\t\t\tgoto free;\n\t\telse if (info->offset + info->bytes > root->ino_cache_progress)\n\t\t\tcount = root->ino_cache_progress - info->offset + 1;\n\t\telse\n\t\t\tcount = info->bytes;\n\n\t\t__btrfs_add_free_space(ctl, info->offset, count);\nfree:\n\t\trb_erase(&info->offset_index, rbroot);\n\t\tkfree(info);\n\t}\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n\nvoid btrfs_unpin_free_ino(struct btrfs_root *root)\n{\n\tstruct btrfs_free_space_ctl *ctl = root->free_ino_ctl;\n\tstruct rb_root *rbroot = &root->free_ino_pinned->free_space_offset;\n\tstruct btrfs_free_space *info;\n\tstruct rb_node *n;\n\tu64 count;\n\n\tif (!btrfs_test_opt(root, INODE_MAP_CACHE))\n\t\treturn;\n\n\twhile (1) {\n\t\tn = rb_first(rbroot);\n\t\tif (!n)\n\t\t\tbreak;\n\n\t\tinfo = rb_entry(n, struct btrfs_free_space, offset_index);\n\t\tBUG_ON(info->bitmap); /* Logic error */\n\n\t\tif (info->offset > root->ino_cache_progress)\n\t\t\tgoto free;\n\t\telse if (info->offset + info->bytes > root->ino_cache_progress)\n\t\t\tcount = root->ino_cache_progress - info->offset + 1;\n\t\telse\n\t\t\tcount = info->bytes;\n\n\t\t__btrfs_add_free_space(ctl, info->offset, count);\nfree:\n\t\trb_erase(&info->offset_index, rbroot);\n\t\tkfree(info);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_fstree",
          "args": [
            "root->objectid"
          ],
          "line": 116
        },
        "resolved": true,
        "details": {
          "function_name": "is_fstree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "4180-4186",
          "snippet": "static inline int is_fstree(u64 rootid)\n{\n\tif (rootid == BTRFS_FS_TREE_OBJECTID ||\n\t    (s64)rootid >= (s64)BTRFS_FIRST_FREE_OBJECTID)\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [
            "#define BTRFS_FIRST_FREE_OBJECTID 256ULL",
            "#define BTRFS_FS_TREE_OBJECTID 5ULL"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\n#define BTRFS_FIRST_FREE_OBJECTID 256ULL\n#define BTRFS_FS_TREE_OBJECTID 5ULL\n\nstatic inline int is_fstree(u64 rootid)\n{\n\tif (rootid == BTRFS_FS_TREE_OBJECTID ||\n\t    (s64)rootid >= (s64)BTRFS_FIRST_FREE_OBJECTID)\n\t\treturn 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_root_node",
          "args": [
            "root"
          ],
          "line": 115
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_root_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "148-170",
          "snippet": "struct extent_buffer *btrfs_root_node(struct btrfs_root *root)\n{\n\tstruct extent_buffer *eb;\n\n\twhile (1) {\n\t\trcu_read_lock();\n\t\teb = rcu_dereference(root->node);\n\n\t\t/*\n\t\t * RCU really hurts here, we could free up the root node because\n\t\t * it was cow'ed but we may not get the new root node yet so do\n\t\t * the inc_not_zero dance and if it doesn't work then\n\t\t * synchronize_rcu and try again.\n\t\t */\n\t\tif (atomic_inc_not_zero(&eb->refs)) {\n\t\t\trcu_read_unlock();\n\t\t\tbreak;\n\t\t}\n\t\trcu_read_unlock();\n\t\tsynchronize_rcu();\n\t}\n\treturn eb;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int tree_mod_log_free_eb(struct btrfs_fs_info *fs_info,\n\t\t\t\t struct extent_buffer *eb);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int tree_mod_log_free_eb(struct btrfs_fs_info *fs_info,\n\t\t\t\t struct extent_buffer *eb);\nstatic noinline struct;\n\nstruct extent_buffer *btrfs_root_node(struct btrfs_root *root)\n{\n\tstruct extent_buffer *eb;\n\n\twhile (1) {\n\t\trcu_read_lock();\n\t\teb = rcu_dereference(root->node);\n\n\t\t/*\n\t\t * RCU really hurts here, we could free up the root node because\n\t\t * it was cow'ed but we may not get the new root node yet so do\n\t\t * the inc_not_zero dance and if it doesn't work then\n\t\t * synchronize_rcu and try again.\n\t\t */\n\t\tif (atomic_inc_not_zero(&eb->refs)) {\n\t\t\trcu_read_unlock();\n\t\t\tbreak;\n\t\t}\n\t\trcu_read_unlock();\n\t\tsynchronize_rcu();\n\t}\n\treturn eb;\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_extent_buffer",
          "args": [
            "root->commit_root"
          ],
          "line": 114
        },
        "resolved": true,
        "details": {
          "function_name": "free_extent_buffer_stale",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "5019-5031",
          "snippet": "void free_extent_buffer_stale(struct extent_buffer *eb)\n{\n\tif (!eb)\n\t\treturn;\n\n\tspin_lock(&eb->refs_lock);\n\tset_bit(EXTENT_BUFFER_STALE, &eb->bflags);\n\n\tif (atomic_read(&eb->refs) == 2 && !extent_buffer_under_io(eb) &&\n\t    test_and_clear_bit(EXTENT_BUFFER_TREE_REF, &eb->bflags))\n\t\tatomic_dec(&eb->refs);\n\trelease_extent_buffer(eb);\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nvoid free_extent_buffer_stale(struct extent_buffer *eb)\n{\n\tif (!eb)\n\t\treturn;\n\n\tspin_lock(&eb->refs_lock);\n\tset_bit(EXTENT_BUFFER_STALE, &eb->bflags);\n\n\tif (atomic_read(&eb->refs) == 2 && !extent_buffer_under_io(eb) &&\n\t    test_and_clear_bit(EXTENT_BUFFER_TREE_REF, &eb->bflags))\n\t\tatomic_dec(&eb->refs);\n\trelease_extent_buffer(eb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&root->dirty_list"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "root",
            "tmp",
            "&trans->switch_commits",
            "dirty_list"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&fs_info->commit_root_sem"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic noinline void switch_commit_roots(struct btrfs_transaction *trans,\n\t\t\t\t\t struct btrfs_fs_info *fs_info)\n{\n\tstruct btrfs_root *root, *tmp;\n\n\tdown_write(&fs_info->commit_root_sem);\n\tlist_for_each_entry_safe(root, tmp, &trans->switch_commits,\n\t\t\t\t dirty_list) {\n\t\tlist_del_init(&root->dirty_list);\n\t\tfree_extent_buffer(root->commit_root);\n\t\troot->commit_root = btrfs_root_node(root);\n\t\tif (is_fstree(root->objectid))\n\t\t\tbtrfs_unpin_free_ino(root);\n\t\tclear_btree_io_tree(&root->dirty_log_pages);\n\t}\n\tup_write(&fs_info->commit_root_sem);\n}"
  },
  {
    "function_name": "clear_btree_io_tree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
    "lines": "79-103",
    "snippet": "static void clear_btree_io_tree(struct extent_io_tree *tree)\n{\n\tspin_lock(&tree->lock);\n\twhile (!RB_EMPTY_ROOT(&tree->state)) {\n\t\tstruct rb_node *node;\n\t\tstruct extent_state *state;\n\n\t\tnode = rb_first(&tree->state);\n\t\tstate = rb_entry(node, struct extent_state, rb_node);\n\t\trb_erase(&state->rb_node, &tree->state);\n\t\tRB_CLEAR_NODE(&state->rb_node);\n\t\t/*\n\t\t * btree io trees aren't supposed to have tasks waiting for\n\t\t * changes in the flags of extent states ever.\n\t\t */\n\t\tASSERT(!waitqueue_active(&state->wq));\n\t\tfree_extent_state(state);\n\t\tif (need_resched()) {\n\t\t\tspin_unlock(&tree->lock);\n\t\t\tcond_resched();\n\t\t\tspin_lock(&tree->lock);\n\t\t}\n\t}\n\tspin_unlock(&tree->lock);\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"dev-replace.h\"",
      "#include \"volumes.h\"",
      "#include \"inode-map.h\"",
      "#include \"tree-log.h\"",
      "#include \"locking.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/uuid.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/writeback.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&tree->lock"
          ],
          "line": 102
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&tree->lock"
          ],
          "line": 99
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "need_resched",
          "args": [],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_extent_state",
          "args": [
            "state"
          ],
          "line": 95
        },
        "resolved": true,
        "details": {
          "function_name": "free_extent_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "225-235",
          "snippet": "void free_extent_state(struct extent_state *state)\n{\n\tif (!state)\n\t\treturn;\n\tif (atomic_dec_and_test(&state->refs)) {\n\t\tWARN_ON(extent_state_in_tree(state));\n\t\tbtrfs_leak_debug_del(&state->leak_list);\n\t\ttrace_free_extent_state(state, _RET_IP_);\n\t\tkmem_cache_free(extent_state_cache, state);\n\t}\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *extent_state_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic struct kmem_cache *extent_state_cache;\n\nvoid free_extent_state(struct extent_state *state)\n{\n\tif (!state)\n\t\treturn;\n\tif (atomic_dec_and_test(&state->refs)) {\n\t\tWARN_ON(extent_state_in_tree(state));\n\t\tbtrfs_leak_debug_del(&state->leak_list);\n\t\ttrace_free_extent_state(state, _RET_IP_);\n\t\tkmem_cache_free(extent_state_cache, state);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "!waitqueue_active(&state->wq)"
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "waitqueue_active",
          "args": [
            "&state->wq"
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RB_CLEAR_NODE",
          "args": [
            "&state->rb_node"
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_erase",
          "args": [
            "&state->rb_node",
            "&tree->state"
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "node",
            "structextent_state",
            "rb_node"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_first",
          "args": [
            "&tree->state"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RB_EMPTY_ROOT",
          "args": [
            "&tree->state"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void clear_btree_io_tree(struct extent_io_tree *tree)\n{\n\tspin_lock(&tree->lock);\n\twhile (!RB_EMPTY_ROOT(&tree->state)) {\n\t\tstruct rb_node *node;\n\t\tstruct extent_state *state;\n\n\t\tnode = rb_first(&tree->state);\n\t\tstate = rb_entry(node, struct extent_state, rb_node);\n\t\trb_erase(&state->rb_node, &tree->state);\n\t\tRB_CLEAR_NODE(&state->rb_node);\n\t\t/*\n\t\t * btree io trees aren't supposed to have tasks waiting for\n\t\t * changes in the flags of extent states ever.\n\t\t */\n\t\tASSERT(!waitqueue_active(&state->wq));\n\t\tfree_extent_state(state);\n\t\tif (need_resched()) {\n\t\t\tspin_unlock(&tree->lock);\n\t\t\tcond_resched();\n\t\t\tspin_lock(&tree->lock);\n\t\t}\n\t}\n\tspin_unlock(&tree->lock);\n}"
  },
  {
    "function_name": "btrfs_put_transaction",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
    "lines": "61-77",
    "snippet": "void btrfs_put_transaction(struct btrfs_transaction *transaction)\n{\n\tWARN_ON(atomic_read(&transaction->use_count) == 0);\n\tif (atomic_dec_and_test(&transaction->use_count)) {\n\t\tBUG_ON(!list_empty(&transaction->list));\n\t\tWARN_ON(!RB_EMPTY_ROOT(&transaction->delayed_refs.href_root));\n\t\twhile (!list_empty(&transaction->pending_chunks)) {\n\t\t\tstruct extent_map *em;\n\n\t\t\tem = list_first_entry(&transaction->pending_chunks,\n\t\t\t\t\t      struct extent_map, list);\n\t\t\tlist_del_init(&em->list);\n\t\t\tfree_extent_map(em);\n\t\t}\n\t\tkmem_cache_free(btrfs_transaction_cachep, transaction);\n\t}\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"dev-replace.h\"",
      "#include \"volumes.h\"",
      "#include \"inode-map.h\"",
      "#include \"tree-log.h\"",
      "#include \"locking.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/uuid.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/writeback.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "btrfs_transaction_cachep",
            "transaction"
          ],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_extent_map",
          "args": [
            "em"
          ],
          "line": 73
        },
        "resolved": true,
        "details": {
          "function_name": "free_extent_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_map.c",
          "lines": "70-82",
          "snippet": "void free_extent_map(struct extent_map *em)\n{\n\tif (!em)\n\t\treturn;\n\tWARN_ON(atomic_read(&em->refs) == 0);\n\tif (atomic_dec_and_test(&em->refs)) {\n\t\tWARN_ON(extent_map_in_tree(em));\n\t\tWARN_ON(!list_empty(&em->list));\n\t\tif (test_bit(EXTENT_FLAG_FS_MAPPING, &em->flags))\n\t\t\tkfree(em->bdev);\n\t\tkmem_cache_free(extent_map_cache, em);\n\t}\n}",
          "includes": [
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <linux/hardirq.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *extent_map_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <linux/hardirq.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n\nstatic struct kmem_cache *extent_map_cache;\n\nvoid free_extent_map(struct extent_map *em)\n{\n\tif (!em)\n\t\treturn;\n\tWARN_ON(atomic_read(&em->refs) == 0);\n\tif (atomic_dec_and_test(&em->refs)) {\n\t\tWARN_ON(extent_map_in_tree(em));\n\t\tWARN_ON(!list_empty(&em->list));\n\t\tif (test_bit(EXTENT_FLAG_FS_MAPPING, &em->flags))\n\t\t\tkfree(em->bdev);\n\t\tkmem_cache_free(extent_map_cache, em);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&em->list"
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_first_entry",
          "args": [
            "&transaction->pending_chunks",
            "structextent_map",
            "list"
          ],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&transaction->pending_chunks"
          ],
          "line": 67
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!RB_EMPTY_ROOT(&transaction->delayed_refs.href_root)"
          ],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RB_EMPTY_ROOT",
          "args": [
            "&transaction->delayed_refs.href_root"
          ],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!list_empty(&transaction->list)"
          ],
          "line": 65
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_dec_and_test",
          "args": [
            "&transaction->use_count"
          ],
          "line": 64
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "atomic_read(&transaction->use_count) == 0"
          ],
          "line": 63
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&transaction->use_count"
          ],
          "line": 63
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid btrfs_put_transaction(struct btrfs_transaction *transaction)\n{\n\tWARN_ON(atomic_read(&transaction->use_count) == 0);\n\tif (atomic_dec_and_test(&transaction->use_count)) {\n\t\tBUG_ON(!list_empty(&transaction->list));\n\t\tWARN_ON(!RB_EMPTY_ROOT(&transaction->delayed_refs.href_root));\n\t\twhile (!list_empty(&transaction->pending_chunks)) {\n\t\t\tstruct extent_map *em;\n\n\t\t\tem = list_first_entry(&transaction->pending_chunks,\n\t\t\t\t\t      struct extent_map, list);\n\t\t\tlist_del_init(&em->list);\n\t\t\tfree_extent_map(em);\n\t\t}\n\t\tkmem_cache_free(btrfs_transaction_cachep, transaction);\n\t}\n}"
  }
]