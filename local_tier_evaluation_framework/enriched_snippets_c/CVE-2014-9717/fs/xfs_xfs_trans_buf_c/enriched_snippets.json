[
  {
    "function_name": "xfs_trans_dquot_buf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_buf.c",
    "lines": "772-802",
    "snippet": "void\nxfs_trans_dquot_buf(\n\txfs_trans_t\t*tp,\n\txfs_buf_t\t*bp,\n\tuint\t\ttype)\n{\n\tstruct xfs_buf_log_item\t*bip = bp->b_fspriv;\n\n\tASSERT(type == XFS_BLF_UDQUOT_BUF ||\n\t       type == XFS_BLF_PDQUOT_BUF ||\n\t       type == XFS_BLF_GDQUOT_BUF);\n\n\tbip->__bli_format.blf_flags |= type;\n\n\tswitch (type) {\n\tcase XFS_BLF_UDQUOT_BUF:\n\t\ttype = XFS_BLFT_UDQUOT_BUF;\n\t\tbreak;\n\tcase XFS_BLF_PDQUOT_BUF:\n\t\ttype = XFS_BLFT_PDQUOT_BUF;\n\t\tbreak;\n\tcase XFS_BLF_GDQUOT_BUF:\n\t\ttype = XFS_BLFT_GDQUOT_BUF;\n\t\tbreak;\n\tdefault:\n\t\ttype = XFS_BLFT_UNKNOWN_BUF;\n\t\tbreak;\n\t}\n\n\txfs_trans_buf_set_type(tp, bp, type);\n}",
    "includes": [
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_trans_buf_set_type",
          "args": [
            "tp",
            "bp",
            "type"
          ],
          "line": 801
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_buf_set_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_buf.c",
          "lines": "730-746",
          "snippet": "void\nxfs_trans_buf_set_type(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_buf\t\t*bp,\n\tenum xfs_blft\t\ttype)\n{\n\tstruct xfs_buf_log_item\t*bip = bp->b_fspriv;\n\n\tif (!tp)\n\t\treturn;\n\n\tASSERT(bp->b_transp == tp);\n\tASSERT(bip != NULL);\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\n\txfs_blft_to_flags(&bip->__bli_format, type);\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nvoid\nxfs_trans_buf_set_type(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_buf\t\t*bp,\n\tenum xfs_blft\t\ttype)\n{\n\tstruct xfs_buf_log_item\t*bip = bp->b_fspriv;\n\n\tif (!tp)\n\t\treturn;\n\n\tASSERT(bp->b_transp == tp);\n\tASSERT(bip != NULL);\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\n\txfs_blft_to_flags(&bip->__bli_format, type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "type == XFS_BLF_UDQUOT_BUF ||\n\t       type == XFS_BLF_PDQUOT_BUF ||\n\t       type == XFS_BLF_GDQUOT_BUF"
          ],
          "line": 780
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nvoid\nxfs_trans_dquot_buf(\n\txfs_trans_t\t*tp,\n\txfs_buf_t\t*bp,\n\tuint\t\ttype)\n{\n\tstruct xfs_buf_log_item\t*bip = bp->b_fspriv;\n\n\tASSERT(type == XFS_BLF_UDQUOT_BUF ||\n\t       type == XFS_BLF_PDQUOT_BUF ||\n\t       type == XFS_BLF_GDQUOT_BUF);\n\n\tbip->__bli_format.blf_flags |= type;\n\n\tswitch (type) {\n\tcase XFS_BLF_UDQUOT_BUF:\n\t\ttype = XFS_BLFT_UDQUOT_BUF;\n\t\tbreak;\n\tcase XFS_BLF_PDQUOT_BUF:\n\t\ttype = XFS_BLFT_PDQUOT_BUF;\n\t\tbreak;\n\tcase XFS_BLF_GDQUOT_BUF:\n\t\ttype = XFS_BLFT_GDQUOT_BUF;\n\t\tbreak;\n\tdefault:\n\t\ttype = XFS_BLFT_UNKNOWN_BUF;\n\t\tbreak;\n\t}\n\n\txfs_trans_buf_set_type(tp, bp, type);\n}"
  },
  {
    "function_name": "xfs_trans_buf_copy_type",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_buf.c",
    "lines": "748-759",
    "snippet": "void\nxfs_trans_buf_copy_type(\n\tstruct xfs_buf\t\t*dst_bp,\n\tstruct xfs_buf\t\t*src_bp)\n{\n\tstruct xfs_buf_log_item\t*sbip = src_bp->b_fspriv;\n\tstruct xfs_buf_log_item\t*dbip = dst_bp->b_fspriv;\n\tenum xfs_blft\t\ttype;\n\n\ttype = xfs_blft_from_flags(&sbip->__bli_format);\n\txfs_blft_to_flags(&dbip->__bli_format, type);\n}",
    "includes": [
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_blft_to_flags",
          "args": [
            "&dbip->__bli_format",
            "type"
          ],
          "line": 758
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_blft_to_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_log_format.h",
          "lines": "501-507",
          "snippet": "static inline void\nxfs_blft_to_flags(struct xfs_buf_log_format *blf, enum xfs_blft type)\n{\n\tASSERT(type > XFS_BLFT_UNKNOWN_BUF && type < XFS_BLFT_MAX_BUF);\n\tblf->blf_flags &= ~XFS_BLFT_MASK;\n\tblf->blf_flags |= ((type << XFS_BLFT_SHIFT) & XFS_BLFT_MASK);\n}",
          "includes": [],
          "macros_used": [
            "#define XFS_BLFT_MASK\t(((1 << XFS_BLFT_BITS) - 1) << XFS_BLFT_SHIFT)",
            "#define XFS_BLFT_SHIFT\t11"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define XFS_BLFT_MASK\t(((1 << XFS_BLFT_BITS) - 1) << XFS_BLFT_SHIFT)\n#define XFS_BLFT_SHIFT\t11\n\nstatic inline void\nxfs_blft_to_flags(struct xfs_buf_log_format *blf, enum xfs_blft type)\n{\n\tASSERT(type > XFS_BLFT_UNKNOWN_BUF && type < XFS_BLFT_MAX_BUF);\n\tblf->blf_flags &= ~XFS_BLFT_MASK;\n\tblf->blf_flags |= ((type << XFS_BLFT_SHIFT) & XFS_BLFT_MASK);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_blft_from_flags",
          "args": [
            "&sbip->__bli_format"
          ],
          "line": 757
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_blft_from_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_log_format.h",
          "lines": "509-513",
          "snippet": "static inline __uint16_t\nxfs_blft_from_flags(struct xfs_buf_log_format *blf)\n{\n\treturn (blf->blf_flags & XFS_BLFT_MASK) >> XFS_BLFT_SHIFT;\n}",
          "includes": [],
          "macros_used": [
            "#define XFS_BLFT_MASK\t(((1 << XFS_BLFT_BITS) - 1) << XFS_BLFT_SHIFT)",
            "#define XFS_BLFT_SHIFT\t11"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define XFS_BLFT_MASK\t(((1 << XFS_BLFT_BITS) - 1) << XFS_BLFT_SHIFT)\n#define XFS_BLFT_SHIFT\t11\n\nstatic inline __uint16_t\nxfs_blft_from_flags(struct xfs_buf_log_format *blf)\n{\n\treturn (blf->blf_flags & XFS_BLFT_MASK) >> XFS_BLFT_SHIFT;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nvoid\nxfs_trans_buf_copy_type(\n\tstruct xfs_buf\t\t*dst_bp,\n\tstruct xfs_buf\t\t*src_bp)\n{\n\tstruct xfs_buf_log_item\t*sbip = src_bp->b_fspriv;\n\tstruct xfs_buf_log_item\t*dbip = dst_bp->b_fspriv;\n\tenum xfs_blft\t\ttype;\n\n\ttype = xfs_blft_from_flags(&sbip->__bli_format);\n\txfs_blft_to_flags(&dbip->__bli_format, type);\n}"
  },
  {
    "function_name": "xfs_trans_buf_set_type",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_buf.c",
    "lines": "730-746",
    "snippet": "void\nxfs_trans_buf_set_type(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_buf\t\t*bp,\n\tenum xfs_blft\t\ttype)\n{\n\tstruct xfs_buf_log_item\t*bip = bp->b_fspriv;\n\n\tif (!tp)\n\t\treturn;\n\n\tASSERT(bp->b_transp == tp);\n\tASSERT(bip != NULL);\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\n\txfs_blft_to_flags(&bip->__bli_format, type);\n}",
    "includes": [
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_blft_to_flags",
          "args": [
            "&bip->__bli_format",
            "type"
          ],
          "line": 745
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_blft_to_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_log_format.h",
          "lines": "501-507",
          "snippet": "static inline void\nxfs_blft_to_flags(struct xfs_buf_log_format *blf, enum xfs_blft type)\n{\n\tASSERT(type > XFS_BLFT_UNKNOWN_BUF && type < XFS_BLFT_MAX_BUF);\n\tblf->blf_flags &= ~XFS_BLFT_MASK;\n\tblf->blf_flags |= ((type << XFS_BLFT_SHIFT) & XFS_BLFT_MASK);\n}",
          "includes": [],
          "macros_used": [
            "#define XFS_BLFT_MASK\t(((1 << XFS_BLFT_BITS) - 1) << XFS_BLFT_SHIFT)",
            "#define XFS_BLFT_SHIFT\t11"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define XFS_BLFT_MASK\t(((1 << XFS_BLFT_BITS) - 1) << XFS_BLFT_SHIFT)\n#define XFS_BLFT_SHIFT\t11\n\nstatic inline void\nxfs_blft_to_flags(struct xfs_buf_log_format *blf, enum xfs_blft type)\n{\n\tASSERT(type > XFS_BLFT_UNKNOWN_BUF && type < XFS_BLFT_MAX_BUF);\n\tblf->blf_flags &= ~XFS_BLFT_MASK;\n\tblf->blf_flags |= ((type << XFS_BLFT_SHIFT) & XFS_BLFT_MASK);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "atomic_read(&bip->bli_refcount) > 0"
          ],
          "line": 743
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&bip->bli_refcount"
          ],
          "line": 743
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "bip != NULL"
          ],
          "line": 742
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "bp->b_transp == tp"
          ],
          "line": 741
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nvoid\nxfs_trans_buf_set_type(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_buf\t\t*bp,\n\tenum xfs_blft\t\ttype)\n{\n\tstruct xfs_buf_log_item\t*bip = bp->b_fspriv;\n\n\tif (!tp)\n\t\treturn;\n\n\tASSERT(bp->b_transp == tp);\n\tASSERT(bip != NULL);\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\n\txfs_blft_to_flags(&bip->__bli_format, type);\n}"
  },
  {
    "function_name": "xfs_trans_ordered_buf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_buf.c",
    "lines": "711-724",
    "snippet": "void\nxfs_trans_ordered_buf(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_buf_log_item\t*bip = bp->b_fspriv;\n\n\tASSERT(bp->b_transp == tp);\n\tASSERT(bip != NULL);\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\n\tbip->bli_flags |= XFS_BLI_ORDERED;\n\ttrace_xfs_buf_item_ordered(bip);\n}",
    "includes": [
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_xfs_buf_item_ordered",
          "args": [
            "bip"
          ],
          "line": 723
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "atomic_read(&bip->bli_refcount) > 0"
          ],
          "line": 720
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&bip->bli_refcount"
          ],
          "line": 720
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "bip != NULL"
          ],
          "line": 719
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "bp->b_transp == tp"
          ],
          "line": 718
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nvoid\nxfs_trans_ordered_buf(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_buf_log_item\t*bip = bp->b_fspriv;\n\n\tASSERT(bp->b_transp == tp);\n\tASSERT(bip != NULL);\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\n\tbip->bli_flags |= XFS_BLI_ORDERED;\n\ttrace_xfs_buf_item_ordered(bip);\n}"
  },
  {
    "function_name": "xfs_trans_inode_alloc_buf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_buf.c",
    "lines": "688-701",
    "snippet": "void\nxfs_trans_inode_alloc_buf(\n\txfs_trans_t\t*tp,\n\txfs_buf_t\t*bp)\n{\n\txfs_buf_log_item_t\t*bip = bp->b_fspriv;\n\n\tASSERT(bp->b_transp == tp);\n\tASSERT(bip != NULL);\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\n\tbip->bli_flags |= XFS_BLI_INODE_ALLOC_BUF;\n\txfs_trans_buf_set_type(tp, bp, XFS_BLFT_DINO_BUF);\n}",
    "includes": [
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_trans_buf_set_type",
          "args": [
            "tp",
            "bp",
            "XFS_BLFT_DINO_BUF"
          ],
          "line": 700
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_buf_set_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_buf.c",
          "lines": "730-746",
          "snippet": "void\nxfs_trans_buf_set_type(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_buf\t\t*bp,\n\tenum xfs_blft\t\ttype)\n{\n\tstruct xfs_buf_log_item\t*bip = bp->b_fspriv;\n\n\tif (!tp)\n\t\treturn;\n\n\tASSERT(bp->b_transp == tp);\n\tASSERT(bip != NULL);\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\n\txfs_blft_to_flags(&bip->__bli_format, type);\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nvoid\nxfs_trans_buf_set_type(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_buf\t\t*bp,\n\tenum xfs_blft\t\ttype)\n{\n\tstruct xfs_buf_log_item\t*bip = bp->b_fspriv;\n\n\tif (!tp)\n\t\treturn;\n\n\tASSERT(bp->b_transp == tp);\n\tASSERT(bip != NULL);\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\n\txfs_blft_to_flags(&bip->__bli_format, type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "atomic_read(&bip->bli_refcount) > 0"
          ],
          "line": 697
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&bip->bli_refcount"
          ],
          "line": 697
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "bip != NULL"
          ],
          "line": 696
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "bp->b_transp == tp"
          ],
          "line": 695
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_inode_alloc_buf(\n\txfs_trans_t\t*tp,\n\txfs_buf_t\t*bp)\n{\n\txfs_buf_log_item_t\t*bip = bp->b_fspriv;\n\n\tASSERT(bp->b_transp == tp);\n\tASSERT(bip != NULL);\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\n\tbip->bli_flags |= XFS_BLI_INODE_ALLOC_BUF;\n\txfs_trans_buf_set_type(tp, bp, XFS_BLFT_DINO_BUF);\n}"
  },
  {
    "function_name": "xfs_trans_stale_inode_buf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_buf.c",
    "lines": "663-677",
    "snippet": "void\nxfs_trans_stale_inode_buf(\n\txfs_trans_t\t*tp,\n\txfs_buf_t\t*bp)\n{\n\txfs_buf_log_item_t\t*bip = bp->b_fspriv;\n\n\tASSERT(bp->b_transp == tp);\n\tASSERT(bip != NULL);\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\n\tbip->bli_flags |= XFS_BLI_STALE_INODE;\n\tbip->bli_item.li_cb = xfs_buf_iodone;\n\txfs_trans_buf_set_type(tp, bp, XFS_BLFT_DINO_BUF);\n}",
    "includes": [
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_trans_buf_set_type",
          "args": [
            "tp",
            "bp",
            "XFS_BLFT_DINO_BUF"
          ],
          "line": 676
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_buf_set_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_buf.c",
          "lines": "730-746",
          "snippet": "void\nxfs_trans_buf_set_type(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_buf\t\t*bp,\n\tenum xfs_blft\t\ttype)\n{\n\tstruct xfs_buf_log_item\t*bip = bp->b_fspriv;\n\n\tif (!tp)\n\t\treturn;\n\n\tASSERT(bp->b_transp == tp);\n\tASSERT(bip != NULL);\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\n\txfs_blft_to_flags(&bip->__bli_format, type);\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nvoid\nxfs_trans_buf_set_type(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_buf\t\t*bp,\n\tenum xfs_blft\t\ttype)\n{\n\tstruct xfs_buf_log_item\t*bip = bp->b_fspriv;\n\n\tif (!tp)\n\t\treturn;\n\n\tASSERT(bp->b_transp == tp);\n\tASSERT(bip != NULL);\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\n\txfs_blft_to_flags(&bip->__bli_format, type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "atomic_read(&bip->bli_refcount) > 0"
          ],
          "line": 672
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&bip->bli_refcount"
          ],
          "line": 672
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "bip != NULL"
          ],
          "line": 671
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "bp->b_transp == tp"
          ],
          "line": 670
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_stale_inode_buf(\n\txfs_trans_t\t*tp,\n\txfs_buf_t\t*bp)\n{\n\txfs_buf_log_item_t\t*bip = bp->b_fspriv;\n\n\tASSERT(bp->b_transp == tp);\n\tASSERT(bip != NULL);\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\n\tbip->bli_flags |= XFS_BLI_STALE_INODE;\n\tbip->bli_item.li_cb = xfs_buf_iodone;\n\txfs_trans_buf_set_type(tp, bp, XFS_BLFT_DINO_BUF);\n}"
  },
  {
    "function_name": "xfs_trans_inode_buf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_buf.c",
    "lines": "639-652",
    "snippet": "void\nxfs_trans_inode_buf(\n\txfs_trans_t\t*tp,\n\txfs_buf_t\t*bp)\n{\n\txfs_buf_log_item_t\t*bip = bp->b_fspriv;\n\n\tASSERT(bp->b_transp == tp);\n\tASSERT(bip != NULL);\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\n\tbip->bli_flags |= XFS_BLI_INODE_BUF;\n\txfs_trans_buf_set_type(tp, bp, XFS_BLFT_DINO_BUF);\n}",
    "includes": [
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_trans_buf_set_type",
          "args": [
            "tp",
            "bp",
            "XFS_BLFT_DINO_BUF"
          ],
          "line": 651
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_buf_set_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_buf.c",
          "lines": "730-746",
          "snippet": "void\nxfs_trans_buf_set_type(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_buf\t\t*bp,\n\tenum xfs_blft\t\ttype)\n{\n\tstruct xfs_buf_log_item\t*bip = bp->b_fspriv;\n\n\tif (!tp)\n\t\treturn;\n\n\tASSERT(bp->b_transp == tp);\n\tASSERT(bip != NULL);\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\n\txfs_blft_to_flags(&bip->__bli_format, type);\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nvoid\nxfs_trans_buf_set_type(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_buf\t\t*bp,\n\tenum xfs_blft\t\ttype)\n{\n\tstruct xfs_buf_log_item\t*bip = bp->b_fspriv;\n\n\tif (!tp)\n\t\treturn;\n\n\tASSERT(bp->b_transp == tp);\n\tASSERT(bip != NULL);\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\n\txfs_blft_to_flags(&bip->__bli_format, type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "atomic_read(&bip->bli_refcount) > 0"
          ],
          "line": 648
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&bip->bli_refcount"
          ],
          "line": 648
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "bip != NULL"
          ],
          "line": 647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "bp->b_transp == tp"
          ],
          "line": 646
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_inode_buf(\n\txfs_trans_t\t*tp,\n\txfs_buf_t\t*bp)\n{\n\txfs_buf_log_item_t\t*bip = bp->b_fspriv;\n\n\tASSERT(bp->b_transp == tp);\n\tASSERT(bip != NULL);\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\n\tbip->bli_flags |= XFS_BLI_INODE_BUF;\n\txfs_trans_buf_set_type(tp, bp, XFS_BLFT_DINO_BUF);\n}"
  },
  {
    "function_name": "xfs_trans_binval",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_buf.c",
    "lines": "584-626",
    "snippet": "void\nxfs_trans_binval(\n\txfs_trans_t\t*tp,\n\txfs_buf_t\t*bp)\n{\n\txfs_buf_log_item_t\t*bip = bp->b_fspriv;\n\tint\t\t\ti;\n\n\tASSERT(bp->b_transp == tp);\n\tASSERT(bip != NULL);\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\n\ttrace_xfs_trans_binval(bip);\n\n\tif (bip->bli_flags & XFS_BLI_STALE) {\n\t\t/*\n\t\t * If the buffer is already invalidated, then\n\t\t * just return.\n\t\t */\n\t\tASSERT(XFS_BUF_ISSTALE(bp));\n\t\tASSERT(!(bip->bli_flags & (XFS_BLI_LOGGED | XFS_BLI_DIRTY)));\n\t\tASSERT(!(bip->__bli_format.blf_flags & XFS_BLF_INODE_BUF));\n\t\tASSERT(!(bip->__bli_format.blf_flags & XFS_BLFT_MASK));\n\t\tASSERT(bip->__bli_format.blf_flags & XFS_BLF_CANCEL);\n\t\tASSERT(bip->bli_item.li_desc->lid_flags & XFS_LID_DIRTY);\n\t\tASSERT(tp->t_flags & XFS_TRANS_DIRTY);\n\t\treturn;\n\t}\n\n\txfs_buf_stale(bp);\n\n\tbip->bli_flags |= XFS_BLI_STALE;\n\tbip->bli_flags &= ~(XFS_BLI_INODE_BUF | XFS_BLI_LOGGED | XFS_BLI_DIRTY);\n\tbip->__bli_format.blf_flags &= ~XFS_BLF_INODE_BUF;\n\tbip->__bli_format.blf_flags |= XFS_BLF_CANCEL;\n\tbip->__bli_format.blf_flags &= ~XFS_BLFT_MASK;\n\tfor (i = 0; i < bip->bli_format_count; i++) {\n\t\tmemset(bip->bli_formats[i].blf_data_map, 0,\n\t\t       (bip->bli_formats[i].blf_map_size * sizeof(uint)));\n\t}\n\tbip->bli_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n}",
    "includes": [
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "bip->bli_formats[i].blf_data_map",
            "0",
            "(bip->bli_formats[i].blf_map_size * sizeof(uint))"
          ],
          "line": 621
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_buf_stale",
          "args": [
            "bp"
          ],
          "line": 613
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_stale",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "90-113",
          "snippet": "void\nxfs_buf_stale(\n\tstruct xfs_buf\t*bp)\n{\n\tASSERT(xfs_buf_islocked(bp));\n\n\tbp->b_flags |= XBF_STALE;\n\n\t/*\n\t * Clear the delwri status so that a delwri queue walker will not\n\t * flush this buffer to disk now that it is stale. The delwri queue has\n\t * a reference to the buffer, so this is safe to do.\n\t */\n\tbp->b_flags &= ~_XBF_DELWRI_Q;\n\n\tspin_lock(&bp->b_lock);\n\tatomic_set(&bp->b_lru_ref, 0);\n\tif (!(bp->b_state & XFS_BSTATE_DISPOSE) &&\n\t    (list_lru_del(&bp->b_target->bt_lru, &bp->b_lru)))\n\t\tatomic_dec(&bp->b_hold);\n\n\tASSERT(atomic_read(&bp->b_hold) >= 1);\n\tspin_unlock(&bp->b_lock);\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nvoid\nxfs_buf_stale(\n\tstruct xfs_buf\t*bp)\n{\n\tASSERT(xfs_buf_islocked(bp));\n\n\tbp->b_flags |= XBF_STALE;\n\n\t/*\n\t * Clear the delwri status so that a delwri queue walker will not\n\t * flush this buffer to disk now that it is stale. The delwri queue has\n\t * a reference to the buffer, so this is safe to do.\n\t */\n\tbp->b_flags &= ~_XBF_DELWRI_Q;\n\n\tspin_lock(&bp->b_lock);\n\tatomic_set(&bp->b_lru_ref, 0);\n\tif (!(bp->b_state & XFS_BSTATE_DISPOSE) &&\n\t    (list_lru_del(&bp->b_target->bt_lru, &bp->b_lru)))\n\t\tatomic_dec(&bp->b_hold);\n\n\tASSERT(atomic_read(&bp->b_hold) >= 1);\n\tspin_unlock(&bp->b_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "tp->t_flags & XFS_TRANS_DIRTY"
          ],
          "line": 609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "bip->bli_item.li_desc->lid_flags & XFS_LID_DIRTY"
          ],
          "line": 608
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "bip->__bli_format.blf_flags & XFS_BLF_CANCEL"
          ],
          "line": 607
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "!(bip->__bli_format.blf_flags & XFS_BLFT_MASK)"
          ],
          "line": 606
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "!(bip->__bli_format.blf_flags & XFS_BLF_INODE_BUF)"
          ],
          "line": 605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "!(bip->bli_flags & (XFS_BLI_LOGGED | XFS_BLI_DIRTY))"
          ],
          "line": 604
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "XFS_BUF_ISSTALE(bp)"
          ],
          "line": 603
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BUF_ISSTALE",
          "args": [
            "bp"
          ],
          "line": 603
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_xfs_trans_binval",
          "args": [
            "bip"
          ],
          "line": 596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "atomic_read(&bip->bli_refcount) > 0"
          ],
          "line": 594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&bip->bli_refcount"
          ],
          "line": 594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "bip != NULL"
          ],
          "line": 593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "bp->b_transp == tp"
          ],
          "line": 592
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_binval(\n\txfs_trans_t\t*tp,\n\txfs_buf_t\t*bp)\n{\n\txfs_buf_log_item_t\t*bip = bp->b_fspriv;\n\tint\t\t\ti;\n\n\tASSERT(bp->b_transp == tp);\n\tASSERT(bip != NULL);\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\n\ttrace_xfs_trans_binval(bip);\n\n\tif (bip->bli_flags & XFS_BLI_STALE) {\n\t\t/*\n\t\t * If the buffer is already invalidated, then\n\t\t * just return.\n\t\t */\n\t\tASSERT(XFS_BUF_ISSTALE(bp));\n\t\tASSERT(!(bip->bli_flags & (XFS_BLI_LOGGED | XFS_BLI_DIRTY)));\n\t\tASSERT(!(bip->__bli_format.blf_flags & XFS_BLF_INODE_BUF));\n\t\tASSERT(!(bip->__bli_format.blf_flags & XFS_BLFT_MASK));\n\t\tASSERT(bip->__bli_format.blf_flags & XFS_BLF_CANCEL);\n\t\tASSERT(bip->bli_item.li_desc->lid_flags & XFS_LID_DIRTY);\n\t\tASSERT(tp->t_flags & XFS_TRANS_DIRTY);\n\t\treturn;\n\t}\n\n\txfs_buf_stale(bp);\n\n\tbip->bli_flags |= XFS_BLI_STALE;\n\tbip->bli_flags &= ~(XFS_BLI_INODE_BUF | XFS_BLI_LOGGED | XFS_BLI_DIRTY);\n\tbip->__bli_format.blf_flags &= ~XFS_BLF_INODE_BUF;\n\tbip->__bli_format.blf_flags |= XFS_BLF_CANCEL;\n\tbip->__bli_format.blf_flags &= ~XFS_BLFT_MASK;\n\tfor (i = 0; i < bip->bli_format_count; i++) {\n\t\tmemset(bip->bli_formats[i].blf_data_map, 0,\n\t\t       (bip->bli_formats[i].blf_map_size * sizeof(uint)));\n\t}\n\tbip->bli_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n}"
  },
  {
    "function_name": "xfs_trans_log_buf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_buf.c",
    "lines": "497-552",
    "snippet": "void\nxfs_trans_log_buf(xfs_trans_t\t*tp,\n\t\t  xfs_buf_t\t*bp,\n\t\t  uint\t\tfirst,\n\t\t  uint\t\tlast)\n{\n\txfs_buf_log_item_t\t*bip = bp->b_fspriv;\n\n\tASSERT(bp->b_transp == tp);\n\tASSERT(bip != NULL);\n\tASSERT(first <= last && last < BBTOB(bp->b_length));\n\tASSERT(bp->b_iodone == NULL ||\n\t       bp->b_iodone == xfs_buf_iodone_callbacks);\n\n\t/*\n\t * Mark the buffer as needing to be written out eventually,\n\t * and set its iodone function to remove the buffer's buf log\n\t * item from the AIL and free it when the buffer is flushed\n\t * to disk.  See xfs_buf_attach_iodone() for more details\n\t * on li_cb and xfs_buf_iodone_callbacks().\n\t * If we end up aborting this transaction, we trap this buffer\n\t * inside the b_bdstrat callback so that this won't get written to\n\t * disk.\n\t */\n\tXFS_BUF_DONE(bp);\n\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\tbp->b_iodone = xfs_buf_iodone_callbacks;\n\tbip->bli_item.li_cb = xfs_buf_iodone;\n\n\ttrace_xfs_trans_log_buf(bip);\n\n\t/*\n\t * If we invalidated the buffer within this transaction, then\n\t * cancel the invalidation now that we're dirtying the buffer\n\t * again.  There are no races with the code in xfs_buf_item_unpin(),\n\t * because we have a reference to the buffer this entire time.\n\t */\n\tif (bip->bli_flags & XFS_BLI_STALE) {\n\t\tbip->bli_flags &= ~XFS_BLI_STALE;\n\t\tASSERT(XFS_BUF_ISSTALE(bp));\n\t\tXFS_BUF_UNSTALE(bp);\n\t\tbip->__bli_format.blf_flags &= ~XFS_BLF_CANCEL;\n\t}\n\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n\tbip->bli_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n\n\t/*\n\t * If we have an ordered buffer we are not logging any dirty range but\n\t * it still needs to be marked dirty and that it has been logged.\n\t */\n\tbip->bli_flags |= XFS_BLI_DIRTY | XFS_BLI_LOGGED;\n\tif (!(bip->bli_flags & XFS_BLI_ORDERED))\n\t\txfs_buf_item_log(bip, first, last);\n}",
    "includes": [
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_buf_item_log",
          "args": [
            "bip",
            "first",
            "last"
          ],
          "line": 551
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_item_log",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf_item.c",
          "lines": "898-931",
          "snippet": "void\nxfs_buf_item_log(\n\txfs_buf_log_item_t\t*bip,\n\tuint\t\t\tfirst,\n\tuint\t\t\tlast)\n{\n\tint\t\t\ti;\n\tuint\t\t\tstart;\n\tuint\t\t\tend;\n\tstruct xfs_buf\t\t*bp = bip->bli_buf;\n\n\t/*\n\t * walk each buffer segment and mark them dirty appropriately.\n\t */\n\tstart = 0;\n\tfor (i = 0; i < bip->bli_format_count; i++) {\n\t\tif (start > last)\n\t\t\tbreak;\n\t\tend = start + BBTOB(bp->b_maps[i].bm_len);\n\t\tif (first > end) {\n\t\t\tstart += BBTOB(bp->b_maps[i].bm_len);\n\t\t\tcontinue;\n\t\t}\n\t\tif (first < start)\n\t\t\tfirst = start;\n\t\tif (end > last)\n\t\t\tend = last;\n\n\t\txfs_buf_item_log_segment(first, end,\n\t\t\t\t\t &bip->bli_formats[i].blf_data_map[0]);\n\n\t\tstart += bp->b_maps[i].bm_len;\n\t}\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC void\txfs_buf_do_callbacks(struct xfs_buf *bp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\txfs_buf_do_callbacks(struct xfs_buf *bp);\n\nvoid\nxfs_buf_item_log(\n\txfs_buf_log_item_t\t*bip,\n\tuint\t\t\tfirst,\n\tuint\t\t\tlast)\n{\n\tint\t\t\ti;\n\tuint\t\t\tstart;\n\tuint\t\t\tend;\n\tstruct xfs_buf\t\t*bp = bip->bli_buf;\n\n\t/*\n\t * walk each buffer segment and mark them dirty appropriately.\n\t */\n\tstart = 0;\n\tfor (i = 0; i < bip->bli_format_count; i++) {\n\t\tif (start > last)\n\t\t\tbreak;\n\t\tend = start + BBTOB(bp->b_maps[i].bm_len);\n\t\tif (first > end) {\n\t\t\tstart += BBTOB(bp->b_maps[i].bm_len);\n\t\t\tcontinue;\n\t\t}\n\t\tif (first < start)\n\t\t\tfirst = start;\n\t\tif (end > last)\n\t\t\tend = last;\n\n\t\txfs_buf_item_log_segment(first, end,\n\t\t\t\t\t &bip->bli_formats[i].blf_data_map[0]);\n\n\t\tstart += bp->b_maps[i].bm_len;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_BUF_UNSTALE",
          "args": [
            "bp"
          ],
          "line": 538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "XFS_BUF_ISSTALE(bp)"
          ],
          "line": 537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BUF_ISSTALE",
          "args": [
            "bp"
          ],
          "line": 537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_xfs_trans_log_buf",
          "args": [
            "bip"
          ],
          "line": 527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "atomic_read(&bip->bli_refcount) > 0"
          ],
          "line": 523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&bip->bli_refcount"
          ],
          "line": 523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BUF_DONE",
          "args": [
            "bp"
          ],
          "line": 521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "bp->b_iodone == NULL ||\n\t       bp->b_iodone == xfs_buf_iodone_callbacks"
          ],
          "line": 508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "first <= last && last < BBTOB(bp->b_length)"
          ],
          "line": 507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BBTOB",
          "args": [
            "bp->b_length"
          ],
          "line": 507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "bip != NULL"
          ],
          "line": 506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "bp->b_transp == tp"
          ],
          "line": 505
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_log_buf(xfs_trans_t\t*tp,\n\t\t  xfs_buf_t\t*bp,\n\t\t  uint\t\tfirst,\n\t\t  uint\t\tlast)\n{\n\txfs_buf_log_item_t\t*bip = bp->b_fspriv;\n\n\tASSERT(bp->b_transp == tp);\n\tASSERT(bip != NULL);\n\tASSERT(first <= last && last < BBTOB(bp->b_length));\n\tASSERT(bp->b_iodone == NULL ||\n\t       bp->b_iodone == xfs_buf_iodone_callbacks);\n\n\t/*\n\t * Mark the buffer as needing to be written out eventually,\n\t * and set its iodone function to remove the buffer's buf log\n\t * item from the AIL and free it when the buffer is flushed\n\t * to disk.  See xfs_buf_attach_iodone() for more details\n\t * on li_cb and xfs_buf_iodone_callbacks().\n\t * If we end up aborting this transaction, we trap this buffer\n\t * inside the b_bdstrat callback so that this won't get written to\n\t * disk.\n\t */\n\tXFS_BUF_DONE(bp);\n\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\tbp->b_iodone = xfs_buf_iodone_callbacks;\n\tbip->bli_item.li_cb = xfs_buf_iodone;\n\n\ttrace_xfs_trans_log_buf(bip);\n\n\t/*\n\t * If we invalidated the buffer within this transaction, then\n\t * cancel the invalidation now that we're dirtying the buffer\n\t * again.  There are no races with the code in xfs_buf_item_unpin(),\n\t * because we have a reference to the buffer this entire time.\n\t */\n\tif (bip->bli_flags & XFS_BLI_STALE) {\n\t\tbip->bli_flags &= ~XFS_BLI_STALE;\n\t\tASSERT(XFS_BUF_ISSTALE(bp));\n\t\tXFS_BUF_UNSTALE(bp);\n\t\tbip->__bli_format.blf_flags &= ~XFS_BLF_CANCEL;\n\t}\n\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n\tbip->bli_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n\n\t/*\n\t * If we have an ordered buffer we are not logging any dirty range but\n\t * it still needs to be marked dirty and that it has been logged.\n\t */\n\tbip->bli_flags |= XFS_BLI_DIRTY | XFS_BLI_LOGGED;\n\tif (!(bip->bli_flags & XFS_BLI_ORDERED))\n\t\txfs_buf_item_log(bip, first, last);\n}"
  },
  {
    "function_name": "xfs_trans_bhold_release",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_buf.c",
    "lines": "471-486",
    "snippet": "void\nxfs_trans_bhold_release(xfs_trans_t\t*tp,\n\t\t\txfs_buf_t\t*bp)\n{\n\txfs_buf_log_item_t\t*bip = bp->b_fspriv;\n\n\tASSERT(bp->b_transp == tp);\n\tASSERT(bip != NULL);\n\tASSERT(!(bip->bli_flags & XFS_BLI_STALE));\n\tASSERT(!(bip->__bli_format.blf_flags & XFS_BLF_CANCEL));\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\tASSERT(bip->bli_flags & XFS_BLI_HOLD);\n\n\tbip->bli_flags &= ~XFS_BLI_HOLD;\n\ttrace_xfs_trans_bhold_release(bip);\n}",
    "includes": [
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_xfs_trans_bhold_release",
          "args": [
            "bip"
          ],
          "line": 485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "bip->bli_flags & XFS_BLI_HOLD"
          ],
          "line": 482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "atomic_read(&bip->bli_refcount) > 0"
          ],
          "line": 481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&bip->bli_refcount"
          ],
          "line": 481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "!(bip->__bli_format.blf_flags & XFS_BLF_CANCEL)"
          ],
          "line": 480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "!(bip->bli_flags & XFS_BLI_STALE)"
          ],
          "line": 479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "bip != NULL"
          ],
          "line": 478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "bp->b_transp == tp"
          ],
          "line": 477
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_bhold_release(xfs_trans_t\t*tp,\n\t\t\txfs_buf_t\t*bp)\n{\n\txfs_buf_log_item_t\t*bip = bp->b_fspriv;\n\n\tASSERT(bp->b_transp == tp);\n\tASSERT(bip != NULL);\n\tASSERT(!(bip->bli_flags & XFS_BLI_STALE));\n\tASSERT(!(bip->__bli_format.blf_flags & XFS_BLF_CANCEL));\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\tASSERT(bip->bli_flags & XFS_BLI_HOLD);\n\n\tbip->bli_flags &= ~XFS_BLI_HOLD;\n\ttrace_xfs_trans_bhold_release(bip);\n}"
  },
  {
    "function_name": "xfs_trans_bhold",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_buf.c",
    "lines": "451-465",
    "snippet": "void\nxfs_trans_bhold(xfs_trans_t\t*tp,\n\t\txfs_buf_t\t*bp)\n{\n\txfs_buf_log_item_t\t*bip = bp->b_fspriv;\n\n\tASSERT(bp->b_transp == tp);\n\tASSERT(bip != NULL);\n\tASSERT(!(bip->bli_flags & XFS_BLI_STALE));\n\tASSERT(!(bip->__bli_format.blf_flags & XFS_BLF_CANCEL));\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\n\tbip->bli_flags |= XFS_BLI_HOLD;\n\ttrace_xfs_trans_bhold(bip);\n}",
    "includes": [
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_xfs_trans_bhold",
          "args": [
            "bip"
          ],
          "line": 464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "atomic_read(&bip->bli_refcount) > 0"
          ],
          "line": 461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&bip->bli_refcount"
          ],
          "line": 461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "!(bip->__bli_format.blf_flags & XFS_BLF_CANCEL)"
          ],
          "line": 460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "!(bip->bli_flags & XFS_BLI_STALE)"
          ],
          "line": 459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "bip != NULL"
          ],
          "line": 458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "bp->b_transp == tp"
          ],
          "line": 457
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_bhold(xfs_trans_t\t*tp,\n\t\txfs_buf_t\t*bp)\n{\n\txfs_buf_log_item_t\t*bip = bp->b_fspriv;\n\n\tASSERT(bp->b_transp == tp);\n\tASSERT(bip != NULL);\n\tASSERT(!(bip->bli_flags & XFS_BLI_STALE));\n\tASSERT(!(bip->__bli_format.blf_flags & XFS_BLF_CANCEL));\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\n\tbip->bli_flags |= XFS_BLI_HOLD;\n\ttrace_xfs_trans_bhold(bip);\n}"
  },
  {
    "function_name": "xfs_trans_brelse",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_buf.c",
    "lines": "354-443",
    "snippet": "void\nxfs_trans_brelse(xfs_trans_t\t*tp,\n\t\t xfs_buf_t\t*bp)\n{\n\txfs_buf_log_item_t\t*bip;\n\n\t/*\n\t * Default to a normal brelse() call if the tp is NULL.\n\t */\n\tif (tp == NULL) {\n\t\tASSERT(bp->b_transp == NULL);\n\t\txfs_buf_relse(bp);\n\t\treturn;\n\t}\n\n\tASSERT(bp->b_transp == tp);\n\tbip = bp->b_fspriv;\n\tASSERT(bip->bli_item.li_type == XFS_LI_BUF);\n\tASSERT(!(bip->bli_flags & XFS_BLI_STALE));\n\tASSERT(!(bip->__bli_format.blf_flags & XFS_BLF_CANCEL));\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\n\ttrace_xfs_trans_brelse(bip);\n\n\t/*\n\t * If the release is just for a recursive lock,\n\t * then decrement the count and return.\n\t */\n\tif (bip->bli_recur > 0) {\n\t\tbip->bli_recur--;\n\t\treturn;\n\t}\n\n\t/*\n\t * If the buffer is dirty within this transaction, we can't\n\t * release it until we commit.\n\t */\n\tif (bip->bli_item.li_desc->lid_flags & XFS_LID_DIRTY)\n\t\treturn;\n\n\t/*\n\t * If the buffer has been invalidated, then we can't release\n\t * it until the transaction commits to disk unless it is re-dirtied\n\t * as part of this transaction.  This prevents us from pulling\n\t * the item from the AIL before we should.\n\t */\n\tif (bip->bli_flags & XFS_BLI_STALE)\n\t\treturn;\n\n\tASSERT(!(bip->bli_flags & XFS_BLI_LOGGED));\n\n\t/*\n\t * Free up the log item descriptor tracking the released item.\n\t */\n\txfs_trans_del_item(&bip->bli_item);\n\n\t/*\n\t * Clear the hold flag in the buf log item if it is set.\n\t * We wouldn't want the next user of the buffer to\n\t * get confused.\n\t */\n\tif (bip->bli_flags & XFS_BLI_HOLD) {\n\t\tbip->bli_flags &= ~XFS_BLI_HOLD;\n\t}\n\n\t/*\n\t * Drop our reference to the buf log item.\n\t */\n\tatomic_dec(&bip->bli_refcount);\n\n\t/*\n\t * If the buf item is not tracking data in the log, then\n\t * we must free it before releasing the buffer back to the\n\t * free pool.  Before releasing the buffer to the free pool,\n\t * clear the transaction pointer in b_fsprivate2 to dissolve\n\t * its relation to this transaction.\n\t */\n\tif (!xfs_buf_item_dirty(bip)) {\n/***\n\t\tASSERT(bp->b_pincount == 0);\n***/\n\t\tASSERT(atomic_read(&bip->bli_refcount) == 0);\n\t\tASSERT(!(bip->bli_item.li_flags & XFS_LI_IN_AIL));\n\t\tASSERT(!(bip->bli_flags & XFS_BLI_INODE_ALLOC_BUF));\n\t\txfs_buf_item_relse(bp);\n\t}\n\n\tbp->b_transp = NULL;\n\txfs_buf_relse(bp);\n}",
    "includes": [
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_buf_relse",
          "args": [
            "bp"
          ],
          "line": 442
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_relse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.h",
          "lines": "361-365",
          "snippet": "static inline void xfs_buf_relse(xfs_buf_t *bp)\n{\n\txfs_buf_unlock(bp);\n\txfs_buf_rele(bp);\n}",
          "includes": [
            "#include <linux/list_lru.h>",
            "#include <linux/uio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/list_lru.h>\n#include <linux/uio.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/list.h>\n\nstatic inline void xfs_buf_relse(xfs_buf_t *bp)\n{\n\txfs_buf_unlock(bp);\n\txfs_buf_rele(bp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_buf_item_relse",
          "args": [
            "bp"
          ],
          "line": 438
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_item_relse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf_item.c",
          "lines": "960-975",
          "snippet": "void\nxfs_buf_item_relse(\n\txfs_buf_t\t*bp)\n{\n\txfs_buf_log_item_t\t*bip = bp->b_fspriv;\n\n\ttrace_xfs_buf_item_relse(bp, _RET_IP_);\n\tASSERT(!(bip->bli_item.li_flags & XFS_LI_IN_AIL));\n\n\tbp->b_fspriv = bip->bli_item.li_bio_list;\n\tif (bp->b_fspriv == NULL)\n\t\tbp->b_iodone = NULL;\n\n\txfs_buf_rele(bp);\n\txfs_buf_item_free(bip);\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC void\txfs_buf_do_callbacks(struct xfs_buf *bp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\txfs_buf_do_callbacks(struct xfs_buf *bp);\n\nvoid\nxfs_buf_item_relse(\n\txfs_buf_t\t*bp)\n{\n\txfs_buf_log_item_t\t*bip = bp->b_fspriv;\n\n\ttrace_xfs_buf_item_relse(bp, _RET_IP_);\n\tASSERT(!(bip->bli_item.li_flags & XFS_LI_IN_AIL));\n\n\tbp->b_fspriv = bip->bli_item.li_bio_list;\n\tif (bp->b_fspriv == NULL)\n\t\tbp->b_iodone = NULL;\n\n\txfs_buf_rele(bp);\n\txfs_buf_item_free(bip);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "!(bip->bli_flags & XFS_BLI_INODE_ALLOC_BUF)"
          ],
          "line": 437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "!(bip->bli_item.li_flags & XFS_LI_IN_AIL)"
          ],
          "line": 436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "atomic_read(&bip->bli_refcount) == 0"
          ],
          "line": 435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&bip->bli_refcount"
          ],
          "line": 435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_buf_item_dirty",
          "args": [
            "bip"
          ],
          "line": 431
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_item_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf_item.c",
          "lines": "938-943",
          "snippet": "uint\nxfs_buf_item_dirty(\n\txfs_buf_log_item_t\t*bip)\n{\n\treturn (bip->bli_flags & XFS_BLI_DIRTY);\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nuint\nxfs_buf_item_dirty(\n\txfs_buf_log_item_t\t*bip)\n{\n\treturn (bip->bli_flags & XFS_BLI_DIRTY);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_dec",
          "args": [
            "&bip->bli_refcount"
          ],
          "line": 422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_trans_del_item",
          "args": [
            "&bip->bli_item"
          ],
          "line": 408
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_del_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.c",
          "lines": "681-687",
          "snippet": "void\nxfs_trans_del_item(\n\tstruct xfs_log_item\t*lip)\n{\n\txfs_trans_free_item_desc(lip->li_desc);\n\tlip->li_desc = NULL;\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_del_item(\n\tstruct xfs_log_item\t*lip)\n{\n\txfs_trans_free_item_desc(lip->li_desc);\n\tlip->li_desc = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "!(bip->bli_flags & XFS_BLI_LOGGED)"
          ],
          "line": 403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_xfs_trans_brelse",
          "args": [
            "bip"
          ],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "atomic_read(&bip->bli_refcount) > 0"
          ],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&bip->bli_refcount"
          ],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "!(bip->__bli_format.blf_flags & XFS_BLF_CANCEL)"
          ],
          "line": 373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "!(bip->bli_flags & XFS_BLI_STALE)"
          ],
          "line": 372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "bip->bli_item.li_type == XFS_LI_BUF"
          ],
          "line": 371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "bp->b_transp == tp"
          ],
          "line": 369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "bp->b_transp == NULL"
          ],
          "line": 364
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_brelse(xfs_trans_t\t*tp,\n\t\t xfs_buf_t\t*bp)\n{\n\txfs_buf_log_item_t\t*bip;\n\n\t/*\n\t * Default to a normal brelse() call if the tp is NULL.\n\t */\n\tif (tp == NULL) {\n\t\tASSERT(bp->b_transp == NULL);\n\t\txfs_buf_relse(bp);\n\t\treturn;\n\t}\n\n\tASSERT(bp->b_transp == tp);\n\tbip = bp->b_fspriv;\n\tASSERT(bip->bli_item.li_type == XFS_LI_BUF);\n\tASSERT(!(bip->bli_flags & XFS_BLI_STALE));\n\tASSERT(!(bip->__bli_format.blf_flags & XFS_BLF_CANCEL));\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\n\ttrace_xfs_trans_brelse(bip);\n\n\t/*\n\t * If the release is just for a recursive lock,\n\t * then decrement the count and return.\n\t */\n\tif (bip->bli_recur > 0) {\n\t\tbip->bli_recur--;\n\t\treturn;\n\t}\n\n\t/*\n\t * If the buffer is dirty within this transaction, we can't\n\t * release it until we commit.\n\t */\n\tif (bip->bli_item.li_desc->lid_flags & XFS_LID_DIRTY)\n\t\treturn;\n\n\t/*\n\t * If the buffer has been invalidated, then we can't release\n\t * it until the transaction commits to disk unless it is re-dirtied\n\t * as part of this transaction.  This prevents us from pulling\n\t * the item from the AIL before we should.\n\t */\n\tif (bip->bli_flags & XFS_BLI_STALE)\n\t\treturn;\n\n\tASSERT(!(bip->bli_flags & XFS_BLI_LOGGED));\n\n\t/*\n\t * Free up the log item descriptor tracking the released item.\n\t */\n\txfs_trans_del_item(&bip->bli_item);\n\n\t/*\n\t * Clear the hold flag in the buf log item if it is set.\n\t * We wouldn't want the next user of the buffer to\n\t * get confused.\n\t */\n\tif (bip->bli_flags & XFS_BLI_HOLD) {\n\t\tbip->bli_flags &= ~XFS_BLI_HOLD;\n\t}\n\n\t/*\n\t * Drop our reference to the buf log item.\n\t */\n\tatomic_dec(&bip->bli_refcount);\n\n\t/*\n\t * If the buf item is not tracking data in the log, then\n\t * we must free it before releasing the buffer back to the\n\t * free pool.  Before releasing the buffer to the free pool,\n\t * clear the transaction pointer in b_fsprivate2 to dissolve\n\t * its relation to this transaction.\n\t */\n\tif (!xfs_buf_item_dirty(bip)) {\n/***\n\t\tASSERT(bp->b_pincount == 0);\n***/\n\t\tASSERT(atomic_read(&bip->bli_refcount) == 0);\n\t\tASSERT(!(bip->bli_item.li_flags & XFS_LI_IN_AIL));\n\t\tASSERT(!(bip->bli_flags & XFS_BLI_INODE_ALLOC_BUF));\n\t\txfs_buf_item_relse(bp);\n\t}\n\n\tbp->b_transp = NULL;\n\txfs_buf_relse(bp);\n}"
  },
  {
    "function_name": "xfs_trans_read_buf_map",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_buf.c",
    "lines": "240-337",
    "snippet": "int\nxfs_trans_read_buf_map(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_buftarg\t*target,\n\tstruct xfs_buf_map\t*map,\n\tint\t\t\tnmaps,\n\txfs_buf_flags_t\t\tflags,\n\tstruct xfs_buf\t\t**bpp,\n\tconst struct xfs_buf_ops *ops)\n{\n\tstruct xfs_buf\t\t*bp = NULL;\n\tstruct xfs_buf_log_item\t*bip;\n\tint\t\t\terror;\n\n\t*bpp = NULL;\n\t/*\n\t * If we find the buffer in the cache with this transaction\n\t * pointer in its b_fsprivate2 field, then we know we already\n\t * have it locked.  If it is already read in we just increment\n\t * the lock recursion count and return the buffer to the caller.\n\t * If the buffer is not yet read in, then we read it in, increment\n\t * the lock recursion count, and return it to the caller.\n\t */\n\tif (tp)\n\t\tbp = xfs_trans_buf_item_match(tp, target, map, nmaps);\n\tif (bp) {\n\t\tASSERT(xfs_buf_islocked(bp));\n\t\tASSERT(bp->b_transp == tp);\n\t\tASSERT(bp->b_fspriv != NULL);\n\t\tASSERT(!bp->b_error);\n\t\tASSERT(bp->b_flags & XBF_DONE);\n\n\t\t/*\n\t\t * We never locked this buf ourselves, so we shouldn't\n\t\t * brelse it either. Just get out.\n\t\t */\n\t\tif (XFS_FORCED_SHUTDOWN(mp)) {\n\t\t\ttrace_xfs_trans_read_buf_shut(bp, _RET_IP_);\n\t\t\treturn -EIO;\n\t\t}\n\n\t\tbip = bp->b_fspriv;\n\t\tbip->bli_recur++;\n\n\t\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\t\ttrace_xfs_trans_read_buf_recur(bip);\n\t\t*bpp = bp;\n\t\treturn 0;\n\t}\n\n\tbp = xfs_buf_read_map(target, map, nmaps, flags, ops);\n\tif (!bp) {\n\t\tif (!(flags & XBF_TRYLOCK))\n\t\t\treturn -ENOMEM;\n\t\treturn tp ? 0 : -EAGAIN;\n\t}\n\n\t/*\n\t * If we've had a read error, then the contents of the buffer are\n\t * invalid and should not be used. To ensure that a followup read tries\n\t * to pull the buffer from disk again, we clear the XBF_DONE flag and\n\t * mark the buffer stale. This ensures that anyone who has a current\n\t * reference to the buffer will interpret it's contents correctly and\n\t * future cache lookups will also treat it as an empty, uninitialised\n\t * buffer.\n\t */\n\tif (bp->b_error) {\n\t\terror = bp->b_error;\n\t\tif (!XFS_FORCED_SHUTDOWN(mp))\n\t\t\txfs_buf_ioerror_alert(bp, __func__);\n\t\tbp->b_flags &= ~XBF_DONE;\n\t\txfs_buf_stale(bp);\n\n\t\tif (tp && (tp->t_flags & XFS_TRANS_DIRTY))\n\t\t\txfs_force_shutdown(tp->t_mountp, SHUTDOWN_META_IO_ERROR);\n\t\txfs_buf_relse(bp);\n\n\t\t/* bad CRC means corrupted metadata */\n\t\tif (error == -EFSBADCRC)\n\t\t\terror = -EFSCORRUPTED;\n\t\treturn error;\n\t}\n\n\tif (XFS_FORCED_SHUTDOWN(mp)) {\n\t\txfs_buf_relse(bp);\n\t\ttrace_xfs_trans_read_buf_shut(bp, _RET_IP_);\n\t\treturn -EIO;\n\t}\n\n\tif (tp) {\n\t\t_xfs_trans_bjoin(tp, bp, 1);\n\t\ttrace_xfs_trans_read_buf(bp->b_fspriv);\n\t}\n\t*bpp = bp;\n\treturn 0;\n\n}",
    "includes": [
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_xfs_trans_read_buf",
          "args": [
            "bp->b_fspriv"
          ],
          "line": 332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_xfs_trans_bjoin",
          "args": [
            "tp",
            "bp",
            "1"
          ],
          "line": 331
        },
        "resolved": true,
        "details": {
          "function_name": "_xfs_trans_bjoin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_buf.c",
          "lines": "74-113",
          "snippet": "STATIC void\n_xfs_trans_bjoin(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_buf\t\t*bp,\n\tint\t\t\treset_recur)\n{\n\tstruct xfs_buf_log_item\t*bip;\n\n\tASSERT(bp->b_transp == NULL);\n\n\t/*\n\t * The xfs_buf_log_item pointer is stored in b_fsprivate.  If\n\t * it doesn't have one yet, then allocate one and initialize it.\n\t * The checks to see if one is there are in xfs_buf_item_init().\n\t */\n\txfs_buf_item_init(bp, tp->t_mountp);\n\tbip = bp->b_fspriv;\n\tASSERT(!(bip->bli_flags & XFS_BLI_STALE));\n\tASSERT(!(bip->__bli_format.blf_flags & XFS_BLF_CANCEL));\n\tASSERT(!(bip->bli_flags & XFS_BLI_LOGGED));\n\tif (reset_recur)\n\t\tbip->bli_recur = 0;\n\n\t/*\n\t * Take a reference for this transaction on the buf item.\n\t */\n\tatomic_inc(&bip->bli_refcount);\n\n\t/*\n\t * Get a log_item_desc to point at the new item.\n\t */\n\txfs_trans_add_item(tp, &bip->bli_item);\n\n\t/*\n\t * Initialize b_fsprivate2 so we can find it with incore_match()\n\t * in xfs_trans_get_buf() and friends above.\n\t */\n\tbp->b_transp = tp;\n\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nSTATIC void\n_xfs_trans_bjoin(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_buf\t\t*bp,\n\tint\t\t\treset_recur)\n{\n\tstruct xfs_buf_log_item\t*bip;\n\n\tASSERT(bp->b_transp == NULL);\n\n\t/*\n\t * The xfs_buf_log_item pointer is stored in b_fsprivate.  If\n\t * it doesn't have one yet, then allocate one and initialize it.\n\t * The checks to see if one is there are in xfs_buf_item_init().\n\t */\n\txfs_buf_item_init(bp, tp->t_mountp);\n\tbip = bp->b_fspriv;\n\tASSERT(!(bip->bli_flags & XFS_BLI_STALE));\n\tASSERT(!(bip->__bli_format.blf_flags & XFS_BLF_CANCEL));\n\tASSERT(!(bip->bli_flags & XFS_BLI_LOGGED));\n\tif (reset_recur)\n\t\tbip->bli_recur = 0;\n\n\t/*\n\t * Take a reference for this transaction on the buf item.\n\t */\n\tatomic_inc(&bip->bli_refcount);\n\n\t/*\n\t * Get a log_item_desc to point at the new item.\n\t */\n\txfs_trans_add_item(tp, &bip->bli_item);\n\n\t/*\n\t * Initialize b_fsprivate2 so we can find it with incore_match()\n\t * in xfs_trans_get_buf() and friends above.\n\t */\n\tbp->b_transp = tp;\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_xfs_trans_read_buf_shut",
          "args": [
            "bp",
            "_RET_IP_"
          ],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_buf_relse",
          "args": [
            "bp"
          ],
          "line": 325
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_relse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.h",
          "lines": "361-365",
          "snippet": "static inline void xfs_buf_relse(xfs_buf_t *bp)\n{\n\txfs_buf_unlock(bp);\n\txfs_buf_rele(bp);\n}",
          "includes": [
            "#include <linux/list_lru.h>",
            "#include <linux/uio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/list_lru.h>\n#include <linux/uio.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/list.h>\n\nstatic inline void xfs_buf_relse(xfs_buf_t *bp)\n{\n\txfs_buf_unlock(bp);\n\txfs_buf_rele(bp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_FORCED_SHUTDOWN",
          "args": [
            "mp"
          ],
          "line": 324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_force_shutdown",
          "args": [
            "tp->t_mountp",
            "SHUTDOWN_META_IO_ERROR"
          ],
          "line": 315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_buf_stale",
          "args": [
            "bp"
          ],
          "line": 312
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_stale",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "90-113",
          "snippet": "void\nxfs_buf_stale(\n\tstruct xfs_buf\t*bp)\n{\n\tASSERT(xfs_buf_islocked(bp));\n\n\tbp->b_flags |= XBF_STALE;\n\n\t/*\n\t * Clear the delwri status so that a delwri queue walker will not\n\t * flush this buffer to disk now that it is stale. The delwri queue has\n\t * a reference to the buffer, so this is safe to do.\n\t */\n\tbp->b_flags &= ~_XBF_DELWRI_Q;\n\n\tspin_lock(&bp->b_lock);\n\tatomic_set(&bp->b_lru_ref, 0);\n\tif (!(bp->b_state & XFS_BSTATE_DISPOSE) &&\n\t    (list_lru_del(&bp->b_target->bt_lru, &bp->b_lru)))\n\t\tatomic_dec(&bp->b_hold);\n\n\tASSERT(atomic_read(&bp->b_hold) >= 1);\n\tspin_unlock(&bp->b_lock);\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nvoid\nxfs_buf_stale(\n\tstruct xfs_buf\t*bp)\n{\n\tASSERT(xfs_buf_islocked(bp));\n\n\tbp->b_flags |= XBF_STALE;\n\n\t/*\n\t * Clear the delwri status so that a delwri queue walker will not\n\t * flush this buffer to disk now that it is stale. The delwri queue has\n\t * a reference to the buffer, so this is safe to do.\n\t */\n\tbp->b_flags &= ~_XBF_DELWRI_Q;\n\n\tspin_lock(&bp->b_lock);\n\tatomic_set(&bp->b_lru_ref, 0);\n\tif (!(bp->b_state & XFS_BSTATE_DISPOSE) &&\n\t    (list_lru_del(&bp->b_target->bt_lru, &bp->b_lru)))\n\t\tatomic_dec(&bp->b_hold);\n\n\tASSERT(atomic_read(&bp->b_hold) >= 1);\n\tspin_unlock(&bp->b_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_buf_ioerror_alert",
          "args": [
            "bp",
            "__func__"
          ],
          "line": 310
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_ioerror_alert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "1067-1075",
          "snippet": "void\nxfs_buf_ioerror_alert(\n\tstruct xfs_buf\t\t*bp,\n\tconst char\t\t*func)\n{\n\txfs_alert(bp->b_target->bt_mount,\n\"metadata I/O error: block 0x%llx (\\\"%s\\\") error %d numblks %d\",\n\t\t(__uint64_t)XFS_BUF_ADDR(bp), func, -bp->b_error, bp->b_length);\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nvoid\nxfs_buf_ioerror_alert(\n\tstruct xfs_buf\t\t*bp,\n\tconst char\t\t*func)\n{\n\txfs_alert(bp->b_target->bt_mount,\n\"metadata I/O error: block 0x%llx (\\\"%s\\\") error %d numblks %d\",\n\t\t(__uint64_t)XFS_BUF_ADDR(bp), func, -bp->b_error, bp->b_length);\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_FORCED_SHUTDOWN",
          "args": [
            "mp"
          ],
          "line": 309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_buf_read_map",
          "args": [
            "target",
            "map",
            "nmaps",
            "flags",
            "ops"
          ],
          "line": 291
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_read_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "631-665",
          "snippet": "xfs_buf_t *\nxfs_buf_read_map(\n\tstruct xfs_buftarg\t*target,\n\tstruct xfs_buf_map\t*map,\n\tint\t\t\tnmaps,\n\txfs_buf_flags_t\t\tflags,\n\tconst struct xfs_buf_ops *ops)\n{\n\tstruct xfs_buf\t\t*bp;\n\n\tflags |= XBF_READ;\n\n\tbp = xfs_buf_get_map(target, map, nmaps, flags);\n\tif (bp) {\n\t\ttrace_xfs_buf_read(bp, flags, _RET_IP_);\n\n\t\tif (!XFS_BUF_ISDONE(bp)) {\n\t\t\tXFS_STATS_INC(xb_get_read);\n\t\t\tbp->b_ops = ops;\n\t\t\t_xfs_buf_read(bp, flags);\n\t\t} else if (flags & XBF_ASYNC) {\n\t\t\t/*\n\t\t\t * Read ahead call which is already satisfied,\n\t\t\t * drop the buffer\n\t\t\t */\n\t\t\txfs_buf_relse(bp);\n\t\t\treturn NULL;\n\t\t} else {\n\t\t\t/* We do not want read in the flags */\n\t\t\tbp->b_flags &= ~XBF_READ;\n\t\t}\n\t}\n\n\treturn bp;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nxfs_buf_t *\nxfs_buf_read_map(\n\tstruct xfs_buftarg\t*target,\n\tstruct xfs_buf_map\t*map,\n\tint\t\t\tnmaps,\n\txfs_buf_flags_t\t\tflags,\n\tconst struct xfs_buf_ops *ops)\n{\n\tstruct xfs_buf\t\t*bp;\n\n\tflags |= XBF_READ;\n\n\tbp = xfs_buf_get_map(target, map, nmaps, flags);\n\tif (bp) {\n\t\ttrace_xfs_buf_read(bp, flags, _RET_IP_);\n\n\t\tif (!XFS_BUF_ISDONE(bp)) {\n\t\t\tXFS_STATS_INC(xb_get_read);\n\t\t\tbp->b_ops = ops;\n\t\t\t_xfs_buf_read(bp, flags);\n\t\t} else if (flags & XBF_ASYNC) {\n\t\t\t/*\n\t\t\t * Read ahead call which is already satisfied,\n\t\t\t * drop the buffer\n\t\t\t */\n\t\t\txfs_buf_relse(bp);\n\t\t\treturn NULL;\n\t\t} else {\n\t\t\t/* We do not want read in the flags */\n\t\t\tbp->b_flags &= ~XBF_READ;\n\t\t}\n\t}\n\n\treturn bp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_xfs_trans_read_buf_recur",
          "args": [
            "bip"
          ],
          "line": 286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "atomic_read(&bip->bli_refcount) > 0"
          ],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&bip->bli_refcount"
          ],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_xfs_trans_read_buf_shut",
          "args": [
            "bp",
            "_RET_IP_"
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_FORCED_SHUTDOWN",
          "args": [
            "mp"
          ],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "bp->b_flags & XBF_DONE"
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "!bp->b_error"
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "bp->b_fspriv != NULL"
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "bp->b_transp == tp"
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "xfs_buf_islocked(bp)"
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_buf_islocked",
          "args": [
            "bp"
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_trans_buf_item_match",
          "args": [
            "tp",
            "target",
            "map",
            "nmaps"
          ],
          "line": 265
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_buf_item_match",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_buf.c",
          "lines": "36-63",
          "snippet": "xfs_buf *\nxfs_trans_buf_item_match(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_buftarg\t*target,\n\tstruct xfs_buf_map\t*map,\n\tint\t\t\tnmaps)\n{\n\tstruct xfs_log_item_desc *lidp;\n\tstruct xfs_buf_log_item\t*blip;\n\tint\t\t\tlen = 0;\n\tint\t\t\ti;\n\n\tfor (i = 0; i < nmaps; i++)\n\t\tlen += map[i].bm_len;\n\n\tlist_for_each_entry(lidp, &tp->t_items, lid_trans) {\n\t\tblip = (struct xfs_buf_log_item *)lidp->lid_item;\n\t\tif (blip->bli_item.li_type == XFS_LI_BUF &&\n\t\t    blip->bli_buf->b_target == target &&\n\t\t    XFS_BUF_ADDR(blip->bli_buf) == map[0].bm_bn &&\n\t\t    blip->bli_buf->b_length == len) {\n\t\t\tASSERT(blip->bli_buf->b_map_count == nmaps);\n\t\t\treturn blip->bli_buf;\n\t\t}\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nxfs_buf *\nxfs_trans_buf_item_match(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_buftarg\t*target,\n\tstruct xfs_buf_map\t*map,\n\tint\t\t\tnmaps)\n{\n\tstruct xfs_log_item_desc *lidp;\n\tstruct xfs_buf_log_item\t*blip;\n\tint\t\t\tlen = 0;\n\tint\t\t\ti;\n\n\tfor (i = 0; i < nmaps; i++)\n\t\tlen += map[i].bm_len;\n\n\tlist_for_each_entry(lidp, &tp->t_items, lid_trans) {\n\t\tblip = (struct xfs_buf_log_item *)lidp->lid_item;\n\t\tif (blip->bli_item.li_type == XFS_LI_BUF &&\n\t\t    blip->bli_buf->b_target == target &&\n\t\t    XFS_BUF_ADDR(blip->bli_buf) == map[0].bm_bn &&\n\t\t    blip->bli_buf->b_length == len) {\n\t\t\tASSERT(blip->bli_buf->b_map_count == nmaps);\n\t\t\treturn blip->bli_buf;\n\t\t}\n\t}\n\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nint\nxfs_trans_read_buf_map(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_buftarg\t*target,\n\tstruct xfs_buf_map\t*map,\n\tint\t\t\tnmaps,\n\txfs_buf_flags_t\t\tflags,\n\tstruct xfs_buf\t\t**bpp,\n\tconst struct xfs_buf_ops *ops)\n{\n\tstruct xfs_buf\t\t*bp = NULL;\n\tstruct xfs_buf_log_item\t*bip;\n\tint\t\t\terror;\n\n\t*bpp = NULL;\n\t/*\n\t * If we find the buffer in the cache with this transaction\n\t * pointer in its b_fsprivate2 field, then we know we already\n\t * have it locked.  If it is already read in we just increment\n\t * the lock recursion count and return the buffer to the caller.\n\t * If the buffer is not yet read in, then we read it in, increment\n\t * the lock recursion count, and return it to the caller.\n\t */\n\tif (tp)\n\t\tbp = xfs_trans_buf_item_match(tp, target, map, nmaps);\n\tif (bp) {\n\t\tASSERT(xfs_buf_islocked(bp));\n\t\tASSERT(bp->b_transp == tp);\n\t\tASSERT(bp->b_fspriv != NULL);\n\t\tASSERT(!bp->b_error);\n\t\tASSERT(bp->b_flags & XBF_DONE);\n\n\t\t/*\n\t\t * We never locked this buf ourselves, so we shouldn't\n\t\t * brelse it either. Just get out.\n\t\t */\n\t\tif (XFS_FORCED_SHUTDOWN(mp)) {\n\t\t\ttrace_xfs_trans_read_buf_shut(bp, _RET_IP_);\n\t\t\treturn -EIO;\n\t\t}\n\n\t\tbip = bp->b_fspriv;\n\t\tbip->bli_recur++;\n\n\t\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\t\ttrace_xfs_trans_read_buf_recur(bip);\n\t\t*bpp = bp;\n\t\treturn 0;\n\t}\n\n\tbp = xfs_buf_read_map(target, map, nmaps, flags, ops);\n\tif (!bp) {\n\t\tif (!(flags & XBF_TRYLOCK))\n\t\t\treturn -ENOMEM;\n\t\treturn tp ? 0 : -EAGAIN;\n\t}\n\n\t/*\n\t * If we've had a read error, then the contents of the buffer are\n\t * invalid and should not be used. To ensure that a followup read tries\n\t * to pull the buffer from disk again, we clear the XBF_DONE flag and\n\t * mark the buffer stale. This ensures that anyone who has a current\n\t * reference to the buffer will interpret it's contents correctly and\n\t * future cache lookups will also treat it as an empty, uninitialised\n\t * buffer.\n\t */\n\tif (bp->b_error) {\n\t\terror = bp->b_error;\n\t\tif (!XFS_FORCED_SHUTDOWN(mp))\n\t\t\txfs_buf_ioerror_alert(bp, __func__);\n\t\tbp->b_flags &= ~XBF_DONE;\n\t\txfs_buf_stale(bp);\n\n\t\tif (tp && (tp->t_flags & XFS_TRANS_DIRTY))\n\t\t\txfs_force_shutdown(tp->t_mountp, SHUTDOWN_META_IO_ERROR);\n\t\txfs_buf_relse(bp);\n\n\t\t/* bad CRC means corrupted metadata */\n\t\tif (error == -EFSBADCRC)\n\t\t\terror = -EFSCORRUPTED;\n\t\treturn error;\n\t}\n\n\tif (XFS_FORCED_SHUTDOWN(mp)) {\n\t\txfs_buf_relse(bp);\n\t\ttrace_xfs_trans_read_buf_shut(bp, _RET_IP_);\n\t\treturn -EIO;\n\t}\n\n\tif (tp) {\n\t\t_xfs_trans_bjoin(tp, bp, 1);\n\t\ttrace_xfs_trans_read_buf(bp->b_fspriv);\n\t}\n\t*bpp = bp;\n\treturn 0;\n\n}"
  },
  {
    "function_name": "xfs_trans_getsb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_buf.c",
    "lines": "190-228",
    "snippet": "xfs_buf_t *\nxfs_trans_getsb(xfs_trans_t\t*tp,\n\t\tstruct xfs_mount *mp,\n\t\tint\t\tflags)\n{\n\txfs_buf_t\t\t*bp;\n\txfs_buf_log_item_t\t*bip;\n\n\t/*\n\t * Default to just trying to lock the superblock buffer\n\t * if tp is NULL.\n\t */\n\tif (tp == NULL)\n\t\treturn xfs_getsb(mp, flags);\n\n\t/*\n\t * If the superblock buffer already has this transaction\n\t * pointer in its b_fsprivate2 field, then we know we already\n\t * have it locked.  In this case we just increment the lock\n\t * recursion count and return the buffer to the caller.\n\t */\n\tbp = mp->m_sb_bp;\n\tif (bp->b_transp == tp) {\n\t\tbip = bp->b_fspriv;\n\t\tASSERT(bip != NULL);\n\t\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\t\tbip->bli_recur++;\n\t\ttrace_xfs_trans_getsb_recur(bip);\n\t\treturn bp;\n\t}\n\n\tbp = xfs_getsb(mp, flags);\n\tif (bp == NULL)\n\t\treturn NULL;\n\n\t_xfs_trans_bjoin(tp, bp, 1);\n\ttrace_xfs_trans_getsb(bp->b_fspriv);\n\treturn bp;\n}",
    "includes": [
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_xfs_trans_getsb",
          "args": [
            "bp->b_fspriv"
          ],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_xfs_trans_bjoin",
          "args": [
            "tp",
            "bp",
            "1"
          ],
          "line": 225
        },
        "resolved": true,
        "details": {
          "function_name": "_xfs_trans_bjoin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_buf.c",
          "lines": "74-113",
          "snippet": "STATIC void\n_xfs_trans_bjoin(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_buf\t\t*bp,\n\tint\t\t\treset_recur)\n{\n\tstruct xfs_buf_log_item\t*bip;\n\n\tASSERT(bp->b_transp == NULL);\n\n\t/*\n\t * The xfs_buf_log_item pointer is stored in b_fsprivate.  If\n\t * it doesn't have one yet, then allocate one and initialize it.\n\t * The checks to see if one is there are in xfs_buf_item_init().\n\t */\n\txfs_buf_item_init(bp, tp->t_mountp);\n\tbip = bp->b_fspriv;\n\tASSERT(!(bip->bli_flags & XFS_BLI_STALE));\n\tASSERT(!(bip->__bli_format.blf_flags & XFS_BLF_CANCEL));\n\tASSERT(!(bip->bli_flags & XFS_BLI_LOGGED));\n\tif (reset_recur)\n\t\tbip->bli_recur = 0;\n\n\t/*\n\t * Take a reference for this transaction on the buf item.\n\t */\n\tatomic_inc(&bip->bli_refcount);\n\n\t/*\n\t * Get a log_item_desc to point at the new item.\n\t */\n\txfs_trans_add_item(tp, &bip->bli_item);\n\n\t/*\n\t * Initialize b_fsprivate2 so we can find it with incore_match()\n\t * in xfs_trans_get_buf() and friends above.\n\t */\n\tbp->b_transp = tp;\n\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nSTATIC void\n_xfs_trans_bjoin(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_buf\t\t*bp,\n\tint\t\t\treset_recur)\n{\n\tstruct xfs_buf_log_item\t*bip;\n\n\tASSERT(bp->b_transp == NULL);\n\n\t/*\n\t * The xfs_buf_log_item pointer is stored in b_fsprivate.  If\n\t * it doesn't have one yet, then allocate one and initialize it.\n\t * The checks to see if one is there are in xfs_buf_item_init().\n\t */\n\txfs_buf_item_init(bp, tp->t_mountp);\n\tbip = bp->b_fspriv;\n\tASSERT(!(bip->bli_flags & XFS_BLI_STALE));\n\tASSERT(!(bip->__bli_format.blf_flags & XFS_BLF_CANCEL));\n\tASSERT(!(bip->bli_flags & XFS_BLI_LOGGED));\n\tif (reset_recur)\n\t\tbip->bli_recur = 0;\n\n\t/*\n\t * Take a reference for this transaction on the buf item.\n\t */\n\tatomic_inc(&bip->bli_refcount);\n\n\t/*\n\t * Get a log_item_desc to point at the new item.\n\t */\n\txfs_trans_add_item(tp, &bip->bli_item);\n\n\t/*\n\t * Initialize b_fsprivate2 so we can find it with incore_match()\n\t * in xfs_trans_get_buf() and friends above.\n\t */\n\tbp->b_transp = tp;\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_getsb",
          "args": [
            "mp",
            "flags"
          ],
          "line": 221
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_getsb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_mount.c",
          "lines": "1360-1376",
          "snippet": "struct xfs_buf *\nxfs_getsb(\n\tstruct xfs_mount\t*mp,\n\tint\t\t\tflags)\n{\n\tstruct xfs_buf\t\t*bp = mp->m_sb_bp;\n\n\tif (!xfs_buf_trylock(bp)) {\n\t\tif (flags & XBF_TRYLOCK)\n\t\t\treturn NULL;\n\t\txfs_buf_lock(bp);\n\t}\n\n\txfs_buf_hold(bp);\n\tASSERT(XFS_BUF_ISDONE(bp));\n\treturn bp;\n}",
          "includes": [
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sysfs.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstruct xfs_buf *\nxfs_getsb(\n\tstruct xfs_mount\t*mp,\n\tint\t\t\tflags)\n{\n\tstruct xfs_buf\t\t*bp = mp->m_sb_bp;\n\n\tif (!xfs_buf_trylock(bp)) {\n\t\tif (flags & XBF_TRYLOCK)\n\t\t\treturn NULL;\n\t\txfs_buf_lock(bp);\n\t}\n\n\txfs_buf_hold(bp);\n\tASSERT(XFS_BUF_ISDONE(bp));\n\treturn bp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_xfs_trans_getsb_recur",
          "args": [
            "bip"
          ],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "atomic_read(&bip->bli_refcount) > 0"
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&bip->bli_refcount"
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "bip != NULL"
          ],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nxfs_buf_t *\nxfs_trans_getsb(xfs_trans_t\t*tp,\n\t\tstruct xfs_mount *mp,\n\t\tint\t\tflags)\n{\n\txfs_buf_t\t\t*bp;\n\txfs_buf_log_item_t\t*bip;\n\n\t/*\n\t * Default to just trying to lock the superblock buffer\n\t * if tp is NULL.\n\t */\n\tif (tp == NULL)\n\t\treturn xfs_getsb(mp, flags);\n\n\t/*\n\t * If the superblock buffer already has this transaction\n\t * pointer in its b_fsprivate2 field, then we know we already\n\t * have it locked.  In this case we just increment the lock\n\t * recursion count and return the buffer to the caller.\n\t */\n\tbp = mp->m_sb_bp;\n\tif (bp->b_transp == tp) {\n\t\tbip = bp->b_fspriv;\n\t\tASSERT(bip != NULL);\n\t\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\t\tbip->bli_recur++;\n\t\ttrace_xfs_trans_getsb_recur(bip);\n\t\treturn bp;\n\t}\n\n\tbp = xfs_getsb(mp, flags);\n\tif (bp == NULL)\n\t\treturn NULL;\n\n\t_xfs_trans_bjoin(tp, bp, 1);\n\ttrace_xfs_trans_getsb(bp->b_fspriv);\n\treturn bp;\n}"
  },
  {
    "function_name": "xfs_trans_get_buf_map",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_buf.c",
    "lines": "133-180",
    "snippet": "struct xfs_buf *\nxfs_trans_get_buf_map(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_buftarg\t*target,\n\tstruct xfs_buf_map\t*map,\n\tint\t\t\tnmaps,\n\txfs_buf_flags_t\t\tflags)\n{\n\txfs_buf_t\t\t*bp;\n\txfs_buf_log_item_t\t*bip;\n\n\tif (!tp)\n\t\treturn xfs_buf_get_map(target, map, nmaps, flags);\n\n\t/*\n\t * If we find the buffer in the cache with this transaction\n\t * pointer in its b_fsprivate2 field, then we know we already\n\t * have it locked.  In this case we just increment the lock\n\t * recursion count and return the buffer to the caller.\n\t */\n\tbp = xfs_trans_buf_item_match(tp, target, map, nmaps);\n\tif (bp != NULL) {\n\t\tASSERT(xfs_buf_islocked(bp));\n\t\tif (XFS_FORCED_SHUTDOWN(tp->t_mountp)) {\n\t\t\txfs_buf_stale(bp);\n\t\t\tXFS_BUF_DONE(bp);\n\t\t}\n\n\t\tASSERT(bp->b_transp == tp);\n\t\tbip = bp->b_fspriv;\n\t\tASSERT(bip != NULL);\n\t\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\t\tbip->bli_recur++;\n\t\ttrace_xfs_trans_get_buf_recur(bip);\n\t\treturn bp;\n\t}\n\n\tbp = xfs_buf_get_map(target, map, nmaps, flags);\n\tif (bp == NULL) {\n\t\treturn NULL;\n\t}\n\n\tASSERT(!bp->b_error);\n\n\t_xfs_trans_bjoin(tp, bp, 1);\n\ttrace_xfs_trans_get_buf(bp->b_fspriv);\n\treturn bp;\n}",
    "includes": [
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_xfs_trans_get_buf",
          "args": [
            "bp->b_fspriv"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_xfs_trans_bjoin",
          "args": [
            "tp",
            "bp",
            "1"
          ],
          "line": 177
        },
        "resolved": true,
        "details": {
          "function_name": "_xfs_trans_bjoin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_buf.c",
          "lines": "74-113",
          "snippet": "STATIC void\n_xfs_trans_bjoin(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_buf\t\t*bp,\n\tint\t\t\treset_recur)\n{\n\tstruct xfs_buf_log_item\t*bip;\n\n\tASSERT(bp->b_transp == NULL);\n\n\t/*\n\t * The xfs_buf_log_item pointer is stored in b_fsprivate.  If\n\t * it doesn't have one yet, then allocate one and initialize it.\n\t * The checks to see if one is there are in xfs_buf_item_init().\n\t */\n\txfs_buf_item_init(bp, tp->t_mountp);\n\tbip = bp->b_fspriv;\n\tASSERT(!(bip->bli_flags & XFS_BLI_STALE));\n\tASSERT(!(bip->__bli_format.blf_flags & XFS_BLF_CANCEL));\n\tASSERT(!(bip->bli_flags & XFS_BLI_LOGGED));\n\tif (reset_recur)\n\t\tbip->bli_recur = 0;\n\n\t/*\n\t * Take a reference for this transaction on the buf item.\n\t */\n\tatomic_inc(&bip->bli_refcount);\n\n\t/*\n\t * Get a log_item_desc to point at the new item.\n\t */\n\txfs_trans_add_item(tp, &bip->bli_item);\n\n\t/*\n\t * Initialize b_fsprivate2 so we can find it with incore_match()\n\t * in xfs_trans_get_buf() and friends above.\n\t */\n\tbp->b_transp = tp;\n\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nSTATIC void\n_xfs_trans_bjoin(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_buf\t\t*bp,\n\tint\t\t\treset_recur)\n{\n\tstruct xfs_buf_log_item\t*bip;\n\n\tASSERT(bp->b_transp == NULL);\n\n\t/*\n\t * The xfs_buf_log_item pointer is stored in b_fsprivate.  If\n\t * it doesn't have one yet, then allocate one and initialize it.\n\t * The checks to see if one is there are in xfs_buf_item_init().\n\t */\n\txfs_buf_item_init(bp, tp->t_mountp);\n\tbip = bp->b_fspriv;\n\tASSERT(!(bip->bli_flags & XFS_BLI_STALE));\n\tASSERT(!(bip->__bli_format.blf_flags & XFS_BLF_CANCEL));\n\tASSERT(!(bip->bli_flags & XFS_BLI_LOGGED));\n\tif (reset_recur)\n\t\tbip->bli_recur = 0;\n\n\t/*\n\t * Take a reference for this transaction on the buf item.\n\t */\n\tatomic_inc(&bip->bli_refcount);\n\n\t/*\n\t * Get a log_item_desc to point at the new item.\n\t */\n\txfs_trans_add_item(tp, &bip->bli_item);\n\n\t/*\n\t * Initialize b_fsprivate2 so we can find it with incore_match()\n\t * in xfs_trans_get_buf() and friends above.\n\t */\n\tbp->b_transp = tp;\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "!bp->b_error"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_buf_get_map",
          "args": [
            "target",
            "map",
            "nmaps",
            "flags"
          ],
          "line": 170
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_get_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "563-611",
          "snippet": "struct xfs_buf *\nxfs_buf_get_map(\n\tstruct xfs_buftarg\t*target,\n\tstruct xfs_buf_map\t*map,\n\tint\t\t\tnmaps,\n\txfs_buf_flags_t\t\tflags)\n{\n\tstruct xfs_buf\t\t*bp;\n\tstruct xfs_buf\t\t*new_bp;\n\tint\t\t\terror = 0;\n\n\tbp = _xfs_buf_find(target, map, nmaps, flags, NULL);\n\tif (likely(bp))\n\t\tgoto found;\n\n\tnew_bp = _xfs_buf_alloc(target, map, nmaps, flags);\n\tif (unlikely(!new_bp))\n\t\treturn NULL;\n\n\terror = xfs_buf_allocate_memory(new_bp, flags);\n\tif (error) {\n\t\txfs_buf_free(new_bp);\n\t\treturn NULL;\n\t}\n\n\tbp = _xfs_buf_find(target, map, nmaps, flags, new_bp);\n\tif (!bp) {\n\t\txfs_buf_free(new_bp);\n\t\treturn NULL;\n\t}\n\n\tif (bp != new_bp)\n\t\txfs_buf_free(new_bp);\n\nfound:\n\tif (!bp->b_addr) {\n\t\terror = _xfs_buf_map_pages(bp, flags);\n\t\tif (unlikely(error)) {\n\t\t\txfs_warn(target->bt_mount,\n\t\t\t\t\"%s: failed to map pagesn\", __func__);\n\t\t\txfs_buf_relse(bp);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tXFS_STATS_INC(xb_get);\n\ttrace_xfs_buf_get(bp, flags, _RET_IP_);\n\treturn bp;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nstruct xfs_buf *\nxfs_buf_get_map(\n\tstruct xfs_buftarg\t*target,\n\tstruct xfs_buf_map\t*map,\n\tint\t\t\tnmaps,\n\txfs_buf_flags_t\t\tflags)\n{\n\tstruct xfs_buf\t\t*bp;\n\tstruct xfs_buf\t\t*new_bp;\n\tint\t\t\terror = 0;\n\n\tbp = _xfs_buf_find(target, map, nmaps, flags, NULL);\n\tif (likely(bp))\n\t\tgoto found;\n\n\tnew_bp = _xfs_buf_alloc(target, map, nmaps, flags);\n\tif (unlikely(!new_bp))\n\t\treturn NULL;\n\n\terror = xfs_buf_allocate_memory(new_bp, flags);\n\tif (error) {\n\t\txfs_buf_free(new_bp);\n\t\treturn NULL;\n\t}\n\n\tbp = _xfs_buf_find(target, map, nmaps, flags, new_bp);\n\tif (!bp) {\n\t\txfs_buf_free(new_bp);\n\t\treturn NULL;\n\t}\n\n\tif (bp != new_bp)\n\t\txfs_buf_free(new_bp);\n\nfound:\n\tif (!bp->b_addr) {\n\t\terror = _xfs_buf_map_pages(bp, flags);\n\t\tif (unlikely(error)) {\n\t\t\txfs_warn(target->bt_mount,\n\t\t\t\t\"%s: failed to map pagesn\", __func__);\n\t\t\txfs_buf_relse(bp);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tXFS_STATS_INC(xb_get);\n\ttrace_xfs_buf_get(bp, flags, _RET_IP_);\n\treturn bp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_xfs_trans_get_buf_recur",
          "args": [
            "bip"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "atomic_read(&bip->bli_refcount) > 0"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&bip->bli_refcount"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "bip != NULL"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "bp->b_transp == tp"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BUF_DONE",
          "args": [
            "bp"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_buf_stale",
          "args": [
            "bp"
          ],
          "line": 157
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_stale",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "90-113",
          "snippet": "void\nxfs_buf_stale(\n\tstruct xfs_buf\t*bp)\n{\n\tASSERT(xfs_buf_islocked(bp));\n\n\tbp->b_flags |= XBF_STALE;\n\n\t/*\n\t * Clear the delwri status so that a delwri queue walker will not\n\t * flush this buffer to disk now that it is stale. The delwri queue has\n\t * a reference to the buffer, so this is safe to do.\n\t */\n\tbp->b_flags &= ~_XBF_DELWRI_Q;\n\n\tspin_lock(&bp->b_lock);\n\tatomic_set(&bp->b_lru_ref, 0);\n\tif (!(bp->b_state & XFS_BSTATE_DISPOSE) &&\n\t    (list_lru_del(&bp->b_target->bt_lru, &bp->b_lru)))\n\t\tatomic_dec(&bp->b_hold);\n\n\tASSERT(atomic_read(&bp->b_hold) >= 1);\n\tspin_unlock(&bp->b_lock);\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nvoid\nxfs_buf_stale(\n\tstruct xfs_buf\t*bp)\n{\n\tASSERT(xfs_buf_islocked(bp));\n\n\tbp->b_flags |= XBF_STALE;\n\n\t/*\n\t * Clear the delwri status so that a delwri queue walker will not\n\t * flush this buffer to disk now that it is stale. The delwri queue has\n\t * a reference to the buffer, so this is safe to do.\n\t */\n\tbp->b_flags &= ~_XBF_DELWRI_Q;\n\n\tspin_lock(&bp->b_lock);\n\tatomic_set(&bp->b_lru_ref, 0);\n\tif (!(bp->b_state & XFS_BSTATE_DISPOSE) &&\n\t    (list_lru_del(&bp->b_target->bt_lru, &bp->b_lru)))\n\t\tatomic_dec(&bp->b_hold);\n\n\tASSERT(atomic_read(&bp->b_hold) >= 1);\n\tspin_unlock(&bp->b_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_FORCED_SHUTDOWN",
          "args": [
            "tp->t_mountp"
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "xfs_buf_islocked(bp)"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_buf_islocked",
          "args": [
            "bp"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_trans_buf_item_match",
          "args": [
            "tp",
            "target",
            "map",
            "nmaps"
          ],
          "line": 153
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_buf_item_match",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_buf.c",
          "lines": "36-63",
          "snippet": "xfs_buf *\nxfs_trans_buf_item_match(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_buftarg\t*target,\n\tstruct xfs_buf_map\t*map,\n\tint\t\t\tnmaps)\n{\n\tstruct xfs_log_item_desc *lidp;\n\tstruct xfs_buf_log_item\t*blip;\n\tint\t\t\tlen = 0;\n\tint\t\t\ti;\n\n\tfor (i = 0; i < nmaps; i++)\n\t\tlen += map[i].bm_len;\n\n\tlist_for_each_entry(lidp, &tp->t_items, lid_trans) {\n\t\tblip = (struct xfs_buf_log_item *)lidp->lid_item;\n\t\tif (blip->bli_item.li_type == XFS_LI_BUF &&\n\t\t    blip->bli_buf->b_target == target &&\n\t\t    XFS_BUF_ADDR(blip->bli_buf) == map[0].bm_bn &&\n\t\t    blip->bli_buf->b_length == len) {\n\t\t\tASSERT(blip->bli_buf->b_map_count == nmaps);\n\t\t\treturn blip->bli_buf;\n\t\t}\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nxfs_buf *\nxfs_trans_buf_item_match(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_buftarg\t*target,\n\tstruct xfs_buf_map\t*map,\n\tint\t\t\tnmaps)\n{\n\tstruct xfs_log_item_desc *lidp;\n\tstruct xfs_buf_log_item\t*blip;\n\tint\t\t\tlen = 0;\n\tint\t\t\ti;\n\n\tfor (i = 0; i < nmaps; i++)\n\t\tlen += map[i].bm_len;\n\n\tlist_for_each_entry(lidp, &tp->t_items, lid_trans) {\n\t\tblip = (struct xfs_buf_log_item *)lidp->lid_item;\n\t\tif (blip->bli_item.li_type == XFS_LI_BUF &&\n\t\t    blip->bli_buf->b_target == target &&\n\t\t    XFS_BUF_ADDR(blip->bli_buf) == map[0].bm_bn &&\n\t\t    blip->bli_buf->b_length == len) {\n\t\t\tASSERT(blip->bli_buf->b_map_count == nmaps);\n\t\t\treturn blip->bli_buf;\n\t\t}\n\t}\n\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nstruct xfs_buf *\nxfs_trans_get_buf_map(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_buftarg\t*target,\n\tstruct xfs_buf_map\t*map,\n\tint\t\t\tnmaps,\n\txfs_buf_flags_t\t\tflags)\n{\n\txfs_buf_t\t\t*bp;\n\txfs_buf_log_item_t\t*bip;\n\n\tif (!tp)\n\t\treturn xfs_buf_get_map(target, map, nmaps, flags);\n\n\t/*\n\t * If we find the buffer in the cache with this transaction\n\t * pointer in its b_fsprivate2 field, then we know we already\n\t * have it locked.  In this case we just increment the lock\n\t * recursion count and return the buffer to the caller.\n\t */\n\tbp = xfs_trans_buf_item_match(tp, target, map, nmaps);\n\tif (bp != NULL) {\n\t\tASSERT(xfs_buf_islocked(bp));\n\t\tif (XFS_FORCED_SHUTDOWN(tp->t_mountp)) {\n\t\t\txfs_buf_stale(bp);\n\t\t\tXFS_BUF_DONE(bp);\n\t\t}\n\n\t\tASSERT(bp->b_transp == tp);\n\t\tbip = bp->b_fspriv;\n\t\tASSERT(bip != NULL);\n\t\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\t\tbip->bli_recur++;\n\t\ttrace_xfs_trans_get_buf_recur(bip);\n\t\treturn bp;\n\t}\n\n\tbp = xfs_buf_get_map(target, map, nmaps, flags);\n\tif (bp == NULL) {\n\t\treturn NULL;\n\t}\n\n\tASSERT(!bp->b_error);\n\n\t_xfs_trans_bjoin(tp, bp, 1);\n\ttrace_xfs_trans_get_buf(bp->b_fspriv);\n\treturn bp;\n}"
  },
  {
    "function_name": "xfs_trans_bjoin",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_buf.c",
    "lines": "115-122",
    "snippet": "void\nxfs_trans_bjoin(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_buf\t\t*bp)\n{\n\t_xfs_trans_bjoin(tp, bp, 0);\n\ttrace_xfs_trans_bjoin(bp->b_fspriv);\n}",
    "includes": [
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_xfs_trans_bjoin",
          "args": [
            "bp->b_fspriv"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_xfs_trans_bjoin",
          "args": [
            "tp",
            "bp",
            "0"
          ],
          "line": 120
        },
        "resolved": true,
        "details": {
          "function_name": "_xfs_trans_bjoin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_buf.c",
          "lines": "74-113",
          "snippet": "STATIC void\n_xfs_trans_bjoin(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_buf\t\t*bp,\n\tint\t\t\treset_recur)\n{\n\tstruct xfs_buf_log_item\t*bip;\n\n\tASSERT(bp->b_transp == NULL);\n\n\t/*\n\t * The xfs_buf_log_item pointer is stored in b_fsprivate.  If\n\t * it doesn't have one yet, then allocate one and initialize it.\n\t * The checks to see if one is there are in xfs_buf_item_init().\n\t */\n\txfs_buf_item_init(bp, tp->t_mountp);\n\tbip = bp->b_fspriv;\n\tASSERT(!(bip->bli_flags & XFS_BLI_STALE));\n\tASSERT(!(bip->__bli_format.blf_flags & XFS_BLF_CANCEL));\n\tASSERT(!(bip->bli_flags & XFS_BLI_LOGGED));\n\tif (reset_recur)\n\t\tbip->bli_recur = 0;\n\n\t/*\n\t * Take a reference for this transaction on the buf item.\n\t */\n\tatomic_inc(&bip->bli_refcount);\n\n\t/*\n\t * Get a log_item_desc to point at the new item.\n\t */\n\txfs_trans_add_item(tp, &bip->bli_item);\n\n\t/*\n\t * Initialize b_fsprivate2 so we can find it with incore_match()\n\t * in xfs_trans_get_buf() and friends above.\n\t */\n\tbp->b_transp = tp;\n\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nSTATIC void\n_xfs_trans_bjoin(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_buf\t\t*bp,\n\tint\t\t\treset_recur)\n{\n\tstruct xfs_buf_log_item\t*bip;\n\n\tASSERT(bp->b_transp == NULL);\n\n\t/*\n\t * The xfs_buf_log_item pointer is stored in b_fsprivate.  If\n\t * it doesn't have one yet, then allocate one and initialize it.\n\t * The checks to see if one is there are in xfs_buf_item_init().\n\t */\n\txfs_buf_item_init(bp, tp->t_mountp);\n\tbip = bp->b_fspriv;\n\tASSERT(!(bip->bli_flags & XFS_BLI_STALE));\n\tASSERT(!(bip->__bli_format.blf_flags & XFS_BLF_CANCEL));\n\tASSERT(!(bip->bli_flags & XFS_BLI_LOGGED));\n\tif (reset_recur)\n\t\tbip->bli_recur = 0;\n\n\t/*\n\t * Take a reference for this transaction on the buf item.\n\t */\n\tatomic_inc(&bip->bli_refcount);\n\n\t/*\n\t * Get a log_item_desc to point at the new item.\n\t */\n\txfs_trans_add_item(tp, &bip->bli_item);\n\n\t/*\n\t * Initialize b_fsprivate2 so we can find it with incore_match()\n\t * in xfs_trans_get_buf() and friends above.\n\t */\n\tbp->b_transp = tp;\n\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nvoid\nxfs_trans_bjoin(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_buf\t\t*bp)\n{\n\t_xfs_trans_bjoin(tp, bp, 0);\n\ttrace_xfs_trans_bjoin(bp->b_fspriv);\n}"
  },
  {
    "function_name": "_xfs_trans_bjoin",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_buf.c",
    "lines": "74-113",
    "snippet": "STATIC void\n_xfs_trans_bjoin(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_buf\t\t*bp,\n\tint\t\t\treset_recur)\n{\n\tstruct xfs_buf_log_item\t*bip;\n\n\tASSERT(bp->b_transp == NULL);\n\n\t/*\n\t * The xfs_buf_log_item pointer is stored in b_fsprivate.  If\n\t * it doesn't have one yet, then allocate one and initialize it.\n\t * The checks to see if one is there are in xfs_buf_item_init().\n\t */\n\txfs_buf_item_init(bp, tp->t_mountp);\n\tbip = bp->b_fspriv;\n\tASSERT(!(bip->bli_flags & XFS_BLI_STALE));\n\tASSERT(!(bip->__bli_format.blf_flags & XFS_BLF_CANCEL));\n\tASSERT(!(bip->bli_flags & XFS_BLI_LOGGED));\n\tif (reset_recur)\n\t\tbip->bli_recur = 0;\n\n\t/*\n\t * Take a reference for this transaction on the buf item.\n\t */\n\tatomic_inc(&bip->bli_refcount);\n\n\t/*\n\t * Get a log_item_desc to point at the new item.\n\t */\n\txfs_trans_add_item(tp, &bip->bli_item);\n\n\t/*\n\t * Initialize b_fsprivate2 so we can find it with incore_match()\n\t * in xfs_trans_get_buf() and friends above.\n\t */\n\tbp->b_transp = tp;\n\n}",
    "includes": [
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_trans_add_item",
          "args": [
            "tp",
            "&bip->bli_item"
          ],
          "line": 105
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_add_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.c",
          "lines": "651-668",
          "snippet": "void\nxfs_trans_add_item(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_log_item\t*lip)\n{\n\tstruct xfs_log_item_desc *lidp;\n\n\tASSERT(lip->li_mountp == tp->t_mountp);\n\tASSERT(lip->li_ailp == tp->t_mountp->m_ail);\n\n\tlidp = kmem_zone_zalloc(xfs_log_item_desc_zone, KM_SLEEP | KM_NOFS);\n\n\tlidp->lid_item = lip;\n\tlidp->lid_flags = 0;\n\tlist_add_tail(&lidp->lid_trans, &tp->t_items);\n\n\tlip->li_desc = lidp;\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "kmem_zone_t\t*xfs_log_item_desc_zone;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nkmem_zone_t\t*xfs_log_item_desc_zone;\n\nvoid\nxfs_trans_add_item(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_log_item\t*lip)\n{\n\tstruct xfs_log_item_desc *lidp;\n\n\tASSERT(lip->li_mountp == tp->t_mountp);\n\tASSERT(lip->li_ailp == tp->t_mountp->m_ail);\n\n\tlidp = kmem_zone_zalloc(xfs_log_item_desc_zone, KM_SLEEP | KM_NOFS);\n\n\tlidp->lid_item = lip;\n\tlidp->lid_flags = 0;\n\tlist_add_tail(&lidp->lid_trans, &tp->t_items);\n\n\tlip->li_desc = lidp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&bip->bli_refcount"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "!(bip->bli_flags & XFS_BLI_LOGGED)"
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "!(bip->__bli_format.blf_flags & XFS_BLF_CANCEL)"
          ],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "!(bip->bli_flags & XFS_BLI_STALE)"
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_buf_item_init",
          "args": [
            "bp",
            "tp->t_mountp"
          ],
          "line": 89
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_item_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf_item.c",
          "lines": "753-810",
          "snippet": "void\nxfs_buf_item_init(\n\txfs_buf_t\t*bp,\n\txfs_mount_t\t*mp)\n{\n\txfs_log_item_t\t\t*lip = bp->b_fspriv;\n\txfs_buf_log_item_t\t*bip;\n\tint\t\t\tchunks;\n\tint\t\t\tmap_size;\n\tint\t\t\terror;\n\tint\t\t\ti;\n\n\t/*\n\t * Check to see if there is already a buf log item for\n\t * this buffer.  If there is, it is guaranteed to be\n\t * the first.  If we do already have one, there is\n\t * nothing to do here so return.\n\t */\n\tASSERT(bp->b_target->bt_mount == mp);\n\tif (lip != NULL && lip->li_type == XFS_LI_BUF)\n\t\treturn;\n\n\tbip = kmem_zone_zalloc(xfs_buf_item_zone, KM_SLEEP);\n\txfs_log_item_init(mp, &bip->bli_item, XFS_LI_BUF, &xfs_buf_item_ops);\n\tbip->bli_buf = bp;\n\txfs_buf_hold(bp);\n\n\t/*\n\t * chunks is the number of XFS_BLF_CHUNK size pieces the buffer\n\t * can be divided into. Make sure not to truncate any pieces.\n\t * map_size is the size of the bitmap needed to describe the\n\t * chunks of the buffer.\n\t *\n\t * Discontiguous buffer support follows the layout of the underlying\n\t * buffer. This makes the implementation as simple as possible.\n\t */\n\terror = xfs_buf_item_get_format(bip, bp->b_map_count);\n\tASSERT(error == 0);\n\n\tfor (i = 0; i < bip->bli_format_count; i++) {\n\t\tchunks = DIV_ROUND_UP(BBTOB(bp->b_maps[i].bm_len),\n\t\t\t\t      XFS_BLF_CHUNK);\n\t\tmap_size = DIV_ROUND_UP(chunks, NBWORD);\n\n\t\tbip->bli_formats[i].blf_type = XFS_LI_BUF;\n\t\tbip->bli_formats[i].blf_blkno = bp->b_maps[i].bm_bn;\n\t\tbip->bli_formats[i].blf_len = bp->b_maps[i].bm_len;\n\t\tbip->bli_formats[i].blf_map_size = map_size;\n\t}\n\n\t/*\n\t * Put the buf item into the list of items attached to the\n\t * buffer at the front.\n\t */\n\tif (bp->b_fspriv)\n\t\tbip->bli_item.li_bio_list = bp->b_fspriv;\n\tbp->b_fspriv = bip;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "kmem_zone_t\t*xfs_buf_item_zone;",
            "STATIC void\txfs_buf_do_callbacks(struct xfs_buf *bp);",
            "static const struct xfs_item_ops xfs_buf_item_ops = {\n\t.iop_size\t= xfs_buf_item_size,\n\t.iop_format\t= xfs_buf_item_format,\n\t.iop_pin\t= xfs_buf_item_pin,\n\t.iop_unpin\t= xfs_buf_item_unpin,\n\t.iop_unlock\t= xfs_buf_item_unlock,\n\t.iop_committed\t= xfs_buf_item_committed,\n\t.iop_push\t= xfs_buf_item_push,\n\t.iop_committing = xfs_buf_item_committing\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nkmem_zone_t\t*xfs_buf_item_zone;\nSTATIC void\txfs_buf_do_callbacks(struct xfs_buf *bp);\nstatic const struct xfs_item_ops xfs_buf_item_ops = {\n\t.iop_size\t= xfs_buf_item_size,\n\t.iop_format\t= xfs_buf_item_format,\n\t.iop_pin\t= xfs_buf_item_pin,\n\t.iop_unpin\t= xfs_buf_item_unpin,\n\t.iop_unlock\t= xfs_buf_item_unlock,\n\t.iop_committed\t= xfs_buf_item_committed,\n\t.iop_push\t= xfs_buf_item_push,\n\t.iop_committing = xfs_buf_item_committing\n};\n\nvoid\nxfs_buf_item_init(\n\txfs_buf_t\t*bp,\n\txfs_mount_t\t*mp)\n{\n\txfs_log_item_t\t\t*lip = bp->b_fspriv;\n\txfs_buf_log_item_t\t*bip;\n\tint\t\t\tchunks;\n\tint\t\t\tmap_size;\n\tint\t\t\terror;\n\tint\t\t\ti;\n\n\t/*\n\t * Check to see if there is already a buf log item for\n\t * this buffer.  If there is, it is guaranteed to be\n\t * the first.  If we do already have one, there is\n\t * nothing to do here so return.\n\t */\n\tASSERT(bp->b_target->bt_mount == mp);\n\tif (lip != NULL && lip->li_type == XFS_LI_BUF)\n\t\treturn;\n\n\tbip = kmem_zone_zalloc(xfs_buf_item_zone, KM_SLEEP);\n\txfs_log_item_init(mp, &bip->bli_item, XFS_LI_BUF, &xfs_buf_item_ops);\n\tbip->bli_buf = bp;\n\txfs_buf_hold(bp);\n\n\t/*\n\t * chunks is the number of XFS_BLF_CHUNK size pieces the buffer\n\t * can be divided into. Make sure not to truncate any pieces.\n\t * map_size is the size of the bitmap needed to describe the\n\t * chunks of the buffer.\n\t *\n\t * Discontiguous buffer support follows the layout of the underlying\n\t * buffer. This makes the implementation as simple as possible.\n\t */\n\terror = xfs_buf_item_get_format(bip, bp->b_map_count);\n\tASSERT(error == 0);\n\n\tfor (i = 0; i < bip->bli_format_count; i++) {\n\t\tchunks = DIV_ROUND_UP(BBTOB(bp->b_maps[i].bm_len),\n\t\t\t\t      XFS_BLF_CHUNK);\n\t\tmap_size = DIV_ROUND_UP(chunks, NBWORD);\n\n\t\tbip->bli_formats[i].blf_type = XFS_LI_BUF;\n\t\tbip->bli_formats[i].blf_blkno = bp->b_maps[i].bm_bn;\n\t\tbip->bli_formats[i].blf_len = bp->b_maps[i].bm_len;\n\t\tbip->bli_formats[i].blf_map_size = map_size;\n\t}\n\n\t/*\n\t * Put the buf item into the list of items attached to the\n\t * buffer at the front.\n\t */\n\tif (bp->b_fspriv)\n\t\tbip->bli_item.li_bio_list = bp->b_fspriv;\n\tbp->b_fspriv = bip;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "bp->b_transp == NULL"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nSTATIC void\n_xfs_trans_bjoin(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_buf\t\t*bp,\n\tint\t\t\treset_recur)\n{\n\tstruct xfs_buf_log_item\t*bip;\n\n\tASSERT(bp->b_transp == NULL);\n\n\t/*\n\t * The xfs_buf_log_item pointer is stored in b_fsprivate.  If\n\t * it doesn't have one yet, then allocate one and initialize it.\n\t * The checks to see if one is there are in xfs_buf_item_init().\n\t */\n\txfs_buf_item_init(bp, tp->t_mountp);\n\tbip = bp->b_fspriv;\n\tASSERT(!(bip->bli_flags & XFS_BLI_STALE));\n\tASSERT(!(bip->__bli_format.blf_flags & XFS_BLF_CANCEL));\n\tASSERT(!(bip->bli_flags & XFS_BLI_LOGGED));\n\tif (reset_recur)\n\t\tbip->bli_recur = 0;\n\n\t/*\n\t * Take a reference for this transaction on the buf item.\n\t */\n\tatomic_inc(&bip->bli_refcount);\n\n\t/*\n\t * Get a log_item_desc to point at the new item.\n\t */\n\txfs_trans_add_item(tp, &bip->bli_item);\n\n\t/*\n\t * Initialize b_fsprivate2 so we can find it with incore_match()\n\t * in xfs_trans_get_buf() and friends above.\n\t */\n\tbp->b_transp = tp;\n\n}"
  },
  {
    "function_name": "xfs_trans_buf_item_match",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_buf.c",
    "lines": "36-63",
    "snippet": "xfs_buf *\nxfs_trans_buf_item_match(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_buftarg\t*target,\n\tstruct xfs_buf_map\t*map,\n\tint\t\t\tnmaps)\n{\n\tstruct xfs_log_item_desc *lidp;\n\tstruct xfs_buf_log_item\t*blip;\n\tint\t\t\tlen = 0;\n\tint\t\t\ti;\n\n\tfor (i = 0; i < nmaps; i++)\n\t\tlen += map[i].bm_len;\n\n\tlist_for_each_entry(lidp, &tp->t_items, lid_trans) {\n\t\tblip = (struct xfs_buf_log_item *)lidp->lid_item;\n\t\tif (blip->bli_item.li_type == XFS_LI_BUF &&\n\t\t    blip->bli_buf->b_target == target &&\n\t\t    XFS_BUF_ADDR(blip->bli_buf) == map[0].bm_bn &&\n\t\t    blip->bli_buf->b_length == len) {\n\t\t\tASSERT(blip->bli_buf->b_map_count == nmaps);\n\t\t\treturn blip->bli_buf;\n\t\t}\n\t}\n\n\treturn NULL;\n}",
    "includes": [
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "blip->bli_buf->b_map_count == nmaps"
          ],
          "line": 57
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BUF_ADDR",
          "args": [
            "blip->bli_buf"
          ],
          "line": 55
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "lidp",
            "&tp->t_items",
            "lid_trans"
          ],
          "line": 51
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nxfs_buf *\nxfs_trans_buf_item_match(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_buftarg\t*target,\n\tstruct xfs_buf_map\t*map,\n\tint\t\t\tnmaps)\n{\n\tstruct xfs_log_item_desc *lidp;\n\tstruct xfs_buf_log_item\t*blip;\n\tint\t\t\tlen = 0;\n\tint\t\t\ti;\n\n\tfor (i = 0; i < nmaps; i++)\n\t\tlen += map[i].bm_len;\n\n\tlist_for_each_entry(lidp, &tp->t_items, lid_trans) {\n\t\tblip = (struct xfs_buf_log_item *)lidp->lid_item;\n\t\tif (blip->bli_item.li_type == XFS_LI_BUF &&\n\t\t    blip->bli_buf->b_target == target &&\n\t\t    XFS_BUF_ADDR(blip->bli_buf) == map[0].bm_bn &&\n\t\t    blip->bli_buf->b_length == len) {\n\t\t\tASSERT(blip->bli_buf->b_map_count == nmaps);\n\t\t\treturn blip->bli_buf;\n\t\t}\n\t}\n\n\treturn NULL;\n}"
  }
]