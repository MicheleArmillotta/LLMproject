[
  {
    "function_name": "dlm_ls_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/member.c",
    "lines": "674-721",
    "snippet": "int dlm_ls_start(struct dlm_ls *ls)\n{\n\tstruct dlm_recover *rv = NULL, *rv_old;\n\tstruct dlm_config_node *nodes;\n\tint error, count;\n\n\trv = kzalloc(sizeof(struct dlm_recover), GFP_NOFS);\n\tif (!rv)\n\t\treturn -ENOMEM;\n\n\terror = dlm_config_nodes(ls->ls_name, &nodes, &count);\n\tif (error < 0)\n\t\tgoto fail;\n\n\tspin_lock(&ls->ls_recover_lock);\n\n\t/* the lockspace needs to be stopped before it can be started */\n\n\tif (!dlm_locking_stopped(ls)) {\n\t\tspin_unlock(&ls->ls_recover_lock);\n\t\tlog_error(ls, \"start ignored: lockspace running\");\n\t\terror = -EINVAL;\n\t\tgoto fail;\n\t}\n\n\trv->nodes = nodes;\n\trv->nodes_count = count;\n\trv->seq = ++ls->ls_recover_seq;\n\trv_old = ls->ls_recover_args;\n\tls->ls_recover_args = rv;\n\tspin_unlock(&ls->ls_recover_lock);\n\n\tif (rv_old) {\n\t\tlog_error(ls, \"unused recovery %llx %d\",\n\t\t\t  (unsigned long long)rv_old->seq, rv_old->nodes_count);\n\t\tkfree(rv_old->nodes);\n\t\tkfree(rv_old);\n\t}\n\n\tset_bit(LSFL_RECOVER_WORK, &ls->ls_flags);\n\twake_up_process(ls->ls_recoverd_task);\n\treturn 0;\n\n fail:\n\tkfree(rv);\n\tkfree(nodes);\n\treturn error;\n}",
    "includes": [
      "#include \"lowcomms.h\"",
      "#include \"config.h\"",
      "#include \"rcom.h\"",
      "#include \"recover.h\"",
      "#include \"recoverd.h\"",
      "#include \"member.h\"",
      "#include \"lockspace.h\"",
      "#include \"dlm_internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "nodes"
          ],
          "line": 719
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "rv"
          ],
          "line": 718
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wake_up_process",
          "args": [
            "ls->ls_recoverd_task"
          ],
          "line": 714
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "LSFL_RECOVER_WORK",
            "&ls->ls_flags"
          ],
          "line": 713
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "rv_old"
          ],
          "line": 710
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "rv_old->nodes"
          ],
          "line": 709
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "log_error",
          "args": [
            "ls",
            "\"unused recovery %llx %d\"",
            "(unsigned long long)rv_old->seq",
            "rv_old->nodes_count"
          ],
          "line": 707
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ls->ls_recover_lock"
          ],
          "line": 704
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "log_error",
          "args": [
            "ls",
            "\"start ignored: lockspace running\""
          ],
          "line": 694
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_locking_stopped",
          "args": [
            "ls"
          ],
          "line": 692
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_locking_stopped",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/dlm_internal.h",
          "lines": "695-698",
          "snippet": "static inline int dlm_locking_stopped(struct dlm_ls *ls)\n{\n\treturn !test_bit(LSFL_RUNNING, &ls->ls_flags);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include <linux/dlm.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/idr.h>",
            "#include <linux/mutex.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/jhash.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kref.h>",
            "#include <linux/kobject.h>",
            "#include <linux/kthread.h>",
            "#include <linux/socket.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/errno.h>",
            "#include <linux/list.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define LSFL_RUNNING\t\t4"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include <linux/dlm.h>\n#include <asm/uaccess.h>\n#include <linux/ratelimit.h>\n#include <linux/idr.h>\n#include <linux/mutex.h>\n#include <linux/miscdevice.h>\n#include <linux/jhash.h>\n#include <linux/kernel.h>\n#include <linux/kref.h>\n#include <linux/kobject.h>\n#include <linux/kthread.h>\n#include <linux/socket.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/errno.h>\n#include <linux/list.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\n#define LSFL_RUNNING\t\t4\n\nstatic inline int dlm_locking_stopped(struct dlm_ls *ls)\n{\n\treturn !test_bit(LSFL_RUNNING, &ls->ls_flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ls->ls_recover_lock"
          ],
          "line": 688
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_config_nodes",
          "args": [
            "ls->ls_name",
            "&nodes",
            "&count"
          ],
          "line": 684
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_config_nodes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/config.c",
          "lines": "937-982",
          "snippet": "int dlm_config_nodes(char *lsname, struct dlm_config_node **nodes_out,\n\t\t     int *count_out)\n{\n\tstruct dlm_space *sp;\n\tstruct dlm_node *nd;\n\tstruct dlm_config_node *nodes, *node;\n\tint rv, count;\n\n\tsp = get_space(lsname);\n\tif (!sp)\n\t\treturn -EEXIST;\n\n\tmutex_lock(&sp->members_lock);\n\tif (!sp->members_count) {\n\t\trv = -EINVAL;\n\t\tprintk(KERN_ERR \"dlm: zero members_count\\n\");\n\t\tgoto out;\n\t}\n\n\tcount = sp->members_count;\n\n\tnodes = kcalloc(count, sizeof(struct dlm_config_node), GFP_NOFS);\n\tif (!nodes) {\n\t\trv = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tnode = nodes;\n\tlist_for_each_entry(nd, &sp->members, list) {\n\t\tnode->nodeid = nd->nodeid;\n\t\tnode->weight = nd->weight;\n\t\tnode->new = nd->new;\n\t\tnode->comm_seq = nd->comm_seq;\n\t\tnode++;\n\n\t\tnd->new = 0;\n\t}\n\n\t*count_out = count;\n\t*nodes_out = nodes;\n\trv = 0;\n out:\n\tmutex_unlock(&sp->members_lock);\n\tput_space(sp);\n\treturn rv;\n}",
          "includes": [
            "#include \"lowcomms.h\"",
            "#include \"config.h\"",
            "#include <net/sock.h>",
            "#include <net/ipv6.h>",
            "#include <linux/dlmconstants.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/slab.h>",
            "#include <linux/configfs.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lowcomms.h\"\n#include \"config.h\"\n#include <net/sock.h>\n#include <net/ipv6.h>\n#include <linux/dlmconstants.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/slab.h>\n#include <linux/configfs.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nint dlm_config_nodes(char *lsname, struct dlm_config_node **nodes_out,\n\t\t     int *count_out)\n{\n\tstruct dlm_space *sp;\n\tstruct dlm_node *nd;\n\tstruct dlm_config_node *nodes, *node;\n\tint rv, count;\n\n\tsp = get_space(lsname);\n\tif (!sp)\n\t\treturn -EEXIST;\n\n\tmutex_lock(&sp->members_lock);\n\tif (!sp->members_count) {\n\t\trv = -EINVAL;\n\t\tprintk(KERN_ERR \"dlm: zero members_count\\n\");\n\t\tgoto out;\n\t}\n\n\tcount = sp->members_count;\n\n\tnodes = kcalloc(count, sizeof(struct dlm_config_node), GFP_NOFS);\n\tif (!nodes) {\n\t\trv = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tnode = nodes;\n\tlist_for_each_entry(nd, &sp->members, list) {\n\t\tnode->nodeid = nd->nodeid;\n\t\tnode->weight = nd->weight;\n\t\tnode->new = nd->new;\n\t\tnode->comm_seq = nd->comm_seq;\n\t\tnode++;\n\n\t\tnd->new = 0;\n\t}\n\n\t*count_out = count;\n\t*nodes_out = nodes;\n\trv = 0;\n out:\n\tmutex_unlock(&sp->members_lock);\n\tput_space(sp);\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct dlm_recover)",
            "GFP_NOFS"
          ],
          "line": 680
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"lowcomms.h\"\n#include \"config.h\"\n#include \"rcom.h\"\n#include \"recover.h\"\n#include \"recoverd.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nint dlm_ls_start(struct dlm_ls *ls)\n{\n\tstruct dlm_recover *rv = NULL, *rv_old;\n\tstruct dlm_config_node *nodes;\n\tint error, count;\n\n\trv = kzalloc(sizeof(struct dlm_recover), GFP_NOFS);\n\tif (!rv)\n\t\treturn -ENOMEM;\n\n\terror = dlm_config_nodes(ls->ls_name, &nodes, &count);\n\tif (error < 0)\n\t\tgoto fail;\n\n\tspin_lock(&ls->ls_recover_lock);\n\n\t/* the lockspace needs to be stopped before it can be started */\n\n\tif (!dlm_locking_stopped(ls)) {\n\t\tspin_unlock(&ls->ls_recover_lock);\n\t\tlog_error(ls, \"start ignored: lockspace running\");\n\t\terror = -EINVAL;\n\t\tgoto fail;\n\t}\n\n\trv->nodes = nodes;\n\trv->nodes_count = count;\n\trv->seq = ++ls->ls_recover_seq;\n\trv_old = ls->ls_recover_args;\n\tls->ls_recover_args = rv;\n\tspin_unlock(&ls->ls_recover_lock);\n\n\tif (rv_old) {\n\t\tlog_error(ls, \"unused recovery %llx %d\",\n\t\t\t  (unsigned long long)rv_old->seq, rv_old->nodes_count);\n\t\tkfree(rv_old->nodes);\n\t\tkfree(rv_old);\n\t}\n\n\tset_bit(LSFL_RECOVER_WORK, &ls->ls_flags);\n\twake_up_process(ls->ls_recoverd_task);\n\treturn 0;\n\n fail:\n\tkfree(rv);\n\tkfree(nodes);\n\treturn error;\n}"
  },
  {
    "function_name": "dlm_ls_stop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/member.c",
    "lines": "598-672",
    "snippet": "int dlm_ls_stop(struct dlm_ls *ls)\n{\n\tint new;\n\n\t/*\n\t * Prevent dlm_recv from being in the middle of something when we do\n\t * the stop.  This includes ensuring dlm_recv isn't processing a\n\t * recovery message (rcom), while dlm_recoverd is aborting and\n\t * resetting things from an in-progress recovery.  i.e. we want\n\t * dlm_recoverd to abort its recovery without worrying about dlm_recv\n\t * processing an rcom at the same time.  Stopping dlm_recv also makes\n\t * it easy for dlm_receive_message() to check locking stopped and add a\n\t * message to the requestqueue without races.\n\t */\n\n\tdown_write(&ls->ls_recv_active);\n\n\t/*\n\t * Abort any recovery that's in progress (see RECOVER_STOP,\n\t * dlm_recovery_stopped()) and tell any other threads running in the\n\t * dlm to quit any processing (see RUNNING, dlm_locking_stopped()).\n\t */\n\n\tspin_lock(&ls->ls_recover_lock);\n\tset_bit(LSFL_RECOVER_STOP, &ls->ls_flags);\n\tnew = test_and_clear_bit(LSFL_RUNNING, &ls->ls_flags);\n\tls->ls_recover_seq++;\n\tspin_unlock(&ls->ls_recover_lock);\n\n\t/*\n\t * Let dlm_recv run again, now any normal messages will be saved on the\n\t * requestqueue for later.\n\t */\n\n\tup_write(&ls->ls_recv_active);\n\n\t/*\n\t * This in_recovery lock does two things:\n\t * 1) Keeps this function from returning until all threads are out\n\t *    of locking routines and locking is truly stopped.\n\t * 2) Keeps any new requests from being processed until it's unlocked\n\t *    when recovery is complete.\n\t */\n\n\tif (new) {\n\t\tset_bit(LSFL_RECOVER_DOWN, &ls->ls_flags);\n\t\twake_up_process(ls->ls_recoverd_task);\n\t\twait_event(ls->ls_recover_lock_wait,\n\t\t\t   test_bit(LSFL_RECOVER_LOCK, &ls->ls_flags));\n\t}\n\n\t/*\n\t * The recoverd suspend/resume makes sure that dlm_recoverd (if\n\t * running) has noticed RECOVER_STOP above and quit processing the\n\t * previous recovery.\n\t */\n\n\tdlm_recoverd_suspend(ls);\n\n\tspin_lock(&ls->ls_recover_lock);\n\tkfree(ls->ls_slots);\n\tls->ls_slots = NULL;\n\tls->ls_num_slots = 0;\n\tls->ls_slots_size = 0;\n\tls->ls_recover_status = 0;\n\tspin_unlock(&ls->ls_recover_lock);\n\n\tdlm_recoverd_resume(ls);\n\n\tif (!ls->ls_recover_begin)\n\t\tls->ls_recover_begin = jiffies;\n\n\tdlm_lsop_recover_prep(ls);\n\treturn 0;\n}",
    "includes": [
      "#include \"lowcomms.h\"",
      "#include \"config.h\"",
      "#include \"rcom.h\"",
      "#include \"recover.h\"",
      "#include \"recoverd.h\"",
      "#include \"member.h\"",
      "#include \"lockspace.h\"",
      "#include \"dlm_internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dlm_lsop_recover_prep",
          "args": [
            "ls"
          ],
          "line": 670
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_lsop_recover_prep",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/member.c",
          "lines": "452-457",
          "snippet": "static void dlm_lsop_recover_prep(struct dlm_ls *ls)\n{\n\tif (!ls->ls_ops || !ls->ls_ops->recover_prep)\n\t\treturn;\n\tls->ls_ops->recover_prep(ls->ls_ops_arg);\n}",
          "includes": [
            "#include \"lowcomms.h\"",
            "#include \"config.h\"",
            "#include \"rcom.h\"",
            "#include \"recover.h\"",
            "#include \"recoverd.h\"",
            "#include \"member.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lowcomms.h\"\n#include \"config.h\"\n#include \"rcom.h\"\n#include \"recover.h\"\n#include \"recoverd.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic void dlm_lsop_recover_prep(struct dlm_ls *ls)\n{\n\tif (!ls->ls_ops || !ls->ls_ops->recover_prep)\n\t\treturn;\n\tls->ls_ops->recover_prep(ls->ls_ops_arg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_recoverd_resume",
          "args": [
            "ls"
          ],
          "line": 665
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_recoverd_resume",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/recoverd.c",
          "lines": "338-341",
          "snippet": "void dlm_recoverd_resume(struct dlm_ls *ls)\n{\n\tmutex_unlock(&ls->ls_recoverd_active);\n}",
          "includes": [
            "#include \"recoverd.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lock.h\"",
            "#include \"lowcomms.h\"",
            "#include \"recover.h\"",
            "#include \"ast.h\"",
            "#include \"dir.h\"",
            "#include \"member.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"recoverd.h\"\n#include \"requestqueue.h\"\n#include \"lock.h\"\n#include \"lowcomms.h\"\n#include \"recover.h\"\n#include \"ast.h\"\n#include \"dir.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nvoid dlm_recoverd_resume(struct dlm_ls *ls)\n{\n\tmutex_unlock(&ls->ls_recoverd_active);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ls->ls_recover_lock"
          ],
          "line": 663
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ls->ls_slots"
          ],
          "line": 658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ls->ls_recover_lock"
          ],
          "line": 657
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_recoverd_suspend",
          "args": [
            "ls"
          ],
          "line": 655
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_recoverd_suspend",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/recoverd.c",
          "lines": "332-336",
          "snippet": "void dlm_recoverd_suspend(struct dlm_ls *ls)\n{\n\twake_up(&ls->ls_wait_general);\n\tmutex_lock(&ls->ls_recoverd_active);\n}",
          "includes": [
            "#include \"recoverd.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lock.h\"",
            "#include \"lowcomms.h\"",
            "#include \"recover.h\"",
            "#include \"ast.h\"",
            "#include \"dir.h\"",
            "#include \"member.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"recoverd.h\"\n#include \"requestqueue.h\"\n#include \"lock.h\"\n#include \"lowcomms.h\"\n#include \"recover.h\"\n#include \"ast.h\"\n#include \"dir.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nvoid dlm_recoverd_suspend(struct dlm_ls *ls)\n{\n\twake_up(&ls->ls_wait_general);\n\tmutex_lock(&ls->ls_recoverd_active);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_event",
          "args": [
            "ls->ls_recover_lock_wait",
            "test_bit(LSFL_RECOVER_LOCK, &ls->ls_flags)"
          ],
          "line": 645
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "LSFL_RECOVER_LOCK",
            "&ls->ls_flags"
          ],
          "line": 646
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wake_up_process",
          "args": [
            "ls->ls_recoverd_task"
          ],
          "line": 644
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "LSFL_RECOVER_DOWN",
            "&ls->ls_flags"
          ],
          "line": 643
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&ls->ls_recv_active"
          ],
          "line": 632
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_and_clear_bit",
          "args": [
            "LSFL_RUNNING",
            "&ls->ls_flags"
          ],
          "line": 623
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_test_and_clear_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1129-1139",
          "snippet": "static inline int f2fs_test_and_clear_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr &= ~mask;\n\treturn ret;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int f2fs_test_and_clear_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr &= ~mask;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&ls->ls_recv_active"
          ],
          "line": 613
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"lowcomms.h\"\n#include \"config.h\"\n#include \"rcom.h\"\n#include \"recover.h\"\n#include \"recoverd.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nint dlm_ls_stop(struct dlm_ls *ls)\n{\n\tint new;\n\n\t/*\n\t * Prevent dlm_recv from being in the middle of something when we do\n\t * the stop.  This includes ensuring dlm_recv isn't processing a\n\t * recovery message (rcom), while dlm_recoverd is aborting and\n\t * resetting things from an in-progress recovery.  i.e. we want\n\t * dlm_recoverd to abort its recovery without worrying about dlm_recv\n\t * processing an rcom at the same time.  Stopping dlm_recv also makes\n\t * it easy for dlm_receive_message() to check locking stopped and add a\n\t * message to the requestqueue without races.\n\t */\n\n\tdown_write(&ls->ls_recv_active);\n\n\t/*\n\t * Abort any recovery that's in progress (see RECOVER_STOP,\n\t * dlm_recovery_stopped()) and tell any other threads running in the\n\t * dlm to quit any processing (see RUNNING, dlm_locking_stopped()).\n\t */\n\n\tspin_lock(&ls->ls_recover_lock);\n\tset_bit(LSFL_RECOVER_STOP, &ls->ls_flags);\n\tnew = test_and_clear_bit(LSFL_RUNNING, &ls->ls_flags);\n\tls->ls_recover_seq++;\n\tspin_unlock(&ls->ls_recover_lock);\n\n\t/*\n\t * Let dlm_recv run again, now any normal messages will be saved on the\n\t * requestqueue for later.\n\t */\n\n\tup_write(&ls->ls_recv_active);\n\n\t/*\n\t * This in_recovery lock does two things:\n\t * 1) Keeps this function from returning until all threads are out\n\t *    of locking routines and locking is truly stopped.\n\t * 2) Keeps any new requests from being processed until it's unlocked\n\t *    when recovery is complete.\n\t */\n\n\tif (new) {\n\t\tset_bit(LSFL_RECOVER_DOWN, &ls->ls_flags);\n\t\twake_up_process(ls->ls_recoverd_task);\n\t\twait_event(ls->ls_recover_lock_wait,\n\t\t\t   test_bit(LSFL_RECOVER_LOCK, &ls->ls_flags));\n\t}\n\n\t/*\n\t * The recoverd suspend/resume makes sure that dlm_recoverd (if\n\t * running) has noticed RECOVER_STOP above and quit processing the\n\t * previous recovery.\n\t */\n\n\tdlm_recoverd_suspend(ls);\n\n\tspin_lock(&ls->ls_recover_lock);\n\tkfree(ls->ls_slots);\n\tls->ls_slots = NULL;\n\tls->ls_num_slots = 0;\n\tls->ls_slots_size = 0;\n\tls->ls_recover_status = 0;\n\tspin_unlock(&ls->ls_recover_lock);\n\n\tdlm_recoverd_resume(ls);\n\n\tif (!ls->ls_recover_begin)\n\t\tls->ls_recover_begin = jiffies;\n\n\tdlm_lsop_recover_prep(ls);\n\treturn 0;\n}"
  },
  {
    "function_name": "dlm_recover_members",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/member.c",
    "lines": "529-593",
    "snippet": "int dlm_recover_members(struct dlm_ls *ls, struct dlm_recover *rv, int *neg_out)\n{\n\tstruct dlm_member *memb, *safe;\n\tstruct dlm_config_node *node;\n\tint i, error, neg = 0, low = -1;\n\n\t/* previously removed members that we've not finished removing need to\n\t   count as a negative change so the \"neg\" recovery steps will happen */\n\n\tlist_for_each_entry(memb, &ls->ls_nodes_gone, list) {\n\t\tlog_rinfo(ls, \"prev removed member %d\", memb->nodeid);\n\t\tneg++;\n\t}\n\n\t/* move departed members from ls_nodes to ls_nodes_gone */\n\n\tlist_for_each_entry_safe(memb, safe, &ls->ls_nodes, list) {\n\t\tnode = find_config_node(rv, memb->nodeid);\n\t\tif (node && !node->new)\n\t\t\tcontinue;\n\n\t\tif (!node) {\n\t\t\tlog_rinfo(ls, \"remove member %d\", memb->nodeid);\n\t\t} else {\n\t\t\t/* removed and re-added */\n\t\t\tlog_rinfo(ls, \"remove member %d comm_seq %u %u\",\n\t\t\t\t  memb->nodeid, memb->comm_seq, node->comm_seq);\n\t\t}\n\n\t\tneg++;\n\t\tlist_move(&memb->list, &ls->ls_nodes_gone);\n\t\tls->ls_num_nodes--;\n\t\tdlm_lsop_recover_slot(ls, memb);\n\t}\n\n\t/* add new members to ls_nodes */\n\n\tfor (i = 0; i < rv->nodes_count; i++) {\n\t\tnode = &rv->nodes[i];\n\t\tif (dlm_is_member(ls, node->nodeid))\n\t\t\tcontinue;\n\t\tdlm_add_member(ls, node);\n\t\tlog_rinfo(ls, \"add member %d\", node->nodeid);\n\t}\n\n\tlist_for_each_entry(memb, &ls->ls_nodes, list) {\n\t\tif (low == -1 || memb->nodeid < low)\n\t\t\tlow = memb->nodeid;\n\t}\n\tls->ls_low_nodeid = low;\n\n\tmake_member_array(ls);\n\t*neg_out = neg;\n\n\terror = ping_members(ls);\n\tif (!error || error == -EPROTO) {\n\t\t/* new_lockspace() may be waiting to know if the config\n\t\t   is good or bad */\n\t\tls->ls_members_result = error;\n\t\tcomplete(&ls->ls_members_done);\n\t}\n\n\tlog_rinfo(ls, \"dlm_recover_members %d nodes\", ls->ls_num_nodes);\n\treturn error;\n}",
    "includes": [
      "#include \"lowcomms.h\"",
      "#include \"config.h\"",
      "#include \"rcom.h\"",
      "#include \"recover.h\"",
      "#include \"recoverd.h\"",
      "#include \"member.h\"",
      "#include \"lockspace.h\"",
      "#include \"dlm_internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "log_rinfo",
          "args": [
            "ls",
            "\"dlm_recover_members %d nodes\"",
            "ls->ls_num_nodes"
          ],
          "line": 591
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "complete",
          "args": [
            "&ls->ls_members_done"
          ],
          "line": 588
        },
        "resolved": true,
        "details": {
          "function_name": "dio_aio_complete_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/direct-io.c",
          "lines": "275-280",
          "snippet": "static void dio_aio_complete_work(struct work_struct *work)\n{\n\tstruct dio *dio = container_of(work, struct dio, complete_work);\n\n\tdio_complete(dio, dio->iocb->ki_pos, 0, true);\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/atomic.h>",
            "#include <linux/uio.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/err.h>",
            "#include <linux/wait.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/prefetch.h>\n#include <linux/atomic.h>\n#include <linux/uio.h>\n#include <linux/rwsem.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/err.h>\n#include <linux/wait.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/types.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic void dio_aio_complete_work(struct work_struct *work)\n{\n\tstruct dio *dio = container_of(work, struct dio, complete_work);\n\n\tdio_complete(dio, dio->iocb->ki_pos, 0, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ping_members",
          "args": [
            "ls"
          ],
          "line": 583
        },
        "resolved": true,
        "details": {
          "function_name": "ping_members",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/member.c",
          "lines": "433-450",
          "snippet": "static int ping_members(struct dlm_ls *ls)\n{\n\tstruct dlm_member *memb;\n\tint error = 0;\n\n\tlist_for_each_entry(memb, &ls->ls_nodes, list) {\n\t\terror = dlm_recovery_stopped(ls);\n\t\tif (error)\n\t\t\tbreak;\n\t\terror = dlm_rcom_status(ls, memb->nodeid, 0);\n\t\tif (error)\n\t\t\tbreak;\n\t}\n\tif (error)\n\t\tlog_rinfo(ls, \"ping_members aborted %d last nodeid %d\",\n\t\t\t  error, ls->ls_recover_nodeid);\n\treturn error;\n}",
          "includes": [
            "#include \"lowcomms.h\"",
            "#include \"config.h\"",
            "#include \"rcom.h\"",
            "#include \"recover.h\"",
            "#include \"recoverd.h\"",
            "#include \"member.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lowcomms.h\"\n#include \"config.h\"\n#include \"rcom.h\"\n#include \"recover.h\"\n#include \"recoverd.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic int ping_members(struct dlm_ls *ls)\n{\n\tstruct dlm_member *memb;\n\tint error = 0;\n\n\tlist_for_each_entry(memb, &ls->ls_nodes, list) {\n\t\terror = dlm_recovery_stopped(ls);\n\t\tif (error)\n\t\t\tbreak;\n\t\terror = dlm_rcom_status(ls, memb->nodeid, 0);\n\t\tif (error)\n\t\t\tbreak;\n\t}\n\tif (error)\n\t\tlog_rinfo(ls, \"ping_members aborted %d last nodeid %d\",\n\t\t\t  error, ls->ls_recover_nodeid);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "make_member_array",
          "args": [
            "ls"
          ],
          "line": 580
        },
        "resolved": true,
        "details": {
          "function_name": "make_member_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/member.c",
          "lines": "387-429",
          "snippet": "static void make_member_array(struct dlm_ls *ls)\n{\n\tstruct dlm_member *memb;\n\tint i, w, x = 0, total = 0, all_zero = 0, *array;\n\n\tkfree(ls->ls_node_array);\n\tls->ls_node_array = NULL;\n\n\tlist_for_each_entry(memb, &ls->ls_nodes, list) {\n\t\tif (memb->weight)\n\t\t\ttotal += memb->weight;\n\t}\n\n\t/* all nodes revert to weight of 1 if all have weight 0 */\n\n\tif (!total) {\n\t\ttotal = ls->ls_num_nodes;\n\t\tall_zero = 1;\n\t}\n\n\tls->ls_total_weight = total;\n\n\tarray = kmalloc(sizeof(int) * total, GFP_NOFS);\n\tif (!array)\n\t\treturn;\n\n\tlist_for_each_entry(memb, &ls->ls_nodes, list) {\n\t\tif (!all_zero && !memb->weight)\n\t\t\tcontinue;\n\n\t\tif (all_zero)\n\t\t\tw = 1;\n\t\telse\n\t\t\tw = memb->weight;\n\n\t\tDLM_ASSERT(x < total, printk(\"total %d x %d\\n\", total, x););\n\n\t\tfor (i = 0; i < w; i++)\n\t\t\tarray[x++] = memb->nodeid;\n\t}\n\n\tls->ls_node_array = array;\n}",
          "includes": [
            "#include \"lowcomms.h\"",
            "#include \"config.h\"",
            "#include \"rcom.h\"",
            "#include \"recover.h\"",
            "#include \"recoverd.h\"",
            "#include \"member.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lowcomms.h\"\n#include \"config.h\"\n#include \"rcom.h\"\n#include \"recover.h\"\n#include \"recoverd.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic void make_member_array(struct dlm_ls *ls)\n{\n\tstruct dlm_member *memb;\n\tint i, w, x = 0, total = 0, all_zero = 0, *array;\n\n\tkfree(ls->ls_node_array);\n\tls->ls_node_array = NULL;\n\n\tlist_for_each_entry(memb, &ls->ls_nodes, list) {\n\t\tif (memb->weight)\n\t\t\ttotal += memb->weight;\n\t}\n\n\t/* all nodes revert to weight of 1 if all have weight 0 */\n\n\tif (!total) {\n\t\ttotal = ls->ls_num_nodes;\n\t\tall_zero = 1;\n\t}\n\n\tls->ls_total_weight = total;\n\n\tarray = kmalloc(sizeof(int) * total, GFP_NOFS);\n\tif (!array)\n\t\treturn;\n\n\tlist_for_each_entry(memb, &ls->ls_nodes, list) {\n\t\tif (!all_zero && !memb->weight)\n\t\t\tcontinue;\n\n\t\tif (all_zero)\n\t\t\tw = 1;\n\t\telse\n\t\t\tw = memb->weight;\n\n\t\tDLM_ASSERT(x < total, printk(\"total %d x %d\\n\", total, x););\n\n\t\tfor (i = 0; i < w; i++)\n\t\t\tarray[x++] = memb->nodeid;\n\t}\n\n\tls->ls_node_array = array;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "memb",
            "&ls->ls_nodes",
            "list"
          ],
          "line": 574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "log_rinfo",
          "args": [
            "ls",
            "\"add member %d\"",
            "node->nodeid"
          ],
          "line": 571
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_add_member",
          "args": [
            "ls",
            "node"
          ],
          "line": 570
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_add_member",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/member.c",
          "lines": "317-338",
          "snippet": "static int dlm_add_member(struct dlm_ls *ls, struct dlm_config_node *node)\n{\n\tstruct dlm_member *memb;\n\tint error;\n\n\tmemb = kzalloc(sizeof(struct dlm_member), GFP_NOFS);\n\tif (!memb)\n\t\treturn -ENOMEM;\n\n\terror = dlm_lowcomms_connect_node(node->nodeid);\n\tif (error < 0) {\n\t\tkfree(memb);\n\t\treturn error;\n\t}\n\n\tmemb->nodeid = node->nodeid;\n\tmemb->weight = node->weight;\n\tmemb->comm_seq = node->comm_seq;\n\tadd_ordered_member(ls, memb);\n\tls->ls_num_nodes++;\n\treturn 0;\n}",
          "includes": [
            "#include \"lowcomms.h\"",
            "#include \"config.h\"",
            "#include \"rcom.h\"",
            "#include \"recover.h\"",
            "#include \"recoverd.h\"",
            "#include \"member.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lowcomms.h\"\n#include \"config.h\"\n#include \"rcom.h\"\n#include \"recover.h\"\n#include \"recoverd.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic int dlm_add_member(struct dlm_ls *ls, struct dlm_config_node *node)\n{\n\tstruct dlm_member *memb;\n\tint error;\n\n\tmemb = kzalloc(sizeof(struct dlm_member), GFP_NOFS);\n\tif (!memb)\n\t\treturn -ENOMEM;\n\n\terror = dlm_lowcomms_connect_node(node->nodeid);\n\tif (error < 0) {\n\t\tkfree(memb);\n\t\treturn error;\n\t}\n\n\tmemb->nodeid = node->nodeid;\n\tmemb->weight = node->weight;\n\tmemb->comm_seq = node->comm_seq;\n\tadd_ordered_member(ls, memb);\n\tls->ls_num_nodes++;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_is_member",
          "args": [
            "ls",
            "node->nodeid"
          ],
          "line": 568
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_is_member",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/member.c",
          "lines": "351-356",
          "snippet": "int dlm_is_member(struct dlm_ls *ls, int nodeid)\n{\n\tif (find_memb(&ls->ls_nodes, nodeid))\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include \"lowcomms.h\"",
            "#include \"config.h\"",
            "#include \"rcom.h\"",
            "#include \"recover.h\"",
            "#include \"recoverd.h\"",
            "#include \"member.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lowcomms.h\"\n#include \"config.h\"\n#include \"rcom.h\"\n#include \"recover.h\"\n#include \"recoverd.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nint dlm_is_member(struct dlm_ls *ls, int nodeid)\n{\n\tif (find_memb(&ls->ls_nodes, nodeid))\n\t\treturn 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_lsop_recover_slot",
          "args": [
            "ls",
            "memb"
          ],
          "line": 561
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_lsop_recover_slot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/member.c",
          "lines": "459-483",
          "snippet": "static void dlm_lsop_recover_slot(struct dlm_ls *ls, struct dlm_member *memb)\n{\n\tstruct dlm_slot slot;\n\tuint32_t seq;\n\tint error;\n\n\tif (!ls->ls_ops || !ls->ls_ops->recover_slot)\n\t\treturn;\n\n\t/* if there is no comms connection with this node\n\t   or the present comms connection is newer\n\t   than the one when this member was added, then\n\t   we consider the node to have failed (versus\n\t   being removed due to dlm_release_lockspace) */\n\n\terror = dlm_comm_seq(memb->nodeid, &seq);\n\n\tif (!error && seq == memb->comm_seq)\n\t\treturn;\n\n\tslot.nodeid = memb->nodeid;\n\tslot.slot = memb->slot;\n\n\tls->ls_ops->recover_slot(ls->ls_ops_arg, &slot);\n}",
          "includes": [
            "#include \"lowcomms.h\"",
            "#include \"config.h\"",
            "#include \"rcom.h\"",
            "#include \"recover.h\"",
            "#include \"recoverd.h\"",
            "#include \"member.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lowcomms.h\"\n#include \"config.h\"\n#include \"rcom.h\"\n#include \"recover.h\"\n#include \"recoverd.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic void dlm_lsop_recover_slot(struct dlm_ls *ls, struct dlm_member *memb)\n{\n\tstruct dlm_slot slot;\n\tuint32_t seq;\n\tint error;\n\n\tif (!ls->ls_ops || !ls->ls_ops->recover_slot)\n\t\treturn;\n\n\t/* if there is no comms connection with this node\n\t   or the present comms connection is newer\n\t   than the one when this member was added, then\n\t   we consider the node to have failed (versus\n\t   being removed due to dlm_release_lockspace) */\n\n\terror = dlm_comm_seq(memb->nodeid, &seq);\n\n\tif (!error && seq == memb->comm_seq)\n\t\treturn;\n\n\tslot.nodeid = memb->nodeid;\n\tslot.slot = memb->slot;\n\n\tls->ls_ops->recover_slot(ls->ls_ops_arg, &slot);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_move",
          "args": [
            "&memb->list",
            "&ls->ls_nodes_gone"
          ],
          "line": 559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "log_rinfo",
          "args": [
            "ls",
            "\"remove member %d comm_seq %u %u\"",
            "memb->nodeid",
            "memb->comm_seq",
            "node->comm_seq"
          ],
          "line": 554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "log_rinfo",
          "args": [
            "ls",
            "\"remove member %d\"",
            "memb->nodeid"
          ],
          "line": 551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_config_node",
          "args": [
            "rv",
            "memb->nodeid"
          ],
          "line": 546
        },
        "resolved": true,
        "details": {
          "function_name": "find_config_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/member.c",
          "lines": "517-527",
          "snippet": "static struct dlm_config_node *find_config_node(struct dlm_recover *rv,\n\t\t\t\t\t\tint nodeid)\n{\n\tint i;\n\n\tfor (i = 0; i < rv->nodes_count; i++) {\n\t\tif (rv->nodes[i].nodeid == nodeid)\n\t\t\treturn &rv->nodes[i];\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"lowcomms.h\"",
            "#include \"config.h\"",
            "#include \"rcom.h\"",
            "#include \"recover.h\"",
            "#include \"recoverd.h\"",
            "#include \"member.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lowcomms.h\"\n#include \"config.h\"\n#include \"rcom.h\"\n#include \"recover.h\"\n#include \"recoverd.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic struct dlm_config_node *find_config_node(struct dlm_recover *rv,\n\t\t\t\t\t\tint nodeid)\n{\n\tint i;\n\n\tfor (i = 0; i < rv->nodes_count; i++) {\n\t\tif (rv->nodes[i].nodeid == nodeid)\n\t\t\treturn &rv->nodes[i];\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "memb",
            "safe",
            "&ls->ls_nodes",
            "list"
          ],
          "line": 545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "log_rinfo",
          "args": [
            "ls",
            "\"prev removed member %d\"",
            "memb->nodeid"
          ],
          "line": 539
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "memb",
            "&ls->ls_nodes_gone",
            "list"
          ],
          "line": 538
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"lowcomms.h\"\n#include \"config.h\"\n#include \"rcom.h\"\n#include \"recover.h\"\n#include \"recoverd.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nint dlm_recover_members(struct dlm_ls *ls, struct dlm_recover *rv, int *neg_out)\n{\n\tstruct dlm_member *memb, *safe;\n\tstruct dlm_config_node *node;\n\tint i, error, neg = 0, low = -1;\n\n\t/* previously removed members that we've not finished removing need to\n\t   count as a negative change so the \"neg\" recovery steps will happen */\n\n\tlist_for_each_entry(memb, &ls->ls_nodes_gone, list) {\n\t\tlog_rinfo(ls, \"prev removed member %d\", memb->nodeid);\n\t\tneg++;\n\t}\n\n\t/* move departed members from ls_nodes to ls_nodes_gone */\n\n\tlist_for_each_entry_safe(memb, safe, &ls->ls_nodes, list) {\n\t\tnode = find_config_node(rv, memb->nodeid);\n\t\tif (node && !node->new)\n\t\t\tcontinue;\n\n\t\tif (!node) {\n\t\t\tlog_rinfo(ls, \"remove member %d\", memb->nodeid);\n\t\t} else {\n\t\t\t/* removed and re-added */\n\t\t\tlog_rinfo(ls, \"remove member %d comm_seq %u %u\",\n\t\t\t\t  memb->nodeid, memb->comm_seq, node->comm_seq);\n\t\t}\n\n\t\tneg++;\n\t\tlist_move(&memb->list, &ls->ls_nodes_gone);\n\t\tls->ls_num_nodes--;\n\t\tdlm_lsop_recover_slot(ls, memb);\n\t}\n\n\t/* add new members to ls_nodes */\n\n\tfor (i = 0; i < rv->nodes_count; i++) {\n\t\tnode = &rv->nodes[i];\n\t\tif (dlm_is_member(ls, node->nodeid))\n\t\t\tcontinue;\n\t\tdlm_add_member(ls, node);\n\t\tlog_rinfo(ls, \"add member %d\", node->nodeid);\n\t}\n\n\tlist_for_each_entry(memb, &ls->ls_nodes, list) {\n\t\tif (low == -1 || memb->nodeid < low)\n\t\t\tlow = memb->nodeid;\n\t}\n\tls->ls_low_nodeid = low;\n\n\tmake_member_array(ls);\n\t*neg_out = neg;\n\n\terror = ping_members(ls);\n\tif (!error || error == -EPROTO) {\n\t\t/* new_lockspace() may be waiting to know if the config\n\t\t   is good or bad */\n\t\tls->ls_members_result = error;\n\t\tcomplete(&ls->ls_members_done);\n\t}\n\n\tlog_rinfo(ls, \"dlm_recover_members %d nodes\", ls->ls_num_nodes);\n\treturn error;\n}"
  },
  {
    "function_name": "find_config_node",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/member.c",
    "lines": "517-527",
    "snippet": "static struct dlm_config_node *find_config_node(struct dlm_recover *rv,\n\t\t\t\t\t\tint nodeid)\n{\n\tint i;\n\n\tfor (i = 0; i < rv->nodes_count; i++) {\n\t\tif (rv->nodes[i].nodeid == nodeid)\n\t\t\treturn &rv->nodes[i];\n\t}\n\treturn NULL;\n}",
    "includes": [
      "#include \"lowcomms.h\"",
      "#include \"config.h\"",
      "#include \"rcom.h\"",
      "#include \"recover.h\"",
      "#include \"recoverd.h\"",
      "#include \"member.h\"",
      "#include \"lockspace.h\"",
      "#include \"dlm_internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"lowcomms.h\"\n#include \"config.h\"\n#include \"rcom.h\"\n#include \"recover.h\"\n#include \"recoverd.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic struct dlm_config_node *find_config_node(struct dlm_recover *rv,\n\t\t\t\t\t\tint nodeid)\n{\n\tint i;\n\n\tfor (i = 0; i < rv->nodes_count; i++) {\n\t\tif (rv->nodes[i].nodeid == nodeid)\n\t\t\treturn &rv->nodes[i];\n\t}\n\treturn NULL;\n}"
  },
  {
    "function_name": "dlm_lsop_recover_done",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/member.c",
    "lines": "485-515",
    "snippet": "void dlm_lsop_recover_done(struct dlm_ls *ls)\n{\n\tstruct dlm_member *memb;\n\tstruct dlm_slot *slots;\n\tint i, num;\n\n\tif (!ls->ls_ops || !ls->ls_ops->recover_done)\n\t\treturn;\n\n\tnum = ls->ls_num_nodes;\n\n\tslots = kzalloc(num * sizeof(struct dlm_slot), GFP_KERNEL);\n\tif (!slots)\n\t\treturn;\n\n\ti = 0;\n\tlist_for_each_entry(memb, &ls->ls_nodes, list) {\n\t\tif (i == num) {\n\t\t\tlog_error(ls, \"dlm_lsop_recover_done bad num %d\", num);\n\t\t\tgoto out;\n\t\t}\n\t\tslots[i].nodeid = memb->nodeid;\n\t\tslots[i].slot = memb->slot;\n\t\ti++;\n\t}\n\n\tls->ls_ops->recover_done(ls->ls_ops_arg, slots, num,\n\t\t\t\t ls->ls_slot, ls->ls_generation);\n out:\n\tkfree(slots);\n}",
    "includes": [
      "#include \"lowcomms.h\"",
      "#include \"config.h\"",
      "#include \"rcom.h\"",
      "#include \"recover.h\"",
      "#include \"recoverd.h\"",
      "#include \"member.h\"",
      "#include \"lockspace.h\"",
      "#include \"dlm_internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "slots"
          ],
          "line": 514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ls->ls_ops->recover_done",
          "args": [
            "ls->ls_ops_arg",
            "slots",
            "num",
            "ls->ls_slot",
            "ls->ls_generation"
          ],
          "line": 511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "log_error",
          "args": [
            "ls",
            "\"dlm_lsop_recover_done bad num %d\"",
            "num"
          ],
          "line": 503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "memb",
            "&ls->ls_nodes",
            "list"
          ],
          "line": 501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "num * sizeof(struct dlm_slot)",
            "GFP_KERNEL"
          ],
          "line": 496
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"lowcomms.h\"\n#include \"config.h\"\n#include \"rcom.h\"\n#include \"recover.h\"\n#include \"recoverd.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nvoid dlm_lsop_recover_done(struct dlm_ls *ls)\n{\n\tstruct dlm_member *memb;\n\tstruct dlm_slot *slots;\n\tint i, num;\n\n\tif (!ls->ls_ops || !ls->ls_ops->recover_done)\n\t\treturn;\n\n\tnum = ls->ls_num_nodes;\n\n\tslots = kzalloc(num * sizeof(struct dlm_slot), GFP_KERNEL);\n\tif (!slots)\n\t\treturn;\n\n\ti = 0;\n\tlist_for_each_entry(memb, &ls->ls_nodes, list) {\n\t\tif (i == num) {\n\t\t\tlog_error(ls, \"dlm_lsop_recover_done bad num %d\", num);\n\t\t\tgoto out;\n\t\t}\n\t\tslots[i].nodeid = memb->nodeid;\n\t\tslots[i].slot = memb->slot;\n\t\ti++;\n\t}\n\n\tls->ls_ops->recover_done(ls->ls_ops_arg, slots, num,\n\t\t\t\t ls->ls_slot, ls->ls_generation);\n out:\n\tkfree(slots);\n}"
  },
  {
    "function_name": "dlm_lsop_recover_slot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/member.c",
    "lines": "459-483",
    "snippet": "static void dlm_lsop_recover_slot(struct dlm_ls *ls, struct dlm_member *memb)\n{\n\tstruct dlm_slot slot;\n\tuint32_t seq;\n\tint error;\n\n\tif (!ls->ls_ops || !ls->ls_ops->recover_slot)\n\t\treturn;\n\n\t/* if there is no comms connection with this node\n\t   or the present comms connection is newer\n\t   than the one when this member was added, then\n\t   we consider the node to have failed (versus\n\t   being removed due to dlm_release_lockspace) */\n\n\terror = dlm_comm_seq(memb->nodeid, &seq);\n\n\tif (!error && seq == memb->comm_seq)\n\t\treturn;\n\n\tslot.nodeid = memb->nodeid;\n\tslot.slot = memb->slot;\n\n\tls->ls_ops->recover_slot(ls->ls_ops_arg, &slot);\n}",
    "includes": [
      "#include \"lowcomms.h\"",
      "#include \"config.h\"",
      "#include \"rcom.h\"",
      "#include \"recover.h\"",
      "#include \"recoverd.h\"",
      "#include \"member.h\"",
      "#include \"lockspace.h\"",
      "#include \"dlm_internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ls->ls_ops->recover_slot",
          "args": [
            "ls->ls_ops_arg",
            "&slot"
          ],
          "line": 482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_comm_seq",
          "args": [
            "memb->nodeid",
            "&seq"
          ],
          "line": 474
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_comm_seq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/config.c",
          "lines": "984-992",
          "snippet": "int dlm_comm_seq(int nodeid, uint32_t *seq)\n{\n\tstruct dlm_comm *cm = get_comm(nodeid);\n\tif (!cm)\n\t\treturn -EEXIST;\n\t*seq = cm->seq;\n\tput_comm(cm);\n\treturn 0;\n}",
          "includes": [
            "#include \"lowcomms.h\"",
            "#include \"config.h\"",
            "#include <net/sock.h>",
            "#include <net/ipv6.h>",
            "#include <linux/dlmconstants.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/slab.h>",
            "#include <linux/configfs.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lowcomms.h\"\n#include \"config.h\"\n#include <net/sock.h>\n#include <net/ipv6.h>\n#include <linux/dlmconstants.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/slab.h>\n#include <linux/configfs.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nint dlm_comm_seq(int nodeid, uint32_t *seq)\n{\n\tstruct dlm_comm *cm = get_comm(nodeid);\n\tif (!cm)\n\t\treturn -EEXIST;\n\t*seq = cm->seq;\n\tput_comm(cm);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"lowcomms.h\"\n#include \"config.h\"\n#include \"rcom.h\"\n#include \"recover.h\"\n#include \"recoverd.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic void dlm_lsop_recover_slot(struct dlm_ls *ls, struct dlm_member *memb)\n{\n\tstruct dlm_slot slot;\n\tuint32_t seq;\n\tint error;\n\n\tif (!ls->ls_ops || !ls->ls_ops->recover_slot)\n\t\treturn;\n\n\t/* if there is no comms connection with this node\n\t   or the present comms connection is newer\n\t   than the one when this member was added, then\n\t   we consider the node to have failed (versus\n\t   being removed due to dlm_release_lockspace) */\n\n\terror = dlm_comm_seq(memb->nodeid, &seq);\n\n\tif (!error && seq == memb->comm_seq)\n\t\treturn;\n\n\tslot.nodeid = memb->nodeid;\n\tslot.slot = memb->slot;\n\n\tls->ls_ops->recover_slot(ls->ls_ops_arg, &slot);\n}"
  },
  {
    "function_name": "dlm_lsop_recover_prep",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/member.c",
    "lines": "452-457",
    "snippet": "static void dlm_lsop_recover_prep(struct dlm_ls *ls)\n{\n\tif (!ls->ls_ops || !ls->ls_ops->recover_prep)\n\t\treturn;\n\tls->ls_ops->recover_prep(ls->ls_ops_arg);\n}",
    "includes": [
      "#include \"lowcomms.h\"",
      "#include \"config.h\"",
      "#include \"rcom.h\"",
      "#include \"recover.h\"",
      "#include \"recoverd.h\"",
      "#include \"member.h\"",
      "#include \"lockspace.h\"",
      "#include \"dlm_internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ls->ls_ops->recover_prep",
          "args": [
            "ls->ls_ops_arg"
          ],
          "line": 456
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"lowcomms.h\"\n#include \"config.h\"\n#include \"rcom.h\"\n#include \"recover.h\"\n#include \"recoverd.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic void dlm_lsop_recover_prep(struct dlm_ls *ls)\n{\n\tif (!ls->ls_ops || !ls->ls_ops->recover_prep)\n\t\treturn;\n\tls->ls_ops->recover_prep(ls->ls_ops_arg);\n}"
  },
  {
    "function_name": "ping_members",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/member.c",
    "lines": "433-450",
    "snippet": "static int ping_members(struct dlm_ls *ls)\n{\n\tstruct dlm_member *memb;\n\tint error = 0;\n\n\tlist_for_each_entry(memb, &ls->ls_nodes, list) {\n\t\terror = dlm_recovery_stopped(ls);\n\t\tif (error)\n\t\t\tbreak;\n\t\terror = dlm_rcom_status(ls, memb->nodeid, 0);\n\t\tif (error)\n\t\t\tbreak;\n\t}\n\tif (error)\n\t\tlog_rinfo(ls, \"ping_members aborted %d last nodeid %d\",\n\t\t\t  error, ls->ls_recover_nodeid);\n\treturn error;\n}",
    "includes": [
      "#include \"lowcomms.h\"",
      "#include \"config.h\"",
      "#include \"rcom.h\"",
      "#include \"recover.h\"",
      "#include \"recoverd.h\"",
      "#include \"member.h\"",
      "#include \"lockspace.h\"",
      "#include \"dlm_internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "log_rinfo",
          "args": [
            "ls",
            "\"ping_members aborted %d last nodeid %d\"",
            "error",
            "ls->ls_recover_nodeid"
          ],
          "line": 447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_rcom_status",
          "args": [
            "ls",
            "memb->nodeid",
            "0"
          ],
          "line": 442
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_rcom_status",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/rcom.c",
          "lines": "144-189",
          "snippet": "int dlm_rcom_status(struct dlm_ls *ls, int nodeid, uint32_t status_flags)\n{\n\tstruct dlm_rcom *rc;\n\tstruct dlm_mhandle *mh;\n\tint error = 0;\n\n\tls->ls_recover_nodeid = nodeid;\n\n\tif (nodeid == dlm_our_nodeid()) {\n\t\trc = ls->ls_recover_buf;\n\t\trc->rc_result = dlm_recover_status(ls);\n\t\tgoto out;\n\t}\n\n\terror = create_rcom(ls, nodeid, DLM_RCOM_STATUS,\n\t\t\t    sizeof(struct rcom_status), &rc, &mh);\n\tif (error)\n\t\tgoto out;\n\n\tset_rcom_status(ls, (struct rcom_status *)rc->rc_buf, status_flags);\n\n\tallow_sync_reply(ls, &rc->rc_id);\n\tmemset(ls->ls_recover_buf, 0, dlm_config.ci_buffer_size);\n\n\tsend_rcom(ls, mh, rc);\n\n\terror = dlm_wait_function(ls, &rcom_response);\n\tdisallow_sync_reply(ls);\n\tif (error)\n\t\tgoto out;\n\n\trc = ls->ls_recover_buf;\n\n\tif (rc->rc_result == -ESRCH) {\n\t\t/* we pretend the remote lockspace exists with 0 status */\n\t\tlog_debug(ls, \"remote node %d not ready\", nodeid);\n\t\trc->rc_result = 0;\n\t\terror = 0;\n\t} else {\n\t\terror = check_rcom_config(ls, rc, nodeid);\n\t}\n\n\t/* the caller looks at rc_result for the remote recovery status */\n out:\n\treturn error;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"lock.h\"",
            "#include \"memory.h\"",
            "#include \"config.h\"",
            "#include \"dir.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"midcomms.h\"",
            "#include \"lowcomms.h\"",
            "#include \"member.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"lock.h\"\n#include \"memory.h\"\n#include \"config.h\"\n#include \"dir.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"midcomms.h\"\n#include \"lowcomms.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nint dlm_rcom_status(struct dlm_ls *ls, int nodeid, uint32_t status_flags)\n{\n\tstruct dlm_rcom *rc;\n\tstruct dlm_mhandle *mh;\n\tint error = 0;\n\n\tls->ls_recover_nodeid = nodeid;\n\n\tif (nodeid == dlm_our_nodeid()) {\n\t\trc = ls->ls_recover_buf;\n\t\trc->rc_result = dlm_recover_status(ls);\n\t\tgoto out;\n\t}\n\n\terror = create_rcom(ls, nodeid, DLM_RCOM_STATUS,\n\t\t\t    sizeof(struct rcom_status), &rc, &mh);\n\tif (error)\n\t\tgoto out;\n\n\tset_rcom_status(ls, (struct rcom_status *)rc->rc_buf, status_flags);\n\n\tallow_sync_reply(ls, &rc->rc_id);\n\tmemset(ls->ls_recover_buf, 0, dlm_config.ci_buffer_size);\n\n\tsend_rcom(ls, mh, rc);\n\n\terror = dlm_wait_function(ls, &rcom_response);\n\tdisallow_sync_reply(ls);\n\tif (error)\n\t\tgoto out;\n\n\trc = ls->ls_recover_buf;\n\n\tif (rc->rc_result == -ESRCH) {\n\t\t/* we pretend the remote lockspace exists with 0 status */\n\t\tlog_debug(ls, \"remote node %d not ready\", nodeid);\n\t\trc->rc_result = 0;\n\t\terror = 0;\n\t} else {\n\t\terror = check_rcom_config(ls, rc, nodeid);\n\t}\n\n\t/* the caller looks at rc_result for the remote recovery status */\n out:\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_recovery_stopped",
          "args": [
            "ls"
          ],
          "line": 439
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_recovery_stopped",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/dlm_internal.h",
          "lines": "700-703",
          "snippet": "static inline int dlm_recovery_stopped(struct dlm_ls *ls)\n{\n\treturn test_bit(LSFL_RECOVER_STOP, &ls->ls_flags);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include <linux/dlm.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/idr.h>",
            "#include <linux/mutex.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/jhash.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kref.h>",
            "#include <linux/kobject.h>",
            "#include <linux/kthread.h>",
            "#include <linux/socket.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/errno.h>",
            "#include <linux/list.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define LSFL_RECOVER_STOP\t0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include <linux/dlm.h>\n#include <asm/uaccess.h>\n#include <linux/ratelimit.h>\n#include <linux/idr.h>\n#include <linux/mutex.h>\n#include <linux/miscdevice.h>\n#include <linux/jhash.h>\n#include <linux/kernel.h>\n#include <linux/kref.h>\n#include <linux/kobject.h>\n#include <linux/kthread.h>\n#include <linux/socket.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/errno.h>\n#include <linux/list.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\n#define LSFL_RECOVER_STOP\t0\n\nstatic inline int dlm_recovery_stopped(struct dlm_ls *ls)\n{\n\treturn test_bit(LSFL_RECOVER_STOP, &ls->ls_flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "memb",
            "&ls->ls_nodes",
            "list"
          ],
          "line": 438
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"lowcomms.h\"\n#include \"config.h\"\n#include \"rcom.h\"\n#include \"recover.h\"\n#include \"recoverd.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic int ping_members(struct dlm_ls *ls)\n{\n\tstruct dlm_member *memb;\n\tint error = 0;\n\n\tlist_for_each_entry(memb, &ls->ls_nodes, list) {\n\t\terror = dlm_recovery_stopped(ls);\n\t\tif (error)\n\t\t\tbreak;\n\t\terror = dlm_rcom_status(ls, memb->nodeid, 0);\n\t\tif (error)\n\t\t\tbreak;\n\t}\n\tif (error)\n\t\tlog_rinfo(ls, \"ping_members aborted %d last nodeid %d\",\n\t\t\t  error, ls->ls_recover_nodeid);\n\treturn error;\n}"
  },
  {
    "function_name": "make_member_array",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/member.c",
    "lines": "387-429",
    "snippet": "static void make_member_array(struct dlm_ls *ls)\n{\n\tstruct dlm_member *memb;\n\tint i, w, x = 0, total = 0, all_zero = 0, *array;\n\n\tkfree(ls->ls_node_array);\n\tls->ls_node_array = NULL;\n\n\tlist_for_each_entry(memb, &ls->ls_nodes, list) {\n\t\tif (memb->weight)\n\t\t\ttotal += memb->weight;\n\t}\n\n\t/* all nodes revert to weight of 1 if all have weight 0 */\n\n\tif (!total) {\n\t\ttotal = ls->ls_num_nodes;\n\t\tall_zero = 1;\n\t}\n\n\tls->ls_total_weight = total;\n\n\tarray = kmalloc(sizeof(int) * total, GFP_NOFS);\n\tif (!array)\n\t\treturn;\n\n\tlist_for_each_entry(memb, &ls->ls_nodes, list) {\n\t\tif (!all_zero && !memb->weight)\n\t\t\tcontinue;\n\n\t\tif (all_zero)\n\t\t\tw = 1;\n\t\telse\n\t\t\tw = memb->weight;\n\n\t\tDLM_ASSERT(x < total, printk(\"total %d x %d\\n\", total, x););\n\n\t\tfor (i = 0; i < w; i++)\n\t\t\tarray[x++] = memb->nodeid;\n\t}\n\n\tls->ls_node_array = array;\n}",
    "includes": [
      "#include \"lowcomms.h\"",
      "#include \"config.h\"",
      "#include \"rcom.h\"",
      "#include \"recover.h\"",
      "#include \"recoverd.h\"",
      "#include \"member.h\"",
      "#include \"lockspace.h\"",
      "#include \"dlm_internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "DLM_ASSERT",
          "args": [
            "x < total",
            "printk(\"total %d x %d\\n\", total, x);"
          ],
          "line": 422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"total %d x %d\\n\"",
            "total",
            "x"
          ],
          "line": 422
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "memb",
            "&ls->ls_nodes",
            "list"
          ],
          "line": 413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(int) * total",
            "GFP_NOFS"
          ],
          "line": 409
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "memb",
            "&ls->ls_nodes",
            "list"
          ],
          "line": 395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ls->ls_node_array"
          ],
          "line": 392
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"lowcomms.h\"\n#include \"config.h\"\n#include \"rcom.h\"\n#include \"recover.h\"\n#include \"recoverd.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic void make_member_array(struct dlm_ls *ls)\n{\n\tstruct dlm_member *memb;\n\tint i, w, x = 0, total = 0, all_zero = 0, *array;\n\n\tkfree(ls->ls_node_array);\n\tls->ls_node_array = NULL;\n\n\tlist_for_each_entry(memb, &ls->ls_nodes, list) {\n\t\tif (memb->weight)\n\t\t\ttotal += memb->weight;\n\t}\n\n\t/* all nodes revert to weight of 1 if all have weight 0 */\n\n\tif (!total) {\n\t\ttotal = ls->ls_num_nodes;\n\t\tall_zero = 1;\n\t}\n\n\tls->ls_total_weight = total;\n\n\tarray = kmalloc(sizeof(int) * total, GFP_NOFS);\n\tif (!array)\n\t\treturn;\n\n\tlist_for_each_entry(memb, &ls->ls_nodes, list) {\n\t\tif (!all_zero && !memb->weight)\n\t\t\tcontinue;\n\n\t\tif (all_zero)\n\t\t\tw = 1;\n\t\telse\n\t\t\tw = memb->weight;\n\n\t\tDLM_ASSERT(x < total, printk(\"total %d x %d\\n\", total, x););\n\n\t\tfor (i = 0; i < w; i++)\n\t\t\tarray[x++] = memb->nodeid;\n\t}\n\n\tls->ls_node_array = array;\n}"
  },
  {
    "function_name": "dlm_clear_members_gone",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/member.c",
    "lines": "382-385",
    "snippet": "void dlm_clear_members_gone(struct dlm_ls *ls)\n{\n\tclear_memb_list(&ls->ls_nodes_gone);\n}",
    "includes": [
      "#include \"lowcomms.h\"",
      "#include \"config.h\"",
      "#include \"rcom.h\"",
      "#include \"recover.h\"",
      "#include \"recoverd.h\"",
      "#include \"member.h\"",
      "#include \"lockspace.h\"",
      "#include \"dlm_internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "clear_memb_list",
          "args": [
            "&ls->ls_nodes_gone"
          ],
          "line": 384
        },
        "resolved": true,
        "details": {
          "function_name": "clear_memb_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/member.c",
          "lines": "365-374",
          "snippet": "static void clear_memb_list(struct list_head *head)\n{\n\tstruct dlm_member *memb;\n\n\twhile (!list_empty(head)) {\n\t\tmemb = list_entry(head->next, struct dlm_member, list);\n\t\tlist_del(&memb->list);\n\t\tkfree(memb);\n\t}\n}",
          "includes": [
            "#include \"lowcomms.h\"",
            "#include \"config.h\"",
            "#include \"rcom.h\"",
            "#include \"recover.h\"",
            "#include \"recoverd.h\"",
            "#include \"member.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lowcomms.h\"\n#include \"config.h\"\n#include \"rcom.h\"\n#include \"recover.h\"\n#include \"recoverd.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic void clear_memb_list(struct list_head *head)\n{\n\tstruct dlm_member *memb;\n\n\twhile (!list_empty(head)) {\n\t\tmemb = list_entry(head->next, struct dlm_member, list);\n\t\tlist_del(&memb->list);\n\t\tkfree(memb);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"lowcomms.h\"\n#include \"config.h\"\n#include \"rcom.h\"\n#include \"recover.h\"\n#include \"recoverd.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nvoid dlm_clear_members_gone(struct dlm_ls *ls)\n{\n\tclear_memb_list(&ls->ls_nodes_gone);\n}"
  },
  {
    "function_name": "dlm_clear_members",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/member.c",
    "lines": "376-380",
    "snippet": "void dlm_clear_members(struct dlm_ls *ls)\n{\n\tclear_memb_list(&ls->ls_nodes);\n\tls->ls_num_nodes = 0;\n}",
    "includes": [
      "#include \"lowcomms.h\"",
      "#include \"config.h\"",
      "#include \"rcom.h\"",
      "#include \"recover.h\"",
      "#include \"recoverd.h\"",
      "#include \"member.h\"",
      "#include \"lockspace.h\"",
      "#include \"dlm_internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "clear_memb_list",
          "args": [
            "&ls->ls_nodes"
          ],
          "line": 378
        },
        "resolved": true,
        "details": {
          "function_name": "clear_memb_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/member.c",
          "lines": "365-374",
          "snippet": "static void clear_memb_list(struct list_head *head)\n{\n\tstruct dlm_member *memb;\n\n\twhile (!list_empty(head)) {\n\t\tmemb = list_entry(head->next, struct dlm_member, list);\n\t\tlist_del(&memb->list);\n\t\tkfree(memb);\n\t}\n}",
          "includes": [
            "#include \"lowcomms.h\"",
            "#include \"config.h\"",
            "#include \"rcom.h\"",
            "#include \"recover.h\"",
            "#include \"recoverd.h\"",
            "#include \"member.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lowcomms.h\"\n#include \"config.h\"\n#include \"rcom.h\"\n#include \"recover.h\"\n#include \"recoverd.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic void clear_memb_list(struct list_head *head)\n{\n\tstruct dlm_member *memb;\n\n\twhile (!list_empty(head)) {\n\t\tmemb = list_entry(head->next, struct dlm_member, list);\n\t\tlist_del(&memb->list);\n\t\tkfree(memb);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"lowcomms.h\"\n#include \"config.h\"\n#include \"rcom.h\"\n#include \"recover.h\"\n#include \"recoverd.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nvoid dlm_clear_members(struct dlm_ls *ls)\n{\n\tclear_memb_list(&ls->ls_nodes);\n\tls->ls_num_nodes = 0;\n}"
  },
  {
    "function_name": "clear_memb_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/member.c",
    "lines": "365-374",
    "snippet": "static void clear_memb_list(struct list_head *head)\n{\n\tstruct dlm_member *memb;\n\n\twhile (!list_empty(head)) {\n\t\tmemb = list_entry(head->next, struct dlm_member, list);\n\t\tlist_del(&memb->list);\n\t\tkfree(memb);\n\t}\n}",
    "includes": [
      "#include \"lowcomms.h\"",
      "#include \"config.h\"",
      "#include \"rcom.h\"",
      "#include \"recover.h\"",
      "#include \"recoverd.h\"",
      "#include \"member.h\"",
      "#include \"lockspace.h\"",
      "#include \"dlm_internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "memb"
          ],
          "line": 372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&memb->list"
          ],
          "line": 371
        },
        "resolved": true,
        "details": {
          "function_name": "recover_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/recover.c",
          "lines": "261-271",
          "snippet": "static void recover_list_del(struct dlm_rsb *r)\n{\n\tstruct dlm_ls *ls = r->res_ls;\n\n\tspin_lock(&ls->ls_recover_list_lock);\n\tlist_del_init(&r->res_recover_list);\n\tls->ls_recover_list_count--;\n\tspin_unlock(&ls->ls_recover_list_lock);\n\n\tdlm_put_rsb(r);\n}",
          "includes": [
            "#include \"recover.h\"",
            "#include \"member.h\"",
            "#include \"lowcomms.h\"",
            "#include \"lock.h\"",
            "#include \"rcom.h\"",
            "#include \"memory.h\"",
            "#include \"ast.h\"",
            "#include \"config.h\"",
            "#include \"dir.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"recover.h\"\n#include \"member.h\"\n#include \"lowcomms.h\"\n#include \"lock.h\"\n#include \"rcom.h\"\n#include \"memory.h\"\n#include \"ast.h\"\n#include \"config.h\"\n#include \"dir.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic void recover_list_del(struct dlm_rsb *r)\n{\n\tstruct dlm_ls *ls = r->res_ls;\n\n\tspin_lock(&ls->ls_recover_list_lock);\n\tlist_del_init(&r->res_recover_list);\n\tls->ls_recover_list_count--;\n\tspin_unlock(&ls->ls_recover_list_lock);\n\n\tdlm_put_rsb(r);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "head->next",
            "structdlm_member",
            "list"
          ],
          "line": 370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "head"
          ],
          "line": 369
        },
        "resolved": true,
        "details": {
          "function_name": "recover_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/recover.c",
          "lines": "237-246",
          "snippet": "static int recover_list_empty(struct dlm_ls *ls)\n{\n\tint empty;\n\n\tspin_lock(&ls->ls_recover_list_lock);\n\tempty = list_empty(&ls->ls_recover_list);\n\tspin_unlock(&ls->ls_recover_list_lock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"recover.h\"",
            "#include \"member.h\"",
            "#include \"lowcomms.h\"",
            "#include \"lock.h\"",
            "#include \"rcom.h\"",
            "#include \"memory.h\"",
            "#include \"ast.h\"",
            "#include \"config.h\"",
            "#include \"dir.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"recover.h\"\n#include \"member.h\"\n#include \"lowcomms.h\"\n#include \"lock.h\"\n#include \"rcom.h\"\n#include \"memory.h\"\n#include \"ast.h\"\n#include \"config.h\"\n#include \"dir.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic int recover_list_empty(struct dlm_ls *ls)\n{\n\tint empty;\n\n\tspin_lock(&ls->ls_recover_list_lock);\n\tempty = list_empty(&ls->ls_recover_list);\n\tspin_unlock(&ls->ls_recover_list_lock);\n\n\treturn empty;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"lowcomms.h\"\n#include \"config.h\"\n#include \"rcom.h\"\n#include \"recover.h\"\n#include \"recoverd.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic void clear_memb_list(struct list_head *head)\n{\n\tstruct dlm_member *memb;\n\n\twhile (!list_empty(head)) {\n\t\tmemb = list_entry(head->next, struct dlm_member, list);\n\t\tlist_del(&memb->list);\n\t\tkfree(memb);\n\t}\n}"
  },
  {
    "function_name": "dlm_is_removed",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/member.c",
    "lines": "358-363",
    "snippet": "int dlm_is_removed(struct dlm_ls *ls, int nodeid)\n{\n\tif (find_memb(&ls->ls_nodes_gone, nodeid))\n\t\treturn 1;\n\treturn 0;\n}",
    "includes": [
      "#include \"lowcomms.h\"",
      "#include \"config.h\"",
      "#include \"rcom.h\"",
      "#include \"recover.h\"",
      "#include \"recoverd.h\"",
      "#include \"member.h\"",
      "#include \"lockspace.h\"",
      "#include \"dlm_internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "find_memb",
          "args": [
            "&ls->ls_nodes_gone",
            "nodeid"
          ],
          "line": 360
        },
        "resolved": true,
        "details": {
          "function_name": "find_memb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/member.c",
          "lines": "340-349",
          "snippet": "static struct dlm_member *find_memb(struct list_head *head, int nodeid)\n{\n\tstruct dlm_member *memb;\n\n\tlist_for_each_entry(memb, head, list) {\n\t\tif (memb->nodeid == nodeid)\n\t\t\treturn memb;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"lowcomms.h\"",
            "#include \"config.h\"",
            "#include \"rcom.h\"",
            "#include \"recover.h\"",
            "#include \"recoverd.h\"",
            "#include \"member.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lowcomms.h\"\n#include \"config.h\"\n#include \"rcom.h\"\n#include \"recover.h\"\n#include \"recoverd.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic struct dlm_member *find_memb(struct list_head *head, int nodeid)\n{\n\tstruct dlm_member *memb;\n\n\tlist_for_each_entry(memb, head, list) {\n\t\tif (memb->nodeid == nodeid)\n\t\t\treturn memb;\n\t}\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"lowcomms.h\"\n#include \"config.h\"\n#include \"rcom.h\"\n#include \"recover.h\"\n#include \"recoverd.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nint dlm_is_removed(struct dlm_ls *ls, int nodeid)\n{\n\tif (find_memb(&ls->ls_nodes_gone, nodeid))\n\t\treturn 1;\n\treturn 0;\n}"
  },
  {
    "function_name": "dlm_is_member",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/member.c",
    "lines": "351-356",
    "snippet": "int dlm_is_member(struct dlm_ls *ls, int nodeid)\n{\n\tif (find_memb(&ls->ls_nodes, nodeid))\n\t\treturn 1;\n\treturn 0;\n}",
    "includes": [
      "#include \"lowcomms.h\"",
      "#include \"config.h\"",
      "#include \"rcom.h\"",
      "#include \"recover.h\"",
      "#include \"recoverd.h\"",
      "#include \"member.h\"",
      "#include \"lockspace.h\"",
      "#include \"dlm_internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "find_memb",
          "args": [
            "&ls->ls_nodes",
            "nodeid"
          ],
          "line": 353
        },
        "resolved": true,
        "details": {
          "function_name": "find_memb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/member.c",
          "lines": "340-349",
          "snippet": "static struct dlm_member *find_memb(struct list_head *head, int nodeid)\n{\n\tstruct dlm_member *memb;\n\n\tlist_for_each_entry(memb, head, list) {\n\t\tif (memb->nodeid == nodeid)\n\t\t\treturn memb;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"lowcomms.h\"",
            "#include \"config.h\"",
            "#include \"rcom.h\"",
            "#include \"recover.h\"",
            "#include \"recoverd.h\"",
            "#include \"member.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lowcomms.h\"\n#include \"config.h\"\n#include \"rcom.h\"\n#include \"recover.h\"\n#include \"recoverd.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic struct dlm_member *find_memb(struct list_head *head, int nodeid)\n{\n\tstruct dlm_member *memb;\n\n\tlist_for_each_entry(memb, head, list) {\n\t\tif (memb->nodeid == nodeid)\n\t\t\treturn memb;\n\t}\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"lowcomms.h\"\n#include \"config.h\"\n#include \"rcom.h\"\n#include \"recover.h\"\n#include \"recoverd.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nint dlm_is_member(struct dlm_ls *ls, int nodeid)\n{\n\tif (find_memb(&ls->ls_nodes, nodeid))\n\t\treturn 1;\n\treturn 0;\n}"
  },
  {
    "function_name": "find_memb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/member.c",
    "lines": "340-349",
    "snippet": "static struct dlm_member *find_memb(struct list_head *head, int nodeid)\n{\n\tstruct dlm_member *memb;\n\n\tlist_for_each_entry(memb, head, list) {\n\t\tif (memb->nodeid == nodeid)\n\t\t\treturn memb;\n\t}\n\treturn NULL;\n}",
    "includes": [
      "#include \"lowcomms.h\"",
      "#include \"config.h\"",
      "#include \"rcom.h\"",
      "#include \"recover.h\"",
      "#include \"recoverd.h\"",
      "#include \"member.h\"",
      "#include \"lockspace.h\"",
      "#include \"dlm_internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "memb",
            "head",
            "list"
          ],
          "line": 344
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"lowcomms.h\"\n#include \"config.h\"\n#include \"rcom.h\"\n#include \"recover.h\"\n#include \"recoverd.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic struct dlm_member *find_memb(struct list_head *head, int nodeid)\n{\n\tstruct dlm_member *memb;\n\n\tlist_for_each_entry(memb, head, list) {\n\t\tif (memb->nodeid == nodeid)\n\t\t\treturn memb;\n\t}\n\treturn NULL;\n}"
  },
  {
    "function_name": "dlm_add_member",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/member.c",
    "lines": "317-338",
    "snippet": "static int dlm_add_member(struct dlm_ls *ls, struct dlm_config_node *node)\n{\n\tstruct dlm_member *memb;\n\tint error;\n\n\tmemb = kzalloc(sizeof(struct dlm_member), GFP_NOFS);\n\tif (!memb)\n\t\treturn -ENOMEM;\n\n\terror = dlm_lowcomms_connect_node(node->nodeid);\n\tif (error < 0) {\n\t\tkfree(memb);\n\t\treturn error;\n\t}\n\n\tmemb->nodeid = node->nodeid;\n\tmemb->weight = node->weight;\n\tmemb->comm_seq = node->comm_seq;\n\tadd_ordered_member(ls, memb);\n\tls->ls_num_nodes++;\n\treturn 0;\n}",
    "includes": [
      "#include \"lowcomms.h\"",
      "#include \"config.h\"",
      "#include \"rcom.h\"",
      "#include \"recover.h\"",
      "#include \"recoverd.h\"",
      "#include \"member.h\"",
      "#include \"lockspace.h\"",
      "#include \"dlm_internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "add_ordered_member",
          "args": [
            "ls",
            "memb"
          ],
          "line": 335
        },
        "resolved": true,
        "details": {
          "function_name": "add_ordered_member",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/member.c",
          "lines": "293-315",
          "snippet": "static void add_ordered_member(struct dlm_ls *ls, struct dlm_member *new)\n{\n\tstruct dlm_member *memb = NULL;\n\tstruct list_head *tmp;\n\tstruct list_head *newlist = &new->list;\n\tstruct list_head *head = &ls->ls_nodes;\n\n\tlist_for_each(tmp, head) {\n\t\tmemb = list_entry(tmp, struct dlm_member, list);\n\t\tif (new->nodeid < memb->nodeid)\n\t\t\tbreak;\n\t}\n\n\tif (!memb)\n\t\tlist_add_tail(newlist, head);\n\telse {\n\t\t/* FIXME: can use list macro here */\n\t\tnewlist->prev = tmp->prev;\n\t\tnewlist->next = tmp;\n\t\ttmp->prev->next = newlist;\n\t\ttmp->prev = newlist;\n\t}\n}",
          "includes": [
            "#include \"lowcomms.h\"",
            "#include \"config.h\"",
            "#include \"rcom.h\"",
            "#include \"recover.h\"",
            "#include \"recoverd.h\"",
            "#include \"member.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lowcomms.h\"\n#include \"config.h\"\n#include \"rcom.h\"\n#include \"recover.h\"\n#include \"recoverd.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic void add_ordered_member(struct dlm_ls *ls, struct dlm_member *new)\n{\n\tstruct dlm_member *memb = NULL;\n\tstruct list_head *tmp;\n\tstruct list_head *newlist = &new->list;\n\tstruct list_head *head = &ls->ls_nodes;\n\n\tlist_for_each(tmp, head) {\n\t\tmemb = list_entry(tmp, struct dlm_member, list);\n\t\tif (new->nodeid < memb->nodeid)\n\t\t\tbreak;\n\t}\n\n\tif (!memb)\n\t\tlist_add_tail(newlist, head);\n\telse {\n\t\t/* FIXME: can use list macro here */\n\t\tnewlist->prev = tmp->prev;\n\t\tnewlist->next = tmp;\n\t\ttmp->prev->next = newlist;\n\t\ttmp->prev = newlist;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "memb"
          ],
          "line": 328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_lowcomms_connect_node",
          "args": [
            "node->nodeid"
          ],
          "line": 326
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_lowcomms_connect_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lowcomms.c",
          "lines": "466-482",
          "snippet": "int dlm_lowcomms_connect_node(int nodeid)\n{\n\tstruct connection *con;\n\n\t/* with sctp there's no connecting without sending */\n\tif (dlm_config.ci_protocol != 0)\n\t\treturn 0;\n\n\tif (nodeid == dlm_our_nodeid())\n\t\treturn 0;\n\n\tcon = nodeid2con(nodeid, GFP_NOFS);\n\tif (!con)\n\t\treturn -ENOMEM;\n\tlowcomms_connect_sock(con);\n\treturn 0;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"midcomms.h\"",
            "#include \"lowcomms.h\"",
            "#include \"dlm_internal.h\"",
            "#include <net/ipv6.h>",
            "#include <net/sctp/sctp.h>",
            "#include <linux/slab.h>",
            "#include <linux/sctp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <net/tcp.h>",
            "#include <net/sock.h>",
            "#include <asm/ioctls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"midcomms.h\"\n#include \"lowcomms.h\"\n#include \"dlm_internal.h\"\n#include <net/ipv6.h>\n#include <net/sctp/sctp.h>\n#include <linux/slab.h>\n#include <linux/sctp.h>\n#include <linux/mutex.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <net/tcp.h>\n#include <net/sock.h>\n#include <asm/ioctls.h>\n\nint dlm_lowcomms_connect_node(int nodeid)\n{\n\tstruct connection *con;\n\n\t/* with sctp there's no connecting without sending */\n\tif (dlm_config.ci_protocol != 0)\n\t\treturn 0;\n\n\tif (nodeid == dlm_our_nodeid())\n\t\treturn 0;\n\n\tcon = nodeid2con(nodeid, GFP_NOFS);\n\tif (!con)\n\t\treturn -ENOMEM;\n\tlowcomms_connect_sock(con);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct dlm_member)",
            "GFP_NOFS"
          ],
          "line": 322
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"lowcomms.h\"\n#include \"config.h\"\n#include \"rcom.h\"\n#include \"recover.h\"\n#include \"recoverd.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic int dlm_add_member(struct dlm_ls *ls, struct dlm_config_node *node)\n{\n\tstruct dlm_member *memb;\n\tint error;\n\n\tmemb = kzalloc(sizeof(struct dlm_member), GFP_NOFS);\n\tif (!memb)\n\t\treturn -ENOMEM;\n\n\terror = dlm_lowcomms_connect_node(node->nodeid);\n\tif (error < 0) {\n\t\tkfree(memb);\n\t\treturn error;\n\t}\n\n\tmemb->nodeid = node->nodeid;\n\tmemb->weight = node->weight;\n\tmemb->comm_seq = node->comm_seq;\n\tadd_ordered_member(ls, memb);\n\tls->ls_num_nodes++;\n\treturn 0;\n}"
  },
  {
    "function_name": "add_ordered_member",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/member.c",
    "lines": "293-315",
    "snippet": "static void add_ordered_member(struct dlm_ls *ls, struct dlm_member *new)\n{\n\tstruct dlm_member *memb = NULL;\n\tstruct list_head *tmp;\n\tstruct list_head *newlist = &new->list;\n\tstruct list_head *head = &ls->ls_nodes;\n\n\tlist_for_each(tmp, head) {\n\t\tmemb = list_entry(tmp, struct dlm_member, list);\n\t\tif (new->nodeid < memb->nodeid)\n\t\t\tbreak;\n\t}\n\n\tif (!memb)\n\t\tlist_add_tail(newlist, head);\n\telse {\n\t\t/* FIXME: can use list macro here */\n\t\tnewlist->prev = tmp->prev;\n\t\tnewlist->next = tmp;\n\t\ttmp->prev->next = newlist;\n\t\ttmp->prev = newlist;\n\t}\n}",
    "includes": [
      "#include \"lowcomms.h\"",
      "#include \"config.h\"",
      "#include \"rcom.h\"",
      "#include \"recover.h\"",
      "#include \"recoverd.h\"",
      "#include \"member.h\"",
      "#include \"lockspace.h\"",
      "#include \"dlm_internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "newlist",
            "head"
          ],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "tmp",
            "structdlm_member",
            "list"
          ],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each",
          "args": [
            "tmp",
            "head"
          ],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"lowcomms.h\"\n#include \"config.h\"\n#include \"rcom.h\"\n#include \"recover.h\"\n#include \"recoverd.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic void add_ordered_member(struct dlm_ls *ls, struct dlm_member *new)\n{\n\tstruct dlm_member *memb = NULL;\n\tstruct list_head *tmp;\n\tstruct list_head *newlist = &new->list;\n\tstruct list_head *head = &ls->ls_nodes;\n\n\tlist_for_each(tmp, head) {\n\t\tmemb = list_entry(tmp, struct dlm_member, list);\n\t\tif (new->nodeid < memb->nodeid)\n\t\t\tbreak;\n\t}\n\n\tif (!memb)\n\t\tlist_add_tail(newlist, head);\n\telse {\n\t\t/* FIXME: can use list macro here */\n\t\tnewlist->prev = tmp->prev;\n\t\tnewlist->next = tmp;\n\t\ttmp->prev->next = newlist;\n\t\ttmp->prev = newlist;\n\t}\n}"
  },
  {
    "function_name": "dlm_slots_assign",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/member.c",
    "lines": "166-291",
    "snippet": "int dlm_slots_assign(struct dlm_ls *ls, int *num_slots, int *slots_size,\n\t\t     struct dlm_slot **slots_out, uint32_t *gen_out)\n{\n\tstruct dlm_member *memb;\n\tstruct dlm_slot *array;\n\tint our_nodeid = dlm_our_nodeid();\n\tint array_size, max_slots, i;\n\tint need = 0;\n\tint max = 0;\n\tint num = 0;\n\tuint32_t gen = 0;\n\n\t/* our own memb struct will have slot -1 gen 0 */\n\n\tlist_for_each_entry(memb, &ls->ls_nodes, list) {\n\t\tif (memb->nodeid == our_nodeid) {\n\t\t\tmemb->slot = ls->ls_slot;\n\t\t\tmemb->generation = ls->ls_generation;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tlist_for_each_entry(memb, &ls->ls_nodes, list) {\n\t\tif (memb->generation > gen)\n\t\t\tgen = memb->generation;\n\n\t\t/* node doesn't support slots */\n\n\t\tif (memb->slot == -1)\n\t\t\treturn -1;\n\n\t\t/* node needs a slot assigned */\n\n\t\tif (!memb->slot)\n\t\t\tneed++;\n\n\t\t/* node has a slot assigned */\n\n\t\tnum++;\n\n\t\tif (!max || max < memb->slot)\n\t\t\tmax = memb->slot;\n\n\t\t/* sanity check, once slot is assigned it shouldn't change */\n\n\t\tif (memb->slot_prev && memb->slot && memb->slot_prev != memb->slot) {\n\t\t\tlog_error(ls, \"nodeid %d slot changed %d %d\",\n\t\t\t\t  memb->nodeid, memb->slot_prev, memb->slot);\n\t\t\treturn -1;\n\t\t}\n\t\tmemb->slot_prev = memb->slot;\n\t}\n\n\tarray_size = max + need;\n\n\tarray = kzalloc(array_size * sizeof(struct dlm_slot), GFP_NOFS);\n\tif (!array)\n\t\treturn -ENOMEM;\n\n\tnum = 0;\n\n\t/* fill in slots (offsets) that are used */\n\n\tlist_for_each_entry(memb, &ls->ls_nodes, list) {\n\t\tif (!memb->slot)\n\t\t\tcontinue;\n\n\t\tif (memb->slot > array_size) {\n\t\t\tlog_error(ls, \"invalid slot number %d\", memb->slot);\n\t\t\tkfree(array);\n\t\t\treturn -1;\n\t\t}\n\n\t\tarray[memb->slot - 1].nodeid = memb->nodeid;\n\t\tarray[memb->slot - 1].slot = memb->slot;\n\t\tnum++;\n\t}\n\n\t/* assign new slots from unused offsets */\n\n\tlist_for_each_entry(memb, &ls->ls_nodes, list) {\n\t\tif (memb->slot)\n\t\t\tcontinue;\n\n\t\tfor (i = 0; i < array_size; i++) {\n\t\t\tif (array[i].nodeid)\n\t\t\t\tcontinue;\n\n\t\t\tmemb->slot = i + 1;\n\t\t\tmemb->slot_prev = memb->slot;\n\t\t\tarray[i].nodeid = memb->nodeid;\n\t\t\tarray[i].slot = memb->slot;\n\t\t\tnum++;\n\n\t\t\tif (!ls->ls_slot && memb->nodeid == our_nodeid)\n\t\t\t\tls->ls_slot = memb->slot;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!memb->slot) {\n\t\t\tlog_error(ls, \"no free slot found\");\n\t\t\tkfree(array);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tgen++;\n\n\tlog_slots(ls, gen, num, NULL, array, array_size);\n\n\tmax_slots = (dlm_config.ci_buffer_size - sizeof(struct dlm_rcom) -\n\t\t     sizeof(struct rcom_config)) / sizeof(struct rcom_slot);\n\n\tif (num > max_slots) {\n\t\tlog_error(ls, \"num_slots %d exceeds max_slots %d\",\n\t\t\t  num, max_slots);\n\t\tkfree(array);\n\t\treturn -1;\n\t}\n\n\t*gen_out = gen;\n\t*slots_out = array;\n\t*slots_size = array_size;\n\t*num_slots = num;\n\treturn 0;\n}",
    "includes": [
      "#include \"lowcomms.h\"",
      "#include \"config.h\"",
      "#include \"rcom.h\"",
      "#include \"recover.h\"",
      "#include \"recoverd.h\"",
      "#include \"member.h\"",
      "#include \"lockspace.h\"",
      "#include \"dlm_internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "array"
          ],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "log_error",
          "args": [
            "ls",
            "\"num_slots %d exceeds max_slots %d\"",
            "num",
            "max_slots"
          ],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "log_slots",
          "args": [
            "ls",
            "gen",
            "num",
            "NULL",
            "array",
            "array_size"
          ],
          "line": 274
        },
        "resolved": true,
        "details": {
          "function_name": "log_slots",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/member.c",
          "lines": "63-96",
          "snippet": "static void log_slots(struct dlm_ls *ls, uint32_t gen, int num_slots,\n\t\t      struct rcom_slot *ro0, struct dlm_slot *array,\n\t\t      int array_size)\n{\n\tchar line[SLOT_DEBUG_LINE];\n\tint len = SLOT_DEBUG_LINE - 1;\n\tint pos = 0;\n\tint ret, i;\n\n\tmemset(line, 0, sizeof(line));\n\n\tif (array) {\n\t\tfor (i = 0; i < array_size; i++) {\n\t\t\tif (!array[i].nodeid)\n\t\t\t\tcontinue;\n\n\t\t\tret = snprintf(line + pos, len - pos, \" %d:%d\",\n\t\t\t\t       array[i].slot, array[i].nodeid);\n\t\t\tif (ret >= len - pos)\n\t\t\t\tbreak;\n\t\t\tpos += ret;\n\t\t}\n\t} else if (ro0) {\n\t\tfor (i = 0; i < num_slots; i++) {\n\t\t\tret = snprintf(line + pos, len - pos, \" %d:%d\",\n\t\t\t\t       ro0[i].ro_slot, ro0[i].ro_nodeid);\n\t\t\tif (ret >= len - pos)\n\t\t\t\tbreak;\n\t\t\tpos += ret;\n\t\t}\n\t}\n\n\tlog_rinfo(ls, \"generation %u slots %d%s\", gen, num_slots, line);\n}",
          "includes": [
            "#include \"lowcomms.h\"",
            "#include \"config.h\"",
            "#include \"rcom.h\"",
            "#include \"recover.h\"",
            "#include \"recoverd.h\"",
            "#include \"member.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [
            "#define SLOT_DEBUG_LINE 128"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lowcomms.h\"\n#include \"config.h\"\n#include \"rcom.h\"\n#include \"recover.h\"\n#include \"recoverd.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\n#define SLOT_DEBUG_LINE 128\n\nstatic void log_slots(struct dlm_ls *ls, uint32_t gen, int num_slots,\n\t\t      struct rcom_slot *ro0, struct dlm_slot *array,\n\t\t      int array_size)\n{\n\tchar line[SLOT_DEBUG_LINE];\n\tint len = SLOT_DEBUG_LINE - 1;\n\tint pos = 0;\n\tint ret, i;\n\n\tmemset(line, 0, sizeof(line));\n\n\tif (array) {\n\t\tfor (i = 0; i < array_size; i++) {\n\t\t\tif (!array[i].nodeid)\n\t\t\t\tcontinue;\n\n\t\t\tret = snprintf(line + pos, len - pos, \" %d:%d\",\n\t\t\t\t       array[i].slot, array[i].nodeid);\n\t\t\tif (ret >= len - pos)\n\t\t\t\tbreak;\n\t\t\tpos += ret;\n\t\t}\n\t} else if (ro0) {\n\t\tfor (i = 0; i < num_slots; i++) {\n\t\t\tret = snprintf(line + pos, len - pos, \" %d:%d\",\n\t\t\t\t       ro0[i].ro_slot, ro0[i].ro_nodeid);\n\t\t\tif (ret >= len - pos)\n\t\t\t\tbreak;\n\t\t\tpos += ret;\n\t\t}\n\t}\n\n\tlog_rinfo(ls, \"generation %u slots %d%s\", gen, num_slots, line);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "array"
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "log_error",
          "args": [
            "ls",
            "\"no free slot found\""
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "memb",
            "&ls->ls_nodes",
            "list"
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "array"
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "log_error",
          "args": [
            "ls",
            "\"invalid slot number %d\"",
            "memb->slot"
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "memb",
            "&ls->ls_nodes",
            "list"
          ],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "array_size * sizeof(struct dlm_slot)",
            "GFP_NOFS"
          ],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "log_error",
          "args": [
            "ls",
            "\"nodeid %d slot changed %d %d\"",
            "memb->nodeid",
            "memb->slot_prev",
            "memb->slot"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "memb",
            "&ls->ls_nodes",
            "list"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "memb",
            "&ls->ls_nodes",
            "list"
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_our_nodeid",
          "args": [],
          "line": 171
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_our_nodeid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/config.c",
          "lines": "994-997",
          "snippet": "int dlm_our_nodeid(void)\n{\n\treturn local_comm ? local_comm->nodeid : 0;\n}",
          "includes": [
            "#include \"lowcomms.h\"",
            "#include \"config.h\"",
            "#include <net/sock.h>",
            "#include <net/ipv6.h>",
            "#include <linux/dlmconstants.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/slab.h>",
            "#include <linux/configfs.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct dlm_comm *local_comm;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lowcomms.h\"\n#include \"config.h\"\n#include <net/sock.h>\n#include <net/ipv6.h>\n#include <linux/dlmconstants.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/slab.h>\n#include <linux/configfs.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct dlm_comm *local_comm;\n\nint dlm_our_nodeid(void)\n{\n\treturn local_comm ? local_comm->nodeid : 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"lowcomms.h\"\n#include \"config.h\"\n#include \"rcom.h\"\n#include \"recover.h\"\n#include \"recoverd.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nint dlm_slots_assign(struct dlm_ls *ls, int *num_slots, int *slots_size,\n\t\t     struct dlm_slot **slots_out, uint32_t *gen_out)\n{\n\tstruct dlm_member *memb;\n\tstruct dlm_slot *array;\n\tint our_nodeid = dlm_our_nodeid();\n\tint array_size, max_slots, i;\n\tint need = 0;\n\tint max = 0;\n\tint num = 0;\n\tuint32_t gen = 0;\n\n\t/* our own memb struct will have slot -1 gen 0 */\n\n\tlist_for_each_entry(memb, &ls->ls_nodes, list) {\n\t\tif (memb->nodeid == our_nodeid) {\n\t\t\tmemb->slot = ls->ls_slot;\n\t\t\tmemb->generation = ls->ls_generation;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tlist_for_each_entry(memb, &ls->ls_nodes, list) {\n\t\tif (memb->generation > gen)\n\t\t\tgen = memb->generation;\n\n\t\t/* node doesn't support slots */\n\n\t\tif (memb->slot == -1)\n\t\t\treturn -1;\n\n\t\t/* node needs a slot assigned */\n\n\t\tif (!memb->slot)\n\t\t\tneed++;\n\n\t\t/* node has a slot assigned */\n\n\t\tnum++;\n\n\t\tif (!max || max < memb->slot)\n\t\t\tmax = memb->slot;\n\n\t\t/* sanity check, once slot is assigned it shouldn't change */\n\n\t\tif (memb->slot_prev && memb->slot && memb->slot_prev != memb->slot) {\n\t\t\tlog_error(ls, \"nodeid %d slot changed %d %d\",\n\t\t\t\t  memb->nodeid, memb->slot_prev, memb->slot);\n\t\t\treturn -1;\n\t\t}\n\t\tmemb->slot_prev = memb->slot;\n\t}\n\n\tarray_size = max + need;\n\n\tarray = kzalloc(array_size * sizeof(struct dlm_slot), GFP_NOFS);\n\tif (!array)\n\t\treturn -ENOMEM;\n\n\tnum = 0;\n\n\t/* fill in slots (offsets) that are used */\n\n\tlist_for_each_entry(memb, &ls->ls_nodes, list) {\n\t\tif (!memb->slot)\n\t\t\tcontinue;\n\n\t\tif (memb->slot > array_size) {\n\t\t\tlog_error(ls, \"invalid slot number %d\", memb->slot);\n\t\t\tkfree(array);\n\t\t\treturn -1;\n\t\t}\n\n\t\tarray[memb->slot - 1].nodeid = memb->nodeid;\n\t\tarray[memb->slot - 1].slot = memb->slot;\n\t\tnum++;\n\t}\n\n\t/* assign new slots from unused offsets */\n\n\tlist_for_each_entry(memb, &ls->ls_nodes, list) {\n\t\tif (memb->slot)\n\t\t\tcontinue;\n\n\t\tfor (i = 0; i < array_size; i++) {\n\t\t\tif (array[i].nodeid)\n\t\t\t\tcontinue;\n\n\t\t\tmemb->slot = i + 1;\n\t\t\tmemb->slot_prev = memb->slot;\n\t\t\tarray[i].nodeid = memb->nodeid;\n\t\t\tarray[i].slot = memb->slot;\n\t\t\tnum++;\n\n\t\t\tif (!ls->ls_slot && memb->nodeid == our_nodeid)\n\t\t\t\tls->ls_slot = memb->slot;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!memb->slot) {\n\t\t\tlog_error(ls, \"no free slot found\");\n\t\t\tkfree(array);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tgen++;\n\n\tlog_slots(ls, gen, num, NULL, array, array_size);\n\n\tmax_slots = (dlm_config.ci_buffer_size - sizeof(struct dlm_rcom) -\n\t\t     sizeof(struct rcom_config)) / sizeof(struct rcom_slot);\n\n\tif (num > max_slots) {\n\t\tlog_error(ls, \"num_slots %d exceeds max_slots %d\",\n\t\t\t  num, max_slots);\n\t\tkfree(array);\n\t\treturn -1;\n\t}\n\n\t*gen_out = gen;\n\t*slots_out = array;\n\t*slots_size = array_size;\n\t*num_slots = num;\n\treturn 0;\n}"
  },
  {
    "function_name": "dlm_slots_copy_in",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/member.c",
    "lines": "98-160",
    "snippet": "int dlm_slots_copy_in(struct dlm_ls *ls)\n{\n\tstruct dlm_member *memb;\n\tstruct dlm_rcom *rc = ls->ls_recover_buf;\n\tstruct rcom_config *rf = (struct rcom_config *)rc->rc_buf;\n\tstruct rcom_slot *ro0, *ro;\n\tint our_nodeid = dlm_our_nodeid();\n\tint i, num_slots;\n\tuint32_t gen;\n\n\tif (!dlm_slots_version(&rc->rc_header))\n\t\treturn -1;\n\n\tgen = le32_to_cpu(rf->rf_generation);\n\tif (gen <= ls->ls_generation) {\n\t\tlog_error(ls, \"dlm_slots_copy_in gen %u old %u\",\n\t\t\t  gen, ls->ls_generation);\n\t}\n\tls->ls_generation = gen;\n\n\tnum_slots = le16_to_cpu(rf->rf_num_slots);\n\tif (!num_slots)\n\t\treturn -1;\n\n\tro0 = (struct rcom_slot *)(rc->rc_buf + sizeof(struct rcom_config));\n\n\tfor (i = 0, ro = ro0; i < num_slots; i++, ro++) {\n\t\tro->ro_nodeid = le32_to_cpu(ro->ro_nodeid);\n\t\tro->ro_slot = le16_to_cpu(ro->ro_slot);\n\t}\n\n\tlog_slots(ls, gen, num_slots, ro0, NULL, 0);\n\n\tlist_for_each_entry(memb, &ls->ls_nodes, list) {\n\t\tfor (i = 0, ro = ro0; i < num_slots; i++, ro++) {\n\t\t\tif (ro->ro_nodeid != memb->nodeid)\n\t\t\t\tcontinue;\n\t\t\tmemb->slot = ro->ro_slot;\n\t\t\tmemb->slot_prev = memb->slot;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (memb->nodeid == our_nodeid) {\n\t\t\tif (ls->ls_slot && ls->ls_slot != memb->slot) {\n\t\t\t\tlog_error(ls, \"dlm_slots_copy_in our slot \"\n\t\t\t\t\t  \"changed %d %d\", ls->ls_slot,\n\t\t\t\t\t  memb->slot);\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tif (!ls->ls_slot)\n\t\t\t\tls->ls_slot = memb->slot;\n\t\t}\n\n\t\tif (!memb->slot) {\n\t\t\tlog_error(ls, \"dlm_slots_copy_in nodeid %d no slot\",\n\t\t\t\t   memb->nodeid);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"lowcomms.h\"",
      "#include \"config.h\"",
      "#include \"rcom.h\"",
      "#include \"recover.h\"",
      "#include \"recoverd.h\"",
      "#include \"member.h\"",
      "#include \"lockspace.h\"",
      "#include \"dlm_internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "log_error",
          "args": [
            "ls",
            "\"dlm_slots_copy_in nodeid %d no slot\"",
            "memb->nodeid"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "log_error",
          "args": [
            "ls",
            "\"dlm_slots_copy_in our slot \"\n\t\t\t\t\t  \"changed %d %d\"",
            "ls->ls_slot",
            "memb->slot"
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "memb",
            "&ls->ls_nodes",
            "list"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "log_slots",
          "args": [
            "ls",
            "gen",
            "num_slots",
            "ro0",
            "NULL",
            "0"
          ],
          "line": 129
        },
        "resolved": true,
        "details": {
          "function_name": "log_slots",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/member.c",
          "lines": "63-96",
          "snippet": "static void log_slots(struct dlm_ls *ls, uint32_t gen, int num_slots,\n\t\t      struct rcom_slot *ro0, struct dlm_slot *array,\n\t\t      int array_size)\n{\n\tchar line[SLOT_DEBUG_LINE];\n\tint len = SLOT_DEBUG_LINE - 1;\n\tint pos = 0;\n\tint ret, i;\n\n\tmemset(line, 0, sizeof(line));\n\n\tif (array) {\n\t\tfor (i = 0; i < array_size; i++) {\n\t\t\tif (!array[i].nodeid)\n\t\t\t\tcontinue;\n\n\t\t\tret = snprintf(line + pos, len - pos, \" %d:%d\",\n\t\t\t\t       array[i].slot, array[i].nodeid);\n\t\t\tif (ret >= len - pos)\n\t\t\t\tbreak;\n\t\t\tpos += ret;\n\t\t}\n\t} else if (ro0) {\n\t\tfor (i = 0; i < num_slots; i++) {\n\t\t\tret = snprintf(line + pos, len - pos, \" %d:%d\",\n\t\t\t\t       ro0[i].ro_slot, ro0[i].ro_nodeid);\n\t\t\tif (ret >= len - pos)\n\t\t\t\tbreak;\n\t\t\tpos += ret;\n\t\t}\n\t}\n\n\tlog_rinfo(ls, \"generation %u slots %d%s\", gen, num_slots, line);\n}",
          "includes": [
            "#include \"lowcomms.h\"",
            "#include \"config.h\"",
            "#include \"rcom.h\"",
            "#include \"recover.h\"",
            "#include \"recoverd.h\"",
            "#include \"member.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [
            "#define SLOT_DEBUG_LINE 128"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lowcomms.h\"\n#include \"config.h\"\n#include \"rcom.h\"\n#include \"recover.h\"\n#include \"recoverd.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\n#define SLOT_DEBUG_LINE 128\n\nstatic void log_slots(struct dlm_ls *ls, uint32_t gen, int num_slots,\n\t\t      struct rcom_slot *ro0, struct dlm_slot *array,\n\t\t      int array_size)\n{\n\tchar line[SLOT_DEBUG_LINE];\n\tint len = SLOT_DEBUG_LINE - 1;\n\tint pos = 0;\n\tint ret, i;\n\n\tmemset(line, 0, sizeof(line));\n\n\tif (array) {\n\t\tfor (i = 0; i < array_size; i++) {\n\t\t\tif (!array[i].nodeid)\n\t\t\t\tcontinue;\n\n\t\t\tret = snprintf(line + pos, len - pos, \" %d:%d\",\n\t\t\t\t       array[i].slot, array[i].nodeid);\n\t\t\tif (ret >= len - pos)\n\t\t\t\tbreak;\n\t\t\tpos += ret;\n\t\t}\n\t} else if (ro0) {\n\t\tfor (i = 0; i < num_slots; i++) {\n\t\t\tret = snprintf(line + pos, len - pos, \" %d:%d\",\n\t\t\t\t       ro0[i].ro_slot, ro0[i].ro_nodeid);\n\t\t\tif (ret >= len - pos)\n\t\t\t\tbreak;\n\t\t\tpos += ret;\n\t\t}\n\t}\n\n\tlog_rinfo(ls, \"generation %u slots %d%s\", gen, num_slots, line);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "ro->ro_slot"
          ],
          "line": 126
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "ro->ro_nodeid"
          ],
          "line": 125
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "log_error",
          "args": [
            "ls",
            "\"dlm_slots_copy_in gen %u old %u\"",
            "gen",
            "ls->ls_generation"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_slots_version",
          "args": [
            "&rc->rc_header"
          ],
          "line": 108
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_slots_version",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/member.c",
          "lines": "22-27",
          "snippet": "int dlm_slots_version(struct dlm_header *h)\n{\n\tif ((h->h_version & 0x0000FFFF) < DLM_HEADER_SLOTS)\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"lowcomms.h\"",
            "#include \"config.h\"",
            "#include \"rcom.h\"",
            "#include \"recover.h\"",
            "#include \"recoverd.h\"",
            "#include \"member.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lowcomms.h\"\n#include \"config.h\"\n#include \"rcom.h\"\n#include \"recover.h\"\n#include \"recoverd.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nint dlm_slots_version(struct dlm_header *h)\n{\n\tif ((h->h_version & 0x0000FFFF) < DLM_HEADER_SLOTS)\n\t\treturn 0;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_our_nodeid",
          "args": [],
          "line": 104
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_our_nodeid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/config.c",
          "lines": "994-997",
          "snippet": "int dlm_our_nodeid(void)\n{\n\treturn local_comm ? local_comm->nodeid : 0;\n}",
          "includes": [
            "#include \"lowcomms.h\"",
            "#include \"config.h\"",
            "#include <net/sock.h>",
            "#include <net/ipv6.h>",
            "#include <linux/dlmconstants.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/slab.h>",
            "#include <linux/configfs.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct dlm_comm *local_comm;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lowcomms.h\"\n#include \"config.h\"\n#include <net/sock.h>\n#include <net/ipv6.h>\n#include <linux/dlmconstants.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/slab.h>\n#include <linux/configfs.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct dlm_comm *local_comm;\n\nint dlm_our_nodeid(void)\n{\n\treturn local_comm ? local_comm->nodeid : 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"lowcomms.h\"\n#include \"config.h\"\n#include \"rcom.h\"\n#include \"recover.h\"\n#include \"recoverd.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nint dlm_slots_copy_in(struct dlm_ls *ls)\n{\n\tstruct dlm_member *memb;\n\tstruct dlm_rcom *rc = ls->ls_recover_buf;\n\tstruct rcom_config *rf = (struct rcom_config *)rc->rc_buf;\n\tstruct rcom_slot *ro0, *ro;\n\tint our_nodeid = dlm_our_nodeid();\n\tint i, num_slots;\n\tuint32_t gen;\n\n\tif (!dlm_slots_version(&rc->rc_header))\n\t\treturn -1;\n\n\tgen = le32_to_cpu(rf->rf_generation);\n\tif (gen <= ls->ls_generation) {\n\t\tlog_error(ls, \"dlm_slots_copy_in gen %u old %u\",\n\t\t\t  gen, ls->ls_generation);\n\t}\n\tls->ls_generation = gen;\n\n\tnum_slots = le16_to_cpu(rf->rf_num_slots);\n\tif (!num_slots)\n\t\treturn -1;\n\n\tro0 = (struct rcom_slot *)(rc->rc_buf + sizeof(struct rcom_config));\n\n\tfor (i = 0, ro = ro0; i < num_slots; i++, ro++) {\n\t\tro->ro_nodeid = le32_to_cpu(ro->ro_nodeid);\n\t\tro->ro_slot = le16_to_cpu(ro->ro_slot);\n\t}\n\n\tlog_slots(ls, gen, num_slots, ro0, NULL, 0);\n\n\tlist_for_each_entry(memb, &ls->ls_nodes, list) {\n\t\tfor (i = 0, ro = ro0; i < num_slots; i++, ro++) {\n\t\t\tif (ro->ro_nodeid != memb->nodeid)\n\t\t\t\tcontinue;\n\t\t\tmemb->slot = ro->ro_slot;\n\t\t\tmemb->slot_prev = memb->slot;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (memb->nodeid == our_nodeid) {\n\t\t\tif (ls->ls_slot && ls->ls_slot != memb->slot) {\n\t\t\t\tlog_error(ls, \"dlm_slots_copy_in our slot \"\n\t\t\t\t\t  \"changed %d %d\", ls->ls_slot,\n\t\t\t\t\t  memb->slot);\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tif (!ls->ls_slot)\n\t\t\t\tls->ls_slot = memb->slot;\n\t\t}\n\n\t\tif (!memb->slot) {\n\t\t\tlog_error(ls, \"dlm_slots_copy_in nodeid %d no slot\",\n\t\t\t\t   memb->nodeid);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "log_slots",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/member.c",
    "lines": "63-96",
    "snippet": "static void log_slots(struct dlm_ls *ls, uint32_t gen, int num_slots,\n\t\t      struct rcom_slot *ro0, struct dlm_slot *array,\n\t\t      int array_size)\n{\n\tchar line[SLOT_DEBUG_LINE];\n\tint len = SLOT_DEBUG_LINE - 1;\n\tint pos = 0;\n\tint ret, i;\n\n\tmemset(line, 0, sizeof(line));\n\n\tif (array) {\n\t\tfor (i = 0; i < array_size; i++) {\n\t\t\tif (!array[i].nodeid)\n\t\t\t\tcontinue;\n\n\t\t\tret = snprintf(line + pos, len - pos, \" %d:%d\",\n\t\t\t\t       array[i].slot, array[i].nodeid);\n\t\t\tif (ret >= len - pos)\n\t\t\t\tbreak;\n\t\t\tpos += ret;\n\t\t}\n\t} else if (ro0) {\n\t\tfor (i = 0; i < num_slots; i++) {\n\t\t\tret = snprintf(line + pos, len - pos, \" %d:%d\",\n\t\t\t\t       ro0[i].ro_slot, ro0[i].ro_nodeid);\n\t\t\tif (ret >= len - pos)\n\t\t\t\tbreak;\n\t\t\tpos += ret;\n\t\t}\n\t}\n\n\tlog_rinfo(ls, \"generation %u slots %d%s\", gen, num_slots, line);\n}",
    "includes": [
      "#include \"lowcomms.h\"",
      "#include \"config.h\"",
      "#include \"rcom.h\"",
      "#include \"recover.h\"",
      "#include \"recoverd.h\"",
      "#include \"member.h\"",
      "#include \"lockspace.h\"",
      "#include \"dlm_internal.h\""
    ],
    "macros_used": [
      "#define SLOT_DEBUG_LINE 128"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "log_rinfo",
          "args": [
            "ls",
            "\"generation %u slots %d%s\"",
            "gen",
            "num_slots",
            "line"
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "line + pos",
            "len - pos",
            "\" %d:%d\"",
            "ro0[i].ro_slot",
            "ro0[i].ro_nodeid"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "line + pos",
            "len - pos",
            "\" %d:%d\"",
            "array[i].slot",
            "array[i].nodeid"
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "line",
            "0",
            "sizeof(line)"
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"lowcomms.h\"\n#include \"config.h\"\n#include \"rcom.h\"\n#include \"recover.h\"\n#include \"recoverd.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\n#define SLOT_DEBUG_LINE 128\n\nstatic void log_slots(struct dlm_ls *ls, uint32_t gen, int num_slots,\n\t\t      struct rcom_slot *ro0, struct dlm_slot *array,\n\t\t      int array_size)\n{\n\tchar line[SLOT_DEBUG_LINE];\n\tint len = SLOT_DEBUG_LINE - 1;\n\tint pos = 0;\n\tint ret, i;\n\n\tmemset(line, 0, sizeof(line));\n\n\tif (array) {\n\t\tfor (i = 0; i < array_size; i++) {\n\t\t\tif (!array[i].nodeid)\n\t\t\t\tcontinue;\n\n\t\t\tret = snprintf(line + pos, len - pos, \" %d:%d\",\n\t\t\t\t       array[i].slot, array[i].nodeid);\n\t\t\tif (ret >= len - pos)\n\t\t\t\tbreak;\n\t\t\tpos += ret;\n\t\t}\n\t} else if (ro0) {\n\t\tfor (i = 0; i < num_slots; i++) {\n\t\t\tret = snprintf(line + pos, len - pos, \" %d:%d\",\n\t\t\t\t       ro0[i].ro_slot, ro0[i].ro_nodeid);\n\t\t\tif (ret >= len - pos)\n\t\t\t\tbreak;\n\t\t\tpos += ret;\n\t\t}\n\t}\n\n\tlog_rinfo(ls, \"generation %u slots %d%s\", gen, num_slots, line);\n}"
  },
  {
    "function_name": "dlm_slots_copy_out",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/member.c",
    "lines": "41-59",
    "snippet": "void dlm_slots_copy_out(struct dlm_ls *ls, struct dlm_rcom *rc)\n{\n\tstruct dlm_slot *slot;\n\tstruct rcom_slot *ro;\n\tint i;\n\n\tro = (struct rcom_slot *)(rc->rc_buf + sizeof(struct rcom_config));\n\n\t/* ls_slots array is sparse, but not rcom_slots */\n\n\tfor (i = 0; i < ls->ls_slots_size; i++) {\n\t\tslot = &ls->ls_slots[i];\n\t\tif (!slot->nodeid)\n\t\t\tcontinue;\n\t\tro->ro_nodeid = cpu_to_le32(slot->nodeid);\n\t\tro->ro_slot = cpu_to_le16(slot->slot);\n\t\tro++;\n\t}\n}",
    "includes": [
      "#include \"lowcomms.h\"",
      "#include \"config.h\"",
      "#include \"rcom.h\"",
      "#include \"recover.h\"",
      "#include \"recoverd.h\"",
      "#include \"member.h\"",
      "#include \"lockspace.h\"",
      "#include \"dlm_internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "slot->slot"
          ],
          "line": 56
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "slot->nodeid"
          ],
          "line": 55
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"lowcomms.h\"\n#include \"config.h\"\n#include \"rcom.h\"\n#include \"recover.h\"\n#include \"recoverd.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nvoid dlm_slots_copy_out(struct dlm_ls *ls, struct dlm_rcom *rc)\n{\n\tstruct dlm_slot *slot;\n\tstruct rcom_slot *ro;\n\tint i;\n\n\tro = (struct rcom_slot *)(rc->rc_buf + sizeof(struct rcom_config));\n\n\t/* ls_slots array is sparse, but not rcom_slots */\n\n\tfor (i = 0; i < ls->ls_slots_size; i++) {\n\t\tslot = &ls->ls_slots[i];\n\t\tif (!slot->nodeid)\n\t\t\tcontinue;\n\t\tro->ro_nodeid = cpu_to_le32(slot->nodeid);\n\t\tro->ro_slot = cpu_to_le16(slot->slot);\n\t\tro++;\n\t}\n}"
  },
  {
    "function_name": "dlm_slot_save",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/member.c",
    "lines": "29-39",
    "snippet": "void dlm_slot_save(struct dlm_ls *ls, struct dlm_rcom *rc,\n\t\t   struct dlm_member *memb)\n{\n\tstruct rcom_config *rf = (struct rcom_config *)rc->rc_buf;\n\n\tif (!dlm_slots_version(&rc->rc_header))\n\t\treturn;\n\n\tmemb->slot = le16_to_cpu(rf->rf_our_slot);\n\tmemb->generation = le32_to_cpu(rf->rf_generation);\n}",
    "includes": [
      "#include \"lowcomms.h\"",
      "#include \"config.h\"",
      "#include \"rcom.h\"",
      "#include \"recover.h\"",
      "#include \"recoverd.h\"",
      "#include \"member.h\"",
      "#include \"lockspace.h\"",
      "#include \"dlm_internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "rf->rf_generation"
          ],
          "line": 38
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "rf->rf_our_slot"
          ],
          "line": 37
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_slots_version",
          "args": [
            "&rc->rc_header"
          ],
          "line": 34
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_slots_version",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/member.c",
          "lines": "22-27",
          "snippet": "int dlm_slots_version(struct dlm_header *h)\n{\n\tif ((h->h_version & 0x0000FFFF) < DLM_HEADER_SLOTS)\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"lowcomms.h\"",
            "#include \"config.h\"",
            "#include \"rcom.h\"",
            "#include \"recover.h\"",
            "#include \"recoverd.h\"",
            "#include \"member.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lowcomms.h\"\n#include \"config.h\"\n#include \"rcom.h\"\n#include \"recover.h\"\n#include \"recoverd.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nint dlm_slots_version(struct dlm_header *h)\n{\n\tif ((h->h_version & 0x0000FFFF) < DLM_HEADER_SLOTS)\n\t\treturn 0;\n\treturn 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"lowcomms.h\"\n#include \"config.h\"\n#include \"rcom.h\"\n#include \"recover.h\"\n#include \"recoverd.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nvoid dlm_slot_save(struct dlm_ls *ls, struct dlm_rcom *rc,\n\t\t   struct dlm_member *memb)\n{\n\tstruct rcom_config *rf = (struct rcom_config *)rc->rc_buf;\n\n\tif (!dlm_slots_version(&rc->rc_header))\n\t\treturn;\n\n\tmemb->slot = le16_to_cpu(rf->rf_our_slot);\n\tmemb->generation = le32_to_cpu(rf->rf_generation);\n}"
  },
  {
    "function_name": "dlm_slots_version",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/member.c",
    "lines": "22-27",
    "snippet": "int dlm_slots_version(struct dlm_header *h)\n{\n\tif ((h->h_version & 0x0000FFFF) < DLM_HEADER_SLOTS)\n\t\treturn 0;\n\treturn 1;\n}",
    "includes": [
      "#include \"lowcomms.h\"",
      "#include \"config.h\"",
      "#include \"rcom.h\"",
      "#include \"recover.h\"",
      "#include \"recoverd.h\"",
      "#include \"member.h\"",
      "#include \"lockspace.h\"",
      "#include \"dlm_internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"lowcomms.h\"\n#include \"config.h\"\n#include \"rcom.h\"\n#include \"recover.h\"\n#include \"recoverd.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nint dlm_slots_version(struct dlm_header *h)\n{\n\tif ((h->h_version & 0x0000FFFF) < DLM_HEADER_SLOTS)\n\t\treturn 0;\n\treturn 1;\n}"
  }
]