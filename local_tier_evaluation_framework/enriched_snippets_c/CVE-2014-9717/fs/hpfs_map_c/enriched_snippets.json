[
  {
    "function_name": "hpfs_fnode_dno",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/map.c",
    "lines": "295-308",
    "snippet": "dnode_secno hpfs_fnode_dno(struct super_block *s, ino_t ino)\n{\n\tstruct buffer_head *bh;\n\tstruct fnode *fnode;\n\tdnode_secno dno;\n\n\tfnode = hpfs_map_fnode(s, ino, &bh);\n\tif (!fnode)\n\t\treturn 0;\n\n\tdno = le32_to_cpu(fnode->u.external[0].disk_secno);\n\tbrelse(bh);\n\treturn dno;\n}",
    "includes": [
      "#include \"hpfs_fn.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 306
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_brelse4",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/buffer.c",
          "lines": "182-190",
          "snippet": "void hpfs_brelse4(struct quad_buffer_head *qbh)\n{\n\tif (unlikely(qbh->data != qbh->bh[0]->b_data))\n\t\tkfree(qbh->data);\n\tbrelse(qbh->bh[0]);\n\tbrelse(qbh->bh[1]);\n\tbrelse(qbh->bh[2]);\n\tbrelse(qbh->bh[3]);\n}",
          "includes": [
            "#include \"hpfs_fn.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid hpfs_brelse4(struct quad_buffer_head *qbh)\n{\n\tif (unlikely(qbh->data != qbh->bh[0]->b_data))\n\t\tkfree(qbh->data);\n\tbrelse(qbh->bh[0]);\n\tbrelse(qbh->bh[1]);\n\tbrelse(qbh->bh[2]);\n\tbrelse(qbh->bh[3]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "fnode->u.external[0].disk_secno"
          ],
          "line": 305
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_map_fnode",
          "args": [
            "s",
            "ino",
            "&bh"
          ],
          "line": 301
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_map_fnode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/map.c",
          "lines": "137-192",
          "snippet": "struct fnode *hpfs_map_fnode(struct super_block *s, ino_t ino, struct buffer_head **bhp)\n{\n\tstruct fnode *fnode;\n\tif (hpfs_sb(s)->sb_chk) if (hpfs_chk_sectors(s, ino, 1, \"fnode\")) {\n\t\treturn NULL;\n\t}\n\tif ((fnode = hpfs_map_sector(s, ino, bhp, FNODE_RD_AHEAD))) {\n\t\tif (hpfs_sb(s)->sb_chk) {\n\t\t\tstruct extended_attribute *ea;\n\t\t\tstruct extended_attribute *ea_end;\n\t\t\tif (le32_to_cpu(fnode->magic) != FNODE_MAGIC) {\n\t\t\t\thpfs_error(s, \"bad magic on fnode %08lx\",\n\t\t\t\t\t(unsigned long)ino);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tif (!fnode_is_dir(fnode)) {\n\t\t\t\tif ((unsigned)fnode->btree.n_used_nodes + (unsigned)fnode->btree.n_free_nodes !=\n\t\t\t\t    (bp_internal(&fnode->btree) ? 12 : 8)) {\n\t\t\t\t\thpfs_error(s,\n\t\t\t\t\t   \"bad number of nodes in fnode %08lx\",\n\t\t\t\t\t    (unsigned long)ino);\n\t\t\t\t\tgoto bail;\n\t\t\t\t}\n\t\t\t\tif (le16_to_cpu(fnode->btree.first_free) !=\n\t\t\t\t    8 + fnode->btree.n_used_nodes * (bp_internal(&fnode->btree) ? 8 : 12)) {\n\t\t\t\t\thpfs_error(s,\n\t\t\t\t\t    \"bad first_free pointer in fnode %08lx\",\n\t\t\t\t\t    (unsigned long)ino);\n\t\t\t\t\tgoto bail;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (le16_to_cpu(fnode->ea_size_s) && (le16_to_cpu(fnode->ea_offs) < 0xc4 ||\n\t\t\t   le16_to_cpu(fnode->ea_offs) + le16_to_cpu(fnode->acl_size_s) + le16_to_cpu(fnode->ea_size_s) > 0x200)) {\n\t\t\t\thpfs_error(s,\n\t\t\t\t\t\"bad EA info in fnode %08lx: ea_offs == %04x ea_size_s == %04x\",\n\t\t\t\t\t(unsigned long)ino,\n\t\t\t\t\tle16_to_cpu(fnode->ea_offs), le16_to_cpu(fnode->ea_size_s));\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tea = fnode_ea(fnode);\n\t\t\tea_end = fnode_end_ea(fnode);\n\t\t\twhile (ea != ea_end) {\n\t\t\t\tif (ea > ea_end) {\n\t\t\t\t\thpfs_error(s, \"bad EA in fnode %08lx\",\n\t\t\t\t\t\t(unsigned long)ino);\n\t\t\t\t\tgoto bail;\n\t\t\t\t}\n\t\t\t\tea = next_ea(ea);\n\t\t\t}\n\t\t}\n\t}\n\treturn fnode;\n\tbail:\n\tbrelse(*bhp);\n\treturn NULL;\n}",
          "includes": [
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n\nstruct fnode *hpfs_map_fnode(struct super_block *s, ino_t ino, struct buffer_head **bhp)\n{\n\tstruct fnode *fnode;\n\tif (hpfs_sb(s)->sb_chk) if (hpfs_chk_sectors(s, ino, 1, \"fnode\")) {\n\t\treturn NULL;\n\t}\n\tif ((fnode = hpfs_map_sector(s, ino, bhp, FNODE_RD_AHEAD))) {\n\t\tif (hpfs_sb(s)->sb_chk) {\n\t\t\tstruct extended_attribute *ea;\n\t\t\tstruct extended_attribute *ea_end;\n\t\t\tif (le32_to_cpu(fnode->magic) != FNODE_MAGIC) {\n\t\t\t\thpfs_error(s, \"bad magic on fnode %08lx\",\n\t\t\t\t\t(unsigned long)ino);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tif (!fnode_is_dir(fnode)) {\n\t\t\t\tif ((unsigned)fnode->btree.n_used_nodes + (unsigned)fnode->btree.n_free_nodes !=\n\t\t\t\t    (bp_internal(&fnode->btree) ? 12 : 8)) {\n\t\t\t\t\thpfs_error(s,\n\t\t\t\t\t   \"bad number of nodes in fnode %08lx\",\n\t\t\t\t\t    (unsigned long)ino);\n\t\t\t\t\tgoto bail;\n\t\t\t\t}\n\t\t\t\tif (le16_to_cpu(fnode->btree.first_free) !=\n\t\t\t\t    8 + fnode->btree.n_used_nodes * (bp_internal(&fnode->btree) ? 8 : 12)) {\n\t\t\t\t\thpfs_error(s,\n\t\t\t\t\t    \"bad first_free pointer in fnode %08lx\",\n\t\t\t\t\t    (unsigned long)ino);\n\t\t\t\t\tgoto bail;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (le16_to_cpu(fnode->ea_size_s) && (le16_to_cpu(fnode->ea_offs) < 0xc4 ||\n\t\t\t   le16_to_cpu(fnode->ea_offs) + le16_to_cpu(fnode->acl_size_s) + le16_to_cpu(fnode->ea_size_s) > 0x200)) {\n\t\t\t\thpfs_error(s,\n\t\t\t\t\t\"bad EA info in fnode %08lx: ea_offs == %04x ea_size_s == %04x\",\n\t\t\t\t\t(unsigned long)ino,\n\t\t\t\t\tle16_to_cpu(fnode->ea_offs), le16_to_cpu(fnode->ea_size_s));\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tea = fnode_ea(fnode);\n\t\t\tea_end = fnode_end_ea(fnode);\n\t\t\twhile (ea != ea_end) {\n\t\t\t\tif (ea > ea_end) {\n\t\t\t\t\thpfs_error(s, \"bad EA in fnode %08lx\",\n\t\t\t\t\t\t(unsigned long)ino);\n\t\t\t\t\tgoto bail;\n\t\t\t\t}\n\t\t\t\tea = next_ea(ea);\n\t\t\t}\n\t\t}\n\t}\n\treturn fnode;\n\tbail:\n\tbrelse(*bhp);\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hpfs_fn.h\"\n\ndnode_secno hpfs_fnode_dno(struct super_block *s, ino_t ino)\n{\n\tstruct buffer_head *bh;\n\tstruct fnode *fnode;\n\tdnode_secno dno;\n\n\tfnode = hpfs_map_fnode(s, ino, &bh);\n\tif (!fnode)\n\t\treturn 0;\n\n\tdno = le32_to_cpu(fnode->u.external[0].disk_secno);\n\tbrelse(bh);\n\treturn dno;\n}"
  },
  {
    "function_name": "hpfs_map_dnode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/map.c",
    "lines": "229-293",
    "snippet": "struct dnode *hpfs_map_dnode(struct super_block *s, unsigned secno,\n\t\t\t     struct quad_buffer_head *qbh)\n{\n\tstruct dnode *dnode;\n\tif (hpfs_sb(s)->sb_chk) {\n\t\tif (hpfs_chk_sectors(s, secno, 4, \"dnode\")) return NULL;\n\t\tif (secno & 3) {\n\t\t\thpfs_error(s, \"dnode %08x not byte-aligned\", secno);\n\t\t\treturn NULL;\n\t\t}\t\n\t}\n\tif ((dnode = hpfs_map_4sectors(s, secno, qbh, DNODE_RD_AHEAD)))\n\t\tif (hpfs_sb(s)->sb_chk) {\n\t\t\tunsigned p, pp = 0;\n\t\t\tunsigned char *d = (unsigned char *)dnode;\n\t\t\tint b = 0;\n\t\t\tif (le32_to_cpu(dnode->magic) != DNODE_MAGIC) {\n\t\t\t\thpfs_error(s, \"bad magic on dnode %08x\", secno);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tif (le32_to_cpu(dnode->self) != secno)\n\t\t\t\thpfs_error(s, \"bad self pointer on dnode %08x self = %08x\", secno, le32_to_cpu(dnode->self));\n\t\t\t/* Check dirents - bad dirents would cause infinite\n\t\t\t   loops or shooting to memory */\n\t\t\tif (le32_to_cpu(dnode->first_free) > 2048) {\n\t\t\t\thpfs_error(s, \"dnode %08x has first_free == %08x\", secno, le32_to_cpu(dnode->first_free));\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tfor (p = 20; p < le32_to_cpu(dnode->first_free); p += d[p] + (d[p+1] << 8)) {\n\t\t\t\tstruct hpfs_dirent *de = (struct hpfs_dirent *)((char *)dnode + p);\n\t\t\t\tif (le16_to_cpu(de->length) > 292 || (le16_to_cpu(de->length) < 32) || (le16_to_cpu(de->length) & 3) || p + le16_to_cpu(de->length) > 2048) {\n\t\t\t\t\thpfs_error(s, \"bad dirent size in dnode %08x, dirent %03x, last %03x\", secno, p, pp);\n\t\t\t\t\tgoto bail;\n\t\t\t\t}\n\t\t\t\tif (((31 + de->namelen + de->down*4 + 3) & ~3) != le16_to_cpu(de->length)) {\n\t\t\t\t\tif (((31 + de->namelen + de->down*4 + 3) & ~3) < le16_to_cpu(de->length) && s->s_flags & MS_RDONLY) goto ok;\n\t\t\t\t\thpfs_error(s, \"namelen does not match dirent size in dnode %08x, dirent %03x, last %03x\", secno, p, pp);\n\t\t\t\t\tgoto bail;\n\t\t\t\t}\n\t\t\t\tok:\n\t\t\t\tif (hpfs_sb(s)->sb_chk >= 2) b |= 1 << de->down;\n\t\t\t\tif (de->down) if (de_down_pointer(de) < 0x10) {\n\t\t\t\t\thpfs_error(s, \"bad down pointer in dnode %08x, dirent %03x, last %03x\", secno, p, pp);\n\t\t\t\t\tgoto bail;\n\t\t\t\t}\n\t\t\t\tpp = p;\n\t\t\t\t\n\t\t\t}\n\t\t\tif (p != le32_to_cpu(dnode->first_free)) {\n\t\t\t\thpfs_error(s, \"size on last dirent does not match first_free; dnode %08x\", secno);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tif (d[pp + 30] != 1 || d[pp + 31] != 255) {\n\t\t\t\thpfs_error(s, \"dnode %08x does not end with \\\\377 entry\", secno);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tif (b == 3)\n\t\t\t\tpr_err(\"unbalanced dnode tree, dnode %08x; see hpfs.txt 4 more info\\n\",\n\t\t\t\t\tsecno);\n\t\t}\n\treturn dnode;\n\tbail:\n\thpfs_brelse4(qbh);\n\treturn NULL;\n}",
    "includes": [
      "#include \"hpfs_fn.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hpfs_brelse4",
          "args": [
            "qbh"
          ],
          "line": 291
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_brelse4",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/buffer.c",
          "lines": "182-190",
          "snippet": "void hpfs_brelse4(struct quad_buffer_head *qbh)\n{\n\tif (unlikely(qbh->data != qbh->bh[0]->b_data))\n\t\tkfree(qbh->data);\n\tbrelse(qbh->bh[0]);\n\tbrelse(qbh->bh[1]);\n\tbrelse(qbh->bh[2]);\n\tbrelse(qbh->bh[3]);\n}",
          "includes": [
            "#include \"hpfs_fn.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid hpfs_brelse4(struct quad_buffer_head *qbh)\n{\n\tif (unlikely(qbh->data != qbh->bh[0]->b_data))\n\t\tkfree(qbh->data);\n\tbrelse(qbh->bh[0]);\n\tbrelse(qbh->bh[1]);\n\tbrelse(qbh->bh[2]);\n\tbrelse(qbh->bh[3]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"unbalanced dnode tree, dnode %08x; see hpfs.txt 4 more info\\n\"",
            "secno"
          ],
          "line": 286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hpfs_error",
          "args": [
            "s",
            "\"dnode %08x does not end with \\\\377 entry\"",
            "secno"
          ],
          "line": 282
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/super.c",
          "lines": "57-86",
          "snippet": "void hpfs_error(struct super_block *s, const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvsnprintf(err_buf, sizeof(err_buf), fmt, args);\n\tva_end(args);\n\n\tpr_err(\"filesystem error: %s\", err_buf);\n\tif (!hpfs_sb(s)->sb_was_error) {\n\t\tif (hpfs_sb(s)->sb_err == 2) {\n\t\t\tpr_cont(\"; crashing the system because you wanted it\\n\");\n\t\t\tmark_dirty(s, 0);\n\t\t\tpanic(\"HPFS panic\");\n\t\t} else if (hpfs_sb(s)->sb_err == 1) {\n\t\t\tif (s->s_flags & MS_RDONLY)\n\t\t\t\tpr_cont(\"; already mounted read-only\\n\");\n\t\t\telse {\n\t\t\t\tpr_cont(\"; remounting read-only\\n\");\n\t\t\t\tmark_dirty(s, 0);\n\t\t\t\ts->s_flags |= MS_RDONLY;\n\t\t\t}\n\t\t} else if (s->s_flags & MS_RDONLY)\n\t\t\t\tpr_cont(\"; going on - but anything won't be destroyed because it's read-only\\n\");\n\t\telse\n\t\t\tpr_cont(\"; corrupted filesystem mounted read/write - your computer will explode within 20 seconds ... but you wanted it so!\\n\");\n\t} else\n\t\tpr_cont(\"\\n\");\n\thpfs_sb(s)->sb_was_error = 1;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/sched.h>",
            "#include <linux/magic.h>",
            "#include <linux/statfs.h>",
            "#include <linux/init.h>",
            "#include <linux/parser.h>",
            "#include <linux/module.h>",
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static char err_buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/bitmap.h>\n#include <linux/sched.h>\n#include <linux/magic.h>\n#include <linux/statfs.h>\n#include <linux/init.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include \"hpfs_fn.h\"\n\nstatic char err_buf[1024];\n\nvoid hpfs_error(struct super_block *s, const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvsnprintf(err_buf, sizeof(err_buf), fmt, args);\n\tva_end(args);\n\n\tpr_err(\"filesystem error: %s\", err_buf);\n\tif (!hpfs_sb(s)->sb_was_error) {\n\t\tif (hpfs_sb(s)->sb_err == 2) {\n\t\t\tpr_cont(\"; crashing the system because you wanted it\\n\");\n\t\t\tmark_dirty(s, 0);\n\t\t\tpanic(\"HPFS panic\");\n\t\t} else if (hpfs_sb(s)->sb_err == 1) {\n\t\t\tif (s->s_flags & MS_RDONLY)\n\t\t\t\tpr_cont(\"; already mounted read-only\\n\");\n\t\t\telse {\n\t\t\t\tpr_cont(\"; remounting read-only\\n\");\n\t\t\t\tmark_dirty(s, 0);\n\t\t\t\ts->s_flags |= MS_RDONLY;\n\t\t\t}\n\t\t} else if (s->s_flags & MS_RDONLY)\n\t\t\t\tpr_cont(\"; going on - but anything won't be destroyed because it's read-only\\n\");\n\t\telse\n\t\t\tpr_cont(\"; corrupted filesystem mounted read/write - your computer will explode within 20 seconds ... but you wanted it so!\\n\");\n\t} else\n\t\tpr_cont(\"\\n\");\n\thpfs_sb(s)->sb_was_error = 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "dnode->first_free"
          ],
          "line": 277
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "de_down_pointer",
          "args": [
            "de"
          ],
          "line": 270
        },
        "resolved": true,
        "details": {
          "function_name": "de_down_pointer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "100-104",
          "snippet": "static inline dnode_secno de_down_pointer (struct hpfs_dirent *de)\n{\n  CHKCOND(de->down,(\"HPFS: de_down_pointer: !de->down\\n\"));\n  return le32_to_cpu(*(__le32 *) ((void *) de + le16_to_cpu(de->length) - 4));\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_add_dirent(struct inode *, const unsigned char *, unsigned,\n\t\t    struct hpfs_dirent *);",
            "void hpfs_count_dnodes(struct super_block *, dnode_secno, int *, int *, int *);",
            "void hpfs_remove_dtree(struct super_block *, dnode_secno);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_add_dirent(struct inode *, const unsigned char *, unsigned,\n\t\t    struct hpfs_dirent *);\nvoid hpfs_count_dnodes(struct super_block *, dnode_secno, int *, int *, int *);\nvoid hpfs_remove_dtree(struct super_block *, dnode_secno);\n\nstatic inline dnode_secno de_down_pointer (struct hpfs_dirent *de)\n{\n  CHKCOND(de->down,(\"HPFS: de_down_pointer: !de->down\\n\"));\n  return le32_to_cpu(*(__le32 *) ((void *) de + le16_to_cpu(de->length) - 4));\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_sb",
          "args": [
            "s"
          ],
          "line": 269
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_sb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "310-313",
          "snippet": "static inline struct hpfs_sb_info *hpfs_sb(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_check_free_dnodes(struct super_block *, int);",
            "void hpfs_prefetch_sectors(struct super_block *, unsigned, int);",
            "void hpfs_prefetch_bitmap(struct super_block *, unsigned);",
            "unsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);",
            "int hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);",
            "void hpfs_error(struct super_block *, const char *, ...);",
            "int hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);",
            "unsigned hpfs_get_free_dnodes(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_check_free_dnodes(struct super_block *, int);\nvoid hpfs_prefetch_sectors(struct super_block *, unsigned, int);\nvoid hpfs_prefetch_bitmap(struct super_block *, unsigned);\nunsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);\nint hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);\nvoid hpfs_error(struct super_block *, const char *, ...);\nint hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);\nunsigned hpfs_get_free_dnodes(struct super_block *);\n\nstatic inline struct hpfs_sb_info *hpfs_sb(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "de->length"
          ],
          "line": 264
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_map_4sectors",
          "args": [
            "s",
            "secno",
            "qbh",
            "DNODE_RD_AHEAD"
          ],
          "line": 240
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_map_4sectors",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/buffer.c",
          "lines": "86-136",
          "snippet": "void *hpfs_map_4sectors(struct super_block *s, unsigned secno, struct quad_buffer_head *qbh,\n\t\t   int ahead)\n{\n\tchar *data;\n\n\thpfs_lock_assert(s);\n\n\tcond_resched();\n\n\tif (secno & 3) {\n\t\tpr_err(\"%s(): unaligned read\\n\", __func__);\n\t\treturn NULL;\n\t}\n\n\thpfs_prefetch_sectors(s, secno, 4 + ahead);\n\n\tif (!(qbh->bh[0] = sb_bread(s, secno + 0))) goto bail0;\n\tif (!(qbh->bh[1] = sb_bread(s, secno + 1))) goto bail1;\n\tif (!(qbh->bh[2] = sb_bread(s, secno + 2))) goto bail2;\n\tif (!(qbh->bh[3] = sb_bread(s, secno + 3))) goto bail3;\n\n\tif (likely(qbh->bh[1]->b_data == qbh->bh[0]->b_data + 1 * 512) &&\n\t    likely(qbh->bh[2]->b_data == qbh->bh[0]->b_data + 2 * 512) &&\n\t    likely(qbh->bh[3]->b_data == qbh->bh[0]->b_data + 3 * 512)) {\n\t\treturn qbh->data = qbh->bh[0]->b_data;\n\t}\n\n\tqbh->data = data = kmalloc(2048, GFP_NOFS);\n\tif (!data) {\n\t\tpr_err(\"%s(): out of memory\\n\", __func__);\n\t\tgoto bail4;\n\t}\n\n\tmemcpy(data + 0 * 512, qbh->bh[0]->b_data, 512);\n\tmemcpy(data + 1 * 512, qbh->bh[1]->b_data, 512);\n\tmemcpy(data + 2 * 512, qbh->bh[2]->b_data, 512);\n\tmemcpy(data + 3 * 512, qbh->bh[3]->b_data, 512);\n\n\treturn data;\n\n bail4:\n\tbrelse(qbh->bh[3]);\n bail3:\n\tbrelse(qbh->bh[2]);\n bail2:\n\tbrelse(qbh->bh[1]);\n bail1:\n\tbrelse(qbh->bh[0]);\n bail0:\n\treturn NULL;\n}",
          "includes": [
            "#include \"hpfs_fn.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid *hpfs_map_4sectors(struct super_block *s, unsigned secno, struct quad_buffer_head *qbh,\n\t\t   int ahead)\n{\n\tchar *data;\n\n\thpfs_lock_assert(s);\n\n\tcond_resched();\n\n\tif (secno & 3) {\n\t\tpr_err(\"%s(): unaligned read\\n\", __func__);\n\t\treturn NULL;\n\t}\n\n\thpfs_prefetch_sectors(s, secno, 4 + ahead);\n\n\tif (!(qbh->bh[0] = sb_bread(s, secno + 0))) goto bail0;\n\tif (!(qbh->bh[1] = sb_bread(s, secno + 1))) goto bail1;\n\tif (!(qbh->bh[2] = sb_bread(s, secno + 2))) goto bail2;\n\tif (!(qbh->bh[3] = sb_bread(s, secno + 3))) goto bail3;\n\n\tif (likely(qbh->bh[1]->b_data == qbh->bh[0]->b_data + 1 * 512) &&\n\t    likely(qbh->bh[2]->b_data == qbh->bh[0]->b_data + 2 * 512) &&\n\t    likely(qbh->bh[3]->b_data == qbh->bh[0]->b_data + 3 * 512)) {\n\t\treturn qbh->data = qbh->bh[0]->b_data;\n\t}\n\n\tqbh->data = data = kmalloc(2048, GFP_NOFS);\n\tif (!data) {\n\t\tpr_err(\"%s(): out of memory\\n\", __func__);\n\t\tgoto bail4;\n\t}\n\n\tmemcpy(data + 0 * 512, qbh->bh[0]->b_data, 512);\n\tmemcpy(data + 1 * 512, qbh->bh[1]->b_data, 512);\n\tmemcpy(data + 2 * 512, qbh->bh[2]->b_data, 512);\n\tmemcpy(data + 3 * 512, qbh->bh[3]->b_data, 512);\n\n\treturn data;\n\n bail4:\n\tbrelse(qbh->bh[3]);\n bail3:\n\tbrelse(qbh->bh[2]);\n bail2:\n\tbrelse(qbh->bh[1]);\n bail1:\n\tbrelse(qbh->bh[0]);\n bail0:\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_chk_sectors",
          "args": [
            "s",
            "secno",
            "4",
            "\"dnode\""
          ],
          "line": 234
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_chk_sectors",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/alloc.c",
          "lines": "99-112",
          "snippet": "int hpfs_chk_sectors(struct super_block *s, secno start, int len, char *msg)\n{\n\tif (start + len < start || start < 0x12 ||\n\t    start + len > hpfs_sb(s)->sb_fs_size) {\n\t    \thpfs_error(s, \"sector(s) '%s' badly placed at %08x\", msg, start);\n\t\treturn 1;\n\t}\n\tif (hpfs_sb(s)->sb_chk>=2) {\n\t\tint i;\n\t\tfor (i = 0; i < len; i++)\n\t\t\tif (chk_if_allocated(s, start + i, msg)) return 1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n\nint hpfs_chk_sectors(struct super_block *s, secno start, int len, char *msg)\n{\n\tif (start + len < start || start < 0x12 ||\n\t    start + len > hpfs_sb(s)->sb_fs_size) {\n\t    \thpfs_error(s, \"sector(s) '%s' badly placed at %08x\", msg, start);\n\t\treturn 1;\n\t}\n\tif (hpfs_sb(s)->sb_chk>=2) {\n\t\tint i;\n\t\tfor (i = 0; i < len; i++)\n\t\t\tif (chk_if_allocated(s, start + i, msg)) return 1;\n\t}\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hpfs_fn.h\"\n\nstruct dnode *hpfs_map_dnode(struct super_block *s, unsigned secno,\n\t\t\t     struct quad_buffer_head *qbh)\n{\n\tstruct dnode *dnode;\n\tif (hpfs_sb(s)->sb_chk) {\n\t\tif (hpfs_chk_sectors(s, secno, 4, \"dnode\")) return NULL;\n\t\tif (secno & 3) {\n\t\t\thpfs_error(s, \"dnode %08x not byte-aligned\", secno);\n\t\t\treturn NULL;\n\t\t}\t\n\t}\n\tif ((dnode = hpfs_map_4sectors(s, secno, qbh, DNODE_RD_AHEAD)))\n\t\tif (hpfs_sb(s)->sb_chk) {\n\t\t\tunsigned p, pp = 0;\n\t\t\tunsigned char *d = (unsigned char *)dnode;\n\t\t\tint b = 0;\n\t\t\tif (le32_to_cpu(dnode->magic) != DNODE_MAGIC) {\n\t\t\t\thpfs_error(s, \"bad magic on dnode %08x\", secno);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tif (le32_to_cpu(dnode->self) != secno)\n\t\t\t\thpfs_error(s, \"bad self pointer on dnode %08x self = %08x\", secno, le32_to_cpu(dnode->self));\n\t\t\t/* Check dirents - bad dirents would cause infinite\n\t\t\t   loops or shooting to memory */\n\t\t\tif (le32_to_cpu(dnode->first_free) > 2048) {\n\t\t\t\thpfs_error(s, \"dnode %08x has first_free == %08x\", secno, le32_to_cpu(dnode->first_free));\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tfor (p = 20; p < le32_to_cpu(dnode->first_free); p += d[p] + (d[p+1] << 8)) {\n\t\t\t\tstruct hpfs_dirent *de = (struct hpfs_dirent *)((char *)dnode + p);\n\t\t\t\tif (le16_to_cpu(de->length) > 292 || (le16_to_cpu(de->length) < 32) || (le16_to_cpu(de->length) & 3) || p + le16_to_cpu(de->length) > 2048) {\n\t\t\t\t\thpfs_error(s, \"bad dirent size in dnode %08x, dirent %03x, last %03x\", secno, p, pp);\n\t\t\t\t\tgoto bail;\n\t\t\t\t}\n\t\t\t\tif (((31 + de->namelen + de->down*4 + 3) & ~3) != le16_to_cpu(de->length)) {\n\t\t\t\t\tif (((31 + de->namelen + de->down*4 + 3) & ~3) < le16_to_cpu(de->length) && s->s_flags & MS_RDONLY) goto ok;\n\t\t\t\t\thpfs_error(s, \"namelen does not match dirent size in dnode %08x, dirent %03x, last %03x\", secno, p, pp);\n\t\t\t\t\tgoto bail;\n\t\t\t\t}\n\t\t\t\tok:\n\t\t\t\tif (hpfs_sb(s)->sb_chk >= 2) b |= 1 << de->down;\n\t\t\t\tif (de->down) if (de_down_pointer(de) < 0x10) {\n\t\t\t\t\thpfs_error(s, \"bad down pointer in dnode %08x, dirent %03x, last %03x\", secno, p, pp);\n\t\t\t\t\tgoto bail;\n\t\t\t\t}\n\t\t\t\tpp = p;\n\t\t\t\t\n\t\t\t}\n\t\t\tif (p != le32_to_cpu(dnode->first_free)) {\n\t\t\t\thpfs_error(s, \"size on last dirent does not match first_free; dnode %08x\", secno);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tif (d[pp + 30] != 1 || d[pp + 31] != 255) {\n\t\t\t\thpfs_error(s, \"dnode %08x does not end with \\\\377 entry\", secno);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tif (b == 3)\n\t\t\t\tpr_err(\"unbalanced dnode tree, dnode %08x; see hpfs.txt 4 more info\\n\",\n\t\t\t\t\tsecno);\n\t\t}\n\treturn dnode;\n\tbail:\n\thpfs_brelse4(qbh);\n\treturn NULL;\n}"
  },
  {
    "function_name": "hpfs_map_anode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/map.c",
    "lines": "194-223",
    "snippet": "struct anode *hpfs_map_anode(struct super_block *s, anode_secno ano, struct buffer_head **bhp)\n{\n\tstruct anode *anode;\n\tif (hpfs_sb(s)->sb_chk) if (hpfs_chk_sectors(s, ano, 1, \"anode\")) return NULL;\n\tif ((anode = hpfs_map_sector(s, ano, bhp, ANODE_RD_AHEAD)))\n\t\tif (hpfs_sb(s)->sb_chk) {\n\t\t\tif (le32_to_cpu(anode->magic) != ANODE_MAGIC) {\n\t\t\t\thpfs_error(s, \"bad magic on anode %08x\", ano);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tif (le32_to_cpu(anode->self) != ano) {\n\t\t\t\thpfs_error(s, \"self pointer invalid on anode %08x\", ano);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tif ((unsigned)anode->btree.n_used_nodes + (unsigned)anode->btree.n_free_nodes !=\n\t\t\t    (bp_internal(&anode->btree) ? 60 : 40)) {\n\t\t\t\thpfs_error(s, \"bad number of nodes in anode %08x\", ano);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tif (le16_to_cpu(anode->btree.first_free) !=\n\t\t\t    8 + anode->btree.n_used_nodes * (bp_internal(&anode->btree) ? 8 : 12)) {\n\t\t\t\thpfs_error(s, \"bad first_free pointer in anode %08x\", ano);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t}\n\treturn anode;\n\tbail:\n\tbrelse(*bhp);\n\treturn NULL;\n}",
    "includes": [
      "#include \"hpfs_fn.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "*bhp"
          ],
          "line": 221
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_brelse4",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/buffer.c",
          "lines": "182-190",
          "snippet": "void hpfs_brelse4(struct quad_buffer_head *qbh)\n{\n\tif (unlikely(qbh->data != qbh->bh[0]->b_data))\n\t\tkfree(qbh->data);\n\tbrelse(qbh->bh[0]);\n\tbrelse(qbh->bh[1]);\n\tbrelse(qbh->bh[2]);\n\tbrelse(qbh->bh[3]);\n}",
          "includes": [
            "#include \"hpfs_fn.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid hpfs_brelse4(struct quad_buffer_head *qbh)\n{\n\tif (unlikely(qbh->data != qbh->bh[0]->b_data))\n\t\tkfree(qbh->data);\n\tbrelse(qbh->bh[0]);\n\tbrelse(qbh->bh[1]);\n\tbrelse(qbh->bh[2]);\n\tbrelse(qbh->bh[3]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_error",
          "args": [
            "s",
            "\"bad first_free pointer in anode %08x\"",
            "ano"
          ],
          "line": 215
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/super.c",
          "lines": "57-86",
          "snippet": "void hpfs_error(struct super_block *s, const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvsnprintf(err_buf, sizeof(err_buf), fmt, args);\n\tva_end(args);\n\n\tpr_err(\"filesystem error: %s\", err_buf);\n\tif (!hpfs_sb(s)->sb_was_error) {\n\t\tif (hpfs_sb(s)->sb_err == 2) {\n\t\t\tpr_cont(\"; crashing the system because you wanted it\\n\");\n\t\t\tmark_dirty(s, 0);\n\t\t\tpanic(\"HPFS panic\");\n\t\t} else if (hpfs_sb(s)->sb_err == 1) {\n\t\t\tif (s->s_flags & MS_RDONLY)\n\t\t\t\tpr_cont(\"; already mounted read-only\\n\");\n\t\t\telse {\n\t\t\t\tpr_cont(\"; remounting read-only\\n\");\n\t\t\t\tmark_dirty(s, 0);\n\t\t\t\ts->s_flags |= MS_RDONLY;\n\t\t\t}\n\t\t} else if (s->s_flags & MS_RDONLY)\n\t\t\t\tpr_cont(\"; going on - but anything won't be destroyed because it's read-only\\n\");\n\t\telse\n\t\t\tpr_cont(\"; corrupted filesystem mounted read/write - your computer will explode within 20 seconds ... but you wanted it so!\\n\");\n\t} else\n\t\tpr_cont(\"\\n\");\n\thpfs_sb(s)->sb_was_error = 1;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/sched.h>",
            "#include <linux/magic.h>",
            "#include <linux/statfs.h>",
            "#include <linux/init.h>",
            "#include <linux/parser.h>",
            "#include <linux/module.h>",
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static char err_buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/bitmap.h>\n#include <linux/sched.h>\n#include <linux/magic.h>\n#include <linux/statfs.h>\n#include <linux/init.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include \"hpfs_fn.h\"\n\nstatic char err_buf[1024];\n\nvoid hpfs_error(struct super_block *s, const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvsnprintf(err_buf, sizeof(err_buf), fmt, args);\n\tva_end(args);\n\n\tpr_err(\"filesystem error: %s\", err_buf);\n\tif (!hpfs_sb(s)->sb_was_error) {\n\t\tif (hpfs_sb(s)->sb_err == 2) {\n\t\t\tpr_cont(\"; crashing the system because you wanted it\\n\");\n\t\t\tmark_dirty(s, 0);\n\t\t\tpanic(\"HPFS panic\");\n\t\t} else if (hpfs_sb(s)->sb_err == 1) {\n\t\t\tif (s->s_flags & MS_RDONLY)\n\t\t\t\tpr_cont(\"; already mounted read-only\\n\");\n\t\t\telse {\n\t\t\t\tpr_cont(\"; remounting read-only\\n\");\n\t\t\t\tmark_dirty(s, 0);\n\t\t\t\ts->s_flags |= MS_RDONLY;\n\t\t\t}\n\t\t} else if (s->s_flags & MS_RDONLY)\n\t\t\t\tpr_cont(\"; going on - but anything won't be destroyed because it's read-only\\n\");\n\t\telse\n\t\t\tpr_cont(\"; corrupted filesystem mounted read/write - your computer will explode within 20 seconds ... but you wanted it so!\\n\");\n\t} else\n\t\tpr_cont(\"\\n\");\n\thpfs_sb(s)->sb_was_error = 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bp_internal",
          "args": [
            "&anode->btree"
          ],
          "line": 214
        },
        "resolved": true,
        "details": {
          "function_name": "bp_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs.h",
          "lines": "417-420",
          "snippet": "static inline bool bp_internal(struct bplus_header *bp)\n{\n\treturn bp->flags & BP_internal;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline bool bp_internal(struct bplus_header *bp)\n{\n\treturn bp->flags & BP_internal;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "anode->btree.first_free"
          ],
          "line": 213
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "anode->self"
          ],
          "line": 204
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_sb",
          "args": [
            "s"
          ],
          "line": 199
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_sb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "310-313",
          "snippet": "static inline struct hpfs_sb_info *hpfs_sb(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_check_free_dnodes(struct super_block *, int);",
            "void hpfs_prefetch_sectors(struct super_block *, unsigned, int);",
            "void hpfs_prefetch_bitmap(struct super_block *, unsigned);",
            "unsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);",
            "int hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);",
            "void hpfs_error(struct super_block *, const char *, ...);",
            "int hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);",
            "unsigned hpfs_get_free_dnodes(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_check_free_dnodes(struct super_block *, int);\nvoid hpfs_prefetch_sectors(struct super_block *, unsigned, int);\nvoid hpfs_prefetch_bitmap(struct super_block *, unsigned);\nunsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);\nint hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);\nvoid hpfs_error(struct super_block *, const char *, ...);\nint hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);\nunsigned hpfs_get_free_dnodes(struct super_block *);\n\nstatic inline struct hpfs_sb_info *hpfs_sb(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_map_sector",
          "args": [
            "s",
            "ano",
            "bhp",
            "ANODE_RD_AHEAD"
          ],
          "line": 198
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_map_sector",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/buffer.c",
          "lines": "43-61",
          "snippet": "void *hpfs_map_sector(struct super_block *s, unsigned secno, struct buffer_head **bhp,\n\t\t int ahead)\n{\n\tstruct buffer_head *bh;\n\n\thpfs_lock_assert(s);\n\n\thpfs_prefetch_sectors(s, secno, ahead);\n\n\tcond_resched();\n\n\t*bhp = bh = sb_bread(s, secno);\n\tif (bh != NULL)\n\t\treturn bh->b_data;\n\telse {\n\t\tpr_err(\"%s(): read error\\n\", __func__);\n\t\treturn NULL;\n\t}\n}",
          "includes": [
            "#include \"hpfs_fn.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid *hpfs_map_sector(struct super_block *s, unsigned secno, struct buffer_head **bhp,\n\t\t int ahead)\n{\n\tstruct buffer_head *bh;\n\n\thpfs_lock_assert(s);\n\n\thpfs_prefetch_sectors(s, secno, ahead);\n\n\tcond_resched();\n\n\t*bhp = bh = sb_bread(s, secno);\n\tif (bh != NULL)\n\t\treturn bh->b_data;\n\telse {\n\t\tpr_err(\"%s(): read error\\n\", __func__);\n\t\treturn NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_chk_sectors",
          "args": [
            "s",
            "ano",
            "1",
            "\"anode\""
          ],
          "line": 197
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_chk_sectors",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/alloc.c",
          "lines": "99-112",
          "snippet": "int hpfs_chk_sectors(struct super_block *s, secno start, int len, char *msg)\n{\n\tif (start + len < start || start < 0x12 ||\n\t    start + len > hpfs_sb(s)->sb_fs_size) {\n\t    \thpfs_error(s, \"sector(s) '%s' badly placed at %08x\", msg, start);\n\t\treturn 1;\n\t}\n\tif (hpfs_sb(s)->sb_chk>=2) {\n\t\tint i;\n\t\tfor (i = 0; i < len; i++)\n\t\t\tif (chk_if_allocated(s, start + i, msg)) return 1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n\nint hpfs_chk_sectors(struct super_block *s, secno start, int len, char *msg)\n{\n\tif (start + len < start || start < 0x12 ||\n\t    start + len > hpfs_sb(s)->sb_fs_size) {\n\t    \thpfs_error(s, \"sector(s) '%s' badly placed at %08x\", msg, start);\n\t\treturn 1;\n\t}\n\tif (hpfs_sb(s)->sb_chk>=2) {\n\t\tint i;\n\t\tfor (i = 0; i < len; i++)\n\t\t\tif (chk_if_allocated(s, start + i, msg)) return 1;\n\t}\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hpfs_fn.h\"\n\nstruct anode *hpfs_map_anode(struct super_block *s, anode_secno ano, struct buffer_head **bhp)\n{\n\tstruct anode *anode;\n\tif (hpfs_sb(s)->sb_chk) if (hpfs_chk_sectors(s, ano, 1, \"anode\")) return NULL;\n\tif ((anode = hpfs_map_sector(s, ano, bhp, ANODE_RD_AHEAD)))\n\t\tif (hpfs_sb(s)->sb_chk) {\n\t\t\tif (le32_to_cpu(anode->magic) != ANODE_MAGIC) {\n\t\t\t\thpfs_error(s, \"bad magic on anode %08x\", ano);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tif (le32_to_cpu(anode->self) != ano) {\n\t\t\t\thpfs_error(s, \"self pointer invalid on anode %08x\", ano);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tif ((unsigned)anode->btree.n_used_nodes + (unsigned)anode->btree.n_free_nodes !=\n\t\t\t    (bp_internal(&anode->btree) ? 60 : 40)) {\n\t\t\t\thpfs_error(s, \"bad number of nodes in anode %08x\", ano);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tif (le16_to_cpu(anode->btree.first_free) !=\n\t\t\t    8 + anode->btree.n_used_nodes * (bp_internal(&anode->btree) ? 8 : 12)) {\n\t\t\t\thpfs_error(s, \"bad first_free pointer in anode %08x\", ano);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t}\n\treturn anode;\n\tbail:\n\tbrelse(*bhp);\n\treturn NULL;\n}"
  },
  {
    "function_name": "hpfs_map_fnode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/map.c",
    "lines": "137-192",
    "snippet": "struct fnode *hpfs_map_fnode(struct super_block *s, ino_t ino, struct buffer_head **bhp)\n{\n\tstruct fnode *fnode;\n\tif (hpfs_sb(s)->sb_chk) if (hpfs_chk_sectors(s, ino, 1, \"fnode\")) {\n\t\treturn NULL;\n\t}\n\tif ((fnode = hpfs_map_sector(s, ino, bhp, FNODE_RD_AHEAD))) {\n\t\tif (hpfs_sb(s)->sb_chk) {\n\t\t\tstruct extended_attribute *ea;\n\t\t\tstruct extended_attribute *ea_end;\n\t\t\tif (le32_to_cpu(fnode->magic) != FNODE_MAGIC) {\n\t\t\t\thpfs_error(s, \"bad magic on fnode %08lx\",\n\t\t\t\t\t(unsigned long)ino);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tif (!fnode_is_dir(fnode)) {\n\t\t\t\tif ((unsigned)fnode->btree.n_used_nodes + (unsigned)fnode->btree.n_free_nodes !=\n\t\t\t\t    (bp_internal(&fnode->btree) ? 12 : 8)) {\n\t\t\t\t\thpfs_error(s,\n\t\t\t\t\t   \"bad number of nodes in fnode %08lx\",\n\t\t\t\t\t    (unsigned long)ino);\n\t\t\t\t\tgoto bail;\n\t\t\t\t}\n\t\t\t\tif (le16_to_cpu(fnode->btree.first_free) !=\n\t\t\t\t    8 + fnode->btree.n_used_nodes * (bp_internal(&fnode->btree) ? 8 : 12)) {\n\t\t\t\t\thpfs_error(s,\n\t\t\t\t\t    \"bad first_free pointer in fnode %08lx\",\n\t\t\t\t\t    (unsigned long)ino);\n\t\t\t\t\tgoto bail;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (le16_to_cpu(fnode->ea_size_s) && (le16_to_cpu(fnode->ea_offs) < 0xc4 ||\n\t\t\t   le16_to_cpu(fnode->ea_offs) + le16_to_cpu(fnode->acl_size_s) + le16_to_cpu(fnode->ea_size_s) > 0x200)) {\n\t\t\t\thpfs_error(s,\n\t\t\t\t\t\"bad EA info in fnode %08lx: ea_offs == %04x ea_size_s == %04x\",\n\t\t\t\t\t(unsigned long)ino,\n\t\t\t\t\tle16_to_cpu(fnode->ea_offs), le16_to_cpu(fnode->ea_size_s));\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tea = fnode_ea(fnode);\n\t\t\tea_end = fnode_end_ea(fnode);\n\t\t\twhile (ea != ea_end) {\n\t\t\t\tif (ea > ea_end) {\n\t\t\t\t\thpfs_error(s, \"bad EA in fnode %08lx\",\n\t\t\t\t\t\t(unsigned long)ino);\n\t\t\t\t\tgoto bail;\n\t\t\t\t}\n\t\t\t\tea = next_ea(ea);\n\t\t\t}\n\t\t}\n\t}\n\treturn fnode;\n\tbail:\n\tbrelse(*bhp);\n\treturn NULL;\n}",
    "includes": [
      "#include \"hpfs_fn.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "*bhp"
          ],
          "line": 190
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_brelse4",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/buffer.c",
          "lines": "182-190",
          "snippet": "void hpfs_brelse4(struct quad_buffer_head *qbh)\n{\n\tif (unlikely(qbh->data != qbh->bh[0]->b_data))\n\t\tkfree(qbh->data);\n\tbrelse(qbh->bh[0]);\n\tbrelse(qbh->bh[1]);\n\tbrelse(qbh->bh[2]);\n\tbrelse(qbh->bh[3]);\n}",
          "includes": [
            "#include \"hpfs_fn.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid hpfs_brelse4(struct quad_buffer_head *qbh)\n{\n\tif (unlikely(qbh->data != qbh->bh[0]->b_data))\n\t\tkfree(qbh->data);\n\tbrelse(qbh->bh[0]);\n\tbrelse(qbh->bh[1]);\n\tbrelse(qbh->bh[2]);\n\tbrelse(qbh->bh[3]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "next_ea",
          "args": [
            "ea"
          ],
          "line": 184
        },
        "resolved": true,
        "details": {
          "function_name": "next_ea",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "144-147",
          "snippet": "static inline struct extended_attribute *next_ea(struct extended_attribute *ea)\n{\n\treturn (struct extended_attribute *)((char *)ea + 5 + ea->namelen + ea_valuelen(ea));\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nstatic inline struct extended_attribute *next_ea(struct extended_attribute *ea)\n{\n\treturn (struct extended_attribute *)((char *)ea + 5 + ea->namelen + ea_valuelen(ea));\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_error",
          "args": [
            "s",
            "\"bad EA in fnode %08lx\"",
            "(unsigned long)ino"
          ],
          "line": 180
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/super.c",
          "lines": "57-86",
          "snippet": "void hpfs_error(struct super_block *s, const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvsnprintf(err_buf, sizeof(err_buf), fmt, args);\n\tva_end(args);\n\n\tpr_err(\"filesystem error: %s\", err_buf);\n\tif (!hpfs_sb(s)->sb_was_error) {\n\t\tif (hpfs_sb(s)->sb_err == 2) {\n\t\t\tpr_cont(\"; crashing the system because you wanted it\\n\");\n\t\t\tmark_dirty(s, 0);\n\t\t\tpanic(\"HPFS panic\");\n\t\t} else if (hpfs_sb(s)->sb_err == 1) {\n\t\t\tif (s->s_flags & MS_RDONLY)\n\t\t\t\tpr_cont(\"; already mounted read-only\\n\");\n\t\t\telse {\n\t\t\t\tpr_cont(\"; remounting read-only\\n\");\n\t\t\t\tmark_dirty(s, 0);\n\t\t\t\ts->s_flags |= MS_RDONLY;\n\t\t\t}\n\t\t} else if (s->s_flags & MS_RDONLY)\n\t\t\t\tpr_cont(\"; going on - but anything won't be destroyed because it's read-only\\n\");\n\t\telse\n\t\t\tpr_cont(\"; corrupted filesystem mounted read/write - your computer will explode within 20 seconds ... but you wanted it so!\\n\");\n\t} else\n\t\tpr_cont(\"\\n\");\n\thpfs_sb(s)->sb_was_error = 1;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/sched.h>",
            "#include <linux/magic.h>",
            "#include <linux/statfs.h>",
            "#include <linux/init.h>",
            "#include <linux/parser.h>",
            "#include <linux/module.h>",
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static char err_buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/bitmap.h>\n#include <linux/sched.h>\n#include <linux/magic.h>\n#include <linux/statfs.h>\n#include <linux/init.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include \"hpfs_fn.h\"\n\nstatic char err_buf[1024];\n\nvoid hpfs_error(struct super_block *s, const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvsnprintf(err_buf, sizeof(err_buf), fmt, args);\n\tva_end(args);\n\n\tpr_err(\"filesystem error: %s\", err_buf);\n\tif (!hpfs_sb(s)->sb_was_error) {\n\t\tif (hpfs_sb(s)->sb_err == 2) {\n\t\t\tpr_cont(\"; crashing the system because you wanted it\\n\");\n\t\t\tmark_dirty(s, 0);\n\t\t\tpanic(\"HPFS panic\");\n\t\t} else if (hpfs_sb(s)->sb_err == 1) {\n\t\t\tif (s->s_flags & MS_RDONLY)\n\t\t\t\tpr_cont(\"; already mounted read-only\\n\");\n\t\t\telse {\n\t\t\t\tpr_cont(\"; remounting read-only\\n\");\n\t\t\t\tmark_dirty(s, 0);\n\t\t\t\ts->s_flags |= MS_RDONLY;\n\t\t\t}\n\t\t} else if (s->s_flags & MS_RDONLY)\n\t\t\t\tpr_cont(\"; going on - but anything won't be destroyed because it's read-only\\n\");\n\t\telse\n\t\t\tpr_cont(\"; corrupted filesystem mounted read/write - your computer will explode within 20 seconds ... but you wanted it so!\\n\");\n\t} else\n\t\tpr_cont(\"\\n\");\n\thpfs_sb(s)->sb_was_error = 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fnode_end_ea",
          "args": [
            "fnode"
          ],
          "line": 177
        },
        "resolved": true,
        "details": {
          "function_name": "fnode_end_ea",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "134-137",
          "snippet": "static inline struct extended_attribute *fnode_end_ea(struct fnode *fnode)\n{\n\treturn (struct extended_attribute *)((char *)fnode + le16_to_cpu(fnode->ea_offs) + le16_to_cpu(fnode->acl_size_s) + le16_to_cpu(fnode->ea_size_s));\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_read_ea(struct super_block *, struct fnode *, char *, char *, int);",
            "char *hpfs_get_ea(struct super_block *, struct fnode *, char *, int *);",
            "void hpfs_set_ea(struct inode *, struct fnode *, const char *,\n\t\t const char *, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_read_ea(struct super_block *, struct fnode *, char *, char *, int);\nchar *hpfs_get_ea(struct super_block *, struct fnode *, char *, int *);\nvoid hpfs_set_ea(struct inode *, struct fnode *, const char *,\n\t\t const char *, int);\n\nstatic inline struct extended_attribute *fnode_end_ea(struct fnode *fnode)\n{\n\treturn (struct extended_attribute *)((char *)fnode + le16_to_cpu(fnode->ea_offs) + le16_to_cpu(fnode->acl_size_s) + le16_to_cpu(fnode->ea_size_s));\n}"
        }
      },
      {
        "call_info": {
          "callee": "fnode_ea",
          "args": [
            "fnode"
          ],
          "line": 176
        },
        "resolved": true,
        "details": {
          "function_name": "fnode_ea",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "129-132",
          "snippet": "static inline struct extended_attribute *fnode_ea(struct fnode *fnode)\n{\n\treturn (struct extended_attribute *)((char *)fnode + le16_to_cpu(fnode->ea_offs) + le16_to_cpu(fnode->acl_size_s));\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_read_ea(struct super_block *, struct fnode *, char *, char *, int);",
            "char *hpfs_get_ea(struct super_block *, struct fnode *, char *, int *);",
            "void hpfs_set_ea(struct inode *, struct fnode *, const char *,\n\t\t const char *, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_read_ea(struct super_block *, struct fnode *, char *, char *, int);\nchar *hpfs_get_ea(struct super_block *, struct fnode *, char *, int *);\nvoid hpfs_set_ea(struct inode *, struct fnode *, const char *,\n\t\t const char *, int);\n\nstatic inline struct extended_attribute *fnode_ea(struct fnode *fnode)\n{\n\treturn (struct extended_attribute *)((char *)fnode + le16_to_cpu(fnode->ea_offs) + le16_to_cpu(fnode->acl_size_s));\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "fnode->ea_size_s"
          ],
          "line": 173
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bp_internal",
          "args": [
            "&fnode->btree"
          ],
          "line": 161
        },
        "resolved": true,
        "details": {
          "function_name": "bp_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs.h",
          "lines": "417-420",
          "snippet": "static inline bool bp_internal(struct bplus_header *bp)\n{\n\treturn bp->flags & BP_internal;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline bool bp_internal(struct bplus_header *bp)\n{\n\treturn bp->flags & BP_internal;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fnode_is_dir",
          "args": [
            "fnode"
          ],
          "line": 152
        },
        "resolved": true,
        "details": {
          "function_name": "fnode_is_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs.h",
          "lines": "480-483",
          "snippet": "static inline bool fnode_is_dir(struct fnode *p)\n{\n\treturn (p->flags & FNODE_dir) != 0;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline bool fnode_is_dir(struct fnode *p)\n{\n\treturn (p->flags & FNODE_dir) != 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "fnode->magic"
          ],
          "line": 147
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_sb",
          "args": [
            "s"
          ],
          "line": 144
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_sb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "310-313",
          "snippet": "static inline struct hpfs_sb_info *hpfs_sb(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_check_free_dnodes(struct super_block *, int);",
            "void hpfs_prefetch_sectors(struct super_block *, unsigned, int);",
            "void hpfs_prefetch_bitmap(struct super_block *, unsigned);",
            "unsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);",
            "int hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);",
            "void hpfs_error(struct super_block *, const char *, ...);",
            "int hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);",
            "unsigned hpfs_get_free_dnodes(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_check_free_dnodes(struct super_block *, int);\nvoid hpfs_prefetch_sectors(struct super_block *, unsigned, int);\nvoid hpfs_prefetch_bitmap(struct super_block *, unsigned);\nunsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);\nint hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);\nvoid hpfs_error(struct super_block *, const char *, ...);\nint hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);\nunsigned hpfs_get_free_dnodes(struct super_block *);\n\nstatic inline struct hpfs_sb_info *hpfs_sb(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_map_sector",
          "args": [
            "s",
            "ino",
            "bhp",
            "FNODE_RD_AHEAD"
          ],
          "line": 143
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_map_sector",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/buffer.c",
          "lines": "43-61",
          "snippet": "void *hpfs_map_sector(struct super_block *s, unsigned secno, struct buffer_head **bhp,\n\t\t int ahead)\n{\n\tstruct buffer_head *bh;\n\n\thpfs_lock_assert(s);\n\n\thpfs_prefetch_sectors(s, secno, ahead);\n\n\tcond_resched();\n\n\t*bhp = bh = sb_bread(s, secno);\n\tif (bh != NULL)\n\t\treturn bh->b_data;\n\telse {\n\t\tpr_err(\"%s(): read error\\n\", __func__);\n\t\treturn NULL;\n\t}\n}",
          "includes": [
            "#include \"hpfs_fn.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid *hpfs_map_sector(struct super_block *s, unsigned secno, struct buffer_head **bhp,\n\t\t int ahead)\n{\n\tstruct buffer_head *bh;\n\n\thpfs_lock_assert(s);\n\n\thpfs_prefetch_sectors(s, secno, ahead);\n\n\tcond_resched();\n\n\t*bhp = bh = sb_bread(s, secno);\n\tif (bh != NULL)\n\t\treturn bh->b_data;\n\telse {\n\t\tpr_err(\"%s(): read error\\n\", __func__);\n\t\treturn NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_chk_sectors",
          "args": [
            "s",
            "ino",
            "1",
            "\"fnode\""
          ],
          "line": 140
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_chk_sectors",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/alloc.c",
          "lines": "99-112",
          "snippet": "int hpfs_chk_sectors(struct super_block *s, secno start, int len, char *msg)\n{\n\tif (start + len < start || start < 0x12 ||\n\t    start + len > hpfs_sb(s)->sb_fs_size) {\n\t    \thpfs_error(s, \"sector(s) '%s' badly placed at %08x\", msg, start);\n\t\treturn 1;\n\t}\n\tif (hpfs_sb(s)->sb_chk>=2) {\n\t\tint i;\n\t\tfor (i = 0; i < len; i++)\n\t\t\tif (chk_if_allocated(s, start + i, msg)) return 1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n\nint hpfs_chk_sectors(struct super_block *s, secno start, int len, char *msg)\n{\n\tif (start + len < start || start < 0x12 ||\n\t    start + len > hpfs_sb(s)->sb_fs_size) {\n\t    \thpfs_error(s, \"sector(s) '%s' badly placed at %08x\", msg, start);\n\t\treturn 1;\n\t}\n\tif (hpfs_sb(s)->sb_chk>=2) {\n\t\tint i;\n\t\tfor (i = 0; i < len; i++)\n\t\t\tif (chk_if_allocated(s, start + i, msg)) return 1;\n\t}\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hpfs_fn.h\"\n\nstruct fnode *hpfs_map_fnode(struct super_block *s, ino_t ino, struct buffer_head **bhp)\n{\n\tstruct fnode *fnode;\n\tif (hpfs_sb(s)->sb_chk) if (hpfs_chk_sectors(s, ino, 1, \"fnode\")) {\n\t\treturn NULL;\n\t}\n\tif ((fnode = hpfs_map_sector(s, ino, bhp, FNODE_RD_AHEAD))) {\n\t\tif (hpfs_sb(s)->sb_chk) {\n\t\t\tstruct extended_attribute *ea;\n\t\t\tstruct extended_attribute *ea_end;\n\t\t\tif (le32_to_cpu(fnode->magic) != FNODE_MAGIC) {\n\t\t\t\thpfs_error(s, \"bad magic on fnode %08lx\",\n\t\t\t\t\t(unsigned long)ino);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tif (!fnode_is_dir(fnode)) {\n\t\t\t\tif ((unsigned)fnode->btree.n_used_nodes + (unsigned)fnode->btree.n_free_nodes !=\n\t\t\t\t    (bp_internal(&fnode->btree) ? 12 : 8)) {\n\t\t\t\t\thpfs_error(s,\n\t\t\t\t\t   \"bad number of nodes in fnode %08lx\",\n\t\t\t\t\t    (unsigned long)ino);\n\t\t\t\t\tgoto bail;\n\t\t\t\t}\n\t\t\t\tif (le16_to_cpu(fnode->btree.first_free) !=\n\t\t\t\t    8 + fnode->btree.n_used_nodes * (bp_internal(&fnode->btree) ? 8 : 12)) {\n\t\t\t\t\thpfs_error(s,\n\t\t\t\t\t    \"bad first_free pointer in fnode %08lx\",\n\t\t\t\t\t    (unsigned long)ino);\n\t\t\t\t\tgoto bail;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (le16_to_cpu(fnode->ea_size_s) && (le16_to_cpu(fnode->ea_offs) < 0xc4 ||\n\t\t\t   le16_to_cpu(fnode->ea_offs) + le16_to_cpu(fnode->acl_size_s) + le16_to_cpu(fnode->ea_size_s) > 0x200)) {\n\t\t\t\thpfs_error(s,\n\t\t\t\t\t\"bad EA info in fnode %08lx: ea_offs == %04x ea_size_s == %04x\",\n\t\t\t\t\t(unsigned long)ino,\n\t\t\t\t\tle16_to_cpu(fnode->ea_offs), le16_to_cpu(fnode->ea_size_s));\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tea = fnode_ea(fnode);\n\t\t\tea_end = fnode_end_ea(fnode);\n\t\t\twhile (ea != ea_end) {\n\t\t\t\tif (ea > ea_end) {\n\t\t\t\t\thpfs_error(s, \"bad EA in fnode %08lx\",\n\t\t\t\t\t\t(unsigned long)ino);\n\t\t\t\t\tgoto bail;\n\t\t\t\t}\n\t\t\t\tea = next_ea(ea);\n\t\t\t}\n\t\t}\n\t}\n\treturn fnode;\n\tbail:\n\tbrelse(*bhp);\n\treturn NULL;\n}"
  },
  {
    "function_name": "hpfs_load_bitmap_directory",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/map.c",
    "lines": "111-131",
    "snippet": "__le32 *hpfs_load_bitmap_directory(struct super_block *s, secno bmp)\n{\n\tstruct buffer_head *bh;\n\tint n = (hpfs_sb(s)->sb_fs_size + 0x200000 - 1) >> 21;\n\tint i;\n\t__le32 *b;\n\tif (!(b = kmalloc(n * 512, GFP_KERNEL))) {\n\t\tpr_err(\"can't allocate memory for bitmap directory\\n\");\n\t\treturn NULL;\n\t}\t\n\tfor (i=0;i<n;i++) {\n\t\t__le32 *d = hpfs_map_sector(s, bmp+i, &bh, n - i - 1);\n\t\tif (!d) {\n\t\t\tkfree(b);\n\t\t\treturn NULL;\n\t\t}\n\t\tmemcpy((char *)b + 512 * i, d, 512);\n\t\tbrelse(bh);\n\t}\n\treturn b;\n}",
    "includes": [
      "#include \"hpfs_fn.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 128
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_brelse4",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/buffer.c",
          "lines": "182-190",
          "snippet": "void hpfs_brelse4(struct quad_buffer_head *qbh)\n{\n\tif (unlikely(qbh->data != qbh->bh[0]->b_data))\n\t\tkfree(qbh->data);\n\tbrelse(qbh->bh[0]);\n\tbrelse(qbh->bh[1]);\n\tbrelse(qbh->bh[2]);\n\tbrelse(qbh->bh[3]);\n}",
          "includes": [
            "#include \"hpfs_fn.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid hpfs_brelse4(struct quad_buffer_head *qbh)\n{\n\tif (unlikely(qbh->data != qbh->bh[0]->b_data))\n\t\tkfree(qbh->data);\n\tbrelse(qbh->bh[0]);\n\tbrelse(qbh->bh[1]);\n\tbrelse(qbh->bh[2]);\n\tbrelse(qbh->bh[3]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "(char *)b + 512 * i",
            "d",
            "512"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "b"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hpfs_map_sector",
          "args": [
            "s",
            "bmp+i",
            "&bh",
            "n - i - 1"
          ],
          "line": 122
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_map_sector",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/buffer.c",
          "lines": "43-61",
          "snippet": "void *hpfs_map_sector(struct super_block *s, unsigned secno, struct buffer_head **bhp,\n\t\t int ahead)\n{\n\tstruct buffer_head *bh;\n\n\thpfs_lock_assert(s);\n\n\thpfs_prefetch_sectors(s, secno, ahead);\n\n\tcond_resched();\n\n\t*bhp = bh = sb_bread(s, secno);\n\tif (bh != NULL)\n\t\treturn bh->b_data;\n\telse {\n\t\tpr_err(\"%s(): read error\\n\", __func__);\n\t\treturn NULL;\n\t}\n}",
          "includes": [
            "#include \"hpfs_fn.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid *hpfs_map_sector(struct super_block *s, unsigned secno, struct buffer_head **bhp,\n\t\t int ahead)\n{\n\tstruct buffer_head *bh;\n\n\thpfs_lock_assert(s);\n\n\thpfs_prefetch_sectors(s, secno, ahead);\n\n\tcond_resched();\n\n\t*bhp = bh = sb_bread(s, secno);\n\tif (bh != NULL)\n\t\treturn bh->b_data;\n\telse {\n\t\tpr_err(\"%s(): read error\\n\", __func__);\n\t\treturn NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"can't allocate memory for bitmap directory\\n\""
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "n * 512",
            "GFP_KERNEL"
          ],
          "line": 117
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_sb",
          "args": [
            "s"
          ],
          "line": 114
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_sb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "310-313",
          "snippet": "static inline struct hpfs_sb_info *hpfs_sb(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_check_free_dnodes(struct super_block *, int);",
            "void hpfs_prefetch_sectors(struct super_block *, unsigned, int);",
            "void hpfs_prefetch_bitmap(struct super_block *, unsigned);",
            "unsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);",
            "int hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);",
            "void hpfs_error(struct super_block *, const char *, ...);",
            "int hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);",
            "unsigned hpfs_get_free_dnodes(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_check_free_dnodes(struct super_block *, int);\nvoid hpfs_prefetch_sectors(struct super_block *, unsigned, int);\nvoid hpfs_prefetch_bitmap(struct super_block *, unsigned);\nunsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);\nint hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);\nvoid hpfs_error(struct super_block *, const char *, ...);\nint hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);\nunsigned hpfs_get_free_dnodes(struct super_block *);\n\nstatic inline struct hpfs_sb_info *hpfs_sb(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hpfs_fn.h\"\n\n__le32 *hpfs_load_bitmap_directory(struct super_block *s, secno bmp)\n{\n\tstruct buffer_head *bh;\n\tint n = (hpfs_sb(s)->sb_fs_size + 0x200000 - 1) >> 21;\n\tint i;\n\t__le32 *b;\n\tif (!(b = kmalloc(n * 512, GFP_KERNEL))) {\n\t\tpr_err(\"can't allocate memory for bitmap directory\\n\");\n\t\treturn NULL;\n\t}\t\n\tfor (i=0;i<n;i++) {\n\t\t__le32 *d = hpfs_map_sector(s, bmp+i, &bh, n - i - 1);\n\t\tif (!d) {\n\t\t\tkfree(b);\n\t\t\treturn NULL;\n\t\t}\n\t\tmemcpy((char *)b + 512 * i, d, 512);\n\t\tbrelse(bh);\n\t}\n\treturn b;\n}"
  },
  {
    "function_name": "hpfs_load_code_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/map.c",
    "lines": "56-109",
    "snippet": "unsigned char *hpfs_load_code_page(struct super_block *s, secno cps)\n{\n\tstruct buffer_head *bh;\n\tsecno cpds;\n\tunsigned cpi;\n\tunsigned char *ptr;\n\tunsigned char *cp_table;\n\tint i;\n\tstruct code_page_data *cpd;\n\tstruct code_page_directory *cp = hpfs_map_sector(s, cps, &bh, 0);\n\tif (!cp) return NULL;\n\tif (le32_to_cpu(cp->magic) != CP_DIR_MAGIC) {\n\t\tpr_err(\"Code page directory magic doesn't match (magic = %08x)\\n\",\n\t\t\tle32_to_cpu(cp->magic));\n\t\tbrelse(bh);\n\t\treturn NULL;\n\t}\n\tif (!le32_to_cpu(cp->n_code_pages)) {\n\t\tpr_err(\"n_code_pages == 0\\n\");\n\t\tbrelse(bh);\n\t\treturn NULL;\n\t}\n\tcpds = le32_to_cpu(cp->array[0].code_page_data);\n\tcpi = le16_to_cpu(cp->array[0].index);\n\tbrelse(bh);\n\n\tif (cpi >= 3) {\n\t\tpr_err(\"Code page index out of array\\n\");\n\t\treturn NULL;\n\t}\n\t\n\tif (!(cpd = hpfs_map_sector(s, cpds, &bh, 0))) return NULL;\n\tif (le16_to_cpu(cpd->offs[cpi]) > 0x178) {\n\t\tpr_err(\"Code page index out of sector\\n\");\n\t\tbrelse(bh);\n\t\treturn NULL;\n\t}\n\tptr = (unsigned char *)cpd + le16_to_cpu(cpd->offs[cpi]) + 6;\n\tif (!(cp_table = kmalloc(256, GFP_KERNEL))) {\n\t\tpr_err(\"out of memory for code page table\\n\");\n\t\tbrelse(bh);\n\t\treturn NULL;\n\t}\n\tmemcpy(cp_table, ptr, 128);\n\tbrelse(bh);\n\n\t/* Try to build lowercasing table from uppercasing one */\n\n\tfor (i=128; i<256; i++) cp_table[i]=i;\n\tfor (i=128; i<256; i++) if (cp_table[i-128]!=i && cp_table[i-128]>=128)\n\t\tcp_table[cp_table[i-128]] = i;\n\t\n\treturn cp_table;\n}",
    "includes": [
      "#include \"hpfs_fn.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 100
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_brelse4",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/buffer.c",
          "lines": "182-190",
          "snippet": "void hpfs_brelse4(struct quad_buffer_head *qbh)\n{\n\tif (unlikely(qbh->data != qbh->bh[0]->b_data))\n\t\tkfree(qbh->data);\n\tbrelse(qbh->bh[0]);\n\tbrelse(qbh->bh[1]);\n\tbrelse(qbh->bh[2]);\n\tbrelse(qbh->bh[3]);\n}",
          "includes": [
            "#include \"hpfs_fn.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid hpfs_brelse4(struct quad_buffer_head *qbh)\n{\n\tif (unlikely(qbh->data != qbh->bh[0]->b_data))\n\t\tkfree(qbh->data);\n\tbrelse(qbh->bh[0]);\n\tbrelse(qbh->bh[1]);\n\tbrelse(qbh->bh[2]);\n\tbrelse(qbh->bh[3]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "cp_table",
            "ptr",
            "128"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"out of memory for code page table\\n\""
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "256",
            "GFP_KERNEL"
          ],
          "line": 94
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "cpd->offs[cpi]"
          ],
          "line": 93
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Code page index out of sector\\n\""
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hpfs_map_sector",
          "args": [
            "s",
            "cpds",
            "&bh",
            "0"
          ],
          "line": 87
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_map_sector",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/buffer.c",
          "lines": "43-61",
          "snippet": "void *hpfs_map_sector(struct super_block *s, unsigned secno, struct buffer_head **bhp,\n\t\t int ahead)\n{\n\tstruct buffer_head *bh;\n\n\thpfs_lock_assert(s);\n\n\thpfs_prefetch_sectors(s, secno, ahead);\n\n\tcond_resched();\n\n\t*bhp = bh = sb_bread(s, secno);\n\tif (bh != NULL)\n\t\treturn bh->b_data;\n\telse {\n\t\tpr_err(\"%s(): read error\\n\", __func__);\n\t\treturn NULL;\n\t}\n}",
          "includes": [
            "#include \"hpfs_fn.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid *hpfs_map_sector(struct super_block *s, unsigned secno, struct buffer_head **bhp,\n\t\t int ahead)\n{\n\tstruct buffer_head *bh;\n\n\thpfs_lock_assert(s);\n\n\thpfs_prefetch_sectors(s, secno, ahead);\n\n\tcond_resched();\n\n\t*bhp = bh = sb_bread(s, secno);\n\tif (bh != NULL)\n\t\treturn bh->b_data;\n\telse {\n\t\tpr_err(\"%s(): read error\\n\", __func__);\n\t\treturn NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Code page index out of array\\n\""
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "cp->array[0].code_page_data"
          ],
          "line": 78
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"n_code_pages == 0\\n\""
          ],
          "line": 74
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Code page directory magic doesn't match (magic = %08x)\\n\"",
            "le32_to_cpu(cp->magic)"
          ],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"hpfs_fn.h\"\n\nunsigned char *hpfs_load_code_page(struct super_block *s, secno cps)\n{\n\tstruct buffer_head *bh;\n\tsecno cpds;\n\tunsigned cpi;\n\tunsigned char *ptr;\n\tunsigned char *cp_table;\n\tint i;\n\tstruct code_page_data *cpd;\n\tstruct code_page_directory *cp = hpfs_map_sector(s, cps, &bh, 0);\n\tif (!cp) return NULL;\n\tif (le32_to_cpu(cp->magic) != CP_DIR_MAGIC) {\n\t\tpr_err(\"Code page directory magic doesn't match (magic = %08x)\\n\",\n\t\t\tle32_to_cpu(cp->magic));\n\t\tbrelse(bh);\n\t\treturn NULL;\n\t}\n\tif (!le32_to_cpu(cp->n_code_pages)) {\n\t\tpr_err(\"n_code_pages == 0\\n\");\n\t\tbrelse(bh);\n\t\treturn NULL;\n\t}\n\tcpds = le32_to_cpu(cp->array[0].code_page_data);\n\tcpi = le16_to_cpu(cp->array[0].index);\n\tbrelse(bh);\n\n\tif (cpi >= 3) {\n\t\tpr_err(\"Code page index out of array\\n\");\n\t\treturn NULL;\n\t}\n\t\n\tif (!(cpd = hpfs_map_sector(s, cpds, &bh, 0))) return NULL;\n\tif (le16_to_cpu(cpd->offs[cpi]) > 0x178) {\n\t\tpr_err(\"Code page index out of sector\\n\");\n\t\tbrelse(bh);\n\t\treturn NULL;\n\t}\n\tptr = (unsigned char *)cpd + le16_to_cpu(cpd->offs[cpi]) + 6;\n\tif (!(cp_table = kmalloc(256, GFP_KERNEL))) {\n\t\tpr_err(\"out of memory for code page table\\n\");\n\t\tbrelse(bh);\n\t\treturn NULL;\n\t}\n\tmemcpy(cp_table, ptr, 128);\n\tbrelse(bh);\n\n\t/* Try to build lowercasing table from uppercasing one */\n\n\tfor (i=128; i<256; i++) cp_table[i]=i;\n\tfor (i=128; i<256; i++) if (cp_table[i-128]!=i && cp_table[i-128]>=128)\n\t\tcp_table[cp_table[i-128]] = i;\n\t\n\treturn cp_table;\n}"
  },
  {
    "function_name": "hpfs_prefetch_bitmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/map.c",
    "lines": "36-48",
    "snippet": "void hpfs_prefetch_bitmap(struct super_block *s, unsigned bmp_block)\n{\n\tunsigned to_prefetch, next_prefetch;\n\tunsigned n_bands = (hpfs_sb(s)->sb_fs_size + 0x3fff) >> 14;\n\tif (unlikely(bmp_block >= n_bands))\n\t\treturn;\n\tto_prefetch = le32_to_cpu(hpfs_sb(s)->sb_bmp_dir[bmp_block]);\n\tif (unlikely(bmp_block + 1 >= n_bands))\n\t\tnext_prefetch = 0;\n\telse\n\t\tnext_prefetch = le32_to_cpu(hpfs_sb(s)->sb_bmp_dir[bmp_block + 1]);\n\thpfs_prefetch_sectors(s, to_prefetch, 4 + 4 * (to_prefetch + 4 == next_prefetch));\n}",
    "includes": [
      "#include \"hpfs_fn.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hpfs_prefetch_sectors",
          "args": [
            "s",
            "to_prefetch",
            "4 + 4 * (to_prefetch + 4 == next_prefetch)"
          ],
          "line": 47
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_prefetch_sectors",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/buffer.c",
          "lines": "13-39",
          "snippet": "void hpfs_prefetch_sectors(struct super_block *s, unsigned secno, int n)\n{\n\tstruct buffer_head *bh;\n\tstruct blk_plug plug;\n\n\tif (n <= 0 || unlikely(secno >= hpfs_sb(s)->sb_fs_size))\n\t\treturn;\n\n\tbh = sb_find_get_block(s, secno);\n\tif (bh) {\n\t\tif (buffer_uptodate(bh)) {\n\t\t\tbrelse(bh);\n\t\t\treturn;\n\t\t}\n\t\tbrelse(bh);\n\t};\n\n\tblk_start_plug(&plug);\n\twhile (n > 0) {\n\t\tif (unlikely(secno >= hpfs_sb(s)->sb_fs_size))\n\t\t\tbreak;\n\t\tsb_breadahead(s, secno);\n\t\tsecno++;\n\t\tn--;\n\t}\n\tblk_finish_plug(&plug);\n}",
          "includes": [
            "#include \"hpfs_fn.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid hpfs_prefetch_sectors(struct super_block *s, unsigned secno, int n)\n{\n\tstruct buffer_head *bh;\n\tstruct blk_plug plug;\n\n\tif (n <= 0 || unlikely(secno >= hpfs_sb(s)->sb_fs_size))\n\t\treturn;\n\n\tbh = sb_find_get_block(s, secno);\n\tif (bh) {\n\t\tif (buffer_uptodate(bh)) {\n\t\t\tbrelse(bh);\n\t\t\treturn;\n\t\t}\n\t\tbrelse(bh);\n\t};\n\n\tblk_start_plug(&plug);\n\twhile (n > 0) {\n\t\tif (unlikely(secno >= hpfs_sb(s)->sb_fs_size))\n\t\t\tbreak;\n\t\tsb_breadahead(s, secno);\n\t\tsecno++;\n\t\tn--;\n\t}\n\tblk_finish_plug(&plug);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "hpfs_sb(s)->sb_bmp_dir[bmp_block + 1]"
          ],
          "line": 46
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_sb",
          "args": [
            "s"
          ],
          "line": 46
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_sb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "310-313",
          "snippet": "static inline struct hpfs_sb_info *hpfs_sb(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_check_free_dnodes(struct super_block *, int);",
            "void hpfs_prefetch_sectors(struct super_block *, unsigned, int);",
            "void hpfs_prefetch_bitmap(struct super_block *, unsigned);",
            "unsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);",
            "int hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);",
            "void hpfs_error(struct super_block *, const char *, ...);",
            "int hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);",
            "unsigned hpfs_get_free_dnodes(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_check_free_dnodes(struct super_block *, int);\nvoid hpfs_prefetch_sectors(struct super_block *, unsigned, int);\nvoid hpfs_prefetch_bitmap(struct super_block *, unsigned);\nunsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);\nint hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);\nvoid hpfs_error(struct super_block *, const char *, ...);\nint hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);\nunsigned hpfs_get_free_dnodes(struct super_block *);\n\nstatic inline struct hpfs_sb_info *hpfs_sb(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "bmp_block + 1 >= n_bands"
          ],
          "line": 43
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "bmp_block >= n_bands"
          ],
          "line": 40
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"hpfs_fn.h\"\n\nvoid hpfs_prefetch_bitmap(struct super_block *s, unsigned bmp_block)\n{\n\tunsigned to_prefetch, next_prefetch;\n\tunsigned n_bands = (hpfs_sb(s)->sb_fs_size + 0x3fff) >> 14;\n\tif (unlikely(bmp_block >= n_bands))\n\t\treturn;\n\tto_prefetch = le32_to_cpu(hpfs_sb(s)->sb_bmp_dir[bmp_block]);\n\tif (unlikely(bmp_block + 1 >= n_bands))\n\t\tnext_prefetch = 0;\n\telse\n\t\tnext_prefetch = le32_to_cpu(hpfs_sb(s)->sb_bmp_dir[bmp_block + 1]);\n\thpfs_prefetch_sectors(s, to_prefetch, 4 + 4 * (to_prefetch + 4 == next_prefetch));\n}"
  },
  {
    "function_name": "hpfs_map_bitmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/map.c",
    "lines": "16-34",
    "snippet": "__le32 *hpfs_map_bitmap(struct super_block *s, unsigned bmp_block,\n\t\t\t struct quad_buffer_head *qbh, char *id)\n{\n\tsecno sec;\n\t__le32 *ret;\n\tunsigned n_bands = (hpfs_sb(s)->sb_fs_size + 0x3fff) >> 14;\n\tif (hpfs_sb(s)->sb_chk) if (bmp_block >= n_bands) {\n\t\thpfs_error(s, \"hpfs_map_bitmap called with bad parameter: %08x at %s\", bmp_block, id);\n\t\treturn NULL;\n\t}\n\tsec = le32_to_cpu(hpfs_sb(s)->sb_bmp_dir[bmp_block]);\n\tif (!sec || sec > hpfs_sb(s)->sb_fs_size-4) {\n\t\thpfs_error(s, \"invalid bitmap block pointer %08x -> %08x at %s\", bmp_block, sec, id);\n\t\treturn NULL;\n\t}\n\tret = hpfs_map_4sectors(s, sec, qbh, 4);\n\tif (ret) hpfs_prefetch_bitmap(s, bmp_block + 1);\n\treturn ret;\n}",
    "includes": [
      "#include \"hpfs_fn.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hpfs_prefetch_bitmap",
          "args": [
            "s",
            "bmp_block + 1"
          ],
          "line": 32
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_prefetch_bitmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/map.c",
          "lines": "36-48",
          "snippet": "void hpfs_prefetch_bitmap(struct super_block *s, unsigned bmp_block)\n{\n\tunsigned to_prefetch, next_prefetch;\n\tunsigned n_bands = (hpfs_sb(s)->sb_fs_size + 0x3fff) >> 14;\n\tif (unlikely(bmp_block >= n_bands))\n\t\treturn;\n\tto_prefetch = le32_to_cpu(hpfs_sb(s)->sb_bmp_dir[bmp_block]);\n\tif (unlikely(bmp_block + 1 >= n_bands))\n\t\tnext_prefetch = 0;\n\telse\n\t\tnext_prefetch = le32_to_cpu(hpfs_sb(s)->sb_bmp_dir[bmp_block + 1]);\n\thpfs_prefetch_sectors(s, to_prefetch, 4 + 4 * (to_prefetch + 4 == next_prefetch));\n}",
          "includes": [
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n\nvoid hpfs_prefetch_bitmap(struct super_block *s, unsigned bmp_block)\n{\n\tunsigned to_prefetch, next_prefetch;\n\tunsigned n_bands = (hpfs_sb(s)->sb_fs_size + 0x3fff) >> 14;\n\tif (unlikely(bmp_block >= n_bands))\n\t\treturn;\n\tto_prefetch = le32_to_cpu(hpfs_sb(s)->sb_bmp_dir[bmp_block]);\n\tif (unlikely(bmp_block + 1 >= n_bands))\n\t\tnext_prefetch = 0;\n\telse\n\t\tnext_prefetch = le32_to_cpu(hpfs_sb(s)->sb_bmp_dir[bmp_block + 1]);\n\thpfs_prefetch_sectors(s, to_prefetch, 4 + 4 * (to_prefetch + 4 == next_prefetch));\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_map_4sectors",
          "args": [
            "s",
            "sec",
            "qbh",
            "4"
          ],
          "line": 31
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_map_4sectors",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/buffer.c",
          "lines": "86-136",
          "snippet": "void *hpfs_map_4sectors(struct super_block *s, unsigned secno, struct quad_buffer_head *qbh,\n\t\t   int ahead)\n{\n\tchar *data;\n\n\thpfs_lock_assert(s);\n\n\tcond_resched();\n\n\tif (secno & 3) {\n\t\tpr_err(\"%s(): unaligned read\\n\", __func__);\n\t\treturn NULL;\n\t}\n\n\thpfs_prefetch_sectors(s, secno, 4 + ahead);\n\n\tif (!(qbh->bh[0] = sb_bread(s, secno + 0))) goto bail0;\n\tif (!(qbh->bh[1] = sb_bread(s, secno + 1))) goto bail1;\n\tif (!(qbh->bh[2] = sb_bread(s, secno + 2))) goto bail2;\n\tif (!(qbh->bh[3] = sb_bread(s, secno + 3))) goto bail3;\n\n\tif (likely(qbh->bh[1]->b_data == qbh->bh[0]->b_data + 1 * 512) &&\n\t    likely(qbh->bh[2]->b_data == qbh->bh[0]->b_data + 2 * 512) &&\n\t    likely(qbh->bh[3]->b_data == qbh->bh[0]->b_data + 3 * 512)) {\n\t\treturn qbh->data = qbh->bh[0]->b_data;\n\t}\n\n\tqbh->data = data = kmalloc(2048, GFP_NOFS);\n\tif (!data) {\n\t\tpr_err(\"%s(): out of memory\\n\", __func__);\n\t\tgoto bail4;\n\t}\n\n\tmemcpy(data + 0 * 512, qbh->bh[0]->b_data, 512);\n\tmemcpy(data + 1 * 512, qbh->bh[1]->b_data, 512);\n\tmemcpy(data + 2 * 512, qbh->bh[2]->b_data, 512);\n\tmemcpy(data + 3 * 512, qbh->bh[3]->b_data, 512);\n\n\treturn data;\n\n bail4:\n\tbrelse(qbh->bh[3]);\n bail3:\n\tbrelse(qbh->bh[2]);\n bail2:\n\tbrelse(qbh->bh[1]);\n bail1:\n\tbrelse(qbh->bh[0]);\n bail0:\n\treturn NULL;\n}",
          "includes": [
            "#include \"hpfs_fn.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid *hpfs_map_4sectors(struct super_block *s, unsigned secno, struct quad_buffer_head *qbh,\n\t\t   int ahead)\n{\n\tchar *data;\n\n\thpfs_lock_assert(s);\n\n\tcond_resched();\n\n\tif (secno & 3) {\n\t\tpr_err(\"%s(): unaligned read\\n\", __func__);\n\t\treturn NULL;\n\t}\n\n\thpfs_prefetch_sectors(s, secno, 4 + ahead);\n\n\tif (!(qbh->bh[0] = sb_bread(s, secno + 0))) goto bail0;\n\tif (!(qbh->bh[1] = sb_bread(s, secno + 1))) goto bail1;\n\tif (!(qbh->bh[2] = sb_bread(s, secno + 2))) goto bail2;\n\tif (!(qbh->bh[3] = sb_bread(s, secno + 3))) goto bail3;\n\n\tif (likely(qbh->bh[1]->b_data == qbh->bh[0]->b_data + 1 * 512) &&\n\t    likely(qbh->bh[2]->b_data == qbh->bh[0]->b_data + 2 * 512) &&\n\t    likely(qbh->bh[3]->b_data == qbh->bh[0]->b_data + 3 * 512)) {\n\t\treturn qbh->data = qbh->bh[0]->b_data;\n\t}\n\n\tqbh->data = data = kmalloc(2048, GFP_NOFS);\n\tif (!data) {\n\t\tpr_err(\"%s(): out of memory\\n\", __func__);\n\t\tgoto bail4;\n\t}\n\n\tmemcpy(data + 0 * 512, qbh->bh[0]->b_data, 512);\n\tmemcpy(data + 1 * 512, qbh->bh[1]->b_data, 512);\n\tmemcpy(data + 2 * 512, qbh->bh[2]->b_data, 512);\n\tmemcpy(data + 3 * 512, qbh->bh[3]->b_data, 512);\n\n\treturn data;\n\n bail4:\n\tbrelse(qbh->bh[3]);\n bail3:\n\tbrelse(qbh->bh[2]);\n bail2:\n\tbrelse(qbh->bh[1]);\n bail1:\n\tbrelse(qbh->bh[0]);\n bail0:\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_error",
          "args": [
            "s",
            "\"invalid bitmap block pointer %08x -> %08x at %s\"",
            "bmp_block",
            "sec",
            "id"
          ],
          "line": 28
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/super.c",
          "lines": "57-86",
          "snippet": "void hpfs_error(struct super_block *s, const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvsnprintf(err_buf, sizeof(err_buf), fmt, args);\n\tva_end(args);\n\n\tpr_err(\"filesystem error: %s\", err_buf);\n\tif (!hpfs_sb(s)->sb_was_error) {\n\t\tif (hpfs_sb(s)->sb_err == 2) {\n\t\t\tpr_cont(\"; crashing the system because you wanted it\\n\");\n\t\t\tmark_dirty(s, 0);\n\t\t\tpanic(\"HPFS panic\");\n\t\t} else if (hpfs_sb(s)->sb_err == 1) {\n\t\t\tif (s->s_flags & MS_RDONLY)\n\t\t\t\tpr_cont(\"; already mounted read-only\\n\");\n\t\t\telse {\n\t\t\t\tpr_cont(\"; remounting read-only\\n\");\n\t\t\t\tmark_dirty(s, 0);\n\t\t\t\ts->s_flags |= MS_RDONLY;\n\t\t\t}\n\t\t} else if (s->s_flags & MS_RDONLY)\n\t\t\t\tpr_cont(\"; going on - but anything won't be destroyed because it's read-only\\n\");\n\t\telse\n\t\t\tpr_cont(\"; corrupted filesystem mounted read/write - your computer will explode within 20 seconds ... but you wanted it so!\\n\");\n\t} else\n\t\tpr_cont(\"\\n\");\n\thpfs_sb(s)->sb_was_error = 1;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/sched.h>",
            "#include <linux/magic.h>",
            "#include <linux/statfs.h>",
            "#include <linux/init.h>",
            "#include <linux/parser.h>",
            "#include <linux/module.h>",
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static char err_buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/bitmap.h>\n#include <linux/sched.h>\n#include <linux/magic.h>\n#include <linux/statfs.h>\n#include <linux/init.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include \"hpfs_fn.h\"\n\nstatic char err_buf[1024];\n\nvoid hpfs_error(struct super_block *s, const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvsnprintf(err_buf, sizeof(err_buf), fmt, args);\n\tva_end(args);\n\n\tpr_err(\"filesystem error: %s\", err_buf);\n\tif (!hpfs_sb(s)->sb_was_error) {\n\t\tif (hpfs_sb(s)->sb_err == 2) {\n\t\t\tpr_cont(\"; crashing the system because you wanted it\\n\");\n\t\t\tmark_dirty(s, 0);\n\t\t\tpanic(\"HPFS panic\");\n\t\t} else if (hpfs_sb(s)->sb_err == 1) {\n\t\t\tif (s->s_flags & MS_RDONLY)\n\t\t\t\tpr_cont(\"; already mounted read-only\\n\");\n\t\t\telse {\n\t\t\t\tpr_cont(\"; remounting read-only\\n\");\n\t\t\t\tmark_dirty(s, 0);\n\t\t\t\ts->s_flags |= MS_RDONLY;\n\t\t\t}\n\t\t} else if (s->s_flags & MS_RDONLY)\n\t\t\t\tpr_cont(\"; going on - but anything won't be destroyed because it's read-only\\n\");\n\t\telse\n\t\t\tpr_cont(\"; corrupted filesystem mounted read/write - your computer will explode within 20 seconds ... but you wanted it so!\\n\");\n\t} else\n\t\tpr_cont(\"\\n\");\n\thpfs_sb(s)->sb_was_error = 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_sb",
          "args": [
            "s"
          ],
          "line": 27
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_sb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "310-313",
          "snippet": "static inline struct hpfs_sb_info *hpfs_sb(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_check_free_dnodes(struct super_block *, int);",
            "void hpfs_prefetch_sectors(struct super_block *, unsigned, int);",
            "void hpfs_prefetch_bitmap(struct super_block *, unsigned);",
            "unsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);",
            "int hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);",
            "void hpfs_error(struct super_block *, const char *, ...);",
            "int hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);",
            "unsigned hpfs_get_free_dnodes(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_check_free_dnodes(struct super_block *, int);\nvoid hpfs_prefetch_sectors(struct super_block *, unsigned, int);\nvoid hpfs_prefetch_bitmap(struct super_block *, unsigned);\nunsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);\nint hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);\nvoid hpfs_error(struct super_block *, const char *, ...);\nint hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);\nunsigned hpfs_get_free_dnodes(struct super_block *);\n\nstatic inline struct hpfs_sb_info *hpfs_sb(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "hpfs_sb(s)->sb_bmp_dir[bmp_block]"
          ],
          "line": 26
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hpfs_fn.h\"\n\n__le32 *hpfs_map_bitmap(struct super_block *s, unsigned bmp_block,\n\t\t\t struct quad_buffer_head *qbh, char *id)\n{\n\tsecno sec;\n\t__le32 *ret;\n\tunsigned n_bands = (hpfs_sb(s)->sb_fs_size + 0x3fff) >> 14;\n\tif (hpfs_sb(s)->sb_chk) if (bmp_block >= n_bands) {\n\t\thpfs_error(s, \"hpfs_map_bitmap called with bad parameter: %08x at %s\", bmp_block, id);\n\t\treturn NULL;\n\t}\n\tsec = le32_to_cpu(hpfs_sb(s)->sb_bmp_dir[bmp_block]);\n\tif (!sec || sec > hpfs_sb(s)->sb_fs_size-4) {\n\t\thpfs_error(s, \"invalid bitmap block pointer %08x -> %08x at %s\", bmp_block, sec, id);\n\t\treturn NULL;\n\t}\n\tret = hpfs_map_4sectors(s, sec, qbh, 4);\n\tif (ret) hpfs_prefetch_bitmap(s, bmp_block + 1);\n\treturn ret;\n}"
  },
  {
    "function_name": "hpfs_map_dnode_bitmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/map.c",
    "lines": "11-14",
    "snippet": "__le32 *hpfs_map_dnode_bitmap(struct super_block *s, struct quad_buffer_head *qbh)\n{\n\treturn hpfs_map_4sectors(s, hpfs_sb(s)->sb_dmap, qbh, 0);\n}",
    "includes": [
      "#include \"hpfs_fn.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hpfs_map_4sectors",
          "args": [
            "s",
            "hpfs_sb(s)->sb_dmap",
            "qbh",
            "0"
          ],
          "line": 13
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_map_4sectors",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/buffer.c",
          "lines": "86-136",
          "snippet": "void *hpfs_map_4sectors(struct super_block *s, unsigned secno, struct quad_buffer_head *qbh,\n\t\t   int ahead)\n{\n\tchar *data;\n\n\thpfs_lock_assert(s);\n\n\tcond_resched();\n\n\tif (secno & 3) {\n\t\tpr_err(\"%s(): unaligned read\\n\", __func__);\n\t\treturn NULL;\n\t}\n\n\thpfs_prefetch_sectors(s, secno, 4 + ahead);\n\n\tif (!(qbh->bh[0] = sb_bread(s, secno + 0))) goto bail0;\n\tif (!(qbh->bh[1] = sb_bread(s, secno + 1))) goto bail1;\n\tif (!(qbh->bh[2] = sb_bread(s, secno + 2))) goto bail2;\n\tif (!(qbh->bh[3] = sb_bread(s, secno + 3))) goto bail3;\n\n\tif (likely(qbh->bh[1]->b_data == qbh->bh[0]->b_data + 1 * 512) &&\n\t    likely(qbh->bh[2]->b_data == qbh->bh[0]->b_data + 2 * 512) &&\n\t    likely(qbh->bh[3]->b_data == qbh->bh[0]->b_data + 3 * 512)) {\n\t\treturn qbh->data = qbh->bh[0]->b_data;\n\t}\n\n\tqbh->data = data = kmalloc(2048, GFP_NOFS);\n\tif (!data) {\n\t\tpr_err(\"%s(): out of memory\\n\", __func__);\n\t\tgoto bail4;\n\t}\n\n\tmemcpy(data + 0 * 512, qbh->bh[0]->b_data, 512);\n\tmemcpy(data + 1 * 512, qbh->bh[1]->b_data, 512);\n\tmemcpy(data + 2 * 512, qbh->bh[2]->b_data, 512);\n\tmemcpy(data + 3 * 512, qbh->bh[3]->b_data, 512);\n\n\treturn data;\n\n bail4:\n\tbrelse(qbh->bh[3]);\n bail3:\n\tbrelse(qbh->bh[2]);\n bail2:\n\tbrelse(qbh->bh[1]);\n bail1:\n\tbrelse(qbh->bh[0]);\n bail0:\n\treturn NULL;\n}",
          "includes": [
            "#include \"hpfs_fn.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid *hpfs_map_4sectors(struct super_block *s, unsigned secno, struct quad_buffer_head *qbh,\n\t\t   int ahead)\n{\n\tchar *data;\n\n\thpfs_lock_assert(s);\n\n\tcond_resched();\n\n\tif (secno & 3) {\n\t\tpr_err(\"%s(): unaligned read\\n\", __func__);\n\t\treturn NULL;\n\t}\n\n\thpfs_prefetch_sectors(s, secno, 4 + ahead);\n\n\tif (!(qbh->bh[0] = sb_bread(s, secno + 0))) goto bail0;\n\tif (!(qbh->bh[1] = sb_bread(s, secno + 1))) goto bail1;\n\tif (!(qbh->bh[2] = sb_bread(s, secno + 2))) goto bail2;\n\tif (!(qbh->bh[3] = sb_bread(s, secno + 3))) goto bail3;\n\n\tif (likely(qbh->bh[1]->b_data == qbh->bh[0]->b_data + 1 * 512) &&\n\t    likely(qbh->bh[2]->b_data == qbh->bh[0]->b_data + 2 * 512) &&\n\t    likely(qbh->bh[3]->b_data == qbh->bh[0]->b_data + 3 * 512)) {\n\t\treturn qbh->data = qbh->bh[0]->b_data;\n\t}\n\n\tqbh->data = data = kmalloc(2048, GFP_NOFS);\n\tif (!data) {\n\t\tpr_err(\"%s(): out of memory\\n\", __func__);\n\t\tgoto bail4;\n\t}\n\n\tmemcpy(data + 0 * 512, qbh->bh[0]->b_data, 512);\n\tmemcpy(data + 1 * 512, qbh->bh[1]->b_data, 512);\n\tmemcpy(data + 2 * 512, qbh->bh[2]->b_data, 512);\n\tmemcpy(data + 3 * 512, qbh->bh[3]->b_data, 512);\n\n\treturn data;\n\n bail4:\n\tbrelse(qbh->bh[3]);\n bail3:\n\tbrelse(qbh->bh[2]);\n bail2:\n\tbrelse(qbh->bh[1]);\n bail1:\n\tbrelse(qbh->bh[0]);\n bail0:\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_sb",
          "args": [
            "s"
          ],
          "line": 13
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_sb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "310-313",
          "snippet": "static inline struct hpfs_sb_info *hpfs_sb(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_check_free_dnodes(struct super_block *, int);",
            "void hpfs_prefetch_sectors(struct super_block *, unsigned, int);",
            "void hpfs_prefetch_bitmap(struct super_block *, unsigned);",
            "unsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);",
            "int hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);",
            "void hpfs_error(struct super_block *, const char *, ...);",
            "int hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);",
            "unsigned hpfs_get_free_dnodes(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_check_free_dnodes(struct super_block *, int);\nvoid hpfs_prefetch_sectors(struct super_block *, unsigned, int);\nvoid hpfs_prefetch_bitmap(struct super_block *, unsigned);\nunsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);\nint hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);\nvoid hpfs_error(struct super_block *, const char *, ...);\nint hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);\nunsigned hpfs_get_free_dnodes(struct super_block *);\n\nstatic inline struct hpfs_sb_info *hpfs_sb(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hpfs_fn.h\"\n\n__le32 *hpfs_map_dnode_bitmap(struct super_block *s, struct quad_buffer_head *qbh)\n{\n\treturn hpfs_map_4sectors(s, hpfs_sb(s)->sb_dmap, qbh, 0);\n}"
  }
]