[
  {
    "function_name": "gfs2_ea_dealloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
    "lines": "1458-1485",
    "snippet": "int gfs2_ea_dealloc(struct gfs2_inode *ip)\n{\n\tint error;\n\n\terror = gfs2_rindex_update(GFS2_SB(&ip->i_inode));\n\tif (error)\n\t\treturn error;\n\n\terror = gfs2_quota_hold(ip, NO_UID_QUOTA_CHANGE, NO_GID_QUOTA_CHANGE);\n\tif (error)\n\t\treturn error;\n\n\terror = ea_foreach(ip, ea_dealloc_unstuffed, NULL);\n\tif (error)\n\t\tgoto out_quota;\n\n\tif (ip->i_diskflags & GFS2_DIF_EA_INDIRECT) {\n\t\terror = ea_dealloc_indirect(ip);\n\t\tif (error)\n\t\t\tgoto out_quota;\n\t}\n\n\terror = ea_dealloc_block(ip);\n\nout_quota:\n\tgfs2_quota_unhold(ip);\n\treturn error;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"trans.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"inode.h\"",
      "#include \"glock.h\"",
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/xattr.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "gfs2_quota_unhold",
          "args": [
            "ip"
          ],
          "line": 1483
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_quota_unhold",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.c",
          "lines": "587-601",
          "snippet": "void gfs2_quota_unhold(struct gfs2_inode *ip)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tunsigned int x;\n\n\tif (ip->i_res == NULL)\n\t\treturn;\n\tgfs2_assert_warn(sdp, !test_bit(GIF_QD_LOCKED, &ip->i_flags));\n\n\tfor (x = 0; x < ip->i_res->rs_qa_qd_num; x++) {\n\t\tqdsb_put(ip->i_res->rs_qa_qd[x]);\n\t\tip->i_res->rs_qa_qd[x] = NULL;\n\t}\n\tip->i_res->rs_qa_qd_num = 0;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_quota_unhold(struct gfs2_inode *ip)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tunsigned int x;\n\n\tif (ip->i_res == NULL)\n\t\treturn;\n\tgfs2_assert_warn(sdp, !test_bit(GIF_QD_LOCKED, &ip->i_flags));\n\n\tfor (x = 0; x < ip->i_res->rs_qa_qd_num; x++) {\n\t\tqdsb_put(ip->i_res->rs_qa_qd[x]);\n\t\tip->i_res->rs_qa_qd[x] = NULL;\n\t}\n\tip->i_res->rs_qa_qd_num = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ea_dealloc_block",
          "args": [
            "ip"
          ],
          "line": 1480
        },
        "resolved": true,
        "details": {
          "function_name": "ea_dealloc_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "1405-1449",
          "snippet": "static int ea_dealloc_block(struct gfs2_inode *ip)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tstruct gfs2_rgrpd *rgd;\n\tstruct buffer_head *dibh;\n\tstruct gfs2_holder gh;\n\tint error;\n\n\terror = gfs2_rindex_update(sdp);\n\tif (error)\n\t\treturn error;\n\n\trgd = gfs2_blk2rgrpd(sdp, ip->i_eattr, 1);\n\tif (!rgd) {\n\t\tgfs2_consist_inode(ip);\n\t\treturn -EIO;\n\t}\n\n\terror = gfs2_glock_nq_init(rgd->rd_gl, LM_ST_EXCLUSIVE, 0, &gh);\n\tif (error)\n\t\treturn error;\n\n\terror = gfs2_trans_begin(sdp, RES_RG_BIT + RES_DINODE + RES_STATFS +\n\t\t\t\t RES_QUOTA, 1);\n\tif (error)\n\t\tgoto out_gunlock;\n\n\tgfs2_free_meta(ip, ip->i_eattr, 1);\n\n\tip->i_eattr = 0;\n\tgfs2_add_inode_blocks(&ip->i_inode, -1);\n\n\terror = gfs2_meta_inode_buffer(ip, &dibh);\n\tif (!error) {\n\t\tgfs2_trans_add_meta(ip->i_gl, dibh);\n\t\tgfs2_dinode_out(ip, dibh->b_data);\n\t\tbrelse(dibh);\n\t}\n\n\tgfs2_trans_end(sdp);\n\nout_gunlock:\n\tgfs2_glock_dq_uninit(&gh);\n\treturn error;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic int ea_dealloc_block(struct gfs2_inode *ip)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tstruct gfs2_rgrpd *rgd;\n\tstruct buffer_head *dibh;\n\tstruct gfs2_holder gh;\n\tint error;\n\n\terror = gfs2_rindex_update(sdp);\n\tif (error)\n\t\treturn error;\n\n\trgd = gfs2_blk2rgrpd(sdp, ip->i_eattr, 1);\n\tif (!rgd) {\n\t\tgfs2_consist_inode(ip);\n\t\treturn -EIO;\n\t}\n\n\terror = gfs2_glock_nq_init(rgd->rd_gl, LM_ST_EXCLUSIVE, 0, &gh);\n\tif (error)\n\t\treturn error;\n\n\terror = gfs2_trans_begin(sdp, RES_RG_BIT + RES_DINODE + RES_STATFS +\n\t\t\t\t RES_QUOTA, 1);\n\tif (error)\n\t\tgoto out_gunlock;\n\n\tgfs2_free_meta(ip, ip->i_eattr, 1);\n\n\tip->i_eattr = 0;\n\tgfs2_add_inode_blocks(&ip->i_inode, -1);\n\n\terror = gfs2_meta_inode_buffer(ip, &dibh);\n\tif (!error) {\n\t\tgfs2_trans_add_meta(ip->i_gl, dibh);\n\t\tgfs2_dinode_out(ip, dibh->b_data);\n\t\tbrelse(dibh);\n\t}\n\n\tgfs2_trans_end(sdp);\n\nout_gunlock:\n\tgfs2_glock_dq_uninit(&gh);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ea_dealloc_indirect",
          "args": [
            "ip"
          ],
          "line": 1475
        },
        "resolved": true,
        "details": {
          "function_name": "ea_dealloc_indirect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "1287-1403",
          "snippet": "static int ea_dealloc_indirect(struct gfs2_inode *ip)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tstruct gfs2_rgrp_list rlist;\n\tstruct buffer_head *indbh, *dibh;\n\t__be64 *eablk, *end;\n\tunsigned int rg_blocks = 0;\n\tu64 bstart = 0;\n\tunsigned int blen = 0;\n\tunsigned int blks = 0;\n\tunsigned int x;\n\tint error;\n\n\terror = gfs2_rindex_update(sdp);\n\tif (error)\n\t\treturn error;\n\n\tmemset(&rlist, 0, sizeof(struct gfs2_rgrp_list));\n\n\terror = gfs2_meta_read(ip->i_gl, ip->i_eattr, DIO_WAIT, &indbh);\n\tif (error)\n\t\treturn error;\n\n\tif (gfs2_metatype_check(sdp, indbh, GFS2_METATYPE_IN)) {\n\t\terror = -EIO;\n\t\tgoto out;\n\t}\n\n\teablk = (__be64 *)(indbh->b_data + sizeof(struct gfs2_meta_header));\n\tend = eablk + sdp->sd_inptrs;\n\n\tfor (; eablk < end; eablk++) {\n\t\tu64 bn;\n\n\t\tif (!*eablk)\n\t\t\tbreak;\n\t\tbn = be64_to_cpu(*eablk);\n\n\t\tif (bstart + blen == bn)\n\t\t\tblen++;\n\t\telse {\n\t\t\tif (bstart)\n\t\t\t\tgfs2_rlist_add(ip, &rlist, bstart);\n\t\t\tbstart = bn;\n\t\t\tblen = 1;\n\t\t}\n\t\tblks++;\n\t}\n\tif (bstart)\n\t\tgfs2_rlist_add(ip, &rlist, bstart);\n\telse\n\t\tgoto out;\n\n\tgfs2_rlist_alloc(&rlist, LM_ST_EXCLUSIVE);\n\n\tfor (x = 0; x < rlist.rl_rgrps; x++) {\n\t\tstruct gfs2_rgrpd *rgd;\n\t\trgd = rlist.rl_ghs[x].gh_gl->gl_object;\n\t\trg_blocks += rgd->rd_length;\n\t}\n\n\terror = gfs2_glock_nq_m(rlist.rl_rgrps, rlist.rl_ghs);\n\tif (error)\n\t\tgoto out_rlist_free;\n\n\terror = gfs2_trans_begin(sdp, rg_blocks + RES_DINODE + RES_INDIRECT +\n\t\t\t\t RES_STATFS + RES_QUOTA, blks);\n\tif (error)\n\t\tgoto out_gunlock;\n\n\tgfs2_trans_add_meta(ip->i_gl, indbh);\n\n\teablk = (__be64 *)(indbh->b_data + sizeof(struct gfs2_meta_header));\n\tbstart = 0;\n\tblen = 0;\n\n\tfor (; eablk < end; eablk++) {\n\t\tu64 bn;\n\n\t\tif (!*eablk)\n\t\t\tbreak;\n\t\tbn = be64_to_cpu(*eablk);\n\n\t\tif (bstart + blen == bn)\n\t\t\tblen++;\n\t\telse {\n\t\t\tif (bstart)\n\t\t\t\tgfs2_free_meta(ip, bstart, blen);\n\t\t\tbstart = bn;\n\t\t\tblen = 1;\n\t\t}\n\n\t\t*eablk = 0;\n\t\tgfs2_add_inode_blocks(&ip->i_inode, -1);\n\t}\n\tif (bstart)\n\t\tgfs2_free_meta(ip, bstart, blen);\n\n\tip->i_diskflags &= ~GFS2_DIF_EA_INDIRECT;\n\n\terror = gfs2_meta_inode_buffer(ip, &dibh);\n\tif (!error) {\n\t\tgfs2_trans_add_meta(ip->i_gl, dibh);\n\t\tgfs2_dinode_out(ip, dibh->b_data);\n\t\tbrelse(dibh);\n\t}\n\n\tgfs2_trans_end(sdp);\n\nout_gunlock:\n\tgfs2_glock_dq_m(rlist.rl_rgrps, rlist.rl_ghs);\nout_rlist_free:\n\tgfs2_rlist_free(&rlist);\nout:\n\tbrelse(indbh);\n\treturn error;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic int ea_dealloc_indirect(struct gfs2_inode *ip)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tstruct gfs2_rgrp_list rlist;\n\tstruct buffer_head *indbh, *dibh;\n\t__be64 *eablk, *end;\n\tunsigned int rg_blocks = 0;\n\tu64 bstart = 0;\n\tunsigned int blen = 0;\n\tunsigned int blks = 0;\n\tunsigned int x;\n\tint error;\n\n\terror = gfs2_rindex_update(sdp);\n\tif (error)\n\t\treturn error;\n\n\tmemset(&rlist, 0, sizeof(struct gfs2_rgrp_list));\n\n\terror = gfs2_meta_read(ip->i_gl, ip->i_eattr, DIO_WAIT, &indbh);\n\tif (error)\n\t\treturn error;\n\n\tif (gfs2_metatype_check(sdp, indbh, GFS2_METATYPE_IN)) {\n\t\terror = -EIO;\n\t\tgoto out;\n\t}\n\n\teablk = (__be64 *)(indbh->b_data + sizeof(struct gfs2_meta_header));\n\tend = eablk + sdp->sd_inptrs;\n\n\tfor (; eablk < end; eablk++) {\n\t\tu64 bn;\n\n\t\tif (!*eablk)\n\t\t\tbreak;\n\t\tbn = be64_to_cpu(*eablk);\n\n\t\tif (bstart + blen == bn)\n\t\t\tblen++;\n\t\telse {\n\t\t\tif (bstart)\n\t\t\t\tgfs2_rlist_add(ip, &rlist, bstart);\n\t\t\tbstart = bn;\n\t\t\tblen = 1;\n\t\t}\n\t\tblks++;\n\t}\n\tif (bstart)\n\t\tgfs2_rlist_add(ip, &rlist, bstart);\n\telse\n\t\tgoto out;\n\n\tgfs2_rlist_alloc(&rlist, LM_ST_EXCLUSIVE);\n\n\tfor (x = 0; x < rlist.rl_rgrps; x++) {\n\t\tstruct gfs2_rgrpd *rgd;\n\t\trgd = rlist.rl_ghs[x].gh_gl->gl_object;\n\t\trg_blocks += rgd->rd_length;\n\t}\n\n\terror = gfs2_glock_nq_m(rlist.rl_rgrps, rlist.rl_ghs);\n\tif (error)\n\t\tgoto out_rlist_free;\n\n\terror = gfs2_trans_begin(sdp, rg_blocks + RES_DINODE + RES_INDIRECT +\n\t\t\t\t RES_STATFS + RES_QUOTA, blks);\n\tif (error)\n\t\tgoto out_gunlock;\n\n\tgfs2_trans_add_meta(ip->i_gl, indbh);\n\n\teablk = (__be64 *)(indbh->b_data + sizeof(struct gfs2_meta_header));\n\tbstart = 0;\n\tblen = 0;\n\n\tfor (; eablk < end; eablk++) {\n\t\tu64 bn;\n\n\t\tif (!*eablk)\n\t\t\tbreak;\n\t\tbn = be64_to_cpu(*eablk);\n\n\t\tif (bstart + blen == bn)\n\t\t\tblen++;\n\t\telse {\n\t\t\tif (bstart)\n\t\t\t\tgfs2_free_meta(ip, bstart, blen);\n\t\t\tbstart = bn;\n\t\t\tblen = 1;\n\t\t}\n\n\t\t*eablk = 0;\n\t\tgfs2_add_inode_blocks(&ip->i_inode, -1);\n\t}\n\tif (bstart)\n\t\tgfs2_free_meta(ip, bstart, blen);\n\n\tip->i_diskflags &= ~GFS2_DIF_EA_INDIRECT;\n\n\terror = gfs2_meta_inode_buffer(ip, &dibh);\n\tif (!error) {\n\t\tgfs2_trans_add_meta(ip->i_gl, dibh);\n\t\tgfs2_dinode_out(ip, dibh->b_data);\n\t\tbrelse(dibh);\n\t}\n\n\tgfs2_trans_end(sdp);\n\nout_gunlock:\n\tgfs2_glock_dq_m(rlist.rl_rgrps, rlist.rl_ghs);\nout_rlist_free:\n\tgfs2_rlist_free(&rlist);\nout:\n\tbrelse(indbh);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ea_foreach",
          "args": [
            "ip",
            "ea_dealloc_unstuffed",
            "NULL"
          ],
          "line": 1470
        },
        "resolved": true,
        "details": {
          "function_name": "ea_foreach",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "116-157",
          "snippet": "static int ea_foreach(struct gfs2_inode *ip, ea_call_t ea_call, void *data)\n{\n\tstruct buffer_head *bh, *eabh;\n\t__be64 *eablk, *end;\n\tint error;\n\n\terror = gfs2_meta_read(ip->i_gl, ip->i_eattr, DIO_WAIT, &bh);\n\tif (error)\n\t\treturn error;\n\n\tif (!(ip->i_diskflags & GFS2_DIF_EA_INDIRECT)) {\n\t\terror = ea_foreach_i(ip, bh, ea_call, data);\n\t\tgoto out;\n\t}\n\n\tif (gfs2_metatype_check(GFS2_SB(&ip->i_inode), bh, GFS2_METATYPE_IN)) {\n\t\terror = -EIO;\n\t\tgoto out;\n\t}\n\n\teablk = (__be64 *)(bh->b_data + sizeof(struct gfs2_meta_header));\n\tend = eablk + GFS2_SB(&ip->i_inode)->sd_inptrs;\n\n\tfor (; eablk < end; eablk++) {\n\t\tu64 bn;\n\n\t\tif (!*eablk)\n\t\t\tbreak;\n\t\tbn = be64_to_cpu(*eablk);\n\n\t\terror = gfs2_meta_read(ip->i_gl, bn, DIO_WAIT, &eabh);\n\t\tif (error)\n\t\t\tbreak;\n\t\terror = ea_foreach_i(ip, eabh, ea_call, data);\n\t\tbrelse(eabh);\n\t\tif (error)\n\t\t\tbreak;\n\t}\nout:\n\tbrelse(bh);\n\treturn error;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic int ea_foreach(struct gfs2_inode *ip, ea_call_t ea_call, void *data)\n{\n\tstruct buffer_head *bh, *eabh;\n\t__be64 *eablk, *end;\n\tint error;\n\n\terror = gfs2_meta_read(ip->i_gl, ip->i_eattr, DIO_WAIT, &bh);\n\tif (error)\n\t\treturn error;\n\n\tif (!(ip->i_diskflags & GFS2_DIF_EA_INDIRECT)) {\n\t\terror = ea_foreach_i(ip, bh, ea_call, data);\n\t\tgoto out;\n\t}\n\n\tif (gfs2_metatype_check(GFS2_SB(&ip->i_inode), bh, GFS2_METATYPE_IN)) {\n\t\terror = -EIO;\n\t\tgoto out;\n\t}\n\n\teablk = (__be64 *)(bh->b_data + sizeof(struct gfs2_meta_header));\n\tend = eablk + GFS2_SB(&ip->i_inode)->sd_inptrs;\n\n\tfor (; eablk < end; eablk++) {\n\t\tu64 bn;\n\n\t\tif (!*eablk)\n\t\t\tbreak;\n\t\tbn = be64_to_cpu(*eablk);\n\n\t\terror = gfs2_meta_read(ip->i_gl, bn, DIO_WAIT, &eabh);\n\t\tif (error)\n\t\t\tbreak;\n\t\terror = ea_foreach_i(ip, eabh, ea_call, data);\n\t\tbrelse(eabh);\n\t\tif (error)\n\t\t\tbreak;\n\t}\nout:\n\tbrelse(bh);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_quota_hold",
          "args": [
            "ip",
            "NO_UID_QUOTA_CHANGE",
            "NO_GID_QUOTA_CHANGE"
          ],
          "line": 1466
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_quota_hold",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.c",
          "lines": "530-585",
          "snippet": "int gfs2_quota_hold(struct gfs2_inode *ip, kuid_t uid, kgid_t gid)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tstruct gfs2_quota_data **qd;\n\tint error;\n\n\tif (ip->i_res == NULL) {\n\t\terror = gfs2_rs_alloc(ip);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\tqd = ip->i_res->rs_qa_qd;\n\n\tif (gfs2_assert_warn(sdp, !ip->i_res->rs_qa_qd_num) ||\n\t    gfs2_assert_warn(sdp, !test_bit(GIF_QD_LOCKED, &ip->i_flags)))\n\t\treturn -EIO;\n\n\tif (sdp->sd_args.ar_quota == GFS2_QUOTA_OFF)\n\t\treturn 0;\n\n\terror = qdsb_get(sdp, make_kqid_uid(ip->i_inode.i_uid), qd);\n\tif (error)\n\t\tgoto out;\n\tip->i_res->rs_qa_qd_num++;\n\tqd++;\n\n\terror = qdsb_get(sdp, make_kqid_gid(ip->i_inode.i_gid), qd);\n\tif (error)\n\t\tgoto out;\n\tip->i_res->rs_qa_qd_num++;\n\tqd++;\n\n\tif (!uid_eq(uid, NO_UID_QUOTA_CHANGE) &&\n\t    !uid_eq(uid, ip->i_inode.i_uid)) {\n\t\terror = qdsb_get(sdp, make_kqid_uid(uid), qd);\n\t\tif (error)\n\t\t\tgoto out;\n\t\tip->i_res->rs_qa_qd_num++;\n\t\tqd++;\n\t}\n\n\tif (!gid_eq(gid, NO_GID_QUOTA_CHANGE) &&\n\t    !gid_eq(gid, ip->i_inode.i_gid)) {\n\t\terror = qdsb_get(sdp, make_kqid_gid(gid), qd);\n\t\tif (error)\n\t\t\tgoto out;\n\t\tip->i_res->rs_qa_qd_num++;\n\t\tqd++;\n\t}\n\nout:\n\tif (error)\n\t\tgfs2_quota_unhold(ip);\n\treturn error;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nint gfs2_quota_hold(struct gfs2_inode *ip, kuid_t uid, kgid_t gid)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tstruct gfs2_quota_data **qd;\n\tint error;\n\n\tif (ip->i_res == NULL) {\n\t\terror = gfs2_rs_alloc(ip);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\tqd = ip->i_res->rs_qa_qd;\n\n\tif (gfs2_assert_warn(sdp, !ip->i_res->rs_qa_qd_num) ||\n\t    gfs2_assert_warn(sdp, !test_bit(GIF_QD_LOCKED, &ip->i_flags)))\n\t\treturn -EIO;\n\n\tif (sdp->sd_args.ar_quota == GFS2_QUOTA_OFF)\n\t\treturn 0;\n\n\terror = qdsb_get(sdp, make_kqid_uid(ip->i_inode.i_uid), qd);\n\tif (error)\n\t\tgoto out;\n\tip->i_res->rs_qa_qd_num++;\n\tqd++;\n\n\terror = qdsb_get(sdp, make_kqid_gid(ip->i_inode.i_gid), qd);\n\tif (error)\n\t\tgoto out;\n\tip->i_res->rs_qa_qd_num++;\n\tqd++;\n\n\tif (!uid_eq(uid, NO_UID_QUOTA_CHANGE) &&\n\t    !uid_eq(uid, ip->i_inode.i_uid)) {\n\t\terror = qdsb_get(sdp, make_kqid_uid(uid), qd);\n\t\tif (error)\n\t\t\tgoto out;\n\t\tip->i_res->rs_qa_qd_num++;\n\t\tqd++;\n\t}\n\n\tif (!gid_eq(gid, NO_GID_QUOTA_CHANGE) &&\n\t    !gid_eq(gid, ip->i_inode.i_gid)) {\n\t\terror = qdsb_get(sdp, make_kqid_gid(gid), qd);\n\t\tif (error)\n\t\t\tgoto out;\n\t\tip->i_res->rs_qa_qd_num++;\n\t\tqd++;\n\t}\n\nout:\n\tif (error)\n\t\tgfs2_quota_unhold(ip);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_rindex_update",
          "args": [
            "GFS2_SB(&ip->i_inode)"
          ],
          "line": 1462
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_rindex_update",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
          "lines": "1029-1052",
          "snippet": "int gfs2_rindex_update(struct gfs2_sbd *sdp)\n{\n\tstruct gfs2_inode *ip = GFS2_I(sdp->sd_rindex);\n\tstruct gfs2_glock *gl = ip->i_gl;\n\tstruct gfs2_holder ri_gh;\n\tint error = 0;\n\tint unlock_required = 0;\n\n\t/* Read new copy from disk if we don't have the latest */\n\tif (!sdp->sd_rindex_uptodate) {\n\t\tif (!gfs2_glock_is_locked_by_me(gl)) {\n\t\t\terror = gfs2_glock_nq_init(gl, LM_ST_SHARED, 0, &ri_gh);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\tunlock_required = 1;\n\t\t}\n\t\tif (!sdp->sd_rindex_uptodate)\n\t\t\terror = gfs2_ri_update(ip);\n\t\tif (unlock_required)\n\t\t\tgfs2_glock_dq_uninit(&ri_gh);\n\t}\n\n\treturn error;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"inode.h\"",
            "#include \"log.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/random.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nint gfs2_rindex_update(struct gfs2_sbd *sdp)\n{\n\tstruct gfs2_inode *ip = GFS2_I(sdp->sd_rindex);\n\tstruct gfs2_glock *gl = ip->i_gl;\n\tstruct gfs2_holder ri_gh;\n\tint error = 0;\n\tint unlock_required = 0;\n\n\t/* Read new copy from disk if we don't have the latest */\n\tif (!sdp->sd_rindex_uptodate) {\n\t\tif (!gfs2_glock_is_locked_by_me(gl)) {\n\t\t\terror = gfs2_glock_nq_init(gl, LM_ST_SHARED, 0, &ri_gh);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\tunlock_required = 1;\n\t\t}\n\t\tif (!sdp->sd_rindex_uptodate)\n\t\t\terror = gfs2_ri_update(ip);\n\t\tif (unlock_required)\n\t\t\tgfs2_glock_dq_uninit(&ri_gh);\n\t}\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GFS2_SB",
          "args": [
            "&ip->i_inode"
          ],
          "line": 1462
        },
        "resolved": true,
        "details": {
          "function_name": "GFS2_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/incore.h",
          "lines": "413-416",
          "snippet": "static inline struct gfs2_sbd *GFS2_SB(const struct inode *inode)\n{\n\treturn inode->i_sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/lockref.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ktime.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/completion.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dlm.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockref.h>\n#include <linux/percpu.h>\n#include <linux/ktime.h>\n#include <linux/rbtree.h>\n#include <linux/completion.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/buffer_head.h>\n#include <linux/dlm.h>\n#include <linux/workqueue.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n\nstatic inline struct gfs2_sbd *GFS2_SB(const struct inode *inode)\n{\n\treturn inode->i_sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nint gfs2_ea_dealloc(struct gfs2_inode *ip)\n{\n\tint error;\n\n\terror = gfs2_rindex_update(GFS2_SB(&ip->i_inode));\n\tif (error)\n\t\treturn error;\n\n\terror = gfs2_quota_hold(ip, NO_UID_QUOTA_CHANGE, NO_GID_QUOTA_CHANGE);\n\tif (error)\n\t\treturn error;\n\n\terror = ea_foreach(ip, ea_dealloc_unstuffed, NULL);\n\tif (error)\n\t\tgoto out_quota;\n\n\tif (ip->i_diskflags & GFS2_DIF_EA_INDIRECT) {\n\t\terror = ea_dealloc_indirect(ip);\n\t\tif (error)\n\t\t\tgoto out_quota;\n\t}\n\n\terror = ea_dealloc_block(ip);\n\nout_quota:\n\tgfs2_quota_unhold(ip);\n\treturn error;\n}"
  },
  {
    "function_name": "ea_dealloc_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
    "lines": "1405-1449",
    "snippet": "static int ea_dealloc_block(struct gfs2_inode *ip)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tstruct gfs2_rgrpd *rgd;\n\tstruct buffer_head *dibh;\n\tstruct gfs2_holder gh;\n\tint error;\n\n\terror = gfs2_rindex_update(sdp);\n\tif (error)\n\t\treturn error;\n\n\trgd = gfs2_blk2rgrpd(sdp, ip->i_eattr, 1);\n\tif (!rgd) {\n\t\tgfs2_consist_inode(ip);\n\t\treturn -EIO;\n\t}\n\n\terror = gfs2_glock_nq_init(rgd->rd_gl, LM_ST_EXCLUSIVE, 0, &gh);\n\tif (error)\n\t\treturn error;\n\n\terror = gfs2_trans_begin(sdp, RES_RG_BIT + RES_DINODE + RES_STATFS +\n\t\t\t\t RES_QUOTA, 1);\n\tif (error)\n\t\tgoto out_gunlock;\n\n\tgfs2_free_meta(ip, ip->i_eattr, 1);\n\n\tip->i_eattr = 0;\n\tgfs2_add_inode_blocks(&ip->i_inode, -1);\n\n\terror = gfs2_meta_inode_buffer(ip, &dibh);\n\tif (!error) {\n\t\tgfs2_trans_add_meta(ip->i_gl, dibh);\n\t\tgfs2_dinode_out(ip, dibh->b_data);\n\t\tbrelse(dibh);\n\t}\n\n\tgfs2_trans_end(sdp);\n\nout_gunlock:\n\tgfs2_glock_dq_uninit(&gh);\n\treturn error;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"trans.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"inode.h\"",
      "#include \"glock.h\"",
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/xattr.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "gfs2_glock_dq_uninit",
          "args": [
            "&gh"
          ],
          "line": 1447
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_glock_dq_uninit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/glock.c",
          "lines": "1110-1114",
          "snippet": "void gfs2_glock_dq_uninit(struct gfs2_holder *gh)\n{\n\tgfs2_glock_dq(gh);\n\tgfs2_holder_uninit(gh);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"bmap.h\"",
            "#include \"util.h\"",
            "#include \"super.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/lockref.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jhash.h>",
            "#include <linux/sort.h>",
            "#include <linux/delay.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"bmap.h\"\n#include \"util.h\"\n#include \"super.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/lockref.h>\n#include <linux/list_sort.h>\n#include <linux/percpu.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/jiffies.h>\n#include <linux/workqueue.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/module.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/jhash.h>\n#include <linux/sort.h>\n#include <linux/delay.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_glock_dq_uninit(struct gfs2_holder *gh)\n{\n\tgfs2_glock_dq(gh);\n\tgfs2_holder_uninit(gh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_trans_end",
          "args": [
            "sdp"
          ],
          "line": 1444
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_trans_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/trans.c",
          "lines": "88-123",
          "snippet": "void gfs2_trans_end(struct gfs2_sbd *sdp)\n{\n\tstruct gfs2_trans *tr = current->journal_info;\n\ts64 nbuf;\n\tint alloced = tr->tr_alloced;\n\n\tBUG_ON(!tr);\n\tcurrent->journal_info = NULL;\n\n\tif (!tr->tr_touched) {\n\t\tgfs2_log_release(sdp, tr->tr_reserved);\n\t\tif (alloced) {\n\t\t\tkfree(tr);\n\t\t\tsb_end_intwrite(sdp->sd_vfs);\n\t\t}\n\t\treturn;\n\t}\n\n\tnbuf = tr->tr_num_buf_new + tr->tr_num_databuf_new;\n\tnbuf -= tr->tr_num_buf_rm;\n\tnbuf -= tr->tr_num_databuf_rm;\n\n\tif (gfs2_assert_withdraw(sdp, (nbuf <= tr->tr_blocks) &&\n\t\t\t\t       (tr->tr_num_revoke <= tr->tr_revokes)))\n\t\tgfs2_print_trans(tr);\n\n\tgfs2_log_commit(sdp, tr);\n\tif (alloced && !tr->tr_attached)\n\t\t\tkfree(tr);\n\tup_read(&sdp->sd_log_flush_lock);\n\n\tif (sdp->sd_vfs->s_flags & MS_SYNCHRONOUS)\n\t\tgfs2_log_flush(sdp, NULL, NORMAL_FLUSH);\n\tif (alloced)\n\t\tsb_end_intwrite(sdp->sd_vfs);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_trans_end(struct gfs2_sbd *sdp)\n{\n\tstruct gfs2_trans *tr = current->journal_info;\n\ts64 nbuf;\n\tint alloced = tr->tr_alloced;\n\n\tBUG_ON(!tr);\n\tcurrent->journal_info = NULL;\n\n\tif (!tr->tr_touched) {\n\t\tgfs2_log_release(sdp, tr->tr_reserved);\n\t\tif (alloced) {\n\t\t\tkfree(tr);\n\t\t\tsb_end_intwrite(sdp->sd_vfs);\n\t\t}\n\t\treturn;\n\t}\n\n\tnbuf = tr->tr_num_buf_new + tr->tr_num_databuf_new;\n\tnbuf -= tr->tr_num_buf_rm;\n\tnbuf -= tr->tr_num_databuf_rm;\n\n\tif (gfs2_assert_withdraw(sdp, (nbuf <= tr->tr_blocks) &&\n\t\t\t\t       (tr->tr_num_revoke <= tr->tr_revokes)))\n\t\tgfs2_print_trans(tr);\n\n\tgfs2_log_commit(sdp, tr);\n\tif (alloced && !tr->tr_attached)\n\t\t\tkfree(tr);\n\tup_read(&sdp->sd_log_flush_lock);\n\n\tif (sdp->sd_vfs->s_flags & MS_SYNCHRONOUS)\n\t\tgfs2_log_flush(sdp, NULL, NORMAL_FLUSH);\n\tif (alloced)\n\t\tsb_end_intwrite(sdp->sd_vfs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "dibh"
          ],
          "line": 1441
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_dinode_out",
          "args": [
            "ip",
            "dibh->b_data"
          ],
          "line": 1440
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_dinode_out",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/super.c",
          "lines": "696-731",
          "snippet": "void gfs2_dinode_out(const struct gfs2_inode *ip, void *buf)\n{\n\tstruct gfs2_dinode *str = buf;\n\n\tstr->di_header.mh_magic = cpu_to_be32(GFS2_MAGIC);\n\tstr->di_header.mh_type = cpu_to_be32(GFS2_METATYPE_DI);\n\tstr->di_header.mh_format = cpu_to_be32(GFS2_FORMAT_DI);\n\tstr->di_num.no_addr = cpu_to_be64(ip->i_no_addr);\n\tstr->di_num.no_formal_ino = cpu_to_be64(ip->i_no_formal_ino);\n\tstr->di_mode = cpu_to_be32(ip->i_inode.i_mode);\n\tstr->di_uid = cpu_to_be32(i_uid_read(&ip->i_inode));\n\tstr->di_gid = cpu_to_be32(i_gid_read(&ip->i_inode));\n\tstr->di_nlink = cpu_to_be32(ip->i_inode.i_nlink);\n\tstr->di_size = cpu_to_be64(i_size_read(&ip->i_inode));\n\tstr->di_blocks = cpu_to_be64(gfs2_get_inode_blocks(&ip->i_inode));\n\tstr->di_atime = cpu_to_be64(ip->i_inode.i_atime.tv_sec);\n\tstr->di_mtime = cpu_to_be64(ip->i_inode.i_mtime.tv_sec);\n\tstr->di_ctime = cpu_to_be64(ip->i_inode.i_ctime.tv_sec);\n\n\tstr->di_goal_meta = cpu_to_be64(ip->i_goal);\n\tstr->di_goal_data = cpu_to_be64(ip->i_goal);\n\tstr->di_generation = cpu_to_be64(ip->i_generation);\n\n\tstr->di_flags = cpu_to_be32(ip->i_diskflags);\n\tstr->di_height = cpu_to_be16(ip->i_height);\n\tstr->di_payload_format = cpu_to_be32(S_ISDIR(ip->i_inode.i_mode) &&\n\t\t\t\t\t     !(ip->i_diskflags & GFS2_DIF_EXHASH) ?\n\t\t\t\t\t     GFS2_FORMAT_DE : 0);\n\tstr->di_depth = cpu_to_be16(ip->i_depth);\n\tstr->di_entries = cpu_to_be32(ip->i_entries);\n\n\tstr->di_eattr = cpu_to_be64(ip->i_eattr);\n\tstr->di_atime_nsec = cpu_to_be32(ip->i_inode.i_atime.tv_nsec);\n\tstr->di_mtime_nsec = cpu_to_be32(ip->i_inode.i_mtime.tv_nsec);\n\tstr->di_ctime_nsec = cpu_to_be32(ip->i_inode.i_ctime.tv_nsec);\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"sys.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"recovery.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"dir.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/kernel.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/time.h>",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/statfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/bio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"sys.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"recovery.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"dir.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/kernel.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/time.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/statfs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/bio.h>\n\nvoid gfs2_dinode_out(const struct gfs2_inode *ip, void *buf)\n{\n\tstruct gfs2_dinode *str = buf;\n\n\tstr->di_header.mh_magic = cpu_to_be32(GFS2_MAGIC);\n\tstr->di_header.mh_type = cpu_to_be32(GFS2_METATYPE_DI);\n\tstr->di_header.mh_format = cpu_to_be32(GFS2_FORMAT_DI);\n\tstr->di_num.no_addr = cpu_to_be64(ip->i_no_addr);\n\tstr->di_num.no_formal_ino = cpu_to_be64(ip->i_no_formal_ino);\n\tstr->di_mode = cpu_to_be32(ip->i_inode.i_mode);\n\tstr->di_uid = cpu_to_be32(i_uid_read(&ip->i_inode));\n\tstr->di_gid = cpu_to_be32(i_gid_read(&ip->i_inode));\n\tstr->di_nlink = cpu_to_be32(ip->i_inode.i_nlink);\n\tstr->di_size = cpu_to_be64(i_size_read(&ip->i_inode));\n\tstr->di_blocks = cpu_to_be64(gfs2_get_inode_blocks(&ip->i_inode));\n\tstr->di_atime = cpu_to_be64(ip->i_inode.i_atime.tv_sec);\n\tstr->di_mtime = cpu_to_be64(ip->i_inode.i_mtime.tv_sec);\n\tstr->di_ctime = cpu_to_be64(ip->i_inode.i_ctime.tv_sec);\n\n\tstr->di_goal_meta = cpu_to_be64(ip->i_goal);\n\tstr->di_goal_data = cpu_to_be64(ip->i_goal);\n\tstr->di_generation = cpu_to_be64(ip->i_generation);\n\n\tstr->di_flags = cpu_to_be32(ip->i_diskflags);\n\tstr->di_height = cpu_to_be16(ip->i_height);\n\tstr->di_payload_format = cpu_to_be32(S_ISDIR(ip->i_inode.i_mode) &&\n\t\t\t\t\t     !(ip->i_diskflags & GFS2_DIF_EXHASH) ?\n\t\t\t\t\t     GFS2_FORMAT_DE : 0);\n\tstr->di_depth = cpu_to_be16(ip->i_depth);\n\tstr->di_entries = cpu_to_be32(ip->i_entries);\n\n\tstr->di_eattr = cpu_to_be64(ip->i_eattr);\n\tstr->di_atime_nsec = cpu_to_be32(ip->i_inode.i_atime.tv_nsec);\n\tstr->di_mtime_nsec = cpu_to_be32(ip->i_inode.i_mtime.tv_nsec);\n\tstr->di_ctime_nsec = cpu_to_be32(ip->i_inode.i_ctime.tv_nsec);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_trans_add_meta",
          "args": [
            "ip->i_gl",
            "dibh"
          ],
          "line": 1439
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_trans_add_meta",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/trans.c",
          "lines": "224-247",
          "snippet": "void gfs2_trans_add_meta(struct gfs2_glock *gl, struct buffer_head *bh)\n{\n\n\tstruct gfs2_sbd *sdp = gl->gl_sbd;\n\tstruct gfs2_bufdata *bd;\n\n\tlock_buffer(bh);\n\tgfs2_log_lock(sdp);\n\tbd = bh->b_private;\n\tif (bd == NULL) {\n\t\tgfs2_log_unlock(sdp);\n\t\tunlock_buffer(bh);\n\t\tlock_page(bh->b_page);\n\t\tif (bh->b_private == NULL)\n\t\t\tbd = gfs2_alloc_bufdata(gl, bh, &gfs2_buf_lops);\n\t\tunlock_page(bh->b_page);\n\t\tlock_buffer(bh);\n\t\tgfs2_log_lock(sdp);\n\t}\n\tgfs2_assert(sdp, bd->bd_gl == gl);\n\tmeta_lo_add(sdp, bd);\n\tgfs2_log_unlock(sdp);\n\tunlock_buffer(bh);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_trans_add_meta(struct gfs2_glock *gl, struct buffer_head *bh)\n{\n\n\tstruct gfs2_sbd *sdp = gl->gl_sbd;\n\tstruct gfs2_bufdata *bd;\n\n\tlock_buffer(bh);\n\tgfs2_log_lock(sdp);\n\tbd = bh->b_private;\n\tif (bd == NULL) {\n\t\tgfs2_log_unlock(sdp);\n\t\tunlock_buffer(bh);\n\t\tlock_page(bh->b_page);\n\t\tif (bh->b_private == NULL)\n\t\t\tbd = gfs2_alloc_bufdata(gl, bh, &gfs2_buf_lops);\n\t\tunlock_page(bh->b_page);\n\t\tlock_buffer(bh);\n\t\tgfs2_log_lock(sdp);\n\t}\n\tgfs2_assert(sdp, bd->bd_gl == gl);\n\tmeta_lo_add(sdp, bd);\n\tgfs2_log_unlock(sdp);\n\tunlock_buffer(bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_meta_inode_buffer",
          "args": [
            "ip",
            "&dibh"
          ],
          "line": 1437
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_meta_inode_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/meta_io.h",
          "lines": "66-70",
          "snippet": "static inline int gfs2_meta_inode_buffer(struct gfs2_inode *ip,\n\t\t\t\t\t struct buffer_head **bhp)\n{\n\treturn gfs2_meta_indirect_buffer(ip, 0, ip->i_no_addr, bhp);\n}",
          "includes": [
            "#include \"incore.h\"",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"incore.h\"\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline int gfs2_meta_inode_buffer(struct gfs2_inode *ip,\n\t\t\t\t\t struct buffer_head **bhp)\n{\n\treturn gfs2_meta_indirect_buffer(ip, 0, ip->i_no_addr, bhp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_add_inode_blocks",
          "args": [
            "&ip->i_inode",
            "-1"
          ],
          "line": 1435
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_add_inode_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/inode.h",
          "lines": "62-67",
          "snippet": "static inline void gfs2_add_inode_blocks(struct inode *inode, s64 change)\n{\n\tgfs2_assert(GFS2_SB(inode), (change >= 0 || inode->i_blocks > -change));\n\tchange *= (GFS2_SB(inode)->sd_sb.sb_bsize/GFS2_BASIC_BLOCK);\n\tinode->i_blocks += change;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include <linux/mm.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <linux/mm.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic inline void gfs2_add_inode_blocks(struct inode *inode, s64 change)\n{\n\tgfs2_assert(GFS2_SB(inode), (change >= 0 || inode->i_blocks > -change));\n\tchange *= (GFS2_SB(inode)->sd_sb.sb_bsize/GFS2_BASIC_BLOCK);\n\tinode->i_blocks += change;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_free_meta",
          "args": [
            "ip",
            "ip->i_eattr",
            "1"
          ],
          "line": 1432
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_free_meta",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
          "lines": "2424-2431",
          "snippet": "void gfs2_free_meta(struct gfs2_inode *ip, u64 bstart, u32 blen)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\n\t__gfs2_free_blocks(ip, bstart, blen, 1);\n\tgfs2_statfs_change(sdp, 0, +blen, 0);\n\tgfs2_quota_change(ip, -(s64)blen, ip->i_inode.i_uid, ip->i_inode.i_gid);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"inode.h\"",
            "#include \"log.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/random.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nvoid gfs2_free_meta(struct gfs2_inode *ip, u64 bstart, u32 blen)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\n\t__gfs2_free_blocks(ip, bstart, blen, 1);\n\tgfs2_statfs_change(sdp, 0, +blen, 0);\n\tgfs2_quota_change(ip, -(s64)blen, ip->i_inode.i_uid, ip->i_inode.i_gid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_trans_begin",
          "args": [
            "sdp",
            "RES_RG_BIT + RES_DINODE + RES_STATFS +\n\t\t\t\t RES_QUOTA",
            "1"
          ],
          "line": 1427
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_trans_begin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/trans.c",
          "lines": "31-75",
          "snippet": "int gfs2_trans_begin(struct gfs2_sbd *sdp, unsigned int blocks,\n\t\t     unsigned int revokes)\n{\n\tstruct gfs2_trans *tr;\n\tint error;\n\n\tBUG_ON(current->journal_info);\n\tBUG_ON(blocks == 0 && revokes == 0);\n\n\tif (!test_bit(SDF_JOURNAL_LIVE, &sdp->sd_flags))\n\t\treturn -EROFS;\n\n\ttr = kzalloc(sizeof(struct gfs2_trans), GFP_NOFS);\n\tif (!tr)\n\t\treturn -ENOMEM;\n\n\ttr->tr_ip = _RET_IP_;\n\ttr->tr_blocks = blocks;\n\ttr->tr_revokes = revokes;\n\ttr->tr_reserved = 1;\n\ttr->tr_alloced = 1;\n\tif (blocks)\n\t\ttr->tr_reserved += 6 + blocks;\n\tif (revokes)\n\t\ttr->tr_reserved += gfs2_struct2blk(sdp, revokes,\n\t\t\t\t\t\t   sizeof(u64));\n\tINIT_LIST_HEAD(&tr->tr_databuf);\n\tINIT_LIST_HEAD(&tr->tr_buf);\n\n\tsb_start_intwrite(sdp->sd_vfs);\n\n\terror = gfs2_log_reserve(sdp, tr->tr_reserved);\n\tif (error)\n\t\tgoto fail;\n\n\tcurrent->journal_info = tr;\n\n\treturn 0;\n\nfail:\n\tsb_end_intwrite(sdp->sd_vfs);\n\tkfree(tr);\n\n\treturn error;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nint gfs2_trans_begin(struct gfs2_sbd *sdp, unsigned int blocks,\n\t\t     unsigned int revokes)\n{\n\tstruct gfs2_trans *tr;\n\tint error;\n\n\tBUG_ON(current->journal_info);\n\tBUG_ON(blocks == 0 && revokes == 0);\n\n\tif (!test_bit(SDF_JOURNAL_LIVE, &sdp->sd_flags))\n\t\treturn -EROFS;\n\n\ttr = kzalloc(sizeof(struct gfs2_trans), GFP_NOFS);\n\tif (!tr)\n\t\treturn -ENOMEM;\n\n\ttr->tr_ip = _RET_IP_;\n\ttr->tr_blocks = blocks;\n\ttr->tr_revokes = revokes;\n\ttr->tr_reserved = 1;\n\ttr->tr_alloced = 1;\n\tif (blocks)\n\t\ttr->tr_reserved += 6 + blocks;\n\tif (revokes)\n\t\ttr->tr_reserved += gfs2_struct2blk(sdp, revokes,\n\t\t\t\t\t\t   sizeof(u64));\n\tINIT_LIST_HEAD(&tr->tr_databuf);\n\tINIT_LIST_HEAD(&tr->tr_buf);\n\n\tsb_start_intwrite(sdp->sd_vfs);\n\n\terror = gfs2_log_reserve(sdp, tr->tr_reserved);\n\tif (error)\n\t\tgoto fail;\n\n\tcurrent->journal_info = tr;\n\n\treturn 0;\n\nfail:\n\tsb_end_intwrite(sdp->sd_vfs);\n\tkfree(tr);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_glock_nq_init",
          "args": [
            "rgd->rd_gl",
            "LM_ST_EXCLUSIVE",
            "0",
            "&gh"
          ],
          "line": 1423
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_glock_nq_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/glock.h",
          "lines": "204-230",
          "snippet": "extern __printf(2, 3)\nvoid gfs2_print_dbg(struct seq_file *seq, const char *fmt, ...);\n\n/**\n * gfs2_glock_nq_init - initialize a holder and enqueue it on a glock\n * @gl: the glock\n * @state: the state we're requesting\n * @flags: the modifier flags\n * @gh: the holder structure\n *\n * Returns: 0, GLR_*, or errno\n */\n\nstatic inline int gfs2_glock_nq_init(struct gfs2_glock *gl,\n\t\t\t\t     unsigned int state, int flags,\n\t\t\t\t     struct gfs2_holder *gh)\n{\n\tint error;\n\n\tgfs2_holder_init(gl, state, flags, gh);\n\n\terror = gfs2_glock_nq(gh);\n\tif (error)\n\t\tgfs2_holder_uninit(gh);\n\n\treturn error;\n}",
          "includes": [
            "#include \"incore.h\"",
            "#include <linux/parser.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"incore.h\"\n#include <linux/parser.h>\n#include <linux/sched.h>\n\nextern __printf(2, 3)\nvoid gfs2_print_dbg(struct seq_file *seq, const char *fmt, ...);\n\n/**\n * gfs2_glock_nq_init - initialize a holder and enqueue it on a glock\n * @gl: the glock\n * @state: the state we're requesting\n * @flags: the modifier flags\n * @gh: the holder structure\n *\n * Returns: 0, GLR_*, or errno\n */\n\nstatic inline int gfs2_glock_nq_init(struct gfs2_glock *gl,\n\t\t\t\t     unsigned int state, int flags,\n\t\t\t\t     struct gfs2_holder *gh)\n{\n\tint error;\n\n\tgfs2_holder_init(gl, state, flags, gh);\n\n\terror = gfs2_glock_nq(gh);\n\tif (error)\n\t\tgfs2_holder_uninit(gh);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_consist_inode",
          "args": [
            "ip"
          ],
          "line": 1419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_blk2rgrpd",
          "args": [
            "sdp",
            "ip->i_eattr",
            "1"
          ],
          "line": 1417
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_blk2rgrpd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
          "lines": "503-532",
          "snippet": "struct gfs2_rgrpd *gfs2_blk2rgrpd(struct gfs2_sbd *sdp, u64 blk, bool exact)\n{\n\tstruct rb_node *n, *next;\n\tstruct gfs2_rgrpd *cur;\n\n\tspin_lock(&sdp->sd_rindex_spin);\n\tn = sdp->sd_rindex_tree.rb_node;\n\twhile (n) {\n\t\tcur = rb_entry(n, struct gfs2_rgrpd, rd_node);\n\t\tnext = NULL;\n\t\tif (blk < cur->rd_addr)\n\t\t\tnext = n->rb_left;\n\t\telse if (blk >= cur->rd_data0 + cur->rd_data)\n\t\t\tnext = n->rb_right;\n\t\tif (next == NULL) {\n\t\t\tspin_unlock(&sdp->sd_rindex_spin);\n\t\t\tif (exact) {\n\t\t\t\tif (blk < cur->rd_addr)\n\t\t\t\t\treturn NULL;\n\t\t\t\tif (blk >= cur->rd_data0 + cur->rd_data)\n\t\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\treturn cur;\n\t\t}\n\t\tn = next;\n\t}\n\tspin_unlock(&sdp->sd_rindex_spin);\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"inode.h\"",
            "#include \"log.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/random.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstruct gfs2_rgrpd *gfs2_blk2rgrpd(struct gfs2_sbd *sdp, u64 blk, bool exact)\n{\n\tstruct rb_node *n, *next;\n\tstruct gfs2_rgrpd *cur;\n\n\tspin_lock(&sdp->sd_rindex_spin);\n\tn = sdp->sd_rindex_tree.rb_node;\n\twhile (n) {\n\t\tcur = rb_entry(n, struct gfs2_rgrpd, rd_node);\n\t\tnext = NULL;\n\t\tif (blk < cur->rd_addr)\n\t\t\tnext = n->rb_left;\n\t\telse if (blk >= cur->rd_data0 + cur->rd_data)\n\t\t\tnext = n->rb_right;\n\t\tif (next == NULL) {\n\t\t\tspin_unlock(&sdp->sd_rindex_spin);\n\t\t\tif (exact) {\n\t\t\t\tif (blk < cur->rd_addr)\n\t\t\t\t\treturn NULL;\n\t\t\t\tif (blk >= cur->rd_data0 + cur->rd_data)\n\t\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\treturn cur;\n\t\t}\n\t\tn = next;\n\t}\n\tspin_unlock(&sdp->sd_rindex_spin);\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_rindex_update",
          "args": [
            "sdp"
          ],
          "line": 1413
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_rindex_update",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
          "lines": "1029-1052",
          "snippet": "int gfs2_rindex_update(struct gfs2_sbd *sdp)\n{\n\tstruct gfs2_inode *ip = GFS2_I(sdp->sd_rindex);\n\tstruct gfs2_glock *gl = ip->i_gl;\n\tstruct gfs2_holder ri_gh;\n\tint error = 0;\n\tint unlock_required = 0;\n\n\t/* Read new copy from disk if we don't have the latest */\n\tif (!sdp->sd_rindex_uptodate) {\n\t\tif (!gfs2_glock_is_locked_by_me(gl)) {\n\t\t\terror = gfs2_glock_nq_init(gl, LM_ST_SHARED, 0, &ri_gh);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\tunlock_required = 1;\n\t\t}\n\t\tif (!sdp->sd_rindex_uptodate)\n\t\t\terror = gfs2_ri_update(ip);\n\t\tif (unlock_required)\n\t\t\tgfs2_glock_dq_uninit(&ri_gh);\n\t}\n\n\treturn error;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"inode.h\"",
            "#include \"log.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/random.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nint gfs2_rindex_update(struct gfs2_sbd *sdp)\n{\n\tstruct gfs2_inode *ip = GFS2_I(sdp->sd_rindex);\n\tstruct gfs2_glock *gl = ip->i_gl;\n\tstruct gfs2_holder ri_gh;\n\tint error = 0;\n\tint unlock_required = 0;\n\n\t/* Read new copy from disk if we don't have the latest */\n\tif (!sdp->sd_rindex_uptodate) {\n\t\tif (!gfs2_glock_is_locked_by_me(gl)) {\n\t\t\terror = gfs2_glock_nq_init(gl, LM_ST_SHARED, 0, &ri_gh);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\tunlock_required = 1;\n\t\t}\n\t\tif (!sdp->sd_rindex_uptodate)\n\t\t\terror = gfs2_ri_update(ip);\n\t\tif (unlock_required)\n\t\t\tgfs2_glock_dq_uninit(&ri_gh);\n\t}\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GFS2_SB",
          "args": [
            "&ip->i_inode"
          ],
          "line": 1407
        },
        "resolved": true,
        "details": {
          "function_name": "GFS2_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/incore.h",
          "lines": "413-416",
          "snippet": "static inline struct gfs2_sbd *GFS2_SB(const struct inode *inode)\n{\n\treturn inode->i_sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/lockref.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ktime.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/completion.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dlm.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockref.h>\n#include <linux/percpu.h>\n#include <linux/ktime.h>\n#include <linux/rbtree.h>\n#include <linux/completion.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/buffer_head.h>\n#include <linux/dlm.h>\n#include <linux/workqueue.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n\nstatic inline struct gfs2_sbd *GFS2_SB(const struct inode *inode)\n{\n\treturn inode->i_sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic int ea_dealloc_block(struct gfs2_inode *ip)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tstruct gfs2_rgrpd *rgd;\n\tstruct buffer_head *dibh;\n\tstruct gfs2_holder gh;\n\tint error;\n\n\terror = gfs2_rindex_update(sdp);\n\tif (error)\n\t\treturn error;\n\n\trgd = gfs2_blk2rgrpd(sdp, ip->i_eattr, 1);\n\tif (!rgd) {\n\t\tgfs2_consist_inode(ip);\n\t\treturn -EIO;\n\t}\n\n\terror = gfs2_glock_nq_init(rgd->rd_gl, LM_ST_EXCLUSIVE, 0, &gh);\n\tif (error)\n\t\treturn error;\n\n\terror = gfs2_trans_begin(sdp, RES_RG_BIT + RES_DINODE + RES_STATFS +\n\t\t\t\t RES_QUOTA, 1);\n\tif (error)\n\t\tgoto out_gunlock;\n\n\tgfs2_free_meta(ip, ip->i_eattr, 1);\n\n\tip->i_eattr = 0;\n\tgfs2_add_inode_blocks(&ip->i_inode, -1);\n\n\terror = gfs2_meta_inode_buffer(ip, &dibh);\n\tif (!error) {\n\t\tgfs2_trans_add_meta(ip->i_gl, dibh);\n\t\tgfs2_dinode_out(ip, dibh->b_data);\n\t\tbrelse(dibh);\n\t}\n\n\tgfs2_trans_end(sdp);\n\nout_gunlock:\n\tgfs2_glock_dq_uninit(&gh);\n\treturn error;\n}"
  },
  {
    "function_name": "ea_dealloc_indirect",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
    "lines": "1287-1403",
    "snippet": "static int ea_dealloc_indirect(struct gfs2_inode *ip)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tstruct gfs2_rgrp_list rlist;\n\tstruct buffer_head *indbh, *dibh;\n\t__be64 *eablk, *end;\n\tunsigned int rg_blocks = 0;\n\tu64 bstart = 0;\n\tunsigned int blen = 0;\n\tunsigned int blks = 0;\n\tunsigned int x;\n\tint error;\n\n\terror = gfs2_rindex_update(sdp);\n\tif (error)\n\t\treturn error;\n\n\tmemset(&rlist, 0, sizeof(struct gfs2_rgrp_list));\n\n\terror = gfs2_meta_read(ip->i_gl, ip->i_eattr, DIO_WAIT, &indbh);\n\tif (error)\n\t\treturn error;\n\n\tif (gfs2_metatype_check(sdp, indbh, GFS2_METATYPE_IN)) {\n\t\terror = -EIO;\n\t\tgoto out;\n\t}\n\n\teablk = (__be64 *)(indbh->b_data + sizeof(struct gfs2_meta_header));\n\tend = eablk + sdp->sd_inptrs;\n\n\tfor (; eablk < end; eablk++) {\n\t\tu64 bn;\n\n\t\tif (!*eablk)\n\t\t\tbreak;\n\t\tbn = be64_to_cpu(*eablk);\n\n\t\tif (bstart + blen == bn)\n\t\t\tblen++;\n\t\telse {\n\t\t\tif (bstart)\n\t\t\t\tgfs2_rlist_add(ip, &rlist, bstart);\n\t\t\tbstart = bn;\n\t\t\tblen = 1;\n\t\t}\n\t\tblks++;\n\t}\n\tif (bstart)\n\t\tgfs2_rlist_add(ip, &rlist, bstart);\n\telse\n\t\tgoto out;\n\n\tgfs2_rlist_alloc(&rlist, LM_ST_EXCLUSIVE);\n\n\tfor (x = 0; x < rlist.rl_rgrps; x++) {\n\t\tstruct gfs2_rgrpd *rgd;\n\t\trgd = rlist.rl_ghs[x].gh_gl->gl_object;\n\t\trg_blocks += rgd->rd_length;\n\t}\n\n\terror = gfs2_glock_nq_m(rlist.rl_rgrps, rlist.rl_ghs);\n\tif (error)\n\t\tgoto out_rlist_free;\n\n\terror = gfs2_trans_begin(sdp, rg_blocks + RES_DINODE + RES_INDIRECT +\n\t\t\t\t RES_STATFS + RES_QUOTA, blks);\n\tif (error)\n\t\tgoto out_gunlock;\n\n\tgfs2_trans_add_meta(ip->i_gl, indbh);\n\n\teablk = (__be64 *)(indbh->b_data + sizeof(struct gfs2_meta_header));\n\tbstart = 0;\n\tblen = 0;\n\n\tfor (; eablk < end; eablk++) {\n\t\tu64 bn;\n\n\t\tif (!*eablk)\n\t\t\tbreak;\n\t\tbn = be64_to_cpu(*eablk);\n\n\t\tif (bstart + blen == bn)\n\t\t\tblen++;\n\t\telse {\n\t\t\tif (bstart)\n\t\t\t\tgfs2_free_meta(ip, bstart, blen);\n\t\t\tbstart = bn;\n\t\t\tblen = 1;\n\t\t}\n\n\t\t*eablk = 0;\n\t\tgfs2_add_inode_blocks(&ip->i_inode, -1);\n\t}\n\tif (bstart)\n\t\tgfs2_free_meta(ip, bstart, blen);\n\n\tip->i_diskflags &= ~GFS2_DIF_EA_INDIRECT;\n\n\terror = gfs2_meta_inode_buffer(ip, &dibh);\n\tif (!error) {\n\t\tgfs2_trans_add_meta(ip->i_gl, dibh);\n\t\tgfs2_dinode_out(ip, dibh->b_data);\n\t\tbrelse(dibh);\n\t}\n\n\tgfs2_trans_end(sdp);\n\nout_gunlock:\n\tgfs2_glock_dq_m(rlist.rl_rgrps, rlist.rl_ghs);\nout_rlist_free:\n\tgfs2_rlist_free(&rlist);\nout:\n\tbrelse(indbh);\n\treturn error;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"trans.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"inode.h\"",
      "#include \"glock.h\"",
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/xattr.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "indbh"
          ],
          "line": 1401
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_rlist_free",
          "args": [
            "&rlist"
          ],
          "line": 1399
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_rlist_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
          "lines": "2600-2612",
          "snippet": "void gfs2_rlist_free(struct gfs2_rgrp_list *rlist)\n{\n\tunsigned int x;\n\n\tkfree(rlist->rl_rgd);\n\n\tif (rlist->rl_ghs) {\n\t\tfor (x = 0; x < rlist->rl_rgrps; x++)\n\t\t\tgfs2_holder_uninit(&rlist->rl_ghs[x]);\n\t\tkfree(rlist->rl_ghs);\n\t\trlist->rl_ghs = NULL;\n\t}\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"inode.h\"",
            "#include \"log.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/random.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nvoid gfs2_rlist_free(struct gfs2_rgrp_list *rlist)\n{\n\tunsigned int x;\n\n\tkfree(rlist->rl_rgd);\n\n\tif (rlist->rl_ghs) {\n\t\tfor (x = 0; x < rlist->rl_rgrps; x++)\n\t\t\tgfs2_holder_uninit(&rlist->rl_ghs[x]);\n\t\tkfree(rlist->rl_ghs);\n\t\trlist->rl_ghs = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_glock_dq_m",
          "args": [
            "rlist.rl_rgrps",
            "rlist.rl_ghs"
          ],
          "line": 1397
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_glock_dq_m",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/glock.c",
          "lines": "1245-1249",
          "snippet": "void gfs2_glock_dq_m(unsigned int num_gh, struct gfs2_holder *ghs)\n{\n\twhile (num_gh--)\n\t\tgfs2_glock_dq(&ghs[num_gh]);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"bmap.h\"",
            "#include \"util.h\"",
            "#include \"super.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/lockref.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jhash.h>",
            "#include <linux/sort.h>",
            "#include <linux/delay.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"bmap.h\"\n#include \"util.h\"\n#include \"super.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/lockref.h>\n#include <linux/list_sort.h>\n#include <linux/percpu.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/jiffies.h>\n#include <linux/workqueue.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/module.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/jhash.h>\n#include <linux/sort.h>\n#include <linux/delay.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_glock_dq_m(unsigned int num_gh, struct gfs2_holder *ghs)\n{\n\twhile (num_gh--)\n\t\tgfs2_glock_dq(&ghs[num_gh]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_trans_end",
          "args": [
            "sdp"
          ],
          "line": 1394
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_trans_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/trans.c",
          "lines": "88-123",
          "snippet": "void gfs2_trans_end(struct gfs2_sbd *sdp)\n{\n\tstruct gfs2_trans *tr = current->journal_info;\n\ts64 nbuf;\n\tint alloced = tr->tr_alloced;\n\n\tBUG_ON(!tr);\n\tcurrent->journal_info = NULL;\n\n\tif (!tr->tr_touched) {\n\t\tgfs2_log_release(sdp, tr->tr_reserved);\n\t\tif (alloced) {\n\t\t\tkfree(tr);\n\t\t\tsb_end_intwrite(sdp->sd_vfs);\n\t\t}\n\t\treturn;\n\t}\n\n\tnbuf = tr->tr_num_buf_new + tr->tr_num_databuf_new;\n\tnbuf -= tr->tr_num_buf_rm;\n\tnbuf -= tr->tr_num_databuf_rm;\n\n\tif (gfs2_assert_withdraw(sdp, (nbuf <= tr->tr_blocks) &&\n\t\t\t\t       (tr->tr_num_revoke <= tr->tr_revokes)))\n\t\tgfs2_print_trans(tr);\n\n\tgfs2_log_commit(sdp, tr);\n\tif (alloced && !tr->tr_attached)\n\t\t\tkfree(tr);\n\tup_read(&sdp->sd_log_flush_lock);\n\n\tif (sdp->sd_vfs->s_flags & MS_SYNCHRONOUS)\n\t\tgfs2_log_flush(sdp, NULL, NORMAL_FLUSH);\n\tif (alloced)\n\t\tsb_end_intwrite(sdp->sd_vfs);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_trans_end(struct gfs2_sbd *sdp)\n{\n\tstruct gfs2_trans *tr = current->journal_info;\n\ts64 nbuf;\n\tint alloced = tr->tr_alloced;\n\n\tBUG_ON(!tr);\n\tcurrent->journal_info = NULL;\n\n\tif (!tr->tr_touched) {\n\t\tgfs2_log_release(sdp, tr->tr_reserved);\n\t\tif (alloced) {\n\t\t\tkfree(tr);\n\t\t\tsb_end_intwrite(sdp->sd_vfs);\n\t\t}\n\t\treturn;\n\t}\n\n\tnbuf = tr->tr_num_buf_new + tr->tr_num_databuf_new;\n\tnbuf -= tr->tr_num_buf_rm;\n\tnbuf -= tr->tr_num_databuf_rm;\n\n\tif (gfs2_assert_withdraw(sdp, (nbuf <= tr->tr_blocks) &&\n\t\t\t\t       (tr->tr_num_revoke <= tr->tr_revokes)))\n\t\tgfs2_print_trans(tr);\n\n\tgfs2_log_commit(sdp, tr);\n\tif (alloced && !tr->tr_attached)\n\t\t\tkfree(tr);\n\tup_read(&sdp->sd_log_flush_lock);\n\n\tif (sdp->sd_vfs->s_flags & MS_SYNCHRONOUS)\n\t\tgfs2_log_flush(sdp, NULL, NORMAL_FLUSH);\n\tif (alloced)\n\t\tsb_end_intwrite(sdp->sd_vfs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_dinode_out",
          "args": [
            "ip",
            "dibh->b_data"
          ],
          "line": 1390
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_dinode_out",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/super.c",
          "lines": "696-731",
          "snippet": "void gfs2_dinode_out(const struct gfs2_inode *ip, void *buf)\n{\n\tstruct gfs2_dinode *str = buf;\n\n\tstr->di_header.mh_magic = cpu_to_be32(GFS2_MAGIC);\n\tstr->di_header.mh_type = cpu_to_be32(GFS2_METATYPE_DI);\n\tstr->di_header.mh_format = cpu_to_be32(GFS2_FORMAT_DI);\n\tstr->di_num.no_addr = cpu_to_be64(ip->i_no_addr);\n\tstr->di_num.no_formal_ino = cpu_to_be64(ip->i_no_formal_ino);\n\tstr->di_mode = cpu_to_be32(ip->i_inode.i_mode);\n\tstr->di_uid = cpu_to_be32(i_uid_read(&ip->i_inode));\n\tstr->di_gid = cpu_to_be32(i_gid_read(&ip->i_inode));\n\tstr->di_nlink = cpu_to_be32(ip->i_inode.i_nlink);\n\tstr->di_size = cpu_to_be64(i_size_read(&ip->i_inode));\n\tstr->di_blocks = cpu_to_be64(gfs2_get_inode_blocks(&ip->i_inode));\n\tstr->di_atime = cpu_to_be64(ip->i_inode.i_atime.tv_sec);\n\tstr->di_mtime = cpu_to_be64(ip->i_inode.i_mtime.tv_sec);\n\tstr->di_ctime = cpu_to_be64(ip->i_inode.i_ctime.tv_sec);\n\n\tstr->di_goal_meta = cpu_to_be64(ip->i_goal);\n\tstr->di_goal_data = cpu_to_be64(ip->i_goal);\n\tstr->di_generation = cpu_to_be64(ip->i_generation);\n\n\tstr->di_flags = cpu_to_be32(ip->i_diskflags);\n\tstr->di_height = cpu_to_be16(ip->i_height);\n\tstr->di_payload_format = cpu_to_be32(S_ISDIR(ip->i_inode.i_mode) &&\n\t\t\t\t\t     !(ip->i_diskflags & GFS2_DIF_EXHASH) ?\n\t\t\t\t\t     GFS2_FORMAT_DE : 0);\n\tstr->di_depth = cpu_to_be16(ip->i_depth);\n\tstr->di_entries = cpu_to_be32(ip->i_entries);\n\n\tstr->di_eattr = cpu_to_be64(ip->i_eattr);\n\tstr->di_atime_nsec = cpu_to_be32(ip->i_inode.i_atime.tv_nsec);\n\tstr->di_mtime_nsec = cpu_to_be32(ip->i_inode.i_mtime.tv_nsec);\n\tstr->di_ctime_nsec = cpu_to_be32(ip->i_inode.i_ctime.tv_nsec);\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"sys.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"recovery.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"dir.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/kernel.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/time.h>",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/statfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/bio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"sys.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"recovery.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"dir.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/kernel.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/time.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/statfs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/bio.h>\n\nvoid gfs2_dinode_out(const struct gfs2_inode *ip, void *buf)\n{\n\tstruct gfs2_dinode *str = buf;\n\n\tstr->di_header.mh_magic = cpu_to_be32(GFS2_MAGIC);\n\tstr->di_header.mh_type = cpu_to_be32(GFS2_METATYPE_DI);\n\tstr->di_header.mh_format = cpu_to_be32(GFS2_FORMAT_DI);\n\tstr->di_num.no_addr = cpu_to_be64(ip->i_no_addr);\n\tstr->di_num.no_formal_ino = cpu_to_be64(ip->i_no_formal_ino);\n\tstr->di_mode = cpu_to_be32(ip->i_inode.i_mode);\n\tstr->di_uid = cpu_to_be32(i_uid_read(&ip->i_inode));\n\tstr->di_gid = cpu_to_be32(i_gid_read(&ip->i_inode));\n\tstr->di_nlink = cpu_to_be32(ip->i_inode.i_nlink);\n\tstr->di_size = cpu_to_be64(i_size_read(&ip->i_inode));\n\tstr->di_blocks = cpu_to_be64(gfs2_get_inode_blocks(&ip->i_inode));\n\tstr->di_atime = cpu_to_be64(ip->i_inode.i_atime.tv_sec);\n\tstr->di_mtime = cpu_to_be64(ip->i_inode.i_mtime.tv_sec);\n\tstr->di_ctime = cpu_to_be64(ip->i_inode.i_ctime.tv_sec);\n\n\tstr->di_goal_meta = cpu_to_be64(ip->i_goal);\n\tstr->di_goal_data = cpu_to_be64(ip->i_goal);\n\tstr->di_generation = cpu_to_be64(ip->i_generation);\n\n\tstr->di_flags = cpu_to_be32(ip->i_diskflags);\n\tstr->di_height = cpu_to_be16(ip->i_height);\n\tstr->di_payload_format = cpu_to_be32(S_ISDIR(ip->i_inode.i_mode) &&\n\t\t\t\t\t     !(ip->i_diskflags & GFS2_DIF_EXHASH) ?\n\t\t\t\t\t     GFS2_FORMAT_DE : 0);\n\tstr->di_depth = cpu_to_be16(ip->i_depth);\n\tstr->di_entries = cpu_to_be32(ip->i_entries);\n\n\tstr->di_eattr = cpu_to_be64(ip->i_eattr);\n\tstr->di_atime_nsec = cpu_to_be32(ip->i_inode.i_atime.tv_nsec);\n\tstr->di_mtime_nsec = cpu_to_be32(ip->i_inode.i_mtime.tv_nsec);\n\tstr->di_ctime_nsec = cpu_to_be32(ip->i_inode.i_ctime.tv_nsec);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_trans_add_meta",
          "args": [
            "ip->i_gl",
            "dibh"
          ],
          "line": 1389
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_trans_add_meta",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/trans.c",
          "lines": "224-247",
          "snippet": "void gfs2_trans_add_meta(struct gfs2_glock *gl, struct buffer_head *bh)\n{\n\n\tstruct gfs2_sbd *sdp = gl->gl_sbd;\n\tstruct gfs2_bufdata *bd;\n\n\tlock_buffer(bh);\n\tgfs2_log_lock(sdp);\n\tbd = bh->b_private;\n\tif (bd == NULL) {\n\t\tgfs2_log_unlock(sdp);\n\t\tunlock_buffer(bh);\n\t\tlock_page(bh->b_page);\n\t\tif (bh->b_private == NULL)\n\t\t\tbd = gfs2_alloc_bufdata(gl, bh, &gfs2_buf_lops);\n\t\tunlock_page(bh->b_page);\n\t\tlock_buffer(bh);\n\t\tgfs2_log_lock(sdp);\n\t}\n\tgfs2_assert(sdp, bd->bd_gl == gl);\n\tmeta_lo_add(sdp, bd);\n\tgfs2_log_unlock(sdp);\n\tunlock_buffer(bh);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_trans_add_meta(struct gfs2_glock *gl, struct buffer_head *bh)\n{\n\n\tstruct gfs2_sbd *sdp = gl->gl_sbd;\n\tstruct gfs2_bufdata *bd;\n\n\tlock_buffer(bh);\n\tgfs2_log_lock(sdp);\n\tbd = bh->b_private;\n\tif (bd == NULL) {\n\t\tgfs2_log_unlock(sdp);\n\t\tunlock_buffer(bh);\n\t\tlock_page(bh->b_page);\n\t\tif (bh->b_private == NULL)\n\t\t\tbd = gfs2_alloc_bufdata(gl, bh, &gfs2_buf_lops);\n\t\tunlock_page(bh->b_page);\n\t\tlock_buffer(bh);\n\t\tgfs2_log_lock(sdp);\n\t}\n\tgfs2_assert(sdp, bd->bd_gl == gl);\n\tmeta_lo_add(sdp, bd);\n\tgfs2_log_unlock(sdp);\n\tunlock_buffer(bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_meta_inode_buffer",
          "args": [
            "ip",
            "&dibh"
          ],
          "line": 1387
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_meta_inode_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/meta_io.h",
          "lines": "66-70",
          "snippet": "static inline int gfs2_meta_inode_buffer(struct gfs2_inode *ip,\n\t\t\t\t\t struct buffer_head **bhp)\n{\n\treturn gfs2_meta_indirect_buffer(ip, 0, ip->i_no_addr, bhp);\n}",
          "includes": [
            "#include \"incore.h\"",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"incore.h\"\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline int gfs2_meta_inode_buffer(struct gfs2_inode *ip,\n\t\t\t\t\t struct buffer_head **bhp)\n{\n\treturn gfs2_meta_indirect_buffer(ip, 0, ip->i_no_addr, bhp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_free_meta",
          "args": [
            "ip",
            "bstart",
            "blen"
          ],
          "line": 1383
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_free_meta",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
          "lines": "2424-2431",
          "snippet": "void gfs2_free_meta(struct gfs2_inode *ip, u64 bstart, u32 blen)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\n\t__gfs2_free_blocks(ip, bstart, blen, 1);\n\tgfs2_statfs_change(sdp, 0, +blen, 0);\n\tgfs2_quota_change(ip, -(s64)blen, ip->i_inode.i_uid, ip->i_inode.i_gid);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"inode.h\"",
            "#include \"log.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/random.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nvoid gfs2_free_meta(struct gfs2_inode *ip, u64 bstart, u32 blen)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\n\t__gfs2_free_blocks(ip, bstart, blen, 1);\n\tgfs2_statfs_change(sdp, 0, +blen, 0);\n\tgfs2_quota_change(ip, -(s64)blen, ip->i_inode.i_uid, ip->i_inode.i_gid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_add_inode_blocks",
          "args": [
            "&ip->i_inode",
            "-1"
          ],
          "line": 1380
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_add_inode_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/inode.h",
          "lines": "62-67",
          "snippet": "static inline void gfs2_add_inode_blocks(struct inode *inode, s64 change)\n{\n\tgfs2_assert(GFS2_SB(inode), (change >= 0 || inode->i_blocks > -change));\n\tchange *= (GFS2_SB(inode)->sd_sb.sb_bsize/GFS2_BASIC_BLOCK);\n\tinode->i_blocks += change;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include <linux/mm.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <linux/mm.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic inline void gfs2_add_inode_blocks(struct inode *inode, s64 change)\n{\n\tgfs2_assert(GFS2_SB(inode), (change >= 0 || inode->i_blocks > -change));\n\tchange *= (GFS2_SB(inode)->sd_sb.sb_bsize/GFS2_BASIC_BLOCK);\n\tinode->i_blocks += change;\n}"
        }
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "*eablk"
          ],
          "line": 1368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_trans_begin",
          "args": [
            "sdp",
            "rg_blocks + RES_DINODE + RES_INDIRECT +\n\t\t\t\t RES_STATFS + RES_QUOTA",
            "blks"
          ],
          "line": 1352
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_trans_begin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/trans.c",
          "lines": "31-75",
          "snippet": "int gfs2_trans_begin(struct gfs2_sbd *sdp, unsigned int blocks,\n\t\t     unsigned int revokes)\n{\n\tstruct gfs2_trans *tr;\n\tint error;\n\n\tBUG_ON(current->journal_info);\n\tBUG_ON(blocks == 0 && revokes == 0);\n\n\tif (!test_bit(SDF_JOURNAL_LIVE, &sdp->sd_flags))\n\t\treturn -EROFS;\n\n\ttr = kzalloc(sizeof(struct gfs2_trans), GFP_NOFS);\n\tif (!tr)\n\t\treturn -ENOMEM;\n\n\ttr->tr_ip = _RET_IP_;\n\ttr->tr_blocks = blocks;\n\ttr->tr_revokes = revokes;\n\ttr->tr_reserved = 1;\n\ttr->tr_alloced = 1;\n\tif (blocks)\n\t\ttr->tr_reserved += 6 + blocks;\n\tif (revokes)\n\t\ttr->tr_reserved += gfs2_struct2blk(sdp, revokes,\n\t\t\t\t\t\t   sizeof(u64));\n\tINIT_LIST_HEAD(&tr->tr_databuf);\n\tINIT_LIST_HEAD(&tr->tr_buf);\n\n\tsb_start_intwrite(sdp->sd_vfs);\n\n\terror = gfs2_log_reserve(sdp, tr->tr_reserved);\n\tif (error)\n\t\tgoto fail;\n\n\tcurrent->journal_info = tr;\n\n\treturn 0;\n\nfail:\n\tsb_end_intwrite(sdp->sd_vfs);\n\tkfree(tr);\n\n\treturn error;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nint gfs2_trans_begin(struct gfs2_sbd *sdp, unsigned int blocks,\n\t\t     unsigned int revokes)\n{\n\tstruct gfs2_trans *tr;\n\tint error;\n\n\tBUG_ON(current->journal_info);\n\tBUG_ON(blocks == 0 && revokes == 0);\n\n\tif (!test_bit(SDF_JOURNAL_LIVE, &sdp->sd_flags))\n\t\treturn -EROFS;\n\n\ttr = kzalloc(sizeof(struct gfs2_trans), GFP_NOFS);\n\tif (!tr)\n\t\treturn -ENOMEM;\n\n\ttr->tr_ip = _RET_IP_;\n\ttr->tr_blocks = blocks;\n\ttr->tr_revokes = revokes;\n\ttr->tr_reserved = 1;\n\ttr->tr_alloced = 1;\n\tif (blocks)\n\t\ttr->tr_reserved += 6 + blocks;\n\tif (revokes)\n\t\ttr->tr_reserved += gfs2_struct2blk(sdp, revokes,\n\t\t\t\t\t\t   sizeof(u64));\n\tINIT_LIST_HEAD(&tr->tr_databuf);\n\tINIT_LIST_HEAD(&tr->tr_buf);\n\n\tsb_start_intwrite(sdp->sd_vfs);\n\n\terror = gfs2_log_reserve(sdp, tr->tr_reserved);\n\tif (error)\n\t\tgoto fail;\n\n\tcurrent->journal_info = tr;\n\n\treturn 0;\n\nfail:\n\tsb_end_intwrite(sdp->sd_vfs);\n\tkfree(tr);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_glock_nq_m",
          "args": [
            "rlist.rl_rgrps",
            "rlist.rl_ghs"
          ],
          "line": 1348
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_glock_nq_m",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/glock.c",
          "lines": "1210-1236",
          "snippet": "int gfs2_glock_nq_m(unsigned int num_gh, struct gfs2_holder *ghs)\n{\n\tstruct gfs2_holder *tmp[4];\n\tstruct gfs2_holder **pph = tmp;\n\tint error = 0;\n\n\tswitch(num_gh) {\n\tcase 0:\n\t\treturn 0;\n\tcase 1:\n\t\tghs->gh_flags &= ~(LM_FLAG_TRY | GL_ASYNC);\n\t\treturn gfs2_glock_nq(ghs);\n\tdefault:\n\t\tif (num_gh <= 4)\n\t\t\tbreak;\n\t\tpph = kmalloc(num_gh * sizeof(struct gfs2_holder *), GFP_NOFS);\n\t\tif (!pph)\n\t\t\treturn -ENOMEM;\n\t}\n\n\terror = nq_m_sync(num_gh, ghs, pph);\n\n\tif (pph != tmp)\n\t\tkfree(pph);\n\n\treturn error;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"bmap.h\"",
            "#include \"util.h\"",
            "#include \"super.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/lockref.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jhash.h>",
            "#include <linux/sort.h>",
            "#include <linux/delay.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"bmap.h\"\n#include \"util.h\"\n#include \"super.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/lockref.h>\n#include <linux/list_sort.h>\n#include <linux/percpu.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/jiffies.h>\n#include <linux/workqueue.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/module.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/jhash.h>\n#include <linux/sort.h>\n#include <linux/delay.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nint gfs2_glock_nq_m(unsigned int num_gh, struct gfs2_holder *ghs)\n{\n\tstruct gfs2_holder *tmp[4];\n\tstruct gfs2_holder **pph = tmp;\n\tint error = 0;\n\n\tswitch(num_gh) {\n\tcase 0:\n\t\treturn 0;\n\tcase 1:\n\t\tghs->gh_flags &= ~(LM_FLAG_TRY | GL_ASYNC);\n\t\treturn gfs2_glock_nq(ghs);\n\tdefault:\n\t\tif (num_gh <= 4)\n\t\t\tbreak;\n\t\tpph = kmalloc(num_gh * sizeof(struct gfs2_holder *), GFP_NOFS);\n\t\tif (!pph)\n\t\t\treturn -ENOMEM;\n\t}\n\n\terror = nq_m_sync(num_gh, ghs, pph);\n\n\tif (pph != tmp)\n\t\tkfree(pph);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_rlist_alloc",
          "args": [
            "&rlist",
            "LM_ST_EXCLUSIVE"
          ],
          "line": 1340
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_rlist_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
          "lines": "2582-2592",
          "snippet": "void gfs2_rlist_alloc(struct gfs2_rgrp_list *rlist, unsigned int state)\n{\n\tunsigned int x;\n\n\trlist->rl_ghs = kcalloc(rlist->rl_rgrps, sizeof(struct gfs2_holder),\n\t\t\t\tGFP_NOFS | __GFP_NOFAIL);\n\tfor (x = 0; x < rlist->rl_rgrps; x++)\n\t\tgfs2_holder_init(rlist->rl_rgd[x]->rd_gl,\n\t\t\t\tstate, 0,\n\t\t\t\t&rlist->rl_ghs[x]);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"inode.h\"",
            "#include \"log.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/random.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nvoid gfs2_rlist_alloc(struct gfs2_rgrp_list *rlist, unsigned int state)\n{\n\tunsigned int x;\n\n\trlist->rl_ghs = kcalloc(rlist->rl_rgrps, sizeof(struct gfs2_holder),\n\t\t\t\tGFP_NOFS | __GFP_NOFAIL);\n\tfor (x = 0; x < rlist->rl_rgrps; x++)\n\t\tgfs2_holder_init(rlist->rl_rgd[x]->rd_gl,\n\t\t\t\tstate, 0,\n\t\t\t\t&rlist->rl_ghs[x]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_rlist_add",
          "args": [
            "ip",
            "&rlist",
            "bstart"
          ],
          "line": 1336
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_rlist_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
          "lines": "2527-2570",
          "snippet": "void gfs2_rlist_add(struct gfs2_inode *ip, struct gfs2_rgrp_list *rlist,\n\t\t    u64 block)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tstruct gfs2_rgrpd *rgd;\n\tstruct gfs2_rgrpd **tmp;\n\tunsigned int new_space;\n\tunsigned int x;\n\n\tif (gfs2_assert_warn(sdp, !rlist->rl_ghs))\n\t\treturn;\n\n\tif (ip->i_rgd && rgrp_contains_block(ip->i_rgd, block))\n\t\trgd = ip->i_rgd;\n\telse\n\t\trgd = gfs2_blk2rgrpd(sdp, block, 1);\n\tif (!rgd) {\n\t\tfs_err(sdp, \"rlist_add: no rgrp for block %llu\\n\", (unsigned long long)block);\n\t\treturn;\n\t}\n\tip->i_rgd = rgd;\n\n\tfor (x = 0; x < rlist->rl_rgrps; x++)\n\t\tif (rlist->rl_rgd[x] == rgd)\n\t\t\treturn;\n\n\tif (rlist->rl_rgrps == rlist->rl_space) {\n\t\tnew_space = rlist->rl_space + 10;\n\n\t\ttmp = kcalloc(new_space, sizeof(struct gfs2_rgrpd *),\n\t\t\t      GFP_NOFS | __GFP_NOFAIL);\n\n\t\tif (rlist->rl_rgd) {\n\t\t\tmemcpy(tmp, rlist->rl_rgd,\n\t\t\t       rlist->rl_space * sizeof(struct gfs2_rgrpd *));\n\t\t\tkfree(rlist->rl_rgd);\n\t\t}\n\n\t\trlist->rl_space = new_space;\n\t\trlist->rl_rgd = tmp;\n\t}\n\n\trlist->rl_rgd[rlist->rl_rgrps++] = rgd;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"inode.h\"",
            "#include \"log.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/random.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nvoid gfs2_rlist_add(struct gfs2_inode *ip, struct gfs2_rgrp_list *rlist,\n\t\t    u64 block)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tstruct gfs2_rgrpd *rgd;\n\tstruct gfs2_rgrpd **tmp;\n\tunsigned int new_space;\n\tunsigned int x;\n\n\tif (gfs2_assert_warn(sdp, !rlist->rl_ghs))\n\t\treturn;\n\n\tif (ip->i_rgd && rgrp_contains_block(ip->i_rgd, block))\n\t\trgd = ip->i_rgd;\n\telse\n\t\trgd = gfs2_blk2rgrpd(sdp, block, 1);\n\tif (!rgd) {\n\t\tfs_err(sdp, \"rlist_add: no rgrp for block %llu\\n\", (unsigned long long)block);\n\t\treturn;\n\t}\n\tip->i_rgd = rgd;\n\n\tfor (x = 0; x < rlist->rl_rgrps; x++)\n\t\tif (rlist->rl_rgd[x] == rgd)\n\t\t\treturn;\n\n\tif (rlist->rl_rgrps == rlist->rl_space) {\n\t\tnew_space = rlist->rl_space + 10;\n\n\t\ttmp = kcalloc(new_space, sizeof(struct gfs2_rgrpd *),\n\t\t\t      GFP_NOFS | __GFP_NOFAIL);\n\n\t\tif (rlist->rl_rgd) {\n\t\t\tmemcpy(tmp, rlist->rl_rgd,\n\t\t\t       rlist->rl_space * sizeof(struct gfs2_rgrpd *));\n\t\t\tkfree(rlist->rl_rgd);\n\t\t}\n\n\t\trlist->rl_space = new_space;\n\t\trlist->rl_rgd = tmp;\n\t}\n\n\trlist->rl_rgd[rlist->rl_rgrps++] = rgd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "*eablk"
          ],
          "line": 1323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_metatype_check",
          "args": [
            "sdp",
            "indbh",
            "GFS2_METATYPE_IN"
          ],
          "line": 1310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_meta_read",
          "args": [
            "ip->i_gl",
            "ip->i_eattr",
            "DIO_WAIT",
            "&indbh"
          ],
          "line": 1306
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_meta_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/meta_io.c",
          "lines": "200-235",
          "snippet": "int gfs2_meta_read(struct gfs2_glock *gl, u64 blkno, int flags,\n\t\t   struct buffer_head **bhp)\n{\n\tstruct gfs2_sbd *sdp = gl->gl_sbd;\n\tstruct buffer_head *bh;\n\n\tif (unlikely(test_bit(SDF_SHUTDOWN, &sdp->sd_flags))) {\n\t\t*bhp = NULL;\n\t\treturn -EIO;\n\t}\n\n\t*bhp = bh = gfs2_getbuf(gl, blkno, CREATE);\n\n\tlock_buffer(bh);\n\tif (buffer_uptodate(bh)) {\n\t\tunlock_buffer(bh);\n\t\treturn 0;\n\t}\n\tbh->b_end_io = end_buffer_read_sync;\n\tget_bh(bh);\n\tsubmit_bh(READ_SYNC | REQ_META | REQ_PRIO, bh);\n\tif (!(flags & DIO_WAIT))\n\t\treturn 0;\n\n\twait_on_buffer(bh);\n\tif (unlikely(!buffer_uptodate(bh))) {\n\t\tstruct gfs2_trans *tr = current->journal_info;\n\t\tif (tr && tr->tr_touched)\n\t\t\tgfs2_io_error_bh(sdp, bh);\n\t\tbrelse(bh);\n\t\t*bhp = NULL;\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/delay.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/delay.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nint gfs2_meta_read(struct gfs2_glock *gl, u64 blkno, int flags,\n\t\t   struct buffer_head **bhp)\n{\n\tstruct gfs2_sbd *sdp = gl->gl_sbd;\n\tstruct buffer_head *bh;\n\n\tif (unlikely(test_bit(SDF_SHUTDOWN, &sdp->sd_flags))) {\n\t\t*bhp = NULL;\n\t\treturn -EIO;\n\t}\n\n\t*bhp = bh = gfs2_getbuf(gl, blkno, CREATE);\n\n\tlock_buffer(bh);\n\tif (buffer_uptodate(bh)) {\n\t\tunlock_buffer(bh);\n\t\treturn 0;\n\t}\n\tbh->b_end_io = end_buffer_read_sync;\n\tget_bh(bh);\n\tsubmit_bh(READ_SYNC | REQ_META | REQ_PRIO, bh);\n\tif (!(flags & DIO_WAIT))\n\t\treturn 0;\n\n\twait_on_buffer(bh);\n\tif (unlikely(!buffer_uptodate(bh))) {\n\t\tstruct gfs2_trans *tr = current->journal_info;\n\t\tif (tr && tr->tr_touched)\n\t\t\tgfs2_io_error_bh(sdp, bh);\n\t\tbrelse(bh);\n\t\t*bhp = NULL;\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&rlist",
            "0",
            "sizeof(struct gfs2_rgrp_list)"
          ],
          "line": 1304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_rindex_update",
          "args": [
            "sdp"
          ],
          "line": 1300
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_rindex_update",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
          "lines": "1029-1052",
          "snippet": "int gfs2_rindex_update(struct gfs2_sbd *sdp)\n{\n\tstruct gfs2_inode *ip = GFS2_I(sdp->sd_rindex);\n\tstruct gfs2_glock *gl = ip->i_gl;\n\tstruct gfs2_holder ri_gh;\n\tint error = 0;\n\tint unlock_required = 0;\n\n\t/* Read new copy from disk if we don't have the latest */\n\tif (!sdp->sd_rindex_uptodate) {\n\t\tif (!gfs2_glock_is_locked_by_me(gl)) {\n\t\t\terror = gfs2_glock_nq_init(gl, LM_ST_SHARED, 0, &ri_gh);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\tunlock_required = 1;\n\t\t}\n\t\tif (!sdp->sd_rindex_uptodate)\n\t\t\terror = gfs2_ri_update(ip);\n\t\tif (unlock_required)\n\t\t\tgfs2_glock_dq_uninit(&ri_gh);\n\t}\n\n\treturn error;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"inode.h\"",
            "#include \"log.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/random.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nint gfs2_rindex_update(struct gfs2_sbd *sdp)\n{\n\tstruct gfs2_inode *ip = GFS2_I(sdp->sd_rindex);\n\tstruct gfs2_glock *gl = ip->i_gl;\n\tstruct gfs2_holder ri_gh;\n\tint error = 0;\n\tint unlock_required = 0;\n\n\t/* Read new copy from disk if we don't have the latest */\n\tif (!sdp->sd_rindex_uptodate) {\n\t\tif (!gfs2_glock_is_locked_by_me(gl)) {\n\t\t\terror = gfs2_glock_nq_init(gl, LM_ST_SHARED, 0, &ri_gh);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\tunlock_required = 1;\n\t\t}\n\t\tif (!sdp->sd_rindex_uptodate)\n\t\t\terror = gfs2_ri_update(ip);\n\t\tif (unlock_required)\n\t\t\tgfs2_glock_dq_uninit(&ri_gh);\n\t}\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GFS2_SB",
          "args": [
            "&ip->i_inode"
          ],
          "line": 1289
        },
        "resolved": true,
        "details": {
          "function_name": "GFS2_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/incore.h",
          "lines": "413-416",
          "snippet": "static inline struct gfs2_sbd *GFS2_SB(const struct inode *inode)\n{\n\treturn inode->i_sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/lockref.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ktime.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/completion.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dlm.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockref.h>\n#include <linux/percpu.h>\n#include <linux/ktime.h>\n#include <linux/rbtree.h>\n#include <linux/completion.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/buffer_head.h>\n#include <linux/dlm.h>\n#include <linux/workqueue.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n\nstatic inline struct gfs2_sbd *GFS2_SB(const struct inode *inode)\n{\n\treturn inode->i_sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic int ea_dealloc_indirect(struct gfs2_inode *ip)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tstruct gfs2_rgrp_list rlist;\n\tstruct buffer_head *indbh, *dibh;\n\t__be64 *eablk, *end;\n\tunsigned int rg_blocks = 0;\n\tu64 bstart = 0;\n\tunsigned int blen = 0;\n\tunsigned int blks = 0;\n\tunsigned int x;\n\tint error;\n\n\terror = gfs2_rindex_update(sdp);\n\tif (error)\n\t\treturn error;\n\n\tmemset(&rlist, 0, sizeof(struct gfs2_rgrp_list));\n\n\terror = gfs2_meta_read(ip->i_gl, ip->i_eattr, DIO_WAIT, &indbh);\n\tif (error)\n\t\treturn error;\n\n\tif (gfs2_metatype_check(sdp, indbh, GFS2_METATYPE_IN)) {\n\t\terror = -EIO;\n\t\tgoto out;\n\t}\n\n\teablk = (__be64 *)(indbh->b_data + sizeof(struct gfs2_meta_header));\n\tend = eablk + sdp->sd_inptrs;\n\n\tfor (; eablk < end; eablk++) {\n\t\tu64 bn;\n\n\t\tif (!*eablk)\n\t\t\tbreak;\n\t\tbn = be64_to_cpu(*eablk);\n\n\t\tif (bstart + blen == bn)\n\t\t\tblen++;\n\t\telse {\n\t\t\tif (bstart)\n\t\t\t\tgfs2_rlist_add(ip, &rlist, bstart);\n\t\t\tbstart = bn;\n\t\t\tblen = 1;\n\t\t}\n\t\tblks++;\n\t}\n\tif (bstart)\n\t\tgfs2_rlist_add(ip, &rlist, bstart);\n\telse\n\t\tgoto out;\n\n\tgfs2_rlist_alloc(&rlist, LM_ST_EXCLUSIVE);\n\n\tfor (x = 0; x < rlist.rl_rgrps; x++) {\n\t\tstruct gfs2_rgrpd *rgd;\n\t\trgd = rlist.rl_ghs[x].gh_gl->gl_object;\n\t\trg_blocks += rgd->rd_length;\n\t}\n\n\terror = gfs2_glock_nq_m(rlist.rl_rgrps, rlist.rl_ghs);\n\tif (error)\n\t\tgoto out_rlist_free;\n\n\terror = gfs2_trans_begin(sdp, rg_blocks + RES_DINODE + RES_INDIRECT +\n\t\t\t\t RES_STATFS + RES_QUOTA, blks);\n\tif (error)\n\t\tgoto out_gunlock;\n\n\tgfs2_trans_add_meta(ip->i_gl, indbh);\n\n\teablk = (__be64 *)(indbh->b_data + sizeof(struct gfs2_meta_header));\n\tbstart = 0;\n\tblen = 0;\n\n\tfor (; eablk < end; eablk++) {\n\t\tu64 bn;\n\n\t\tif (!*eablk)\n\t\t\tbreak;\n\t\tbn = be64_to_cpu(*eablk);\n\n\t\tif (bstart + blen == bn)\n\t\t\tblen++;\n\t\telse {\n\t\t\tif (bstart)\n\t\t\t\tgfs2_free_meta(ip, bstart, blen);\n\t\t\tbstart = bn;\n\t\t\tblen = 1;\n\t\t}\n\n\t\t*eablk = 0;\n\t\tgfs2_add_inode_blocks(&ip->i_inode, -1);\n\t}\n\tif (bstart)\n\t\tgfs2_free_meta(ip, bstart, blen);\n\n\tip->i_diskflags &= ~GFS2_DIF_EA_INDIRECT;\n\n\terror = gfs2_meta_inode_buffer(ip, &dibh);\n\tif (!error) {\n\t\tgfs2_trans_add_meta(ip->i_gl, dibh);\n\t\tgfs2_dinode_out(ip, dibh->b_data);\n\t\tbrelse(dibh);\n\t}\n\n\tgfs2_trans_end(sdp);\n\nout_gunlock:\n\tgfs2_glock_dq_m(rlist.rl_rgrps, rlist.rl_ghs);\nout_rlist_free:\n\tgfs2_rlist_free(&rlist);\nout:\n\tbrelse(indbh);\n\treturn error;\n}"
  },
  {
    "function_name": "gfs2_xattr_acl_chmod",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
    "lines": "1256-1285",
    "snippet": "int gfs2_xattr_acl_chmod(struct gfs2_inode *ip, struct iattr *attr, char *data)\n{\n\tstruct inode *inode = &ip->i_inode;\n\tstruct gfs2_sbd *sdp = GFS2_SB(inode);\n\tstruct gfs2_ea_location el;\n\tint error;\n\n\terror = gfs2_ea_find(ip, GFS2_EATYPE_SYS, GFS2_POSIX_ACL_ACCESS, &el);\n\tif (error)\n\t\treturn error;\n\n\tif (GFS2_EA_IS_STUFFED(el.el_ea)) {\n\t\terror = gfs2_trans_begin(sdp, RES_DINODE + RES_EATTR, 0);\n\t\tif (error == 0) {\n\t\t\tgfs2_trans_add_meta(ip->i_gl, el.el_bh);\n\t\t\tmemcpy(GFS2_EA2DATA(el.el_ea), data,\n\t\t\t       GFS2_EA_DATA_LEN(el.el_ea));\n\t\t}\n\t} else {\n\t\terror = ea_acl_chmod_unstuffed(ip, el.el_ea, data);\n\t}\n\n\tbrelse(el.el_bh);\n\tif (error)\n\t\treturn error;\n\n\terror = gfs2_setattr_simple(inode, attr);\n\tgfs2_trans_end(sdp);\n\treturn error;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"trans.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"inode.h\"",
      "#include \"glock.h\"",
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/xattr.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "gfs2_trans_end",
          "args": [
            "sdp"
          ],
          "line": 1283
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_trans_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/trans.c",
          "lines": "88-123",
          "snippet": "void gfs2_trans_end(struct gfs2_sbd *sdp)\n{\n\tstruct gfs2_trans *tr = current->journal_info;\n\ts64 nbuf;\n\tint alloced = tr->tr_alloced;\n\n\tBUG_ON(!tr);\n\tcurrent->journal_info = NULL;\n\n\tif (!tr->tr_touched) {\n\t\tgfs2_log_release(sdp, tr->tr_reserved);\n\t\tif (alloced) {\n\t\t\tkfree(tr);\n\t\t\tsb_end_intwrite(sdp->sd_vfs);\n\t\t}\n\t\treturn;\n\t}\n\n\tnbuf = tr->tr_num_buf_new + tr->tr_num_databuf_new;\n\tnbuf -= tr->tr_num_buf_rm;\n\tnbuf -= tr->tr_num_databuf_rm;\n\n\tif (gfs2_assert_withdraw(sdp, (nbuf <= tr->tr_blocks) &&\n\t\t\t\t       (tr->tr_num_revoke <= tr->tr_revokes)))\n\t\tgfs2_print_trans(tr);\n\n\tgfs2_log_commit(sdp, tr);\n\tif (alloced && !tr->tr_attached)\n\t\t\tkfree(tr);\n\tup_read(&sdp->sd_log_flush_lock);\n\n\tif (sdp->sd_vfs->s_flags & MS_SYNCHRONOUS)\n\t\tgfs2_log_flush(sdp, NULL, NORMAL_FLUSH);\n\tif (alloced)\n\t\tsb_end_intwrite(sdp->sd_vfs);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_trans_end(struct gfs2_sbd *sdp)\n{\n\tstruct gfs2_trans *tr = current->journal_info;\n\ts64 nbuf;\n\tint alloced = tr->tr_alloced;\n\n\tBUG_ON(!tr);\n\tcurrent->journal_info = NULL;\n\n\tif (!tr->tr_touched) {\n\t\tgfs2_log_release(sdp, tr->tr_reserved);\n\t\tif (alloced) {\n\t\t\tkfree(tr);\n\t\t\tsb_end_intwrite(sdp->sd_vfs);\n\t\t}\n\t\treturn;\n\t}\n\n\tnbuf = tr->tr_num_buf_new + tr->tr_num_databuf_new;\n\tnbuf -= tr->tr_num_buf_rm;\n\tnbuf -= tr->tr_num_databuf_rm;\n\n\tif (gfs2_assert_withdraw(sdp, (nbuf <= tr->tr_blocks) &&\n\t\t\t\t       (tr->tr_num_revoke <= tr->tr_revokes)))\n\t\tgfs2_print_trans(tr);\n\n\tgfs2_log_commit(sdp, tr);\n\tif (alloced && !tr->tr_attached)\n\t\t\tkfree(tr);\n\tup_read(&sdp->sd_log_flush_lock);\n\n\tif (sdp->sd_vfs->s_flags & MS_SYNCHRONOUS)\n\t\tgfs2_log_flush(sdp, NULL, NORMAL_FLUSH);\n\tif (alloced)\n\t\tsb_end_intwrite(sdp->sd_vfs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_setattr_simple",
          "args": [
            "inode",
            "attr"
          ],
          "line": 1282
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_setattr_simple",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/inode.c",
          "lines": "1649-1663",
          "snippet": "int gfs2_setattr_simple(struct inode *inode, struct iattr *attr)\n{\n\tint error;\n\n\tif (current->journal_info)\n\t\treturn __gfs2_setattr_simple(inode, attr);\n\n\terror = gfs2_trans_begin(GFS2_SB(inode), RES_DINODE, 0);\n\tif (error)\n\t\treturn error;\n\n\terror = __gfs2_setattr_simple(inode, attr);\n\tgfs2_trans_end(GFS2_SB(inode));\n\treturn error;\n}",
          "includes": [
            "#include \"glops.h\"",
            "#include \"super.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"dir.h\"",
            "#include \"bmap.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/security.h>",
            "#include <linux/fiemap.h>",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glops.h\"\n#include \"super.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"dir.h\"\n#include \"bmap.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/security.h>\n#include <linux/fiemap.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nint gfs2_setattr_simple(struct inode *inode, struct iattr *attr)\n{\n\tint error;\n\n\tif (current->journal_info)\n\t\treturn __gfs2_setattr_simple(inode, attr);\n\n\terror = gfs2_trans_begin(GFS2_SB(inode), RES_DINODE, 0);\n\tif (error)\n\t\treturn error;\n\n\terror = __gfs2_setattr_simple(inode, attr);\n\tgfs2_trans_end(GFS2_SB(inode));\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "el.el_bh"
          ],
          "line": 1278
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "ea_acl_chmod_unstuffed",
          "args": [
            "ip",
            "el.el_ea",
            "data"
          ],
          "line": 1275
        },
        "resolved": true,
        "details": {
          "function_name": "ea_acl_chmod_unstuffed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "1238-1254",
          "snippet": "static int ea_acl_chmod_unstuffed(struct gfs2_inode *ip,\n\t\t\t\t  struct gfs2_ea_header *ea, char *data)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tunsigned int amount = GFS2_EA_DATA_LEN(ea);\n\tunsigned int nptrs = DIV_ROUND_UP(amount, sdp->sd_jbsize);\n\tint ret;\n\n\tret = gfs2_trans_begin(sdp, nptrs + RES_DINODE, 0);\n\tif (ret)\n\t\treturn ret;\n\n\tret = gfs2_iter_unstuffed(ip, ea, data, NULL);\n\tgfs2_trans_end(sdp);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic int ea_acl_chmod_unstuffed(struct gfs2_inode *ip,\n\t\t\t\t  struct gfs2_ea_header *ea, char *data)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tunsigned int amount = GFS2_EA_DATA_LEN(ea);\n\tunsigned int nptrs = DIV_ROUND_UP(amount, sdp->sd_jbsize);\n\tint ret;\n\n\tret = gfs2_trans_begin(sdp, nptrs + RES_DINODE, 0);\n\tif (ret)\n\t\treturn ret;\n\n\tret = gfs2_iter_unstuffed(ip, ea, data, NULL);\n\tgfs2_trans_end(sdp);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "GFS2_EA2DATA(el.el_ea)",
            "data",
            "GFS2_EA_DATA_LEN(el.el_ea)"
          ],
          "line": 1271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GFS2_EA_DATA_LEN",
          "args": [
            "el.el_ea"
          ],
          "line": 1272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GFS2_EA2DATA",
          "args": [
            "el.el_ea"
          ],
          "line": 1271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_trans_add_meta",
          "args": [
            "ip->i_gl",
            "el.el_bh"
          ],
          "line": 1270
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_trans_add_meta",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/trans.c",
          "lines": "224-247",
          "snippet": "void gfs2_trans_add_meta(struct gfs2_glock *gl, struct buffer_head *bh)\n{\n\n\tstruct gfs2_sbd *sdp = gl->gl_sbd;\n\tstruct gfs2_bufdata *bd;\n\n\tlock_buffer(bh);\n\tgfs2_log_lock(sdp);\n\tbd = bh->b_private;\n\tif (bd == NULL) {\n\t\tgfs2_log_unlock(sdp);\n\t\tunlock_buffer(bh);\n\t\tlock_page(bh->b_page);\n\t\tif (bh->b_private == NULL)\n\t\t\tbd = gfs2_alloc_bufdata(gl, bh, &gfs2_buf_lops);\n\t\tunlock_page(bh->b_page);\n\t\tlock_buffer(bh);\n\t\tgfs2_log_lock(sdp);\n\t}\n\tgfs2_assert(sdp, bd->bd_gl == gl);\n\tmeta_lo_add(sdp, bd);\n\tgfs2_log_unlock(sdp);\n\tunlock_buffer(bh);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_trans_add_meta(struct gfs2_glock *gl, struct buffer_head *bh)\n{\n\n\tstruct gfs2_sbd *sdp = gl->gl_sbd;\n\tstruct gfs2_bufdata *bd;\n\n\tlock_buffer(bh);\n\tgfs2_log_lock(sdp);\n\tbd = bh->b_private;\n\tif (bd == NULL) {\n\t\tgfs2_log_unlock(sdp);\n\t\tunlock_buffer(bh);\n\t\tlock_page(bh->b_page);\n\t\tif (bh->b_private == NULL)\n\t\t\tbd = gfs2_alloc_bufdata(gl, bh, &gfs2_buf_lops);\n\t\tunlock_page(bh->b_page);\n\t\tlock_buffer(bh);\n\t\tgfs2_log_lock(sdp);\n\t}\n\tgfs2_assert(sdp, bd->bd_gl == gl);\n\tmeta_lo_add(sdp, bd);\n\tgfs2_log_unlock(sdp);\n\tunlock_buffer(bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_trans_begin",
          "args": [
            "sdp",
            "RES_DINODE + RES_EATTR",
            "0"
          ],
          "line": 1268
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_trans_begin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/trans.c",
          "lines": "31-75",
          "snippet": "int gfs2_trans_begin(struct gfs2_sbd *sdp, unsigned int blocks,\n\t\t     unsigned int revokes)\n{\n\tstruct gfs2_trans *tr;\n\tint error;\n\n\tBUG_ON(current->journal_info);\n\tBUG_ON(blocks == 0 && revokes == 0);\n\n\tif (!test_bit(SDF_JOURNAL_LIVE, &sdp->sd_flags))\n\t\treturn -EROFS;\n\n\ttr = kzalloc(sizeof(struct gfs2_trans), GFP_NOFS);\n\tif (!tr)\n\t\treturn -ENOMEM;\n\n\ttr->tr_ip = _RET_IP_;\n\ttr->tr_blocks = blocks;\n\ttr->tr_revokes = revokes;\n\ttr->tr_reserved = 1;\n\ttr->tr_alloced = 1;\n\tif (blocks)\n\t\ttr->tr_reserved += 6 + blocks;\n\tif (revokes)\n\t\ttr->tr_reserved += gfs2_struct2blk(sdp, revokes,\n\t\t\t\t\t\t   sizeof(u64));\n\tINIT_LIST_HEAD(&tr->tr_databuf);\n\tINIT_LIST_HEAD(&tr->tr_buf);\n\n\tsb_start_intwrite(sdp->sd_vfs);\n\n\terror = gfs2_log_reserve(sdp, tr->tr_reserved);\n\tif (error)\n\t\tgoto fail;\n\n\tcurrent->journal_info = tr;\n\n\treturn 0;\n\nfail:\n\tsb_end_intwrite(sdp->sd_vfs);\n\tkfree(tr);\n\n\treturn error;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nint gfs2_trans_begin(struct gfs2_sbd *sdp, unsigned int blocks,\n\t\t     unsigned int revokes)\n{\n\tstruct gfs2_trans *tr;\n\tint error;\n\n\tBUG_ON(current->journal_info);\n\tBUG_ON(blocks == 0 && revokes == 0);\n\n\tif (!test_bit(SDF_JOURNAL_LIVE, &sdp->sd_flags))\n\t\treturn -EROFS;\n\n\ttr = kzalloc(sizeof(struct gfs2_trans), GFP_NOFS);\n\tif (!tr)\n\t\treturn -ENOMEM;\n\n\ttr->tr_ip = _RET_IP_;\n\ttr->tr_blocks = blocks;\n\ttr->tr_revokes = revokes;\n\ttr->tr_reserved = 1;\n\ttr->tr_alloced = 1;\n\tif (blocks)\n\t\ttr->tr_reserved += 6 + blocks;\n\tif (revokes)\n\t\ttr->tr_reserved += gfs2_struct2blk(sdp, revokes,\n\t\t\t\t\t\t   sizeof(u64));\n\tINIT_LIST_HEAD(&tr->tr_databuf);\n\tINIT_LIST_HEAD(&tr->tr_buf);\n\n\tsb_start_intwrite(sdp->sd_vfs);\n\n\terror = gfs2_log_reserve(sdp, tr->tr_reserved);\n\tif (error)\n\t\tgoto fail;\n\n\tcurrent->journal_info = tr;\n\n\treturn 0;\n\nfail:\n\tsb_end_intwrite(sdp->sd_vfs);\n\tkfree(tr);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GFS2_EA_IS_STUFFED",
          "args": [
            "el.el_ea"
          ],
          "line": 1267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_ea_find",
          "args": [
            "ip",
            "GFS2_EATYPE_SYS",
            "GFS2_POSIX_ACL_ACCESS",
            "&el"
          ],
          "line": 1263
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_find",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "190-208",
          "snippet": "static int gfs2_ea_find(struct gfs2_inode *ip, int type, const char *name,\n\t\t\tstruct gfs2_ea_location *el)\n{\n\tstruct ea_find ef;\n\tint error;\n\n\tef.type = type;\n\tef.name = name;\n\tef.namel = strlen(name);\n\tef.ef_el = el;\n\n\tmemset(el, 0, sizeof(struct gfs2_ea_location));\n\n\terror = ea_foreach(ip, ea_find_i, &ef);\n\tif (error > 0)\n\t\treturn 0;\n\n\treturn error;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic int gfs2_ea_find(struct gfs2_inode *ip, int type, const char *name,\n\t\t\tstruct gfs2_ea_location *el)\n{\n\tstruct ea_find ef;\n\tint error;\n\n\tef.type = type;\n\tef.name = name;\n\tef.namel = strlen(name);\n\tef.ef_el = el;\n\n\tmemset(el, 0, sizeof(struct gfs2_ea_location));\n\n\terror = ea_foreach(ip, ea_find_i, &ef);\n\tif (error > 0)\n\t\treturn 0;\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GFS2_SB",
          "args": [
            "inode"
          ],
          "line": 1259
        },
        "resolved": true,
        "details": {
          "function_name": "GFS2_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/incore.h",
          "lines": "413-416",
          "snippet": "static inline struct gfs2_sbd *GFS2_SB(const struct inode *inode)\n{\n\treturn inode->i_sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/lockref.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ktime.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/completion.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dlm.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockref.h>\n#include <linux/percpu.h>\n#include <linux/ktime.h>\n#include <linux/rbtree.h>\n#include <linux/completion.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/buffer_head.h>\n#include <linux/dlm.h>\n#include <linux/workqueue.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n\nstatic inline struct gfs2_sbd *GFS2_SB(const struct inode *inode)\n{\n\treturn inode->i_sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nint gfs2_xattr_acl_chmod(struct gfs2_inode *ip, struct iattr *attr, char *data)\n{\n\tstruct inode *inode = &ip->i_inode;\n\tstruct gfs2_sbd *sdp = GFS2_SB(inode);\n\tstruct gfs2_ea_location el;\n\tint error;\n\n\terror = gfs2_ea_find(ip, GFS2_EATYPE_SYS, GFS2_POSIX_ACL_ACCESS, &el);\n\tif (error)\n\t\treturn error;\n\n\tif (GFS2_EA_IS_STUFFED(el.el_ea)) {\n\t\terror = gfs2_trans_begin(sdp, RES_DINODE + RES_EATTR, 0);\n\t\tif (error == 0) {\n\t\t\tgfs2_trans_add_meta(ip->i_gl, el.el_bh);\n\t\t\tmemcpy(GFS2_EA2DATA(el.el_ea), data,\n\t\t\t       GFS2_EA_DATA_LEN(el.el_ea));\n\t\t}\n\t} else {\n\t\terror = ea_acl_chmod_unstuffed(ip, el.el_ea, data);\n\t}\n\n\tbrelse(el.el_bh);\n\tif (error)\n\t\treturn error;\n\n\terror = gfs2_setattr_simple(inode, attr);\n\tgfs2_trans_end(sdp);\n\treturn error;\n}"
  },
  {
    "function_name": "ea_acl_chmod_unstuffed",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
    "lines": "1238-1254",
    "snippet": "static int ea_acl_chmod_unstuffed(struct gfs2_inode *ip,\n\t\t\t\t  struct gfs2_ea_header *ea, char *data)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tunsigned int amount = GFS2_EA_DATA_LEN(ea);\n\tunsigned int nptrs = DIV_ROUND_UP(amount, sdp->sd_jbsize);\n\tint ret;\n\n\tret = gfs2_trans_begin(sdp, nptrs + RES_DINODE, 0);\n\tif (ret)\n\t\treturn ret;\n\n\tret = gfs2_iter_unstuffed(ip, ea, data, NULL);\n\tgfs2_trans_end(sdp);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"trans.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"inode.h\"",
      "#include \"glock.h\"",
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/xattr.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "gfs2_trans_end",
          "args": [
            "sdp"
          ],
          "line": 1251
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_trans_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/trans.c",
          "lines": "88-123",
          "snippet": "void gfs2_trans_end(struct gfs2_sbd *sdp)\n{\n\tstruct gfs2_trans *tr = current->journal_info;\n\ts64 nbuf;\n\tint alloced = tr->tr_alloced;\n\n\tBUG_ON(!tr);\n\tcurrent->journal_info = NULL;\n\n\tif (!tr->tr_touched) {\n\t\tgfs2_log_release(sdp, tr->tr_reserved);\n\t\tif (alloced) {\n\t\t\tkfree(tr);\n\t\t\tsb_end_intwrite(sdp->sd_vfs);\n\t\t}\n\t\treturn;\n\t}\n\n\tnbuf = tr->tr_num_buf_new + tr->tr_num_databuf_new;\n\tnbuf -= tr->tr_num_buf_rm;\n\tnbuf -= tr->tr_num_databuf_rm;\n\n\tif (gfs2_assert_withdraw(sdp, (nbuf <= tr->tr_blocks) &&\n\t\t\t\t       (tr->tr_num_revoke <= tr->tr_revokes)))\n\t\tgfs2_print_trans(tr);\n\n\tgfs2_log_commit(sdp, tr);\n\tif (alloced && !tr->tr_attached)\n\t\t\tkfree(tr);\n\tup_read(&sdp->sd_log_flush_lock);\n\n\tif (sdp->sd_vfs->s_flags & MS_SYNCHRONOUS)\n\t\tgfs2_log_flush(sdp, NULL, NORMAL_FLUSH);\n\tif (alloced)\n\t\tsb_end_intwrite(sdp->sd_vfs);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_trans_end(struct gfs2_sbd *sdp)\n{\n\tstruct gfs2_trans *tr = current->journal_info;\n\ts64 nbuf;\n\tint alloced = tr->tr_alloced;\n\n\tBUG_ON(!tr);\n\tcurrent->journal_info = NULL;\n\n\tif (!tr->tr_touched) {\n\t\tgfs2_log_release(sdp, tr->tr_reserved);\n\t\tif (alloced) {\n\t\t\tkfree(tr);\n\t\t\tsb_end_intwrite(sdp->sd_vfs);\n\t\t}\n\t\treturn;\n\t}\n\n\tnbuf = tr->tr_num_buf_new + tr->tr_num_databuf_new;\n\tnbuf -= tr->tr_num_buf_rm;\n\tnbuf -= tr->tr_num_databuf_rm;\n\n\tif (gfs2_assert_withdraw(sdp, (nbuf <= tr->tr_blocks) &&\n\t\t\t\t       (tr->tr_num_revoke <= tr->tr_revokes)))\n\t\tgfs2_print_trans(tr);\n\n\tgfs2_log_commit(sdp, tr);\n\tif (alloced && !tr->tr_attached)\n\t\t\tkfree(tr);\n\tup_read(&sdp->sd_log_flush_lock);\n\n\tif (sdp->sd_vfs->s_flags & MS_SYNCHRONOUS)\n\t\tgfs2_log_flush(sdp, NULL, NORMAL_FLUSH);\n\tif (alloced)\n\t\tsb_end_intwrite(sdp->sd_vfs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_iter_unstuffed",
          "args": [
            "ip",
            "ea",
            "data",
            "NULL"
          ],
          "line": 1250
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_iter_unstuffed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "462-525",
          "snippet": "static int gfs2_iter_unstuffed(struct gfs2_inode *ip, struct gfs2_ea_header *ea,\n\t\t\t       const char *din, char *dout)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tstruct buffer_head **bh;\n\tunsigned int amount = GFS2_EA_DATA_LEN(ea);\n\tunsigned int nptrs = DIV_ROUND_UP(amount, sdp->sd_jbsize);\n\t__be64 *dataptrs = GFS2_EA2DATAPTRS(ea);\n\tunsigned int x;\n\tint error = 0;\n\tunsigned char *pos;\n\tunsigned cp_size;\n\n\tbh = kcalloc(nptrs, sizeof(struct buffer_head *), GFP_NOFS);\n\tif (!bh)\n\t\treturn -ENOMEM;\n\n\tfor (x = 0; x < nptrs; x++) {\n\t\terror = gfs2_meta_read(ip->i_gl, be64_to_cpu(*dataptrs), 0,\n\t\t\t\t       bh + x);\n\t\tif (error) {\n\t\t\twhile (x--)\n\t\t\t\tbrelse(bh[x]);\n\t\t\tgoto out;\n\t\t}\n\t\tdataptrs++;\n\t}\n\n\tfor (x = 0; x < nptrs; x++) {\n\t\terror = gfs2_meta_wait(sdp, bh[x]);\n\t\tif (error) {\n\t\t\tfor (; x < nptrs; x++)\n\t\t\t\tbrelse(bh[x]);\n\t\t\tgoto out;\n\t\t}\n\t\tif (gfs2_metatype_check(sdp, bh[x], GFS2_METATYPE_ED)) {\n\t\t\tfor (; x < nptrs; x++)\n\t\t\t\tbrelse(bh[x]);\n\t\t\terror = -EIO;\n\t\t\tgoto out;\n\t\t}\n\n\t\tpos = bh[x]->b_data + sizeof(struct gfs2_meta_header);\n\t\tcp_size = (sdp->sd_jbsize > amount) ? amount : sdp->sd_jbsize;\n\n\t\tif (dout) {\n\t\t\tmemcpy(dout, pos, cp_size);\n\t\t\tdout += sdp->sd_jbsize;\n\t\t}\n\n\t\tif (din) {\n\t\t\tgfs2_trans_add_meta(ip->i_gl, bh[x]);\n\t\t\tmemcpy(pos, din, cp_size);\n\t\t\tdin += sdp->sd_jbsize;\n\t\t}\n\n\t\tamount -= sdp->sd_jbsize;\n\t\tbrelse(bh[x]);\n\t}\n\nout:\n\tkfree(bh);\n\treturn error;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic int gfs2_iter_unstuffed(struct gfs2_inode *ip, struct gfs2_ea_header *ea,\n\t\t\t       const char *din, char *dout)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tstruct buffer_head **bh;\n\tunsigned int amount = GFS2_EA_DATA_LEN(ea);\n\tunsigned int nptrs = DIV_ROUND_UP(amount, sdp->sd_jbsize);\n\t__be64 *dataptrs = GFS2_EA2DATAPTRS(ea);\n\tunsigned int x;\n\tint error = 0;\n\tunsigned char *pos;\n\tunsigned cp_size;\n\n\tbh = kcalloc(nptrs, sizeof(struct buffer_head *), GFP_NOFS);\n\tif (!bh)\n\t\treturn -ENOMEM;\n\n\tfor (x = 0; x < nptrs; x++) {\n\t\terror = gfs2_meta_read(ip->i_gl, be64_to_cpu(*dataptrs), 0,\n\t\t\t\t       bh + x);\n\t\tif (error) {\n\t\t\twhile (x--)\n\t\t\t\tbrelse(bh[x]);\n\t\t\tgoto out;\n\t\t}\n\t\tdataptrs++;\n\t}\n\n\tfor (x = 0; x < nptrs; x++) {\n\t\terror = gfs2_meta_wait(sdp, bh[x]);\n\t\tif (error) {\n\t\t\tfor (; x < nptrs; x++)\n\t\t\t\tbrelse(bh[x]);\n\t\t\tgoto out;\n\t\t}\n\t\tif (gfs2_metatype_check(sdp, bh[x], GFS2_METATYPE_ED)) {\n\t\t\tfor (; x < nptrs; x++)\n\t\t\t\tbrelse(bh[x]);\n\t\t\terror = -EIO;\n\t\t\tgoto out;\n\t\t}\n\n\t\tpos = bh[x]->b_data + sizeof(struct gfs2_meta_header);\n\t\tcp_size = (sdp->sd_jbsize > amount) ? amount : sdp->sd_jbsize;\n\n\t\tif (dout) {\n\t\t\tmemcpy(dout, pos, cp_size);\n\t\t\tdout += sdp->sd_jbsize;\n\t\t}\n\n\t\tif (din) {\n\t\t\tgfs2_trans_add_meta(ip->i_gl, bh[x]);\n\t\t\tmemcpy(pos, din, cp_size);\n\t\t\tdin += sdp->sd_jbsize;\n\t\t}\n\n\t\tamount -= sdp->sd_jbsize;\n\t\tbrelse(bh[x]);\n\t}\n\nout:\n\tkfree(bh);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_trans_begin",
          "args": [
            "sdp",
            "nptrs + RES_DINODE",
            "0"
          ],
          "line": 1246
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_trans_begin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/trans.c",
          "lines": "31-75",
          "snippet": "int gfs2_trans_begin(struct gfs2_sbd *sdp, unsigned int blocks,\n\t\t     unsigned int revokes)\n{\n\tstruct gfs2_trans *tr;\n\tint error;\n\n\tBUG_ON(current->journal_info);\n\tBUG_ON(blocks == 0 && revokes == 0);\n\n\tif (!test_bit(SDF_JOURNAL_LIVE, &sdp->sd_flags))\n\t\treturn -EROFS;\n\n\ttr = kzalloc(sizeof(struct gfs2_trans), GFP_NOFS);\n\tif (!tr)\n\t\treturn -ENOMEM;\n\n\ttr->tr_ip = _RET_IP_;\n\ttr->tr_blocks = blocks;\n\ttr->tr_revokes = revokes;\n\ttr->tr_reserved = 1;\n\ttr->tr_alloced = 1;\n\tif (blocks)\n\t\ttr->tr_reserved += 6 + blocks;\n\tif (revokes)\n\t\ttr->tr_reserved += gfs2_struct2blk(sdp, revokes,\n\t\t\t\t\t\t   sizeof(u64));\n\tINIT_LIST_HEAD(&tr->tr_databuf);\n\tINIT_LIST_HEAD(&tr->tr_buf);\n\n\tsb_start_intwrite(sdp->sd_vfs);\n\n\terror = gfs2_log_reserve(sdp, tr->tr_reserved);\n\tif (error)\n\t\tgoto fail;\n\n\tcurrent->journal_info = tr;\n\n\treturn 0;\n\nfail:\n\tsb_end_intwrite(sdp->sd_vfs);\n\tkfree(tr);\n\n\treturn error;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nint gfs2_trans_begin(struct gfs2_sbd *sdp, unsigned int blocks,\n\t\t     unsigned int revokes)\n{\n\tstruct gfs2_trans *tr;\n\tint error;\n\n\tBUG_ON(current->journal_info);\n\tBUG_ON(blocks == 0 && revokes == 0);\n\n\tif (!test_bit(SDF_JOURNAL_LIVE, &sdp->sd_flags))\n\t\treturn -EROFS;\n\n\ttr = kzalloc(sizeof(struct gfs2_trans), GFP_NOFS);\n\tif (!tr)\n\t\treturn -ENOMEM;\n\n\ttr->tr_ip = _RET_IP_;\n\ttr->tr_blocks = blocks;\n\ttr->tr_revokes = revokes;\n\ttr->tr_reserved = 1;\n\ttr->tr_alloced = 1;\n\tif (blocks)\n\t\ttr->tr_reserved += 6 + blocks;\n\tif (revokes)\n\t\ttr->tr_reserved += gfs2_struct2blk(sdp, revokes,\n\t\t\t\t\t\t   sizeof(u64));\n\tINIT_LIST_HEAD(&tr->tr_databuf);\n\tINIT_LIST_HEAD(&tr->tr_buf);\n\n\tsb_start_intwrite(sdp->sd_vfs);\n\n\terror = gfs2_log_reserve(sdp, tr->tr_reserved);\n\tif (error)\n\t\tgoto fail;\n\n\tcurrent->journal_info = tr;\n\n\treturn 0;\n\nfail:\n\tsb_end_intwrite(sdp->sd_vfs);\n\tkfree(tr);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DIV_ROUND_UP",
          "args": [
            "amount",
            "sdp->sd_jbsize"
          ],
          "line": 1243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GFS2_EA_DATA_LEN",
          "args": [
            "ea"
          ],
          "line": 1242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GFS2_SB",
          "args": [
            "&ip->i_inode"
          ],
          "line": 1241
        },
        "resolved": true,
        "details": {
          "function_name": "GFS2_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/incore.h",
          "lines": "413-416",
          "snippet": "static inline struct gfs2_sbd *GFS2_SB(const struct inode *inode)\n{\n\treturn inode->i_sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/lockref.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ktime.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/completion.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dlm.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockref.h>\n#include <linux/percpu.h>\n#include <linux/ktime.h>\n#include <linux/rbtree.h>\n#include <linux/completion.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/buffer_head.h>\n#include <linux/dlm.h>\n#include <linux/workqueue.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n\nstatic inline struct gfs2_sbd *GFS2_SB(const struct inode *inode)\n{\n\treturn inode->i_sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic int ea_acl_chmod_unstuffed(struct gfs2_inode *ip,\n\t\t\t\t  struct gfs2_ea_header *ea, char *data)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tunsigned int amount = GFS2_EA_DATA_LEN(ea);\n\tunsigned int nptrs = DIV_ROUND_UP(amount, sdp->sd_jbsize);\n\tint ret;\n\n\tret = gfs2_trans_begin(sdp, nptrs + RES_DINODE, 0);\n\tif (ret)\n\t\treturn ret;\n\n\tret = gfs2_iter_unstuffed(ip, ea, data, NULL);\n\tgfs2_trans_end(sdp);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "gfs2_xattr_set",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
    "lines": "1230-1235",
    "snippet": "static int gfs2_xattr_set(struct dentry *dentry, const char *name,\n\t\tconst void *value, size_t size, int flags, int type)\n{\n\treturn __gfs2_xattr_set(dentry->d_inode, name, value,\n\t\t\t\tsize, flags, type);\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"trans.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"inode.h\"",
      "#include \"glock.h\"",
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/xattr.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__gfs2_xattr_set",
          "args": [
            "dentry->d_inode",
            "name",
            "value",
            "size",
            "flags",
            "type"
          ],
          "line": 1233
        },
        "resolved": true,
        "details": {
          "function_name": "__gfs2_xattr_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "1175-1228",
          "snippet": "int __gfs2_xattr_set(struct inode *inode, const char *name,\n\t\t   const void *value, size_t size, int flags, int type)\n{\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tstruct gfs2_sbd *sdp = GFS2_SB(inode);\n\tstruct gfs2_ea_location el;\n\tunsigned int namel = strlen(name);\n\tint error;\n\n\tif (IS_IMMUTABLE(inode) || IS_APPEND(inode))\n\t\treturn -EPERM;\n\tif (namel > GFS2_EA_MAX_NAME_LEN)\n\t\treturn -ERANGE;\n\n\tif (value == NULL)\n\t\treturn gfs2_xattr_remove(ip, type, name);\n\n\tif (ea_check_size(sdp, namel, size))\n\t\treturn -ERANGE;\n\n\tif (!ip->i_eattr) {\n\t\tif (flags & XATTR_REPLACE)\n\t\t\treturn -ENODATA;\n\t\treturn ea_init(ip, type, name, value, size);\n\t}\n\n\terror = gfs2_ea_find(ip, type, name, &el);\n\tif (error)\n\t\treturn error;\n\n\tif (el.el_ea) {\n\t\tif (ip->i_diskflags & GFS2_DIF_APPENDONLY) {\n\t\t\tbrelse(el.el_bh);\n\t\t\treturn -EPERM;\n\t\t}\n\n\t\terror = -EEXIST;\n\t\tif (!(flags & XATTR_CREATE)) {\n\t\t\tint unstuffed = !GFS2_EA_IS_STUFFED(el.el_ea);\n\t\t\terror = ea_set_i(ip, type, name, value, size, &el);\n\t\t\tif (!error && unstuffed)\n\t\t\t\tea_set_remove_unstuffed(ip, &el);\n\t\t}\n\n\t\tbrelse(el.el_bh);\n\t\treturn error;\n\t}\n\n\terror = -ENODATA;\n\tif (!(flags & XATTR_REPLACE))\n\t\terror = ea_set_i(ip, type, name, value, size, NULL);\n\n\treturn error;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nint __gfs2_xattr_set(struct inode *inode, const char *name,\n\t\t   const void *value, size_t size, int flags, int type)\n{\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tstruct gfs2_sbd *sdp = GFS2_SB(inode);\n\tstruct gfs2_ea_location el;\n\tunsigned int namel = strlen(name);\n\tint error;\n\n\tif (IS_IMMUTABLE(inode) || IS_APPEND(inode))\n\t\treturn -EPERM;\n\tif (namel > GFS2_EA_MAX_NAME_LEN)\n\t\treturn -ERANGE;\n\n\tif (value == NULL)\n\t\treturn gfs2_xattr_remove(ip, type, name);\n\n\tif (ea_check_size(sdp, namel, size))\n\t\treturn -ERANGE;\n\n\tif (!ip->i_eattr) {\n\t\tif (flags & XATTR_REPLACE)\n\t\t\treturn -ENODATA;\n\t\treturn ea_init(ip, type, name, value, size);\n\t}\n\n\terror = gfs2_ea_find(ip, type, name, &el);\n\tif (error)\n\t\treturn error;\n\n\tif (el.el_ea) {\n\t\tif (ip->i_diskflags & GFS2_DIF_APPENDONLY) {\n\t\t\tbrelse(el.el_bh);\n\t\t\treturn -EPERM;\n\t\t}\n\n\t\terror = -EEXIST;\n\t\tif (!(flags & XATTR_CREATE)) {\n\t\t\tint unstuffed = !GFS2_EA_IS_STUFFED(el.el_ea);\n\t\t\terror = ea_set_i(ip, type, name, value, size, &el);\n\t\t\tif (!error && unstuffed)\n\t\t\t\tea_set_remove_unstuffed(ip, &el);\n\t\t}\n\n\t\tbrelse(el.el_bh);\n\t\treturn error;\n\t}\n\n\terror = -ENODATA;\n\tif (!(flags & XATTR_REPLACE))\n\t\terror = ea_set_i(ip, type, name, value, size, NULL);\n\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic int gfs2_xattr_set(struct dentry *dentry, const char *name,\n\t\tconst void *value, size_t size, int flags, int type)\n{\n\treturn __gfs2_xattr_set(dentry->d_inode, name, value,\n\t\t\t\tsize, flags, type);\n}"
  },
  {
    "function_name": "__gfs2_xattr_set",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
    "lines": "1175-1228",
    "snippet": "int __gfs2_xattr_set(struct inode *inode, const char *name,\n\t\t   const void *value, size_t size, int flags, int type)\n{\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tstruct gfs2_sbd *sdp = GFS2_SB(inode);\n\tstruct gfs2_ea_location el;\n\tunsigned int namel = strlen(name);\n\tint error;\n\n\tif (IS_IMMUTABLE(inode) || IS_APPEND(inode))\n\t\treturn -EPERM;\n\tif (namel > GFS2_EA_MAX_NAME_LEN)\n\t\treturn -ERANGE;\n\n\tif (value == NULL)\n\t\treturn gfs2_xattr_remove(ip, type, name);\n\n\tif (ea_check_size(sdp, namel, size))\n\t\treturn -ERANGE;\n\n\tif (!ip->i_eattr) {\n\t\tif (flags & XATTR_REPLACE)\n\t\t\treturn -ENODATA;\n\t\treturn ea_init(ip, type, name, value, size);\n\t}\n\n\terror = gfs2_ea_find(ip, type, name, &el);\n\tif (error)\n\t\treturn error;\n\n\tif (el.el_ea) {\n\t\tif (ip->i_diskflags & GFS2_DIF_APPENDONLY) {\n\t\t\tbrelse(el.el_bh);\n\t\t\treturn -EPERM;\n\t\t}\n\n\t\terror = -EEXIST;\n\t\tif (!(flags & XATTR_CREATE)) {\n\t\t\tint unstuffed = !GFS2_EA_IS_STUFFED(el.el_ea);\n\t\t\terror = ea_set_i(ip, type, name, value, size, &el);\n\t\t\tif (!error && unstuffed)\n\t\t\t\tea_set_remove_unstuffed(ip, &el);\n\t\t}\n\n\t\tbrelse(el.el_bh);\n\t\treturn error;\n\t}\n\n\terror = -ENODATA;\n\tif (!(flags & XATTR_REPLACE))\n\t\terror = ea_set_i(ip, type, name, value, size, NULL);\n\n\treturn error;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"trans.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"inode.h\"",
      "#include \"glock.h\"",
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/xattr.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ea_set_i",
          "args": [
            "ip",
            "type",
            "name",
            "value",
            "size",
            "NULL"
          ],
          "line": 1225
        },
        "resolved": true,
        "details": {
          "function_name": "ea_set_i",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "1042-1072",
          "snippet": "static int ea_set_i(struct gfs2_inode *ip, int type, const char *name,\n\t\t    const void *value, size_t size, struct gfs2_ea_location *el)\n{\n\tstruct gfs2_ea_request er;\n\tstruct ea_set es;\n\tunsigned int blks = 2;\n\tint error;\n\n\ter.er_type = type;\n\ter.er_name = name;\n\ter.er_data = (void *)value;\n\ter.er_name_len = strlen(name);\n\ter.er_data_len = size;\n\n\tmemset(&es, 0, sizeof(struct ea_set));\n\tes.es_er = &er;\n\tes.es_el = el;\n\n\terror = ea_foreach(ip, ea_set_simple, &es);\n\tif (error > 0)\n\t\treturn 0;\n\tif (error)\n\t\treturn error;\n\n\tif (!(ip->i_diskflags & GFS2_DIF_EA_INDIRECT))\n\t\tblks++;\n\tif (GFS2_EAREQ_SIZE_STUFFED(&er) > GFS2_SB(&ip->i_inode)->sd_jbsize)\n\t\tblks += DIV_ROUND_UP(er.er_data_len, GFS2_SB(&ip->i_inode)->sd_jbsize);\n\n\treturn ea_alloc_skeleton(ip, &er, blks, ea_set_block, el);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic int ea_set_i(struct gfs2_inode *ip, int type, const char *name,\n\t\t    const void *value, size_t size, struct gfs2_ea_location *el)\n{\n\tstruct gfs2_ea_request er;\n\tstruct ea_set es;\n\tunsigned int blks = 2;\n\tint error;\n\n\ter.er_type = type;\n\ter.er_name = name;\n\ter.er_data = (void *)value;\n\ter.er_name_len = strlen(name);\n\ter.er_data_len = size;\n\n\tmemset(&es, 0, sizeof(struct ea_set));\n\tes.es_er = &er;\n\tes.es_el = el;\n\n\terror = ea_foreach(ip, ea_set_simple, &es);\n\tif (error > 0)\n\t\treturn 0;\n\tif (error)\n\t\treturn error;\n\n\tif (!(ip->i_diskflags & GFS2_DIF_EA_INDIRECT))\n\t\tblks++;\n\tif (GFS2_EAREQ_SIZE_STUFFED(&er) > GFS2_SB(&ip->i_inode)->sd_jbsize)\n\t\tblks += DIV_ROUND_UP(er.er_data_len, GFS2_SB(&ip->i_inode)->sd_jbsize);\n\n\treturn ea_alloc_skeleton(ip, &er, blks, ea_set_block, el);\n}"
        }
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "el.el_bh"
          ],
          "line": 1219
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "ea_set_remove_unstuffed",
          "args": [
            "ip",
            "&el"
          ],
          "line": 1216
        },
        "resolved": true,
        "details": {
          "function_name": "ea_set_remove_unstuffed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "1074-1084",
          "snippet": "static int ea_set_remove_unstuffed(struct gfs2_inode *ip,\n\t\t\t\t   struct gfs2_ea_location *el)\n{\n\tif (el->el_prev && GFS2_EA2NEXT(el->el_prev) != el->el_ea) {\n\t\tel->el_prev = GFS2_EA2NEXT(el->el_prev);\n\t\tgfs2_assert_withdraw(GFS2_SB(&ip->i_inode),\n\t\t\t\t     GFS2_EA2NEXT(el->el_prev) == el->el_ea);\n\t}\n\n\treturn ea_remove_unstuffed(ip, el->el_bh, el->el_ea, el->el_prev, 0);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic int ea_set_remove_unstuffed(struct gfs2_inode *ip,\n\t\t\t\t   struct gfs2_ea_location *el)\n{\n\tif (el->el_prev && GFS2_EA2NEXT(el->el_prev) != el->el_ea) {\n\t\tel->el_prev = GFS2_EA2NEXT(el->el_prev);\n\t\tgfs2_assert_withdraw(GFS2_SB(&ip->i_inode),\n\t\t\t\t     GFS2_EA2NEXT(el->el_prev) == el->el_ea);\n\t}\n\n\treturn ea_remove_unstuffed(ip, el->el_bh, el->el_ea, el->el_prev, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "GFS2_EA_IS_STUFFED",
          "args": [
            "el.el_ea"
          ],
          "line": 1213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_ea_find",
          "args": [
            "ip",
            "type",
            "name",
            "&el"
          ],
          "line": 1201
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_find",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "190-208",
          "snippet": "static int gfs2_ea_find(struct gfs2_inode *ip, int type, const char *name,\n\t\t\tstruct gfs2_ea_location *el)\n{\n\tstruct ea_find ef;\n\tint error;\n\n\tef.type = type;\n\tef.name = name;\n\tef.namel = strlen(name);\n\tef.ef_el = el;\n\n\tmemset(el, 0, sizeof(struct gfs2_ea_location));\n\n\terror = ea_foreach(ip, ea_find_i, &ef);\n\tif (error > 0)\n\t\treturn 0;\n\n\treturn error;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic int gfs2_ea_find(struct gfs2_inode *ip, int type, const char *name,\n\t\t\tstruct gfs2_ea_location *el)\n{\n\tstruct ea_find ef;\n\tint error;\n\n\tef.type = type;\n\tef.name = name;\n\tef.namel = strlen(name);\n\tef.ef_el = el;\n\n\tmemset(el, 0, sizeof(struct gfs2_ea_location));\n\n\terror = ea_foreach(ip, ea_find_i, &ef);\n\tif (error > 0)\n\t\treturn 0;\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ea_init",
          "args": [
            "ip",
            "type",
            "name",
            "value",
            "size"
          ],
          "line": 1198
        },
        "resolved": true,
        "details": {
          "function_name": "ea_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "796-813",
          "snippet": "static int ea_init(struct gfs2_inode *ip, int type, const char *name,\n\t\t   const void *data, size_t size)\n{\n\tstruct gfs2_ea_request er;\n\tunsigned int jbsize = GFS2_SB(&ip->i_inode)->sd_jbsize;\n\tunsigned int blks = 1;\n\n\ter.er_type = type;\n\ter.er_name = name;\n\ter.er_name_len = strlen(name);\n\ter.er_data = (void *)data;\n\ter.er_data_len = size;\n\n\tif (GFS2_EAREQ_SIZE_STUFFED(&er) > jbsize)\n\t\tblks += DIV_ROUND_UP(er.er_data_len, jbsize);\n\n\treturn ea_alloc_skeleton(ip, &er, blks, ea_init_i, NULL);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic int ea_init(struct gfs2_inode *ip, int type, const char *name,\n\t\t   const void *data, size_t size)\n{\n\tstruct gfs2_ea_request er;\n\tunsigned int jbsize = GFS2_SB(&ip->i_inode)->sd_jbsize;\n\tunsigned int blks = 1;\n\n\ter.er_type = type;\n\ter.er_name = name;\n\ter.er_name_len = strlen(name);\n\ter.er_data = (void *)data;\n\ter.er_data_len = size;\n\n\tif (GFS2_EAREQ_SIZE_STUFFED(&er) > jbsize)\n\t\tblks += DIV_ROUND_UP(er.er_data_len, jbsize);\n\n\treturn ea_alloc_skeleton(ip, &er, blks, ea_init_i, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ea_check_size",
          "args": [
            "sdp",
            "namel",
            "size"
          ],
          "line": 1192
        },
        "resolved": true,
        "details": {
          "function_name": "ea_check_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "59-73",
          "snippet": "static int ea_check_size(struct gfs2_sbd *sdp, unsigned int nsize, size_t dsize)\n{\n\tunsigned int size;\n\n\tif (dsize > GFS2_EA_MAX_DATA_LEN)\n\t\treturn -ERANGE;\n\n\tea_calc_size(sdp, nsize, dsize, &size);\n\n\t/* This can only happen with 512 byte blocks */\n\tif (size > sdp->sd_jbsize)\n\t\treturn -ERANGE;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic int ea_check_size(struct gfs2_sbd *sdp, unsigned int nsize, size_t dsize)\n{\n\tunsigned int size;\n\n\tif (dsize > GFS2_EA_MAX_DATA_LEN)\n\t\treturn -ERANGE;\n\n\tea_calc_size(sdp, nsize, dsize, &size);\n\n\t/* This can only happen with 512 byte blocks */\n\tif (size > sdp->sd_jbsize)\n\t\treturn -ERANGE;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_xattr_remove",
          "args": [
            "ip",
            "type",
            "name"
          ],
          "line": 1190
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_xattr_remove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "1137-1159",
          "snippet": "static int gfs2_xattr_remove(struct gfs2_inode *ip, int type, const char *name)\n{\n\tstruct gfs2_ea_location el;\n\tint error;\n\n\tif (!ip->i_eattr)\n\t\treturn -ENODATA;\n\n\terror = gfs2_ea_find(ip, type, name, &el);\n\tif (error)\n\t\treturn error;\n\tif (!el.el_ea)\n\t\treturn -ENODATA;\n\n\tif (GFS2_EA_IS_STUFFED(el.el_ea))\n\t\terror = ea_remove_stuffed(ip, &el);\n\telse\n\t\terror = ea_remove_unstuffed(ip, el.el_bh, el.el_ea, el.el_prev, 0);\n\n\tbrelse(el.el_bh);\n\n\treturn error;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic int gfs2_xattr_remove(struct gfs2_inode *ip, int type, const char *name)\n{\n\tstruct gfs2_ea_location el;\n\tint error;\n\n\tif (!ip->i_eattr)\n\t\treturn -ENODATA;\n\n\terror = gfs2_ea_find(ip, type, name, &el);\n\tif (error)\n\t\treturn error;\n\tif (!el.el_ea)\n\t\treturn -ENODATA;\n\n\tif (GFS2_EA_IS_STUFFED(el.el_ea))\n\t\terror = ea_remove_stuffed(ip, &el);\n\telse\n\t\terror = ea_remove_unstuffed(ip, el.el_bh, el.el_ea, el.el_prev, 0);\n\n\tbrelse(el.el_bh);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_APPEND",
          "args": [
            "inode"
          ],
          "line": 1184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_IMMUTABLE",
          "args": [
            "inode"
          ],
          "line": 1184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "name"
          ],
          "line": 1181
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "GFS2_SB",
          "args": [
            "inode"
          ],
          "line": 1179
        },
        "resolved": true,
        "details": {
          "function_name": "GFS2_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/incore.h",
          "lines": "413-416",
          "snippet": "static inline struct gfs2_sbd *GFS2_SB(const struct inode *inode)\n{\n\treturn inode->i_sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/lockref.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ktime.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/completion.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dlm.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockref.h>\n#include <linux/percpu.h>\n#include <linux/ktime.h>\n#include <linux/rbtree.h>\n#include <linux/completion.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/buffer_head.h>\n#include <linux/dlm.h>\n#include <linux/workqueue.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n\nstatic inline struct gfs2_sbd *GFS2_SB(const struct inode *inode)\n{\n\treturn inode->i_sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GFS2_I",
          "args": [
            "inode"
          ],
          "line": 1178
        },
        "resolved": true,
        "details": {
          "function_name": "GFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/incore.h",
          "lines": "408-411",
          "snippet": "static inline struct gfs2_inode *GFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct gfs2_inode, i_inode);\n}",
          "includes": [
            "#include <linux/lockref.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ktime.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/completion.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dlm.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockref.h>\n#include <linux/percpu.h>\n#include <linux/ktime.h>\n#include <linux/rbtree.h>\n#include <linux/completion.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/buffer_head.h>\n#include <linux/dlm.h>\n#include <linux/workqueue.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n\nstatic inline struct gfs2_inode *GFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct gfs2_inode, i_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nint __gfs2_xattr_set(struct inode *inode, const char *name,\n\t\t   const void *value, size_t size, int flags, int type)\n{\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tstruct gfs2_sbd *sdp = GFS2_SB(inode);\n\tstruct gfs2_ea_location el;\n\tunsigned int namel = strlen(name);\n\tint error;\n\n\tif (IS_IMMUTABLE(inode) || IS_APPEND(inode))\n\t\treturn -EPERM;\n\tif (namel > GFS2_EA_MAX_NAME_LEN)\n\t\treturn -ERANGE;\n\n\tif (value == NULL)\n\t\treturn gfs2_xattr_remove(ip, type, name);\n\n\tif (ea_check_size(sdp, namel, size))\n\t\treturn -ERANGE;\n\n\tif (!ip->i_eattr) {\n\t\tif (flags & XATTR_REPLACE)\n\t\t\treturn -ENODATA;\n\t\treturn ea_init(ip, type, name, value, size);\n\t}\n\n\terror = gfs2_ea_find(ip, type, name, &el);\n\tif (error)\n\t\treturn error;\n\n\tif (el.el_ea) {\n\t\tif (ip->i_diskflags & GFS2_DIF_APPENDONLY) {\n\t\t\tbrelse(el.el_bh);\n\t\t\treturn -EPERM;\n\t\t}\n\n\t\terror = -EEXIST;\n\t\tif (!(flags & XATTR_CREATE)) {\n\t\t\tint unstuffed = !GFS2_EA_IS_STUFFED(el.el_ea);\n\t\t\terror = ea_set_i(ip, type, name, value, size, &el);\n\t\t\tif (!error && unstuffed)\n\t\t\t\tea_set_remove_unstuffed(ip, &el);\n\t\t}\n\n\t\tbrelse(el.el_bh);\n\t\treturn error;\n\t}\n\n\terror = -ENODATA;\n\tif (!(flags & XATTR_REPLACE))\n\t\terror = ea_set_i(ip, type, name, value, size, NULL);\n\n\treturn error;\n}"
  },
  {
    "function_name": "gfs2_xattr_remove",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
    "lines": "1137-1159",
    "snippet": "static int gfs2_xattr_remove(struct gfs2_inode *ip, int type, const char *name)\n{\n\tstruct gfs2_ea_location el;\n\tint error;\n\n\tif (!ip->i_eattr)\n\t\treturn -ENODATA;\n\n\terror = gfs2_ea_find(ip, type, name, &el);\n\tif (error)\n\t\treturn error;\n\tif (!el.el_ea)\n\t\treturn -ENODATA;\n\n\tif (GFS2_EA_IS_STUFFED(el.el_ea))\n\t\terror = ea_remove_stuffed(ip, &el);\n\telse\n\t\terror = ea_remove_unstuffed(ip, el.el_bh, el.el_ea, el.el_prev, 0);\n\n\tbrelse(el.el_bh);\n\n\treturn error;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"trans.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"inode.h\"",
      "#include \"glock.h\"",
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/xattr.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "el.el_bh"
          ],
          "line": 1156
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "ea_remove_unstuffed",
          "args": [
            "ip",
            "el.el_bh",
            "el.el_ea",
            "el.el_prev",
            "0"
          ],
          "line": 1154
        },
        "resolved": true,
        "details": {
          "function_name": "ea_remove_unstuffed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "325-344",
          "snippet": "static int ea_remove_unstuffed(struct gfs2_inode *ip, struct buffer_head *bh,\n\t\t\t       struct gfs2_ea_header *ea,\n\t\t\t       struct gfs2_ea_header *prev, int leave)\n{\n\tint error;\n\n\terror = gfs2_rindex_update(GFS2_SB(&ip->i_inode));\n\tif (error)\n\t\treturn error;\n\n\terror = gfs2_quota_hold(ip, NO_UID_QUOTA_CHANGE, NO_GID_QUOTA_CHANGE);\n\tif (error)\n\t\tgoto out_alloc;\n\n\terror = ea_dealloc_unstuffed(ip, bh, ea, prev, (leave) ? &error : NULL);\n\n\tgfs2_quota_unhold(ip);\nout_alloc:\n\treturn error;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic int ea_remove_unstuffed(struct gfs2_inode *ip, struct buffer_head *bh,\n\t\t\t       struct gfs2_ea_header *ea,\n\t\t\t       struct gfs2_ea_header *prev, int leave)\n{\n\tint error;\n\n\terror = gfs2_rindex_update(GFS2_SB(&ip->i_inode));\n\tif (error)\n\t\treturn error;\n\n\terror = gfs2_quota_hold(ip, NO_UID_QUOTA_CHANGE, NO_GID_QUOTA_CHANGE);\n\tif (error)\n\t\tgoto out_alloc;\n\n\terror = ea_dealloc_unstuffed(ip, bh, ea, prev, (leave) ? &error : NULL);\n\n\tgfs2_quota_unhold(ip);\nout_alloc:\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ea_remove_stuffed",
          "args": [
            "ip",
            "&el"
          ],
          "line": 1152
        },
        "resolved": true,
        "details": {
          "function_name": "ea_remove_stuffed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "1086-1122",
          "snippet": "static int ea_remove_stuffed(struct gfs2_inode *ip, struct gfs2_ea_location *el)\n{\n\tstruct gfs2_ea_header *ea = el->el_ea;\n\tstruct gfs2_ea_header *prev = el->el_prev;\n\tstruct buffer_head *dibh;\n\tint error;\n\n\terror = gfs2_trans_begin(GFS2_SB(&ip->i_inode), RES_DINODE + RES_EATTR, 0);\n\tif (error)\n\t\treturn error;\n\n\tgfs2_trans_add_meta(ip->i_gl, el->el_bh);\n\n\tif (prev) {\n\t\tu32 len;\n\n\t\tlen = GFS2_EA_REC_LEN(prev) + GFS2_EA_REC_LEN(ea);\n\t\tprev->ea_rec_len = cpu_to_be32(len);\n\n\t\tif (GFS2_EA_IS_LAST(ea))\n\t\t\tprev->ea_flags |= GFS2_EAFLAG_LAST;\n\t} else {\n\t\tea->ea_type = GFS2_EATYPE_UNUSED;\n\t}\n\n\terror = gfs2_meta_inode_buffer(ip, &dibh);\n\tif (!error) {\n\t\tip->i_inode.i_ctime = CURRENT_TIME;\n\t\tgfs2_trans_add_meta(ip->i_gl, dibh);\n\t\tgfs2_dinode_out(ip, dibh->b_data);\n\t\tbrelse(dibh);\n\t}\n\n\tgfs2_trans_end(GFS2_SB(&ip->i_inode));\n\n\treturn error;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic int ea_remove_stuffed(struct gfs2_inode *ip, struct gfs2_ea_location *el)\n{\n\tstruct gfs2_ea_header *ea = el->el_ea;\n\tstruct gfs2_ea_header *prev = el->el_prev;\n\tstruct buffer_head *dibh;\n\tint error;\n\n\terror = gfs2_trans_begin(GFS2_SB(&ip->i_inode), RES_DINODE + RES_EATTR, 0);\n\tif (error)\n\t\treturn error;\n\n\tgfs2_trans_add_meta(ip->i_gl, el->el_bh);\n\n\tif (prev) {\n\t\tu32 len;\n\n\t\tlen = GFS2_EA_REC_LEN(prev) + GFS2_EA_REC_LEN(ea);\n\t\tprev->ea_rec_len = cpu_to_be32(len);\n\n\t\tif (GFS2_EA_IS_LAST(ea))\n\t\t\tprev->ea_flags |= GFS2_EAFLAG_LAST;\n\t} else {\n\t\tea->ea_type = GFS2_EATYPE_UNUSED;\n\t}\n\n\terror = gfs2_meta_inode_buffer(ip, &dibh);\n\tif (!error) {\n\t\tip->i_inode.i_ctime = CURRENT_TIME;\n\t\tgfs2_trans_add_meta(ip->i_gl, dibh);\n\t\tgfs2_dinode_out(ip, dibh->b_data);\n\t\tbrelse(dibh);\n\t}\n\n\tgfs2_trans_end(GFS2_SB(&ip->i_inode));\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GFS2_EA_IS_STUFFED",
          "args": [
            "el.el_ea"
          ],
          "line": 1151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_ea_find",
          "args": [
            "ip",
            "type",
            "name",
            "&el"
          ],
          "line": 1145
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_find",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "190-208",
          "snippet": "static int gfs2_ea_find(struct gfs2_inode *ip, int type, const char *name,\n\t\t\tstruct gfs2_ea_location *el)\n{\n\tstruct ea_find ef;\n\tint error;\n\n\tef.type = type;\n\tef.name = name;\n\tef.namel = strlen(name);\n\tef.ef_el = el;\n\n\tmemset(el, 0, sizeof(struct gfs2_ea_location));\n\n\terror = ea_foreach(ip, ea_find_i, &ef);\n\tif (error > 0)\n\t\treturn 0;\n\n\treturn error;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic int gfs2_ea_find(struct gfs2_inode *ip, int type, const char *name,\n\t\t\tstruct gfs2_ea_location *el)\n{\n\tstruct ea_find ef;\n\tint error;\n\n\tef.type = type;\n\tef.name = name;\n\tef.namel = strlen(name);\n\tef.ef_el = el;\n\n\tmemset(el, 0, sizeof(struct gfs2_ea_location));\n\n\terror = ea_foreach(ip, ea_find_i, &ef);\n\tif (error > 0)\n\t\treturn 0;\n\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic int gfs2_xattr_remove(struct gfs2_inode *ip, int type, const char *name)\n{\n\tstruct gfs2_ea_location el;\n\tint error;\n\n\tif (!ip->i_eattr)\n\t\treturn -ENODATA;\n\n\terror = gfs2_ea_find(ip, type, name, &el);\n\tif (error)\n\t\treturn error;\n\tif (!el.el_ea)\n\t\treturn -ENODATA;\n\n\tif (GFS2_EA_IS_STUFFED(el.el_ea))\n\t\terror = ea_remove_stuffed(ip, &el);\n\telse\n\t\terror = ea_remove_unstuffed(ip, el.el_bh, el.el_ea, el.el_prev, 0);\n\n\tbrelse(el.el_bh);\n\n\treturn error;\n}"
  },
  {
    "function_name": "ea_remove_stuffed",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
    "lines": "1086-1122",
    "snippet": "static int ea_remove_stuffed(struct gfs2_inode *ip, struct gfs2_ea_location *el)\n{\n\tstruct gfs2_ea_header *ea = el->el_ea;\n\tstruct gfs2_ea_header *prev = el->el_prev;\n\tstruct buffer_head *dibh;\n\tint error;\n\n\terror = gfs2_trans_begin(GFS2_SB(&ip->i_inode), RES_DINODE + RES_EATTR, 0);\n\tif (error)\n\t\treturn error;\n\n\tgfs2_trans_add_meta(ip->i_gl, el->el_bh);\n\n\tif (prev) {\n\t\tu32 len;\n\n\t\tlen = GFS2_EA_REC_LEN(prev) + GFS2_EA_REC_LEN(ea);\n\t\tprev->ea_rec_len = cpu_to_be32(len);\n\n\t\tif (GFS2_EA_IS_LAST(ea))\n\t\t\tprev->ea_flags |= GFS2_EAFLAG_LAST;\n\t} else {\n\t\tea->ea_type = GFS2_EATYPE_UNUSED;\n\t}\n\n\terror = gfs2_meta_inode_buffer(ip, &dibh);\n\tif (!error) {\n\t\tip->i_inode.i_ctime = CURRENT_TIME;\n\t\tgfs2_trans_add_meta(ip->i_gl, dibh);\n\t\tgfs2_dinode_out(ip, dibh->b_data);\n\t\tbrelse(dibh);\n\t}\n\n\tgfs2_trans_end(GFS2_SB(&ip->i_inode));\n\n\treturn error;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"trans.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"inode.h\"",
      "#include \"glock.h\"",
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/xattr.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "gfs2_trans_end",
          "args": [
            "GFS2_SB(&ip->i_inode)"
          ],
          "line": 1119
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_trans_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/trans.c",
          "lines": "88-123",
          "snippet": "void gfs2_trans_end(struct gfs2_sbd *sdp)\n{\n\tstruct gfs2_trans *tr = current->journal_info;\n\ts64 nbuf;\n\tint alloced = tr->tr_alloced;\n\n\tBUG_ON(!tr);\n\tcurrent->journal_info = NULL;\n\n\tif (!tr->tr_touched) {\n\t\tgfs2_log_release(sdp, tr->tr_reserved);\n\t\tif (alloced) {\n\t\t\tkfree(tr);\n\t\t\tsb_end_intwrite(sdp->sd_vfs);\n\t\t}\n\t\treturn;\n\t}\n\n\tnbuf = tr->tr_num_buf_new + tr->tr_num_databuf_new;\n\tnbuf -= tr->tr_num_buf_rm;\n\tnbuf -= tr->tr_num_databuf_rm;\n\n\tif (gfs2_assert_withdraw(sdp, (nbuf <= tr->tr_blocks) &&\n\t\t\t\t       (tr->tr_num_revoke <= tr->tr_revokes)))\n\t\tgfs2_print_trans(tr);\n\n\tgfs2_log_commit(sdp, tr);\n\tif (alloced && !tr->tr_attached)\n\t\t\tkfree(tr);\n\tup_read(&sdp->sd_log_flush_lock);\n\n\tif (sdp->sd_vfs->s_flags & MS_SYNCHRONOUS)\n\t\tgfs2_log_flush(sdp, NULL, NORMAL_FLUSH);\n\tif (alloced)\n\t\tsb_end_intwrite(sdp->sd_vfs);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_trans_end(struct gfs2_sbd *sdp)\n{\n\tstruct gfs2_trans *tr = current->journal_info;\n\ts64 nbuf;\n\tint alloced = tr->tr_alloced;\n\n\tBUG_ON(!tr);\n\tcurrent->journal_info = NULL;\n\n\tif (!tr->tr_touched) {\n\t\tgfs2_log_release(sdp, tr->tr_reserved);\n\t\tif (alloced) {\n\t\t\tkfree(tr);\n\t\t\tsb_end_intwrite(sdp->sd_vfs);\n\t\t}\n\t\treturn;\n\t}\n\n\tnbuf = tr->tr_num_buf_new + tr->tr_num_databuf_new;\n\tnbuf -= tr->tr_num_buf_rm;\n\tnbuf -= tr->tr_num_databuf_rm;\n\n\tif (gfs2_assert_withdraw(sdp, (nbuf <= tr->tr_blocks) &&\n\t\t\t\t       (tr->tr_num_revoke <= tr->tr_revokes)))\n\t\tgfs2_print_trans(tr);\n\n\tgfs2_log_commit(sdp, tr);\n\tif (alloced && !tr->tr_attached)\n\t\t\tkfree(tr);\n\tup_read(&sdp->sd_log_flush_lock);\n\n\tif (sdp->sd_vfs->s_flags & MS_SYNCHRONOUS)\n\t\tgfs2_log_flush(sdp, NULL, NORMAL_FLUSH);\n\tif (alloced)\n\t\tsb_end_intwrite(sdp->sd_vfs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "GFS2_SB",
          "args": [
            "&ip->i_inode"
          ],
          "line": 1119
        },
        "resolved": true,
        "details": {
          "function_name": "GFS2_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/incore.h",
          "lines": "413-416",
          "snippet": "static inline struct gfs2_sbd *GFS2_SB(const struct inode *inode)\n{\n\treturn inode->i_sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/lockref.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ktime.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/completion.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dlm.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockref.h>\n#include <linux/percpu.h>\n#include <linux/ktime.h>\n#include <linux/rbtree.h>\n#include <linux/completion.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/buffer_head.h>\n#include <linux/dlm.h>\n#include <linux/workqueue.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n\nstatic inline struct gfs2_sbd *GFS2_SB(const struct inode *inode)\n{\n\treturn inode->i_sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "dibh"
          ],
          "line": 1116
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_dinode_out",
          "args": [
            "ip",
            "dibh->b_data"
          ],
          "line": 1115
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_dinode_out",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/super.c",
          "lines": "696-731",
          "snippet": "void gfs2_dinode_out(const struct gfs2_inode *ip, void *buf)\n{\n\tstruct gfs2_dinode *str = buf;\n\n\tstr->di_header.mh_magic = cpu_to_be32(GFS2_MAGIC);\n\tstr->di_header.mh_type = cpu_to_be32(GFS2_METATYPE_DI);\n\tstr->di_header.mh_format = cpu_to_be32(GFS2_FORMAT_DI);\n\tstr->di_num.no_addr = cpu_to_be64(ip->i_no_addr);\n\tstr->di_num.no_formal_ino = cpu_to_be64(ip->i_no_formal_ino);\n\tstr->di_mode = cpu_to_be32(ip->i_inode.i_mode);\n\tstr->di_uid = cpu_to_be32(i_uid_read(&ip->i_inode));\n\tstr->di_gid = cpu_to_be32(i_gid_read(&ip->i_inode));\n\tstr->di_nlink = cpu_to_be32(ip->i_inode.i_nlink);\n\tstr->di_size = cpu_to_be64(i_size_read(&ip->i_inode));\n\tstr->di_blocks = cpu_to_be64(gfs2_get_inode_blocks(&ip->i_inode));\n\tstr->di_atime = cpu_to_be64(ip->i_inode.i_atime.tv_sec);\n\tstr->di_mtime = cpu_to_be64(ip->i_inode.i_mtime.tv_sec);\n\tstr->di_ctime = cpu_to_be64(ip->i_inode.i_ctime.tv_sec);\n\n\tstr->di_goal_meta = cpu_to_be64(ip->i_goal);\n\tstr->di_goal_data = cpu_to_be64(ip->i_goal);\n\tstr->di_generation = cpu_to_be64(ip->i_generation);\n\n\tstr->di_flags = cpu_to_be32(ip->i_diskflags);\n\tstr->di_height = cpu_to_be16(ip->i_height);\n\tstr->di_payload_format = cpu_to_be32(S_ISDIR(ip->i_inode.i_mode) &&\n\t\t\t\t\t     !(ip->i_diskflags & GFS2_DIF_EXHASH) ?\n\t\t\t\t\t     GFS2_FORMAT_DE : 0);\n\tstr->di_depth = cpu_to_be16(ip->i_depth);\n\tstr->di_entries = cpu_to_be32(ip->i_entries);\n\n\tstr->di_eattr = cpu_to_be64(ip->i_eattr);\n\tstr->di_atime_nsec = cpu_to_be32(ip->i_inode.i_atime.tv_nsec);\n\tstr->di_mtime_nsec = cpu_to_be32(ip->i_inode.i_mtime.tv_nsec);\n\tstr->di_ctime_nsec = cpu_to_be32(ip->i_inode.i_ctime.tv_nsec);\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"sys.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"recovery.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"dir.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/kernel.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/time.h>",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/statfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/bio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"sys.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"recovery.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"dir.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/kernel.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/time.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/statfs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/bio.h>\n\nvoid gfs2_dinode_out(const struct gfs2_inode *ip, void *buf)\n{\n\tstruct gfs2_dinode *str = buf;\n\n\tstr->di_header.mh_magic = cpu_to_be32(GFS2_MAGIC);\n\tstr->di_header.mh_type = cpu_to_be32(GFS2_METATYPE_DI);\n\tstr->di_header.mh_format = cpu_to_be32(GFS2_FORMAT_DI);\n\tstr->di_num.no_addr = cpu_to_be64(ip->i_no_addr);\n\tstr->di_num.no_formal_ino = cpu_to_be64(ip->i_no_formal_ino);\n\tstr->di_mode = cpu_to_be32(ip->i_inode.i_mode);\n\tstr->di_uid = cpu_to_be32(i_uid_read(&ip->i_inode));\n\tstr->di_gid = cpu_to_be32(i_gid_read(&ip->i_inode));\n\tstr->di_nlink = cpu_to_be32(ip->i_inode.i_nlink);\n\tstr->di_size = cpu_to_be64(i_size_read(&ip->i_inode));\n\tstr->di_blocks = cpu_to_be64(gfs2_get_inode_blocks(&ip->i_inode));\n\tstr->di_atime = cpu_to_be64(ip->i_inode.i_atime.tv_sec);\n\tstr->di_mtime = cpu_to_be64(ip->i_inode.i_mtime.tv_sec);\n\tstr->di_ctime = cpu_to_be64(ip->i_inode.i_ctime.tv_sec);\n\n\tstr->di_goal_meta = cpu_to_be64(ip->i_goal);\n\tstr->di_goal_data = cpu_to_be64(ip->i_goal);\n\tstr->di_generation = cpu_to_be64(ip->i_generation);\n\n\tstr->di_flags = cpu_to_be32(ip->i_diskflags);\n\tstr->di_height = cpu_to_be16(ip->i_height);\n\tstr->di_payload_format = cpu_to_be32(S_ISDIR(ip->i_inode.i_mode) &&\n\t\t\t\t\t     !(ip->i_diskflags & GFS2_DIF_EXHASH) ?\n\t\t\t\t\t     GFS2_FORMAT_DE : 0);\n\tstr->di_depth = cpu_to_be16(ip->i_depth);\n\tstr->di_entries = cpu_to_be32(ip->i_entries);\n\n\tstr->di_eattr = cpu_to_be64(ip->i_eattr);\n\tstr->di_atime_nsec = cpu_to_be32(ip->i_inode.i_atime.tv_nsec);\n\tstr->di_mtime_nsec = cpu_to_be32(ip->i_inode.i_mtime.tv_nsec);\n\tstr->di_ctime_nsec = cpu_to_be32(ip->i_inode.i_ctime.tv_nsec);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_trans_add_meta",
          "args": [
            "ip->i_gl",
            "dibh"
          ],
          "line": 1114
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_trans_add_meta",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/trans.c",
          "lines": "224-247",
          "snippet": "void gfs2_trans_add_meta(struct gfs2_glock *gl, struct buffer_head *bh)\n{\n\n\tstruct gfs2_sbd *sdp = gl->gl_sbd;\n\tstruct gfs2_bufdata *bd;\n\n\tlock_buffer(bh);\n\tgfs2_log_lock(sdp);\n\tbd = bh->b_private;\n\tif (bd == NULL) {\n\t\tgfs2_log_unlock(sdp);\n\t\tunlock_buffer(bh);\n\t\tlock_page(bh->b_page);\n\t\tif (bh->b_private == NULL)\n\t\t\tbd = gfs2_alloc_bufdata(gl, bh, &gfs2_buf_lops);\n\t\tunlock_page(bh->b_page);\n\t\tlock_buffer(bh);\n\t\tgfs2_log_lock(sdp);\n\t}\n\tgfs2_assert(sdp, bd->bd_gl == gl);\n\tmeta_lo_add(sdp, bd);\n\tgfs2_log_unlock(sdp);\n\tunlock_buffer(bh);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_trans_add_meta(struct gfs2_glock *gl, struct buffer_head *bh)\n{\n\n\tstruct gfs2_sbd *sdp = gl->gl_sbd;\n\tstruct gfs2_bufdata *bd;\n\n\tlock_buffer(bh);\n\tgfs2_log_lock(sdp);\n\tbd = bh->b_private;\n\tif (bd == NULL) {\n\t\tgfs2_log_unlock(sdp);\n\t\tunlock_buffer(bh);\n\t\tlock_page(bh->b_page);\n\t\tif (bh->b_private == NULL)\n\t\t\tbd = gfs2_alloc_bufdata(gl, bh, &gfs2_buf_lops);\n\t\tunlock_page(bh->b_page);\n\t\tlock_buffer(bh);\n\t\tgfs2_log_lock(sdp);\n\t}\n\tgfs2_assert(sdp, bd->bd_gl == gl);\n\tmeta_lo_add(sdp, bd);\n\tgfs2_log_unlock(sdp);\n\tunlock_buffer(bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_meta_inode_buffer",
          "args": [
            "ip",
            "&dibh"
          ],
          "line": 1111
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_meta_inode_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/meta_io.h",
          "lines": "66-70",
          "snippet": "static inline int gfs2_meta_inode_buffer(struct gfs2_inode *ip,\n\t\t\t\t\t struct buffer_head **bhp)\n{\n\treturn gfs2_meta_indirect_buffer(ip, 0, ip->i_no_addr, bhp);\n}",
          "includes": [
            "#include \"incore.h\"",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"incore.h\"\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline int gfs2_meta_inode_buffer(struct gfs2_inode *ip,\n\t\t\t\t\t struct buffer_head **bhp)\n{\n\treturn gfs2_meta_indirect_buffer(ip, 0, ip->i_no_addr, bhp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "GFS2_EA_IS_LAST",
          "args": [
            "ea"
          ],
          "line": 1105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "len"
          ],
          "line": 1103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GFS2_EA_REC_LEN",
          "args": [
            "ea"
          ],
          "line": 1102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GFS2_EA_REC_LEN",
          "args": [
            "prev"
          ],
          "line": 1102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_trans_begin",
          "args": [
            "GFS2_SB(&ip->i_inode)",
            "RES_DINODE + RES_EATTR",
            "0"
          ],
          "line": 1093
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_trans_begin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/trans.c",
          "lines": "31-75",
          "snippet": "int gfs2_trans_begin(struct gfs2_sbd *sdp, unsigned int blocks,\n\t\t     unsigned int revokes)\n{\n\tstruct gfs2_trans *tr;\n\tint error;\n\n\tBUG_ON(current->journal_info);\n\tBUG_ON(blocks == 0 && revokes == 0);\n\n\tif (!test_bit(SDF_JOURNAL_LIVE, &sdp->sd_flags))\n\t\treturn -EROFS;\n\n\ttr = kzalloc(sizeof(struct gfs2_trans), GFP_NOFS);\n\tif (!tr)\n\t\treturn -ENOMEM;\n\n\ttr->tr_ip = _RET_IP_;\n\ttr->tr_blocks = blocks;\n\ttr->tr_revokes = revokes;\n\ttr->tr_reserved = 1;\n\ttr->tr_alloced = 1;\n\tif (blocks)\n\t\ttr->tr_reserved += 6 + blocks;\n\tif (revokes)\n\t\ttr->tr_reserved += gfs2_struct2blk(sdp, revokes,\n\t\t\t\t\t\t   sizeof(u64));\n\tINIT_LIST_HEAD(&tr->tr_databuf);\n\tINIT_LIST_HEAD(&tr->tr_buf);\n\n\tsb_start_intwrite(sdp->sd_vfs);\n\n\terror = gfs2_log_reserve(sdp, tr->tr_reserved);\n\tif (error)\n\t\tgoto fail;\n\n\tcurrent->journal_info = tr;\n\n\treturn 0;\n\nfail:\n\tsb_end_intwrite(sdp->sd_vfs);\n\tkfree(tr);\n\n\treturn error;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nint gfs2_trans_begin(struct gfs2_sbd *sdp, unsigned int blocks,\n\t\t     unsigned int revokes)\n{\n\tstruct gfs2_trans *tr;\n\tint error;\n\n\tBUG_ON(current->journal_info);\n\tBUG_ON(blocks == 0 && revokes == 0);\n\n\tif (!test_bit(SDF_JOURNAL_LIVE, &sdp->sd_flags))\n\t\treturn -EROFS;\n\n\ttr = kzalloc(sizeof(struct gfs2_trans), GFP_NOFS);\n\tif (!tr)\n\t\treturn -ENOMEM;\n\n\ttr->tr_ip = _RET_IP_;\n\ttr->tr_blocks = blocks;\n\ttr->tr_revokes = revokes;\n\ttr->tr_reserved = 1;\n\ttr->tr_alloced = 1;\n\tif (blocks)\n\t\ttr->tr_reserved += 6 + blocks;\n\tif (revokes)\n\t\ttr->tr_reserved += gfs2_struct2blk(sdp, revokes,\n\t\t\t\t\t\t   sizeof(u64));\n\tINIT_LIST_HEAD(&tr->tr_databuf);\n\tINIT_LIST_HEAD(&tr->tr_buf);\n\n\tsb_start_intwrite(sdp->sd_vfs);\n\n\terror = gfs2_log_reserve(sdp, tr->tr_reserved);\n\tif (error)\n\t\tgoto fail;\n\n\tcurrent->journal_info = tr;\n\n\treturn 0;\n\nfail:\n\tsb_end_intwrite(sdp->sd_vfs);\n\tkfree(tr);\n\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic int ea_remove_stuffed(struct gfs2_inode *ip, struct gfs2_ea_location *el)\n{\n\tstruct gfs2_ea_header *ea = el->el_ea;\n\tstruct gfs2_ea_header *prev = el->el_prev;\n\tstruct buffer_head *dibh;\n\tint error;\n\n\terror = gfs2_trans_begin(GFS2_SB(&ip->i_inode), RES_DINODE + RES_EATTR, 0);\n\tif (error)\n\t\treturn error;\n\n\tgfs2_trans_add_meta(ip->i_gl, el->el_bh);\n\n\tif (prev) {\n\t\tu32 len;\n\n\t\tlen = GFS2_EA_REC_LEN(prev) + GFS2_EA_REC_LEN(ea);\n\t\tprev->ea_rec_len = cpu_to_be32(len);\n\n\t\tif (GFS2_EA_IS_LAST(ea))\n\t\t\tprev->ea_flags |= GFS2_EAFLAG_LAST;\n\t} else {\n\t\tea->ea_type = GFS2_EATYPE_UNUSED;\n\t}\n\n\terror = gfs2_meta_inode_buffer(ip, &dibh);\n\tif (!error) {\n\t\tip->i_inode.i_ctime = CURRENT_TIME;\n\t\tgfs2_trans_add_meta(ip->i_gl, dibh);\n\t\tgfs2_dinode_out(ip, dibh->b_data);\n\t\tbrelse(dibh);\n\t}\n\n\tgfs2_trans_end(GFS2_SB(&ip->i_inode));\n\n\treturn error;\n}"
  },
  {
    "function_name": "ea_set_remove_unstuffed",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
    "lines": "1074-1084",
    "snippet": "static int ea_set_remove_unstuffed(struct gfs2_inode *ip,\n\t\t\t\t   struct gfs2_ea_location *el)\n{\n\tif (el->el_prev && GFS2_EA2NEXT(el->el_prev) != el->el_ea) {\n\t\tel->el_prev = GFS2_EA2NEXT(el->el_prev);\n\t\tgfs2_assert_withdraw(GFS2_SB(&ip->i_inode),\n\t\t\t\t     GFS2_EA2NEXT(el->el_prev) == el->el_ea);\n\t}\n\n\treturn ea_remove_unstuffed(ip, el->el_bh, el->el_ea, el->el_prev, 0);\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"trans.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"inode.h\"",
      "#include \"glock.h\"",
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/xattr.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ea_remove_unstuffed",
          "args": [
            "ip",
            "el->el_bh",
            "el->el_ea",
            "el->el_prev",
            "0"
          ],
          "line": 1083
        },
        "resolved": true,
        "details": {
          "function_name": "ea_remove_unstuffed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "325-344",
          "snippet": "static int ea_remove_unstuffed(struct gfs2_inode *ip, struct buffer_head *bh,\n\t\t\t       struct gfs2_ea_header *ea,\n\t\t\t       struct gfs2_ea_header *prev, int leave)\n{\n\tint error;\n\n\terror = gfs2_rindex_update(GFS2_SB(&ip->i_inode));\n\tif (error)\n\t\treturn error;\n\n\terror = gfs2_quota_hold(ip, NO_UID_QUOTA_CHANGE, NO_GID_QUOTA_CHANGE);\n\tif (error)\n\t\tgoto out_alloc;\n\n\terror = ea_dealloc_unstuffed(ip, bh, ea, prev, (leave) ? &error : NULL);\n\n\tgfs2_quota_unhold(ip);\nout_alloc:\n\treturn error;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic int ea_remove_unstuffed(struct gfs2_inode *ip, struct buffer_head *bh,\n\t\t\t       struct gfs2_ea_header *ea,\n\t\t\t       struct gfs2_ea_header *prev, int leave)\n{\n\tint error;\n\n\terror = gfs2_rindex_update(GFS2_SB(&ip->i_inode));\n\tif (error)\n\t\treturn error;\n\n\terror = gfs2_quota_hold(ip, NO_UID_QUOTA_CHANGE, NO_GID_QUOTA_CHANGE);\n\tif (error)\n\t\tgoto out_alloc;\n\n\terror = ea_dealloc_unstuffed(ip, bh, ea, prev, (leave) ? &error : NULL);\n\n\tgfs2_quota_unhold(ip);\nout_alloc:\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_assert_withdraw",
          "args": [
            "GFS2_SB(&ip->i_inode)",
            "GFS2_EA2NEXT(el->el_prev) == el->el_ea"
          ],
          "line": 1079
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GFS2_EA2NEXT",
          "args": [
            "el->el_prev"
          ],
          "line": 1080
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GFS2_SB",
          "args": [
            "&ip->i_inode"
          ],
          "line": 1079
        },
        "resolved": true,
        "details": {
          "function_name": "GFS2_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/incore.h",
          "lines": "413-416",
          "snippet": "static inline struct gfs2_sbd *GFS2_SB(const struct inode *inode)\n{\n\treturn inode->i_sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/lockref.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ktime.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/completion.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dlm.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockref.h>\n#include <linux/percpu.h>\n#include <linux/ktime.h>\n#include <linux/rbtree.h>\n#include <linux/completion.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/buffer_head.h>\n#include <linux/dlm.h>\n#include <linux/workqueue.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n\nstatic inline struct gfs2_sbd *GFS2_SB(const struct inode *inode)\n{\n\treturn inode->i_sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GFS2_EA2NEXT",
          "args": [
            "el->el_prev"
          ],
          "line": 1078
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GFS2_EA2NEXT",
          "args": [
            "el->el_prev"
          ],
          "line": 1077
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic int ea_set_remove_unstuffed(struct gfs2_inode *ip,\n\t\t\t\t   struct gfs2_ea_location *el)\n{\n\tif (el->el_prev && GFS2_EA2NEXT(el->el_prev) != el->el_ea) {\n\t\tel->el_prev = GFS2_EA2NEXT(el->el_prev);\n\t\tgfs2_assert_withdraw(GFS2_SB(&ip->i_inode),\n\t\t\t\t     GFS2_EA2NEXT(el->el_prev) == el->el_ea);\n\t}\n\n\treturn ea_remove_unstuffed(ip, el->el_bh, el->el_ea, el->el_prev, 0);\n}"
  },
  {
    "function_name": "ea_set_i",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
    "lines": "1042-1072",
    "snippet": "static int ea_set_i(struct gfs2_inode *ip, int type, const char *name,\n\t\t    const void *value, size_t size, struct gfs2_ea_location *el)\n{\n\tstruct gfs2_ea_request er;\n\tstruct ea_set es;\n\tunsigned int blks = 2;\n\tint error;\n\n\ter.er_type = type;\n\ter.er_name = name;\n\ter.er_data = (void *)value;\n\ter.er_name_len = strlen(name);\n\ter.er_data_len = size;\n\n\tmemset(&es, 0, sizeof(struct ea_set));\n\tes.es_er = &er;\n\tes.es_el = el;\n\n\terror = ea_foreach(ip, ea_set_simple, &es);\n\tif (error > 0)\n\t\treturn 0;\n\tif (error)\n\t\treturn error;\n\n\tif (!(ip->i_diskflags & GFS2_DIF_EA_INDIRECT))\n\t\tblks++;\n\tif (GFS2_EAREQ_SIZE_STUFFED(&er) > GFS2_SB(&ip->i_inode)->sd_jbsize)\n\t\tblks += DIV_ROUND_UP(er.er_data_len, GFS2_SB(&ip->i_inode)->sd_jbsize);\n\n\treturn ea_alloc_skeleton(ip, &er, blks, ea_set_block, el);\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"trans.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"inode.h\"",
      "#include \"glock.h\"",
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/xattr.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ea_alloc_skeleton",
          "args": [
            "ip",
            "&er",
            "blks",
            "ea_set_block",
            "el"
          ],
          "line": 1071
        },
        "resolved": true,
        "details": {
          "function_name": "ea_alloc_skeleton",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "723-768",
          "snippet": "static int ea_alloc_skeleton(struct gfs2_inode *ip, struct gfs2_ea_request *er,\n\t\t\t     unsigned int blks,\n\t\t\t     ea_skeleton_call_t skeleton_call, void *private)\n{\n\tstruct gfs2_alloc_parms ap = { .target = blks };\n\tstruct buffer_head *dibh;\n\tint error;\n\n\terror = gfs2_rindex_update(GFS2_SB(&ip->i_inode));\n\tif (error)\n\t\treturn error;\n\n\terror = gfs2_quota_lock_check(ip);\n\tif (error)\n\t\treturn error;\n\n\terror = gfs2_inplace_reserve(ip, &ap);\n\tif (error)\n\t\tgoto out_gunlock_q;\n\n\terror = gfs2_trans_begin(GFS2_SB(&ip->i_inode),\n\t\t\t\t blks + gfs2_rg_blocks(ip, blks) +\n\t\t\t\t RES_DINODE + RES_STATFS + RES_QUOTA, 0);\n\tif (error)\n\t\tgoto out_ipres;\n\n\terror = skeleton_call(ip, er, private);\n\tif (error)\n\t\tgoto out_end_trans;\n\n\terror = gfs2_meta_inode_buffer(ip, &dibh);\n\tif (!error) {\n\t\tip->i_inode.i_ctime = CURRENT_TIME;\n\t\tgfs2_trans_add_meta(ip->i_gl, dibh);\n\t\tgfs2_dinode_out(ip, dibh->b_data);\n\t\tbrelse(dibh);\n\t}\n\nout_end_trans:\n\tgfs2_trans_end(GFS2_SB(&ip->i_inode));\nout_ipres:\n\tgfs2_inplace_release(ip);\nout_gunlock_q:\n\tgfs2_quota_unlock(ip);\n\treturn error;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic int ea_alloc_skeleton(struct gfs2_inode *ip, struct gfs2_ea_request *er,\n\t\t\t     unsigned int blks,\n\t\t\t     ea_skeleton_call_t skeleton_call, void *private)\n{\n\tstruct gfs2_alloc_parms ap = { .target = blks };\n\tstruct buffer_head *dibh;\n\tint error;\n\n\terror = gfs2_rindex_update(GFS2_SB(&ip->i_inode));\n\tif (error)\n\t\treturn error;\n\n\terror = gfs2_quota_lock_check(ip);\n\tif (error)\n\t\treturn error;\n\n\terror = gfs2_inplace_reserve(ip, &ap);\n\tif (error)\n\t\tgoto out_gunlock_q;\n\n\terror = gfs2_trans_begin(GFS2_SB(&ip->i_inode),\n\t\t\t\t blks + gfs2_rg_blocks(ip, blks) +\n\t\t\t\t RES_DINODE + RES_STATFS + RES_QUOTA, 0);\n\tif (error)\n\t\tgoto out_ipres;\n\n\terror = skeleton_call(ip, er, private);\n\tif (error)\n\t\tgoto out_end_trans;\n\n\terror = gfs2_meta_inode_buffer(ip, &dibh);\n\tif (!error) {\n\t\tip->i_inode.i_ctime = CURRENT_TIME;\n\t\tgfs2_trans_add_meta(ip->i_gl, dibh);\n\t\tgfs2_dinode_out(ip, dibh->b_data);\n\t\tbrelse(dibh);\n\t}\n\nout_end_trans:\n\tgfs2_trans_end(GFS2_SB(&ip->i_inode));\nout_ipres:\n\tgfs2_inplace_release(ip);\nout_gunlock_q:\n\tgfs2_quota_unlock(ip);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DIV_ROUND_UP",
          "args": [
            "er.er_data_len",
            "GFS2_SB(&ip->i_inode)->sd_jbsize"
          ],
          "line": 1069
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GFS2_SB",
          "args": [
            "&ip->i_inode"
          ],
          "line": 1069
        },
        "resolved": true,
        "details": {
          "function_name": "GFS2_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/incore.h",
          "lines": "413-416",
          "snippet": "static inline struct gfs2_sbd *GFS2_SB(const struct inode *inode)\n{\n\treturn inode->i_sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/lockref.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ktime.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/completion.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dlm.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockref.h>\n#include <linux/percpu.h>\n#include <linux/ktime.h>\n#include <linux/rbtree.h>\n#include <linux/completion.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/buffer_head.h>\n#include <linux/dlm.h>\n#include <linux/workqueue.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n\nstatic inline struct gfs2_sbd *GFS2_SB(const struct inode *inode)\n{\n\treturn inode->i_sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GFS2_EAREQ_SIZE_STUFFED",
          "args": [
            "&er"
          ],
          "line": 1068
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ea_foreach",
          "args": [
            "ip",
            "ea_set_simple",
            "&es"
          ],
          "line": 1060
        },
        "resolved": true,
        "details": {
          "function_name": "ea_foreach",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "116-157",
          "snippet": "static int ea_foreach(struct gfs2_inode *ip, ea_call_t ea_call, void *data)\n{\n\tstruct buffer_head *bh, *eabh;\n\t__be64 *eablk, *end;\n\tint error;\n\n\terror = gfs2_meta_read(ip->i_gl, ip->i_eattr, DIO_WAIT, &bh);\n\tif (error)\n\t\treturn error;\n\n\tif (!(ip->i_diskflags & GFS2_DIF_EA_INDIRECT)) {\n\t\terror = ea_foreach_i(ip, bh, ea_call, data);\n\t\tgoto out;\n\t}\n\n\tif (gfs2_metatype_check(GFS2_SB(&ip->i_inode), bh, GFS2_METATYPE_IN)) {\n\t\terror = -EIO;\n\t\tgoto out;\n\t}\n\n\teablk = (__be64 *)(bh->b_data + sizeof(struct gfs2_meta_header));\n\tend = eablk + GFS2_SB(&ip->i_inode)->sd_inptrs;\n\n\tfor (; eablk < end; eablk++) {\n\t\tu64 bn;\n\n\t\tif (!*eablk)\n\t\t\tbreak;\n\t\tbn = be64_to_cpu(*eablk);\n\n\t\terror = gfs2_meta_read(ip->i_gl, bn, DIO_WAIT, &eabh);\n\t\tif (error)\n\t\t\tbreak;\n\t\terror = ea_foreach_i(ip, eabh, ea_call, data);\n\t\tbrelse(eabh);\n\t\tif (error)\n\t\t\tbreak;\n\t}\nout:\n\tbrelse(bh);\n\treturn error;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic int ea_foreach(struct gfs2_inode *ip, ea_call_t ea_call, void *data)\n{\n\tstruct buffer_head *bh, *eabh;\n\t__be64 *eablk, *end;\n\tint error;\n\n\terror = gfs2_meta_read(ip->i_gl, ip->i_eattr, DIO_WAIT, &bh);\n\tif (error)\n\t\treturn error;\n\n\tif (!(ip->i_diskflags & GFS2_DIF_EA_INDIRECT)) {\n\t\terror = ea_foreach_i(ip, bh, ea_call, data);\n\t\tgoto out;\n\t}\n\n\tif (gfs2_metatype_check(GFS2_SB(&ip->i_inode), bh, GFS2_METATYPE_IN)) {\n\t\terror = -EIO;\n\t\tgoto out;\n\t}\n\n\teablk = (__be64 *)(bh->b_data + sizeof(struct gfs2_meta_header));\n\tend = eablk + GFS2_SB(&ip->i_inode)->sd_inptrs;\n\n\tfor (; eablk < end; eablk++) {\n\t\tu64 bn;\n\n\t\tif (!*eablk)\n\t\t\tbreak;\n\t\tbn = be64_to_cpu(*eablk);\n\n\t\terror = gfs2_meta_read(ip->i_gl, bn, DIO_WAIT, &eabh);\n\t\tif (error)\n\t\t\tbreak;\n\t\terror = ea_foreach_i(ip, eabh, ea_call, data);\n\t\tbrelse(eabh);\n\t\tif (error)\n\t\t\tbreak;\n\t}\nout:\n\tbrelse(bh);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&es",
            "0",
            "sizeof(struct ea_set)"
          ],
          "line": 1056
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "name"
          ],
          "line": 1053
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic int ea_set_i(struct gfs2_inode *ip, int type, const char *name,\n\t\t    const void *value, size_t size, struct gfs2_ea_location *el)\n{\n\tstruct gfs2_ea_request er;\n\tstruct ea_set es;\n\tunsigned int blks = 2;\n\tint error;\n\n\ter.er_type = type;\n\ter.er_name = name;\n\ter.er_data = (void *)value;\n\ter.er_name_len = strlen(name);\n\ter.er_data_len = size;\n\n\tmemset(&es, 0, sizeof(struct ea_set));\n\tes.es_er = &er;\n\tes.es_el = el;\n\n\terror = ea_foreach(ip, ea_set_simple, &es);\n\tif (error > 0)\n\t\treturn 0;\n\tif (error)\n\t\treturn error;\n\n\tif (!(ip->i_diskflags & GFS2_DIF_EA_INDIRECT))\n\t\tblks++;\n\tif (GFS2_EAREQ_SIZE_STUFFED(&er) > GFS2_SB(&ip->i_inode)->sd_jbsize)\n\t\tblks += DIV_ROUND_UP(er.er_data_len, GFS2_SB(&ip->i_inode)->sd_jbsize);\n\n\treturn ea_alloc_skeleton(ip, &er, blks, ea_set_block, el);\n}"
  },
  {
    "function_name": "ea_set_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
    "lines": "968-1040",
    "snippet": "static int ea_set_block(struct gfs2_inode *ip, struct gfs2_ea_request *er,\n\t\t\tvoid *private)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tstruct buffer_head *indbh, *newbh;\n\t__be64 *eablk;\n\tint error;\n\tint mh_size = sizeof(struct gfs2_meta_header);\n\n\tif (ip->i_diskflags & GFS2_DIF_EA_INDIRECT) {\n\t\t__be64 *end;\n\n\t\terror = gfs2_meta_read(ip->i_gl, ip->i_eattr, DIO_WAIT,\n\t\t\t\t       &indbh);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\tif (gfs2_metatype_check(sdp, indbh, GFS2_METATYPE_IN)) {\n\t\t\terror = -EIO;\n\t\t\tgoto out;\n\t\t}\n\n\t\teablk = (__be64 *)(indbh->b_data + mh_size);\n\t\tend = eablk + sdp->sd_inptrs;\n\n\t\tfor (; eablk < end; eablk++)\n\t\t\tif (!*eablk)\n\t\t\t\tbreak;\n\n\t\tif (eablk == end) {\n\t\t\terror = -ENOSPC;\n\t\t\tgoto out;\n\t\t}\n\n\t\tgfs2_trans_add_meta(ip->i_gl, indbh);\n\t} else {\n\t\tu64 blk;\n\t\tunsigned int n = 1;\n\t\terror = gfs2_alloc_blocks(ip, &blk, &n, 0, NULL);\n\t\tif (error)\n\t\t\treturn error;\n\t\tgfs2_trans_add_unrevoke(sdp, blk, 1);\n\t\tindbh = gfs2_meta_new(ip->i_gl, blk);\n\t\tgfs2_trans_add_meta(ip->i_gl, indbh);\n\t\tgfs2_metatype_set(indbh, GFS2_METATYPE_IN, GFS2_FORMAT_IN);\n\t\tgfs2_buffer_clear_tail(indbh, mh_size);\n\n\t\teablk = (__be64 *)(indbh->b_data + mh_size);\n\t\t*eablk = cpu_to_be64(ip->i_eattr);\n\t\tip->i_eattr = blk;\n\t\tip->i_diskflags |= GFS2_DIF_EA_INDIRECT;\n\t\tgfs2_add_inode_blocks(&ip->i_inode, 1);\n\n\t\teablk++;\n\t}\n\n\terror = ea_alloc_blk(ip, &newbh);\n\tif (error)\n\t\tgoto out;\n\n\t*eablk = cpu_to_be64((u64)newbh->b_blocknr);\n\terror = ea_write(ip, GFS2_EA_BH2FIRST(newbh), er);\n\tbrelse(newbh);\n\tif (error)\n\t\tgoto out;\n\n\tif (private)\n\t\tea_set_remove_stuffed(ip, private);\n\nout:\n\tbrelse(indbh);\n\treturn error;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"trans.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"inode.h\"",
      "#include \"glock.h\"",
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/xattr.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "indbh"
          ],
          "line": 1038
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "ea_set_remove_stuffed",
          "args": [
            "ip",
            "private"
          ],
          "line": 1035
        },
        "resolved": true,
        "details": {
          "function_name": "ea_set_remove_stuffed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "832-854",
          "snippet": "static void ea_set_remove_stuffed(struct gfs2_inode *ip,\n\t\t\t\t  struct gfs2_ea_location *el)\n{\n\tstruct gfs2_ea_header *ea = el->el_ea;\n\tstruct gfs2_ea_header *prev = el->el_prev;\n\tu32 len;\n\n\tgfs2_trans_add_meta(ip->i_gl, el->el_bh);\n\n\tif (!prev || !GFS2_EA_IS_STUFFED(ea)) {\n\t\tea->ea_type = GFS2_EATYPE_UNUSED;\n\t\treturn;\n\t} else if (GFS2_EA2NEXT(prev) != ea) {\n\t\tprev = GFS2_EA2NEXT(prev);\n\t\tgfs2_assert_withdraw(GFS2_SB(&ip->i_inode), GFS2_EA2NEXT(prev) == ea);\n\t}\n\n\tlen = GFS2_EA_REC_LEN(prev) + GFS2_EA_REC_LEN(ea);\n\tprev->ea_rec_len = cpu_to_be32(len);\n\n\tif (GFS2_EA_IS_LAST(ea))\n\t\tprev->ea_flags |= GFS2_EAFLAG_LAST;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic void ea_set_remove_stuffed(struct gfs2_inode *ip,\n\t\t\t\t  struct gfs2_ea_location *el)\n{\n\tstruct gfs2_ea_header *ea = el->el_ea;\n\tstruct gfs2_ea_header *prev = el->el_prev;\n\tu32 len;\n\n\tgfs2_trans_add_meta(ip->i_gl, el->el_bh);\n\n\tif (!prev || !GFS2_EA_IS_STUFFED(ea)) {\n\t\tea->ea_type = GFS2_EATYPE_UNUSED;\n\t\treturn;\n\t} else if (GFS2_EA2NEXT(prev) != ea) {\n\t\tprev = GFS2_EA2NEXT(prev);\n\t\tgfs2_assert_withdraw(GFS2_SB(&ip->i_inode), GFS2_EA2NEXT(prev) == ea);\n\t}\n\n\tlen = GFS2_EA_REC_LEN(prev) + GFS2_EA_REC_LEN(ea);\n\tprev->ea_rec_len = cpu_to_be32(len);\n\n\tif (GFS2_EA_IS_LAST(ea))\n\t\tprev->ea_flags |= GFS2_EAFLAG_LAST;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ea_write",
          "args": [
            "ip",
            "GFS2_EA_BH2FIRST(newbh)",
            "er"
          ],
          "line": 1029
        },
        "resolved": true,
        "details": {
          "function_name": "ea_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "660-718",
          "snippet": "static int ea_write(struct gfs2_inode *ip, struct gfs2_ea_header *ea,\n\t\t    struct gfs2_ea_request *er)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tint error;\n\n\tea->ea_data_len = cpu_to_be32(er->er_data_len);\n\tea->ea_name_len = er->er_name_len;\n\tea->ea_type = er->er_type;\n\tea->__pad = 0;\n\n\tmemcpy(GFS2_EA2NAME(ea), er->er_name, er->er_name_len);\n\n\tif (GFS2_EAREQ_SIZE_STUFFED(er) <= sdp->sd_jbsize) {\n\t\tea->ea_num_ptrs = 0;\n\t\tmemcpy(GFS2_EA2DATA(ea), er->er_data, er->er_data_len);\n\t} else {\n\t\t__be64 *dataptr = GFS2_EA2DATAPTRS(ea);\n\t\tconst char *data = er->er_data;\n\t\tunsigned int data_len = er->er_data_len;\n\t\tunsigned int copy;\n\t\tunsigned int x;\n\n\t\tea->ea_num_ptrs = DIV_ROUND_UP(er->er_data_len, sdp->sd_jbsize);\n\t\tfor (x = 0; x < ea->ea_num_ptrs; x++) {\n\t\t\tstruct buffer_head *bh;\n\t\t\tu64 block;\n\t\t\tint mh_size = sizeof(struct gfs2_meta_header);\n\t\t\tunsigned int n = 1;\n\n\t\t\terror = gfs2_alloc_blocks(ip, &block, &n, 0, NULL);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\tgfs2_trans_add_unrevoke(sdp, block, 1);\n\t\t\tbh = gfs2_meta_new(ip->i_gl, block);\n\t\t\tgfs2_trans_add_meta(ip->i_gl, bh);\n\t\t\tgfs2_metatype_set(bh, GFS2_METATYPE_ED, GFS2_FORMAT_ED);\n\n\t\t\tgfs2_add_inode_blocks(&ip->i_inode, 1);\n\n\t\t\tcopy = data_len > sdp->sd_jbsize ? sdp->sd_jbsize :\n\t\t\t\t\t\t\t   data_len;\n\t\t\tmemcpy(bh->b_data + mh_size, data, copy);\n\t\t\tif (copy < sdp->sd_jbsize)\n\t\t\t\tmemset(bh->b_data + mh_size + copy, 0,\n\t\t\t\t       sdp->sd_jbsize - copy);\n\n\t\t\t*dataptr++ = cpu_to_be64(bh->b_blocknr);\n\t\t\tdata += copy;\n\t\t\tdata_len -= copy;\n\n\t\t\tbrelse(bh);\n\t\t}\n\n\t\tgfs2_assert_withdraw(sdp, !data_len);\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic int ea_write(struct gfs2_inode *ip, struct gfs2_ea_header *ea,\n\t\t    struct gfs2_ea_request *er)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tint error;\n\n\tea->ea_data_len = cpu_to_be32(er->er_data_len);\n\tea->ea_name_len = er->er_name_len;\n\tea->ea_type = er->er_type;\n\tea->__pad = 0;\n\n\tmemcpy(GFS2_EA2NAME(ea), er->er_name, er->er_name_len);\n\n\tif (GFS2_EAREQ_SIZE_STUFFED(er) <= sdp->sd_jbsize) {\n\t\tea->ea_num_ptrs = 0;\n\t\tmemcpy(GFS2_EA2DATA(ea), er->er_data, er->er_data_len);\n\t} else {\n\t\t__be64 *dataptr = GFS2_EA2DATAPTRS(ea);\n\t\tconst char *data = er->er_data;\n\t\tunsigned int data_len = er->er_data_len;\n\t\tunsigned int copy;\n\t\tunsigned int x;\n\n\t\tea->ea_num_ptrs = DIV_ROUND_UP(er->er_data_len, sdp->sd_jbsize);\n\t\tfor (x = 0; x < ea->ea_num_ptrs; x++) {\n\t\t\tstruct buffer_head *bh;\n\t\t\tu64 block;\n\t\t\tint mh_size = sizeof(struct gfs2_meta_header);\n\t\t\tunsigned int n = 1;\n\n\t\t\terror = gfs2_alloc_blocks(ip, &block, &n, 0, NULL);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\tgfs2_trans_add_unrevoke(sdp, block, 1);\n\t\t\tbh = gfs2_meta_new(ip->i_gl, block);\n\t\t\tgfs2_trans_add_meta(ip->i_gl, bh);\n\t\t\tgfs2_metatype_set(bh, GFS2_METATYPE_ED, GFS2_FORMAT_ED);\n\n\t\t\tgfs2_add_inode_blocks(&ip->i_inode, 1);\n\n\t\t\tcopy = data_len > sdp->sd_jbsize ? sdp->sd_jbsize :\n\t\t\t\t\t\t\t   data_len;\n\t\t\tmemcpy(bh->b_data + mh_size, data, copy);\n\t\t\tif (copy < sdp->sd_jbsize)\n\t\t\t\tmemset(bh->b_data + mh_size + copy, 0,\n\t\t\t\t       sdp->sd_jbsize - copy);\n\n\t\t\t*dataptr++ = cpu_to_be64(bh->b_blocknr);\n\t\t\tdata += copy;\n\t\t\tdata_len -= copy;\n\n\t\t\tbrelse(bh);\n\t\t}\n\n\t\tgfs2_assert_withdraw(sdp, !data_len);\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GFS2_EA_BH2FIRST",
          "args": [
            "newbh"
          ],
          "line": 1029
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "(u64)newbh->b_blocknr"
          ],
          "line": 1028
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ea_alloc_blk",
          "args": [
            "ip",
            "&newbh"
          ],
          "line": 1024
        },
        "resolved": true,
        "details": {
          "function_name": "ea_alloc_blk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "620-646",
          "snippet": "static int ea_alloc_blk(struct gfs2_inode *ip, struct buffer_head **bhp)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tstruct gfs2_ea_header *ea;\n\tunsigned int n = 1;\n\tu64 block;\n\tint error;\n\n\terror = gfs2_alloc_blocks(ip, &block, &n, 0, NULL);\n\tif (error)\n\t\treturn error;\n\tgfs2_trans_add_unrevoke(sdp, block, 1);\n\t*bhp = gfs2_meta_new(ip->i_gl, block);\n\tgfs2_trans_add_meta(ip->i_gl, *bhp);\n\tgfs2_metatype_set(*bhp, GFS2_METATYPE_EA, GFS2_FORMAT_EA);\n\tgfs2_buffer_clear_tail(*bhp, sizeof(struct gfs2_meta_header));\n\n\tea = GFS2_EA_BH2FIRST(*bhp);\n\tea->ea_rec_len = cpu_to_be32(sdp->sd_jbsize);\n\tea->ea_type = GFS2_EATYPE_UNUSED;\n\tea->ea_flags = GFS2_EAFLAG_LAST;\n\tea->ea_num_ptrs = 0;\n\n\tgfs2_add_inode_blocks(&ip->i_inode, 1);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic int ea_alloc_blk(struct gfs2_inode *ip, struct buffer_head **bhp)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tstruct gfs2_ea_header *ea;\n\tunsigned int n = 1;\n\tu64 block;\n\tint error;\n\n\terror = gfs2_alloc_blocks(ip, &block, &n, 0, NULL);\n\tif (error)\n\t\treturn error;\n\tgfs2_trans_add_unrevoke(sdp, block, 1);\n\t*bhp = gfs2_meta_new(ip->i_gl, block);\n\tgfs2_trans_add_meta(ip->i_gl, *bhp);\n\tgfs2_metatype_set(*bhp, GFS2_METATYPE_EA, GFS2_FORMAT_EA);\n\tgfs2_buffer_clear_tail(*bhp, sizeof(struct gfs2_meta_header));\n\n\tea = GFS2_EA_BH2FIRST(*bhp);\n\tea->ea_rec_len = cpu_to_be32(sdp->sd_jbsize);\n\tea->ea_type = GFS2_EATYPE_UNUSED;\n\tea->ea_flags = GFS2_EAFLAG_LAST;\n\tea->ea_num_ptrs = 0;\n\n\tgfs2_add_inode_blocks(&ip->i_inode, 1);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_add_inode_blocks",
          "args": [
            "&ip->i_inode",
            "1"
          ],
          "line": 1019
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_add_inode_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/inode.h",
          "lines": "62-67",
          "snippet": "static inline void gfs2_add_inode_blocks(struct inode *inode, s64 change)\n{\n\tgfs2_assert(GFS2_SB(inode), (change >= 0 || inode->i_blocks > -change));\n\tchange *= (GFS2_SB(inode)->sd_sb.sb_bsize/GFS2_BASIC_BLOCK);\n\tinode->i_blocks += change;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include <linux/mm.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <linux/mm.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic inline void gfs2_add_inode_blocks(struct inode *inode, s64 change)\n{\n\tgfs2_assert(GFS2_SB(inode), (change >= 0 || inode->i_blocks > -change));\n\tchange *= (GFS2_SB(inode)->sd_sb.sb_bsize/GFS2_BASIC_BLOCK);\n\tinode->i_blocks += change;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "ip->i_eattr"
          ],
          "line": 1016
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_buffer_clear_tail",
          "args": [
            "indbh",
            "mh_size"
          ],
          "line": 1013
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_buffer_clear_tail",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/meta_io.h",
          "lines": "22-26",
          "snippet": "static inline void gfs2_buffer_clear_tail(struct buffer_head *bh, int head)\n{\n\tBUG_ON(head > bh->b_size);\n\tmemset(bh->b_data + head, 0, bh->b_size - head);\n}",
          "includes": [
            "#include \"incore.h\"",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"incore.h\"\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline void gfs2_buffer_clear_tail(struct buffer_head *bh, int head)\n{\n\tBUG_ON(head > bh->b_size);\n\tmemset(bh->b_data + head, 0, bh->b_size - head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_metatype_set",
          "args": [
            "indbh",
            "GFS2_METATYPE_IN",
            "GFS2_FORMAT_IN"
          ],
          "line": 1012
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_metatype_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/util.h",
          "lines": "122-129",
          "snippet": "static inline void gfs2_metatype_set(struct buffer_head *bh, u16 type,\n\t\t\t\t     u16 format)\n{\n\tstruct gfs2_meta_header *mh;\n\tmh = (struct gfs2_meta_header *)bh->b_data;\n\tmh->mh_type = cpu_to_be32(type);\n\tmh->mh_format = cpu_to_be32(format);\n}",
          "includes": [
            "#include \"incore.h\"",
            "#include <linux/mempool.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"incore.h\"\n#include <linux/mempool.h>\n\nstatic inline void gfs2_metatype_set(struct buffer_head *bh, u16 type,\n\t\t\t\t     u16 format)\n{\n\tstruct gfs2_meta_header *mh;\n\tmh = (struct gfs2_meta_header *)bh->b_data;\n\tmh->mh_type = cpu_to_be32(type);\n\tmh->mh_format = cpu_to_be32(format);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_trans_add_meta",
          "args": [
            "ip->i_gl",
            "indbh"
          ],
          "line": 1011
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_trans_add_meta",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/trans.c",
          "lines": "224-247",
          "snippet": "void gfs2_trans_add_meta(struct gfs2_glock *gl, struct buffer_head *bh)\n{\n\n\tstruct gfs2_sbd *sdp = gl->gl_sbd;\n\tstruct gfs2_bufdata *bd;\n\n\tlock_buffer(bh);\n\tgfs2_log_lock(sdp);\n\tbd = bh->b_private;\n\tif (bd == NULL) {\n\t\tgfs2_log_unlock(sdp);\n\t\tunlock_buffer(bh);\n\t\tlock_page(bh->b_page);\n\t\tif (bh->b_private == NULL)\n\t\t\tbd = gfs2_alloc_bufdata(gl, bh, &gfs2_buf_lops);\n\t\tunlock_page(bh->b_page);\n\t\tlock_buffer(bh);\n\t\tgfs2_log_lock(sdp);\n\t}\n\tgfs2_assert(sdp, bd->bd_gl == gl);\n\tmeta_lo_add(sdp, bd);\n\tgfs2_log_unlock(sdp);\n\tunlock_buffer(bh);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_trans_add_meta(struct gfs2_glock *gl, struct buffer_head *bh)\n{\n\n\tstruct gfs2_sbd *sdp = gl->gl_sbd;\n\tstruct gfs2_bufdata *bd;\n\n\tlock_buffer(bh);\n\tgfs2_log_lock(sdp);\n\tbd = bh->b_private;\n\tif (bd == NULL) {\n\t\tgfs2_log_unlock(sdp);\n\t\tunlock_buffer(bh);\n\t\tlock_page(bh->b_page);\n\t\tif (bh->b_private == NULL)\n\t\t\tbd = gfs2_alloc_bufdata(gl, bh, &gfs2_buf_lops);\n\t\tunlock_page(bh->b_page);\n\t\tlock_buffer(bh);\n\t\tgfs2_log_lock(sdp);\n\t}\n\tgfs2_assert(sdp, bd->bd_gl == gl);\n\tmeta_lo_add(sdp, bd);\n\tgfs2_log_unlock(sdp);\n\tunlock_buffer(bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_meta_new",
          "args": [
            "ip->i_gl",
            "blk"
          ],
          "line": 1010
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_meta_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/meta_io.c",
          "lines": "182-188",
          "snippet": "struct buffer_head *gfs2_meta_new(struct gfs2_glock *gl, u64 blkno)\n{\n\tstruct buffer_head *bh;\n\tbh = gfs2_getbuf(gl, blkno, CREATE);\n\tmeta_prep_new(bh);\n\treturn bh;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/delay.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/delay.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstruct buffer_head *gfs2_meta_new(struct gfs2_glock *gl, u64 blkno)\n{\n\tstruct buffer_head *bh;\n\tbh = gfs2_getbuf(gl, blkno, CREATE);\n\tmeta_prep_new(bh);\n\treturn bh;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_trans_add_unrevoke",
          "args": [
            "sdp",
            "blk",
            "1"
          ],
          "line": 1009
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_trans_add_unrevoke",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/trans.c",
          "lines": "259-278",
          "snippet": "void gfs2_trans_add_unrevoke(struct gfs2_sbd *sdp, u64 blkno, unsigned int len)\n{\n\tstruct gfs2_bufdata *bd, *tmp;\n\tstruct gfs2_trans *tr = current->journal_info;\n\tunsigned int n = len;\n\n\tgfs2_log_lock(sdp);\n\tlist_for_each_entry_safe(bd, tmp, &sdp->sd_log_le_revoke, bd_list) {\n\t\tif ((bd->bd_blkno >= blkno) && (bd->bd_blkno < (blkno + len))) {\n\t\t\tlist_del_init(&bd->bd_list);\n\t\t\tgfs2_assert_withdraw(sdp, sdp->sd_log_num_revoke);\n\t\t\tsdp->sd_log_num_revoke--;\n\t\t\tkmem_cache_free(gfs2_bufdata_cachep, bd);\n\t\t\ttr->tr_num_revoke_rm++;\n\t\t\tif (--n == 0)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tgfs2_log_unlock(sdp);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_trans_add_unrevoke(struct gfs2_sbd *sdp, u64 blkno, unsigned int len)\n{\n\tstruct gfs2_bufdata *bd, *tmp;\n\tstruct gfs2_trans *tr = current->journal_info;\n\tunsigned int n = len;\n\n\tgfs2_log_lock(sdp);\n\tlist_for_each_entry_safe(bd, tmp, &sdp->sd_log_le_revoke, bd_list) {\n\t\tif ((bd->bd_blkno >= blkno) && (bd->bd_blkno < (blkno + len))) {\n\t\t\tlist_del_init(&bd->bd_list);\n\t\t\tgfs2_assert_withdraw(sdp, sdp->sd_log_num_revoke);\n\t\t\tsdp->sd_log_num_revoke--;\n\t\t\tkmem_cache_free(gfs2_bufdata_cachep, bd);\n\t\t\ttr->tr_num_revoke_rm++;\n\t\t\tif (--n == 0)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tgfs2_log_unlock(sdp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_alloc_blocks",
          "args": [
            "ip",
            "&blk",
            "&n",
            "0",
            "NULL"
          ],
          "line": 1006
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_alloc_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
          "lines": "2304-2385",
          "snippet": "int gfs2_alloc_blocks(struct gfs2_inode *ip, u64 *bn, unsigned int *nblocks,\n\t\t      bool dinode, u64 *generation)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tstruct buffer_head *dibh;\n\tstruct gfs2_rbm rbm = { .rgd = ip->i_rgd, };\n\tunsigned int ndata;\n\tu64 block; /* block, within the file system scope */\n\tint error;\n\n\tgfs2_set_alloc_start(&rbm, ip, dinode);\n\terror = gfs2_rbm_find(&rbm, GFS2_BLKST_FREE, NULL, ip, false, NULL);\n\n\tif (error == -ENOSPC) {\n\t\tgfs2_set_alloc_start(&rbm, ip, dinode);\n\t\terror = gfs2_rbm_find(&rbm, GFS2_BLKST_FREE, NULL, NULL, false,\n\t\t\t\t      NULL);\n\t}\n\n\t/* Since all blocks are reserved in advance, this shouldn't happen */\n\tif (error) {\n\t\tfs_warn(sdp, \"inum=%llu error=%d, nblocks=%u, full=%d fail_pt=%d\\n\",\n\t\t\t(unsigned long long)ip->i_no_addr, error, *nblocks,\n\t\t\ttest_bit(GBF_FULL, &rbm.rgd->rd_bits->bi_flags),\n\t\t\trbm.rgd->rd_extfail_pt);\n\t\tgoto rgrp_error;\n\t}\n\n\tgfs2_alloc_extent(&rbm, dinode, nblocks);\n\tblock = gfs2_rbm_to_block(&rbm);\n\trbm.rgd->rd_last_alloc = block - rbm.rgd->rd_data0;\n\tif (gfs2_rs_active(ip->i_res))\n\t\tgfs2_adjust_reservation(ip, &rbm, *nblocks);\n\tndata = *nblocks;\n\tif (dinode)\n\t\tndata--;\n\n\tif (!dinode) {\n\t\tip->i_goal = block + ndata - 1;\n\t\terror = gfs2_meta_inode_buffer(ip, &dibh);\n\t\tif (error == 0) {\n\t\t\tstruct gfs2_dinode *di =\n\t\t\t\t(struct gfs2_dinode *)dibh->b_data;\n\t\t\tgfs2_trans_add_meta(ip->i_gl, dibh);\n\t\t\tdi->di_goal_meta = di->di_goal_data =\n\t\t\t\tcpu_to_be64(ip->i_goal);\n\t\t\tbrelse(dibh);\n\t\t}\n\t}\n\tif (rbm.rgd->rd_free < *nblocks) {\n\t\tpr_warn(\"nblocks=%u\\n\", *nblocks);\n\t\tgoto rgrp_error;\n\t}\n\n\trbm.rgd->rd_free -= *nblocks;\n\tif (dinode) {\n\t\trbm.rgd->rd_dinodes++;\n\t\t*generation = rbm.rgd->rd_igeneration++;\n\t\tif (*generation == 0)\n\t\t\t*generation = rbm.rgd->rd_igeneration++;\n\t}\n\n\tgfs2_trans_add_meta(rbm.rgd->rd_gl, rbm.rgd->rd_bits[0].bi_bh);\n\tgfs2_rgrp_out(rbm.rgd, rbm.rgd->rd_bits[0].bi_bh->b_data);\n\tgfs2_rgrp_ondisk2lvb(rbm.rgd->rd_rgl, rbm.rgd->rd_bits[0].bi_bh->b_data);\n\n\tgfs2_statfs_change(sdp, 0, -(s64)*nblocks, dinode ? 1 : 0);\n\tif (dinode)\n\t\tgfs2_trans_add_unrevoke(sdp, block, *nblocks);\n\n\tgfs2_quota_change(ip, *nblocks, ip->i_inode.i_uid, ip->i_inode.i_gid);\n\n\trbm.rgd->rd_free_clone -= *nblocks;\n\ttrace_gfs2_block_alloc(ip, rbm.rgd, block, *nblocks,\n\t\t\t       dinode ? GFS2_BLKST_DINODE : GFS2_BLKST_USED);\n\t*bn = block;\n\treturn 0;\n\nrgrp_error:\n\tgfs2_rgrp_error(rbm.rgd);\n\treturn -EIO;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"inode.h\"",
            "#include \"log.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/random.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nint gfs2_alloc_blocks(struct gfs2_inode *ip, u64 *bn, unsigned int *nblocks,\n\t\t      bool dinode, u64 *generation)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tstruct buffer_head *dibh;\n\tstruct gfs2_rbm rbm = { .rgd = ip->i_rgd, };\n\tunsigned int ndata;\n\tu64 block; /* block, within the file system scope */\n\tint error;\n\n\tgfs2_set_alloc_start(&rbm, ip, dinode);\n\terror = gfs2_rbm_find(&rbm, GFS2_BLKST_FREE, NULL, ip, false, NULL);\n\n\tif (error == -ENOSPC) {\n\t\tgfs2_set_alloc_start(&rbm, ip, dinode);\n\t\terror = gfs2_rbm_find(&rbm, GFS2_BLKST_FREE, NULL, NULL, false,\n\t\t\t\t      NULL);\n\t}\n\n\t/* Since all blocks are reserved in advance, this shouldn't happen */\n\tif (error) {\n\t\tfs_warn(sdp, \"inum=%llu error=%d, nblocks=%u, full=%d fail_pt=%d\\n\",\n\t\t\t(unsigned long long)ip->i_no_addr, error, *nblocks,\n\t\t\ttest_bit(GBF_FULL, &rbm.rgd->rd_bits->bi_flags),\n\t\t\trbm.rgd->rd_extfail_pt);\n\t\tgoto rgrp_error;\n\t}\n\n\tgfs2_alloc_extent(&rbm, dinode, nblocks);\n\tblock = gfs2_rbm_to_block(&rbm);\n\trbm.rgd->rd_last_alloc = block - rbm.rgd->rd_data0;\n\tif (gfs2_rs_active(ip->i_res))\n\t\tgfs2_adjust_reservation(ip, &rbm, *nblocks);\n\tndata = *nblocks;\n\tif (dinode)\n\t\tndata--;\n\n\tif (!dinode) {\n\t\tip->i_goal = block + ndata - 1;\n\t\terror = gfs2_meta_inode_buffer(ip, &dibh);\n\t\tif (error == 0) {\n\t\t\tstruct gfs2_dinode *di =\n\t\t\t\t(struct gfs2_dinode *)dibh->b_data;\n\t\t\tgfs2_trans_add_meta(ip->i_gl, dibh);\n\t\t\tdi->di_goal_meta = di->di_goal_data =\n\t\t\t\tcpu_to_be64(ip->i_goal);\n\t\t\tbrelse(dibh);\n\t\t}\n\t}\n\tif (rbm.rgd->rd_free < *nblocks) {\n\t\tpr_warn(\"nblocks=%u\\n\", *nblocks);\n\t\tgoto rgrp_error;\n\t}\n\n\trbm.rgd->rd_free -= *nblocks;\n\tif (dinode) {\n\t\trbm.rgd->rd_dinodes++;\n\t\t*generation = rbm.rgd->rd_igeneration++;\n\t\tif (*generation == 0)\n\t\t\t*generation = rbm.rgd->rd_igeneration++;\n\t}\n\n\tgfs2_trans_add_meta(rbm.rgd->rd_gl, rbm.rgd->rd_bits[0].bi_bh);\n\tgfs2_rgrp_out(rbm.rgd, rbm.rgd->rd_bits[0].bi_bh->b_data);\n\tgfs2_rgrp_ondisk2lvb(rbm.rgd->rd_rgl, rbm.rgd->rd_bits[0].bi_bh->b_data);\n\n\tgfs2_statfs_change(sdp, 0, -(s64)*nblocks, dinode ? 1 : 0);\n\tif (dinode)\n\t\tgfs2_trans_add_unrevoke(sdp, block, *nblocks);\n\n\tgfs2_quota_change(ip, *nblocks, ip->i_inode.i_uid, ip->i_inode.i_gid);\n\n\trbm.rgd->rd_free_clone -= *nblocks;\n\ttrace_gfs2_block_alloc(ip, rbm.rgd, block, *nblocks,\n\t\t\t       dinode ? GFS2_BLKST_DINODE : GFS2_BLKST_USED);\n\t*bn = block;\n\treturn 0;\n\nrgrp_error:\n\tgfs2_rgrp_error(rbm.rgd);\n\treturn -EIO;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_metatype_check",
          "args": [
            "sdp",
            "indbh",
            "GFS2_METATYPE_IN"
          ],
          "line": 985
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_meta_read",
          "args": [
            "ip->i_gl",
            "ip->i_eattr",
            "DIO_WAIT",
            "&indbh"
          ],
          "line": 980
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_meta_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/meta_io.c",
          "lines": "200-235",
          "snippet": "int gfs2_meta_read(struct gfs2_glock *gl, u64 blkno, int flags,\n\t\t   struct buffer_head **bhp)\n{\n\tstruct gfs2_sbd *sdp = gl->gl_sbd;\n\tstruct buffer_head *bh;\n\n\tif (unlikely(test_bit(SDF_SHUTDOWN, &sdp->sd_flags))) {\n\t\t*bhp = NULL;\n\t\treturn -EIO;\n\t}\n\n\t*bhp = bh = gfs2_getbuf(gl, blkno, CREATE);\n\n\tlock_buffer(bh);\n\tif (buffer_uptodate(bh)) {\n\t\tunlock_buffer(bh);\n\t\treturn 0;\n\t}\n\tbh->b_end_io = end_buffer_read_sync;\n\tget_bh(bh);\n\tsubmit_bh(READ_SYNC | REQ_META | REQ_PRIO, bh);\n\tif (!(flags & DIO_WAIT))\n\t\treturn 0;\n\n\twait_on_buffer(bh);\n\tif (unlikely(!buffer_uptodate(bh))) {\n\t\tstruct gfs2_trans *tr = current->journal_info;\n\t\tif (tr && tr->tr_touched)\n\t\t\tgfs2_io_error_bh(sdp, bh);\n\t\tbrelse(bh);\n\t\t*bhp = NULL;\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/delay.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/delay.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nint gfs2_meta_read(struct gfs2_glock *gl, u64 blkno, int flags,\n\t\t   struct buffer_head **bhp)\n{\n\tstruct gfs2_sbd *sdp = gl->gl_sbd;\n\tstruct buffer_head *bh;\n\n\tif (unlikely(test_bit(SDF_SHUTDOWN, &sdp->sd_flags))) {\n\t\t*bhp = NULL;\n\t\treturn -EIO;\n\t}\n\n\t*bhp = bh = gfs2_getbuf(gl, blkno, CREATE);\n\n\tlock_buffer(bh);\n\tif (buffer_uptodate(bh)) {\n\t\tunlock_buffer(bh);\n\t\treturn 0;\n\t}\n\tbh->b_end_io = end_buffer_read_sync;\n\tget_bh(bh);\n\tsubmit_bh(READ_SYNC | REQ_META | REQ_PRIO, bh);\n\tif (!(flags & DIO_WAIT))\n\t\treturn 0;\n\n\twait_on_buffer(bh);\n\tif (unlikely(!buffer_uptodate(bh))) {\n\t\tstruct gfs2_trans *tr = current->journal_info;\n\t\tif (tr && tr->tr_touched)\n\t\t\tgfs2_io_error_bh(sdp, bh);\n\t\tbrelse(bh);\n\t\t*bhp = NULL;\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GFS2_SB",
          "args": [
            "&ip->i_inode"
          ],
          "line": 971
        },
        "resolved": true,
        "details": {
          "function_name": "GFS2_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/incore.h",
          "lines": "413-416",
          "snippet": "static inline struct gfs2_sbd *GFS2_SB(const struct inode *inode)\n{\n\treturn inode->i_sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/lockref.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ktime.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/completion.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dlm.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockref.h>\n#include <linux/percpu.h>\n#include <linux/ktime.h>\n#include <linux/rbtree.h>\n#include <linux/completion.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/buffer_head.h>\n#include <linux/dlm.h>\n#include <linux/workqueue.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n\nstatic inline struct gfs2_sbd *GFS2_SB(const struct inode *inode)\n{\n\treturn inode->i_sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic int ea_set_block(struct gfs2_inode *ip, struct gfs2_ea_request *er,\n\t\t\tvoid *private)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tstruct buffer_head *indbh, *newbh;\n\t__be64 *eablk;\n\tint error;\n\tint mh_size = sizeof(struct gfs2_meta_header);\n\n\tif (ip->i_diskflags & GFS2_DIF_EA_INDIRECT) {\n\t\t__be64 *end;\n\n\t\terror = gfs2_meta_read(ip->i_gl, ip->i_eattr, DIO_WAIT,\n\t\t\t\t       &indbh);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\tif (gfs2_metatype_check(sdp, indbh, GFS2_METATYPE_IN)) {\n\t\t\terror = -EIO;\n\t\t\tgoto out;\n\t\t}\n\n\t\teablk = (__be64 *)(indbh->b_data + mh_size);\n\t\tend = eablk + sdp->sd_inptrs;\n\n\t\tfor (; eablk < end; eablk++)\n\t\t\tif (!*eablk)\n\t\t\t\tbreak;\n\n\t\tif (eablk == end) {\n\t\t\terror = -ENOSPC;\n\t\t\tgoto out;\n\t\t}\n\n\t\tgfs2_trans_add_meta(ip->i_gl, indbh);\n\t} else {\n\t\tu64 blk;\n\t\tunsigned int n = 1;\n\t\terror = gfs2_alloc_blocks(ip, &blk, &n, 0, NULL);\n\t\tif (error)\n\t\t\treturn error;\n\t\tgfs2_trans_add_unrevoke(sdp, blk, 1);\n\t\tindbh = gfs2_meta_new(ip->i_gl, blk);\n\t\tgfs2_trans_add_meta(ip->i_gl, indbh);\n\t\tgfs2_metatype_set(indbh, GFS2_METATYPE_IN, GFS2_FORMAT_IN);\n\t\tgfs2_buffer_clear_tail(indbh, mh_size);\n\n\t\teablk = (__be64 *)(indbh->b_data + mh_size);\n\t\t*eablk = cpu_to_be64(ip->i_eattr);\n\t\tip->i_eattr = blk;\n\t\tip->i_diskflags |= GFS2_DIF_EA_INDIRECT;\n\t\tgfs2_add_inode_blocks(&ip->i_inode, 1);\n\n\t\teablk++;\n\t}\n\n\terror = ea_alloc_blk(ip, &newbh);\n\tif (error)\n\t\tgoto out;\n\n\t*eablk = cpu_to_be64((u64)newbh->b_blocknr);\n\terror = ea_write(ip, GFS2_EA_BH2FIRST(newbh), er);\n\tbrelse(newbh);\n\tif (error)\n\t\tgoto out;\n\n\tif (private)\n\t\tea_set_remove_stuffed(ip, private);\n\nout:\n\tbrelse(indbh);\n\treturn error;\n}"
  },
  {
    "function_name": "ea_set_simple",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
    "lines": "921-966",
    "snippet": "static int ea_set_simple(struct gfs2_inode *ip, struct buffer_head *bh,\n\t\t\t struct gfs2_ea_header *ea, struct gfs2_ea_header *prev,\n\t\t\t void *private)\n{\n\tstruct ea_set *es = private;\n\tunsigned int size;\n\tint stuffed;\n\tint error;\n\n\tstuffed = ea_calc_size(GFS2_SB(&ip->i_inode), es->es_er->er_name_len,\n\t\t\t       es->es_er->er_data_len, &size);\n\n\tif (ea->ea_type == GFS2_EATYPE_UNUSED) {\n\t\tif (GFS2_EA_REC_LEN(ea) < size)\n\t\t\treturn 0;\n\t\tif (!GFS2_EA_IS_STUFFED(ea)) {\n\t\t\terror = ea_remove_unstuffed(ip, bh, ea, prev, 1);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t}\n\t\tes->ea_split = 0;\n\t} else if (GFS2_EA_REC_LEN(ea) - GFS2_EA_SIZE(ea) >= size)\n\t\tes->ea_split = 1;\n\telse\n\t\treturn 0;\n\n\tif (stuffed) {\n\t\terror = ea_set_simple_noalloc(ip, bh, ea, es);\n\t\tif (error)\n\t\t\treturn error;\n\t} else {\n\t\tunsigned int blks;\n\n\t\tes->es_bh = bh;\n\t\tes->es_ea = ea;\n\t\tblks = 2 + DIV_ROUND_UP(es->es_er->er_data_len,\n\t\t\t\t\tGFS2_SB(&ip->i_inode)->sd_jbsize);\n\n\t\terror = ea_alloc_skeleton(ip, es->es_er, blks,\n\t\t\t\t\t  ea_set_simple_alloc, es);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\treturn 1;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"trans.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"inode.h\"",
      "#include \"glock.h\"",
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/xattr.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ea_alloc_skeleton",
          "args": [
            "ip",
            "es->es_er",
            "blks",
            "ea_set_simple_alloc",
            "es"
          ],
          "line": 959
        },
        "resolved": true,
        "details": {
          "function_name": "ea_alloc_skeleton",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "723-768",
          "snippet": "static int ea_alloc_skeleton(struct gfs2_inode *ip, struct gfs2_ea_request *er,\n\t\t\t     unsigned int blks,\n\t\t\t     ea_skeleton_call_t skeleton_call, void *private)\n{\n\tstruct gfs2_alloc_parms ap = { .target = blks };\n\tstruct buffer_head *dibh;\n\tint error;\n\n\terror = gfs2_rindex_update(GFS2_SB(&ip->i_inode));\n\tif (error)\n\t\treturn error;\n\n\terror = gfs2_quota_lock_check(ip);\n\tif (error)\n\t\treturn error;\n\n\terror = gfs2_inplace_reserve(ip, &ap);\n\tif (error)\n\t\tgoto out_gunlock_q;\n\n\terror = gfs2_trans_begin(GFS2_SB(&ip->i_inode),\n\t\t\t\t blks + gfs2_rg_blocks(ip, blks) +\n\t\t\t\t RES_DINODE + RES_STATFS + RES_QUOTA, 0);\n\tif (error)\n\t\tgoto out_ipres;\n\n\terror = skeleton_call(ip, er, private);\n\tif (error)\n\t\tgoto out_end_trans;\n\n\terror = gfs2_meta_inode_buffer(ip, &dibh);\n\tif (!error) {\n\t\tip->i_inode.i_ctime = CURRENT_TIME;\n\t\tgfs2_trans_add_meta(ip->i_gl, dibh);\n\t\tgfs2_dinode_out(ip, dibh->b_data);\n\t\tbrelse(dibh);\n\t}\n\nout_end_trans:\n\tgfs2_trans_end(GFS2_SB(&ip->i_inode));\nout_ipres:\n\tgfs2_inplace_release(ip);\nout_gunlock_q:\n\tgfs2_quota_unlock(ip);\n\treturn error;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic int ea_alloc_skeleton(struct gfs2_inode *ip, struct gfs2_ea_request *er,\n\t\t\t     unsigned int blks,\n\t\t\t     ea_skeleton_call_t skeleton_call, void *private)\n{\n\tstruct gfs2_alloc_parms ap = { .target = blks };\n\tstruct buffer_head *dibh;\n\tint error;\n\n\terror = gfs2_rindex_update(GFS2_SB(&ip->i_inode));\n\tif (error)\n\t\treturn error;\n\n\terror = gfs2_quota_lock_check(ip);\n\tif (error)\n\t\treturn error;\n\n\terror = gfs2_inplace_reserve(ip, &ap);\n\tif (error)\n\t\tgoto out_gunlock_q;\n\n\terror = gfs2_trans_begin(GFS2_SB(&ip->i_inode),\n\t\t\t\t blks + gfs2_rg_blocks(ip, blks) +\n\t\t\t\t RES_DINODE + RES_STATFS + RES_QUOTA, 0);\n\tif (error)\n\t\tgoto out_ipres;\n\n\terror = skeleton_call(ip, er, private);\n\tif (error)\n\t\tgoto out_end_trans;\n\n\terror = gfs2_meta_inode_buffer(ip, &dibh);\n\tif (!error) {\n\t\tip->i_inode.i_ctime = CURRENT_TIME;\n\t\tgfs2_trans_add_meta(ip->i_gl, dibh);\n\t\tgfs2_dinode_out(ip, dibh->b_data);\n\t\tbrelse(dibh);\n\t}\n\nout_end_trans:\n\tgfs2_trans_end(GFS2_SB(&ip->i_inode));\nout_ipres:\n\tgfs2_inplace_release(ip);\nout_gunlock_q:\n\tgfs2_quota_unlock(ip);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DIV_ROUND_UP",
          "args": [
            "es->es_er->er_data_len",
            "GFS2_SB(&ip->i_inode)->sd_jbsize"
          ],
          "line": 956
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GFS2_SB",
          "args": [
            "&ip->i_inode"
          ],
          "line": 957
        },
        "resolved": true,
        "details": {
          "function_name": "GFS2_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/incore.h",
          "lines": "413-416",
          "snippet": "static inline struct gfs2_sbd *GFS2_SB(const struct inode *inode)\n{\n\treturn inode->i_sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/lockref.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ktime.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/completion.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dlm.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockref.h>\n#include <linux/percpu.h>\n#include <linux/ktime.h>\n#include <linux/rbtree.h>\n#include <linux/completion.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/buffer_head.h>\n#include <linux/dlm.h>\n#include <linux/workqueue.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n\nstatic inline struct gfs2_sbd *GFS2_SB(const struct inode *inode)\n{\n\treturn inode->i_sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ea_set_simple_noalloc",
          "args": [
            "ip",
            "bh",
            "ea",
            "es"
          ],
          "line": 948
        },
        "resolved": true,
        "details": {
          "function_name": "ea_set_simple_noalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "866-897",
          "snippet": "static int ea_set_simple_noalloc(struct gfs2_inode *ip, struct buffer_head *bh,\n\t\t\t\t struct gfs2_ea_header *ea, struct ea_set *es)\n{\n\tstruct gfs2_ea_request *er = es->es_er;\n\tstruct buffer_head *dibh;\n\tint error;\n\n\terror = gfs2_trans_begin(GFS2_SB(&ip->i_inode), RES_DINODE + 2 * RES_EATTR, 0);\n\tif (error)\n\t\treturn error;\n\n\tgfs2_trans_add_meta(ip->i_gl, bh);\n\n\tif (es->ea_split)\n\t\tea = ea_split_ea(ea);\n\n\tea_write(ip, ea, er);\n\n\tif (es->es_el)\n\t\tea_set_remove_stuffed(ip, es->es_el);\n\n\terror = gfs2_meta_inode_buffer(ip, &dibh);\n\tif (error)\n\t\tgoto out;\n\tip->i_inode.i_ctime = CURRENT_TIME;\n\tgfs2_trans_add_meta(ip->i_gl, dibh);\n\tgfs2_dinode_out(ip, dibh->b_data);\n\tbrelse(dibh);\nout:\n\tgfs2_trans_end(GFS2_SB(&ip->i_inode));\n\treturn error;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic int ea_set_simple_noalloc(struct gfs2_inode *ip, struct buffer_head *bh,\n\t\t\t\t struct gfs2_ea_header *ea, struct ea_set *es)\n{\n\tstruct gfs2_ea_request *er = es->es_er;\n\tstruct buffer_head *dibh;\n\tint error;\n\n\terror = gfs2_trans_begin(GFS2_SB(&ip->i_inode), RES_DINODE + 2 * RES_EATTR, 0);\n\tif (error)\n\t\treturn error;\n\n\tgfs2_trans_add_meta(ip->i_gl, bh);\n\n\tif (es->ea_split)\n\t\tea = ea_split_ea(ea);\n\n\tea_write(ip, ea, er);\n\n\tif (es->es_el)\n\t\tea_set_remove_stuffed(ip, es->es_el);\n\n\terror = gfs2_meta_inode_buffer(ip, &dibh);\n\tif (error)\n\t\tgoto out;\n\tip->i_inode.i_ctime = CURRENT_TIME;\n\tgfs2_trans_add_meta(ip->i_gl, dibh);\n\tgfs2_dinode_out(ip, dibh->b_data);\n\tbrelse(dibh);\nout:\n\tgfs2_trans_end(GFS2_SB(&ip->i_inode));\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GFS2_EA_SIZE",
          "args": [
            "ea"
          ],
          "line": 942
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GFS2_EA_REC_LEN",
          "args": [
            "ea"
          ],
          "line": 942
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ea_remove_unstuffed",
          "args": [
            "ip",
            "bh",
            "ea",
            "prev",
            "1"
          ],
          "line": 937
        },
        "resolved": true,
        "details": {
          "function_name": "ea_remove_unstuffed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "325-344",
          "snippet": "static int ea_remove_unstuffed(struct gfs2_inode *ip, struct buffer_head *bh,\n\t\t\t       struct gfs2_ea_header *ea,\n\t\t\t       struct gfs2_ea_header *prev, int leave)\n{\n\tint error;\n\n\terror = gfs2_rindex_update(GFS2_SB(&ip->i_inode));\n\tif (error)\n\t\treturn error;\n\n\terror = gfs2_quota_hold(ip, NO_UID_QUOTA_CHANGE, NO_GID_QUOTA_CHANGE);\n\tif (error)\n\t\tgoto out_alloc;\n\n\terror = ea_dealloc_unstuffed(ip, bh, ea, prev, (leave) ? &error : NULL);\n\n\tgfs2_quota_unhold(ip);\nout_alloc:\n\treturn error;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic int ea_remove_unstuffed(struct gfs2_inode *ip, struct buffer_head *bh,\n\t\t\t       struct gfs2_ea_header *ea,\n\t\t\t       struct gfs2_ea_header *prev, int leave)\n{\n\tint error;\n\n\terror = gfs2_rindex_update(GFS2_SB(&ip->i_inode));\n\tif (error)\n\t\treturn error;\n\n\terror = gfs2_quota_hold(ip, NO_UID_QUOTA_CHANGE, NO_GID_QUOTA_CHANGE);\n\tif (error)\n\t\tgoto out_alloc;\n\n\terror = ea_dealloc_unstuffed(ip, bh, ea, prev, (leave) ? &error : NULL);\n\n\tgfs2_quota_unhold(ip);\nout_alloc:\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GFS2_EA_IS_STUFFED",
          "args": [
            "ea"
          ],
          "line": 936
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GFS2_EA_REC_LEN",
          "args": [
            "ea"
          ],
          "line": 934
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ea_calc_size",
          "args": [
            "GFS2_SB(&ip->i_inode)",
            "es->es_er->er_name_len",
            "es->es_er->er_data_len",
            "&size"
          ],
          "line": 930
        },
        "resolved": true,
        "details": {
          "function_name": "ea_calc_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "41-57",
          "snippet": "static int ea_calc_size(struct gfs2_sbd *sdp, unsigned int nsize, size_t dsize,\n\t\t\tunsigned int *size)\n{\n\tunsigned int jbsize = sdp->sd_jbsize;\n\n\t/* Stuffed */\n\t*size = ALIGN(sizeof(struct gfs2_ea_header) + nsize + dsize, 8);\n\n\tif (*size <= jbsize)\n\t\treturn 1;\n\n\t/* Unstuffed */\n\t*size = ALIGN(sizeof(struct gfs2_ea_header) + nsize +\n\t\t      (sizeof(__be64) * DIV_ROUND_UP(dsize, jbsize)), 8);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic int ea_calc_size(struct gfs2_sbd *sdp, unsigned int nsize, size_t dsize,\n\t\t\tunsigned int *size)\n{\n\tunsigned int jbsize = sdp->sd_jbsize;\n\n\t/* Stuffed */\n\t*size = ALIGN(sizeof(struct gfs2_ea_header) + nsize + dsize, 8);\n\n\tif (*size <= jbsize)\n\t\treturn 1;\n\n\t/* Unstuffed */\n\t*size = ALIGN(sizeof(struct gfs2_ea_header) + nsize +\n\t\t      (sizeof(__be64) * DIV_ROUND_UP(dsize, jbsize)), 8);\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic int ea_set_simple(struct gfs2_inode *ip, struct buffer_head *bh,\n\t\t\t struct gfs2_ea_header *ea, struct gfs2_ea_header *prev,\n\t\t\t void *private)\n{\n\tstruct ea_set *es = private;\n\tunsigned int size;\n\tint stuffed;\n\tint error;\n\n\tstuffed = ea_calc_size(GFS2_SB(&ip->i_inode), es->es_er->er_name_len,\n\t\t\t       es->es_er->er_data_len, &size);\n\n\tif (ea->ea_type == GFS2_EATYPE_UNUSED) {\n\t\tif (GFS2_EA_REC_LEN(ea) < size)\n\t\t\treturn 0;\n\t\tif (!GFS2_EA_IS_STUFFED(ea)) {\n\t\t\terror = ea_remove_unstuffed(ip, bh, ea, prev, 1);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t}\n\t\tes->ea_split = 0;\n\t} else if (GFS2_EA_REC_LEN(ea) - GFS2_EA_SIZE(ea) >= size)\n\t\tes->ea_split = 1;\n\telse\n\t\treturn 0;\n\n\tif (stuffed) {\n\t\terror = ea_set_simple_noalloc(ip, bh, ea, es);\n\t\tif (error)\n\t\t\treturn error;\n\t} else {\n\t\tunsigned int blks;\n\n\t\tes->es_bh = bh;\n\t\tes->es_ea = ea;\n\t\tblks = 2 + DIV_ROUND_UP(es->es_er->er_data_len,\n\t\t\t\t\tGFS2_SB(&ip->i_inode)->sd_jbsize);\n\n\t\terror = ea_alloc_skeleton(ip, es->es_er, blks,\n\t\t\t\t\t  ea_set_simple_alloc, es);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\treturn 1;\n}"
  },
  {
    "function_name": "ea_set_simple_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
    "lines": "899-919",
    "snippet": "static int ea_set_simple_alloc(struct gfs2_inode *ip,\n\t\t\t       struct gfs2_ea_request *er, void *private)\n{\n\tstruct ea_set *es = private;\n\tstruct gfs2_ea_header *ea = es->es_ea;\n\tint error;\n\n\tgfs2_trans_add_meta(ip->i_gl, es->es_bh);\n\n\tif (es->ea_split)\n\t\tea = ea_split_ea(ea);\n\n\terror = ea_write(ip, ea, er);\n\tif (error)\n\t\treturn error;\n\n\tif (es->es_el)\n\t\tea_set_remove_stuffed(ip, es->es_el);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"trans.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"inode.h\"",
      "#include \"glock.h\"",
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/xattr.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ea_set_remove_stuffed",
          "args": [
            "ip",
            "es->es_el"
          ],
          "line": 916
        },
        "resolved": true,
        "details": {
          "function_name": "ea_set_remove_stuffed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "832-854",
          "snippet": "static void ea_set_remove_stuffed(struct gfs2_inode *ip,\n\t\t\t\t  struct gfs2_ea_location *el)\n{\n\tstruct gfs2_ea_header *ea = el->el_ea;\n\tstruct gfs2_ea_header *prev = el->el_prev;\n\tu32 len;\n\n\tgfs2_trans_add_meta(ip->i_gl, el->el_bh);\n\n\tif (!prev || !GFS2_EA_IS_STUFFED(ea)) {\n\t\tea->ea_type = GFS2_EATYPE_UNUSED;\n\t\treturn;\n\t} else if (GFS2_EA2NEXT(prev) != ea) {\n\t\tprev = GFS2_EA2NEXT(prev);\n\t\tgfs2_assert_withdraw(GFS2_SB(&ip->i_inode), GFS2_EA2NEXT(prev) == ea);\n\t}\n\n\tlen = GFS2_EA_REC_LEN(prev) + GFS2_EA_REC_LEN(ea);\n\tprev->ea_rec_len = cpu_to_be32(len);\n\n\tif (GFS2_EA_IS_LAST(ea))\n\t\tprev->ea_flags |= GFS2_EAFLAG_LAST;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic void ea_set_remove_stuffed(struct gfs2_inode *ip,\n\t\t\t\t  struct gfs2_ea_location *el)\n{\n\tstruct gfs2_ea_header *ea = el->el_ea;\n\tstruct gfs2_ea_header *prev = el->el_prev;\n\tu32 len;\n\n\tgfs2_trans_add_meta(ip->i_gl, el->el_bh);\n\n\tif (!prev || !GFS2_EA_IS_STUFFED(ea)) {\n\t\tea->ea_type = GFS2_EATYPE_UNUSED;\n\t\treturn;\n\t} else if (GFS2_EA2NEXT(prev) != ea) {\n\t\tprev = GFS2_EA2NEXT(prev);\n\t\tgfs2_assert_withdraw(GFS2_SB(&ip->i_inode), GFS2_EA2NEXT(prev) == ea);\n\t}\n\n\tlen = GFS2_EA_REC_LEN(prev) + GFS2_EA_REC_LEN(ea);\n\tprev->ea_rec_len = cpu_to_be32(len);\n\n\tif (GFS2_EA_IS_LAST(ea))\n\t\tprev->ea_flags |= GFS2_EAFLAG_LAST;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ea_write",
          "args": [
            "ip",
            "ea",
            "er"
          ],
          "line": 911
        },
        "resolved": true,
        "details": {
          "function_name": "ea_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "660-718",
          "snippet": "static int ea_write(struct gfs2_inode *ip, struct gfs2_ea_header *ea,\n\t\t    struct gfs2_ea_request *er)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tint error;\n\n\tea->ea_data_len = cpu_to_be32(er->er_data_len);\n\tea->ea_name_len = er->er_name_len;\n\tea->ea_type = er->er_type;\n\tea->__pad = 0;\n\n\tmemcpy(GFS2_EA2NAME(ea), er->er_name, er->er_name_len);\n\n\tif (GFS2_EAREQ_SIZE_STUFFED(er) <= sdp->sd_jbsize) {\n\t\tea->ea_num_ptrs = 0;\n\t\tmemcpy(GFS2_EA2DATA(ea), er->er_data, er->er_data_len);\n\t} else {\n\t\t__be64 *dataptr = GFS2_EA2DATAPTRS(ea);\n\t\tconst char *data = er->er_data;\n\t\tunsigned int data_len = er->er_data_len;\n\t\tunsigned int copy;\n\t\tunsigned int x;\n\n\t\tea->ea_num_ptrs = DIV_ROUND_UP(er->er_data_len, sdp->sd_jbsize);\n\t\tfor (x = 0; x < ea->ea_num_ptrs; x++) {\n\t\t\tstruct buffer_head *bh;\n\t\t\tu64 block;\n\t\t\tint mh_size = sizeof(struct gfs2_meta_header);\n\t\t\tunsigned int n = 1;\n\n\t\t\terror = gfs2_alloc_blocks(ip, &block, &n, 0, NULL);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\tgfs2_trans_add_unrevoke(sdp, block, 1);\n\t\t\tbh = gfs2_meta_new(ip->i_gl, block);\n\t\t\tgfs2_trans_add_meta(ip->i_gl, bh);\n\t\t\tgfs2_metatype_set(bh, GFS2_METATYPE_ED, GFS2_FORMAT_ED);\n\n\t\t\tgfs2_add_inode_blocks(&ip->i_inode, 1);\n\n\t\t\tcopy = data_len > sdp->sd_jbsize ? sdp->sd_jbsize :\n\t\t\t\t\t\t\t   data_len;\n\t\t\tmemcpy(bh->b_data + mh_size, data, copy);\n\t\t\tif (copy < sdp->sd_jbsize)\n\t\t\t\tmemset(bh->b_data + mh_size + copy, 0,\n\t\t\t\t       sdp->sd_jbsize - copy);\n\n\t\t\t*dataptr++ = cpu_to_be64(bh->b_blocknr);\n\t\t\tdata += copy;\n\t\t\tdata_len -= copy;\n\n\t\t\tbrelse(bh);\n\t\t}\n\n\t\tgfs2_assert_withdraw(sdp, !data_len);\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic int ea_write(struct gfs2_inode *ip, struct gfs2_ea_header *ea,\n\t\t    struct gfs2_ea_request *er)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tint error;\n\n\tea->ea_data_len = cpu_to_be32(er->er_data_len);\n\tea->ea_name_len = er->er_name_len;\n\tea->ea_type = er->er_type;\n\tea->__pad = 0;\n\n\tmemcpy(GFS2_EA2NAME(ea), er->er_name, er->er_name_len);\n\n\tif (GFS2_EAREQ_SIZE_STUFFED(er) <= sdp->sd_jbsize) {\n\t\tea->ea_num_ptrs = 0;\n\t\tmemcpy(GFS2_EA2DATA(ea), er->er_data, er->er_data_len);\n\t} else {\n\t\t__be64 *dataptr = GFS2_EA2DATAPTRS(ea);\n\t\tconst char *data = er->er_data;\n\t\tunsigned int data_len = er->er_data_len;\n\t\tunsigned int copy;\n\t\tunsigned int x;\n\n\t\tea->ea_num_ptrs = DIV_ROUND_UP(er->er_data_len, sdp->sd_jbsize);\n\t\tfor (x = 0; x < ea->ea_num_ptrs; x++) {\n\t\t\tstruct buffer_head *bh;\n\t\t\tu64 block;\n\t\t\tint mh_size = sizeof(struct gfs2_meta_header);\n\t\t\tunsigned int n = 1;\n\n\t\t\terror = gfs2_alloc_blocks(ip, &block, &n, 0, NULL);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\tgfs2_trans_add_unrevoke(sdp, block, 1);\n\t\t\tbh = gfs2_meta_new(ip->i_gl, block);\n\t\t\tgfs2_trans_add_meta(ip->i_gl, bh);\n\t\t\tgfs2_metatype_set(bh, GFS2_METATYPE_ED, GFS2_FORMAT_ED);\n\n\t\t\tgfs2_add_inode_blocks(&ip->i_inode, 1);\n\n\t\t\tcopy = data_len > sdp->sd_jbsize ? sdp->sd_jbsize :\n\t\t\t\t\t\t\t   data_len;\n\t\t\tmemcpy(bh->b_data + mh_size, data, copy);\n\t\t\tif (copy < sdp->sd_jbsize)\n\t\t\t\tmemset(bh->b_data + mh_size + copy, 0,\n\t\t\t\t       sdp->sd_jbsize - copy);\n\n\t\t\t*dataptr++ = cpu_to_be64(bh->b_blocknr);\n\t\t\tdata += copy;\n\t\t\tdata_len -= copy;\n\n\t\t\tbrelse(bh);\n\t\t}\n\n\t\tgfs2_assert_withdraw(sdp, !data_len);\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ea_split_ea",
          "args": [
            "ea"
          ],
          "line": 909
        },
        "resolved": true,
        "details": {
          "function_name": "ea_split_ea",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "815-830",
          "snippet": "static struct gfs2_ea_header *ea_split_ea(struct gfs2_ea_header *ea)\n{\n\tu32 ea_size = GFS2_EA_SIZE(ea);\n\tstruct gfs2_ea_header *new = (struct gfs2_ea_header *)((char *)ea +\n\t\t\t\t     ea_size);\n\tu32 new_size = GFS2_EA_REC_LEN(ea) - ea_size;\n\tint last = ea->ea_flags & GFS2_EAFLAG_LAST;\n\n\tea->ea_rec_len = cpu_to_be32(ea_size);\n\tea->ea_flags ^= last;\n\n\tnew->ea_rec_len = cpu_to_be32(new_size);\n\tnew->ea_flags = last;\n\n\treturn new;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic struct gfs2_ea_header *ea_split_ea(struct gfs2_ea_header *ea)\n{\n\tu32 ea_size = GFS2_EA_SIZE(ea);\n\tstruct gfs2_ea_header *new = (struct gfs2_ea_header *)((char *)ea +\n\t\t\t\t     ea_size);\n\tu32 new_size = GFS2_EA_REC_LEN(ea) - ea_size;\n\tint last = ea->ea_flags & GFS2_EAFLAG_LAST;\n\n\tea->ea_rec_len = cpu_to_be32(ea_size);\n\tea->ea_flags ^= last;\n\n\tnew->ea_rec_len = cpu_to_be32(new_size);\n\tnew->ea_flags = last;\n\n\treturn new;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_trans_add_meta",
          "args": [
            "ip->i_gl",
            "es->es_bh"
          ],
          "line": 906
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_trans_add_meta",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/trans.c",
          "lines": "224-247",
          "snippet": "void gfs2_trans_add_meta(struct gfs2_glock *gl, struct buffer_head *bh)\n{\n\n\tstruct gfs2_sbd *sdp = gl->gl_sbd;\n\tstruct gfs2_bufdata *bd;\n\n\tlock_buffer(bh);\n\tgfs2_log_lock(sdp);\n\tbd = bh->b_private;\n\tif (bd == NULL) {\n\t\tgfs2_log_unlock(sdp);\n\t\tunlock_buffer(bh);\n\t\tlock_page(bh->b_page);\n\t\tif (bh->b_private == NULL)\n\t\t\tbd = gfs2_alloc_bufdata(gl, bh, &gfs2_buf_lops);\n\t\tunlock_page(bh->b_page);\n\t\tlock_buffer(bh);\n\t\tgfs2_log_lock(sdp);\n\t}\n\tgfs2_assert(sdp, bd->bd_gl == gl);\n\tmeta_lo_add(sdp, bd);\n\tgfs2_log_unlock(sdp);\n\tunlock_buffer(bh);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_trans_add_meta(struct gfs2_glock *gl, struct buffer_head *bh)\n{\n\n\tstruct gfs2_sbd *sdp = gl->gl_sbd;\n\tstruct gfs2_bufdata *bd;\n\n\tlock_buffer(bh);\n\tgfs2_log_lock(sdp);\n\tbd = bh->b_private;\n\tif (bd == NULL) {\n\t\tgfs2_log_unlock(sdp);\n\t\tunlock_buffer(bh);\n\t\tlock_page(bh->b_page);\n\t\tif (bh->b_private == NULL)\n\t\t\tbd = gfs2_alloc_bufdata(gl, bh, &gfs2_buf_lops);\n\t\tunlock_page(bh->b_page);\n\t\tlock_buffer(bh);\n\t\tgfs2_log_lock(sdp);\n\t}\n\tgfs2_assert(sdp, bd->bd_gl == gl);\n\tmeta_lo_add(sdp, bd);\n\tgfs2_log_unlock(sdp);\n\tunlock_buffer(bh);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic int ea_set_simple_alloc(struct gfs2_inode *ip,\n\t\t\t       struct gfs2_ea_request *er, void *private)\n{\n\tstruct ea_set *es = private;\n\tstruct gfs2_ea_header *ea = es->es_ea;\n\tint error;\n\n\tgfs2_trans_add_meta(ip->i_gl, es->es_bh);\n\n\tif (es->ea_split)\n\t\tea = ea_split_ea(ea);\n\n\terror = ea_write(ip, ea, er);\n\tif (error)\n\t\treturn error;\n\n\tif (es->es_el)\n\t\tea_set_remove_stuffed(ip, es->es_el);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "ea_set_simple_noalloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
    "lines": "866-897",
    "snippet": "static int ea_set_simple_noalloc(struct gfs2_inode *ip, struct buffer_head *bh,\n\t\t\t\t struct gfs2_ea_header *ea, struct ea_set *es)\n{\n\tstruct gfs2_ea_request *er = es->es_er;\n\tstruct buffer_head *dibh;\n\tint error;\n\n\terror = gfs2_trans_begin(GFS2_SB(&ip->i_inode), RES_DINODE + 2 * RES_EATTR, 0);\n\tif (error)\n\t\treturn error;\n\n\tgfs2_trans_add_meta(ip->i_gl, bh);\n\n\tif (es->ea_split)\n\t\tea = ea_split_ea(ea);\n\n\tea_write(ip, ea, er);\n\n\tif (es->es_el)\n\t\tea_set_remove_stuffed(ip, es->es_el);\n\n\terror = gfs2_meta_inode_buffer(ip, &dibh);\n\tif (error)\n\t\tgoto out;\n\tip->i_inode.i_ctime = CURRENT_TIME;\n\tgfs2_trans_add_meta(ip->i_gl, dibh);\n\tgfs2_dinode_out(ip, dibh->b_data);\n\tbrelse(dibh);\nout:\n\tgfs2_trans_end(GFS2_SB(&ip->i_inode));\n\treturn error;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"trans.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"inode.h\"",
      "#include \"glock.h\"",
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/xattr.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "gfs2_trans_end",
          "args": [
            "GFS2_SB(&ip->i_inode)"
          ],
          "line": 895
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_trans_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/trans.c",
          "lines": "88-123",
          "snippet": "void gfs2_trans_end(struct gfs2_sbd *sdp)\n{\n\tstruct gfs2_trans *tr = current->journal_info;\n\ts64 nbuf;\n\tint alloced = tr->tr_alloced;\n\n\tBUG_ON(!tr);\n\tcurrent->journal_info = NULL;\n\n\tif (!tr->tr_touched) {\n\t\tgfs2_log_release(sdp, tr->tr_reserved);\n\t\tif (alloced) {\n\t\t\tkfree(tr);\n\t\t\tsb_end_intwrite(sdp->sd_vfs);\n\t\t}\n\t\treturn;\n\t}\n\n\tnbuf = tr->tr_num_buf_new + tr->tr_num_databuf_new;\n\tnbuf -= tr->tr_num_buf_rm;\n\tnbuf -= tr->tr_num_databuf_rm;\n\n\tif (gfs2_assert_withdraw(sdp, (nbuf <= tr->tr_blocks) &&\n\t\t\t\t       (tr->tr_num_revoke <= tr->tr_revokes)))\n\t\tgfs2_print_trans(tr);\n\n\tgfs2_log_commit(sdp, tr);\n\tif (alloced && !tr->tr_attached)\n\t\t\tkfree(tr);\n\tup_read(&sdp->sd_log_flush_lock);\n\n\tif (sdp->sd_vfs->s_flags & MS_SYNCHRONOUS)\n\t\tgfs2_log_flush(sdp, NULL, NORMAL_FLUSH);\n\tif (alloced)\n\t\tsb_end_intwrite(sdp->sd_vfs);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_trans_end(struct gfs2_sbd *sdp)\n{\n\tstruct gfs2_trans *tr = current->journal_info;\n\ts64 nbuf;\n\tint alloced = tr->tr_alloced;\n\n\tBUG_ON(!tr);\n\tcurrent->journal_info = NULL;\n\n\tif (!tr->tr_touched) {\n\t\tgfs2_log_release(sdp, tr->tr_reserved);\n\t\tif (alloced) {\n\t\t\tkfree(tr);\n\t\t\tsb_end_intwrite(sdp->sd_vfs);\n\t\t}\n\t\treturn;\n\t}\n\n\tnbuf = tr->tr_num_buf_new + tr->tr_num_databuf_new;\n\tnbuf -= tr->tr_num_buf_rm;\n\tnbuf -= tr->tr_num_databuf_rm;\n\n\tif (gfs2_assert_withdraw(sdp, (nbuf <= tr->tr_blocks) &&\n\t\t\t\t       (tr->tr_num_revoke <= tr->tr_revokes)))\n\t\tgfs2_print_trans(tr);\n\n\tgfs2_log_commit(sdp, tr);\n\tif (alloced && !tr->tr_attached)\n\t\t\tkfree(tr);\n\tup_read(&sdp->sd_log_flush_lock);\n\n\tif (sdp->sd_vfs->s_flags & MS_SYNCHRONOUS)\n\t\tgfs2_log_flush(sdp, NULL, NORMAL_FLUSH);\n\tif (alloced)\n\t\tsb_end_intwrite(sdp->sd_vfs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "GFS2_SB",
          "args": [
            "&ip->i_inode"
          ],
          "line": 895
        },
        "resolved": true,
        "details": {
          "function_name": "GFS2_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/incore.h",
          "lines": "413-416",
          "snippet": "static inline struct gfs2_sbd *GFS2_SB(const struct inode *inode)\n{\n\treturn inode->i_sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/lockref.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ktime.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/completion.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dlm.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockref.h>\n#include <linux/percpu.h>\n#include <linux/ktime.h>\n#include <linux/rbtree.h>\n#include <linux/completion.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/buffer_head.h>\n#include <linux/dlm.h>\n#include <linux/workqueue.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n\nstatic inline struct gfs2_sbd *GFS2_SB(const struct inode *inode)\n{\n\treturn inode->i_sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "dibh"
          ],
          "line": 893
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_dinode_out",
          "args": [
            "ip",
            "dibh->b_data"
          ],
          "line": 892
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_dinode_out",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/super.c",
          "lines": "696-731",
          "snippet": "void gfs2_dinode_out(const struct gfs2_inode *ip, void *buf)\n{\n\tstruct gfs2_dinode *str = buf;\n\n\tstr->di_header.mh_magic = cpu_to_be32(GFS2_MAGIC);\n\tstr->di_header.mh_type = cpu_to_be32(GFS2_METATYPE_DI);\n\tstr->di_header.mh_format = cpu_to_be32(GFS2_FORMAT_DI);\n\tstr->di_num.no_addr = cpu_to_be64(ip->i_no_addr);\n\tstr->di_num.no_formal_ino = cpu_to_be64(ip->i_no_formal_ino);\n\tstr->di_mode = cpu_to_be32(ip->i_inode.i_mode);\n\tstr->di_uid = cpu_to_be32(i_uid_read(&ip->i_inode));\n\tstr->di_gid = cpu_to_be32(i_gid_read(&ip->i_inode));\n\tstr->di_nlink = cpu_to_be32(ip->i_inode.i_nlink);\n\tstr->di_size = cpu_to_be64(i_size_read(&ip->i_inode));\n\tstr->di_blocks = cpu_to_be64(gfs2_get_inode_blocks(&ip->i_inode));\n\tstr->di_atime = cpu_to_be64(ip->i_inode.i_atime.tv_sec);\n\tstr->di_mtime = cpu_to_be64(ip->i_inode.i_mtime.tv_sec);\n\tstr->di_ctime = cpu_to_be64(ip->i_inode.i_ctime.tv_sec);\n\n\tstr->di_goal_meta = cpu_to_be64(ip->i_goal);\n\tstr->di_goal_data = cpu_to_be64(ip->i_goal);\n\tstr->di_generation = cpu_to_be64(ip->i_generation);\n\n\tstr->di_flags = cpu_to_be32(ip->i_diskflags);\n\tstr->di_height = cpu_to_be16(ip->i_height);\n\tstr->di_payload_format = cpu_to_be32(S_ISDIR(ip->i_inode.i_mode) &&\n\t\t\t\t\t     !(ip->i_diskflags & GFS2_DIF_EXHASH) ?\n\t\t\t\t\t     GFS2_FORMAT_DE : 0);\n\tstr->di_depth = cpu_to_be16(ip->i_depth);\n\tstr->di_entries = cpu_to_be32(ip->i_entries);\n\n\tstr->di_eattr = cpu_to_be64(ip->i_eattr);\n\tstr->di_atime_nsec = cpu_to_be32(ip->i_inode.i_atime.tv_nsec);\n\tstr->di_mtime_nsec = cpu_to_be32(ip->i_inode.i_mtime.tv_nsec);\n\tstr->di_ctime_nsec = cpu_to_be32(ip->i_inode.i_ctime.tv_nsec);\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"sys.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"recovery.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"dir.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/kernel.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/time.h>",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/statfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/bio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"sys.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"recovery.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"dir.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/kernel.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/time.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/statfs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/bio.h>\n\nvoid gfs2_dinode_out(const struct gfs2_inode *ip, void *buf)\n{\n\tstruct gfs2_dinode *str = buf;\n\n\tstr->di_header.mh_magic = cpu_to_be32(GFS2_MAGIC);\n\tstr->di_header.mh_type = cpu_to_be32(GFS2_METATYPE_DI);\n\tstr->di_header.mh_format = cpu_to_be32(GFS2_FORMAT_DI);\n\tstr->di_num.no_addr = cpu_to_be64(ip->i_no_addr);\n\tstr->di_num.no_formal_ino = cpu_to_be64(ip->i_no_formal_ino);\n\tstr->di_mode = cpu_to_be32(ip->i_inode.i_mode);\n\tstr->di_uid = cpu_to_be32(i_uid_read(&ip->i_inode));\n\tstr->di_gid = cpu_to_be32(i_gid_read(&ip->i_inode));\n\tstr->di_nlink = cpu_to_be32(ip->i_inode.i_nlink);\n\tstr->di_size = cpu_to_be64(i_size_read(&ip->i_inode));\n\tstr->di_blocks = cpu_to_be64(gfs2_get_inode_blocks(&ip->i_inode));\n\tstr->di_atime = cpu_to_be64(ip->i_inode.i_atime.tv_sec);\n\tstr->di_mtime = cpu_to_be64(ip->i_inode.i_mtime.tv_sec);\n\tstr->di_ctime = cpu_to_be64(ip->i_inode.i_ctime.tv_sec);\n\n\tstr->di_goal_meta = cpu_to_be64(ip->i_goal);\n\tstr->di_goal_data = cpu_to_be64(ip->i_goal);\n\tstr->di_generation = cpu_to_be64(ip->i_generation);\n\n\tstr->di_flags = cpu_to_be32(ip->i_diskflags);\n\tstr->di_height = cpu_to_be16(ip->i_height);\n\tstr->di_payload_format = cpu_to_be32(S_ISDIR(ip->i_inode.i_mode) &&\n\t\t\t\t\t     !(ip->i_diskflags & GFS2_DIF_EXHASH) ?\n\t\t\t\t\t     GFS2_FORMAT_DE : 0);\n\tstr->di_depth = cpu_to_be16(ip->i_depth);\n\tstr->di_entries = cpu_to_be32(ip->i_entries);\n\n\tstr->di_eattr = cpu_to_be64(ip->i_eattr);\n\tstr->di_atime_nsec = cpu_to_be32(ip->i_inode.i_atime.tv_nsec);\n\tstr->di_mtime_nsec = cpu_to_be32(ip->i_inode.i_mtime.tv_nsec);\n\tstr->di_ctime_nsec = cpu_to_be32(ip->i_inode.i_ctime.tv_nsec);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_trans_add_meta",
          "args": [
            "ip->i_gl",
            "dibh"
          ],
          "line": 891
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_trans_add_meta",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/trans.c",
          "lines": "224-247",
          "snippet": "void gfs2_trans_add_meta(struct gfs2_glock *gl, struct buffer_head *bh)\n{\n\n\tstruct gfs2_sbd *sdp = gl->gl_sbd;\n\tstruct gfs2_bufdata *bd;\n\n\tlock_buffer(bh);\n\tgfs2_log_lock(sdp);\n\tbd = bh->b_private;\n\tif (bd == NULL) {\n\t\tgfs2_log_unlock(sdp);\n\t\tunlock_buffer(bh);\n\t\tlock_page(bh->b_page);\n\t\tif (bh->b_private == NULL)\n\t\t\tbd = gfs2_alloc_bufdata(gl, bh, &gfs2_buf_lops);\n\t\tunlock_page(bh->b_page);\n\t\tlock_buffer(bh);\n\t\tgfs2_log_lock(sdp);\n\t}\n\tgfs2_assert(sdp, bd->bd_gl == gl);\n\tmeta_lo_add(sdp, bd);\n\tgfs2_log_unlock(sdp);\n\tunlock_buffer(bh);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_trans_add_meta(struct gfs2_glock *gl, struct buffer_head *bh)\n{\n\n\tstruct gfs2_sbd *sdp = gl->gl_sbd;\n\tstruct gfs2_bufdata *bd;\n\n\tlock_buffer(bh);\n\tgfs2_log_lock(sdp);\n\tbd = bh->b_private;\n\tif (bd == NULL) {\n\t\tgfs2_log_unlock(sdp);\n\t\tunlock_buffer(bh);\n\t\tlock_page(bh->b_page);\n\t\tif (bh->b_private == NULL)\n\t\t\tbd = gfs2_alloc_bufdata(gl, bh, &gfs2_buf_lops);\n\t\tunlock_page(bh->b_page);\n\t\tlock_buffer(bh);\n\t\tgfs2_log_lock(sdp);\n\t}\n\tgfs2_assert(sdp, bd->bd_gl == gl);\n\tmeta_lo_add(sdp, bd);\n\tgfs2_log_unlock(sdp);\n\tunlock_buffer(bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_meta_inode_buffer",
          "args": [
            "ip",
            "&dibh"
          ],
          "line": 887
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_meta_inode_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/meta_io.h",
          "lines": "66-70",
          "snippet": "static inline int gfs2_meta_inode_buffer(struct gfs2_inode *ip,\n\t\t\t\t\t struct buffer_head **bhp)\n{\n\treturn gfs2_meta_indirect_buffer(ip, 0, ip->i_no_addr, bhp);\n}",
          "includes": [
            "#include \"incore.h\"",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"incore.h\"\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline int gfs2_meta_inode_buffer(struct gfs2_inode *ip,\n\t\t\t\t\t struct buffer_head **bhp)\n{\n\treturn gfs2_meta_indirect_buffer(ip, 0, ip->i_no_addr, bhp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ea_set_remove_stuffed",
          "args": [
            "ip",
            "es->es_el"
          ],
          "line": 885
        },
        "resolved": true,
        "details": {
          "function_name": "ea_set_remove_stuffed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "832-854",
          "snippet": "static void ea_set_remove_stuffed(struct gfs2_inode *ip,\n\t\t\t\t  struct gfs2_ea_location *el)\n{\n\tstruct gfs2_ea_header *ea = el->el_ea;\n\tstruct gfs2_ea_header *prev = el->el_prev;\n\tu32 len;\n\n\tgfs2_trans_add_meta(ip->i_gl, el->el_bh);\n\n\tif (!prev || !GFS2_EA_IS_STUFFED(ea)) {\n\t\tea->ea_type = GFS2_EATYPE_UNUSED;\n\t\treturn;\n\t} else if (GFS2_EA2NEXT(prev) != ea) {\n\t\tprev = GFS2_EA2NEXT(prev);\n\t\tgfs2_assert_withdraw(GFS2_SB(&ip->i_inode), GFS2_EA2NEXT(prev) == ea);\n\t}\n\n\tlen = GFS2_EA_REC_LEN(prev) + GFS2_EA_REC_LEN(ea);\n\tprev->ea_rec_len = cpu_to_be32(len);\n\n\tif (GFS2_EA_IS_LAST(ea))\n\t\tprev->ea_flags |= GFS2_EAFLAG_LAST;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic void ea_set_remove_stuffed(struct gfs2_inode *ip,\n\t\t\t\t  struct gfs2_ea_location *el)\n{\n\tstruct gfs2_ea_header *ea = el->el_ea;\n\tstruct gfs2_ea_header *prev = el->el_prev;\n\tu32 len;\n\n\tgfs2_trans_add_meta(ip->i_gl, el->el_bh);\n\n\tif (!prev || !GFS2_EA_IS_STUFFED(ea)) {\n\t\tea->ea_type = GFS2_EATYPE_UNUSED;\n\t\treturn;\n\t} else if (GFS2_EA2NEXT(prev) != ea) {\n\t\tprev = GFS2_EA2NEXT(prev);\n\t\tgfs2_assert_withdraw(GFS2_SB(&ip->i_inode), GFS2_EA2NEXT(prev) == ea);\n\t}\n\n\tlen = GFS2_EA_REC_LEN(prev) + GFS2_EA_REC_LEN(ea);\n\tprev->ea_rec_len = cpu_to_be32(len);\n\n\tif (GFS2_EA_IS_LAST(ea))\n\t\tprev->ea_flags |= GFS2_EAFLAG_LAST;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ea_write",
          "args": [
            "ip",
            "ea",
            "er"
          ],
          "line": 882
        },
        "resolved": true,
        "details": {
          "function_name": "ea_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "660-718",
          "snippet": "static int ea_write(struct gfs2_inode *ip, struct gfs2_ea_header *ea,\n\t\t    struct gfs2_ea_request *er)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tint error;\n\n\tea->ea_data_len = cpu_to_be32(er->er_data_len);\n\tea->ea_name_len = er->er_name_len;\n\tea->ea_type = er->er_type;\n\tea->__pad = 0;\n\n\tmemcpy(GFS2_EA2NAME(ea), er->er_name, er->er_name_len);\n\n\tif (GFS2_EAREQ_SIZE_STUFFED(er) <= sdp->sd_jbsize) {\n\t\tea->ea_num_ptrs = 0;\n\t\tmemcpy(GFS2_EA2DATA(ea), er->er_data, er->er_data_len);\n\t} else {\n\t\t__be64 *dataptr = GFS2_EA2DATAPTRS(ea);\n\t\tconst char *data = er->er_data;\n\t\tunsigned int data_len = er->er_data_len;\n\t\tunsigned int copy;\n\t\tunsigned int x;\n\n\t\tea->ea_num_ptrs = DIV_ROUND_UP(er->er_data_len, sdp->sd_jbsize);\n\t\tfor (x = 0; x < ea->ea_num_ptrs; x++) {\n\t\t\tstruct buffer_head *bh;\n\t\t\tu64 block;\n\t\t\tint mh_size = sizeof(struct gfs2_meta_header);\n\t\t\tunsigned int n = 1;\n\n\t\t\terror = gfs2_alloc_blocks(ip, &block, &n, 0, NULL);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\tgfs2_trans_add_unrevoke(sdp, block, 1);\n\t\t\tbh = gfs2_meta_new(ip->i_gl, block);\n\t\t\tgfs2_trans_add_meta(ip->i_gl, bh);\n\t\t\tgfs2_metatype_set(bh, GFS2_METATYPE_ED, GFS2_FORMAT_ED);\n\n\t\t\tgfs2_add_inode_blocks(&ip->i_inode, 1);\n\n\t\t\tcopy = data_len > sdp->sd_jbsize ? sdp->sd_jbsize :\n\t\t\t\t\t\t\t   data_len;\n\t\t\tmemcpy(bh->b_data + mh_size, data, copy);\n\t\t\tif (copy < sdp->sd_jbsize)\n\t\t\t\tmemset(bh->b_data + mh_size + copy, 0,\n\t\t\t\t       sdp->sd_jbsize - copy);\n\n\t\t\t*dataptr++ = cpu_to_be64(bh->b_blocknr);\n\t\t\tdata += copy;\n\t\t\tdata_len -= copy;\n\n\t\t\tbrelse(bh);\n\t\t}\n\n\t\tgfs2_assert_withdraw(sdp, !data_len);\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic int ea_write(struct gfs2_inode *ip, struct gfs2_ea_header *ea,\n\t\t    struct gfs2_ea_request *er)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tint error;\n\n\tea->ea_data_len = cpu_to_be32(er->er_data_len);\n\tea->ea_name_len = er->er_name_len;\n\tea->ea_type = er->er_type;\n\tea->__pad = 0;\n\n\tmemcpy(GFS2_EA2NAME(ea), er->er_name, er->er_name_len);\n\n\tif (GFS2_EAREQ_SIZE_STUFFED(er) <= sdp->sd_jbsize) {\n\t\tea->ea_num_ptrs = 0;\n\t\tmemcpy(GFS2_EA2DATA(ea), er->er_data, er->er_data_len);\n\t} else {\n\t\t__be64 *dataptr = GFS2_EA2DATAPTRS(ea);\n\t\tconst char *data = er->er_data;\n\t\tunsigned int data_len = er->er_data_len;\n\t\tunsigned int copy;\n\t\tunsigned int x;\n\n\t\tea->ea_num_ptrs = DIV_ROUND_UP(er->er_data_len, sdp->sd_jbsize);\n\t\tfor (x = 0; x < ea->ea_num_ptrs; x++) {\n\t\t\tstruct buffer_head *bh;\n\t\t\tu64 block;\n\t\t\tint mh_size = sizeof(struct gfs2_meta_header);\n\t\t\tunsigned int n = 1;\n\n\t\t\terror = gfs2_alloc_blocks(ip, &block, &n, 0, NULL);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\tgfs2_trans_add_unrevoke(sdp, block, 1);\n\t\t\tbh = gfs2_meta_new(ip->i_gl, block);\n\t\t\tgfs2_trans_add_meta(ip->i_gl, bh);\n\t\t\tgfs2_metatype_set(bh, GFS2_METATYPE_ED, GFS2_FORMAT_ED);\n\n\t\t\tgfs2_add_inode_blocks(&ip->i_inode, 1);\n\n\t\t\tcopy = data_len > sdp->sd_jbsize ? sdp->sd_jbsize :\n\t\t\t\t\t\t\t   data_len;\n\t\t\tmemcpy(bh->b_data + mh_size, data, copy);\n\t\t\tif (copy < sdp->sd_jbsize)\n\t\t\t\tmemset(bh->b_data + mh_size + copy, 0,\n\t\t\t\t       sdp->sd_jbsize - copy);\n\n\t\t\t*dataptr++ = cpu_to_be64(bh->b_blocknr);\n\t\t\tdata += copy;\n\t\t\tdata_len -= copy;\n\n\t\t\tbrelse(bh);\n\t\t}\n\n\t\tgfs2_assert_withdraw(sdp, !data_len);\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ea_split_ea",
          "args": [
            "ea"
          ],
          "line": 880
        },
        "resolved": true,
        "details": {
          "function_name": "ea_split_ea",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "815-830",
          "snippet": "static struct gfs2_ea_header *ea_split_ea(struct gfs2_ea_header *ea)\n{\n\tu32 ea_size = GFS2_EA_SIZE(ea);\n\tstruct gfs2_ea_header *new = (struct gfs2_ea_header *)((char *)ea +\n\t\t\t\t     ea_size);\n\tu32 new_size = GFS2_EA_REC_LEN(ea) - ea_size;\n\tint last = ea->ea_flags & GFS2_EAFLAG_LAST;\n\n\tea->ea_rec_len = cpu_to_be32(ea_size);\n\tea->ea_flags ^= last;\n\n\tnew->ea_rec_len = cpu_to_be32(new_size);\n\tnew->ea_flags = last;\n\n\treturn new;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic struct gfs2_ea_header *ea_split_ea(struct gfs2_ea_header *ea)\n{\n\tu32 ea_size = GFS2_EA_SIZE(ea);\n\tstruct gfs2_ea_header *new = (struct gfs2_ea_header *)((char *)ea +\n\t\t\t\t     ea_size);\n\tu32 new_size = GFS2_EA_REC_LEN(ea) - ea_size;\n\tint last = ea->ea_flags & GFS2_EAFLAG_LAST;\n\n\tea->ea_rec_len = cpu_to_be32(ea_size);\n\tea->ea_flags ^= last;\n\n\tnew->ea_rec_len = cpu_to_be32(new_size);\n\tnew->ea_flags = last;\n\n\treturn new;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_trans_begin",
          "args": [
            "GFS2_SB(&ip->i_inode)",
            "RES_DINODE + 2 * RES_EATTR",
            "0"
          ],
          "line": 873
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_trans_begin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/trans.c",
          "lines": "31-75",
          "snippet": "int gfs2_trans_begin(struct gfs2_sbd *sdp, unsigned int blocks,\n\t\t     unsigned int revokes)\n{\n\tstruct gfs2_trans *tr;\n\tint error;\n\n\tBUG_ON(current->journal_info);\n\tBUG_ON(blocks == 0 && revokes == 0);\n\n\tif (!test_bit(SDF_JOURNAL_LIVE, &sdp->sd_flags))\n\t\treturn -EROFS;\n\n\ttr = kzalloc(sizeof(struct gfs2_trans), GFP_NOFS);\n\tif (!tr)\n\t\treturn -ENOMEM;\n\n\ttr->tr_ip = _RET_IP_;\n\ttr->tr_blocks = blocks;\n\ttr->tr_revokes = revokes;\n\ttr->tr_reserved = 1;\n\ttr->tr_alloced = 1;\n\tif (blocks)\n\t\ttr->tr_reserved += 6 + blocks;\n\tif (revokes)\n\t\ttr->tr_reserved += gfs2_struct2blk(sdp, revokes,\n\t\t\t\t\t\t   sizeof(u64));\n\tINIT_LIST_HEAD(&tr->tr_databuf);\n\tINIT_LIST_HEAD(&tr->tr_buf);\n\n\tsb_start_intwrite(sdp->sd_vfs);\n\n\terror = gfs2_log_reserve(sdp, tr->tr_reserved);\n\tif (error)\n\t\tgoto fail;\n\n\tcurrent->journal_info = tr;\n\n\treturn 0;\n\nfail:\n\tsb_end_intwrite(sdp->sd_vfs);\n\tkfree(tr);\n\n\treturn error;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nint gfs2_trans_begin(struct gfs2_sbd *sdp, unsigned int blocks,\n\t\t     unsigned int revokes)\n{\n\tstruct gfs2_trans *tr;\n\tint error;\n\n\tBUG_ON(current->journal_info);\n\tBUG_ON(blocks == 0 && revokes == 0);\n\n\tif (!test_bit(SDF_JOURNAL_LIVE, &sdp->sd_flags))\n\t\treturn -EROFS;\n\n\ttr = kzalloc(sizeof(struct gfs2_trans), GFP_NOFS);\n\tif (!tr)\n\t\treturn -ENOMEM;\n\n\ttr->tr_ip = _RET_IP_;\n\ttr->tr_blocks = blocks;\n\ttr->tr_revokes = revokes;\n\ttr->tr_reserved = 1;\n\ttr->tr_alloced = 1;\n\tif (blocks)\n\t\ttr->tr_reserved += 6 + blocks;\n\tif (revokes)\n\t\ttr->tr_reserved += gfs2_struct2blk(sdp, revokes,\n\t\t\t\t\t\t   sizeof(u64));\n\tINIT_LIST_HEAD(&tr->tr_databuf);\n\tINIT_LIST_HEAD(&tr->tr_buf);\n\n\tsb_start_intwrite(sdp->sd_vfs);\n\n\terror = gfs2_log_reserve(sdp, tr->tr_reserved);\n\tif (error)\n\t\tgoto fail;\n\n\tcurrent->journal_info = tr;\n\n\treturn 0;\n\nfail:\n\tsb_end_intwrite(sdp->sd_vfs);\n\tkfree(tr);\n\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic int ea_set_simple_noalloc(struct gfs2_inode *ip, struct buffer_head *bh,\n\t\t\t\t struct gfs2_ea_header *ea, struct ea_set *es)\n{\n\tstruct gfs2_ea_request *er = es->es_er;\n\tstruct buffer_head *dibh;\n\tint error;\n\n\terror = gfs2_trans_begin(GFS2_SB(&ip->i_inode), RES_DINODE + 2 * RES_EATTR, 0);\n\tif (error)\n\t\treturn error;\n\n\tgfs2_trans_add_meta(ip->i_gl, bh);\n\n\tif (es->ea_split)\n\t\tea = ea_split_ea(ea);\n\n\tea_write(ip, ea, er);\n\n\tif (es->es_el)\n\t\tea_set_remove_stuffed(ip, es->es_el);\n\n\terror = gfs2_meta_inode_buffer(ip, &dibh);\n\tif (error)\n\t\tgoto out;\n\tip->i_inode.i_ctime = CURRENT_TIME;\n\tgfs2_trans_add_meta(ip->i_gl, dibh);\n\tgfs2_dinode_out(ip, dibh->b_data);\n\tbrelse(dibh);\nout:\n\tgfs2_trans_end(GFS2_SB(&ip->i_inode));\n\treturn error;\n}"
  },
  {
    "function_name": "ea_set_remove_stuffed",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
    "lines": "832-854",
    "snippet": "static void ea_set_remove_stuffed(struct gfs2_inode *ip,\n\t\t\t\t  struct gfs2_ea_location *el)\n{\n\tstruct gfs2_ea_header *ea = el->el_ea;\n\tstruct gfs2_ea_header *prev = el->el_prev;\n\tu32 len;\n\n\tgfs2_trans_add_meta(ip->i_gl, el->el_bh);\n\n\tif (!prev || !GFS2_EA_IS_STUFFED(ea)) {\n\t\tea->ea_type = GFS2_EATYPE_UNUSED;\n\t\treturn;\n\t} else if (GFS2_EA2NEXT(prev) != ea) {\n\t\tprev = GFS2_EA2NEXT(prev);\n\t\tgfs2_assert_withdraw(GFS2_SB(&ip->i_inode), GFS2_EA2NEXT(prev) == ea);\n\t}\n\n\tlen = GFS2_EA_REC_LEN(prev) + GFS2_EA_REC_LEN(ea);\n\tprev->ea_rec_len = cpu_to_be32(len);\n\n\tif (GFS2_EA_IS_LAST(ea))\n\t\tprev->ea_flags |= GFS2_EAFLAG_LAST;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"trans.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"inode.h\"",
      "#include \"glock.h\"",
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/xattr.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "GFS2_EA_IS_LAST",
          "args": [
            "ea"
          ],
          "line": 852
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "len"
          ],
          "line": 850
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GFS2_EA_REC_LEN",
          "args": [
            "ea"
          ],
          "line": 849
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GFS2_EA_REC_LEN",
          "args": [
            "prev"
          ],
          "line": 849
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_assert_withdraw",
          "args": [
            "GFS2_SB(&ip->i_inode)",
            "GFS2_EA2NEXT(prev) == ea"
          ],
          "line": 846
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GFS2_EA2NEXT",
          "args": [
            "prev"
          ],
          "line": 846
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GFS2_SB",
          "args": [
            "&ip->i_inode"
          ],
          "line": 846
        },
        "resolved": true,
        "details": {
          "function_name": "GFS2_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/incore.h",
          "lines": "413-416",
          "snippet": "static inline struct gfs2_sbd *GFS2_SB(const struct inode *inode)\n{\n\treturn inode->i_sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/lockref.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ktime.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/completion.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dlm.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockref.h>\n#include <linux/percpu.h>\n#include <linux/ktime.h>\n#include <linux/rbtree.h>\n#include <linux/completion.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/buffer_head.h>\n#include <linux/dlm.h>\n#include <linux/workqueue.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n\nstatic inline struct gfs2_sbd *GFS2_SB(const struct inode *inode)\n{\n\treturn inode->i_sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GFS2_EA2NEXT",
          "args": [
            "prev"
          ],
          "line": 845
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GFS2_EA2NEXT",
          "args": [
            "prev"
          ],
          "line": 844
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GFS2_EA_IS_STUFFED",
          "args": [
            "ea"
          ],
          "line": 841
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_trans_add_meta",
          "args": [
            "ip->i_gl",
            "el->el_bh"
          ],
          "line": 839
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_trans_add_meta",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/trans.c",
          "lines": "224-247",
          "snippet": "void gfs2_trans_add_meta(struct gfs2_glock *gl, struct buffer_head *bh)\n{\n\n\tstruct gfs2_sbd *sdp = gl->gl_sbd;\n\tstruct gfs2_bufdata *bd;\n\n\tlock_buffer(bh);\n\tgfs2_log_lock(sdp);\n\tbd = bh->b_private;\n\tif (bd == NULL) {\n\t\tgfs2_log_unlock(sdp);\n\t\tunlock_buffer(bh);\n\t\tlock_page(bh->b_page);\n\t\tif (bh->b_private == NULL)\n\t\t\tbd = gfs2_alloc_bufdata(gl, bh, &gfs2_buf_lops);\n\t\tunlock_page(bh->b_page);\n\t\tlock_buffer(bh);\n\t\tgfs2_log_lock(sdp);\n\t}\n\tgfs2_assert(sdp, bd->bd_gl == gl);\n\tmeta_lo_add(sdp, bd);\n\tgfs2_log_unlock(sdp);\n\tunlock_buffer(bh);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_trans_add_meta(struct gfs2_glock *gl, struct buffer_head *bh)\n{\n\n\tstruct gfs2_sbd *sdp = gl->gl_sbd;\n\tstruct gfs2_bufdata *bd;\n\n\tlock_buffer(bh);\n\tgfs2_log_lock(sdp);\n\tbd = bh->b_private;\n\tif (bd == NULL) {\n\t\tgfs2_log_unlock(sdp);\n\t\tunlock_buffer(bh);\n\t\tlock_page(bh->b_page);\n\t\tif (bh->b_private == NULL)\n\t\t\tbd = gfs2_alloc_bufdata(gl, bh, &gfs2_buf_lops);\n\t\tunlock_page(bh->b_page);\n\t\tlock_buffer(bh);\n\t\tgfs2_log_lock(sdp);\n\t}\n\tgfs2_assert(sdp, bd->bd_gl == gl);\n\tmeta_lo_add(sdp, bd);\n\tgfs2_log_unlock(sdp);\n\tunlock_buffer(bh);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic void ea_set_remove_stuffed(struct gfs2_inode *ip,\n\t\t\t\t  struct gfs2_ea_location *el)\n{\n\tstruct gfs2_ea_header *ea = el->el_ea;\n\tstruct gfs2_ea_header *prev = el->el_prev;\n\tu32 len;\n\n\tgfs2_trans_add_meta(ip->i_gl, el->el_bh);\n\n\tif (!prev || !GFS2_EA_IS_STUFFED(ea)) {\n\t\tea->ea_type = GFS2_EATYPE_UNUSED;\n\t\treturn;\n\t} else if (GFS2_EA2NEXT(prev) != ea) {\n\t\tprev = GFS2_EA2NEXT(prev);\n\t\tgfs2_assert_withdraw(GFS2_SB(&ip->i_inode), GFS2_EA2NEXT(prev) == ea);\n\t}\n\n\tlen = GFS2_EA_REC_LEN(prev) + GFS2_EA_REC_LEN(ea);\n\tprev->ea_rec_len = cpu_to_be32(len);\n\n\tif (GFS2_EA_IS_LAST(ea))\n\t\tprev->ea_flags |= GFS2_EAFLAG_LAST;\n}"
  },
  {
    "function_name": "ea_split_ea",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
    "lines": "815-830",
    "snippet": "static struct gfs2_ea_header *ea_split_ea(struct gfs2_ea_header *ea)\n{\n\tu32 ea_size = GFS2_EA_SIZE(ea);\n\tstruct gfs2_ea_header *new = (struct gfs2_ea_header *)((char *)ea +\n\t\t\t\t     ea_size);\n\tu32 new_size = GFS2_EA_REC_LEN(ea) - ea_size;\n\tint last = ea->ea_flags & GFS2_EAFLAG_LAST;\n\n\tea->ea_rec_len = cpu_to_be32(ea_size);\n\tea->ea_flags ^= last;\n\n\tnew->ea_rec_len = cpu_to_be32(new_size);\n\tnew->ea_flags = last;\n\n\treturn new;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"trans.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"inode.h\"",
      "#include \"glock.h\"",
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/xattr.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "new_size"
          ],
          "line": 826
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "ea_size"
          ],
          "line": 823
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GFS2_EA_REC_LEN",
          "args": [
            "ea"
          ],
          "line": 820
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GFS2_EA_SIZE",
          "args": [
            "ea"
          ],
          "line": 817
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic struct gfs2_ea_header *ea_split_ea(struct gfs2_ea_header *ea)\n{\n\tu32 ea_size = GFS2_EA_SIZE(ea);\n\tstruct gfs2_ea_header *new = (struct gfs2_ea_header *)((char *)ea +\n\t\t\t\t     ea_size);\n\tu32 new_size = GFS2_EA_REC_LEN(ea) - ea_size;\n\tint last = ea->ea_flags & GFS2_EAFLAG_LAST;\n\n\tea->ea_rec_len = cpu_to_be32(ea_size);\n\tea->ea_flags ^= last;\n\n\tnew->ea_rec_len = cpu_to_be32(new_size);\n\tnew->ea_flags = last;\n\n\treturn new;\n}"
  },
  {
    "function_name": "ea_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
    "lines": "796-813",
    "snippet": "static int ea_init(struct gfs2_inode *ip, int type, const char *name,\n\t\t   const void *data, size_t size)\n{\n\tstruct gfs2_ea_request er;\n\tunsigned int jbsize = GFS2_SB(&ip->i_inode)->sd_jbsize;\n\tunsigned int blks = 1;\n\n\ter.er_type = type;\n\ter.er_name = name;\n\ter.er_name_len = strlen(name);\n\ter.er_data = (void *)data;\n\ter.er_data_len = size;\n\n\tif (GFS2_EAREQ_SIZE_STUFFED(&er) > jbsize)\n\t\tblks += DIV_ROUND_UP(er.er_data_len, jbsize);\n\n\treturn ea_alloc_skeleton(ip, &er, blks, ea_init_i, NULL);\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"trans.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"inode.h\"",
      "#include \"glock.h\"",
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/xattr.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ea_alloc_skeleton",
          "args": [
            "ip",
            "&er",
            "blks",
            "ea_init_i",
            "NULL"
          ],
          "line": 812
        },
        "resolved": true,
        "details": {
          "function_name": "ea_alloc_skeleton",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "723-768",
          "snippet": "static int ea_alloc_skeleton(struct gfs2_inode *ip, struct gfs2_ea_request *er,\n\t\t\t     unsigned int blks,\n\t\t\t     ea_skeleton_call_t skeleton_call, void *private)\n{\n\tstruct gfs2_alloc_parms ap = { .target = blks };\n\tstruct buffer_head *dibh;\n\tint error;\n\n\terror = gfs2_rindex_update(GFS2_SB(&ip->i_inode));\n\tif (error)\n\t\treturn error;\n\n\terror = gfs2_quota_lock_check(ip);\n\tif (error)\n\t\treturn error;\n\n\terror = gfs2_inplace_reserve(ip, &ap);\n\tif (error)\n\t\tgoto out_gunlock_q;\n\n\terror = gfs2_trans_begin(GFS2_SB(&ip->i_inode),\n\t\t\t\t blks + gfs2_rg_blocks(ip, blks) +\n\t\t\t\t RES_DINODE + RES_STATFS + RES_QUOTA, 0);\n\tif (error)\n\t\tgoto out_ipres;\n\n\terror = skeleton_call(ip, er, private);\n\tif (error)\n\t\tgoto out_end_trans;\n\n\terror = gfs2_meta_inode_buffer(ip, &dibh);\n\tif (!error) {\n\t\tip->i_inode.i_ctime = CURRENT_TIME;\n\t\tgfs2_trans_add_meta(ip->i_gl, dibh);\n\t\tgfs2_dinode_out(ip, dibh->b_data);\n\t\tbrelse(dibh);\n\t}\n\nout_end_trans:\n\tgfs2_trans_end(GFS2_SB(&ip->i_inode));\nout_ipres:\n\tgfs2_inplace_release(ip);\nout_gunlock_q:\n\tgfs2_quota_unlock(ip);\n\treturn error;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic int ea_alloc_skeleton(struct gfs2_inode *ip, struct gfs2_ea_request *er,\n\t\t\t     unsigned int blks,\n\t\t\t     ea_skeleton_call_t skeleton_call, void *private)\n{\n\tstruct gfs2_alloc_parms ap = { .target = blks };\n\tstruct buffer_head *dibh;\n\tint error;\n\n\terror = gfs2_rindex_update(GFS2_SB(&ip->i_inode));\n\tif (error)\n\t\treturn error;\n\n\terror = gfs2_quota_lock_check(ip);\n\tif (error)\n\t\treturn error;\n\n\terror = gfs2_inplace_reserve(ip, &ap);\n\tif (error)\n\t\tgoto out_gunlock_q;\n\n\terror = gfs2_trans_begin(GFS2_SB(&ip->i_inode),\n\t\t\t\t blks + gfs2_rg_blocks(ip, blks) +\n\t\t\t\t RES_DINODE + RES_STATFS + RES_QUOTA, 0);\n\tif (error)\n\t\tgoto out_ipres;\n\n\terror = skeleton_call(ip, er, private);\n\tif (error)\n\t\tgoto out_end_trans;\n\n\terror = gfs2_meta_inode_buffer(ip, &dibh);\n\tif (!error) {\n\t\tip->i_inode.i_ctime = CURRENT_TIME;\n\t\tgfs2_trans_add_meta(ip->i_gl, dibh);\n\t\tgfs2_dinode_out(ip, dibh->b_data);\n\t\tbrelse(dibh);\n\t}\n\nout_end_trans:\n\tgfs2_trans_end(GFS2_SB(&ip->i_inode));\nout_ipres:\n\tgfs2_inplace_release(ip);\nout_gunlock_q:\n\tgfs2_quota_unlock(ip);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DIV_ROUND_UP",
          "args": [
            "er.er_data_len",
            "jbsize"
          ],
          "line": 810
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GFS2_EAREQ_SIZE_STUFFED",
          "args": [
            "&er"
          ],
          "line": 809
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "name"
          ],
          "line": 805
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "GFS2_SB",
          "args": [
            "&ip->i_inode"
          ],
          "line": 800
        },
        "resolved": true,
        "details": {
          "function_name": "GFS2_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/incore.h",
          "lines": "413-416",
          "snippet": "static inline struct gfs2_sbd *GFS2_SB(const struct inode *inode)\n{\n\treturn inode->i_sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/lockref.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ktime.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/completion.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dlm.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockref.h>\n#include <linux/percpu.h>\n#include <linux/ktime.h>\n#include <linux/rbtree.h>\n#include <linux/completion.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/buffer_head.h>\n#include <linux/dlm.h>\n#include <linux/workqueue.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n\nstatic inline struct gfs2_sbd *GFS2_SB(const struct inode *inode)\n{\n\treturn inode->i_sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic int ea_init(struct gfs2_inode *ip, int type, const char *name,\n\t\t   const void *data, size_t size)\n{\n\tstruct gfs2_ea_request er;\n\tunsigned int jbsize = GFS2_SB(&ip->i_inode)->sd_jbsize;\n\tunsigned int blks = 1;\n\n\ter.er_type = type;\n\ter.er_name = name;\n\ter.er_name_len = strlen(name);\n\ter.er_data = (void *)data;\n\ter.er_data_len = size;\n\n\tif (GFS2_EAREQ_SIZE_STUFFED(&er) > jbsize)\n\t\tblks += DIV_ROUND_UP(er.er_data_len, jbsize);\n\n\treturn ea_alloc_skeleton(ip, &er, blks, ea_init_i, NULL);\n}"
  },
  {
    "function_name": "ea_init_i",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
    "lines": "770-786",
    "snippet": "static int ea_init_i(struct gfs2_inode *ip, struct gfs2_ea_request *er,\n\t\t     void *private)\n{\n\tstruct buffer_head *bh;\n\tint error;\n\n\terror = ea_alloc_blk(ip, &bh);\n\tif (error)\n\t\treturn error;\n\n\tip->i_eattr = bh->b_blocknr;\n\terror = ea_write(ip, GFS2_EA_BH2FIRST(bh), er);\n\n\tbrelse(bh);\n\n\treturn error;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"trans.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"inode.h\"",
      "#include \"glock.h\"",
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/xattr.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 783
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "ea_write",
          "args": [
            "ip",
            "GFS2_EA_BH2FIRST(bh)",
            "er"
          ],
          "line": 781
        },
        "resolved": true,
        "details": {
          "function_name": "ea_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "660-718",
          "snippet": "static int ea_write(struct gfs2_inode *ip, struct gfs2_ea_header *ea,\n\t\t    struct gfs2_ea_request *er)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tint error;\n\n\tea->ea_data_len = cpu_to_be32(er->er_data_len);\n\tea->ea_name_len = er->er_name_len;\n\tea->ea_type = er->er_type;\n\tea->__pad = 0;\n\n\tmemcpy(GFS2_EA2NAME(ea), er->er_name, er->er_name_len);\n\n\tif (GFS2_EAREQ_SIZE_STUFFED(er) <= sdp->sd_jbsize) {\n\t\tea->ea_num_ptrs = 0;\n\t\tmemcpy(GFS2_EA2DATA(ea), er->er_data, er->er_data_len);\n\t} else {\n\t\t__be64 *dataptr = GFS2_EA2DATAPTRS(ea);\n\t\tconst char *data = er->er_data;\n\t\tunsigned int data_len = er->er_data_len;\n\t\tunsigned int copy;\n\t\tunsigned int x;\n\n\t\tea->ea_num_ptrs = DIV_ROUND_UP(er->er_data_len, sdp->sd_jbsize);\n\t\tfor (x = 0; x < ea->ea_num_ptrs; x++) {\n\t\t\tstruct buffer_head *bh;\n\t\t\tu64 block;\n\t\t\tint mh_size = sizeof(struct gfs2_meta_header);\n\t\t\tunsigned int n = 1;\n\n\t\t\terror = gfs2_alloc_blocks(ip, &block, &n, 0, NULL);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\tgfs2_trans_add_unrevoke(sdp, block, 1);\n\t\t\tbh = gfs2_meta_new(ip->i_gl, block);\n\t\t\tgfs2_trans_add_meta(ip->i_gl, bh);\n\t\t\tgfs2_metatype_set(bh, GFS2_METATYPE_ED, GFS2_FORMAT_ED);\n\n\t\t\tgfs2_add_inode_blocks(&ip->i_inode, 1);\n\n\t\t\tcopy = data_len > sdp->sd_jbsize ? sdp->sd_jbsize :\n\t\t\t\t\t\t\t   data_len;\n\t\t\tmemcpy(bh->b_data + mh_size, data, copy);\n\t\t\tif (copy < sdp->sd_jbsize)\n\t\t\t\tmemset(bh->b_data + mh_size + copy, 0,\n\t\t\t\t       sdp->sd_jbsize - copy);\n\n\t\t\t*dataptr++ = cpu_to_be64(bh->b_blocknr);\n\t\t\tdata += copy;\n\t\t\tdata_len -= copy;\n\n\t\t\tbrelse(bh);\n\t\t}\n\n\t\tgfs2_assert_withdraw(sdp, !data_len);\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic int ea_write(struct gfs2_inode *ip, struct gfs2_ea_header *ea,\n\t\t    struct gfs2_ea_request *er)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tint error;\n\n\tea->ea_data_len = cpu_to_be32(er->er_data_len);\n\tea->ea_name_len = er->er_name_len;\n\tea->ea_type = er->er_type;\n\tea->__pad = 0;\n\n\tmemcpy(GFS2_EA2NAME(ea), er->er_name, er->er_name_len);\n\n\tif (GFS2_EAREQ_SIZE_STUFFED(er) <= sdp->sd_jbsize) {\n\t\tea->ea_num_ptrs = 0;\n\t\tmemcpy(GFS2_EA2DATA(ea), er->er_data, er->er_data_len);\n\t} else {\n\t\t__be64 *dataptr = GFS2_EA2DATAPTRS(ea);\n\t\tconst char *data = er->er_data;\n\t\tunsigned int data_len = er->er_data_len;\n\t\tunsigned int copy;\n\t\tunsigned int x;\n\n\t\tea->ea_num_ptrs = DIV_ROUND_UP(er->er_data_len, sdp->sd_jbsize);\n\t\tfor (x = 0; x < ea->ea_num_ptrs; x++) {\n\t\t\tstruct buffer_head *bh;\n\t\t\tu64 block;\n\t\t\tint mh_size = sizeof(struct gfs2_meta_header);\n\t\t\tunsigned int n = 1;\n\n\t\t\terror = gfs2_alloc_blocks(ip, &block, &n, 0, NULL);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\tgfs2_trans_add_unrevoke(sdp, block, 1);\n\t\t\tbh = gfs2_meta_new(ip->i_gl, block);\n\t\t\tgfs2_trans_add_meta(ip->i_gl, bh);\n\t\t\tgfs2_metatype_set(bh, GFS2_METATYPE_ED, GFS2_FORMAT_ED);\n\n\t\t\tgfs2_add_inode_blocks(&ip->i_inode, 1);\n\n\t\t\tcopy = data_len > sdp->sd_jbsize ? sdp->sd_jbsize :\n\t\t\t\t\t\t\t   data_len;\n\t\t\tmemcpy(bh->b_data + mh_size, data, copy);\n\t\t\tif (copy < sdp->sd_jbsize)\n\t\t\t\tmemset(bh->b_data + mh_size + copy, 0,\n\t\t\t\t       sdp->sd_jbsize - copy);\n\n\t\t\t*dataptr++ = cpu_to_be64(bh->b_blocknr);\n\t\t\tdata += copy;\n\t\t\tdata_len -= copy;\n\n\t\t\tbrelse(bh);\n\t\t}\n\n\t\tgfs2_assert_withdraw(sdp, !data_len);\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GFS2_EA_BH2FIRST",
          "args": [
            "bh"
          ],
          "line": 781
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ea_alloc_blk",
          "args": [
            "ip",
            "&bh"
          ],
          "line": 776
        },
        "resolved": true,
        "details": {
          "function_name": "ea_alloc_blk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "620-646",
          "snippet": "static int ea_alloc_blk(struct gfs2_inode *ip, struct buffer_head **bhp)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tstruct gfs2_ea_header *ea;\n\tunsigned int n = 1;\n\tu64 block;\n\tint error;\n\n\terror = gfs2_alloc_blocks(ip, &block, &n, 0, NULL);\n\tif (error)\n\t\treturn error;\n\tgfs2_trans_add_unrevoke(sdp, block, 1);\n\t*bhp = gfs2_meta_new(ip->i_gl, block);\n\tgfs2_trans_add_meta(ip->i_gl, *bhp);\n\tgfs2_metatype_set(*bhp, GFS2_METATYPE_EA, GFS2_FORMAT_EA);\n\tgfs2_buffer_clear_tail(*bhp, sizeof(struct gfs2_meta_header));\n\n\tea = GFS2_EA_BH2FIRST(*bhp);\n\tea->ea_rec_len = cpu_to_be32(sdp->sd_jbsize);\n\tea->ea_type = GFS2_EATYPE_UNUSED;\n\tea->ea_flags = GFS2_EAFLAG_LAST;\n\tea->ea_num_ptrs = 0;\n\n\tgfs2_add_inode_blocks(&ip->i_inode, 1);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic int ea_alloc_blk(struct gfs2_inode *ip, struct buffer_head **bhp)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tstruct gfs2_ea_header *ea;\n\tunsigned int n = 1;\n\tu64 block;\n\tint error;\n\n\terror = gfs2_alloc_blocks(ip, &block, &n, 0, NULL);\n\tif (error)\n\t\treturn error;\n\tgfs2_trans_add_unrevoke(sdp, block, 1);\n\t*bhp = gfs2_meta_new(ip->i_gl, block);\n\tgfs2_trans_add_meta(ip->i_gl, *bhp);\n\tgfs2_metatype_set(*bhp, GFS2_METATYPE_EA, GFS2_FORMAT_EA);\n\tgfs2_buffer_clear_tail(*bhp, sizeof(struct gfs2_meta_header));\n\n\tea = GFS2_EA_BH2FIRST(*bhp);\n\tea->ea_rec_len = cpu_to_be32(sdp->sd_jbsize);\n\tea->ea_type = GFS2_EATYPE_UNUSED;\n\tea->ea_flags = GFS2_EAFLAG_LAST;\n\tea->ea_num_ptrs = 0;\n\n\tgfs2_add_inode_blocks(&ip->i_inode, 1);\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic int ea_init_i(struct gfs2_inode *ip, struct gfs2_ea_request *er,\n\t\t     void *private)\n{\n\tstruct buffer_head *bh;\n\tint error;\n\n\terror = ea_alloc_blk(ip, &bh);\n\tif (error)\n\t\treturn error;\n\n\tip->i_eattr = bh->b_blocknr;\n\terror = ea_write(ip, GFS2_EA_BH2FIRST(bh), er);\n\n\tbrelse(bh);\n\n\treturn error;\n}"
  },
  {
    "function_name": "ea_alloc_skeleton",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
    "lines": "723-768",
    "snippet": "static int ea_alloc_skeleton(struct gfs2_inode *ip, struct gfs2_ea_request *er,\n\t\t\t     unsigned int blks,\n\t\t\t     ea_skeleton_call_t skeleton_call, void *private)\n{\n\tstruct gfs2_alloc_parms ap = { .target = blks };\n\tstruct buffer_head *dibh;\n\tint error;\n\n\terror = gfs2_rindex_update(GFS2_SB(&ip->i_inode));\n\tif (error)\n\t\treturn error;\n\n\terror = gfs2_quota_lock_check(ip);\n\tif (error)\n\t\treturn error;\n\n\terror = gfs2_inplace_reserve(ip, &ap);\n\tif (error)\n\t\tgoto out_gunlock_q;\n\n\terror = gfs2_trans_begin(GFS2_SB(&ip->i_inode),\n\t\t\t\t blks + gfs2_rg_blocks(ip, blks) +\n\t\t\t\t RES_DINODE + RES_STATFS + RES_QUOTA, 0);\n\tif (error)\n\t\tgoto out_ipres;\n\n\terror = skeleton_call(ip, er, private);\n\tif (error)\n\t\tgoto out_end_trans;\n\n\terror = gfs2_meta_inode_buffer(ip, &dibh);\n\tif (!error) {\n\t\tip->i_inode.i_ctime = CURRENT_TIME;\n\t\tgfs2_trans_add_meta(ip->i_gl, dibh);\n\t\tgfs2_dinode_out(ip, dibh->b_data);\n\t\tbrelse(dibh);\n\t}\n\nout_end_trans:\n\tgfs2_trans_end(GFS2_SB(&ip->i_inode));\nout_ipres:\n\tgfs2_inplace_release(ip);\nout_gunlock_q:\n\tgfs2_quota_unlock(ip);\n\treturn error;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"trans.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"inode.h\"",
      "#include \"glock.h\"",
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/xattr.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "gfs2_quota_unlock",
          "args": [
            "ip"
          ],
          "line": 766
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_quota_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.c",
          "lines": "1033-1081",
          "snippet": "void gfs2_quota_unlock(struct gfs2_inode *ip)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tstruct gfs2_quota_data *qda[4];\n\tunsigned int count = 0;\n\tunsigned int x;\n\tint found;\n\n\tif (!test_and_clear_bit(GIF_QD_LOCKED, &ip->i_flags))\n\t\tgoto out;\n\n\tfor (x = 0; x < ip->i_res->rs_qa_qd_num; x++) {\n\t\tstruct gfs2_quota_data *qd;\n\t\tint sync;\n\n\t\tqd = ip->i_res->rs_qa_qd[x];\n\t\tsync = need_sync(qd);\n\n\t\tgfs2_glock_dq_uninit(&ip->i_res->rs_qa_qd_ghs[x]);\n\t\tif (!sync)\n\t\t\tcontinue;\n\n\t\tspin_lock(&qd_lock);\n\t\tfound = qd_check_sync(sdp, qd, NULL);\n\t\tspin_unlock(&qd_lock);\n\n\t\tif (!found)\n\t\t\tcontinue;\n\n\t\tgfs2_assert_warn(sdp, qd->qd_change_sync);\n\t\tif (bh_get(qd)) {\n\t\t\tclear_bit(QDF_LOCKED, &qd->qd_flags);\n\t\t\tslot_put(qd);\n\t\t\tqd_put(qd);\n\t\t\tcontinue;\n\t\t}\n\n\t\tqda[count++] = qd;\n\t}\n\n\tif (count) {\n\t\tdo_sync(count, qda);\n\t\tfor (x = 0; x < count; x++)\n\t\t\tqd_unlock(qda[x]);\n\t}\n\nout:\n\tgfs2_quota_unhold(ip);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(qd_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic DEFINE_SPINLOCK(qd_lock);\n\nvoid gfs2_quota_unlock(struct gfs2_inode *ip)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tstruct gfs2_quota_data *qda[4];\n\tunsigned int count = 0;\n\tunsigned int x;\n\tint found;\n\n\tif (!test_and_clear_bit(GIF_QD_LOCKED, &ip->i_flags))\n\t\tgoto out;\n\n\tfor (x = 0; x < ip->i_res->rs_qa_qd_num; x++) {\n\t\tstruct gfs2_quota_data *qd;\n\t\tint sync;\n\n\t\tqd = ip->i_res->rs_qa_qd[x];\n\t\tsync = need_sync(qd);\n\n\t\tgfs2_glock_dq_uninit(&ip->i_res->rs_qa_qd_ghs[x]);\n\t\tif (!sync)\n\t\t\tcontinue;\n\n\t\tspin_lock(&qd_lock);\n\t\tfound = qd_check_sync(sdp, qd, NULL);\n\t\tspin_unlock(&qd_lock);\n\n\t\tif (!found)\n\t\t\tcontinue;\n\n\t\tgfs2_assert_warn(sdp, qd->qd_change_sync);\n\t\tif (bh_get(qd)) {\n\t\t\tclear_bit(QDF_LOCKED, &qd->qd_flags);\n\t\t\tslot_put(qd);\n\t\t\tqd_put(qd);\n\t\t\tcontinue;\n\t\t}\n\n\t\tqda[count++] = qd;\n\t}\n\n\tif (count) {\n\t\tdo_sync(count, qda);\n\t\tfor (x = 0; x < count; x++)\n\t\t\tqd_unlock(qda[x]);\n\t}\n\nout:\n\tgfs2_quota_unhold(ip);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_inplace_release",
          "args": [
            "ip"
          ],
          "line": 764
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_inplace_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
          "lines": "2081-2087",
          "snippet": "void gfs2_inplace_release(struct gfs2_inode *ip)\n{\n\tstruct gfs2_blkreserv *rs = ip->i_res;\n\n\tif (rs->rs_rgd_gh.gh_gl)\n\t\tgfs2_glock_dq_uninit(&rs->rs_rgd_gh);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"inode.h\"",
            "#include \"log.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/random.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nvoid gfs2_inplace_release(struct gfs2_inode *ip)\n{\n\tstruct gfs2_blkreserv *rs = ip->i_res;\n\n\tif (rs->rs_rgd_gh.gh_gl)\n\t\tgfs2_glock_dq_uninit(&rs->rs_rgd_gh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_trans_end",
          "args": [
            "GFS2_SB(&ip->i_inode)"
          ],
          "line": 762
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_trans_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/trans.c",
          "lines": "88-123",
          "snippet": "void gfs2_trans_end(struct gfs2_sbd *sdp)\n{\n\tstruct gfs2_trans *tr = current->journal_info;\n\ts64 nbuf;\n\tint alloced = tr->tr_alloced;\n\n\tBUG_ON(!tr);\n\tcurrent->journal_info = NULL;\n\n\tif (!tr->tr_touched) {\n\t\tgfs2_log_release(sdp, tr->tr_reserved);\n\t\tif (alloced) {\n\t\t\tkfree(tr);\n\t\t\tsb_end_intwrite(sdp->sd_vfs);\n\t\t}\n\t\treturn;\n\t}\n\n\tnbuf = tr->tr_num_buf_new + tr->tr_num_databuf_new;\n\tnbuf -= tr->tr_num_buf_rm;\n\tnbuf -= tr->tr_num_databuf_rm;\n\n\tif (gfs2_assert_withdraw(sdp, (nbuf <= tr->tr_blocks) &&\n\t\t\t\t       (tr->tr_num_revoke <= tr->tr_revokes)))\n\t\tgfs2_print_trans(tr);\n\n\tgfs2_log_commit(sdp, tr);\n\tif (alloced && !tr->tr_attached)\n\t\t\tkfree(tr);\n\tup_read(&sdp->sd_log_flush_lock);\n\n\tif (sdp->sd_vfs->s_flags & MS_SYNCHRONOUS)\n\t\tgfs2_log_flush(sdp, NULL, NORMAL_FLUSH);\n\tif (alloced)\n\t\tsb_end_intwrite(sdp->sd_vfs);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_trans_end(struct gfs2_sbd *sdp)\n{\n\tstruct gfs2_trans *tr = current->journal_info;\n\ts64 nbuf;\n\tint alloced = tr->tr_alloced;\n\n\tBUG_ON(!tr);\n\tcurrent->journal_info = NULL;\n\n\tif (!tr->tr_touched) {\n\t\tgfs2_log_release(sdp, tr->tr_reserved);\n\t\tif (alloced) {\n\t\t\tkfree(tr);\n\t\t\tsb_end_intwrite(sdp->sd_vfs);\n\t\t}\n\t\treturn;\n\t}\n\n\tnbuf = tr->tr_num_buf_new + tr->tr_num_databuf_new;\n\tnbuf -= tr->tr_num_buf_rm;\n\tnbuf -= tr->tr_num_databuf_rm;\n\n\tif (gfs2_assert_withdraw(sdp, (nbuf <= tr->tr_blocks) &&\n\t\t\t\t       (tr->tr_num_revoke <= tr->tr_revokes)))\n\t\tgfs2_print_trans(tr);\n\n\tgfs2_log_commit(sdp, tr);\n\tif (alloced && !tr->tr_attached)\n\t\t\tkfree(tr);\n\tup_read(&sdp->sd_log_flush_lock);\n\n\tif (sdp->sd_vfs->s_flags & MS_SYNCHRONOUS)\n\t\tgfs2_log_flush(sdp, NULL, NORMAL_FLUSH);\n\tif (alloced)\n\t\tsb_end_intwrite(sdp->sd_vfs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "GFS2_SB",
          "args": [
            "&ip->i_inode"
          ],
          "line": 762
        },
        "resolved": true,
        "details": {
          "function_name": "GFS2_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/incore.h",
          "lines": "413-416",
          "snippet": "static inline struct gfs2_sbd *GFS2_SB(const struct inode *inode)\n{\n\treturn inode->i_sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/lockref.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ktime.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/completion.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dlm.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockref.h>\n#include <linux/percpu.h>\n#include <linux/ktime.h>\n#include <linux/rbtree.h>\n#include <linux/completion.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/buffer_head.h>\n#include <linux/dlm.h>\n#include <linux/workqueue.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n\nstatic inline struct gfs2_sbd *GFS2_SB(const struct inode *inode)\n{\n\treturn inode->i_sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "dibh"
          ],
          "line": 758
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_dinode_out",
          "args": [
            "ip",
            "dibh->b_data"
          ],
          "line": 757
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_dinode_out",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/super.c",
          "lines": "696-731",
          "snippet": "void gfs2_dinode_out(const struct gfs2_inode *ip, void *buf)\n{\n\tstruct gfs2_dinode *str = buf;\n\n\tstr->di_header.mh_magic = cpu_to_be32(GFS2_MAGIC);\n\tstr->di_header.mh_type = cpu_to_be32(GFS2_METATYPE_DI);\n\tstr->di_header.mh_format = cpu_to_be32(GFS2_FORMAT_DI);\n\tstr->di_num.no_addr = cpu_to_be64(ip->i_no_addr);\n\tstr->di_num.no_formal_ino = cpu_to_be64(ip->i_no_formal_ino);\n\tstr->di_mode = cpu_to_be32(ip->i_inode.i_mode);\n\tstr->di_uid = cpu_to_be32(i_uid_read(&ip->i_inode));\n\tstr->di_gid = cpu_to_be32(i_gid_read(&ip->i_inode));\n\tstr->di_nlink = cpu_to_be32(ip->i_inode.i_nlink);\n\tstr->di_size = cpu_to_be64(i_size_read(&ip->i_inode));\n\tstr->di_blocks = cpu_to_be64(gfs2_get_inode_blocks(&ip->i_inode));\n\tstr->di_atime = cpu_to_be64(ip->i_inode.i_atime.tv_sec);\n\tstr->di_mtime = cpu_to_be64(ip->i_inode.i_mtime.tv_sec);\n\tstr->di_ctime = cpu_to_be64(ip->i_inode.i_ctime.tv_sec);\n\n\tstr->di_goal_meta = cpu_to_be64(ip->i_goal);\n\tstr->di_goal_data = cpu_to_be64(ip->i_goal);\n\tstr->di_generation = cpu_to_be64(ip->i_generation);\n\n\tstr->di_flags = cpu_to_be32(ip->i_diskflags);\n\tstr->di_height = cpu_to_be16(ip->i_height);\n\tstr->di_payload_format = cpu_to_be32(S_ISDIR(ip->i_inode.i_mode) &&\n\t\t\t\t\t     !(ip->i_diskflags & GFS2_DIF_EXHASH) ?\n\t\t\t\t\t     GFS2_FORMAT_DE : 0);\n\tstr->di_depth = cpu_to_be16(ip->i_depth);\n\tstr->di_entries = cpu_to_be32(ip->i_entries);\n\n\tstr->di_eattr = cpu_to_be64(ip->i_eattr);\n\tstr->di_atime_nsec = cpu_to_be32(ip->i_inode.i_atime.tv_nsec);\n\tstr->di_mtime_nsec = cpu_to_be32(ip->i_inode.i_mtime.tv_nsec);\n\tstr->di_ctime_nsec = cpu_to_be32(ip->i_inode.i_ctime.tv_nsec);\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"sys.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"recovery.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"dir.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/kernel.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/time.h>",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/statfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/bio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"sys.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"recovery.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"dir.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/kernel.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/time.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/statfs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/bio.h>\n\nvoid gfs2_dinode_out(const struct gfs2_inode *ip, void *buf)\n{\n\tstruct gfs2_dinode *str = buf;\n\n\tstr->di_header.mh_magic = cpu_to_be32(GFS2_MAGIC);\n\tstr->di_header.mh_type = cpu_to_be32(GFS2_METATYPE_DI);\n\tstr->di_header.mh_format = cpu_to_be32(GFS2_FORMAT_DI);\n\tstr->di_num.no_addr = cpu_to_be64(ip->i_no_addr);\n\tstr->di_num.no_formal_ino = cpu_to_be64(ip->i_no_formal_ino);\n\tstr->di_mode = cpu_to_be32(ip->i_inode.i_mode);\n\tstr->di_uid = cpu_to_be32(i_uid_read(&ip->i_inode));\n\tstr->di_gid = cpu_to_be32(i_gid_read(&ip->i_inode));\n\tstr->di_nlink = cpu_to_be32(ip->i_inode.i_nlink);\n\tstr->di_size = cpu_to_be64(i_size_read(&ip->i_inode));\n\tstr->di_blocks = cpu_to_be64(gfs2_get_inode_blocks(&ip->i_inode));\n\tstr->di_atime = cpu_to_be64(ip->i_inode.i_atime.tv_sec);\n\tstr->di_mtime = cpu_to_be64(ip->i_inode.i_mtime.tv_sec);\n\tstr->di_ctime = cpu_to_be64(ip->i_inode.i_ctime.tv_sec);\n\n\tstr->di_goal_meta = cpu_to_be64(ip->i_goal);\n\tstr->di_goal_data = cpu_to_be64(ip->i_goal);\n\tstr->di_generation = cpu_to_be64(ip->i_generation);\n\n\tstr->di_flags = cpu_to_be32(ip->i_diskflags);\n\tstr->di_height = cpu_to_be16(ip->i_height);\n\tstr->di_payload_format = cpu_to_be32(S_ISDIR(ip->i_inode.i_mode) &&\n\t\t\t\t\t     !(ip->i_diskflags & GFS2_DIF_EXHASH) ?\n\t\t\t\t\t     GFS2_FORMAT_DE : 0);\n\tstr->di_depth = cpu_to_be16(ip->i_depth);\n\tstr->di_entries = cpu_to_be32(ip->i_entries);\n\n\tstr->di_eattr = cpu_to_be64(ip->i_eattr);\n\tstr->di_atime_nsec = cpu_to_be32(ip->i_inode.i_atime.tv_nsec);\n\tstr->di_mtime_nsec = cpu_to_be32(ip->i_inode.i_mtime.tv_nsec);\n\tstr->di_ctime_nsec = cpu_to_be32(ip->i_inode.i_ctime.tv_nsec);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_trans_add_meta",
          "args": [
            "ip->i_gl",
            "dibh"
          ],
          "line": 756
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_trans_add_meta",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/trans.c",
          "lines": "224-247",
          "snippet": "void gfs2_trans_add_meta(struct gfs2_glock *gl, struct buffer_head *bh)\n{\n\n\tstruct gfs2_sbd *sdp = gl->gl_sbd;\n\tstruct gfs2_bufdata *bd;\n\n\tlock_buffer(bh);\n\tgfs2_log_lock(sdp);\n\tbd = bh->b_private;\n\tif (bd == NULL) {\n\t\tgfs2_log_unlock(sdp);\n\t\tunlock_buffer(bh);\n\t\tlock_page(bh->b_page);\n\t\tif (bh->b_private == NULL)\n\t\t\tbd = gfs2_alloc_bufdata(gl, bh, &gfs2_buf_lops);\n\t\tunlock_page(bh->b_page);\n\t\tlock_buffer(bh);\n\t\tgfs2_log_lock(sdp);\n\t}\n\tgfs2_assert(sdp, bd->bd_gl == gl);\n\tmeta_lo_add(sdp, bd);\n\tgfs2_log_unlock(sdp);\n\tunlock_buffer(bh);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_trans_add_meta(struct gfs2_glock *gl, struct buffer_head *bh)\n{\n\n\tstruct gfs2_sbd *sdp = gl->gl_sbd;\n\tstruct gfs2_bufdata *bd;\n\n\tlock_buffer(bh);\n\tgfs2_log_lock(sdp);\n\tbd = bh->b_private;\n\tif (bd == NULL) {\n\t\tgfs2_log_unlock(sdp);\n\t\tunlock_buffer(bh);\n\t\tlock_page(bh->b_page);\n\t\tif (bh->b_private == NULL)\n\t\t\tbd = gfs2_alloc_bufdata(gl, bh, &gfs2_buf_lops);\n\t\tunlock_page(bh->b_page);\n\t\tlock_buffer(bh);\n\t\tgfs2_log_lock(sdp);\n\t}\n\tgfs2_assert(sdp, bd->bd_gl == gl);\n\tmeta_lo_add(sdp, bd);\n\tgfs2_log_unlock(sdp);\n\tunlock_buffer(bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_meta_inode_buffer",
          "args": [
            "ip",
            "&dibh"
          ],
          "line": 753
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_meta_inode_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/meta_io.h",
          "lines": "66-70",
          "snippet": "static inline int gfs2_meta_inode_buffer(struct gfs2_inode *ip,\n\t\t\t\t\t struct buffer_head **bhp)\n{\n\treturn gfs2_meta_indirect_buffer(ip, 0, ip->i_no_addr, bhp);\n}",
          "includes": [
            "#include \"incore.h\"",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"incore.h\"\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline int gfs2_meta_inode_buffer(struct gfs2_inode *ip,\n\t\t\t\t\t struct buffer_head **bhp)\n{\n\treturn gfs2_meta_indirect_buffer(ip, 0, ip->i_no_addr, bhp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "skeleton_call",
          "args": [
            "ip",
            "er",
            "private"
          ],
          "line": 749
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_trans_begin",
          "args": [
            "GFS2_SB(&ip->i_inode)",
            "blks + gfs2_rg_blocks(ip, blks) +\n\t\t\t\t RES_DINODE + RES_STATFS + RES_QUOTA",
            "0"
          ],
          "line": 743
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_trans_begin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/trans.c",
          "lines": "31-75",
          "snippet": "int gfs2_trans_begin(struct gfs2_sbd *sdp, unsigned int blocks,\n\t\t     unsigned int revokes)\n{\n\tstruct gfs2_trans *tr;\n\tint error;\n\n\tBUG_ON(current->journal_info);\n\tBUG_ON(blocks == 0 && revokes == 0);\n\n\tif (!test_bit(SDF_JOURNAL_LIVE, &sdp->sd_flags))\n\t\treturn -EROFS;\n\n\ttr = kzalloc(sizeof(struct gfs2_trans), GFP_NOFS);\n\tif (!tr)\n\t\treturn -ENOMEM;\n\n\ttr->tr_ip = _RET_IP_;\n\ttr->tr_blocks = blocks;\n\ttr->tr_revokes = revokes;\n\ttr->tr_reserved = 1;\n\ttr->tr_alloced = 1;\n\tif (blocks)\n\t\ttr->tr_reserved += 6 + blocks;\n\tif (revokes)\n\t\ttr->tr_reserved += gfs2_struct2blk(sdp, revokes,\n\t\t\t\t\t\t   sizeof(u64));\n\tINIT_LIST_HEAD(&tr->tr_databuf);\n\tINIT_LIST_HEAD(&tr->tr_buf);\n\n\tsb_start_intwrite(sdp->sd_vfs);\n\n\terror = gfs2_log_reserve(sdp, tr->tr_reserved);\n\tif (error)\n\t\tgoto fail;\n\n\tcurrent->journal_info = tr;\n\n\treturn 0;\n\nfail:\n\tsb_end_intwrite(sdp->sd_vfs);\n\tkfree(tr);\n\n\treturn error;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nint gfs2_trans_begin(struct gfs2_sbd *sdp, unsigned int blocks,\n\t\t     unsigned int revokes)\n{\n\tstruct gfs2_trans *tr;\n\tint error;\n\n\tBUG_ON(current->journal_info);\n\tBUG_ON(blocks == 0 && revokes == 0);\n\n\tif (!test_bit(SDF_JOURNAL_LIVE, &sdp->sd_flags))\n\t\treturn -EROFS;\n\n\ttr = kzalloc(sizeof(struct gfs2_trans), GFP_NOFS);\n\tif (!tr)\n\t\treturn -ENOMEM;\n\n\ttr->tr_ip = _RET_IP_;\n\ttr->tr_blocks = blocks;\n\ttr->tr_revokes = revokes;\n\ttr->tr_reserved = 1;\n\ttr->tr_alloced = 1;\n\tif (blocks)\n\t\ttr->tr_reserved += 6 + blocks;\n\tif (revokes)\n\t\ttr->tr_reserved += gfs2_struct2blk(sdp, revokes,\n\t\t\t\t\t\t   sizeof(u64));\n\tINIT_LIST_HEAD(&tr->tr_databuf);\n\tINIT_LIST_HEAD(&tr->tr_buf);\n\n\tsb_start_intwrite(sdp->sd_vfs);\n\n\terror = gfs2_log_reserve(sdp, tr->tr_reserved);\n\tif (error)\n\t\tgoto fail;\n\n\tcurrent->journal_info = tr;\n\n\treturn 0;\n\nfail:\n\tsb_end_intwrite(sdp->sd_vfs);\n\tkfree(tr);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_rg_blocks",
          "args": [
            "ip",
            "blks"
          ],
          "line": 744
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_rg_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/trans.h",
          "lines": "31-36",
          "snippet": "static inline unsigned int gfs2_rg_blocks(const struct gfs2_inode *ip, unsigned requested)\n{\n\tif (requested < ip->i_rgd->rd_length)\n\t\treturn requested + 1;\n\treturn ip->i_rgd->rd_length;\n}",
          "includes": [
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n\nstatic inline unsigned int gfs2_rg_blocks(const struct gfs2_inode *ip, unsigned requested)\n{\n\tif (requested < ip->i_rgd->rd_length)\n\t\treturn requested + 1;\n\treturn ip->i_rgd->rd_length;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_inplace_reserve",
          "args": [
            "ip",
            "&ap"
          ],
          "line": 739
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_inplace_reserve",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
          "lines": "1952-2072",
          "snippet": "int gfs2_inplace_reserve(struct gfs2_inode *ip, const struct gfs2_alloc_parms *ap)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tstruct gfs2_rgrpd *begin = NULL;\n\tstruct gfs2_blkreserv *rs = ip->i_res;\n\tint error = 0, rg_locked, flags = 0;\n\tu64 last_unlinked = NO_BLOCK;\n\tint loops = 0;\n\tu32 skip = 0;\n\n\tif (sdp->sd_args.ar_rgrplvb)\n\t\tflags |= GL_SKIP;\n\tif (gfs2_assert_warn(sdp, ap->target))\n\t\treturn -EINVAL;\n\tif (gfs2_rs_active(rs)) {\n\t\tbegin = rs->rs_rbm.rgd;\n\t} else if (ip->i_rgd && rgrp_contains_block(ip->i_rgd, ip->i_goal)) {\n\t\trs->rs_rbm.rgd = begin = ip->i_rgd;\n\t} else {\n\t\tcheck_and_update_goal(ip);\n\t\trs->rs_rbm.rgd = begin = gfs2_blk2rgrpd(sdp, ip->i_goal, 1);\n\t}\n\tif (S_ISDIR(ip->i_inode.i_mode) && (ap->aflags & GFS2_AF_ORLOV))\n\t\tskip = gfs2_orlov_skip(ip);\n\tif (rs->rs_rbm.rgd == NULL)\n\t\treturn -EBADSLT;\n\n\twhile (loops < 3) {\n\t\trg_locked = 1;\n\n\t\tif (!gfs2_glock_is_locked_by_me(rs->rs_rbm.rgd->rd_gl)) {\n\t\t\trg_locked = 0;\n\t\t\tif (skip && skip--)\n\t\t\t\tgoto next_rgrp;\n\t\t\tif (!gfs2_rs_active(rs)) {\n\t\t\t\tif (loops == 0 &&\n\t\t\t\t    !fast_to_acquire(rs->rs_rbm.rgd))\n\t\t\t\t\tgoto next_rgrp;\n\t\t\t\tif ((loops < 2) &&\n\t\t\t\t    gfs2_rgrp_used_recently(rs, 1000) &&\n\t\t\t\t    gfs2_rgrp_congested(rs->rs_rbm.rgd, loops))\n\t\t\t\t\tgoto next_rgrp;\n\t\t\t}\n\t\t\terror = gfs2_glock_nq_init(rs->rs_rbm.rgd->rd_gl,\n\t\t\t\t\t\t   LM_ST_EXCLUSIVE, flags,\n\t\t\t\t\t\t   &rs->rs_rgd_gh);\n\t\t\tif (unlikely(error))\n\t\t\t\treturn error;\n\t\t\tif (!gfs2_rs_active(rs) && (loops < 2) &&\n\t\t\t    gfs2_rgrp_congested(rs->rs_rbm.rgd, loops))\n\t\t\t\tgoto skip_rgrp;\n\t\t\tif (sdp->sd_args.ar_rgrplvb) {\n\t\t\t\terror = update_rgrp_lvb(rs->rs_rbm.rgd);\n\t\t\t\tif (unlikely(error)) {\n\t\t\t\t\tgfs2_glock_dq_uninit(&rs->rs_rgd_gh);\n\t\t\t\t\treturn error;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/* Skip unuseable resource groups */\n\t\tif ((rs->rs_rbm.rgd->rd_flags & (GFS2_RGF_NOALLOC |\n\t\t\t\t\t\t GFS2_RDF_ERROR)) ||\n\t\t    (ap->target > rs->rs_rbm.rgd->rd_extfail_pt))\n\t\t\tgoto skip_rgrp;\n\n\t\tif (sdp->sd_args.ar_rgrplvb)\n\t\t\tgfs2_rgrp_bh_get(rs->rs_rbm.rgd);\n\n\t\t/* Get a reservation if we don't already have one */\n\t\tif (!gfs2_rs_active(rs))\n\t\t\trg_mblk_search(rs->rs_rbm.rgd, ip, ap);\n\n\t\t/* Skip rgrps when we can't get a reservation on first pass */\n\t\tif (!gfs2_rs_active(rs) && (loops < 1))\n\t\t\tgoto check_rgrp;\n\n\t\t/* If rgrp has enough free space, use it */\n\t\tif (rs->rs_rbm.rgd->rd_free_clone >= ap->target) {\n\t\t\tip->i_rgd = rs->rs_rbm.rgd;\n\t\t\treturn 0;\n\t\t}\n\ncheck_rgrp:\n\t\t/* Check for unlinked inodes which can be reclaimed */\n\t\tif (rs->rs_rbm.rgd->rd_flags & GFS2_RDF_CHECK)\n\t\t\ttry_rgrp_unlink(rs->rs_rbm.rgd, &last_unlinked,\n\t\t\t\t\tip->i_no_addr);\nskip_rgrp:\n\t\t/* Drop reservation, if we couldn't use reserved rgrp */\n\t\tif (gfs2_rs_active(rs))\n\t\t\tgfs2_rs_deltree(rs);\n\n\t\t/* Unlock rgrp if required */\n\t\tif (!rg_locked)\n\t\t\tgfs2_glock_dq_uninit(&rs->rs_rgd_gh);\nnext_rgrp:\n\t\t/* Find the next rgrp, and continue looking */\n\t\tif (gfs2_select_rgrp(&rs->rs_rbm.rgd, begin))\n\t\t\tcontinue;\n\t\tif (skip)\n\t\t\tcontinue;\n\n\t\t/* If we've scanned all the rgrps, but found no free blocks\n\t\t * then this checks for some less likely conditions before\n\t\t * trying again.\n\t\t */\n\t\tloops++;\n\t\t/* Check that fs hasn't grown if writing to rindex */\n\t\tif (ip == GFS2_I(sdp->sd_rindex) && !sdp->sd_rindex_uptodate) {\n\t\t\terror = gfs2_ri_update(ip);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t}\n\t\t/* Flushing the log may release space */\n\t\tif (loops == 2)\n\t\t\tgfs2_log_flush(sdp, NULL, NORMAL_FLUSH);\n\t}\n\n\treturn -ENOSPC;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"inode.h\"",
            "#include \"log.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/random.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [
            "#define NO_BLOCK ((u64)~0)"
          ],
          "globals_used": [
            "static int gfs2_rbm_find(struct gfs2_rbm *rbm, u8 state, u32 *minext,\n\t\t\t const struct gfs2_inode *ip, bool nowrap,\n\t\t\t const struct gfs2_alloc_parms *ap);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\n#define NO_BLOCK ((u64)~0)\n\nstatic int gfs2_rbm_find(struct gfs2_rbm *rbm, u8 state, u32 *minext,\n\t\t\t const struct gfs2_inode *ip, bool nowrap,\n\t\t\t const struct gfs2_alloc_parms *ap);\n\nint gfs2_inplace_reserve(struct gfs2_inode *ip, const struct gfs2_alloc_parms *ap)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tstruct gfs2_rgrpd *begin = NULL;\n\tstruct gfs2_blkreserv *rs = ip->i_res;\n\tint error = 0, rg_locked, flags = 0;\n\tu64 last_unlinked = NO_BLOCK;\n\tint loops = 0;\n\tu32 skip = 0;\n\n\tif (sdp->sd_args.ar_rgrplvb)\n\t\tflags |= GL_SKIP;\n\tif (gfs2_assert_warn(sdp, ap->target))\n\t\treturn -EINVAL;\n\tif (gfs2_rs_active(rs)) {\n\t\tbegin = rs->rs_rbm.rgd;\n\t} else if (ip->i_rgd && rgrp_contains_block(ip->i_rgd, ip->i_goal)) {\n\t\trs->rs_rbm.rgd = begin = ip->i_rgd;\n\t} else {\n\t\tcheck_and_update_goal(ip);\n\t\trs->rs_rbm.rgd = begin = gfs2_blk2rgrpd(sdp, ip->i_goal, 1);\n\t}\n\tif (S_ISDIR(ip->i_inode.i_mode) && (ap->aflags & GFS2_AF_ORLOV))\n\t\tskip = gfs2_orlov_skip(ip);\n\tif (rs->rs_rbm.rgd == NULL)\n\t\treturn -EBADSLT;\n\n\twhile (loops < 3) {\n\t\trg_locked = 1;\n\n\t\tif (!gfs2_glock_is_locked_by_me(rs->rs_rbm.rgd->rd_gl)) {\n\t\t\trg_locked = 0;\n\t\t\tif (skip && skip--)\n\t\t\t\tgoto next_rgrp;\n\t\t\tif (!gfs2_rs_active(rs)) {\n\t\t\t\tif (loops == 0 &&\n\t\t\t\t    !fast_to_acquire(rs->rs_rbm.rgd))\n\t\t\t\t\tgoto next_rgrp;\n\t\t\t\tif ((loops < 2) &&\n\t\t\t\t    gfs2_rgrp_used_recently(rs, 1000) &&\n\t\t\t\t    gfs2_rgrp_congested(rs->rs_rbm.rgd, loops))\n\t\t\t\t\tgoto next_rgrp;\n\t\t\t}\n\t\t\terror = gfs2_glock_nq_init(rs->rs_rbm.rgd->rd_gl,\n\t\t\t\t\t\t   LM_ST_EXCLUSIVE, flags,\n\t\t\t\t\t\t   &rs->rs_rgd_gh);\n\t\t\tif (unlikely(error))\n\t\t\t\treturn error;\n\t\t\tif (!gfs2_rs_active(rs) && (loops < 2) &&\n\t\t\t    gfs2_rgrp_congested(rs->rs_rbm.rgd, loops))\n\t\t\t\tgoto skip_rgrp;\n\t\t\tif (sdp->sd_args.ar_rgrplvb) {\n\t\t\t\terror = update_rgrp_lvb(rs->rs_rbm.rgd);\n\t\t\t\tif (unlikely(error)) {\n\t\t\t\t\tgfs2_glock_dq_uninit(&rs->rs_rgd_gh);\n\t\t\t\t\treturn error;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/* Skip unuseable resource groups */\n\t\tif ((rs->rs_rbm.rgd->rd_flags & (GFS2_RGF_NOALLOC |\n\t\t\t\t\t\t GFS2_RDF_ERROR)) ||\n\t\t    (ap->target > rs->rs_rbm.rgd->rd_extfail_pt))\n\t\t\tgoto skip_rgrp;\n\n\t\tif (sdp->sd_args.ar_rgrplvb)\n\t\t\tgfs2_rgrp_bh_get(rs->rs_rbm.rgd);\n\n\t\t/* Get a reservation if we don't already have one */\n\t\tif (!gfs2_rs_active(rs))\n\t\t\trg_mblk_search(rs->rs_rbm.rgd, ip, ap);\n\n\t\t/* Skip rgrps when we can't get a reservation on first pass */\n\t\tif (!gfs2_rs_active(rs) && (loops < 1))\n\t\t\tgoto check_rgrp;\n\n\t\t/* If rgrp has enough free space, use it */\n\t\tif (rs->rs_rbm.rgd->rd_free_clone >= ap->target) {\n\t\t\tip->i_rgd = rs->rs_rbm.rgd;\n\t\t\treturn 0;\n\t\t}\n\ncheck_rgrp:\n\t\t/* Check for unlinked inodes which can be reclaimed */\n\t\tif (rs->rs_rbm.rgd->rd_flags & GFS2_RDF_CHECK)\n\t\t\ttry_rgrp_unlink(rs->rs_rbm.rgd, &last_unlinked,\n\t\t\t\t\tip->i_no_addr);\nskip_rgrp:\n\t\t/* Drop reservation, if we couldn't use reserved rgrp */\n\t\tif (gfs2_rs_active(rs))\n\t\t\tgfs2_rs_deltree(rs);\n\n\t\t/* Unlock rgrp if required */\n\t\tif (!rg_locked)\n\t\t\tgfs2_glock_dq_uninit(&rs->rs_rgd_gh);\nnext_rgrp:\n\t\t/* Find the next rgrp, and continue looking */\n\t\tif (gfs2_select_rgrp(&rs->rs_rbm.rgd, begin))\n\t\t\tcontinue;\n\t\tif (skip)\n\t\t\tcontinue;\n\n\t\t/* If we've scanned all the rgrps, but found no free blocks\n\t\t * then this checks for some less likely conditions before\n\t\t * trying again.\n\t\t */\n\t\tloops++;\n\t\t/* Check that fs hasn't grown if writing to rindex */\n\t\tif (ip == GFS2_I(sdp->sd_rindex) && !sdp->sd_rindex_uptodate) {\n\t\t\terror = gfs2_ri_update(ip);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t}\n\t\t/* Flushing the log may release space */\n\t\tif (loops == 2)\n\t\t\tgfs2_log_flush(sdp, NULL, NORMAL_FLUSH);\n\t}\n\n\treturn -ENOSPC;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_quota_lock_check",
          "args": [
            "ip"
          ],
          "line": 735
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_quota_lock_check",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.h",
          "lines": "40-55",
          "snippet": "static inline int gfs2_quota_lock_check(struct gfs2_inode *ip)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tint ret;\n\tif (sdp->sd_args.ar_quota == GFS2_QUOTA_OFF)\n\t\treturn 0;\n\tret = gfs2_quota_lock(ip, NO_UID_QUOTA_CHANGE, NO_GID_QUOTA_CHANGE);\n\tif (ret)\n\t\treturn ret;\n\tif (sdp->sd_args.ar_quota != GFS2_QUOTA_ON)\n\t\treturn 0;\n\tret = gfs2_quota_check(ip, ip->i_inode.i_uid, ip->i_inode.i_gid);\n\tif (ret)\n\t\tgfs2_quota_unlock(ip);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/list_lru.h>"
          ],
          "macros_used": [
            "#define NO_GID_QUOTA_CHANGE INVALID_GID",
            "#define NO_UID_QUOTA_CHANGE INVALID_UID"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/list_lru.h>\n\n#define NO_GID_QUOTA_CHANGE INVALID_GID\n#define NO_UID_QUOTA_CHANGE INVALID_UID\n\nstatic inline int gfs2_quota_lock_check(struct gfs2_inode *ip)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tint ret;\n\tif (sdp->sd_args.ar_quota == GFS2_QUOTA_OFF)\n\t\treturn 0;\n\tret = gfs2_quota_lock(ip, NO_UID_QUOTA_CHANGE, NO_GID_QUOTA_CHANGE);\n\tif (ret)\n\t\treturn ret;\n\tif (sdp->sd_args.ar_quota != GFS2_QUOTA_ON)\n\t\treturn 0;\n\tret = gfs2_quota_check(ip, ip->i_inode.i_uid, ip->i_inode.i_gid);\n\tif (ret)\n\t\tgfs2_quota_unlock(ip);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_rindex_update",
          "args": [
            "GFS2_SB(&ip->i_inode)"
          ],
          "line": 731
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_rindex_update",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
          "lines": "1029-1052",
          "snippet": "int gfs2_rindex_update(struct gfs2_sbd *sdp)\n{\n\tstruct gfs2_inode *ip = GFS2_I(sdp->sd_rindex);\n\tstruct gfs2_glock *gl = ip->i_gl;\n\tstruct gfs2_holder ri_gh;\n\tint error = 0;\n\tint unlock_required = 0;\n\n\t/* Read new copy from disk if we don't have the latest */\n\tif (!sdp->sd_rindex_uptodate) {\n\t\tif (!gfs2_glock_is_locked_by_me(gl)) {\n\t\t\terror = gfs2_glock_nq_init(gl, LM_ST_SHARED, 0, &ri_gh);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\tunlock_required = 1;\n\t\t}\n\t\tif (!sdp->sd_rindex_uptodate)\n\t\t\terror = gfs2_ri_update(ip);\n\t\tif (unlock_required)\n\t\t\tgfs2_glock_dq_uninit(&ri_gh);\n\t}\n\n\treturn error;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"inode.h\"",
            "#include \"log.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/random.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nint gfs2_rindex_update(struct gfs2_sbd *sdp)\n{\n\tstruct gfs2_inode *ip = GFS2_I(sdp->sd_rindex);\n\tstruct gfs2_glock *gl = ip->i_gl;\n\tstruct gfs2_holder ri_gh;\n\tint error = 0;\n\tint unlock_required = 0;\n\n\t/* Read new copy from disk if we don't have the latest */\n\tif (!sdp->sd_rindex_uptodate) {\n\t\tif (!gfs2_glock_is_locked_by_me(gl)) {\n\t\t\terror = gfs2_glock_nq_init(gl, LM_ST_SHARED, 0, &ri_gh);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\tunlock_required = 1;\n\t\t}\n\t\tif (!sdp->sd_rindex_uptodate)\n\t\t\terror = gfs2_ri_update(ip);\n\t\tif (unlock_required)\n\t\t\tgfs2_glock_dq_uninit(&ri_gh);\n\t}\n\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic int ea_alloc_skeleton(struct gfs2_inode *ip, struct gfs2_ea_request *er,\n\t\t\t     unsigned int blks,\n\t\t\t     ea_skeleton_call_t skeleton_call, void *private)\n{\n\tstruct gfs2_alloc_parms ap = { .target = blks };\n\tstruct buffer_head *dibh;\n\tint error;\n\n\terror = gfs2_rindex_update(GFS2_SB(&ip->i_inode));\n\tif (error)\n\t\treturn error;\n\n\terror = gfs2_quota_lock_check(ip);\n\tif (error)\n\t\treturn error;\n\n\terror = gfs2_inplace_reserve(ip, &ap);\n\tif (error)\n\t\tgoto out_gunlock_q;\n\n\terror = gfs2_trans_begin(GFS2_SB(&ip->i_inode),\n\t\t\t\t blks + gfs2_rg_blocks(ip, blks) +\n\t\t\t\t RES_DINODE + RES_STATFS + RES_QUOTA, 0);\n\tif (error)\n\t\tgoto out_ipres;\n\n\terror = skeleton_call(ip, er, private);\n\tif (error)\n\t\tgoto out_end_trans;\n\n\terror = gfs2_meta_inode_buffer(ip, &dibh);\n\tif (!error) {\n\t\tip->i_inode.i_ctime = CURRENT_TIME;\n\t\tgfs2_trans_add_meta(ip->i_gl, dibh);\n\t\tgfs2_dinode_out(ip, dibh->b_data);\n\t\tbrelse(dibh);\n\t}\n\nout_end_trans:\n\tgfs2_trans_end(GFS2_SB(&ip->i_inode));\nout_ipres:\n\tgfs2_inplace_release(ip);\nout_gunlock_q:\n\tgfs2_quota_unlock(ip);\n\treturn error;\n}"
  },
  {
    "function_name": "ea_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
    "lines": "660-718",
    "snippet": "static int ea_write(struct gfs2_inode *ip, struct gfs2_ea_header *ea,\n\t\t    struct gfs2_ea_request *er)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tint error;\n\n\tea->ea_data_len = cpu_to_be32(er->er_data_len);\n\tea->ea_name_len = er->er_name_len;\n\tea->ea_type = er->er_type;\n\tea->__pad = 0;\n\n\tmemcpy(GFS2_EA2NAME(ea), er->er_name, er->er_name_len);\n\n\tif (GFS2_EAREQ_SIZE_STUFFED(er) <= sdp->sd_jbsize) {\n\t\tea->ea_num_ptrs = 0;\n\t\tmemcpy(GFS2_EA2DATA(ea), er->er_data, er->er_data_len);\n\t} else {\n\t\t__be64 *dataptr = GFS2_EA2DATAPTRS(ea);\n\t\tconst char *data = er->er_data;\n\t\tunsigned int data_len = er->er_data_len;\n\t\tunsigned int copy;\n\t\tunsigned int x;\n\n\t\tea->ea_num_ptrs = DIV_ROUND_UP(er->er_data_len, sdp->sd_jbsize);\n\t\tfor (x = 0; x < ea->ea_num_ptrs; x++) {\n\t\t\tstruct buffer_head *bh;\n\t\t\tu64 block;\n\t\t\tint mh_size = sizeof(struct gfs2_meta_header);\n\t\t\tunsigned int n = 1;\n\n\t\t\terror = gfs2_alloc_blocks(ip, &block, &n, 0, NULL);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\tgfs2_trans_add_unrevoke(sdp, block, 1);\n\t\t\tbh = gfs2_meta_new(ip->i_gl, block);\n\t\t\tgfs2_trans_add_meta(ip->i_gl, bh);\n\t\t\tgfs2_metatype_set(bh, GFS2_METATYPE_ED, GFS2_FORMAT_ED);\n\n\t\t\tgfs2_add_inode_blocks(&ip->i_inode, 1);\n\n\t\t\tcopy = data_len > sdp->sd_jbsize ? sdp->sd_jbsize :\n\t\t\t\t\t\t\t   data_len;\n\t\t\tmemcpy(bh->b_data + mh_size, data, copy);\n\t\t\tif (copy < sdp->sd_jbsize)\n\t\t\t\tmemset(bh->b_data + mh_size + copy, 0,\n\t\t\t\t       sdp->sd_jbsize - copy);\n\n\t\t\t*dataptr++ = cpu_to_be64(bh->b_blocknr);\n\t\t\tdata += copy;\n\t\t\tdata_len -= copy;\n\n\t\t\tbrelse(bh);\n\t\t}\n\n\t\tgfs2_assert_withdraw(sdp, !data_len);\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"trans.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"inode.h\"",
      "#include \"glock.h\"",
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/xattr.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "gfs2_assert_withdraw",
          "args": [
            "sdp",
            "!data_len"
          ],
          "line": 714
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 711
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "bh->b_blocknr"
          ],
          "line": 707
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "bh->b_data + mh_size + copy",
            "0",
            "sdp->sd_jbsize - copy"
          ],
          "line": 704
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "bh->b_data + mh_size",
            "data",
            "copy"
          ],
          "line": 702
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_add_inode_blocks",
          "args": [
            "&ip->i_inode",
            "1"
          ],
          "line": 698
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_add_inode_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/inode.h",
          "lines": "62-67",
          "snippet": "static inline void gfs2_add_inode_blocks(struct inode *inode, s64 change)\n{\n\tgfs2_assert(GFS2_SB(inode), (change >= 0 || inode->i_blocks > -change));\n\tchange *= (GFS2_SB(inode)->sd_sb.sb_bsize/GFS2_BASIC_BLOCK);\n\tinode->i_blocks += change;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include <linux/mm.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <linux/mm.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic inline void gfs2_add_inode_blocks(struct inode *inode, s64 change)\n{\n\tgfs2_assert(GFS2_SB(inode), (change >= 0 || inode->i_blocks > -change));\n\tchange *= (GFS2_SB(inode)->sd_sb.sb_bsize/GFS2_BASIC_BLOCK);\n\tinode->i_blocks += change;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_metatype_set",
          "args": [
            "bh",
            "GFS2_METATYPE_ED",
            "GFS2_FORMAT_ED"
          ],
          "line": 696
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_metatype_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/util.h",
          "lines": "122-129",
          "snippet": "static inline void gfs2_metatype_set(struct buffer_head *bh, u16 type,\n\t\t\t\t     u16 format)\n{\n\tstruct gfs2_meta_header *mh;\n\tmh = (struct gfs2_meta_header *)bh->b_data;\n\tmh->mh_type = cpu_to_be32(type);\n\tmh->mh_format = cpu_to_be32(format);\n}",
          "includes": [
            "#include \"incore.h\"",
            "#include <linux/mempool.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"incore.h\"\n#include <linux/mempool.h>\n\nstatic inline void gfs2_metatype_set(struct buffer_head *bh, u16 type,\n\t\t\t\t     u16 format)\n{\n\tstruct gfs2_meta_header *mh;\n\tmh = (struct gfs2_meta_header *)bh->b_data;\n\tmh->mh_type = cpu_to_be32(type);\n\tmh->mh_format = cpu_to_be32(format);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_trans_add_meta",
          "args": [
            "ip->i_gl",
            "bh"
          ],
          "line": 695
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_trans_add_meta",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/trans.c",
          "lines": "224-247",
          "snippet": "void gfs2_trans_add_meta(struct gfs2_glock *gl, struct buffer_head *bh)\n{\n\n\tstruct gfs2_sbd *sdp = gl->gl_sbd;\n\tstruct gfs2_bufdata *bd;\n\n\tlock_buffer(bh);\n\tgfs2_log_lock(sdp);\n\tbd = bh->b_private;\n\tif (bd == NULL) {\n\t\tgfs2_log_unlock(sdp);\n\t\tunlock_buffer(bh);\n\t\tlock_page(bh->b_page);\n\t\tif (bh->b_private == NULL)\n\t\t\tbd = gfs2_alloc_bufdata(gl, bh, &gfs2_buf_lops);\n\t\tunlock_page(bh->b_page);\n\t\tlock_buffer(bh);\n\t\tgfs2_log_lock(sdp);\n\t}\n\tgfs2_assert(sdp, bd->bd_gl == gl);\n\tmeta_lo_add(sdp, bd);\n\tgfs2_log_unlock(sdp);\n\tunlock_buffer(bh);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_trans_add_meta(struct gfs2_glock *gl, struct buffer_head *bh)\n{\n\n\tstruct gfs2_sbd *sdp = gl->gl_sbd;\n\tstruct gfs2_bufdata *bd;\n\n\tlock_buffer(bh);\n\tgfs2_log_lock(sdp);\n\tbd = bh->b_private;\n\tif (bd == NULL) {\n\t\tgfs2_log_unlock(sdp);\n\t\tunlock_buffer(bh);\n\t\tlock_page(bh->b_page);\n\t\tif (bh->b_private == NULL)\n\t\t\tbd = gfs2_alloc_bufdata(gl, bh, &gfs2_buf_lops);\n\t\tunlock_page(bh->b_page);\n\t\tlock_buffer(bh);\n\t\tgfs2_log_lock(sdp);\n\t}\n\tgfs2_assert(sdp, bd->bd_gl == gl);\n\tmeta_lo_add(sdp, bd);\n\tgfs2_log_unlock(sdp);\n\tunlock_buffer(bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_meta_new",
          "args": [
            "ip->i_gl",
            "block"
          ],
          "line": 694
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_meta_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/meta_io.c",
          "lines": "182-188",
          "snippet": "struct buffer_head *gfs2_meta_new(struct gfs2_glock *gl, u64 blkno)\n{\n\tstruct buffer_head *bh;\n\tbh = gfs2_getbuf(gl, blkno, CREATE);\n\tmeta_prep_new(bh);\n\treturn bh;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/delay.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/delay.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstruct buffer_head *gfs2_meta_new(struct gfs2_glock *gl, u64 blkno)\n{\n\tstruct buffer_head *bh;\n\tbh = gfs2_getbuf(gl, blkno, CREATE);\n\tmeta_prep_new(bh);\n\treturn bh;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_trans_add_unrevoke",
          "args": [
            "sdp",
            "block",
            "1"
          ],
          "line": 693
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_trans_add_unrevoke",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/trans.c",
          "lines": "259-278",
          "snippet": "void gfs2_trans_add_unrevoke(struct gfs2_sbd *sdp, u64 blkno, unsigned int len)\n{\n\tstruct gfs2_bufdata *bd, *tmp;\n\tstruct gfs2_trans *tr = current->journal_info;\n\tunsigned int n = len;\n\n\tgfs2_log_lock(sdp);\n\tlist_for_each_entry_safe(bd, tmp, &sdp->sd_log_le_revoke, bd_list) {\n\t\tif ((bd->bd_blkno >= blkno) && (bd->bd_blkno < (blkno + len))) {\n\t\t\tlist_del_init(&bd->bd_list);\n\t\t\tgfs2_assert_withdraw(sdp, sdp->sd_log_num_revoke);\n\t\t\tsdp->sd_log_num_revoke--;\n\t\t\tkmem_cache_free(gfs2_bufdata_cachep, bd);\n\t\t\ttr->tr_num_revoke_rm++;\n\t\t\tif (--n == 0)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tgfs2_log_unlock(sdp);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_trans_add_unrevoke(struct gfs2_sbd *sdp, u64 blkno, unsigned int len)\n{\n\tstruct gfs2_bufdata *bd, *tmp;\n\tstruct gfs2_trans *tr = current->journal_info;\n\tunsigned int n = len;\n\n\tgfs2_log_lock(sdp);\n\tlist_for_each_entry_safe(bd, tmp, &sdp->sd_log_le_revoke, bd_list) {\n\t\tif ((bd->bd_blkno >= blkno) && (bd->bd_blkno < (blkno + len))) {\n\t\t\tlist_del_init(&bd->bd_list);\n\t\t\tgfs2_assert_withdraw(sdp, sdp->sd_log_num_revoke);\n\t\t\tsdp->sd_log_num_revoke--;\n\t\t\tkmem_cache_free(gfs2_bufdata_cachep, bd);\n\t\t\ttr->tr_num_revoke_rm++;\n\t\t\tif (--n == 0)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tgfs2_log_unlock(sdp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_alloc_blocks",
          "args": [
            "ip",
            "&block",
            "&n",
            "0",
            "NULL"
          ],
          "line": 690
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_alloc_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
          "lines": "2304-2385",
          "snippet": "int gfs2_alloc_blocks(struct gfs2_inode *ip, u64 *bn, unsigned int *nblocks,\n\t\t      bool dinode, u64 *generation)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tstruct buffer_head *dibh;\n\tstruct gfs2_rbm rbm = { .rgd = ip->i_rgd, };\n\tunsigned int ndata;\n\tu64 block; /* block, within the file system scope */\n\tint error;\n\n\tgfs2_set_alloc_start(&rbm, ip, dinode);\n\terror = gfs2_rbm_find(&rbm, GFS2_BLKST_FREE, NULL, ip, false, NULL);\n\n\tif (error == -ENOSPC) {\n\t\tgfs2_set_alloc_start(&rbm, ip, dinode);\n\t\terror = gfs2_rbm_find(&rbm, GFS2_BLKST_FREE, NULL, NULL, false,\n\t\t\t\t      NULL);\n\t}\n\n\t/* Since all blocks are reserved in advance, this shouldn't happen */\n\tif (error) {\n\t\tfs_warn(sdp, \"inum=%llu error=%d, nblocks=%u, full=%d fail_pt=%d\\n\",\n\t\t\t(unsigned long long)ip->i_no_addr, error, *nblocks,\n\t\t\ttest_bit(GBF_FULL, &rbm.rgd->rd_bits->bi_flags),\n\t\t\trbm.rgd->rd_extfail_pt);\n\t\tgoto rgrp_error;\n\t}\n\n\tgfs2_alloc_extent(&rbm, dinode, nblocks);\n\tblock = gfs2_rbm_to_block(&rbm);\n\trbm.rgd->rd_last_alloc = block - rbm.rgd->rd_data0;\n\tif (gfs2_rs_active(ip->i_res))\n\t\tgfs2_adjust_reservation(ip, &rbm, *nblocks);\n\tndata = *nblocks;\n\tif (dinode)\n\t\tndata--;\n\n\tif (!dinode) {\n\t\tip->i_goal = block + ndata - 1;\n\t\terror = gfs2_meta_inode_buffer(ip, &dibh);\n\t\tif (error == 0) {\n\t\t\tstruct gfs2_dinode *di =\n\t\t\t\t(struct gfs2_dinode *)dibh->b_data;\n\t\t\tgfs2_trans_add_meta(ip->i_gl, dibh);\n\t\t\tdi->di_goal_meta = di->di_goal_data =\n\t\t\t\tcpu_to_be64(ip->i_goal);\n\t\t\tbrelse(dibh);\n\t\t}\n\t}\n\tif (rbm.rgd->rd_free < *nblocks) {\n\t\tpr_warn(\"nblocks=%u\\n\", *nblocks);\n\t\tgoto rgrp_error;\n\t}\n\n\trbm.rgd->rd_free -= *nblocks;\n\tif (dinode) {\n\t\trbm.rgd->rd_dinodes++;\n\t\t*generation = rbm.rgd->rd_igeneration++;\n\t\tif (*generation == 0)\n\t\t\t*generation = rbm.rgd->rd_igeneration++;\n\t}\n\n\tgfs2_trans_add_meta(rbm.rgd->rd_gl, rbm.rgd->rd_bits[0].bi_bh);\n\tgfs2_rgrp_out(rbm.rgd, rbm.rgd->rd_bits[0].bi_bh->b_data);\n\tgfs2_rgrp_ondisk2lvb(rbm.rgd->rd_rgl, rbm.rgd->rd_bits[0].bi_bh->b_data);\n\n\tgfs2_statfs_change(sdp, 0, -(s64)*nblocks, dinode ? 1 : 0);\n\tif (dinode)\n\t\tgfs2_trans_add_unrevoke(sdp, block, *nblocks);\n\n\tgfs2_quota_change(ip, *nblocks, ip->i_inode.i_uid, ip->i_inode.i_gid);\n\n\trbm.rgd->rd_free_clone -= *nblocks;\n\ttrace_gfs2_block_alloc(ip, rbm.rgd, block, *nblocks,\n\t\t\t       dinode ? GFS2_BLKST_DINODE : GFS2_BLKST_USED);\n\t*bn = block;\n\treturn 0;\n\nrgrp_error:\n\tgfs2_rgrp_error(rbm.rgd);\n\treturn -EIO;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"inode.h\"",
            "#include \"log.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/random.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nint gfs2_alloc_blocks(struct gfs2_inode *ip, u64 *bn, unsigned int *nblocks,\n\t\t      bool dinode, u64 *generation)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tstruct buffer_head *dibh;\n\tstruct gfs2_rbm rbm = { .rgd = ip->i_rgd, };\n\tunsigned int ndata;\n\tu64 block; /* block, within the file system scope */\n\tint error;\n\n\tgfs2_set_alloc_start(&rbm, ip, dinode);\n\terror = gfs2_rbm_find(&rbm, GFS2_BLKST_FREE, NULL, ip, false, NULL);\n\n\tif (error == -ENOSPC) {\n\t\tgfs2_set_alloc_start(&rbm, ip, dinode);\n\t\terror = gfs2_rbm_find(&rbm, GFS2_BLKST_FREE, NULL, NULL, false,\n\t\t\t\t      NULL);\n\t}\n\n\t/* Since all blocks are reserved in advance, this shouldn't happen */\n\tif (error) {\n\t\tfs_warn(sdp, \"inum=%llu error=%d, nblocks=%u, full=%d fail_pt=%d\\n\",\n\t\t\t(unsigned long long)ip->i_no_addr, error, *nblocks,\n\t\t\ttest_bit(GBF_FULL, &rbm.rgd->rd_bits->bi_flags),\n\t\t\trbm.rgd->rd_extfail_pt);\n\t\tgoto rgrp_error;\n\t}\n\n\tgfs2_alloc_extent(&rbm, dinode, nblocks);\n\tblock = gfs2_rbm_to_block(&rbm);\n\trbm.rgd->rd_last_alloc = block - rbm.rgd->rd_data0;\n\tif (gfs2_rs_active(ip->i_res))\n\t\tgfs2_adjust_reservation(ip, &rbm, *nblocks);\n\tndata = *nblocks;\n\tif (dinode)\n\t\tndata--;\n\n\tif (!dinode) {\n\t\tip->i_goal = block + ndata - 1;\n\t\terror = gfs2_meta_inode_buffer(ip, &dibh);\n\t\tif (error == 0) {\n\t\t\tstruct gfs2_dinode *di =\n\t\t\t\t(struct gfs2_dinode *)dibh->b_data;\n\t\t\tgfs2_trans_add_meta(ip->i_gl, dibh);\n\t\t\tdi->di_goal_meta = di->di_goal_data =\n\t\t\t\tcpu_to_be64(ip->i_goal);\n\t\t\tbrelse(dibh);\n\t\t}\n\t}\n\tif (rbm.rgd->rd_free < *nblocks) {\n\t\tpr_warn(\"nblocks=%u\\n\", *nblocks);\n\t\tgoto rgrp_error;\n\t}\n\n\trbm.rgd->rd_free -= *nblocks;\n\tif (dinode) {\n\t\trbm.rgd->rd_dinodes++;\n\t\t*generation = rbm.rgd->rd_igeneration++;\n\t\tif (*generation == 0)\n\t\t\t*generation = rbm.rgd->rd_igeneration++;\n\t}\n\n\tgfs2_trans_add_meta(rbm.rgd->rd_gl, rbm.rgd->rd_bits[0].bi_bh);\n\tgfs2_rgrp_out(rbm.rgd, rbm.rgd->rd_bits[0].bi_bh->b_data);\n\tgfs2_rgrp_ondisk2lvb(rbm.rgd->rd_rgl, rbm.rgd->rd_bits[0].bi_bh->b_data);\n\n\tgfs2_statfs_change(sdp, 0, -(s64)*nblocks, dinode ? 1 : 0);\n\tif (dinode)\n\t\tgfs2_trans_add_unrevoke(sdp, block, *nblocks);\n\n\tgfs2_quota_change(ip, *nblocks, ip->i_inode.i_uid, ip->i_inode.i_gid);\n\n\trbm.rgd->rd_free_clone -= *nblocks;\n\ttrace_gfs2_block_alloc(ip, rbm.rgd, block, *nblocks,\n\t\t\t       dinode ? GFS2_BLKST_DINODE : GFS2_BLKST_USED);\n\t*bn = block;\n\treturn 0;\n\nrgrp_error:\n\tgfs2_rgrp_error(rbm.rgd);\n\treturn -EIO;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DIV_ROUND_UP",
          "args": [
            "er->er_data_len",
            "sdp->sd_jbsize"
          ],
          "line": 683
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GFS2_EA2DATAPTRS",
          "args": [
            "ea"
          ],
          "line": 677
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "GFS2_EA2DATA(ea)",
            "er->er_data",
            "er->er_data_len"
          ],
          "line": 675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GFS2_EA2DATA",
          "args": [
            "ea"
          ],
          "line": 675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GFS2_EAREQ_SIZE_STUFFED",
          "args": [
            "er"
          ],
          "line": 673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "GFS2_EA2NAME(ea)",
            "er->er_name",
            "er->er_name_len"
          ],
          "line": 671
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GFS2_EA2NAME",
          "args": [
            "ea"
          ],
          "line": 671
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "er->er_data_len"
          ],
          "line": 666
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GFS2_SB",
          "args": [
            "&ip->i_inode"
          ],
          "line": 663
        },
        "resolved": true,
        "details": {
          "function_name": "GFS2_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/incore.h",
          "lines": "413-416",
          "snippet": "static inline struct gfs2_sbd *GFS2_SB(const struct inode *inode)\n{\n\treturn inode->i_sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/lockref.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ktime.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/completion.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dlm.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockref.h>\n#include <linux/percpu.h>\n#include <linux/ktime.h>\n#include <linux/rbtree.h>\n#include <linux/completion.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/buffer_head.h>\n#include <linux/dlm.h>\n#include <linux/workqueue.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n\nstatic inline struct gfs2_sbd *GFS2_SB(const struct inode *inode)\n{\n\treturn inode->i_sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic int ea_write(struct gfs2_inode *ip, struct gfs2_ea_header *ea,\n\t\t    struct gfs2_ea_request *er)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tint error;\n\n\tea->ea_data_len = cpu_to_be32(er->er_data_len);\n\tea->ea_name_len = er->er_name_len;\n\tea->ea_type = er->er_type;\n\tea->__pad = 0;\n\n\tmemcpy(GFS2_EA2NAME(ea), er->er_name, er->er_name_len);\n\n\tif (GFS2_EAREQ_SIZE_STUFFED(er) <= sdp->sd_jbsize) {\n\t\tea->ea_num_ptrs = 0;\n\t\tmemcpy(GFS2_EA2DATA(ea), er->er_data, er->er_data_len);\n\t} else {\n\t\t__be64 *dataptr = GFS2_EA2DATAPTRS(ea);\n\t\tconst char *data = er->er_data;\n\t\tunsigned int data_len = er->er_data_len;\n\t\tunsigned int copy;\n\t\tunsigned int x;\n\n\t\tea->ea_num_ptrs = DIV_ROUND_UP(er->er_data_len, sdp->sd_jbsize);\n\t\tfor (x = 0; x < ea->ea_num_ptrs; x++) {\n\t\t\tstruct buffer_head *bh;\n\t\t\tu64 block;\n\t\t\tint mh_size = sizeof(struct gfs2_meta_header);\n\t\t\tunsigned int n = 1;\n\n\t\t\terror = gfs2_alloc_blocks(ip, &block, &n, 0, NULL);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\tgfs2_trans_add_unrevoke(sdp, block, 1);\n\t\t\tbh = gfs2_meta_new(ip->i_gl, block);\n\t\t\tgfs2_trans_add_meta(ip->i_gl, bh);\n\t\t\tgfs2_metatype_set(bh, GFS2_METATYPE_ED, GFS2_FORMAT_ED);\n\n\t\t\tgfs2_add_inode_blocks(&ip->i_inode, 1);\n\n\t\t\tcopy = data_len > sdp->sd_jbsize ? sdp->sd_jbsize :\n\t\t\t\t\t\t\t   data_len;\n\t\t\tmemcpy(bh->b_data + mh_size, data, copy);\n\t\t\tif (copy < sdp->sd_jbsize)\n\t\t\t\tmemset(bh->b_data + mh_size + copy, 0,\n\t\t\t\t       sdp->sd_jbsize - copy);\n\n\t\t\t*dataptr++ = cpu_to_be64(bh->b_blocknr);\n\t\t\tdata += copy;\n\t\t\tdata_len -= copy;\n\n\t\t\tbrelse(bh);\n\t\t}\n\n\t\tgfs2_assert_withdraw(sdp, !data_len);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "ea_alloc_blk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
    "lines": "620-646",
    "snippet": "static int ea_alloc_blk(struct gfs2_inode *ip, struct buffer_head **bhp)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tstruct gfs2_ea_header *ea;\n\tunsigned int n = 1;\n\tu64 block;\n\tint error;\n\n\terror = gfs2_alloc_blocks(ip, &block, &n, 0, NULL);\n\tif (error)\n\t\treturn error;\n\tgfs2_trans_add_unrevoke(sdp, block, 1);\n\t*bhp = gfs2_meta_new(ip->i_gl, block);\n\tgfs2_trans_add_meta(ip->i_gl, *bhp);\n\tgfs2_metatype_set(*bhp, GFS2_METATYPE_EA, GFS2_FORMAT_EA);\n\tgfs2_buffer_clear_tail(*bhp, sizeof(struct gfs2_meta_header));\n\n\tea = GFS2_EA_BH2FIRST(*bhp);\n\tea->ea_rec_len = cpu_to_be32(sdp->sd_jbsize);\n\tea->ea_type = GFS2_EATYPE_UNUSED;\n\tea->ea_flags = GFS2_EAFLAG_LAST;\n\tea->ea_num_ptrs = 0;\n\n\tgfs2_add_inode_blocks(&ip->i_inode, 1);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"trans.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"inode.h\"",
      "#include \"glock.h\"",
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/xattr.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "gfs2_add_inode_blocks",
          "args": [
            "&ip->i_inode",
            "1"
          ],
          "line": 643
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_add_inode_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/inode.h",
          "lines": "62-67",
          "snippet": "static inline void gfs2_add_inode_blocks(struct inode *inode, s64 change)\n{\n\tgfs2_assert(GFS2_SB(inode), (change >= 0 || inode->i_blocks > -change));\n\tchange *= (GFS2_SB(inode)->sd_sb.sb_bsize/GFS2_BASIC_BLOCK);\n\tinode->i_blocks += change;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include <linux/mm.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <linux/mm.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic inline void gfs2_add_inode_blocks(struct inode *inode, s64 change)\n{\n\tgfs2_assert(GFS2_SB(inode), (change >= 0 || inode->i_blocks > -change));\n\tchange *= (GFS2_SB(inode)->sd_sb.sb_bsize/GFS2_BASIC_BLOCK);\n\tinode->i_blocks += change;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "sdp->sd_jbsize"
          ],
          "line": 638
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GFS2_EA_BH2FIRST",
          "args": [
            "*bhp"
          ],
          "line": 637
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_buffer_clear_tail",
          "args": [
            "*bhp",
            "sizeof(struct gfs2_meta_header)"
          ],
          "line": 635
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_buffer_clear_tail",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/meta_io.h",
          "lines": "22-26",
          "snippet": "static inline void gfs2_buffer_clear_tail(struct buffer_head *bh, int head)\n{\n\tBUG_ON(head > bh->b_size);\n\tmemset(bh->b_data + head, 0, bh->b_size - head);\n}",
          "includes": [
            "#include \"incore.h\"",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"incore.h\"\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline void gfs2_buffer_clear_tail(struct buffer_head *bh, int head)\n{\n\tBUG_ON(head > bh->b_size);\n\tmemset(bh->b_data + head, 0, bh->b_size - head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_metatype_set",
          "args": [
            "*bhp",
            "GFS2_METATYPE_EA",
            "GFS2_FORMAT_EA"
          ],
          "line": 634
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_metatype_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/util.h",
          "lines": "122-129",
          "snippet": "static inline void gfs2_metatype_set(struct buffer_head *bh, u16 type,\n\t\t\t\t     u16 format)\n{\n\tstruct gfs2_meta_header *mh;\n\tmh = (struct gfs2_meta_header *)bh->b_data;\n\tmh->mh_type = cpu_to_be32(type);\n\tmh->mh_format = cpu_to_be32(format);\n}",
          "includes": [
            "#include \"incore.h\"",
            "#include <linux/mempool.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"incore.h\"\n#include <linux/mempool.h>\n\nstatic inline void gfs2_metatype_set(struct buffer_head *bh, u16 type,\n\t\t\t\t     u16 format)\n{\n\tstruct gfs2_meta_header *mh;\n\tmh = (struct gfs2_meta_header *)bh->b_data;\n\tmh->mh_type = cpu_to_be32(type);\n\tmh->mh_format = cpu_to_be32(format);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_trans_add_meta",
          "args": [
            "ip->i_gl",
            "*bhp"
          ],
          "line": 633
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_trans_add_meta",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/trans.c",
          "lines": "224-247",
          "snippet": "void gfs2_trans_add_meta(struct gfs2_glock *gl, struct buffer_head *bh)\n{\n\n\tstruct gfs2_sbd *sdp = gl->gl_sbd;\n\tstruct gfs2_bufdata *bd;\n\n\tlock_buffer(bh);\n\tgfs2_log_lock(sdp);\n\tbd = bh->b_private;\n\tif (bd == NULL) {\n\t\tgfs2_log_unlock(sdp);\n\t\tunlock_buffer(bh);\n\t\tlock_page(bh->b_page);\n\t\tif (bh->b_private == NULL)\n\t\t\tbd = gfs2_alloc_bufdata(gl, bh, &gfs2_buf_lops);\n\t\tunlock_page(bh->b_page);\n\t\tlock_buffer(bh);\n\t\tgfs2_log_lock(sdp);\n\t}\n\tgfs2_assert(sdp, bd->bd_gl == gl);\n\tmeta_lo_add(sdp, bd);\n\tgfs2_log_unlock(sdp);\n\tunlock_buffer(bh);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_trans_add_meta(struct gfs2_glock *gl, struct buffer_head *bh)\n{\n\n\tstruct gfs2_sbd *sdp = gl->gl_sbd;\n\tstruct gfs2_bufdata *bd;\n\n\tlock_buffer(bh);\n\tgfs2_log_lock(sdp);\n\tbd = bh->b_private;\n\tif (bd == NULL) {\n\t\tgfs2_log_unlock(sdp);\n\t\tunlock_buffer(bh);\n\t\tlock_page(bh->b_page);\n\t\tif (bh->b_private == NULL)\n\t\t\tbd = gfs2_alloc_bufdata(gl, bh, &gfs2_buf_lops);\n\t\tunlock_page(bh->b_page);\n\t\tlock_buffer(bh);\n\t\tgfs2_log_lock(sdp);\n\t}\n\tgfs2_assert(sdp, bd->bd_gl == gl);\n\tmeta_lo_add(sdp, bd);\n\tgfs2_log_unlock(sdp);\n\tunlock_buffer(bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_meta_new",
          "args": [
            "ip->i_gl",
            "block"
          ],
          "line": 632
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_meta_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/meta_io.c",
          "lines": "182-188",
          "snippet": "struct buffer_head *gfs2_meta_new(struct gfs2_glock *gl, u64 blkno)\n{\n\tstruct buffer_head *bh;\n\tbh = gfs2_getbuf(gl, blkno, CREATE);\n\tmeta_prep_new(bh);\n\treturn bh;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/delay.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/delay.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstruct buffer_head *gfs2_meta_new(struct gfs2_glock *gl, u64 blkno)\n{\n\tstruct buffer_head *bh;\n\tbh = gfs2_getbuf(gl, blkno, CREATE);\n\tmeta_prep_new(bh);\n\treturn bh;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_trans_add_unrevoke",
          "args": [
            "sdp",
            "block",
            "1"
          ],
          "line": 631
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_trans_add_unrevoke",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/trans.c",
          "lines": "259-278",
          "snippet": "void gfs2_trans_add_unrevoke(struct gfs2_sbd *sdp, u64 blkno, unsigned int len)\n{\n\tstruct gfs2_bufdata *bd, *tmp;\n\tstruct gfs2_trans *tr = current->journal_info;\n\tunsigned int n = len;\n\n\tgfs2_log_lock(sdp);\n\tlist_for_each_entry_safe(bd, tmp, &sdp->sd_log_le_revoke, bd_list) {\n\t\tif ((bd->bd_blkno >= blkno) && (bd->bd_blkno < (blkno + len))) {\n\t\t\tlist_del_init(&bd->bd_list);\n\t\t\tgfs2_assert_withdraw(sdp, sdp->sd_log_num_revoke);\n\t\t\tsdp->sd_log_num_revoke--;\n\t\t\tkmem_cache_free(gfs2_bufdata_cachep, bd);\n\t\t\ttr->tr_num_revoke_rm++;\n\t\t\tif (--n == 0)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tgfs2_log_unlock(sdp);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_trans_add_unrevoke(struct gfs2_sbd *sdp, u64 blkno, unsigned int len)\n{\n\tstruct gfs2_bufdata *bd, *tmp;\n\tstruct gfs2_trans *tr = current->journal_info;\n\tunsigned int n = len;\n\n\tgfs2_log_lock(sdp);\n\tlist_for_each_entry_safe(bd, tmp, &sdp->sd_log_le_revoke, bd_list) {\n\t\tif ((bd->bd_blkno >= blkno) && (bd->bd_blkno < (blkno + len))) {\n\t\t\tlist_del_init(&bd->bd_list);\n\t\t\tgfs2_assert_withdraw(sdp, sdp->sd_log_num_revoke);\n\t\t\tsdp->sd_log_num_revoke--;\n\t\t\tkmem_cache_free(gfs2_bufdata_cachep, bd);\n\t\t\ttr->tr_num_revoke_rm++;\n\t\t\tif (--n == 0)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tgfs2_log_unlock(sdp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_alloc_blocks",
          "args": [
            "ip",
            "&block",
            "&n",
            "0",
            "NULL"
          ],
          "line": 628
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_alloc_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
          "lines": "2304-2385",
          "snippet": "int gfs2_alloc_blocks(struct gfs2_inode *ip, u64 *bn, unsigned int *nblocks,\n\t\t      bool dinode, u64 *generation)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tstruct buffer_head *dibh;\n\tstruct gfs2_rbm rbm = { .rgd = ip->i_rgd, };\n\tunsigned int ndata;\n\tu64 block; /* block, within the file system scope */\n\tint error;\n\n\tgfs2_set_alloc_start(&rbm, ip, dinode);\n\terror = gfs2_rbm_find(&rbm, GFS2_BLKST_FREE, NULL, ip, false, NULL);\n\n\tif (error == -ENOSPC) {\n\t\tgfs2_set_alloc_start(&rbm, ip, dinode);\n\t\terror = gfs2_rbm_find(&rbm, GFS2_BLKST_FREE, NULL, NULL, false,\n\t\t\t\t      NULL);\n\t}\n\n\t/* Since all blocks are reserved in advance, this shouldn't happen */\n\tif (error) {\n\t\tfs_warn(sdp, \"inum=%llu error=%d, nblocks=%u, full=%d fail_pt=%d\\n\",\n\t\t\t(unsigned long long)ip->i_no_addr, error, *nblocks,\n\t\t\ttest_bit(GBF_FULL, &rbm.rgd->rd_bits->bi_flags),\n\t\t\trbm.rgd->rd_extfail_pt);\n\t\tgoto rgrp_error;\n\t}\n\n\tgfs2_alloc_extent(&rbm, dinode, nblocks);\n\tblock = gfs2_rbm_to_block(&rbm);\n\trbm.rgd->rd_last_alloc = block - rbm.rgd->rd_data0;\n\tif (gfs2_rs_active(ip->i_res))\n\t\tgfs2_adjust_reservation(ip, &rbm, *nblocks);\n\tndata = *nblocks;\n\tif (dinode)\n\t\tndata--;\n\n\tif (!dinode) {\n\t\tip->i_goal = block + ndata - 1;\n\t\terror = gfs2_meta_inode_buffer(ip, &dibh);\n\t\tif (error == 0) {\n\t\t\tstruct gfs2_dinode *di =\n\t\t\t\t(struct gfs2_dinode *)dibh->b_data;\n\t\t\tgfs2_trans_add_meta(ip->i_gl, dibh);\n\t\t\tdi->di_goal_meta = di->di_goal_data =\n\t\t\t\tcpu_to_be64(ip->i_goal);\n\t\t\tbrelse(dibh);\n\t\t}\n\t}\n\tif (rbm.rgd->rd_free < *nblocks) {\n\t\tpr_warn(\"nblocks=%u\\n\", *nblocks);\n\t\tgoto rgrp_error;\n\t}\n\n\trbm.rgd->rd_free -= *nblocks;\n\tif (dinode) {\n\t\trbm.rgd->rd_dinodes++;\n\t\t*generation = rbm.rgd->rd_igeneration++;\n\t\tif (*generation == 0)\n\t\t\t*generation = rbm.rgd->rd_igeneration++;\n\t}\n\n\tgfs2_trans_add_meta(rbm.rgd->rd_gl, rbm.rgd->rd_bits[0].bi_bh);\n\tgfs2_rgrp_out(rbm.rgd, rbm.rgd->rd_bits[0].bi_bh->b_data);\n\tgfs2_rgrp_ondisk2lvb(rbm.rgd->rd_rgl, rbm.rgd->rd_bits[0].bi_bh->b_data);\n\n\tgfs2_statfs_change(sdp, 0, -(s64)*nblocks, dinode ? 1 : 0);\n\tif (dinode)\n\t\tgfs2_trans_add_unrevoke(sdp, block, *nblocks);\n\n\tgfs2_quota_change(ip, *nblocks, ip->i_inode.i_uid, ip->i_inode.i_gid);\n\n\trbm.rgd->rd_free_clone -= *nblocks;\n\ttrace_gfs2_block_alloc(ip, rbm.rgd, block, *nblocks,\n\t\t\t       dinode ? GFS2_BLKST_DINODE : GFS2_BLKST_USED);\n\t*bn = block;\n\treturn 0;\n\nrgrp_error:\n\tgfs2_rgrp_error(rbm.rgd);\n\treturn -EIO;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"inode.h\"",
            "#include \"log.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/random.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nint gfs2_alloc_blocks(struct gfs2_inode *ip, u64 *bn, unsigned int *nblocks,\n\t\t      bool dinode, u64 *generation)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tstruct buffer_head *dibh;\n\tstruct gfs2_rbm rbm = { .rgd = ip->i_rgd, };\n\tunsigned int ndata;\n\tu64 block; /* block, within the file system scope */\n\tint error;\n\n\tgfs2_set_alloc_start(&rbm, ip, dinode);\n\terror = gfs2_rbm_find(&rbm, GFS2_BLKST_FREE, NULL, ip, false, NULL);\n\n\tif (error == -ENOSPC) {\n\t\tgfs2_set_alloc_start(&rbm, ip, dinode);\n\t\terror = gfs2_rbm_find(&rbm, GFS2_BLKST_FREE, NULL, NULL, false,\n\t\t\t\t      NULL);\n\t}\n\n\t/* Since all blocks are reserved in advance, this shouldn't happen */\n\tif (error) {\n\t\tfs_warn(sdp, \"inum=%llu error=%d, nblocks=%u, full=%d fail_pt=%d\\n\",\n\t\t\t(unsigned long long)ip->i_no_addr, error, *nblocks,\n\t\t\ttest_bit(GBF_FULL, &rbm.rgd->rd_bits->bi_flags),\n\t\t\trbm.rgd->rd_extfail_pt);\n\t\tgoto rgrp_error;\n\t}\n\n\tgfs2_alloc_extent(&rbm, dinode, nblocks);\n\tblock = gfs2_rbm_to_block(&rbm);\n\trbm.rgd->rd_last_alloc = block - rbm.rgd->rd_data0;\n\tif (gfs2_rs_active(ip->i_res))\n\t\tgfs2_adjust_reservation(ip, &rbm, *nblocks);\n\tndata = *nblocks;\n\tif (dinode)\n\t\tndata--;\n\n\tif (!dinode) {\n\t\tip->i_goal = block + ndata - 1;\n\t\terror = gfs2_meta_inode_buffer(ip, &dibh);\n\t\tif (error == 0) {\n\t\t\tstruct gfs2_dinode *di =\n\t\t\t\t(struct gfs2_dinode *)dibh->b_data;\n\t\t\tgfs2_trans_add_meta(ip->i_gl, dibh);\n\t\t\tdi->di_goal_meta = di->di_goal_data =\n\t\t\t\tcpu_to_be64(ip->i_goal);\n\t\t\tbrelse(dibh);\n\t\t}\n\t}\n\tif (rbm.rgd->rd_free < *nblocks) {\n\t\tpr_warn(\"nblocks=%u\\n\", *nblocks);\n\t\tgoto rgrp_error;\n\t}\n\n\trbm.rgd->rd_free -= *nblocks;\n\tif (dinode) {\n\t\trbm.rgd->rd_dinodes++;\n\t\t*generation = rbm.rgd->rd_igeneration++;\n\t\tif (*generation == 0)\n\t\t\t*generation = rbm.rgd->rd_igeneration++;\n\t}\n\n\tgfs2_trans_add_meta(rbm.rgd->rd_gl, rbm.rgd->rd_bits[0].bi_bh);\n\tgfs2_rgrp_out(rbm.rgd, rbm.rgd->rd_bits[0].bi_bh->b_data);\n\tgfs2_rgrp_ondisk2lvb(rbm.rgd->rd_rgl, rbm.rgd->rd_bits[0].bi_bh->b_data);\n\n\tgfs2_statfs_change(sdp, 0, -(s64)*nblocks, dinode ? 1 : 0);\n\tif (dinode)\n\t\tgfs2_trans_add_unrevoke(sdp, block, *nblocks);\n\n\tgfs2_quota_change(ip, *nblocks, ip->i_inode.i_uid, ip->i_inode.i_gid);\n\n\trbm.rgd->rd_free_clone -= *nblocks;\n\ttrace_gfs2_block_alloc(ip, rbm.rgd, block, *nblocks,\n\t\t\t       dinode ? GFS2_BLKST_DINODE : GFS2_BLKST_USED);\n\t*bn = block;\n\treturn 0;\n\nrgrp_error:\n\tgfs2_rgrp_error(rbm.rgd);\n\treturn -EIO;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GFS2_SB",
          "args": [
            "&ip->i_inode"
          ],
          "line": 622
        },
        "resolved": true,
        "details": {
          "function_name": "GFS2_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/incore.h",
          "lines": "413-416",
          "snippet": "static inline struct gfs2_sbd *GFS2_SB(const struct inode *inode)\n{\n\treturn inode->i_sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/lockref.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ktime.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/completion.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dlm.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockref.h>\n#include <linux/percpu.h>\n#include <linux/ktime.h>\n#include <linux/rbtree.h>\n#include <linux/completion.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/buffer_head.h>\n#include <linux/dlm.h>\n#include <linux/workqueue.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n\nstatic inline struct gfs2_sbd *GFS2_SB(const struct inode *inode)\n{\n\treturn inode->i_sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic int ea_alloc_blk(struct gfs2_inode *ip, struct buffer_head **bhp)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tstruct gfs2_ea_header *ea;\n\tunsigned int n = 1;\n\tu64 block;\n\tint error;\n\n\terror = gfs2_alloc_blocks(ip, &block, &n, 0, NULL);\n\tif (error)\n\t\treturn error;\n\tgfs2_trans_add_unrevoke(sdp, block, 1);\n\t*bhp = gfs2_meta_new(ip->i_gl, block);\n\tgfs2_trans_add_meta(ip->i_gl, *bhp);\n\tgfs2_metatype_set(*bhp, GFS2_METATYPE_EA, GFS2_FORMAT_EA);\n\tgfs2_buffer_clear_tail(*bhp, sizeof(struct gfs2_meta_header));\n\n\tea = GFS2_EA_BH2FIRST(*bhp);\n\tea->ea_rec_len = cpu_to_be32(sdp->sd_jbsize);\n\tea->ea_type = GFS2_EATYPE_UNUSED;\n\tea->ea_flags = GFS2_EAFLAG_LAST;\n\tea->ea_num_ptrs = 0;\n\n\tgfs2_add_inode_blocks(&ip->i_inode, 1);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "gfs2_xattr_get",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
    "lines": "586-610",
    "snippet": "static int gfs2_xattr_get(struct dentry *dentry, const char *name,\n\t\tvoid *buffer, size_t size, int type)\n{\n\tstruct gfs2_inode *ip = GFS2_I(dentry->d_inode);\n\tstruct gfs2_ea_location el;\n\tint error;\n\n\tif (!ip->i_eattr)\n\t\treturn -ENODATA;\n\tif (strlen(name) > GFS2_EA_MAX_NAME_LEN)\n\t\treturn -EINVAL;\n\n\terror = gfs2_ea_find(ip, type, name, &el);\n\tif (error)\n\t\treturn error;\n\tif (!el.el_ea)\n\t\treturn -ENODATA;\n\tif (size)\n\t\terror = gfs2_ea_get_copy(ip, &el, buffer, size);\n\telse\n\t\terror = GFS2_EA_DATA_LEN(el.el_ea);\n\tbrelse(el.el_bh);\n\n\treturn error;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"trans.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"inode.h\"",
      "#include \"glock.h\"",
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/xattr.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "el.el_bh"
          ],
          "line": 607
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "GFS2_EA_DATA_LEN",
          "args": [
            "el.el_ea"
          ],
          "line": 606
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_ea_get_copy",
          "args": [
            "ip",
            "&el",
            "buffer",
            "size"
          ],
          "line": 604
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_get_copy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "527-543",
          "snippet": "static int gfs2_ea_get_copy(struct gfs2_inode *ip, struct gfs2_ea_location *el,\n\t\t\t    char *data, size_t size)\n{\n\tint ret;\n\tsize_t len = GFS2_EA_DATA_LEN(el->el_ea);\n\tif (len > size)\n\t\treturn -ERANGE;\n\n\tif (GFS2_EA_IS_STUFFED(el->el_ea)) {\n\t\tmemcpy(data, GFS2_EA2DATA(el->el_ea), len);\n\t\treturn len;\n\t}\n\tret = gfs2_iter_unstuffed(ip, el->el_ea, NULL, data);\n\tif (ret < 0)\n\t\treturn ret;\n\treturn len;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic int gfs2_ea_get_copy(struct gfs2_inode *ip, struct gfs2_ea_location *el,\n\t\t\t    char *data, size_t size)\n{\n\tint ret;\n\tsize_t len = GFS2_EA_DATA_LEN(el->el_ea);\n\tif (len > size)\n\t\treturn -ERANGE;\n\n\tif (GFS2_EA_IS_STUFFED(el->el_ea)) {\n\t\tmemcpy(data, GFS2_EA2DATA(el->el_ea), len);\n\t\treturn len;\n\t}\n\tret = gfs2_iter_unstuffed(ip, el->el_ea, NULL, data);\n\tif (ret < 0)\n\t\treturn ret;\n\treturn len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_ea_find",
          "args": [
            "ip",
            "type",
            "name",
            "&el"
          ],
          "line": 598
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_find",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "190-208",
          "snippet": "static int gfs2_ea_find(struct gfs2_inode *ip, int type, const char *name,\n\t\t\tstruct gfs2_ea_location *el)\n{\n\tstruct ea_find ef;\n\tint error;\n\n\tef.type = type;\n\tef.name = name;\n\tef.namel = strlen(name);\n\tef.ef_el = el;\n\n\tmemset(el, 0, sizeof(struct gfs2_ea_location));\n\n\terror = ea_foreach(ip, ea_find_i, &ef);\n\tif (error > 0)\n\t\treturn 0;\n\n\treturn error;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic int gfs2_ea_find(struct gfs2_inode *ip, int type, const char *name,\n\t\t\tstruct gfs2_ea_location *el)\n{\n\tstruct ea_find ef;\n\tint error;\n\n\tef.type = type;\n\tef.name = name;\n\tef.namel = strlen(name);\n\tef.ef_el = el;\n\n\tmemset(el, 0, sizeof(struct gfs2_ea_location));\n\n\terror = ea_foreach(ip, ea_find_i, &ef);\n\tif (error > 0)\n\t\treturn 0;\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "name"
          ],
          "line": 595
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "GFS2_I",
          "args": [
            "dentry->d_inode"
          ],
          "line": 589
        },
        "resolved": true,
        "details": {
          "function_name": "GFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/incore.h",
          "lines": "408-411",
          "snippet": "static inline struct gfs2_inode *GFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct gfs2_inode, i_inode);\n}",
          "includes": [
            "#include <linux/lockref.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ktime.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/completion.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dlm.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockref.h>\n#include <linux/percpu.h>\n#include <linux/ktime.h>\n#include <linux/rbtree.h>\n#include <linux/completion.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/buffer_head.h>\n#include <linux/dlm.h>\n#include <linux/workqueue.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n\nstatic inline struct gfs2_inode *GFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct gfs2_inode, i_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic int gfs2_xattr_get(struct dentry *dentry, const char *name,\n\t\tvoid *buffer, size_t size, int type)\n{\n\tstruct gfs2_inode *ip = GFS2_I(dentry->d_inode);\n\tstruct gfs2_ea_location el;\n\tint error;\n\n\tif (!ip->i_eattr)\n\t\treturn -ENODATA;\n\tif (strlen(name) > GFS2_EA_MAX_NAME_LEN)\n\t\treturn -EINVAL;\n\n\terror = gfs2_ea_find(ip, type, name, &el);\n\tif (error)\n\t\treturn error;\n\tif (!el.el_ea)\n\t\treturn -ENODATA;\n\tif (size)\n\t\terror = gfs2_ea_get_copy(ip, &el, buffer, size);\n\telse\n\t\terror = GFS2_EA_DATA_LEN(el.el_ea);\n\tbrelse(el.el_bh);\n\n\treturn error;\n}"
  },
  {
    "function_name": "gfs2_xattr_acl_get",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
    "lines": "545-574",
    "snippet": "int gfs2_xattr_acl_get(struct gfs2_inode *ip, const char *name, char **ppdata)\n{\n\tstruct gfs2_ea_location el;\n\tint error;\n\tint len;\n\tchar *data;\n\n\terror = gfs2_ea_find(ip, GFS2_EATYPE_SYS, name, &el);\n\tif (error)\n\t\treturn error;\n\tif (!el.el_ea)\n\t\tgoto out;\n\tif (!GFS2_EA_DATA_LEN(el.el_ea))\n\t\tgoto out;\n\n\tlen = GFS2_EA_DATA_LEN(el.el_ea);\n\tdata = kmalloc(len, GFP_NOFS);\n\terror = -ENOMEM;\n\tif (data == NULL)\n\t\tgoto out;\n\n\terror = gfs2_ea_get_copy(ip, &el, data, len);\n\tif (error < 0)\n\t\tkfree(data);\n\telse\n\t\t*ppdata = data;\nout:\n\tbrelse(el.el_bh);\n\treturn error;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"trans.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"inode.h\"",
      "#include \"glock.h\"",
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/xattr.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "el.el_bh"
          ],
          "line": 572
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "data"
          ],
          "line": 568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_ea_get_copy",
          "args": [
            "ip",
            "&el",
            "data",
            "len"
          ],
          "line": 566
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_get_copy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "527-543",
          "snippet": "static int gfs2_ea_get_copy(struct gfs2_inode *ip, struct gfs2_ea_location *el,\n\t\t\t    char *data, size_t size)\n{\n\tint ret;\n\tsize_t len = GFS2_EA_DATA_LEN(el->el_ea);\n\tif (len > size)\n\t\treturn -ERANGE;\n\n\tif (GFS2_EA_IS_STUFFED(el->el_ea)) {\n\t\tmemcpy(data, GFS2_EA2DATA(el->el_ea), len);\n\t\treturn len;\n\t}\n\tret = gfs2_iter_unstuffed(ip, el->el_ea, NULL, data);\n\tif (ret < 0)\n\t\treturn ret;\n\treturn len;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic int gfs2_ea_get_copy(struct gfs2_inode *ip, struct gfs2_ea_location *el,\n\t\t\t    char *data, size_t size)\n{\n\tint ret;\n\tsize_t len = GFS2_EA_DATA_LEN(el->el_ea);\n\tif (len > size)\n\t\treturn -ERANGE;\n\n\tif (GFS2_EA_IS_STUFFED(el->el_ea)) {\n\t\tmemcpy(data, GFS2_EA2DATA(el->el_ea), len);\n\t\treturn len;\n\t}\n\tret = gfs2_iter_unstuffed(ip, el->el_ea, NULL, data);\n\tif (ret < 0)\n\t\treturn ret;\n\treturn len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "len",
            "GFP_NOFS"
          ],
          "line": 561
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GFS2_EA_DATA_LEN",
          "args": [
            "el.el_ea"
          ],
          "line": 560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GFS2_EA_DATA_LEN",
          "args": [
            "el.el_ea"
          ],
          "line": 557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_ea_find",
          "args": [
            "ip",
            "GFS2_EATYPE_SYS",
            "name",
            "&el"
          ],
          "line": 552
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_find",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "190-208",
          "snippet": "static int gfs2_ea_find(struct gfs2_inode *ip, int type, const char *name,\n\t\t\tstruct gfs2_ea_location *el)\n{\n\tstruct ea_find ef;\n\tint error;\n\n\tef.type = type;\n\tef.name = name;\n\tef.namel = strlen(name);\n\tef.ef_el = el;\n\n\tmemset(el, 0, sizeof(struct gfs2_ea_location));\n\n\terror = ea_foreach(ip, ea_find_i, &ef);\n\tif (error > 0)\n\t\treturn 0;\n\n\treturn error;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic int gfs2_ea_find(struct gfs2_inode *ip, int type, const char *name,\n\t\t\tstruct gfs2_ea_location *el)\n{\n\tstruct ea_find ef;\n\tint error;\n\n\tef.type = type;\n\tef.name = name;\n\tef.namel = strlen(name);\n\tef.ef_el = el;\n\n\tmemset(el, 0, sizeof(struct gfs2_ea_location));\n\n\terror = ea_foreach(ip, ea_find_i, &ef);\n\tif (error > 0)\n\t\treturn 0;\n\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nint gfs2_xattr_acl_get(struct gfs2_inode *ip, const char *name, char **ppdata)\n{\n\tstruct gfs2_ea_location el;\n\tint error;\n\tint len;\n\tchar *data;\n\n\terror = gfs2_ea_find(ip, GFS2_EATYPE_SYS, name, &el);\n\tif (error)\n\t\treturn error;\n\tif (!el.el_ea)\n\t\tgoto out;\n\tif (!GFS2_EA_DATA_LEN(el.el_ea))\n\t\tgoto out;\n\n\tlen = GFS2_EA_DATA_LEN(el.el_ea);\n\tdata = kmalloc(len, GFP_NOFS);\n\terror = -ENOMEM;\n\tif (data == NULL)\n\t\tgoto out;\n\n\terror = gfs2_ea_get_copy(ip, &el, data, len);\n\tif (error < 0)\n\t\tkfree(data);\n\telse\n\t\t*ppdata = data;\nout:\n\tbrelse(el.el_bh);\n\treturn error;\n}"
  },
  {
    "function_name": "gfs2_ea_get_copy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
    "lines": "527-543",
    "snippet": "static int gfs2_ea_get_copy(struct gfs2_inode *ip, struct gfs2_ea_location *el,\n\t\t\t    char *data, size_t size)\n{\n\tint ret;\n\tsize_t len = GFS2_EA_DATA_LEN(el->el_ea);\n\tif (len > size)\n\t\treturn -ERANGE;\n\n\tif (GFS2_EA_IS_STUFFED(el->el_ea)) {\n\t\tmemcpy(data, GFS2_EA2DATA(el->el_ea), len);\n\t\treturn len;\n\t}\n\tret = gfs2_iter_unstuffed(ip, el->el_ea, NULL, data);\n\tif (ret < 0)\n\t\treturn ret;\n\treturn len;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"trans.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"inode.h\"",
      "#include \"glock.h\"",
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/xattr.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "gfs2_iter_unstuffed",
          "args": [
            "ip",
            "el->el_ea",
            "NULL",
            "data"
          ],
          "line": 539
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_iter_unstuffed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "462-525",
          "snippet": "static int gfs2_iter_unstuffed(struct gfs2_inode *ip, struct gfs2_ea_header *ea,\n\t\t\t       const char *din, char *dout)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tstruct buffer_head **bh;\n\tunsigned int amount = GFS2_EA_DATA_LEN(ea);\n\tunsigned int nptrs = DIV_ROUND_UP(amount, sdp->sd_jbsize);\n\t__be64 *dataptrs = GFS2_EA2DATAPTRS(ea);\n\tunsigned int x;\n\tint error = 0;\n\tunsigned char *pos;\n\tunsigned cp_size;\n\n\tbh = kcalloc(nptrs, sizeof(struct buffer_head *), GFP_NOFS);\n\tif (!bh)\n\t\treturn -ENOMEM;\n\n\tfor (x = 0; x < nptrs; x++) {\n\t\terror = gfs2_meta_read(ip->i_gl, be64_to_cpu(*dataptrs), 0,\n\t\t\t\t       bh + x);\n\t\tif (error) {\n\t\t\twhile (x--)\n\t\t\t\tbrelse(bh[x]);\n\t\t\tgoto out;\n\t\t}\n\t\tdataptrs++;\n\t}\n\n\tfor (x = 0; x < nptrs; x++) {\n\t\terror = gfs2_meta_wait(sdp, bh[x]);\n\t\tif (error) {\n\t\t\tfor (; x < nptrs; x++)\n\t\t\t\tbrelse(bh[x]);\n\t\t\tgoto out;\n\t\t}\n\t\tif (gfs2_metatype_check(sdp, bh[x], GFS2_METATYPE_ED)) {\n\t\t\tfor (; x < nptrs; x++)\n\t\t\t\tbrelse(bh[x]);\n\t\t\terror = -EIO;\n\t\t\tgoto out;\n\t\t}\n\n\t\tpos = bh[x]->b_data + sizeof(struct gfs2_meta_header);\n\t\tcp_size = (sdp->sd_jbsize > amount) ? amount : sdp->sd_jbsize;\n\n\t\tif (dout) {\n\t\t\tmemcpy(dout, pos, cp_size);\n\t\t\tdout += sdp->sd_jbsize;\n\t\t}\n\n\t\tif (din) {\n\t\t\tgfs2_trans_add_meta(ip->i_gl, bh[x]);\n\t\t\tmemcpy(pos, din, cp_size);\n\t\t\tdin += sdp->sd_jbsize;\n\t\t}\n\n\t\tamount -= sdp->sd_jbsize;\n\t\tbrelse(bh[x]);\n\t}\n\nout:\n\tkfree(bh);\n\treturn error;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic int gfs2_iter_unstuffed(struct gfs2_inode *ip, struct gfs2_ea_header *ea,\n\t\t\t       const char *din, char *dout)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tstruct buffer_head **bh;\n\tunsigned int amount = GFS2_EA_DATA_LEN(ea);\n\tunsigned int nptrs = DIV_ROUND_UP(amount, sdp->sd_jbsize);\n\t__be64 *dataptrs = GFS2_EA2DATAPTRS(ea);\n\tunsigned int x;\n\tint error = 0;\n\tunsigned char *pos;\n\tunsigned cp_size;\n\n\tbh = kcalloc(nptrs, sizeof(struct buffer_head *), GFP_NOFS);\n\tif (!bh)\n\t\treturn -ENOMEM;\n\n\tfor (x = 0; x < nptrs; x++) {\n\t\terror = gfs2_meta_read(ip->i_gl, be64_to_cpu(*dataptrs), 0,\n\t\t\t\t       bh + x);\n\t\tif (error) {\n\t\t\twhile (x--)\n\t\t\t\tbrelse(bh[x]);\n\t\t\tgoto out;\n\t\t}\n\t\tdataptrs++;\n\t}\n\n\tfor (x = 0; x < nptrs; x++) {\n\t\terror = gfs2_meta_wait(sdp, bh[x]);\n\t\tif (error) {\n\t\t\tfor (; x < nptrs; x++)\n\t\t\t\tbrelse(bh[x]);\n\t\t\tgoto out;\n\t\t}\n\t\tif (gfs2_metatype_check(sdp, bh[x], GFS2_METATYPE_ED)) {\n\t\t\tfor (; x < nptrs; x++)\n\t\t\t\tbrelse(bh[x]);\n\t\t\terror = -EIO;\n\t\t\tgoto out;\n\t\t}\n\n\t\tpos = bh[x]->b_data + sizeof(struct gfs2_meta_header);\n\t\tcp_size = (sdp->sd_jbsize > amount) ? amount : sdp->sd_jbsize;\n\n\t\tif (dout) {\n\t\t\tmemcpy(dout, pos, cp_size);\n\t\t\tdout += sdp->sd_jbsize;\n\t\t}\n\n\t\tif (din) {\n\t\t\tgfs2_trans_add_meta(ip->i_gl, bh[x]);\n\t\t\tmemcpy(pos, din, cp_size);\n\t\t\tdin += sdp->sd_jbsize;\n\t\t}\n\n\t\tamount -= sdp->sd_jbsize;\n\t\tbrelse(bh[x]);\n\t}\n\nout:\n\tkfree(bh);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "data",
            "GFS2_EA2DATA(el->el_ea)",
            "len"
          ],
          "line": 536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GFS2_EA2DATA",
          "args": [
            "el->el_ea"
          ],
          "line": 536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GFS2_EA_IS_STUFFED",
          "args": [
            "el->el_ea"
          ],
          "line": 535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GFS2_EA_DATA_LEN",
          "args": [
            "el->el_ea"
          ],
          "line": 531
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic int gfs2_ea_get_copy(struct gfs2_inode *ip, struct gfs2_ea_location *el,\n\t\t\t    char *data, size_t size)\n{\n\tint ret;\n\tsize_t len = GFS2_EA_DATA_LEN(el->el_ea);\n\tif (len > size)\n\t\treturn -ERANGE;\n\n\tif (GFS2_EA_IS_STUFFED(el->el_ea)) {\n\t\tmemcpy(data, GFS2_EA2DATA(el->el_ea), len);\n\t\treturn len;\n\t}\n\tret = gfs2_iter_unstuffed(ip, el->el_ea, NULL, data);\n\tif (ret < 0)\n\t\treturn ret;\n\treturn len;\n}"
  },
  {
    "function_name": "gfs2_iter_unstuffed",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
    "lines": "462-525",
    "snippet": "static int gfs2_iter_unstuffed(struct gfs2_inode *ip, struct gfs2_ea_header *ea,\n\t\t\t       const char *din, char *dout)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tstruct buffer_head **bh;\n\tunsigned int amount = GFS2_EA_DATA_LEN(ea);\n\tunsigned int nptrs = DIV_ROUND_UP(amount, sdp->sd_jbsize);\n\t__be64 *dataptrs = GFS2_EA2DATAPTRS(ea);\n\tunsigned int x;\n\tint error = 0;\n\tunsigned char *pos;\n\tunsigned cp_size;\n\n\tbh = kcalloc(nptrs, sizeof(struct buffer_head *), GFP_NOFS);\n\tif (!bh)\n\t\treturn -ENOMEM;\n\n\tfor (x = 0; x < nptrs; x++) {\n\t\terror = gfs2_meta_read(ip->i_gl, be64_to_cpu(*dataptrs), 0,\n\t\t\t\t       bh + x);\n\t\tif (error) {\n\t\t\twhile (x--)\n\t\t\t\tbrelse(bh[x]);\n\t\t\tgoto out;\n\t\t}\n\t\tdataptrs++;\n\t}\n\n\tfor (x = 0; x < nptrs; x++) {\n\t\terror = gfs2_meta_wait(sdp, bh[x]);\n\t\tif (error) {\n\t\t\tfor (; x < nptrs; x++)\n\t\t\t\tbrelse(bh[x]);\n\t\t\tgoto out;\n\t\t}\n\t\tif (gfs2_metatype_check(sdp, bh[x], GFS2_METATYPE_ED)) {\n\t\t\tfor (; x < nptrs; x++)\n\t\t\t\tbrelse(bh[x]);\n\t\t\terror = -EIO;\n\t\t\tgoto out;\n\t\t}\n\n\t\tpos = bh[x]->b_data + sizeof(struct gfs2_meta_header);\n\t\tcp_size = (sdp->sd_jbsize > amount) ? amount : sdp->sd_jbsize;\n\n\t\tif (dout) {\n\t\t\tmemcpy(dout, pos, cp_size);\n\t\t\tdout += sdp->sd_jbsize;\n\t\t}\n\n\t\tif (din) {\n\t\t\tgfs2_trans_add_meta(ip->i_gl, bh[x]);\n\t\t\tmemcpy(pos, din, cp_size);\n\t\t\tdin += sdp->sd_jbsize;\n\t\t}\n\n\t\tamount -= sdp->sd_jbsize;\n\t\tbrelse(bh[x]);\n\t}\n\nout:\n\tkfree(bh);\n\treturn error;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"trans.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"inode.h\"",
      "#include \"glock.h\"",
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/xattr.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "bh"
          ],
          "line": 523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh[x]"
          ],
          "line": 519
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "pos",
            "din",
            "cp_size"
          ],
          "line": 514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_trans_add_meta",
          "args": [
            "ip->i_gl",
            "bh[x]"
          ],
          "line": 513
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_trans_add_meta",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/trans.c",
          "lines": "224-247",
          "snippet": "void gfs2_trans_add_meta(struct gfs2_glock *gl, struct buffer_head *bh)\n{\n\n\tstruct gfs2_sbd *sdp = gl->gl_sbd;\n\tstruct gfs2_bufdata *bd;\n\n\tlock_buffer(bh);\n\tgfs2_log_lock(sdp);\n\tbd = bh->b_private;\n\tif (bd == NULL) {\n\t\tgfs2_log_unlock(sdp);\n\t\tunlock_buffer(bh);\n\t\tlock_page(bh->b_page);\n\t\tif (bh->b_private == NULL)\n\t\t\tbd = gfs2_alloc_bufdata(gl, bh, &gfs2_buf_lops);\n\t\tunlock_page(bh->b_page);\n\t\tlock_buffer(bh);\n\t\tgfs2_log_lock(sdp);\n\t}\n\tgfs2_assert(sdp, bd->bd_gl == gl);\n\tmeta_lo_add(sdp, bd);\n\tgfs2_log_unlock(sdp);\n\tunlock_buffer(bh);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_trans_add_meta(struct gfs2_glock *gl, struct buffer_head *bh)\n{\n\n\tstruct gfs2_sbd *sdp = gl->gl_sbd;\n\tstruct gfs2_bufdata *bd;\n\n\tlock_buffer(bh);\n\tgfs2_log_lock(sdp);\n\tbd = bh->b_private;\n\tif (bd == NULL) {\n\t\tgfs2_log_unlock(sdp);\n\t\tunlock_buffer(bh);\n\t\tlock_page(bh->b_page);\n\t\tif (bh->b_private == NULL)\n\t\t\tbd = gfs2_alloc_bufdata(gl, bh, &gfs2_buf_lops);\n\t\tunlock_page(bh->b_page);\n\t\tlock_buffer(bh);\n\t\tgfs2_log_lock(sdp);\n\t}\n\tgfs2_assert(sdp, bd->bd_gl == gl);\n\tmeta_lo_add(sdp, bd);\n\tgfs2_log_unlock(sdp);\n\tunlock_buffer(bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "dout",
            "pos",
            "cp_size"
          ],
          "line": 508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_metatype_check",
          "args": [
            "sdp",
            "bh[x]",
            "GFS2_METATYPE_ED"
          ],
          "line": 497
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_meta_wait",
          "args": [
            "sdp",
            "bh[x]"
          ],
          "line": 491
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_meta_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/meta_io.c",
          "lines": "245-262",
          "snippet": "int gfs2_meta_wait(struct gfs2_sbd *sdp, struct buffer_head *bh)\n{\n\tif (unlikely(test_bit(SDF_SHUTDOWN, &sdp->sd_flags)))\n\t\treturn -EIO;\n\n\twait_on_buffer(bh);\n\n\tif (!buffer_uptodate(bh)) {\n\t\tstruct gfs2_trans *tr = current->journal_info;\n\t\tif (tr && tr->tr_touched)\n\t\t\tgfs2_io_error_bh(sdp, bh);\n\t\treturn -EIO;\n\t}\n\tif (unlikely(test_bit(SDF_SHUTDOWN, &sdp->sd_flags)))\n\t\treturn -EIO;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/delay.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/delay.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nint gfs2_meta_wait(struct gfs2_sbd *sdp, struct buffer_head *bh)\n{\n\tif (unlikely(test_bit(SDF_SHUTDOWN, &sdp->sd_flags)))\n\t\treturn -EIO;\n\n\twait_on_buffer(bh);\n\n\tif (!buffer_uptodate(bh)) {\n\t\tstruct gfs2_trans *tr = current->journal_info;\n\t\tif (tr && tr->tr_touched)\n\t\t\tgfs2_io_error_bh(sdp, bh);\n\t\treturn -EIO;\n\t}\n\tif (unlikely(test_bit(SDF_SHUTDOWN, &sdp->sd_flags)))\n\t\treturn -EIO;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_meta_read",
          "args": [
            "ip->i_gl",
            "be64_to_cpu(*dataptrs)",
            "0",
            "bh + x"
          ],
          "line": 480
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_meta_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/meta_io.c",
          "lines": "200-235",
          "snippet": "int gfs2_meta_read(struct gfs2_glock *gl, u64 blkno, int flags,\n\t\t   struct buffer_head **bhp)\n{\n\tstruct gfs2_sbd *sdp = gl->gl_sbd;\n\tstruct buffer_head *bh;\n\n\tif (unlikely(test_bit(SDF_SHUTDOWN, &sdp->sd_flags))) {\n\t\t*bhp = NULL;\n\t\treturn -EIO;\n\t}\n\n\t*bhp = bh = gfs2_getbuf(gl, blkno, CREATE);\n\n\tlock_buffer(bh);\n\tif (buffer_uptodate(bh)) {\n\t\tunlock_buffer(bh);\n\t\treturn 0;\n\t}\n\tbh->b_end_io = end_buffer_read_sync;\n\tget_bh(bh);\n\tsubmit_bh(READ_SYNC | REQ_META | REQ_PRIO, bh);\n\tif (!(flags & DIO_WAIT))\n\t\treturn 0;\n\n\twait_on_buffer(bh);\n\tif (unlikely(!buffer_uptodate(bh))) {\n\t\tstruct gfs2_trans *tr = current->journal_info;\n\t\tif (tr && tr->tr_touched)\n\t\t\tgfs2_io_error_bh(sdp, bh);\n\t\tbrelse(bh);\n\t\t*bhp = NULL;\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/delay.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/delay.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nint gfs2_meta_read(struct gfs2_glock *gl, u64 blkno, int flags,\n\t\t   struct buffer_head **bhp)\n{\n\tstruct gfs2_sbd *sdp = gl->gl_sbd;\n\tstruct buffer_head *bh;\n\n\tif (unlikely(test_bit(SDF_SHUTDOWN, &sdp->sd_flags))) {\n\t\t*bhp = NULL;\n\t\treturn -EIO;\n\t}\n\n\t*bhp = bh = gfs2_getbuf(gl, blkno, CREATE);\n\n\tlock_buffer(bh);\n\tif (buffer_uptodate(bh)) {\n\t\tunlock_buffer(bh);\n\t\treturn 0;\n\t}\n\tbh->b_end_io = end_buffer_read_sync;\n\tget_bh(bh);\n\tsubmit_bh(READ_SYNC | REQ_META | REQ_PRIO, bh);\n\tif (!(flags & DIO_WAIT))\n\t\treturn 0;\n\n\twait_on_buffer(bh);\n\tif (unlikely(!buffer_uptodate(bh))) {\n\t\tstruct gfs2_trans *tr = current->journal_info;\n\t\tif (tr && tr->tr_touched)\n\t\t\tgfs2_io_error_bh(sdp, bh);\n\t\tbrelse(bh);\n\t\t*bhp = NULL;\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "*dataptrs"
          ],
          "line": 480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kcalloc",
          "args": [
            "nptrs",
            "sizeof(struct buffer_head *)",
            "GFP_NOFS"
          ],
          "line": 475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GFS2_EA2DATAPTRS",
          "args": [
            "ea"
          ],
          "line": 469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DIV_ROUND_UP",
          "args": [
            "amount",
            "sdp->sd_jbsize"
          ],
          "line": 468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GFS2_EA_DATA_LEN",
          "args": [
            "ea"
          ],
          "line": 467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GFS2_SB",
          "args": [
            "&ip->i_inode"
          ],
          "line": 465
        },
        "resolved": true,
        "details": {
          "function_name": "GFS2_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/incore.h",
          "lines": "413-416",
          "snippet": "static inline struct gfs2_sbd *GFS2_SB(const struct inode *inode)\n{\n\treturn inode->i_sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/lockref.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ktime.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/completion.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dlm.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockref.h>\n#include <linux/percpu.h>\n#include <linux/ktime.h>\n#include <linux/rbtree.h>\n#include <linux/completion.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/buffer_head.h>\n#include <linux/dlm.h>\n#include <linux/workqueue.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n\nstatic inline struct gfs2_sbd *GFS2_SB(const struct inode *inode)\n{\n\treturn inode->i_sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic int gfs2_iter_unstuffed(struct gfs2_inode *ip, struct gfs2_ea_header *ea,\n\t\t\t       const char *din, char *dout)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tstruct buffer_head **bh;\n\tunsigned int amount = GFS2_EA_DATA_LEN(ea);\n\tunsigned int nptrs = DIV_ROUND_UP(amount, sdp->sd_jbsize);\n\t__be64 *dataptrs = GFS2_EA2DATAPTRS(ea);\n\tunsigned int x;\n\tint error = 0;\n\tunsigned char *pos;\n\tunsigned cp_size;\n\n\tbh = kcalloc(nptrs, sizeof(struct buffer_head *), GFP_NOFS);\n\tif (!bh)\n\t\treturn -ENOMEM;\n\n\tfor (x = 0; x < nptrs; x++) {\n\t\terror = gfs2_meta_read(ip->i_gl, be64_to_cpu(*dataptrs), 0,\n\t\t\t\t       bh + x);\n\t\tif (error) {\n\t\t\twhile (x--)\n\t\t\t\tbrelse(bh[x]);\n\t\t\tgoto out;\n\t\t}\n\t\tdataptrs++;\n\t}\n\n\tfor (x = 0; x < nptrs; x++) {\n\t\terror = gfs2_meta_wait(sdp, bh[x]);\n\t\tif (error) {\n\t\t\tfor (; x < nptrs; x++)\n\t\t\t\tbrelse(bh[x]);\n\t\t\tgoto out;\n\t\t}\n\t\tif (gfs2_metatype_check(sdp, bh[x], GFS2_METATYPE_ED)) {\n\t\t\tfor (; x < nptrs; x++)\n\t\t\t\tbrelse(bh[x]);\n\t\t\terror = -EIO;\n\t\t\tgoto out;\n\t\t}\n\n\t\tpos = bh[x]->b_data + sizeof(struct gfs2_meta_header);\n\t\tcp_size = (sdp->sd_jbsize > amount) ? amount : sdp->sd_jbsize;\n\n\t\tif (dout) {\n\t\t\tmemcpy(dout, pos, cp_size);\n\t\t\tdout += sdp->sd_jbsize;\n\t\t}\n\n\t\tif (din) {\n\t\t\tgfs2_trans_add_meta(ip->i_gl, bh[x]);\n\t\t\tmemcpy(pos, din, cp_size);\n\t\t\tdin += sdp->sd_jbsize;\n\t\t}\n\n\t\tamount -= sdp->sd_jbsize;\n\t\tbrelse(bh[x]);\n\t}\n\nout:\n\tkfree(bh);\n\treturn error;\n}"
  },
  {
    "function_name": "gfs2_listxattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
    "lines": "421-449",
    "snippet": "ssize_t gfs2_listxattr(struct dentry *dentry, char *buffer, size_t size)\n{\n\tstruct gfs2_inode *ip = GFS2_I(dentry->d_inode);\n\tstruct gfs2_ea_request er;\n\tstruct gfs2_holder i_gh;\n\tint error;\n\n\tmemset(&er, 0, sizeof(struct gfs2_ea_request));\n\tif (size) {\n\t\ter.er_data = buffer;\n\t\ter.er_data_len = size;\n\t}\n\n\terror = gfs2_glock_nq_init(ip->i_gl, LM_ST_SHARED, LM_FLAG_ANY, &i_gh);\n\tif (error)\n\t\treturn error;\n\n\tif (ip->i_eattr) {\n\t\tstruct ea_list ei = { .ei_er = &er, .ei_size = 0 };\n\n\t\terror = ea_foreach(ip, ea_list_i, &ei);\n\t\tif (!error)\n\t\t\terror = ei.ei_size;\n\t}\n\n\tgfs2_glock_dq_uninit(&i_gh);\n\n\treturn error;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"trans.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"inode.h\"",
      "#include \"glock.h\"",
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/xattr.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "gfs2_glock_dq_uninit",
          "args": [
            "&i_gh"
          ],
          "line": 446
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_glock_dq_uninit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/glock.c",
          "lines": "1110-1114",
          "snippet": "void gfs2_glock_dq_uninit(struct gfs2_holder *gh)\n{\n\tgfs2_glock_dq(gh);\n\tgfs2_holder_uninit(gh);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"bmap.h\"",
            "#include \"util.h\"",
            "#include \"super.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/lockref.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jhash.h>",
            "#include <linux/sort.h>",
            "#include <linux/delay.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"bmap.h\"\n#include \"util.h\"\n#include \"super.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/lockref.h>\n#include <linux/list_sort.h>\n#include <linux/percpu.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/jiffies.h>\n#include <linux/workqueue.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/module.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/jhash.h>\n#include <linux/sort.h>\n#include <linux/delay.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_glock_dq_uninit(struct gfs2_holder *gh)\n{\n\tgfs2_glock_dq(gh);\n\tgfs2_holder_uninit(gh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ea_foreach",
          "args": [
            "ip",
            "ea_list_i",
            "&ei"
          ],
          "line": 441
        },
        "resolved": true,
        "details": {
          "function_name": "ea_foreach",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "116-157",
          "snippet": "static int ea_foreach(struct gfs2_inode *ip, ea_call_t ea_call, void *data)\n{\n\tstruct buffer_head *bh, *eabh;\n\t__be64 *eablk, *end;\n\tint error;\n\n\terror = gfs2_meta_read(ip->i_gl, ip->i_eattr, DIO_WAIT, &bh);\n\tif (error)\n\t\treturn error;\n\n\tif (!(ip->i_diskflags & GFS2_DIF_EA_INDIRECT)) {\n\t\terror = ea_foreach_i(ip, bh, ea_call, data);\n\t\tgoto out;\n\t}\n\n\tif (gfs2_metatype_check(GFS2_SB(&ip->i_inode), bh, GFS2_METATYPE_IN)) {\n\t\terror = -EIO;\n\t\tgoto out;\n\t}\n\n\teablk = (__be64 *)(bh->b_data + sizeof(struct gfs2_meta_header));\n\tend = eablk + GFS2_SB(&ip->i_inode)->sd_inptrs;\n\n\tfor (; eablk < end; eablk++) {\n\t\tu64 bn;\n\n\t\tif (!*eablk)\n\t\t\tbreak;\n\t\tbn = be64_to_cpu(*eablk);\n\n\t\terror = gfs2_meta_read(ip->i_gl, bn, DIO_WAIT, &eabh);\n\t\tif (error)\n\t\t\tbreak;\n\t\terror = ea_foreach_i(ip, eabh, ea_call, data);\n\t\tbrelse(eabh);\n\t\tif (error)\n\t\t\tbreak;\n\t}\nout:\n\tbrelse(bh);\n\treturn error;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic int ea_foreach(struct gfs2_inode *ip, ea_call_t ea_call, void *data)\n{\n\tstruct buffer_head *bh, *eabh;\n\t__be64 *eablk, *end;\n\tint error;\n\n\terror = gfs2_meta_read(ip->i_gl, ip->i_eattr, DIO_WAIT, &bh);\n\tif (error)\n\t\treturn error;\n\n\tif (!(ip->i_diskflags & GFS2_DIF_EA_INDIRECT)) {\n\t\terror = ea_foreach_i(ip, bh, ea_call, data);\n\t\tgoto out;\n\t}\n\n\tif (gfs2_metatype_check(GFS2_SB(&ip->i_inode), bh, GFS2_METATYPE_IN)) {\n\t\terror = -EIO;\n\t\tgoto out;\n\t}\n\n\teablk = (__be64 *)(bh->b_data + sizeof(struct gfs2_meta_header));\n\tend = eablk + GFS2_SB(&ip->i_inode)->sd_inptrs;\n\n\tfor (; eablk < end; eablk++) {\n\t\tu64 bn;\n\n\t\tif (!*eablk)\n\t\t\tbreak;\n\t\tbn = be64_to_cpu(*eablk);\n\n\t\terror = gfs2_meta_read(ip->i_gl, bn, DIO_WAIT, &eabh);\n\t\tif (error)\n\t\t\tbreak;\n\t\terror = ea_foreach_i(ip, eabh, ea_call, data);\n\t\tbrelse(eabh);\n\t\tif (error)\n\t\t\tbreak;\n\t}\nout:\n\tbrelse(bh);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_glock_nq_init",
          "args": [
            "ip->i_gl",
            "LM_ST_SHARED",
            "LM_FLAG_ANY",
            "&i_gh"
          ],
          "line": 434
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_glock_nq_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/glock.h",
          "lines": "204-230",
          "snippet": "extern __printf(2, 3)\nvoid gfs2_print_dbg(struct seq_file *seq, const char *fmt, ...);\n\n/**\n * gfs2_glock_nq_init - initialize a holder and enqueue it on a glock\n * @gl: the glock\n * @state: the state we're requesting\n * @flags: the modifier flags\n * @gh: the holder structure\n *\n * Returns: 0, GLR_*, or errno\n */\n\nstatic inline int gfs2_glock_nq_init(struct gfs2_glock *gl,\n\t\t\t\t     unsigned int state, int flags,\n\t\t\t\t     struct gfs2_holder *gh)\n{\n\tint error;\n\n\tgfs2_holder_init(gl, state, flags, gh);\n\n\terror = gfs2_glock_nq(gh);\n\tif (error)\n\t\tgfs2_holder_uninit(gh);\n\n\treturn error;\n}",
          "includes": [
            "#include \"incore.h\"",
            "#include <linux/parser.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"incore.h\"\n#include <linux/parser.h>\n#include <linux/sched.h>\n\nextern __printf(2, 3)\nvoid gfs2_print_dbg(struct seq_file *seq, const char *fmt, ...);\n\n/**\n * gfs2_glock_nq_init - initialize a holder and enqueue it on a glock\n * @gl: the glock\n * @state: the state we're requesting\n * @flags: the modifier flags\n * @gh: the holder structure\n *\n * Returns: 0, GLR_*, or errno\n */\n\nstatic inline int gfs2_glock_nq_init(struct gfs2_glock *gl,\n\t\t\t\t     unsigned int state, int flags,\n\t\t\t\t     struct gfs2_holder *gh)\n{\n\tint error;\n\n\tgfs2_holder_init(gl, state, flags, gh);\n\n\terror = gfs2_glock_nq(gh);\n\tif (error)\n\t\tgfs2_holder_uninit(gh);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&er",
            "0",
            "sizeof(struct gfs2_ea_request)"
          ],
          "line": 428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GFS2_I",
          "args": [
            "dentry->d_inode"
          ],
          "line": 423
        },
        "resolved": true,
        "details": {
          "function_name": "GFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/incore.h",
          "lines": "408-411",
          "snippet": "static inline struct gfs2_inode *GFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct gfs2_inode, i_inode);\n}",
          "includes": [
            "#include <linux/lockref.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ktime.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/completion.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dlm.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockref.h>\n#include <linux/percpu.h>\n#include <linux/ktime.h>\n#include <linux/rbtree.h>\n#include <linux/completion.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/buffer_head.h>\n#include <linux/dlm.h>\n#include <linux/workqueue.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n\nstatic inline struct gfs2_inode *GFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct gfs2_inode, i_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nssize_t gfs2_listxattr(struct dentry *dentry, char *buffer, size_t size)\n{\n\tstruct gfs2_inode *ip = GFS2_I(dentry->d_inode);\n\tstruct gfs2_ea_request er;\n\tstruct gfs2_holder i_gh;\n\tint error;\n\n\tmemset(&er, 0, sizeof(struct gfs2_ea_request));\n\tif (size) {\n\t\ter.er_data = buffer;\n\t\ter.er_data_len = size;\n\t}\n\n\terror = gfs2_glock_nq_init(ip->i_gl, LM_ST_SHARED, LM_FLAG_ANY, &i_gh);\n\tif (error)\n\t\treturn error;\n\n\tif (ip->i_eattr) {\n\t\tstruct ea_list ei = { .ei_er = &er, .ei_size = 0 };\n\n\t\terror = ea_foreach(ip, ea_list_i, &ei);\n\t\tif (!error)\n\t\t\terror = ei.ei_size;\n\t}\n\n\tgfs2_glock_dq_uninit(&i_gh);\n\n\treturn error;\n}"
  },
  {
    "function_name": "ea_list_i",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
    "lines": "365-410",
    "snippet": "static int ea_list_i(struct gfs2_inode *ip, struct buffer_head *bh,\n\t\t     struct gfs2_ea_header *ea, struct gfs2_ea_header *prev,\n\t\t     void *private)\n{\n\tstruct ea_list *ei = private;\n\tstruct gfs2_ea_request *er = ei->ei_er;\n\tunsigned int ea_size = gfs2_ea_strlen(ea);\n\n\tif (ea->ea_type == GFS2_EATYPE_UNUSED)\n\t\treturn 0;\n\n\tif (er->er_data_len) {\n\t\tchar *prefix = NULL;\n\t\tunsigned int l = 0;\n\t\tchar c = 0;\n\n\t\tif (ei->ei_size + ea_size > er->er_data_len)\n\t\t\treturn -ERANGE;\n\n\t\tswitch (ea->ea_type) {\n\t\tcase GFS2_EATYPE_USR:\n\t\t\tprefix = \"user.\";\n\t\t\tl = 5;\n\t\t\tbreak;\n\t\tcase GFS2_EATYPE_SYS:\n\t\t\tprefix = \"system.\";\n\t\t\tl = 7;\n\t\t\tbreak;\n\t\tcase GFS2_EATYPE_SECURITY:\n\t\t\tprefix = \"security.\";\n\t\t\tl = 9;\n\t\t\tbreak;\n\t\t}\n\n\t\tBUG_ON(l == 0);\n\n\t\tmemcpy(er->er_data + ei->ei_size, prefix, l);\n\t\tmemcpy(er->er_data + ei->ei_size + l, GFS2_EA2NAME(ea),\n\t\t       ea->ea_name_len);\n\t\tmemcpy(er->er_data + ei->ei_size + ea_size - 1, &c, 1);\n\t}\n\n\tei->ei_size += ea_size;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"trans.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"inode.h\"",
      "#include \"glock.h\"",
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/xattr.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "er->er_data + ei->ei_size + ea_size - 1",
            "&c",
            "1"
          ],
          "line": 404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "er->er_data + ei->ei_size + l",
            "GFS2_EA2NAME(ea)",
            "ea->ea_name_len"
          ],
          "line": 402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GFS2_EA2NAME",
          "args": [
            "ea"
          ],
          "line": 402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "er->er_data + ei->ei_size",
            "prefix",
            "l"
          ],
          "line": 401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "l == 0"
          ],
          "line": 399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_ea_strlen",
          "args": [
            "ea"
          ],
          "line": 371
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic int ea_list_i(struct gfs2_inode *ip, struct buffer_head *bh,\n\t\t     struct gfs2_ea_header *ea, struct gfs2_ea_header *prev,\n\t\t     void *private)\n{\n\tstruct ea_list *ei = private;\n\tstruct gfs2_ea_request *er = ei->ei_er;\n\tunsigned int ea_size = gfs2_ea_strlen(ea);\n\n\tif (ea->ea_type == GFS2_EATYPE_UNUSED)\n\t\treturn 0;\n\n\tif (er->er_data_len) {\n\t\tchar *prefix = NULL;\n\t\tunsigned int l = 0;\n\t\tchar c = 0;\n\n\t\tif (ei->ei_size + ea_size > er->er_data_len)\n\t\t\treturn -ERANGE;\n\n\t\tswitch (ea->ea_type) {\n\t\tcase GFS2_EATYPE_USR:\n\t\t\tprefix = \"user.\";\n\t\t\tl = 5;\n\t\t\tbreak;\n\t\tcase GFS2_EATYPE_SYS:\n\t\t\tprefix = \"system.\";\n\t\t\tl = 7;\n\t\t\tbreak;\n\t\tcase GFS2_EATYPE_SECURITY:\n\t\t\tprefix = \"security.\";\n\t\t\tl = 9;\n\t\t\tbreak;\n\t\t}\n\n\t\tBUG_ON(l == 0);\n\n\t\tmemcpy(er->er_data + ei->ei_size, prefix, l);\n\t\tmemcpy(er->er_data + ei->ei_size + l, GFS2_EA2NAME(ea),\n\t\t       ea->ea_name_len);\n\t\tmemcpy(er->er_data + ei->ei_size + ea_size - 1, &c, 1);\n\t}\n\n\tei->ei_size += ea_size;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "gfs2_ea_strlen",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
    "lines": "351-363",
    "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"trans.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"inode.h\"",
      "#include \"glock.h\"",
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/xattr.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
  },
  {
    "function_name": "ea_remove_unstuffed",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
    "lines": "325-344",
    "snippet": "static int ea_remove_unstuffed(struct gfs2_inode *ip, struct buffer_head *bh,\n\t\t\t       struct gfs2_ea_header *ea,\n\t\t\t       struct gfs2_ea_header *prev, int leave)\n{\n\tint error;\n\n\terror = gfs2_rindex_update(GFS2_SB(&ip->i_inode));\n\tif (error)\n\t\treturn error;\n\n\terror = gfs2_quota_hold(ip, NO_UID_QUOTA_CHANGE, NO_GID_QUOTA_CHANGE);\n\tif (error)\n\t\tgoto out_alloc;\n\n\terror = ea_dealloc_unstuffed(ip, bh, ea, prev, (leave) ? &error : NULL);\n\n\tgfs2_quota_unhold(ip);\nout_alloc:\n\treturn error;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"trans.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"inode.h\"",
      "#include \"glock.h\"",
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/xattr.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "gfs2_quota_unhold",
          "args": [
            "ip"
          ],
          "line": 341
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_quota_unhold",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.c",
          "lines": "587-601",
          "snippet": "void gfs2_quota_unhold(struct gfs2_inode *ip)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tunsigned int x;\n\n\tif (ip->i_res == NULL)\n\t\treturn;\n\tgfs2_assert_warn(sdp, !test_bit(GIF_QD_LOCKED, &ip->i_flags));\n\n\tfor (x = 0; x < ip->i_res->rs_qa_qd_num; x++) {\n\t\tqdsb_put(ip->i_res->rs_qa_qd[x]);\n\t\tip->i_res->rs_qa_qd[x] = NULL;\n\t}\n\tip->i_res->rs_qa_qd_num = 0;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_quota_unhold(struct gfs2_inode *ip)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tunsigned int x;\n\n\tif (ip->i_res == NULL)\n\t\treturn;\n\tgfs2_assert_warn(sdp, !test_bit(GIF_QD_LOCKED, &ip->i_flags));\n\n\tfor (x = 0; x < ip->i_res->rs_qa_qd_num; x++) {\n\t\tqdsb_put(ip->i_res->rs_qa_qd[x]);\n\t\tip->i_res->rs_qa_qd[x] = NULL;\n\t}\n\tip->i_res->rs_qa_qd_num = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ea_dealloc_unstuffed",
          "args": [
            "ip",
            "bh",
            "ea",
            "prev",
            "(leave) ? &error : NULL"
          ],
          "line": 339
        },
        "resolved": true,
        "details": {
          "function_name": "ea_dealloc_unstuffed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "225-323",
          "snippet": "static int ea_dealloc_unstuffed(struct gfs2_inode *ip, struct buffer_head *bh,\n\t\t\t\tstruct gfs2_ea_header *ea,\n\t\t\t\tstruct gfs2_ea_header *prev, void *private)\n{\n\tint *leave = private;\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tstruct gfs2_rgrpd *rgd;\n\tstruct gfs2_holder rg_gh;\n\tstruct buffer_head *dibh;\n\t__be64 *dataptrs;\n\tu64 bn = 0;\n\tu64 bstart = 0;\n\tunsigned int blen = 0;\n\tunsigned int blks = 0;\n\tunsigned int x;\n\tint error;\n\n\terror = gfs2_rindex_update(sdp);\n\tif (error)\n\t\treturn error;\n\n\tif (GFS2_EA_IS_STUFFED(ea))\n\t\treturn 0;\n\n\tdataptrs = GFS2_EA2DATAPTRS(ea);\n\tfor (x = 0; x < ea->ea_num_ptrs; x++, dataptrs++) {\n\t\tif (*dataptrs) {\n\t\t\tblks++;\n\t\t\tbn = be64_to_cpu(*dataptrs);\n\t\t}\n\t}\n\tif (!blks)\n\t\treturn 0;\n\n\trgd = gfs2_blk2rgrpd(sdp, bn, 1);\n\tif (!rgd) {\n\t\tgfs2_consist_inode(ip);\n\t\treturn -EIO;\n\t}\n\n\terror = gfs2_glock_nq_init(rgd->rd_gl, LM_ST_EXCLUSIVE, 0, &rg_gh);\n\tif (error)\n\t\treturn error;\n\n\terror = gfs2_trans_begin(sdp, rgd->rd_length + RES_DINODE +\n\t\t\t\t RES_EATTR + RES_STATFS + RES_QUOTA, blks);\n\tif (error)\n\t\tgoto out_gunlock;\n\n\tgfs2_trans_add_meta(ip->i_gl, bh);\n\n\tdataptrs = GFS2_EA2DATAPTRS(ea);\n\tfor (x = 0; x < ea->ea_num_ptrs; x++, dataptrs++) {\n\t\tif (!*dataptrs)\n\t\t\tbreak;\n\t\tbn = be64_to_cpu(*dataptrs);\n\n\t\tif (bstart + blen == bn)\n\t\t\tblen++;\n\t\telse {\n\t\t\tif (bstart)\n\t\t\t\tgfs2_free_meta(ip, bstart, blen);\n\t\t\tbstart = bn;\n\t\t\tblen = 1;\n\t\t}\n\n\t\t*dataptrs = 0;\n\t\tgfs2_add_inode_blocks(&ip->i_inode, -1);\n\t}\n\tif (bstart)\n\t\tgfs2_free_meta(ip, bstart, blen);\n\n\tif (prev && !leave) {\n\t\tu32 len;\n\n\t\tlen = GFS2_EA_REC_LEN(prev) + GFS2_EA_REC_LEN(ea);\n\t\tprev->ea_rec_len = cpu_to_be32(len);\n\n\t\tif (GFS2_EA_IS_LAST(ea))\n\t\t\tprev->ea_flags |= GFS2_EAFLAG_LAST;\n\t} else {\n\t\tea->ea_type = GFS2_EATYPE_UNUSED;\n\t\tea->ea_num_ptrs = 0;\n\t}\n\n\terror = gfs2_meta_inode_buffer(ip, &dibh);\n\tif (!error) {\n\t\tip->i_inode.i_ctime = CURRENT_TIME;\n\t\tgfs2_trans_add_meta(ip->i_gl, dibh);\n\t\tgfs2_dinode_out(ip, dibh->b_data);\n\t\tbrelse(dibh);\n\t}\n\n\tgfs2_trans_end(sdp);\n\nout_gunlock:\n\tgfs2_glock_dq_uninit(&rg_gh);\n\treturn error;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic int ea_dealloc_unstuffed(struct gfs2_inode *ip, struct buffer_head *bh,\n\t\t\t\tstruct gfs2_ea_header *ea,\n\t\t\t\tstruct gfs2_ea_header *prev, void *private)\n{\n\tint *leave = private;\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tstruct gfs2_rgrpd *rgd;\n\tstruct gfs2_holder rg_gh;\n\tstruct buffer_head *dibh;\n\t__be64 *dataptrs;\n\tu64 bn = 0;\n\tu64 bstart = 0;\n\tunsigned int blen = 0;\n\tunsigned int blks = 0;\n\tunsigned int x;\n\tint error;\n\n\terror = gfs2_rindex_update(sdp);\n\tif (error)\n\t\treturn error;\n\n\tif (GFS2_EA_IS_STUFFED(ea))\n\t\treturn 0;\n\n\tdataptrs = GFS2_EA2DATAPTRS(ea);\n\tfor (x = 0; x < ea->ea_num_ptrs; x++, dataptrs++) {\n\t\tif (*dataptrs) {\n\t\t\tblks++;\n\t\t\tbn = be64_to_cpu(*dataptrs);\n\t\t}\n\t}\n\tif (!blks)\n\t\treturn 0;\n\n\trgd = gfs2_blk2rgrpd(sdp, bn, 1);\n\tif (!rgd) {\n\t\tgfs2_consist_inode(ip);\n\t\treturn -EIO;\n\t}\n\n\terror = gfs2_glock_nq_init(rgd->rd_gl, LM_ST_EXCLUSIVE, 0, &rg_gh);\n\tif (error)\n\t\treturn error;\n\n\terror = gfs2_trans_begin(sdp, rgd->rd_length + RES_DINODE +\n\t\t\t\t RES_EATTR + RES_STATFS + RES_QUOTA, blks);\n\tif (error)\n\t\tgoto out_gunlock;\n\n\tgfs2_trans_add_meta(ip->i_gl, bh);\n\n\tdataptrs = GFS2_EA2DATAPTRS(ea);\n\tfor (x = 0; x < ea->ea_num_ptrs; x++, dataptrs++) {\n\t\tif (!*dataptrs)\n\t\t\tbreak;\n\t\tbn = be64_to_cpu(*dataptrs);\n\n\t\tif (bstart + blen == bn)\n\t\t\tblen++;\n\t\telse {\n\t\t\tif (bstart)\n\t\t\t\tgfs2_free_meta(ip, bstart, blen);\n\t\t\tbstart = bn;\n\t\t\tblen = 1;\n\t\t}\n\n\t\t*dataptrs = 0;\n\t\tgfs2_add_inode_blocks(&ip->i_inode, -1);\n\t}\n\tif (bstart)\n\t\tgfs2_free_meta(ip, bstart, blen);\n\n\tif (prev && !leave) {\n\t\tu32 len;\n\n\t\tlen = GFS2_EA_REC_LEN(prev) + GFS2_EA_REC_LEN(ea);\n\t\tprev->ea_rec_len = cpu_to_be32(len);\n\n\t\tif (GFS2_EA_IS_LAST(ea))\n\t\t\tprev->ea_flags |= GFS2_EAFLAG_LAST;\n\t} else {\n\t\tea->ea_type = GFS2_EATYPE_UNUSED;\n\t\tea->ea_num_ptrs = 0;\n\t}\n\n\terror = gfs2_meta_inode_buffer(ip, &dibh);\n\tif (!error) {\n\t\tip->i_inode.i_ctime = CURRENT_TIME;\n\t\tgfs2_trans_add_meta(ip->i_gl, dibh);\n\t\tgfs2_dinode_out(ip, dibh->b_data);\n\t\tbrelse(dibh);\n\t}\n\n\tgfs2_trans_end(sdp);\n\nout_gunlock:\n\tgfs2_glock_dq_uninit(&rg_gh);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_quota_hold",
          "args": [
            "ip",
            "NO_UID_QUOTA_CHANGE",
            "NO_GID_QUOTA_CHANGE"
          ],
          "line": 335
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_quota_hold",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.c",
          "lines": "530-585",
          "snippet": "int gfs2_quota_hold(struct gfs2_inode *ip, kuid_t uid, kgid_t gid)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tstruct gfs2_quota_data **qd;\n\tint error;\n\n\tif (ip->i_res == NULL) {\n\t\terror = gfs2_rs_alloc(ip);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\tqd = ip->i_res->rs_qa_qd;\n\n\tif (gfs2_assert_warn(sdp, !ip->i_res->rs_qa_qd_num) ||\n\t    gfs2_assert_warn(sdp, !test_bit(GIF_QD_LOCKED, &ip->i_flags)))\n\t\treturn -EIO;\n\n\tif (sdp->sd_args.ar_quota == GFS2_QUOTA_OFF)\n\t\treturn 0;\n\n\terror = qdsb_get(sdp, make_kqid_uid(ip->i_inode.i_uid), qd);\n\tif (error)\n\t\tgoto out;\n\tip->i_res->rs_qa_qd_num++;\n\tqd++;\n\n\terror = qdsb_get(sdp, make_kqid_gid(ip->i_inode.i_gid), qd);\n\tif (error)\n\t\tgoto out;\n\tip->i_res->rs_qa_qd_num++;\n\tqd++;\n\n\tif (!uid_eq(uid, NO_UID_QUOTA_CHANGE) &&\n\t    !uid_eq(uid, ip->i_inode.i_uid)) {\n\t\terror = qdsb_get(sdp, make_kqid_uid(uid), qd);\n\t\tif (error)\n\t\t\tgoto out;\n\t\tip->i_res->rs_qa_qd_num++;\n\t\tqd++;\n\t}\n\n\tif (!gid_eq(gid, NO_GID_QUOTA_CHANGE) &&\n\t    !gid_eq(gid, ip->i_inode.i_gid)) {\n\t\terror = qdsb_get(sdp, make_kqid_gid(gid), qd);\n\t\tif (error)\n\t\t\tgoto out;\n\t\tip->i_res->rs_qa_qd_num++;\n\t\tqd++;\n\t}\n\nout:\n\tif (error)\n\t\tgfs2_quota_unhold(ip);\n\treturn error;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nint gfs2_quota_hold(struct gfs2_inode *ip, kuid_t uid, kgid_t gid)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tstruct gfs2_quota_data **qd;\n\tint error;\n\n\tif (ip->i_res == NULL) {\n\t\terror = gfs2_rs_alloc(ip);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\tqd = ip->i_res->rs_qa_qd;\n\n\tif (gfs2_assert_warn(sdp, !ip->i_res->rs_qa_qd_num) ||\n\t    gfs2_assert_warn(sdp, !test_bit(GIF_QD_LOCKED, &ip->i_flags)))\n\t\treturn -EIO;\n\n\tif (sdp->sd_args.ar_quota == GFS2_QUOTA_OFF)\n\t\treturn 0;\n\n\terror = qdsb_get(sdp, make_kqid_uid(ip->i_inode.i_uid), qd);\n\tif (error)\n\t\tgoto out;\n\tip->i_res->rs_qa_qd_num++;\n\tqd++;\n\n\terror = qdsb_get(sdp, make_kqid_gid(ip->i_inode.i_gid), qd);\n\tif (error)\n\t\tgoto out;\n\tip->i_res->rs_qa_qd_num++;\n\tqd++;\n\n\tif (!uid_eq(uid, NO_UID_QUOTA_CHANGE) &&\n\t    !uid_eq(uid, ip->i_inode.i_uid)) {\n\t\terror = qdsb_get(sdp, make_kqid_uid(uid), qd);\n\t\tif (error)\n\t\t\tgoto out;\n\t\tip->i_res->rs_qa_qd_num++;\n\t\tqd++;\n\t}\n\n\tif (!gid_eq(gid, NO_GID_QUOTA_CHANGE) &&\n\t    !gid_eq(gid, ip->i_inode.i_gid)) {\n\t\terror = qdsb_get(sdp, make_kqid_gid(gid), qd);\n\t\tif (error)\n\t\t\tgoto out;\n\t\tip->i_res->rs_qa_qd_num++;\n\t\tqd++;\n\t}\n\nout:\n\tif (error)\n\t\tgfs2_quota_unhold(ip);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_rindex_update",
          "args": [
            "GFS2_SB(&ip->i_inode)"
          ],
          "line": 331
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_rindex_update",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
          "lines": "1029-1052",
          "snippet": "int gfs2_rindex_update(struct gfs2_sbd *sdp)\n{\n\tstruct gfs2_inode *ip = GFS2_I(sdp->sd_rindex);\n\tstruct gfs2_glock *gl = ip->i_gl;\n\tstruct gfs2_holder ri_gh;\n\tint error = 0;\n\tint unlock_required = 0;\n\n\t/* Read new copy from disk if we don't have the latest */\n\tif (!sdp->sd_rindex_uptodate) {\n\t\tif (!gfs2_glock_is_locked_by_me(gl)) {\n\t\t\terror = gfs2_glock_nq_init(gl, LM_ST_SHARED, 0, &ri_gh);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\tunlock_required = 1;\n\t\t}\n\t\tif (!sdp->sd_rindex_uptodate)\n\t\t\terror = gfs2_ri_update(ip);\n\t\tif (unlock_required)\n\t\t\tgfs2_glock_dq_uninit(&ri_gh);\n\t}\n\n\treturn error;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"inode.h\"",
            "#include \"log.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/random.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nint gfs2_rindex_update(struct gfs2_sbd *sdp)\n{\n\tstruct gfs2_inode *ip = GFS2_I(sdp->sd_rindex);\n\tstruct gfs2_glock *gl = ip->i_gl;\n\tstruct gfs2_holder ri_gh;\n\tint error = 0;\n\tint unlock_required = 0;\n\n\t/* Read new copy from disk if we don't have the latest */\n\tif (!sdp->sd_rindex_uptodate) {\n\t\tif (!gfs2_glock_is_locked_by_me(gl)) {\n\t\t\terror = gfs2_glock_nq_init(gl, LM_ST_SHARED, 0, &ri_gh);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\tunlock_required = 1;\n\t\t}\n\t\tif (!sdp->sd_rindex_uptodate)\n\t\t\terror = gfs2_ri_update(ip);\n\t\tif (unlock_required)\n\t\t\tgfs2_glock_dq_uninit(&ri_gh);\n\t}\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GFS2_SB",
          "args": [
            "&ip->i_inode"
          ],
          "line": 331
        },
        "resolved": true,
        "details": {
          "function_name": "GFS2_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/incore.h",
          "lines": "413-416",
          "snippet": "static inline struct gfs2_sbd *GFS2_SB(const struct inode *inode)\n{\n\treturn inode->i_sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/lockref.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ktime.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/completion.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dlm.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockref.h>\n#include <linux/percpu.h>\n#include <linux/ktime.h>\n#include <linux/rbtree.h>\n#include <linux/completion.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/buffer_head.h>\n#include <linux/dlm.h>\n#include <linux/workqueue.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n\nstatic inline struct gfs2_sbd *GFS2_SB(const struct inode *inode)\n{\n\treturn inode->i_sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic int ea_remove_unstuffed(struct gfs2_inode *ip, struct buffer_head *bh,\n\t\t\t       struct gfs2_ea_header *ea,\n\t\t\t       struct gfs2_ea_header *prev, int leave)\n{\n\tint error;\n\n\terror = gfs2_rindex_update(GFS2_SB(&ip->i_inode));\n\tif (error)\n\t\treturn error;\n\n\terror = gfs2_quota_hold(ip, NO_UID_QUOTA_CHANGE, NO_GID_QUOTA_CHANGE);\n\tif (error)\n\t\tgoto out_alloc;\n\n\terror = ea_dealloc_unstuffed(ip, bh, ea, prev, (leave) ? &error : NULL);\n\n\tgfs2_quota_unhold(ip);\nout_alloc:\n\treturn error;\n}"
  },
  {
    "function_name": "ea_dealloc_unstuffed",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
    "lines": "225-323",
    "snippet": "static int ea_dealloc_unstuffed(struct gfs2_inode *ip, struct buffer_head *bh,\n\t\t\t\tstruct gfs2_ea_header *ea,\n\t\t\t\tstruct gfs2_ea_header *prev, void *private)\n{\n\tint *leave = private;\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tstruct gfs2_rgrpd *rgd;\n\tstruct gfs2_holder rg_gh;\n\tstruct buffer_head *dibh;\n\t__be64 *dataptrs;\n\tu64 bn = 0;\n\tu64 bstart = 0;\n\tunsigned int blen = 0;\n\tunsigned int blks = 0;\n\tunsigned int x;\n\tint error;\n\n\terror = gfs2_rindex_update(sdp);\n\tif (error)\n\t\treturn error;\n\n\tif (GFS2_EA_IS_STUFFED(ea))\n\t\treturn 0;\n\n\tdataptrs = GFS2_EA2DATAPTRS(ea);\n\tfor (x = 0; x < ea->ea_num_ptrs; x++, dataptrs++) {\n\t\tif (*dataptrs) {\n\t\t\tblks++;\n\t\t\tbn = be64_to_cpu(*dataptrs);\n\t\t}\n\t}\n\tif (!blks)\n\t\treturn 0;\n\n\trgd = gfs2_blk2rgrpd(sdp, bn, 1);\n\tif (!rgd) {\n\t\tgfs2_consist_inode(ip);\n\t\treturn -EIO;\n\t}\n\n\terror = gfs2_glock_nq_init(rgd->rd_gl, LM_ST_EXCLUSIVE, 0, &rg_gh);\n\tif (error)\n\t\treturn error;\n\n\terror = gfs2_trans_begin(sdp, rgd->rd_length + RES_DINODE +\n\t\t\t\t RES_EATTR + RES_STATFS + RES_QUOTA, blks);\n\tif (error)\n\t\tgoto out_gunlock;\n\n\tgfs2_trans_add_meta(ip->i_gl, bh);\n\n\tdataptrs = GFS2_EA2DATAPTRS(ea);\n\tfor (x = 0; x < ea->ea_num_ptrs; x++, dataptrs++) {\n\t\tif (!*dataptrs)\n\t\t\tbreak;\n\t\tbn = be64_to_cpu(*dataptrs);\n\n\t\tif (bstart + blen == bn)\n\t\t\tblen++;\n\t\telse {\n\t\t\tif (bstart)\n\t\t\t\tgfs2_free_meta(ip, bstart, blen);\n\t\t\tbstart = bn;\n\t\t\tblen = 1;\n\t\t}\n\n\t\t*dataptrs = 0;\n\t\tgfs2_add_inode_blocks(&ip->i_inode, -1);\n\t}\n\tif (bstart)\n\t\tgfs2_free_meta(ip, bstart, blen);\n\n\tif (prev && !leave) {\n\t\tu32 len;\n\n\t\tlen = GFS2_EA_REC_LEN(prev) + GFS2_EA_REC_LEN(ea);\n\t\tprev->ea_rec_len = cpu_to_be32(len);\n\n\t\tif (GFS2_EA_IS_LAST(ea))\n\t\t\tprev->ea_flags |= GFS2_EAFLAG_LAST;\n\t} else {\n\t\tea->ea_type = GFS2_EATYPE_UNUSED;\n\t\tea->ea_num_ptrs = 0;\n\t}\n\n\terror = gfs2_meta_inode_buffer(ip, &dibh);\n\tif (!error) {\n\t\tip->i_inode.i_ctime = CURRENT_TIME;\n\t\tgfs2_trans_add_meta(ip->i_gl, dibh);\n\t\tgfs2_dinode_out(ip, dibh->b_data);\n\t\tbrelse(dibh);\n\t}\n\n\tgfs2_trans_end(sdp);\n\nout_gunlock:\n\tgfs2_glock_dq_uninit(&rg_gh);\n\treturn error;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"trans.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"inode.h\"",
      "#include \"glock.h\"",
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/xattr.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "gfs2_glock_dq_uninit",
          "args": [
            "&rg_gh"
          ],
          "line": 321
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_glock_dq_uninit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/glock.c",
          "lines": "1110-1114",
          "snippet": "void gfs2_glock_dq_uninit(struct gfs2_holder *gh)\n{\n\tgfs2_glock_dq(gh);\n\tgfs2_holder_uninit(gh);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"bmap.h\"",
            "#include \"util.h\"",
            "#include \"super.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/lockref.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jhash.h>",
            "#include <linux/sort.h>",
            "#include <linux/delay.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"bmap.h\"\n#include \"util.h\"\n#include \"super.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/lockref.h>\n#include <linux/list_sort.h>\n#include <linux/percpu.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/jiffies.h>\n#include <linux/workqueue.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/module.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/jhash.h>\n#include <linux/sort.h>\n#include <linux/delay.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_glock_dq_uninit(struct gfs2_holder *gh)\n{\n\tgfs2_glock_dq(gh);\n\tgfs2_holder_uninit(gh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_trans_end",
          "args": [
            "sdp"
          ],
          "line": 318
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_trans_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/trans.c",
          "lines": "88-123",
          "snippet": "void gfs2_trans_end(struct gfs2_sbd *sdp)\n{\n\tstruct gfs2_trans *tr = current->journal_info;\n\ts64 nbuf;\n\tint alloced = tr->tr_alloced;\n\n\tBUG_ON(!tr);\n\tcurrent->journal_info = NULL;\n\n\tif (!tr->tr_touched) {\n\t\tgfs2_log_release(sdp, tr->tr_reserved);\n\t\tif (alloced) {\n\t\t\tkfree(tr);\n\t\t\tsb_end_intwrite(sdp->sd_vfs);\n\t\t}\n\t\treturn;\n\t}\n\n\tnbuf = tr->tr_num_buf_new + tr->tr_num_databuf_new;\n\tnbuf -= tr->tr_num_buf_rm;\n\tnbuf -= tr->tr_num_databuf_rm;\n\n\tif (gfs2_assert_withdraw(sdp, (nbuf <= tr->tr_blocks) &&\n\t\t\t\t       (tr->tr_num_revoke <= tr->tr_revokes)))\n\t\tgfs2_print_trans(tr);\n\n\tgfs2_log_commit(sdp, tr);\n\tif (alloced && !tr->tr_attached)\n\t\t\tkfree(tr);\n\tup_read(&sdp->sd_log_flush_lock);\n\n\tif (sdp->sd_vfs->s_flags & MS_SYNCHRONOUS)\n\t\tgfs2_log_flush(sdp, NULL, NORMAL_FLUSH);\n\tif (alloced)\n\t\tsb_end_intwrite(sdp->sd_vfs);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_trans_end(struct gfs2_sbd *sdp)\n{\n\tstruct gfs2_trans *tr = current->journal_info;\n\ts64 nbuf;\n\tint alloced = tr->tr_alloced;\n\n\tBUG_ON(!tr);\n\tcurrent->journal_info = NULL;\n\n\tif (!tr->tr_touched) {\n\t\tgfs2_log_release(sdp, tr->tr_reserved);\n\t\tif (alloced) {\n\t\t\tkfree(tr);\n\t\t\tsb_end_intwrite(sdp->sd_vfs);\n\t\t}\n\t\treturn;\n\t}\n\n\tnbuf = tr->tr_num_buf_new + tr->tr_num_databuf_new;\n\tnbuf -= tr->tr_num_buf_rm;\n\tnbuf -= tr->tr_num_databuf_rm;\n\n\tif (gfs2_assert_withdraw(sdp, (nbuf <= tr->tr_blocks) &&\n\t\t\t\t       (tr->tr_num_revoke <= tr->tr_revokes)))\n\t\tgfs2_print_trans(tr);\n\n\tgfs2_log_commit(sdp, tr);\n\tif (alloced && !tr->tr_attached)\n\t\t\tkfree(tr);\n\tup_read(&sdp->sd_log_flush_lock);\n\n\tif (sdp->sd_vfs->s_flags & MS_SYNCHRONOUS)\n\t\tgfs2_log_flush(sdp, NULL, NORMAL_FLUSH);\n\tif (alloced)\n\t\tsb_end_intwrite(sdp->sd_vfs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "dibh"
          ],
          "line": 315
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_dinode_out",
          "args": [
            "ip",
            "dibh->b_data"
          ],
          "line": 314
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_dinode_out",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/super.c",
          "lines": "696-731",
          "snippet": "void gfs2_dinode_out(const struct gfs2_inode *ip, void *buf)\n{\n\tstruct gfs2_dinode *str = buf;\n\n\tstr->di_header.mh_magic = cpu_to_be32(GFS2_MAGIC);\n\tstr->di_header.mh_type = cpu_to_be32(GFS2_METATYPE_DI);\n\tstr->di_header.mh_format = cpu_to_be32(GFS2_FORMAT_DI);\n\tstr->di_num.no_addr = cpu_to_be64(ip->i_no_addr);\n\tstr->di_num.no_formal_ino = cpu_to_be64(ip->i_no_formal_ino);\n\tstr->di_mode = cpu_to_be32(ip->i_inode.i_mode);\n\tstr->di_uid = cpu_to_be32(i_uid_read(&ip->i_inode));\n\tstr->di_gid = cpu_to_be32(i_gid_read(&ip->i_inode));\n\tstr->di_nlink = cpu_to_be32(ip->i_inode.i_nlink);\n\tstr->di_size = cpu_to_be64(i_size_read(&ip->i_inode));\n\tstr->di_blocks = cpu_to_be64(gfs2_get_inode_blocks(&ip->i_inode));\n\tstr->di_atime = cpu_to_be64(ip->i_inode.i_atime.tv_sec);\n\tstr->di_mtime = cpu_to_be64(ip->i_inode.i_mtime.tv_sec);\n\tstr->di_ctime = cpu_to_be64(ip->i_inode.i_ctime.tv_sec);\n\n\tstr->di_goal_meta = cpu_to_be64(ip->i_goal);\n\tstr->di_goal_data = cpu_to_be64(ip->i_goal);\n\tstr->di_generation = cpu_to_be64(ip->i_generation);\n\n\tstr->di_flags = cpu_to_be32(ip->i_diskflags);\n\tstr->di_height = cpu_to_be16(ip->i_height);\n\tstr->di_payload_format = cpu_to_be32(S_ISDIR(ip->i_inode.i_mode) &&\n\t\t\t\t\t     !(ip->i_diskflags & GFS2_DIF_EXHASH) ?\n\t\t\t\t\t     GFS2_FORMAT_DE : 0);\n\tstr->di_depth = cpu_to_be16(ip->i_depth);\n\tstr->di_entries = cpu_to_be32(ip->i_entries);\n\n\tstr->di_eattr = cpu_to_be64(ip->i_eattr);\n\tstr->di_atime_nsec = cpu_to_be32(ip->i_inode.i_atime.tv_nsec);\n\tstr->di_mtime_nsec = cpu_to_be32(ip->i_inode.i_mtime.tv_nsec);\n\tstr->di_ctime_nsec = cpu_to_be32(ip->i_inode.i_ctime.tv_nsec);\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"sys.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"recovery.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"dir.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/kernel.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/time.h>",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/statfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/bio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"sys.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"recovery.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"dir.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/kernel.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/time.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/statfs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/bio.h>\n\nvoid gfs2_dinode_out(const struct gfs2_inode *ip, void *buf)\n{\n\tstruct gfs2_dinode *str = buf;\n\n\tstr->di_header.mh_magic = cpu_to_be32(GFS2_MAGIC);\n\tstr->di_header.mh_type = cpu_to_be32(GFS2_METATYPE_DI);\n\tstr->di_header.mh_format = cpu_to_be32(GFS2_FORMAT_DI);\n\tstr->di_num.no_addr = cpu_to_be64(ip->i_no_addr);\n\tstr->di_num.no_formal_ino = cpu_to_be64(ip->i_no_formal_ino);\n\tstr->di_mode = cpu_to_be32(ip->i_inode.i_mode);\n\tstr->di_uid = cpu_to_be32(i_uid_read(&ip->i_inode));\n\tstr->di_gid = cpu_to_be32(i_gid_read(&ip->i_inode));\n\tstr->di_nlink = cpu_to_be32(ip->i_inode.i_nlink);\n\tstr->di_size = cpu_to_be64(i_size_read(&ip->i_inode));\n\tstr->di_blocks = cpu_to_be64(gfs2_get_inode_blocks(&ip->i_inode));\n\tstr->di_atime = cpu_to_be64(ip->i_inode.i_atime.tv_sec);\n\tstr->di_mtime = cpu_to_be64(ip->i_inode.i_mtime.tv_sec);\n\tstr->di_ctime = cpu_to_be64(ip->i_inode.i_ctime.tv_sec);\n\n\tstr->di_goal_meta = cpu_to_be64(ip->i_goal);\n\tstr->di_goal_data = cpu_to_be64(ip->i_goal);\n\tstr->di_generation = cpu_to_be64(ip->i_generation);\n\n\tstr->di_flags = cpu_to_be32(ip->i_diskflags);\n\tstr->di_height = cpu_to_be16(ip->i_height);\n\tstr->di_payload_format = cpu_to_be32(S_ISDIR(ip->i_inode.i_mode) &&\n\t\t\t\t\t     !(ip->i_diskflags & GFS2_DIF_EXHASH) ?\n\t\t\t\t\t     GFS2_FORMAT_DE : 0);\n\tstr->di_depth = cpu_to_be16(ip->i_depth);\n\tstr->di_entries = cpu_to_be32(ip->i_entries);\n\n\tstr->di_eattr = cpu_to_be64(ip->i_eattr);\n\tstr->di_atime_nsec = cpu_to_be32(ip->i_inode.i_atime.tv_nsec);\n\tstr->di_mtime_nsec = cpu_to_be32(ip->i_inode.i_mtime.tv_nsec);\n\tstr->di_ctime_nsec = cpu_to_be32(ip->i_inode.i_ctime.tv_nsec);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_trans_add_meta",
          "args": [
            "ip->i_gl",
            "dibh"
          ],
          "line": 313
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_trans_add_meta",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/trans.c",
          "lines": "224-247",
          "snippet": "void gfs2_trans_add_meta(struct gfs2_glock *gl, struct buffer_head *bh)\n{\n\n\tstruct gfs2_sbd *sdp = gl->gl_sbd;\n\tstruct gfs2_bufdata *bd;\n\n\tlock_buffer(bh);\n\tgfs2_log_lock(sdp);\n\tbd = bh->b_private;\n\tif (bd == NULL) {\n\t\tgfs2_log_unlock(sdp);\n\t\tunlock_buffer(bh);\n\t\tlock_page(bh->b_page);\n\t\tif (bh->b_private == NULL)\n\t\t\tbd = gfs2_alloc_bufdata(gl, bh, &gfs2_buf_lops);\n\t\tunlock_page(bh->b_page);\n\t\tlock_buffer(bh);\n\t\tgfs2_log_lock(sdp);\n\t}\n\tgfs2_assert(sdp, bd->bd_gl == gl);\n\tmeta_lo_add(sdp, bd);\n\tgfs2_log_unlock(sdp);\n\tunlock_buffer(bh);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_trans_add_meta(struct gfs2_glock *gl, struct buffer_head *bh)\n{\n\n\tstruct gfs2_sbd *sdp = gl->gl_sbd;\n\tstruct gfs2_bufdata *bd;\n\n\tlock_buffer(bh);\n\tgfs2_log_lock(sdp);\n\tbd = bh->b_private;\n\tif (bd == NULL) {\n\t\tgfs2_log_unlock(sdp);\n\t\tunlock_buffer(bh);\n\t\tlock_page(bh->b_page);\n\t\tif (bh->b_private == NULL)\n\t\t\tbd = gfs2_alloc_bufdata(gl, bh, &gfs2_buf_lops);\n\t\tunlock_page(bh->b_page);\n\t\tlock_buffer(bh);\n\t\tgfs2_log_lock(sdp);\n\t}\n\tgfs2_assert(sdp, bd->bd_gl == gl);\n\tmeta_lo_add(sdp, bd);\n\tgfs2_log_unlock(sdp);\n\tunlock_buffer(bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_meta_inode_buffer",
          "args": [
            "ip",
            "&dibh"
          ],
          "line": 310
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_meta_inode_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/meta_io.h",
          "lines": "66-70",
          "snippet": "static inline int gfs2_meta_inode_buffer(struct gfs2_inode *ip,\n\t\t\t\t\t struct buffer_head **bhp)\n{\n\treturn gfs2_meta_indirect_buffer(ip, 0, ip->i_no_addr, bhp);\n}",
          "includes": [
            "#include \"incore.h\"",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"incore.h\"\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline int gfs2_meta_inode_buffer(struct gfs2_inode *ip,\n\t\t\t\t\t struct buffer_head **bhp)\n{\n\treturn gfs2_meta_indirect_buffer(ip, 0, ip->i_no_addr, bhp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "GFS2_EA_IS_LAST",
          "args": [
            "ea"
          ],
          "line": 303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "len"
          ],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GFS2_EA_REC_LEN",
          "args": [
            "ea"
          ],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GFS2_EA_REC_LEN",
          "args": [
            "prev"
          ],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_free_meta",
          "args": [
            "ip",
            "bstart",
            "blen"
          ],
          "line": 295
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_free_meta",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
          "lines": "2424-2431",
          "snippet": "void gfs2_free_meta(struct gfs2_inode *ip, u64 bstart, u32 blen)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\n\t__gfs2_free_blocks(ip, bstart, blen, 1);\n\tgfs2_statfs_change(sdp, 0, +blen, 0);\n\tgfs2_quota_change(ip, -(s64)blen, ip->i_inode.i_uid, ip->i_inode.i_gid);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"inode.h\"",
            "#include \"log.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/random.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nvoid gfs2_free_meta(struct gfs2_inode *ip, u64 bstart, u32 blen)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\n\t__gfs2_free_blocks(ip, bstart, blen, 1);\n\tgfs2_statfs_change(sdp, 0, +blen, 0);\n\tgfs2_quota_change(ip, -(s64)blen, ip->i_inode.i_uid, ip->i_inode.i_gid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_add_inode_blocks",
          "args": [
            "&ip->i_inode",
            "-1"
          ],
          "line": 292
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_add_inode_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/inode.h",
          "lines": "62-67",
          "snippet": "static inline void gfs2_add_inode_blocks(struct inode *inode, s64 change)\n{\n\tgfs2_assert(GFS2_SB(inode), (change >= 0 || inode->i_blocks > -change));\n\tchange *= (GFS2_SB(inode)->sd_sb.sb_bsize/GFS2_BASIC_BLOCK);\n\tinode->i_blocks += change;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include <linux/mm.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <linux/mm.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic inline void gfs2_add_inode_blocks(struct inode *inode, s64 change)\n{\n\tgfs2_assert(GFS2_SB(inode), (change >= 0 || inode->i_blocks > -change));\n\tchange *= (GFS2_SB(inode)->sd_sb.sb_bsize/GFS2_BASIC_BLOCK);\n\tinode->i_blocks += change;\n}"
        }
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "*dataptrs"
          ],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GFS2_EA2DATAPTRS",
          "args": [
            "ea"
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_trans_begin",
          "args": [
            "sdp",
            "rgd->rd_length + RES_DINODE +\n\t\t\t\t RES_EATTR + RES_STATFS + RES_QUOTA",
            "blks"
          ],
          "line": 269
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_trans_begin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/trans.c",
          "lines": "31-75",
          "snippet": "int gfs2_trans_begin(struct gfs2_sbd *sdp, unsigned int blocks,\n\t\t     unsigned int revokes)\n{\n\tstruct gfs2_trans *tr;\n\tint error;\n\n\tBUG_ON(current->journal_info);\n\tBUG_ON(blocks == 0 && revokes == 0);\n\n\tif (!test_bit(SDF_JOURNAL_LIVE, &sdp->sd_flags))\n\t\treturn -EROFS;\n\n\ttr = kzalloc(sizeof(struct gfs2_trans), GFP_NOFS);\n\tif (!tr)\n\t\treturn -ENOMEM;\n\n\ttr->tr_ip = _RET_IP_;\n\ttr->tr_blocks = blocks;\n\ttr->tr_revokes = revokes;\n\ttr->tr_reserved = 1;\n\ttr->tr_alloced = 1;\n\tif (blocks)\n\t\ttr->tr_reserved += 6 + blocks;\n\tif (revokes)\n\t\ttr->tr_reserved += gfs2_struct2blk(sdp, revokes,\n\t\t\t\t\t\t   sizeof(u64));\n\tINIT_LIST_HEAD(&tr->tr_databuf);\n\tINIT_LIST_HEAD(&tr->tr_buf);\n\n\tsb_start_intwrite(sdp->sd_vfs);\n\n\terror = gfs2_log_reserve(sdp, tr->tr_reserved);\n\tif (error)\n\t\tgoto fail;\n\n\tcurrent->journal_info = tr;\n\n\treturn 0;\n\nfail:\n\tsb_end_intwrite(sdp->sd_vfs);\n\tkfree(tr);\n\n\treturn error;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nint gfs2_trans_begin(struct gfs2_sbd *sdp, unsigned int blocks,\n\t\t     unsigned int revokes)\n{\n\tstruct gfs2_trans *tr;\n\tint error;\n\n\tBUG_ON(current->journal_info);\n\tBUG_ON(blocks == 0 && revokes == 0);\n\n\tif (!test_bit(SDF_JOURNAL_LIVE, &sdp->sd_flags))\n\t\treturn -EROFS;\n\n\ttr = kzalloc(sizeof(struct gfs2_trans), GFP_NOFS);\n\tif (!tr)\n\t\treturn -ENOMEM;\n\n\ttr->tr_ip = _RET_IP_;\n\ttr->tr_blocks = blocks;\n\ttr->tr_revokes = revokes;\n\ttr->tr_reserved = 1;\n\ttr->tr_alloced = 1;\n\tif (blocks)\n\t\ttr->tr_reserved += 6 + blocks;\n\tif (revokes)\n\t\ttr->tr_reserved += gfs2_struct2blk(sdp, revokes,\n\t\t\t\t\t\t   sizeof(u64));\n\tINIT_LIST_HEAD(&tr->tr_databuf);\n\tINIT_LIST_HEAD(&tr->tr_buf);\n\n\tsb_start_intwrite(sdp->sd_vfs);\n\n\terror = gfs2_log_reserve(sdp, tr->tr_reserved);\n\tif (error)\n\t\tgoto fail;\n\n\tcurrent->journal_info = tr;\n\n\treturn 0;\n\nfail:\n\tsb_end_intwrite(sdp->sd_vfs);\n\tkfree(tr);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_glock_nq_init",
          "args": [
            "rgd->rd_gl",
            "LM_ST_EXCLUSIVE",
            "0",
            "&rg_gh"
          ],
          "line": 265
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_glock_nq_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/glock.h",
          "lines": "204-230",
          "snippet": "extern __printf(2, 3)\nvoid gfs2_print_dbg(struct seq_file *seq, const char *fmt, ...);\n\n/**\n * gfs2_glock_nq_init - initialize a holder and enqueue it on a glock\n * @gl: the glock\n * @state: the state we're requesting\n * @flags: the modifier flags\n * @gh: the holder structure\n *\n * Returns: 0, GLR_*, or errno\n */\n\nstatic inline int gfs2_glock_nq_init(struct gfs2_glock *gl,\n\t\t\t\t     unsigned int state, int flags,\n\t\t\t\t     struct gfs2_holder *gh)\n{\n\tint error;\n\n\tgfs2_holder_init(gl, state, flags, gh);\n\n\terror = gfs2_glock_nq(gh);\n\tif (error)\n\t\tgfs2_holder_uninit(gh);\n\n\treturn error;\n}",
          "includes": [
            "#include \"incore.h\"",
            "#include <linux/parser.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"incore.h\"\n#include <linux/parser.h>\n#include <linux/sched.h>\n\nextern __printf(2, 3)\nvoid gfs2_print_dbg(struct seq_file *seq, const char *fmt, ...);\n\n/**\n * gfs2_glock_nq_init - initialize a holder and enqueue it on a glock\n * @gl: the glock\n * @state: the state we're requesting\n * @flags: the modifier flags\n * @gh: the holder structure\n *\n * Returns: 0, GLR_*, or errno\n */\n\nstatic inline int gfs2_glock_nq_init(struct gfs2_glock *gl,\n\t\t\t\t     unsigned int state, int flags,\n\t\t\t\t     struct gfs2_holder *gh)\n{\n\tint error;\n\n\tgfs2_holder_init(gl, state, flags, gh);\n\n\terror = gfs2_glock_nq(gh);\n\tif (error)\n\t\tgfs2_holder_uninit(gh);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_consist_inode",
          "args": [
            "ip"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_blk2rgrpd",
          "args": [
            "sdp",
            "bn",
            "1"
          ],
          "line": 259
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_blk2rgrpd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
          "lines": "503-532",
          "snippet": "struct gfs2_rgrpd *gfs2_blk2rgrpd(struct gfs2_sbd *sdp, u64 blk, bool exact)\n{\n\tstruct rb_node *n, *next;\n\tstruct gfs2_rgrpd *cur;\n\n\tspin_lock(&sdp->sd_rindex_spin);\n\tn = sdp->sd_rindex_tree.rb_node;\n\twhile (n) {\n\t\tcur = rb_entry(n, struct gfs2_rgrpd, rd_node);\n\t\tnext = NULL;\n\t\tif (blk < cur->rd_addr)\n\t\t\tnext = n->rb_left;\n\t\telse if (blk >= cur->rd_data0 + cur->rd_data)\n\t\t\tnext = n->rb_right;\n\t\tif (next == NULL) {\n\t\t\tspin_unlock(&sdp->sd_rindex_spin);\n\t\t\tif (exact) {\n\t\t\t\tif (blk < cur->rd_addr)\n\t\t\t\t\treturn NULL;\n\t\t\t\tif (blk >= cur->rd_data0 + cur->rd_data)\n\t\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\treturn cur;\n\t\t}\n\t\tn = next;\n\t}\n\tspin_unlock(&sdp->sd_rindex_spin);\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"inode.h\"",
            "#include \"log.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/random.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstruct gfs2_rgrpd *gfs2_blk2rgrpd(struct gfs2_sbd *sdp, u64 blk, bool exact)\n{\n\tstruct rb_node *n, *next;\n\tstruct gfs2_rgrpd *cur;\n\n\tspin_lock(&sdp->sd_rindex_spin);\n\tn = sdp->sd_rindex_tree.rb_node;\n\twhile (n) {\n\t\tcur = rb_entry(n, struct gfs2_rgrpd, rd_node);\n\t\tnext = NULL;\n\t\tif (blk < cur->rd_addr)\n\t\t\tnext = n->rb_left;\n\t\telse if (blk >= cur->rd_data0 + cur->rd_data)\n\t\t\tnext = n->rb_right;\n\t\tif (next == NULL) {\n\t\t\tspin_unlock(&sdp->sd_rindex_spin);\n\t\t\tif (exact) {\n\t\t\t\tif (blk < cur->rd_addr)\n\t\t\t\t\treturn NULL;\n\t\t\t\tif (blk >= cur->rd_data0 + cur->rd_data)\n\t\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\treturn cur;\n\t\t}\n\t\tn = next;\n\t}\n\tspin_unlock(&sdp->sd_rindex_spin);\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "*dataptrs"
          ],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GFS2_EA2DATAPTRS",
          "args": [
            "ea"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GFS2_EA_IS_STUFFED",
          "args": [
            "ea"
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_rindex_update",
          "args": [
            "sdp"
          ],
          "line": 242
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_rindex_update",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
          "lines": "1029-1052",
          "snippet": "int gfs2_rindex_update(struct gfs2_sbd *sdp)\n{\n\tstruct gfs2_inode *ip = GFS2_I(sdp->sd_rindex);\n\tstruct gfs2_glock *gl = ip->i_gl;\n\tstruct gfs2_holder ri_gh;\n\tint error = 0;\n\tint unlock_required = 0;\n\n\t/* Read new copy from disk if we don't have the latest */\n\tif (!sdp->sd_rindex_uptodate) {\n\t\tif (!gfs2_glock_is_locked_by_me(gl)) {\n\t\t\terror = gfs2_glock_nq_init(gl, LM_ST_SHARED, 0, &ri_gh);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\tunlock_required = 1;\n\t\t}\n\t\tif (!sdp->sd_rindex_uptodate)\n\t\t\terror = gfs2_ri_update(ip);\n\t\tif (unlock_required)\n\t\t\tgfs2_glock_dq_uninit(&ri_gh);\n\t}\n\n\treturn error;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"inode.h\"",
            "#include \"log.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/random.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nint gfs2_rindex_update(struct gfs2_sbd *sdp)\n{\n\tstruct gfs2_inode *ip = GFS2_I(sdp->sd_rindex);\n\tstruct gfs2_glock *gl = ip->i_gl;\n\tstruct gfs2_holder ri_gh;\n\tint error = 0;\n\tint unlock_required = 0;\n\n\t/* Read new copy from disk if we don't have the latest */\n\tif (!sdp->sd_rindex_uptodate) {\n\t\tif (!gfs2_glock_is_locked_by_me(gl)) {\n\t\t\terror = gfs2_glock_nq_init(gl, LM_ST_SHARED, 0, &ri_gh);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\tunlock_required = 1;\n\t\t}\n\t\tif (!sdp->sd_rindex_uptodate)\n\t\t\terror = gfs2_ri_update(ip);\n\t\tif (unlock_required)\n\t\t\tgfs2_glock_dq_uninit(&ri_gh);\n\t}\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GFS2_SB",
          "args": [
            "&ip->i_inode"
          ],
          "line": 230
        },
        "resolved": true,
        "details": {
          "function_name": "GFS2_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/incore.h",
          "lines": "413-416",
          "snippet": "static inline struct gfs2_sbd *GFS2_SB(const struct inode *inode)\n{\n\treturn inode->i_sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/lockref.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ktime.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/completion.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dlm.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockref.h>\n#include <linux/percpu.h>\n#include <linux/ktime.h>\n#include <linux/rbtree.h>\n#include <linux/completion.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/buffer_head.h>\n#include <linux/dlm.h>\n#include <linux/workqueue.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n\nstatic inline struct gfs2_sbd *GFS2_SB(const struct inode *inode)\n{\n\treturn inode->i_sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic int ea_dealloc_unstuffed(struct gfs2_inode *ip, struct buffer_head *bh,\n\t\t\t\tstruct gfs2_ea_header *ea,\n\t\t\t\tstruct gfs2_ea_header *prev, void *private)\n{\n\tint *leave = private;\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tstruct gfs2_rgrpd *rgd;\n\tstruct gfs2_holder rg_gh;\n\tstruct buffer_head *dibh;\n\t__be64 *dataptrs;\n\tu64 bn = 0;\n\tu64 bstart = 0;\n\tunsigned int blen = 0;\n\tunsigned int blks = 0;\n\tunsigned int x;\n\tint error;\n\n\terror = gfs2_rindex_update(sdp);\n\tif (error)\n\t\treturn error;\n\n\tif (GFS2_EA_IS_STUFFED(ea))\n\t\treturn 0;\n\n\tdataptrs = GFS2_EA2DATAPTRS(ea);\n\tfor (x = 0; x < ea->ea_num_ptrs; x++, dataptrs++) {\n\t\tif (*dataptrs) {\n\t\t\tblks++;\n\t\t\tbn = be64_to_cpu(*dataptrs);\n\t\t}\n\t}\n\tif (!blks)\n\t\treturn 0;\n\n\trgd = gfs2_blk2rgrpd(sdp, bn, 1);\n\tif (!rgd) {\n\t\tgfs2_consist_inode(ip);\n\t\treturn -EIO;\n\t}\n\n\terror = gfs2_glock_nq_init(rgd->rd_gl, LM_ST_EXCLUSIVE, 0, &rg_gh);\n\tif (error)\n\t\treturn error;\n\n\terror = gfs2_trans_begin(sdp, rgd->rd_length + RES_DINODE +\n\t\t\t\t RES_EATTR + RES_STATFS + RES_QUOTA, blks);\n\tif (error)\n\t\tgoto out_gunlock;\n\n\tgfs2_trans_add_meta(ip->i_gl, bh);\n\n\tdataptrs = GFS2_EA2DATAPTRS(ea);\n\tfor (x = 0; x < ea->ea_num_ptrs; x++, dataptrs++) {\n\t\tif (!*dataptrs)\n\t\t\tbreak;\n\t\tbn = be64_to_cpu(*dataptrs);\n\n\t\tif (bstart + blen == bn)\n\t\t\tblen++;\n\t\telse {\n\t\t\tif (bstart)\n\t\t\t\tgfs2_free_meta(ip, bstart, blen);\n\t\t\tbstart = bn;\n\t\t\tblen = 1;\n\t\t}\n\n\t\t*dataptrs = 0;\n\t\tgfs2_add_inode_blocks(&ip->i_inode, -1);\n\t}\n\tif (bstart)\n\t\tgfs2_free_meta(ip, bstart, blen);\n\n\tif (prev && !leave) {\n\t\tu32 len;\n\n\t\tlen = GFS2_EA_REC_LEN(prev) + GFS2_EA_REC_LEN(ea);\n\t\tprev->ea_rec_len = cpu_to_be32(len);\n\n\t\tif (GFS2_EA_IS_LAST(ea))\n\t\t\tprev->ea_flags |= GFS2_EAFLAG_LAST;\n\t} else {\n\t\tea->ea_type = GFS2_EATYPE_UNUSED;\n\t\tea->ea_num_ptrs = 0;\n\t}\n\n\terror = gfs2_meta_inode_buffer(ip, &dibh);\n\tif (!error) {\n\t\tip->i_inode.i_ctime = CURRENT_TIME;\n\t\tgfs2_trans_add_meta(ip->i_gl, dibh);\n\t\tgfs2_dinode_out(ip, dibh->b_data);\n\t\tbrelse(dibh);\n\t}\n\n\tgfs2_trans_end(sdp);\n\nout_gunlock:\n\tgfs2_glock_dq_uninit(&rg_gh);\n\treturn error;\n}"
  },
  {
    "function_name": "gfs2_ea_find",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
    "lines": "190-208",
    "snippet": "static int gfs2_ea_find(struct gfs2_inode *ip, int type, const char *name,\n\t\t\tstruct gfs2_ea_location *el)\n{\n\tstruct ea_find ef;\n\tint error;\n\n\tef.type = type;\n\tef.name = name;\n\tef.namel = strlen(name);\n\tef.ef_el = el;\n\n\tmemset(el, 0, sizeof(struct gfs2_ea_location));\n\n\terror = ea_foreach(ip, ea_find_i, &ef);\n\tif (error > 0)\n\t\treturn 0;\n\n\treturn error;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"trans.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"inode.h\"",
      "#include \"glock.h\"",
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/xattr.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ea_foreach",
          "args": [
            "ip",
            "ea_find_i",
            "&ef"
          ],
          "line": 203
        },
        "resolved": true,
        "details": {
          "function_name": "ea_foreach",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "116-157",
          "snippet": "static int ea_foreach(struct gfs2_inode *ip, ea_call_t ea_call, void *data)\n{\n\tstruct buffer_head *bh, *eabh;\n\t__be64 *eablk, *end;\n\tint error;\n\n\terror = gfs2_meta_read(ip->i_gl, ip->i_eattr, DIO_WAIT, &bh);\n\tif (error)\n\t\treturn error;\n\n\tif (!(ip->i_diskflags & GFS2_DIF_EA_INDIRECT)) {\n\t\terror = ea_foreach_i(ip, bh, ea_call, data);\n\t\tgoto out;\n\t}\n\n\tif (gfs2_metatype_check(GFS2_SB(&ip->i_inode), bh, GFS2_METATYPE_IN)) {\n\t\terror = -EIO;\n\t\tgoto out;\n\t}\n\n\teablk = (__be64 *)(bh->b_data + sizeof(struct gfs2_meta_header));\n\tend = eablk + GFS2_SB(&ip->i_inode)->sd_inptrs;\n\n\tfor (; eablk < end; eablk++) {\n\t\tu64 bn;\n\n\t\tif (!*eablk)\n\t\t\tbreak;\n\t\tbn = be64_to_cpu(*eablk);\n\n\t\terror = gfs2_meta_read(ip->i_gl, bn, DIO_WAIT, &eabh);\n\t\tif (error)\n\t\t\tbreak;\n\t\terror = ea_foreach_i(ip, eabh, ea_call, data);\n\t\tbrelse(eabh);\n\t\tif (error)\n\t\t\tbreak;\n\t}\nout:\n\tbrelse(bh);\n\treturn error;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic int ea_foreach(struct gfs2_inode *ip, ea_call_t ea_call, void *data)\n{\n\tstruct buffer_head *bh, *eabh;\n\t__be64 *eablk, *end;\n\tint error;\n\n\terror = gfs2_meta_read(ip->i_gl, ip->i_eattr, DIO_WAIT, &bh);\n\tif (error)\n\t\treturn error;\n\n\tif (!(ip->i_diskflags & GFS2_DIF_EA_INDIRECT)) {\n\t\terror = ea_foreach_i(ip, bh, ea_call, data);\n\t\tgoto out;\n\t}\n\n\tif (gfs2_metatype_check(GFS2_SB(&ip->i_inode), bh, GFS2_METATYPE_IN)) {\n\t\terror = -EIO;\n\t\tgoto out;\n\t}\n\n\teablk = (__be64 *)(bh->b_data + sizeof(struct gfs2_meta_header));\n\tend = eablk + GFS2_SB(&ip->i_inode)->sd_inptrs;\n\n\tfor (; eablk < end; eablk++) {\n\t\tu64 bn;\n\n\t\tif (!*eablk)\n\t\t\tbreak;\n\t\tbn = be64_to_cpu(*eablk);\n\n\t\terror = gfs2_meta_read(ip->i_gl, bn, DIO_WAIT, &eabh);\n\t\tif (error)\n\t\t\tbreak;\n\t\terror = ea_foreach_i(ip, eabh, ea_call, data);\n\t\tbrelse(eabh);\n\t\tif (error)\n\t\t\tbreak;\n\t}\nout:\n\tbrelse(bh);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "el",
            "0",
            "sizeof(struct gfs2_ea_location)"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "name"
          ],
          "line": 198
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic int gfs2_ea_find(struct gfs2_inode *ip, int type, const char *name,\n\t\t\tstruct gfs2_ea_location *el)\n{\n\tstruct ea_find ef;\n\tint error;\n\n\tef.type = type;\n\tef.name = name;\n\tef.namel = strlen(name);\n\tef.ef_el = el;\n\n\tmemset(el, 0, sizeof(struct gfs2_ea_location));\n\n\terror = ea_foreach(ip, ea_find_i, &ef);\n\tif (error > 0)\n\t\treturn 0;\n\n\treturn error;\n}"
  },
  {
    "function_name": "ea_find_i",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
    "lines": "166-188",
    "snippet": "static int ea_find_i(struct gfs2_inode *ip, struct buffer_head *bh,\n\t\t     struct gfs2_ea_header *ea, struct gfs2_ea_header *prev,\n\t\t     void *private)\n{\n\tstruct ea_find *ef = private;\n\n\tif (ea->ea_type == GFS2_EATYPE_UNUSED)\n\t\treturn 0;\n\n\tif (ea->ea_type == ef->type) {\n\t\tif (ea->ea_name_len == ef->namel &&\n\t\t    !memcmp(GFS2_EA2NAME(ea), ef->name, ea->ea_name_len)) {\n\t\t\tstruct gfs2_ea_location *el = ef->ef_el;\n\t\t\tget_bh(bh);\n\t\t\tel->el_bh = bh;\n\t\t\tel->el_ea = ea;\n\t\t\tel->el_prev = prev;\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"trans.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"inode.h\"",
      "#include \"glock.h\"",
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/xattr.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_bh",
          "args": [
            "bh"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "GFS2_EA2NAME(ea)",
            "ef->name",
            "ea->ea_name_len"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GFS2_EA2NAME",
          "args": [
            "ea"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic int ea_find_i(struct gfs2_inode *ip, struct buffer_head *bh,\n\t\t     struct gfs2_ea_header *ea, struct gfs2_ea_header *prev,\n\t\t     void *private)\n{\n\tstruct ea_find *ef = private;\n\n\tif (ea->ea_type == GFS2_EATYPE_UNUSED)\n\t\treturn 0;\n\n\tif (ea->ea_type == ef->type) {\n\t\tif (ea->ea_name_len == ef->namel &&\n\t\t    !memcmp(GFS2_EA2NAME(ea), ef->name, ea->ea_name_len)) {\n\t\t\tstruct gfs2_ea_location *el = ef->ef_el;\n\t\t\tget_bh(bh);\n\t\t\tel->el_bh = bh;\n\t\t\tel->el_ea = ea;\n\t\t\tel->el_prev = prev;\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "ea_foreach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
    "lines": "116-157",
    "snippet": "static int ea_foreach(struct gfs2_inode *ip, ea_call_t ea_call, void *data)\n{\n\tstruct buffer_head *bh, *eabh;\n\t__be64 *eablk, *end;\n\tint error;\n\n\terror = gfs2_meta_read(ip->i_gl, ip->i_eattr, DIO_WAIT, &bh);\n\tif (error)\n\t\treturn error;\n\n\tif (!(ip->i_diskflags & GFS2_DIF_EA_INDIRECT)) {\n\t\terror = ea_foreach_i(ip, bh, ea_call, data);\n\t\tgoto out;\n\t}\n\n\tif (gfs2_metatype_check(GFS2_SB(&ip->i_inode), bh, GFS2_METATYPE_IN)) {\n\t\terror = -EIO;\n\t\tgoto out;\n\t}\n\n\teablk = (__be64 *)(bh->b_data + sizeof(struct gfs2_meta_header));\n\tend = eablk + GFS2_SB(&ip->i_inode)->sd_inptrs;\n\n\tfor (; eablk < end; eablk++) {\n\t\tu64 bn;\n\n\t\tif (!*eablk)\n\t\t\tbreak;\n\t\tbn = be64_to_cpu(*eablk);\n\n\t\terror = gfs2_meta_read(ip->i_gl, bn, DIO_WAIT, &eabh);\n\t\tif (error)\n\t\t\tbreak;\n\t\terror = ea_foreach_i(ip, eabh, ea_call, data);\n\t\tbrelse(eabh);\n\t\tif (error)\n\t\t\tbreak;\n\t}\nout:\n\tbrelse(bh);\n\treturn error;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"trans.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"inode.h\"",
      "#include \"glock.h\"",
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/xattr.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 155
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "ea_foreach_i",
          "args": [
            "ip",
            "eabh",
            "ea_call",
            "data"
          ],
          "line": 149
        },
        "resolved": true,
        "details": {
          "function_name": "ea_foreach_i",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "79-114",
          "snippet": "static int ea_foreach_i(struct gfs2_inode *ip, struct buffer_head *bh,\n\t\t\tea_call_t ea_call, void *data)\n{\n\tstruct gfs2_ea_header *ea, *prev = NULL;\n\tint error = 0;\n\n\tif (gfs2_metatype_check(GFS2_SB(&ip->i_inode), bh, GFS2_METATYPE_EA))\n\t\treturn -EIO;\n\n\tfor (ea = GFS2_EA_BH2FIRST(bh);; prev = ea, ea = GFS2_EA2NEXT(ea)) {\n\t\tif (!GFS2_EA_REC_LEN(ea))\n\t\t\tgoto fail;\n\t\tif (!(bh->b_data <= (char *)ea && (char *)GFS2_EA2NEXT(ea) <=\n\t\t\t\t\t\t  bh->b_data + bh->b_size))\n\t\t\tgoto fail;\n\t\tif (!GFS2_EATYPE_VALID(ea->ea_type))\n\t\t\tgoto fail;\n\n\t\terror = ea_call(ip, bh, ea, prev, data);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\tif (GFS2_EA_IS_LAST(ea)) {\n\t\t\tif ((char *)GFS2_EA2NEXT(ea) !=\n\t\t\t    bh->b_data + bh->b_size)\n\t\t\t\tgoto fail;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn error;\n\nfail:\n\tgfs2_consist_inode(ip);\n\treturn -EIO;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic int ea_foreach_i(struct gfs2_inode *ip, struct buffer_head *bh,\n\t\t\tea_call_t ea_call, void *data)\n{\n\tstruct gfs2_ea_header *ea, *prev = NULL;\n\tint error = 0;\n\n\tif (gfs2_metatype_check(GFS2_SB(&ip->i_inode), bh, GFS2_METATYPE_EA))\n\t\treturn -EIO;\n\n\tfor (ea = GFS2_EA_BH2FIRST(bh);; prev = ea, ea = GFS2_EA2NEXT(ea)) {\n\t\tif (!GFS2_EA_REC_LEN(ea))\n\t\t\tgoto fail;\n\t\tif (!(bh->b_data <= (char *)ea && (char *)GFS2_EA2NEXT(ea) <=\n\t\t\t\t\t\t  bh->b_data + bh->b_size))\n\t\t\tgoto fail;\n\t\tif (!GFS2_EATYPE_VALID(ea->ea_type))\n\t\t\tgoto fail;\n\n\t\terror = ea_call(ip, bh, ea, prev, data);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\tif (GFS2_EA_IS_LAST(ea)) {\n\t\t\tif ((char *)GFS2_EA2NEXT(ea) !=\n\t\t\t    bh->b_data + bh->b_size)\n\t\t\t\tgoto fail;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn error;\n\nfail:\n\tgfs2_consist_inode(ip);\n\treturn -EIO;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_meta_read",
          "args": [
            "ip->i_gl",
            "bn",
            "DIO_WAIT",
            "&eabh"
          ],
          "line": 146
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_meta_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/meta_io.c",
          "lines": "200-235",
          "snippet": "int gfs2_meta_read(struct gfs2_glock *gl, u64 blkno, int flags,\n\t\t   struct buffer_head **bhp)\n{\n\tstruct gfs2_sbd *sdp = gl->gl_sbd;\n\tstruct buffer_head *bh;\n\n\tif (unlikely(test_bit(SDF_SHUTDOWN, &sdp->sd_flags))) {\n\t\t*bhp = NULL;\n\t\treturn -EIO;\n\t}\n\n\t*bhp = bh = gfs2_getbuf(gl, blkno, CREATE);\n\n\tlock_buffer(bh);\n\tif (buffer_uptodate(bh)) {\n\t\tunlock_buffer(bh);\n\t\treturn 0;\n\t}\n\tbh->b_end_io = end_buffer_read_sync;\n\tget_bh(bh);\n\tsubmit_bh(READ_SYNC | REQ_META | REQ_PRIO, bh);\n\tif (!(flags & DIO_WAIT))\n\t\treturn 0;\n\n\twait_on_buffer(bh);\n\tif (unlikely(!buffer_uptodate(bh))) {\n\t\tstruct gfs2_trans *tr = current->journal_info;\n\t\tif (tr && tr->tr_touched)\n\t\t\tgfs2_io_error_bh(sdp, bh);\n\t\tbrelse(bh);\n\t\t*bhp = NULL;\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/delay.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/delay.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nint gfs2_meta_read(struct gfs2_glock *gl, u64 blkno, int flags,\n\t\t   struct buffer_head **bhp)\n{\n\tstruct gfs2_sbd *sdp = gl->gl_sbd;\n\tstruct buffer_head *bh;\n\n\tif (unlikely(test_bit(SDF_SHUTDOWN, &sdp->sd_flags))) {\n\t\t*bhp = NULL;\n\t\treturn -EIO;\n\t}\n\n\t*bhp = bh = gfs2_getbuf(gl, blkno, CREATE);\n\n\tlock_buffer(bh);\n\tif (buffer_uptodate(bh)) {\n\t\tunlock_buffer(bh);\n\t\treturn 0;\n\t}\n\tbh->b_end_io = end_buffer_read_sync;\n\tget_bh(bh);\n\tsubmit_bh(READ_SYNC | REQ_META | REQ_PRIO, bh);\n\tif (!(flags & DIO_WAIT))\n\t\treturn 0;\n\n\twait_on_buffer(bh);\n\tif (unlikely(!buffer_uptodate(bh))) {\n\t\tstruct gfs2_trans *tr = current->journal_info;\n\t\tif (tr && tr->tr_touched)\n\t\t\tgfs2_io_error_bh(sdp, bh);\n\t\tbrelse(bh);\n\t\t*bhp = NULL;\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "*eablk"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GFS2_SB",
          "args": [
            "&ip->i_inode"
          ],
          "line": 137
        },
        "resolved": true,
        "details": {
          "function_name": "GFS2_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/incore.h",
          "lines": "413-416",
          "snippet": "static inline struct gfs2_sbd *GFS2_SB(const struct inode *inode)\n{\n\treturn inode->i_sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/lockref.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ktime.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/completion.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dlm.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockref.h>\n#include <linux/percpu.h>\n#include <linux/ktime.h>\n#include <linux/rbtree.h>\n#include <linux/completion.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/buffer_head.h>\n#include <linux/dlm.h>\n#include <linux/workqueue.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n\nstatic inline struct gfs2_sbd *GFS2_SB(const struct inode *inode)\n{\n\treturn inode->i_sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_metatype_check",
          "args": [
            "GFS2_SB(&ip->i_inode)",
            "bh",
            "GFS2_METATYPE_IN"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic int ea_foreach(struct gfs2_inode *ip, ea_call_t ea_call, void *data)\n{\n\tstruct buffer_head *bh, *eabh;\n\t__be64 *eablk, *end;\n\tint error;\n\n\terror = gfs2_meta_read(ip->i_gl, ip->i_eattr, DIO_WAIT, &bh);\n\tif (error)\n\t\treturn error;\n\n\tif (!(ip->i_diskflags & GFS2_DIF_EA_INDIRECT)) {\n\t\terror = ea_foreach_i(ip, bh, ea_call, data);\n\t\tgoto out;\n\t}\n\n\tif (gfs2_metatype_check(GFS2_SB(&ip->i_inode), bh, GFS2_METATYPE_IN)) {\n\t\terror = -EIO;\n\t\tgoto out;\n\t}\n\n\teablk = (__be64 *)(bh->b_data + sizeof(struct gfs2_meta_header));\n\tend = eablk + GFS2_SB(&ip->i_inode)->sd_inptrs;\n\n\tfor (; eablk < end; eablk++) {\n\t\tu64 bn;\n\n\t\tif (!*eablk)\n\t\t\tbreak;\n\t\tbn = be64_to_cpu(*eablk);\n\n\t\terror = gfs2_meta_read(ip->i_gl, bn, DIO_WAIT, &eabh);\n\t\tif (error)\n\t\t\tbreak;\n\t\terror = ea_foreach_i(ip, eabh, ea_call, data);\n\t\tbrelse(eabh);\n\t\tif (error)\n\t\t\tbreak;\n\t}\nout:\n\tbrelse(bh);\n\treturn error;\n}"
  },
  {
    "function_name": "ea_foreach_i",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
    "lines": "79-114",
    "snippet": "static int ea_foreach_i(struct gfs2_inode *ip, struct buffer_head *bh,\n\t\t\tea_call_t ea_call, void *data)\n{\n\tstruct gfs2_ea_header *ea, *prev = NULL;\n\tint error = 0;\n\n\tif (gfs2_metatype_check(GFS2_SB(&ip->i_inode), bh, GFS2_METATYPE_EA))\n\t\treturn -EIO;\n\n\tfor (ea = GFS2_EA_BH2FIRST(bh);; prev = ea, ea = GFS2_EA2NEXT(ea)) {\n\t\tif (!GFS2_EA_REC_LEN(ea))\n\t\t\tgoto fail;\n\t\tif (!(bh->b_data <= (char *)ea && (char *)GFS2_EA2NEXT(ea) <=\n\t\t\t\t\t\t  bh->b_data + bh->b_size))\n\t\t\tgoto fail;\n\t\tif (!GFS2_EATYPE_VALID(ea->ea_type))\n\t\t\tgoto fail;\n\n\t\terror = ea_call(ip, bh, ea, prev, data);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\tif (GFS2_EA_IS_LAST(ea)) {\n\t\t\tif ((char *)GFS2_EA2NEXT(ea) !=\n\t\t\t    bh->b_data + bh->b_size)\n\t\t\t\tgoto fail;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn error;\n\nfail:\n\tgfs2_consist_inode(ip);\n\treturn -EIO;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"trans.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"inode.h\"",
      "#include \"glock.h\"",
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/xattr.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "gfs2_consist_inode",
          "args": [
            "ip"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GFS2_EA2NEXT",
          "args": [
            "ea"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GFS2_EA_IS_LAST",
          "args": [
            "ea"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ea_call",
          "args": [
            "ip",
            "bh",
            "ea",
            "prev",
            "data"
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GFS2_EATYPE_VALID",
          "args": [
            "ea->ea_type"
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GFS2_EA2NEXT",
          "args": [
            "ea"
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GFS2_EA_REC_LEN",
          "args": [
            "ea"
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GFS2_EA2NEXT",
          "args": [
            "ea"
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GFS2_EA_BH2FIRST",
          "args": [
            "bh"
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_metatype_check",
          "args": [
            "GFS2_SB(&ip->i_inode)",
            "bh",
            "GFS2_METATYPE_EA"
          ],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GFS2_SB",
          "args": [
            "&ip->i_inode"
          ],
          "line": 85
        },
        "resolved": true,
        "details": {
          "function_name": "GFS2_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/incore.h",
          "lines": "413-416",
          "snippet": "static inline struct gfs2_sbd *GFS2_SB(const struct inode *inode)\n{\n\treturn inode->i_sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/lockref.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ktime.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/completion.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dlm.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockref.h>\n#include <linux/percpu.h>\n#include <linux/ktime.h>\n#include <linux/rbtree.h>\n#include <linux/completion.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/buffer_head.h>\n#include <linux/dlm.h>\n#include <linux/workqueue.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n\nstatic inline struct gfs2_sbd *GFS2_SB(const struct inode *inode)\n{\n\treturn inode->i_sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic int ea_foreach_i(struct gfs2_inode *ip, struct buffer_head *bh,\n\t\t\tea_call_t ea_call, void *data)\n{\n\tstruct gfs2_ea_header *ea, *prev = NULL;\n\tint error = 0;\n\n\tif (gfs2_metatype_check(GFS2_SB(&ip->i_inode), bh, GFS2_METATYPE_EA))\n\t\treturn -EIO;\n\n\tfor (ea = GFS2_EA_BH2FIRST(bh);; prev = ea, ea = GFS2_EA2NEXT(ea)) {\n\t\tif (!GFS2_EA_REC_LEN(ea))\n\t\t\tgoto fail;\n\t\tif (!(bh->b_data <= (char *)ea && (char *)GFS2_EA2NEXT(ea) <=\n\t\t\t\t\t\t  bh->b_data + bh->b_size))\n\t\t\tgoto fail;\n\t\tif (!GFS2_EATYPE_VALID(ea->ea_type))\n\t\t\tgoto fail;\n\n\t\terror = ea_call(ip, bh, ea, prev, data);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\tif (GFS2_EA_IS_LAST(ea)) {\n\t\t\tif ((char *)GFS2_EA2NEXT(ea) !=\n\t\t\t    bh->b_data + bh->b_size)\n\t\t\t\tgoto fail;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn error;\n\nfail:\n\tgfs2_consist_inode(ip);\n\treturn -EIO;\n}"
  },
  {
    "function_name": "ea_check_size",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
    "lines": "59-73",
    "snippet": "static int ea_check_size(struct gfs2_sbd *sdp, unsigned int nsize, size_t dsize)\n{\n\tunsigned int size;\n\n\tif (dsize > GFS2_EA_MAX_DATA_LEN)\n\t\treturn -ERANGE;\n\n\tea_calc_size(sdp, nsize, dsize, &size);\n\n\t/* This can only happen with 512 byte blocks */\n\tif (size > sdp->sd_jbsize)\n\t\treturn -ERANGE;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"trans.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"inode.h\"",
      "#include \"glock.h\"",
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/xattr.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ea_calc_size",
          "args": [
            "sdp",
            "nsize",
            "dsize",
            "&size"
          ],
          "line": 66
        },
        "resolved": true,
        "details": {
          "function_name": "ea_calc_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "41-57",
          "snippet": "static int ea_calc_size(struct gfs2_sbd *sdp, unsigned int nsize, size_t dsize,\n\t\t\tunsigned int *size)\n{\n\tunsigned int jbsize = sdp->sd_jbsize;\n\n\t/* Stuffed */\n\t*size = ALIGN(sizeof(struct gfs2_ea_header) + nsize + dsize, 8);\n\n\tif (*size <= jbsize)\n\t\treturn 1;\n\n\t/* Unstuffed */\n\t*size = ALIGN(sizeof(struct gfs2_ea_header) + nsize +\n\t\t      (sizeof(__be64) * DIV_ROUND_UP(dsize, jbsize)), 8);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic int ea_calc_size(struct gfs2_sbd *sdp, unsigned int nsize, size_t dsize,\n\t\t\tunsigned int *size)\n{\n\tunsigned int jbsize = sdp->sd_jbsize;\n\n\t/* Stuffed */\n\t*size = ALIGN(sizeof(struct gfs2_ea_header) + nsize + dsize, 8);\n\n\tif (*size <= jbsize)\n\t\treturn 1;\n\n\t/* Unstuffed */\n\t*size = ALIGN(sizeof(struct gfs2_ea_header) + nsize +\n\t\t      (sizeof(__be64) * DIV_ROUND_UP(dsize, jbsize)), 8);\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic int ea_check_size(struct gfs2_sbd *sdp, unsigned int nsize, size_t dsize)\n{\n\tunsigned int size;\n\n\tif (dsize > GFS2_EA_MAX_DATA_LEN)\n\t\treturn -ERANGE;\n\n\tea_calc_size(sdp, nsize, dsize, &size);\n\n\t/* This can only happen with 512 byte blocks */\n\tif (size > sdp->sd_jbsize)\n\t\treturn -ERANGE;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "ea_calc_size",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
    "lines": "41-57",
    "snippet": "static int ea_calc_size(struct gfs2_sbd *sdp, unsigned int nsize, size_t dsize,\n\t\t\tunsigned int *size)\n{\n\tunsigned int jbsize = sdp->sd_jbsize;\n\n\t/* Stuffed */\n\t*size = ALIGN(sizeof(struct gfs2_ea_header) + nsize + dsize, 8);\n\n\tif (*size <= jbsize)\n\t\treturn 1;\n\n\t/* Unstuffed */\n\t*size = ALIGN(sizeof(struct gfs2_ea_header) + nsize +\n\t\t      (sizeof(__be64) * DIV_ROUND_UP(dsize, jbsize)), 8);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"trans.h\"",
      "#include \"rgrp.h\"",
      "#include \"quota.h\"",
      "#include \"meta_io.h\"",
      "#include \"inode.h\"",
      "#include \"glock.h\"",
      "#include \"xattr.h\"",
      "#include \"acl.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/xattr.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ALIGN",
          "args": [
            "sizeof(struct gfs2_ea_header) + nsize +\n\t\t      (sizeof(__be64) * DIV_ROUND_UP(dsize, jbsize))",
            "8"
          ],
          "line": 53
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DIV_ROUND_UP",
          "args": [
            "dsize",
            "jbsize"
          ],
          "line": 54
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ALIGN",
          "args": [
            "sizeof(struct gfs2_ea_header) + nsize + dsize",
            "8"
          ],
          "line": 47
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic int ea_calc_size(struct gfs2_sbd *sdp, unsigned int nsize, size_t dsize,\n\t\t\tunsigned int *size)\n{\n\tunsigned int jbsize = sdp->sd_jbsize;\n\n\t/* Stuffed */\n\t*size = ALIGN(sizeof(struct gfs2_ea_header) + nsize + dsize, 8);\n\n\tif (*size <= jbsize)\n\t\treturn 1;\n\n\t/* Unstuffed */\n\t*size = ALIGN(sizeof(struct gfs2_ea_header) + nsize +\n\t\t      (sizeof(__be64) * DIV_ROUND_UP(dsize, jbsize)), 8);\n\n\treturn 0;\n}"
  }
]