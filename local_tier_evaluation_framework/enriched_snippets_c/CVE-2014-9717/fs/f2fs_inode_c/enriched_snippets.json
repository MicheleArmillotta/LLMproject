[
  {
    "function_name": "handle_failed_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/inode.c",
    "lines": "343-364",
    "snippet": "void handle_failed_inode(struct inode *inode)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\n\tclear_nlink(inode);\n\tmake_bad_inode(inode);\n\tunlock_new_inode(inode);\n\n\ti_size_write(inode, 0);\n\tif (F2FS_HAS_BLOCKS(inode))\n\t\tf2fs_truncate(inode);\n\n\tremove_inode_page(inode);\n\n\tclear_inode_flag(F2FS_I(inode), FI_INLINE_DATA);\n\tclear_inode_flag(F2FS_I(inode), FI_INLINE_DENTRY);\n\talloc_nid_failed(sbi, inode->i_ino);\n\tf2fs_unlock_op(sbi);\n\n\t/* iput will drop the inode object */\n\tiput(inode);\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/bitops.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "inode"
          ],
          "line": 363
        },
        "resolved": true,
        "details": {
          "function_name": "iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1471-1488",
          "snippet": "void iput(struct inode *inode)\n{\n\tif (!inode)\n\t\treturn;\n\tBUG_ON(inode->i_state & I_CLEAR);\nretry:\n\tif (atomic_dec_and_lock(&inode->i_count, &inode->i_lock)) {\n\t\tif (inode->i_nlink && (inode->i_state & I_DIRTY_TIME)) {\n\t\t\tatomic_inc(&inode->i_count);\n\t\t\tinode->i_state &= ~I_DIRTY_TIME;\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\ttrace_writeback_lazytime_iput(inode);\n\t\t\tmark_inode_dirty_sync(inode);\n\t\t\tgoto retry;\n\t\t}\n\t\tiput_final(inode);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid iput(struct inode *inode)\n{\n\tif (!inode)\n\t\treturn;\n\tBUG_ON(inode->i_state & I_CLEAR);\nretry:\n\tif (atomic_dec_and_lock(&inode->i_count, &inode->i_lock)) {\n\t\tif (inode->i_nlink && (inode->i_state & I_DIRTY_TIME)) {\n\t\t\tatomic_inc(&inode->i_count);\n\t\t\tinode->i_state &= ~I_DIRTY_TIME;\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\ttrace_writeback_lazytime_iput(inode);\n\t\t\tmark_inode_dirty_sync(inode);\n\t\t\tgoto retry;\n\t\t}\n\t\tiput_final(inode);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_unlock_op",
          "args": [
            "sbi"
          ],
          "line": 360
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_unlock_op",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "760-763",
          "snippet": "static inline void f2fs_unlock_op(struct f2fs_sb_info *sbi)\n{\n\tup_read(&sbi->cp_rwsem);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void f2fs_unlock_op(struct f2fs_sb_info *sbi)\n{\n\tup_read(&sbi->cp_rwsem);\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_nid_failed",
          "args": [
            "sbi",
            "inode->i_ino"
          ],
          "line": 359
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_nid_failed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
          "lines": "1599-1622",
          "snippet": "void alloc_nid_failed(struct f2fs_sb_info *sbi, nid_t nid)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tstruct free_nid *i;\n\tbool need_free = false;\n\n\tif (!nid)\n\t\treturn;\n\n\tspin_lock(&nm_i->free_nid_list_lock);\n\ti = __lookup_free_nid_list(nm_i, nid);\n\tf2fs_bug_on(sbi, !i || i->state != NID_ALLOC);\n\tif (!available_free_memory(sbi, FREE_NIDS)) {\n\t\t__del_from_free_nid_list(nm_i, i);\n\t\tneed_free = true;\n\t} else {\n\t\ti->state = NID_NEW;\n\t\tnm_i->fcnt++;\n\t}\n\tspin_unlock(&nm_i->free_nid_list_lock);\n\n\tif (need_free)\n\t\tkmem_cache_free(free_nid_slab, i);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mpage.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *free_nid_slab;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic struct kmem_cache *free_nid_slab;\n\nvoid alloc_nid_failed(struct f2fs_sb_info *sbi, nid_t nid)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tstruct free_nid *i;\n\tbool need_free = false;\n\n\tif (!nid)\n\t\treturn;\n\n\tspin_lock(&nm_i->free_nid_list_lock);\n\ti = __lookup_free_nid_list(nm_i, nid);\n\tf2fs_bug_on(sbi, !i || i->state != NID_ALLOC);\n\tif (!available_free_memory(sbi, FREE_NIDS)) {\n\t\t__del_from_free_nid_list(nm_i, i);\n\t\tneed_free = true;\n\t} else {\n\t\ti->state = NID_NEW;\n\t\tnm_i->fcnt++;\n\t}\n\tspin_unlock(&nm_i->free_nid_list_lock);\n\n\tif (need_free)\n\t\tkmem_cache_free(free_nid_slab, i);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_inode_flag",
          "args": [
            "F2FS_I(inode)",
            "FI_INLINE_DENTRY"
          ],
          "line": 358
        },
        "resolved": true,
        "details": {
          "function_name": "clear_inode_flag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1184-1188",
          "snippet": "static inline void clear_inode_flag(struct f2fs_inode_info *fi, int flag)\n{\n\tif (test_bit(flag, &fi->flags))\n\t\tclear_bit(flag, &fi->flags);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void clear_inode_flag(struct f2fs_inode_info *fi, int flag)\n{\n\tif (test_bit(flag, &fi->flags))\n\t\tclear_bit(flag, &fi->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "F2FS_I",
          "args": [
            "inode"
          ],
          "line": 358
        },
        "resolved": true,
        "details": {
          "function_name": "F2FS_INODE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "675-678",
          "snippet": "static inline struct f2fs_inode *F2FS_INODE(struct page *page)\n{\n\treturn &((struct f2fs_node *)page_address(page))->i;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_inode *F2FS_INODE(struct page *page)\n{\n\treturn &((struct f2fs_node *)page_address(page))->i;\n}"
        }
      },
      {
        "call_info": {
          "callee": "remove_inode_page",
          "args": [
            "inode"
          ],
          "line": 355
        },
        "resolved": true,
        "details": {
          "function_name": "remove_inode_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
          "lines": "890-914",
          "snippet": "void remove_inode_page(struct inode *inode)\n{\n\tstruct dnode_of_data dn;\n\n\tset_new_dnode(&dn, inode, NULL, NULL, inode->i_ino);\n\tif (get_dnode_of_data(&dn, 0, LOOKUP_NODE))\n\t\treturn;\n\n\tif (truncate_xattr_node(inode, dn.inode_page)) {\n\t\tf2fs_put_dnode(&dn);\n\t\treturn;\n\t}\n\n\t/* remove potential inline_data blocks */\n\tif (S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode) ||\n\t\t\t\tS_ISLNK(inode->i_mode))\n\t\ttruncate_data_blocks_range(&dn, 1);\n\n\t/* 0 is possible, after f2fs_new_inode() has failed */\n\tf2fs_bug_on(F2FS_I_SB(inode),\n\t\t\tinode->i_blocks != 0 && inode->i_blocks != 1);\n\n\t/* will put inode & node pages */\n\ttruncate_node(&dn);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mpage.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nvoid remove_inode_page(struct inode *inode)\n{\n\tstruct dnode_of_data dn;\n\n\tset_new_dnode(&dn, inode, NULL, NULL, inode->i_ino);\n\tif (get_dnode_of_data(&dn, 0, LOOKUP_NODE))\n\t\treturn;\n\n\tif (truncate_xattr_node(inode, dn.inode_page)) {\n\t\tf2fs_put_dnode(&dn);\n\t\treturn;\n\t}\n\n\t/* remove potential inline_data blocks */\n\tif (S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode) ||\n\t\t\t\tS_ISLNK(inode->i_mode))\n\t\ttruncate_data_blocks_range(&dn, 1);\n\n\t/* 0 is possible, after f2fs_new_inode() has failed */\n\tf2fs_bug_on(F2FS_I_SB(inode),\n\t\t\tinode->i_blocks != 0 && inode->i_blocks != 1);\n\n\t/* will put inode & node pages */\n\ttruncate_node(&dn);\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_truncate",
          "args": [
            "inode"
          ],
          "line": 353
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_truncate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/file.c",
          "lines": "542-560",
          "snippet": "void f2fs_truncate(struct inode *inode)\n{\n\tif (!(S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode) ||\n\t\t\t\tS_ISLNK(inode->i_mode)))\n\t\treturn;\n\n\ttrace_f2fs_truncate(inode);\n\n\t/* we should check inline_data size */\n\tif (f2fs_has_inline_data(inode) && !f2fs_may_inline(inode)) {\n\t\tif (f2fs_convert_inline_inode(inode))\n\t\t\treturn;\n\t}\n\n\tif (!truncate_blocks(inode, i_size_read(inode), true)) {\n\t\tinode->i_mtime = inode->i_ctime = CURRENT_TIME;\n\t\tmark_inode_dirty(inode);\n\t}\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/pagevec.h>",
            "#include <linux/mount.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/types.h>",
            "#include <linux/falloc.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/stat.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/pagevec.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/types.h>\n#include <linux/falloc.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/stat.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nvoid f2fs_truncate(struct inode *inode)\n{\n\tif (!(S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode) ||\n\t\t\t\tS_ISLNK(inode->i_mode)))\n\t\treturn;\n\n\ttrace_f2fs_truncate(inode);\n\n\t/* we should check inline_data size */\n\tif (f2fs_has_inline_data(inode) && !f2fs_may_inline(inode)) {\n\t\tif (f2fs_convert_inline_inode(inode))\n\t\t\treturn;\n\t}\n\n\tif (!truncate_blocks(inode, i_size_read(inode), true)) {\n\t\tinode->i_mtime = inode->i_ctime = CURRENT_TIME;\n\t\tmark_inode_dirty(inode);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "F2FS_HAS_BLOCKS",
          "args": [
            "inode"
          ],
          "line": 352
        },
        "resolved": true,
        "details": {
          "function_name": "F2FS_HAS_BLOCKS",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "814-820",
          "snippet": "static inline int F2FS_HAS_BLOCKS(struct inode *inode)\n{\n\tif (F2FS_I(inode)->i_xattr_nid)\n\t\treturn inode->i_blocks > F2FS_DEFAULT_ALLOCATED_BLOCKS + 1;\n\telse\n\t\treturn inode->i_blocks > F2FS_DEFAULT_ALLOCATED_BLOCKS;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define F2FS_DEFAULT_ALLOCATED_BLOCKS\t1"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\n#define F2FS_DEFAULT_ALLOCATED_BLOCKS\t1\n\nstatic inline int F2FS_HAS_BLOCKS(struct inode *inode)\n{\n\tif (F2FS_I(inode)->i_xattr_nid)\n\t\treturn inode->i_blocks > F2FS_DEFAULT_ALLOCATED_BLOCKS + 1;\n\telse\n\t\treturn inode->i_blocks > F2FS_DEFAULT_ALLOCATED_BLOCKS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_write",
          "args": [
            "inode",
            "0"
          ],
          "line": 351
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_i_size_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "233-237",
          "snippet": "static inline void btrfs_i_size_write(struct inode *inode, u64 size)\n{\n\ti_size_write(inode, size);\n\tBTRFS_I(inode)->disk_i_size = size;\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline void btrfs_i_size_write(struct inode *inode, u64 size)\n{\n\ti_size_write(inode, size);\n\tBTRFS_I(inode)->disk_i_size = size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_new_inode",
          "args": [
            "inode"
          ],
          "line": 349
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_new_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "924-933",
          "snippet": "void unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "make_bad_inode",
          "args": [
            "inode"
          ],
          "line": 348
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_make_bad_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/inode.c",
          "lines": "1520-1524",
          "snippet": "static void reiserfs_make_bad_inode(struct inode *inode)\n{\n\tmemset(INODE_PKEY(inode), 0, KEY_SIZE);\n\tmake_bad_inode(inode);\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/exportfs.h>",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/quotaops.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <asm/unaligned.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/exportfs.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic void reiserfs_make_bad_inode(struct inode *inode)\n{\n\tmemset(INODE_PKEY(inode), 0, KEY_SIZE);\n\tmake_bad_inode(inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_nlink",
          "args": [
            "inode"
          ],
          "line": 347
        },
        "resolved": true,
        "details": {
          "function_name": "clear_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "288-294",
          "snippet": "void clear_nlink(struct inode *inode)\n{\n\tif (inode->i_nlink) {\n\t\tinode->__i_nlink = 0;\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid clear_nlink(struct inode *inode)\n{\n\tif (inode->i_nlink) {\n\t\tinode->__i_nlink = 0;\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "F2FS_I_SB",
          "args": [
            "inode"
          ],
          "line": 345
        },
        "resolved": true,
        "details": {
          "function_name": "F2FS_I_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "645-648",
          "snippet": "static inline struct f2fs_sb_info *F2FS_I_SB(struct inode *inode)\n{\n\treturn F2FS_SB(inode->i_sb);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_sb_info *F2FS_I_SB(struct inode *inode)\n{\n\treturn F2FS_SB(inode->i_sb);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/bitops.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nvoid handle_failed_inode(struct inode *inode)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\n\tclear_nlink(inode);\n\tmake_bad_inode(inode);\n\tunlock_new_inode(inode);\n\n\ti_size_write(inode, 0);\n\tif (F2FS_HAS_BLOCKS(inode))\n\t\tf2fs_truncate(inode);\n\n\tremove_inode_page(inode);\n\n\tclear_inode_flag(F2FS_I(inode), FI_INLINE_DATA);\n\tclear_inode_flag(F2FS_I(inode), FI_INLINE_DENTRY);\n\talloc_nid_failed(sbi, inode->i_ino);\n\tf2fs_unlock_op(sbi);\n\n\t/* iput will drop the inode object */\n\tiput(inode);\n}"
  },
  {
    "function_name": "f2fs_evict_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/inode.c",
    "lines": "294-340",
    "snippet": "void f2fs_evict_inode(struct inode *inode)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tnid_t xnid = F2FS_I(inode)->i_xattr_nid;\n\n\t/* some remained atomic pages should discarded */\n\tif (f2fs_is_atomic_file(inode))\n\t\tcommit_inmem_pages(inode, true);\n\n\ttrace_f2fs_evict_inode(inode);\n\ttruncate_inode_pages_final(&inode->i_data);\n\n\tif (inode->i_ino == F2FS_NODE_INO(sbi) ||\n\t\t\tinode->i_ino == F2FS_META_INO(sbi))\n\t\tgoto out_clear;\n\n\tf2fs_bug_on(sbi, get_dirty_pages(inode));\n\tremove_dirty_dir_inode(inode);\n\n\tif (inode->i_nlink || is_bad_inode(inode))\n\t\tgoto no_delete;\n\n\tsb_start_intwrite(inode->i_sb);\n\tset_inode_flag(F2FS_I(inode), FI_NO_ALLOC);\n\ti_size_write(inode, 0);\n\n\tif (F2FS_HAS_BLOCKS(inode))\n\t\tf2fs_truncate(inode);\n\n\tf2fs_lock_op(sbi);\n\tremove_inode_page(inode);\n\tf2fs_unlock_op(sbi);\n\n\tsb_end_intwrite(inode->i_sb);\nno_delete:\n\tstat_dec_inline_dir(inode);\n\tstat_dec_inline_inode(inode);\n\tinvalidate_mapping_pages(NODE_MAPPING(sbi), inode->i_ino, inode->i_ino);\n\tif (xnid)\n\t\tinvalidate_mapping_pages(NODE_MAPPING(sbi), xnid, xnid);\n\tif (is_inode_flag_set(F2FS_I(inode), FI_APPEND_WRITE))\n\t\tadd_dirty_inode(sbi, inode->i_ino, APPEND_INO);\n\tif (is_inode_flag_set(F2FS_I(inode), FI_UPDATE_WRITE))\n\t\tadd_dirty_inode(sbi, inode->i_ino, UPDATE_INO);\nout_clear:\n\tclear_inode(inode);\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/bitops.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "clear_inode",
          "args": [
            "inode"
          ],
          "line": 339
        },
        "resolved": true,
        "details": {
          "function_name": "clear_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "488-505",
          "snippet": "void clear_inode(struct inode *inode)\n{\n\tmight_sleep();\n\t/*\n\t * We have to cycle tree_lock here because reclaim can be still in the\n\t * process of removing the last page (in __delete_from_page_cache())\n\t * and we must not free mapping under it.\n\t */\n\tspin_lock_irq(&inode->i_data.tree_lock);\n\tBUG_ON(inode->i_data.nrpages);\n\tBUG_ON(inode->i_data.nrshadows);\n\tspin_unlock_irq(&inode->i_data.tree_lock);\n\tBUG_ON(!list_empty(&inode->i_data.private_list));\n\tBUG_ON(!(inode->i_state & I_FREEING));\n\tBUG_ON(inode->i_state & I_CLEAR);\n\t/* don't need i_lock here, no concurrent mods to i_state */\n\tinode->i_state = I_FREEING | I_CLEAR;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid clear_inode(struct inode *inode)\n{\n\tmight_sleep();\n\t/*\n\t * We have to cycle tree_lock here because reclaim can be still in the\n\t * process of removing the last page (in __delete_from_page_cache())\n\t * and we must not free mapping under it.\n\t */\n\tspin_lock_irq(&inode->i_data.tree_lock);\n\tBUG_ON(inode->i_data.nrpages);\n\tBUG_ON(inode->i_data.nrshadows);\n\tspin_unlock_irq(&inode->i_data.tree_lock);\n\tBUG_ON(!list_empty(&inode->i_data.private_list));\n\tBUG_ON(!(inode->i_state & I_FREEING));\n\tBUG_ON(inode->i_state & I_CLEAR);\n\t/* don't need i_lock here, no concurrent mods to i_state */\n\tinode->i_state = I_FREEING | I_CLEAR;\n}"
        }
      },
      {
        "call_info": {
          "callee": "add_dirty_inode",
          "args": [
            "sbi",
            "inode->i_ino",
            "UPDATE_INO"
          ],
          "line": 337
        },
        "resolved": true,
        "details": {
          "function_name": "add_dirty_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/checkpoint.c",
          "lines": "375-379",
          "snippet": "void add_dirty_inode(struct f2fs_sb_info *sbi, nid_t ino, int type)\n{\n\t/* add new dirty ino entry into list */\n\t__add_ino_entry(sbi, ino, type);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/f2fs_fs.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n\nvoid add_dirty_inode(struct f2fs_sb_info *sbi, nid_t ino, int type)\n{\n\t/* add new dirty ino entry into list */\n\t__add_ino_entry(sbi, ino, type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_inode_flag_set",
          "args": [
            "F2FS_I(inode)",
            "FI_UPDATE_WRITE"
          ],
          "line": 336
        },
        "resolved": true,
        "details": {
          "function_name": "is_inode_flag_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1179-1182",
          "snippet": "static inline int is_inode_flag_set(struct f2fs_inode_info *fi, int flag)\n{\n\treturn test_bit(flag, &fi->flags);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int is_inode_flag_set(struct f2fs_inode_info *fi, int flag)\n{\n\treturn test_bit(flag, &fi->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "F2FS_I",
          "args": [
            "inode"
          ],
          "line": 336
        },
        "resolved": true,
        "details": {
          "function_name": "F2FS_INODE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "675-678",
          "snippet": "static inline struct f2fs_inode *F2FS_INODE(struct page *page)\n{\n\treturn &((struct f2fs_node *)page_address(page))->i;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_inode *F2FS_INODE(struct page *page)\n{\n\treturn &((struct f2fs_node *)page_address(page))->i;\n}"
        }
      },
      {
        "call_info": {
          "callee": "invalidate_mapping_pages",
          "args": [
            "NODE_MAPPING(sbi)",
            "xnid",
            "xnid"
          ],
          "line": 333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NODE_MAPPING",
          "args": [
            "sbi"
          ],
          "line": 333
        },
        "resolved": true,
        "details": {
          "function_name": "NODE_MAPPING",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "710-713",
          "snippet": "static inline struct address_space *NODE_MAPPING(struct f2fs_sb_info *sbi)\n{\n\treturn sbi->node_inode->i_mapping;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct address_space *NODE_MAPPING(struct f2fs_sb_info *sbi)\n{\n\treturn sbi->node_inode->i_mapping;\n}"
        }
      },
      {
        "call_info": {
          "callee": "invalidate_mapping_pages",
          "args": [
            "NODE_MAPPING(sbi)",
            "inode->i_ino",
            "inode->i_ino"
          ],
          "line": 331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stat_dec_inline_inode",
          "args": [
            "inode"
          ],
          "line": 330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stat_dec_inline_dir",
          "args": [
            "inode"
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_end_intwrite",
          "args": [
            "inode->i_sb"
          ],
          "line": 327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f2fs_unlock_op",
          "args": [
            "sbi"
          ],
          "line": 325
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_unlock_op",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "760-763",
          "snippet": "static inline void f2fs_unlock_op(struct f2fs_sb_info *sbi)\n{\n\tup_read(&sbi->cp_rwsem);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void f2fs_unlock_op(struct f2fs_sb_info *sbi)\n{\n\tup_read(&sbi->cp_rwsem);\n}"
        }
      },
      {
        "call_info": {
          "callee": "remove_inode_page",
          "args": [
            "inode"
          ],
          "line": 324
        },
        "resolved": true,
        "details": {
          "function_name": "remove_inode_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
          "lines": "890-914",
          "snippet": "void remove_inode_page(struct inode *inode)\n{\n\tstruct dnode_of_data dn;\n\n\tset_new_dnode(&dn, inode, NULL, NULL, inode->i_ino);\n\tif (get_dnode_of_data(&dn, 0, LOOKUP_NODE))\n\t\treturn;\n\n\tif (truncate_xattr_node(inode, dn.inode_page)) {\n\t\tf2fs_put_dnode(&dn);\n\t\treturn;\n\t}\n\n\t/* remove potential inline_data blocks */\n\tif (S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode) ||\n\t\t\t\tS_ISLNK(inode->i_mode))\n\t\ttruncate_data_blocks_range(&dn, 1);\n\n\t/* 0 is possible, after f2fs_new_inode() has failed */\n\tf2fs_bug_on(F2FS_I_SB(inode),\n\t\t\tinode->i_blocks != 0 && inode->i_blocks != 1);\n\n\t/* will put inode & node pages */\n\ttruncate_node(&dn);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mpage.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nvoid remove_inode_page(struct inode *inode)\n{\n\tstruct dnode_of_data dn;\n\n\tset_new_dnode(&dn, inode, NULL, NULL, inode->i_ino);\n\tif (get_dnode_of_data(&dn, 0, LOOKUP_NODE))\n\t\treturn;\n\n\tif (truncate_xattr_node(inode, dn.inode_page)) {\n\t\tf2fs_put_dnode(&dn);\n\t\treturn;\n\t}\n\n\t/* remove potential inline_data blocks */\n\tif (S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode) ||\n\t\t\t\tS_ISLNK(inode->i_mode))\n\t\ttruncate_data_blocks_range(&dn, 1);\n\n\t/* 0 is possible, after f2fs_new_inode() has failed */\n\tf2fs_bug_on(F2FS_I_SB(inode),\n\t\t\tinode->i_blocks != 0 && inode->i_blocks != 1);\n\n\t/* will put inode & node pages */\n\ttruncate_node(&dn);\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_lock_op",
          "args": [
            "sbi"
          ],
          "line": 323
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_lock_op",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "755-758",
          "snippet": "static inline void f2fs_lock_op(struct f2fs_sb_info *sbi)\n{\n\tdown_read(&sbi->cp_rwsem);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void f2fs_lock_op(struct f2fs_sb_info *sbi)\n{\n\tdown_read(&sbi->cp_rwsem);\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_truncate",
          "args": [
            "inode"
          ],
          "line": 321
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_truncate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/file.c",
          "lines": "542-560",
          "snippet": "void f2fs_truncate(struct inode *inode)\n{\n\tif (!(S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode) ||\n\t\t\t\tS_ISLNK(inode->i_mode)))\n\t\treturn;\n\n\ttrace_f2fs_truncate(inode);\n\n\t/* we should check inline_data size */\n\tif (f2fs_has_inline_data(inode) && !f2fs_may_inline(inode)) {\n\t\tif (f2fs_convert_inline_inode(inode))\n\t\t\treturn;\n\t}\n\n\tif (!truncate_blocks(inode, i_size_read(inode), true)) {\n\t\tinode->i_mtime = inode->i_ctime = CURRENT_TIME;\n\t\tmark_inode_dirty(inode);\n\t}\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/pagevec.h>",
            "#include <linux/mount.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/types.h>",
            "#include <linux/falloc.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/stat.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/pagevec.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/types.h>\n#include <linux/falloc.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/stat.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nvoid f2fs_truncate(struct inode *inode)\n{\n\tif (!(S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode) ||\n\t\t\t\tS_ISLNK(inode->i_mode)))\n\t\treturn;\n\n\ttrace_f2fs_truncate(inode);\n\n\t/* we should check inline_data size */\n\tif (f2fs_has_inline_data(inode) && !f2fs_may_inline(inode)) {\n\t\tif (f2fs_convert_inline_inode(inode))\n\t\t\treturn;\n\t}\n\n\tif (!truncate_blocks(inode, i_size_read(inode), true)) {\n\t\tinode->i_mtime = inode->i_ctime = CURRENT_TIME;\n\t\tmark_inode_dirty(inode);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "F2FS_HAS_BLOCKS",
          "args": [
            "inode"
          ],
          "line": 320
        },
        "resolved": true,
        "details": {
          "function_name": "F2FS_HAS_BLOCKS",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "814-820",
          "snippet": "static inline int F2FS_HAS_BLOCKS(struct inode *inode)\n{\n\tif (F2FS_I(inode)->i_xattr_nid)\n\t\treturn inode->i_blocks > F2FS_DEFAULT_ALLOCATED_BLOCKS + 1;\n\telse\n\t\treturn inode->i_blocks > F2FS_DEFAULT_ALLOCATED_BLOCKS;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define F2FS_DEFAULT_ALLOCATED_BLOCKS\t1"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\n#define F2FS_DEFAULT_ALLOCATED_BLOCKS\t1\n\nstatic inline int F2FS_HAS_BLOCKS(struct inode *inode)\n{\n\tif (F2FS_I(inode)->i_xattr_nid)\n\t\treturn inode->i_blocks > F2FS_DEFAULT_ALLOCATED_BLOCKS + 1;\n\telse\n\t\treturn inode->i_blocks > F2FS_DEFAULT_ALLOCATED_BLOCKS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_write",
          "args": [
            "inode",
            "0"
          ],
          "line": 318
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_i_size_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "233-237",
          "snippet": "static inline void btrfs_i_size_write(struct inode *inode, u64 size)\n{\n\ti_size_write(inode, size);\n\tBTRFS_I(inode)->disk_i_size = size;\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline void btrfs_i_size_write(struct inode *inode, u64 size)\n{\n\ti_size_write(inode, size);\n\tBTRFS_I(inode)->disk_i_size = size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_inode_flag",
          "args": [
            "F2FS_I(inode)",
            "FI_NO_ALLOC"
          ],
          "line": 317
        },
        "resolved": true,
        "details": {
          "function_name": "set_inode_flag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1173-1177",
          "snippet": "static inline void set_inode_flag(struct f2fs_inode_info *fi, int flag)\n{\n\tif (!test_bit(flag, &fi->flags))\n\t\tset_bit(flag, &fi->flags);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void set_inode_flag(struct f2fs_inode_info *fi, int flag)\n{\n\tif (!test_bit(flag, &fi->flags))\n\t\tset_bit(flag, &fi->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sb_start_intwrite",
          "args": [
            "inode->i_sb"
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_bad_inode",
          "args": [
            "inode"
          ],
          "line": 313
        },
        "resolved": true,
        "details": {
          "function_name": "is_bad_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/bad_inode.c",
          "lines": "195-198",
          "snippet": "int is_bad_inode(struct inode *inode)\n{\n\treturn (inode->i_op == &bad_inode_ops);\t\n}",
          "includes": [
            "#include <linux/poll.h>",
            "#include <linux/namei.h>",
            "#include <linux/time.h>",
            "#include <linux/stat.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct inode_operations bad_inode_ops =\n{\n\t.create\t\t= bad_inode_create,\n\t.lookup\t\t= bad_inode_lookup,\n\t.link\t\t= bad_inode_link,\n\t.unlink\t\t= bad_inode_unlink,\n\t.symlink\t= bad_inode_symlink,\n\t.mkdir\t\t= bad_inode_mkdir,\n\t.rmdir\t\t= bad_inode_rmdir,\n\t.mknod\t\t= bad_inode_mknod,\n\t.rename2\t= bad_inode_rename2,\n\t.readlink\t= bad_inode_readlink,\n\t/* follow_link must be no-op, otherwise unmounting this inode\n\t   won't work */\n\t/* put_link returns void */\n\t/* truncate returns void */\n\t.permission\t= bad_inode_permission,\n\t.getattr\t= bad_inode_getattr,\n\t.setattr\t= bad_inode_setattr,\n\t.setxattr\t= bad_inode_setxattr,\n\t.getxattr\t= bad_inode_getxattr,\n\t.listxattr\t= bad_inode_listxattr,\n\t.removexattr\t= bad_inode_removexattr,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/poll.h>\n#include <linux/namei.h>\n#include <linux/time.h>\n#include <linux/stat.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nstatic const struct inode_operations bad_inode_ops =\n{\n\t.create\t\t= bad_inode_create,\n\t.lookup\t\t= bad_inode_lookup,\n\t.link\t\t= bad_inode_link,\n\t.unlink\t\t= bad_inode_unlink,\n\t.symlink\t= bad_inode_symlink,\n\t.mkdir\t\t= bad_inode_mkdir,\n\t.rmdir\t\t= bad_inode_rmdir,\n\t.mknod\t\t= bad_inode_mknod,\n\t.rename2\t= bad_inode_rename2,\n\t.readlink\t= bad_inode_readlink,\n\t/* follow_link must be no-op, otherwise unmounting this inode\n\t   won't work */\n\t/* put_link returns void */\n\t/* truncate returns void */\n\t.permission\t= bad_inode_permission,\n\t.getattr\t= bad_inode_getattr,\n\t.setattr\t= bad_inode_setattr,\n\t.setxattr\t= bad_inode_setxattr,\n\t.getxattr\t= bad_inode_getxattr,\n\t.listxattr\t= bad_inode_listxattr,\n\t.removexattr\t= bad_inode_removexattr,\n};\n\nint is_bad_inode(struct inode *inode)\n{\n\treturn (inode->i_op == &bad_inode_ops);\t\n}"
        }
      },
      {
        "call_info": {
          "callee": "remove_dirty_dir_inode",
          "args": [
            "inode"
          ],
          "line": 311
        },
        "resolved": true,
        "details": {
          "function_name": "remove_dirty_dir_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/checkpoint.c",
          "lines": "741-769",
          "snippet": "void remove_dirty_dir_inode(struct inode *inode)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tstruct inode_entry *entry;\n\n\tif (!S_ISDIR(inode->i_mode))\n\t\treturn;\n\n\tspin_lock(&sbi->dir_inode_lock);\n\tif (get_dirty_pages(inode) ||\n\t\t\t!is_inode_flag_set(F2FS_I(inode), FI_DIRTY_DIR)) {\n\t\tspin_unlock(&sbi->dir_inode_lock);\n\t\treturn;\n\t}\n\n\tentry = F2FS_I(inode)->dirty_dir;\n\tlist_del(&entry->list);\n\tF2FS_I(inode)->dirty_dir = NULL;\n\tclear_inode_flag(F2FS_I(inode), FI_DIRTY_DIR);\n\tstat_dec_dirty_dir(sbi);\n\tspin_unlock(&sbi->dir_inode_lock);\n\tkmem_cache_free(inode_entry_slab, entry);\n\n\t/* Only from the recovery routine */\n\tif (is_inode_flag_set(F2FS_I(inode), FI_DELAY_IPUT)) {\n\t\tclear_inode_flag(F2FS_I(inode), FI_DELAY_IPUT);\n\t\tiput(inode);\n\t}\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct kmem_cache *inode_entry_slab;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/f2fs_fs.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n\nstruct kmem_cache *inode_entry_slab;\n\nvoid remove_dirty_dir_inode(struct inode *inode)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tstruct inode_entry *entry;\n\n\tif (!S_ISDIR(inode->i_mode))\n\t\treturn;\n\n\tspin_lock(&sbi->dir_inode_lock);\n\tif (get_dirty_pages(inode) ||\n\t\t\t!is_inode_flag_set(F2FS_I(inode), FI_DIRTY_DIR)) {\n\t\tspin_unlock(&sbi->dir_inode_lock);\n\t\treturn;\n\t}\n\n\tentry = F2FS_I(inode)->dirty_dir;\n\tlist_del(&entry->list);\n\tF2FS_I(inode)->dirty_dir = NULL;\n\tclear_inode_flag(F2FS_I(inode), FI_DIRTY_DIR);\n\tstat_dec_dirty_dir(sbi);\n\tspin_unlock(&sbi->dir_inode_lock);\n\tkmem_cache_free(inode_entry_slab, entry);\n\n\t/* Only from the recovery routine */\n\tif (is_inode_flag_set(F2FS_I(inode), FI_DELAY_IPUT)) {\n\t\tclear_inode_flag(F2FS_I(inode), FI_DELAY_IPUT);\n\t\tiput(inode);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_bug_on",
          "args": [
            "sbi",
            "get_dirty_pages(inode)"
          ],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_dirty_pages",
          "args": [
            "inode"
          ],
          "line": 310
        },
        "resolved": true,
        "details": {
          "function_name": "get_dirty_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "892-895",
          "snippet": "static inline int get_dirty_pages(struct inode *inode)\n{\n\treturn atomic_read(&F2FS_I(inode)->dirty_pages);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int get_dirty_pages(struct inode *inode)\n{\n\treturn atomic_read(&F2FS_I(inode)->dirty_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "F2FS_META_INO",
          "args": [
            "sbi"
          ],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "F2FS_NODE_INO",
          "args": [
            "sbi"
          ],
          "line": 306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "truncate_inode_pages_final",
          "args": [
            "&inode->i_data"
          ],
          "line": 304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_f2fs_evict_inode",
          "args": [
            "inode"
          ],
          "line": 303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "commit_inmem_pages",
          "args": [
            "inode",
            "true"
          ],
          "line": 301
        },
        "resolved": true,
        "details": {
          "function_name": "commit_inmem_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
          "lines": "210-260",
          "snippet": "void commit_inmem_pages(struct inode *inode, bool abort)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tstruct f2fs_inode_info *fi = F2FS_I(inode);\n\tstruct inmem_pages *cur, *tmp;\n\tbool submit_bio = false;\n\tstruct f2fs_io_info fio = {\n\t\t.type = DATA,\n\t\t.rw = WRITE_SYNC | REQ_PRIO,\n\t};\n\n\t/*\n\t * The abort is true only when f2fs_evict_inode is called.\n\t * Basically, the f2fs_evict_inode doesn't produce any data writes, so\n\t * that we don't need to call f2fs_balance_fs.\n\t * Otherwise, f2fs_gc in f2fs_balance_fs can wait forever until this\n\t * inode becomes free by iget_locked in f2fs_iget.\n\t */\n\tif (!abort) {\n\t\tf2fs_balance_fs(sbi);\n\t\tf2fs_lock_op(sbi);\n\t}\n\n\tmutex_lock(&fi->inmem_lock);\n\tlist_for_each_entry_safe(cur, tmp, &fi->inmem_pages, list) {\n\t\tif (!abort) {\n\t\t\tlock_page(cur->page);\n\t\t\tif (cur->page->mapping == inode->i_mapping) {\n\t\t\t\tf2fs_wait_on_page_writeback(cur->page, DATA);\n\t\t\t\tif (clear_page_dirty_for_io(cur->page))\n\t\t\t\t\tinode_dec_dirty_pages(inode);\n\t\t\t\tdo_write_data_page(cur->page, &fio);\n\t\t\t\tsubmit_bio = true;\n\t\t\t}\n\t\t\tf2fs_put_page(cur->page, 1);\n\t\t} else {\n\t\t\tput_page(cur->page);\n\t\t}\n\t\tradix_tree_delete(&fi->inmem_root, cur->page->index);\n\t\tlist_del(&cur->list);\n\t\tkmem_cache_free(inmem_entry_slab, cur);\n\t\tdec_page_count(F2FS_I_SB(inode), F2FS_INMEM_PAGES);\n\t}\n\tmutex_unlock(&fi->inmem_lock);\n\n\tif (!abort) {\n\t\tf2fs_unlock_op(sbi);\n\t\tif (submit_bio)\n\t\t\tf2fs_submit_merged_bio(sbi, DATA, WRITE);\n\t}\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"node.h\"",
            "#include \"segment.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kthread.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *inmem_entry_slab;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic struct kmem_cache *inmem_entry_slab;\n\nvoid commit_inmem_pages(struct inode *inode, bool abort)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tstruct f2fs_inode_info *fi = F2FS_I(inode);\n\tstruct inmem_pages *cur, *tmp;\n\tbool submit_bio = false;\n\tstruct f2fs_io_info fio = {\n\t\t.type = DATA,\n\t\t.rw = WRITE_SYNC | REQ_PRIO,\n\t};\n\n\t/*\n\t * The abort is true only when f2fs_evict_inode is called.\n\t * Basically, the f2fs_evict_inode doesn't produce any data writes, so\n\t * that we don't need to call f2fs_balance_fs.\n\t * Otherwise, f2fs_gc in f2fs_balance_fs can wait forever until this\n\t * inode becomes free by iget_locked in f2fs_iget.\n\t */\n\tif (!abort) {\n\t\tf2fs_balance_fs(sbi);\n\t\tf2fs_lock_op(sbi);\n\t}\n\n\tmutex_lock(&fi->inmem_lock);\n\tlist_for_each_entry_safe(cur, tmp, &fi->inmem_pages, list) {\n\t\tif (!abort) {\n\t\t\tlock_page(cur->page);\n\t\t\tif (cur->page->mapping == inode->i_mapping) {\n\t\t\t\tf2fs_wait_on_page_writeback(cur->page, DATA);\n\t\t\t\tif (clear_page_dirty_for_io(cur->page))\n\t\t\t\t\tinode_dec_dirty_pages(inode);\n\t\t\t\tdo_write_data_page(cur->page, &fio);\n\t\t\t\tsubmit_bio = true;\n\t\t\t}\n\t\t\tf2fs_put_page(cur->page, 1);\n\t\t} else {\n\t\t\tput_page(cur->page);\n\t\t}\n\t\tradix_tree_delete(&fi->inmem_root, cur->page->index);\n\t\tlist_del(&cur->list);\n\t\tkmem_cache_free(inmem_entry_slab, cur);\n\t\tdec_page_count(F2FS_I_SB(inode), F2FS_INMEM_PAGES);\n\t}\n\tmutex_unlock(&fi->inmem_lock);\n\n\tif (!abort) {\n\t\tf2fs_unlock_op(sbi);\n\t\tif (submit_bio)\n\t\t\tf2fs_submit_merged_bio(sbi, DATA, WRITE);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_is_atomic_file",
          "args": [
            "inode"
          ],
          "line": 300
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_is_atomic_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1267-1270",
          "snippet": "static inline bool f2fs_is_atomic_file(struct inode *inode)\n{\n\treturn is_inode_flag_set(F2FS_I(inode), FI_ATOMIC_FILE);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline bool f2fs_is_atomic_file(struct inode *inode)\n{\n\treturn is_inode_flag_set(F2FS_I(inode), FI_ATOMIC_FILE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "F2FS_I_SB",
          "args": [
            "inode"
          ],
          "line": 296
        },
        "resolved": true,
        "details": {
          "function_name": "F2FS_I_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "645-648",
          "snippet": "static inline struct f2fs_sb_info *F2FS_I_SB(struct inode *inode)\n{\n\treturn F2FS_SB(inode->i_sb);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_sb_info *F2FS_I_SB(struct inode *inode)\n{\n\treturn F2FS_SB(inode->i_sb);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/bitops.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nvoid f2fs_evict_inode(struct inode *inode)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tnid_t xnid = F2FS_I(inode)->i_xattr_nid;\n\n\t/* some remained atomic pages should discarded */\n\tif (f2fs_is_atomic_file(inode))\n\t\tcommit_inmem_pages(inode, true);\n\n\ttrace_f2fs_evict_inode(inode);\n\ttruncate_inode_pages_final(&inode->i_data);\n\n\tif (inode->i_ino == F2FS_NODE_INO(sbi) ||\n\t\t\tinode->i_ino == F2FS_META_INO(sbi))\n\t\tgoto out_clear;\n\n\tf2fs_bug_on(sbi, get_dirty_pages(inode));\n\tremove_dirty_dir_inode(inode);\n\n\tif (inode->i_nlink || is_bad_inode(inode))\n\t\tgoto no_delete;\n\n\tsb_start_intwrite(inode->i_sb);\n\tset_inode_flag(F2FS_I(inode), FI_NO_ALLOC);\n\ti_size_write(inode, 0);\n\n\tif (F2FS_HAS_BLOCKS(inode))\n\t\tf2fs_truncate(inode);\n\n\tf2fs_lock_op(sbi);\n\tremove_inode_page(inode);\n\tf2fs_unlock_op(sbi);\n\n\tsb_end_intwrite(inode->i_sb);\nno_delete:\n\tstat_dec_inline_dir(inode);\n\tstat_dec_inline_inode(inode);\n\tinvalidate_mapping_pages(NODE_MAPPING(sbi), inode->i_ino, inode->i_ino);\n\tif (xnid)\n\t\tinvalidate_mapping_pages(NODE_MAPPING(sbi), xnid, xnid);\n\tif (is_inode_flag_set(F2FS_I(inode), FI_APPEND_WRITE))\n\t\tadd_dirty_inode(sbi, inode->i_ino, APPEND_INO);\n\tif (is_inode_flag_set(F2FS_I(inode), FI_UPDATE_WRITE))\n\t\tadd_dirty_inode(sbi, inode->i_ino, UPDATE_INO);\nout_clear:\n\tclear_inode(inode);\n}"
  },
  {
    "function_name": "f2fs_write_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/inode.c",
    "lines": "266-289",
    "snippet": "int f2fs_write_inode(struct inode *inode, struct writeback_control *wbc)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\n\tif (inode->i_ino == F2FS_NODE_INO(sbi) ||\n\t\t\tinode->i_ino == F2FS_META_INO(sbi))\n\t\treturn 0;\n\n\tif (!is_inode_flag_set(F2FS_I(inode), FI_DIRTY_INODE))\n\t\treturn 0;\n\n\t/*\n\t * We need to lock here to prevent from producing dirty node pages\n\t * during the urgent cleaning time when runing out of free sections.\n\t */\n\tf2fs_lock_op(sbi);\n\tupdate_inode_page(inode);\n\tf2fs_unlock_op(sbi);\n\n\tif (wbc)\n\t\tf2fs_balance_fs(sbi);\n\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/bitops.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "f2fs_balance_fs",
          "args": [
            "sbi"
          ],
          "line": 286
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_balance_fs_bg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
          "lines": "278-285",
          "snippet": "void f2fs_balance_fs_bg(struct f2fs_sb_info *sbi)\n{\n\t/* check the # of cached NAT entries and prefree segments */\n\tif (try_to_free_nats(sbi, NAT_ENTRY_PER_BLOCK) ||\n\t\t\texcess_prefree_segs(sbi) ||\n\t\t\t!available_free_memory(sbi, INO_ENTRIES))\n\t\tf2fs_sync_fs(sbi->sb, true);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"node.h\"",
            "#include \"segment.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kthread.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nvoid f2fs_balance_fs_bg(struct f2fs_sb_info *sbi)\n{\n\t/* check the # of cached NAT entries and prefree segments */\n\tif (try_to_free_nats(sbi, NAT_ENTRY_PER_BLOCK) ||\n\t\t\texcess_prefree_segs(sbi) ||\n\t\t\t!available_free_memory(sbi, INO_ENTRIES))\n\t\tf2fs_sync_fs(sbi->sb, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_unlock_op",
          "args": [
            "sbi"
          ],
          "line": 283
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_unlock_op",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "760-763",
          "snippet": "static inline void f2fs_unlock_op(struct f2fs_sb_info *sbi)\n{\n\tup_read(&sbi->cp_rwsem);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void f2fs_unlock_op(struct f2fs_sb_info *sbi)\n{\n\tup_read(&sbi->cp_rwsem);\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_inode_page",
          "args": [
            "inode"
          ],
          "line": 282
        },
        "resolved": true,
        "details": {
          "function_name": "update_inode_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/inode.c",
          "lines": "246-264",
          "snippet": "void update_inode_page(struct inode *inode)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tstruct page *node_page;\nretry:\n\tnode_page = get_node_page(sbi, inode->i_ino);\n\tif (IS_ERR(node_page)) {\n\t\tint err = PTR_ERR(node_page);\n\t\tif (err == -ENOMEM) {\n\t\t\tcond_resched();\n\t\t\tgoto retry;\n\t\t} else if (err != -ENOENT) {\n\t\t\tf2fs_stop_checkpoint(sbi);\n\t\t}\n\t\treturn;\n\t}\n\tupdate_inode(inode, node_page);\n\tf2fs_put_page(node_page, 1);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/bitops.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nvoid update_inode_page(struct inode *inode)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tstruct page *node_page;\nretry:\n\tnode_page = get_node_page(sbi, inode->i_ino);\n\tif (IS_ERR(node_page)) {\n\t\tint err = PTR_ERR(node_page);\n\t\tif (err == -ENOMEM) {\n\t\t\tcond_resched();\n\t\t\tgoto retry;\n\t\t} else if (err != -ENOENT) {\n\t\t\tf2fs_stop_checkpoint(sbi);\n\t\t}\n\t\treturn;\n\t}\n\tupdate_inode(inode, node_page);\n\tf2fs_put_page(node_page, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_lock_op",
          "args": [
            "sbi"
          ],
          "line": 281
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_lock_op",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "755-758",
          "snippet": "static inline void f2fs_lock_op(struct f2fs_sb_info *sbi)\n{\n\tdown_read(&sbi->cp_rwsem);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void f2fs_lock_op(struct f2fs_sb_info *sbi)\n{\n\tdown_read(&sbi->cp_rwsem);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_inode_flag_set",
          "args": [
            "F2FS_I(inode)",
            "FI_DIRTY_INODE"
          ],
          "line": 274
        },
        "resolved": true,
        "details": {
          "function_name": "is_inode_flag_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1179-1182",
          "snippet": "static inline int is_inode_flag_set(struct f2fs_inode_info *fi, int flag)\n{\n\treturn test_bit(flag, &fi->flags);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int is_inode_flag_set(struct f2fs_inode_info *fi, int flag)\n{\n\treturn test_bit(flag, &fi->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "F2FS_I",
          "args": [
            "inode"
          ],
          "line": 274
        },
        "resolved": true,
        "details": {
          "function_name": "F2FS_INODE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "675-678",
          "snippet": "static inline struct f2fs_inode *F2FS_INODE(struct page *page)\n{\n\treturn &((struct f2fs_node *)page_address(page))->i;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_inode *F2FS_INODE(struct page *page)\n{\n\treturn &((struct f2fs_node *)page_address(page))->i;\n}"
        }
      },
      {
        "call_info": {
          "callee": "F2FS_META_INO",
          "args": [
            "sbi"
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "F2FS_NODE_INO",
          "args": [
            "sbi"
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "F2FS_I_SB",
          "args": [
            "inode"
          ],
          "line": 268
        },
        "resolved": true,
        "details": {
          "function_name": "F2FS_I_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "645-648",
          "snippet": "static inline struct f2fs_sb_info *F2FS_I_SB(struct inode *inode)\n{\n\treturn F2FS_SB(inode->i_sb);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_sb_info *F2FS_I_SB(struct inode *inode)\n{\n\treturn F2FS_SB(inode->i_sb);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/bitops.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nint f2fs_write_inode(struct inode *inode, struct writeback_control *wbc)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\n\tif (inode->i_ino == F2FS_NODE_INO(sbi) ||\n\t\t\tinode->i_ino == F2FS_META_INO(sbi))\n\t\treturn 0;\n\n\tif (!is_inode_flag_set(F2FS_I(inode), FI_DIRTY_INODE))\n\t\treturn 0;\n\n\t/*\n\t * We need to lock here to prevent from producing dirty node pages\n\t * during the urgent cleaning time when runing out of free sections.\n\t */\n\tf2fs_lock_op(sbi);\n\tupdate_inode_page(inode);\n\tf2fs_unlock_op(sbi);\n\n\tif (wbc)\n\t\tf2fs_balance_fs(sbi);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "update_inode_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/inode.c",
    "lines": "246-264",
    "snippet": "void update_inode_page(struct inode *inode)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tstruct page *node_page;\nretry:\n\tnode_page = get_node_page(sbi, inode->i_ino);\n\tif (IS_ERR(node_page)) {\n\t\tint err = PTR_ERR(node_page);\n\t\tif (err == -ENOMEM) {\n\t\t\tcond_resched();\n\t\t\tgoto retry;\n\t\t} else if (err != -ENOENT) {\n\t\t\tf2fs_stop_checkpoint(sbi);\n\t\t}\n\t\treturn;\n\t}\n\tupdate_inode(inode, node_page);\n\tf2fs_put_page(node_page, 1);\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/bitops.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "f2fs_put_page",
          "args": [
            "node_page",
            "1"
          ],
          "line": 263
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_put_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1036-1046",
          "snippet": "static inline void f2fs_put_page(struct page *page, int unlock)\n{\n\tif (!page)\n\t\treturn;\n\n\tif (unlock) {\n\t\tf2fs_bug_on(F2FS_P_SB(page), !PageLocked(page));\n\t\tunlock_page(page);\n\t}\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void f2fs_put_page(struct page *page, int unlock)\n{\n\tif (!page)\n\t\treturn;\n\n\tif (unlock) {\n\t\tf2fs_bug_on(F2FS_P_SB(page), !PageLocked(page));\n\t\tunlock_page(page);\n\t}\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_inode",
          "args": [
            "inode",
            "node_page"
          ],
          "line": 262
        },
        "resolved": true,
        "details": {
          "function_name": "update_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/inode.c",
          "lines": "208-244",
          "snippet": "void update_inode(struct inode *inode, struct page *node_page)\n{\n\tstruct f2fs_inode *ri;\n\n\tf2fs_wait_on_page_writeback(node_page, NODE);\n\n\tri = F2FS_INODE(node_page);\n\n\tri->i_mode = cpu_to_le16(inode->i_mode);\n\tri->i_advise = F2FS_I(inode)->i_advise;\n\tri->i_uid = cpu_to_le32(i_uid_read(inode));\n\tri->i_gid = cpu_to_le32(i_gid_read(inode));\n\tri->i_links = cpu_to_le32(inode->i_nlink);\n\tri->i_size = cpu_to_le64(i_size_read(inode));\n\tri->i_blocks = cpu_to_le64(inode->i_blocks);\n\tset_raw_extent(&F2FS_I(inode)->ext, &ri->i_ext);\n\tset_raw_inline(F2FS_I(inode), ri);\n\n\tri->i_atime = cpu_to_le64(inode->i_atime.tv_sec);\n\tri->i_ctime = cpu_to_le64(inode->i_ctime.tv_sec);\n\tri->i_mtime = cpu_to_le64(inode->i_mtime.tv_sec);\n\tri->i_atime_nsec = cpu_to_le32(inode->i_atime.tv_nsec);\n\tri->i_ctime_nsec = cpu_to_le32(inode->i_ctime.tv_nsec);\n\tri->i_mtime_nsec = cpu_to_le32(inode->i_mtime.tv_nsec);\n\tri->i_current_depth = cpu_to_le32(F2FS_I(inode)->i_current_depth);\n\tri->i_xattr_nid = cpu_to_le32(F2FS_I(inode)->i_xattr_nid);\n\tri->i_flags = cpu_to_le32(F2FS_I(inode)->i_flags);\n\tri->i_pino = cpu_to_le32(F2FS_I(inode)->i_pino);\n\tri->i_generation = cpu_to_le32(inode->i_generation);\n\tri->i_dir_level = F2FS_I(inode)->i_dir_level;\n\n\t__set_inode_rdev(inode, ri);\n\tset_cold_node(inode, node_page);\n\tset_page_dirty(node_page);\n\n\tclear_inode_flag(F2FS_I(inode), FI_DIRTY_INODE);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/bitops.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nvoid update_inode(struct inode *inode, struct page *node_page)\n{\n\tstruct f2fs_inode *ri;\n\n\tf2fs_wait_on_page_writeback(node_page, NODE);\n\n\tri = F2FS_INODE(node_page);\n\n\tri->i_mode = cpu_to_le16(inode->i_mode);\n\tri->i_advise = F2FS_I(inode)->i_advise;\n\tri->i_uid = cpu_to_le32(i_uid_read(inode));\n\tri->i_gid = cpu_to_le32(i_gid_read(inode));\n\tri->i_links = cpu_to_le32(inode->i_nlink);\n\tri->i_size = cpu_to_le64(i_size_read(inode));\n\tri->i_blocks = cpu_to_le64(inode->i_blocks);\n\tset_raw_extent(&F2FS_I(inode)->ext, &ri->i_ext);\n\tset_raw_inline(F2FS_I(inode), ri);\n\n\tri->i_atime = cpu_to_le64(inode->i_atime.tv_sec);\n\tri->i_ctime = cpu_to_le64(inode->i_ctime.tv_sec);\n\tri->i_mtime = cpu_to_le64(inode->i_mtime.tv_sec);\n\tri->i_atime_nsec = cpu_to_le32(inode->i_atime.tv_nsec);\n\tri->i_ctime_nsec = cpu_to_le32(inode->i_ctime.tv_nsec);\n\tri->i_mtime_nsec = cpu_to_le32(inode->i_mtime.tv_nsec);\n\tri->i_current_depth = cpu_to_le32(F2FS_I(inode)->i_current_depth);\n\tri->i_xattr_nid = cpu_to_le32(F2FS_I(inode)->i_xattr_nid);\n\tri->i_flags = cpu_to_le32(F2FS_I(inode)->i_flags);\n\tri->i_pino = cpu_to_le32(F2FS_I(inode)->i_pino);\n\tri->i_generation = cpu_to_le32(inode->i_generation);\n\tri->i_dir_level = F2FS_I(inode)->i_dir_level;\n\n\t__set_inode_rdev(inode, ri);\n\tset_cold_node(inode, node_page);\n\tset_page_dirty(node_page);\n\n\tclear_inode_flag(F2FS_I(inode), FI_DIRTY_INODE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_stop_checkpoint",
          "args": [
            "sbi"
          ],
          "line": 258
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_stop_checkpoint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1315-1319",
          "snippet": "static inline void f2fs_stop_checkpoint(struct f2fs_sb_info *sbi)\n{\n\tset_ckpt_flags(sbi->ckpt, CP_ERROR_FLAG);\n\tsbi->sb->s_flags |= MS_RDONLY;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void f2fs_stop_checkpoint(struct f2fs_sb_info *sbi)\n{\n\tset_ckpt_flags(sbi->ckpt, CP_ERROR_FLAG);\n\tsbi->sb->s_flags |= MS_RDONLY;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "node_page"
          ],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "node_page"
          ],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_node_page",
          "args": [
            "sbi",
            "inode->i_ino"
          ],
          "line": 251
        },
        "resolved": true,
        "details": {
          "function_name": "get_node_page_ra",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
          "lines": "1066-1114",
          "snippet": "struct page *get_node_page_ra(struct page *parent, int start)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_P_SB(parent);\n\tstruct blk_plug plug;\n\tstruct page *page;\n\tint err, i, end;\n\tnid_t nid;\n\n\t/* First, try getting the desired direct node. */\n\tnid = get_nid(parent, start, false);\n\tif (!nid)\n\t\treturn ERR_PTR(-ENOENT);\nrepeat:\n\tpage = grab_cache_page(NODE_MAPPING(sbi), nid);\n\tif (!page)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\terr = read_node_page(page, READ_SYNC);\n\tif (err < 0)\n\t\treturn ERR_PTR(err);\n\telse if (err == LOCKED_PAGE)\n\t\tgoto page_hit;\n\n\tblk_start_plug(&plug);\n\n\t/* Then, try readahead for siblings of the desired node */\n\tend = start + MAX_RA_NODE;\n\tend = min(end, NIDS_PER_BLOCK);\n\tfor (i = start + 1; i < end; i++) {\n\t\tnid = get_nid(parent, i, false);\n\t\tif (!nid)\n\t\t\tcontinue;\n\t\tra_node_page(sbi, nid);\n\t}\n\n\tblk_finish_plug(&plug);\n\n\tlock_page(page);\n\tif (unlikely(page->mapping != NODE_MAPPING(sbi))) {\n\t\tf2fs_put_page(page, 1);\n\t\tgoto repeat;\n\t}\npage_hit:\n\tif (unlikely(!PageUptodate(page))) {\n\t\tf2fs_put_page(page, 1);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\treturn page;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mpage.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstruct page *get_node_page_ra(struct page *parent, int start)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_P_SB(parent);\n\tstruct blk_plug plug;\n\tstruct page *page;\n\tint err, i, end;\n\tnid_t nid;\n\n\t/* First, try getting the desired direct node. */\n\tnid = get_nid(parent, start, false);\n\tif (!nid)\n\t\treturn ERR_PTR(-ENOENT);\nrepeat:\n\tpage = grab_cache_page(NODE_MAPPING(sbi), nid);\n\tif (!page)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\terr = read_node_page(page, READ_SYNC);\n\tif (err < 0)\n\t\treturn ERR_PTR(err);\n\telse if (err == LOCKED_PAGE)\n\t\tgoto page_hit;\n\n\tblk_start_plug(&plug);\n\n\t/* Then, try readahead for siblings of the desired node */\n\tend = start + MAX_RA_NODE;\n\tend = min(end, NIDS_PER_BLOCK);\n\tfor (i = start + 1; i < end; i++) {\n\t\tnid = get_nid(parent, i, false);\n\t\tif (!nid)\n\t\t\tcontinue;\n\t\tra_node_page(sbi, nid);\n\t}\n\n\tblk_finish_plug(&plug);\n\n\tlock_page(page);\n\tif (unlikely(page->mapping != NODE_MAPPING(sbi))) {\n\t\tf2fs_put_page(page, 1);\n\t\tgoto repeat;\n\t}\npage_hit:\n\tif (unlikely(!PageUptodate(page))) {\n\t\tf2fs_put_page(page, 1);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\treturn page;\n}"
        }
      },
      {
        "call_info": {
          "callee": "F2FS_I_SB",
          "args": [
            "inode"
          ],
          "line": 248
        },
        "resolved": true,
        "details": {
          "function_name": "F2FS_I_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "645-648",
          "snippet": "static inline struct f2fs_sb_info *F2FS_I_SB(struct inode *inode)\n{\n\treturn F2FS_SB(inode->i_sb);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_sb_info *F2FS_I_SB(struct inode *inode)\n{\n\treturn F2FS_SB(inode->i_sb);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/bitops.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nvoid update_inode_page(struct inode *inode)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tstruct page *node_page;\nretry:\n\tnode_page = get_node_page(sbi, inode->i_ino);\n\tif (IS_ERR(node_page)) {\n\t\tint err = PTR_ERR(node_page);\n\t\tif (err == -ENOMEM) {\n\t\t\tcond_resched();\n\t\t\tgoto retry;\n\t\t} else if (err != -ENOENT) {\n\t\t\tf2fs_stop_checkpoint(sbi);\n\t\t}\n\t\treturn;\n\t}\n\tupdate_inode(inode, node_page);\n\tf2fs_put_page(node_page, 1);\n}"
  },
  {
    "function_name": "update_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/inode.c",
    "lines": "208-244",
    "snippet": "void update_inode(struct inode *inode, struct page *node_page)\n{\n\tstruct f2fs_inode *ri;\n\n\tf2fs_wait_on_page_writeback(node_page, NODE);\n\n\tri = F2FS_INODE(node_page);\n\n\tri->i_mode = cpu_to_le16(inode->i_mode);\n\tri->i_advise = F2FS_I(inode)->i_advise;\n\tri->i_uid = cpu_to_le32(i_uid_read(inode));\n\tri->i_gid = cpu_to_le32(i_gid_read(inode));\n\tri->i_links = cpu_to_le32(inode->i_nlink);\n\tri->i_size = cpu_to_le64(i_size_read(inode));\n\tri->i_blocks = cpu_to_le64(inode->i_blocks);\n\tset_raw_extent(&F2FS_I(inode)->ext, &ri->i_ext);\n\tset_raw_inline(F2FS_I(inode), ri);\n\n\tri->i_atime = cpu_to_le64(inode->i_atime.tv_sec);\n\tri->i_ctime = cpu_to_le64(inode->i_ctime.tv_sec);\n\tri->i_mtime = cpu_to_le64(inode->i_mtime.tv_sec);\n\tri->i_atime_nsec = cpu_to_le32(inode->i_atime.tv_nsec);\n\tri->i_ctime_nsec = cpu_to_le32(inode->i_ctime.tv_nsec);\n\tri->i_mtime_nsec = cpu_to_le32(inode->i_mtime.tv_nsec);\n\tri->i_current_depth = cpu_to_le32(F2FS_I(inode)->i_current_depth);\n\tri->i_xattr_nid = cpu_to_le32(F2FS_I(inode)->i_xattr_nid);\n\tri->i_flags = cpu_to_le32(F2FS_I(inode)->i_flags);\n\tri->i_pino = cpu_to_le32(F2FS_I(inode)->i_pino);\n\tri->i_generation = cpu_to_le32(inode->i_generation);\n\tri->i_dir_level = F2FS_I(inode)->i_dir_level;\n\n\t__set_inode_rdev(inode, ri);\n\tset_cold_node(inode, node_page);\n\tset_page_dirty(node_page);\n\n\tclear_inode_flag(F2FS_I(inode), FI_DIRTY_INODE);\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/bitops.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "clear_inode_flag",
          "args": [
            "F2FS_I(inode)",
            "FI_DIRTY_INODE"
          ],
          "line": 243
        },
        "resolved": true,
        "details": {
          "function_name": "clear_inode_flag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1184-1188",
          "snippet": "static inline void clear_inode_flag(struct f2fs_inode_info *fi, int flag)\n{\n\tif (test_bit(flag, &fi->flags))\n\t\tclear_bit(flag, &fi->flags);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void clear_inode_flag(struct f2fs_inode_info *fi, int flag)\n{\n\tif (test_bit(flag, &fi->flags))\n\t\tclear_bit(flag, &fi->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "F2FS_I",
          "args": [
            "inode"
          ],
          "line": 243
        },
        "resolved": true,
        "details": {
          "function_name": "F2FS_INODE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "675-678",
          "snippet": "static inline struct f2fs_inode *F2FS_INODE(struct page *page)\n{\n\treturn &((struct f2fs_node *)page_address(page))->i;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_inode *F2FS_INODE(struct page *page)\n{\n\treturn &((struct f2fs_node *)page_address(page))->i;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_page_dirty",
          "args": [
            "node_page"
          ],
          "line": 241
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_set_page_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/inode.c",
          "lines": "223-257",
          "snippet": "static int nilfs_set_page_dirty(struct page *page)\n{\n\tstruct inode *inode = page->mapping->host;\n\tint ret = __set_page_dirty_nobuffers(page);\n\n\tif (page_has_buffers(page)) {\n\t\tunsigned nr_dirty = 0;\n\t\tstruct buffer_head *bh, *head;\n\n\t\t/*\n\t\t * This page is locked by callers, and no other thread\n\t\t * concurrently marks its buffers dirty since they are\n\t\t * only dirtied through routines in fs/buffer.c in\n\t\t * which call sites of mark_buffer_dirty are protected\n\t\t * by page lock.\n\t\t */\n\t\tbh = head = page_buffers(page);\n\t\tdo {\n\t\t\t/* Do not mark hole blocks dirty */\n\t\t\tif (buffer_dirty(bh) || !buffer_mapped(bh))\n\t\t\t\tcontinue;\n\n\t\t\tset_buffer_dirty(bh);\n\t\t\tnr_dirty++;\n\t\t} while (bh = bh->b_this_page, bh != head);\n\n\t\tif (nr_dirty)\n\t\t\tnilfs_set_file_dirty(inode, nr_dirty);\n\t} else if (ret) {\n\t\tunsigned nr_dirty = 1 << (PAGE_CACHE_SHIFT - inode->i_blkbits);\n\n\t\tnilfs_set_file_dirty(inode, nr_dirty);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"ifile.h\"",
            "#include \"cpfile.h\"",
            "#include \"mdt.h\"",
            "#include \"page.h\"",
            "#include \"segment.h\"",
            "#include \"btnode.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/aio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/gfp.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"mdt.h\"\n#include \"page.h\"\n#include \"segment.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/aio.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/mpage.h>\n#include <linux/gfp.h>\n#include <linux/buffer_head.h>\n\nstatic int nilfs_set_page_dirty(struct page *page)\n{\n\tstruct inode *inode = page->mapping->host;\n\tint ret = __set_page_dirty_nobuffers(page);\n\n\tif (page_has_buffers(page)) {\n\t\tunsigned nr_dirty = 0;\n\t\tstruct buffer_head *bh, *head;\n\n\t\t/*\n\t\t * This page is locked by callers, and no other thread\n\t\t * concurrently marks its buffers dirty since they are\n\t\t * only dirtied through routines in fs/buffer.c in\n\t\t * which call sites of mark_buffer_dirty are protected\n\t\t * by page lock.\n\t\t */\n\t\tbh = head = page_buffers(page);\n\t\tdo {\n\t\t\t/* Do not mark hole blocks dirty */\n\t\t\tif (buffer_dirty(bh) || !buffer_mapped(bh))\n\t\t\t\tcontinue;\n\n\t\t\tset_buffer_dirty(bh);\n\t\t\tnr_dirty++;\n\t\t} while (bh = bh->b_this_page, bh != head);\n\n\t\tif (nr_dirty)\n\t\t\tnilfs_set_file_dirty(inode, nr_dirty);\n\t} else if (ret) {\n\t\tunsigned nr_dirty = 1 << (PAGE_CACHE_SHIFT - inode->i_blkbits);\n\n\t\tnilfs_set_file_dirty(inode, nr_dirty);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_cold_node",
          "args": [
            "inode",
            "node_page"
          ],
          "line": 240
        },
        "resolved": true,
        "details": {
          "function_name": "set_cold_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.h",
          "lines": "392-402",
          "snippet": "static inline void set_cold_node(struct inode *inode, struct page *page)\n{\n\tstruct f2fs_node *rn = F2FS_NODE(page);\n\tunsigned int flag = le32_to_cpu(rn->footer.flag);\n\n\tif (S_ISDIR(inode->i_mode))\n\t\tflag &= ~(0x1 << COLD_BIT_SHIFT);\n\telse\n\t\tflag |= (0x1 << COLD_BIT_SHIFT);\n\trn->footer.flag = cpu_to_le32(flag);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void set_cold_node(struct inode *inode, struct page *page)\n{\n\tstruct f2fs_node *rn = F2FS_NODE(page);\n\tunsigned int flag = le32_to_cpu(rn->footer.flag);\n\n\tif (S_ISDIR(inode->i_mode))\n\t\tflag &= ~(0x1 << COLD_BIT_SHIFT);\n\telse\n\t\tflag |= (0x1 << COLD_BIT_SHIFT);\n\trn->footer.flag = cpu_to_le32(flag);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__set_inode_rdev",
          "args": [
            "inode",
            "ri"
          ],
          "line": 239
        },
        "resolved": true,
        "details": {
          "function_name": "__set_inode_rdev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/inode.c",
          "lines": "54-68",
          "snippet": "static void __set_inode_rdev(struct inode *inode, struct f2fs_inode *ri)\n{\n\tif (S_ISCHR(inode->i_mode) || S_ISBLK(inode->i_mode)) {\n\t\tif (old_valid_dev(inode->i_rdev)) {\n\t\t\tri->i_addr[0] =\n\t\t\t\tcpu_to_le32(old_encode_dev(inode->i_rdev));\n\t\t\tri->i_addr[1] = 0;\n\t\t} else {\n\t\t\tri->i_addr[0] = 0;\n\t\t\tri->i_addr[1] =\n\t\t\t\tcpu_to_le32(new_encode_dev(inode->i_rdev));\n\t\t\tri->i_addr[2] = 0;\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/bitops.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic void __set_inode_rdev(struct inode *inode, struct f2fs_inode *ri)\n{\n\tif (S_ISCHR(inode->i_mode) || S_ISBLK(inode->i_mode)) {\n\t\tif (old_valid_dev(inode->i_rdev)) {\n\t\t\tri->i_addr[0] =\n\t\t\t\tcpu_to_le32(old_encode_dev(inode->i_rdev));\n\t\t\tri->i_addr[1] = 0;\n\t\t} else {\n\t\t\tri->i_addr[0] = 0;\n\t\t\tri->i_addr[1] =\n\t\t\t\tcpu_to_le32(new_encode_dev(inode->i_rdev));\n\t\t\tri->i_addr[2] = 0;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "inode->i_generation"
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "F2FS_I(inode)->i_pino"
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "F2FS_I(inode)->i_flags"
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "F2FS_I(inode)->i_xattr_nid"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "F2FS_I(inode)->i_current_depth"
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "inode->i_mtime.tv_nsec"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "inode->i_ctime.tv_nsec"
          ],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "inode->i_atime.tv_nsec"
          ],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "inode->i_mtime.tv_sec"
          ],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "inode->i_ctime.tv_sec"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "inode->i_atime.tv_sec"
          ],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_raw_inline",
          "args": [
            "F2FS_I(inode)",
            "ri"
          ],
          "line": 224
        },
        "resolved": true,
        "details": {
          "function_name": "set_raw_inline",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1209-1222",
          "snippet": "static inline void set_raw_inline(struct f2fs_inode_info *fi,\n\t\t\t\t\tstruct f2fs_inode *ri)\n{\n\tri->i_inline = 0;\n\n\tif (is_inode_flag_set(fi, FI_INLINE_XATTR))\n\t\tri->i_inline |= F2FS_INLINE_XATTR;\n\tif (is_inode_flag_set(fi, FI_INLINE_DATA))\n\t\tri->i_inline |= F2FS_INLINE_DATA;\n\tif (is_inode_flag_set(fi, FI_INLINE_DENTRY))\n\t\tri->i_inline |= F2FS_INLINE_DENTRY;\n\tif (is_inode_flag_set(fi, FI_DATA_EXIST))\n\t\tri->i_inline |= F2FS_DATA_EXIST;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void set_raw_inline(struct f2fs_inode_info *fi,\n\t\t\t\t\tstruct f2fs_inode *ri)\n{\n\tri->i_inline = 0;\n\n\tif (is_inode_flag_set(fi, FI_INLINE_XATTR))\n\t\tri->i_inline |= F2FS_INLINE_XATTR;\n\tif (is_inode_flag_set(fi, FI_INLINE_DATA))\n\t\tri->i_inline |= F2FS_INLINE_DATA;\n\tif (is_inode_flag_set(fi, FI_INLINE_DENTRY))\n\t\tri->i_inline |= F2FS_INLINE_DENTRY;\n\tif (is_inode_flag_set(fi, FI_DATA_EXIST))\n\t\tri->i_inline |= F2FS_DATA_EXIST;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_raw_extent",
          "args": [
            "&F2FS_I(inode)->ext",
            "&ri->i_ext"
          ],
          "line": 223
        },
        "resolved": true,
        "details": {
          "function_name": "set_raw_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "329-337",
          "snippet": "static inline void set_raw_extent(struct extent_info *ext,\n\t\t\t\t\tstruct f2fs_extent *i_ext)\n{\n\tread_lock(&ext->ext_lock);\n\ti_ext->fofs = cpu_to_le32(ext->fofs);\n\ti_ext->blk_addr = cpu_to_le32(ext->blk_addr);\n\ti_ext->len = cpu_to_le32(ext->len);\n\tread_unlock(&ext->ext_lock);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void set_raw_extent(struct extent_info *ext,\n\t\t\t\t\tstruct f2fs_extent *i_ext)\n{\n\tread_lock(&ext->ext_lock);\n\ti_ext->fofs = cpu_to_le32(ext->fofs);\n\ti_ext->blk_addr = cpu_to_le32(ext->blk_addr);\n\ti_ext->len = cpu_to_le32(ext->len);\n\tread_unlock(&ext->ext_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "inode->i_blocks"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "i_size_read(inode)"
          ],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "inode->i_nlink"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "i_gid_read(inode)"
          ],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_gid_read",
          "args": [
            "inode"
          ],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "i_uid_read(inode)"
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_uid_read",
          "args": [
            "inode"
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "inode->i_mode"
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f2fs_wait_on_page_writeback",
          "args": [
            "node_page",
            "NODE"
          ],
          "line": 212
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_wait_on_page_writeback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
          "lines": "1321-1331",
          "snippet": "void f2fs_wait_on_page_writeback(struct page *page,\n\t\t\t\tenum page_type type)\n{\n\tif (PageWriteback(page)) {\n\t\tstruct f2fs_sb_info *sbi = F2FS_P_SB(page);\n\n\t\tif (is_merged_page(sbi, page, type))\n\t\t\tf2fs_submit_merged_bio(sbi, type, WRITE);\n\t\twait_on_page_writeback(page);\n\t}\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"node.h\"",
            "#include \"segment.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kthread.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nvoid f2fs_wait_on_page_writeback(struct page *page,\n\t\t\t\tenum page_type type)\n{\n\tif (PageWriteback(page)) {\n\t\tstruct f2fs_sb_info *sbi = F2FS_P_SB(page);\n\n\t\tif (is_merged_page(sbi, page, type))\n\t\t\tf2fs_submit_merged_bio(sbi, type, WRITE);\n\t\twait_on_page_writeback(page);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/bitops.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nvoid update_inode(struct inode *inode, struct page *node_page)\n{\n\tstruct f2fs_inode *ri;\n\n\tf2fs_wait_on_page_writeback(node_page, NODE);\n\n\tri = F2FS_INODE(node_page);\n\n\tri->i_mode = cpu_to_le16(inode->i_mode);\n\tri->i_advise = F2FS_I(inode)->i_advise;\n\tri->i_uid = cpu_to_le32(i_uid_read(inode));\n\tri->i_gid = cpu_to_le32(i_gid_read(inode));\n\tri->i_links = cpu_to_le32(inode->i_nlink);\n\tri->i_size = cpu_to_le64(i_size_read(inode));\n\tri->i_blocks = cpu_to_le64(inode->i_blocks);\n\tset_raw_extent(&F2FS_I(inode)->ext, &ri->i_ext);\n\tset_raw_inline(F2FS_I(inode), ri);\n\n\tri->i_atime = cpu_to_le64(inode->i_atime.tv_sec);\n\tri->i_ctime = cpu_to_le64(inode->i_ctime.tv_sec);\n\tri->i_mtime = cpu_to_le64(inode->i_mtime.tv_sec);\n\tri->i_atime_nsec = cpu_to_le32(inode->i_atime.tv_nsec);\n\tri->i_ctime_nsec = cpu_to_le32(inode->i_ctime.tv_nsec);\n\tri->i_mtime_nsec = cpu_to_le32(inode->i_mtime.tv_nsec);\n\tri->i_current_depth = cpu_to_le32(F2FS_I(inode)->i_current_depth);\n\tri->i_xattr_nid = cpu_to_le32(F2FS_I(inode)->i_xattr_nid);\n\tri->i_flags = cpu_to_le32(F2FS_I(inode)->i_flags);\n\tri->i_pino = cpu_to_le32(F2FS_I(inode)->i_pino);\n\tri->i_generation = cpu_to_le32(inode->i_generation);\n\tri->i_dir_level = F2FS_I(inode)->i_dir_level;\n\n\t__set_inode_rdev(inode, ri);\n\tset_cold_node(inode, node_page);\n\tset_page_dirty(node_page);\n\n\tclear_inode_flag(F2FS_I(inode), FI_DIRTY_INODE);\n}"
  },
  {
    "function_name": "f2fs_iget",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/inode.c",
    "lines": "151-206",
    "snippet": "struct inode *f2fs_iget(struct super_block *sb, unsigned long ino)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_SB(sb);\n\tstruct inode *inode;\n\tint ret = 0;\n\n\tinode = iget_locked(sb, ino);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (!(inode->i_state & I_NEW)) {\n\t\ttrace_f2fs_iget(inode);\n\t\treturn inode;\n\t}\n\tif (ino == F2FS_NODE_INO(sbi) || ino == F2FS_META_INO(sbi))\n\t\tgoto make_now;\n\n\tret = do_read_inode(inode);\n\tif (ret)\n\t\tgoto bad_inode;\nmake_now:\n\tif (ino == F2FS_NODE_INO(sbi)) {\n\t\tinode->i_mapping->a_ops = &f2fs_node_aops;\n\t\tmapping_set_gfp_mask(inode->i_mapping, GFP_F2FS_ZERO);\n\t} else if (ino == F2FS_META_INO(sbi)) {\n\t\tinode->i_mapping->a_ops = &f2fs_meta_aops;\n\t\tmapping_set_gfp_mask(inode->i_mapping, GFP_F2FS_ZERO);\n\t} else if (S_ISREG(inode->i_mode)) {\n\t\tinode->i_op = &f2fs_file_inode_operations;\n\t\tinode->i_fop = &f2fs_file_operations;\n\t\tinode->i_mapping->a_ops = &f2fs_dblock_aops;\n\t} else if (S_ISDIR(inode->i_mode)) {\n\t\tinode->i_op = &f2fs_dir_inode_operations;\n\t\tinode->i_fop = &f2fs_dir_operations;\n\t\tinode->i_mapping->a_ops = &f2fs_dblock_aops;\n\t\tmapping_set_gfp_mask(inode->i_mapping, GFP_F2FS_HIGH_ZERO);\n\t} else if (S_ISLNK(inode->i_mode)) {\n\t\tinode->i_op = &f2fs_symlink_inode_operations;\n\t\tinode->i_mapping->a_ops = &f2fs_dblock_aops;\n\t} else if (S_ISCHR(inode->i_mode) || S_ISBLK(inode->i_mode) ||\n\t\t\tS_ISFIFO(inode->i_mode) || S_ISSOCK(inode->i_mode)) {\n\t\tinode->i_op = &f2fs_special_inode_operations;\n\t\tinit_special_inode(inode, inode->i_mode, inode->i_rdev);\n\t} else {\n\t\tret = -EIO;\n\t\tgoto bad_inode;\n\t}\n\tunlock_new_inode(inode);\n\ttrace_f2fs_iget(inode);\n\treturn inode;\n\nbad_inode:\n\tiget_failed(inode);\n\ttrace_f2fs_iget_exit(inode, ret);\n\treturn ERR_PTR(ret);\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/bitops.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "ret"
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_f2fs_iget_exit",
          "args": [
            "inode",
            "ret"
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iget_failed",
          "args": [
            "inode"
          ],
          "line": 203
        },
        "resolved": true,
        "details": {
          "function_name": "iget_failed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/bad_inode.c",
          "lines": "208-213",
          "snippet": "void iget_failed(struct inode *inode)\n{\n\tmake_bad_inode(inode);\n\tunlock_new_inode(inode);\n\tiput(inode);\n}",
          "includes": [
            "#include <linux/poll.h>",
            "#include <linux/namei.h>",
            "#include <linux/time.h>",
            "#include <linux/stat.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/poll.h>\n#include <linux/namei.h>\n#include <linux/time.h>\n#include <linux/stat.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nvoid iget_failed(struct inode *inode)\n{\n\tmake_bad_inode(inode);\n\tunlock_new_inode(inode);\n\tiput(inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_f2fs_iget",
          "args": [
            "inode"
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_new_inode",
          "args": [
            "inode"
          ],
          "line": 198
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_new_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "924-933",
          "snippet": "void unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_special_inode",
          "args": [
            "inode",
            "inode->i_mode",
            "inode->i_rdev"
          ],
          "line": 193
        },
        "resolved": true,
        "details": {
          "function_name": "init_special_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1854-1871",
          "snippet": "void init_special_inode(struct inode *inode, umode_t mode, dev_t rdev)\n{\n\tinode->i_mode = mode;\n\tif (S_ISCHR(mode)) {\n\t\tinode->i_fop = &def_chr_fops;\n\t\tinode->i_rdev = rdev;\n\t} else if (S_ISBLK(mode)) {\n\t\tinode->i_fop = &def_blk_fops;\n\t\tinode->i_rdev = rdev;\n\t} else if (S_ISFIFO(mode))\n\t\tinode->i_fop = &pipefifo_fops;\n\telse if (S_ISSOCK(mode))\n\t\t;\t/* leave it no_open_fops */\n\telse\n\t\tprintk(KERN_DEBUG \"init_special_inode: bogus i_mode (%o) for\"\n\t\t\t\t  \" inode %s:%lu\\n\", mode, inode->i_sb->s_id,\n\t\t\t\t  inode->i_ino);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid init_special_inode(struct inode *inode, umode_t mode, dev_t rdev)\n{\n\tinode->i_mode = mode;\n\tif (S_ISCHR(mode)) {\n\t\tinode->i_fop = &def_chr_fops;\n\t\tinode->i_rdev = rdev;\n\t} else if (S_ISBLK(mode)) {\n\t\tinode->i_fop = &def_blk_fops;\n\t\tinode->i_rdev = rdev;\n\t} else if (S_ISFIFO(mode))\n\t\tinode->i_fop = &pipefifo_fops;\n\telse if (S_ISSOCK(mode))\n\t\t;\t/* leave it no_open_fops */\n\telse\n\t\tprintk(KERN_DEBUG \"init_special_inode: bogus i_mode (%o) for\"\n\t\t\t\t  \" inode %s:%lu\\n\", mode, inode->i_sb->s_id,\n\t\t\t\t  inode->i_ino);\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISSOCK",
          "args": [
            "inode->i_mode"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISFIFO",
          "args": [
            "inode->i_mode"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISBLK",
          "args": [
            "inode->i_mode"
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISCHR",
          "args": [
            "inode->i_mode"
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISLNK",
          "args": [
            "inode->i_mode"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mapping_set_gfp_mask",
          "args": [
            "inode->i_mapping",
            "GFP_F2FS_HIGH_ZERO"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "inode->i_mode"
          ],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "inode->i_mode"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mapping_set_gfp_mask",
          "args": [
            "inode->i_mapping",
            "GFP_F2FS_ZERO"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "F2FS_META_INO",
          "args": [
            "sbi"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mapping_set_gfp_mask",
          "args": [
            "inode->i_mapping",
            "GFP_F2FS_ZERO"
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "F2FS_NODE_INO",
          "args": [
            "sbi"
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_read_inode",
          "args": [
            "inode"
          ],
          "line": 168
        },
        "resolved": true,
        "details": {
          "function_name": "do_read_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/inode.c",
          "lines": "89-149",
          "snippet": "static int do_read_inode(struct inode *inode)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tstruct f2fs_inode_info *fi = F2FS_I(inode);\n\tstruct page *node_page;\n\tstruct f2fs_inode *ri;\n\n\t/* Check if ino is within scope */\n\tif (check_nid_range(sbi, inode->i_ino)) {\n\t\tf2fs_msg(inode->i_sb, KERN_ERR, \"bad inode number: %lu\",\n\t\t\t (unsigned long) inode->i_ino);\n\t\tWARN_ON(1);\n\t\treturn -EINVAL;\n\t}\n\n\tnode_page = get_node_page(sbi, inode->i_ino);\n\tif (IS_ERR(node_page))\n\t\treturn PTR_ERR(node_page);\n\n\tri = F2FS_INODE(node_page);\n\n\tinode->i_mode = le16_to_cpu(ri->i_mode);\n\ti_uid_write(inode, le32_to_cpu(ri->i_uid));\n\ti_gid_write(inode, le32_to_cpu(ri->i_gid));\n\tset_nlink(inode, le32_to_cpu(ri->i_links));\n\tinode->i_size = le64_to_cpu(ri->i_size);\n\tinode->i_blocks = le64_to_cpu(ri->i_blocks);\n\n\tinode->i_atime.tv_sec = le64_to_cpu(ri->i_atime);\n\tinode->i_ctime.tv_sec = le64_to_cpu(ri->i_ctime);\n\tinode->i_mtime.tv_sec = le64_to_cpu(ri->i_mtime);\n\tinode->i_atime.tv_nsec = le32_to_cpu(ri->i_atime_nsec);\n\tinode->i_ctime.tv_nsec = le32_to_cpu(ri->i_ctime_nsec);\n\tinode->i_mtime.tv_nsec = le32_to_cpu(ri->i_mtime_nsec);\n\tinode->i_generation = le32_to_cpu(ri->i_generation);\n\n\tfi->i_current_depth = le32_to_cpu(ri->i_current_depth);\n\tfi->i_xattr_nid = le32_to_cpu(ri->i_xattr_nid);\n\tfi->i_flags = le32_to_cpu(ri->i_flags);\n\tfi->flags = 0;\n\tfi->i_advise = ri->i_advise;\n\tfi->i_pino = le32_to_cpu(ri->i_pino);\n\tfi->i_dir_level = ri->i_dir_level;\n\n\tget_extent_info(&fi->ext, ri->i_ext);\n\tget_inline_info(fi, ri);\n\n\t/* check data exist */\n\tif (f2fs_has_inline_data(inode) && !f2fs_exist_data(inode))\n\t\t__recover_inline_status(inode, node_page);\n\n\t/* get rdev by using inline_info */\n\t__get_inode_rdev(inode, ri);\n\n\tf2fs_put_page(node_page, 1);\n\n\tstat_inc_inline_inode(inode);\n\tstat_inc_inline_dir(inode);\n\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/bitops.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic int do_read_inode(struct inode *inode)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tstruct f2fs_inode_info *fi = F2FS_I(inode);\n\tstruct page *node_page;\n\tstruct f2fs_inode *ri;\n\n\t/* Check if ino is within scope */\n\tif (check_nid_range(sbi, inode->i_ino)) {\n\t\tf2fs_msg(inode->i_sb, KERN_ERR, \"bad inode number: %lu\",\n\t\t\t (unsigned long) inode->i_ino);\n\t\tWARN_ON(1);\n\t\treturn -EINVAL;\n\t}\n\n\tnode_page = get_node_page(sbi, inode->i_ino);\n\tif (IS_ERR(node_page))\n\t\treturn PTR_ERR(node_page);\n\n\tri = F2FS_INODE(node_page);\n\n\tinode->i_mode = le16_to_cpu(ri->i_mode);\n\ti_uid_write(inode, le32_to_cpu(ri->i_uid));\n\ti_gid_write(inode, le32_to_cpu(ri->i_gid));\n\tset_nlink(inode, le32_to_cpu(ri->i_links));\n\tinode->i_size = le64_to_cpu(ri->i_size);\n\tinode->i_blocks = le64_to_cpu(ri->i_blocks);\n\n\tinode->i_atime.tv_sec = le64_to_cpu(ri->i_atime);\n\tinode->i_ctime.tv_sec = le64_to_cpu(ri->i_ctime);\n\tinode->i_mtime.tv_sec = le64_to_cpu(ri->i_mtime);\n\tinode->i_atime.tv_nsec = le32_to_cpu(ri->i_atime_nsec);\n\tinode->i_ctime.tv_nsec = le32_to_cpu(ri->i_ctime_nsec);\n\tinode->i_mtime.tv_nsec = le32_to_cpu(ri->i_mtime_nsec);\n\tinode->i_generation = le32_to_cpu(ri->i_generation);\n\n\tfi->i_current_depth = le32_to_cpu(ri->i_current_depth);\n\tfi->i_xattr_nid = le32_to_cpu(ri->i_xattr_nid);\n\tfi->i_flags = le32_to_cpu(ri->i_flags);\n\tfi->flags = 0;\n\tfi->i_advise = ri->i_advise;\n\tfi->i_pino = le32_to_cpu(ri->i_pino);\n\tfi->i_dir_level = ri->i_dir_level;\n\n\tget_extent_info(&fi->ext, ri->i_ext);\n\tget_inline_info(fi, ri);\n\n\t/* check data exist */\n\tif (f2fs_has_inline_data(inode) && !f2fs_exist_data(inode))\n\t\t__recover_inline_status(inode, node_page);\n\n\t/* get rdev by using inline_info */\n\t__get_inode_rdev(inode, ri);\n\n\tf2fs_put_page(node_page, 1);\n\n\tstat_inc_inline_inode(inode);\n\tstat_inc_inline_dir(inode);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "F2FS_META_INO",
          "args": [
            "sbi"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "F2FS_NODE_INO",
          "args": [
            "sbi"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_f2fs_iget",
          "args": [
            "inode"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iget_locked",
          "args": [
            "sb",
            "ino"
          ],
          "line": 157
        },
        "resolved": true,
        "details": {
          "function_name": "iget_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1063-1109",
          "snippet": "struct inode *iget_locked(struct super_block *sb, unsigned long ino)\n{\n\tstruct hlist_head *head = inode_hashtable + hash(sb, ino);\n\tstruct inode *inode;\n\n\tspin_lock(&inode_hash_lock);\n\tinode = find_inode_fast(sb, head, ino);\n\tspin_unlock(&inode_hash_lock);\n\tif (inode) {\n\t\twait_on_inode(inode);\n\t\treturn inode;\n\t}\n\n\tinode = alloc_inode(sb);\n\tif (inode) {\n\t\tstruct inode *old;\n\n\t\tspin_lock(&inode_hash_lock);\n\t\t/* We released the lock, so.. */\n\t\told = find_inode_fast(sb, head, ino);\n\t\tif (!old) {\n\t\t\tinode->i_ino = ino;\n\t\t\tspin_lock(&inode->i_lock);\n\t\t\tinode->i_state = I_NEW;\n\t\t\thlist_add_head(&inode->i_hash, head);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tinode_sb_list_add(inode);\n\t\t\tspin_unlock(&inode_hash_lock);\n\n\t\t\t/* Return the locked inode with I_NEW set, the\n\t\t\t * caller is responsible for filling in the contents\n\t\t\t */\n\t\t\treturn inode;\n\t\t}\n\n\t\t/*\n\t\t * Uhhuh, somebody else created the same inode under\n\t\t * us. Use the old inode instead of the one we just\n\t\t * allocated.\n\t\t */\n\t\tspin_unlock(&inode_hash_lock);\n\t\tdestroy_inode(inode);\n\t\tinode = old;\n\t\twait_on_inode(inode);\n\t}\n\treturn inode;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_head *inode_hashtable",
            "static __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic struct hlist_head *inode_hashtable;\nstatic __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstruct inode *iget_locked(struct super_block *sb, unsigned long ino)\n{\n\tstruct hlist_head *head = inode_hashtable + hash(sb, ino);\n\tstruct inode *inode;\n\n\tspin_lock(&inode_hash_lock);\n\tinode = find_inode_fast(sb, head, ino);\n\tspin_unlock(&inode_hash_lock);\n\tif (inode) {\n\t\twait_on_inode(inode);\n\t\treturn inode;\n\t}\n\n\tinode = alloc_inode(sb);\n\tif (inode) {\n\t\tstruct inode *old;\n\n\t\tspin_lock(&inode_hash_lock);\n\t\t/* We released the lock, so.. */\n\t\told = find_inode_fast(sb, head, ino);\n\t\tif (!old) {\n\t\t\tinode->i_ino = ino;\n\t\t\tspin_lock(&inode->i_lock);\n\t\t\tinode->i_state = I_NEW;\n\t\t\thlist_add_head(&inode->i_hash, head);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tinode_sb_list_add(inode);\n\t\t\tspin_unlock(&inode_hash_lock);\n\n\t\t\t/* Return the locked inode with I_NEW set, the\n\t\t\t * caller is responsible for filling in the contents\n\t\t\t */\n\t\t\treturn inode;\n\t\t}\n\n\t\t/*\n\t\t * Uhhuh, somebody else created the same inode under\n\t\t * us. Use the old inode instead of the one we just\n\t\t * allocated.\n\t\t */\n\t\tspin_unlock(&inode_hash_lock);\n\t\tdestroy_inode(inode);\n\t\tinode = old;\n\t\twait_on_inode(inode);\n\t}\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "F2FS_SB",
          "args": [
            "sb"
          ],
          "line": 153
        },
        "resolved": true,
        "details": {
          "function_name": "F2FS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "640-643",
          "snippet": "static inline struct f2fs_sb_info *F2FS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_sb_info *F2FS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/bitops.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstruct inode *f2fs_iget(struct super_block *sb, unsigned long ino)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_SB(sb);\n\tstruct inode *inode;\n\tint ret = 0;\n\n\tinode = iget_locked(sb, ino);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (!(inode->i_state & I_NEW)) {\n\t\ttrace_f2fs_iget(inode);\n\t\treturn inode;\n\t}\n\tif (ino == F2FS_NODE_INO(sbi) || ino == F2FS_META_INO(sbi))\n\t\tgoto make_now;\n\n\tret = do_read_inode(inode);\n\tif (ret)\n\t\tgoto bad_inode;\nmake_now:\n\tif (ino == F2FS_NODE_INO(sbi)) {\n\t\tinode->i_mapping->a_ops = &f2fs_node_aops;\n\t\tmapping_set_gfp_mask(inode->i_mapping, GFP_F2FS_ZERO);\n\t} else if (ino == F2FS_META_INO(sbi)) {\n\t\tinode->i_mapping->a_ops = &f2fs_meta_aops;\n\t\tmapping_set_gfp_mask(inode->i_mapping, GFP_F2FS_ZERO);\n\t} else if (S_ISREG(inode->i_mode)) {\n\t\tinode->i_op = &f2fs_file_inode_operations;\n\t\tinode->i_fop = &f2fs_file_operations;\n\t\tinode->i_mapping->a_ops = &f2fs_dblock_aops;\n\t} else if (S_ISDIR(inode->i_mode)) {\n\t\tinode->i_op = &f2fs_dir_inode_operations;\n\t\tinode->i_fop = &f2fs_dir_operations;\n\t\tinode->i_mapping->a_ops = &f2fs_dblock_aops;\n\t\tmapping_set_gfp_mask(inode->i_mapping, GFP_F2FS_HIGH_ZERO);\n\t} else if (S_ISLNK(inode->i_mode)) {\n\t\tinode->i_op = &f2fs_symlink_inode_operations;\n\t\tinode->i_mapping->a_ops = &f2fs_dblock_aops;\n\t} else if (S_ISCHR(inode->i_mode) || S_ISBLK(inode->i_mode) ||\n\t\t\tS_ISFIFO(inode->i_mode) || S_ISSOCK(inode->i_mode)) {\n\t\tinode->i_op = &f2fs_special_inode_operations;\n\t\tinit_special_inode(inode, inode->i_mode, inode->i_rdev);\n\t} else {\n\t\tret = -EIO;\n\t\tgoto bad_inode;\n\t}\n\tunlock_new_inode(inode);\n\ttrace_f2fs_iget(inode);\n\treturn inode;\n\nbad_inode:\n\tiget_failed(inode);\n\ttrace_f2fs_iget_exit(inode, ret);\n\treturn ERR_PTR(ret);\n}"
  },
  {
    "function_name": "do_read_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/inode.c",
    "lines": "89-149",
    "snippet": "static int do_read_inode(struct inode *inode)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tstruct f2fs_inode_info *fi = F2FS_I(inode);\n\tstruct page *node_page;\n\tstruct f2fs_inode *ri;\n\n\t/* Check if ino is within scope */\n\tif (check_nid_range(sbi, inode->i_ino)) {\n\t\tf2fs_msg(inode->i_sb, KERN_ERR, \"bad inode number: %lu\",\n\t\t\t (unsigned long) inode->i_ino);\n\t\tWARN_ON(1);\n\t\treturn -EINVAL;\n\t}\n\n\tnode_page = get_node_page(sbi, inode->i_ino);\n\tif (IS_ERR(node_page))\n\t\treturn PTR_ERR(node_page);\n\n\tri = F2FS_INODE(node_page);\n\n\tinode->i_mode = le16_to_cpu(ri->i_mode);\n\ti_uid_write(inode, le32_to_cpu(ri->i_uid));\n\ti_gid_write(inode, le32_to_cpu(ri->i_gid));\n\tset_nlink(inode, le32_to_cpu(ri->i_links));\n\tinode->i_size = le64_to_cpu(ri->i_size);\n\tinode->i_blocks = le64_to_cpu(ri->i_blocks);\n\n\tinode->i_atime.tv_sec = le64_to_cpu(ri->i_atime);\n\tinode->i_ctime.tv_sec = le64_to_cpu(ri->i_ctime);\n\tinode->i_mtime.tv_sec = le64_to_cpu(ri->i_mtime);\n\tinode->i_atime.tv_nsec = le32_to_cpu(ri->i_atime_nsec);\n\tinode->i_ctime.tv_nsec = le32_to_cpu(ri->i_ctime_nsec);\n\tinode->i_mtime.tv_nsec = le32_to_cpu(ri->i_mtime_nsec);\n\tinode->i_generation = le32_to_cpu(ri->i_generation);\n\n\tfi->i_current_depth = le32_to_cpu(ri->i_current_depth);\n\tfi->i_xattr_nid = le32_to_cpu(ri->i_xattr_nid);\n\tfi->i_flags = le32_to_cpu(ri->i_flags);\n\tfi->flags = 0;\n\tfi->i_advise = ri->i_advise;\n\tfi->i_pino = le32_to_cpu(ri->i_pino);\n\tfi->i_dir_level = ri->i_dir_level;\n\n\tget_extent_info(&fi->ext, ri->i_ext);\n\tget_inline_info(fi, ri);\n\n\t/* check data exist */\n\tif (f2fs_has_inline_data(inode) && !f2fs_exist_data(inode))\n\t\t__recover_inline_status(inode, node_page);\n\n\t/* get rdev by using inline_info */\n\t__get_inode_rdev(inode, ri);\n\n\tf2fs_put_page(node_page, 1);\n\n\tstat_inc_inline_inode(inode);\n\tstat_inc_inline_dir(inode);\n\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/bitops.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "stat_inc_inline_dir",
          "args": [
            "inode"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stat_inc_inline_inode",
          "args": [
            "inode"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f2fs_put_page",
          "args": [
            "node_page",
            "1"
          ],
          "line": 143
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_put_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1036-1046",
          "snippet": "static inline void f2fs_put_page(struct page *page, int unlock)\n{\n\tif (!page)\n\t\treturn;\n\n\tif (unlock) {\n\t\tf2fs_bug_on(F2FS_P_SB(page), !PageLocked(page));\n\t\tunlock_page(page);\n\t}\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void f2fs_put_page(struct page *page, int unlock)\n{\n\tif (!page)\n\t\treturn;\n\n\tif (unlock) {\n\t\tf2fs_bug_on(F2FS_P_SB(page), !PageLocked(page));\n\t\tunlock_page(page);\n\t}\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__get_inode_rdev",
          "args": [
            "inode",
            "ri"
          ],
          "line": 141
        },
        "resolved": true,
        "details": {
          "function_name": "__get_inode_rdev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/inode.c",
          "lines": "41-52",
          "snippet": "static void __get_inode_rdev(struct inode *inode, struct f2fs_inode *ri)\n{\n\tif (S_ISCHR(inode->i_mode) || S_ISBLK(inode->i_mode) ||\n\t\t\tS_ISFIFO(inode->i_mode) || S_ISSOCK(inode->i_mode)) {\n\t\tif (ri->i_addr[0])\n\t\t\tinode->i_rdev =\n\t\t\t\told_decode_dev(le32_to_cpu(ri->i_addr[0]));\n\t\telse\n\t\t\tinode->i_rdev =\n\t\t\t\tnew_decode_dev(le32_to_cpu(ri->i_addr[1]));\n\t}\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/bitops.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic void __get_inode_rdev(struct inode *inode, struct f2fs_inode *ri)\n{\n\tif (S_ISCHR(inode->i_mode) || S_ISBLK(inode->i_mode) ||\n\t\t\tS_ISFIFO(inode->i_mode) || S_ISSOCK(inode->i_mode)) {\n\t\tif (ri->i_addr[0])\n\t\t\tinode->i_rdev =\n\t\t\t\told_decode_dev(le32_to_cpu(ri->i_addr[0]));\n\t\telse\n\t\t\tinode->i_rdev =\n\t\t\t\tnew_decode_dev(le32_to_cpu(ri->i_addr[1]));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "__recover_inline_status",
          "args": [
            "inode",
            "node_page"
          ],
          "line": 138
        },
        "resolved": true,
        "details": {
          "function_name": "__recover_inline_status",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/inode.c",
          "lines": "70-87",
          "snippet": "static void __recover_inline_status(struct inode *inode, struct page *ipage)\n{\n\tvoid *inline_data = inline_data_addr(ipage);\n\t__le32 *start = inline_data;\n\t__le32 *end = start + MAX_INLINE_DATA / sizeof(__le32);\n\n\twhile (start < end) {\n\t\tif (*start++) {\n\t\t\tf2fs_wait_on_page_writeback(ipage, NODE);\n\n\t\t\tset_inode_flag(F2FS_I(inode), FI_DATA_EXIST);\n\t\t\tset_raw_inline(F2FS_I(inode), F2FS_INODE(ipage));\n\t\t\tset_page_dirty(ipage);\n\t\t\treturn;\n\t\t}\n\t}\n\treturn;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/bitops.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic void __recover_inline_status(struct inode *inode, struct page *ipage)\n{\n\tvoid *inline_data = inline_data_addr(ipage);\n\t__le32 *start = inline_data;\n\t__le32 *end = start + MAX_INLINE_DATA / sizeof(__le32);\n\n\twhile (start < end) {\n\t\tif (*start++) {\n\t\t\tf2fs_wait_on_page_writeback(ipage, NODE);\n\n\t\t\tset_inode_flag(F2FS_I(inode), FI_DATA_EXIST);\n\t\t\tset_raw_inline(F2FS_I(inode), F2FS_INODE(ipage));\n\t\t\tset_page_dirty(ipage);\n\t\t\treturn;\n\t\t}\n\t}\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_exist_data",
          "args": [
            "inode"
          ],
          "line": 137
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_exist_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1262-1265",
          "snippet": "static inline int f2fs_exist_data(struct inode *inode)\n{\n\treturn is_inode_flag_set(F2FS_I(inode), FI_DATA_EXIST);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int f2fs_exist_data(struct inode *inode)\n{\n\treturn is_inode_flag_set(F2FS_I(inode), FI_DATA_EXIST);\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_has_inline_data",
          "args": [
            "inode"
          ],
          "line": 137
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_has_inline_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1251-1254",
          "snippet": "static inline int f2fs_has_inline_data(struct inode *inode)\n{\n\treturn is_inode_flag_set(F2FS_I(inode), FI_INLINE_DATA);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int f2fs_has_inline_data(struct inode *inode)\n{\n\treturn is_inode_flag_set(F2FS_I(inode), FI_INLINE_DATA);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_inline_info",
          "args": [
            "fi",
            "ri"
          ],
          "line": 134
        },
        "resolved": true,
        "details": {
          "function_name": "get_inline_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1196-1207",
          "snippet": "static inline void get_inline_info(struct f2fs_inode_info *fi,\n\t\t\t\t\tstruct f2fs_inode *ri)\n{\n\tif (ri->i_inline & F2FS_INLINE_XATTR)\n\t\tset_inode_flag(fi, FI_INLINE_XATTR);\n\tif (ri->i_inline & F2FS_INLINE_DATA)\n\t\tset_inode_flag(fi, FI_INLINE_DATA);\n\tif (ri->i_inline & F2FS_INLINE_DENTRY)\n\t\tset_inode_flag(fi, FI_INLINE_DENTRY);\n\tif (ri->i_inline & F2FS_DATA_EXIST)\n\t\tset_inode_flag(fi, FI_DATA_EXIST);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void get_inline_info(struct f2fs_inode_info *fi,\n\t\t\t\t\tstruct f2fs_inode *ri)\n{\n\tif (ri->i_inline & F2FS_INLINE_XATTR)\n\t\tset_inode_flag(fi, FI_INLINE_XATTR);\n\tif (ri->i_inline & F2FS_INLINE_DATA)\n\t\tset_inode_flag(fi, FI_INLINE_DATA);\n\tif (ri->i_inline & F2FS_INLINE_DENTRY)\n\t\tset_inode_flag(fi, FI_INLINE_DENTRY);\n\tif (ri->i_inline & F2FS_DATA_EXIST)\n\t\tset_inode_flag(fi, FI_DATA_EXIST);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_extent_info",
          "args": [
            "&fi->ext",
            "ri->i_ext"
          ],
          "line": 133
        },
        "resolved": true,
        "details": {
          "function_name": "get_extent_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "319-327",
          "snippet": "static inline void get_extent_info(struct extent_info *ext,\n\t\t\t\t\tstruct f2fs_extent i_ext)\n{\n\twrite_lock(&ext->ext_lock);\n\text->fofs = le32_to_cpu(i_ext.fofs);\n\text->blk_addr = le32_to_cpu(i_ext.blk_addr);\n\text->len = le32_to_cpu(i_ext.len);\n\twrite_unlock(&ext->ext_lock);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void get_extent_info(struct extent_info *ext,\n\t\t\t\t\tstruct f2fs_extent i_ext)\n{\n\twrite_lock(&ext->ext_lock);\n\text->fofs = le32_to_cpu(i_ext.fofs);\n\text->blk_addr = le32_to_cpu(i_ext.blk_addr);\n\text->len = le32_to_cpu(i_ext.len);\n\twrite_unlock(&ext->ext_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "ri->i_pino"
          ],
          "line": 130
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "ri->i_mtime"
          ],
          "line": 119
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_nlink",
          "args": [
            "inode",
            "le32_to_cpu(ri->i_links)"
          ],
          "line": 113
        },
        "resolved": true,
        "details": {
          "function_name": "set_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "305-316",
          "snippet": "void set_nlink(struct inode *inode, unsigned int nlink)\n{\n\tif (!nlink) {\n\t\tclear_nlink(inode);\n\t} else {\n\t\t/* Yes, some filesystems do change nlink from zero to one */\n\t\tif (inode->i_nlink == 0)\n\t\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\n\t\tinode->__i_nlink = nlink;\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid set_nlink(struct inode *inode, unsigned int nlink)\n{\n\tif (!nlink) {\n\t\tclear_nlink(inode);\n\t} else {\n\t\t/* Yes, some filesystems do change nlink from zero to one */\n\t\tif (inode->i_nlink == 0)\n\t\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\n\t\tinode->__i_nlink = nlink;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_gid_write",
          "args": [
            "inode",
            "le32_to_cpu(ri->i_gid)"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_uid_write",
          "args": [
            "inode",
            "le32_to_cpu(ri->i_uid)"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "ri->i_mode"
          ],
          "line": 110
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "F2FS_INODE",
          "args": [
            "node_page"
          ],
          "line": 108
        },
        "resolved": true,
        "details": {
          "function_name": "F2FS_INODE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "675-678",
          "snippet": "static inline struct f2fs_inode *F2FS_INODE(struct page *page)\n{\n\treturn &((struct f2fs_node *)page_address(page))->i;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_inode *F2FS_INODE(struct page *page)\n{\n\treturn &((struct f2fs_node *)page_address(page))->i;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "node_page"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "node_page"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_node_page",
          "args": [
            "sbi",
            "inode->i_ino"
          ],
          "line": 104
        },
        "resolved": true,
        "details": {
          "function_name": "get_node_page_ra",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
          "lines": "1066-1114",
          "snippet": "struct page *get_node_page_ra(struct page *parent, int start)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_P_SB(parent);\n\tstruct blk_plug plug;\n\tstruct page *page;\n\tint err, i, end;\n\tnid_t nid;\n\n\t/* First, try getting the desired direct node. */\n\tnid = get_nid(parent, start, false);\n\tif (!nid)\n\t\treturn ERR_PTR(-ENOENT);\nrepeat:\n\tpage = grab_cache_page(NODE_MAPPING(sbi), nid);\n\tif (!page)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\terr = read_node_page(page, READ_SYNC);\n\tif (err < 0)\n\t\treturn ERR_PTR(err);\n\telse if (err == LOCKED_PAGE)\n\t\tgoto page_hit;\n\n\tblk_start_plug(&plug);\n\n\t/* Then, try readahead for siblings of the desired node */\n\tend = start + MAX_RA_NODE;\n\tend = min(end, NIDS_PER_BLOCK);\n\tfor (i = start + 1; i < end; i++) {\n\t\tnid = get_nid(parent, i, false);\n\t\tif (!nid)\n\t\t\tcontinue;\n\t\tra_node_page(sbi, nid);\n\t}\n\n\tblk_finish_plug(&plug);\n\n\tlock_page(page);\n\tif (unlikely(page->mapping != NODE_MAPPING(sbi))) {\n\t\tf2fs_put_page(page, 1);\n\t\tgoto repeat;\n\t}\npage_hit:\n\tif (unlikely(!PageUptodate(page))) {\n\t\tf2fs_put_page(page, 1);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\treturn page;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mpage.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstruct page *get_node_page_ra(struct page *parent, int start)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_P_SB(parent);\n\tstruct blk_plug plug;\n\tstruct page *page;\n\tint err, i, end;\n\tnid_t nid;\n\n\t/* First, try getting the desired direct node. */\n\tnid = get_nid(parent, start, false);\n\tif (!nid)\n\t\treturn ERR_PTR(-ENOENT);\nrepeat:\n\tpage = grab_cache_page(NODE_MAPPING(sbi), nid);\n\tif (!page)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\terr = read_node_page(page, READ_SYNC);\n\tif (err < 0)\n\t\treturn ERR_PTR(err);\n\telse if (err == LOCKED_PAGE)\n\t\tgoto page_hit;\n\n\tblk_start_plug(&plug);\n\n\t/* Then, try readahead for siblings of the desired node */\n\tend = start + MAX_RA_NODE;\n\tend = min(end, NIDS_PER_BLOCK);\n\tfor (i = start + 1; i < end; i++) {\n\t\tnid = get_nid(parent, i, false);\n\t\tif (!nid)\n\t\t\tcontinue;\n\t\tra_node_page(sbi, nid);\n\t}\n\n\tblk_finish_plug(&plug);\n\n\tlock_page(page);\n\tif (unlikely(page->mapping != NODE_MAPPING(sbi))) {\n\t\tf2fs_put_page(page, 1);\n\t\tgoto repeat;\n\t}\npage_hit:\n\tif (unlikely(!PageUptodate(page))) {\n\t\tf2fs_put_page(page, 1);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\treturn page;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "1"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f2fs_msg",
          "args": [
            "inode->i_sb",
            "KERN_ERR",
            "\"bad inode number: %lu\"",
            "(unsigned long) inode->i_ino"
          ],
          "line": 98
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_msg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/super.c",
          "lines": "235-245",
          "snippet": "void f2fs_msg(struct super_block *sb, const char *level, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tprintk(\"%sF2FS-fs (%s): %pV\\n\", level, sb->s_id, &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"gc.h\"",
            "#include \"xattr.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/sysfs.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/random.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/parser.h>",
            "#include <linux/kthread.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/statfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"gc.h\"\n#include \"xattr.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/sysfs.h>\n#include <linux/f2fs_fs.h>\n#include <linux/blkdev.h>\n#include <linux/exportfs.h>\n#include <linux/random.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/parser.h>\n#include <linux/kthread.h>\n#include <linux/backing-dev.h>\n#include <linux/buffer_head.h>\n#include <linux/statfs.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nvoid f2fs_msg(struct super_block *sb, const char *level, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tprintk(\"%sF2FS-fs (%s): %pV\\n\", level, sb->s_id, &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_nid_range",
          "args": [
            "sbi",
            "inode->i_ino"
          ],
          "line": 97
        },
        "resolved": true,
        "details": {
          "function_name": "check_nid_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "800-807",
          "snippet": "static inline int check_nid_range(struct f2fs_sb_info *sbi, nid_t nid)\n{\n\tif (unlikely(nid < F2FS_ROOT_INO(sbi)))\n\t\treturn -EINVAL;\n\tif (unlikely(nid >= NM_I(sbi)->max_nid))\n\t\treturn -EINVAL;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int check_nid_range(struct f2fs_sb_info *sbi, nid_t nid)\n{\n\tif (unlikely(nid < F2FS_ROOT_INO(sbi)))\n\t\treturn -EINVAL;\n\tif (unlikely(nid >= NM_I(sbi)->max_nid))\n\t\treturn -EINVAL;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "F2FS_I_SB",
          "args": [
            "inode"
          ],
          "line": 91
        },
        "resolved": true,
        "details": {
          "function_name": "F2FS_I_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "645-648",
          "snippet": "static inline struct f2fs_sb_info *F2FS_I_SB(struct inode *inode)\n{\n\treturn F2FS_SB(inode->i_sb);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_sb_info *F2FS_I_SB(struct inode *inode)\n{\n\treturn F2FS_SB(inode->i_sb);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/bitops.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic int do_read_inode(struct inode *inode)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tstruct f2fs_inode_info *fi = F2FS_I(inode);\n\tstruct page *node_page;\n\tstruct f2fs_inode *ri;\n\n\t/* Check if ino is within scope */\n\tif (check_nid_range(sbi, inode->i_ino)) {\n\t\tf2fs_msg(inode->i_sb, KERN_ERR, \"bad inode number: %lu\",\n\t\t\t (unsigned long) inode->i_ino);\n\t\tWARN_ON(1);\n\t\treturn -EINVAL;\n\t}\n\n\tnode_page = get_node_page(sbi, inode->i_ino);\n\tif (IS_ERR(node_page))\n\t\treturn PTR_ERR(node_page);\n\n\tri = F2FS_INODE(node_page);\n\n\tinode->i_mode = le16_to_cpu(ri->i_mode);\n\ti_uid_write(inode, le32_to_cpu(ri->i_uid));\n\ti_gid_write(inode, le32_to_cpu(ri->i_gid));\n\tset_nlink(inode, le32_to_cpu(ri->i_links));\n\tinode->i_size = le64_to_cpu(ri->i_size);\n\tinode->i_blocks = le64_to_cpu(ri->i_blocks);\n\n\tinode->i_atime.tv_sec = le64_to_cpu(ri->i_atime);\n\tinode->i_ctime.tv_sec = le64_to_cpu(ri->i_ctime);\n\tinode->i_mtime.tv_sec = le64_to_cpu(ri->i_mtime);\n\tinode->i_atime.tv_nsec = le32_to_cpu(ri->i_atime_nsec);\n\tinode->i_ctime.tv_nsec = le32_to_cpu(ri->i_ctime_nsec);\n\tinode->i_mtime.tv_nsec = le32_to_cpu(ri->i_mtime_nsec);\n\tinode->i_generation = le32_to_cpu(ri->i_generation);\n\n\tfi->i_current_depth = le32_to_cpu(ri->i_current_depth);\n\tfi->i_xattr_nid = le32_to_cpu(ri->i_xattr_nid);\n\tfi->i_flags = le32_to_cpu(ri->i_flags);\n\tfi->flags = 0;\n\tfi->i_advise = ri->i_advise;\n\tfi->i_pino = le32_to_cpu(ri->i_pino);\n\tfi->i_dir_level = ri->i_dir_level;\n\n\tget_extent_info(&fi->ext, ri->i_ext);\n\tget_inline_info(fi, ri);\n\n\t/* check data exist */\n\tif (f2fs_has_inline_data(inode) && !f2fs_exist_data(inode))\n\t\t__recover_inline_status(inode, node_page);\n\n\t/* get rdev by using inline_info */\n\t__get_inode_rdev(inode, ri);\n\n\tf2fs_put_page(node_page, 1);\n\n\tstat_inc_inline_inode(inode);\n\tstat_inc_inline_dir(inode);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "__recover_inline_status",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/inode.c",
    "lines": "70-87",
    "snippet": "static void __recover_inline_status(struct inode *inode, struct page *ipage)\n{\n\tvoid *inline_data = inline_data_addr(ipage);\n\t__le32 *start = inline_data;\n\t__le32 *end = start + MAX_INLINE_DATA / sizeof(__le32);\n\n\twhile (start < end) {\n\t\tif (*start++) {\n\t\t\tf2fs_wait_on_page_writeback(ipage, NODE);\n\n\t\t\tset_inode_flag(F2FS_I(inode), FI_DATA_EXIST);\n\t\t\tset_raw_inline(F2FS_I(inode), F2FS_INODE(ipage));\n\t\t\tset_page_dirty(ipage);\n\t\t\treturn;\n\t\t}\n\t}\n\treturn;\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/bitops.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_page_dirty",
          "args": [
            "ipage"
          ],
          "line": 82
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_set_page_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/inode.c",
          "lines": "223-257",
          "snippet": "static int nilfs_set_page_dirty(struct page *page)\n{\n\tstruct inode *inode = page->mapping->host;\n\tint ret = __set_page_dirty_nobuffers(page);\n\n\tif (page_has_buffers(page)) {\n\t\tunsigned nr_dirty = 0;\n\t\tstruct buffer_head *bh, *head;\n\n\t\t/*\n\t\t * This page is locked by callers, and no other thread\n\t\t * concurrently marks its buffers dirty since they are\n\t\t * only dirtied through routines in fs/buffer.c in\n\t\t * which call sites of mark_buffer_dirty are protected\n\t\t * by page lock.\n\t\t */\n\t\tbh = head = page_buffers(page);\n\t\tdo {\n\t\t\t/* Do not mark hole blocks dirty */\n\t\t\tif (buffer_dirty(bh) || !buffer_mapped(bh))\n\t\t\t\tcontinue;\n\n\t\t\tset_buffer_dirty(bh);\n\t\t\tnr_dirty++;\n\t\t} while (bh = bh->b_this_page, bh != head);\n\n\t\tif (nr_dirty)\n\t\t\tnilfs_set_file_dirty(inode, nr_dirty);\n\t} else if (ret) {\n\t\tunsigned nr_dirty = 1 << (PAGE_CACHE_SHIFT - inode->i_blkbits);\n\n\t\tnilfs_set_file_dirty(inode, nr_dirty);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"ifile.h\"",
            "#include \"cpfile.h\"",
            "#include \"mdt.h\"",
            "#include \"page.h\"",
            "#include \"segment.h\"",
            "#include \"btnode.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/aio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/gfp.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"mdt.h\"\n#include \"page.h\"\n#include \"segment.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/aio.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/mpage.h>\n#include <linux/gfp.h>\n#include <linux/buffer_head.h>\n\nstatic int nilfs_set_page_dirty(struct page *page)\n{\n\tstruct inode *inode = page->mapping->host;\n\tint ret = __set_page_dirty_nobuffers(page);\n\n\tif (page_has_buffers(page)) {\n\t\tunsigned nr_dirty = 0;\n\t\tstruct buffer_head *bh, *head;\n\n\t\t/*\n\t\t * This page is locked by callers, and no other thread\n\t\t * concurrently marks its buffers dirty since they are\n\t\t * only dirtied through routines in fs/buffer.c in\n\t\t * which call sites of mark_buffer_dirty are protected\n\t\t * by page lock.\n\t\t */\n\t\tbh = head = page_buffers(page);\n\t\tdo {\n\t\t\t/* Do not mark hole blocks dirty */\n\t\t\tif (buffer_dirty(bh) || !buffer_mapped(bh))\n\t\t\t\tcontinue;\n\n\t\t\tset_buffer_dirty(bh);\n\t\t\tnr_dirty++;\n\t\t} while (bh = bh->b_this_page, bh != head);\n\n\t\tif (nr_dirty)\n\t\t\tnilfs_set_file_dirty(inode, nr_dirty);\n\t} else if (ret) {\n\t\tunsigned nr_dirty = 1 << (PAGE_CACHE_SHIFT - inode->i_blkbits);\n\n\t\tnilfs_set_file_dirty(inode, nr_dirty);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_raw_inline",
          "args": [
            "F2FS_I(inode)",
            "F2FS_INODE(ipage)"
          ],
          "line": 81
        },
        "resolved": true,
        "details": {
          "function_name": "set_raw_inline",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1209-1222",
          "snippet": "static inline void set_raw_inline(struct f2fs_inode_info *fi,\n\t\t\t\t\tstruct f2fs_inode *ri)\n{\n\tri->i_inline = 0;\n\n\tif (is_inode_flag_set(fi, FI_INLINE_XATTR))\n\t\tri->i_inline |= F2FS_INLINE_XATTR;\n\tif (is_inode_flag_set(fi, FI_INLINE_DATA))\n\t\tri->i_inline |= F2FS_INLINE_DATA;\n\tif (is_inode_flag_set(fi, FI_INLINE_DENTRY))\n\t\tri->i_inline |= F2FS_INLINE_DENTRY;\n\tif (is_inode_flag_set(fi, FI_DATA_EXIST))\n\t\tri->i_inline |= F2FS_DATA_EXIST;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void set_raw_inline(struct f2fs_inode_info *fi,\n\t\t\t\t\tstruct f2fs_inode *ri)\n{\n\tri->i_inline = 0;\n\n\tif (is_inode_flag_set(fi, FI_INLINE_XATTR))\n\t\tri->i_inline |= F2FS_INLINE_XATTR;\n\tif (is_inode_flag_set(fi, FI_INLINE_DATA))\n\t\tri->i_inline |= F2FS_INLINE_DATA;\n\tif (is_inode_flag_set(fi, FI_INLINE_DENTRY))\n\t\tri->i_inline |= F2FS_INLINE_DENTRY;\n\tif (is_inode_flag_set(fi, FI_DATA_EXIST))\n\t\tri->i_inline |= F2FS_DATA_EXIST;\n}"
        }
      },
      {
        "call_info": {
          "callee": "F2FS_INODE",
          "args": [
            "ipage"
          ],
          "line": 81
        },
        "resolved": true,
        "details": {
          "function_name": "F2FS_INODE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "675-678",
          "snippet": "static inline struct f2fs_inode *F2FS_INODE(struct page *page)\n{\n\treturn &((struct f2fs_node *)page_address(page))->i;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_inode *F2FS_INODE(struct page *page)\n{\n\treturn &((struct f2fs_node *)page_address(page))->i;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_inode_flag",
          "args": [
            "F2FS_I(inode)",
            "FI_DATA_EXIST"
          ],
          "line": 80
        },
        "resolved": true,
        "details": {
          "function_name": "set_inode_flag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1173-1177",
          "snippet": "static inline void set_inode_flag(struct f2fs_inode_info *fi, int flag)\n{\n\tif (!test_bit(flag, &fi->flags))\n\t\tset_bit(flag, &fi->flags);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void set_inode_flag(struct f2fs_inode_info *fi, int flag)\n{\n\tif (!test_bit(flag, &fi->flags))\n\t\tset_bit(flag, &fi->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_wait_on_page_writeback",
          "args": [
            "ipage",
            "NODE"
          ],
          "line": 78
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_wait_on_page_writeback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
          "lines": "1321-1331",
          "snippet": "void f2fs_wait_on_page_writeback(struct page *page,\n\t\t\t\tenum page_type type)\n{\n\tif (PageWriteback(page)) {\n\t\tstruct f2fs_sb_info *sbi = F2FS_P_SB(page);\n\n\t\tif (is_merged_page(sbi, page, type))\n\t\t\tf2fs_submit_merged_bio(sbi, type, WRITE);\n\t\twait_on_page_writeback(page);\n\t}\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"node.h\"",
            "#include \"segment.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kthread.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nvoid f2fs_wait_on_page_writeback(struct page *page,\n\t\t\t\tenum page_type type)\n{\n\tif (PageWriteback(page)) {\n\t\tstruct f2fs_sb_info *sbi = F2FS_P_SB(page);\n\n\t\tif (is_merged_page(sbi, page, type))\n\t\t\tf2fs_submit_merged_bio(sbi, type, WRITE);\n\t\twait_on_page_writeback(page);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "inline_data_addr",
          "args": [
            "ipage"
          ],
          "line": 72
        },
        "resolved": true,
        "details": {
          "function_name": "inline_data_addr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1282-1286",
          "snippet": "static inline void *inline_data_addr(struct page *page)\n{\n\tstruct f2fs_inode *ri = F2FS_INODE(page);\n\treturn (void *)&(ri->i_addr[1]);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void *inline_data_addr(struct page *page)\n{\n\tstruct f2fs_inode *ri = F2FS_INODE(page);\n\treturn (void *)&(ri->i_addr[1]);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/bitops.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic void __recover_inline_status(struct inode *inode, struct page *ipage)\n{\n\tvoid *inline_data = inline_data_addr(ipage);\n\t__le32 *start = inline_data;\n\t__le32 *end = start + MAX_INLINE_DATA / sizeof(__le32);\n\n\twhile (start < end) {\n\t\tif (*start++) {\n\t\t\tf2fs_wait_on_page_writeback(ipage, NODE);\n\n\t\t\tset_inode_flag(F2FS_I(inode), FI_DATA_EXIST);\n\t\t\tset_raw_inline(F2FS_I(inode), F2FS_INODE(ipage));\n\t\t\tset_page_dirty(ipage);\n\t\t\treturn;\n\t\t}\n\t}\n\treturn;\n}"
  },
  {
    "function_name": "__set_inode_rdev",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/inode.c",
    "lines": "54-68",
    "snippet": "static void __set_inode_rdev(struct inode *inode, struct f2fs_inode *ri)\n{\n\tif (S_ISCHR(inode->i_mode) || S_ISBLK(inode->i_mode)) {\n\t\tif (old_valid_dev(inode->i_rdev)) {\n\t\t\tri->i_addr[0] =\n\t\t\t\tcpu_to_le32(old_encode_dev(inode->i_rdev));\n\t\t\tri->i_addr[1] = 0;\n\t\t} else {\n\t\t\tri->i_addr[0] = 0;\n\t\t\tri->i_addr[1] =\n\t\t\t\tcpu_to_le32(new_encode_dev(inode->i_rdev));\n\t\t\tri->i_addr[2] = 0;\n\t\t}\n\t}\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/bitops.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "new_encode_dev(inode->i_rdev)"
          ],
          "line": 64
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "new_encode_dev",
          "args": [
            "inode->i_rdev"
          ],
          "line": 64
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "old_encode_dev(inode->i_rdev)"
          ],
          "line": 59
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "old_encode_dev",
          "args": [
            "inode->i_rdev"
          ],
          "line": 59
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "old_valid_dev",
          "args": [
            "inode->i_rdev"
          ],
          "line": 57
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISBLK",
          "args": [
            "inode->i_mode"
          ],
          "line": 56
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISCHR",
          "args": [
            "inode->i_mode"
          ],
          "line": 56
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/bitops.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic void __set_inode_rdev(struct inode *inode, struct f2fs_inode *ri)\n{\n\tif (S_ISCHR(inode->i_mode) || S_ISBLK(inode->i_mode)) {\n\t\tif (old_valid_dev(inode->i_rdev)) {\n\t\t\tri->i_addr[0] =\n\t\t\t\tcpu_to_le32(old_encode_dev(inode->i_rdev));\n\t\t\tri->i_addr[1] = 0;\n\t\t} else {\n\t\t\tri->i_addr[0] = 0;\n\t\t\tri->i_addr[1] =\n\t\t\t\tcpu_to_le32(new_encode_dev(inode->i_rdev));\n\t\t\tri->i_addr[2] = 0;\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "__get_inode_rdev",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/inode.c",
    "lines": "41-52",
    "snippet": "static void __get_inode_rdev(struct inode *inode, struct f2fs_inode *ri)\n{\n\tif (S_ISCHR(inode->i_mode) || S_ISBLK(inode->i_mode) ||\n\t\t\tS_ISFIFO(inode->i_mode) || S_ISSOCK(inode->i_mode)) {\n\t\tif (ri->i_addr[0])\n\t\t\tinode->i_rdev =\n\t\t\t\told_decode_dev(le32_to_cpu(ri->i_addr[0]));\n\t\telse\n\t\t\tinode->i_rdev =\n\t\t\t\tnew_decode_dev(le32_to_cpu(ri->i_addr[1]));\n\t}\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/bitops.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "new_decode_dev",
          "args": [
            "le32_to_cpu(ri->i_addr[1])"
          ],
          "line": 50
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "ri->i_addr[1]"
          ],
          "line": 50
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "old_decode_dev",
          "args": [
            "le32_to_cpu(ri->i_addr[0])"
          ],
          "line": 47
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISSOCK",
          "args": [
            "inode->i_mode"
          ],
          "line": 44
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISFIFO",
          "args": [
            "inode->i_mode"
          ],
          "line": 44
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISBLK",
          "args": [
            "inode->i_mode"
          ],
          "line": 43
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISCHR",
          "args": [
            "inode->i_mode"
          ],
          "line": 43
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/bitops.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic void __get_inode_rdev(struct inode *inode, struct f2fs_inode *ri)\n{\n\tif (S_ISCHR(inode->i_mode) || S_ISBLK(inode->i_mode) ||\n\t\t\tS_ISFIFO(inode->i_mode) || S_ISSOCK(inode->i_mode)) {\n\t\tif (ri->i_addr[0])\n\t\t\tinode->i_rdev =\n\t\t\t\told_decode_dev(le32_to_cpu(ri->i_addr[0]));\n\t\telse\n\t\t\tinode->i_rdev =\n\t\t\t\tnew_decode_dev(le32_to_cpu(ri->i_addr[1]));\n\t}\n}"
  },
  {
    "function_name": "f2fs_set_inode_flags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/inode.c",
    "lines": "22-39",
    "snippet": "void f2fs_set_inode_flags(struct inode *inode)\n{\n\tunsigned int flags = F2FS_I(inode)->i_flags;\n\tunsigned int new_fl = 0;\n\n\tif (flags & FS_SYNC_FL)\n\t\tnew_fl |= S_SYNC;\n\tif (flags & FS_APPEND_FL)\n\t\tnew_fl |= S_APPEND;\n\tif (flags & FS_IMMUTABLE_FL)\n\t\tnew_fl |= S_IMMUTABLE;\n\tif (flags & FS_NOATIME_FL)\n\t\tnew_fl |= S_NOATIME;\n\tif (flags & FS_DIRSYNC_FL)\n\t\tnew_fl |= S_DIRSYNC;\n\tset_mask_bits(&inode->i_flags,\n\t\t\tS_SYNC|S_APPEND|S_IMMUTABLE|S_NOATIME|S_DIRSYNC, new_fl);\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/bitops.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_mask_bits",
          "args": [
            "&inode->i_flags",
            "S_SYNC|S_APPEND|S_IMMUTABLE|S_NOATIME|S_DIRSYNC",
            "new_fl"
          ],
          "line": 37
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "F2FS_I",
          "args": [
            "inode"
          ],
          "line": 24
        },
        "resolved": true,
        "details": {
          "function_name": "F2FS_INODE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "675-678",
          "snippet": "static inline struct f2fs_inode *F2FS_INODE(struct page *page)\n{\n\treturn &((struct f2fs_node *)page_address(page))->i;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_inode *F2FS_INODE(struct page *page)\n{\n\treturn &((struct f2fs_node *)page_address(page))->i;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/bitops.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nvoid f2fs_set_inode_flags(struct inode *inode)\n{\n\tunsigned int flags = F2FS_I(inode)->i_flags;\n\tunsigned int new_fl = 0;\n\n\tif (flags & FS_SYNC_FL)\n\t\tnew_fl |= S_SYNC;\n\tif (flags & FS_APPEND_FL)\n\t\tnew_fl |= S_APPEND;\n\tif (flags & FS_IMMUTABLE_FL)\n\t\tnew_fl |= S_IMMUTABLE;\n\tif (flags & FS_NOATIME_FL)\n\t\tnew_fl |= S_NOATIME;\n\tif (flags & FS_DIRSYNC_FL)\n\t\tnew_fl |= S_DIRSYNC;\n\tset_mask_bits(&inode->i_flags,\n\t\t\tS_SYNC|S_APPEND|S_IMMUTABLE|S_NOATIME|S_DIRSYNC, new_fl);\n}"
  }
]