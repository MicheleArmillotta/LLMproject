[
  {
    "function_name": "dlm_send_proxy_ast_msg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmast.c",
    "lines": "450-504",
    "snippet": "int dlm_send_proxy_ast_msg(struct dlm_ctxt *dlm, struct dlm_lock_resource *res,\n\t\t\t   struct dlm_lock *lock, int msg_type,\n\t\t\t   int blocked_type, int flags)\n{\n\tint ret = 0;\n\tstruct dlm_proxy_ast past;\n\tstruct kvec vec[2];\n\tsize_t veclen = 1;\n\tint status;\n\n\tmlog(0, \"%s: res %.*s, to %u, type %d, blocked_type %d\\n\", dlm->name,\n\t     res->lockname.len, res->lockname.name, lock->ml.node, msg_type,\n\t     blocked_type);\n\n\tmemset(&past, 0, sizeof(struct dlm_proxy_ast));\n\tpast.node_idx = dlm->node_num;\n\tpast.type = msg_type;\n\tpast.blocked_type = blocked_type;\n\tpast.namelen = res->lockname.len;\n\tmemcpy(past.name, res->lockname.name, past.namelen);\n\tpast.cookie = lock->ml.cookie;\n\n\tvec[0].iov_len = sizeof(struct dlm_proxy_ast);\n\tvec[0].iov_base = &past;\n\tif (flags & DLM_LKSB_GET_LVB) {\n\t\tbe32_add_cpu(&past.flags, LKM_GET_LVB);\n\t\tvec[1].iov_len = DLM_LVB_LEN;\n\t\tvec[1].iov_base = lock->lksb->lvb;\n\t\tveclen++;\n\t}\n\n\tret = o2net_send_message_vec(DLM_PROXY_AST_MSG, dlm->key, vec, veclen,\n\t\t\t\t     lock->ml.node, &status);\n\tif (ret < 0)\n\t\tmlog(ML_ERROR, \"%s: res %.*s, error %d send AST to node %u\\n\",\n\t\t     dlm->name, res->lockname.len, res->lockname.name, ret,\n\t\t     lock->ml.node);\n\telse {\n\t\tif (status == DLM_RECOVERING) {\n\t\t\tmlog(ML_ERROR, \"sent AST to node %u, it thinks this \"\n\t\t\t     \"node is dead!\\n\", lock->ml.node);\n\t\t\tBUG();\n\t\t} else if (status == DLM_MIGRATING) {\n\t\t\tmlog(ML_ERROR, \"sent AST to node %u, it returned \"\n\t\t\t     \"DLM_MIGRATING!\\n\", lock->ml.node);\n\t\t\tBUG();\n\t\t} else if (status != DLM_NORMAL && status != DLM_IVLOCKID) {\n\t\t\tmlog(ML_ERROR, \"AST to node %u returned %d!\\n\",\n\t\t\t     lock->ml.node, status);\n\t\t\t/* ignore it */\n\t\t}\n\t\tret = 0;\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/spinlock.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/random.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void dlm_update_lvb(struct dlm_ctxt *dlm, struct dlm_lock_resource *res,\n\t\t\t   struct dlm_lock *lock);",
      "static int dlm_should_cancel_bast(struct dlm_ctxt *dlm, struct dlm_lock *lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"AST to node %u returned %d!\\n\"",
            "lock->ml.node",
            "status"
          ],
          "line": 497
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_store",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "115-121",
          "snippet": "static ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"sent AST to node %u, it returned \"\n\t\t\t     \"DLM_MIGRATING!\\n\"",
            "lock->ml.node"
          ],
          "line": 493
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "107-113",
          "snippet": "static ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"%s: res %.*s, error %d send AST to node %u\\n\"",
            "dlm->name",
            "res->lockname.len",
            "res->lockname.name",
            "ret",
            "lock->ml.node"
          ],
          "line": 484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "o2net_send_message_vec",
          "args": [
            "DLM_PROXY_AST_MSG",
            "dlm->key",
            "vec",
            "veclen",
            "lock->ml.node",
            "&status"
          ],
          "line": 481
        },
        "resolved": true,
        "details": {
          "function_name": "o2net_send_message_vec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
          "lines": "1029-1144",
          "snippet": "int o2net_send_message_vec(u32 msg_type, u32 key, struct kvec *caller_vec,\n\t\t\t   size_t caller_veclen, u8 target_node, int *status)\n{\n\tint ret = 0;\n\tstruct o2net_msg *msg = NULL;\n\tsize_t veclen, caller_bytes = 0;\n\tstruct kvec *vec = NULL;\n\tstruct o2net_sock_container *sc = NULL;\n\tstruct o2net_node *nn = o2net_nn_from_num(target_node);\n\tstruct o2net_status_wait nsw = {\n\t\t.ns_node_item = LIST_HEAD_INIT(nsw.ns_node_item),\n\t};\n\tstruct o2net_send_tracking nst;\n\n\to2net_init_nst(&nst, msg_type, key, current, target_node);\n\n\tif (o2net_wq == NULL) {\n\t\tmlog(0, \"attempt to tx without o2netd running\\n\");\n\t\tret = -ESRCH;\n\t\tgoto out;\n\t}\n\n\tif (caller_veclen == 0) {\n\t\tmlog(0, \"bad kvec array length\\n\");\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tcaller_bytes = iov_length((struct iovec *)caller_vec, caller_veclen);\n\tif (caller_bytes > O2NET_MAX_PAYLOAD_BYTES) {\n\t\tmlog(0, \"total payload len %zu too large\\n\", caller_bytes);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (target_node == o2nm_this_node()) {\n\t\tret = -ELOOP;\n\t\tgoto out;\n\t}\n\n\to2net_debug_add_nst(&nst);\n\n\to2net_set_nst_sock_time(&nst);\n\n\twait_event(nn->nn_sc_wq, o2net_tx_can_proceed(nn, &sc, &ret));\n\tif (ret)\n\t\tgoto out;\n\n\to2net_set_nst_sock_container(&nst, sc);\n\n\tveclen = caller_veclen + 1;\n\tvec = kmalloc(sizeof(struct kvec) * veclen, GFP_ATOMIC);\n\tif (vec == NULL) {\n\t\tmlog(0, \"failed to %zu element kvec!\\n\", veclen);\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tmsg = kmalloc(sizeof(struct o2net_msg), GFP_ATOMIC);\n\tif (!msg) {\n\t\tmlog(0, \"failed to allocate a o2net_msg!\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\to2net_init_msg(msg, caller_bytes, msg_type, key);\n\n\tvec[0].iov_len = sizeof(struct o2net_msg);\n\tvec[0].iov_base = msg;\n\tmemcpy(&vec[1], caller_vec, caller_veclen * sizeof(struct kvec));\n\n\tret = o2net_prep_nsw(nn, &nsw);\n\tif (ret)\n\t\tgoto out;\n\n\tmsg->msg_num = cpu_to_be32(nsw.ns_id);\n\to2net_set_nst_msg_id(&nst, nsw.ns_id);\n\n\to2net_set_nst_send_time(&nst);\n\n\t/* finally, convert the message header to network byte-order\n\t * and send */\n\tmutex_lock(&sc->sc_send_lock);\n\tret = o2net_send_tcp_msg(sc->sc_sock, vec, veclen,\n\t\t\t\t sizeof(struct o2net_msg) + caller_bytes);\n\tmutex_unlock(&sc->sc_send_lock);\n\tmsglog(msg, \"sending returned %d\\n\", ret);\n\tif (ret < 0) {\n\t\tmlog(0, \"error returned from o2net_send_tcp_msg=%d\\n\", ret);\n\t\tgoto out;\n\t}\n\n\t/* wait on other node's handler */\n\to2net_set_nst_status_time(&nst);\n\twait_event(nsw.ns_wq, o2net_nsw_completed(nn, &nsw));\n\n\to2net_update_send_stats(&nst, sc);\n\n\t/* Note that we avoid overwriting the callers status return\n\t * variable if a system error was reported on the other\n\t * side. Callers beware. */\n\tret = o2net_sys_err_to_errno(nsw.ns_sys_status);\n\tif (status && !ret)\n\t\t*status = nsw.ns_status;\n\n\tmlog(0, \"woken, returning system status %d, user status %d\\n\",\n\t     ret, nsw.ns_status);\nout:\n\to2net_debug_del_nst(&nst); /* must be before dropping sc and node */\n\tif (sc)\n\t\tsc_put(sc);\n\tkfree(vec);\n\tkfree(msg);\n\to2net_complete_nsw(nn, &nsw, 0, 0, 0);\n\treturn ret;\n}",
          "includes": [
            "#include \"tcp_internal.h\"",
            "#include \"quorum.h\"",
            "#include \"masklog.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include \"heartbeat.h\"",
            "#include <asm/uaccess.h>",
            "#include <net/tcp.h>",
            "#include <linux/export.h>",
            "#include <linux/net.h>",
            "#include <linux/kref.h>",
            "#include <linux/idr.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct workqueue_struct *o2net_wq;",
            "static void o2net_sc_postpone_idle(struct o2net_sock_container *sc);",
            "static void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic struct workqueue_struct *o2net_wq;\nstatic void o2net_sc_postpone_idle(struct o2net_sock_container *sc);\nstatic void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);\n\nint o2net_send_message_vec(u32 msg_type, u32 key, struct kvec *caller_vec,\n\t\t\t   size_t caller_veclen, u8 target_node, int *status)\n{\n\tint ret = 0;\n\tstruct o2net_msg *msg = NULL;\n\tsize_t veclen, caller_bytes = 0;\n\tstruct kvec *vec = NULL;\n\tstruct o2net_sock_container *sc = NULL;\n\tstruct o2net_node *nn = o2net_nn_from_num(target_node);\n\tstruct o2net_status_wait nsw = {\n\t\t.ns_node_item = LIST_HEAD_INIT(nsw.ns_node_item),\n\t};\n\tstruct o2net_send_tracking nst;\n\n\to2net_init_nst(&nst, msg_type, key, current, target_node);\n\n\tif (o2net_wq == NULL) {\n\t\tmlog(0, \"attempt to tx without o2netd running\\n\");\n\t\tret = -ESRCH;\n\t\tgoto out;\n\t}\n\n\tif (caller_veclen == 0) {\n\t\tmlog(0, \"bad kvec array length\\n\");\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tcaller_bytes = iov_length((struct iovec *)caller_vec, caller_veclen);\n\tif (caller_bytes > O2NET_MAX_PAYLOAD_BYTES) {\n\t\tmlog(0, \"total payload len %zu too large\\n\", caller_bytes);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (target_node == o2nm_this_node()) {\n\t\tret = -ELOOP;\n\t\tgoto out;\n\t}\n\n\to2net_debug_add_nst(&nst);\n\n\to2net_set_nst_sock_time(&nst);\n\n\twait_event(nn->nn_sc_wq, o2net_tx_can_proceed(nn, &sc, &ret));\n\tif (ret)\n\t\tgoto out;\n\n\to2net_set_nst_sock_container(&nst, sc);\n\n\tveclen = caller_veclen + 1;\n\tvec = kmalloc(sizeof(struct kvec) * veclen, GFP_ATOMIC);\n\tif (vec == NULL) {\n\t\tmlog(0, \"failed to %zu element kvec!\\n\", veclen);\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tmsg = kmalloc(sizeof(struct o2net_msg), GFP_ATOMIC);\n\tif (!msg) {\n\t\tmlog(0, \"failed to allocate a o2net_msg!\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\to2net_init_msg(msg, caller_bytes, msg_type, key);\n\n\tvec[0].iov_len = sizeof(struct o2net_msg);\n\tvec[0].iov_base = msg;\n\tmemcpy(&vec[1], caller_vec, caller_veclen * sizeof(struct kvec));\n\n\tret = o2net_prep_nsw(nn, &nsw);\n\tif (ret)\n\t\tgoto out;\n\n\tmsg->msg_num = cpu_to_be32(nsw.ns_id);\n\to2net_set_nst_msg_id(&nst, nsw.ns_id);\n\n\to2net_set_nst_send_time(&nst);\n\n\t/* finally, convert the message header to network byte-order\n\t * and send */\n\tmutex_lock(&sc->sc_send_lock);\n\tret = o2net_send_tcp_msg(sc->sc_sock, vec, veclen,\n\t\t\t\t sizeof(struct o2net_msg) + caller_bytes);\n\tmutex_unlock(&sc->sc_send_lock);\n\tmsglog(msg, \"sending returned %d\\n\", ret);\n\tif (ret < 0) {\n\t\tmlog(0, \"error returned from o2net_send_tcp_msg=%d\\n\", ret);\n\t\tgoto out;\n\t}\n\n\t/* wait on other node's handler */\n\to2net_set_nst_status_time(&nst);\n\twait_event(nsw.ns_wq, o2net_nsw_completed(nn, &nsw));\n\n\to2net_update_send_stats(&nst, sc);\n\n\t/* Note that we avoid overwriting the callers status return\n\t * variable if a system error was reported on the other\n\t * side. Callers beware. */\n\tret = o2net_sys_err_to_errno(nsw.ns_sys_status);\n\tif (status && !ret)\n\t\t*status = nsw.ns_status;\n\n\tmlog(0, \"woken, returning system status %d, user status %d\\n\",\n\t     ret, nsw.ns_status);\nout:\n\to2net_debug_del_nst(&nst); /* must be before dropping sc and node */\n\tif (sc)\n\t\tsc_put(sc);\n\tkfree(vec);\n\tkfree(msg);\n\to2net_complete_nsw(nn, &nsw, 0, 0, 0);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_add_cpu",
          "args": [
            "&past.flags",
            "LKM_GET_LVB"
          ],
          "line": 475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "past.name",
            "res->lockname.name",
            "past.namelen"
          ],
          "line": 469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&past",
            "0",
            "sizeof(struct dlm_proxy_ast)"
          ],
          "line": 464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"%s: res %.*s, to %u, type %d, blocked_type %d\\n\"",
            "dlm->name",
            "res->lockname.len",
            "res->lockname.name",
            "lock->ml.node",
            "msg_type",
            "blocked_type"
          ],
          "line": 460
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_update_lvb(struct dlm_ctxt *dlm, struct dlm_lock_resource *res,\n\t\t\t   struct dlm_lock *lock);\nstatic int dlm_should_cancel_bast(struct dlm_ctxt *dlm, struct dlm_lock *lock);\n\nint dlm_send_proxy_ast_msg(struct dlm_ctxt *dlm, struct dlm_lock_resource *res,\n\t\t\t   struct dlm_lock *lock, int msg_type,\n\t\t\t   int blocked_type, int flags)\n{\n\tint ret = 0;\n\tstruct dlm_proxy_ast past;\n\tstruct kvec vec[2];\n\tsize_t veclen = 1;\n\tint status;\n\n\tmlog(0, \"%s: res %.*s, to %u, type %d, blocked_type %d\\n\", dlm->name,\n\t     res->lockname.len, res->lockname.name, lock->ml.node, msg_type,\n\t     blocked_type);\n\n\tmemset(&past, 0, sizeof(struct dlm_proxy_ast));\n\tpast.node_idx = dlm->node_num;\n\tpast.type = msg_type;\n\tpast.blocked_type = blocked_type;\n\tpast.namelen = res->lockname.len;\n\tmemcpy(past.name, res->lockname.name, past.namelen);\n\tpast.cookie = lock->ml.cookie;\n\n\tvec[0].iov_len = sizeof(struct dlm_proxy_ast);\n\tvec[0].iov_base = &past;\n\tif (flags & DLM_LKSB_GET_LVB) {\n\t\tbe32_add_cpu(&past.flags, LKM_GET_LVB);\n\t\tvec[1].iov_len = DLM_LVB_LEN;\n\t\tvec[1].iov_base = lock->lksb->lvb;\n\t\tveclen++;\n\t}\n\n\tret = o2net_send_message_vec(DLM_PROXY_AST_MSG, dlm->key, vec, veclen,\n\t\t\t\t     lock->ml.node, &status);\n\tif (ret < 0)\n\t\tmlog(ML_ERROR, \"%s: res %.*s, error %d send AST to node %u\\n\",\n\t\t     dlm->name, res->lockname.len, res->lockname.name, ret,\n\t\t     lock->ml.node);\n\telse {\n\t\tif (status == DLM_RECOVERING) {\n\t\t\tmlog(ML_ERROR, \"sent AST to node %u, it thinks this \"\n\t\t\t     \"node is dead!\\n\", lock->ml.node);\n\t\t\tBUG();\n\t\t} else if (status == DLM_MIGRATING) {\n\t\t\tmlog(ML_ERROR, \"sent AST to node %u, it returned \"\n\t\t\t     \"DLM_MIGRATING!\\n\", lock->ml.node);\n\t\t\tBUG();\n\t\t} else if (status != DLM_NORMAL && status != DLM_IVLOCKID) {\n\t\t\tmlog(ML_ERROR, \"AST to node %u returned %d!\\n\",\n\t\t\t     lock->ml.node, status);\n\t\t\t/* ignore it */\n\t\t}\n\t\tret = 0;\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "dlm_proxy_ast_handler",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmast.c",
    "lines": "285-446",
    "snippet": "int dlm_proxy_ast_handler(struct o2net_msg *msg, u32 len, void *data,\n\t\t\t  void **ret_data)\n{\n\tint ret;\n\tunsigned int locklen;\n\tstruct dlm_ctxt *dlm = data;\n\tstruct dlm_lock_resource *res = NULL;\n\tstruct dlm_lock *lock = NULL;\n\tstruct dlm_proxy_ast *past = (struct dlm_proxy_ast *) msg->buf;\n\tchar *name;\n\tstruct list_head *head = NULL;\n\t__be64 cookie;\n\tu32 flags;\n\tu8 node;\n\n\tif (!dlm_grab(dlm)) {\n\t\tdlm_error(DLM_REJECTED);\n\t\treturn DLM_REJECTED;\n\t}\n\n\tmlog_bug_on_msg(!dlm_domain_fully_joined(dlm),\n\t\t\t\"Domain %s not fully joined!\\n\", dlm->name);\n\n\tname = past->name;\n\tlocklen = past->namelen;\n\tcookie = past->cookie;\n\tflags = be32_to_cpu(past->flags);\n\tnode = past->node_idx;\n\n\tif (locklen > DLM_LOCKID_NAME_MAX) {\n\t\tret = DLM_IVBUFLEN;\n\t\tmlog(ML_ERROR, \"Invalid name length (%d) in proxy ast \"\n\t\t     \"handler!\\n\", locklen);\n\t\tgoto leave;\n\t}\n\n\tif ((flags & (LKM_PUT_LVB|LKM_GET_LVB)) ==\n\t     (LKM_PUT_LVB|LKM_GET_LVB)) {\n\t\tmlog(ML_ERROR, \"Both PUT and GET lvb specified, (0x%x)\\n\",\n\t\t     flags);\n\t\tret = DLM_BADARGS;\n\t\tgoto leave;\n\t}\n\n\tmlog(0, \"lvb: %s\\n\", flags & LKM_PUT_LVB ? \"put lvb\" :\n\t\t  (flags & LKM_GET_LVB ? \"get lvb\" : \"none\"));\n\n\tmlog(0, \"type=%d, blocked_type=%d\\n\", past->type, past->blocked_type);\n\n\tif (past->type != DLM_AST &&\n\t    past->type != DLM_BAST) {\n\t\tmlog(ML_ERROR, \"Unknown ast type! %d, cookie=%u:%llu\"\n\t\t     \"name=%.*s, node=%u\\n\", past->type,\n\t\t     dlm_get_lock_cookie_node(be64_to_cpu(cookie)),\n\t\t     dlm_get_lock_cookie_seq(be64_to_cpu(cookie)),\n\t\t     locklen, name, node);\n\t\tret = DLM_IVLOCKID;\n\t\tgoto leave;\n\t}\n\n\tres = dlm_lookup_lockres(dlm, name, locklen);\n\tif (!res) {\n\t\tmlog(0, \"Got %sast for unknown lockres! cookie=%u:%llu, \"\n\t\t     \"name=%.*s, node=%u\\n\", (past->type == DLM_AST ? \"\" : \"b\"),\n\t\t     dlm_get_lock_cookie_node(be64_to_cpu(cookie)),\n\t\t     dlm_get_lock_cookie_seq(be64_to_cpu(cookie)),\n\t\t     locklen, name, node);\n\t\tret = DLM_IVLOCKID;\n\t\tgoto leave;\n\t}\n\n\t/* cannot get a proxy ast message if this node owns it */\n\tBUG_ON(res->owner == dlm->node_num);\n\n\tmlog(0, \"%s: res %.*s\\n\", dlm->name, res->lockname.len,\n\t     res->lockname.name);\n\n\tspin_lock(&res->spinlock);\n\tif (res->state & DLM_LOCK_RES_RECOVERING) {\n\t\tmlog(0, \"Responding with DLM_RECOVERING!\\n\");\n\t\tret = DLM_RECOVERING;\n\t\tgoto unlock_out;\n\t}\n\tif (res->state & DLM_LOCK_RES_MIGRATING) {\n\t\tmlog(0, \"Responding with DLM_MIGRATING!\\n\");\n\t\tret = DLM_MIGRATING;\n\t\tgoto unlock_out;\n\t}\n\t/* try convert queue for both ast/bast */\n\thead = &res->converting;\n\tlock = NULL;\n\tlist_for_each_entry(lock, head, list) {\n\t\tif (lock->ml.cookie == cookie)\n\t\t\tgoto do_ast;\n\t}\n\n\t/* if not on convert, try blocked for ast, granted for bast */\n\tif (past->type == DLM_AST)\n\t\thead = &res->blocked;\n\telse\n\t\thead = &res->granted;\n\n\tlist_for_each_entry(lock, head, list) {\n\t\t/* if lock is found but unlock is pending ignore the bast */\n\t\tif (lock->ml.cookie == cookie) {\n\t\t\tif (lock->unlock_pending)\n\t\t\t\tbreak;\n\t\t\tgoto do_ast;\n\t\t}\n\t}\n\n\tmlog(0, \"Got %sast for unknown lock! cookie=%u:%llu, name=%.*s, \"\n\t     \"node=%u\\n\", past->type == DLM_AST ? \"\" : \"b\",\n\t     dlm_get_lock_cookie_node(be64_to_cpu(cookie)),\n\t     dlm_get_lock_cookie_seq(be64_to_cpu(cookie)),\n\t     locklen, name, node);\n\n\tret = DLM_NORMAL;\nunlock_out:\n\tspin_unlock(&res->spinlock);\n\tgoto leave;\n\ndo_ast:\n\tret = DLM_NORMAL;\n\tif (past->type == DLM_AST) {\n\t\t/* do not alter lock refcount.  switching lists. */\n\t\tlist_move_tail(&lock->list, &res->granted);\n\t\tmlog(0, \"%s: res %.*s, lock %u:%llu, Granted type %d => %d\\n\",\n\t\t     dlm->name, res->lockname.len, res->lockname.name,\n\t\t     dlm_get_lock_cookie_node(be64_to_cpu(cookie)),\n\t\t     dlm_get_lock_cookie_seq(be64_to_cpu(cookie)),\n\t\t     lock->ml.type, lock->ml.convert_type);\n\n\t\tif (lock->ml.convert_type != LKM_IVMODE) {\n\t\t\tlock->ml.type = lock->ml.convert_type;\n\t\t\tlock->ml.convert_type = LKM_IVMODE;\n\t\t} else {\n\t\t\t// should already be there....\n\t\t}\n\n\t\tlock->lksb->status = DLM_NORMAL;\n\n\t\t/* if we requested the lvb, fetch it into our lksb now */\n\t\tif (flags & LKM_GET_LVB) {\n\t\t\tBUG_ON(!(lock->lksb->flags & DLM_LKSB_GET_LVB));\n\t\t\tmemcpy(lock->lksb->lvb, past->lvb, DLM_LVB_LEN);\n\t\t}\n\t}\n\tspin_unlock(&res->spinlock);\n\n\tif (past->type == DLM_AST)\n\t\tdlm_do_local_ast(dlm, res, lock);\n\telse\n\t\tdlm_do_local_bast(dlm, res, lock, past->blocked_type);\n\nleave:\n\tif (res)\n\t\tdlm_lockres_put(res);\n\n\tdlm_put(dlm);\n\treturn ret;\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/spinlock.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/random.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void dlm_update_lvb(struct dlm_ctxt *dlm, struct dlm_lock_resource *res,\n\t\t\t   struct dlm_lock *lock);",
      "static int dlm_should_cancel_bast(struct dlm_ctxt *dlm, struct dlm_lock *lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dlm_put",
          "args": [
            "dlm"
          ],
          "line": 444
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_put_mle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
          "lines": "248-258",
          "snippet": "static void dlm_put_mle(struct dlm_master_list_entry *mle)\n{\n\tstruct dlm_ctxt *dlm;\n\tdlm = mle->dlm;\n\n\tspin_lock(&dlm->spinlock);\n\tspin_lock(&dlm->master_lock);\n\t__dlm_put_mle(mle);\n\tspin_unlock(&dlm->master_lock);\n\tspin_unlock(&dlm->spinlock);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_put_mle(struct dlm_master_list_entry *mle);",
            "static void __dlm_put_mle(struct dlm_master_list_entry *mle);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_put_mle(struct dlm_master_list_entry *mle);\nstatic void __dlm_put_mle(struct dlm_master_list_entry *mle);\n\nstatic void dlm_put_mle(struct dlm_master_list_entry *mle)\n{\n\tstruct dlm_ctxt *dlm;\n\tdlm = mle->dlm;\n\n\tspin_lock(&dlm->spinlock);\n\tspin_lock(&dlm->master_lock);\n\t__dlm_put_mle(mle);\n\tspin_unlock(&dlm->master_lock);\n\tspin_unlock(&dlm->spinlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_lockres_put",
          "args": [
            "res"
          ],
          "line": 442
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_lockres_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
          "lines": "550-553",
          "snippet": "void dlm_lockres_put(struct dlm_lock_resource *res)\n{\n\tkref_put(&res->refs, dlm_lockres_release);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);",
            "static void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);",
            "static int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);\nstatic void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);\nstatic int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);\n\nvoid dlm_lockres_put(struct dlm_lock_resource *res)\n{\n\tkref_put(&res->refs, dlm_lockres_release);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_do_local_bast",
          "args": [
            "dlm",
            "res",
            "lock",
            "past->blocked_type"
          ],
          "line": 438
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_do_local_bast",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmast.c",
          "lines": "267-281",
          "snippet": "void dlm_do_local_bast(struct dlm_ctxt *dlm, struct dlm_lock_resource *res,\n\t\t       struct dlm_lock *lock, int blocked_type)\n{\n\tdlm_bastlockfunc_t *fn = lock->bast;\n\n\tBUG_ON(lock->ml.node != dlm->node_num);\n\n\tmlog(0, \"%s: res %.*s, lock %u:%llu, Local BAST, blocked %d\\n\",\n\t     dlm->name, res->lockname.len, res->lockname.name,\n\t     dlm_get_lock_cookie_node(be64_to_cpu(lock->ml.cookie)),\n\t     dlm_get_lock_cookie_seq(be64_to_cpu(lock->ml.cookie)),\n\t     blocked_type);\n\n\t(*fn)(lock->astdata, blocked_type);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_update_lvb(struct dlm_ctxt *dlm, struct dlm_lock_resource *res,\n\t\t\t   struct dlm_lock *lock);",
            "static int dlm_should_cancel_bast(struct dlm_ctxt *dlm, struct dlm_lock *lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_update_lvb(struct dlm_ctxt *dlm, struct dlm_lock_resource *res,\n\t\t\t   struct dlm_lock *lock);\nstatic int dlm_should_cancel_bast(struct dlm_ctxt *dlm, struct dlm_lock *lock);\n\nvoid dlm_do_local_bast(struct dlm_ctxt *dlm, struct dlm_lock_resource *res,\n\t\t       struct dlm_lock *lock, int blocked_type)\n{\n\tdlm_bastlockfunc_t *fn = lock->bast;\n\n\tBUG_ON(lock->ml.node != dlm->node_num);\n\n\tmlog(0, \"%s: res %.*s, lock %u:%llu, Local BAST, blocked %d\\n\",\n\t     dlm->name, res->lockname.len, res->lockname.name,\n\t     dlm_get_lock_cookie_node(be64_to_cpu(lock->ml.cookie)),\n\t     dlm_get_lock_cookie_seq(be64_to_cpu(lock->ml.cookie)),\n\t     blocked_type);\n\n\t(*fn)(lock->astdata, blocked_type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_do_local_ast",
          "args": [
            "dlm",
            "res",
            "lock"
          ],
          "line": 436
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_do_local_ast",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmast.c",
          "lines": "223-240",
          "snippet": "void dlm_do_local_ast(struct dlm_ctxt *dlm, struct dlm_lock_resource *res,\n\t\t      struct dlm_lock *lock)\n{\n\tdlm_astlockfunc_t *fn;\n\tstruct dlm_lockstatus *lksb;\n\n\tmlog(0, \"%s: res %.*s, lock %u:%llu, Local AST\\n\", dlm->name,\n\t     res->lockname.len, res->lockname.name,\n\t     dlm_get_lock_cookie_node(be64_to_cpu(lock->ml.cookie)),\n\t     dlm_get_lock_cookie_seq(be64_to_cpu(lock->ml.cookie)));\n\n\tlksb = lock->lksb;\n\tfn = lock->ast;\n\tBUG_ON(lock->ml.node != dlm->node_num);\n\n\tdlm_update_lvb(dlm, res, lock);\n\t(*fn)(lock->astdata);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_update_lvb(struct dlm_ctxt *dlm, struct dlm_lock_resource *res,\n\t\t\t   struct dlm_lock *lock);",
            "static int dlm_should_cancel_bast(struct dlm_ctxt *dlm, struct dlm_lock *lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_update_lvb(struct dlm_ctxt *dlm, struct dlm_lock_resource *res,\n\t\t\t   struct dlm_lock *lock);\nstatic int dlm_should_cancel_bast(struct dlm_ctxt *dlm, struct dlm_lock *lock);\n\nvoid dlm_do_local_ast(struct dlm_ctxt *dlm, struct dlm_lock_resource *res,\n\t\t      struct dlm_lock *lock)\n{\n\tdlm_astlockfunc_t *fn;\n\tstruct dlm_lockstatus *lksb;\n\n\tmlog(0, \"%s: res %.*s, lock %u:%llu, Local AST\\n\", dlm->name,\n\t     res->lockname.len, res->lockname.name,\n\t     dlm_get_lock_cookie_node(be64_to_cpu(lock->ml.cookie)),\n\t     dlm_get_lock_cookie_seq(be64_to_cpu(lock->ml.cookie)));\n\n\tlksb = lock->lksb;\n\tfn = lock->ast;\n\tBUG_ON(lock->ml.node != dlm->node_num);\n\n\tdlm_update_lvb(dlm, res, lock);\n\t(*fn)(lock->astdata);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&res->spinlock"
          ],
          "line": 433
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "lock->lksb->lvb",
            "past->lvb",
            "DLM_LVB_LEN"
          ],
          "line": 430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!(lock->lksb->flags & DLM_LKSB_GET_LVB)"
          ],
          "line": 429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"%s: res %.*s, lock %u:%llu, Granted type %d => %d\\n\"",
            "dlm->name",
            "res->lockname.len",
            "res->lockname.name",
            "dlm_get_lock_cookie_node(be64_to_cpu(cookie))",
            "dlm_get_lock_cookie_seq(be64_to_cpu(cookie))",
            "lock->ml.type",
            "lock->ml.convert_type"
          ],
          "line": 412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_get_lock_cookie_seq",
          "args": [
            "be64_to_cpu(cookie)"
          ],
          "line": 415
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_get_lock_cookie_seq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmcommon.h",
          "lines": "821-826",
          "snippet": "static inline unsigned long long dlm_get_lock_cookie_seq(u64 cookie)\n{\n\tunsigned long long ret;\n\tret = ((unsigned long long)cookie) & 0x00ffffffffffffffULL;\n\treturn ret;\n}",
          "includes": [
            "#include <linux/kref.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kref.h>\n\nstatic inline unsigned long long dlm_get_lock_cookie_seq(u64 cookie)\n{\n\tunsigned long long ret;\n\tret = ((unsigned long long)cookie) & 0x00ffffffffffffffULL;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "cookie"
          ],
          "line": 415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_get_lock_cookie_node",
          "args": [
            "be64_to_cpu(cookie)"
          ],
          "line": 414
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_get_lock_cookie_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmcommon.h",
          "lines": "813-819",
          "snippet": "static inline u8 dlm_get_lock_cookie_node(u64 cookie)\n{\n\tu8 ret;\n\tcookie >>= 56;\n\tret = (u8)(cookie & 0xffULL);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/kref.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kref.h>\n\nstatic inline u8 dlm_get_lock_cookie_node(u64 cookie)\n{\n\tu8 ret;\n\tcookie >>= 56;\n\tret = (u8)(cookie & 0xffULL);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "cookie"
          ],
          "line": 414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_move_tail",
          "args": [
            "&lock->list",
            "&res->granted"
          ],
          "line": 411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"Got %sast for unknown lock! cookie=%u:%llu, name=%.*s, \"\n\t     \"node=%u\\n\"",
            "past->type == DLM_AST ? \"\" : \"b\"",
            "dlm_get_lock_cookie_node(be64_to_cpu(cookie))",
            "dlm_get_lock_cookie_seq(be64_to_cpu(cookie))",
            "locklen",
            "name",
            "node"
          ],
          "line": 396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "cookie"
          ],
          "line": 399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "cookie"
          ],
          "line": 398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "lock",
            "head",
            "list"
          ],
          "line": 387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "lock",
            "head",
            "list"
          ],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"Responding with DLM_MIGRATING!\\n\""
          ],
          "line": 369
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_mask_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "36-48",
          "snippet": "static ssize_t mlog_mask_show(u64 mask, char *buf)\n{\n\tchar *state;\n\n\tif (__mlog_test_u64(mask, mlog_and_bits))\n\t\tstate = \"allow\";\n\telse if (__mlog_test_u64(mask, mlog_not_bits))\n\t\tstate = \"deny\";\n\telse\n\t\tstate = \"off\";\n\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", state);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct mlog_bits mlog_and_bits = MLOG_BITS_RHS(MLOG_INITIAL_AND_MASK);",
            "struct mlog_bits mlog_not_bits = MLOG_BITS_RHS(0);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstruct mlog_bits mlog_and_bits = MLOG_BITS_RHS(MLOG_INITIAL_AND_MASK);\nstruct mlog_bits mlog_not_bits = MLOG_BITS_RHS(0);\n\nstatic ssize_t mlog_mask_show(u64 mask, char *buf)\n{\n\tchar *state;\n\n\tif (__mlog_test_u64(mask, mlog_and_bits))\n\t\tstate = \"allow\";\n\telse if (__mlog_test_u64(mask, mlog_not_bits))\n\t\tstate = \"deny\";\n\telse\n\t\tstate = \"off\";\n\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&res->spinlock"
          ],
          "line": 362
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"%s: res %.*s\\n\"",
            "dlm->name",
            "res->lockname.len",
            "res->lockname.name"
          ],
          "line": 359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "res->owner == dlm->node_num"
          ],
          "line": 357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"Got %sast for unknown lockres! cookie=%u:%llu, \"\n\t\t     \"name=%.*s, node=%u\\n\"",
            "(past->type == DLM_AST ? \"\" : \"b\")",
            "dlm_get_lock_cookie_node(be64_to_cpu(cookie))",
            "dlm_get_lock_cookie_seq(be64_to_cpu(cookie))",
            "locklen",
            "name",
            "node"
          ],
          "line": 347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "cookie"
          ],
          "line": 350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "cookie"
          ],
          "line": 349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_lookup_lockres",
          "args": [
            "dlm",
            "name",
            "locklen"
          ],
          "line": 345
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_lookup_lockres",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
          "lines": "246-257",
          "snippet": "struct dlm_lock_resource * dlm_lookup_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t    const char *name,\n\t\t\t\t    unsigned int len)\n{\n\tstruct dlm_lock_resource *res;\n\tunsigned int hash = dlm_lockid_hash(name, len);\n\n\tspin_lock(&dlm->spinlock);\n\tres = __dlm_lookup_lockres(dlm, name, len, hash);\n\tspin_unlock(&dlm->spinlock);\n\treturn res;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/debugfs.h>",
            "#include <linux/err.h>",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);\n\nstruct dlm_lock_resource * dlm_lookup_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t    const char *name,\n\t\t\t\t    unsigned int len)\n{\n\tstruct dlm_lock_resource *res;\n\tunsigned int hash = dlm_lockid_hash(name, len);\n\n\tspin_lock(&dlm->spinlock);\n\tres = __dlm_lookup_lockres(dlm, name, len, hash);\n\tspin_unlock(&dlm->spinlock);\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"Unknown ast type! %d, cookie=%u:%llu\"\n\t\t     \"name=%.*s, node=%u\\n\"",
            "past->type",
            "dlm_get_lock_cookie_node(be64_to_cpu(cookie))",
            "dlm_get_lock_cookie_seq(be64_to_cpu(cookie))",
            "locklen",
            "name",
            "node"
          ],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "cookie"
          ],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "cookie"
          ],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"type=%d, blocked_type=%d\\n\"",
            "past->type",
            "past->blocked_type"
          ],
          "line": 332
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_store",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "115-121",
          "snippet": "static ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"lvb: %s\\n\"",
            "flags & LKM_PUT_LVB ? \"put lvb\" :\n\t\t  (flags & LKM_GET_LVB ? \"get lvb\" : \"none\")"
          ],
          "line": 329
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "107-113",
          "snippet": "static ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "past->flags"
          ],
          "line": 311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_bug_on_msg",
          "args": [
            "!dlm_domain_fully_joined(dlm)",
            "\"Domain %s not fully joined!\\n\"",
            "dlm->name"
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_domain_fully_joined",
          "args": [
            "dlm"
          ],
          "line": 305
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_domain_fully_joined",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
          "lines": "380-390",
          "snippet": "int dlm_domain_fully_joined(struct dlm_ctxt *dlm)\n{\n\tint ret;\n\n\tspin_lock(&dlm_domain_lock);\n\tret = (dlm->dlm_state == DLM_CTXT_JOINED) ||\n\t\t(dlm->dlm_state == DLM_CTXT_IN_SHUTDOWN);\n\tspin_unlock(&dlm_domain_lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/debugfs.h>",
            "#include <linux/err.h>",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);\n\nint dlm_domain_fully_joined(struct dlm_ctxt *dlm)\n{\n\tint ret;\n\n\tspin_lock(&dlm_domain_lock);\n\tret = (dlm->dlm_state == DLM_CTXT_JOINED) ||\n\t\t(dlm->dlm_state == DLM_CTXT_IN_SHUTDOWN);\n\tspin_unlock(&dlm_domain_lock);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_error",
          "args": [
            "DLM_REJECTED"
          ],
          "line": 301
        },
        "resolved": true,
        "details": {
          "function_name": "user_recover_from_dlm_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmfs/userdlm.c",
          "lines": "99-104",
          "snippet": "static inline void user_recover_from_dlm_error(struct user_lock_res *lockres)\n{\n\tspin_lock(&lockres->l_lock);\n\tlockres->l_flags &= ~USER_LOCK_BUSY;\n\tspin_unlock(&lockres->l_lock);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"userdlm.h\"",
            "#include \"stackglue.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include <linux/crc32.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"userdlm.h\"\n#include \"stackglue.h\"\n#include \"ocfs2_lockingver.h\"\n#include <linux/crc32.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/signal.h>\n\nstatic inline void user_recover_from_dlm_error(struct user_lock_res *lockres)\n{\n\tspin_lock(&lockres->l_lock);\n\tlockres->l_flags &= ~USER_LOCK_BUSY;\n\tspin_unlock(&lockres->l_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_grab",
          "args": [
            "dlm"
          ],
          "line": 300
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_grab",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
          "lines": "360-378",
          "snippet": "struct dlm_ctxt *dlm_grab(struct dlm_ctxt *dlm)\n{\n\tstruct dlm_ctxt *target;\n\tstruct dlm_ctxt *ret = NULL;\n\n\tspin_lock(&dlm_domain_lock);\n\n\tlist_for_each_entry(target, &dlm_domains, list) {\n\t\tif (target == dlm) {\n\t\t\t__dlm_get(target);\n\t\t\tret = target;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tspin_unlock(&dlm_domain_lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/debugfs.h>",
            "#include <linux/err.h>",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);\n\nstruct dlm_ctxt *dlm_grab(struct dlm_ctxt *dlm)\n{\n\tstruct dlm_ctxt *target;\n\tstruct dlm_ctxt *ret = NULL;\n\n\tspin_lock(&dlm_domain_lock);\n\n\tlist_for_each_entry(target, &dlm_domains, list) {\n\t\tif (target == dlm) {\n\t\t\t__dlm_get(target);\n\t\t\tret = target;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tspin_unlock(&dlm_domain_lock);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_update_lvb(struct dlm_ctxt *dlm, struct dlm_lock_resource *res,\n\t\t\t   struct dlm_lock *lock);\nstatic int dlm_should_cancel_bast(struct dlm_ctxt *dlm, struct dlm_lock *lock);\n\nint dlm_proxy_ast_handler(struct o2net_msg *msg, u32 len, void *data,\n\t\t\t  void **ret_data)\n{\n\tint ret;\n\tunsigned int locklen;\n\tstruct dlm_ctxt *dlm = data;\n\tstruct dlm_lock_resource *res = NULL;\n\tstruct dlm_lock *lock = NULL;\n\tstruct dlm_proxy_ast *past = (struct dlm_proxy_ast *) msg->buf;\n\tchar *name;\n\tstruct list_head *head = NULL;\n\t__be64 cookie;\n\tu32 flags;\n\tu8 node;\n\n\tif (!dlm_grab(dlm)) {\n\t\tdlm_error(DLM_REJECTED);\n\t\treturn DLM_REJECTED;\n\t}\n\n\tmlog_bug_on_msg(!dlm_domain_fully_joined(dlm),\n\t\t\t\"Domain %s not fully joined!\\n\", dlm->name);\n\n\tname = past->name;\n\tlocklen = past->namelen;\n\tcookie = past->cookie;\n\tflags = be32_to_cpu(past->flags);\n\tnode = past->node_idx;\n\n\tif (locklen > DLM_LOCKID_NAME_MAX) {\n\t\tret = DLM_IVBUFLEN;\n\t\tmlog(ML_ERROR, \"Invalid name length (%d) in proxy ast \"\n\t\t     \"handler!\\n\", locklen);\n\t\tgoto leave;\n\t}\n\n\tif ((flags & (LKM_PUT_LVB|LKM_GET_LVB)) ==\n\t     (LKM_PUT_LVB|LKM_GET_LVB)) {\n\t\tmlog(ML_ERROR, \"Both PUT and GET lvb specified, (0x%x)\\n\",\n\t\t     flags);\n\t\tret = DLM_BADARGS;\n\t\tgoto leave;\n\t}\n\n\tmlog(0, \"lvb: %s\\n\", flags & LKM_PUT_LVB ? \"put lvb\" :\n\t\t  (flags & LKM_GET_LVB ? \"get lvb\" : \"none\"));\n\n\tmlog(0, \"type=%d, blocked_type=%d\\n\", past->type, past->blocked_type);\n\n\tif (past->type != DLM_AST &&\n\t    past->type != DLM_BAST) {\n\t\tmlog(ML_ERROR, \"Unknown ast type! %d, cookie=%u:%llu\"\n\t\t     \"name=%.*s, node=%u\\n\", past->type,\n\t\t     dlm_get_lock_cookie_node(be64_to_cpu(cookie)),\n\t\t     dlm_get_lock_cookie_seq(be64_to_cpu(cookie)),\n\t\t     locklen, name, node);\n\t\tret = DLM_IVLOCKID;\n\t\tgoto leave;\n\t}\n\n\tres = dlm_lookup_lockres(dlm, name, locklen);\n\tif (!res) {\n\t\tmlog(0, \"Got %sast for unknown lockres! cookie=%u:%llu, \"\n\t\t     \"name=%.*s, node=%u\\n\", (past->type == DLM_AST ? \"\" : \"b\"),\n\t\t     dlm_get_lock_cookie_node(be64_to_cpu(cookie)),\n\t\t     dlm_get_lock_cookie_seq(be64_to_cpu(cookie)),\n\t\t     locklen, name, node);\n\t\tret = DLM_IVLOCKID;\n\t\tgoto leave;\n\t}\n\n\t/* cannot get a proxy ast message if this node owns it */\n\tBUG_ON(res->owner == dlm->node_num);\n\n\tmlog(0, \"%s: res %.*s\\n\", dlm->name, res->lockname.len,\n\t     res->lockname.name);\n\n\tspin_lock(&res->spinlock);\n\tif (res->state & DLM_LOCK_RES_RECOVERING) {\n\t\tmlog(0, \"Responding with DLM_RECOVERING!\\n\");\n\t\tret = DLM_RECOVERING;\n\t\tgoto unlock_out;\n\t}\n\tif (res->state & DLM_LOCK_RES_MIGRATING) {\n\t\tmlog(0, \"Responding with DLM_MIGRATING!\\n\");\n\t\tret = DLM_MIGRATING;\n\t\tgoto unlock_out;\n\t}\n\t/* try convert queue for both ast/bast */\n\thead = &res->converting;\n\tlock = NULL;\n\tlist_for_each_entry(lock, head, list) {\n\t\tif (lock->ml.cookie == cookie)\n\t\t\tgoto do_ast;\n\t}\n\n\t/* if not on convert, try blocked for ast, granted for bast */\n\tif (past->type == DLM_AST)\n\t\thead = &res->blocked;\n\telse\n\t\thead = &res->granted;\n\n\tlist_for_each_entry(lock, head, list) {\n\t\t/* if lock is found but unlock is pending ignore the bast */\n\t\tif (lock->ml.cookie == cookie) {\n\t\t\tif (lock->unlock_pending)\n\t\t\t\tbreak;\n\t\t\tgoto do_ast;\n\t\t}\n\t}\n\n\tmlog(0, \"Got %sast for unknown lock! cookie=%u:%llu, name=%.*s, \"\n\t     \"node=%u\\n\", past->type == DLM_AST ? \"\" : \"b\",\n\t     dlm_get_lock_cookie_node(be64_to_cpu(cookie)),\n\t     dlm_get_lock_cookie_seq(be64_to_cpu(cookie)),\n\t     locklen, name, node);\n\n\tret = DLM_NORMAL;\nunlock_out:\n\tspin_unlock(&res->spinlock);\n\tgoto leave;\n\ndo_ast:\n\tret = DLM_NORMAL;\n\tif (past->type == DLM_AST) {\n\t\t/* do not alter lock refcount.  switching lists. */\n\t\tlist_move_tail(&lock->list, &res->granted);\n\t\tmlog(0, \"%s: res %.*s, lock %u:%llu, Granted type %d => %d\\n\",\n\t\t     dlm->name, res->lockname.len, res->lockname.name,\n\t\t     dlm_get_lock_cookie_node(be64_to_cpu(cookie)),\n\t\t     dlm_get_lock_cookie_seq(be64_to_cpu(cookie)),\n\t\t     lock->ml.type, lock->ml.convert_type);\n\n\t\tif (lock->ml.convert_type != LKM_IVMODE) {\n\t\t\tlock->ml.type = lock->ml.convert_type;\n\t\t\tlock->ml.convert_type = LKM_IVMODE;\n\t\t} else {\n\t\t\t// should already be there....\n\t\t}\n\n\t\tlock->lksb->status = DLM_NORMAL;\n\n\t\t/* if we requested the lvb, fetch it into our lksb now */\n\t\tif (flags & LKM_GET_LVB) {\n\t\t\tBUG_ON(!(lock->lksb->flags & DLM_LKSB_GET_LVB));\n\t\t\tmemcpy(lock->lksb->lvb, past->lvb, DLM_LVB_LEN);\n\t\t}\n\t}\n\tspin_unlock(&res->spinlock);\n\n\tif (past->type == DLM_AST)\n\t\tdlm_do_local_ast(dlm, res, lock);\n\telse\n\t\tdlm_do_local_bast(dlm, res, lock, past->blocked_type);\n\nleave:\n\tif (res)\n\t\tdlm_lockres_put(res);\n\n\tdlm_put(dlm);\n\treturn ret;\n}"
  },
  {
    "function_name": "dlm_do_local_bast",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmast.c",
    "lines": "267-281",
    "snippet": "void dlm_do_local_bast(struct dlm_ctxt *dlm, struct dlm_lock_resource *res,\n\t\t       struct dlm_lock *lock, int blocked_type)\n{\n\tdlm_bastlockfunc_t *fn = lock->bast;\n\n\tBUG_ON(lock->ml.node != dlm->node_num);\n\n\tmlog(0, \"%s: res %.*s, lock %u:%llu, Local BAST, blocked %d\\n\",\n\t     dlm->name, res->lockname.len, res->lockname.name,\n\t     dlm_get_lock_cookie_node(be64_to_cpu(lock->ml.cookie)),\n\t     dlm_get_lock_cookie_seq(be64_to_cpu(lock->ml.cookie)),\n\t     blocked_type);\n\n\t(*fn)(lock->astdata, blocked_type);\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/spinlock.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/random.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void dlm_update_lvb(struct dlm_ctxt *dlm, struct dlm_lock_resource *res,\n\t\t\t   struct dlm_lock *lock);",
      "static int dlm_should_cancel_bast(struct dlm_ctxt *dlm, struct dlm_lock *lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "",
          "args": [
            "lock->astdata",
            "blocked_type"
          ],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"%s: res %.*s, lock %u:%llu, Local BAST, blocked %d\\n\"",
            "dlm->name",
            "res->lockname.len",
            "res->lockname.name",
            "dlm_get_lock_cookie_node(be64_to_cpu(lock->ml.cookie))",
            "dlm_get_lock_cookie_seq(be64_to_cpu(lock->ml.cookie))",
            "blocked_type"
          ],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_get_lock_cookie_seq",
          "args": [
            "be64_to_cpu(lock->ml.cookie)"
          ],
          "line": 277
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_get_lock_cookie_seq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmcommon.h",
          "lines": "821-826",
          "snippet": "static inline unsigned long long dlm_get_lock_cookie_seq(u64 cookie)\n{\n\tunsigned long long ret;\n\tret = ((unsigned long long)cookie) & 0x00ffffffffffffffULL;\n\treturn ret;\n}",
          "includes": [
            "#include <linux/kref.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kref.h>\n\nstatic inline unsigned long long dlm_get_lock_cookie_seq(u64 cookie)\n{\n\tunsigned long long ret;\n\tret = ((unsigned long long)cookie) & 0x00ffffffffffffffULL;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "lock->ml.cookie"
          ],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_get_lock_cookie_node",
          "args": [
            "be64_to_cpu(lock->ml.cookie)"
          ],
          "line": 276
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_get_lock_cookie_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmcommon.h",
          "lines": "813-819",
          "snippet": "static inline u8 dlm_get_lock_cookie_node(u64 cookie)\n{\n\tu8 ret;\n\tcookie >>= 56;\n\tret = (u8)(cookie & 0xffULL);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/kref.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kref.h>\n\nstatic inline u8 dlm_get_lock_cookie_node(u64 cookie)\n{\n\tu8 ret;\n\tcookie >>= 56;\n\tret = (u8)(cookie & 0xffULL);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "lock->ml.cookie"
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "lock->ml.node != dlm->node_num"
          ],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_update_lvb(struct dlm_ctxt *dlm, struct dlm_lock_resource *res,\n\t\t\t   struct dlm_lock *lock);\nstatic int dlm_should_cancel_bast(struct dlm_ctxt *dlm, struct dlm_lock *lock);\n\nvoid dlm_do_local_bast(struct dlm_ctxt *dlm, struct dlm_lock_resource *res,\n\t\t       struct dlm_lock *lock, int blocked_type)\n{\n\tdlm_bastlockfunc_t *fn = lock->bast;\n\n\tBUG_ON(lock->ml.node != dlm->node_num);\n\n\tmlog(0, \"%s: res %.*s, lock %u:%llu, Local BAST, blocked %d\\n\",\n\t     dlm->name, res->lockname.len, res->lockname.name,\n\t     dlm_get_lock_cookie_node(be64_to_cpu(lock->ml.cookie)),\n\t     dlm_get_lock_cookie_seq(be64_to_cpu(lock->ml.cookie)),\n\t     blocked_type);\n\n\t(*fn)(lock->astdata, blocked_type);\n}"
  },
  {
    "function_name": "dlm_do_remote_ast",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmast.c",
    "lines": "243-265",
    "snippet": "int dlm_do_remote_ast(struct dlm_ctxt *dlm, struct dlm_lock_resource *res,\n\t\t      struct dlm_lock *lock)\n{\n\tint ret;\n\tstruct dlm_lockstatus *lksb;\n\tint lksbflags;\n\n\tmlog(0, \"%s: res %.*s, lock %u:%llu, Remote AST\\n\", dlm->name,\n\t     res->lockname.len, res->lockname.name,\n\t     dlm_get_lock_cookie_node(be64_to_cpu(lock->ml.cookie)),\n\t     dlm_get_lock_cookie_seq(be64_to_cpu(lock->ml.cookie)));\n\n\tlksb = lock->lksb;\n\tBUG_ON(lock->ml.node == dlm->node_num);\n\n\tlksbflags = lksb->flags;\n\tdlm_update_lvb(dlm, res, lock);\n\n\t/* lock request came from another node\n\t * go do the ast over there */\n\tret = dlm_send_proxy_ast(dlm, res, lock, lksbflags);\n\treturn ret;\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/spinlock.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/random.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void dlm_update_lvb(struct dlm_ctxt *dlm, struct dlm_lock_resource *res,\n\t\t\t   struct dlm_lock *lock);",
      "static int dlm_should_cancel_bast(struct dlm_ctxt *dlm, struct dlm_lock *lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dlm_send_proxy_ast",
          "args": [
            "dlm",
            "res",
            "lock",
            "lksbflags"
          ],
          "line": 263
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_send_proxy_ast",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmcommon.h",
          "lines": "945-952",
          "snippet": "static inline int dlm_send_proxy_ast(struct dlm_ctxt *dlm,\n\t\t\t\t     struct dlm_lock_resource *res,\n\t\t\t\t     struct dlm_lock *lock,\n\t\t\t\t     int flags)\n{\n\treturn dlm_send_proxy_ast_msg(dlm, res, lock, DLM_AST,\n\t\t\t\t      0, flags);\n}",
          "includes": [
            "#include <linux/kref.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kref.h>\n\nstatic inline int dlm_send_proxy_ast(struct dlm_ctxt *dlm,\n\t\t\t\t     struct dlm_lock_resource *res,\n\t\t\t\t     struct dlm_lock *lock,\n\t\t\t\t     int flags)\n{\n\treturn dlm_send_proxy_ast_msg(dlm, res, lock, DLM_AST,\n\t\t\t\t      0, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_update_lvb",
          "args": [
            "dlm",
            "res",
            "lock"
          ],
          "line": 259
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_update_lvb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmast.c",
          "lines": "193-221",
          "snippet": "static void dlm_update_lvb(struct dlm_ctxt *dlm, struct dlm_lock_resource *res,\n\t\t\t   struct dlm_lock *lock)\n{\n\tstruct dlm_lockstatus *lksb = lock->lksb;\n\tBUG_ON(!lksb);\n\n\t/* only updates if this node masters the lockres */\n\tspin_lock(&res->spinlock);\n\tif (res->owner == dlm->node_num) {\n\t\t/* check the lksb flags for the direction */\n\t\tif (lksb->flags & DLM_LKSB_GET_LVB) {\n\t\t\tmlog(0, \"getting lvb from lockres for %s node\\n\",\n\t\t\t\t  lock->ml.node == dlm->node_num ? \"master\" :\n\t\t\t\t  \"remote\");\n\t\t\tmemcpy(lksb->lvb, res->lvb, DLM_LVB_LEN);\n\t\t}\n\t\t/* Do nothing for lvb put requests - they should be done in\n \t\t * place when the lock is downconverted - otherwise we risk\n \t\t * racing gets and puts which could result in old lvb data\n \t\t * being propagated. We leave the put flag set and clear it\n \t\t * here. In the future we might want to clear it at the time\n \t\t * the put is actually done.\n\t\t */\n\t}\n\tspin_unlock(&res->spinlock);\n\n\t/* reset any lvb flags on the lksb */\n\tlksb->flags &= ~(DLM_LKSB_PUT_LVB|DLM_LKSB_GET_LVB);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_update_lvb(struct dlm_ctxt *dlm, struct dlm_lock_resource *res,\n\t\t\t   struct dlm_lock *lock);",
            "static int dlm_should_cancel_bast(struct dlm_ctxt *dlm, struct dlm_lock *lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_update_lvb(struct dlm_ctxt *dlm, struct dlm_lock_resource *res,\n\t\t\t   struct dlm_lock *lock);\nstatic int dlm_should_cancel_bast(struct dlm_ctxt *dlm, struct dlm_lock *lock);\n\nstatic void dlm_update_lvb(struct dlm_ctxt *dlm, struct dlm_lock_resource *res,\n\t\t\t   struct dlm_lock *lock)\n{\n\tstruct dlm_lockstatus *lksb = lock->lksb;\n\tBUG_ON(!lksb);\n\n\t/* only updates if this node masters the lockres */\n\tspin_lock(&res->spinlock);\n\tif (res->owner == dlm->node_num) {\n\t\t/* check the lksb flags for the direction */\n\t\tif (lksb->flags & DLM_LKSB_GET_LVB) {\n\t\t\tmlog(0, \"getting lvb from lockres for %s node\\n\",\n\t\t\t\t  lock->ml.node == dlm->node_num ? \"master\" :\n\t\t\t\t  \"remote\");\n\t\t\tmemcpy(lksb->lvb, res->lvb, DLM_LVB_LEN);\n\t\t}\n\t\t/* Do nothing for lvb put requests - they should be done in\n \t\t * place when the lock is downconverted - otherwise we risk\n \t\t * racing gets and puts which could result in old lvb data\n \t\t * being propagated. We leave the put flag set and clear it\n \t\t * here. In the future we might want to clear it at the time\n \t\t * the put is actually done.\n\t\t */\n\t}\n\tspin_unlock(&res->spinlock);\n\n\t/* reset any lvb flags on the lksb */\n\tlksb->flags &= ~(DLM_LKSB_PUT_LVB|DLM_LKSB_GET_LVB);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "lock->ml.node == dlm->node_num"
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"%s: res %.*s, lock %u:%llu, Remote AST\\n\"",
            "dlm->name",
            "res->lockname.len",
            "res->lockname.name",
            "dlm_get_lock_cookie_node(be64_to_cpu(lock->ml.cookie))",
            "dlm_get_lock_cookie_seq(be64_to_cpu(lock->ml.cookie))"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_get_lock_cookie_seq",
          "args": [
            "be64_to_cpu(lock->ml.cookie)"
          ],
          "line": 253
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_get_lock_cookie_seq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmcommon.h",
          "lines": "821-826",
          "snippet": "static inline unsigned long long dlm_get_lock_cookie_seq(u64 cookie)\n{\n\tunsigned long long ret;\n\tret = ((unsigned long long)cookie) & 0x00ffffffffffffffULL;\n\treturn ret;\n}",
          "includes": [
            "#include <linux/kref.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kref.h>\n\nstatic inline unsigned long long dlm_get_lock_cookie_seq(u64 cookie)\n{\n\tunsigned long long ret;\n\tret = ((unsigned long long)cookie) & 0x00ffffffffffffffULL;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "lock->ml.cookie"
          ],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_get_lock_cookie_node",
          "args": [
            "be64_to_cpu(lock->ml.cookie)"
          ],
          "line": 252
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_get_lock_cookie_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmcommon.h",
          "lines": "813-819",
          "snippet": "static inline u8 dlm_get_lock_cookie_node(u64 cookie)\n{\n\tu8 ret;\n\tcookie >>= 56;\n\tret = (u8)(cookie & 0xffULL);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/kref.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kref.h>\n\nstatic inline u8 dlm_get_lock_cookie_node(u64 cookie)\n{\n\tu8 ret;\n\tcookie >>= 56;\n\tret = (u8)(cookie & 0xffULL);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "lock->ml.cookie"
          ],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_update_lvb(struct dlm_ctxt *dlm, struct dlm_lock_resource *res,\n\t\t\t   struct dlm_lock *lock);\nstatic int dlm_should_cancel_bast(struct dlm_ctxt *dlm, struct dlm_lock *lock);\n\nint dlm_do_remote_ast(struct dlm_ctxt *dlm, struct dlm_lock_resource *res,\n\t\t      struct dlm_lock *lock)\n{\n\tint ret;\n\tstruct dlm_lockstatus *lksb;\n\tint lksbflags;\n\n\tmlog(0, \"%s: res %.*s, lock %u:%llu, Remote AST\\n\", dlm->name,\n\t     res->lockname.len, res->lockname.name,\n\t     dlm_get_lock_cookie_node(be64_to_cpu(lock->ml.cookie)),\n\t     dlm_get_lock_cookie_seq(be64_to_cpu(lock->ml.cookie)));\n\n\tlksb = lock->lksb;\n\tBUG_ON(lock->ml.node == dlm->node_num);\n\n\tlksbflags = lksb->flags;\n\tdlm_update_lvb(dlm, res, lock);\n\n\t/* lock request came from another node\n\t * go do the ast over there */\n\tret = dlm_send_proxy_ast(dlm, res, lock, lksbflags);\n\treturn ret;\n}"
  },
  {
    "function_name": "dlm_do_local_ast",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmast.c",
    "lines": "223-240",
    "snippet": "void dlm_do_local_ast(struct dlm_ctxt *dlm, struct dlm_lock_resource *res,\n\t\t      struct dlm_lock *lock)\n{\n\tdlm_astlockfunc_t *fn;\n\tstruct dlm_lockstatus *lksb;\n\n\tmlog(0, \"%s: res %.*s, lock %u:%llu, Local AST\\n\", dlm->name,\n\t     res->lockname.len, res->lockname.name,\n\t     dlm_get_lock_cookie_node(be64_to_cpu(lock->ml.cookie)),\n\t     dlm_get_lock_cookie_seq(be64_to_cpu(lock->ml.cookie)));\n\n\tlksb = lock->lksb;\n\tfn = lock->ast;\n\tBUG_ON(lock->ml.node != dlm->node_num);\n\n\tdlm_update_lvb(dlm, res, lock);\n\t(*fn)(lock->astdata);\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/spinlock.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/random.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void dlm_update_lvb(struct dlm_ctxt *dlm, struct dlm_lock_resource *res,\n\t\t\t   struct dlm_lock *lock);",
      "static int dlm_should_cancel_bast(struct dlm_ctxt *dlm, struct dlm_lock *lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "",
          "args": [
            "lock->astdata"
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_update_lvb",
          "args": [
            "dlm",
            "res",
            "lock"
          ],
          "line": 238
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_update_lvb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmast.c",
          "lines": "193-221",
          "snippet": "static void dlm_update_lvb(struct dlm_ctxt *dlm, struct dlm_lock_resource *res,\n\t\t\t   struct dlm_lock *lock)\n{\n\tstruct dlm_lockstatus *lksb = lock->lksb;\n\tBUG_ON(!lksb);\n\n\t/* only updates if this node masters the lockres */\n\tspin_lock(&res->spinlock);\n\tif (res->owner == dlm->node_num) {\n\t\t/* check the lksb flags for the direction */\n\t\tif (lksb->flags & DLM_LKSB_GET_LVB) {\n\t\t\tmlog(0, \"getting lvb from lockres for %s node\\n\",\n\t\t\t\t  lock->ml.node == dlm->node_num ? \"master\" :\n\t\t\t\t  \"remote\");\n\t\t\tmemcpy(lksb->lvb, res->lvb, DLM_LVB_LEN);\n\t\t}\n\t\t/* Do nothing for lvb put requests - they should be done in\n \t\t * place when the lock is downconverted - otherwise we risk\n \t\t * racing gets and puts which could result in old lvb data\n \t\t * being propagated. We leave the put flag set and clear it\n \t\t * here. In the future we might want to clear it at the time\n \t\t * the put is actually done.\n\t\t */\n\t}\n\tspin_unlock(&res->spinlock);\n\n\t/* reset any lvb flags on the lksb */\n\tlksb->flags &= ~(DLM_LKSB_PUT_LVB|DLM_LKSB_GET_LVB);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_update_lvb(struct dlm_ctxt *dlm, struct dlm_lock_resource *res,\n\t\t\t   struct dlm_lock *lock);",
            "static int dlm_should_cancel_bast(struct dlm_ctxt *dlm, struct dlm_lock *lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_update_lvb(struct dlm_ctxt *dlm, struct dlm_lock_resource *res,\n\t\t\t   struct dlm_lock *lock);\nstatic int dlm_should_cancel_bast(struct dlm_ctxt *dlm, struct dlm_lock *lock);\n\nstatic void dlm_update_lvb(struct dlm_ctxt *dlm, struct dlm_lock_resource *res,\n\t\t\t   struct dlm_lock *lock)\n{\n\tstruct dlm_lockstatus *lksb = lock->lksb;\n\tBUG_ON(!lksb);\n\n\t/* only updates if this node masters the lockres */\n\tspin_lock(&res->spinlock);\n\tif (res->owner == dlm->node_num) {\n\t\t/* check the lksb flags for the direction */\n\t\tif (lksb->flags & DLM_LKSB_GET_LVB) {\n\t\t\tmlog(0, \"getting lvb from lockres for %s node\\n\",\n\t\t\t\t  lock->ml.node == dlm->node_num ? \"master\" :\n\t\t\t\t  \"remote\");\n\t\t\tmemcpy(lksb->lvb, res->lvb, DLM_LVB_LEN);\n\t\t}\n\t\t/* Do nothing for lvb put requests - they should be done in\n \t\t * place when the lock is downconverted - otherwise we risk\n \t\t * racing gets and puts which could result in old lvb data\n \t\t * being propagated. We leave the put flag set and clear it\n \t\t * here. In the future we might want to clear it at the time\n \t\t * the put is actually done.\n\t\t */\n\t}\n\tspin_unlock(&res->spinlock);\n\n\t/* reset any lvb flags on the lksb */\n\tlksb->flags &= ~(DLM_LKSB_PUT_LVB|DLM_LKSB_GET_LVB);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "lock->ml.node != dlm->node_num"
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"%s: res %.*s, lock %u:%llu, Local AST\\n\"",
            "dlm->name",
            "res->lockname.len",
            "res->lockname.name",
            "dlm_get_lock_cookie_node(be64_to_cpu(lock->ml.cookie))",
            "dlm_get_lock_cookie_seq(be64_to_cpu(lock->ml.cookie))"
          ],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_get_lock_cookie_seq",
          "args": [
            "be64_to_cpu(lock->ml.cookie)"
          ],
          "line": 232
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_get_lock_cookie_seq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmcommon.h",
          "lines": "821-826",
          "snippet": "static inline unsigned long long dlm_get_lock_cookie_seq(u64 cookie)\n{\n\tunsigned long long ret;\n\tret = ((unsigned long long)cookie) & 0x00ffffffffffffffULL;\n\treturn ret;\n}",
          "includes": [
            "#include <linux/kref.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kref.h>\n\nstatic inline unsigned long long dlm_get_lock_cookie_seq(u64 cookie)\n{\n\tunsigned long long ret;\n\tret = ((unsigned long long)cookie) & 0x00ffffffffffffffULL;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "lock->ml.cookie"
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_get_lock_cookie_node",
          "args": [
            "be64_to_cpu(lock->ml.cookie)"
          ],
          "line": 231
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_get_lock_cookie_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmcommon.h",
          "lines": "813-819",
          "snippet": "static inline u8 dlm_get_lock_cookie_node(u64 cookie)\n{\n\tu8 ret;\n\tcookie >>= 56;\n\tret = (u8)(cookie & 0xffULL);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/kref.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kref.h>\n\nstatic inline u8 dlm_get_lock_cookie_node(u64 cookie)\n{\n\tu8 ret;\n\tcookie >>= 56;\n\tret = (u8)(cookie & 0xffULL);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "lock->ml.cookie"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_update_lvb(struct dlm_ctxt *dlm, struct dlm_lock_resource *res,\n\t\t\t   struct dlm_lock *lock);\nstatic int dlm_should_cancel_bast(struct dlm_ctxt *dlm, struct dlm_lock *lock);\n\nvoid dlm_do_local_ast(struct dlm_ctxt *dlm, struct dlm_lock_resource *res,\n\t\t      struct dlm_lock *lock)\n{\n\tdlm_astlockfunc_t *fn;\n\tstruct dlm_lockstatus *lksb;\n\n\tmlog(0, \"%s: res %.*s, lock %u:%llu, Local AST\\n\", dlm->name,\n\t     res->lockname.len, res->lockname.name,\n\t     dlm_get_lock_cookie_node(be64_to_cpu(lock->ml.cookie)),\n\t     dlm_get_lock_cookie_seq(be64_to_cpu(lock->ml.cookie)));\n\n\tlksb = lock->lksb;\n\tfn = lock->ast;\n\tBUG_ON(lock->ml.node != dlm->node_num);\n\n\tdlm_update_lvb(dlm, res, lock);\n\t(*fn)(lock->astdata);\n}"
  },
  {
    "function_name": "dlm_update_lvb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmast.c",
    "lines": "193-221",
    "snippet": "static void dlm_update_lvb(struct dlm_ctxt *dlm, struct dlm_lock_resource *res,\n\t\t\t   struct dlm_lock *lock)\n{\n\tstruct dlm_lockstatus *lksb = lock->lksb;\n\tBUG_ON(!lksb);\n\n\t/* only updates if this node masters the lockres */\n\tspin_lock(&res->spinlock);\n\tif (res->owner == dlm->node_num) {\n\t\t/* check the lksb flags for the direction */\n\t\tif (lksb->flags & DLM_LKSB_GET_LVB) {\n\t\t\tmlog(0, \"getting lvb from lockres for %s node\\n\",\n\t\t\t\t  lock->ml.node == dlm->node_num ? \"master\" :\n\t\t\t\t  \"remote\");\n\t\t\tmemcpy(lksb->lvb, res->lvb, DLM_LVB_LEN);\n\t\t}\n\t\t/* Do nothing for lvb put requests - they should be done in\n \t\t * place when the lock is downconverted - otherwise we risk\n \t\t * racing gets and puts which could result in old lvb data\n \t\t * being propagated. We leave the put flag set and clear it\n \t\t * here. In the future we might want to clear it at the time\n \t\t * the put is actually done.\n\t\t */\n\t}\n\tspin_unlock(&res->spinlock);\n\n\t/* reset any lvb flags on the lksb */\n\tlksb->flags &= ~(DLM_LKSB_PUT_LVB|DLM_LKSB_GET_LVB);\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/spinlock.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/random.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void dlm_update_lvb(struct dlm_ctxt *dlm, struct dlm_lock_resource *res,\n\t\t\t   struct dlm_lock *lock);",
      "static int dlm_should_cancel_bast(struct dlm_ctxt *dlm, struct dlm_lock *lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&res->spinlock"
          ],
          "line": 217
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "lksb->lvb",
            "res->lvb",
            "DLM_LVB_LEN"
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"getting lvb from lockres for %s node\\n\"",
            "lock->ml.node == dlm->node_num ? \"master\" :\n\t\t\t\t  \"remote\""
          ],
          "line": 204
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "107-113",
          "snippet": "static ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&res->spinlock"
          ],
          "line": 200
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!lksb"
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_update_lvb(struct dlm_ctxt *dlm, struct dlm_lock_resource *res,\n\t\t\t   struct dlm_lock *lock);\nstatic int dlm_should_cancel_bast(struct dlm_ctxt *dlm, struct dlm_lock *lock);\n\nstatic void dlm_update_lvb(struct dlm_ctxt *dlm, struct dlm_lock_resource *res,\n\t\t\t   struct dlm_lock *lock)\n{\n\tstruct dlm_lockstatus *lksb = lock->lksb;\n\tBUG_ON(!lksb);\n\n\t/* only updates if this node masters the lockres */\n\tspin_lock(&res->spinlock);\n\tif (res->owner == dlm->node_num) {\n\t\t/* check the lksb flags for the direction */\n\t\tif (lksb->flags & DLM_LKSB_GET_LVB) {\n\t\t\tmlog(0, \"getting lvb from lockres for %s node\\n\",\n\t\t\t\t  lock->ml.node == dlm->node_num ? \"master\" :\n\t\t\t\t  \"remote\");\n\t\t\tmemcpy(lksb->lvb, res->lvb, DLM_LVB_LEN);\n\t\t}\n\t\t/* Do nothing for lvb put requests - they should be done in\n \t\t * place when the lock is downconverted - otherwise we risk\n \t\t * racing gets and puts which could result in old lvb data\n \t\t * being propagated. We leave the put flag set and clear it\n \t\t * here. In the future we might want to clear it at the time\n \t\t * the put is actually done.\n\t\t */\n\t}\n\tspin_unlock(&res->spinlock);\n\n\t/* reset any lvb flags on the lksb */\n\tlksb->flags &= ~(DLM_LKSB_PUT_LVB|DLM_LKSB_GET_LVB);\n}"
  },
  {
    "function_name": "dlm_queue_bast",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmast.c",
    "lines": "183-191",
    "snippet": "void dlm_queue_bast(struct dlm_ctxt *dlm, struct dlm_lock *lock)\n{\n\tBUG_ON(!dlm);\n\tBUG_ON(!lock);\n\n\tspin_lock(&dlm->ast_lock);\n\t__dlm_queue_bast(dlm, lock);\n\tspin_unlock(&dlm->ast_lock);\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/spinlock.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/random.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void dlm_update_lvb(struct dlm_ctxt *dlm, struct dlm_lock_resource *res,\n\t\t\t   struct dlm_lock *lock);",
      "static int dlm_should_cancel_bast(struct dlm_ctxt *dlm, struct dlm_lock *lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&dlm->ast_lock"
          ],
          "line": 190
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "__dlm_queue_bast",
          "args": [
            "dlm",
            "lock"
          ],
          "line": 189
        },
        "resolved": true,
        "details": {
          "function_name": "__dlm_queue_bast",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmast.c",
          "lines": "157-181",
          "snippet": "void __dlm_queue_bast(struct dlm_ctxt *dlm, struct dlm_lock *lock)\n{\n\tstruct dlm_lock_resource *res;\n\n\tBUG_ON(!dlm);\n\tBUG_ON(!lock);\n\n\tassert_spin_locked(&dlm->ast_lock);\n\n\tres = lock->lockres;\n\n\tBUG_ON(!list_empty(&lock->bast_list));\n\tif (lock->bast_pending)\n\t\tmlog(0, \"%s: res %.*s, lock %u:%llu, BAST getting flushed\\n\",\n\t\t     dlm->name, res->lockname.len, res->lockname.name,\n\t\t     dlm_get_lock_cookie_node(be64_to_cpu(lock->ml.cookie)),\n\t\t     dlm_get_lock_cookie_seq(be64_to_cpu(lock->ml.cookie)));\n\n\t/* putting lock on list, add a ref */\n\tdlm_lock_get(lock);\n\tspin_lock(&lock->spinlock);\n\tlist_add_tail(&lock->bast_list, &dlm->pending_basts);\n\tlock->bast_pending = 1;\n\tspin_unlock(&lock->spinlock);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_update_lvb(struct dlm_ctxt *dlm, struct dlm_lock_resource *res,\n\t\t\t   struct dlm_lock *lock);",
            "static int dlm_should_cancel_bast(struct dlm_ctxt *dlm, struct dlm_lock *lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_update_lvb(struct dlm_ctxt *dlm, struct dlm_lock_resource *res,\n\t\t\t   struct dlm_lock *lock);\nstatic int dlm_should_cancel_bast(struct dlm_ctxt *dlm, struct dlm_lock *lock);\n\nvoid __dlm_queue_bast(struct dlm_ctxt *dlm, struct dlm_lock *lock)\n{\n\tstruct dlm_lock_resource *res;\n\n\tBUG_ON(!dlm);\n\tBUG_ON(!lock);\n\n\tassert_spin_locked(&dlm->ast_lock);\n\n\tres = lock->lockres;\n\n\tBUG_ON(!list_empty(&lock->bast_list));\n\tif (lock->bast_pending)\n\t\tmlog(0, \"%s: res %.*s, lock %u:%llu, BAST getting flushed\\n\",\n\t\t     dlm->name, res->lockname.len, res->lockname.name,\n\t\t     dlm_get_lock_cookie_node(be64_to_cpu(lock->ml.cookie)),\n\t\t     dlm_get_lock_cookie_seq(be64_to_cpu(lock->ml.cookie)));\n\n\t/* putting lock on list, add a ref */\n\tdlm_lock_get(lock);\n\tspin_lock(&lock->spinlock);\n\tlist_add_tail(&lock->bast_list, &dlm->pending_basts);\n\tlock->bast_pending = 1;\n\tspin_unlock(&lock->spinlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&dlm->ast_lock"
          ],
          "line": 188
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!lock"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!dlm"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_update_lvb(struct dlm_ctxt *dlm, struct dlm_lock_resource *res,\n\t\t\t   struct dlm_lock *lock);\nstatic int dlm_should_cancel_bast(struct dlm_ctxt *dlm, struct dlm_lock *lock);\n\nvoid dlm_queue_bast(struct dlm_ctxt *dlm, struct dlm_lock *lock)\n{\n\tBUG_ON(!dlm);\n\tBUG_ON(!lock);\n\n\tspin_lock(&dlm->ast_lock);\n\t__dlm_queue_bast(dlm, lock);\n\tspin_unlock(&dlm->ast_lock);\n}"
  },
  {
    "function_name": "__dlm_queue_bast",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmast.c",
    "lines": "157-181",
    "snippet": "void __dlm_queue_bast(struct dlm_ctxt *dlm, struct dlm_lock *lock)\n{\n\tstruct dlm_lock_resource *res;\n\n\tBUG_ON(!dlm);\n\tBUG_ON(!lock);\n\n\tassert_spin_locked(&dlm->ast_lock);\n\n\tres = lock->lockres;\n\n\tBUG_ON(!list_empty(&lock->bast_list));\n\tif (lock->bast_pending)\n\t\tmlog(0, \"%s: res %.*s, lock %u:%llu, BAST getting flushed\\n\",\n\t\t     dlm->name, res->lockname.len, res->lockname.name,\n\t\t     dlm_get_lock_cookie_node(be64_to_cpu(lock->ml.cookie)),\n\t\t     dlm_get_lock_cookie_seq(be64_to_cpu(lock->ml.cookie)));\n\n\t/* putting lock on list, add a ref */\n\tdlm_lock_get(lock);\n\tspin_lock(&lock->spinlock);\n\tlist_add_tail(&lock->bast_list, &dlm->pending_basts);\n\tlock->bast_pending = 1;\n\tspin_unlock(&lock->spinlock);\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/spinlock.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/random.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void dlm_update_lvb(struct dlm_ctxt *dlm, struct dlm_lock_resource *res,\n\t\t\t   struct dlm_lock *lock);",
      "static int dlm_should_cancel_bast(struct dlm_ctxt *dlm, struct dlm_lock *lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&lock->spinlock"
          ],
          "line": 180
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&lock->bast_list",
            "&dlm->pending_basts"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&lock->spinlock"
          ],
          "line": 177
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_lock_get",
          "args": [
            "lock"
          ],
          "line": 176
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_lock_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmlock.c",
          "lines": "342-345",
          "snippet": "void dlm_lock_get(struct dlm_lock *lock)\n{\n\tkref_get(&lock->lock_refs);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmconvert.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_lock_detach_lockres(struct dlm_lock *lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmconvert.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_lock_detach_lockres(struct dlm_lock *lock);\n\nvoid dlm_lock_get(struct dlm_lock *lock)\n{\n\tkref_get(&lock->lock_refs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"%s: res %.*s, lock %u:%llu, BAST getting flushed\\n\"",
            "dlm->name",
            "res->lockname.len",
            "res->lockname.name",
            "dlm_get_lock_cookie_node(be64_to_cpu(lock->ml.cookie))",
            "dlm_get_lock_cookie_seq(be64_to_cpu(lock->ml.cookie))"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_get_lock_cookie_seq",
          "args": [
            "be64_to_cpu(lock->ml.cookie)"
          ],
          "line": 173
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_get_lock_cookie_seq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmcommon.h",
          "lines": "821-826",
          "snippet": "static inline unsigned long long dlm_get_lock_cookie_seq(u64 cookie)\n{\n\tunsigned long long ret;\n\tret = ((unsigned long long)cookie) & 0x00ffffffffffffffULL;\n\treturn ret;\n}",
          "includes": [
            "#include <linux/kref.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kref.h>\n\nstatic inline unsigned long long dlm_get_lock_cookie_seq(u64 cookie)\n{\n\tunsigned long long ret;\n\tret = ((unsigned long long)cookie) & 0x00ffffffffffffffULL;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "lock->ml.cookie"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_get_lock_cookie_node",
          "args": [
            "be64_to_cpu(lock->ml.cookie)"
          ],
          "line": 172
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_get_lock_cookie_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmcommon.h",
          "lines": "813-819",
          "snippet": "static inline u8 dlm_get_lock_cookie_node(u64 cookie)\n{\n\tu8 ret;\n\tcookie >>= 56;\n\tret = (u8)(cookie & 0xffULL);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/kref.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kref.h>\n\nstatic inline u8 dlm_get_lock_cookie_node(u64 cookie)\n{\n\tu8 ret;\n\tcookie >>= 56;\n\tret = (u8)(cookie & 0xffULL);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "lock->ml.cookie"
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!list_empty(&lock->bast_list)"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&lock->bast_list"
          ],
          "line": 168
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert_spin_locked",
          "args": [
            "&dlm->ast_lock"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!lock"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!dlm"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_update_lvb(struct dlm_ctxt *dlm, struct dlm_lock_resource *res,\n\t\t\t   struct dlm_lock *lock);\nstatic int dlm_should_cancel_bast(struct dlm_ctxt *dlm, struct dlm_lock *lock);\n\nvoid __dlm_queue_bast(struct dlm_ctxt *dlm, struct dlm_lock *lock)\n{\n\tstruct dlm_lock_resource *res;\n\n\tBUG_ON(!dlm);\n\tBUG_ON(!lock);\n\n\tassert_spin_locked(&dlm->ast_lock);\n\n\tres = lock->lockres;\n\n\tBUG_ON(!list_empty(&lock->bast_list));\n\tif (lock->bast_pending)\n\t\tmlog(0, \"%s: res %.*s, lock %u:%llu, BAST getting flushed\\n\",\n\t\t     dlm->name, res->lockname.len, res->lockname.name,\n\t\t     dlm_get_lock_cookie_node(be64_to_cpu(lock->ml.cookie)),\n\t\t     dlm_get_lock_cookie_seq(be64_to_cpu(lock->ml.cookie)));\n\n\t/* putting lock on list, add a ref */\n\tdlm_lock_get(lock);\n\tspin_lock(&lock->spinlock);\n\tlist_add_tail(&lock->bast_list, &dlm->pending_basts);\n\tlock->bast_pending = 1;\n\tspin_unlock(&lock->spinlock);\n}"
  },
  {
    "function_name": "dlm_queue_ast",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmast.c",
    "lines": "146-154",
    "snippet": "void dlm_queue_ast(struct dlm_ctxt *dlm, struct dlm_lock *lock)\n{\n\tBUG_ON(!dlm);\n\tBUG_ON(!lock);\n\n\tspin_lock(&dlm->ast_lock);\n\t__dlm_queue_ast(dlm, lock);\n\tspin_unlock(&dlm->ast_lock);\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/spinlock.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/random.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void dlm_update_lvb(struct dlm_ctxt *dlm, struct dlm_lock_resource *res,\n\t\t\t   struct dlm_lock *lock);",
      "static int dlm_should_cancel_bast(struct dlm_ctxt *dlm, struct dlm_lock *lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&dlm->ast_lock"
          ],
          "line": 153
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "__dlm_queue_ast",
          "args": [
            "dlm",
            "lock"
          ],
          "line": 152
        },
        "resolved": true,
        "details": {
          "function_name": "__dlm_queue_ast",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmast.c",
          "lines": "91-144",
          "snippet": "void __dlm_queue_ast(struct dlm_ctxt *dlm, struct dlm_lock *lock)\n{\n\tstruct dlm_lock_resource *res;\n\n\tBUG_ON(!dlm);\n\tBUG_ON(!lock);\n\n\tres = lock->lockres;\n\n\tassert_spin_locked(&dlm->ast_lock);\n\n\tif (!list_empty(&lock->ast_list)) {\n\t\tmlog(ML_ERROR, \"%s: res %.*s, lock %u:%llu, \"\n\t\t     \"AST list not empty, pending %d, newlevel %d\\n\",\n\t\t     dlm->name, res->lockname.len, res->lockname.name,\n\t\t     dlm_get_lock_cookie_node(be64_to_cpu(lock->ml.cookie)),\n\t\t     dlm_get_lock_cookie_seq(be64_to_cpu(lock->ml.cookie)),\n\t\t     lock->ast_pending, lock->ml.type);\n\t\tBUG();\n\t}\n\tif (lock->ast_pending)\n\t\tmlog(0, \"%s: res %.*s, lock %u:%llu, AST getting flushed\\n\",\n\t\t     dlm->name, res->lockname.len, res->lockname.name,\n\t\t     dlm_get_lock_cookie_node(be64_to_cpu(lock->ml.cookie)),\n\t\t     dlm_get_lock_cookie_seq(be64_to_cpu(lock->ml.cookie)));\n\n\t/* putting lock on list, add a ref */\n\tdlm_lock_get(lock);\n\tspin_lock(&lock->spinlock);\n\n\t/* check to see if this ast obsoletes the bast */\n\tif (dlm_should_cancel_bast(dlm, lock)) {\n\t\tmlog(0, \"%s: res %.*s, lock %u:%llu, Cancelling BAST\\n\",\n\t\t     dlm->name, res->lockname.len, res->lockname.name,\n\t\t     dlm_get_lock_cookie_node(be64_to_cpu(lock->ml.cookie)),\n\t\t     dlm_get_lock_cookie_seq(be64_to_cpu(lock->ml.cookie)));\n\t\tlock->bast_pending = 0;\n\t\tlist_del_init(&lock->bast_list);\n\t\tlock->ml.highest_blocked = LKM_IVMODE;\n\t\t/* removing lock from list, remove a ref.  guaranteed\n\t\t * this won't be the last ref because of the get above,\n\t\t * so res->spinlock will not be taken here */\n\t\tdlm_lock_put(lock);\n\t\t/* free up the reserved bast that we are cancelling.\n\t\t * guaranteed that this will not be the last reserved\n\t\t * ast because *both* an ast and a bast were reserved\n\t\t * to get to this point.  the res->spinlock will not be\n\t\t * taken here */\n\t\tdlm_lockres_release_ast(dlm, res);\n\t}\n\tlist_add_tail(&lock->ast_list, &dlm->pending_asts);\n\tlock->ast_pending = 1;\n\tspin_unlock(&lock->spinlock);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_update_lvb(struct dlm_ctxt *dlm, struct dlm_lock_resource *res,\n\t\t\t   struct dlm_lock *lock);",
            "static int dlm_should_cancel_bast(struct dlm_ctxt *dlm, struct dlm_lock *lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_update_lvb(struct dlm_ctxt *dlm, struct dlm_lock_resource *res,\n\t\t\t   struct dlm_lock *lock);\nstatic int dlm_should_cancel_bast(struct dlm_ctxt *dlm, struct dlm_lock *lock);\n\nvoid __dlm_queue_ast(struct dlm_ctxt *dlm, struct dlm_lock *lock)\n{\n\tstruct dlm_lock_resource *res;\n\n\tBUG_ON(!dlm);\n\tBUG_ON(!lock);\n\n\tres = lock->lockres;\n\n\tassert_spin_locked(&dlm->ast_lock);\n\n\tif (!list_empty(&lock->ast_list)) {\n\t\tmlog(ML_ERROR, \"%s: res %.*s, lock %u:%llu, \"\n\t\t     \"AST list not empty, pending %d, newlevel %d\\n\",\n\t\t     dlm->name, res->lockname.len, res->lockname.name,\n\t\t     dlm_get_lock_cookie_node(be64_to_cpu(lock->ml.cookie)),\n\t\t     dlm_get_lock_cookie_seq(be64_to_cpu(lock->ml.cookie)),\n\t\t     lock->ast_pending, lock->ml.type);\n\t\tBUG();\n\t}\n\tif (lock->ast_pending)\n\t\tmlog(0, \"%s: res %.*s, lock %u:%llu, AST getting flushed\\n\",\n\t\t     dlm->name, res->lockname.len, res->lockname.name,\n\t\t     dlm_get_lock_cookie_node(be64_to_cpu(lock->ml.cookie)),\n\t\t     dlm_get_lock_cookie_seq(be64_to_cpu(lock->ml.cookie)));\n\n\t/* putting lock on list, add a ref */\n\tdlm_lock_get(lock);\n\tspin_lock(&lock->spinlock);\n\n\t/* check to see if this ast obsoletes the bast */\n\tif (dlm_should_cancel_bast(dlm, lock)) {\n\t\tmlog(0, \"%s: res %.*s, lock %u:%llu, Cancelling BAST\\n\",\n\t\t     dlm->name, res->lockname.len, res->lockname.name,\n\t\t     dlm_get_lock_cookie_node(be64_to_cpu(lock->ml.cookie)),\n\t\t     dlm_get_lock_cookie_seq(be64_to_cpu(lock->ml.cookie)));\n\t\tlock->bast_pending = 0;\n\t\tlist_del_init(&lock->bast_list);\n\t\tlock->ml.highest_blocked = LKM_IVMODE;\n\t\t/* removing lock from list, remove a ref.  guaranteed\n\t\t * this won't be the last ref because of the get above,\n\t\t * so res->spinlock will not be taken here */\n\t\tdlm_lock_put(lock);\n\t\t/* free up the reserved bast that we are cancelling.\n\t\t * guaranteed that this will not be the last reserved\n\t\t * ast because *both* an ast and a bast were reserved\n\t\t * to get to this point.  the res->spinlock will not be\n\t\t * taken here */\n\t\tdlm_lockres_release_ast(dlm, res);\n\t}\n\tlist_add_tail(&lock->ast_list, &dlm->pending_asts);\n\tlock->ast_pending = 1;\n\tspin_unlock(&lock->spinlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&dlm->ast_lock"
          ],
          "line": 151
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!lock"
          ],
          "line": 149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!dlm"
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_update_lvb(struct dlm_ctxt *dlm, struct dlm_lock_resource *res,\n\t\t\t   struct dlm_lock *lock);\nstatic int dlm_should_cancel_bast(struct dlm_ctxt *dlm, struct dlm_lock *lock);\n\nvoid dlm_queue_ast(struct dlm_ctxt *dlm, struct dlm_lock *lock)\n{\n\tBUG_ON(!dlm);\n\tBUG_ON(!lock);\n\n\tspin_lock(&dlm->ast_lock);\n\t__dlm_queue_ast(dlm, lock);\n\tspin_unlock(&dlm->ast_lock);\n}"
  },
  {
    "function_name": "__dlm_queue_ast",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmast.c",
    "lines": "91-144",
    "snippet": "void __dlm_queue_ast(struct dlm_ctxt *dlm, struct dlm_lock *lock)\n{\n\tstruct dlm_lock_resource *res;\n\n\tBUG_ON(!dlm);\n\tBUG_ON(!lock);\n\n\tres = lock->lockres;\n\n\tassert_spin_locked(&dlm->ast_lock);\n\n\tif (!list_empty(&lock->ast_list)) {\n\t\tmlog(ML_ERROR, \"%s: res %.*s, lock %u:%llu, \"\n\t\t     \"AST list not empty, pending %d, newlevel %d\\n\",\n\t\t     dlm->name, res->lockname.len, res->lockname.name,\n\t\t     dlm_get_lock_cookie_node(be64_to_cpu(lock->ml.cookie)),\n\t\t     dlm_get_lock_cookie_seq(be64_to_cpu(lock->ml.cookie)),\n\t\t     lock->ast_pending, lock->ml.type);\n\t\tBUG();\n\t}\n\tif (lock->ast_pending)\n\t\tmlog(0, \"%s: res %.*s, lock %u:%llu, AST getting flushed\\n\",\n\t\t     dlm->name, res->lockname.len, res->lockname.name,\n\t\t     dlm_get_lock_cookie_node(be64_to_cpu(lock->ml.cookie)),\n\t\t     dlm_get_lock_cookie_seq(be64_to_cpu(lock->ml.cookie)));\n\n\t/* putting lock on list, add a ref */\n\tdlm_lock_get(lock);\n\tspin_lock(&lock->spinlock);\n\n\t/* check to see if this ast obsoletes the bast */\n\tif (dlm_should_cancel_bast(dlm, lock)) {\n\t\tmlog(0, \"%s: res %.*s, lock %u:%llu, Cancelling BAST\\n\",\n\t\t     dlm->name, res->lockname.len, res->lockname.name,\n\t\t     dlm_get_lock_cookie_node(be64_to_cpu(lock->ml.cookie)),\n\t\t     dlm_get_lock_cookie_seq(be64_to_cpu(lock->ml.cookie)));\n\t\tlock->bast_pending = 0;\n\t\tlist_del_init(&lock->bast_list);\n\t\tlock->ml.highest_blocked = LKM_IVMODE;\n\t\t/* removing lock from list, remove a ref.  guaranteed\n\t\t * this won't be the last ref because of the get above,\n\t\t * so res->spinlock will not be taken here */\n\t\tdlm_lock_put(lock);\n\t\t/* free up the reserved bast that we are cancelling.\n\t\t * guaranteed that this will not be the last reserved\n\t\t * ast because *both* an ast and a bast were reserved\n\t\t * to get to this point.  the res->spinlock will not be\n\t\t * taken here */\n\t\tdlm_lockres_release_ast(dlm, res);\n\t}\n\tlist_add_tail(&lock->ast_list, &dlm->pending_asts);\n\tlock->ast_pending = 1;\n\tspin_unlock(&lock->spinlock);\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/spinlock.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/random.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void dlm_update_lvb(struct dlm_ctxt *dlm, struct dlm_lock_resource *res,\n\t\t\t   struct dlm_lock *lock);",
      "static int dlm_should_cancel_bast(struct dlm_ctxt *dlm, struct dlm_lock *lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&lock->spinlock"
          ],
          "line": 143
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&lock->ast_list",
            "&dlm->pending_asts"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_lockres_release_ast",
          "args": [
            "dlm",
            "res"
          ],
          "line": 139
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_lockres_release_ast",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
          "lines": "3419-3436",
          "snippet": "void dlm_lockres_release_ast(struct dlm_ctxt *dlm,\n\t\t\t     struct dlm_lock_resource *res)\n{\n\tif (!atomic_dec_and_lock(&res->asts_reserved, &res->spinlock))\n\t\treturn;\n\n\tif (!res->migration_pending) {\n\t\tspin_unlock(&res->spinlock);\n\t\treturn;\n\t}\n\n\tBUG_ON(res->state & DLM_LOCK_RES_MIGRATING);\n\tres->migration_pending = 0;\n\tres->state |= DLM_LOCK_RES_MIGRATING;\n\tspin_unlock(&res->spinlock);\n\twake_up(&res->wq);\n\twake_up(&dlm->migration_wq);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);",
            "static void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);",
            "static int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);\nstatic void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);\nstatic int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);\n\nvoid dlm_lockres_release_ast(struct dlm_ctxt *dlm,\n\t\t\t     struct dlm_lock_resource *res)\n{\n\tif (!atomic_dec_and_lock(&res->asts_reserved, &res->spinlock))\n\t\treturn;\n\n\tif (!res->migration_pending) {\n\t\tspin_unlock(&res->spinlock);\n\t\treturn;\n\t}\n\n\tBUG_ON(res->state & DLM_LOCK_RES_MIGRATING);\n\tres->migration_pending = 0;\n\tres->state |= DLM_LOCK_RES_MIGRATING;\n\tspin_unlock(&res->spinlock);\n\twake_up(&res->wq);\n\twake_up(&dlm->migration_wq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_lock_put",
          "args": [
            "lock"
          ],
          "line": 133
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_lock_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmlock.c",
          "lines": "347-350",
          "snippet": "void dlm_lock_put(struct dlm_lock *lock)\n{\n\tkref_put(&lock->lock_refs, dlm_lock_release);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmconvert.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_lock_detach_lockres(struct dlm_lock *lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmconvert.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_lock_detach_lockres(struct dlm_lock *lock);\n\nvoid dlm_lock_put(struct dlm_lock *lock)\n{\n\tkref_put(&lock->lock_refs, dlm_lock_release);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&lock->bast_list"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"%s: res %.*s, lock %u:%llu, Cancelling BAST\\n\"",
            "dlm->name",
            "res->lockname.len",
            "res->lockname.name",
            "dlm_get_lock_cookie_node(be64_to_cpu(lock->ml.cookie))",
            "dlm_get_lock_cookie_seq(be64_to_cpu(lock->ml.cookie))"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_get_lock_cookie_seq",
          "args": [
            "be64_to_cpu(lock->ml.cookie)"
          ],
          "line": 126
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_get_lock_cookie_seq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmcommon.h",
          "lines": "821-826",
          "snippet": "static inline unsigned long long dlm_get_lock_cookie_seq(u64 cookie)\n{\n\tunsigned long long ret;\n\tret = ((unsigned long long)cookie) & 0x00ffffffffffffffULL;\n\treturn ret;\n}",
          "includes": [
            "#include <linux/kref.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kref.h>\n\nstatic inline unsigned long long dlm_get_lock_cookie_seq(u64 cookie)\n{\n\tunsigned long long ret;\n\tret = ((unsigned long long)cookie) & 0x00ffffffffffffffULL;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "lock->ml.cookie"
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_get_lock_cookie_node",
          "args": [
            "be64_to_cpu(lock->ml.cookie)"
          ],
          "line": 125
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_get_lock_cookie_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmcommon.h",
          "lines": "813-819",
          "snippet": "static inline u8 dlm_get_lock_cookie_node(u64 cookie)\n{\n\tu8 ret;\n\tcookie >>= 56;\n\tret = (u8)(cookie & 0xffULL);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/kref.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kref.h>\n\nstatic inline u8 dlm_get_lock_cookie_node(u64 cookie)\n{\n\tu8 ret;\n\tcookie >>= 56;\n\tret = (u8)(cookie & 0xffULL);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "lock->ml.cookie"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_should_cancel_bast",
          "args": [
            "dlm",
            "lock"
          ],
          "line": 122
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_should_cancel_bast",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmast.c",
          "lines": "64-89",
          "snippet": "static int dlm_should_cancel_bast(struct dlm_ctxt *dlm, struct dlm_lock *lock)\n{\n\tassert_spin_locked(&dlm->ast_lock);\n\tassert_spin_locked(&lock->spinlock);\n\n\tif (lock->ml.highest_blocked == LKM_IVMODE)\n\t\treturn 0;\n\tBUG_ON(lock->ml.highest_blocked == LKM_NLMODE);\n\n\tif (lock->bast_pending &&\n\t    list_empty(&lock->bast_list))\n\t\t/* old bast already sent, ok */\n\t\treturn 0;\n\n\tif (lock->ml.type == LKM_EXMODE)\n\t\t/* EX blocks anything left, any bast still valid */\n\t\treturn 0;\n\telse if (lock->ml.type == LKM_NLMODE)\n\t\t/* NL blocks nothing, no reason to send any bast, cancel it */\n\t\treturn 1;\n\telse if (lock->ml.highest_blocked != LKM_EXMODE)\n\t\t/* PR only blocks EX */\n\t\treturn 1;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_update_lvb(struct dlm_ctxt *dlm, struct dlm_lock_resource *res,\n\t\t\t   struct dlm_lock *lock);",
            "static int dlm_should_cancel_bast(struct dlm_ctxt *dlm, struct dlm_lock *lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_update_lvb(struct dlm_ctxt *dlm, struct dlm_lock_resource *res,\n\t\t\t   struct dlm_lock *lock);\nstatic int dlm_should_cancel_bast(struct dlm_ctxt *dlm, struct dlm_lock *lock);\n\nstatic int dlm_should_cancel_bast(struct dlm_ctxt *dlm, struct dlm_lock *lock)\n{\n\tassert_spin_locked(&dlm->ast_lock);\n\tassert_spin_locked(&lock->spinlock);\n\n\tif (lock->ml.highest_blocked == LKM_IVMODE)\n\t\treturn 0;\n\tBUG_ON(lock->ml.highest_blocked == LKM_NLMODE);\n\n\tif (lock->bast_pending &&\n\t    list_empty(&lock->bast_list))\n\t\t/* old bast already sent, ok */\n\t\treturn 0;\n\n\tif (lock->ml.type == LKM_EXMODE)\n\t\t/* EX blocks anything left, any bast still valid */\n\t\treturn 0;\n\telse if (lock->ml.type == LKM_NLMODE)\n\t\t/* NL blocks nothing, no reason to send any bast, cancel it */\n\t\treturn 1;\n\telse if (lock->ml.highest_blocked != LKM_EXMODE)\n\t\t/* PR only blocks EX */\n\t\treturn 1;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&lock->spinlock"
          ],
          "line": 119
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_lock_get",
          "args": [
            "lock"
          ],
          "line": 118
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_lock_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmlock.c",
          "lines": "342-345",
          "snippet": "void dlm_lock_get(struct dlm_lock *lock)\n{\n\tkref_get(&lock->lock_refs);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmconvert.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_lock_detach_lockres(struct dlm_lock *lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmconvert.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_lock_detach_lockres(struct dlm_lock *lock);\n\nvoid dlm_lock_get(struct dlm_lock *lock)\n{\n\tkref_get(&lock->lock_refs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"%s: res %.*s, lock %u:%llu, AST getting flushed\\n\"",
            "dlm->name",
            "res->lockname.len",
            "res->lockname.name",
            "dlm_get_lock_cookie_node(be64_to_cpu(lock->ml.cookie))",
            "dlm_get_lock_cookie_seq(be64_to_cpu(lock->ml.cookie))"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "lock->ml.cookie"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "lock->ml.cookie"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"%s: res %.*s, lock %u:%llu, \"\n\t\t     \"AST list not empty, pending %d, newlevel %d\\n\"",
            "dlm->name",
            "res->lockname.len",
            "res->lockname.name",
            "dlm_get_lock_cookie_node(be64_to_cpu(lock->ml.cookie))",
            "dlm_get_lock_cookie_seq(be64_to_cpu(lock->ml.cookie))",
            "lock->ast_pending",
            "lock->ml.type"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "lock->ml.cookie"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "lock->ml.cookie"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&lock->ast_list"
          ],
          "line": 102
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert_spin_locked",
          "args": [
            "&dlm->ast_lock"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!lock"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!dlm"
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_update_lvb(struct dlm_ctxt *dlm, struct dlm_lock_resource *res,\n\t\t\t   struct dlm_lock *lock);\nstatic int dlm_should_cancel_bast(struct dlm_ctxt *dlm, struct dlm_lock *lock);\n\nvoid __dlm_queue_ast(struct dlm_ctxt *dlm, struct dlm_lock *lock)\n{\n\tstruct dlm_lock_resource *res;\n\n\tBUG_ON(!dlm);\n\tBUG_ON(!lock);\n\n\tres = lock->lockres;\n\n\tassert_spin_locked(&dlm->ast_lock);\n\n\tif (!list_empty(&lock->ast_list)) {\n\t\tmlog(ML_ERROR, \"%s: res %.*s, lock %u:%llu, \"\n\t\t     \"AST list not empty, pending %d, newlevel %d\\n\",\n\t\t     dlm->name, res->lockname.len, res->lockname.name,\n\t\t     dlm_get_lock_cookie_node(be64_to_cpu(lock->ml.cookie)),\n\t\t     dlm_get_lock_cookie_seq(be64_to_cpu(lock->ml.cookie)),\n\t\t     lock->ast_pending, lock->ml.type);\n\t\tBUG();\n\t}\n\tif (lock->ast_pending)\n\t\tmlog(0, \"%s: res %.*s, lock %u:%llu, AST getting flushed\\n\",\n\t\t     dlm->name, res->lockname.len, res->lockname.name,\n\t\t     dlm_get_lock_cookie_node(be64_to_cpu(lock->ml.cookie)),\n\t\t     dlm_get_lock_cookie_seq(be64_to_cpu(lock->ml.cookie)));\n\n\t/* putting lock on list, add a ref */\n\tdlm_lock_get(lock);\n\tspin_lock(&lock->spinlock);\n\n\t/* check to see if this ast obsoletes the bast */\n\tif (dlm_should_cancel_bast(dlm, lock)) {\n\t\tmlog(0, \"%s: res %.*s, lock %u:%llu, Cancelling BAST\\n\",\n\t\t     dlm->name, res->lockname.len, res->lockname.name,\n\t\t     dlm_get_lock_cookie_node(be64_to_cpu(lock->ml.cookie)),\n\t\t     dlm_get_lock_cookie_seq(be64_to_cpu(lock->ml.cookie)));\n\t\tlock->bast_pending = 0;\n\t\tlist_del_init(&lock->bast_list);\n\t\tlock->ml.highest_blocked = LKM_IVMODE;\n\t\t/* removing lock from list, remove a ref.  guaranteed\n\t\t * this won't be the last ref because of the get above,\n\t\t * so res->spinlock will not be taken here */\n\t\tdlm_lock_put(lock);\n\t\t/* free up the reserved bast that we are cancelling.\n\t\t * guaranteed that this will not be the last reserved\n\t\t * ast because *both* an ast and a bast were reserved\n\t\t * to get to this point.  the res->spinlock will not be\n\t\t * taken here */\n\t\tdlm_lockres_release_ast(dlm, res);\n\t}\n\tlist_add_tail(&lock->ast_list, &dlm->pending_asts);\n\tlock->ast_pending = 1;\n\tspin_unlock(&lock->spinlock);\n}"
  },
  {
    "function_name": "dlm_should_cancel_bast",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmast.c",
    "lines": "64-89",
    "snippet": "static int dlm_should_cancel_bast(struct dlm_ctxt *dlm, struct dlm_lock *lock)\n{\n\tassert_spin_locked(&dlm->ast_lock);\n\tassert_spin_locked(&lock->spinlock);\n\n\tif (lock->ml.highest_blocked == LKM_IVMODE)\n\t\treturn 0;\n\tBUG_ON(lock->ml.highest_blocked == LKM_NLMODE);\n\n\tif (lock->bast_pending &&\n\t    list_empty(&lock->bast_list))\n\t\t/* old bast already sent, ok */\n\t\treturn 0;\n\n\tif (lock->ml.type == LKM_EXMODE)\n\t\t/* EX blocks anything left, any bast still valid */\n\t\treturn 0;\n\telse if (lock->ml.type == LKM_NLMODE)\n\t\t/* NL blocks nothing, no reason to send any bast, cancel it */\n\t\treturn 1;\n\telse if (lock->ml.highest_blocked != LKM_EXMODE)\n\t\t/* PR only blocks EX */\n\t\treturn 1;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/spinlock.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/random.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void dlm_update_lvb(struct dlm_ctxt *dlm, struct dlm_lock_resource *res,\n\t\t\t   struct dlm_lock *lock);",
      "static int dlm_should_cancel_bast(struct dlm_ctxt *dlm, struct dlm_lock *lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&lock->bast_list"
          ],
          "line": 74
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "lock->ml.highest_blocked == LKM_NLMODE"
          ],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert_spin_locked",
          "args": [
            "&lock->spinlock"
          ],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert_spin_locked",
          "args": [
            "&dlm->ast_lock"
          ],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_update_lvb(struct dlm_ctxt *dlm, struct dlm_lock_resource *res,\n\t\t\t   struct dlm_lock *lock);\nstatic int dlm_should_cancel_bast(struct dlm_ctxt *dlm, struct dlm_lock *lock);\n\nstatic int dlm_should_cancel_bast(struct dlm_ctxt *dlm, struct dlm_lock *lock)\n{\n\tassert_spin_locked(&dlm->ast_lock);\n\tassert_spin_locked(&lock->spinlock);\n\n\tif (lock->ml.highest_blocked == LKM_IVMODE)\n\t\treturn 0;\n\tBUG_ON(lock->ml.highest_blocked == LKM_NLMODE);\n\n\tif (lock->bast_pending &&\n\t    list_empty(&lock->bast_list))\n\t\t/* old bast already sent, ok */\n\t\treturn 0;\n\n\tif (lock->ml.type == LKM_EXMODE)\n\t\t/* EX blocks anything left, any bast still valid */\n\t\treturn 0;\n\telse if (lock->ml.type == LKM_NLMODE)\n\t\t/* NL blocks nothing, no reason to send any bast, cancel it */\n\t\treturn 1;\n\telse if (lock->ml.highest_blocked != LKM_EXMODE)\n\t\t/* PR only blocks EX */\n\t\treturn 1;\n\n\treturn 0;\n}"
  }
]