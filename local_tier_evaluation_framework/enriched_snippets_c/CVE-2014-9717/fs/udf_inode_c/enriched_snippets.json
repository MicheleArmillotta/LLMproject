[
  {
    "function_name": "udf_block_map",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/inode.c",
    "lines": "2270-2293",
    "snippet": "long udf_block_map(struct inode *inode, sector_t block)\n{\n\tstruct kernel_lb_addr eloc;\n\tuint32_t elen;\n\tsector_t offset;\n\tstruct extent_position epos = {};\n\tint ret;\n\n\tdown_read(&UDF_I(inode)->i_data_sem);\n\n\tif (inode_bmap(inode, block, &epos, &eloc, &elen, &offset) ==\n\t\t\t\t\t\t(EXT_RECORDED_ALLOCATED >> 30))\n\t\tret = udf_get_lb_pblock(inode->i_sb, &eloc, offset);\n\telse\n\t\tret = 0;\n\n\tup_read(&UDF_I(inode)->i_data_sem);\n\tbrelse(epos.bh);\n\n\tif (UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_VARCONV))\n\t\treturn udf_fixed_to_variable(ret);\n\telse\n\t\treturn ret;\n}",
    "includes": [
      "#include \"udf_sb.h\"",
      "#include \"udf_i.h\"",
      "#include <linux/aio.h>",
      "#include <linux/mpage.h>",
      "#include <linux/crc-itu-t.h>",
      "#include <linux/slab.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include \"udfdecl.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int udf_update_inode(struct inode *, int);",
      "static int udf_sync_inode(struct inode *inode);",
      "static sector_t inode_getblk(struct inode *, sector_t, int *, int *);",
      "static int8_t udf_insert_aext(struct inode *, struct extent_position,\n\t\t\t      struct kernel_lb_addr, uint32_t);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "udf_fixed_to_variable",
          "args": [
            "ret"
          ],
          "line": 2290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UDF_QUERY_FLAG",
          "args": [
            "inode->i_sb",
            "UDF_FLAG_VARCONV"
          ],
          "line": 2289
        },
        "resolved": true,
        "details": {
          "function_name": "UDF_QUERY_FLAG",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/udf_sb.h",
          "lines": "169-172",
          "snippet": "static inline int UDF_QUERY_FLAG(struct super_block *sb, int flag)\n{\n\treturn test_bit(flag, &UDF_SB(sb)->s_flags);\n}",
          "includes": [
            "#include <linux/bitops.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bitops.h>\n#include <linux/mutex.h>\n\nstatic inline int UDF_QUERY_FLAG(struct super_block *sb, int flag)\n{\n\treturn test_bit(flag, &UDF_SB(sb)->s_flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "epos.bh"
          ],
          "line": 2287
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&UDF_I(inode)->i_data_sem"
          ],
          "line": 2286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UDF_I",
          "args": [
            "inode"
          ],
          "line": 2286
        },
        "resolved": true,
        "details": {
          "function_name": "UDF_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/udf_i.h",
          "lines": "57-60",
          "snippet": "static inline struct udf_inode_info *UDF_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct udf_inode_info, vfs_inode);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline struct udf_inode_info *UDF_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct udf_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_get_lb_pblock",
          "args": [
            "inode->i_sb",
            "&eloc",
            "offset"
          ],
          "line": 2282
        },
        "resolved": true,
        "details": {
          "function_name": "udf_get_lb_pblock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/udfdecl.h",
          "lines": "205-211",
          "snippet": "static inline uint32_t\nudf_get_lb_pblock(struct super_block *sb, struct kernel_lb_addr *loc,\n\t\t  uint32_t offset)\n{\n\treturn udf_get_pblock(sb, loc->logicalBlockNum,\n\t\t\tloc->partitionReferenceNum, offset);\n}",
          "includes": [
            "#include \"udf_i.h\"",
            "#include \"udfend.h\"",
            "#include \"udf_sb.h\"",
            "#include <linux/udf_fs_i.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include \"osta_udf.h\"",
            "#include \"ecma_167.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_i.h\"\n#include \"udfend.h\"\n#include \"udf_sb.h\"\n#include <linux/udf_fs_i.h>\n#include <linux/buffer_head.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include \"osta_udf.h\"\n#include \"ecma_167.h\"\n\nstatic inline uint32_t\nudf_get_lb_pblock(struct super_block *sb, struct kernel_lb_addr *loc,\n\t\t  uint32_t offset)\n{\n\treturn udf_get_pblock(sb, loc->logicalBlockNum,\n\t\t\tloc->partitionReferenceNum, offset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_bmap",
          "args": [
            "inode",
            "block",
            "&epos",
            "&eloc",
            "&elen",
            "&offset"
          ],
          "line": 2280
        },
        "resolved": true,
        "details": {
          "function_name": "inode_bmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/inode.c",
          "lines": "2237-2268",
          "snippet": "int8_t inode_bmap(struct inode *inode, sector_t block,\n\t\t  struct extent_position *pos, struct kernel_lb_addr *eloc,\n\t\t  uint32_t *elen, sector_t *offset)\n{\n\tunsigned char blocksize_bits = inode->i_sb->s_blocksize_bits;\n\tloff_t lbcount = 0, bcount =\n\t    (loff_t) block << blocksize_bits;\n\tint8_t etype;\n\tstruct udf_inode_info *iinfo;\n\n\tiinfo = UDF_I(inode);\n\tif (!udf_read_extent_cache(inode, bcount, &lbcount, pos)) {\n\t\tpos->offset = 0;\n\t\tpos->block = iinfo->i_location;\n\t\tpos->bh = NULL;\n\t}\n\t*elen = 0;\n\tdo {\n\t\tetype = udf_next_aext(inode, pos, eloc, elen, 1);\n\t\tif (etype == -1) {\n\t\t\t*offset = (bcount - lbcount) >> blocksize_bits;\n\t\t\tiinfo->i_lenExtents = lbcount;\n\t\t\treturn -1;\n\t\t}\n\t\tlbcount += *elen;\n\t} while (lbcount <= bcount);\n\t/* update extent cache */\n\tudf_update_extent_cache(inode, lbcount - *elen, pos, 1);\n\t*offset = (bcount + *elen - lbcount) >> blocksize_bits;\n\n\treturn etype;\n}",
          "includes": [
            "#include \"udf_sb.h\"",
            "#include \"udf_i.h\"",
            "#include <linux/aio.h>",
            "#include <linux/mpage.h>",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int udf_update_inode(struct inode *, int);",
            "static int udf_sync_inode(struct inode *inode);",
            "static sector_t inode_getblk(struct inode *, sector_t, int *, int *);",
            "static int8_t udf_insert_aext(struct inode *, struct extent_position,\n\t\t\t      struct kernel_lb_addr, uint32_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/crc-itu-t.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include \"udfdecl.h\"\n\nstatic int udf_update_inode(struct inode *, int);\nstatic int udf_sync_inode(struct inode *inode);\nstatic sector_t inode_getblk(struct inode *, sector_t, int *, int *);\nstatic int8_t udf_insert_aext(struct inode *, struct extent_position,\n\t\t\t      struct kernel_lb_addr, uint32_t);\n\nint8_t inode_bmap(struct inode *inode, sector_t block,\n\t\t  struct extent_position *pos, struct kernel_lb_addr *eloc,\n\t\t  uint32_t *elen, sector_t *offset)\n{\n\tunsigned char blocksize_bits = inode->i_sb->s_blocksize_bits;\n\tloff_t lbcount = 0, bcount =\n\t    (loff_t) block << blocksize_bits;\n\tint8_t etype;\n\tstruct udf_inode_info *iinfo;\n\n\tiinfo = UDF_I(inode);\n\tif (!udf_read_extent_cache(inode, bcount, &lbcount, pos)) {\n\t\tpos->offset = 0;\n\t\tpos->block = iinfo->i_location;\n\t\tpos->bh = NULL;\n\t}\n\t*elen = 0;\n\tdo {\n\t\tetype = udf_next_aext(inode, pos, eloc, elen, 1);\n\t\tif (etype == -1) {\n\t\t\t*offset = (bcount - lbcount) >> blocksize_bits;\n\t\t\tiinfo->i_lenExtents = lbcount;\n\t\t\treturn -1;\n\t\t}\n\t\tlbcount += *elen;\n\t} while (lbcount <= bcount);\n\t/* update extent cache */\n\tudf_update_extent_cache(inode, lbcount - *elen, pos, 1);\n\t*offset = (bcount + *elen - lbcount) >> blocksize_bits;\n\n\treturn etype;\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_read",
          "args": [
            "&UDF_I(inode)->i_data_sem"
          ],
          "line": 2278
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/crc-itu-t.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include \"udfdecl.h\"\n\nstatic int udf_update_inode(struct inode *, int);\nstatic int udf_sync_inode(struct inode *inode);\nstatic sector_t inode_getblk(struct inode *, sector_t, int *, int *);\nstatic int8_t udf_insert_aext(struct inode *, struct extent_position,\n\t\t\t      struct kernel_lb_addr, uint32_t);\n\nlong udf_block_map(struct inode *inode, sector_t block)\n{\n\tstruct kernel_lb_addr eloc;\n\tuint32_t elen;\n\tsector_t offset;\n\tstruct extent_position epos = {};\n\tint ret;\n\n\tdown_read(&UDF_I(inode)->i_data_sem);\n\n\tif (inode_bmap(inode, block, &epos, &eloc, &elen, &offset) ==\n\t\t\t\t\t\t(EXT_RECORDED_ALLOCATED >> 30))\n\t\tret = udf_get_lb_pblock(inode->i_sb, &eloc, offset);\n\telse\n\t\tret = 0;\n\n\tup_read(&UDF_I(inode)->i_data_sem);\n\tbrelse(epos.bh);\n\n\tif (UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_VARCONV))\n\t\treturn udf_fixed_to_variable(ret);\n\telse\n\t\treturn ret;\n}"
  },
  {
    "function_name": "inode_bmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/inode.c",
    "lines": "2237-2268",
    "snippet": "int8_t inode_bmap(struct inode *inode, sector_t block,\n\t\t  struct extent_position *pos, struct kernel_lb_addr *eloc,\n\t\t  uint32_t *elen, sector_t *offset)\n{\n\tunsigned char blocksize_bits = inode->i_sb->s_blocksize_bits;\n\tloff_t lbcount = 0, bcount =\n\t    (loff_t) block << blocksize_bits;\n\tint8_t etype;\n\tstruct udf_inode_info *iinfo;\n\n\tiinfo = UDF_I(inode);\n\tif (!udf_read_extent_cache(inode, bcount, &lbcount, pos)) {\n\t\tpos->offset = 0;\n\t\tpos->block = iinfo->i_location;\n\t\tpos->bh = NULL;\n\t}\n\t*elen = 0;\n\tdo {\n\t\tetype = udf_next_aext(inode, pos, eloc, elen, 1);\n\t\tif (etype == -1) {\n\t\t\t*offset = (bcount - lbcount) >> blocksize_bits;\n\t\t\tiinfo->i_lenExtents = lbcount;\n\t\t\treturn -1;\n\t\t}\n\t\tlbcount += *elen;\n\t} while (lbcount <= bcount);\n\t/* update extent cache */\n\tudf_update_extent_cache(inode, lbcount - *elen, pos, 1);\n\t*offset = (bcount + *elen - lbcount) >> blocksize_bits;\n\n\treturn etype;\n}",
    "includes": [
      "#include \"udf_sb.h\"",
      "#include \"udf_i.h\"",
      "#include <linux/aio.h>",
      "#include <linux/mpage.h>",
      "#include <linux/crc-itu-t.h>",
      "#include <linux/slab.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include \"udfdecl.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int udf_update_inode(struct inode *, int);",
      "static int udf_sync_inode(struct inode *inode);",
      "static sector_t inode_getblk(struct inode *, sector_t, int *, int *);",
      "static int8_t udf_insert_aext(struct inode *, struct extent_position,\n\t\t\t      struct kernel_lb_addr, uint32_t);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "udf_update_extent_cache",
          "args": [
            "inode",
            "lbcount - *elen",
            "pos",
            "1"
          ],
          "line": 2264
        },
        "resolved": true,
        "details": {
          "function_name": "udf_update_extent_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/inode.c",
          "lines": "113-137",
          "snippet": "static void udf_update_extent_cache(struct inode *inode, loff_t estart,\n\t\t\t\t    struct extent_position *pos, int next_epos)\n{\n\tstruct udf_inode_info *iinfo = UDF_I(inode);\n\n\tspin_lock(&iinfo->i_extent_cache_lock);\n\t/* Invalidate previously cached extent */\n\t__udf_clear_extent_cache(inode);\n\tif (pos->bh)\n\t\tget_bh(pos->bh);\n\tmemcpy(&iinfo->cached_extent.epos, pos,\n\t       sizeof(struct extent_position));\n\tiinfo->cached_extent.lstart = estart;\n\tif (next_epos)\n\t\tswitch (iinfo->i_alloc_type) {\n\t\tcase ICBTAG_FLAG_AD_SHORT:\n\t\t\tiinfo->cached_extent.epos.offset -=\n\t\t\tsizeof(struct short_ad);\n\t\t\tbreak;\n\t\tcase ICBTAG_FLAG_AD_LONG:\n\t\t\tiinfo->cached_extent.epos.offset -=\n\t\t\tsizeof(struct long_ad);\n\t\t}\n\tspin_unlock(&iinfo->i_extent_cache_lock);\n}",
          "includes": [
            "#include \"udf_sb.h\"",
            "#include \"udf_i.h\"",
            "#include <linux/aio.h>",
            "#include <linux/mpage.h>",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int udf_update_inode(struct inode *, int);",
            "static int udf_sync_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/crc-itu-t.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include \"udfdecl.h\"\n\nstatic int udf_update_inode(struct inode *, int);\nstatic int udf_sync_inode(struct inode *inode);\n\nstatic void udf_update_extent_cache(struct inode *inode, loff_t estart,\n\t\t\t\t    struct extent_position *pos, int next_epos)\n{\n\tstruct udf_inode_info *iinfo = UDF_I(inode);\n\n\tspin_lock(&iinfo->i_extent_cache_lock);\n\t/* Invalidate previously cached extent */\n\t__udf_clear_extent_cache(inode);\n\tif (pos->bh)\n\t\tget_bh(pos->bh);\n\tmemcpy(&iinfo->cached_extent.epos, pos,\n\t       sizeof(struct extent_position));\n\tiinfo->cached_extent.lstart = estart;\n\tif (next_epos)\n\t\tswitch (iinfo->i_alloc_type) {\n\t\tcase ICBTAG_FLAG_AD_SHORT:\n\t\t\tiinfo->cached_extent.epos.offset -=\n\t\t\tsizeof(struct short_ad);\n\t\t\tbreak;\n\t\tcase ICBTAG_FLAG_AD_LONG:\n\t\t\tiinfo->cached_extent.epos.offset -=\n\t\t\tsizeof(struct long_ad);\n\t\t}\n\tspin_unlock(&iinfo->i_extent_cache_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_next_aext",
          "args": [
            "inode",
            "pos",
            "eloc",
            "elen",
            "1"
          ],
          "line": 2255
        },
        "resolved": true,
        "details": {
          "function_name": "udf_next_aext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/inode.c",
          "lines": "2057-2077",
          "snippet": "int8_t udf_next_aext(struct inode *inode, struct extent_position *epos,\n\t\t     struct kernel_lb_addr *eloc, uint32_t *elen, int inc)\n{\n\tint8_t etype;\n\n\twhile ((etype = udf_current_aext(inode, epos, eloc, elen, inc)) ==\n\t       (EXT_NEXT_EXTENT_ALLOCDECS >> 30)) {\n\t\tint block;\n\t\tepos->block = *eloc;\n\t\tepos->offset = sizeof(struct allocExtDesc);\n\t\tbrelse(epos->bh);\n\t\tblock = udf_get_lb_pblock(inode->i_sb, &epos->block, 0);\n\t\tepos->bh = udf_tread(inode->i_sb, block);\n\t\tif (!epos->bh) {\n\t\t\tudf_debug(\"reading block %d failed!\\n\", block);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn etype;\n}",
          "includes": [
            "#include \"udf_sb.h\"",
            "#include \"udf_i.h\"",
            "#include <linux/aio.h>",
            "#include <linux/mpage.h>",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int udf_update_inode(struct inode *, int);",
            "static int udf_sync_inode(struct inode *inode);",
            "static int8_t udf_insert_aext(struct inode *, struct extent_position,\n\t\t\t      struct kernel_lb_addr, uint32_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/crc-itu-t.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include \"udfdecl.h\"\n\nstatic int udf_update_inode(struct inode *, int);\nstatic int udf_sync_inode(struct inode *inode);\nstatic int8_t udf_insert_aext(struct inode *, struct extent_position,\n\t\t\t      struct kernel_lb_addr, uint32_t);\n\nint8_t udf_next_aext(struct inode *inode, struct extent_position *epos,\n\t\t     struct kernel_lb_addr *eloc, uint32_t *elen, int inc)\n{\n\tint8_t etype;\n\n\twhile ((etype = udf_current_aext(inode, epos, eloc, elen, inc)) ==\n\t       (EXT_NEXT_EXTENT_ALLOCDECS >> 30)) {\n\t\tint block;\n\t\tepos->block = *eloc;\n\t\tepos->offset = sizeof(struct allocExtDesc);\n\t\tbrelse(epos->bh);\n\t\tblock = udf_get_lb_pblock(inode->i_sb, &epos->block, 0);\n\t\tepos->bh = udf_tread(inode->i_sb, block);\n\t\tif (!epos->bh) {\n\t\t\tudf_debug(\"reading block %d failed!\\n\", block);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn etype;\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_read_extent_cache",
          "args": [
            "inode",
            "bcount",
            "&lbcount",
            "pos"
          ],
          "line": 2248
        },
        "resolved": true,
        "details": {
          "function_name": "udf_read_extent_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/inode.c",
          "lines": "91-110",
          "snippet": "static int udf_read_extent_cache(struct inode *inode, loff_t bcount,\n\t\t\t\t loff_t *lbcount, struct extent_position *pos)\n{\n\tstruct udf_inode_info *iinfo = UDF_I(inode);\n\tint ret = 0;\n\n\tspin_lock(&iinfo->i_extent_cache_lock);\n\tif ((iinfo->cached_extent.lstart <= bcount) &&\n\t    (iinfo->cached_extent.lstart != -1)) {\n\t\t/* Cache hit */\n\t\t*lbcount = iinfo->cached_extent.lstart;\n\t\tmemcpy(pos, &iinfo->cached_extent.epos,\n\t\t       sizeof(struct extent_position));\n\t\tif (pos->bh)\n\t\t\tget_bh(pos->bh);\n\t\tret = 1;\n\t}\n\tspin_unlock(&iinfo->i_extent_cache_lock);\n\treturn ret;\n}",
          "includes": [
            "#include \"udf_sb.h\"",
            "#include \"udf_i.h\"",
            "#include <linux/aio.h>",
            "#include <linux/mpage.h>",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int udf_update_inode(struct inode *, int);",
            "static int udf_sync_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/crc-itu-t.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include \"udfdecl.h\"\n\nstatic int udf_update_inode(struct inode *, int);\nstatic int udf_sync_inode(struct inode *inode);\n\nstatic int udf_read_extent_cache(struct inode *inode, loff_t bcount,\n\t\t\t\t loff_t *lbcount, struct extent_position *pos)\n{\n\tstruct udf_inode_info *iinfo = UDF_I(inode);\n\tint ret = 0;\n\n\tspin_lock(&iinfo->i_extent_cache_lock);\n\tif ((iinfo->cached_extent.lstart <= bcount) &&\n\t    (iinfo->cached_extent.lstart != -1)) {\n\t\t/* Cache hit */\n\t\t*lbcount = iinfo->cached_extent.lstart;\n\t\tmemcpy(pos, &iinfo->cached_extent.epos,\n\t\t       sizeof(struct extent_position));\n\t\tif (pos->bh)\n\t\t\tget_bh(pos->bh);\n\t\tret = 1;\n\t}\n\tspin_unlock(&iinfo->i_extent_cache_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "UDF_I",
          "args": [
            "inode"
          ],
          "line": 2247
        },
        "resolved": true,
        "details": {
          "function_name": "UDF_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/udf_i.h",
          "lines": "57-60",
          "snippet": "static inline struct udf_inode_info *UDF_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct udf_inode_info, vfs_inode);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline struct udf_inode_info *UDF_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct udf_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/crc-itu-t.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include \"udfdecl.h\"\n\nstatic int udf_update_inode(struct inode *, int);\nstatic int udf_sync_inode(struct inode *inode);\nstatic sector_t inode_getblk(struct inode *, sector_t, int *, int *);\nstatic int8_t udf_insert_aext(struct inode *, struct extent_position,\n\t\t\t      struct kernel_lb_addr, uint32_t);\n\nint8_t inode_bmap(struct inode *inode, sector_t block,\n\t\t  struct extent_position *pos, struct kernel_lb_addr *eloc,\n\t\t  uint32_t *elen, sector_t *offset)\n{\n\tunsigned char blocksize_bits = inode->i_sb->s_blocksize_bits;\n\tloff_t lbcount = 0, bcount =\n\t    (loff_t) block << blocksize_bits;\n\tint8_t etype;\n\tstruct udf_inode_info *iinfo;\n\n\tiinfo = UDF_I(inode);\n\tif (!udf_read_extent_cache(inode, bcount, &lbcount, pos)) {\n\t\tpos->offset = 0;\n\t\tpos->block = iinfo->i_location;\n\t\tpos->bh = NULL;\n\t}\n\t*elen = 0;\n\tdo {\n\t\tetype = udf_next_aext(inode, pos, eloc, elen, 1);\n\t\tif (etype == -1) {\n\t\t\t*offset = (bcount - lbcount) >> blocksize_bits;\n\t\t\tiinfo->i_lenExtents = lbcount;\n\t\t\treturn -1;\n\t\t}\n\t\tlbcount += *elen;\n\t} while (lbcount <= bcount);\n\t/* update extent cache */\n\tudf_update_extent_cache(inode, lbcount - *elen, pos, 1);\n\t*offset = (bcount + *elen - lbcount) >> blocksize_bits;\n\n\treturn etype;\n}"
  },
  {
    "function_name": "udf_delete_aext",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/inode.c",
    "lines": "2154-2235",
    "snippet": "int8_t udf_delete_aext(struct inode *inode, struct extent_position epos,\n\t\t       struct kernel_lb_addr eloc, uint32_t elen)\n{\n\tstruct extent_position oepos;\n\tint adsize;\n\tint8_t etype;\n\tstruct allocExtDesc *aed;\n\tstruct udf_inode_info *iinfo;\n\n\tif (epos.bh) {\n\t\tget_bh(epos.bh);\n\t\tget_bh(epos.bh);\n\t}\n\n\tiinfo = UDF_I(inode);\n\tif (iinfo->i_alloc_type == ICBTAG_FLAG_AD_SHORT)\n\t\tadsize = sizeof(struct short_ad);\n\telse if (iinfo->i_alloc_type == ICBTAG_FLAG_AD_LONG)\n\t\tadsize = sizeof(struct long_ad);\n\telse\n\t\tadsize = 0;\n\n\toepos = epos;\n\tif (udf_next_aext(inode, &epos, &eloc, &elen, 1) == -1)\n\t\treturn -1;\n\n\twhile ((etype = udf_next_aext(inode, &epos, &eloc, &elen, 1)) != -1) {\n\t\tudf_write_aext(inode, &oepos, &eloc, (etype << 30) | elen, 1);\n\t\tif (oepos.bh != epos.bh) {\n\t\t\toepos.block = epos.block;\n\t\t\tbrelse(oepos.bh);\n\t\t\tget_bh(epos.bh);\n\t\t\toepos.bh = epos.bh;\n\t\t\toepos.offset = epos.offset - adsize;\n\t\t}\n\t}\n\tmemset(&eloc, 0x00, sizeof(struct kernel_lb_addr));\n\telen = 0;\n\n\tif (epos.bh != oepos.bh) {\n\t\tudf_free_blocks(inode->i_sb, inode, &epos.block, 0, 1);\n\t\tudf_write_aext(inode, &oepos, &eloc, elen, 1);\n\t\tudf_write_aext(inode, &oepos, &eloc, elen, 1);\n\t\tif (!oepos.bh) {\n\t\t\tiinfo->i_lenAlloc -= (adsize * 2);\n\t\t\tmark_inode_dirty(inode);\n\t\t} else {\n\t\t\taed = (struct allocExtDesc *)oepos.bh->b_data;\n\t\t\tle32_add_cpu(&aed->lengthAllocDescs, -(2 * adsize));\n\t\t\tif (!UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_STRICT) ||\n\t\t\t    UDF_SB(inode->i_sb)->s_udfrev >= 0x0201)\n\t\t\t\tudf_update_tag(oepos.bh->b_data,\n\t\t\t\t\t\toepos.offset - (2 * adsize));\n\t\t\telse\n\t\t\t\tudf_update_tag(oepos.bh->b_data,\n\t\t\t\t\t\tsizeof(struct allocExtDesc));\n\t\t\tmark_buffer_dirty_inode(oepos.bh, inode);\n\t\t}\n\t} else {\n\t\tudf_write_aext(inode, &oepos, &eloc, elen, 1);\n\t\tif (!oepos.bh) {\n\t\t\tiinfo->i_lenAlloc -= adsize;\n\t\t\tmark_inode_dirty(inode);\n\t\t} else {\n\t\t\taed = (struct allocExtDesc *)oepos.bh->b_data;\n\t\t\tle32_add_cpu(&aed->lengthAllocDescs, -adsize);\n\t\t\tif (!UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_STRICT) ||\n\t\t\t    UDF_SB(inode->i_sb)->s_udfrev >= 0x0201)\n\t\t\t\tudf_update_tag(oepos.bh->b_data,\n\t\t\t\t\t\tepos.offset - adsize);\n\t\t\telse\n\t\t\t\tudf_update_tag(oepos.bh->b_data,\n\t\t\t\t\t\tsizeof(struct allocExtDesc));\n\t\t\tmark_buffer_dirty_inode(oepos.bh, inode);\n\t\t}\n\t}\n\n\tbrelse(epos.bh);\n\tbrelse(oepos.bh);\n\n\treturn (elen >> 30);\n}",
    "includes": [
      "#include \"udf_sb.h\"",
      "#include \"udf_i.h\"",
      "#include <linux/aio.h>",
      "#include <linux/mpage.h>",
      "#include <linux/crc-itu-t.h>",
      "#include <linux/slab.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include \"udfdecl.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int udf_update_inode(struct inode *, int);",
      "static int udf_sync_inode(struct inode *inode);",
      "static int8_t udf_insert_aext(struct inode *, struct extent_position,\n\t\t\t      struct kernel_lb_addr, uint32_t);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "oepos.bh"
          ],
          "line": 2232
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_buffer_dirty_inode",
          "args": [
            "oepos.bh",
            "inode"
          ],
          "line": 2227
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_dirty_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "599-617",
          "snippet": "void mark_buffer_dirty_inode(struct buffer_head *bh, struct inode *inode)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tstruct address_space *buffer_mapping = bh->b_page->mapping;\n\n\tmark_buffer_dirty(bh);\n\tif (!mapping->private_data) {\n\t\tmapping->private_data = buffer_mapping;\n\t} else {\n\t\tBUG_ON(mapping->private_data != buffer_mapping);\n\t}\n\tif (!bh->b_assoc_map) {\n\t\tspin_lock(&buffer_mapping->private_lock);\n\t\tlist_move_tail(&bh->b_assoc_buffers,\n\t\t\t\t&mapping->private_list);\n\t\tbh->b_assoc_map = mapping;\n\t\tspin_unlock(&buffer_mapping->private_lock);\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_dirty_inode(struct buffer_head *bh, struct inode *inode)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tstruct address_space *buffer_mapping = bh->b_page->mapping;\n\n\tmark_buffer_dirty(bh);\n\tif (!mapping->private_data) {\n\t\tmapping->private_data = buffer_mapping;\n\t} else {\n\t\tBUG_ON(mapping->private_data != buffer_mapping);\n\t}\n\tif (!bh->b_assoc_map) {\n\t\tspin_lock(&buffer_mapping->private_lock);\n\t\tlist_move_tail(&bh->b_assoc_buffers,\n\t\t\t\t&mapping->private_list);\n\t\tbh->b_assoc_map = mapping;\n\t\tspin_unlock(&buffer_mapping->private_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_update_tag",
          "args": [
            "oepos.bh->b_data",
            "sizeof(struct allocExtDesc)"
          ],
          "line": 2225
        },
        "resolved": true,
        "details": {
          "function_name": "udf_update_tag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/misc.c",
          "lines": "269-277",
          "snippet": "void udf_update_tag(char *data, int length)\n{\n\tstruct tag *tptr = (struct tag *)data;\n\tlength -= sizeof(struct tag);\n\n\ttptr->descCRCLength = cpu_to_le16(length);\n\ttptr->descCRC = cpu_to_le16(crc_itu_t(0, data + sizeof(struct tag), length));\n\ttptr->tagChecksum = udf_tag_checksum(tptr);\n}",
          "includes": [
            "#include \"udf_sb.h\"",
            "#include \"udf_i.h\"",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/crc-itu-t.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include \"udfdecl.h\"\n\nvoid udf_update_tag(char *data, int length)\n{\n\tstruct tag *tptr = (struct tag *)data;\n\tlength -= sizeof(struct tag);\n\n\ttptr->descCRCLength = cpu_to_le16(length);\n\ttptr->descCRC = cpu_to_le16(crc_itu_t(0, data + sizeof(struct tag), length));\n\ttptr->tagChecksum = udf_tag_checksum(tptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "UDF_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 2221
        },
        "resolved": true,
        "details": {
          "function_name": "UDF_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/udf_sb.h",
          "lines": "160-163",
          "snippet": "static inline struct udf_sb_info *UDF_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/bitops.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bitops.h>\n#include <linux/mutex.h>\n\nstatic inline struct udf_sb_info *UDF_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "UDF_QUERY_FLAG",
          "args": [
            "inode->i_sb",
            "UDF_FLAG_STRICT"
          ],
          "line": 2220
        },
        "resolved": true,
        "details": {
          "function_name": "UDF_QUERY_FLAG",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/udf_sb.h",
          "lines": "169-172",
          "snippet": "static inline int UDF_QUERY_FLAG(struct super_block *sb, int flag)\n{\n\treturn test_bit(flag, &UDF_SB(sb)->s_flags);\n}",
          "includes": [
            "#include <linux/bitops.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bitops.h>\n#include <linux/mutex.h>\n\nstatic inline int UDF_QUERY_FLAG(struct super_block *sb, int flag)\n{\n\treturn test_bit(flag, &UDF_SB(sb)->s_flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_add_cpu",
          "args": [
            "&aed->lengthAllocDescs",
            "-adsize"
          ],
          "line": 2219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mark_inode_dirty",
          "args": [
            "inode"
          ],
          "line": 2216
        },
        "resolved": true,
        "details": {
          "function_name": "block_dump___mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1134-1154",
          "snippet": "static noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_write_aext",
          "args": [
            "inode",
            "&oepos",
            "&eloc",
            "elen",
            "1"
          ],
          "line": 2213
        },
        "resolved": true,
        "details": {
          "function_name": "udf_write_aext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/inode.c",
          "lines": "2005-2055",
          "snippet": "void udf_write_aext(struct inode *inode, struct extent_position *epos,\n\t\t    struct kernel_lb_addr *eloc, uint32_t elen, int inc)\n{\n\tint adsize;\n\tuint8_t *ptr;\n\tstruct short_ad *sad;\n\tstruct long_ad *lad;\n\tstruct udf_inode_info *iinfo = UDF_I(inode);\n\n\tif (!epos->bh)\n\t\tptr = iinfo->i_ext.i_data + epos->offset -\n\t\t\tudf_file_entry_alloc_offset(inode) +\n\t\t\tiinfo->i_lenEAttr;\n\telse\n\t\tptr = epos->bh->b_data + epos->offset;\n\n\tswitch (iinfo->i_alloc_type) {\n\tcase ICBTAG_FLAG_AD_SHORT:\n\t\tsad = (struct short_ad *)ptr;\n\t\tsad->extLength = cpu_to_le32(elen);\n\t\tsad->extPosition = cpu_to_le32(eloc->logicalBlockNum);\n\t\tadsize = sizeof(struct short_ad);\n\t\tbreak;\n\tcase ICBTAG_FLAG_AD_LONG:\n\t\tlad = (struct long_ad *)ptr;\n\t\tlad->extLength = cpu_to_le32(elen);\n\t\tlad->extLocation = cpu_to_lelb(*eloc);\n\t\tmemset(lad->impUse, 0x00, sizeof(lad->impUse));\n\t\tadsize = sizeof(struct long_ad);\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\n\tif (epos->bh) {\n\t\tif (!UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_STRICT) ||\n\t\t    UDF_SB(inode->i_sb)->s_udfrev >= 0x0201) {\n\t\t\tstruct allocExtDesc *aed =\n\t\t\t\t(struct allocExtDesc *)epos->bh->b_data;\n\t\t\tudf_update_tag(epos->bh->b_data,\n\t\t\t\t       le32_to_cpu(aed->lengthAllocDescs) +\n\t\t\t\t       sizeof(struct allocExtDesc));\n\t\t}\n\t\tmark_buffer_dirty_inode(epos->bh, inode);\n\t} else {\n\t\tmark_inode_dirty(inode);\n\t}\n\n\tif (inc)\n\t\tepos->offset += adsize;\n}",
          "includes": [
            "#include \"udf_sb.h\"",
            "#include \"udf_i.h\"",
            "#include <linux/aio.h>",
            "#include <linux/mpage.h>",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int udf_update_inode(struct inode *, int);",
            "static int udf_sync_inode(struct inode *inode);",
            "static int8_t udf_insert_aext(struct inode *, struct extent_position,\n\t\t\t      struct kernel_lb_addr, uint32_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/crc-itu-t.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include \"udfdecl.h\"\n\nstatic int udf_update_inode(struct inode *, int);\nstatic int udf_sync_inode(struct inode *inode);\nstatic int8_t udf_insert_aext(struct inode *, struct extent_position,\n\t\t\t      struct kernel_lb_addr, uint32_t);\n\nvoid udf_write_aext(struct inode *inode, struct extent_position *epos,\n\t\t    struct kernel_lb_addr *eloc, uint32_t elen, int inc)\n{\n\tint adsize;\n\tuint8_t *ptr;\n\tstruct short_ad *sad;\n\tstruct long_ad *lad;\n\tstruct udf_inode_info *iinfo = UDF_I(inode);\n\n\tif (!epos->bh)\n\t\tptr = iinfo->i_ext.i_data + epos->offset -\n\t\t\tudf_file_entry_alloc_offset(inode) +\n\t\t\tiinfo->i_lenEAttr;\n\telse\n\t\tptr = epos->bh->b_data + epos->offset;\n\n\tswitch (iinfo->i_alloc_type) {\n\tcase ICBTAG_FLAG_AD_SHORT:\n\t\tsad = (struct short_ad *)ptr;\n\t\tsad->extLength = cpu_to_le32(elen);\n\t\tsad->extPosition = cpu_to_le32(eloc->logicalBlockNum);\n\t\tadsize = sizeof(struct short_ad);\n\t\tbreak;\n\tcase ICBTAG_FLAG_AD_LONG:\n\t\tlad = (struct long_ad *)ptr;\n\t\tlad->extLength = cpu_to_le32(elen);\n\t\tlad->extLocation = cpu_to_lelb(*eloc);\n\t\tmemset(lad->impUse, 0x00, sizeof(lad->impUse));\n\t\tadsize = sizeof(struct long_ad);\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\n\tif (epos->bh) {\n\t\tif (!UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_STRICT) ||\n\t\t    UDF_SB(inode->i_sb)->s_udfrev >= 0x0201) {\n\t\t\tstruct allocExtDesc *aed =\n\t\t\t\t(struct allocExtDesc *)epos->bh->b_data;\n\t\t\tudf_update_tag(epos->bh->b_data,\n\t\t\t\t       le32_to_cpu(aed->lengthAllocDescs) +\n\t\t\t\t       sizeof(struct allocExtDesc));\n\t\t}\n\t\tmark_buffer_dirty_inode(epos->bh, inode);\n\t} else {\n\t\tmark_inode_dirty(inode);\n\t}\n\n\tif (inc)\n\t\tepos->offset += adsize;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_add_cpu",
          "args": [
            "&aed->lengthAllocDescs",
            "-(2 * adsize)"
          ],
          "line": 2202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udf_free_blocks",
          "args": [
            "inode->i_sb",
            "inode",
            "&epos.block",
            "0",
            "1"
          ],
          "line": 2194
        },
        "resolved": true,
        "details": {
          "function_name": "udf_free_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/balloc.c",
          "lines": "732-757",
          "snippet": "void udf_free_blocks(struct super_block *sb, struct inode *inode,\n\t\t     struct kernel_lb_addr *bloc, uint32_t offset,\n\t\t     uint32_t count)\n{\n\tuint16_t partition = bloc->partitionReferenceNum;\n\tstruct udf_part_map *map = &UDF_SB(sb)->s_partmaps[partition];\n\n\tif (map->s_partition_flags & UDF_PART_FLAG_UNALLOC_BITMAP) {\n\t\tudf_bitmap_free_blocks(sb, map->s_uspace.s_bitmap,\n\t\t\t\t       bloc, offset, count);\n\t} else if (map->s_partition_flags & UDF_PART_FLAG_UNALLOC_TABLE) {\n\t\tudf_table_free_blocks(sb, map->s_uspace.s_table,\n\t\t\t\t      bloc, offset, count);\n\t} else if (map->s_partition_flags & UDF_PART_FLAG_FREED_BITMAP) {\n\t\tudf_bitmap_free_blocks(sb, map->s_fspace.s_bitmap,\n\t\t\t\t       bloc, offset, count);\n\t} else if (map->s_partition_flags & UDF_PART_FLAG_FREED_TABLE) {\n\t\tudf_table_free_blocks(sb, map->s_fspace.s_table,\n\t\t\t\t      bloc, offset, count);\n\t}\n\n\tif (inode) {\n\t\tinode_sub_bytes(inode,\n\t\t\t\t((sector_t)count) << sb->s_blocksize_bits);\n\t}\n}",
          "includes": [
            "#include \"udf_sb.h\"",
            "#include \"udf_i.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/buffer_head.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/bitops.h>\n#include <linux/buffer_head.h>\n#include \"udfdecl.h\"\n\nvoid udf_free_blocks(struct super_block *sb, struct inode *inode,\n\t\t     struct kernel_lb_addr *bloc, uint32_t offset,\n\t\t     uint32_t count)\n{\n\tuint16_t partition = bloc->partitionReferenceNum;\n\tstruct udf_part_map *map = &UDF_SB(sb)->s_partmaps[partition];\n\n\tif (map->s_partition_flags & UDF_PART_FLAG_UNALLOC_BITMAP) {\n\t\tudf_bitmap_free_blocks(sb, map->s_uspace.s_bitmap,\n\t\t\t\t       bloc, offset, count);\n\t} else if (map->s_partition_flags & UDF_PART_FLAG_UNALLOC_TABLE) {\n\t\tudf_table_free_blocks(sb, map->s_uspace.s_table,\n\t\t\t\t      bloc, offset, count);\n\t} else if (map->s_partition_flags & UDF_PART_FLAG_FREED_BITMAP) {\n\t\tudf_bitmap_free_blocks(sb, map->s_fspace.s_bitmap,\n\t\t\t\t       bloc, offset, count);\n\t} else if (map->s_partition_flags & UDF_PART_FLAG_FREED_TABLE) {\n\t\tudf_table_free_blocks(sb, map->s_fspace.s_table,\n\t\t\t\t      bloc, offset, count);\n\t}\n\n\tif (inode) {\n\t\tinode_sub_bytes(inode,\n\t\t\t\t((sector_t)count) << sb->s_blocksize_bits);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&eloc",
            "0x00",
            "sizeof(struct kernel_lb_addr)"
          ],
          "line": 2190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_bh",
          "args": [
            "epos.bh"
          ],
          "line": 2185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udf_next_aext",
          "args": [
            "inode",
            "&epos",
            "&eloc",
            "&elen",
            "1"
          ],
          "line": 2180
        },
        "resolved": true,
        "details": {
          "function_name": "udf_next_aext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/inode.c",
          "lines": "2057-2077",
          "snippet": "int8_t udf_next_aext(struct inode *inode, struct extent_position *epos,\n\t\t     struct kernel_lb_addr *eloc, uint32_t *elen, int inc)\n{\n\tint8_t etype;\n\n\twhile ((etype = udf_current_aext(inode, epos, eloc, elen, inc)) ==\n\t       (EXT_NEXT_EXTENT_ALLOCDECS >> 30)) {\n\t\tint block;\n\t\tepos->block = *eloc;\n\t\tepos->offset = sizeof(struct allocExtDesc);\n\t\tbrelse(epos->bh);\n\t\tblock = udf_get_lb_pblock(inode->i_sb, &epos->block, 0);\n\t\tepos->bh = udf_tread(inode->i_sb, block);\n\t\tif (!epos->bh) {\n\t\t\tudf_debug(\"reading block %d failed!\\n\", block);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn etype;\n}",
          "includes": [
            "#include \"udf_sb.h\"",
            "#include \"udf_i.h\"",
            "#include <linux/aio.h>",
            "#include <linux/mpage.h>",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int udf_update_inode(struct inode *, int);",
            "static int udf_sync_inode(struct inode *inode);",
            "static int8_t udf_insert_aext(struct inode *, struct extent_position,\n\t\t\t      struct kernel_lb_addr, uint32_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/crc-itu-t.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include \"udfdecl.h\"\n\nstatic int udf_update_inode(struct inode *, int);\nstatic int udf_sync_inode(struct inode *inode);\nstatic int8_t udf_insert_aext(struct inode *, struct extent_position,\n\t\t\t      struct kernel_lb_addr, uint32_t);\n\nint8_t udf_next_aext(struct inode *inode, struct extent_position *epos,\n\t\t     struct kernel_lb_addr *eloc, uint32_t *elen, int inc)\n{\n\tint8_t etype;\n\n\twhile ((etype = udf_current_aext(inode, epos, eloc, elen, inc)) ==\n\t       (EXT_NEXT_EXTENT_ALLOCDECS >> 30)) {\n\t\tint block;\n\t\tepos->block = *eloc;\n\t\tepos->offset = sizeof(struct allocExtDesc);\n\t\tbrelse(epos->bh);\n\t\tblock = udf_get_lb_pblock(inode->i_sb, &epos->block, 0);\n\t\tepos->bh = udf_tread(inode->i_sb, block);\n\t\tif (!epos->bh) {\n\t\t\tudf_debug(\"reading block %d failed!\\n\", block);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn etype;\n}"
        }
      },
      {
        "call_info": {
          "callee": "UDF_I",
          "args": [
            "inode"
          ],
          "line": 2168
        },
        "resolved": true,
        "details": {
          "function_name": "UDF_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/udf_i.h",
          "lines": "57-60",
          "snippet": "static inline struct udf_inode_info *UDF_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct udf_inode_info, vfs_inode);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline struct udf_inode_info *UDF_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct udf_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_bh",
          "args": [
            "epos.bh"
          ],
          "line": 2165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_bh",
          "args": [
            "epos.bh"
          ],
          "line": 2164
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/crc-itu-t.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include \"udfdecl.h\"\n\nstatic int udf_update_inode(struct inode *, int);\nstatic int udf_sync_inode(struct inode *inode);\nstatic int8_t udf_insert_aext(struct inode *, struct extent_position,\n\t\t\t      struct kernel_lb_addr, uint32_t);\n\nint8_t udf_delete_aext(struct inode *inode, struct extent_position epos,\n\t\t       struct kernel_lb_addr eloc, uint32_t elen)\n{\n\tstruct extent_position oepos;\n\tint adsize;\n\tint8_t etype;\n\tstruct allocExtDesc *aed;\n\tstruct udf_inode_info *iinfo;\n\n\tif (epos.bh) {\n\t\tget_bh(epos.bh);\n\t\tget_bh(epos.bh);\n\t}\n\n\tiinfo = UDF_I(inode);\n\tif (iinfo->i_alloc_type == ICBTAG_FLAG_AD_SHORT)\n\t\tadsize = sizeof(struct short_ad);\n\telse if (iinfo->i_alloc_type == ICBTAG_FLAG_AD_LONG)\n\t\tadsize = sizeof(struct long_ad);\n\telse\n\t\tadsize = 0;\n\n\toepos = epos;\n\tif (udf_next_aext(inode, &epos, &eloc, &elen, 1) == -1)\n\t\treturn -1;\n\n\twhile ((etype = udf_next_aext(inode, &epos, &eloc, &elen, 1)) != -1) {\n\t\tudf_write_aext(inode, &oepos, &eloc, (etype << 30) | elen, 1);\n\t\tif (oepos.bh != epos.bh) {\n\t\t\toepos.block = epos.block;\n\t\t\tbrelse(oepos.bh);\n\t\t\tget_bh(epos.bh);\n\t\t\toepos.bh = epos.bh;\n\t\t\toepos.offset = epos.offset - adsize;\n\t\t}\n\t}\n\tmemset(&eloc, 0x00, sizeof(struct kernel_lb_addr));\n\telen = 0;\n\n\tif (epos.bh != oepos.bh) {\n\t\tudf_free_blocks(inode->i_sb, inode, &epos.block, 0, 1);\n\t\tudf_write_aext(inode, &oepos, &eloc, elen, 1);\n\t\tudf_write_aext(inode, &oepos, &eloc, elen, 1);\n\t\tif (!oepos.bh) {\n\t\t\tiinfo->i_lenAlloc -= (adsize * 2);\n\t\t\tmark_inode_dirty(inode);\n\t\t} else {\n\t\t\taed = (struct allocExtDesc *)oepos.bh->b_data;\n\t\t\tle32_add_cpu(&aed->lengthAllocDescs, -(2 * adsize));\n\t\t\tif (!UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_STRICT) ||\n\t\t\t    UDF_SB(inode->i_sb)->s_udfrev >= 0x0201)\n\t\t\t\tudf_update_tag(oepos.bh->b_data,\n\t\t\t\t\t\toepos.offset - (2 * adsize));\n\t\t\telse\n\t\t\t\tudf_update_tag(oepos.bh->b_data,\n\t\t\t\t\t\tsizeof(struct allocExtDesc));\n\t\t\tmark_buffer_dirty_inode(oepos.bh, inode);\n\t\t}\n\t} else {\n\t\tudf_write_aext(inode, &oepos, &eloc, elen, 1);\n\t\tif (!oepos.bh) {\n\t\t\tiinfo->i_lenAlloc -= adsize;\n\t\t\tmark_inode_dirty(inode);\n\t\t} else {\n\t\t\taed = (struct allocExtDesc *)oepos.bh->b_data;\n\t\t\tle32_add_cpu(&aed->lengthAllocDescs, -adsize);\n\t\t\tif (!UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_STRICT) ||\n\t\t\t    UDF_SB(inode->i_sb)->s_udfrev >= 0x0201)\n\t\t\t\tudf_update_tag(oepos.bh->b_data,\n\t\t\t\t\t\tepos.offset - adsize);\n\t\t\telse\n\t\t\t\tudf_update_tag(oepos.bh->b_data,\n\t\t\t\t\t\tsizeof(struct allocExtDesc));\n\t\t\tmark_buffer_dirty_inode(oepos.bh, inode);\n\t\t}\n\t}\n\n\tbrelse(epos.bh);\n\tbrelse(oepos.bh);\n\n\treturn (elen >> 30);\n}"
  },
  {
    "function_name": "udf_insert_aext",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/inode.c",
    "lines": "2133-2152",
    "snippet": "static int8_t udf_insert_aext(struct inode *inode, struct extent_position epos,\n\t\t\t      struct kernel_lb_addr neloc, uint32_t nelen)\n{\n\tstruct kernel_lb_addr oeloc;\n\tuint32_t oelen;\n\tint8_t etype;\n\n\tif (epos.bh)\n\t\tget_bh(epos.bh);\n\n\twhile ((etype = udf_next_aext(inode, &epos, &oeloc, &oelen, 0)) != -1) {\n\t\tudf_write_aext(inode, &epos, &neloc, nelen, 1);\n\t\tneloc = oeloc;\n\t\tnelen = (etype << 30) | oelen;\n\t}\n\tudf_add_aext(inode, &epos, &neloc, nelen, 1);\n\tbrelse(epos.bh);\n\n\treturn (nelen >> 30);\n}",
    "includes": [
      "#include \"udf_sb.h\"",
      "#include \"udf_i.h\"",
      "#include <linux/aio.h>",
      "#include <linux/mpage.h>",
      "#include <linux/crc-itu-t.h>",
      "#include <linux/slab.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include \"udfdecl.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int udf_update_inode(struct inode *, int);",
      "static int udf_sync_inode(struct inode *inode);",
      "static int8_t udf_insert_aext(struct inode *, struct extent_position,\n\t\t\t      struct kernel_lb_addr, uint32_t);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "epos.bh"
          ],
          "line": 2149
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_add_aext",
          "args": [
            "inode",
            "&epos",
            "&neloc",
            "nelen",
            "1"
          ],
          "line": 2148
        },
        "resolved": true,
        "details": {
          "function_name": "udf_add_aext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/inode.c",
          "lines": "1876-2003",
          "snippet": "int udf_add_aext(struct inode *inode, struct extent_position *epos,\n\t\t struct kernel_lb_addr *eloc, uint32_t elen, int inc)\n{\n\tint adsize;\n\tstruct short_ad *sad = NULL;\n\tstruct long_ad *lad = NULL;\n\tstruct allocExtDesc *aed;\n\tuint8_t *ptr;\n\tstruct udf_inode_info *iinfo = UDF_I(inode);\n\n\tif (!epos->bh)\n\t\tptr = iinfo->i_ext.i_data + epos->offset -\n\t\t\tudf_file_entry_alloc_offset(inode) +\n\t\t\tiinfo->i_lenEAttr;\n\telse\n\t\tptr = epos->bh->b_data + epos->offset;\n\n\tif (iinfo->i_alloc_type == ICBTAG_FLAG_AD_SHORT)\n\t\tadsize = sizeof(struct short_ad);\n\telse if (iinfo->i_alloc_type == ICBTAG_FLAG_AD_LONG)\n\t\tadsize = sizeof(struct long_ad);\n\telse\n\t\treturn -EIO;\n\n\tif (epos->offset + (2 * adsize) > inode->i_sb->s_blocksize) {\n\t\tunsigned char *sptr, *dptr;\n\t\tstruct buffer_head *nbh;\n\t\tint err, loffset;\n\t\tstruct kernel_lb_addr obloc = epos->block;\n\n\t\tepos->block.logicalBlockNum = udf_new_block(inode->i_sb, NULL,\n\t\t\t\t\t\tobloc.partitionReferenceNum,\n\t\t\t\t\t\tobloc.logicalBlockNum, &err);\n\t\tif (!epos->block.logicalBlockNum)\n\t\t\treturn -ENOSPC;\n\t\tnbh = udf_tgetblk(inode->i_sb, udf_get_lb_pblock(inode->i_sb,\n\t\t\t\t\t\t\t\t &epos->block,\n\t\t\t\t\t\t\t\t 0));\n\t\tif (!nbh)\n\t\t\treturn -EIO;\n\t\tlock_buffer(nbh);\n\t\tmemset(nbh->b_data, 0x00, inode->i_sb->s_blocksize);\n\t\tset_buffer_uptodate(nbh);\n\t\tunlock_buffer(nbh);\n\t\tmark_buffer_dirty_inode(nbh, inode);\n\n\t\taed = (struct allocExtDesc *)(nbh->b_data);\n\t\tif (!UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_STRICT))\n\t\t\taed->previousAllocExtLocation =\n\t\t\t\t\tcpu_to_le32(obloc.logicalBlockNum);\n\t\tif (epos->offset + adsize > inode->i_sb->s_blocksize) {\n\t\t\tloffset = epos->offset;\n\t\t\taed->lengthAllocDescs = cpu_to_le32(adsize);\n\t\t\tsptr = ptr - adsize;\n\t\t\tdptr = nbh->b_data + sizeof(struct allocExtDesc);\n\t\t\tmemcpy(dptr, sptr, adsize);\n\t\t\tepos->offset = sizeof(struct allocExtDesc) + adsize;\n\t\t} else {\n\t\t\tloffset = epos->offset + adsize;\n\t\t\taed->lengthAllocDescs = cpu_to_le32(0);\n\t\t\tsptr = ptr;\n\t\t\tepos->offset = sizeof(struct allocExtDesc);\n\n\t\t\tif (epos->bh) {\n\t\t\t\taed = (struct allocExtDesc *)epos->bh->b_data;\n\t\t\t\tle32_add_cpu(&aed->lengthAllocDescs, adsize);\n\t\t\t} else {\n\t\t\t\tiinfo->i_lenAlloc += adsize;\n\t\t\t\tmark_inode_dirty(inode);\n\t\t\t}\n\t\t}\n\t\tif (UDF_SB(inode->i_sb)->s_udfrev >= 0x0200)\n\t\t\tudf_new_tag(nbh->b_data, TAG_IDENT_AED, 3, 1,\n\t\t\t\t    epos->block.logicalBlockNum, sizeof(struct tag));\n\t\telse\n\t\t\tudf_new_tag(nbh->b_data, TAG_IDENT_AED, 2, 1,\n\t\t\t\t    epos->block.logicalBlockNum, sizeof(struct tag));\n\t\tswitch (iinfo->i_alloc_type) {\n\t\tcase ICBTAG_FLAG_AD_SHORT:\n\t\t\tsad = (struct short_ad *)sptr;\n\t\t\tsad->extLength = cpu_to_le32(EXT_NEXT_EXTENT_ALLOCDECS |\n\t\t\t\t\t\t     inode->i_sb->s_blocksize);\n\t\t\tsad->extPosition =\n\t\t\t\tcpu_to_le32(epos->block.logicalBlockNum);\n\t\t\tbreak;\n\t\tcase ICBTAG_FLAG_AD_LONG:\n\t\t\tlad = (struct long_ad *)sptr;\n\t\t\tlad->extLength = cpu_to_le32(EXT_NEXT_EXTENT_ALLOCDECS |\n\t\t\t\t\t\t     inode->i_sb->s_blocksize);\n\t\t\tlad->extLocation = cpu_to_lelb(epos->block);\n\t\t\tmemset(lad->impUse, 0x00, sizeof(lad->impUse));\n\t\t\tbreak;\n\t\t}\n\t\tif (epos->bh) {\n\t\t\tif (!UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_STRICT) ||\n\t\t\t    UDF_SB(inode->i_sb)->s_udfrev >= 0x0201)\n\t\t\t\tudf_update_tag(epos->bh->b_data, loffset);\n\t\t\telse\n\t\t\t\tudf_update_tag(epos->bh->b_data,\n\t\t\t\t\t\tsizeof(struct allocExtDesc));\n\t\t\tmark_buffer_dirty_inode(epos->bh, inode);\n\t\t\tbrelse(epos->bh);\n\t\t} else {\n\t\t\tmark_inode_dirty(inode);\n\t\t}\n\t\tepos->bh = nbh;\n\t}\n\n\tudf_write_aext(inode, epos, eloc, elen, inc);\n\n\tif (!epos->bh) {\n\t\tiinfo->i_lenAlloc += adsize;\n\t\tmark_inode_dirty(inode);\n\t} else {\n\t\taed = (struct allocExtDesc *)epos->bh->b_data;\n\t\tle32_add_cpu(&aed->lengthAllocDescs, adsize);\n\t\tif (!UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_STRICT) ||\n\t\t\t\tUDF_SB(inode->i_sb)->s_udfrev >= 0x0201)\n\t\t\tudf_update_tag(epos->bh->b_data,\n\t\t\t\t\tepos->offset + (inc ? 0 : adsize));\n\t\telse\n\t\t\tudf_update_tag(epos->bh->b_data,\n\t\t\t\t\tsizeof(struct allocExtDesc));\n\t\tmark_buffer_dirty_inode(epos->bh, inode);\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"udf_sb.h\"",
            "#include \"udf_i.h\"",
            "#include <linux/aio.h>",
            "#include <linux/mpage.h>",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int udf_update_inode(struct inode *, int);",
            "static int udf_sync_inode(struct inode *inode);",
            "static int8_t udf_insert_aext(struct inode *, struct extent_position,\n\t\t\t      struct kernel_lb_addr, uint32_t);",
            "static int udf_get_block(struct inode *, sector_t, struct buffer_head *, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/crc-itu-t.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include \"udfdecl.h\"\n\nstatic int udf_update_inode(struct inode *, int);\nstatic int udf_sync_inode(struct inode *inode);\nstatic int8_t udf_insert_aext(struct inode *, struct extent_position,\n\t\t\t      struct kernel_lb_addr, uint32_t);\nstatic int udf_get_block(struct inode *, sector_t, struct buffer_head *, int);\n\nint udf_add_aext(struct inode *inode, struct extent_position *epos,\n\t\t struct kernel_lb_addr *eloc, uint32_t elen, int inc)\n{\n\tint adsize;\n\tstruct short_ad *sad = NULL;\n\tstruct long_ad *lad = NULL;\n\tstruct allocExtDesc *aed;\n\tuint8_t *ptr;\n\tstruct udf_inode_info *iinfo = UDF_I(inode);\n\n\tif (!epos->bh)\n\t\tptr = iinfo->i_ext.i_data + epos->offset -\n\t\t\tudf_file_entry_alloc_offset(inode) +\n\t\t\tiinfo->i_lenEAttr;\n\telse\n\t\tptr = epos->bh->b_data + epos->offset;\n\n\tif (iinfo->i_alloc_type == ICBTAG_FLAG_AD_SHORT)\n\t\tadsize = sizeof(struct short_ad);\n\telse if (iinfo->i_alloc_type == ICBTAG_FLAG_AD_LONG)\n\t\tadsize = sizeof(struct long_ad);\n\telse\n\t\treturn -EIO;\n\n\tif (epos->offset + (2 * adsize) > inode->i_sb->s_blocksize) {\n\t\tunsigned char *sptr, *dptr;\n\t\tstruct buffer_head *nbh;\n\t\tint err, loffset;\n\t\tstruct kernel_lb_addr obloc = epos->block;\n\n\t\tepos->block.logicalBlockNum = udf_new_block(inode->i_sb, NULL,\n\t\t\t\t\t\tobloc.partitionReferenceNum,\n\t\t\t\t\t\tobloc.logicalBlockNum, &err);\n\t\tif (!epos->block.logicalBlockNum)\n\t\t\treturn -ENOSPC;\n\t\tnbh = udf_tgetblk(inode->i_sb, udf_get_lb_pblock(inode->i_sb,\n\t\t\t\t\t\t\t\t &epos->block,\n\t\t\t\t\t\t\t\t 0));\n\t\tif (!nbh)\n\t\t\treturn -EIO;\n\t\tlock_buffer(nbh);\n\t\tmemset(nbh->b_data, 0x00, inode->i_sb->s_blocksize);\n\t\tset_buffer_uptodate(nbh);\n\t\tunlock_buffer(nbh);\n\t\tmark_buffer_dirty_inode(nbh, inode);\n\n\t\taed = (struct allocExtDesc *)(nbh->b_data);\n\t\tif (!UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_STRICT))\n\t\t\taed->previousAllocExtLocation =\n\t\t\t\t\tcpu_to_le32(obloc.logicalBlockNum);\n\t\tif (epos->offset + adsize > inode->i_sb->s_blocksize) {\n\t\t\tloffset = epos->offset;\n\t\t\taed->lengthAllocDescs = cpu_to_le32(adsize);\n\t\t\tsptr = ptr - adsize;\n\t\t\tdptr = nbh->b_data + sizeof(struct allocExtDesc);\n\t\t\tmemcpy(dptr, sptr, adsize);\n\t\t\tepos->offset = sizeof(struct allocExtDesc) + adsize;\n\t\t} else {\n\t\t\tloffset = epos->offset + adsize;\n\t\t\taed->lengthAllocDescs = cpu_to_le32(0);\n\t\t\tsptr = ptr;\n\t\t\tepos->offset = sizeof(struct allocExtDesc);\n\n\t\t\tif (epos->bh) {\n\t\t\t\taed = (struct allocExtDesc *)epos->bh->b_data;\n\t\t\t\tle32_add_cpu(&aed->lengthAllocDescs, adsize);\n\t\t\t} else {\n\t\t\t\tiinfo->i_lenAlloc += adsize;\n\t\t\t\tmark_inode_dirty(inode);\n\t\t\t}\n\t\t}\n\t\tif (UDF_SB(inode->i_sb)->s_udfrev >= 0x0200)\n\t\t\tudf_new_tag(nbh->b_data, TAG_IDENT_AED, 3, 1,\n\t\t\t\t    epos->block.logicalBlockNum, sizeof(struct tag));\n\t\telse\n\t\t\tudf_new_tag(nbh->b_data, TAG_IDENT_AED, 2, 1,\n\t\t\t\t    epos->block.logicalBlockNum, sizeof(struct tag));\n\t\tswitch (iinfo->i_alloc_type) {\n\t\tcase ICBTAG_FLAG_AD_SHORT:\n\t\t\tsad = (struct short_ad *)sptr;\n\t\t\tsad->extLength = cpu_to_le32(EXT_NEXT_EXTENT_ALLOCDECS |\n\t\t\t\t\t\t     inode->i_sb->s_blocksize);\n\t\t\tsad->extPosition =\n\t\t\t\tcpu_to_le32(epos->block.logicalBlockNum);\n\t\t\tbreak;\n\t\tcase ICBTAG_FLAG_AD_LONG:\n\t\t\tlad = (struct long_ad *)sptr;\n\t\t\tlad->extLength = cpu_to_le32(EXT_NEXT_EXTENT_ALLOCDECS |\n\t\t\t\t\t\t     inode->i_sb->s_blocksize);\n\t\t\tlad->extLocation = cpu_to_lelb(epos->block);\n\t\t\tmemset(lad->impUse, 0x00, sizeof(lad->impUse));\n\t\t\tbreak;\n\t\t}\n\t\tif (epos->bh) {\n\t\t\tif (!UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_STRICT) ||\n\t\t\t    UDF_SB(inode->i_sb)->s_udfrev >= 0x0201)\n\t\t\t\tudf_update_tag(epos->bh->b_data, loffset);\n\t\t\telse\n\t\t\t\tudf_update_tag(epos->bh->b_data,\n\t\t\t\t\t\tsizeof(struct allocExtDesc));\n\t\t\tmark_buffer_dirty_inode(epos->bh, inode);\n\t\t\tbrelse(epos->bh);\n\t\t} else {\n\t\t\tmark_inode_dirty(inode);\n\t\t}\n\t\tepos->bh = nbh;\n\t}\n\n\tudf_write_aext(inode, epos, eloc, elen, inc);\n\n\tif (!epos->bh) {\n\t\tiinfo->i_lenAlloc += adsize;\n\t\tmark_inode_dirty(inode);\n\t} else {\n\t\taed = (struct allocExtDesc *)epos->bh->b_data;\n\t\tle32_add_cpu(&aed->lengthAllocDescs, adsize);\n\t\tif (!UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_STRICT) ||\n\t\t\t\tUDF_SB(inode->i_sb)->s_udfrev >= 0x0201)\n\t\t\tudf_update_tag(epos->bh->b_data,\n\t\t\t\t\tepos->offset + (inc ? 0 : adsize));\n\t\telse\n\t\t\tudf_update_tag(epos->bh->b_data,\n\t\t\t\t\tsizeof(struct allocExtDesc));\n\t\tmark_buffer_dirty_inode(epos->bh, inode);\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_write_aext",
          "args": [
            "inode",
            "&epos",
            "&neloc",
            "nelen",
            "1"
          ],
          "line": 2144
        },
        "resolved": true,
        "details": {
          "function_name": "udf_write_aext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/inode.c",
          "lines": "2005-2055",
          "snippet": "void udf_write_aext(struct inode *inode, struct extent_position *epos,\n\t\t    struct kernel_lb_addr *eloc, uint32_t elen, int inc)\n{\n\tint adsize;\n\tuint8_t *ptr;\n\tstruct short_ad *sad;\n\tstruct long_ad *lad;\n\tstruct udf_inode_info *iinfo = UDF_I(inode);\n\n\tif (!epos->bh)\n\t\tptr = iinfo->i_ext.i_data + epos->offset -\n\t\t\tudf_file_entry_alloc_offset(inode) +\n\t\t\tiinfo->i_lenEAttr;\n\telse\n\t\tptr = epos->bh->b_data + epos->offset;\n\n\tswitch (iinfo->i_alloc_type) {\n\tcase ICBTAG_FLAG_AD_SHORT:\n\t\tsad = (struct short_ad *)ptr;\n\t\tsad->extLength = cpu_to_le32(elen);\n\t\tsad->extPosition = cpu_to_le32(eloc->logicalBlockNum);\n\t\tadsize = sizeof(struct short_ad);\n\t\tbreak;\n\tcase ICBTAG_FLAG_AD_LONG:\n\t\tlad = (struct long_ad *)ptr;\n\t\tlad->extLength = cpu_to_le32(elen);\n\t\tlad->extLocation = cpu_to_lelb(*eloc);\n\t\tmemset(lad->impUse, 0x00, sizeof(lad->impUse));\n\t\tadsize = sizeof(struct long_ad);\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\n\tif (epos->bh) {\n\t\tif (!UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_STRICT) ||\n\t\t    UDF_SB(inode->i_sb)->s_udfrev >= 0x0201) {\n\t\t\tstruct allocExtDesc *aed =\n\t\t\t\t(struct allocExtDesc *)epos->bh->b_data;\n\t\t\tudf_update_tag(epos->bh->b_data,\n\t\t\t\t       le32_to_cpu(aed->lengthAllocDescs) +\n\t\t\t\t       sizeof(struct allocExtDesc));\n\t\t}\n\t\tmark_buffer_dirty_inode(epos->bh, inode);\n\t} else {\n\t\tmark_inode_dirty(inode);\n\t}\n\n\tif (inc)\n\t\tepos->offset += adsize;\n}",
          "includes": [
            "#include \"udf_sb.h\"",
            "#include \"udf_i.h\"",
            "#include <linux/aio.h>",
            "#include <linux/mpage.h>",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int udf_update_inode(struct inode *, int);",
            "static int udf_sync_inode(struct inode *inode);",
            "static int8_t udf_insert_aext(struct inode *, struct extent_position,\n\t\t\t      struct kernel_lb_addr, uint32_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/crc-itu-t.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include \"udfdecl.h\"\n\nstatic int udf_update_inode(struct inode *, int);\nstatic int udf_sync_inode(struct inode *inode);\nstatic int8_t udf_insert_aext(struct inode *, struct extent_position,\n\t\t\t      struct kernel_lb_addr, uint32_t);\n\nvoid udf_write_aext(struct inode *inode, struct extent_position *epos,\n\t\t    struct kernel_lb_addr *eloc, uint32_t elen, int inc)\n{\n\tint adsize;\n\tuint8_t *ptr;\n\tstruct short_ad *sad;\n\tstruct long_ad *lad;\n\tstruct udf_inode_info *iinfo = UDF_I(inode);\n\n\tif (!epos->bh)\n\t\tptr = iinfo->i_ext.i_data + epos->offset -\n\t\t\tudf_file_entry_alloc_offset(inode) +\n\t\t\tiinfo->i_lenEAttr;\n\telse\n\t\tptr = epos->bh->b_data + epos->offset;\n\n\tswitch (iinfo->i_alloc_type) {\n\tcase ICBTAG_FLAG_AD_SHORT:\n\t\tsad = (struct short_ad *)ptr;\n\t\tsad->extLength = cpu_to_le32(elen);\n\t\tsad->extPosition = cpu_to_le32(eloc->logicalBlockNum);\n\t\tadsize = sizeof(struct short_ad);\n\t\tbreak;\n\tcase ICBTAG_FLAG_AD_LONG:\n\t\tlad = (struct long_ad *)ptr;\n\t\tlad->extLength = cpu_to_le32(elen);\n\t\tlad->extLocation = cpu_to_lelb(*eloc);\n\t\tmemset(lad->impUse, 0x00, sizeof(lad->impUse));\n\t\tadsize = sizeof(struct long_ad);\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\n\tif (epos->bh) {\n\t\tif (!UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_STRICT) ||\n\t\t    UDF_SB(inode->i_sb)->s_udfrev >= 0x0201) {\n\t\t\tstruct allocExtDesc *aed =\n\t\t\t\t(struct allocExtDesc *)epos->bh->b_data;\n\t\t\tudf_update_tag(epos->bh->b_data,\n\t\t\t\t       le32_to_cpu(aed->lengthAllocDescs) +\n\t\t\t\t       sizeof(struct allocExtDesc));\n\t\t}\n\t\tmark_buffer_dirty_inode(epos->bh, inode);\n\t} else {\n\t\tmark_inode_dirty(inode);\n\t}\n\n\tif (inc)\n\t\tepos->offset += adsize;\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_next_aext",
          "args": [
            "inode",
            "&epos",
            "&oeloc",
            "&oelen",
            "0"
          ],
          "line": 2143
        },
        "resolved": true,
        "details": {
          "function_name": "udf_next_aext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/inode.c",
          "lines": "2057-2077",
          "snippet": "int8_t udf_next_aext(struct inode *inode, struct extent_position *epos,\n\t\t     struct kernel_lb_addr *eloc, uint32_t *elen, int inc)\n{\n\tint8_t etype;\n\n\twhile ((etype = udf_current_aext(inode, epos, eloc, elen, inc)) ==\n\t       (EXT_NEXT_EXTENT_ALLOCDECS >> 30)) {\n\t\tint block;\n\t\tepos->block = *eloc;\n\t\tepos->offset = sizeof(struct allocExtDesc);\n\t\tbrelse(epos->bh);\n\t\tblock = udf_get_lb_pblock(inode->i_sb, &epos->block, 0);\n\t\tepos->bh = udf_tread(inode->i_sb, block);\n\t\tif (!epos->bh) {\n\t\t\tudf_debug(\"reading block %d failed!\\n\", block);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn etype;\n}",
          "includes": [
            "#include \"udf_sb.h\"",
            "#include \"udf_i.h\"",
            "#include <linux/aio.h>",
            "#include <linux/mpage.h>",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int udf_update_inode(struct inode *, int);",
            "static int udf_sync_inode(struct inode *inode);",
            "static int8_t udf_insert_aext(struct inode *, struct extent_position,\n\t\t\t      struct kernel_lb_addr, uint32_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/crc-itu-t.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include \"udfdecl.h\"\n\nstatic int udf_update_inode(struct inode *, int);\nstatic int udf_sync_inode(struct inode *inode);\nstatic int8_t udf_insert_aext(struct inode *, struct extent_position,\n\t\t\t      struct kernel_lb_addr, uint32_t);\n\nint8_t udf_next_aext(struct inode *inode, struct extent_position *epos,\n\t\t     struct kernel_lb_addr *eloc, uint32_t *elen, int inc)\n{\n\tint8_t etype;\n\n\twhile ((etype = udf_current_aext(inode, epos, eloc, elen, inc)) ==\n\t       (EXT_NEXT_EXTENT_ALLOCDECS >> 30)) {\n\t\tint block;\n\t\tepos->block = *eloc;\n\t\tepos->offset = sizeof(struct allocExtDesc);\n\t\tbrelse(epos->bh);\n\t\tblock = udf_get_lb_pblock(inode->i_sb, &epos->block, 0);\n\t\tepos->bh = udf_tread(inode->i_sb, block);\n\t\tif (!epos->bh) {\n\t\t\tudf_debug(\"reading block %d failed!\\n\", block);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn etype;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_bh",
          "args": [
            "epos.bh"
          ],
          "line": 2141
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/crc-itu-t.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include \"udfdecl.h\"\n\nstatic int udf_update_inode(struct inode *, int);\nstatic int udf_sync_inode(struct inode *inode);\nstatic int8_t udf_insert_aext(struct inode *, struct extent_position,\n\t\t\t      struct kernel_lb_addr, uint32_t);\n\nstatic int8_t udf_insert_aext(struct inode *inode, struct extent_position epos,\n\t\t\t      struct kernel_lb_addr neloc, uint32_t nelen)\n{\n\tstruct kernel_lb_addr oeloc;\n\tuint32_t oelen;\n\tint8_t etype;\n\n\tif (epos.bh)\n\t\tget_bh(epos.bh);\n\n\twhile ((etype = udf_next_aext(inode, &epos, &oeloc, &oelen, 0)) != -1) {\n\t\tudf_write_aext(inode, &epos, &neloc, nelen, 1);\n\t\tneloc = oeloc;\n\t\tnelen = (etype << 30) | oelen;\n\t}\n\tudf_add_aext(inode, &epos, &neloc, nelen, 1);\n\tbrelse(epos.bh);\n\n\treturn (nelen >> 30);\n}"
  },
  {
    "function_name": "udf_current_aext",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/inode.c",
    "lines": "2079-2131",
    "snippet": "int8_t udf_current_aext(struct inode *inode, struct extent_position *epos,\n\t\t\tstruct kernel_lb_addr *eloc, uint32_t *elen, int inc)\n{\n\tint alen;\n\tint8_t etype;\n\tuint8_t *ptr;\n\tstruct short_ad *sad;\n\tstruct long_ad *lad;\n\tstruct udf_inode_info *iinfo = UDF_I(inode);\n\n\tif (!epos->bh) {\n\t\tif (!epos->offset)\n\t\t\tepos->offset = udf_file_entry_alloc_offset(inode);\n\t\tptr = iinfo->i_ext.i_data + epos->offset -\n\t\t\tudf_file_entry_alloc_offset(inode) +\n\t\t\tiinfo->i_lenEAttr;\n\t\talen = udf_file_entry_alloc_offset(inode) +\n\t\t\t\t\t\t\tiinfo->i_lenAlloc;\n\t} else {\n\t\tif (!epos->offset)\n\t\t\tepos->offset = sizeof(struct allocExtDesc);\n\t\tptr = epos->bh->b_data + epos->offset;\n\t\talen = sizeof(struct allocExtDesc) +\n\t\t\tle32_to_cpu(((struct allocExtDesc *)epos->bh->b_data)->\n\t\t\t\t\t\t\tlengthAllocDescs);\n\t}\n\n\tswitch (iinfo->i_alloc_type) {\n\tcase ICBTAG_FLAG_AD_SHORT:\n\t\tsad = udf_get_fileshortad(ptr, alen, &epos->offset, inc);\n\t\tif (!sad)\n\t\t\treturn -1;\n\t\tetype = le32_to_cpu(sad->extLength) >> 30;\n\t\teloc->logicalBlockNum = le32_to_cpu(sad->extPosition);\n\t\teloc->partitionReferenceNum =\n\t\t\t\tiinfo->i_location.partitionReferenceNum;\n\t\t*elen = le32_to_cpu(sad->extLength) & UDF_EXTENT_LENGTH_MASK;\n\t\tbreak;\n\tcase ICBTAG_FLAG_AD_LONG:\n\t\tlad = udf_get_filelongad(ptr, alen, &epos->offset, inc);\n\t\tif (!lad)\n\t\t\treturn -1;\n\t\tetype = le32_to_cpu(lad->extLength) >> 30;\n\t\t*eloc = lelb_to_cpu(lad->extLocation);\n\t\t*elen = le32_to_cpu(lad->extLength) & UDF_EXTENT_LENGTH_MASK;\n\t\tbreak;\n\tdefault:\n\t\tudf_debug(\"alloc_type = %d unsupported\\n\", iinfo->i_alloc_type);\n\t\treturn -1;\n\t}\n\n\treturn etype;\n}",
    "includes": [
      "#include \"udf_sb.h\"",
      "#include \"udf_i.h\"",
      "#include <linux/aio.h>",
      "#include <linux/mpage.h>",
      "#include <linux/crc-itu-t.h>",
      "#include <linux/slab.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include \"udfdecl.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int udf_update_inode(struct inode *, int);",
      "static int udf_sync_inode(struct inode *inode);",
      "static int8_t udf_insert_aext(struct inode *, struct extent_position,\n\t\t\t      struct kernel_lb_addr, uint32_t);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "udf_debug",
          "args": [
            "\"alloc_type = %d unsupported\\n\"",
            "iinfo->i_alloc_type"
          ],
          "line": 2126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "lad->extLength"
          ],
          "line": 2123
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lelb_to_cpu",
          "args": [
            "lad->extLocation"
          ],
          "line": 2122
        },
        "resolved": true,
        "details": {
          "function_name": "lelb_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/udfend.h",
          "lines": "7-15",
          "snippet": "static inline struct kernel_lb_addr lelb_to_cpu(struct lb_addr in)\n{\n\tstruct kernel_lb_addr out;\n\n\tout.logicalBlockNum = le32_to_cpu(in.logicalBlockNum);\n\tout.partitionReferenceNum = le16_to_cpu(in.partitionReferenceNum);\n\n\treturn out;\n}",
          "includes": [
            "#include <linux/string.h>",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/string.h>\n#include <asm/byteorder.h>\n\nstatic inline struct kernel_lb_addr lelb_to_cpu(struct lb_addr in)\n{\n\tstruct kernel_lb_addr out;\n\n\tout.logicalBlockNum = le32_to_cpu(in.logicalBlockNum);\n\tout.partitionReferenceNum = le16_to_cpu(in.partitionReferenceNum);\n\n\treturn out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_get_filelongad",
          "args": [
            "ptr",
            "alen",
            "&epos->offset",
            "inc"
          ],
          "line": 2118
        },
        "resolved": true,
        "details": {
          "function_name": "udf_get_filelongad",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/directory.c",
          "lines": "221-241",
          "snippet": "struct long_ad *udf_get_filelongad(uint8_t *ptr, int maxoffset, uint32_t *offset, int inc)\n{\n\tstruct long_ad *la;\n\n\tif ((!ptr) || (!offset)) {\n\t\tpr_err(\"%s: invalidparms\\n\", __func__);\n\t\treturn NULL;\n\t}\n\n\tif ((*offset + sizeof(struct long_ad)) > maxoffset)\n\t\treturn NULL;\n\telse {\n\t\tla = (struct long_ad *)ptr;\n\t\tif (la->extLength == 0)\n\t\t\treturn NULL;\n\t}\n\n\tif (inc)\n\t\t*offset += sizeof(struct long_ad);\n\treturn la;\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>",
            "#include \"udf_i.h\"",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include \"udf_i.h\"\n#include \"udfdecl.h\"\n\nstruct long_ad *udf_get_filelongad(uint8_t *ptr, int maxoffset, uint32_t *offset, int inc)\n{\n\tstruct long_ad *la;\n\n\tif ((!ptr) || (!offset)) {\n\t\tpr_err(\"%s: invalidparms\\n\", __func__);\n\t\treturn NULL;\n\t}\n\n\tif ((*offset + sizeof(struct long_ad)) > maxoffset)\n\t\treturn NULL;\n\telse {\n\t\tla = (struct long_ad *)ptr;\n\t\tif (la->extLength == 0)\n\t\t\treturn NULL;\n\t}\n\n\tif (inc)\n\t\t*offset += sizeof(struct long_ad);\n\treturn la;\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_get_fileshortad",
          "args": [
            "ptr",
            "alen",
            "&epos->offset",
            "inc"
          ],
          "line": 2108
        },
        "resolved": true,
        "details": {
          "function_name": "udf_get_fileshortad",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/directory.c",
          "lines": "198-219",
          "snippet": "struct short_ad *udf_get_fileshortad(uint8_t *ptr, int maxoffset, uint32_t *offset,\n\t\t\t      int inc)\n{\n\tstruct short_ad *sa;\n\n\tif ((!ptr) || (!offset)) {\n\t\tpr_err(\"%s: invalidparms\\n\", __func__);\n\t\treturn NULL;\n\t}\n\n\tif ((*offset + sizeof(struct short_ad)) > maxoffset)\n\t\treturn NULL;\n\telse {\n\t\tsa = (struct short_ad *)ptr;\n\t\tif (sa->extLength == 0)\n\t\t\treturn NULL;\n\t}\n\n\tif (inc)\n\t\t*offset += sizeof(struct short_ad);\n\treturn sa;\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>",
            "#include \"udf_i.h\"",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include \"udf_i.h\"\n#include \"udfdecl.h\"\n\nstruct short_ad *udf_get_fileshortad(uint8_t *ptr, int maxoffset, uint32_t *offset,\n\t\t\t      int inc)\n{\n\tstruct short_ad *sa;\n\n\tif ((!ptr) || (!offset)) {\n\t\tpr_err(\"%s: invalidparms\\n\", __func__);\n\t\treturn NULL;\n\t}\n\n\tif ((*offset + sizeof(struct short_ad)) > maxoffset)\n\t\treturn NULL;\n\telse {\n\t\tsa = (struct short_ad *)ptr;\n\t\tif (sa->extLength == 0)\n\t\t\treturn NULL;\n\t}\n\n\tif (inc)\n\t\t*offset += sizeof(struct short_ad);\n\treturn sa;\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_file_entry_alloc_offset",
          "args": [
            "inode"
          ],
          "line": 2095
        },
        "resolved": true,
        "details": {
          "function_name": "udf_file_entry_alloc_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/udfdecl.h",
          "lines": "55-64",
          "snippet": "static inline size_t udf_file_entry_alloc_offset(struct inode *inode)\n{\n\tstruct udf_inode_info *iinfo = UDF_I(inode);\n\tif (iinfo->i_use)\n\t\treturn sizeof(struct unallocSpaceEntry);\n\telse if (iinfo->i_efe)\n\t\treturn sizeof(struct extendedFileEntry) + iinfo->i_lenEAttr;\n\telse\n\t\treturn sizeof(struct fileEntry) + iinfo->i_lenEAttr;\n}",
          "includes": [
            "#include \"udf_i.h\"",
            "#include \"udfend.h\"",
            "#include \"udf_sb.h\"",
            "#include <linux/udf_fs_i.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include \"osta_udf.h\"",
            "#include \"ecma_167.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_i.h\"\n#include \"udfend.h\"\n#include \"udf_sb.h\"\n#include <linux/udf_fs_i.h>\n#include <linux/buffer_head.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include \"osta_udf.h\"\n#include \"ecma_167.h\"\n\nstatic inline size_t udf_file_entry_alloc_offset(struct inode *inode)\n{\n\tstruct udf_inode_info *iinfo = UDF_I(inode);\n\tif (iinfo->i_use)\n\t\treturn sizeof(struct unallocSpaceEntry);\n\telse if (iinfo->i_efe)\n\t\treturn sizeof(struct extendedFileEntry) + iinfo->i_lenEAttr;\n\telse\n\t\treturn sizeof(struct fileEntry) + iinfo->i_lenEAttr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "UDF_I",
          "args": [
            "inode"
          ],
          "line": 2087
        },
        "resolved": true,
        "details": {
          "function_name": "UDF_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/udf_i.h",
          "lines": "57-60",
          "snippet": "static inline struct udf_inode_info *UDF_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct udf_inode_info, vfs_inode);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline struct udf_inode_info *UDF_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct udf_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/crc-itu-t.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include \"udfdecl.h\"\n\nstatic int udf_update_inode(struct inode *, int);\nstatic int udf_sync_inode(struct inode *inode);\nstatic int8_t udf_insert_aext(struct inode *, struct extent_position,\n\t\t\t      struct kernel_lb_addr, uint32_t);\n\nint8_t udf_current_aext(struct inode *inode, struct extent_position *epos,\n\t\t\tstruct kernel_lb_addr *eloc, uint32_t *elen, int inc)\n{\n\tint alen;\n\tint8_t etype;\n\tuint8_t *ptr;\n\tstruct short_ad *sad;\n\tstruct long_ad *lad;\n\tstruct udf_inode_info *iinfo = UDF_I(inode);\n\n\tif (!epos->bh) {\n\t\tif (!epos->offset)\n\t\t\tepos->offset = udf_file_entry_alloc_offset(inode);\n\t\tptr = iinfo->i_ext.i_data + epos->offset -\n\t\t\tudf_file_entry_alloc_offset(inode) +\n\t\t\tiinfo->i_lenEAttr;\n\t\talen = udf_file_entry_alloc_offset(inode) +\n\t\t\t\t\t\t\tiinfo->i_lenAlloc;\n\t} else {\n\t\tif (!epos->offset)\n\t\t\tepos->offset = sizeof(struct allocExtDesc);\n\t\tptr = epos->bh->b_data + epos->offset;\n\t\talen = sizeof(struct allocExtDesc) +\n\t\t\tle32_to_cpu(((struct allocExtDesc *)epos->bh->b_data)->\n\t\t\t\t\t\t\tlengthAllocDescs);\n\t}\n\n\tswitch (iinfo->i_alloc_type) {\n\tcase ICBTAG_FLAG_AD_SHORT:\n\t\tsad = udf_get_fileshortad(ptr, alen, &epos->offset, inc);\n\t\tif (!sad)\n\t\t\treturn -1;\n\t\tetype = le32_to_cpu(sad->extLength) >> 30;\n\t\teloc->logicalBlockNum = le32_to_cpu(sad->extPosition);\n\t\teloc->partitionReferenceNum =\n\t\t\t\tiinfo->i_location.partitionReferenceNum;\n\t\t*elen = le32_to_cpu(sad->extLength) & UDF_EXTENT_LENGTH_MASK;\n\t\tbreak;\n\tcase ICBTAG_FLAG_AD_LONG:\n\t\tlad = udf_get_filelongad(ptr, alen, &epos->offset, inc);\n\t\tif (!lad)\n\t\t\treturn -1;\n\t\tetype = le32_to_cpu(lad->extLength) >> 30;\n\t\t*eloc = lelb_to_cpu(lad->extLocation);\n\t\t*elen = le32_to_cpu(lad->extLength) & UDF_EXTENT_LENGTH_MASK;\n\t\tbreak;\n\tdefault:\n\t\tudf_debug(\"alloc_type = %d unsupported\\n\", iinfo->i_alloc_type);\n\t\treturn -1;\n\t}\n\n\treturn etype;\n}"
  },
  {
    "function_name": "udf_next_aext",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/inode.c",
    "lines": "2057-2077",
    "snippet": "int8_t udf_next_aext(struct inode *inode, struct extent_position *epos,\n\t\t     struct kernel_lb_addr *eloc, uint32_t *elen, int inc)\n{\n\tint8_t etype;\n\n\twhile ((etype = udf_current_aext(inode, epos, eloc, elen, inc)) ==\n\t       (EXT_NEXT_EXTENT_ALLOCDECS >> 30)) {\n\t\tint block;\n\t\tepos->block = *eloc;\n\t\tepos->offset = sizeof(struct allocExtDesc);\n\t\tbrelse(epos->bh);\n\t\tblock = udf_get_lb_pblock(inode->i_sb, &epos->block, 0);\n\t\tepos->bh = udf_tread(inode->i_sb, block);\n\t\tif (!epos->bh) {\n\t\t\tudf_debug(\"reading block %d failed!\\n\", block);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn etype;\n}",
    "includes": [
      "#include \"udf_sb.h\"",
      "#include \"udf_i.h\"",
      "#include <linux/aio.h>",
      "#include <linux/mpage.h>",
      "#include <linux/crc-itu-t.h>",
      "#include <linux/slab.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include \"udfdecl.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int udf_update_inode(struct inode *, int);",
      "static int udf_sync_inode(struct inode *inode);",
      "static int8_t udf_insert_aext(struct inode *, struct extent_position,\n\t\t\t      struct kernel_lb_addr, uint32_t);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "udf_debug",
          "args": [
            "\"reading block %d failed!\\n\"",
            "block"
          ],
          "line": 2071
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udf_tread",
          "args": [
            "inode->i_sb",
            "block"
          ],
          "line": 2069
        },
        "resolved": true,
        "details": {
          "function_name": "udf_tread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/misc.c",
          "lines": "40-46",
          "snippet": "struct buffer_head *udf_tread(struct super_block *sb, int block)\n{\n\tif (UDF_QUERY_FLAG(sb, UDF_FLAG_VARCONV))\n\t\treturn sb_bread(sb, udf_fixed_to_variable(block));\n\telse\n\t\treturn sb_bread(sb, block);\n}",
          "includes": [
            "#include \"udf_sb.h\"",
            "#include \"udf_i.h\"",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/crc-itu-t.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include \"udfdecl.h\"\n\nstruct buffer_head *udf_tread(struct super_block *sb, int block)\n{\n\tif (UDF_QUERY_FLAG(sb, UDF_FLAG_VARCONV))\n\t\treturn sb_bread(sb, udf_fixed_to_variable(block));\n\telse\n\t\treturn sb_bread(sb, block);\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_get_lb_pblock",
          "args": [
            "inode->i_sb",
            "&epos->block",
            "0"
          ],
          "line": 2068
        },
        "resolved": true,
        "details": {
          "function_name": "udf_get_lb_pblock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/udfdecl.h",
          "lines": "205-211",
          "snippet": "static inline uint32_t\nudf_get_lb_pblock(struct super_block *sb, struct kernel_lb_addr *loc,\n\t\t  uint32_t offset)\n{\n\treturn udf_get_pblock(sb, loc->logicalBlockNum,\n\t\t\tloc->partitionReferenceNum, offset);\n}",
          "includes": [
            "#include \"udf_i.h\"",
            "#include \"udfend.h\"",
            "#include \"udf_sb.h\"",
            "#include <linux/udf_fs_i.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include \"osta_udf.h\"",
            "#include \"ecma_167.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_i.h\"\n#include \"udfend.h\"\n#include \"udf_sb.h\"\n#include <linux/udf_fs_i.h>\n#include <linux/buffer_head.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include \"osta_udf.h\"\n#include \"ecma_167.h\"\n\nstatic inline uint32_t\nudf_get_lb_pblock(struct super_block *sb, struct kernel_lb_addr *loc,\n\t\t  uint32_t offset)\n{\n\treturn udf_get_pblock(sb, loc->logicalBlockNum,\n\t\t\tloc->partitionReferenceNum, offset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "epos->bh"
          ],
          "line": 2067
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_current_aext",
          "args": [
            "inode",
            "epos",
            "eloc",
            "elen",
            "inc"
          ],
          "line": 2062
        },
        "resolved": true,
        "details": {
          "function_name": "udf_current_aext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/inode.c",
          "lines": "2079-2131",
          "snippet": "int8_t udf_current_aext(struct inode *inode, struct extent_position *epos,\n\t\t\tstruct kernel_lb_addr *eloc, uint32_t *elen, int inc)\n{\n\tint alen;\n\tint8_t etype;\n\tuint8_t *ptr;\n\tstruct short_ad *sad;\n\tstruct long_ad *lad;\n\tstruct udf_inode_info *iinfo = UDF_I(inode);\n\n\tif (!epos->bh) {\n\t\tif (!epos->offset)\n\t\t\tepos->offset = udf_file_entry_alloc_offset(inode);\n\t\tptr = iinfo->i_ext.i_data + epos->offset -\n\t\t\tudf_file_entry_alloc_offset(inode) +\n\t\t\tiinfo->i_lenEAttr;\n\t\talen = udf_file_entry_alloc_offset(inode) +\n\t\t\t\t\t\t\tiinfo->i_lenAlloc;\n\t} else {\n\t\tif (!epos->offset)\n\t\t\tepos->offset = sizeof(struct allocExtDesc);\n\t\tptr = epos->bh->b_data + epos->offset;\n\t\talen = sizeof(struct allocExtDesc) +\n\t\t\tle32_to_cpu(((struct allocExtDesc *)epos->bh->b_data)->\n\t\t\t\t\t\t\tlengthAllocDescs);\n\t}\n\n\tswitch (iinfo->i_alloc_type) {\n\tcase ICBTAG_FLAG_AD_SHORT:\n\t\tsad = udf_get_fileshortad(ptr, alen, &epos->offset, inc);\n\t\tif (!sad)\n\t\t\treturn -1;\n\t\tetype = le32_to_cpu(sad->extLength) >> 30;\n\t\teloc->logicalBlockNum = le32_to_cpu(sad->extPosition);\n\t\teloc->partitionReferenceNum =\n\t\t\t\tiinfo->i_location.partitionReferenceNum;\n\t\t*elen = le32_to_cpu(sad->extLength) & UDF_EXTENT_LENGTH_MASK;\n\t\tbreak;\n\tcase ICBTAG_FLAG_AD_LONG:\n\t\tlad = udf_get_filelongad(ptr, alen, &epos->offset, inc);\n\t\tif (!lad)\n\t\t\treturn -1;\n\t\tetype = le32_to_cpu(lad->extLength) >> 30;\n\t\t*eloc = lelb_to_cpu(lad->extLocation);\n\t\t*elen = le32_to_cpu(lad->extLength) & UDF_EXTENT_LENGTH_MASK;\n\t\tbreak;\n\tdefault:\n\t\tudf_debug(\"alloc_type = %d unsupported\\n\", iinfo->i_alloc_type);\n\t\treturn -1;\n\t}\n\n\treturn etype;\n}",
          "includes": [
            "#include \"udf_sb.h\"",
            "#include \"udf_i.h\"",
            "#include <linux/aio.h>",
            "#include <linux/mpage.h>",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int udf_update_inode(struct inode *, int);",
            "static int udf_sync_inode(struct inode *inode);",
            "static int8_t udf_insert_aext(struct inode *, struct extent_position,\n\t\t\t      struct kernel_lb_addr, uint32_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/crc-itu-t.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include \"udfdecl.h\"\n\nstatic int udf_update_inode(struct inode *, int);\nstatic int udf_sync_inode(struct inode *inode);\nstatic int8_t udf_insert_aext(struct inode *, struct extent_position,\n\t\t\t      struct kernel_lb_addr, uint32_t);\n\nint8_t udf_current_aext(struct inode *inode, struct extent_position *epos,\n\t\t\tstruct kernel_lb_addr *eloc, uint32_t *elen, int inc)\n{\n\tint alen;\n\tint8_t etype;\n\tuint8_t *ptr;\n\tstruct short_ad *sad;\n\tstruct long_ad *lad;\n\tstruct udf_inode_info *iinfo = UDF_I(inode);\n\n\tif (!epos->bh) {\n\t\tif (!epos->offset)\n\t\t\tepos->offset = udf_file_entry_alloc_offset(inode);\n\t\tptr = iinfo->i_ext.i_data + epos->offset -\n\t\t\tudf_file_entry_alloc_offset(inode) +\n\t\t\tiinfo->i_lenEAttr;\n\t\talen = udf_file_entry_alloc_offset(inode) +\n\t\t\t\t\t\t\tiinfo->i_lenAlloc;\n\t} else {\n\t\tif (!epos->offset)\n\t\t\tepos->offset = sizeof(struct allocExtDesc);\n\t\tptr = epos->bh->b_data + epos->offset;\n\t\talen = sizeof(struct allocExtDesc) +\n\t\t\tle32_to_cpu(((struct allocExtDesc *)epos->bh->b_data)->\n\t\t\t\t\t\t\tlengthAllocDescs);\n\t}\n\n\tswitch (iinfo->i_alloc_type) {\n\tcase ICBTAG_FLAG_AD_SHORT:\n\t\tsad = udf_get_fileshortad(ptr, alen, &epos->offset, inc);\n\t\tif (!sad)\n\t\t\treturn -1;\n\t\tetype = le32_to_cpu(sad->extLength) >> 30;\n\t\teloc->logicalBlockNum = le32_to_cpu(sad->extPosition);\n\t\teloc->partitionReferenceNum =\n\t\t\t\tiinfo->i_location.partitionReferenceNum;\n\t\t*elen = le32_to_cpu(sad->extLength) & UDF_EXTENT_LENGTH_MASK;\n\t\tbreak;\n\tcase ICBTAG_FLAG_AD_LONG:\n\t\tlad = udf_get_filelongad(ptr, alen, &epos->offset, inc);\n\t\tif (!lad)\n\t\t\treturn -1;\n\t\tetype = le32_to_cpu(lad->extLength) >> 30;\n\t\t*eloc = lelb_to_cpu(lad->extLocation);\n\t\t*elen = le32_to_cpu(lad->extLength) & UDF_EXTENT_LENGTH_MASK;\n\t\tbreak;\n\tdefault:\n\t\tudf_debug(\"alloc_type = %d unsupported\\n\", iinfo->i_alloc_type);\n\t\treturn -1;\n\t}\n\n\treturn etype;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/crc-itu-t.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include \"udfdecl.h\"\n\nstatic int udf_update_inode(struct inode *, int);\nstatic int udf_sync_inode(struct inode *inode);\nstatic int8_t udf_insert_aext(struct inode *, struct extent_position,\n\t\t\t      struct kernel_lb_addr, uint32_t);\n\nint8_t udf_next_aext(struct inode *inode, struct extent_position *epos,\n\t\t     struct kernel_lb_addr *eloc, uint32_t *elen, int inc)\n{\n\tint8_t etype;\n\n\twhile ((etype = udf_current_aext(inode, epos, eloc, elen, inc)) ==\n\t       (EXT_NEXT_EXTENT_ALLOCDECS >> 30)) {\n\t\tint block;\n\t\tepos->block = *eloc;\n\t\tepos->offset = sizeof(struct allocExtDesc);\n\t\tbrelse(epos->bh);\n\t\tblock = udf_get_lb_pblock(inode->i_sb, &epos->block, 0);\n\t\tepos->bh = udf_tread(inode->i_sb, block);\n\t\tif (!epos->bh) {\n\t\t\tudf_debug(\"reading block %d failed!\\n\", block);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn etype;\n}"
  },
  {
    "function_name": "udf_write_aext",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/inode.c",
    "lines": "2005-2055",
    "snippet": "void udf_write_aext(struct inode *inode, struct extent_position *epos,\n\t\t    struct kernel_lb_addr *eloc, uint32_t elen, int inc)\n{\n\tint adsize;\n\tuint8_t *ptr;\n\tstruct short_ad *sad;\n\tstruct long_ad *lad;\n\tstruct udf_inode_info *iinfo = UDF_I(inode);\n\n\tif (!epos->bh)\n\t\tptr = iinfo->i_ext.i_data + epos->offset -\n\t\t\tudf_file_entry_alloc_offset(inode) +\n\t\t\tiinfo->i_lenEAttr;\n\telse\n\t\tptr = epos->bh->b_data + epos->offset;\n\n\tswitch (iinfo->i_alloc_type) {\n\tcase ICBTAG_FLAG_AD_SHORT:\n\t\tsad = (struct short_ad *)ptr;\n\t\tsad->extLength = cpu_to_le32(elen);\n\t\tsad->extPosition = cpu_to_le32(eloc->logicalBlockNum);\n\t\tadsize = sizeof(struct short_ad);\n\t\tbreak;\n\tcase ICBTAG_FLAG_AD_LONG:\n\t\tlad = (struct long_ad *)ptr;\n\t\tlad->extLength = cpu_to_le32(elen);\n\t\tlad->extLocation = cpu_to_lelb(*eloc);\n\t\tmemset(lad->impUse, 0x00, sizeof(lad->impUse));\n\t\tadsize = sizeof(struct long_ad);\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\n\tif (epos->bh) {\n\t\tif (!UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_STRICT) ||\n\t\t    UDF_SB(inode->i_sb)->s_udfrev >= 0x0201) {\n\t\t\tstruct allocExtDesc *aed =\n\t\t\t\t(struct allocExtDesc *)epos->bh->b_data;\n\t\t\tudf_update_tag(epos->bh->b_data,\n\t\t\t\t       le32_to_cpu(aed->lengthAllocDescs) +\n\t\t\t\t       sizeof(struct allocExtDesc));\n\t\t}\n\t\tmark_buffer_dirty_inode(epos->bh, inode);\n\t} else {\n\t\tmark_inode_dirty(inode);\n\t}\n\n\tif (inc)\n\t\tepos->offset += adsize;\n}",
    "includes": [
      "#include \"udf_sb.h\"",
      "#include \"udf_i.h\"",
      "#include <linux/aio.h>",
      "#include <linux/mpage.h>",
      "#include <linux/crc-itu-t.h>",
      "#include <linux/slab.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include \"udfdecl.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int udf_update_inode(struct inode *, int);",
      "static int udf_sync_inode(struct inode *inode);",
      "static int8_t udf_insert_aext(struct inode *, struct extent_position,\n\t\t\t      struct kernel_lb_addr, uint32_t);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mark_inode_dirty",
          "args": [
            "inode"
          ],
          "line": 2050
        },
        "resolved": true,
        "details": {
          "function_name": "block_dump___mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1134-1154",
          "snippet": "static noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_buffer_dirty_inode",
          "args": [
            "epos->bh",
            "inode"
          ],
          "line": 2048
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_dirty_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "599-617",
          "snippet": "void mark_buffer_dirty_inode(struct buffer_head *bh, struct inode *inode)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tstruct address_space *buffer_mapping = bh->b_page->mapping;\n\n\tmark_buffer_dirty(bh);\n\tif (!mapping->private_data) {\n\t\tmapping->private_data = buffer_mapping;\n\t} else {\n\t\tBUG_ON(mapping->private_data != buffer_mapping);\n\t}\n\tif (!bh->b_assoc_map) {\n\t\tspin_lock(&buffer_mapping->private_lock);\n\t\tlist_move_tail(&bh->b_assoc_buffers,\n\t\t\t\t&mapping->private_list);\n\t\tbh->b_assoc_map = mapping;\n\t\tspin_unlock(&buffer_mapping->private_lock);\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_dirty_inode(struct buffer_head *bh, struct inode *inode)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tstruct address_space *buffer_mapping = bh->b_page->mapping;\n\n\tmark_buffer_dirty(bh);\n\tif (!mapping->private_data) {\n\t\tmapping->private_data = buffer_mapping;\n\t} else {\n\t\tBUG_ON(mapping->private_data != buffer_mapping);\n\t}\n\tif (!bh->b_assoc_map) {\n\t\tspin_lock(&buffer_mapping->private_lock);\n\t\tlist_move_tail(&bh->b_assoc_buffers,\n\t\t\t\t&mapping->private_list);\n\t\tbh->b_assoc_map = mapping;\n\t\tspin_unlock(&buffer_mapping->private_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_update_tag",
          "args": [
            "epos->bh->b_data",
            "le32_to_cpu(aed->lengthAllocDescs) +\n\t\t\t\t       sizeof(struct allocExtDesc)"
          ],
          "line": 2044
        },
        "resolved": true,
        "details": {
          "function_name": "udf_update_tag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/misc.c",
          "lines": "269-277",
          "snippet": "void udf_update_tag(char *data, int length)\n{\n\tstruct tag *tptr = (struct tag *)data;\n\tlength -= sizeof(struct tag);\n\n\ttptr->descCRCLength = cpu_to_le16(length);\n\ttptr->descCRC = cpu_to_le16(crc_itu_t(0, data + sizeof(struct tag), length));\n\ttptr->tagChecksum = udf_tag_checksum(tptr);\n}",
          "includes": [
            "#include \"udf_sb.h\"",
            "#include \"udf_i.h\"",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/crc-itu-t.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include \"udfdecl.h\"\n\nvoid udf_update_tag(char *data, int length)\n{\n\tstruct tag *tptr = (struct tag *)data;\n\tlength -= sizeof(struct tag);\n\n\ttptr->descCRCLength = cpu_to_le16(length);\n\ttptr->descCRC = cpu_to_le16(crc_itu_t(0, data + sizeof(struct tag), length));\n\ttptr->tagChecksum = udf_tag_checksum(tptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "aed->lengthAllocDescs"
          ],
          "line": 2045
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "UDF_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 2041
        },
        "resolved": true,
        "details": {
          "function_name": "UDF_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/udf_sb.h",
          "lines": "160-163",
          "snippet": "static inline struct udf_sb_info *UDF_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/bitops.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bitops.h>\n#include <linux/mutex.h>\n\nstatic inline struct udf_sb_info *UDF_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "UDF_QUERY_FLAG",
          "args": [
            "inode->i_sb",
            "UDF_FLAG_STRICT"
          ],
          "line": 2040
        },
        "resolved": true,
        "details": {
          "function_name": "UDF_QUERY_FLAG",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/udf_sb.h",
          "lines": "169-172",
          "snippet": "static inline int UDF_QUERY_FLAG(struct super_block *sb, int flag)\n{\n\treturn test_bit(flag, &UDF_SB(sb)->s_flags);\n}",
          "includes": [
            "#include <linux/bitops.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bitops.h>\n#include <linux/mutex.h>\n\nstatic inline int UDF_QUERY_FLAG(struct super_block *sb, int flag)\n{\n\treturn test_bit(flag, &UDF_SB(sb)->s_flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "lad->impUse",
            "0x00",
            "sizeof(lad->impUse)"
          ],
          "line": 2032
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_lelb",
          "args": [
            "*eloc"
          ],
          "line": 2031
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_to_lelb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/udfend.h",
          "lines": "17-25",
          "snippet": "static inline struct lb_addr cpu_to_lelb(struct kernel_lb_addr in)\n{\n\tstruct lb_addr out;\n\n\tout.logicalBlockNum = cpu_to_le32(in.logicalBlockNum);\n\tout.partitionReferenceNum = cpu_to_le16(in.partitionReferenceNum);\n\n\treturn out;\n}",
          "includes": [
            "#include <linux/string.h>",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/string.h>\n#include <asm/byteorder.h>\n\nstatic inline struct lb_addr cpu_to_lelb(struct kernel_lb_addr in)\n{\n\tstruct lb_addr out;\n\n\tout.logicalBlockNum = cpu_to_le32(in.logicalBlockNum);\n\tout.partitionReferenceNum = cpu_to_le16(in.partitionReferenceNum);\n\n\treturn out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "elen"
          ],
          "line": 2030
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "eloc->logicalBlockNum"
          ],
          "line": 2025
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "elen"
          ],
          "line": 2024
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udf_file_entry_alloc_offset",
          "args": [
            "inode"
          ],
          "line": 2016
        },
        "resolved": true,
        "details": {
          "function_name": "udf_file_entry_alloc_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/udfdecl.h",
          "lines": "55-64",
          "snippet": "static inline size_t udf_file_entry_alloc_offset(struct inode *inode)\n{\n\tstruct udf_inode_info *iinfo = UDF_I(inode);\n\tif (iinfo->i_use)\n\t\treturn sizeof(struct unallocSpaceEntry);\n\telse if (iinfo->i_efe)\n\t\treturn sizeof(struct extendedFileEntry) + iinfo->i_lenEAttr;\n\telse\n\t\treturn sizeof(struct fileEntry) + iinfo->i_lenEAttr;\n}",
          "includes": [
            "#include \"udf_i.h\"",
            "#include \"udfend.h\"",
            "#include \"udf_sb.h\"",
            "#include <linux/udf_fs_i.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include \"osta_udf.h\"",
            "#include \"ecma_167.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_i.h\"\n#include \"udfend.h\"\n#include \"udf_sb.h\"\n#include <linux/udf_fs_i.h>\n#include <linux/buffer_head.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include \"osta_udf.h\"\n#include \"ecma_167.h\"\n\nstatic inline size_t udf_file_entry_alloc_offset(struct inode *inode)\n{\n\tstruct udf_inode_info *iinfo = UDF_I(inode);\n\tif (iinfo->i_use)\n\t\treturn sizeof(struct unallocSpaceEntry);\n\telse if (iinfo->i_efe)\n\t\treturn sizeof(struct extendedFileEntry) + iinfo->i_lenEAttr;\n\telse\n\t\treturn sizeof(struct fileEntry) + iinfo->i_lenEAttr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "UDF_I",
          "args": [
            "inode"
          ],
          "line": 2012
        },
        "resolved": true,
        "details": {
          "function_name": "UDF_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/udf_i.h",
          "lines": "57-60",
          "snippet": "static inline struct udf_inode_info *UDF_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct udf_inode_info, vfs_inode);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline struct udf_inode_info *UDF_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct udf_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/crc-itu-t.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include \"udfdecl.h\"\n\nstatic int udf_update_inode(struct inode *, int);\nstatic int udf_sync_inode(struct inode *inode);\nstatic int8_t udf_insert_aext(struct inode *, struct extent_position,\n\t\t\t      struct kernel_lb_addr, uint32_t);\n\nvoid udf_write_aext(struct inode *inode, struct extent_position *epos,\n\t\t    struct kernel_lb_addr *eloc, uint32_t elen, int inc)\n{\n\tint adsize;\n\tuint8_t *ptr;\n\tstruct short_ad *sad;\n\tstruct long_ad *lad;\n\tstruct udf_inode_info *iinfo = UDF_I(inode);\n\n\tif (!epos->bh)\n\t\tptr = iinfo->i_ext.i_data + epos->offset -\n\t\t\tudf_file_entry_alloc_offset(inode) +\n\t\t\tiinfo->i_lenEAttr;\n\telse\n\t\tptr = epos->bh->b_data + epos->offset;\n\n\tswitch (iinfo->i_alloc_type) {\n\tcase ICBTAG_FLAG_AD_SHORT:\n\t\tsad = (struct short_ad *)ptr;\n\t\tsad->extLength = cpu_to_le32(elen);\n\t\tsad->extPosition = cpu_to_le32(eloc->logicalBlockNum);\n\t\tadsize = sizeof(struct short_ad);\n\t\tbreak;\n\tcase ICBTAG_FLAG_AD_LONG:\n\t\tlad = (struct long_ad *)ptr;\n\t\tlad->extLength = cpu_to_le32(elen);\n\t\tlad->extLocation = cpu_to_lelb(*eloc);\n\t\tmemset(lad->impUse, 0x00, sizeof(lad->impUse));\n\t\tadsize = sizeof(struct long_ad);\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\n\tif (epos->bh) {\n\t\tif (!UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_STRICT) ||\n\t\t    UDF_SB(inode->i_sb)->s_udfrev >= 0x0201) {\n\t\t\tstruct allocExtDesc *aed =\n\t\t\t\t(struct allocExtDesc *)epos->bh->b_data;\n\t\t\tudf_update_tag(epos->bh->b_data,\n\t\t\t\t       le32_to_cpu(aed->lengthAllocDescs) +\n\t\t\t\t       sizeof(struct allocExtDesc));\n\t\t}\n\t\tmark_buffer_dirty_inode(epos->bh, inode);\n\t} else {\n\t\tmark_inode_dirty(inode);\n\t}\n\n\tif (inc)\n\t\tepos->offset += adsize;\n}"
  },
  {
    "function_name": "udf_add_aext",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/inode.c",
    "lines": "1876-2003",
    "snippet": "int udf_add_aext(struct inode *inode, struct extent_position *epos,\n\t\t struct kernel_lb_addr *eloc, uint32_t elen, int inc)\n{\n\tint adsize;\n\tstruct short_ad *sad = NULL;\n\tstruct long_ad *lad = NULL;\n\tstruct allocExtDesc *aed;\n\tuint8_t *ptr;\n\tstruct udf_inode_info *iinfo = UDF_I(inode);\n\n\tif (!epos->bh)\n\t\tptr = iinfo->i_ext.i_data + epos->offset -\n\t\t\tudf_file_entry_alloc_offset(inode) +\n\t\t\tiinfo->i_lenEAttr;\n\telse\n\t\tptr = epos->bh->b_data + epos->offset;\n\n\tif (iinfo->i_alloc_type == ICBTAG_FLAG_AD_SHORT)\n\t\tadsize = sizeof(struct short_ad);\n\telse if (iinfo->i_alloc_type == ICBTAG_FLAG_AD_LONG)\n\t\tadsize = sizeof(struct long_ad);\n\telse\n\t\treturn -EIO;\n\n\tif (epos->offset + (2 * adsize) > inode->i_sb->s_blocksize) {\n\t\tunsigned char *sptr, *dptr;\n\t\tstruct buffer_head *nbh;\n\t\tint err, loffset;\n\t\tstruct kernel_lb_addr obloc = epos->block;\n\n\t\tepos->block.logicalBlockNum = udf_new_block(inode->i_sb, NULL,\n\t\t\t\t\t\tobloc.partitionReferenceNum,\n\t\t\t\t\t\tobloc.logicalBlockNum, &err);\n\t\tif (!epos->block.logicalBlockNum)\n\t\t\treturn -ENOSPC;\n\t\tnbh = udf_tgetblk(inode->i_sb, udf_get_lb_pblock(inode->i_sb,\n\t\t\t\t\t\t\t\t &epos->block,\n\t\t\t\t\t\t\t\t 0));\n\t\tif (!nbh)\n\t\t\treturn -EIO;\n\t\tlock_buffer(nbh);\n\t\tmemset(nbh->b_data, 0x00, inode->i_sb->s_blocksize);\n\t\tset_buffer_uptodate(nbh);\n\t\tunlock_buffer(nbh);\n\t\tmark_buffer_dirty_inode(nbh, inode);\n\n\t\taed = (struct allocExtDesc *)(nbh->b_data);\n\t\tif (!UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_STRICT))\n\t\t\taed->previousAllocExtLocation =\n\t\t\t\t\tcpu_to_le32(obloc.logicalBlockNum);\n\t\tif (epos->offset + adsize > inode->i_sb->s_blocksize) {\n\t\t\tloffset = epos->offset;\n\t\t\taed->lengthAllocDescs = cpu_to_le32(adsize);\n\t\t\tsptr = ptr - adsize;\n\t\t\tdptr = nbh->b_data + sizeof(struct allocExtDesc);\n\t\t\tmemcpy(dptr, sptr, adsize);\n\t\t\tepos->offset = sizeof(struct allocExtDesc) + adsize;\n\t\t} else {\n\t\t\tloffset = epos->offset + adsize;\n\t\t\taed->lengthAllocDescs = cpu_to_le32(0);\n\t\t\tsptr = ptr;\n\t\t\tepos->offset = sizeof(struct allocExtDesc);\n\n\t\t\tif (epos->bh) {\n\t\t\t\taed = (struct allocExtDesc *)epos->bh->b_data;\n\t\t\t\tle32_add_cpu(&aed->lengthAllocDescs, adsize);\n\t\t\t} else {\n\t\t\t\tiinfo->i_lenAlloc += adsize;\n\t\t\t\tmark_inode_dirty(inode);\n\t\t\t}\n\t\t}\n\t\tif (UDF_SB(inode->i_sb)->s_udfrev >= 0x0200)\n\t\t\tudf_new_tag(nbh->b_data, TAG_IDENT_AED, 3, 1,\n\t\t\t\t    epos->block.logicalBlockNum, sizeof(struct tag));\n\t\telse\n\t\t\tudf_new_tag(nbh->b_data, TAG_IDENT_AED, 2, 1,\n\t\t\t\t    epos->block.logicalBlockNum, sizeof(struct tag));\n\t\tswitch (iinfo->i_alloc_type) {\n\t\tcase ICBTAG_FLAG_AD_SHORT:\n\t\t\tsad = (struct short_ad *)sptr;\n\t\t\tsad->extLength = cpu_to_le32(EXT_NEXT_EXTENT_ALLOCDECS |\n\t\t\t\t\t\t     inode->i_sb->s_blocksize);\n\t\t\tsad->extPosition =\n\t\t\t\tcpu_to_le32(epos->block.logicalBlockNum);\n\t\t\tbreak;\n\t\tcase ICBTAG_FLAG_AD_LONG:\n\t\t\tlad = (struct long_ad *)sptr;\n\t\t\tlad->extLength = cpu_to_le32(EXT_NEXT_EXTENT_ALLOCDECS |\n\t\t\t\t\t\t     inode->i_sb->s_blocksize);\n\t\t\tlad->extLocation = cpu_to_lelb(epos->block);\n\t\t\tmemset(lad->impUse, 0x00, sizeof(lad->impUse));\n\t\t\tbreak;\n\t\t}\n\t\tif (epos->bh) {\n\t\t\tif (!UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_STRICT) ||\n\t\t\t    UDF_SB(inode->i_sb)->s_udfrev >= 0x0201)\n\t\t\t\tudf_update_tag(epos->bh->b_data, loffset);\n\t\t\telse\n\t\t\t\tudf_update_tag(epos->bh->b_data,\n\t\t\t\t\t\tsizeof(struct allocExtDesc));\n\t\t\tmark_buffer_dirty_inode(epos->bh, inode);\n\t\t\tbrelse(epos->bh);\n\t\t} else {\n\t\t\tmark_inode_dirty(inode);\n\t\t}\n\t\tepos->bh = nbh;\n\t}\n\n\tudf_write_aext(inode, epos, eloc, elen, inc);\n\n\tif (!epos->bh) {\n\t\tiinfo->i_lenAlloc += adsize;\n\t\tmark_inode_dirty(inode);\n\t} else {\n\t\taed = (struct allocExtDesc *)epos->bh->b_data;\n\t\tle32_add_cpu(&aed->lengthAllocDescs, adsize);\n\t\tif (!UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_STRICT) ||\n\t\t\t\tUDF_SB(inode->i_sb)->s_udfrev >= 0x0201)\n\t\t\tudf_update_tag(epos->bh->b_data,\n\t\t\t\t\tepos->offset + (inc ? 0 : adsize));\n\t\telse\n\t\t\tudf_update_tag(epos->bh->b_data,\n\t\t\t\t\tsizeof(struct allocExtDesc));\n\t\tmark_buffer_dirty_inode(epos->bh, inode);\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"udf_sb.h\"",
      "#include \"udf_i.h\"",
      "#include <linux/aio.h>",
      "#include <linux/mpage.h>",
      "#include <linux/crc-itu-t.h>",
      "#include <linux/slab.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include \"udfdecl.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int udf_update_inode(struct inode *, int);",
      "static int udf_sync_inode(struct inode *inode);",
      "static int8_t udf_insert_aext(struct inode *, struct extent_position,\n\t\t\t      struct kernel_lb_addr, uint32_t);",
      "static int udf_get_block(struct inode *, sector_t, struct buffer_head *, int);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mark_buffer_dirty_inode",
          "args": [
            "epos->bh",
            "inode"
          ],
          "line": 1999
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_dirty_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "599-617",
          "snippet": "void mark_buffer_dirty_inode(struct buffer_head *bh, struct inode *inode)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tstruct address_space *buffer_mapping = bh->b_page->mapping;\n\n\tmark_buffer_dirty(bh);\n\tif (!mapping->private_data) {\n\t\tmapping->private_data = buffer_mapping;\n\t} else {\n\t\tBUG_ON(mapping->private_data != buffer_mapping);\n\t}\n\tif (!bh->b_assoc_map) {\n\t\tspin_lock(&buffer_mapping->private_lock);\n\t\tlist_move_tail(&bh->b_assoc_buffers,\n\t\t\t\t&mapping->private_list);\n\t\tbh->b_assoc_map = mapping;\n\t\tspin_unlock(&buffer_mapping->private_lock);\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_dirty_inode(struct buffer_head *bh, struct inode *inode)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tstruct address_space *buffer_mapping = bh->b_page->mapping;\n\n\tmark_buffer_dirty(bh);\n\tif (!mapping->private_data) {\n\t\tmapping->private_data = buffer_mapping;\n\t} else {\n\t\tBUG_ON(mapping->private_data != buffer_mapping);\n\t}\n\tif (!bh->b_assoc_map) {\n\t\tspin_lock(&buffer_mapping->private_lock);\n\t\tlist_move_tail(&bh->b_assoc_buffers,\n\t\t\t\t&mapping->private_list);\n\t\tbh->b_assoc_map = mapping;\n\t\tspin_unlock(&buffer_mapping->private_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_update_tag",
          "args": [
            "epos->bh->b_data",
            "sizeof(struct allocExtDesc)"
          ],
          "line": 1997
        },
        "resolved": true,
        "details": {
          "function_name": "udf_update_tag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/misc.c",
          "lines": "269-277",
          "snippet": "void udf_update_tag(char *data, int length)\n{\n\tstruct tag *tptr = (struct tag *)data;\n\tlength -= sizeof(struct tag);\n\n\ttptr->descCRCLength = cpu_to_le16(length);\n\ttptr->descCRC = cpu_to_le16(crc_itu_t(0, data + sizeof(struct tag), length));\n\ttptr->tagChecksum = udf_tag_checksum(tptr);\n}",
          "includes": [
            "#include \"udf_sb.h\"",
            "#include \"udf_i.h\"",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/crc-itu-t.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include \"udfdecl.h\"\n\nvoid udf_update_tag(char *data, int length)\n{\n\tstruct tag *tptr = (struct tag *)data;\n\tlength -= sizeof(struct tag);\n\n\ttptr->descCRCLength = cpu_to_le16(length);\n\ttptr->descCRC = cpu_to_le16(crc_itu_t(0, data + sizeof(struct tag), length));\n\ttptr->tagChecksum = udf_tag_checksum(tptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "UDF_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 1993
        },
        "resolved": true,
        "details": {
          "function_name": "UDF_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/udf_sb.h",
          "lines": "160-163",
          "snippet": "static inline struct udf_sb_info *UDF_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/bitops.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bitops.h>\n#include <linux/mutex.h>\n\nstatic inline struct udf_sb_info *UDF_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "UDF_QUERY_FLAG",
          "args": [
            "inode->i_sb",
            "UDF_FLAG_STRICT"
          ],
          "line": 1992
        },
        "resolved": true,
        "details": {
          "function_name": "UDF_QUERY_FLAG",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/udf_sb.h",
          "lines": "169-172",
          "snippet": "static inline int UDF_QUERY_FLAG(struct super_block *sb, int flag)\n{\n\treturn test_bit(flag, &UDF_SB(sb)->s_flags);\n}",
          "includes": [
            "#include <linux/bitops.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bitops.h>\n#include <linux/mutex.h>\n\nstatic inline int UDF_QUERY_FLAG(struct super_block *sb, int flag)\n{\n\treturn test_bit(flag, &UDF_SB(sb)->s_flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_add_cpu",
          "args": [
            "&aed->lengthAllocDescs",
            "adsize"
          ],
          "line": 1991
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mark_inode_dirty",
          "args": [
            "inode"
          ],
          "line": 1988
        },
        "resolved": true,
        "details": {
          "function_name": "block_dump___mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1134-1154",
          "snippet": "static noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_write_aext",
          "args": [
            "inode",
            "epos",
            "eloc",
            "elen",
            "inc"
          ],
          "line": 1984
        },
        "resolved": true,
        "details": {
          "function_name": "udf_write_aext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/inode.c",
          "lines": "2005-2055",
          "snippet": "void udf_write_aext(struct inode *inode, struct extent_position *epos,\n\t\t    struct kernel_lb_addr *eloc, uint32_t elen, int inc)\n{\n\tint adsize;\n\tuint8_t *ptr;\n\tstruct short_ad *sad;\n\tstruct long_ad *lad;\n\tstruct udf_inode_info *iinfo = UDF_I(inode);\n\n\tif (!epos->bh)\n\t\tptr = iinfo->i_ext.i_data + epos->offset -\n\t\t\tudf_file_entry_alloc_offset(inode) +\n\t\t\tiinfo->i_lenEAttr;\n\telse\n\t\tptr = epos->bh->b_data + epos->offset;\n\n\tswitch (iinfo->i_alloc_type) {\n\tcase ICBTAG_FLAG_AD_SHORT:\n\t\tsad = (struct short_ad *)ptr;\n\t\tsad->extLength = cpu_to_le32(elen);\n\t\tsad->extPosition = cpu_to_le32(eloc->logicalBlockNum);\n\t\tadsize = sizeof(struct short_ad);\n\t\tbreak;\n\tcase ICBTAG_FLAG_AD_LONG:\n\t\tlad = (struct long_ad *)ptr;\n\t\tlad->extLength = cpu_to_le32(elen);\n\t\tlad->extLocation = cpu_to_lelb(*eloc);\n\t\tmemset(lad->impUse, 0x00, sizeof(lad->impUse));\n\t\tadsize = sizeof(struct long_ad);\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\n\tif (epos->bh) {\n\t\tif (!UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_STRICT) ||\n\t\t    UDF_SB(inode->i_sb)->s_udfrev >= 0x0201) {\n\t\t\tstruct allocExtDesc *aed =\n\t\t\t\t(struct allocExtDesc *)epos->bh->b_data;\n\t\t\tudf_update_tag(epos->bh->b_data,\n\t\t\t\t       le32_to_cpu(aed->lengthAllocDescs) +\n\t\t\t\t       sizeof(struct allocExtDesc));\n\t\t}\n\t\tmark_buffer_dirty_inode(epos->bh, inode);\n\t} else {\n\t\tmark_inode_dirty(inode);\n\t}\n\n\tif (inc)\n\t\tepos->offset += adsize;\n}",
          "includes": [
            "#include \"udf_sb.h\"",
            "#include \"udf_i.h\"",
            "#include <linux/aio.h>",
            "#include <linux/mpage.h>",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int udf_update_inode(struct inode *, int);",
            "static int udf_sync_inode(struct inode *inode);",
            "static int8_t udf_insert_aext(struct inode *, struct extent_position,\n\t\t\t      struct kernel_lb_addr, uint32_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/crc-itu-t.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include \"udfdecl.h\"\n\nstatic int udf_update_inode(struct inode *, int);\nstatic int udf_sync_inode(struct inode *inode);\nstatic int8_t udf_insert_aext(struct inode *, struct extent_position,\n\t\t\t      struct kernel_lb_addr, uint32_t);\n\nvoid udf_write_aext(struct inode *inode, struct extent_position *epos,\n\t\t    struct kernel_lb_addr *eloc, uint32_t elen, int inc)\n{\n\tint adsize;\n\tuint8_t *ptr;\n\tstruct short_ad *sad;\n\tstruct long_ad *lad;\n\tstruct udf_inode_info *iinfo = UDF_I(inode);\n\n\tif (!epos->bh)\n\t\tptr = iinfo->i_ext.i_data + epos->offset -\n\t\t\tudf_file_entry_alloc_offset(inode) +\n\t\t\tiinfo->i_lenEAttr;\n\telse\n\t\tptr = epos->bh->b_data + epos->offset;\n\n\tswitch (iinfo->i_alloc_type) {\n\tcase ICBTAG_FLAG_AD_SHORT:\n\t\tsad = (struct short_ad *)ptr;\n\t\tsad->extLength = cpu_to_le32(elen);\n\t\tsad->extPosition = cpu_to_le32(eloc->logicalBlockNum);\n\t\tadsize = sizeof(struct short_ad);\n\t\tbreak;\n\tcase ICBTAG_FLAG_AD_LONG:\n\t\tlad = (struct long_ad *)ptr;\n\t\tlad->extLength = cpu_to_le32(elen);\n\t\tlad->extLocation = cpu_to_lelb(*eloc);\n\t\tmemset(lad->impUse, 0x00, sizeof(lad->impUse));\n\t\tadsize = sizeof(struct long_ad);\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\n\tif (epos->bh) {\n\t\tif (!UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_STRICT) ||\n\t\t    UDF_SB(inode->i_sb)->s_udfrev >= 0x0201) {\n\t\t\tstruct allocExtDesc *aed =\n\t\t\t\t(struct allocExtDesc *)epos->bh->b_data;\n\t\t\tudf_update_tag(epos->bh->b_data,\n\t\t\t\t       le32_to_cpu(aed->lengthAllocDescs) +\n\t\t\t\t       sizeof(struct allocExtDesc));\n\t\t}\n\t\tmark_buffer_dirty_inode(epos->bh, inode);\n\t} else {\n\t\tmark_inode_dirty(inode);\n\t}\n\n\tif (inc)\n\t\tepos->offset += adsize;\n}"
        }
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "epos->bh"
          ],
          "line": 1977
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "lad->impUse",
            "0x00",
            "sizeof(lad->impUse)"
          ],
          "line": 1966
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_lelb",
          "args": [
            "epos->block"
          ],
          "line": 1965
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_to_lelb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/udfend.h",
          "lines": "17-25",
          "snippet": "static inline struct lb_addr cpu_to_lelb(struct kernel_lb_addr in)\n{\n\tstruct lb_addr out;\n\n\tout.logicalBlockNum = cpu_to_le32(in.logicalBlockNum);\n\tout.partitionReferenceNum = cpu_to_le16(in.partitionReferenceNum);\n\n\treturn out;\n}",
          "includes": [
            "#include <linux/string.h>",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/string.h>\n#include <asm/byteorder.h>\n\nstatic inline struct lb_addr cpu_to_lelb(struct kernel_lb_addr in)\n{\n\tstruct lb_addr out;\n\n\tout.logicalBlockNum = cpu_to_le32(in.logicalBlockNum);\n\tout.partitionReferenceNum = cpu_to_le16(in.partitionReferenceNum);\n\n\treturn out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "EXT_NEXT_EXTENT_ALLOCDECS |\n\t\t\t\t\t\t     inode->i_sb->s_blocksize"
          ],
          "line": 1963
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "epos->block.logicalBlockNum"
          ],
          "line": 1959
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "EXT_NEXT_EXTENT_ALLOCDECS |\n\t\t\t\t\t\t     inode->i_sb->s_blocksize"
          ],
          "line": 1956
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udf_new_tag",
          "args": [
            "nbh->b_data",
            "TAG_IDENT_AED",
            "2",
            "1",
            "epos->block.logicalBlockNum",
            "sizeof(struct tag)"
          ],
          "line": 1951
        },
        "resolved": true,
        "details": {
          "function_name": "udf_new_tag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/misc.c",
          "lines": "279-288",
          "snippet": "void udf_new_tag(char *data, uint16_t ident, uint16_t version, uint16_t snum,\n\t\t uint32_t loc, int length)\n{\n\tstruct tag *tptr = (struct tag *)data;\n\ttptr->tagIdent = cpu_to_le16(ident);\n\ttptr->descVersion = cpu_to_le16(version);\n\ttptr->tagSerialNum = cpu_to_le16(snum);\n\ttptr->tagLocation = cpu_to_le32(loc);\n\tudf_update_tag(data, length);\n}",
          "includes": [
            "#include \"udf_sb.h\"",
            "#include \"udf_i.h\"",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/crc-itu-t.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include \"udfdecl.h\"\n\nvoid udf_new_tag(char *data, uint16_t ident, uint16_t version, uint16_t snum,\n\t\t uint32_t loc, int length)\n{\n\tstruct tag *tptr = (struct tag *)data;\n\ttptr->tagIdent = cpu_to_le16(ident);\n\ttptr->descVersion = cpu_to_le16(version);\n\ttptr->tagSerialNum = cpu_to_le16(snum);\n\ttptr->tagLocation = cpu_to_le32(loc);\n\tudf_update_tag(data, length);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_add_cpu",
          "args": [
            "&aed->lengthAllocDescs",
            "adsize"
          ],
          "line": 1941
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "0"
          ],
          "line": 1935
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "dptr",
            "sptr",
            "adsize"
          ],
          "line": 1931
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "adsize"
          ],
          "line": 1928
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "obloc.logicalBlockNum"
          ],
          "line": 1925
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_buffer",
          "args": [
            "nbh"
          ],
          "line": 1919
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "70-75",
          "snippet": "void unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_buffer_uptodate",
          "args": [
            "nbh"
          ],
          "line": 1918
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3758-3761",
          "snippet": "int btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "nbh->b_data",
            "0x00",
            "inode->i_sb->s_blocksize"
          ],
          "line": 1917
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udf_tgetblk",
          "args": [
            "inode->i_sb",
            "udf_get_lb_pblock(inode->i_sb,\n\t\t\t\t\t\t\t\t &epos->block,\n\t\t\t\t\t\t\t\t 0)"
          ],
          "line": 1911
        },
        "resolved": true,
        "details": {
          "function_name": "udf_tgetblk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/misc.c",
          "lines": "32-38",
          "snippet": "struct buffer_head *udf_tgetblk(struct super_block *sb, int block)\n{\n\tif (UDF_QUERY_FLAG(sb, UDF_FLAG_VARCONV))\n\t\treturn sb_getblk(sb, udf_fixed_to_variable(block));\n\telse\n\t\treturn sb_getblk(sb, block);\n}",
          "includes": [
            "#include \"udf_sb.h\"",
            "#include \"udf_i.h\"",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/crc-itu-t.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include \"udfdecl.h\"\n\nstruct buffer_head *udf_tgetblk(struct super_block *sb, int block)\n{\n\tif (UDF_QUERY_FLAG(sb, UDF_FLAG_VARCONV))\n\t\treturn sb_getblk(sb, udf_fixed_to_variable(block));\n\telse\n\t\treturn sb_getblk(sb, block);\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_get_lb_pblock",
          "args": [
            "inode->i_sb",
            "&epos->block",
            "0"
          ],
          "line": 1911
        },
        "resolved": true,
        "details": {
          "function_name": "udf_get_lb_pblock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/udfdecl.h",
          "lines": "205-211",
          "snippet": "static inline uint32_t\nudf_get_lb_pblock(struct super_block *sb, struct kernel_lb_addr *loc,\n\t\t  uint32_t offset)\n{\n\treturn udf_get_pblock(sb, loc->logicalBlockNum,\n\t\t\tloc->partitionReferenceNum, offset);\n}",
          "includes": [
            "#include \"udf_i.h\"",
            "#include \"udfend.h\"",
            "#include \"udf_sb.h\"",
            "#include <linux/udf_fs_i.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include \"osta_udf.h\"",
            "#include \"ecma_167.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_i.h\"\n#include \"udfend.h\"\n#include \"udf_sb.h\"\n#include <linux/udf_fs_i.h>\n#include <linux/buffer_head.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include \"osta_udf.h\"\n#include \"ecma_167.h\"\n\nstatic inline uint32_t\nudf_get_lb_pblock(struct super_block *sb, struct kernel_lb_addr *loc,\n\t\t  uint32_t offset)\n{\n\treturn udf_get_pblock(sb, loc->logicalBlockNum,\n\t\t\tloc->partitionReferenceNum, offset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_new_block",
          "args": [
            "inode->i_sb",
            "NULL",
            "obloc.partitionReferenceNum",
            "obloc.logicalBlockNum",
            "&err"
          ],
          "line": 1906
        },
        "resolved": true,
        "details": {
          "function_name": "udf_new_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/balloc.c",
          "lines": "795-825",
          "snippet": "inline int udf_new_block(struct super_block *sb,\n\t\t\t struct inode *inode,\n\t\t\t uint16_t partition, uint32_t goal, int *err)\n{\n\tstruct udf_part_map *map = &UDF_SB(sb)->s_partmaps[partition];\n\tint block;\n\n\tif (map->s_partition_flags & UDF_PART_FLAG_UNALLOC_BITMAP)\n\t\tblock = udf_bitmap_new_block(sb,\n\t\t\t\t\t     map->s_uspace.s_bitmap,\n\t\t\t\t\t     partition, goal, err);\n\telse if (map->s_partition_flags & UDF_PART_FLAG_UNALLOC_TABLE)\n\t\tblock = udf_table_new_block(sb,\n\t\t\t\t\t    map->s_uspace.s_table,\n\t\t\t\t\t    partition, goal, err);\n\telse if (map->s_partition_flags & UDF_PART_FLAG_FREED_BITMAP)\n\t\tblock = udf_bitmap_new_block(sb,\n\t\t\t\t\t     map->s_fspace.s_bitmap,\n\t\t\t\t\t     partition, goal, err);\n\telse if (map->s_partition_flags & UDF_PART_FLAG_FREED_TABLE)\n\t\tblock = udf_table_new_block(sb,\n\t\t\t\t\t    map->s_fspace.s_table,\n\t\t\t\t\t    partition, goal, err);\n\telse {\n\t\t*err = -EIO;\n\t\treturn 0;\n\t}\n\tif (inode && block)\n\t\tinode_add_bytes(inode, sb->s_blocksize);\n\treturn block;\n}",
          "includes": [
            "#include \"udf_sb.h\"",
            "#include \"udf_i.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/buffer_head.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/bitops.h>\n#include <linux/buffer_head.h>\n#include \"udfdecl.h\"\n\ninline int udf_new_block(struct super_block *sb,\n\t\t\t struct inode *inode,\n\t\t\t uint16_t partition, uint32_t goal, int *err)\n{\n\tstruct udf_part_map *map = &UDF_SB(sb)->s_partmaps[partition];\n\tint block;\n\n\tif (map->s_partition_flags & UDF_PART_FLAG_UNALLOC_BITMAP)\n\t\tblock = udf_bitmap_new_block(sb,\n\t\t\t\t\t     map->s_uspace.s_bitmap,\n\t\t\t\t\t     partition, goal, err);\n\telse if (map->s_partition_flags & UDF_PART_FLAG_UNALLOC_TABLE)\n\t\tblock = udf_table_new_block(sb,\n\t\t\t\t\t    map->s_uspace.s_table,\n\t\t\t\t\t    partition, goal, err);\n\telse if (map->s_partition_flags & UDF_PART_FLAG_FREED_BITMAP)\n\t\tblock = udf_bitmap_new_block(sb,\n\t\t\t\t\t     map->s_fspace.s_bitmap,\n\t\t\t\t\t     partition, goal, err);\n\telse if (map->s_partition_flags & UDF_PART_FLAG_FREED_TABLE)\n\t\tblock = udf_table_new_block(sb,\n\t\t\t\t\t    map->s_fspace.s_table,\n\t\t\t\t\t    partition, goal, err);\n\telse {\n\t\t*err = -EIO;\n\t\treturn 0;\n\t}\n\tif (inode && block)\n\t\tinode_add_bytes(inode, sb->s_blocksize);\n\treturn block;\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_file_entry_alloc_offset",
          "args": [
            "inode"
          ],
          "line": 1888
        },
        "resolved": true,
        "details": {
          "function_name": "udf_file_entry_alloc_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/udfdecl.h",
          "lines": "55-64",
          "snippet": "static inline size_t udf_file_entry_alloc_offset(struct inode *inode)\n{\n\tstruct udf_inode_info *iinfo = UDF_I(inode);\n\tif (iinfo->i_use)\n\t\treturn sizeof(struct unallocSpaceEntry);\n\telse if (iinfo->i_efe)\n\t\treturn sizeof(struct extendedFileEntry) + iinfo->i_lenEAttr;\n\telse\n\t\treturn sizeof(struct fileEntry) + iinfo->i_lenEAttr;\n}",
          "includes": [
            "#include \"udf_i.h\"",
            "#include \"udfend.h\"",
            "#include \"udf_sb.h\"",
            "#include <linux/udf_fs_i.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include \"osta_udf.h\"",
            "#include \"ecma_167.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_i.h\"\n#include \"udfend.h\"\n#include \"udf_sb.h\"\n#include <linux/udf_fs_i.h>\n#include <linux/buffer_head.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include \"osta_udf.h\"\n#include \"ecma_167.h\"\n\nstatic inline size_t udf_file_entry_alloc_offset(struct inode *inode)\n{\n\tstruct udf_inode_info *iinfo = UDF_I(inode);\n\tif (iinfo->i_use)\n\t\treturn sizeof(struct unallocSpaceEntry);\n\telse if (iinfo->i_efe)\n\t\treturn sizeof(struct extendedFileEntry) + iinfo->i_lenEAttr;\n\telse\n\t\treturn sizeof(struct fileEntry) + iinfo->i_lenEAttr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "UDF_I",
          "args": [
            "inode"
          ],
          "line": 1884
        },
        "resolved": true,
        "details": {
          "function_name": "UDF_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/udf_i.h",
          "lines": "57-60",
          "snippet": "static inline struct udf_inode_info *UDF_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct udf_inode_info, vfs_inode);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline struct udf_inode_info *UDF_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct udf_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/crc-itu-t.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include \"udfdecl.h\"\n\nstatic int udf_update_inode(struct inode *, int);\nstatic int udf_sync_inode(struct inode *inode);\nstatic int8_t udf_insert_aext(struct inode *, struct extent_position,\n\t\t\t      struct kernel_lb_addr, uint32_t);\nstatic int udf_get_block(struct inode *, sector_t, struct buffer_head *, int);\n\nint udf_add_aext(struct inode *inode, struct extent_position *epos,\n\t\t struct kernel_lb_addr *eloc, uint32_t elen, int inc)\n{\n\tint adsize;\n\tstruct short_ad *sad = NULL;\n\tstruct long_ad *lad = NULL;\n\tstruct allocExtDesc *aed;\n\tuint8_t *ptr;\n\tstruct udf_inode_info *iinfo = UDF_I(inode);\n\n\tif (!epos->bh)\n\t\tptr = iinfo->i_ext.i_data + epos->offset -\n\t\t\tudf_file_entry_alloc_offset(inode) +\n\t\t\tiinfo->i_lenEAttr;\n\telse\n\t\tptr = epos->bh->b_data + epos->offset;\n\n\tif (iinfo->i_alloc_type == ICBTAG_FLAG_AD_SHORT)\n\t\tadsize = sizeof(struct short_ad);\n\telse if (iinfo->i_alloc_type == ICBTAG_FLAG_AD_LONG)\n\t\tadsize = sizeof(struct long_ad);\n\telse\n\t\treturn -EIO;\n\n\tif (epos->offset + (2 * adsize) > inode->i_sb->s_blocksize) {\n\t\tunsigned char *sptr, *dptr;\n\t\tstruct buffer_head *nbh;\n\t\tint err, loffset;\n\t\tstruct kernel_lb_addr obloc = epos->block;\n\n\t\tepos->block.logicalBlockNum = udf_new_block(inode->i_sb, NULL,\n\t\t\t\t\t\tobloc.partitionReferenceNum,\n\t\t\t\t\t\tobloc.logicalBlockNum, &err);\n\t\tif (!epos->block.logicalBlockNum)\n\t\t\treturn -ENOSPC;\n\t\tnbh = udf_tgetblk(inode->i_sb, udf_get_lb_pblock(inode->i_sb,\n\t\t\t\t\t\t\t\t &epos->block,\n\t\t\t\t\t\t\t\t 0));\n\t\tif (!nbh)\n\t\t\treturn -EIO;\n\t\tlock_buffer(nbh);\n\t\tmemset(nbh->b_data, 0x00, inode->i_sb->s_blocksize);\n\t\tset_buffer_uptodate(nbh);\n\t\tunlock_buffer(nbh);\n\t\tmark_buffer_dirty_inode(nbh, inode);\n\n\t\taed = (struct allocExtDesc *)(nbh->b_data);\n\t\tif (!UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_STRICT))\n\t\t\taed->previousAllocExtLocation =\n\t\t\t\t\tcpu_to_le32(obloc.logicalBlockNum);\n\t\tif (epos->offset + adsize > inode->i_sb->s_blocksize) {\n\t\t\tloffset = epos->offset;\n\t\t\taed->lengthAllocDescs = cpu_to_le32(adsize);\n\t\t\tsptr = ptr - adsize;\n\t\t\tdptr = nbh->b_data + sizeof(struct allocExtDesc);\n\t\t\tmemcpy(dptr, sptr, adsize);\n\t\t\tepos->offset = sizeof(struct allocExtDesc) + adsize;\n\t\t} else {\n\t\t\tloffset = epos->offset + adsize;\n\t\t\taed->lengthAllocDescs = cpu_to_le32(0);\n\t\t\tsptr = ptr;\n\t\t\tepos->offset = sizeof(struct allocExtDesc);\n\n\t\t\tif (epos->bh) {\n\t\t\t\taed = (struct allocExtDesc *)epos->bh->b_data;\n\t\t\t\tle32_add_cpu(&aed->lengthAllocDescs, adsize);\n\t\t\t} else {\n\t\t\t\tiinfo->i_lenAlloc += adsize;\n\t\t\t\tmark_inode_dirty(inode);\n\t\t\t}\n\t\t}\n\t\tif (UDF_SB(inode->i_sb)->s_udfrev >= 0x0200)\n\t\t\tudf_new_tag(nbh->b_data, TAG_IDENT_AED, 3, 1,\n\t\t\t\t    epos->block.logicalBlockNum, sizeof(struct tag));\n\t\telse\n\t\t\tudf_new_tag(nbh->b_data, TAG_IDENT_AED, 2, 1,\n\t\t\t\t    epos->block.logicalBlockNum, sizeof(struct tag));\n\t\tswitch (iinfo->i_alloc_type) {\n\t\tcase ICBTAG_FLAG_AD_SHORT:\n\t\t\tsad = (struct short_ad *)sptr;\n\t\t\tsad->extLength = cpu_to_le32(EXT_NEXT_EXTENT_ALLOCDECS |\n\t\t\t\t\t\t     inode->i_sb->s_blocksize);\n\t\t\tsad->extPosition =\n\t\t\t\tcpu_to_le32(epos->block.logicalBlockNum);\n\t\t\tbreak;\n\t\tcase ICBTAG_FLAG_AD_LONG:\n\t\t\tlad = (struct long_ad *)sptr;\n\t\t\tlad->extLength = cpu_to_le32(EXT_NEXT_EXTENT_ALLOCDECS |\n\t\t\t\t\t\t     inode->i_sb->s_blocksize);\n\t\t\tlad->extLocation = cpu_to_lelb(epos->block);\n\t\t\tmemset(lad->impUse, 0x00, sizeof(lad->impUse));\n\t\t\tbreak;\n\t\t}\n\t\tif (epos->bh) {\n\t\t\tif (!UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_STRICT) ||\n\t\t\t    UDF_SB(inode->i_sb)->s_udfrev >= 0x0201)\n\t\t\t\tudf_update_tag(epos->bh->b_data, loffset);\n\t\t\telse\n\t\t\t\tudf_update_tag(epos->bh->b_data,\n\t\t\t\t\t\tsizeof(struct allocExtDesc));\n\t\t\tmark_buffer_dirty_inode(epos->bh, inode);\n\t\t\tbrelse(epos->bh);\n\t\t} else {\n\t\t\tmark_inode_dirty(inode);\n\t\t}\n\t\tepos->bh = nbh;\n\t}\n\n\tudf_write_aext(inode, epos, eloc, elen, inc);\n\n\tif (!epos->bh) {\n\t\tiinfo->i_lenAlloc += adsize;\n\t\tmark_inode_dirty(inode);\n\t} else {\n\t\taed = (struct allocExtDesc *)epos->bh->b_data;\n\t\tle32_add_cpu(&aed->lengthAllocDescs, adsize);\n\t\tif (!UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_STRICT) ||\n\t\t\t\tUDF_SB(inode->i_sb)->s_udfrev >= 0x0201)\n\t\t\tudf_update_tag(epos->bh->b_data,\n\t\t\t\t\tepos->offset + (inc ? 0 : adsize));\n\t\telse\n\t\t\tudf_update_tag(epos->bh->b_data,\n\t\t\t\t\tsizeof(struct allocExtDesc));\n\t\tmark_buffer_dirty_inode(epos->bh, inode);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "__udf_iget",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/inode.c",
    "lines": "1852-1874",
    "snippet": "struct inode *__udf_iget(struct super_block *sb, struct kernel_lb_addr *ino,\n\t\t\t bool hidden_inode)\n{\n\tunsigned long block = udf_get_lb_pblock(sb, ino, 0);\n\tstruct inode *inode = iget_locked(sb, block);\n\tint err;\n\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (!(inode->i_state & I_NEW))\n\t\treturn inode;\n\n\tmemcpy(&UDF_I(inode)->i_location, ino, sizeof(struct kernel_lb_addr));\n\terr = udf_read_inode(inode, hidden_inode);\n\tif (err < 0) {\n\t\tiget_failed(inode);\n\t\treturn ERR_PTR(err);\n\t}\n\tunlock_new_inode(inode);\n\n\treturn inode;\n}",
    "includes": [
      "#include \"udf_sb.h\"",
      "#include \"udf_i.h\"",
      "#include <linux/aio.h>",
      "#include <linux/mpage.h>",
      "#include <linux/crc-itu-t.h>",
      "#include <linux/slab.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include \"udfdecl.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int udf_update_inode(struct inode *, int);",
      "static int udf_sync_inode(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_new_inode",
          "args": [
            "inode"
          ],
          "line": 1871
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_new_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "924-933",
          "snippet": "void unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "err"
          ],
          "line": 1869
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iget_failed",
          "args": [
            "inode"
          ],
          "line": 1868
        },
        "resolved": true,
        "details": {
          "function_name": "iget_failed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/bad_inode.c",
          "lines": "208-213",
          "snippet": "void iget_failed(struct inode *inode)\n{\n\tmake_bad_inode(inode);\n\tunlock_new_inode(inode);\n\tiput(inode);\n}",
          "includes": [
            "#include <linux/poll.h>",
            "#include <linux/namei.h>",
            "#include <linux/time.h>",
            "#include <linux/stat.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/poll.h>\n#include <linux/namei.h>\n#include <linux/time.h>\n#include <linux/stat.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nvoid iget_failed(struct inode *inode)\n{\n\tmake_bad_inode(inode);\n\tunlock_new_inode(inode);\n\tiput(inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_read_inode",
          "args": [
            "inode",
            "hidden_inode"
          ],
          "line": 1866
        },
        "resolved": true,
        "details": {
          "function_name": "udf_read_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/inode.c",
          "lines": "1280-1577",
          "snippet": "static int udf_read_inode(struct inode *inode, bool hidden_inode)\n{\n\tstruct buffer_head *bh = NULL;\n\tstruct fileEntry *fe;\n\tstruct extendedFileEntry *efe;\n\tuint16_t ident;\n\tstruct udf_inode_info *iinfo = UDF_I(inode);\n\tstruct udf_sb_info *sbi = UDF_SB(inode->i_sb);\n\tstruct kernel_lb_addr *iloc = &iinfo->i_location;\n\tunsigned int link_count;\n\tunsigned int indirections = 0;\n\tint bs = inode->i_sb->s_blocksize;\n\tint ret = -EIO;\n\nreread:\n\tif (iloc->logicalBlockNum >=\n\t    sbi->s_partmaps[iloc->partitionReferenceNum].s_partition_len) {\n\t\tudf_debug(\"block=%d, partition=%d out of range\\n\",\n\t\t\t  iloc->logicalBlockNum, iloc->partitionReferenceNum);\n\t\treturn -EIO;\n\t}\n\n\t/*\n\t * Set defaults, but the inode is still incomplete!\n\t * Note: get_new_inode() sets the following on a new inode:\n\t *      i_sb = sb\n\t *      i_no = ino\n\t *      i_flags = sb->s_flags\n\t *      i_state = 0\n\t * clean_inode(): zero fills and sets\n\t *      i_count = 1\n\t *      i_nlink = 1\n\t *      i_op = NULL;\n\t */\n\tbh = udf_read_ptagged(inode->i_sb, iloc, 0, &ident);\n\tif (!bh) {\n\t\tudf_err(inode->i_sb, \"(ino %ld) failed !bh\\n\", inode->i_ino);\n\t\treturn -EIO;\n\t}\n\n\tif (ident != TAG_IDENT_FE && ident != TAG_IDENT_EFE &&\n\t    ident != TAG_IDENT_USE) {\n\t\tudf_err(inode->i_sb, \"(ino %ld) failed ident=%d\\n\",\n\t\t\tinode->i_ino, ident);\n\t\tgoto out;\n\t}\n\n\tfe = (struct fileEntry *)bh->b_data;\n\tefe = (struct extendedFileEntry *)bh->b_data;\n\n\tif (fe->icbTag.strategyType == cpu_to_le16(4096)) {\n\t\tstruct buffer_head *ibh;\n\n\t\tibh = udf_read_ptagged(inode->i_sb, iloc, 1, &ident);\n\t\tif (ident == TAG_IDENT_IE && ibh) {\n\t\t\tstruct kernel_lb_addr loc;\n\t\t\tstruct indirectEntry *ie;\n\n\t\t\tie = (struct indirectEntry *)ibh->b_data;\n\t\t\tloc = lelb_to_cpu(ie->indirectICB.extLocation);\n\n\t\t\tif (ie->indirectICB.extLength) {\n\t\t\t\tbrelse(ibh);\n\t\t\t\tmemcpy(&iinfo->i_location, &loc,\n\t\t\t\t       sizeof(struct kernel_lb_addr));\n\t\t\t\tif (++indirections > UDF_MAX_ICB_NESTING) {\n\t\t\t\t\tudf_err(inode->i_sb,\n\t\t\t\t\t\t\"too many ICBs in ICB hierarchy\"\n\t\t\t\t\t\t\" (max %d supported)\\n\",\n\t\t\t\t\t\tUDF_MAX_ICB_NESTING);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tbrelse(bh);\n\t\t\t\tgoto reread;\n\t\t\t}\n\t\t}\n\t\tbrelse(ibh);\n\t} else if (fe->icbTag.strategyType != cpu_to_le16(4)) {\n\t\tudf_err(inode->i_sb, \"unsupported strategy type: %d\\n\",\n\t\t\tle16_to_cpu(fe->icbTag.strategyType));\n\t\tgoto out;\n\t}\n\tif (fe->icbTag.strategyType == cpu_to_le16(4))\n\t\tiinfo->i_strat4096 = 0;\n\telse /* if (fe->icbTag.strategyType == cpu_to_le16(4096)) */\n\t\tiinfo->i_strat4096 = 1;\n\n\tiinfo->i_alloc_type = le16_to_cpu(fe->icbTag.flags) &\n\t\t\t\t\t\t\tICBTAG_FLAG_AD_MASK;\n\tiinfo->i_unique = 0;\n\tiinfo->i_lenEAttr = 0;\n\tiinfo->i_lenExtents = 0;\n\tiinfo->i_lenAlloc = 0;\n\tiinfo->i_next_alloc_block = 0;\n\tiinfo->i_next_alloc_goal = 0;\n\tif (fe->descTag.tagIdent == cpu_to_le16(TAG_IDENT_EFE)) {\n\t\tiinfo->i_efe = 1;\n\t\tiinfo->i_use = 0;\n\t\tret = udf_alloc_i_data(inode, bs -\n\t\t\t\t\tsizeof(struct extendedFileEntry));\n\t\tif (ret)\n\t\t\tgoto out;\n\t\tmemcpy(iinfo->i_ext.i_data,\n\t\t       bh->b_data + sizeof(struct extendedFileEntry),\n\t\t       bs - sizeof(struct extendedFileEntry));\n\t} else if (fe->descTag.tagIdent == cpu_to_le16(TAG_IDENT_FE)) {\n\t\tiinfo->i_efe = 0;\n\t\tiinfo->i_use = 0;\n\t\tret = udf_alloc_i_data(inode, bs - sizeof(struct fileEntry));\n\t\tif (ret)\n\t\t\tgoto out;\n\t\tmemcpy(iinfo->i_ext.i_data,\n\t\t       bh->b_data + sizeof(struct fileEntry),\n\t\t       bs - sizeof(struct fileEntry));\n\t} else if (fe->descTag.tagIdent == cpu_to_le16(TAG_IDENT_USE)) {\n\t\tiinfo->i_efe = 0;\n\t\tiinfo->i_use = 1;\n\t\tiinfo->i_lenAlloc = le32_to_cpu(\n\t\t\t\t((struct unallocSpaceEntry *)bh->b_data)->\n\t\t\t\t lengthAllocDescs);\n\t\tret = udf_alloc_i_data(inode, bs -\n\t\t\t\t\tsizeof(struct unallocSpaceEntry));\n\t\tif (ret)\n\t\t\tgoto out;\n\t\tmemcpy(iinfo->i_ext.i_data,\n\t\t       bh->b_data + sizeof(struct unallocSpaceEntry),\n\t\t       bs - sizeof(struct unallocSpaceEntry));\n\t\treturn 0;\n\t}\n\n\tret = -EIO;\n\tread_lock(&sbi->s_cred_lock);\n\ti_uid_write(inode, le32_to_cpu(fe->uid));\n\tif (!uid_valid(inode->i_uid) ||\n\t    UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_UID_IGNORE) ||\n\t    UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_UID_SET))\n\t\tinode->i_uid = UDF_SB(inode->i_sb)->s_uid;\n\n\ti_gid_write(inode, le32_to_cpu(fe->gid));\n\tif (!gid_valid(inode->i_gid) ||\n\t    UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_GID_IGNORE) ||\n\t    UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_GID_SET))\n\t\tinode->i_gid = UDF_SB(inode->i_sb)->s_gid;\n\n\tif (fe->icbTag.fileType != ICBTAG_FILE_TYPE_DIRECTORY &&\n\t\t\tsbi->s_fmode != UDF_INVALID_MODE)\n\t\tinode->i_mode = sbi->s_fmode;\n\telse if (fe->icbTag.fileType == ICBTAG_FILE_TYPE_DIRECTORY &&\n\t\t\tsbi->s_dmode != UDF_INVALID_MODE)\n\t\tinode->i_mode = sbi->s_dmode;\n\telse\n\t\tinode->i_mode = udf_convert_permissions(fe);\n\tinode->i_mode &= ~sbi->s_umask;\n\tread_unlock(&sbi->s_cred_lock);\n\n\tlink_count = le16_to_cpu(fe->fileLinkCount);\n\tif (!link_count) {\n\t\tif (!hidden_inode) {\n\t\t\tret = -ESTALE;\n\t\t\tgoto out;\n\t\t}\n\t\tlink_count = 1;\n\t}\n\tset_nlink(inode, link_count);\n\n\tinode->i_size = le64_to_cpu(fe->informationLength);\n\tiinfo->i_lenExtents = inode->i_size;\n\n\tif (iinfo->i_efe == 0) {\n\t\tinode->i_blocks = le64_to_cpu(fe->logicalBlocksRecorded) <<\n\t\t\t(inode->i_sb->s_blocksize_bits - 9);\n\n\t\tif (!udf_disk_stamp_to_time(&inode->i_atime, fe->accessTime))\n\t\t\tinode->i_atime = sbi->s_record_time;\n\n\t\tif (!udf_disk_stamp_to_time(&inode->i_mtime,\n\t\t\t\t\t    fe->modificationTime))\n\t\t\tinode->i_mtime = sbi->s_record_time;\n\n\t\tif (!udf_disk_stamp_to_time(&inode->i_ctime, fe->attrTime))\n\t\t\tinode->i_ctime = sbi->s_record_time;\n\n\t\tiinfo->i_unique = le64_to_cpu(fe->uniqueID);\n\t\tiinfo->i_lenEAttr = le32_to_cpu(fe->lengthExtendedAttr);\n\t\tiinfo->i_lenAlloc = le32_to_cpu(fe->lengthAllocDescs);\n\t\tiinfo->i_checkpoint = le32_to_cpu(fe->checkpoint);\n\t} else {\n\t\tinode->i_blocks = le64_to_cpu(efe->logicalBlocksRecorded) <<\n\t\t    (inode->i_sb->s_blocksize_bits - 9);\n\n\t\tif (!udf_disk_stamp_to_time(&inode->i_atime, efe->accessTime))\n\t\t\tinode->i_atime = sbi->s_record_time;\n\n\t\tif (!udf_disk_stamp_to_time(&inode->i_mtime,\n\t\t\t\t\t    efe->modificationTime))\n\t\t\tinode->i_mtime = sbi->s_record_time;\n\n\t\tif (!udf_disk_stamp_to_time(&iinfo->i_crtime, efe->createTime))\n\t\t\tiinfo->i_crtime = sbi->s_record_time;\n\n\t\tif (!udf_disk_stamp_to_time(&inode->i_ctime, efe->attrTime))\n\t\t\tinode->i_ctime = sbi->s_record_time;\n\n\t\tiinfo->i_unique = le64_to_cpu(efe->uniqueID);\n\t\tiinfo->i_lenEAttr = le32_to_cpu(efe->lengthExtendedAttr);\n\t\tiinfo->i_lenAlloc = le32_to_cpu(efe->lengthAllocDescs);\n\t\tiinfo->i_checkpoint = le32_to_cpu(efe->checkpoint);\n\t}\n\tinode->i_generation = iinfo->i_unique;\n\n\t/*\n\t * Sanity check length of allocation descriptors and extended attrs to\n\t * avoid integer overflows\n\t */\n\tif (iinfo->i_lenEAttr > bs || iinfo->i_lenAlloc > bs)\n\t\tgoto out;\n\t/* Now do exact checks */\n\tif (udf_file_entry_alloc_offset(inode) + iinfo->i_lenAlloc > bs)\n\t\tgoto out;\n\t/* Sanity checks for files in ICB so that we don't get confused later */\n\tif (iinfo->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB) {\n\t\t/*\n\t\t * For file in ICB data is stored in allocation descriptor\n\t\t * so sizes should match\n\t\t */\n\t\tif (iinfo->i_lenAlloc != inode->i_size)\n\t\t\tgoto out;\n\t\t/* File in ICB has to fit in there... */\n\t\tif (inode->i_size > bs - udf_file_entry_alloc_offset(inode))\n\t\t\tgoto out;\n\t}\n\n\tswitch (fe->icbTag.fileType) {\n\tcase ICBTAG_FILE_TYPE_DIRECTORY:\n\t\tinode->i_op = &udf_dir_inode_operations;\n\t\tinode->i_fop = &udf_dir_operations;\n\t\tinode->i_mode |= S_IFDIR;\n\t\tinc_nlink(inode);\n\t\tbreak;\n\tcase ICBTAG_FILE_TYPE_REALTIME:\n\tcase ICBTAG_FILE_TYPE_REGULAR:\n\tcase ICBTAG_FILE_TYPE_UNDEF:\n\tcase ICBTAG_FILE_TYPE_VAT20:\n\t\tif (iinfo->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB)\n\t\t\tinode->i_data.a_ops = &udf_adinicb_aops;\n\t\telse\n\t\t\tinode->i_data.a_ops = &udf_aops;\n\t\tinode->i_op = &udf_file_inode_operations;\n\t\tinode->i_fop = &udf_file_operations;\n\t\tinode->i_mode |= S_IFREG;\n\t\tbreak;\n\tcase ICBTAG_FILE_TYPE_BLOCK:\n\t\tinode->i_mode |= S_IFBLK;\n\t\tbreak;\n\tcase ICBTAG_FILE_TYPE_CHAR:\n\t\tinode->i_mode |= S_IFCHR;\n\t\tbreak;\n\tcase ICBTAG_FILE_TYPE_FIFO:\n\t\tinit_special_inode(inode, inode->i_mode | S_IFIFO, 0);\n\t\tbreak;\n\tcase ICBTAG_FILE_TYPE_SOCKET:\n\t\tinit_special_inode(inode, inode->i_mode | S_IFSOCK, 0);\n\t\tbreak;\n\tcase ICBTAG_FILE_TYPE_SYMLINK:\n\t\tinode->i_data.a_ops = &udf_symlink_aops;\n\t\tinode->i_op = &udf_symlink_inode_operations;\n\t\tinode->i_mode = S_IFLNK | S_IRWXUGO;\n\t\tbreak;\n\tcase ICBTAG_FILE_TYPE_MAIN:\n\t\tudf_debug(\"METADATA FILE-----\\n\");\n\t\tbreak;\n\tcase ICBTAG_FILE_TYPE_MIRROR:\n\t\tudf_debug(\"METADATA MIRROR FILE-----\\n\");\n\t\tbreak;\n\tcase ICBTAG_FILE_TYPE_BITMAP:\n\t\tudf_debug(\"METADATA BITMAP FILE-----\\n\");\n\t\tbreak;\n\tdefault:\n\t\tudf_err(inode->i_sb, \"(ino %ld) failed unknown file type=%d\\n\",\n\t\t\tinode->i_ino, fe->icbTag.fileType);\n\t\tgoto out;\n\t}\n\tif (S_ISCHR(inode->i_mode) || S_ISBLK(inode->i_mode)) {\n\t\tstruct deviceSpec *dsea =\n\t\t\t(struct deviceSpec *)udf_get_extendedattr(inode, 12, 1);\n\t\tif (dsea) {\n\t\t\tinit_special_inode(inode, inode->i_mode,\n\t\t\t\tMKDEV(le32_to_cpu(dsea->majorDeviceIdent),\n\t\t\t\t      le32_to_cpu(dsea->minorDeviceIdent)));\n\t\t\t/* Developer ID ??? */\n\t\t} else\n\t\t\tgoto out;\n\t}\n\tret = 0;\nout:\n\tbrelse(bh);\n\treturn ret;\n}",
          "includes": [
            "#include \"udf_sb.h\"",
            "#include \"udf_i.h\"",
            "#include <linux/aio.h>",
            "#include <linux/mpage.h>",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [
            "#define UDF_MAX_ICB_NESTING 1024"
          ],
          "globals_used": [
            "static umode_t udf_convert_permissions(struct fileEntry *);",
            "static int udf_update_inode(struct inode *, int);",
            "static int udf_sync_inode(struct inode *inode);",
            "static int udf_get_block(struct inode *, sector_t, struct buffer_head *, int);",
            "const struct address_space_operations udf_aops = {\n\t.readpage\t= udf_readpage,\n\t.readpages\t= udf_readpages,\n\t.writepage\t= udf_writepage,\n\t.writepages\t= udf_writepages,\n\t.write_begin\t= udf_write_begin,\n\t.write_end\t= generic_write_end,\n\t.direct_IO\t= udf_direct_IO,\n\t.bmap\t\t= udf_bmap,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/crc-itu-t.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include \"udfdecl.h\"\n\n#define UDF_MAX_ICB_NESTING 1024\n\nstatic umode_t udf_convert_permissions(struct fileEntry *);\nstatic int udf_update_inode(struct inode *, int);\nstatic int udf_sync_inode(struct inode *inode);\nstatic int udf_get_block(struct inode *, sector_t, struct buffer_head *, int);\nconst struct address_space_operations udf_aops = {\n\t.readpage\t= udf_readpage,\n\t.readpages\t= udf_readpages,\n\t.writepage\t= udf_writepage,\n\t.writepages\t= udf_writepages,\n\t.write_begin\t= udf_write_begin,\n\t.write_end\t= generic_write_end,\n\t.direct_IO\t= udf_direct_IO,\n\t.bmap\t\t= udf_bmap,\n};\n\nstatic int udf_read_inode(struct inode *inode, bool hidden_inode)\n{\n\tstruct buffer_head *bh = NULL;\n\tstruct fileEntry *fe;\n\tstruct extendedFileEntry *efe;\n\tuint16_t ident;\n\tstruct udf_inode_info *iinfo = UDF_I(inode);\n\tstruct udf_sb_info *sbi = UDF_SB(inode->i_sb);\n\tstruct kernel_lb_addr *iloc = &iinfo->i_location;\n\tunsigned int link_count;\n\tunsigned int indirections = 0;\n\tint bs = inode->i_sb->s_blocksize;\n\tint ret = -EIO;\n\nreread:\n\tif (iloc->logicalBlockNum >=\n\t    sbi->s_partmaps[iloc->partitionReferenceNum].s_partition_len) {\n\t\tudf_debug(\"block=%d, partition=%d out of range\\n\",\n\t\t\t  iloc->logicalBlockNum, iloc->partitionReferenceNum);\n\t\treturn -EIO;\n\t}\n\n\t/*\n\t * Set defaults, but the inode is still incomplete!\n\t * Note: get_new_inode() sets the following on a new inode:\n\t *      i_sb = sb\n\t *      i_no = ino\n\t *      i_flags = sb->s_flags\n\t *      i_state = 0\n\t * clean_inode(): zero fills and sets\n\t *      i_count = 1\n\t *      i_nlink = 1\n\t *      i_op = NULL;\n\t */\n\tbh = udf_read_ptagged(inode->i_sb, iloc, 0, &ident);\n\tif (!bh) {\n\t\tudf_err(inode->i_sb, \"(ino %ld) failed !bh\\n\", inode->i_ino);\n\t\treturn -EIO;\n\t}\n\n\tif (ident != TAG_IDENT_FE && ident != TAG_IDENT_EFE &&\n\t    ident != TAG_IDENT_USE) {\n\t\tudf_err(inode->i_sb, \"(ino %ld) failed ident=%d\\n\",\n\t\t\tinode->i_ino, ident);\n\t\tgoto out;\n\t}\n\n\tfe = (struct fileEntry *)bh->b_data;\n\tefe = (struct extendedFileEntry *)bh->b_data;\n\n\tif (fe->icbTag.strategyType == cpu_to_le16(4096)) {\n\t\tstruct buffer_head *ibh;\n\n\t\tibh = udf_read_ptagged(inode->i_sb, iloc, 1, &ident);\n\t\tif (ident == TAG_IDENT_IE && ibh) {\n\t\t\tstruct kernel_lb_addr loc;\n\t\t\tstruct indirectEntry *ie;\n\n\t\t\tie = (struct indirectEntry *)ibh->b_data;\n\t\t\tloc = lelb_to_cpu(ie->indirectICB.extLocation);\n\n\t\t\tif (ie->indirectICB.extLength) {\n\t\t\t\tbrelse(ibh);\n\t\t\t\tmemcpy(&iinfo->i_location, &loc,\n\t\t\t\t       sizeof(struct kernel_lb_addr));\n\t\t\t\tif (++indirections > UDF_MAX_ICB_NESTING) {\n\t\t\t\t\tudf_err(inode->i_sb,\n\t\t\t\t\t\t\"too many ICBs in ICB hierarchy\"\n\t\t\t\t\t\t\" (max %d supported)\\n\",\n\t\t\t\t\t\tUDF_MAX_ICB_NESTING);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tbrelse(bh);\n\t\t\t\tgoto reread;\n\t\t\t}\n\t\t}\n\t\tbrelse(ibh);\n\t} else if (fe->icbTag.strategyType != cpu_to_le16(4)) {\n\t\tudf_err(inode->i_sb, \"unsupported strategy type: %d\\n\",\n\t\t\tle16_to_cpu(fe->icbTag.strategyType));\n\t\tgoto out;\n\t}\n\tif (fe->icbTag.strategyType == cpu_to_le16(4))\n\t\tiinfo->i_strat4096 = 0;\n\telse /* if (fe->icbTag.strategyType == cpu_to_le16(4096)) */\n\t\tiinfo->i_strat4096 = 1;\n\n\tiinfo->i_alloc_type = le16_to_cpu(fe->icbTag.flags) &\n\t\t\t\t\t\t\tICBTAG_FLAG_AD_MASK;\n\tiinfo->i_unique = 0;\n\tiinfo->i_lenEAttr = 0;\n\tiinfo->i_lenExtents = 0;\n\tiinfo->i_lenAlloc = 0;\n\tiinfo->i_next_alloc_block = 0;\n\tiinfo->i_next_alloc_goal = 0;\n\tif (fe->descTag.tagIdent == cpu_to_le16(TAG_IDENT_EFE)) {\n\t\tiinfo->i_efe = 1;\n\t\tiinfo->i_use = 0;\n\t\tret = udf_alloc_i_data(inode, bs -\n\t\t\t\t\tsizeof(struct extendedFileEntry));\n\t\tif (ret)\n\t\t\tgoto out;\n\t\tmemcpy(iinfo->i_ext.i_data,\n\t\t       bh->b_data + sizeof(struct extendedFileEntry),\n\t\t       bs - sizeof(struct extendedFileEntry));\n\t} else if (fe->descTag.tagIdent == cpu_to_le16(TAG_IDENT_FE)) {\n\t\tiinfo->i_efe = 0;\n\t\tiinfo->i_use = 0;\n\t\tret = udf_alloc_i_data(inode, bs - sizeof(struct fileEntry));\n\t\tif (ret)\n\t\t\tgoto out;\n\t\tmemcpy(iinfo->i_ext.i_data,\n\t\t       bh->b_data + sizeof(struct fileEntry),\n\t\t       bs - sizeof(struct fileEntry));\n\t} else if (fe->descTag.tagIdent == cpu_to_le16(TAG_IDENT_USE)) {\n\t\tiinfo->i_efe = 0;\n\t\tiinfo->i_use = 1;\n\t\tiinfo->i_lenAlloc = le32_to_cpu(\n\t\t\t\t((struct unallocSpaceEntry *)bh->b_data)->\n\t\t\t\t lengthAllocDescs);\n\t\tret = udf_alloc_i_data(inode, bs -\n\t\t\t\t\tsizeof(struct unallocSpaceEntry));\n\t\tif (ret)\n\t\t\tgoto out;\n\t\tmemcpy(iinfo->i_ext.i_data,\n\t\t       bh->b_data + sizeof(struct unallocSpaceEntry),\n\t\t       bs - sizeof(struct unallocSpaceEntry));\n\t\treturn 0;\n\t}\n\n\tret = -EIO;\n\tread_lock(&sbi->s_cred_lock);\n\ti_uid_write(inode, le32_to_cpu(fe->uid));\n\tif (!uid_valid(inode->i_uid) ||\n\t    UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_UID_IGNORE) ||\n\t    UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_UID_SET))\n\t\tinode->i_uid = UDF_SB(inode->i_sb)->s_uid;\n\n\ti_gid_write(inode, le32_to_cpu(fe->gid));\n\tif (!gid_valid(inode->i_gid) ||\n\t    UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_GID_IGNORE) ||\n\t    UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_GID_SET))\n\t\tinode->i_gid = UDF_SB(inode->i_sb)->s_gid;\n\n\tif (fe->icbTag.fileType != ICBTAG_FILE_TYPE_DIRECTORY &&\n\t\t\tsbi->s_fmode != UDF_INVALID_MODE)\n\t\tinode->i_mode = sbi->s_fmode;\n\telse if (fe->icbTag.fileType == ICBTAG_FILE_TYPE_DIRECTORY &&\n\t\t\tsbi->s_dmode != UDF_INVALID_MODE)\n\t\tinode->i_mode = sbi->s_dmode;\n\telse\n\t\tinode->i_mode = udf_convert_permissions(fe);\n\tinode->i_mode &= ~sbi->s_umask;\n\tread_unlock(&sbi->s_cred_lock);\n\n\tlink_count = le16_to_cpu(fe->fileLinkCount);\n\tif (!link_count) {\n\t\tif (!hidden_inode) {\n\t\t\tret = -ESTALE;\n\t\t\tgoto out;\n\t\t}\n\t\tlink_count = 1;\n\t}\n\tset_nlink(inode, link_count);\n\n\tinode->i_size = le64_to_cpu(fe->informationLength);\n\tiinfo->i_lenExtents = inode->i_size;\n\n\tif (iinfo->i_efe == 0) {\n\t\tinode->i_blocks = le64_to_cpu(fe->logicalBlocksRecorded) <<\n\t\t\t(inode->i_sb->s_blocksize_bits - 9);\n\n\t\tif (!udf_disk_stamp_to_time(&inode->i_atime, fe->accessTime))\n\t\t\tinode->i_atime = sbi->s_record_time;\n\n\t\tif (!udf_disk_stamp_to_time(&inode->i_mtime,\n\t\t\t\t\t    fe->modificationTime))\n\t\t\tinode->i_mtime = sbi->s_record_time;\n\n\t\tif (!udf_disk_stamp_to_time(&inode->i_ctime, fe->attrTime))\n\t\t\tinode->i_ctime = sbi->s_record_time;\n\n\t\tiinfo->i_unique = le64_to_cpu(fe->uniqueID);\n\t\tiinfo->i_lenEAttr = le32_to_cpu(fe->lengthExtendedAttr);\n\t\tiinfo->i_lenAlloc = le32_to_cpu(fe->lengthAllocDescs);\n\t\tiinfo->i_checkpoint = le32_to_cpu(fe->checkpoint);\n\t} else {\n\t\tinode->i_blocks = le64_to_cpu(efe->logicalBlocksRecorded) <<\n\t\t    (inode->i_sb->s_blocksize_bits - 9);\n\n\t\tif (!udf_disk_stamp_to_time(&inode->i_atime, efe->accessTime))\n\t\t\tinode->i_atime = sbi->s_record_time;\n\n\t\tif (!udf_disk_stamp_to_time(&inode->i_mtime,\n\t\t\t\t\t    efe->modificationTime))\n\t\t\tinode->i_mtime = sbi->s_record_time;\n\n\t\tif (!udf_disk_stamp_to_time(&iinfo->i_crtime, efe->createTime))\n\t\t\tiinfo->i_crtime = sbi->s_record_time;\n\n\t\tif (!udf_disk_stamp_to_time(&inode->i_ctime, efe->attrTime))\n\t\t\tinode->i_ctime = sbi->s_record_time;\n\n\t\tiinfo->i_unique = le64_to_cpu(efe->uniqueID);\n\t\tiinfo->i_lenEAttr = le32_to_cpu(efe->lengthExtendedAttr);\n\t\tiinfo->i_lenAlloc = le32_to_cpu(efe->lengthAllocDescs);\n\t\tiinfo->i_checkpoint = le32_to_cpu(efe->checkpoint);\n\t}\n\tinode->i_generation = iinfo->i_unique;\n\n\t/*\n\t * Sanity check length of allocation descriptors and extended attrs to\n\t * avoid integer overflows\n\t */\n\tif (iinfo->i_lenEAttr > bs || iinfo->i_lenAlloc > bs)\n\t\tgoto out;\n\t/* Now do exact checks */\n\tif (udf_file_entry_alloc_offset(inode) + iinfo->i_lenAlloc > bs)\n\t\tgoto out;\n\t/* Sanity checks for files in ICB so that we don't get confused later */\n\tif (iinfo->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB) {\n\t\t/*\n\t\t * For file in ICB data is stored in allocation descriptor\n\t\t * so sizes should match\n\t\t */\n\t\tif (iinfo->i_lenAlloc != inode->i_size)\n\t\t\tgoto out;\n\t\t/* File in ICB has to fit in there... */\n\t\tif (inode->i_size > bs - udf_file_entry_alloc_offset(inode))\n\t\t\tgoto out;\n\t}\n\n\tswitch (fe->icbTag.fileType) {\n\tcase ICBTAG_FILE_TYPE_DIRECTORY:\n\t\tinode->i_op = &udf_dir_inode_operations;\n\t\tinode->i_fop = &udf_dir_operations;\n\t\tinode->i_mode |= S_IFDIR;\n\t\tinc_nlink(inode);\n\t\tbreak;\n\tcase ICBTAG_FILE_TYPE_REALTIME:\n\tcase ICBTAG_FILE_TYPE_REGULAR:\n\tcase ICBTAG_FILE_TYPE_UNDEF:\n\tcase ICBTAG_FILE_TYPE_VAT20:\n\t\tif (iinfo->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB)\n\t\t\tinode->i_data.a_ops = &udf_adinicb_aops;\n\t\telse\n\t\t\tinode->i_data.a_ops = &udf_aops;\n\t\tinode->i_op = &udf_file_inode_operations;\n\t\tinode->i_fop = &udf_file_operations;\n\t\tinode->i_mode |= S_IFREG;\n\t\tbreak;\n\tcase ICBTAG_FILE_TYPE_BLOCK:\n\t\tinode->i_mode |= S_IFBLK;\n\t\tbreak;\n\tcase ICBTAG_FILE_TYPE_CHAR:\n\t\tinode->i_mode |= S_IFCHR;\n\t\tbreak;\n\tcase ICBTAG_FILE_TYPE_FIFO:\n\t\tinit_special_inode(inode, inode->i_mode | S_IFIFO, 0);\n\t\tbreak;\n\tcase ICBTAG_FILE_TYPE_SOCKET:\n\t\tinit_special_inode(inode, inode->i_mode | S_IFSOCK, 0);\n\t\tbreak;\n\tcase ICBTAG_FILE_TYPE_SYMLINK:\n\t\tinode->i_data.a_ops = &udf_symlink_aops;\n\t\tinode->i_op = &udf_symlink_inode_operations;\n\t\tinode->i_mode = S_IFLNK | S_IRWXUGO;\n\t\tbreak;\n\tcase ICBTAG_FILE_TYPE_MAIN:\n\t\tudf_debug(\"METADATA FILE-----\\n\");\n\t\tbreak;\n\tcase ICBTAG_FILE_TYPE_MIRROR:\n\t\tudf_debug(\"METADATA MIRROR FILE-----\\n\");\n\t\tbreak;\n\tcase ICBTAG_FILE_TYPE_BITMAP:\n\t\tudf_debug(\"METADATA BITMAP FILE-----\\n\");\n\t\tbreak;\n\tdefault:\n\t\tudf_err(inode->i_sb, \"(ino %ld) failed unknown file type=%d\\n\",\n\t\t\tinode->i_ino, fe->icbTag.fileType);\n\t\tgoto out;\n\t}\n\tif (S_ISCHR(inode->i_mode) || S_ISBLK(inode->i_mode)) {\n\t\tstruct deviceSpec *dsea =\n\t\t\t(struct deviceSpec *)udf_get_extendedattr(inode, 12, 1);\n\t\tif (dsea) {\n\t\t\tinit_special_inode(inode, inode->i_mode,\n\t\t\t\tMKDEV(le32_to_cpu(dsea->majorDeviceIdent),\n\t\t\t\t      le32_to_cpu(dsea->minorDeviceIdent)));\n\t\t\t/* Developer ID ??? */\n\t\t} else\n\t\t\tgoto out;\n\t}\n\tret = 0;\nout:\n\tbrelse(bh);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&UDF_I(inode)->i_location",
            "ino",
            "sizeof(struct kernel_lb_addr)"
          ],
          "line": 1865
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UDF_I",
          "args": [
            "inode"
          ],
          "line": 1865
        },
        "resolved": true,
        "details": {
          "function_name": "UDF_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/udf_i.h",
          "lines": "57-60",
          "snippet": "static inline struct udf_inode_info *UDF_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct udf_inode_info, vfs_inode);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline struct udf_inode_info *UDF_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct udf_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 1860
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iget_locked",
          "args": [
            "sb",
            "block"
          ],
          "line": 1856
        },
        "resolved": true,
        "details": {
          "function_name": "iget_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1063-1109",
          "snippet": "struct inode *iget_locked(struct super_block *sb, unsigned long ino)\n{\n\tstruct hlist_head *head = inode_hashtable + hash(sb, ino);\n\tstruct inode *inode;\n\n\tspin_lock(&inode_hash_lock);\n\tinode = find_inode_fast(sb, head, ino);\n\tspin_unlock(&inode_hash_lock);\n\tif (inode) {\n\t\twait_on_inode(inode);\n\t\treturn inode;\n\t}\n\n\tinode = alloc_inode(sb);\n\tif (inode) {\n\t\tstruct inode *old;\n\n\t\tspin_lock(&inode_hash_lock);\n\t\t/* We released the lock, so.. */\n\t\told = find_inode_fast(sb, head, ino);\n\t\tif (!old) {\n\t\t\tinode->i_ino = ino;\n\t\t\tspin_lock(&inode->i_lock);\n\t\t\tinode->i_state = I_NEW;\n\t\t\thlist_add_head(&inode->i_hash, head);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tinode_sb_list_add(inode);\n\t\t\tspin_unlock(&inode_hash_lock);\n\n\t\t\t/* Return the locked inode with I_NEW set, the\n\t\t\t * caller is responsible for filling in the contents\n\t\t\t */\n\t\t\treturn inode;\n\t\t}\n\n\t\t/*\n\t\t * Uhhuh, somebody else created the same inode under\n\t\t * us. Use the old inode instead of the one we just\n\t\t * allocated.\n\t\t */\n\t\tspin_unlock(&inode_hash_lock);\n\t\tdestroy_inode(inode);\n\t\tinode = old;\n\t\twait_on_inode(inode);\n\t}\n\treturn inode;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_head *inode_hashtable",
            "static __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic struct hlist_head *inode_hashtable;\nstatic __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstruct inode *iget_locked(struct super_block *sb, unsigned long ino)\n{\n\tstruct hlist_head *head = inode_hashtable + hash(sb, ino);\n\tstruct inode *inode;\n\n\tspin_lock(&inode_hash_lock);\n\tinode = find_inode_fast(sb, head, ino);\n\tspin_unlock(&inode_hash_lock);\n\tif (inode) {\n\t\twait_on_inode(inode);\n\t\treturn inode;\n\t}\n\n\tinode = alloc_inode(sb);\n\tif (inode) {\n\t\tstruct inode *old;\n\n\t\tspin_lock(&inode_hash_lock);\n\t\t/* We released the lock, so.. */\n\t\told = find_inode_fast(sb, head, ino);\n\t\tif (!old) {\n\t\t\tinode->i_ino = ino;\n\t\t\tspin_lock(&inode->i_lock);\n\t\t\tinode->i_state = I_NEW;\n\t\t\thlist_add_head(&inode->i_hash, head);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tinode_sb_list_add(inode);\n\t\t\tspin_unlock(&inode_hash_lock);\n\n\t\t\t/* Return the locked inode with I_NEW set, the\n\t\t\t * caller is responsible for filling in the contents\n\t\t\t */\n\t\t\treturn inode;\n\t\t}\n\n\t\t/*\n\t\t * Uhhuh, somebody else created the same inode under\n\t\t * us. Use the old inode instead of the one we just\n\t\t * allocated.\n\t\t */\n\t\tspin_unlock(&inode_hash_lock);\n\t\tdestroy_inode(inode);\n\t\tinode = old;\n\t\twait_on_inode(inode);\n\t}\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_get_lb_pblock",
          "args": [
            "sb",
            "ino",
            "0"
          ],
          "line": 1855
        },
        "resolved": true,
        "details": {
          "function_name": "udf_get_lb_pblock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/udfdecl.h",
          "lines": "205-211",
          "snippet": "static inline uint32_t\nudf_get_lb_pblock(struct super_block *sb, struct kernel_lb_addr *loc,\n\t\t  uint32_t offset)\n{\n\treturn udf_get_pblock(sb, loc->logicalBlockNum,\n\t\t\tloc->partitionReferenceNum, offset);\n}",
          "includes": [
            "#include \"udf_i.h\"",
            "#include \"udfend.h\"",
            "#include \"udf_sb.h\"",
            "#include <linux/udf_fs_i.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include \"osta_udf.h\"",
            "#include \"ecma_167.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_i.h\"\n#include \"udfend.h\"\n#include \"udf_sb.h\"\n#include <linux/udf_fs_i.h>\n#include <linux/buffer_head.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include \"osta_udf.h\"\n#include \"ecma_167.h\"\n\nstatic inline uint32_t\nudf_get_lb_pblock(struct super_block *sb, struct kernel_lb_addr *loc,\n\t\t  uint32_t offset)\n{\n\treturn udf_get_pblock(sb, loc->logicalBlockNum,\n\t\t\tloc->partitionReferenceNum, offset);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/crc-itu-t.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include \"udfdecl.h\"\n\nstatic int udf_update_inode(struct inode *, int);\nstatic int udf_sync_inode(struct inode *inode);\n\nstruct inode *__udf_iget(struct super_block *sb, struct kernel_lb_addr *ino,\n\t\t\t bool hidden_inode)\n{\n\tunsigned long block = udf_get_lb_pblock(sb, ino, 0);\n\tstruct inode *inode = iget_locked(sb, block);\n\tint err;\n\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (!(inode->i_state & I_NEW))\n\t\treturn inode;\n\n\tmemcpy(&UDF_I(inode)->i_location, ino, sizeof(struct kernel_lb_addr));\n\terr = udf_read_inode(inode, hidden_inode);\n\tif (err < 0) {\n\t\tiget_failed(inode);\n\t\treturn ERR_PTR(err);\n\t}\n\tunlock_new_inode(inode);\n\n\treturn inode;\n}"
  },
  {
    "function_name": "udf_update_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/inode.c",
    "lines": "1622-1850",
    "snippet": "static int udf_update_inode(struct inode *inode, int do_sync)\n{\n\tstruct buffer_head *bh = NULL;\n\tstruct fileEntry *fe;\n\tstruct extendedFileEntry *efe;\n\tuint64_t lb_recorded;\n\tuint32_t udfperms;\n\tuint16_t icbflags;\n\tuint16_t crclen;\n\tint err = 0;\n\tstruct udf_sb_info *sbi = UDF_SB(inode->i_sb);\n\tunsigned char blocksize_bits = inode->i_sb->s_blocksize_bits;\n\tstruct udf_inode_info *iinfo = UDF_I(inode);\n\n\tbh = udf_tgetblk(inode->i_sb,\n\t\t\tudf_get_lb_pblock(inode->i_sb, &iinfo->i_location, 0));\n\tif (!bh) {\n\t\tudf_debug(\"getblk failure\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tlock_buffer(bh);\n\tmemset(bh->b_data, 0, inode->i_sb->s_blocksize);\n\tfe = (struct fileEntry *)bh->b_data;\n\tefe = (struct extendedFileEntry *)bh->b_data;\n\n\tif (iinfo->i_use) {\n\t\tstruct unallocSpaceEntry *use =\n\t\t\t(struct unallocSpaceEntry *)bh->b_data;\n\n\t\tuse->lengthAllocDescs = cpu_to_le32(iinfo->i_lenAlloc);\n\t\tmemcpy(bh->b_data + sizeof(struct unallocSpaceEntry),\n\t\t       iinfo->i_ext.i_data, inode->i_sb->s_blocksize -\n\t\t\t\t\tsizeof(struct unallocSpaceEntry));\n\t\tuse->descTag.tagIdent = cpu_to_le16(TAG_IDENT_USE);\n\t\tuse->descTag.tagLocation =\n\t\t\t\tcpu_to_le32(iinfo->i_location.logicalBlockNum);\n\t\tcrclen = sizeof(struct unallocSpaceEntry) +\n\t\t\t\tiinfo->i_lenAlloc - sizeof(struct tag);\n\t\tuse->descTag.descCRCLength = cpu_to_le16(crclen);\n\t\tuse->descTag.descCRC = cpu_to_le16(crc_itu_t(0, (char *)use +\n\t\t\t\t\t\t\t   sizeof(struct tag),\n\t\t\t\t\t\t\t   crclen));\n\t\tuse->descTag.tagChecksum = udf_tag_checksum(&use->descTag);\n\n\t\tgoto out;\n\t}\n\n\tif (UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_UID_FORGET))\n\t\tfe->uid = cpu_to_le32(-1);\n\telse\n\t\tfe->uid = cpu_to_le32(i_uid_read(inode));\n\n\tif (UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_GID_FORGET))\n\t\tfe->gid = cpu_to_le32(-1);\n\telse\n\t\tfe->gid = cpu_to_le32(i_gid_read(inode));\n\n\tudfperms = ((inode->i_mode & S_IRWXO)) |\n\t\t   ((inode->i_mode & S_IRWXG) << 2) |\n\t\t   ((inode->i_mode & S_IRWXU) << 4);\n\n\tudfperms |= (le32_to_cpu(fe->permissions) &\n\t\t    (FE_PERM_O_DELETE | FE_PERM_O_CHATTR |\n\t\t     FE_PERM_G_DELETE | FE_PERM_G_CHATTR |\n\t\t     FE_PERM_U_DELETE | FE_PERM_U_CHATTR));\n\tfe->permissions = cpu_to_le32(udfperms);\n\n\tif (S_ISDIR(inode->i_mode) && inode->i_nlink > 0)\n\t\tfe->fileLinkCount = cpu_to_le16(inode->i_nlink - 1);\n\telse\n\t\tfe->fileLinkCount = cpu_to_le16(inode->i_nlink);\n\n\tfe->informationLength = cpu_to_le64(inode->i_size);\n\n\tif (S_ISCHR(inode->i_mode) || S_ISBLK(inode->i_mode)) {\n\t\tstruct regid *eid;\n\t\tstruct deviceSpec *dsea =\n\t\t\t(struct deviceSpec *)udf_get_extendedattr(inode, 12, 1);\n\t\tif (!dsea) {\n\t\t\tdsea = (struct deviceSpec *)\n\t\t\t\tudf_add_extendedattr(inode,\n\t\t\t\t\t\t     sizeof(struct deviceSpec) +\n\t\t\t\t\t\t     sizeof(struct regid), 12, 0x3);\n\t\t\tdsea->attrType = cpu_to_le32(12);\n\t\t\tdsea->attrSubtype = 1;\n\t\t\tdsea->attrLength = cpu_to_le32(\n\t\t\t\t\t\tsizeof(struct deviceSpec) +\n\t\t\t\t\t\tsizeof(struct regid));\n\t\t\tdsea->impUseLength = cpu_to_le32(sizeof(struct regid));\n\t\t}\n\t\teid = (struct regid *)dsea->impUse;\n\t\tmemset(eid, 0, sizeof(struct regid));\n\t\tstrcpy(eid->ident, UDF_ID_DEVELOPER);\n\t\teid->identSuffix[0] = UDF_OS_CLASS_UNIX;\n\t\teid->identSuffix[1] = UDF_OS_ID_LINUX;\n\t\tdsea->majorDeviceIdent = cpu_to_le32(imajor(inode));\n\t\tdsea->minorDeviceIdent = cpu_to_le32(iminor(inode));\n\t}\n\n\tif (iinfo->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB)\n\t\tlb_recorded = 0; /* No extents => no blocks! */\n\telse\n\t\tlb_recorded =\n\t\t\t(inode->i_blocks + (1 << (blocksize_bits - 9)) - 1) >>\n\t\t\t(blocksize_bits - 9);\n\n\tif (iinfo->i_efe == 0) {\n\t\tmemcpy(bh->b_data + sizeof(struct fileEntry),\n\t\t       iinfo->i_ext.i_data,\n\t\t       inode->i_sb->s_blocksize - sizeof(struct fileEntry));\n\t\tfe->logicalBlocksRecorded = cpu_to_le64(lb_recorded);\n\n\t\tudf_time_to_disk_stamp(&fe->accessTime, inode->i_atime);\n\t\tudf_time_to_disk_stamp(&fe->modificationTime, inode->i_mtime);\n\t\tudf_time_to_disk_stamp(&fe->attrTime, inode->i_ctime);\n\t\tmemset(&(fe->impIdent), 0, sizeof(struct regid));\n\t\tstrcpy(fe->impIdent.ident, UDF_ID_DEVELOPER);\n\t\tfe->impIdent.identSuffix[0] = UDF_OS_CLASS_UNIX;\n\t\tfe->impIdent.identSuffix[1] = UDF_OS_ID_LINUX;\n\t\tfe->uniqueID = cpu_to_le64(iinfo->i_unique);\n\t\tfe->lengthExtendedAttr = cpu_to_le32(iinfo->i_lenEAttr);\n\t\tfe->lengthAllocDescs = cpu_to_le32(iinfo->i_lenAlloc);\n\t\tfe->checkpoint = cpu_to_le32(iinfo->i_checkpoint);\n\t\tfe->descTag.tagIdent = cpu_to_le16(TAG_IDENT_FE);\n\t\tcrclen = sizeof(struct fileEntry);\n\t} else {\n\t\tmemcpy(bh->b_data + sizeof(struct extendedFileEntry),\n\t\t       iinfo->i_ext.i_data,\n\t\t       inode->i_sb->s_blocksize -\n\t\t\t\t\tsizeof(struct extendedFileEntry));\n\t\tefe->objectSize = cpu_to_le64(inode->i_size);\n\t\tefe->logicalBlocksRecorded = cpu_to_le64(lb_recorded);\n\n\t\tif (iinfo->i_crtime.tv_sec > inode->i_atime.tv_sec ||\n\t\t    (iinfo->i_crtime.tv_sec == inode->i_atime.tv_sec &&\n\t\t     iinfo->i_crtime.tv_nsec > inode->i_atime.tv_nsec))\n\t\t\tiinfo->i_crtime = inode->i_atime;\n\n\t\tif (iinfo->i_crtime.tv_sec > inode->i_mtime.tv_sec ||\n\t\t    (iinfo->i_crtime.tv_sec == inode->i_mtime.tv_sec &&\n\t\t     iinfo->i_crtime.tv_nsec > inode->i_mtime.tv_nsec))\n\t\t\tiinfo->i_crtime = inode->i_mtime;\n\n\t\tif (iinfo->i_crtime.tv_sec > inode->i_ctime.tv_sec ||\n\t\t    (iinfo->i_crtime.tv_sec == inode->i_ctime.tv_sec &&\n\t\t     iinfo->i_crtime.tv_nsec > inode->i_ctime.tv_nsec))\n\t\t\tiinfo->i_crtime = inode->i_ctime;\n\n\t\tudf_time_to_disk_stamp(&efe->accessTime, inode->i_atime);\n\t\tudf_time_to_disk_stamp(&efe->modificationTime, inode->i_mtime);\n\t\tudf_time_to_disk_stamp(&efe->createTime, iinfo->i_crtime);\n\t\tudf_time_to_disk_stamp(&efe->attrTime, inode->i_ctime);\n\n\t\tmemset(&(efe->impIdent), 0, sizeof(struct regid));\n\t\tstrcpy(efe->impIdent.ident, UDF_ID_DEVELOPER);\n\t\tefe->impIdent.identSuffix[0] = UDF_OS_CLASS_UNIX;\n\t\tefe->impIdent.identSuffix[1] = UDF_OS_ID_LINUX;\n\t\tefe->uniqueID = cpu_to_le64(iinfo->i_unique);\n\t\tefe->lengthExtendedAttr = cpu_to_le32(iinfo->i_lenEAttr);\n\t\tefe->lengthAllocDescs = cpu_to_le32(iinfo->i_lenAlloc);\n\t\tefe->checkpoint = cpu_to_le32(iinfo->i_checkpoint);\n\t\tefe->descTag.tagIdent = cpu_to_le16(TAG_IDENT_EFE);\n\t\tcrclen = sizeof(struct extendedFileEntry);\n\t}\n\tif (iinfo->i_strat4096) {\n\t\tfe->icbTag.strategyType = cpu_to_le16(4096);\n\t\tfe->icbTag.strategyParameter = cpu_to_le16(1);\n\t\tfe->icbTag.numEntries = cpu_to_le16(2);\n\t} else {\n\t\tfe->icbTag.strategyType = cpu_to_le16(4);\n\t\tfe->icbTag.numEntries = cpu_to_le16(1);\n\t}\n\n\tif (S_ISDIR(inode->i_mode))\n\t\tfe->icbTag.fileType = ICBTAG_FILE_TYPE_DIRECTORY;\n\telse if (S_ISREG(inode->i_mode))\n\t\tfe->icbTag.fileType = ICBTAG_FILE_TYPE_REGULAR;\n\telse if (S_ISLNK(inode->i_mode))\n\t\tfe->icbTag.fileType = ICBTAG_FILE_TYPE_SYMLINK;\n\telse if (S_ISBLK(inode->i_mode))\n\t\tfe->icbTag.fileType = ICBTAG_FILE_TYPE_BLOCK;\n\telse if (S_ISCHR(inode->i_mode))\n\t\tfe->icbTag.fileType = ICBTAG_FILE_TYPE_CHAR;\n\telse if (S_ISFIFO(inode->i_mode))\n\t\tfe->icbTag.fileType = ICBTAG_FILE_TYPE_FIFO;\n\telse if (S_ISSOCK(inode->i_mode))\n\t\tfe->icbTag.fileType = ICBTAG_FILE_TYPE_SOCKET;\n\n\ticbflags =\tiinfo->i_alloc_type |\n\t\t\t((inode->i_mode & S_ISUID) ? ICBTAG_FLAG_SETUID : 0) |\n\t\t\t((inode->i_mode & S_ISGID) ? ICBTAG_FLAG_SETGID : 0) |\n\t\t\t((inode->i_mode & S_ISVTX) ? ICBTAG_FLAG_STICKY : 0) |\n\t\t\t(le16_to_cpu(fe->icbTag.flags) &\n\t\t\t\t~(ICBTAG_FLAG_AD_MASK | ICBTAG_FLAG_SETUID |\n\t\t\t\tICBTAG_FLAG_SETGID | ICBTAG_FLAG_STICKY));\n\n\tfe->icbTag.flags = cpu_to_le16(icbflags);\n\tif (sbi->s_udfrev >= 0x0200)\n\t\tfe->descTag.descVersion = cpu_to_le16(3);\n\telse\n\t\tfe->descTag.descVersion = cpu_to_le16(2);\n\tfe->descTag.tagSerialNum = cpu_to_le16(sbi->s_serial_number);\n\tfe->descTag.tagLocation = cpu_to_le32(\n\t\t\t\t\tiinfo->i_location.logicalBlockNum);\n\tcrclen += iinfo->i_lenEAttr + iinfo->i_lenAlloc - sizeof(struct tag);\n\tfe->descTag.descCRCLength = cpu_to_le16(crclen);\n\tfe->descTag.descCRC = cpu_to_le16(crc_itu_t(0, (char *)fe + sizeof(struct tag),\n\t\t\t\t\t\t  crclen));\n\tfe->descTag.tagChecksum = udf_tag_checksum(&fe->descTag);\n\nout:\n\tset_buffer_uptodate(bh);\n\tunlock_buffer(bh);\n\n\t/* write the data blocks */\n\tmark_buffer_dirty(bh);\n\tif (do_sync) {\n\t\tsync_dirty_buffer(bh);\n\t\tif (buffer_write_io_error(bh)) {\n\t\t\tudf_warn(inode->i_sb, \"IO error syncing udf inode [%08lx]\\n\",\n\t\t\t\t inode->i_ino);\n\t\t\terr = -EIO;\n\t\t}\n\t}\n\tbrelse(bh);\n\n\treturn err;\n}",
    "includes": [
      "#include \"udf_sb.h\"",
      "#include \"udf_i.h\"",
      "#include <linux/aio.h>",
      "#include <linux/mpage.h>",
      "#include <linux/crc-itu-t.h>",
      "#include <linux/slab.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include \"udfdecl.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static umode_t udf_convert_permissions(struct fileEntry *);",
      "static int udf_update_inode(struct inode *, int);",
      "static int udf_sync_inode(struct inode *inode);",
      "static int8_t udf_insert_aext(struct inode *, struct extent_position,\n\t\t\t      struct kernel_lb_addr, uint32_t);",
      "static int udf_get_block(struct inode *, sector_t, struct buffer_head *, int);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 1847
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_warn",
          "args": [
            "inode->i_sb",
            "\"IO error syncing udf inode [%08lx]\\n\"",
            "inode->i_ino"
          ],
          "line": 1842
        },
        "resolved": true,
        "details": {
          "function_name": "_udf_warn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/super.c",
          "lines": "2272-2286",
          "snippet": "void _udf_warn(struct super_block *sb, const char *function,\n\t       const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tpr_warn(\"warning (device %s): %s: %pV\", sb->s_id, function, &vaf);\n\n\tva_end(args);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/init.h>",
            "#include \"udf_i.h\"",
            "#include \"udf_sb.h\"",
            "#include <asm/byteorder.h>",
            "#include <linux/log2.h>",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/errno.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/vfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/nls.h>",
            "#include <linux/cdrom.h>",
            "#include <linux/stat.h>",
            "#include <linux/parser.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int udf_fill_super(struct super_block *, void *, int);",
            "static void udf_put_super(struct super_block *);",
            "static int udf_sync_fs(struct super_block *, int);",
            "static int udf_remount_fs(struct super_block *, int *, char *);",
            "static void udf_open_lvid(struct super_block *);",
            "static void udf_close_lvid(struct super_block *);",
            "static unsigned int udf_count_free(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/init.h>\n#include \"udf_i.h\"\n#include \"udf_sb.h\"\n#include <asm/byteorder.h>\n#include <linux/log2.h>\n#include <linux/crc-itu-t.h>\n#include <linux/bitmap.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/errno.h>\n#include <linux/vmalloc.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/nls.h>\n#include <linux/cdrom.h>\n#include <linux/stat.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include \"udfdecl.h\"\n\nstatic int udf_fill_super(struct super_block *, void *, int);\nstatic void udf_put_super(struct super_block *);\nstatic int udf_sync_fs(struct super_block *, int);\nstatic int udf_remount_fs(struct super_block *, int *, char *);\nstatic void udf_open_lvid(struct super_block *);\nstatic void udf_close_lvid(struct super_block *);\nstatic unsigned int udf_count_free(struct super_block *);\n\nvoid _udf_warn(struct super_block *sb, const char *function,\n\t       const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tpr_warn(\"warning (device %s): %s: %pV\", sb->s_id, function, &vaf);\n\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "buffer_write_io_error",
          "args": [
            "bh"
          ],
          "line": 1841
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sync_dirty_buffer",
          "args": [
            "bh"
          ],
          "line": 1840
        },
        "resolved": true,
        "details": {
          "function_name": "sync_dirty_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "3153-3156",
          "snippet": "int sync_dirty_buffer(struct buffer_head *bh)\n{\n\treturn __sync_dirty_buffer(bh, WRITE_SYNC);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint sync_dirty_buffer(struct buffer_head *bh)\n{\n\treturn __sync_dirty_buffer(bh, WRITE_SYNC);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_buffer_dirty",
          "args": [
            "bh"
          ],
          "line": 1838
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1141-1167",
          "snippet": "void mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_buffer",
          "args": [
            "bh"
          ],
          "line": 1835
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "70-75",
          "snippet": "void unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_buffer_uptodate",
          "args": [
            "bh"
          ],
          "line": 1834
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3758-3761",
          "snippet": "int btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_tag_checksum",
          "args": [
            "&fe->descTag"
          ],
          "line": 1831
        },
        "resolved": true,
        "details": {
          "function_name": "udf_tag_checksum",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/misc.c",
          "lines": "290-299",
          "snippet": "u8 udf_tag_checksum(const struct tag *t)\n{\n\tu8 *data = (u8 *)t;\n\tu8 checksum = 0;\n\tint i;\n\tfor (i = 0; i < sizeof(struct tag); ++i)\n\t\tif (i != 4) /* position of checksum */\n\t\t\tchecksum += data[i];\n\treturn checksum;\n}",
          "includes": [
            "#include \"udf_sb.h\"",
            "#include \"udf_i.h\"",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/crc-itu-t.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include \"udfdecl.h\"\n\nu8 udf_tag_checksum(const struct tag *t)\n{\n\tu8 *data = (u8 *)t;\n\tu8 checksum = 0;\n\tint i;\n\tfor (i = 0; i < sizeof(struct tag); ++i)\n\t\tif (i != 4) /* position of checksum */\n\t\t\tchecksum += data[i];\n\treturn checksum;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "crc_itu_t(0, (char *)fe + sizeof(struct tag),\n\t\t\t\t\t\t  crclen)"
          ],
          "line": 1829
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crc_itu_t",
          "args": [
            "0",
            "(char *)fe + sizeof(struct tag)",
            "crclen"
          ],
          "line": 1829
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "crclen"
          ],
          "line": 1828
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "iinfo->i_location.logicalBlockNum"
          ],
          "line": 1825
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "sbi->s_serial_number"
          ],
          "line": 1824
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "2"
          ],
          "line": 1823
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "3"
          ],
          "line": 1821
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "icbflags"
          ],
          "line": 1819
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "fe->icbTag.flags"
          ],
          "line": 1815
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISSOCK",
          "args": [
            "inode->i_mode"
          ],
          "line": 1808
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISFIFO",
          "args": [
            "inode->i_mode"
          ],
          "line": 1806
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISCHR",
          "args": [
            "inode->i_mode"
          ],
          "line": 1804
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISBLK",
          "args": [
            "inode->i_mode"
          ],
          "line": 1802
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISLNK",
          "args": [
            "inode->i_mode"
          ],
          "line": 1800
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "inode->i_mode"
          ],
          "line": 1798
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "inode->i_mode"
          ],
          "line": 1796
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "1"
          ],
          "line": 1793
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "4"
          ],
          "line": 1792
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "2"
          ],
          "line": 1790
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "1"
          ],
          "line": 1789
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "4096"
          ],
          "line": 1788
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "TAG_IDENT_EFE"
          ],
          "line": 1784
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "iinfo->i_checkpoint"
          ],
          "line": 1783
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "iinfo->i_lenAlloc"
          ],
          "line": 1782
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "iinfo->i_lenEAttr"
          ],
          "line": 1781
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "iinfo->i_unique"
          ],
          "line": 1780
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "efe->impIdent.ident",
            "UDF_ID_DEVELOPER"
          ],
          "line": 1777
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&(efe->impIdent)",
            "0",
            "sizeof(struct regid)"
          ],
          "line": 1776
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udf_time_to_disk_stamp",
          "args": [
            "&efe->attrTime",
            "inode->i_ctime"
          ],
          "line": 1774
        },
        "resolved": true,
        "details": {
          "function_name": "udf_time_to_disk_stamp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/udftime.c",
          "lines": "119-168",
          "snippet": "struct timestamp *\nudf_time_to_disk_stamp(struct timestamp *dest, struct timespec ts)\n{\n\tlong int days, rem, y;\n\tconst unsigned short int *ip;\n\tint16_t offset;\n\n\toffset = -sys_tz.tz_minuteswest;\n\n\tif (!dest)\n\t\treturn NULL;\n\n\tdest->typeAndTimezone = cpu_to_le16(0x1000 | (offset & 0x0FFF));\n\n\tts.tv_sec += offset * 60;\n\tdays = ts.tv_sec / SECS_PER_DAY;\n\trem = ts.tv_sec % SECS_PER_DAY;\n\tdest->hour = rem / SECS_PER_HOUR;\n\trem %= SECS_PER_HOUR;\n\tdest->minute = rem / 60;\n\tdest->second = rem % 60;\n\ty = 1970;\n\n#define DIV(a, b) ((a) / (b) - ((a) % (b) < 0))\n#define LEAPS_THRU_END_OF(y) (DIV (y, 4) - DIV (y, 100) + DIV (y, 400))\n\n\twhile (days < 0 || days >= (__isleap(y) ? 366 : 365)) {\n\t\tlong int yg = y + days / 365 - (days % 365 < 0);\n\n\t\t/* Adjust DAYS and Y to match the guessed year.  */\n\t\tdays -= ((yg - y) * 365\n\t\t\t + LEAPS_THRU_END_OF(yg - 1)\n\t\t\t - LEAPS_THRU_END_OF(y - 1));\n\t\ty = yg;\n\t}\n\tdest->year = cpu_to_le16(y);\n\tip = __mon_yday[__isleap(y)];\n\tfor (y = 11; days < (long int)ip[y]; --y)\n\t\tcontinue;\n\tdays -= ip[y];\n\tdest->month = y + 1;\n\tdest->day = days + 1;\n\n\tdest->centiseconds = ts.tv_nsec / 10000000;\n\tdest->hundredsOfMicroseconds = (ts.tv_nsec / 1000 -\n\t\t\t\t\tdest->centiseconds * 10000) / 100;\n\tdest->microseconds = (ts.tv_nsec / 1000 - dest->centiseconds * 10000 -\n\t\t\t      dest->hundredsOfMicroseconds * 100);\n\treturn dest;\n}",
          "includes": [
            "#include <linux/kernel.h>",
            "#include <linux/types.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [
            "#define SECS_PER_DAY\t(SECS_PER_HOUR * 24)",
            "#define SECS_PER_HOUR\t(60 * 60)"
          ],
          "globals_used": [
            "static const unsigned short int __mon_yday[2][13] = {\n\t/* Normal years.  */\n\t{0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365},\n\t/* Leap years.  */\n\t{0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335, 366}\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/types.h>\n#include \"udfdecl.h\"\n\n#define SECS_PER_DAY\t(SECS_PER_HOUR * 24)\n#define SECS_PER_HOUR\t(60 * 60)\n\nstatic const unsigned short int __mon_yday[2][13] = {\n\t/* Normal years.  */\n\t{0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365},\n\t/* Leap years.  */\n\t{0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335, 366}\n};\n\nstruct timestamp *\nudf_time_to_disk_stamp(struct timestamp *dest, struct timespec ts)\n{\n\tlong int days, rem, y;\n\tconst unsigned short int *ip;\n\tint16_t offset;\n\n\toffset = -sys_tz.tz_minuteswest;\n\n\tif (!dest)\n\t\treturn NULL;\n\n\tdest->typeAndTimezone = cpu_to_le16(0x1000 | (offset & 0x0FFF));\n\n\tts.tv_sec += offset * 60;\n\tdays = ts.tv_sec / SECS_PER_DAY;\n\trem = ts.tv_sec % SECS_PER_DAY;\n\tdest->hour = rem / SECS_PER_HOUR;\n\trem %= SECS_PER_HOUR;\n\tdest->minute = rem / 60;\n\tdest->second = rem % 60;\n\ty = 1970;\n\n#define DIV(a, b) ((a) / (b) - ((a) % (b) < 0))\n#define LEAPS_THRU_END_OF(y) (DIV (y, 4) - DIV (y, 100) + DIV (y, 400))\n\n\twhile (days < 0 || days >= (__isleap(y) ? 366 : 365)) {\n\t\tlong int yg = y + days / 365 - (days % 365 < 0);\n\n\t\t/* Adjust DAYS and Y to match the guessed year.  */\n\t\tdays -= ((yg - y) * 365\n\t\t\t + LEAPS_THRU_END_OF(yg - 1)\n\t\t\t - LEAPS_THRU_END_OF(y - 1));\n\t\ty = yg;\n\t}\n\tdest->year = cpu_to_le16(y);\n\tip = __mon_yday[__isleap(y)];\n\tfor (y = 11; days < (long int)ip[y]; --y)\n\t\tcontinue;\n\tdays -= ip[y];\n\tdest->month = y + 1;\n\tdest->day = days + 1;\n\n\tdest->centiseconds = ts.tv_nsec / 10000000;\n\tdest->hundredsOfMicroseconds = (ts.tv_nsec / 1000 -\n\t\t\t\t\tdest->centiseconds * 10000) / 100;\n\tdest->microseconds = (ts.tv_nsec / 1000 - dest->centiseconds * 10000 -\n\t\t\t      dest->hundredsOfMicroseconds * 100);\n\treturn dest;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "lb_recorded"
          ],
          "line": 1754
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "inode->i_size"
          ],
          "line": 1753
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "bh->b_data + sizeof(struct extendedFileEntry)",
            "iinfo->i_ext.i_data",
            "inode->i_sb->s_blocksize -\n\t\t\t\t\tsizeof(struct extendedFileEntry)"
          ],
          "line": 1749
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "TAG_IDENT_FE"
          ],
          "line": 1746
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "iinfo->i_checkpoint"
          ],
          "line": 1745
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "iinfo->i_lenAlloc"
          ],
          "line": 1744
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "iinfo->i_lenEAttr"
          ],
          "line": 1743
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "iinfo->i_unique"
          ],
          "line": 1742
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "fe->impIdent.ident",
            "UDF_ID_DEVELOPER"
          ],
          "line": 1739
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&(fe->impIdent)",
            "0",
            "sizeof(struct regid)"
          ],
          "line": 1738
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "lb_recorded"
          ],
          "line": 1733
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "bh->b_data + sizeof(struct fileEntry)",
            "iinfo->i_ext.i_data",
            "inode->i_sb->s_blocksize - sizeof(struct fileEntry)"
          ],
          "line": 1730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "iminor(inode)"
          ],
          "line": 1719
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iminor",
          "args": [
            "inode"
          ],
          "line": 1719
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "imajor(inode)"
          ],
          "line": 1718
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "imajor",
          "args": [
            "inode"
          ],
          "line": 1718
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "eid->ident",
            "UDF_ID_DEVELOPER"
          ],
          "line": 1715
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "eid",
            "0",
            "sizeof(struct regid)"
          ],
          "line": 1714
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "sizeof(struct regid)"
          ],
          "line": 1711
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "sizeof(struct deviceSpec) +\n\t\t\t\t\t\tsizeof(struct regid)"
          ],
          "line": 1708
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "12"
          ],
          "line": 1706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udf_add_extendedattr",
          "args": [
            "inode",
            "sizeof(struct deviceSpec) +\n\t\t\t\t\t\t     sizeof(struct regid)",
            "12",
            "0x3"
          ],
          "line": 1703
        },
        "resolved": true,
        "details": {
          "function_name": "udf_add_extendedattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/misc.c",
          "lines": "48-149",
          "snippet": "struct genericFormat *udf_add_extendedattr(struct inode *inode, uint32_t size,\n\t\t\t\t\t   uint32_t type, uint8_t loc)\n{\n\tuint8_t *ea = NULL, *ad = NULL;\n\tint offset;\n\tuint16_t crclen;\n\tstruct udf_inode_info *iinfo = UDF_I(inode);\n\n\tea = iinfo->i_ext.i_data;\n\tif (iinfo->i_lenEAttr) {\n\t\tad = iinfo->i_ext.i_data + iinfo->i_lenEAttr;\n\t} else {\n\t\tad = ea;\n\t\tsize += sizeof(struct extendedAttrHeaderDesc);\n\t}\n\n\toffset = inode->i_sb->s_blocksize - udf_file_entry_alloc_offset(inode) -\n\t\tiinfo->i_lenAlloc;\n\n\t/* TODO - Check for FreeEASpace */\n\n\tif (loc & 0x01 && offset >= size) {\n\t\tstruct extendedAttrHeaderDesc *eahd;\n\t\teahd = (struct extendedAttrHeaderDesc *)ea;\n\n\t\tif (iinfo->i_lenAlloc)\n\t\t\tmemmove(&ad[size], ad, iinfo->i_lenAlloc);\n\n\t\tif (iinfo->i_lenEAttr) {\n\t\t\t/* check checksum/crc */\n\t\t\tif (eahd->descTag.tagIdent !=\n\t\t\t\t\tcpu_to_le16(TAG_IDENT_EAHD) ||\n\t\t\t    le32_to_cpu(eahd->descTag.tagLocation) !=\n\t\t\t\t\tiinfo->i_location.logicalBlockNum)\n\t\t\t\treturn NULL;\n\t\t} else {\n\t\t\tstruct udf_sb_info *sbi = UDF_SB(inode->i_sb);\n\n\t\t\tsize -= sizeof(struct extendedAttrHeaderDesc);\n\t\t\tiinfo->i_lenEAttr +=\n\t\t\t\tsizeof(struct extendedAttrHeaderDesc);\n\t\t\teahd->descTag.tagIdent = cpu_to_le16(TAG_IDENT_EAHD);\n\t\t\tif (sbi->s_udfrev >= 0x0200)\n\t\t\t\teahd->descTag.descVersion = cpu_to_le16(3);\n\t\t\telse\n\t\t\t\teahd->descTag.descVersion = cpu_to_le16(2);\n\t\t\teahd->descTag.tagSerialNum =\n\t\t\t\t\tcpu_to_le16(sbi->s_serial_number);\n\t\t\teahd->descTag.tagLocation = cpu_to_le32(\n\t\t\t\t\tiinfo->i_location.logicalBlockNum);\n\t\t\teahd->impAttrLocation = cpu_to_le32(0xFFFFFFFF);\n\t\t\teahd->appAttrLocation = cpu_to_le32(0xFFFFFFFF);\n\t\t}\n\n\t\toffset = iinfo->i_lenEAttr;\n\t\tif (type < 2048) {\n\t\t\tif (le32_to_cpu(eahd->appAttrLocation) <\n\t\t\t\t\tiinfo->i_lenEAttr) {\n\t\t\t\tuint32_t aal =\n\t\t\t\t\tle32_to_cpu(eahd->appAttrLocation);\n\t\t\t\tmemmove(&ea[offset - aal + size],\n\t\t\t\t\t&ea[aal], offset - aal);\n\t\t\t\toffset -= aal;\n\t\t\t\teahd->appAttrLocation =\n\t\t\t\t\t\tcpu_to_le32(aal + size);\n\t\t\t}\n\t\t\tif (le32_to_cpu(eahd->impAttrLocation) <\n\t\t\t\t\tiinfo->i_lenEAttr) {\n\t\t\t\tuint32_t ial =\n\t\t\t\t\tle32_to_cpu(eahd->impAttrLocation);\n\t\t\t\tmemmove(&ea[offset - ial + size],\n\t\t\t\t\t&ea[ial], offset - ial);\n\t\t\t\toffset -= ial;\n\t\t\t\teahd->impAttrLocation =\n\t\t\t\t\t\tcpu_to_le32(ial + size);\n\t\t\t}\n\t\t} else if (type < 65536) {\n\t\t\tif (le32_to_cpu(eahd->appAttrLocation) <\n\t\t\t\t\tiinfo->i_lenEAttr) {\n\t\t\t\tuint32_t aal =\n\t\t\t\t\tle32_to_cpu(eahd->appAttrLocation);\n\t\t\t\tmemmove(&ea[offset - aal + size],\n\t\t\t\t\t&ea[aal], offset - aal);\n\t\t\t\toffset -= aal;\n\t\t\t\teahd->appAttrLocation =\n\t\t\t\t\t\tcpu_to_le32(aal + size);\n\t\t\t}\n\t\t}\n\t\t/* rewrite CRC + checksum of eahd */\n\t\tcrclen = sizeof(struct extendedAttrHeaderDesc) - sizeof(struct tag);\n\t\teahd->descTag.descCRCLength = cpu_to_le16(crclen);\n\t\teahd->descTag.descCRC = cpu_to_le16(crc_itu_t(0, (char *)eahd +\n\t\t\t\t\t\tsizeof(struct tag), crclen));\n\t\teahd->descTag.tagChecksum = udf_tag_checksum(&eahd->descTag);\n\t\tiinfo->i_lenEAttr += size;\n\t\treturn (struct genericFormat *)&ea[offset];\n\t}\n\tif (loc & 0x02)\n\t\t;\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"udf_sb.h\"",
            "#include \"udf_i.h\"",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/crc-itu-t.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include \"udfdecl.h\"\n\nstruct genericFormat *udf_add_extendedattr(struct inode *inode, uint32_t size,\n\t\t\t\t\t   uint32_t type, uint8_t loc)\n{\n\tuint8_t *ea = NULL, *ad = NULL;\n\tint offset;\n\tuint16_t crclen;\n\tstruct udf_inode_info *iinfo = UDF_I(inode);\n\n\tea = iinfo->i_ext.i_data;\n\tif (iinfo->i_lenEAttr) {\n\t\tad = iinfo->i_ext.i_data + iinfo->i_lenEAttr;\n\t} else {\n\t\tad = ea;\n\t\tsize += sizeof(struct extendedAttrHeaderDesc);\n\t}\n\n\toffset = inode->i_sb->s_blocksize - udf_file_entry_alloc_offset(inode) -\n\t\tiinfo->i_lenAlloc;\n\n\t/* TODO - Check for FreeEASpace */\n\n\tif (loc & 0x01 && offset >= size) {\n\t\tstruct extendedAttrHeaderDesc *eahd;\n\t\teahd = (struct extendedAttrHeaderDesc *)ea;\n\n\t\tif (iinfo->i_lenAlloc)\n\t\t\tmemmove(&ad[size], ad, iinfo->i_lenAlloc);\n\n\t\tif (iinfo->i_lenEAttr) {\n\t\t\t/* check checksum/crc */\n\t\t\tif (eahd->descTag.tagIdent !=\n\t\t\t\t\tcpu_to_le16(TAG_IDENT_EAHD) ||\n\t\t\t    le32_to_cpu(eahd->descTag.tagLocation) !=\n\t\t\t\t\tiinfo->i_location.logicalBlockNum)\n\t\t\t\treturn NULL;\n\t\t} else {\n\t\t\tstruct udf_sb_info *sbi = UDF_SB(inode->i_sb);\n\n\t\t\tsize -= sizeof(struct extendedAttrHeaderDesc);\n\t\t\tiinfo->i_lenEAttr +=\n\t\t\t\tsizeof(struct extendedAttrHeaderDesc);\n\t\t\teahd->descTag.tagIdent = cpu_to_le16(TAG_IDENT_EAHD);\n\t\t\tif (sbi->s_udfrev >= 0x0200)\n\t\t\t\teahd->descTag.descVersion = cpu_to_le16(3);\n\t\t\telse\n\t\t\t\teahd->descTag.descVersion = cpu_to_le16(2);\n\t\t\teahd->descTag.tagSerialNum =\n\t\t\t\t\tcpu_to_le16(sbi->s_serial_number);\n\t\t\teahd->descTag.tagLocation = cpu_to_le32(\n\t\t\t\t\tiinfo->i_location.logicalBlockNum);\n\t\t\teahd->impAttrLocation = cpu_to_le32(0xFFFFFFFF);\n\t\t\teahd->appAttrLocation = cpu_to_le32(0xFFFFFFFF);\n\t\t}\n\n\t\toffset = iinfo->i_lenEAttr;\n\t\tif (type < 2048) {\n\t\t\tif (le32_to_cpu(eahd->appAttrLocation) <\n\t\t\t\t\tiinfo->i_lenEAttr) {\n\t\t\t\tuint32_t aal =\n\t\t\t\t\tle32_to_cpu(eahd->appAttrLocation);\n\t\t\t\tmemmove(&ea[offset - aal + size],\n\t\t\t\t\t&ea[aal], offset - aal);\n\t\t\t\toffset -= aal;\n\t\t\t\teahd->appAttrLocation =\n\t\t\t\t\t\tcpu_to_le32(aal + size);\n\t\t\t}\n\t\t\tif (le32_to_cpu(eahd->impAttrLocation) <\n\t\t\t\t\tiinfo->i_lenEAttr) {\n\t\t\t\tuint32_t ial =\n\t\t\t\t\tle32_to_cpu(eahd->impAttrLocation);\n\t\t\t\tmemmove(&ea[offset - ial + size],\n\t\t\t\t\t&ea[ial], offset - ial);\n\t\t\t\toffset -= ial;\n\t\t\t\teahd->impAttrLocation =\n\t\t\t\t\t\tcpu_to_le32(ial + size);\n\t\t\t}\n\t\t} else if (type < 65536) {\n\t\t\tif (le32_to_cpu(eahd->appAttrLocation) <\n\t\t\t\t\tiinfo->i_lenEAttr) {\n\t\t\t\tuint32_t aal =\n\t\t\t\t\tle32_to_cpu(eahd->appAttrLocation);\n\t\t\t\tmemmove(&ea[offset - aal + size],\n\t\t\t\t\t&ea[aal], offset - aal);\n\t\t\t\toffset -= aal;\n\t\t\t\teahd->appAttrLocation =\n\t\t\t\t\t\tcpu_to_le32(aal + size);\n\t\t\t}\n\t\t}\n\t\t/* rewrite CRC + checksum of eahd */\n\t\tcrclen = sizeof(struct extendedAttrHeaderDesc) - sizeof(struct tag);\n\t\teahd->descTag.descCRCLength = cpu_to_le16(crclen);\n\t\teahd->descTag.descCRC = cpu_to_le16(crc_itu_t(0, (char *)eahd +\n\t\t\t\t\t\tsizeof(struct tag), crclen));\n\t\teahd->descTag.tagChecksum = udf_tag_checksum(&eahd->descTag);\n\t\tiinfo->i_lenEAttr += size;\n\t\treturn (struct genericFormat *)&ea[offset];\n\t}\n\tif (loc & 0x02)\n\t\t;\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_get_extendedattr",
          "args": [
            "inode",
            "12",
            "1"
          ],
          "line": 1700
        },
        "resolved": true,
        "details": {
          "function_name": "udf_get_extendedattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/misc.c",
          "lines": "151-190",
          "snippet": "struct genericFormat *udf_get_extendedattr(struct inode *inode, uint32_t type,\n\t\t\t\t\t   uint8_t subtype)\n{\n\tstruct genericFormat *gaf;\n\tuint8_t *ea = NULL;\n\tuint32_t offset;\n\tstruct udf_inode_info *iinfo = UDF_I(inode);\n\n\tea = iinfo->i_ext.i_data;\n\n\tif (iinfo->i_lenEAttr) {\n\t\tstruct extendedAttrHeaderDesc *eahd;\n\t\teahd = (struct extendedAttrHeaderDesc *)ea;\n\n\t\t/* check checksum/crc */\n\t\tif (eahd->descTag.tagIdent !=\n\t\t\t\tcpu_to_le16(TAG_IDENT_EAHD) ||\n\t\t    le32_to_cpu(eahd->descTag.tagLocation) !=\n\t\t\t\tiinfo->i_location.logicalBlockNum)\n\t\t\treturn NULL;\n\n\t\tif (type < 2048)\n\t\t\toffset = sizeof(struct extendedAttrHeaderDesc);\n\t\telse if (type < 65536)\n\t\t\toffset = le32_to_cpu(eahd->impAttrLocation);\n\t\telse\n\t\t\toffset = le32_to_cpu(eahd->appAttrLocation);\n\n\t\twhile (offset < iinfo->i_lenEAttr) {\n\t\t\tgaf = (struct genericFormat *)&ea[offset];\n\t\t\tif (le32_to_cpu(gaf->attrType) == type &&\n\t\t\t\t\tgaf->attrSubtype == subtype)\n\t\t\t\treturn gaf;\n\t\t\telse\n\t\t\t\toffset += le32_to_cpu(gaf->attrLength);\n\t\t}\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"udf_sb.h\"",
            "#include \"udf_i.h\"",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/crc-itu-t.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include \"udfdecl.h\"\n\nstruct genericFormat *udf_get_extendedattr(struct inode *inode, uint32_t type,\n\t\t\t\t\t   uint8_t subtype)\n{\n\tstruct genericFormat *gaf;\n\tuint8_t *ea = NULL;\n\tuint32_t offset;\n\tstruct udf_inode_info *iinfo = UDF_I(inode);\n\n\tea = iinfo->i_ext.i_data;\n\n\tif (iinfo->i_lenEAttr) {\n\t\tstruct extendedAttrHeaderDesc *eahd;\n\t\teahd = (struct extendedAttrHeaderDesc *)ea;\n\n\t\t/* check checksum/crc */\n\t\tif (eahd->descTag.tagIdent !=\n\t\t\t\tcpu_to_le16(TAG_IDENT_EAHD) ||\n\t\t    le32_to_cpu(eahd->descTag.tagLocation) !=\n\t\t\t\tiinfo->i_location.logicalBlockNum)\n\t\t\treturn NULL;\n\n\t\tif (type < 2048)\n\t\t\toffset = sizeof(struct extendedAttrHeaderDesc);\n\t\telse if (type < 65536)\n\t\t\toffset = le32_to_cpu(eahd->impAttrLocation);\n\t\telse\n\t\t\toffset = le32_to_cpu(eahd->appAttrLocation);\n\n\t\twhile (offset < iinfo->i_lenEAttr) {\n\t\t\tgaf = (struct genericFormat *)&ea[offset];\n\t\t\tif (le32_to_cpu(gaf->attrType) == type &&\n\t\t\t\t\tgaf->attrSubtype == subtype)\n\t\t\t\treturn gaf;\n\t\t\telse\n\t\t\t\toffset += le32_to_cpu(gaf->attrLength);\n\t\t}\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISBLK",
          "args": [
            "inode->i_mode"
          ],
          "line": 1697
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISCHR",
          "args": [
            "inode->i_mode"
          ],
          "line": 1697
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "inode->i_size"
          ],
          "line": 1695
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "inode->i_nlink"
          ],
          "line": 1693
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "inode->i_nlink - 1"
          ],
          "line": 1691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "inode->i_mode"
          ],
          "line": 1690
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "udfperms"
          ],
          "line": 1688
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "fe->permissions"
          ],
          "line": 1684
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "i_gid_read(inode)"
          ],
          "line": 1678
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_gid_read",
          "args": [
            "inode"
          ],
          "line": 1678
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "-1"
          ],
          "line": 1676
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UDF_QUERY_FLAG",
          "args": [
            "inode->i_sb",
            "UDF_FLAG_GID_FORGET"
          ],
          "line": 1675
        },
        "resolved": true,
        "details": {
          "function_name": "UDF_QUERY_FLAG",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/udf_sb.h",
          "lines": "169-172",
          "snippet": "static inline int UDF_QUERY_FLAG(struct super_block *sb, int flag)\n{\n\treturn test_bit(flag, &UDF_SB(sb)->s_flags);\n}",
          "includes": [
            "#include <linux/bitops.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bitops.h>\n#include <linux/mutex.h>\n\nstatic inline int UDF_QUERY_FLAG(struct super_block *sb, int flag)\n{\n\treturn test_bit(flag, &UDF_SB(sb)->s_flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "i_uid_read(inode)"
          ],
          "line": 1673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_uid_read",
          "args": [
            "inode"
          ],
          "line": 1673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "-1"
          ],
          "line": 1671
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "crc_itu_t(0, (char *)use +\n\t\t\t\t\t\t\t   sizeof(struct tag),\n\t\t\t\t\t\t\t   crclen)"
          ],
          "line": 1662
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crc_itu_t",
          "args": [
            "0",
            "(char *)use +\n\t\t\t\t\t\t\t   sizeof(struct tag)",
            "crclen"
          ],
          "line": 1662
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "crclen"
          ],
          "line": 1661
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "iinfo->i_location.logicalBlockNum"
          ],
          "line": 1658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "TAG_IDENT_USE"
          ],
          "line": 1656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "bh->b_data + sizeof(struct unallocSpaceEntry)",
            "iinfo->i_ext.i_data",
            "inode->i_sb->s_blocksize -\n\t\t\t\t\tsizeof(struct unallocSpaceEntry)"
          ],
          "line": 1653
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "iinfo->i_lenAlloc"
          ],
          "line": 1652
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "bh->b_data",
            "0",
            "inode->i_sb->s_blocksize"
          ],
          "line": 1644
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udf_debug",
          "args": [
            "\"getblk failure\\n\""
          ],
          "line": 1639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udf_tgetblk",
          "args": [
            "inode->i_sb",
            "udf_get_lb_pblock(inode->i_sb, &iinfo->i_location, 0)"
          ],
          "line": 1636
        },
        "resolved": true,
        "details": {
          "function_name": "udf_tgetblk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/misc.c",
          "lines": "32-38",
          "snippet": "struct buffer_head *udf_tgetblk(struct super_block *sb, int block)\n{\n\tif (UDF_QUERY_FLAG(sb, UDF_FLAG_VARCONV))\n\t\treturn sb_getblk(sb, udf_fixed_to_variable(block));\n\telse\n\t\treturn sb_getblk(sb, block);\n}",
          "includes": [
            "#include \"udf_sb.h\"",
            "#include \"udf_i.h\"",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/crc-itu-t.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include \"udfdecl.h\"\n\nstruct buffer_head *udf_tgetblk(struct super_block *sb, int block)\n{\n\tif (UDF_QUERY_FLAG(sb, UDF_FLAG_VARCONV))\n\t\treturn sb_getblk(sb, udf_fixed_to_variable(block));\n\telse\n\t\treturn sb_getblk(sb, block);\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_get_lb_pblock",
          "args": [
            "inode->i_sb",
            "&iinfo->i_location",
            "0"
          ],
          "line": 1637
        },
        "resolved": true,
        "details": {
          "function_name": "udf_get_lb_pblock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/udfdecl.h",
          "lines": "205-211",
          "snippet": "static inline uint32_t\nudf_get_lb_pblock(struct super_block *sb, struct kernel_lb_addr *loc,\n\t\t  uint32_t offset)\n{\n\treturn udf_get_pblock(sb, loc->logicalBlockNum,\n\t\t\tloc->partitionReferenceNum, offset);\n}",
          "includes": [
            "#include \"udf_i.h\"",
            "#include \"udfend.h\"",
            "#include \"udf_sb.h\"",
            "#include <linux/udf_fs_i.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include \"osta_udf.h\"",
            "#include \"ecma_167.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_i.h\"\n#include \"udfend.h\"\n#include \"udf_sb.h\"\n#include <linux/udf_fs_i.h>\n#include <linux/buffer_head.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include \"osta_udf.h\"\n#include \"ecma_167.h\"\n\nstatic inline uint32_t\nudf_get_lb_pblock(struct super_block *sb, struct kernel_lb_addr *loc,\n\t\t  uint32_t offset)\n{\n\treturn udf_get_pblock(sb, loc->logicalBlockNum,\n\t\t\tloc->partitionReferenceNum, offset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "UDF_I",
          "args": [
            "inode"
          ],
          "line": 1634
        },
        "resolved": true,
        "details": {
          "function_name": "UDF_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/udf_i.h",
          "lines": "57-60",
          "snippet": "static inline struct udf_inode_info *UDF_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct udf_inode_info, vfs_inode);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline struct udf_inode_info *UDF_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct udf_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "UDF_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 1632
        },
        "resolved": true,
        "details": {
          "function_name": "UDF_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/udf_sb.h",
          "lines": "160-163",
          "snippet": "static inline struct udf_sb_info *UDF_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/bitops.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bitops.h>\n#include <linux/mutex.h>\n\nstatic inline struct udf_sb_info *UDF_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/crc-itu-t.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include \"udfdecl.h\"\n\nstatic umode_t udf_convert_permissions(struct fileEntry *);\nstatic int udf_update_inode(struct inode *, int);\nstatic int udf_sync_inode(struct inode *inode);\nstatic int8_t udf_insert_aext(struct inode *, struct extent_position,\n\t\t\t      struct kernel_lb_addr, uint32_t);\nstatic int udf_get_block(struct inode *, sector_t, struct buffer_head *, int);\n\nstatic int udf_update_inode(struct inode *inode, int do_sync)\n{\n\tstruct buffer_head *bh = NULL;\n\tstruct fileEntry *fe;\n\tstruct extendedFileEntry *efe;\n\tuint64_t lb_recorded;\n\tuint32_t udfperms;\n\tuint16_t icbflags;\n\tuint16_t crclen;\n\tint err = 0;\n\tstruct udf_sb_info *sbi = UDF_SB(inode->i_sb);\n\tunsigned char blocksize_bits = inode->i_sb->s_blocksize_bits;\n\tstruct udf_inode_info *iinfo = UDF_I(inode);\n\n\tbh = udf_tgetblk(inode->i_sb,\n\t\t\tudf_get_lb_pblock(inode->i_sb, &iinfo->i_location, 0));\n\tif (!bh) {\n\t\tudf_debug(\"getblk failure\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tlock_buffer(bh);\n\tmemset(bh->b_data, 0, inode->i_sb->s_blocksize);\n\tfe = (struct fileEntry *)bh->b_data;\n\tefe = (struct extendedFileEntry *)bh->b_data;\n\n\tif (iinfo->i_use) {\n\t\tstruct unallocSpaceEntry *use =\n\t\t\t(struct unallocSpaceEntry *)bh->b_data;\n\n\t\tuse->lengthAllocDescs = cpu_to_le32(iinfo->i_lenAlloc);\n\t\tmemcpy(bh->b_data + sizeof(struct unallocSpaceEntry),\n\t\t       iinfo->i_ext.i_data, inode->i_sb->s_blocksize -\n\t\t\t\t\tsizeof(struct unallocSpaceEntry));\n\t\tuse->descTag.tagIdent = cpu_to_le16(TAG_IDENT_USE);\n\t\tuse->descTag.tagLocation =\n\t\t\t\tcpu_to_le32(iinfo->i_location.logicalBlockNum);\n\t\tcrclen = sizeof(struct unallocSpaceEntry) +\n\t\t\t\tiinfo->i_lenAlloc - sizeof(struct tag);\n\t\tuse->descTag.descCRCLength = cpu_to_le16(crclen);\n\t\tuse->descTag.descCRC = cpu_to_le16(crc_itu_t(0, (char *)use +\n\t\t\t\t\t\t\t   sizeof(struct tag),\n\t\t\t\t\t\t\t   crclen));\n\t\tuse->descTag.tagChecksum = udf_tag_checksum(&use->descTag);\n\n\t\tgoto out;\n\t}\n\n\tif (UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_UID_FORGET))\n\t\tfe->uid = cpu_to_le32(-1);\n\telse\n\t\tfe->uid = cpu_to_le32(i_uid_read(inode));\n\n\tif (UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_GID_FORGET))\n\t\tfe->gid = cpu_to_le32(-1);\n\telse\n\t\tfe->gid = cpu_to_le32(i_gid_read(inode));\n\n\tudfperms = ((inode->i_mode & S_IRWXO)) |\n\t\t   ((inode->i_mode & S_IRWXG) << 2) |\n\t\t   ((inode->i_mode & S_IRWXU) << 4);\n\n\tudfperms |= (le32_to_cpu(fe->permissions) &\n\t\t    (FE_PERM_O_DELETE | FE_PERM_O_CHATTR |\n\t\t     FE_PERM_G_DELETE | FE_PERM_G_CHATTR |\n\t\t     FE_PERM_U_DELETE | FE_PERM_U_CHATTR));\n\tfe->permissions = cpu_to_le32(udfperms);\n\n\tif (S_ISDIR(inode->i_mode) && inode->i_nlink > 0)\n\t\tfe->fileLinkCount = cpu_to_le16(inode->i_nlink - 1);\n\telse\n\t\tfe->fileLinkCount = cpu_to_le16(inode->i_nlink);\n\n\tfe->informationLength = cpu_to_le64(inode->i_size);\n\n\tif (S_ISCHR(inode->i_mode) || S_ISBLK(inode->i_mode)) {\n\t\tstruct regid *eid;\n\t\tstruct deviceSpec *dsea =\n\t\t\t(struct deviceSpec *)udf_get_extendedattr(inode, 12, 1);\n\t\tif (!dsea) {\n\t\t\tdsea = (struct deviceSpec *)\n\t\t\t\tudf_add_extendedattr(inode,\n\t\t\t\t\t\t     sizeof(struct deviceSpec) +\n\t\t\t\t\t\t     sizeof(struct regid), 12, 0x3);\n\t\t\tdsea->attrType = cpu_to_le32(12);\n\t\t\tdsea->attrSubtype = 1;\n\t\t\tdsea->attrLength = cpu_to_le32(\n\t\t\t\t\t\tsizeof(struct deviceSpec) +\n\t\t\t\t\t\tsizeof(struct regid));\n\t\t\tdsea->impUseLength = cpu_to_le32(sizeof(struct regid));\n\t\t}\n\t\teid = (struct regid *)dsea->impUse;\n\t\tmemset(eid, 0, sizeof(struct regid));\n\t\tstrcpy(eid->ident, UDF_ID_DEVELOPER);\n\t\teid->identSuffix[0] = UDF_OS_CLASS_UNIX;\n\t\teid->identSuffix[1] = UDF_OS_ID_LINUX;\n\t\tdsea->majorDeviceIdent = cpu_to_le32(imajor(inode));\n\t\tdsea->minorDeviceIdent = cpu_to_le32(iminor(inode));\n\t}\n\n\tif (iinfo->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB)\n\t\tlb_recorded = 0; /* No extents => no blocks! */\n\telse\n\t\tlb_recorded =\n\t\t\t(inode->i_blocks + (1 << (blocksize_bits - 9)) - 1) >>\n\t\t\t(blocksize_bits - 9);\n\n\tif (iinfo->i_efe == 0) {\n\t\tmemcpy(bh->b_data + sizeof(struct fileEntry),\n\t\t       iinfo->i_ext.i_data,\n\t\t       inode->i_sb->s_blocksize - sizeof(struct fileEntry));\n\t\tfe->logicalBlocksRecorded = cpu_to_le64(lb_recorded);\n\n\t\tudf_time_to_disk_stamp(&fe->accessTime, inode->i_atime);\n\t\tudf_time_to_disk_stamp(&fe->modificationTime, inode->i_mtime);\n\t\tudf_time_to_disk_stamp(&fe->attrTime, inode->i_ctime);\n\t\tmemset(&(fe->impIdent), 0, sizeof(struct regid));\n\t\tstrcpy(fe->impIdent.ident, UDF_ID_DEVELOPER);\n\t\tfe->impIdent.identSuffix[0] = UDF_OS_CLASS_UNIX;\n\t\tfe->impIdent.identSuffix[1] = UDF_OS_ID_LINUX;\n\t\tfe->uniqueID = cpu_to_le64(iinfo->i_unique);\n\t\tfe->lengthExtendedAttr = cpu_to_le32(iinfo->i_lenEAttr);\n\t\tfe->lengthAllocDescs = cpu_to_le32(iinfo->i_lenAlloc);\n\t\tfe->checkpoint = cpu_to_le32(iinfo->i_checkpoint);\n\t\tfe->descTag.tagIdent = cpu_to_le16(TAG_IDENT_FE);\n\t\tcrclen = sizeof(struct fileEntry);\n\t} else {\n\t\tmemcpy(bh->b_data + sizeof(struct extendedFileEntry),\n\t\t       iinfo->i_ext.i_data,\n\t\t       inode->i_sb->s_blocksize -\n\t\t\t\t\tsizeof(struct extendedFileEntry));\n\t\tefe->objectSize = cpu_to_le64(inode->i_size);\n\t\tefe->logicalBlocksRecorded = cpu_to_le64(lb_recorded);\n\n\t\tif (iinfo->i_crtime.tv_sec > inode->i_atime.tv_sec ||\n\t\t    (iinfo->i_crtime.tv_sec == inode->i_atime.tv_sec &&\n\t\t     iinfo->i_crtime.tv_nsec > inode->i_atime.tv_nsec))\n\t\t\tiinfo->i_crtime = inode->i_atime;\n\n\t\tif (iinfo->i_crtime.tv_sec > inode->i_mtime.tv_sec ||\n\t\t    (iinfo->i_crtime.tv_sec == inode->i_mtime.tv_sec &&\n\t\t     iinfo->i_crtime.tv_nsec > inode->i_mtime.tv_nsec))\n\t\t\tiinfo->i_crtime = inode->i_mtime;\n\n\t\tif (iinfo->i_crtime.tv_sec > inode->i_ctime.tv_sec ||\n\t\t    (iinfo->i_crtime.tv_sec == inode->i_ctime.tv_sec &&\n\t\t     iinfo->i_crtime.tv_nsec > inode->i_ctime.tv_nsec))\n\t\t\tiinfo->i_crtime = inode->i_ctime;\n\n\t\tudf_time_to_disk_stamp(&efe->accessTime, inode->i_atime);\n\t\tudf_time_to_disk_stamp(&efe->modificationTime, inode->i_mtime);\n\t\tudf_time_to_disk_stamp(&efe->createTime, iinfo->i_crtime);\n\t\tudf_time_to_disk_stamp(&efe->attrTime, inode->i_ctime);\n\n\t\tmemset(&(efe->impIdent), 0, sizeof(struct regid));\n\t\tstrcpy(efe->impIdent.ident, UDF_ID_DEVELOPER);\n\t\tefe->impIdent.identSuffix[0] = UDF_OS_CLASS_UNIX;\n\t\tefe->impIdent.identSuffix[1] = UDF_OS_ID_LINUX;\n\t\tefe->uniqueID = cpu_to_le64(iinfo->i_unique);\n\t\tefe->lengthExtendedAttr = cpu_to_le32(iinfo->i_lenEAttr);\n\t\tefe->lengthAllocDescs = cpu_to_le32(iinfo->i_lenAlloc);\n\t\tefe->checkpoint = cpu_to_le32(iinfo->i_checkpoint);\n\t\tefe->descTag.tagIdent = cpu_to_le16(TAG_IDENT_EFE);\n\t\tcrclen = sizeof(struct extendedFileEntry);\n\t}\n\tif (iinfo->i_strat4096) {\n\t\tfe->icbTag.strategyType = cpu_to_le16(4096);\n\t\tfe->icbTag.strategyParameter = cpu_to_le16(1);\n\t\tfe->icbTag.numEntries = cpu_to_le16(2);\n\t} else {\n\t\tfe->icbTag.strategyType = cpu_to_le16(4);\n\t\tfe->icbTag.numEntries = cpu_to_le16(1);\n\t}\n\n\tif (S_ISDIR(inode->i_mode))\n\t\tfe->icbTag.fileType = ICBTAG_FILE_TYPE_DIRECTORY;\n\telse if (S_ISREG(inode->i_mode))\n\t\tfe->icbTag.fileType = ICBTAG_FILE_TYPE_REGULAR;\n\telse if (S_ISLNK(inode->i_mode))\n\t\tfe->icbTag.fileType = ICBTAG_FILE_TYPE_SYMLINK;\n\telse if (S_ISBLK(inode->i_mode))\n\t\tfe->icbTag.fileType = ICBTAG_FILE_TYPE_BLOCK;\n\telse if (S_ISCHR(inode->i_mode))\n\t\tfe->icbTag.fileType = ICBTAG_FILE_TYPE_CHAR;\n\telse if (S_ISFIFO(inode->i_mode))\n\t\tfe->icbTag.fileType = ICBTAG_FILE_TYPE_FIFO;\n\telse if (S_ISSOCK(inode->i_mode))\n\t\tfe->icbTag.fileType = ICBTAG_FILE_TYPE_SOCKET;\n\n\ticbflags =\tiinfo->i_alloc_type |\n\t\t\t((inode->i_mode & S_ISUID) ? ICBTAG_FLAG_SETUID : 0) |\n\t\t\t((inode->i_mode & S_ISGID) ? ICBTAG_FLAG_SETGID : 0) |\n\t\t\t((inode->i_mode & S_ISVTX) ? ICBTAG_FLAG_STICKY : 0) |\n\t\t\t(le16_to_cpu(fe->icbTag.flags) &\n\t\t\t\t~(ICBTAG_FLAG_AD_MASK | ICBTAG_FLAG_SETUID |\n\t\t\t\tICBTAG_FLAG_SETGID | ICBTAG_FLAG_STICKY));\n\n\tfe->icbTag.flags = cpu_to_le16(icbflags);\n\tif (sbi->s_udfrev >= 0x0200)\n\t\tfe->descTag.descVersion = cpu_to_le16(3);\n\telse\n\t\tfe->descTag.descVersion = cpu_to_le16(2);\n\tfe->descTag.tagSerialNum = cpu_to_le16(sbi->s_serial_number);\n\tfe->descTag.tagLocation = cpu_to_le32(\n\t\t\t\t\tiinfo->i_location.logicalBlockNum);\n\tcrclen += iinfo->i_lenEAttr + iinfo->i_lenAlloc - sizeof(struct tag);\n\tfe->descTag.descCRCLength = cpu_to_le16(crclen);\n\tfe->descTag.descCRC = cpu_to_le16(crc_itu_t(0, (char *)fe + sizeof(struct tag),\n\t\t\t\t\t\t  crclen));\n\tfe->descTag.tagChecksum = udf_tag_checksum(&fe->descTag);\n\nout:\n\tset_buffer_uptodate(bh);\n\tunlock_buffer(bh);\n\n\t/* write the data blocks */\n\tmark_buffer_dirty(bh);\n\tif (do_sync) {\n\t\tsync_dirty_buffer(bh);\n\t\tif (buffer_write_io_error(bh)) {\n\t\t\tudf_warn(inode->i_sb, \"IO error syncing udf inode [%08lx]\\n\",\n\t\t\t\t inode->i_ino);\n\t\t\terr = -EIO;\n\t\t}\n\t}\n\tbrelse(bh);\n\n\treturn err;\n}"
  },
  {
    "function_name": "udf_sync_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/inode.c",
    "lines": "1617-1620",
    "snippet": "static int udf_sync_inode(struct inode *inode)\n{\n\treturn udf_update_inode(inode, 1);\n}",
    "includes": [
      "#include \"udf_sb.h\"",
      "#include \"udf_i.h\"",
      "#include <linux/aio.h>",
      "#include <linux/mpage.h>",
      "#include <linux/crc-itu-t.h>",
      "#include <linux/slab.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include \"udfdecl.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int udf_update_inode(struct inode *, int);",
      "static int udf_sync_inode(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "udf_update_inode",
          "args": [
            "inode",
            "1"
          ],
          "line": 1619
        },
        "resolved": true,
        "details": {
          "function_name": "udf_update_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/inode.c",
          "lines": "1622-1850",
          "snippet": "static int udf_update_inode(struct inode *inode, int do_sync)\n{\n\tstruct buffer_head *bh = NULL;\n\tstruct fileEntry *fe;\n\tstruct extendedFileEntry *efe;\n\tuint64_t lb_recorded;\n\tuint32_t udfperms;\n\tuint16_t icbflags;\n\tuint16_t crclen;\n\tint err = 0;\n\tstruct udf_sb_info *sbi = UDF_SB(inode->i_sb);\n\tunsigned char blocksize_bits = inode->i_sb->s_blocksize_bits;\n\tstruct udf_inode_info *iinfo = UDF_I(inode);\n\n\tbh = udf_tgetblk(inode->i_sb,\n\t\t\tudf_get_lb_pblock(inode->i_sb, &iinfo->i_location, 0));\n\tif (!bh) {\n\t\tudf_debug(\"getblk failure\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tlock_buffer(bh);\n\tmemset(bh->b_data, 0, inode->i_sb->s_blocksize);\n\tfe = (struct fileEntry *)bh->b_data;\n\tefe = (struct extendedFileEntry *)bh->b_data;\n\n\tif (iinfo->i_use) {\n\t\tstruct unallocSpaceEntry *use =\n\t\t\t(struct unallocSpaceEntry *)bh->b_data;\n\n\t\tuse->lengthAllocDescs = cpu_to_le32(iinfo->i_lenAlloc);\n\t\tmemcpy(bh->b_data + sizeof(struct unallocSpaceEntry),\n\t\t       iinfo->i_ext.i_data, inode->i_sb->s_blocksize -\n\t\t\t\t\tsizeof(struct unallocSpaceEntry));\n\t\tuse->descTag.tagIdent = cpu_to_le16(TAG_IDENT_USE);\n\t\tuse->descTag.tagLocation =\n\t\t\t\tcpu_to_le32(iinfo->i_location.logicalBlockNum);\n\t\tcrclen = sizeof(struct unallocSpaceEntry) +\n\t\t\t\tiinfo->i_lenAlloc - sizeof(struct tag);\n\t\tuse->descTag.descCRCLength = cpu_to_le16(crclen);\n\t\tuse->descTag.descCRC = cpu_to_le16(crc_itu_t(0, (char *)use +\n\t\t\t\t\t\t\t   sizeof(struct tag),\n\t\t\t\t\t\t\t   crclen));\n\t\tuse->descTag.tagChecksum = udf_tag_checksum(&use->descTag);\n\n\t\tgoto out;\n\t}\n\n\tif (UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_UID_FORGET))\n\t\tfe->uid = cpu_to_le32(-1);\n\telse\n\t\tfe->uid = cpu_to_le32(i_uid_read(inode));\n\n\tif (UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_GID_FORGET))\n\t\tfe->gid = cpu_to_le32(-1);\n\telse\n\t\tfe->gid = cpu_to_le32(i_gid_read(inode));\n\n\tudfperms = ((inode->i_mode & S_IRWXO)) |\n\t\t   ((inode->i_mode & S_IRWXG) << 2) |\n\t\t   ((inode->i_mode & S_IRWXU) << 4);\n\n\tudfperms |= (le32_to_cpu(fe->permissions) &\n\t\t    (FE_PERM_O_DELETE | FE_PERM_O_CHATTR |\n\t\t     FE_PERM_G_DELETE | FE_PERM_G_CHATTR |\n\t\t     FE_PERM_U_DELETE | FE_PERM_U_CHATTR));\n\tfe->permissions = cpu_to_le32(udfperms);\n\n\tif (S_ISDIR(inode->i_mode) && inode->i_nlink > 0)\n\t\tfe->fileLinkCount = cpu_to_le16(inode->i_nlink - 1);\n\telse\n\t\tfe->fileLinkCount = cpu_to_le16(inode->i_nlink);\n\n\tfe->informationLength = cpu_to_le64(inode->i_size);\n\n\tif (S_ISCHR(inode->i_mode) || S_ISBLK(inode->i_mode)) {\n\t\tstruct regid *eid;\n\t\tstruct deviceSpec *dsea =\n\t\t\t(struct deviceSpec *)udf_get_extendedattr(inode, 12, 1);\n\t\tif (!dsea) {\n\t\t\tdsea = (struct deviceSpec *)\n\t\t\t\tudf_add_extendedattr(inode,\n\t\t\t\t\t\t     sizeof(struct deviceSpec) +\n\t\t\t\t\t\t     sizeof(struct regid), 12, 0x3);\n\t\t\tdsea->attrType = cpu_to_le32(12);\n\t\t\tdsea->attrSubtype = 1;\n\t\t\tdsea->attrLength = cpu_to_le32(\n\t\t\t\t\t\tsizeof(struct deviceSpec) +\n\t\t\t\t\t\tsizeof(struct regid));\n\t\t\tdsea->impUseLength = cpu_to_le32(sizeof(struct regid));\n\t\t}\n\t\teid = (struct regid *)dsea->impUse;\n\t\tmemset(eid, 0, sizeof(struct regid));\n\t\tstrcpy(eid->ident, UDF_ID_DEVELOPER);\n\t\teid->identSuffix[0] = UDF_OS_CLASS_UNIX;\n\t\teid->identSuffix[1] = UDF_OS_ID_LINUX;\n\t\tdsea->majorDeviceIdent = cpu_to_le32(imajor(inode));\n\t\tdsea->minorDeviceIdent = cpu_to_le32(iminor(inode));\n\t}\n\n\tif (iinfo->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB)\n\t\tlb_recorded = 0; /* No extents => no blocks! */\n\telse\n\t\tlb_recorded =\n\t\t\t(inode->i_blocks + (1 << (blocksize_bits - 9)) - 1) >>\n\t\t\t(blocksize_bits - 9);\n\n\tif (iinfo->i_efe == 0) {\n\t\tmemcpy(bh->b_data + sizeof(struct fileEntry),\n\t\t       iinfo->i_ext.i_data,\n\t\t       inode->i_sb->s_blocksize - sizeof(struct fileEntry));\n\t\tfe->logicalBlocksRecorded = cpu_to_le64(lb_recorded);\n\n\t\tudf_time_to_disk_stamp(&fe->accessTime, inode->i_atime);\n\t\tudf_time_to_disk_stamp(&fe->modificationTime, inode->i_mtime);\n\t\tudf_time_to_disk_stamp(&fe->attrTime, inode->i_ctime);\n\t\tmemset(&(fe->impIdent), 0, sizeof(struct regid));\n\t\tstrcpy(fe->impIdent.ident, UDF_ID_DEVELOPER);\n\t\tfe->impIdent.identSuffix[0] = UDF_OS_CLASS_UNIX;\n\t\tfe->impIdent.identSuffix[1] = UDF_OS_ID_LINUX;\n\t\tfe->uniqueID = cpu_to_le64(iinfo->i_unique);\n\t\tfe->lengthExtendedAttr = cpu_to_le32(iinfo->i_lenEAttr);\n\t\tfe->lengthAllocDescs = cpu_to_le32(iinfo->i_lenAlloc);\n\t\tfe->checkpoint = cpu_to_le32(iinfo->i_checkpoint);\n\t\tfe->descTag.tagIdent = cpu_to_le16(TAG_IDENT_FE);\n\t\tcrclen = sizeof(struct fileEntry);\n\t} else {\n\t\tmemcpy(bh->b_data + sizeof(struct extendedFileEntry),\n\t\t       iinfo->i_ext.i_data,\n\t\t       inode->i_sb->s_blocksize -\n\t\t\t\t\tsizeof(struct extendedFileEntry));\n\t\tefe->objectSize = cpu_to_le64(inode->i_size);\n\t\tefe->logicalBlocksRecorded = cpu_to_le64(lb_recorded);\n\n\t\tif (iinfo->i_crtime.tv_sec > inode->i_atime.tv_sec ||\n\t\t    (iinfo->i_crtime.tv_sec == inode->i_atime.tv_sec &&\n\t\t     iinfo->i_crtime.tv_nsec > inode->i_atime.tv_nsec))\n\t\t\tiinfo->i_crtime = inode->i_atime;\n\n\t\tif (iinfo->i_crtime.tv_sec > inode->i_mtime.tv_sec ||\n\t\t    (iinfo->i_crtime.tv_sec == inode->i_mtime.tv_sec &&\n\t\t     iinfo->i_crtime.tv_nsec > inode->i_mtime.tv_nsec))\n\t\t\tiinfo->i_crtime = inode->i_mtime;\n\n\t\tif (iinfo->i_crtime.tv_sec > inode->i_ctime.tv_sec ||\n\t\t    (iinfo->i_crtime.tv_sec == inode->i_ctime.tv_sec &&\n\t\t     iinfo->i_crtime.tv_nsec > inode->i_ctime.tv_nsec))\n\t\t\tiinfo->i_crtime = inode->i_ctime;\n\n\t\tudf_time_to_disk_stamp(&efe->accessTime, inode->i_atime);\n\t\tudf_time_to_disk_stamp(&efe->modificationTime, inode->i_mtime);\n\t\tudf_time_to_disk_stamp(&efe->createTime, iinfo->i_crtime);\n\t\tudf_time_to_disk_stamp(&efe->attrTime, inode->i_ctime);\n\n\t\tmemset(&(efe->impIdent), 0, sizeof(struct regid));\n\t\tstrcpy(efe->impIdent.ident, UDF_ID_DEVELOPER);\n\t\tefe->impIdent.identSuffix[0] = UDF_OS_CLASS_UNIX;\n\t\tefe->impIdent.identSuffix[1] = UDF_OS_ID_LINUX;\n\t\tefe->uniqueID = cpu_to_le64(iinfo->i_unique);\n\t\tefe->lengthExtendedAttr = cpu_to_le32(iinfo->i_lenEAttr);\n\t\tefe->lengthAllocDescs = cpu_to_le32(iinfo->i_lenAlloc);\n\t\tefe->checkpoint = cpu_to_le32(iinfo->i_checkpoint);\n\t\tefe->descTag.tagIdent = cpu_to_le16(TAG_IDENT_EFE);\n\t\tcrclen = sizeof(struct extendedFileEntry);\n\t}\n\tif (iinfo->i_strat4096) {\n\t\tfe->icbTag.strategyType = cpu_to_le16(4096);\n\t\tfe->icbTag.strategyParameter = cpu_to_le16(1);\n\t\tfe->icbTag.numEntries = cpu_to_le16(2);\n\t} else {\n\t\tfe->icbTag.strategyType = cpu_to_le16(4);\n\t\tfe->icbTag.numEntries = cpu_to_le16(1);\n\t}\n\n\tif (S_ISDIR(inode->i_mode))\n\t\tfe->icbTag.fileType = ICBTAG_FILE_TYPE_DIRECTORY;\n\telse if (S_ISREG(inode->i_mode))\n\t\tfe->icbTag.fileType = ICBTAG_FILE_TYPE_REGULAR;\n\telse if (S_ISLNK(inode->i_mode))\n\t\tfe->icbTag.fileType = ICBTAG_FILE_TYPE_SYMLINK;\n\telse if (S_ISBLK(inode->i_mode))\n\t\tfe->icbTag.fileType = ICBTAG_FILE_TYPE_BLOCK;\n\telse if (S_ISCHR(inode->i_mode))\n\t\tfe->icbTag.fileType = ICBTAG_FILE_TYPE_CHAR;\n\telse if (S_ISFIFO(inode->i_mode))\n\t\tfe->icbTag.fileType = ICBTAG_FILE_TYPE_FIFO;\n\telse if (S_ISSOCK(inode->i_mode))\n\t\tfe->icbTag.fileType = ICBTAG_FILE_TYPE_SOCKET;\n\n\ticbflags =\tiinfo->i_alloc_type |\n\t\t\t((inode->i_mode & S_ISUID) ? ICBTAG_FLAG_SETUID : 0) |\n\t\t\t((inode->i_mode & S_ISGID) ? ICBTAG_FLAG_SETGID : 0) |\n\t\t\t((inode->i_mode & S_ISVTX) ? ICBTAG_FLAG_STICKY : 0) |\n\t\t\t(le16_to_cpu(fe->icbTag.flags) &\n\t\t\t\t~(ICBTAG_FLAG_AD_MASK | ICBTAG_FLAG_SETUID |\n\t\t\t\tICBTAG_FLAG_SETGID | ICBTAG_FLAG_STICKY));\n\n\tfe->icbTag.flags = cpu_to_le16(icbflags);\n\tif (sbi->s_udfrev >= 0x0200)\n\t\tfe->descTag.descVersion = cpu_to_le16(3);\n\telse\n\t\tfe->descTag.descVersion = cpu_to_le16(2);\n\tfe->descTag.tagSerialNum = cpu_to_le16(sbi->s_serial_number);\n\tfe->descTag.tagLocation = cpu_to_le32(\n\t\t\t\t\tiinfo->i_location.logicalBlockNum);\n\tcrclen += iinfo->i_lenEAttr + iinfo->i_lenAlloc - sizeof(struct tag);\n\tfe->descTag.descCRCLength = cpu_to_le16(crclen);\n\tfe->descTag.descCRC = cpu_to_le16(crc_itu_t(0, (char *)fe + sizeof(struct tag),\n\t\t\t\t\t\t  crclen));\n\tfe->descTag.tagChecksum = udf_tag_checksum(&fe->descTag);\n\nout:\n\tset_buffer_uptodate(bh);\n\tunlock_buffer(bh);\n\n\t/* write the data blocks */\n\tmark_buffer_dirty(bh);\n\tif (do_sync) {\n\t\tsync_dirty_buffer(bh);\n\t\tif (buffer_write_io_error(bh)) {\n\t\t\tudf_warn(inode->i_sb, \"IO error syncing udf inode [%08lx]\\n\",\n\t\t\t\t inode->i_ino);\n\t\t\terr = -EIO;\n\t\t}\n\t}\n\tbrelse(bh);\n\n\treturn err;\n}",
          "includes": [
            "#include \"udf_sb.h\"",
            "#include \"udf_i.h\"",
            "#include <linux/aio.h>",
            "#include <linux/mpage.h>",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static umode_t udf_convert_permissions(struct fileEntry *);",
            "static int udf_update_inode(struct inode *, int);",
            "static int udf_sync_inode(struct inode *inode);",
            "static int8_t udf_insert_aext(struct inode *, struct extent_position,\n\t\t\t      struct kernel_lb_addr, uint32_t);",
            "static int udf_get_block(struct inode *, sector_t, struct buffer_head *, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/crc-itu-t.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include \"udfdecl.h\"\n\nstatic umode_t udf_convert_permissions(struct fileEntry *);\nstatic int udf_update_inode(struct inode *, int);\nstatic int udf_sync_inode(struct inode *inode);\nstatic int8_t udf_insert_aext(struct inode *, struct extent_position,\n\t\t\t      struct kernel_lb_addr, uint32_t);\nstatic int udf_get_block(struct inode *, sector_t, struct buffer_head *, int);\n\nstatic int udf_update_inode(struct inode *inode, int do_sync)\n{\n\tstruct buffer_head *bh = NULL;\n\tstruct fileEntry *fe;\n\tstruct extendedFileEntry *efe;\n\tuint64_t lb_recorded;\n\tuint32_t udfperms;\n\tuint16_t icbflags;\n\tuint16_t crclen;\n\tint err = 0;\n\tstruct udf_sb_info *sbi = UDF_SB(inode->i_sb);\n\tunsigned char blocksize_bits = inode->i_sb->s_blocksize_bits;\n\tstruct udf_inode_info *iinfo = UDF_I(inode);\n\n\tbh = udf_tgetblk(inode->i_sb,\n\t\t\tudf_get_lb_pblock(inode->i_sb, &iinfo->i_location, 0));\n\tif (!bh) {\n\t\tudf_debug(\"getblk failure\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tlock_buffer(bh);\n\tmemset(bh->b_data, 0, inode->i_sb->s_blocksize);\n\tfe = (struct fileEntry *)bh->b_data;\n\tefe = (struct extendedFileEntry *)bh->b_data;\n\n\tif (iinfo->i_use) {\n\t\tstruct unallocSpaceEntry *use =\n\t\t\t(struct unallocSpaceEntry *)bh->b_data;\n\n\t\tuse->lengthAllocDescs = cpu_to_le32(iinfo->i_lenAlloc);\n\t\tmemcpy(bh->b_data + sizeof(struct unallocSpaceEntry),\n\t\t       iinfo->i_ext.i_data, inode->i_sb->s_blocksize -\n\t\t\t\t\tsizeof(struct unallocSpaceEntry));\n\t\tuse->descTag.tagIdent = cpu_to_le16(TAG_IDENT_USE);\n\t\tuse->descTag.tagLocation =\n\t\t\t\tcpu_to_le32(iinfo->i_location.logicalBlockNum);\n\t\tcrclen = sizeof(struct unallocSpaceEntry) +\n\t\t\t\tiinfo->i_lenAlloc - sizeof(struct tag);\n\t\tuse->descTag.descCRCLength = cpu_to_le16(crclen);\n\t\tuse->descTag.descCRC = cpu_to_le16(crc_itu_t(0, (char *)use +\n\t\t\t\t\t\t\t   sizeof(struct tag),\n\t\t\t\t\t\t\t   crclen));\n\t\tuse->descTag.tagChecksum = udf_tag_checksum(&use->descTag);\n\n\t\tgoto out;\n\t}\n\n\tif (UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_UID_FORGET))\n\t\tfe->uid = cpu_to_le32(-1);\n\telse\n\t\tfe->uid = cpu_to_le32(i_uid_read(inode));\n\n\tif (UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_GID_FORGET))\n\t\tfe->gid = cpu_to_le32(-1);\n\telse\n\t\tfe->gid = cpu_to_le32(i_gid_read(inode));\n\n\tudfperms = ((inode->i_mode & S_IRWXO)) |\n\t\t   ((inode->i_mode & S_IRWXG) << 2) |\n\t\t   ((inode->i_mode & S_IRWXU) << 4);\n\n\tudfperms |= (le32_to_cpu(fe->permissions) &\n\t\t    (FE_PERM_O_DELETE | FE_PERM_O_CHATTR |\n\t\t     FE_PERM_G_DELETE | FE_PERM_G_CHATTR |\n\t\t     FE_PERM_U_DELETE | FE_PERM_U_CHATTR));\n\tfe->permissions = cpu_to_le32(udfperms);\n\n\tif (S_ISDIR(inode->i_mode) && inode->i_nlink > 0)\n\t\tfe->fileLinkCount = cpu_to_le16(inode->i_nlink - 1);\n\telse\n\t\tfe->fileLinkCount = cpu_to_le16(inode->i_nlink);\n\n\tfe->informationLength = cpu_to_le64(inode->i_size);\n\n\tif (S_ISCHR(inode->i_mode) || S_ISBLK(inode->i_mode)) {\n\t\tstruct regid *eid;\n\t\tstruct deviceSpec *dsea =\n\t\t\t(struct deviceSpec *)udf_get_extendedattr(inode, 12, 1);\n\t\tif (!dsea) {\n\t\t\tdsea = (struct deviceSpec *)\n\t\t\t\tudf_add_extendedattr(inode,\n\t\t\t\t\t\t     sizeof(struct deviceSpec) +\n\t\t\t\t\t\t     sizeof(struct regid), 12, 0x3);\n\t\t\tdsea->attrType = cpu_to_le32(12);\n\t\t\tdsea->attrSubtype = 1;\n\t\t\tdsea->attrLength = cpu_to_le32(\n\t\t\t\t\t\tsizeof(struct deviceSpec) +\n\t\t\t\t\t\tsizeof(struct regid));\n\t\t\tdsea->impUseLength = cpu_to_le32(sizeof(struct regid));\n\t\t}\n\t\teid = (struct regid *)dsea->impUse;\n\t\tmemset(eid, 0, sizeof(struct regid));\n\t\tstrcpy(eid->ident, UDF_ID_DEVELOPER);\n\t\teid->identSuffix[0] = UDF_OS_CLASS_UNIX;\n\t\teid->identSuffix[1] = UDF_OS_ID_LINUX;\n\t\tdsea->majorDeviceIdent = cpu_to_le32(imajor(inode));\n\t\tdsea->minorDeviceIdent = cpu_to_le32(iminor(inode));\n\t}\n\n\tif (iinfo->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB)\n\t\tlb_recorded = 0; /* No extents => no blocks! */\n\telse\n\t\tlb_recorded =\n\t\t\t(inode->i_blocks + (1 << (blocksize_bits - 9)) - 1) >>\n\t\t\t(blocksize_bits - 9);\n\n\tif (iinfo->i_efe == 0) {\n\t\tmemcpy(bh->b_data + sizeof(struct fileEntry),\n\t\t       iinfo->i_ext.i_data,\n\t\t       inode->i_sb->s_blocksize - sizeof(struct fileEntry));\n\t\tfe->logicalBlocksRecorded = cpu_to_le64(lb_recorded);\n\n\t\tudf_time_to_disk_stamp(&fe->accessTime, inode->i_atime);\n\t\tudf_time_to_disk_stamp(&fe->modificationTime, inode->i_mtime);\n\t\tudf_time_to_disk_stamp(&fe->attrTime, inode->i_ctime);\n\t\tmemset(&(fe->impIdent), 0, sizeof(struct regid));\n\t\tstrcpy(fe->impIdent.ident, UDF_ID_DEVELOPER);\n\t\tfe->impIdent.identSuffix[0] = UDF_OS_CLASS_UNIX;\n\t\tfe->impIdent.identSuffix[1] = UDF_OS_ID_LINUX;\n\t\tfe->uniqueID = cpu_to_le64(iinfo->i_unique);\n\t\tfe->lengthExtendedAttr = cpu_to_le32(iinfo->i_lenEAttr);\n\t\tfe->lengthAllocDescs = cpu_to_le32(iinfo->i_lenAlloc);\n\t\tfe->checkpoint = cpu_to_le32(iinfo->i_checkpoint);\n\t\tfe->descTag.tagIdent = cpu_to_le16(TAG_IDENT_FE);\n\t\tcrclen = sizeof(struct fileEntry);\n\t} else {\n\t\tmemcpy(bh->b_data + sizeof(struct extendedFileEntry),\n\t\t       iinfo->i_ext.i_data,\n\t\t       inode->i_sb->s_blocksize -\n\t\t\t\t\tsizeof(struct extendedFileEntry));\n\t\tefe->objectSize = cpu_to_le64(inode->i_size);\n\t\tefe->logicalBlocksRecorded = cpu_to_le64(lb_recorded);\n\n\t\tif (iinfo->i_crtime.tv_sec > inode->i_atime.tv_sec ||\n\t\t    (iinfo->i_crtime.tv_sec == inode->i_atime.tv_sec &&\n\t\t     iinfo->i_crtime.tv_nsec > inode->i_atime.tv_nsec))\n\t\t\tiinfo->i_crtime = inode->i_atime;\n\n\t\tif (iinfo->i_crtime.tv_sec > inode->i_mtime.tv_sec ||\n\t\t    (iinfo->i_crtime.tv_sec == inode->i_mtime.tv_sec &&\n\t\t     iinfo->i_crtime.tv_nsec > inode->i_mtime.tv_nsec))\n\t\t\tiinfo->i_crtime = inode->i_mtime;\n\n\t\tif (iinfo->i_crtime.tv_sec > inode->i_ctime.tv_sec ||\n\t\t    (iinfo->i_crtime.tv_sec == inode->i_ctime.tv_sec &&\n\t\t     iinfo->i_crtime.tv_nsec > inode->i_ctime.tv_nsec))\n\t\t\tiinfo->i_crtime = inode->i_ctime;\n\n\t\tudf_time_to_disk_stamp(&efe->accessTime, inode->i_atime);\n\t\tudf_time_to_disk_stamp(&efe->modificationTime, inode->i_mtime);\n\t\tudf_time_to_disk_stamp(&efe->createTime, iinfo->i_crtime);\n\t\tudf_time_to_disk_stamp(&efe->attrTime, inode->i_ctime);\n\n\t\tmemset(&(efe->impIdent), 0, sizeof(struct regid));\n\t\tstrcpy(efe->impIdent.ident, UDF_ID_DEVELOPER);\n\t\tefe->impIdent.identSuffix[0] = UDF_OS_CLASS_UNIX;\n\t\tefe->impIdent.identSuffix[1] = UDF_OS_ID_LINUX;\n\t\tefe->uniqueID = cpu_to_le64(iinfo->i_unique);\n\t\tefe->lengthExtendedAttr = cpu_to_le32(iinfo->i_lenEAttr);\n\t\tefe->lengthAllocDescs = cpu_to_le32(iinfo->i_lenAlloc);\n\t\tefe->checkpoint = cpu_to_le32(iinfo->i_checkpoint);\n\t\tefe->descTag.tagIdent = cpu_to_le16(TAG_IDENT_EFE);\n\t\tcrclen = sizeof(struct extendedFileEntry);\n\t}\n\tif (iinfo->i_strat4096) {\n\t\tfe->icbTag.strategyType = cpu_to_le16(4096);\n\t\tfe->icbTag.strategyParameter = cpu_to_le16(1);\n\t\tfe->icbTag.numEntries = cpu_to_le16(2);\n\t} else {\n\t\tfe->icbTag.strategyType = cpu_to_le16(4);\n\t\tfe->icbTag.numEntries = cpu_to_le16(1);\n\t}\n\n\tif (S_ISDIR(inode->i_mode))\n\t\tfe->icbTag.fileType = ICBTAG_FILE_TYPE_DIRECTORY;\n\telse if (S_ISREG(inode->i_mode))\n\t\tfe->icbTag.fileType = ICBTAG_FILE_TYPE_REGULAR;\n\telse if (S_ISLNK(inode->i_mode))\n\t\tfe->icbTag.fileType = ICBTAG_FILE_TYPE_SYMLINK;\n\telse if (S_ISBLK(inode->i_mode))\n\t\tfe->icbTag.fileType = ICBTAG_FILE_TYPE_BLOCK;\n\telse if (S_ISCHR(inode->i_mode))\n\t\tfe->icbTag.fileType = ICBTAG_FILE_TYPE_CHAR;\n\telse if (S_ISFIFO(inode->i_mode))\n\t\tfe->icbTag.fileType = ICBTAG_FILE_TYPE_FIFO;\n\telse if (S_ISSOCK(inode->i_mode))\n\t\tfe->icbTag.fileType = ICBTAG_FILE_TYPE_SOCKET;\n\n\ticbflags =\tiinfo->i_alloc_type |\n\t\t\t((inode->i_mode & S_ISUID) ? ICBTAG_FLAG_SETUID : 0) |\n\t\t\t((inode->i_mode & S_ISGID) ? ICBTAG_FLAG_SETGID : 0) |\n\t\t\t((inode->i_mode & S_ISVTX) ? ICBTAG_FLAG_STICKY : 0) |\n\t\t\t(le16_to_cpu(fe->icbTag.flags) &\n\t\t\t\t~(ICBTAG_FLAG_AD_MASK | ICBTAG_FLAG_SETUID |\n\t\t\t\tICBTAG_FLAG_SETGID | ICBTAG_FLAG_STICKY));\n\n\tfe->icbTag.flags = cpu_to_le16(icbflags);\n\tif (sbi->s_udfrev >= 0x0200)\n\t\tfe->descTag.descVersion = cpu_to_le16(3);\n\telse\n\t\tfe->descTag.descVersion = cpu_to_le16(2);\n\tfe->descTag.tagSerialNum = cpu_to_le16(sbi->s_serial_number);\n\tfe->descTag.tagLocation = cpu_to_le32(\n\t\t\t\t\tiinfo->i_location.logicalBlockNum);\n\tcrclen += iinfo->i_lenEAttr + iinfo->i_lenAlloc - sizeof(struct tag);\n\tfe->descTag.descCRCLength = cpu_to_le16(crclen);\n\tfe->descTag.descCRC = cpu_to_le16(crc_itu_t(0, (char *)fe + sizeof(struct tag),\n\t\t\t\t\t\t  crclen));\n\tfe->descTag.tagChecksum = udf_tag_checksum(&fe->descTag);\n\nout:\n\tset_buffer_uptodate(bh);\n\tunlock_buffer(bh);\n\n\t/* write the data blocks */\n\tmark_buffer_dirty(bh);\n\tif (do_sync) {\n\t\tsync_dirty_buffer(bh);\n\t\tif (buffer_write_io_error(bh)) {\n\t\t\tudf_warn(inode->i_sb, \"IO error syncing udf inode [%08lx]\\n\",\n\t\t\t\t inode->i_ino);\n\t\t\terr = -EIO;\n\t\t}\n\t}\n\tbrelse(bh);\n\n\treturn err;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/crc-itu-t.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include \"udfdecl.h\"\n\nstatic int udf_update_inode(struct inode *, int);\nstatic int udf_sync_inode(struct inode *inode);\n\nstatic int udf_sync_inode(struct inode *inode)\n{\n\treturn udf_update_inode(inode, 1);\n}"
  },
  {
    "function_name": "udf_write_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/inode.c",
    "lines": "1612-1615",
    "snippet": "int udf_write_inode(struct inode *inode, struct writeback_control *wbc)\n{\n\treturn udf_update_inode(inode, wbc->sync_mode == WB_SYNC_ALL);\n}",
    "includes": [
      "#include \"udf_sb.h\"",
      "#include \"udf_i.h\"",
      "#include <linux/aio.h>",
      "#include <linux/mpage.h>",
      "#include <linux/crc-itu-t.h>",
      "#include <linux/slab.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include \"udfdecl.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int udf_update_inode(struct inode *, int);",
      "static int udf_sync_inode(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "udf_update_inode",
          "args": [
            "inode",
            "wbc->sync_mode == WB_SYNC_ALL"
          ],
          "line": 1614
        },
        "resolved": true,
        "details": {
          "function_name": "udf_update_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/inode.c",
          "lines": "1622-1850",
          "snippet": "static int udf_update_inode(struct inode *inode, int do_sync)\n{\n\tstruct buffer_head *bh = NULL;\n\tstruct fileEntry *fe;\n\tstruct extendedFileEntry *efe;\n\tuint64_t lb_recorded;\n\tuint32_t udfperms;\n\tuint16_t icbflags;\n\tuint16_t crclen;\n\tint err = 0;\n\tstruct udf_sb_info *sbi = UDF_SB(inode->i_sb);\n\tunsigned char blocksize_bits = inode->i_sb->s_blocksize_bits;\n\tstruct udf_inode_info *iinfo = UDF_I(inode);\n\n\tbh = udf_tgetblk(inode->i_sb,\n\t\t\tudf_get_lb_pblock(inode->i_sb, &iinfo->i_location, 0));\n\tif (!bh) {\n\t\tudf_debug(\"getblk failure\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tlock_buffer(bh);\n\tmemset(bh->b_data, 0, inode->i_sb->s_blocksize);\n\tfe = (struct fileEntry *)bh->b_data;\n\tefe = (struct extendedFileEntry *)bh->b_data;\n\n\tif (iinfo->i_use) {\n\t\tstruct unallocSpaceEntry *use =\n\t\t\t(struct unallocSpaceEntry *)bh->b_data;\n\n\t\tuse->lengthAllocDescs = cpu_to_le32(iinfo->i_lenAlloc);\n\t\tmemcpy(bh->b_data + sizeof(struct unallocSpaceEntry),\n\t\t       iinfo->i_ext.i_data, inode->i_sb->s_blocksize -\n\t\t\t\t\tsizeof(struct unallocSpaceEntry));\n\t\tuse->descTag.tagIdent = cpu_to_le16(TAG_IDENT_USE);\n\t\tuse->descTag.tagLocation =\n\t\t\t\tcpu_to_le32(iinfo->i_location.logicalBlockNum);\n\t\tcrclen = sizeof(struct unallocSpaceEntry) +\n\t\t\t\tiinfo->i_lenAlloc - sizeof(struct tag);\n\t\tuse->descTag.descCRCLength = cpu_to_le16(crclen);\n\t\tuse->descTag.descCRC = cpu_to_le16(crc_itu_t(0, (char *)use +\n\t\t\t\t\t\t\t   sizeof(struct tag),\n\t\t\t\t\t\t\t   crclen));\n\t\tuse->descTag.tagChecksum = udf_tag_checksum(&use->descTag);\n\n\t\tgoto out;\n\t}\n\n\tif (UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_UID_FORGET))\n\t\tfe->uid = cpu_to_le32(-1);\n\telse\n\t\tfe->uid = cpu_to_le32(i_uid_read(inode));\n\n\tif (UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_GID_FORGET))\n\t\tfe->gid = cpu_to_le32(-1);\n\telse\n\t\tfe->gid = cpu_to_le32(i_gid_read(inode));\n\n\tudfperms = ((inode->i_mode & S_IRWXO)) |\n\t\t   ((inode->i_mode & S_IRWXG) << 2) |\n\t\t   ((inode->i_mode & S_IRWXU) << 4);\n\n\tudfperms |= (le32_to_cpu(fe->permissions) &\n\t\t    (FE_PERM_O_DELETE | FE_PERM_O_CHATTR |\n\t\t     FE_PERM_G_DELETE | FE_PERM_G_CHATTR |\n\t\t     FE_PERM_U_DELETE | FE_PERM_U_CHATTR));\n\tfe->permissions = cpu_to_le32(udfperms);\n\n\tif (S_ISDIR(inode->i_mode) && inode->i_nlink > 0)\n\t\tfe->fileLinkCount = cpu_to_le16(inode->i_nlink - 1);\n\telse\n\t\tfe->fileLinkCount = cpu_to_le16(inode->i_nlink);\n\n\tfe->informationLength = cpu_to_le64(inode->i_size);\n\n\tif (S_ISCHR(inode->i_mode) || S_ISBLK(inode->i_mode)) {\n\t\tstruct regid *eid;\n\t\tstruct deviceSpec *dsea =\n\t\t\t(struct deviceSpec *)udf_get_extendedattr(inode, 12, 1);\n\t\tif (!dsea) {\n\t\t\tdsea = (struct deviceSpec *)\n\t\t\t\tudf_add_extendedattr(inode,\n\t\t\t\t\t\t     sizeof(struct deviceSpec) +\n\t\t\t\t\t\t     sizeof(struct regid), 12, 0x3);\n\t\t\tdsea->attrType = cpu_to_le32(12);\n\t\t\tdsea->attrSubtype = 1;\n\t\t\tdsea->attrLength = cpu_to_le32(\n\t\t\t\t\t\tsizeof(struct deviceSpec) +\n\t\t\t\t\t\tsizeof(struct regid));\n\t\t\tdsea->impUseLength = cpu_to_le32(sizeof(struct regid));\n\t\t}\n\t\teid = (struct regid *)dsea->impUse;\n\t\tmemset(eid, 0, sizeof(struct regid));\n\t\tstrcpy(eid->ident, UDF_ID_DEVELOPER);\n\t\teid->identSuffix[0] = UDF_OS_CLASS_UNIX;\n\t\teid->identSuffix[1] = UDF_OS_ID_LINUX;\n\t\tdsea->majorDeviceIdent = cpu_to_le32(imajor(inode));\n\t\tdsea->minorDeviceIdent = cpu_to_le32(iminor(inode));\n\t}\n\n\tif (iinfo->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB)\n\t\tlb_recorded = 0; /* No extents => no blocks! */\n\telse\n\t\tlb_recorded =\n\t\t\t(inode->i_blocks + (1 << (blocksize_bits - 9)) - 1) >>\n\t\t\t(blocksize_bits - 9);\n\n\tif (iinfo->i_efe == 0) {\n\t\tmemcpy(bh->b_data + sizeof(struct fileEntry),\n\t\t       iinfo->i_ext.i_data,\n\t\t       inode->i_sb->s_blocksize - sizeof(struct fileEntry));\n\t\tfe->logicalBlocksRecorded = cpu_to_le64(lb_recorded);\n\n\t\tudf_time_to_disk_stamp(&fe->accessTime, inode->i_atime);\n\t\tudf_time_to_disk_stamp(&fe->modificationTime, inode->i_mtime);\n\t\tudf_time_to_disk_stamp(&fe->attrTime, inode->i_ctime);\n\t\tmemset(&(fe->impIdent), 0, sizeof(struct regid));\n\t\tstrcpy(fe->impIdent.ident, UDF_ID_DEVELOPER);\n\t\tfe->impIdent.identSuffix[0] = UDF_OS_CLASS_UNIX;\n\t\tfe->impIdent.identSuffix[1] = UDF_OS_ID_LINUX;\n\t\tfe->uniqueID = cpu_to_le64(iinfo->i_unique);\n\t\tfe->lengthExtendedAttr = cpu_to_le32(iinfo->i_lenEAttr);\n\t\tfe->lengthAllocDescs = cpu_to_le32(iinfo->i_lenAlloc);\n\t\tfe->checkpoint = cpu_to_le32(iinfo->i_checkpoint);\n\t\tfe->descTag.tagIdent = cpu_to_le16(TAG_IDENT_FE);\n\t\tcrclen = sizeof(struct fileEntry);\n\t} else {\n\t\tmemcpy(bh->b_data + sizeof(struct extendedFileEntry),\n\t\t       iinfo->i_ext.i_data,\n\t\t       inode->i_sb->s_blocksize -\n\t\t\t\t\tsizeof(struct extendedFileEntry));\n\t\tefe->objectSize = cpu_to_le64(inode->i_size);\n\t\tefe->logicalBlocksRecorded = cpu_to_le64(lb_recorded);\n\n\t\tif (iinfo->i_crtime.tv_sec > inode->i_atime.tv_sec ||\n\t\t    (iinfo->i_crtime.tv_sec == inode->i_atime.tv_sec &&\n\t\t     iinfo->i_crtime.tv_nsec > inode->i_atime.tv_nsec))\n\t\t\tiinfo->i_crtime = inode->i_atime;\n\n\t\tif (iinfo->i_crtime.tv_sec > inode->i_mtime.tv_sec ||\n\t\t    (iinfo->i_crtime.tv_sec == inode->i_mtime.tv_sec &&\n\t\t     iinfo->i_crtime.tv_nsec > inode->i_mtime.tv_nsec))\n\t\t\tiinfo->i_crtime = inode->i_mtime;\n\n\t\tif (iinfo->i_crtime.tv_sec > inode->i_ctime.tv_sec ||\n\t\t    (iinfo->i_crtime.tv_sec == inode->i_ctime.tv_sec &&\n\t\t     iinfo->i_crtime.tv_nsec > inode->i_ctime.tv_nsec))\n\t\t\tiinfo->i_crtime = inode->i_ctime;\n\n\t\tudf_time_to_disk_stamp(&efe->accessTime, inode->i_atime);\n\t\tudf_time_to_disk_stamp(&efe->modificationTime, inode->i_mtime);\n\t\tudf_time_to_disk_stamp(&efe->createTime, iinfo->i_crtime);\n\t\tudf_time_to_disk_stamp(&efe->attrTime, inode->i_ctime);\n\n\t\tmemset(&(efe->impIdent), 0, sizeof(struct regid));\n\t\tstrcpy(efe->impIdent.ident, UDF_ID_DEVELOPER);\n\t\tefe->impIdent.identSuffix[0] = UDF_OS_CLASS_UNIX;\n\t\tefe->impIdent.identSuffix[1] = UDF_OS_ID_LINUX;\n\t\tefe->uniqueID = cpu_to_le64(iinfo->i_unique);\n\t\tefe->lengthExtendedAttr = cpu_to_le32(iinfo->i_lenEAttr);\n\t\tefe->lengthAllocDescs = cpu_to_le32(iinfo->i_lenAlloc);\n\t\tefe->checkpoint = cpu_to_le32(iinfo->i_checkpoint);\n\t\tefe->descTag.tagIdent = cpu_to_le16(TAG_IDENT_EFE);\n\t\tcrclen = sizeof(struct extendedFileEntry);\n\t}\n\tif (iinfo->i_strat4096) {\n\t\tfe->icbTag.strategyType = cpu_to_le16(4096);\n\t\tfe->icbTag.strategyParameter = cpu_to_le16(1);\n\t\tfe->icbTag.numEntries = cpu_to_le16(2);\n\t} else {\n\t\tfe->icbTag.strategyType = cpu_to_le16(4);\n\t\tfe->icbTag.numEntries = cpu_to_le16(1);\n\t}\n\n\tif (S_ISDIR(inode->i_mode))\n\t\tfe->icbTag.fileType = ICBTAG_FILE_TYPE_DIRECTORY;\n\telse if (S_ISREG(inode->i_mode))\n\t\tfe->icbTag.fileType = ICBTAG_FILE_TYPE_REGULAR;\n\telse if (S_ISLNK(inode->i_mode))\n\t\tfe->icbTag.fileType = ICBTAG_FILE_TYPE_SYMLINK;\n\telse if (S_ISBLK(inode->i_mode))\n\t\tfe->icbTag.fileType = ICBTAG_FILE_TYPE_BLOCK;\n\telse if (S_ISCHR(inode->i_mode))\n\t\tfe->icbTag.fileType = ICBTAG_FILE_TYPE_CHAR;\n\telse if (S_ISFIFO(inode->i_mode))\n\t\tfe->icbTag.fileType = ICBTAG_FILE_TYPE_FIFO;\n\telse if (S_ISSOCK(inode->i_mode))\n\t\tfe->icbTag.fileType = ICBTAG_FILE_TYPE_SOCKET;\n\n\ticbflags =\tiinfo->i_alloc_type |\n\t\t\t((inode->i_mode & S_ISUID) ? ICBTAG_FLAG_SETUID : 0) |\n\t\t\t((inode->i_mode & S_ISGID) ? ICBTAG_FLAG_SETGID : 0) |\n\t\t\t((inode->i_mode & S_ISVTX) ? ICBTAG_FLAG_STICKY : 0) |\n\t\t\t(le16_to_cpu(fe->icbTag.flags) &\n\t\t\t\t~(ICBTAG_FLAG_AD_MASK | ICBTAG_FLAG_SETUID |\n\t\t\t\tICBTAG_FLAG_SETGID | ICBTAG_FLAG_STICKY));\n\n\tfe->icbTag.flags = cpu_to_le16(icbflags);\n\tif (sbi->s_udfrev >= 0x0200)\n\t\tfe->descTag.descVersion = cpu_to_le16(3);\n\telse\n\t\tfe->descTag.descVersion = cpu_to_le16(2);\n\tfe->descTag.tagSerialNum = cpu_to_le16(sbi->s_serial_number);\n\tfe->descTag.tagLocation = cpu_to_le32(\n\t\t\t\t\tiinfo->i_location.logicalBlockNum);\n\tcrclen += iinfo->i_lenEAttr + iinfo->i_lenAlloc - sizeof(struct tag);\n\tfe->descTag.descCRCLength = cpu_to_le16(crclen);\n\tfe->descTag.descCRC = cpu_to_le16(crc_itu_t(0, (char *)fe + sizeof(struct tag),\n\t\t\t\t\t\t  crclen));\n\tfe->descTag.tagChecksum = udf_tag_checksum(&fe->descTag);\n\nout:\n\tset_buffer_uptodate(bh);\n\tunlock_buffer(bh);\n\n\t/* write the data blocks */\n\tmark_buffer_dirty(bh);\n\tif (do_sync) {\n\t\tsync_dirty_buffer(bh);\n\t\tif (buffer_write_io_error(bh)) {\n\t\t\tudf_warn(inode->i_sb, \"IO error syncing udf inode [%08lx]\\n\",\n\t\t\t\t inode->i_ino);\n\t\t\terr = -EIO;\n\t\t}\n\t}\n\tbrelse(bh);\n\n\treturn err;\n}",
          "includes": [
            "#include \"udf_sb.h\"",
            "#include \"udf_i.h\"",
            "#include <linux/aio.h>",
            "#include <linux/mpage.h>",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static umode_t udf_convert_permissions(struct fileEntry *);",
            "static int udf_update_inode(struct inode *, int);",
            "static int udf_sync_inode(struct inode *inode);",
            "static int8_t udf_insert_aext(struct inode *, struct extent_position,\n\t\t\t      struct kernel_lb_addr, uint32_t);",
            "static int udf_get_block(struct inode *, sector_t, struct buffer_head *, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/crc-itu-t.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include \"udfdecl.h\"\n\nstatic umode_t udf_convert_permissions(struct fileEntry *);\nstatic int udf_update_inode(struct inode *, int);\nstatic int udf_sync_inode(struct inode *inode);\nstatic int8_t udf_insert_aext(struct inode *, struct extent_position,\n\t\t\t      struct kernel_lb_addr, uint32_t);\nstatic int udf_get_block(struct inode *, sector_t, struct buffer_head *, int);\n\nstatic int udf_update_inode(struct inode *inode, int do_sync)\n{\n\tstruct buffer_head *bh = NULL;\n\tstruct fileEntry *fe;\n\tstruct extendedFileEntry *efe;\n\tuint64_t lb_recorded;\n\tuint32_t udfperms;\n\tuint16_t icbflags;\n\tuint16_t crclen;\n\tint err = 0;\n\tstruct udf_sb_info *sbi = UDF_SB(inode->i_sb);\n\tunsigned char blocksize_bits = inode->i_sb->s_blocksize_bits;\n\tstruct udf_inode_info *iinfo = UDF_I(inode);\n\n\tbh = udf_tgetblk(inode->i_sb,\n\t\t\tudf_get_lb_pblock(inode->i_sb, &iinfo->i_location, 0));\n\tif (!bh) {\n\t\tudf_debug(\"getblk failure\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tlock_buffer(bh);\n\tmemset(bh->b_data, 0, inode->i_sb->s_blocksize);\n\tfe = (struct fileEntry *)bh->b_data;\n\tefe = (struct extendedFileEntry *)bh->b_data;\n\n\tif (iinfo->i_use) {\n\t\tstruct unallocSpaceEntry *use =\n\t\t\t(struct unallocSpaceEntry *)bh->b_data;\n\n\t\tuse->lengthAllocDescs = cpu_to_le32(iinfo->i_lenAlloc);\n\t\tmemcpy(bh->b_data + sizeof(struct unallocSpaceEntry),\n\t\t       iinfo->i_ext.i_data, inode->i_sb->s_blocksize -\n\t\t\t\t\tsizeof(struct unallocSpaceEntry));\n\t\tuse->descTag.tagIdent = cpu_to_le16(TAG_IDENT_USE);\n\t\tuse->descTag.tagLocation =\n\t\t\t\tcpu_to_le32(iinfo->i_location.logicalBlockNum);\n\t\tcrclen = sizeof(struct unallocSpaceEntry) +\n\t\t\t\tiinfo->i_lenAlloc - sizeof(struct tag);\n\t\tuse->descTag.descCRCLength = cpu_to_le16(crclen);\n\t\tuse->descTag.descCRC = cpu_to_le16(crc_itu_t(0, (char *)use +\n\t\t\t\t\t\t\t   sizeof(struct tag),\n\t\t\t\t\t\t\t   crclen));\n\t\tuse->descTag.tagChecksum = udf_tag_checksum(&use->descTag);\n\n\t\tgoto out;\n\t}\n\n\tif (UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_UID_FORGET))\n\t\tfe->uid = cpu_to_le32(-1);\n\telse\n\t\tfe->uid = cpu_to_le32(i_uid_read(inode));\n\n\tif (UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_GID_FORGET))\n\t\tfe->gid = cpu_to_le32(-1);\n\telse\n\t\tfe->gid = cpu_to_le32(i_gid_read(inode));\n\n\tudfperms = ((inode->i_mode & S_IRWXO)) |\n\t\t   ((inode->i_mode & S_IRWXG) << 2) |\n\t\t   ((inode->i_mode & S_IRWXU) << 4);\n\n\tudfperms |= (le32_to_cpu(fe->permissions) &\n\t\t    (FE_PERM_O_DELETE | FE_PERM_O_CHATTR |\n\t\t     FE_PERM_G_DELETE | FE_PERM_G_CHATTR |\n\t\t     FE_PERM_U_DELETE | FE_PERM_U_CHATTR));\n\tfe->permissions = cpu_to_le32(udfperms);\n\n\tif (S_ISDIR(inode->i_mode) && inode->i_nlink > 0)\n\t\tfe->fileLinkCount = cpu_to_le16(inode->i_nlink - 1);\n\telse\n\t\tfe->fileLinkCount = cpu_to_le16(inode->i_nlink);\n\n\tfe->informationLength = cpu_to_le64(inode->i_size);\n\n\tif (S_ISCHR(inode->i_mode) || S_ISBLK(inode->i_mode)) {\n\t\tstruct regid *eid;\n\t\tstruct deviceSpec *dsea =\n\t\t\t(struct deviceSpec *)udf_get_extendedattr(inode, 12, 1);\n\t\tif (!dsea) {\n\t\t\tdsea = (struct deviceSpec *)\n\t\t\t\tudf_add_extendedattr(inode,\n\t\t\t\t\t\t     sizeof(struct deviceSpec) +\n\t\t\t\t\t\t     sizeof(struct regid), 12, 0x3);\n\t\t\tdsea->attrType = cpu_to_le32(12);\n\t\t\tdsea->attrSubtype = 1;\n\t\t\tdsea->attrLength = cpu_to_le32(\n\t\t\t\t\t\tsizeof(struct deviceSpec) +\n\t\t\t\t\t\tsizeof(struct regid));\n\t\t\tdsea->impUseLength = cpu_to_le32(sizeof(struct regid));\n\t\t}\n\t\teid = (struct regid *)dsea->impUse;\n\t\tmemset(eid, 0, sizeof(struct regid));\n\t\tstrcpy(eid->ident, UDF_ID_DEVELOPER);\n\t\teid->identSuffix[0] = UDF_OS_CLASS_UNIX;\n\t\teid->identSuffix[1] = UDF_OS_ID_LINUX;\n\t\tdsea->majorDeviceIdent = cpu_to_le32(imajor(inode));\n\t\tdsea->minorDeviceIdent = cpu_to_le32(iminor(inode));\n\t}\n\n\tif (iinfo->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB)\n\t\tlb_recorded = 0; /* No extents => no blocks! */\n\telse\n\t\tlb_recorded =\n\t\t\t(inode->i_blocks + (1 << (blocksize_bits - 9)) - 1) >>\n\t\t\t(blocksize_bits - 9);\n\n\tif (iinfo->i_efe == 0) {\n\t\tmemcpy(bh->b_data + sizeof(struct fileEntry),\n\t\t       iinfo->i_ext.i_data,\n\t\t       inode->i_sb->s_blocksize - sizeof(struct fileEntry));\n\t\tfe->logicalBlocksRecorded = cpu_to_le64(lb_recorded);\n\n\t\tudf_time_to_disk_stamp(&fe->accessTime, inode->i_atime);\n\t\tudf_time_to_disk_stamp(&fe->modificationTime, inode->i_mtime);\n\t\tudf_time_to_disk_stamp(&fe->attrTime, inode->i_ctime);\n\t\tmemset(&(fe->impIdent), 0, sizeof(struct regid));\n\t\tstrcpy(fe->impIdent.ident, UDF_ID_DEVELOPER);\n\t\tfe->impIdent.identSuffix[0] = UDF_OS_CLASS_UNIX;\n\t\tfe->impIdent.identSuffix[1] = UDF_OS_ID_LINUX;\n\t\tfe->uniqueID = cpu_to_le64(iinfo->i_unique);\n\t\tfe->lengthExtendedAttr = cpu_to_le32(iinfo->i_lenEAttr);\n\t\tfe->lengthAllocDescs = cpu_to_le32(iinfo->i_lenAlloc);\n\t\tfe->checkpoint = cpu_to_le32(iinfo->i_checkpoint);\n\t\tfe->descTag.tagIdent = cpu_to_le16(TAG_IDENT_FE);\n\t\tcrclen = sizeof(struct fileEntry);\n\t} else {\n\t\tmemcpy(bh->b_data + sizeof(struct extendedFileEntry),\n\t\t       iinfo->i_ext.i_data,\n\t\t       inode->i_sb->s_blocksize -\n\t\t\t\t\tsizeof(struct extendedFileEntry));\n\t\tefe->objectSize = cpu_to_le64(inode->i_size);\n\t\tefe->logicalBlocksRecorded = cpu_to_le64(lb_recorded);\n\n\t\tif (iinfo->i_crtime.tv_sec > inode->i_atime.tv_sec ||\n\t\t    (iinfo->i_crtime.tv_sec == inode->i_atime.tv_sec &&\n\t\t     iinfo->i_crtime.tv_nsec > inode->i_atime.tv_nsec))\n\t\t\tiinfo->i_crtime = inode->i_atime;\n\n\t\tif (iinfo->i_crtime.tv_sec > inode->i_mtime.tv_sec ||\n\t\t    (iinfo->i_crtime.tv_sec == inode->i_mtime.tv_sec &&\n\t\t     iinfo->i_crtime.tv_nsec > inode->i_mtime.tv_nsec))\n\t\t\tiinfo->i_crtime = inode->i_mtime;\n\n\t\tif (iinfo->i_crtime.tv_sec > inode->i_ctime.tv_sec ||\n\t\t    (iinfo->i_crtime.tv_sec == inode->i_ctime.tv_sec &&\n\t\t     iinfo->i_crtime.tv_nsec > inode->i_ctime.tv_nsec))\n\t\t\tiinfo->i_crtime = inode->i_ctime;\n\n\t\tudf_time_to_disk_stamp(&efe->accessTime, inode->i_atime);\n\t\tudf_time_to_disk_stamp(&efe->modificationTime, inode->i_mtime);\n\t\tudf_time_to_disk_stamp(&efe->createTime, iinfo->i_crtime);\n\t\tudf_time_to_disk_stamp(&efe->attrTime, inode->i_ctime);\n\n\t\tmemset(&(efe->impIdent), 0, sizeof(struct regid));\n\t\tstrcpy(efe->impIdent.ident, UDF_ID_DEVELOPER);\n\t\tefe->impIdent.identSuffix[0] = UDF_OS_CLASS_UNIX;\n\t\tefe->impIdent.identSuffix[1] = UDF_OS_ID_LINUX;\n\t\tefe->uniqueID = cpu_to_le64(iinfo->i_unique);\n\t\tefe->lengthExtendedAttr = cpu_to_le32(iinfo->i_lenEAttr);\n\t\tefe->lengthAllocDescs = cpu_to_le32(iinfo->i_lenAlloc);\n\t\tefe->checkpoint = cpu_to_le32(iinfo->i_checkpoint);\n\t\tefe->descTag.tagIdent = cpu_to_le16(TAG_IDENT_EFE);\n\t\tcrclen = sizeof(struct extendedFileEntry);\n\t}\n\tif (iinfo->i_strat4096) {\n\t\tfe->icbTag.strategyType = cpu_to_le16(4096);\n\t\tfe->icbTag.strategyParameter = cpu_to_le16(1);\n\t\tfe->icbTag.numEntries = cpu_to_le16(2);\n\t} else {\n\t\tfe->icbTag.strategyType = cpu_to_le16(4);\n\t\tfe->icbTag.numEntries = cpu_to_le16(1);\n\t}\n\n\tif (S_ISDIR(inode->i_mode))\n\t\tfe->icbTag.fileType = ICBTAG_FILE_TYPE_DIRECTORY;\n\telse if (S_ISREG(inode->i_mode))\n\t\tfe->icbTag.fileType = ICBTAG_FILE_TYPE_REGULAR;\n\telse if (S_ISLNK(inode->i_mode))\n\t\tfe->icbTag.fileType = ICBTAG_FILE_TYPE_SYMLINK;\n\telse if (S_ISBLK(inode->i_mode))\n\t\tfe->icbTag.fileType = ICBTAG_FILE_TYPE_BLOCK;\n\telse if (S_ISCHR(inode->i_mode))\n\t\tfe->icbTag.fileType = ICBTAG_FILE_TYPE_CHAR;\n\telse if (S_ISFIFO(inode->i_mode))\n\t\tfe->icbTag.fileType = ICBTAG_FILE_TYPE_FIFO;\n\telse if (S_ISSOCK(inode->i_mode))\n\t\tfe->icbTag.fileType = ICBTAG_FILE_TYPE_SOCKET;\n\n\ticbflags =\tiinfo->i_alloc_type |\n\t\t\t((inode->i_mode & S_ISUID) ? ICBTAG_FLAG_SETUID : 0) |\n\t\t\t((inode->i_mode & S_ISGID) ? ICBTAG_FLAG_SETGID : 0) |\n\t\t\t((inode->i_mode & S_ISVTX) ? ICBTAG_FLAG_STICKY : 0) |\n\t\t\t(le16_to_cpu(fe->icbTag.flags) &\n\t\t\t\t~(ICBTAG_FLAG_AD_MASK | ICBTAG_FLAG_SETUID |\n\t\t\t\tICBTAG_FLAG_SETGID | ICBTAG_FLAG_STICKY));\n\n\tfe->icbTag.flags = cpu_to_le16(icbflags);\n\tif (sbi->s_udfrev >= 0x0200)\n\t\tfe->descTag.descVersion = cpu_to_le16(3);\n\telse\n\t\tfe->descTag.descVersion = cpu_to_le16(2);\n\tfe->descTag.tagSerialNum = cpu_to_le16(sbi->s_serial_number);\n\tfe->descTag.tagLocation = cpu_to_le32(\n\t\t\t\t\tiinfo->i_location.logicalBlockNum);\n\tcrclen += iinfo->i_lenEAttr + iinfo->i_lenAlloc - sizeof(struct tag);\n\tfe->descTag.descCRCLength = cpu_to_le16(crclen);\n\tfe->descTag.descCRC = cpu_to_le16(crc_itu_t(0, (char *)fe + sizeof(struct tag),\n\t\t\t\t\t\t  crclen));\n\tfe->descTag.tagChecksum = udf_tag_checksum(&fe->descTag);\n\nout:\n\tset_buffer_uptodate(bh);\n\tunlock_buffer(bh);\n\n\t/* write the data blocks */\n\tmark_buffer_dirty(bh);\n\tif (do_sync) {\n\t\tsync_dirty_buffer(bh);\n\t\tif (buffer_write_io_error(bh)) {\n\t\t\tudf_warn(inode->i_sb, \"IO error syncing udf inode [%08lx]\\n\",\n\t\t\t\t inode->i_ino);\n\t\t\terr = -EIO;\n\t\t}\n\t}\n\tbrelse(bh);\n\n\treturn err;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/crc-itu-t.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include \"udfdecl.h\"\n\nstatic int udf_update_inode(struct inode *, int);\nstatic int udf_sync_inode(struct inode *inode);\n\nint udf_write_inode(struct inode *inode, struct writeback_control *wbc)\n{\n\treturn udf_update_inode(inode, wbc->sync_mode == WB_SYNC_ALL);\n}"
  },
  {
    "function_name": "udf_convert_permissions",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/inode.c",
    "lines": "1593-1610",
    "snippet": "static umode_t udf_convert_permissions(struct fileEntry *fe)\n{\n\tumode_t mode;\n\tuint32_t permissions;\n\tuint32_t flags;\n\n\tpermissions = le32_to_cpu(fe->permissions);\n\tflags = le16_to_cpu(fe->icbTag.flags);\n\n\tmode =\t((permissions) & S_IRWXO) |\n\t\t((permissions >> 2) & S_IRWXG) |\n\t\t((permissions >> 4) & S_IRWXU) |\n\t\t((flags & ICBTAG_FLAG_SETUID) ? S_ISUID : 0) |\n\t\t((flags & ICBTAG_FLAG_SETGID) ? S_ISGID : 0) |\n\t\t((flags & ICBTAG_FLAG_STICKY) ? S_ISVTX : 0);\n\n\treturn mode;\n}",
    "includes": [
      "#include \"udf_sb.h\"",
      "#include \"udf_i.h\"",
      "#include <linux/aio.h>",
      "#include <linux/mpage.h>",
      "#include <linux/crc-itu-t.h>",
      "#include <linux/slab.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include \"udfdecl.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static umode_t udf_convert_permissions(struct fileEntry *);",
      "static int8_t udf_insert_aext(struct inode *, struct extent_position,\n\t\t\t      struct kernel_lb_addr, uint32_t);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "fe->icbTag.flags"
          ],
          "line": 1600
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "fe->permissions"
          ],
          "line": 1599
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/crc-itu-t.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include \"udfdecl.h\"\n\nstatic umode_t udf_convert_permissions(struct fileEntry *);\nstatic int8_t udf_insert_aext(struct inode *, struct extent_position,\n\t\t\t      struct kernel_lb_addr, uint32_t);\n\nstatic umode_t udf_convert_permissions(struct fileEntry *fe)\n{\n\tumode_t mode;\n\tuint32_t permissions;\n\tuint32_t flags;\n\n\tpermissions = le32_to_cpu(fe->permissions);\n\tflags = le16_to_cpu(fe->icbTag.flags);\n\n\tmode =\t((permissions) & S_IRWXO) |\n\t\t((permissions >> 2) & S_IRWXG) |\n\t\t((permissions >> 4) & S_IRWXU) |\n\t\t((flags & ICBTAG_FLAG_SETUID) ? S_ISUID : 0) |\n\t\t((flags & ICBTAG_FLAG_SETGID) ? S_ISGID : 0) |\n\t\t((flags & ICBTAG_FLAG_STICKY) ? S_ISVTX : 0);\n\n\treturn mode;\n}"
  },
  {
    "function_name": "udf_alloc_i_data",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/inode.c",
    "lines": "1579-1591",
    "snippet": "static int udf_alloc_i_data(struct inode *inode, size_t size)\n{\n\tstruct udf_inode_info *iinfo = UDF_I(inode);\n\tiinfo->i_ext.i_data = kmalloc(size, GFP_KERNEL);\n\n\tif (!iinfo->i_ext.i_data) {\n\t\tudf_err(inode->i_sb, \"(ino %ld) no free memory\\n\",\n\t\t\tinode->i_ino);\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"udf_sb.h\"",
      "#include \"udf_i.h\"",
      "#include <linux/aio.h>",
      "#include <linux/mpage.h>",
      "#include <linux/crc-itu-t.h>",
      "#include <linux/slab.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include \"udfdecl.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int udf_update_inode(struct inode *, int);",
      "static int udf_sync_inode(struct inode *inode);",
      "static int udf_alloc_i_data(struct inode *inode, size_t size);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "udf_err",
          "args": [
            "inode->i_sb",
            "\"(ino %ld) no free memory\\n\"",
            "inode->i_ino"
          ],
          "line": 1585
        },
        "resolved": true,
        "details": {
          "function_name": "_udf_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/super.c",
          "lines": "2256-2270",
          "snippet": "void _udf_err(struct super_block *sb, const char *function,\n\t      const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tpr_err(\"error (device %s): %s: %pV\", sb->s_id, function, &vaf);\n\n\tva_end(args);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/init.h>",
            "#include \"udf_i.h\"",
            "#include \"udf_sb.h\"",
            "#include <asm/byteorder.h>",
            "#include <linux/log2.h>",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/errno.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/vfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/nls.h>",
            "#include <linux/cdrom.h>",
            "#include <linux/stat.h>",
            "#include <linux/parser.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int udf_fill_super(struct super_block *, void *, int);",
            "static void udf_put_super(struct super_block *);",
            "static int udf_sync_fs(struct super_block *, int);",
            "static int udf_remount_fs(struct super_block *, int *, char *);",
            "static void udf_open_lvid(struct super_block *);",
            "static void udf_close_lvid(struct super_block *);",
            "static unsigned int udf_count_free(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/init.h>\n#include \"udf_i.h\"\n#include \"udf_sb.h\"\n#include <asm/byteorder.h>\n#include <linux/log2.h>\n#include <linux/crc-itu-t.h>\n#include <linux/bitmap.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/errno.h>\n#include <linux/vmalloc.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/nls.h>\n#include <linux/cdrom.h>\n#include <linux/stat.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include \"udfdecl.h\"\n\nstatic int udf_fill_super(struct super_block *, void *, int);\nstatic void udf_put_super(struct super_block *);\nstatic int udf_sync_fs(struct super_block *, int);\nstatic int udf_remount_fs(struct super_block *, int *, char *);\nstatic void udf_open_lvid(struct super_block *);\nstatic void udf_close_lvid(struct super_block *);\nstatic unsigned int udf_count_free(struct super_block *);\n\nvoid _udf_err(struct super_block *sb, const char *function,\n\t      const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tpr_err(\"error (device %s): %s: %pV\", sb->s_id, function, &vaf);\n\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "size",
            "GFP_KERNEL"
          ],
          "line": 1582
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "UDF_I",
          "args": [
            "inode"
          ],
          "line": 1581
        },
        "resolved": true,
        "details": {
          "function_name": "UDF_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/udf_i.h",
          "lines": "57-60",
          "snippet": "static inline struct udf_inode_info *UDF_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct udf_inode_info, vfs_inode);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline struct udf_inode_info *UDF_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct udf_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/crc-itu-t.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include \"udfdecl.h\"\n\nstatic int udf_update_inode(struct inode *, int);\nstatic int udf_sync_inode(struct inode *inode);\nstatic int udf_alloc_i_data(struct inode *inode, size_t size);\n\nstatic int udf_alloc_i_data(struct inode *inode, size_t size)\n{\n\tstruct udf_inode_info *iinfo = UDF_I(inode);\n\tiinfo->i_ext.i_data = kmalloc(size, GFP_KERNEL);\n\n\tif (!iinfo->i_ext.i_data) {\n\t\tudf_err(inode->i_sb, \"(ino %ld) no free memory\\n\",\n\t\t\tinode->i_ino);\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "udf_read_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/inode.c",
    "lines": "1280-1577",
    "snippet": "static int udf_read_inode(struct inode *inode, bool hidden_inode)\n{\n\tstruct buffer_head *bh = NULL;\n\tstruct fileEntry *fe;\n\tstruct extendedFileEntry *efe;\n\tuint16_t ident;\n\tstruct udf_inode_info *iinfo = UDF_I(inode);\n\tstruct udf_sb_info *sbi = UDF_SB(inode->i_sb);\n\tstruct kernel_lb_addr *iloc = &iinfo->i_location;\n\tunsigned int link_count;\n\tunsigned int indirections = 0;\n\tint bs = inode->i_sb->s_blocksize;\n\tint ret = -EIO;\n\nreread:\n\tif (iloc->logicalBlockNum >=\n\t    sbi->s_partmaps[iloc->partitionReferenceNum].s_partition_len) {\n\t\tudf_debug(\"block=%d, partition=%d out of range\\n\",\n\t\t\t  iloc->logicalBlockNum, iloc->partitionReferenceNum);\n\t\treturn -EIO;\n\t}\n\n\t/*\n\t * Set defaults, but the inode is still incomplete!\n\t * Note: get_new_inode() sets the following on a new inode:\n\t *      i_sb = sb\n\t *      i_no = ino\n\t *      i_flags = sb->s_flags\n\t *      i_state = 0\n\t * clean_inode(): zero fills and sets\n\t *      i_count = 1\n\t *      i_nlink = 1\n\t *      i_op = NULL;\n\t */\n\tbh = udf_read_ptagged(inode->i_sb, iloc, 0, &ident);\n\tif (!bh) {\n\t\tudf_err(inode->i_sb, \"(ino %ld) failed !bh\\n\", inode->i_ino);\n\t\treturn -EIO;\n\t}\n\n\tif (ident != TAG_IDENT_FE && ident != TAG_IDENT_EFE &&\n\t    ident != TAG_IDENT_USE) {\n\t\tudf_err(inode->i_sb, \"(ino %ld) failed ident=%d\\n\",\n\t\t\tinode->i_ino, ident);\n\t\tgoto out;\n\t}\n\n\tfe = (struct fileEntry *)bh->b_data;\n\tefe = (struct extendedFileEntry *)bh->b_data;\n\n\tif (fe->icbTag.strategyType == cpu_to_le16(4096)) {\n\t\tstruct buffer_head *ibh;\n\n\t\tibh = udf_read_ptagged(inode->i_sb, iloc, 1, &ident);\n\t\tif (ident == TAG_IDENT_IE && ibh) {\n\t\t\tstruct kernel_lb_addr loc;\n\t\t\tstruct indirectEntry *ie;\n\n\t\t\tie = (struct indirectEntry *)ibh->b_data;\n\t\t\tloc = lelb_to_cpu(ie->indirectICB.extLocation);\n\n\t\t\tif (ie->indirectICB.extLength) {\n\t\t\t\tbrelse(ibh);\n\t\t\t\tmemcpy(&iinfo->i_location, &loc,\n\t\t\t\t       sizeof(struct kernel_lb_addr));\n\t\t\t\tif (++indirections > UDF_MAX_ICB_NESTING) {\n\t\t\t\t\tudf_err(inode->i_sb,\n\t\t\t\t\t\t\"too many ICBs in ICB hierarchy\"\n\t\t\t\t\t\t\" (max %d supported)\\n\",\n\t\t\t\t\t\tUDF_MAX_ICB_NESTING);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tbrelse(bh);\n\t\t\t\tgoto reread;\n\t\t\t}\n\t\t}\n\t\tbrelse(ibh);\n\t} else if (fe->icbTag.strategyType != cpu_to_le16(4)) {\n\t\tudf_err(inode->i_sb, \"unsupported strategy type: %d\\n\",\n\t\t\tle16_to_cpu(fe->icbTag.strategyType));\n\t\tgoto out;\n\t}\n\tif (fe->icbTag.strategyType == cpu_to_le16(4))\n\t\tiinfo->i_strat4096 = 0;\n\telse /* if (fe->icbTag.strategyType == cpu_to_le16(4096)) */\n\t\tiinfo->i_strat4096 = 1;\n\n\tiinfo->i_alloc_type = le16_to_cpu(fe->icbTag.flags) &\n\t\t\t\t\t\t\tICBTAG_FLAG_AD_MASK;\n\tiinfo->i_unique = 0;\n\tiinfo->i_lenEAttr = 0;\n\tiinfo->i_lenExtents = 0;\n\tiinfo->i_lenAlloc = 0;\n\tiinfo->i_next_alloc_block = 0;\n\tiinfo->i_next_alloc_goal = 0;\n\tif (fe->descTag.tagIdent == cpu_to_le16(TAG_IDENT_EFE)) {\n\t\tiinfo->i_efe = 1;\n\t\tiinfo->i_use = 0;\n\t\tret = udf_alloc_i_data(inode, bs -\n\t\t\t\t\tsizeof(struct extendedFileEntry));\n\t\tif (ret)\n\t\t\tgoto out;\n\t\tmemcpy(iinfo->i_ext.i_data,\n\t\t       bh->b_data + sizeof(struct extendedFileEntry),\n\t\t       bs - sizeof(struct extendedFileEntry));\n\t} else if (fe->descTag.tagIdent == cpu_to_le16(TAG_IDENT_FE)) {\n\t\tiinfo->i_efe = 0;\n\t\tiinfo->i_use = 0;\n\t\tret = udf_alloc_i_data(inode, bs - sizeof(struct fileEntry));\n\t\tif (ret)\n\t\t\tgoto out;\n\t\tmemcpy(iinfo->i_ext.i_data,\n\t\t       bh->b_data + sizeof(struct fileEntry),\n\t\t       bs - sizeof(struct fileEntry));\n\t} else if (fe->descTag.tagIdent == cpu_to_le16(TAG_IDENT_USE)) {\n\t\tiinfo->i_efe = 0;\n\t\tiinfo->i_use = 1;\n\t\tiinfo->i_lenAlloc = le32_to_cpu(\n\t\t\t\t((struct unallocSpaceEntry *)bh->b_data)->\n\t\t\t\t lengthAllocDescs);\n\t\tret = udf_alloc_i_data(inode, bs -\n\t\t\t\t\tsizeof(struct unallocSpaceEntry));\n\t\tif (ret)\n\t\t\tgoto out;\n\t\tmemcpy(iinfo->i_ext.i_data,\n\t\t       bh->b_data + sizeof(struct unallocSpaceEntry),\n\t\t       bs - sizeof(struct unallocSpaceEntry));\n\t\treturn 0;\n\t}\n\n\tret = -EIO;\n\tread_lock(&sbi->s_cred_lock);\n\ti_uid_write(inode, le32_to_cpu(fe->uid));\n\tif (!uid_valid(inode->i_uid) ||\n\t    UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_UID_IGNORE) ||\n\t    UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_UID_SET))\n\t\tinode->i_uid = UDF_SB(inode->i_sb)->s_uid;\n\n\ti_gid_write(inode, le32_to_cpu(fe->gid));\n\tif (!gid_valid(inode->i_gid) ||\n\t    UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_GID_IGNORE) ||\n\t    UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_GID_SET))\n\t\tinode->i_gid = UDF_SB(inode->i_sb)->s_gid;\n\n\tif (fe->icbTag.fileType != ICBTAG_FILE_TYPE_DIRECTORY &&\n\t\t\tsbi->s_fmode != UDF_INVALID_MODE)\n\t\tinode->i_mode = sbi->s_fmode;\n\telse if (fe->icbTag.fileType == ICBTAG_FILE_TYPE_DIRECTORY &&\n\t\t\tsbi->s_dmode != UDF_INVALID_MODE)\n\t\tinode->i_mode = sbi->s_dmode;\n\telse\n\t\tinode->i_mode = udf_convert_permissions(fe);\n\tinode->i_mode &= ~sbi->s_umask;\n\tread_unlock(&sbi->s_cred_lock);\n\n\tlink_count = le16_to_cpu(fe->fileLinkCount);\n\tif (!link_count) {\n\t\tif (!hidden_inode) {\n\t\t\tret = -ESTALE;\n\t\t\tgoto out;\n\t\t}\n\t\tlink_count = 1;\n\t}\n\tset_nlink(inode, link_count);\n\n\tinode->i_size = le64_to_cpu(fe->informationLength);\n\tiinfo->i_lenExtents = inode->i_size;\n\n\tif (iinfo->i_efe == 0) {\n\t\tinode->i_blocks = le64_to_cpu(fe->logicalBlocksRecorded) <<\n\t\t\t(inode->i_sb->s_blocksize_bits - 9);\n\n\t\tif (!udf_disk_stamp_to_time(&inode->i_atime, fe->accessTime))\n\t\t\tinode->i_atime = sbi->s_record_time;\n\n\t\tif (!udf_disk_stamp_to_time(&inode->i_mtime,\n\t\t\t\t\t    fe->modificationTime))\n\t\t\tinode->i_mtime = sbi->s_record_time;\n\n\t\tif (!udf_disk_stamp_to_time(&inode->i_ctime, fe->attrTime))\n\t\t\tinode->i_ctime = sbi->s_record_time;\n\n\t\tiinfo->i_unique = le64_to_cpu(fe->uniqueID);\n\t\tiinfo->i_lenEAttr = le32_to_cpu(fe->lengthExtendedAttr);\n\t\tiinfo->i_lenAlloc = le32_to_cpu(fe->lengthAllocDescs);\n\t\tiinfo->i_checkpoint = le32_to_cpu(fe->checkpoint);\n\t} else {\n\t\tinode->i_blocks = le64_to_cpu(efe->logicalBlocksRecorded) <<\n\t\t    (inode->i_sb->s_blocksize_bits - 9);\n\n\t\tif (!udf_disk_stamp_to_time(&inode->i_atime, efe->accessTime))\n\t\t\tinode->i_atime = sbi->s_record_time;\n\n\t\tif (!udf_disk_stamp_to_time(&inode->i_mtime,\n\t\t\t\t\t    efe->modificationTime))\n\t\t\tinode->i_mtime = sbi->s_record_time;\n\n\t\tif (!udf_disk_stamp_to_time(&iinfo->i_crtime, efe->createTime))\n\t\t\tiinfo->i_crtime = sbi->s_record_time;\n\n\t\tif (!udf_disk_stamp_to_time(&inode->i_ctime, efe->attrTime))\n\t\t\tinode->i_ctime = sbi->s_record_time;\n\n\t\tiinfo->i_unique = le64_to_cpu(efe->uniqueID);\n\t\tiinfo->i_lenEAttr = le32_to_cpu(efe->lengthExtendedAttr);\n\t\tiinfo->i_lenAlloc = le32_to_cpu(efe->lengthAllocDescs);\n\t\tiinfo->i_checkpoint = le32_to_cpu(efe->checkpoint);\n\t}\n\tinode->i_generation = iinfo->i_unique;\n\n\t/*\n\t * Sanity check length of allocation descriptors and extended attrs to\n\t * avoid integer overflows\n\t */\n\tif (iinfo->i_lenEAttr > bs || iinfo->i_lenAlloc > bs)\n\t\tgoto out;\n\t/* Now do exact checks */\n\tif (udf_file_entry_alloc_offset(inode) + iinfo->i_lenAlloc > bs)\n\t\tgoto out;\n\t/* Sanity checks for files in ICB so that we don't get confused later */\n\tif (iinfo->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB) {\n\t\t/*\n\t\t * For file in ICB data is stored in allocation descriptor\n\t\t * so sizes should match\n\t\t */\n\t\tif (iinfo->i_lenAlloc != inode->i_size)\n\t\t\tgoto out;\n\t\t/* File in ICB has to fit in there... */\n\t\tif (inode->i_size > bs - udf_file_entry_alloc_offset(inode))\n\t\t\tgoto out;\n\t}\n\n\tswitch (fe->icbTag.fileType) {\n\tcase ICBTAG_FILE_TYPE_DIRECTORY:\n\t\tinode->i_op = &udf_dir_inode_operations;\n\t\tinode->i_fop = &udf_dir_operations;\n\t\tinode->i_mode |= S_IFDIR;\n\t\tinc_nlink(inode);\n\t\tbreak;\n\tcase ICBTAG_FILE_TYPE_REALTIME:\n\tcase ICBTAG_FILE_TYPE_REGULAR:\n\tcase ICBTAG_FILE_TYPE_UNDEF:\n\tcase ICBTAG_FILE_TYPE_VAT20:\n\t\tif (iinfo->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB)\n\t\t\tinode->i_data.a_ops = &udf_adinicb_aops;\n\t\telse\n\t\t\tinode->i_data.a_ops = &udf_aops;\n\t\tinode->i_op = &udf_file_inode_operations;\n\t\tinode->i_fop = &udf_file_operations;\n\t\tinode->i_mode |= S_IFREG;\n\t\tbreak;\n\tcase ICBTAG_FILE_TYPE_BLOCK:\n\t\tinode->i_mode |= S_IFBLK;\n\t\tbreak;\n\tcase ICBTAG_FILE_TYPE_CHAR:\n\t\tinode->i_mode |= S_IFCHR;\n\t\tbreak;\n\tcase ICBTAG_FILE_TYPE_FIFO:\n\t\tinit_special_inode(inode, inode->i_mode | S_IFIFO, 0);\n\t\tbreak;\n\tcase ICBTAG_FILE_TYPE_SOCKET:\n\t\tinit_special_inode(inode, inode->i_mode | S_IFSOCK, 0);\n\t\tbreak;\n\tcase ICBTAG_FILE_TYPE_SYMLINK:\n\t\tinode->i_data.a_ops = &udf_symlink_aops;\n\t\tinode->i_op = &udf_symlink_inode_operations;\n\t\tinode->i_mode = S_IFLNK | S_IRWXUGO;\n\t\tbreak;\n\tcase ICBTAG_FILE_TYPE_MAIN:\n\t\tudf_debug(\"METADATA FILE-----\\n\");\n\t\tbreak;\n\tcase ICBTAG_FILE_TYPE_MIRROR:\n\t\tudf_debug(\"METADATA MIRROR FILE-----\\n\");\n\t\tbreak;\n\tcase ICBTAG_FILE_TYPE_BITMAP:\n\t\tudf_debug(\"METADATA BITMAP FILE-----\\n\");\n\t\tbreak;\n\tdefault:\n\t\tudf_err(inode->i_sb, \"(ino %ld) failed unknown file type=%d\\n\",\n\t\t\tinode->i_ino, fe->icbTag.fileType);\n\t\tgoto out;\n\t}\n\tif (S_ISCHR(inode->i_mode) || S_ISBLK(inode->i_mode)) {\n\t\tstruct deviceSpec *dsea =\n\t\t\t(struct deviceSpec *)udf_get_extendedattr(inode, 12, 1);\n\t\tif (dsea) {\n\t\t\tinit_special_inode(inode, inode->i_mode,\n\t\t\t\tMKDEV(le32_to_cpu(dsea->majorDeviceIdent),\n\t\t\t\t      le32_to_cpu(dsea->minorDeviceIdent)));\n\t\t\t/* Developer ID ??? */\n\t\t} else\n\t\t\tgoto out;\n\t}\n\tret = 0;\nout:\n\tbrelse(bh);\n\treturn ret;\n}",
    "includes": [
      "#include \"udf_sb.h\"",
      "#include \"udf_i.h\"",
      "#include <linux/aio.h>",
      "#include <linux/mpage.h>",
      "#include <linux/crc-itu-t.h>",
      "#include <linux/slab.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include \"udfdecl.h\""
    ],
    "macros_used": [
      "#define UDF_MAX_ICB_NESTING 1024"
    ],
    "globals_used": [
      "static umode_t udf_convert_permissions(struct fileEntry *);",
      "static int udf_update_inode(struct inode *, int);",
      "static int udf_sync_inode(struct inode *inode);",
      "static int udf_get_block(struct inode *, sector_t, struct buffer_head *, int);",
      "const struct address_space_operations udf_aops = {\n\t.readpage\t= udf_readpage,\n\t.readpages\t= udf_readpages,\n\t.writepage\t= udf_writepage,\n\t.writepages\t= udf_writepages,\n\t.write_begin\t= udf_write_begin,\n\t.write_end\t= generic_write_end,\n\t.direct_IO\t= udf_direct_IO,\n\t.bmap\t\t= udf_bmap,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 1575
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_special_inode",
          "args": [
            "inode",
            "inode->i_mode",
            "MKDEV(le32_to_cpu(dsea->majorDeviceIdent),\n\t\t\t\t      le32_to_cpu(dsea->minorDeviceIdent))"
          ],
          "line": 1566
        },
        "resolved": true,
        "details": {
          "function_name": "init_special_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1854-1871",
          "snippet": "void init_special_inode(struct inode *inode, umode_t mode, dev_t rdev)\n{\n\tinode->i_mode = mode;\n\tif (S_ISCHR(mode)) {\n\t\tinode->i_fop = &def_chr_fops;\n\t\tinode->i_rdev = rdev;\n\t} else if (S_ISBLK(mode)) {\n\t\tinode->i_fop = &def_blk_fops;\n\t\tinode->i_rdev = rdev;\n\t} else if (S_ISFIFO(mode))\n\t\tinode->i_fop = &pipefifo_fops;\n\telse if (S_ISSOCK(mode))\n\t\t;\t/* leave it no_open_fops */\n\telse\n\t\tprintk(KERN_DEBUG \"init_special_inode: bogus i_mode (%o) for\"\n\t\t\t\t  \" inode %s:%lu\\n\", mode, inode->i_sb->s_id,\n\t\t\t\t  inode->i_ino);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid init_special_inode(struct inode *inode, umode_t mode, dev_t rdev)\n{\n\tinode->i_mode = mode;\n\tif (S_ISCHR(mode)) {\n\t\tinode->i_fop = &def_chr_fops;\n\t\tinode->i_rdev = rdev;\n\t} else if (S_ISBLK(mode)) {\n\t\tinode->i_fop = &def_blk_fops;\n\t\tinode->i_rdev = rdev;\n\t} else if (S_ISFIFO(mode))\n\t\tinode->i_fop = &pipefifo_fops;\n\telse if (S_ISSOCK(mode))\n\t\t;\t/* leave it no_open_fops */\n\telse\n\t\tprintk(KERN_DEBUG \"init_special_inode: bogus i_mode (%o) for\"\n\t\t\t\t  \" inode %s:%lu\\n\", mode, inode->i_sb->s_id,\n\t\t\t\t  inode->i_ino);\n}"
        }
      },
      {
        "call_info": {
          "callee": "MKDEV",
          "args": [
            "le32_to_cpu(dsea->majorDeviceIdent)",
            "le32_to_cpu(dsea->minorDeviceIdent)"
          ],
          "line": 1567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "dsea->minorDeviceIdent"
          ],
          "line": 1568
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_get_extendedattr",
          "args": [
            "inode",
            "12",
            "1"
          ],
          "line": 1564
        },
        "resolved": true,
        "details": {
          "function_name": "udf_get_extendedattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/misc.c",
          "lines": "151-190",
          "snippet": "struct genericFormat *udf_get_extendedattr(struct inode *inode, uint32_t type,\n\t\t\t\t\t   uint8_t subtype)\n{\n\tstruct genericFormat *gaf;\n\tuint8_t *ea = NULL;\n\tuint32_t offset;\n\tstruct udf_inode_info *iinfo = UDF_I(inode);\n\n\tea = iinfo->i_ext.i_data;\n\n\tif (iinfo->i_lenEAttr) {\n\t\tstruct extendedAttrHeaderDesc *eahd;\n\t\teahd = (struct extendedAttrHeaderDesc *)ea;\n\n\t\t/* check checksum/crc */\n\t\tif (eahd->descTag.tagIdent !=\n\t\t\t\tcpu_to_le16(TAG_IDENT_EAHD) ||\n\t\t    le32_to_cpu(eahd->descTag.tagLocation) !=\n\t\t\t\tiinfo->i_location.logicalBlockNum)\n\t\t\treturn NULL;\n\n\t\tif (type < 2048)\n\t\t\toffset = sizeof(struct extendedAttrHeaderDesc);\n\t\telse if (type < 65536)\n\t\t\toffset = le32_to_cpu(eahd->impAttrLocation);\n\t\telse\n\t\t\toffset = le32_to_cpu(eahd->appAttrLocation);\n\n\t\twhile (offset < iinfo->i_lenEAttr) {\n\t\t\tgaf = (struct genericFormat *)&ea[offset];\n\t\t\tif (le32_to_cpu(gaf->attrType) == type &&\n\t\t\t\t\tgaf->attrSubtype == subtype)\n\t\t\t\treturn gaf;\n\t\t\telse\n\t\t\t\toffset += le32_to_cpu(gaf->attrLength);\n\t\t}\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"udf_sb.h\"",
            "#include \"udf_i.h\"",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/crc-itu-t.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include \"udfdecl.h\"\n\nstruct genericFormat *udf_get_extendedattr(struct inode *inode, uint32_t type,\n\t\t\t\t\t   uint8_t subtype)\n{\n\tstruct genericFormat *gaf;\n\tuint8_t *ea = NULL;\n\tuint32_t offset;\n\tstruct udf_inode_info *iinfo = UDF_I(inode);\n\n\tea = iinfo->i_ext.i_data;\n\n\tif (iinfo->i_lenEAttr) {\n\t\tstruct extendedAttrHeaderDesc *eahd;\n\t\teahd = (struct extendedAttrHeaderDesc *)ea;\n\n\t\t/* check checksum/crc */\n\t\tif (eahd->descTag.tagIdent !=\n\t\t\t\tcpu_to_le16(TAG_IDENT_EAHD) ||\n\t\t    le32_to_cpu(eahd->descTag.tagLocation) !=\n\t\t\t\tiinfo->i_location.logicalBlockNum)\n\t\t\treturn NULL;\n\n\t\tif (type < 2048)\n\t\t\toffset = sizeof(struct extendedAttrHeaderDesc);\n\t\telse if (type < 65536)\n\t\t\toffset = le32_to_cpu(eahd->impAttrLocation);\n\t\telse\n\t\t\toffset = le32_to_cpu(eahd->appAttrLocation);\n\n\t\twhile (offset < iinfo->i_lenEAttr) {\n\t\t\tgaf = (struct genericFormat *)&ea[offset];\n\t\t\tif (le32_to_cpu(gaf->attrType) == type &&\n\t\t\t\t\tgaf->attrSubtype == subtype)\n\t\t\t\treturn gaf;\n\t\t\telse\n\t\t\t\toffset += le32_to_cpu(gaf->attrLength);\n\t\t}\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISBLK",
          "args": [
            "inode->i_mode"
          ],
          "line": 1562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISCHR",
          "args": [
            "inode->i_mode"
          ],
          "line": 1562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udf_err",
          "args": [
            "inode->i_sb",
            "\"(ino %ld) failed unknown file type=%d\\n\"",
            "inode->i_ino",
            "fe->icbTag.fileType"
          ],
          "line": 1558
        },
        "resolved": true,
        "details": {
          "function_name": "_udf_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/super.c",
          "lines": "2256-2270",
          "snippet": "void _udf_err(struct super_block *sb, const char *function,\n\t      const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tpr_err(\"error (device %s): %s: %pV\", sb->s_id, function, &vaf);\n\n\tva_end(args);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/init.h>",
            "#include \"udf_i.h\"",
            "#include \"udf_sb.h\"",
            "#include <asm/byteorder.h>",
            "#include <linux/log2.h>",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/errno.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/vfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/nls.h>",
            "#include <linux/cdrom.h>",
            "#include <linux/stat.h>",
            "#include <linux/parser.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int udf_fill_super(struct super_block *, void *, int);",
            "static void udf_put_super(struct super_block *);",
            "static int udf_sync_fs(struct super_block *, int);",
            "static int udf_remount_fs(struct super_block *, int *, char *);",
            "static void udf_open_lvid(struct super_block *);",
            "static void udf_close_lvid(struct super_block *);",
            "static unsigned int udf_count_free(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/init.h>\n#include \"udf_i.h\"\n#include \"udf_sb.h\"\n#include <asm/byteorder.h>\n#include <linux/log2.h>\n#include <linux/crc-itu-t.h>\n#include <linux/bitmap.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/errno.h>\n#include <linux/vmalloc.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/nls.h>\n#include <linux/cdrom.h>\n#include <linux/stat.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include \"udfdecl.h\"\n\nstatic int udf_fill_super(struct super_block *, void *, int);\nstatic void udf_put_super(struct super_block *);\nstatic int udf_sync_fs(struct super_block *, int);\nstatic int udf_remount_fs(struct super_block *, int *, char *);\nstatic void udf_open_lvid(struct super_block *);\nstatic void udf_close_lvid(struct super_block *);\nstatic unsigned int udf_count_free(struct super_block *);\n\nvoid _udf_err(struct super_block *sb, const char *function,\n\t      const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tpr_err(\"error (device %s): %s: %pV\", sb->s_id, function, &vaf);\n\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_debug",
          "args": [
            "\"METADATA BITMAP FILE-----\\n\""
          ],
          "line": 1555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udf_debug",
          "args": [
            "\"METADATA MIRROR FILE-----\\n\""
          ],
          "line": 1552
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udf_debug",
          "args": [
            "\"METADATA FILE-----\\n\""
          ],
          "line": 1549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inc_nlink",
          "args": [
            "inode"
          ],
          "line": 1517
        },
        "resolved": true,
        "details": {
          "function_name": "inc_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "327-335",
          "snippet": "void inc_nlink(struct inode *inode)\n{\n\tif (unlikely(inode->i_nlink == 0)) {\n\t\tWARN_ON(!(inode->i_state & I_LINKABLE));\n\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\t}\n\n\tinode->__i_nlink++;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid inc_nlink(struct inode *inode)\n{\n\tif (unlikely(inode->i_nlink == 0)) {\n\t\tWARN_ON(!(inode->i_state & I_LINKABLE));\n\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\t}\n\n\tinode->__i_nlink++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_file_entry_alloc_offset",
          "args": [
            "inode"
          ],
          "line": 1508
        },
        "resolved": true,
        "details": {
          "function_name": "udf_file_entry_alloc_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/udfdecl.h",
          "lines": "55-64",
          "snippet": "static inline size_t udf_file_entry_alloc_offset(struct inode *inode)\n{\n\tstruct udf_inode_info *iinfo = UDF_I(inode);\n\tif (iinfo->i_use)\n\t\treturn sizeof(struct unallocSpaceEntry);\n\telse if (iinfo->i_efe)\n\t\treturn sizeof(struct extendedFileEntry) + iinfo->i_lenEAttr;\n\telse\n\t\treturn sizeof(struct fileEntry) + iinfo->i_lenEAttr;\n}",
          "includes": [
            "#include \"udf_i.h\"",
            "#include \"udfend.h\"",
            "#include \"udf_sb.h\"",
            "#include <linux/udf_fs_i.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include \"osta_udf.h\"",
            "#include \"ecma_167.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_i.h\"\n#include \"udfend.h\"\n#include \"udf_sb.h\"\n#include <linux/udf_fs_i.h>\n#include <linux/buffer_head.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include \"osta_udf.h\"\n#include \"ecma_167.h\"\n\nstatic inline size_t udf_file_entry_alloc_offset(struct inode *inode)\n{\n\tstruct udf_inode_info *iinfo = UDF_I(inode);\n\tif (iinfo->i_use)\n\t\treturn sizeof(struct unallocSpaceEntry);\n\telse if (iinfo->i_efe)\n\t\treturn sizeof(struct extendedFileEntry) + iinfo->i_lenEAttr;\n\telse\n\t\treturn sizeof(struct fileEntry) + iinfo->i_lenEAttr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "efe->uniqueID"
          ],
          "line": 1483
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_disk_stamp_to_time",
          "args": [
            "&inode->i_ctime",
            "efe->attrTime"
          ],
          "line": 1480
        },
        "resolved": true,
        "details": {
          "function_name": "udf_disk_stamp_to_time",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/udftime.c",
          "lines": "87-117",
          "snippet": "struct timespec *\nudf_disk_stamp_to_time(struct timespec *dest, struct timestamp src)\n{\n\tint yday;\n\tu16 typeAndTimezone = le16_to_cpu(src.typeAndTimezone);\n\tu16 year = le16_to_cpu(src.year);\n\tuint8_t type = typeAndTimezone >> 12;\n\tint16_t offset;\n\n\tif (type == 1) {\n\t\toffset = typeAndTimezone << 4;\n\t\t/* sign extent offset */\n\t\toffset = (offset >> 4);\n\t\tif (offset == -2047) /* unspecified offset */\n\t\t\toffset = 0;\n\t} else\n\t\toffset = 0;\n\n\tif ((year < EPOCH_YEAR) ||\n\t    (year >= EPOCH_YEAR + MAX_YEAR_SECONDS)) {\n\t\treturn NULL;\n\t}\n\tdest->tv_sec = year_seconds[year - EPOCH_YEAR];\n\tdest->tv_sec -= offset * 60;\n\n\tyday = ((__mon_yday[__isleap(year)][src.month - 1]) + src.day - 1);\n\tdest->tv_sec += (((yday * 24) + src.hour) * 60 + src.minute) * 60 + src.second;\n\tdest->tv_nsec = 1000 * (src.centiseconds * 10000 +\n\t\t\tsrc.hundredsOfMicroseconds * 100 + src.microseconds);\n\treturn dest;\n}",
          "includes": [
            "#include <linux/kernel.h>",
            "#include <linux/types.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [
            "#define MAX_YEAR_SECONDS\t69",
            "#define EPOCH_YEAR 1970"
          ],
          "globals_used": [
            "static const unsigned short int __mon_yday[2][13] = {\n\t/* Normal years.  */\n\t{0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365},\n\t/* Leap years.  */\n\t{0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335, 366}\n};",
            "static time_t year_seconds[MAX_YEAR_SECONDS] = {\n/*1970*/ SPY(0,   0, 0), SPY(1,   0, 0), SPY(2,   0, 0), SPY(3,   1, 0),\n/*1974*/ SPY(4,   1, 0), SPY(5,   1, 0), SPY(6,   1, 0), SPY(7,   2, 0),\n/*1978*/ SPY(8,   2, 0), SPY(9,   2, 0), SPY(10,  2, 0), SPY(11,  3, 0),\n/*1982*/ SPY(12,  3, 0), SPY(13,  3, 0), SPY(14,  3, 0), SPY(15,  4, 0),\n/*1986*/ SPY(16,  4, 0), SPY(17,  4, 0), SPY(18,  4, 0), SPY(19,  5, 0),\n/*1990*/ SPY(20,  5, 0), SPY(21,  5, 0), SPY(22,  5, 0), SPY(23,  6, 0),\n/*1994*/ SPY(24,  6, 0), SPY(25,  6, 0), SPY(26,  6, 0), SPY(27,  7, 0),\n/*1998*/ SPY(28,  7, 0), SPY(29,  7, 0), SPY(30,  7, 0), SPY(31,  8, 0),\n/*2002*/ SPY(32,  8, 0), SPY(33,  8, 0), SPY(34,  8, 0), SPY(35,  9, 0),\n/*2006*/ SPY(36,  9, 0), SPY(37,  9, 0), SPY(38,  9, 0), SPY(39, 10, 0),\n/*2010*/ SPY(40, 10, 0), SPY(41, 10, 0), SPY(42, 10, 0), SPY(43, 11, 0),\n/*2014*/ SPY(44, 11, 0), SPY(45, 11, 0), SPY(46, 11, 0), SPY(47, 12, 0),\n/*2018*/ SPY(48, 12, 0), SPY(49, 12, 0), SPY(50, 12, 0), SPY(51, 13, 0),\n/*2022*/ SPY(52, 13, 0), SPY(53, 13, 0), SPY(54, 13, 0), SPY(55, 14, 0),\n/*2026*/ SPY(56, 14, 0), SPY(57, 14, 0), SPY(58, 14, 0), SPY(59, 15, 0),\n/*2030*/ SPY(60, 15, 0), SPY(61, 15, 0), SPY(62, 15, 0), SPY(63, 16, 0),\n/*2034*/ SPY(64, 16, 0), SPY(65, 16, 0), SPY(66, 16, 0), SPY(67, 17, 0),\n/*2038*/ SPY(68, 17, 0)\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/types.h>\n#include \"udfdecl.h\"\n\n#define MAX_YEAR_SECONDS\t69\n#define EPOCH_YEAR 1970\n\nstatic const unsigned short int __mon_yday[2][13] = {\n\t/* Normal years.  */\n\t{0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365},\n\t/* Leap years.  */\n\t{0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335, 366}\n};\nstatic time_t year_seconds[MAX_YEAR_SECONDS] = {\n/*1970*/ SPY(0,   0, 0), SPY(1,   0, 0), SPY(2,   0, 0), SPY(3,   1, 0),\n/*1974*/ SPY(4,   1, 0), SPY(5,   1, 0), SPY(6,   1, 0), SPY(7,   2, 0),\n/*1978*/ SPY(8,   2, 0), SPY(9,   2, 0), SPY(10,  2, 0), SPY(11,  3, 0),\n/*1982*/ SPY(12,  3, 0), SPY(13,  3, 0), SPY(14,  3, 0), SPY(15,  4, 0),\n/*1986*/ SPY(16,  4, 0), SPY(17,  4, 0), SPY(18,  4, 0), SPY(19,  5, 0),\n/*1990*/ SPY(20,  5, 0), SPY(21,  5, 0), SPY(22,  5, 0), SPY(23,  6, 0),\n/*1994*/ SPY(24,  6, 0), SPY(25,  6, 0), SPY(26,  6, 0), SPY(27,  7, 0),\n/*1998*/ SPY(28,  7, 0), SPY(29,  7, 0), SPY(30,  7, 0), SPY(31,  8, 0),\n/*2002*/ SPY(32,  8, 0), SPY(33,  8, 0), SPY(34,  8, 0), SPY(35,  9, 0),\n/*2006*/ SPY(36,  9, 0), SPY(37,  9, 0), SPY(38,  9, 0), SPY(39, 10, 0),\n/*2010*/ SPY(40, 10, 0), SPY(41, 10, 0), SPY(42, 10, 0), SPY(43, 11, 0),\n/*2014*/ SPY(44, 11, 0), SPY(45, 11, 0), SPY(46, 11, 0), SPY(47, 12, 0),\n/*2018*/ SPY(48, 12, 0), SPY(49, 12, 0), SPY(50, 12, 0), SPY(51, 13, 0),\n/*2022*/ SPY(52, 13, 0), SPY(53, 13, 0), SPY(54, 13, 0), SPY(55, 14, 0),\n/*2026*/ SPY(56, 14, 0), SPY(57, 14, 0), SPY(58, 14, 0), SPY(59, 15, 0),\n/*2030*/ SPY(60, 15, 0), SPY(61, 15, 0), SPY(62, 15, 0), SPY(63, 16, 0),\n/*2034*/ SPY(64, 16, 0), SPY(65, 16, 0), SPY(66, 16, 0), SPY(67, 17, 0),\n/*2038*/ SPY(68, 17, 0)\n};\n\nstruct timespec *\nudf_disk_stamp_to_time(struct timespec *dest, struct timestamp src)\n{\n\tint yday;\n\tu16 typeAndTimezone = le16_to_cpu(src.typeAndTimezone);\n\tu16 year = le16_to_cpu(src.year);\n\tuint8_t type = typeAndTimezone >> 12;\n\tint16_t offset;\n\n\tif (type == 1) {\n\t\toffset = typeAndTimezone << 4;\n\t\t/* sign extent offset */\n\t\toffset = (offset >> 4);\n\t\tif (offset == -2047) /* unspecified offset */\n\t\t\toffset = 0;\n\t} else\n\t\toffset = 0;\n\n\tif ((year < EPOCH_YEAR) ||\n\t    (year >= EPOCH_YEAR + MAX_YEAR_SECONDS)) {\n\t\treturn NULL;\n\t}\n\tdest->tv_sec = year_seconds[year - EPOCH_YEAR];\n\tdest->tv_sec -= offset * 60;\n\n\tyday = ((__mon_yday[__isleap(year)][src.month - 1]) + src.day - 1);\n\tdest->tv_sec += (((yday * 24) + src.hour) * 60 + src.minute) * 60 + src.second;\n\tdest->tv_nsec = 1000 * (src.centiseconds * 10000 +\n\t\t\tsrc.hundredsOfMicroseconds * 100 + src.microseconds);\n\treturn dest;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_nlink",
          "args": [
            "inode",
            "link_count"
          ],
          "line": 1443
        },
        "resolved": true,
        "details": {
          "function_name": "set_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "305-316",
          "snippet": "void set_nlink(struct inode *inode, unsigned int nlink)\n{\n\tif (!nlink) {\n\t\tclear_nlink(inode);\n\t} else {\n\t\t/* Yes, some filesystems do change nlink from zero to one */\n\t\tif (inode->i_nlink == 0)\n\t\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\n\t\tinode->__i_nlink = nlink;\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid set_nlink(struct inode *inode, unsigned int nlink)\n{\n\tif (!nlink) {\n\t\tclear_nlink(inode);\n\t} else {\n\t\t/* Yes, some filesystems do change nlink from zero to one */\n\t\tif (inode->i_nlink == 0)\n\t\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\n\t\tinode->__i_nlink = nlink;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "fe->fileLinkCount"
          ],
          "line": 1435
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_unlock",
          "args": [
            "&sbi->s_cred_lock"
          ],
          "line": 1433
        },
        "resolved": true,
        "details": {
          "function_name": "tree_mod_log_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "340-343",
          "snippet": "static inline void tree_mod_log_read_unlock(struct btrfs_fs_info *fs_info)\n{\n\tread_unlock(&fs_info->tree_mod_log_lock);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic inline void tree_mod_log_read_unlock(struct btrfs_fs_info *fs_info)\n{\n\tread_unlock(&fs_info->tree_mod_log_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_convert_permissions",
          "args": [
            "fe"
          ],
          "line": 1431
        },
        "resolved": true,
        "details": {
          "function_name": "udf_convert_permissions",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/inode.c",
          "lines": "1593-1610",
          "snippet": "static umode_t udf_convert_permissions(struct fileEntry *fe)\n{\n\tumode_t mode;\n\tuint32_t permissions;\n\tuint32_t flags;\n\n\tpermissions = le32_to_cpu(fe->permissions);\n\tflags = le16_to_cpu(fe->icbTag.flags);\n\n\tmode =\t((permissions) & S_IRWXO) |\n\t\t((permissions >> 2) & S_IRWXG) |\n\t\t((permissions >> 4) & S_IRWXU) |\n\t\t((flags & ICBTAG_FLAG_SETUID) ? S_ISUID : 0) |\n\t\t((flags & ICBTAG_FLAG_SETGID) ? S_ISGID : 0) |\n\t\t((flags & ICBTAG_FLAG_STICKY) ? S_ISVTX : 0);\n\n\treturn mode;\n}",
          "includes": [
            "#include \"udf_sb.h\"",
            "#include \"udf_i.h\"",
            "#include <linux/aio.h>",
            "#include <linux/mpage.h>",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static umode_t udf_convert_permissions(struct fileEntry *);",
            "static int8_t udf_insert_aext(struct inode *, struct extent_position,\n\t\t\t      struct kernel_lb_addr, uint32_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/crc-itu-t.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include \"udfdecl.h\"\n\nstatic umode_t udf_convert_permissions(struct fileEntry *);\nstatic int8_t udf_insert_aext(struct inode *, struct extent_position,\n\t\t\t      struct kernel_lb_addr, uint32_t);\n\nstatic umode_t udf_convert_permissions(struct fileEntry *fe)\n{\n\tumode_t mode;\n\tuint32_t permissions;\n\tuint32_t flags;\n\n\tpermissions = le32_to_cpu(fe->permissions);\n\tflags = le16_to_cpu(fe->icbTag.flags);\n\n\tmode =\t((permissions) & S_IRWXO) |\n\t\t((permissions >> 2) & S_IRWXG) |\n\t\t((permissions >> 4) & S_IRWXU) |\n\t\t((flags & ICBTAG_FLAG_SETUID) ? S_ISUID : 0) |\n\t\t((flags & ICBTAG_FLAG_SETGID) ? S_ISGID : 0) |\n\t\t((flags & ICBTAG_FLAG_STICKY) ? S_ISVTX : 0);\n\n\treturn mode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "UDF_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 1422
        },
        "resolved": true,
        "details": {
          "function_name": "UDF_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/udf_sb.h",
          "lines": "160-163",
          "snippet": "static inline struct udf_sb_info *UDF_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/bitops.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bitops.h>\n#include <linux/mutex.h>\n\nstatic inline struct udf_sb_info *UDF_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "UDF_QUERY_FLAG",
          "args": [
            "inode->i_sb",
            "UDF_FLAG_GID_SET"
          ],
          "line": 1421
        },
        "resolved": true,
        "details": {
          "function_name": "UDF_QUERY_FLAG",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/udf_sb.h",
          "lines": "169-172",
          "snippet": "static inline int UDF_QUERY_FLAG(struct super_block *sb, int flag)\n{\n\treturn test_bit(flag, &UDF_SB(sb)->s_flags);\n}",
          "includes": [
            "#include <linux/bitops.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bitops.h>\n#include <linux/mutex.h>\n\nstatic inline int UDF_QUERY_FLAG(struct super_block *sb, int flag)\n{\n\treturn test_bit(flag, &UDF_SB(sb)->s_flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gid_valid",
          "args": [
            "inode->i_gid"
          ],
          "line": 1419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_gid_write",
          "args": [
            "inode",
            "le32_to_cpu(fe->gid)"
          ],
          "line": 1418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uid_valid",
          "args": [
            "inode->i_uid"
          ],
          "line": 1413
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_uuid_valid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/sys.c",
          "lines": "73-82",
          "snippet": "static int gfs2_uuid_valid(const u8 *uuid)\n{\n\tint i;\n\n\tfor (i = 0; i < 16; i++) {\n\t\tif (uuid[i])\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"recovery.h\"",
            "#include \"glops.h\"",
            "#include \"util.h\"",
            "#include \"quota.h\"",
            "#include \"glock.h\"",
            "#include \"super.h\"",
            "#include \"sys.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/genhd.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/kobject.h>",
            "#include <linux/module.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"recovery.h\"\n#include \"glops.h\"\n#include \"util.h\"\n#include \"quota.h\"\n#include \"glock.h\"\n#include \"super.h\"\n#include \"sys.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/genhd.h>\n#include <linux/gfs2_ondisk.h>\n#include <asm/uaccess.h>\n#include <linux/kobject.h>\n#include <linux/module.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n\nstatic int gfs2_uuid_valid(const u8 *uuid)\n{\n\tint i;\n\n\tfor (i = 0; i < 16; i++) {\n\t\tif (uuid[i])\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_uid_write",
          "args": [
            "inode",
            "le32_to_cpu(fe->uid)"
          ],
          "line": 1412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_lock",
          "args": [
            "&sbi->s_cred_lock"
          ],
          "line": 1411
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_read_locked_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/inode.c",
          "lines": "550-1203",
          "snippet": "static int ntfs_read_locked_inode(struct inode *vi)\n{\n\tntfs_volume *vol = NTFS_SB(vi->i_sb);\n\tntfs_inode *ni;\n\tstruct inode *bvi;\n\tMFT_RECORD *m;\n\tATTR_RECORD *a;\n\tSTANDARD_INFORMATION *si;\n\tntfs_attr_search_ctx *ctx;\n\tint err = 0;\n\n\tntfs_debug(\"Entering for i_ino 0x%lx.\", vi->i_ino);\n\n\t/* Setup the generic vfs inode parts now. */\n\n\t/*\n\t * This is for checking whether an inode has changed w.r.t. a file so\n\t * that the file can be updated if necessary (compare with f_version).\n\t */\n\tvi->i_version = 1;\n\n\tvi->i_uid = vol->uid;\n\tvi->i_gid = vol->gid;\n\tvi->i_mode = 0;\n\n\t/*\n\t * Initialize the ntfs specific part of @vi special casing\n\t * FILE_MFT which we need to do at mount time.\n\t */\n\tif (vi->i_ino != FILE_MFT)\n\t\tntfs_init_big_inode(vi);\n\tni = NTFS_I(vi);\n\n\tm = map_mft_record(ni);\n\tif (IS_ERR(m)) {\n\t\terr = PTR_ERR(m);\n\t\tgoto err_out;\n\t}\n\tctx = ntfs_attr_get_search_ctx(ni, m);\n\tif (!ctx) {\n\t\terr = -ENOMEM;\n\t\tgoto unm_err_out;\n\t}\n\n\tif (!(m->flags & MFT_RECORD_IN_USE)) {\n\t\tntfs_error(vi->i_sb, \"Inode is not in use!\");\n\t\tgoto unm_err_out;\n\t}\n\tif (m->base_mft_record) {\n\t\tntfs_error(vi->i_sb, \"Inode is an extent inode!\");\n\t\tgoto unm_err_out;\n\t}\n\n\t/* Transfer information from mft record into vfs and ntfs inodes. */\n\tvi->i_generation = ni->seq_no = le16_to_cpu(m->sequence_number);\n\n\t/*\n\t * FIXME: Keep in mind that link_count is two for files which have both\n\t * a long file name and a short file name as separate entries, so if\n\t * we are hiding short file names this will be too high. Either we need\n\t * to account for the short file names by subtracting them or we need\n\t * to make sure we delete files even though i_nlink is not zero which\n\t * might be tricky due to vfs interactions. Need to think about this\n\t * some more when implementing the unlink command.\n\t */\n\tset_nlink(vi, le16_to_cpu(m->link_count));\n\t/*\n\t * FIXME: Reparse points can have the directory bit set even though\n\t * they would be S_IFLNK. Need to deal with this further below when we\n\t * implement reparse points / symbolic links but it will do for now.\n\t * Also if not a directory, it could be something else, rather than\n\t * a regular file. But again, will do for now.\n\t */\n\t/* Everyone gets all permissions. */\n\tvi->i_mode |= S_IRWXUGO;\n\t/* If read-only, no one gets write permissions. */\n\tif (IS_RDONLY(vi))\n\t\tvi->i_mode &= ~S_IWUGO;\n\tif (m->flags & MFT_RECORD_IS_DIRECTORY) {\n\t\tvi->i_mode |= S_IFDIR;\n\t\t/*\n\t\t * Apply the directory permissions mask set in the mount\n\t\t * options.\n\t\t */\n\t\tvi->i_mode &= ~vol->dmask;\n\t\t/* Things break without this kludge! */\n\t\tif (vi->i_nlink > 1)\n\t\t\tset_nlink(vi, 1);\n\t} else {\n\t\tvi->i_mode |= S_IFREG;\n\t\t/* Apply the file permissions mask set in the mount options. */\n\t\tvi->i_mode &= ~vol->fmask;\n\t}\n\t/*\n\t * Find the standard information attribute in the mft record. At this\n\t * stage we haven't setup the attribute list stuff yet, so this could\n\t * in fact fail if the standard information is in an extent record, but\n\t * I don't think this actually ever happens.\n\t */\n\terr = ntfs_attr_lookup(AT_STANDARD_INFORMATION, NULL, 0, 0, 0, NULL, 0,\n\t\t\tctx);\n\tif (unlikely(err)) {\n\t\tif (err == -ENOENT) {\n\t\t\t/*\n\t\t\t * TODO: We should be performing a hot fix here (if the\n\t\t\t * recover mount option is set) by creating a new\n\t\t\t * attribute.\n\t\t\t */\n\t\t\tntfs_error(vi->i_sb, \"$STANDARD_INFORMATION attribute \"\n\t\t\t\t\t\"is missing.\");\n\t\t}\n\t\tgoto unm_err_out;\n\t}\n\ta = ctx->attr;\n\t/* Get the standard information attribute value. */\n\tsi = (STANDARD_INFORMATION*)((u8*)a +\n\t\t\tle16_to_cpu(a->data.resident.value_offset));\n\n\t/* Transfer information from the standard information into vi. */\n\t/*\n\t * Note: The i_?times do not quite map perfectly onto the NTFS times,\n\t * but they are close enough, and in the end it doesn't really matter\n\t * that much...\n\t */\n\t/*\n\t * mtime is the last change of the data within the file. Not changed\n\t * when only metadata is changed, e.g. a rename doesn't affect mtime.\n\t */\n\tvi->i_mtime = ntfs2utc(si->last_data_change_time);\n\t/*\n\t * ctime is the last change of the metadata of the file. This obviously\n\t * always changes, when mtime is changed. ctime can be changed on its\n\t * own, mtime is then not changed, e.g. when a file is renamed.\n\t */\n\tvi->i_ctime = ntfs2utc(si->last_mft_change_time);\n\t/*\n\t * Last access to the data within the file. Not changed during a rename\n\t * for example but changed whenever the file is written to.\n\t */\n\tvi->i_atime = ntfs2utc(si->last_access_time);\n\n\t/* Find the attribute list attribute if present. */\n\tntfs_attr_reinit_search_ctx(ctx);\n\terr = ntfs_attr_lookup(AT_ATTRIBUTE_LIST, NULL, 0, 0, 0, NULL, 0, ctx);\n\tif (err) {\n\t\tif (unlikely(err != -ENOENT)) {\n\t\t\tntfs_error(vi->i_sb, \"Failed to lookup attribute list \"\n\t\t\t\t\t\"attribute.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t} else /* if (!err) */ {\n\t\tif (vi->i_ino == FILE_MFT)\n\t\t\tgoto skip_attr_list_load;\n\t\tntfs_debug(\"Attribute list found in inode 0x%lx.\", vi->i_ino);\n\t\tNInoSetAttrList(ni);\n\t\ta = ctx->attr;\n\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\tntfs_error(vi->i_sb, \"Attribute list attribute is \"\n\t\t\t\t\t\"compressed.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_IS_ENCRYPTED ||\n\t\t\t\ta->flags & ATTR_IS_SPARSE) {\n\t\t\tif (a->non_resident) {\n\t\t\t\tntfs_error(vi->i_sb, \"Non-resident attribute \"\n\t\t\t\t\t\t\"list attribute is encrypted/\"\n\t\t\t\t\t\t\"sparse.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tntfs_warning(vi->i_sb, \"Resident attribute list \"\n\t\t\t\t\t\"attribute in inode 0x%lx is marked \"\n\t\t\t\t\t\"encrypted/sparse which is not true.  \"\n\t\t\t\t\t\"However, Windows allows this and \"\n\t\t\t\t\t\"chkdsk does not detect or correct it \"\n\t\t\t\t\t\"so we will just ignore the invalid \"\n\t\t\t\t\t\"flags and pretend they are not set.\",\n\t\t\t\t\tvi->i_ino);\n\t\t}\n\t\t/* Now allocate memory for the attribute list. */\n\t\tni->attr_list_size = (u32)ntfs_attr_size(a);\n\t\tni->attr_list = ntfs_malloc_nofs(ni->attr_list_size);\n\t\tif (!ni->attr_list) {\n\t\t\tntfs_error(vi->i_sb, \"Not enough memory to allocate \"\n\t\t\t\t\t\"buffer for attribute list.\");\n\t\t\terr = -ENOMEM;\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->non_resident) {\n\t\t\tNInoSetAttrListNonResident(ni);\n\t\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\t\tntfs_error(vi->i_sb, \"Attribute list has non \"\n\t\t\t\t\t\t\"zero lowest_vcn.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Setup the runlist. No need for locking as we have\n\t\t\t * exclusive access to the inode at this time.\n\t\t\t */\n\t\t\tni->attr_list_rl.rl = ntfs_mapping_pairs_decompress(vol,\n\t\t\t\t\ta, NULL);\n\t\t\tif (IS_ERR(ni->attr_list_rl.rl)) {\n\t\t\t\terr = PTR_ERR(ni->attr_list_rl.rl);\n\t\t\t\tni->attr_list_rl.rl = NULL;\n\t\t\t\tntfs_error(vi->i_sb, \"Mapping pairs \"\n\t\t\t\t\t\t\"decompression failed.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/* Now load the attribute list. */\n\t\t\tif ((err = load_attribute_list(vol, &ni->attr_list_rl,\n\t\t\t\t\tni->attr_list, ni->attr_list_size,\n\t\t\t\t\tsle64_to_cpu(a->data.non_resident.\n\t\t\t\t\tinitialized_size)))) {\n\t\t\t\tntfs_error(vi->i_sb, \"Failed to load \"\n\t\t\t\t\t\t\"attribute list attribute.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t} else /* if (!a->non_resident) */ {\n\t\t\tif ((u8*)a + le16_to_cpu(a->data.resident.value_offset)\n\t\t\t\t\t+ le32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length) >\n\t\t\t\t\t(u8*)ctx->mrec + vol->mft_record_size) {\n\t\t\t\tntfs_error(vi->i_sb, \"Corrupt attribute list \"\n\t\t\t\t\t\t\"in inode.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/* Now copy the attribute list. */\n\t\t\tmemcpy(ni->attr_list, (u8*)a + le16_to_cpu(\n\t\t\t\t\ta->data.resident.value_offset),\n\t\t\t\t\tle32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length));\n\t\t}\n\t}\nskip_attr_list_load:\n\t/*\n\t * If an attribute list is present we now have the attribute list value\n\t * in ntfs_ino->attr_list and it is ntfs_ino->attr_list_size bytes.\n\t */\n\tif (S_ISDIR(vi->i_mode)) {\n\t\tloff_t bvi_size;\n\t\tntfs_inode *bni;\n\t\tINDEX_ROOT *ir;\n\t\tu8 *ir_end, *index_end;\n\n\t\t/* It is a directory, find index root attribute. */\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\t\terr = ntfs_attr_lookup(AT_INDEX_ROOT, I30, 4, CASE_SENSITIVE,\n\t\t\t\t0, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tif (err == -ENOENT) {\n\t\t\t\t// FIXME: File is corrupt! Hot-fix with empty\n\t\t\t\t// index root attribute if recovery option is\n\t\t\t\t// set.\n\t\t\t\tntfs_error(vi->i_sb, \"$INDEX_ROOT attribute \"\n\t\t\t\t\t\t\"is missing.\");\n\t\t\t}\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\ta = ctx->attr;\n\t\t/* Set up the state. */\n\t\tif (unlikely(a->non_resident)) {\n\t\t\tntfs_error(vol->sb, \"$INDEX_ROOT attribute is not \"\n\t\t\t\t\t\"resident.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/* Ensure the attribute name is placed before the value. */\n\t\tif (unlikely(a->name_length && (le16_to_cpu(a->name_offset) >=\n\t\t\t\tle16_to_cpu(a->data.resident.value_offset)))) {\n\t\t\tntfs_error(vol->sb, \"$INDEX_ROOT attribute name is \"\n\t\t\t\t\t\"placed after the attribute value.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/*\n\t\t * Compressed/encrypted index root just means that the newly\n\t\t * created files in that directory should be created compressed/\n\t\t * encrypted. However index root cannot be both compressed and\n\t\t * encrypted.\n\t\t */\n\t\tif (a->flags & ATTR_COMPRESSION_MASK)\n\t\t\tNInoSetCompressed(ni);\n\t\tif (a->flags & ATTR_IS_ENCRYPTED) {\n\t\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\t\tntfs_error(vi->i_sb, \"Found encrypted and \"\n\t\t\t\t\t\t\"compressed attribute.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tNInoSetEncrypted(ni);\n\t\t}\n\t\tif (a->flags & ATTR_IS_SPARSE)\n\t\t\tNInoSetSparse(ni);\n\t\tir = (INDEX_ROOT*)((u8*)a +\n\t\t\t\tle16_to_cpu(a->data.resident.value_offset));\n\t\tir_end = (u8*)ir + le32_to_cpu(a->data.resident.value_length);\n\t\tif (ir_end > (u8*)ctx->mrec + vol->mft_record_size) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ROOT attribute is \"\n\t\t\t\t\t\"corrupt.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tindex_end = (u8*)&ir->index +\n\t\t\t\tle32_to_cpu(ir->index.index_length);\n\t\tif (index_end > ir_end) {\n\t\t\tntfs_error(vi->i_sb, \"Directory index is corrupt.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ir->type != AT_FILE_NAME) {\n\t\t\tntfs_error(vi->i_sb, \"Indexed attribute is not \"\n\t\t\t\t\t\"$FILE_NAME.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ir->collation_rule != COLLATION_FILE_NAME) {\n\t\t\tntfs_error(vi->i_sb, \"Index collation rule is not \"\n\t\t\t\t\t\"COLLATION_FILE_NAME.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tni->itype.index.collation_rule = ir->collation_rule;\n\t\tni->itype.index.block_size = le32_to_cpu(ir->index_block_size);\n\t\tif (ni->itype.index.block_size &\n\t\t\t\t(ni->itype.index.block_size - 1)) {\n\t\t\tntfs_error(vi->i_sb, \"Index block size (%u) is not a \"\n\t\t\t\t\t\"power of two.\",\n\t\t\t\t\tni->itype.index.block_size);\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ni->itype.index.block_size > PAGE_CACHE_SIZE) {\n\t\t\tntfs_error(vi->i_sb, \"Index block size (%u) > \"\n\t\t\t\t\t\"PAGE_CACHE_SIZE (%ld) is not \"\n\t\t\t\t\t\"supported.  Sorry.\",\n\t\t\t\t\tni->itype.index.block_size,\n\t\t\t\t\tPAGE_CACHE_SIZE);\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ni->itype.index.block_size < NTFS_BLOCK_SIZE) {\n\t\t\tntfs_error(vi->i_sb, \"Index block size (%u) < \"\n\t\t\t\t\t\"NTFS_BLOCK_SIZE (%i) is not \"\n\t\t\t\t\t\"supported.  Sorry.\",\n\t\t\t\t\tni->itype.index.block_size,\n\t\t\t\t\tNTFS_BLOCK_SIZE);\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tni->itype.index.block_size_bits =\n\t\t\t\tffs(ni->itype.index.block_size) - 1;\n\t\t/* Determine the size of a vcn in the directory index. */\n\t\tif (vol->cluster_size <= ni->itype.index.block_size) {\n\t\t\tni->itype.index.vcn_size = vol->cluster_size;\n\t\t\tni->itype.index.vcn_size_bits = vol->cluster_size_bits;\n\t\t} else {\n\t\t\tni->itype.index.vcn_size = vol->sector_size;\n\t\t\tni->itype.index.vcn_size_bits = vol->sector_size_bits;\n\t\t}\n\n\t\t/* Setup the index allocation attribute, even if not present. */\n\t\tNInoSetMstProtected(ni);\n\t\tni->type = AT_INDEX_ALLOCATION;\n\t\tni->name = I30;\n\t\tni->name_len = 4;\n\n\t\tif (!(ir->index.flags & LARGE_INDEX)) {\n\t\t\t/* No index allocation. */\n\t\t\tvi->i_size = ni->initialized_size =\n\t\t\t\t\tni->allocated_size = 0;\n\t\t\t/* We are done with the mft record, so we release it. */\n\t\t\tntfs_attr_put_search_ctx(ctx);\n\t\t\tunmap_mft_record(ni);\n\t\t\tm = NULL;\n\t\t\tctx = NULL;\n\t\t\tgoto skip_large_dir_stuff;\n\t\t} /* LARGE_INDEX: Index allocation present. Setup state. */\n\t\tNInoSetIndexAllocPresent(ni);\n\t\t/* Find index allocation attribute. */\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\t\terr = ntfs_attr_lookup(AT_INDEX_ALLOCATION, I30, 4,\n\t\t\t\tCASE_SENSITIVE, 0, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tif (err == -ENOENT)\n\t\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION \"\n\t\t\t\t\t\t\"attribute is not present but \"\n\t\t\t\t\t\t\"$INDEX_ROOT indicated it is.\");\n\t\t\telse\n\t\t\t\tntfs_error(vi->i_sb, \"Failed to lookup \"\n\t\t\t\t\t\t\"$INDEX_ALLOCATION \"\n\t\t\t\t\t\t\"attribute.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\ta = ctx->attr;\n\t\tif (!a->non_resident) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is resident.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/*\n\t\t * Ensure the attribute name is placed before the mapping pairs\n\t\t * array.\n\t\t */\n\t\tif (unlikely(a->name_length && (le16_to_cpu(a->name_offset) >=\n\t\t\t\tle16_to_cpu(\n\t\t\t\ta->data.non_resident.mapping_pairs_offset)))) {\n\t\t\tntfs_error(vol->sb, \"$INDEX_ALLOCATION attribute name \"\n\t\t\t\t\t\"is placed after the mapping pairs \"\n\t\t\t\t\t\"array.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_IS_ENCRYPTED) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is encrypted.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_IS_SPARSE) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is sparse.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is compressed.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\tntfs_error(vi->i_sb, \"First extent of \"\n\t\t\t\t\t\"$INDEX_ALLOCATION attribute has non \"\n\t\t\t\t\t\"zero lowest_vcn.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tvi->i_size = sle64_to_cpu(a->data.non_resident.data_size);\n\t\tni->initialized_size = sle64_to_cpu(\n\t\t\t\ta->data.non_resident.initialized_size);\n\t\tni->allocated_size = sle64_to_cpu(\n\t\t\t\ta->data.non_resident.allocated_size);\n\t\t/*\n\t\t * We are done with the mft record, so we release it. Otherwise\n\t\t * we would deadlock in ntfs_attr_iget().\n\t\t */\n\t\tntfs_attr_put_search_ctx(ctx);\n\t\tunmap_mft_record(ni);\n\t\tm = NULL;\n\t\tctx = NULL;\n\t\t/* Get the index bitmap attribute inode. */\n\t\tbvi = ntfs_attr_iget(vi, AT_BITMAP, I30, 4);\n\t\tif (IS_ERR(bvi)) {\n\t\t\tntfs_error(vi->i_sb, \"Failed to get bitmap attribute.\");\n\t\t\terr = PTR_ERR(bvi);\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tbni = NTFS_I(bvi);\n\t\tif (NInoCompressed(bni) || NInoEncrypted(bni) ||\n\t\t\t\tNInoSparse(bni)) {\n\t\t\tntfs_error(vi->i_sb, \"$BITMAP attribute is compressed \"\n\t\t\t\t\t\"and/or encrypted and/or sparse.\");\n\t\t\tgoto iput_unm_err_out;\n\t\t}\n\t\t/* Consistency check bitmap size vs. index allocation size. */\n\t\tbvi_size = i_size_read(bvi);\n\t\tif ((bvi_size << 3) < (vi->i_size >>\n\t\t\t\tni->itype.index.block_size_bits)) {\n\t\t\tntfs_error(vi->i_sb, \"Index bitmap too small (0x%llx) \"\n\t\t\t\t\t\"for index allocation (0x%llx).\",\n\t\t\t\t\tbvi_size << 3, vi->i_size);\n\t\t\tgoto iput_unm_err_out;\n\t\t}\n\t\t/* No longer need the bitmap attribute inode. */\n\t\tiput(bvi);\nskip_large_dir_stuff:\n\t\t/* Setup the operations for this inode. */\n\t\tvi->i_op = &ntfs_dir_inode_ops;\n\t\tvi->i_fop = &ntfs_dir_ops;\n\t\tvi->i_mapping->a_ops = &ntfs_mst_aops;\n\t} else {\n\t\t/* It is a file. */\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\n\t\t/* Setup the data attribute, even if not present. */\n\t\tni->type = AT_DATA;\n\t\tni->name = NULL;\n\t\tni->name_len = 0;\n\n\t\t/* Find first extent of the unnamed data attribute. */\n\t\terr = ntfs_attr_lookup(AT_DATA, NULL, 0, 0, 0, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tvi->i_size = ni->initialized_size =\n\t\t\t\t\tni->allocated_size = 0;\n\t\t\tif (err != -ENOENT) {\n\t\t\t\tntfs_error(vi->i_sb, \"Failed to lookup $DATA \"\n\t\t\t\t\t\t\"attribute.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/*\n\t\t\t * FILE_Secure does not have an unnamed $DATA\n\t\t\t * attribute, so we special case it here.\n\t\t\t */\n\t\t\tif (vi->i_ino == FILE_Secure)\n\t\t\t\tgoto no_data_attr_special_case;\n\t\t\t/*\n\t\t\t * Most if not all the system files in the $Extend\n\t\t\t * system directory do not have unnamed data\n\t\t\t * attributes so we need to check if the parent\n\t\t\t * directory of the file is FILE_Extend and if it is\n\t\t\t * ignore this error. To do this we need to get the\n\t\t\t * name of this inode from the mft record as the name\n\t\t\t * contains the back reference to the parent directory.\n\t\t\t */\n\t\t\tif (ntfs_is_extended_system_file(ctx) > 0)\n\t\t\t\tgoto no_data_attr_special_case;\n\t\t\t// FIXME: File is corrupt! Hot-fix with empty data\n\t\t\t// attribute if recovery option is set.\n\t\t\tntfs_error(vi->i_sb, \"$DATA attribute is missing.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\ta = ctx->attr;\n\t\t/* Setup the state. */\n\t\tif (a->flags & (ATTR_COMPRESSION_MASK | ATTR_IS_SPARSE)) {\n\t\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\t\tNInoSetCompressed(ni);\n\t\t\t\tif (vol->cluster_size > 4096) {\n\t\t\t\t\tntfs_error(vi->i_sb, \"Found \"\n\t\t\t\t\t\t\t\"compressed data but \"\n\t\t\t\t\t\t\t\"compression is \"\n\t\t\t\t\t\t\t\"disabled due to \"\n\t\t\t\t\t\t\t\"cluster size (%i) > \"\n\t\t\t\t\t\t\t\"4kiB.\",\n\t\t\t\t\t\t\tvol->cluster_size);\n\t\t\t\t\tgoto unm_err_out;\n\t\t\t\t}\n\t\t\t\tif ((a->flags & ATTR_COMPRESSION_MASK)\n\t\t\t\t\t\t!= ATTR_IS_COMPRESSED) {\n\t\t\t\t\tntfs_error(vi->i_sb, \"Found unknown \"\n\t\t\t\t\t\t\t\"compression method \"\n\t\t\t\t\t\t\t\"or corrupt file.\");\n\t\t\t\t\tgoto unm_err_out;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (a->flags & ATTR_IS_SPARSE)\n\t\t\t\tNInoSetSparse(ni);\n\t\t}\n\t\tif (a->flags & ATTR_IS_ENCRYPTED) {\n\t\t\tif (NInoCompressed(ni)) {\n\t\t\t\tntfs_error(vi->i_sb, \"Found encrypted and \"\n\t\t\t\t\t\t\"compressed data.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tNInoSetEncrypted(ni);\n\t\t}\n\t\tif (a->non_resident) {\n\t\t\tNInoSetNonResident(ni);\n\t\t\tif (NInoCompressed(ni) || NInoSparse(ni)) {\n\t\t\t\tif (NInoCompressed(ni) && a->data.non_resident.\n\t\t\t\t\t\tcompression_unit != 4) {\n\t\t\t\t\tntfs_error(vi->i_sb, \"Found \"\n\t\t\t\t\t\t\t\"non-standard \"\n\t\t\t\t\t\t\t\"compression unit (%u \"\n\t\t\t\t\t\t\t\"instead of 4).  \"\n\t\t\t\t\t\t\t\"Cannot handle this.\",\n\t\t\t\t\t\t\ta->data.non_resident.\n\t\t\t\t\t\t\tcompression_unit);\n\t\t\t\t\terr = -EOPNOTSUPP;\n\t\t\t\t\tgoto unm_err_out;\n\t\t\t\t}\n\t\t\t\tif (a->data.non_resident.compression_unit) {\n\t\t\t\t\tni->itype.compressed.block_size = 1U <<\n\t\t\t\t\t\t\t(a->data.non_resident.\n\t\t\t\t\t\t\tcompression_unit +\n\t\t\t\t\t\t\tvol->cluster_size_bits);\n\t\t\t\t\tni->itype.compressed.block_size_bits =\n\t\t\t\t\t\t\tffs(ni->itype.\n\t\t\t\t\t\t\tcompressed.\n\t\t\t\t\t\t\tblock_size) - 1;\n\t\t\t\t\tni->itype.compressed.block_clusters =\n\t\t\t\t\t\t\t1U << a->data.\n\t\t\t\t\t\t\tnon_resident.\n\t\t\t\t\t\t\tcompression_unit;\n\t\t\t\t} else {\n\t\t\t\t\tni->itype.compressed.block_size = 0;\n\t\t\t\t\tni->itype.compressed.block_size_bits =\n\t\t\t\t\t\t\t0;\n\t\t\t\t\tni->itype.compressed.block_clusters =\n\t\t\t\t\t\t\t0;\n\t\t\t\t}\n\t\t\t\tni->itype.compressed.size = sle64_to_cpu(\n\t\t\t\t\t\ta->data.non_resident.\n\t\t\t\t\t\tcompressed_size);\n\t\t\t}\n\t\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\t\tntfs_error(vi->i_sb, \"First extent of $DATA \"\n\t\t\t\t\t\t\"attribute has non zero \"\n\t\t\t\t\t\t\"lowest_vcn.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tvi->i_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.data_size);\n\t\t\tni->initialized_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.initialized_size);\n\t\t\tni->allocated_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.allocated_size);\n\t\t} else { /* Resident attribute. */\n\t\t\tvi->i_size = ni->initialized_size = le32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length);\n\t\t\tni->allocated_size = le32_to_cpu(a->length) -\n\t\t\t\t\tle16_to_cpu(\n\t\t\t\t\ta->data.resident.value_offset);\n\t\t\tif (vi->i_size > ni->allocated_size) {\n\t\t\t\tntfs_error(vi->i_sb, \"Resident data attribute \"\n\t\t\t\t\t\t\"is corrupt (size exceeds \"\n\t\t\t\t\t\t\"allocation).\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t}\nno_data_attr_special_case:\n\t\t/* We are done with the mft record, so we release it. */\n\t\tntfs_attr_put_search_ctx(ctx);\n\t\tunmap_mft_record(ni);\n\t\tm = NULL;\n\t\tctx = NULL;\n\t\t/* Setup the operations for this inode. */\n\t\tvi->i_op = &ntfs_file_inode_ops;\n\t\tvi->i_fop = &ntfs_file_ops;\n\t\tvi->i_mapping->a_ops = &ntfs_normal_aops;\n\t\tif (NInoMstProtected(ni))\n\t\t\tvi->i_mapping->a_ops = &ntfs_mst_aops;\n\t\telse if (NInoCompressed(ni))\n\t\t\tvi->i_mapping->a_ops = &ntfs_compressed_aops;\n\t}\n\t/*\n\t * The number of 512-byte blocks used on disk (for stat). This is in so\n\t * far inaccurate as it doesn't account for any named streams or other\n\t * special non-resident attributes, but that is how Windows works, too,\n\t * so we are at least consistent with Windows, if not entirely\n\t * consistent with the Linux Way. Doing it the Linux Way would cause a\n\t * significant slowdown as it would involve iterating over all\n\t * attributes in the mft record and adding the allocated/compressed\n\t * sizes of all non-resident attributes present to give us the Linux\n\t * correct size that should go into i_blocks (after division by 512).\n\t */\n\tif (S_ISREG(vi->i_mode) && (NInoCompressed(ni) || NInoSparse(ni)))\n\t\tvi->i_blocks = ni->itype.compressed.size >> 9;\n\telse\n\t\tvi->i_blocks = ni->allocated_size >> 9;\n\tntfs_debug(\"Done.\");\n\treturn 0;\niput_unm_err_out:\n\tiput(bvi);\nunm_err_out:\n\tif (!err)\n\t\terr = -EIO;\n\tif (ctx)\n\t\tntfs_attr_put_search_ctx(ctx);\n\tif (m)\n\t\tunmap_mft_record(ni);\nerr_out:\n\tntfs_error(vol->sb, \"Failed with error code %i.  Marking corrupt \"\n\t\t\t\"inode 0x%lx as bad.  Run chkdsk.\", err, vi->i_ino);\n\tmake_bad_inode(vi);\n\tif (err != -EOPNOTSUPP && err != -ENOMEM)\n\t\tNVolSetErrors(vol);\n\treturn err;\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"time.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"inode.h\"",
            "#include \"debug.h\"",
            "#include \"dir.h\"",
            "#include \"bitmap.h\"",
            "#include \"attrib.h\"",
            "#include \"aops.h\"",
            "#include <linux/aio.h>",
            "#include <linux/log2.h>",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mount.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ntfs_read_locked_inode(struct inode *vi);",
            "static int ntfs_read_locked_attr_inode(struct inode *base_vi, struct inode *vi);",
            "static int ntfs_read_locked_index_inode(struct inode *base_vi,\n\t\tstruct inode *vi);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"time.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"inode.h\"\n#include \"debug.h\"\n#include \"dir.h\"\n#include \"bitmap.h\"\n#include \"attrib.h\"\n#include \"aops.h\"\n#include <linux/aio.h>\n#include <linux/log2.h>\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n\nstatic int ntfs_read_locked_inode(struct inode *vi);\nstatic int ntfs_read_locked_attr_inode(struct inode *base_vi, struct inode *vi);\nstatic int ntfs_read_locked_index_inode(struct inode *base_vi,\n\t\tstruct inode *vi);\n\nstatic int ntfs_read_locked_inode(struct inode *vi)\n{\n\tntfs_volume *vol = NTFS_SB(vi->i_sb);\n\tntfs_inode *ni;\n\tstruct inode *bvi;\n\tMFT_RECORD *m;\n\tATTR_RECORD *a;\n\tSTANDARD_INFORMATION *si;\n\tntfs_attr_search_ctx *ctx;\n\tint err = 0;\n\n\tntfs_debug(\"Entering for i_ino 0x%lx.\", vi->i_ino);\n\n\t/* Setup the generic vfs inode parts now. */\n\n\t/*\n\t * This is for checking whether an inode has changed w.r.t. a file so\n\t * that the file can be updated if necessary (compare with f_version).\n\t */\n\tvi->i_version = 1;\n\n\tvi->i_uid = vol->uid;\n\tvi->i_gid = vol->gid;\n\tvi->i_mode = 0;\n\n\t/*\n\t * Initialize the ntfs specific part of @vi special casing\n\t * FILE_MFT which we need to do at mount time.\n\t */\n\tif (vi->i_ino != FILE_MFT)\n\t\tntfs_init_big_inode(vi);\n\tni = NTFS_I(vi);\n\n\tm = map_mft_record(ni);\n\tif (IS_ERR(m)) {\n\t\terr = PTR_ERR(m);\n\t\tgoto err_out;\n\t}\n\tctx = ntfs_attr_get_search_ctx(ni, m);\n\tif (!ctx) {\n\t\terr = -ENOMEM;\n\t\tgoto unm_err_out;\n\t}\n\n\tif (!(m->flags & MFT_RECORD_IN_USE)) {\n\t\tntfs_error(vi->i_sb, \"Inode is not in use!\");\n\t\tgoto unm_err_out;\n\t}\n\tif (m->base_mft_record) {\n\t\tntfs_error(vi->i_sb, \"Inode is an extent inode!\");\n\t\tgoto unm_err_out;\n\t}\n\n\t/* Transfer information from mft record into vfs and ntfs inodes. */\n\tvi->i_generation = ni->seq_no = le16_to_cpu(m->sequence_number);\n\n\t/*\n\t * FIXME: Keep in mind that link_count is two for files which have both\n\t * a long file name and a short file name as separate entries, so if\n\t * we are hiding short file names this will be too high. Either we need\n\t * to account for the short file names by subtracting them or we need\n\t * to make sure we delete files even though i_nlink is not zero which\n\t * might be tricky due to vfs interactions. Need to think about this\n\t * some more when implementing the unlink command.\n\t */\n\tset_nlink(vi, le16_to_cpu(m->link_count));\n\t/*\n\t * FIXME: Reparse points can have the directory bit set even though\n\t * they would be S_IFLNK. Need to deal with this further below when we\n\t * implement reparse points / symbolic links but it will do for now.\n\t * Also if not a directory, it could be something else, rather than\n\t * a regular file. But again, will do for now.\n\t */\n\t/* Everyone gets all permissions. */\n\tvi->i_mode |= S_IRWXUGO;\n\t/* If read-only, no one gets write permissions. */\n\tif (IS_RDONLY(vi))\n\t\tvi->i_mode &= ~S_IWUGO;\n\tif (m->flags & MFT_RECORD_IS_DIRECTORY) {\n\t\tvi->i_mode |= S_IFDIR;\n\t\t/*\n\t\t * Apply the directory permissions mask set in the mount\n\t\t * options.\n\t\t */\n\t\tvi->i_mode &= ~vol->dmask;\n\t\t/* Things break without this kludge! */\n\t\tif (vi->i_nlink > 1)\n\t\t\tset_nlink(vi, 1);\n\t} else {\n\t\tvi->i_mode |= S_IFREG;\n\t\t/* Apply the file permissions mask set in the mount options. */\n\t\tvi->i_mode &= ~vol->fmask;\n\t}\n\t/*\n\t * Find the standard information attribute in the mft record. At this\n\t * stage we haven't setup the attribute list stuff yet, so this could\n\t * in fact fail if the standard information is in an extent record, but\n\t * I don't think this actually ever happens.\n\t */\n\terr = ntfs_attr_lookup(AT_STANDARD_INFORMATION, NULL, 0, 0, 0, NULL, 0,\n\t\t\tctx);\n\tif (unlikely(err)) {\n\t\tif (err == -ENOENT) {\n\t\t\t/*\n\t\t\t * TODO: We should be performing a hot fix here (if the\n\t\t\t * recover mount option is set) by creating a new\n\t\t\t * attribute.\n\t\t\t */\n\t\t\tntfs_error(vi->i_sb, \"$STANDARD_INFORMATION attribute \"\n\t\t\t\t\t\"is missing.\");\n\t\t}\n\t\tgoto unm_err_out;\n\t}\n\ta = ctx->attr;\n\t/* Get the standard information attribute value. */\n\tsi = (STANDARD_INFORMATION*)((u8*)a +\n\t\t\tle16_to_cpu(a->data.resident.value_offset));\n\n\t/* Transfer information from the standard information into vi. */\n\t/*\n\t * Note: The i_?times do not quite map perfectly onto the NTFS times,\n\t * but they are close enough, and in the end it doesn't really matter\n\t * that much...\n\t */\n\t/*\n\t * mtime is the last change of the data within the file. Not changed\n\t * when only metadata is changed, e.g. a rename doesn't affect mtime.\n\t */\n\tvi->i_mtime = ntfs2utc(si->last_data_change_time);\n\t/*\n\t * ctime is the last change of the metadata of the file. This obviously\n\t * always changes, when mtime is changed. ctime can be changed on its\n\t * own, mtime is then not changed, e.g. when a file is renamed.\n\t */\n\tvi->i_ctime = ntfs2utc(si->last_mft_change_time);\n\t/*\n\t * Last access to the data within the file. Not changed during a rename\n\t * for example but changed whenever the file is written to.\n\t */\n\tvi->i_atime = ntfs2utc(si->last_access_time);\n\n\t/* Find the attribute list attribute if present. */\n\tntfs_attr_reinit_search_ctx(ctx);\n\terr = ntfs_attr_lookup(AT_ATTRIBUTE_LIST, NULL, 0, 0, 0, NULL, 0, ctx);\n\tif (err) {\n\t\tif (unlikely(err != -ENOENT)) {\n\t\t\tntfs_error(vi->i_sb, \"Failed to lookup attribute list \"\n\t\t\t\t\t\"attribute.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t} else /* if (!err) */ {\n\t\tif (vi->i_ino == FILE_MFT)\n\t\t\tgoto skip_attr_list_load;\n\t\tntfs_debug(\"Attribute list found in inode 0x%lx.\", vi->i_ino);\n\t\tNInoSetAttrList(ni);\n\t\ta = ctx->attr;\n\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\tntfs_error(vi->i_sb, \"Attribute list attribute is \"\n\t\t\t\t\t\"compressed.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_IS_ENCRYPTED ||\n\t\t\t\ta->flags & ATTR_IS_SPARSE) {\n\t\t\tif (a->non_resident) {\n\t\t\t\tntfs_error(vi->i_sb, \"Non-resident attribute \"\n\t\t\t\t\t\t\"list attribute is encrypted/\"\n\t\t\t\t\t\t\"sparse.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tntfs_warning(vi->i_sb, \"Resident attribute list \"\n\t\t\t\t\t\"attribute in inode 0x%lx is marked \"\n\t\t\t\t\t\"encrypted/sparse which is not true.  \"\n\t\t\t\t\t\"However, Windows allows this and \"\n\t\t\t\t\t\"chkdsk does not detect or correct it \"\n\t\t\t\t\t\"so we will just ignore the invalid \"\n\t\t\t\t\t\"flags and pretend they are not set.\",\n\t\t\t\t\tvi->i_ino);\n\t\t}\n\t\t/* Now allocate memory for the attribute list. */\n\t\tni->attr_list_size = (u32)ntfs_attr_size(a);\n\t\tni->attr_list = ntfs_malloc_nofs(ni->attr_list_size);\n\t\tif (!ni->attr_list) {\n\t\t\tntfs_error(vi->i_sb, \"Not enough memory to allocate \"\n\t\t\t\t\t\"buffer for attribute list.\");\n\t\t\terr = -ENOMEM;\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->non_resident) {\n\t\t\tNInoSetAttrListNonResident(ni);\n\t\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\t\tntfs_error(vi->i_sb, \"Attribute list has non \"\n\t\t\t\t\t\t\"zero lowest_vcn.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Setup the runlist. No need for locking as we have\n\t\t\t * exclusive access to the inode at this time.\n\t\t\t */\n\t\t\tni->attr_list_rl.rl = ntfs_mapping_pairs_decompress(vol,\n\t\t\t\t\ta, NULL);\n\t\t\tif (IS_ERR(ni->attr_list_rl.rl)) {\n\t\t\t\terr = PTR_ERR(ni->attr_list_rl.rl);\n\t\t\t\tni->attr_list_rl.rl = NULL;\n\t\t\t\tntfs_error(vi->i_sb, \"Mapping pairs \"\n\t\t\t\t\t\t\"decompression failed.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/* Now load the attribute list. */\n\t\t\tif ((err = load_attribute_list(vol, &ni->attr_list_rl,\n\t\t\t\t\tni->attr_list, ni->attr_list_size,\n\t\t\t\t\tsle64_to_cpu(a->data.non_resident.\n\t\t\t\t\tinitialized_size)))) {\n\t\t\t\tntfs_error(vi->i_sb, \"Failed to load \"\n\t\t\t\t\t\t\"attribute list attribute.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t} else /* if (!a->non_resident) */ {\n\t\t\tif ((u8*)a + le16_to_cpu(a->data.resident.value_offset)\n\t\t\t\t\t+ le32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length) >\n\t\t\t\t\t(u8*)ctx->mrec + vol->mft_record_size) {\n\t\t\t\tntfs_error(vi->i_sb, \"Corrupt attribute list \"\n\t\t\t\t\t\t\"in inode.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/* Now copy the attribute list. */\n\t\t\tmemcpy(ni->attr_list, (u8*)a + le16_to_cpu(\n\t\t\t\t\ta->data.resident.value_offset),\n\t\t\t\t\tle32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length));\n\t\t}\n\t}\nskip_attr_list_load:\n\t/*\n\t * If an attribute list is present we now have the attribute list value\n\t * in ntfs_ino->attr_list and it is ntfs_ino->attr_list_size bytes.\n\t */\n\tif (S_ISDIR(vi->i_mode)) {\n\t\tloff_t bvi_size;\n\t\tntfs_inode *bni;\n\t\tINDEX_ROOT *ir;\n\t\tu8 *ir_end, *index_end;\n\n\t\t/* It is a directory, find index root attribute. */\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\t\terr = ntfs_attr_lookup(AT_INDEX_ROOT, I30, 4, CASE_SENSITIVE,\n\t\t\t\t0, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tif (err == -ENOENT) {\n\t\t\t\t// FIXME: File is corrupt! Hot-fix with empty\n\t\t\t\t// index root attribute if recovery option is\n\t\t\t\t// set.\n\t\t\t\tntfs_error(vi->i_sb, \"$INDEX_ROOT attribute \"\n\t\t\t\t\t\t\"is missing.\");\n\t\t\t}\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\ta = ctx->attr;\n\t\t/* Set up the state. */\n\t\tif (unlikely(a->non_resident)) {\n\t\t\tntfs_error(vol->sb, \"$INDEX_ROOT attribute is not \"\n\t\t\t\t\t\"resident.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/* Ensure the attribute name is placed before the value. */\n\t\tif (unlikely(a->name_length && (le16_to_cpu(a->name_offset) >=\n\t\t\t\tle16_to_cpu(a->data.resident.value_offset)))) {\n\t\t\tntfs_error(vol->sb, \"$INDEX_ROOT attribute name is \"\n\t\t\t\t\t\"placed after the attribute value.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/*\n\t\t * Compressed/encrypted index root just means that the newly\n\t\t * created files in that directory should be created compressed/\n\t\t * encrypted. However index root cannot be both compressed and\n\t\t * encrypted.\n\t\t */\n\t\tif (a->flags & ATTR_COMPRESSION_MASK)\n\t\t\tNInoSetCompressed(ni);\n\t\tif (a->flags & ATTR_IS_ENCRYPTED) {\n\t\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\t\tntfs_error(vi->i_sb, \"Found encrypted and \"\n\t\t\t\t\t\t\"compressed attribute.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tNInoSetEncrypted(ni);\n\t\t}\n\t\tif (a->flags & ATTR_IS_SPARSE)\n\t\t\tNInoSetSparse(ni);\n\t\tir = (INDEX_ROOT*)((u8*)a +\n\t\t\t\tle16_to_cpu(a->data.resident.value_offset));\n\t\tir_end = (u8*)ir + le32_to_cpu(a->data.resident.value_length);\n\t\tif (ir_end > (u8*)ctx->mrec + vol->mft_record_size) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ROOT attribute is \"\n\t\t\t\t\t\"corrupt.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tindex_end = (u8*)&ir->index +\n\t\t\t\tle32_to_cpu(ir->index.index_length);\n\t\tif (index_end > ir_end) {\n\t\t\tntfs_error(vi->i_sb, \"Directory index is corrupt.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ir->type != AT_FILE_NAME) {\n\t\t\tntfs_error(vi->i_sb, \"Indexed attribute is not \"\n\t\t\t\t\t\"$FILE_NAME.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ir->collation_rule != COLLATION_FILE_NAME) {\n\t\t\tntfs_error(vi->i_sb, \"Index collation rule is not \"\n\t\t\t\t\t\"COLLATION_FILE_NAME.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tni->itype.index.collation_rule = ir->collation_rule;\n\t\tni->itype.index.block_size = le32_to_cpu(ir->index_block_size);\n\t\tif (ni->itype.index.block_size &\n\t\t\t\t(ni->itype.index.block_size - 1)) {\n\t\t\tntfs_error(vi->i_sb, \"Index block size (%u) is not a \"\n\t\t\t\t\t\"power of two.\",\n\t\t\t\t\tni->itype.index.block_size);\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ni->itype.index.block_size > PAGE_CACHE_SIZE) {\n\t\t\tntfs_error(vi->i_sb, \"Index block size (%u) > \"\n\t\t\t\t\t\"PAGE_CACHE_SIZE (%ld) is not \"\n\t\t\t\t\t\"supported.  Sorry.\",\n\t\t\t\t\tni->itype.index.block_size,\n\t\t\t\t\tPAGE_CACHE_SIZE);\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ni->itype.index.block_size < NTFS_BLOCK_SIZE) {\n\t\t\tntfs_error(vi->i_sb, \"Index block size (%u) < \"\n\t\t\t\t\t\"NTFS_BLOCK_SIZE (%i) is not \"\n\t\t\t\t\t\"supported.  Sorry.\",\n\t\t\t\t\tni->itype.index.block_size,\n\t\t\t\t\tNTFS_BLOCK_SIZE);\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tni->itype.index.block_size_bits =\n\t\t\t\tffs(ni->itype.index.block_size) - 1;\n\t\t/* Determine the size of a vcn in the directory index. */\n\t\tif (vol->cluster_size <= ni->itype.index.block_size) {\n\t\t\tni->itype.index.vcn_size = vol->cluster_size;\n\t\t\tni->itype.index.vcn_size_bits = vol->cluster_size_bits;\n\t\t} else {\n\t\t\tni->itype.index.vcn_size = vol->sector_size;\n\t\t\tni->itype.index.vcn_size_bits = vol->sector_size_bits;\n\t\t}\n\n\t\t/* Setup the index allocation attribute, even if not present. */\n\t\tNInoSetMstProtected(ni);\n\t\tni->type = AT_INDEX_ALLOCATION;\n\t\tni->name = I30;\n\t\tni->name_len = 4;\n\n\t\tif (!(ir->index.flags & LARGE_INDEX)) {\n\t\t\t/* No index allocation. */\n\t\t\tvi->i_size = ni->initialized_size =\n\t\t\t\t\tni->allocated_size = 0;\n\t\t\t/* We are done with the mft record, so we release it. */\n\t\t\tntfs_attr_put_search_ctx(ctx);\n\t\t\tunmap_mft_record(ni);\n\t\t\tm = NULL;\n\t\t\tctx = NULL;\n\t\t\tgoto skip_large_dir_stuff;\n\t\t} /* LARGE_INDEX: Index allocation present. Setup state. */\n\t\tNInoSetIndexAllocPresent(ni);\n\t\t/* Find index allocation attribute. */\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\t\terr = ntfs_attr_lookup(AT_INDEX_ALLOCATION, I30, 4,\n\t\t\t\tCASE_SENSITIVE, 0, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tif (err == -ENOENT)\n\t\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION \"\n\t\t\t\t\t\t\"attribute is not present but \"\n\t\t\t\t\t\t\"$INDEX_ROOT indicated it is.\");\n\t\t\telse\n\t\t\t\tntfs_error(vi->i_sb, \"Failed to lookup \"\n\t\t\t\t\t\t\"$INDEX_ALLOCATION \"\n\t\t\t\t\t\t\"attribute.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\ta = ctx->attr;\n\t\tif (!a->non_resident) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is resident.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/*\n\t\t * Ensure the attribute name is placed before the mapping pairs\n\t\t * array.\n\t\t */\n\t\tif (unlikely(a->name_length && (le16_to_cpu(a->name_offset) >=\n\t\t\t\tle16_to_cpu(\n\t\t\t\ta->data.non_resident.mapping_pairs_offset)))) {\n\t\t\tntfs_error(vol->sb, \"$INDEX_ALLOCATION attribute name \"\n\t\t\t\t\t\"is placed after the mapping pairs \"\n\t\t\t\t\t\"array.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_IS_ENCRYPTED) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is encrypted.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_IS_SPARSE) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is sparse.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is compressed.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\tntfs_error(vi->i_sb, \"First extent of \"\n\t\t\t\t\t\"$INDEX_ALLOCATION attribute has non \"\n\t\t\t\t\t\"zero lowest_vcn.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tvi->i_size = sle64_to_cpu(a->data.non_resident.data_size);\n\t\tni->initialized_size = sle64_to_cpu(\n\t\t\t\ta->data.non_resident.initialized_size);\n\t\tni->allocated_size = sle64_to_cpu(\n\t\t\t\ta->data.non_resident.allocated_size);\n\t\t/*\n\t\t * We are done with the mft record, so we release it. Otherwise\n\t\t * we would deadlock in ntfs_attr_iget().\n\t\t */\n\t\tntfs_attr_put_search_ctx(ctx);\n\t\tunmap_mft_record(ni);\n\t\tm = NULL;\n\t\tctx = NULL;\n\t\t/* Get the index bitmap attribute inode. */\n\t\tbvi = ntfs_attr_iget(vi, AT_BITMAP, I30, 4);\n\t\tif (IS_ERR(bvi)) {\n\t\t\tntfs_error(vi->i_sb, \"Failed to get bitmap attribute.\");\n\t\t\terr = PTR_ERR(bvi);\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tbni = NTFS_I(bvi);\n\t\tif (NInoCompressed(bni) || NInoEncrypted(bni) ||\n\t\t\t\tNInoSparse(bni)) {\n\t\t\tntfs_error(vi->i_sb, \"$BITMAP attribute is compressed \"\n\t\t\t\t\t\"and/or encrypted and/or sparse.\");\n\t\t\tgoto iput_unm_err_out;\n\t\t}\n\t\t/* Consistency check bitmap size vs. index allocation size. */\n\t\tbvi_size = i_size_read(bvi);\n\t\tif ((bvi_size << 3) < (vi->i_size >>\n\t\t\t\tni->itype.index.block_size_bits)) {\n\t\t\tntfs_error(vi->i_sb, \"Index bitmap too small (0x%llx) \"\n\t\t\t\t\t\"for index allocation (0x%llx).\",\n\t\t\t\t\tbvi_size << 3, vi->i_size);\n\t\t\tgoto iput_unm_err_out;\n\t\t}\n\t\t/* No longer need the bitmap attribute inode. */\n\t\tiput(bvi);\nskip_large_dir_stuff:\n\t\t/* Setup the operations for this inode. */\n\t\tvi->i_op = &ntfs_dir_inode_ops;\n\t\tvi->i_fop = &ntfs_dir_ops;\n\t\tvi->i_mapping->a_ops = &ntfs_mst_aops;\n\t} else {\n\t\t/* It is a file. */\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\n\t\t/* Setup the data attribute, even if not present. */\n\t\tni->type = AT_DATA;\n\t\tni->name = NULL;\n\t\tni->name_len = 0;\n\n\t\t/* Find first extent of the unnamed data attribute. */\n\t\terr = ntfs_attr_lookup(AT_DATA, NULL, 0, 0, 0, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tvi->i_size = ni->initialized_size =\n\t\t\t\t\tni->allocated_size = 0;\n\t\t\tif (err != -ENOENT) {\n\t\t\t\tntfs_error(vi->i_sb, \"Failed to lookup $DATA \"\n\t\t\t\t\t\t\"attribute.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/*\n\t\t\t * FILE_Secure does not have an unnamed $DATA\n\t\t\t * attribute, so we special case it here.\n\t\t\t */\n\t\t\tif (vi->i_ino == FILE_Secure)\n\t\t\t\tgoto no_data_attr_special_case;\n\t\t\t/*\n\t\t\t * Most if not all the system files in the $Extend\n\t\t\t * system directory do not have unnamed data\n\t\t\t * attributes so we need to check if the parent\n\t\t\t * directory of the file is FILE_Extend and if it is\n\t\t\t * ignore this error. To do this we need to get the\n\t\t\t * name of this inode from the mft record as the name\n\t\t\t * contains the back reference to the parent directory.\n\t\t\t */\n\t\t\tif (ntfs_is_extended_system_file(ctx) > 0)\n\t\t\t\tgoto no_data_attr_special_case;\n\t\t\t// FIXME: File is corrupt! Hot-fix with empty data\n\t\t\t// attribute if recovery option is set.\n\t\t\tntfs_error(vi->i_sb, \"$DATA attribute is missing.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\ta = ctx->attr;\n\t\t/* Setup the state. */\n\t\tif (a->flags & (ATTR_COMPRESSION_MASK | ATTR_IS_SPARSE)) {\n\t\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\t\tNInoSetCompressed(ni);\n\t\t\t\tif (vol->cluster_size > 4096) {\n\t\t\t\t\tntfs_error(vi->i_sb, \"Found \"\n\t\t\t\t\t\t\t\"compressed data but \"\n\t\t\t\t\t\t\t\"compression is \"\n\t\t\t\t\t\t\t\"disabled due to \"\n\t\t\t\t\t\t\t\"cluster size (%i) > \"\n\t\t\t\t\t\t\t\"4kiB.\",\n\t\t\t\t\t\t\tvol->cluster_size);\n\t\t\t\t\tgoto unm_err_out;\n\t\t\t\t}\n\t\t\t\tif ((a->flags & ATTR_COMPRESSION_MASK)\n\t\t\t\t\t\t!= ATTR_IS_COMPRESSED) {\n\t\t\t\t\tntfs_error(vi->i_sb, \"Found unknown \"\n\t\t\t\t\t\t\t\"compression method \"\n\t\t\t\t\t\t\t\"or corrupt file.\");\n\t\t\t\t\tgoto unm_err_out;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (a->flags & ATTR_IS_SPARSE)\n\t\t\t\tNInoSetSparse(ni);\n\t\t}\n\t\tif (a->flags & ATTR_IS_ENCRYPTED) {\n\t\t\tif (NInoCompressed(ni)) {\n\t\t\t\tntfs_error(vi->i_sb, \"Found encrypted and \"\n\t\t\t\t\t\t\"compressed data.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tNInoSetEncrypted(ni);\n\t\t}\n\t\tif (a->non_resident) {\n\t\t\tNInoSetNonResident(ni);\n\t\t\tif (NInoCompressed(ni) || NInoSparse(ni)) {\n\t\t\t\tif (NInoCompressed(ni) && a->data.non_resident.\n\t\t\t\t\t\tcompression_unit != 4) {\n\t\t\t\t\tntfs_error(vi->i_sb, \"Found \"\n\t\t\t\t\t\t\t\"non-standard \"\n\t\t\t\t\t\t\t\"compression unit (%u \"\n\t\t\t\t\t\t\t\"instead of 4).  \"\n\t\t\t\t\t\t\t\"Cannot handle this.\",\n\t\t\t\t\t\t\ta->data.non_resident.\n\t\t\t\t\t\t\tcompression_unit);\n\t\t\t\t\terr = -EOPNOTSUPP;\n\t\t\t\t\tgoto unm_err_out;\n\t\t\t\t}\n\t\t\t\tif (a->data.non_resident.compression_unit) {\n\t\t\t\t\tni->itype.compressed.block_size = 1U <<\n\t\t\t\t\t\t\t(a->data.non_resident.\n\t\t\t\t\t\t\tcompression_unit +\n\t\t\t\t\t\t\tvol->cluster_size_bits);\n\t\t\t\t\tni->itype.compressed.block_size_bits =\n\t\t\t\t\t\t\tffs(ni->itype.\n\t\t\t\t\t\t\tcompressed.\n\t\t\t\t\t\t\tblock_size) - 1;\n\t\t\t\t\tni->itype.compressed.block_clusters =\n\t\t\t\t\t\t\t1U << a->data.\n\t\t\t\t\t\t\tnon_resident.\n\t\t\t\t\t\t\tcompression_unit;\n\t\t\t\t} else {\n\t\t\t\t\tni->itype.compressed.block_size = 0;\n\t\t\t\t\tni->itype.compressed.block_size_bits =\n\t\t\t\t\t\t\t0;\n\t\t\t\t\tni->itype.compressed.block_clusters =\n\t\t\t\t\t\t\t0;\n\t\t\t\t}\n\t\t\t\tni->itype.compressed.size = sle64_to_cpu(\n\t\t\t\t\t\ta->data.non_resident.\n\t\t\t\t\t\tcompressed_size);\n\t\t\t}\n\t\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\t\tntfs_error(vi->i_sb, \"First extent of $DATA \"\n\t\t\t\t\t\t\"attribute has non zero \"\n\t\t\t\t\t\t\"lowest_vcn.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tvi->i_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.data_size);\n\t\t\tni->initialized_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.initialized_size);\n\t\t\tni->allocated_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.allocated_size);\n\t\t} else { /* Resident attribute. */\n\t\t\tvi->i_size = ni->initialized_size = le32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length);\n\t\t\tni->allocated_size = le32_to_cpu(a->length) -\n\t\t\t\t\tle16_to_cpu(\n\t\t\t\t\ta->data.resident.value_offset);\n\t\t\tif (vi->i_size > ni->allocated_size) {\n\t\t\t\tntfs_error(vi->i_sb, \"Resident data attribute \"\n\t\t\t\t\t\t\"is corrupt (size exceeds \"\n\t\t\t\t\t\t\"allocation).\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t}\nno_data_attr_special_case:\n\t\t/* We are done with the mft record, so we release it. */\n\t\tntfs_attr_put_search_ctx(ctx);\n\t\tunmap_mft_record(ni);\n\t\tm = NULL;\n\t\tctx = NULL;\n\t\t/* Setup the operations for this inode. */\n\t\tvi->i_op = &ntfs_file_inode_ops;\n\t\tvi->i_fop = &ntfs_file_ops;\n\t\tvi->i_mapping->a_ops = &ntfs_normal_aops;\n\t\tif (NInoMstProtected(ni))\n\t\t\tvi->i_mapping->a_ops = &ntfs_mst_aops;\n\t\telse if (NInoCompressed(ni))\n\t\t\tvi->i_mapping->a_ops = &ntfs_compressed_aops;\n\t}\n\t/*\n\t * The number of 512-byte blocks used on disk (for stat). This is in so\n\t * far inaccurate as it doesn't account for any named streams or other\n\t * special non-resident attributes, but that is how Windows works, too,\n\t * so we are at least consistent with Windows, if not entirely\n\t * consistent with the Linux Way. Doing it the Linux Way would cause a\n\t * significant slowdown as it would involve iterating over all\n\t * attributes in the mft record and adding the allocated/compressed\n\t * sizes of all non-resident attributes present to give us the Linux\n\t * correct size that should go into i_blocks (after division by 512).\n\t */\n\tif (S_ISREG(vi->i_mode) && (NInoCompressed(ni) || NInoSparse(ni)))\n\t\tvi->i_blocks = ni->itype.compressed.size >> 9;\n\telse\n\t\tvi->i_blocks = ni->allocated_size >> 9;\n\tntfs_debug(\"Done.\");\n\treturn 0;\niput_unm_err_out:\n\tiput(bvi);\nunm_err_out:\n\tif (!err)\n\t\terr = -EIO;\n\tif (ctx)\n\t\tntfs_attr_put_search_ctx(ctx);\n\tif (m)\n\t\tunmap_mft_record(ni);\nerr_out:\n\tntfs_error(vol->sb, \"Failed with error code %i.  Marking corrupt \"\n\t\t\t\"inode 0x%lx as bad.  Run chkdsk.\", err, vi->i_ino);\n\tmake_bad_inode(vi);\n\tif (err != -EOPNOTSUPP && err != -ENOMEM)\n\t\tNVolSetErrors(vol);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "iinfo->i_ext.i_data",
            "bh->b_data + sizeof(struct unallocSpaceEntry)",
            "bs - sizeof(struct unallocSpaceEntry)"
          ],
          "line": 1404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udf_alloc_i_data",
          "args": [
            "inode",
            "bs -\n\t\t\t\t\tsizeof(struct unallocSpaceEntry)"
          ],
          "line": 1400
        },
        "resolved": true,
        "details": {
          "function_name": "udf_alloc_i_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/inode.c",
          "lines": "1579-1591",
          "snippet": "static int udf_alloc_i_data(struct inode *inode, size_t size)\n{\n\tstruct udf_inode_info *iinfo = UDF_I(inode);\n\tiinfo->i_ext.i_data = kmalloc(size, GFP_KERNEL);\n\n\tif (!iinfo->i_ext.i_data) {\n\t\tudf_err(inode->i_sb, \"(ino %ld) no free memory\\n\",\n\t\t\tinode->i_ino);\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"udf_sb.h\"",
            "#include \"udf_i.h\"",
            "#include <linux/aio.h>",
            "#include <linux/mpage.h>",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int udf_update_inode(struct inode *, int);",
            "static int udf_sync_inode(struct inode *inode);",
            "static int udf_alloc_i_data(struct inode *inode, size_t size);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/crc-itu-t.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include \"udfdecl.h\"\n\nstatic int udf_update_inode(struct inode *, int);\nstatic int udf_sync_inode(struct inode *inode);\nstatic int udf_alloc_i_data(struct inode *inode, size_t size);\n\nstatic int udf_alloc_i_data(struct inode *inode, size_t size)\n{\n\tstruct udf_inode_info *iinfo = UDF_I(inode);\n\tiinfo->i_ext.i_data = kmalloc(size, GFP_KERNEL);\n\n\tif (!iinfo->i_ext.i_data) {\n\t\tudf_err(inode->i_sb, \"(ino %ld) no free memory\\n\",\n\t\t\tinode->i_ino);\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "TAG_IDENT_USE"
          ],
          "line": 1394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "iinfo->i_ext.i_data",
            "bh->b_data + sizeof(struct fileEntry)",
            "bs - sizeof(struct fileEntry)"
          ],
          "line": 1391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "TAG_IDENT_FE"
          ],
          "line": 1385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "iinfo->i_ext.i_data",
            "bh->b_data + sizeof(struct extendedFileEntry)",
            "bs - sizeof(struct extendedFileEntry)"
          ],
          "line": 1382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "TAG_IDENT_EFE"
          ],
          "line": 1375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "4"
          ],
          "line": 1362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "4"
          ],
          "line": 1357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&iinfo->i_location",
            "&loc",
            "sizeof(struct kernel_lb_addr)"
          ],
          "line": 1343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lelb_to_cpu",
          "args": [
            "ie->indirectICB.extLocation"
          ],
          "line": 1339
        },
        "resolved": true,
        "details": {
          "function_name": "lelb_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/udfend.h",
          "lines": "7-15",
          "snippet": "static inline struct kernel_lb_addr lelb_to_cpu(struct lb_addr in)\n{\n\tstruct kernel_lb_addr out;\n\n\tout.logicalBlockNum = le32_to_cpu(in.logicalBlockNum);\n\tout.partitionReferenceNum = le16_to_cpu(in.partitionReferenceNum);\n\n\treturn out;\n}",
          "includes": [
            "#include <linux/string.h>",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/string.h>\n#include <asm/byteorder.h>\n\nstatic inline struct kernel_lb_addr lelb_to_cpu(struct lb_addr in)\n{\n\tstruct kernel_lb_addr out;\n\n\tout.logicalBlockNum = le32_to_cpu(in.logicalBlockNum);\n\tout.partitionReferenceNum = le16_to_cpu(in.partitionReferenceNum);\n\n\treturn out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_read_ptagged",
          "args": [
            "inode->i_sb",
            "iloc",
            "1",
            "&ident"
          ],
          "line": 1333
        },
        "resolved": true,
        "details": {
          "function_name": "udf_read_ptagged",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/misc.c",
          "lines": "261-267",
          "snippet": "struct buffer_head *udf_read_ptagged(struct super_block *sb,\n\t\t\t\t     struct kernel_lb_addr *loc,\n\t\t\t\t     uint32_t offset, uint16_t *ident)\n{\n\treturn udf_read_tagged(sb, udf_get_lb_pblock(sb, loc, offset),\n\t\t\t       loc->logicalBlockNum + offset, ident);\n}",
          "includes": [
            "#include \"udf_sb.h\"",
            "#include \"udf_i.h\"",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/crc-itu-t.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include \"udfdecl.h\"\n\nstruct buffer_head *udf_read_ptagged(struct super_block *sb,\n\t\t\t\t     struct kernel_lb_addr *loc,\n\t\t\t\t     uint32_t offset, uint16_t *ident)\n{\n\treturn udf_read_tagged(sb, udf_get_lb_pblock(sb, loc, offset),\n\t\t\t       loc->logicalBlockNum + offset, ident);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "4096"
          ],
          "line": 1330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udf_debug",
          "args": [
            "\"block=%d, partition=%d out of range\\n\"",
            "iloc->logicalBlockNum",
            "iloc->partitionReferenceNum"
          ],
          "line": 1297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UDF_I",
          "args": [
            "inode"
          ],
          "line": 1286
        },
        "resolved": true,
        "details": {
          "function_name": "UDF_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/udf_i.h",
          "lines": "57-60",
          "snippet": "static inline struct udf_inode_info *UDF_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct udf_inode_info, vfs_inode);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline struct udf_inode_info *UDF_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct udf_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/crc-itu-t.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include \"udfdecl.h\"\n\n#define UDF_MAX_ICB_NESTING 1024\n\nstatic umode_t udf_convert_permissions(struct fileEntry *);\nstatic int udf_update_inode(struct inode *, int);\nstatic int udf_sync_inode(struct inode *inode);\nstatic int udf_get_block(struct inode *, sector_t, struct buffer_head *, int);\nconst struct address_space_operations udf_aops = {\n\t.readpage\t= udf_readpage,\n\t.readpages\t= udf_readpages,\n\t.writepage\t= udf_writepage,\n\t.writepages\t= udf_writepages,\n\t.write_begin\t= udf_write_begin,\n\t.write_end\t= generic_write_end,\n\t.direct_IO\t= udf_direct_IO,\n\t.bmap\t\t= udf_bmap,\n};\n\nstatic int udf_read_inode(struct inode *inode, bool hidden_inode)\n{\n\tstruct buffer_head *bh = NULL;\n\tstruct fileEntry *fe;\n\tstruct extendedFileEntry *efe;\n\tuint16_t ident;\n\tstruct udf_inode_info *iinfo = UDF_I(inode);\n\tstruct udf_sb_info *sbi = UDF_SB(inode->i_sb);\n\tstruct kernel_lb_addr *iloc = &iinfo->i_location;\n\tunsigned int link_count;\n\tunsigned int indirections = 0;\n\tint bs = inode->i_sb->s_blocksize;\n\tint ret = -EIO;\n\nreread:\n\tif (iloc->logicalBlockNum >=\n\t    sbi->s_partmaps[iloc->partitionReferenceNum].s_partition_len) {\n\t\tudf_debug(\"block=%d, partition=%d out of range\\n\",\n\t\t\t  iloc->logicalBlockNum, iloc->partitionReferenceNum);\n\t\treturn -EIO;\n\t}\n\n\t/*\n\t * Set defaults, but the inode is still incomplete!\n\t * Note: get_new_inode() sets the following on a new inode:\n\t *      i_sb = sb\n\t *      i_no = ino\n\t *      i_flags = sb->s_flags\n\t *      i_state = 0\n\t * clean_inode(): zero fills and sets\n\t *      i_count = 1\n\t *      i_nlink = 1\n\t *      i_op = NULL;\n\t */\n\tbh = udf_read_ptagged(inode->i_sb, iloc, 0, &ident);\n\tif (!bh) {\n\t\tudf_err(inode->i_sb, \"(ino %ld) failed !bh\\n\", inode->i_ino);\n\t\treturn -EIO;\n\t}\n\n\tif (ident != TAG_IDENT_FE && ident != TAG_IDENT_EFE &&\n\t    ident != TAG_IDENT_USE) {\n\t\tudf_err(inode->i_sb, \"(ino %ld) failed ident=%d\\n\",\n\t\t\tinode->i_ino, ident);\n\t\tgoto out;\n\t}\n\n\tfe = (struct fileEntry *)bh->b_data;\n\tefe = (struct extendedFileEntry *)bh->b_data;\n\n\tif (fe->icbTag.strategyType == cpu_to_le16(4096)) {\n\t\tstruct buffer_head *ibh;\n\n\t\tibh = udf_read_ptagged(inode->i_sb, iloc, 1, &ident);\n\t\tif (ident == TAG_IDENT_IE && ibh) {\n\t\t\tstruct kernel_lb_addr loc;\n\t\t\tstruct indirectEntry *ie;\n\n\t\t\tie = (struct indirectEntry *)ibh->b_data;\n\t\t\tloc = lelb_to_cpu(ie->indirectICB.extLocation);\n\n\t\t\tif (ie->indirectICB.extLength) {\n\t\t\t\tbrelse(ibh);\n\t\t\t\tmemcpy(&iinfo->i_location, &loc,\n\t\t\t\t       sizeof(struct kernel_lb_addr));\n\t\t\t\tif (++indirections > UDF_MAX_ICB_NESTING) {\n\t\t\t\t\tudf_err(inode->i_sb,\n\t\t\t\t\t\t\"too many ICBs in ICB hierarchy\"\n\t\t\t\t\t\t\" (max %d supported)\\n\",\n\t\t\t\t\t\tUDF_MAX_ICB_NESTING);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tbrelse(bh);\n\t\t\t\tgoto reread;\n\t\t\t}\n\t\t}\n\t\tbrelse(ibh);\n\t} else if (fe->icbTag.strategyType != cpu_to_le16(4)) {\n\t\tudf_err(inode->i_sb, \"unsupported strategy type: %d\\n\",\n\t\t\tle16_to_cpu(fe->icbTag.strategyType));\n\t\tgoto out;\n\t}\n\tif (fe->icbTag.strategyType == cpu_to_le16(4))\n\t\tiinfo->i_strat4096 = 0;\n\telse /* if (fe->icbTag.strategyType == cpu_to_le16(4096)) */\n\t\tiinfo->i_strat4096 = 1;\n\n\tiinfo->i_alloc_type = le16_to_cpu(fe->icbTag.flags) &\n\t\t\t\t\t\t\tICBTAG_FLAG_AD_MASK;\n\tiinfo->i_unique = 0;\n\tiinfo->i_lenEAttr = 0;\n\tiinfo->i_lenExtents = 0;\n\tiinfo->i_lenAlloc = 0;\n\tiinfo->i_next_alloc_block = 0;\n\tiinfo->i_next_alloc_goal = 0;\n\tif (fe->descTag.tagIdent == cpu_to_le16(TAG_IDENT_EFE)) {\n\t\tiinfo->i_efe = 1;\n\t\tiinfo->i_use = 0;\n\t\tret = udf_alloc_i_data(inode, bs -\n\t\t\t\t\tsizeof(struct extendedFileEntry));\n\t\tif (ret)\n\t\t\tgoto out;\n\t\tmemcpy(iinfo->i_ext.i_data,\n\t\t       bh->b_data + sizeof(struct extendedFileEntry),\n\t\t       bs - sizeof(struct extendedFileEntry));\n\t} else if (fe->descTag.tagIdent == cpu_to_le16(TAG_IDENT_FE)) {\n\t\tiinfo->i_efe = 0;\n\t\tiinfo->i_use = 0;\n\t\tret = udf_alloc_i_data(inode, bs - sizeof(struct fileEntry));\n\t\tif (ret)\n\t\t\tgoto out;\n\t\tmemcpy(iinfo->i_ext.i_data,\n\t\t       bh->b_data + sizeof(struct fileEntry),\n\t\t       bs - sizeof(struct fileEntry));\n\t} else if (fe->descTag.tagIdent == cpu_to_le16(TAG_IDENT_USE)) {\n\t\tiinfo->i_efe = 0;\n\t\tiinfo->i_use = 1;\n\t\tiinfo->i_lenAlloc = le32_to_cpu(\n\t\t\t\t((struct unallocSpaceEntry *)bh->b_data)->\n\t\t\t\t lengthAllocDescs);\n\t\tret = udf_alloc_i_data(inode, bs -\n\t\t\t\t\tsizeof(struct unallocSpaceEntry));\n\t\tif (ret)\n\t\t\tgoto out;\n\t\tmemcpy(iinfo->i_ext.i_data,\n\t\t       bh->b_data + sizeof(struct unallocSpaceEntry),\n\t\t       bs - sizeof(struct unallocSpaceEntry));\n\t\treturn 0;\n\t}\n\n\tret = -EIO;\n\tread_lock(&sbi->s_cred_lock);\n\ti_uid_write(inode, le32_to_cpu(fe->uid));\n\tif (!uid_valid(inode->i_uid) ||\n\t    UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_UID_IGNORE) ||\n\t    UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_UID_SET))\n\t\tinode->i_uid = UDF_SB(inode->i_sb)->s_uid;\n\n\ti_gid_write(inode, le32_to_cpu(fe->gid));\n\tif (!gid_valid(inode->i_gid) ||\n\t    UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_GID_IGNORE) ||\n\t    UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_GID_SET))\n\t\tinode->i_gid = UDF_SB(inode->i_sb)->s_gid;\n\n\tif (fe->icbTag.fileType != ICBTAG_FILE_TYPE_DIRECTORY &&\n\t\t\tsbi->s_fmode != UDF_INVALID_MODE)\n\t\tinode->i_mode = sbi->s_fmode;\n\telse if (fe->icbTag.fileType == ICBTAG_FILE_TYPE_DIRECTORY &&\n\t\t\tsbi->s_dmode != UDF_INVALID_MODE)\n\t\tinode->i_mode = sbi->s_dmode;\n\telse\n\t\tinode->i_mode = udf_convert_permissions(fe);\n\tinode->i_mode &= ~sbi->s_umask;\n\tread_unlock(&sbi->s_cred_lock);\n\n\tlink_count = le16_to_cpu(fe->fileLinkCount);\n\tif (!link_count) {\n\t\tif (!hidden_inode) {\n\t\t\tret = -ESTALE;\n\t\t\tgoto out;\n\t\t}\n\t\tlink_count = 1;\n\t}\n\tset_nlink(inode, link_count);\n\n\tinode->i_size = le64_to_cpu(fe->informationLength);\n\tiinfo->i_lenExtents = inode->i_size;\n\n\tif (iinfo->i_efe == 0) {\n\t\tinode->i_blocks = le64_to_cpu(fe->logicalBlocksRecorded) <<\n\t\t\t(inode->i_sb->s_blocksize_bits - 9);\n\n\t\tif (!udf_disk_stamp_to_time(&inode->i_atime, fe->accessTime))\n\t\t\tinode->i_atime = sbi->s_record_time;\n\n\t\tif (!udf_disk_stamp_to_time(&inode->i_mtime,\n\t\t\t\t\t    fe->modificationTime))\n\t\t\tinode->i_mtime = sbi->s_record_time;\n\n\t\tif (!udf_disk_stamp_to_time(&inode->i_ctime, fe->attrTime))\n\t\t\tinode->i_ctime = sbi->s_record_time;\n\n\t\tiinfo->i_unique = le64_to_cpu(fe->uniqueID);\n\t\tiinfo->i_lenEAttr = le32_to_cpu(fe->lengthExtendedAttr);\n\t\tiinfo->i_lenAlloc = le32_to_cpu(fe->lengthAllocDescs);\n\t\tiinfo->i_checkpoint = le32_to_cpu(fe->checkpoint);\n\t} else {\n\t\tinode->i_blocks = le64_to_cpu(efe->logicalBlocksRecorded) <<\n\t\t    (inode->i_sb->s_blocksize_bits - 9);\n\n\t\tif (!udf_disk_stamp_to_time(&inode->i_atime, efe->accessTime))\n\t\t\tinode->i_atime = sbi->s_record_time;\n\n\t\tif (!udf_disk_stamp_to_time(&inode->i_mtime,\n\t\t\t\t\t    efe->modificationTime))\n\t\t\tinode->i_mtime = sbi->s_record_time;\n\n\t\tif (!udf_disk_stamp_to_time(&iinfo->i_crtime, efe->createTime))\n\t\t\tiinfo->i_crtime = sbi->s_record_time;\n\n\t\tif (!udf_disk_stamp_to_time(&inode->i_ctime, efe->attrTime))\n\t\t\tinode->i_ctime = sbi->s_record_time;\n\n\t\tiinfo->i_unique = le64_to_cpu(efe->uniqueID);\n\t\tiinfo->i_lenEAttr = le32_to_cpu(efe->lengthExtendedAttr);\n\t\tiinfo->i_lenAlloc = le32_to_cpu(efe->lengthAllocDescs);\n\t\tiinfo->i_checkpoint = le32_to_cpu(efe->checkpoint);\n\t}\n\tinode->i_generation = iinfo->i_unique;\n\n\t/*\n\t * Sanity check length of allocation descriptors and extended attrs to\n\t * avoid integer overflows\n\t */\n\tif (iinfo->i_lenEAttr > bs || iinfo->i_lenAlloc > bs)\n\t\tgoto out;\n\t/* Now do exact checks */\n\tif (udf_file_entry_alloc_offset(inode) + iinfo->i_lenAlloc > bs)\n\t\tgoto out;\n\t/* Sanity checks for files in ICB so that we don't get confused later */\n\tif (iinfo->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB) {\n\t\t/*\n\t\t * For file in ICB data is stored in allocation descriptor\n\t\t * so sizes should match\n\t\t */\n\t\tif (iinfo->i_lenAlloc != inode->i_size)\n\t\t\tgoto out;\n\t\t/* File in ICB has to fit in there... */\n\t\tif (inode->i_size > bs - udf_file_entry_alloc_offset(inode))\n\t\t\tgoto out;\n\t}\n\n\tswitch (fe->icbTag.fileType) {\n\tcase ICBTAG_FILE_TYPE_DIRECTORY:\n\t\tinode->i_op = &udf_dir_inode_operations;\n\t\tinode->i_fop = &udf_dir_operations;\n\t\tinode->i_mode |= S_IFDIR;\n\t\tinc_nlink(inode);\n\t\tbreak;\n\tcase ICBTAG_FILE_TYPE_REALTIME:\n\tcase ICBTAG_FILE_TYPE_REGULAR:\n\tcase ICBTAG_FILE_TYPE_UNDEF:\n\tcase ICBTAG_FILE_TYPE_VAT20:\n\t\tif (iinfo->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB)\n\t\t\tinode->i_data.a_ops = &udf_adinicb_aops;\n\t\telse\n\t\t\tinode->i_data.a_ops = &udf_aops;\n\t\tinode->i_op = &udf_file_inode_operations;\n\t\tinode->i_fop = &udf_file_operations;\n\t\tinode->i_mode |= S_IFREG;\n\t\tbreak;\n\tcase ICBTAG_FILE_TYPE_BLOCK:\n\t\tinode->i_mode |= S_IFBLK;\n\t\tbreak;\n\tcase ICBTAG_FILE_TYPE_CHAR:\n\t\tinode->i_mode |= S_IFCHR;\n\t\tbreak;\n\tcase ICBTAG_FILE_TYPE_FIFO:\n\t\tinit_special_inode(inode, inode->i_mode | S_IFIFO, 0);\n\t\tbreak;\n\tcase ICBTAG_FILE_TYPE_SOCKET:\n\t\tinit_special_inode(inode, inode->i_mode | S_IFSOCK, 0);\n\t\tbreak;\n\tcase ICBTAG_FILE_TYPE_SYMLINK:\n\t\tinode->i_data.a_ops = &udf_symlink_aops;\n\t\tinode->i_op = &udf_symlink_inode_operations;\n\t\tinode->i_mode = S_IFLNK | S_IRWXUGO;\n\t\tbreak;\n\tcase ICBTAG_FILE_TYPE_MAIN:\n\t\tudf_debug(\"METADATA FILE-----\\n\");\n\t\tbreak;\n\tcase ICBTAG_FILE_TYPE_MIRROR:\n\t\tudf_debug(\"METADATA MIRROR FILE-----\\n\");\n\t\tbreak;\n\tcase ICBTAG_FILE_TYPE_BITMAP:\n\t\tudf_debug(\"METADATA BITMAP FILE-----\\n\");\n\t\tbreak;\n\tdefault:\n\t\tudf_err(inode->i_sb, \"(ino %ld) failed unknown file type=%d\\n\",\n\t\t\tinode->i_ino, fe->icbTag.fileType);\n\t\tgoto out;\n\t}\n\tif (S_ISCHR(inode->i_mode) || S_ISBLK(inode->i_mode)) {\n\t\tstruct deviceSpec *dsea =\n\t\t\t(struct deviceSpec *)udf_get_extendedattr(inode, 12, 1);\n\t\tif (dsea) {\n\t\t\tinit_special_inode(inode, inode->i_mode,\n\t\t\t\tMKDEV(le32_to_cpu(dsea->majorDeviceIdent),\n\t\t\t\t      le32_to_cpu(dsea->minorDeviceIdent)));\n\t\t\t/* Developer ID ??? */\n\t\t} else\n\t\t\tgoto out;\n\t}\n\tret = 0;\nout:\n\tbrelse(bh);\n\treturn ret;\n}"
  },
  {
    "function_name": "udf_setsize",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/inode.c",
    "lines": "1207-1271",
    "snippet": "int udf_setsize(struct inode *inode, loff_t newsize)\n{\n\tint err;\n\tstruct udf_inode_info *iinfo;\n\tint bsize = 1 << inode->i_blkbits;\n\n\tif (!(S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode) ||\n\t      S_ISLNK(inode->i_mode)))\n\t\treturn -EINVAL;\n\tif (IS_APPEND(inode) || IS_IMMUTABLE(inode))\n\t\treturn -EPERM;\n\n\tiinfo = UDF_I(inode);\n\tif (newsize > inode->i_size) {\n\t\tdown_write(&iinfo->i_data_sem);\n\t\tif (iinfo->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB) {\n\t\t\tif (bsize <\n\t\t\t    (udf_file_entry_alloc_offset(inode) + newsize)) {\n\t\t\t\terr = udf_expand_file_adinicb(inode);\n\t\t\t\tif (err)\n\t\t\t\t\treturn err;\n\t\t\t\tdown_write(&iinfo->i_data_sem);\n\t\t\t} else {\n\t\t\t\tiinfo->i_lenAlloc = newsize;\n\t\t\t\tgoto set_size;\n\t\t\t}\n\t\t}\n\t\terr = udf_extend_file(inode, newsize);\n\t\tif (err) {\n\t\t\tup_write(&iinfo->i_data_sem);\n\t\t\treturn err;\n\t\t}\nset_size:\n\t\ttruncate_setsize(inode, newsize);\n\t\tup_write(&iinfo->i_data_sem);\n\t} else {\n\t\tif (iinfo->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB) {\n\t\t\tdown_write(&iinfo->i_data_sem);\n\t\t\tudf_clear_extent_cache(inode);\n\t\t\tmemset(iinfo->i_ext.i_data + iinfo->i_lenEAttr + newsize,\n\t\t\t       0x00, bsize - newsize -\n\t\t\t       udf_file_entry_alloc_offset(inode));\n\t\t\tiinfo->i_lenAlloc = newsize;\n\t\t\ttruncate_setsize(inode, newsize);\n\t\t\tup_write(&iinfo->i_data_sem);\n\t\t\tgoto update_time;\n\t\t}\n\t\terr = block_truncate_page(inode->i_mapping, newsize,\n\t\t\t\t\t  udf_get_block);\n\t\tif (err)\n\t\t\treturn err;\n\t\tdown_write(&iinfo->i_data_sem);\n\t\tudf_clear_extent_cache(inode);\n\t\ttruncate_setsize(inode, newsize);\n\t\tudf_truncate_extents(inode);\n\t\tup_write(&iinfo->i_data_sem);\n\t}\nupdate_time:\n\tinode->i_mtime = inode->i_ctime = current_fs_time(inode->i_sb);\n\tif (IS_SYNC(inode))\n\t\tudf_sync_inode(inode);\n\telse\n\t\tmark_inode_dirty(inode);\n\treturn 0;\n}",
    "includes": [
      "#include \"udf_sb.h\"",
      "#include \"udf_i.h\"",
      "#include <linux/aio.h>",
      "#include <linux/mpage.h>",
      "#include <linux/crc-itu-t.h>",
      "#include <linux/slab.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include \"udfdecl.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int udf_update_inode(struct inode *, int);",
      "static int udf_sync_inode(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mark_inode_dirty",
          "args": [
            "inode"
          ],
          "line": 1269
        },
        "resolved": true,
        "details": {
          "function_name": "block_dump___mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1134-1154",
          "snippet": "static noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_sync_inode",
          "args": [
            "inode"
          ],
          "line": 1267
        },
        "resolved": true,
        "details": {
          "function_name": "udf_sync_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/inode.c",
          "lines": "1617-1620",
          "snippet": "static int udf_sync_inode(struct inode *inode)\n{\n\treturn udf_update_inode(inode, 1);\n}",
          "includes": [
            "#include \"udf_sb.h\"",
            "#include \"udf_i.h\"",
            "#include <linux/aio.h>",
            "#include <linux/mpage.h>",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int udf_update_inode(struct inode *, int);",
            "static int udf_sync_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/crc-itu-t.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include \"udfdecl.h\"\n\nstatic int udf_update_inode(struct inode *, int);\nstatic int udf_sync_inode(struct inode *inode);\n\nstatic int udf_sync_inode(struct inode *inode)\n{\n\treturn udf_update_inode(inode, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_SYNC",
          "args": [
            "inode"
          ],
          "line": 1266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_fs_time",
          "args": [
            "inode->i_sb"
          ],
          "line": 1265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&iinfo->i_data_sem"
          ],
          "line": 1262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udf_truncate_extents",
          "args": [
            "inode"
          ],
          "line": 1261
        },
        "resolved": true,
        "details": {
          "function_name": "udf_truncate_extents",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/truncate.c",
          "lines": "203-287",
          "snippet": "void udf_truncate_extents(struct inode *inode)\n{\n\tstruct extent_position epos;\n\tstruct kernel_lb_addr eloc, neloc = {};\n\tuint32_t elen, nelen = 0, indirect_ext_len = 0, lenalloc;\n\tint8_t etype;\n\tstruct super_block *sb = inode->i_sb;\n\tsector_t first_block = inode->i_size >> sb->s_blocksize_bits, offset;\n\tloff_t byte_offset;\n\tint adsize;\n\tstruct udf_inode_info *iinfo = UDF_I(inode);\n\n\tif (iinfo->i_alloc_type == ICBTAG_FLAG_AD_SHORT)\n\t\tadsize = sizeof(struct short_ad);\n\telse if (iinfo->i_alloc_type == ICBTAG_FLAG_AD_LONG)\n\t\tadsize = sizeof(struct long_ad);\n\telse\n\t\tBUG();\n\n\tetype = inode_bmap(inode, first_block, &epos, &eloc, &elen, &offset);\n\tbyte_offset = (offset << sb->s_blocksize_bits) +\n\t\t(inode->i_size & (sb->s_blocksize - 1));\n\tif (etype == -1) {\n\t\t/* We should extend the file? */\n\t\tWARN_ON(byte_offset);\n\t\treturn;\n\t}\n\tepos.offset -= adsize;\n\textent_trunc(inode, &epos, &eloc, etype, elen, byte_offset);\n\tepos.offset += adsize;\n\tif (byte_offset)\n\t\tlenalloc = epos.offset;\n\telse\n\t\tlenalloc = epos.offset - adsize;\n\n\tif (!epos.bh)\n\t\tlenalloc -= udf_file_entry_alloc_offset(inode);\n\telse\n\t\tlenalloc -= sizeof(struct allocExtDesc);\n\n\twhile ((etype = udf_current_aext(inode, &epos, &eloc,\n\t\t\t\t\t &elen, 0)) != -1) {\n\t\tif (etype == (EXT_NEXT_EXTENT_ALLOCDECS >> 30)) {\n\t\t\tudf_write_aext(inode, &epos, &neloc, nelen, 0);\n\t\t\tif (indirect_ext_len) {\n\t\t\t\t/* We managed to free all extents in the\n\t\t\t\t * indirect extent - free it too */\n\t\t\t\tBUG_ON(!epos.bh);\n\t\t\t\tudf_free_blocks(sb, NULL, &epos.block,\n\t\t\t\t\t\t0, indirect_ext_len);\n\t\t\t} else if (!epos.bh) {\n\t\t\t\tiinfo->i_lenAlloc = lenalloc;\n\t\t\t\tmark_inode_dirty(inode);\n\t\t\t} else\n\t\t\t\tudf_update_alloc_ext_desc(inode,\n\t\t\t\t\t\t&epos, lenalloc);\n\t\t\tbrelse(epos.bh);\n\t\t\tepos.offset = sizeof(struct allocExtDesc);\n\t\t\tepos.block = eloc;\n\t\t\tepos.bh = udf_tread(sb,\n\t\t\t\t\tudf_get_lb_pblock(sb, &eloc, 0));\n\t\t\tif (elen)\n\t\t\t\tindirect_ext_len =\n\t\t\t\t\t(elen + sb->s_blocksize - 1) >>\n\t\t\t\t\tsb->s_blocksize_bits;\n\t\t\telse\n\t\t\t\tindirect_ext_len = 1;\n\t\t} else {\n\t\t\textent_trunc(inode, &epos, &eloc, etype, elen, 0);\n\t\t\tepos.offset += adsize;\n\t\t}\n\t}\n\n\tif (indirect_ext_len) {\n\t\tBUG_ON(!epos.bh);\n\t\tudf_free_blocks(sb, NULL, &epos.block, 0, indirect_ext_len);\n\t} else if (!epos.bh) {\n\t\tiinfo->i_lenAlloc = lenalloc;\n\t\tmark_inode_dirty(inode);\n\t} else\n\t\tudf_update_alloc_ext_desc(inode, &epos, lenalloc);\n\tiinfo->i_lenExtents = inode->i_size;\n\n\tbrelse(epos.bh);\n}",
          "includes": [
            "#include \"udf_sb.h\"",
            "#include \"udf_i.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/buffer_head.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include \"udfdecl.h\"\n\nvoid udf_truncate_extents(struct inode *inode)\n{\n\tstruct extent_position epos;\n\tstruct kernel_lb_addr eloc, neloc = {};\n\tuint32_t elen, nelen = 0, indirect_ext_len = 0, lenalloc;\n\tint8_t etype;\n\tstruct super_block *sb = inode->i_sb;\n\tsector_t first_block = inode->i_size >> sb->s_blocksize_bits, offset;\n\tloff_t byte_offset;\n\tint adsize;\n\tstruct udf_inode_info *iinfo = UDF_I(inode);\n\n\tif (iinfo->i_alloc_type == ICBTAG_FLAG_AD_SHORT)\n\t\tadsize = sizeof(struct short_ad);\n\telse if (iinfo->i_alloc_type == ICBTAG_FLAG_AD_LONG)\n\t\tadsize = sizeof(struct long_ad);\n\telse\n\t\tBUG();\n\n\tetype = inode_bmap(inode, first_block, &epos, &eloc, &elen, &offset);\n\tbyte_offset = (offset << sb->s_blocksize_bits) +\n\t\t(inode->i_size & (sb->s_blocksize - 1));\n\tif (etype == -1) {\n\t\t/* We should extend the file? */\n\t\tWARN_ON(byte_offset);\n\t\treturn;\n\t}\n\tepos.offset -= adsize;\n\textent_trunc(inode, &epos, &eloc, etype, elen, byte_offset);\n\tepos.offset += adsize;\n\tif (byte_offset)\n\t\tlenalloc = epos.offset;\n\telse\n\t\tlenalloc = epos.offset - adsize;\n\n\tif (!epos.bh)\n\t\tlenalloc -= udf_file_entry_alloc_offset(inode);\n\telse\n\t\tlenalloc -= sizeof(struct allocExtDesc);\n\n\twhile ((etype = udf_current_aext(inode, &epos, &eloc,\n\t\t\t\t\t &elen, 0)) != -1) {\n\t\tif (etype == (EXT_NEXT_EXTENT_ALLOCDECS >> 30)) {\n\t\t\tudf_write_aext(inode, &epos, &neloc, nelen, 0);\n\t\t\tif (indirect_ext_len) {\n\t\t\t\t/* We managed to free all extents in the\n\t\t\t\t * indirect extent - free it too */\n\t\t\t\tBUG_ON(!epos.bh);\n\t\t\t\tudf_free_blocks(sb, NULL, &epos.block,\n\t\t\t\t\t\t0, indirect_ext_len);\n\t\t\t} else if (!epos.bh) {\n\t\t\t\tiinfo->i_lenAlloc = lenalloc;\n\t\t\t\tmark_inode_dirty(inode);\n\t\t\t} else\n\t\t\t\tudf_update_alloc_ext_desc(inode,\n\t\t\t\t\t\t&epos, lenalloc);\n\t\t\tbrelse(epos.bh);\n\t\t\tepos.offset = sizeof(struct allocExtDesc);\n\t\t\tepos.block = eloc;\n\t\t\tepos.bh = udf_tread(sb,\n\t\t\t\t\tudf_get_lb_pblock(sb, &eloc, 0));\n\t\t\tif (elen)\n\t\t\t\tindirect_ext_len =\n\t\t\t\t\t(elen + sb->s_blocksize - 1) >>\n\t\t\t\t\tsb->s_blocksize_bits;\n\t\t\telse\n\t\t\t\tindirect_ext_len = 1;\n\t\t} else {\n\t\t\textent_trunc(inode, &epos, &eloc, etype, elen, 0);\n\t\t\tepos.offset += adsize;\n\t\t}\n\t}\n\n\tif (indirect_ext_len) {\n\t\tBUG_ON(!epos.bh);\n\t\tudf_free_blocks(sb, NULL, &epos.block, 0, indirect_ext_len);\n\t} else if (!epos.bh) {\n\t\tiinfo->i_lenAlloc = lenalloc;\n\t\tmark_inode_dirty(inode);\n\t} else\n\t\tudf_update_alloc_ext_desc(inode, &epos, lenalloc);\n\tiinfo->i_lenExtents = inode->i_size;\n\n\tbrelse(epos.bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "truncate_setsize",
          "args": [
            "inode",
            "newsize"
          ],
          "line": 1260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udf_clear_extent_cache",
          "args": [
            "inode"
          ],
          "line": 1259
        },
        "resolved": true,
        "details": {
          "function_name": "udf_clear_extent_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/inode.c",
          "lines": "81-88",
          "snippet": "static void udf_clear_extent_cache(struct inode *inode)\n{\n\tstruct udf_inode_info *iinfo = UDF_I(inode);\n\n\tspin_lock(&iinfo->i_extent_cache_lock);\n\t__udf_clear_extent_cache(inode);\n\tspin_unlock(&iinfo->i_extent_cache_lock);\n}",
          "includes": [
            "#include \"udf_sb.h\"",
            "#include \"udf_i.h\"",
            "#include <linux/aio.h>",
            "#include <linux/mpage.h>",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int udf_update_inode(struct inode *, int);",
            "static int udf_sync_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/crc-itu-t.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include \"udfdecl.h\"\n\nstatic int udf_update_inode(struct inode *, int);\nstatic int udf_sync_inode(struct inode *inode);\n\nstatic void udf_clear_extent_cache(struct inode *inode)\n{\n\tstruct udf_inode_info *iinfo = UDF_I(inode);\n\n\tspin_lock(&iinfo->i_extent_cache_lock);\n\t__udf_clear_extent_cache(inode);\n\tspin_unlock(&iinfo->i_extent_cache_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&iinfo->i_data_sem"
          ],
          "line": 1258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "block_truncate_page",
          "args": [
            "inode->i_mapping",
            "newsize",
            "udf_get_block"
          ],
          "line": 1254
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_block_truncate_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
          "lines": "3323-3335",
          "snippet": "static int ext4_block_truncate_page(handle_t *handle,\n\t\tstruct address_space *mapping, loff_t from)\n{\n\tunsigned offset = from & (PAGE_CACHE_SIZE-1);\n\tunsigned length;\n\tunsigned blocksize;\n\tstruct inode *inode = mapping->host;\n\n\tblocksize = inode->i_sb->s_blocksize;\n\tlength = blocksize - (offset & (blocksize - 1));\n\n\treturn ext4_block_zero_page_range(handle, mapping, from, length);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/aio.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ext4_invalidatepage(struct page *page, unsigned int offset,\n\t\t\t\tunsigned int length);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstatic void ext4_invalidatepage(struct page *page, unsigned int offset,\n\t\t\t\tunsigned int length);\n\nstatic int ext4_block_truncate_page(handle_t *handle,\n\t\tstruct address_space *mapping, loff_t from)\n{\n\tunsigned offset = from & (PAGE_CACHE_SIZE-1);\n\tunsigned length;\n\tunsigned blocksize;\n\tstruct inode *inode = mapping->host;\n\n\tblocksize = inode->i_sb->s_blocksize;\n\tlength = blocksize - (offset & (blocksize - 1));\n\n\treturn ext4_block_zero_page_range(handle, mapping, from, length);\n}"
        }
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&iinfo->i_data_sem"
          ],
          "line": 1251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "truncate_setsize",
          "args": [
            "inode",
            "newsize"
          ],
          "line": 1250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "iinfo->i_ext.i_data + iinfo->i_lenEAttr + newsize",
            "0x00",
            "bsize - newsize -\n\t\t\t       udf_file_entry_alloc_offset(inode)"
          ],
          "line": 1246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udf_file_entry_alloc_offset",
          "args": [
            "inode"
          ],
          "line": 1248
        },
        "resolved": true,
        "details": {
          "function_name": "udf_file_entry_alloc_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/udfdecl.h",
          "lines": "55-64",
          "snippet": "static inline size_t udf_file_entry_alloc_offset(struct inode *inode)\n{\n\tstruct udf_inode_info *iinfo = UDF_I(inode);\n\tif (iinfo->i_use)\n\t\treturn sizeof(struct unallocSpaceEntry);\n\telse if (iinfo->i_efe)\n\t\treturn sizeof(struct extendedFileEntry) + iinfo->i_lenEAttr;\n\telse\n\t\treturn sizeof(struct fileEntry) + iinfo->i_lenEAttr;\n}",
          "includes": [
            "#include \"udf_i.h\"",
            "#include \"udfend.h\"",
            "#include \"udf_sb.h\"",
            "#include <linux/udf_fs_i.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include \"osta_udf.h\"",
            "#include \"ecma_167.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_i.h\"\n#include \"udfend.h\"\n#include \"udf_sb.h\"\n#include <linux/udf_fs_i.h>\n#include <linux/buffer_head.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include \"osta_udf.h\"\n#include \"ecma_167.h\"\n\nstatic inline size_t udf_file_entry_alloc_offset(struct inode *inode)\n{\n\tstruct udf_inode_info *iinfo = UDF_I(inode);\n\tif (iinfo->i_use)\n\t\treturn sizeof(struct unallocSpaceEntry);\n\telse if (iinfo->i_efe)\n\t\treturn sizeof(struct extendedFileEntry) + iinfo->i_lenEAttr;\n\telse\n\t\treturn sizeof(struct fileEntry) + iinfo->i_lenEAttr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&iinfo->i_data_sem"
          ],
          "line": 1244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&iinfo->i_data_sem"
          ],
          "line": 1241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "truncate_setsize",
          "args": [
            "inode",
            "newsize"
          ],
          "line": 1240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&iinfo->i_data_sem"
          ],
          "line": 1236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udf_extend_file",
          "args": [
            "inode",
            "newsize"
          ],
          "line": 1234
        },
        "resolved": true,
        "details": {
          "function_name": "udf_extend_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/inode.c",
          "lines": "601-656",
          "snippet": "static int udf_extend_file(struct inode *inode, loff_t newsize)\n{\n\n\tstruct extent_position epos;\n\tstruct kernel_lb_addr eloc;\n\tuint32_t elen;\n\tint8_t etype;\n\tstruct super_block *sb = inode->i_sb;\n\tsector_t first_block = newsize >> sb->s_blocksize_bits, offset;\n\tint adsize;\n\tstruct udf_inode_info *iinfo = UDF_I(inode);\n\tstruct kernel_long_ad extent;\n\tint err;\n\n\tif (iinfo->i_alloc_type == ICBTAG_FLAG_AD_SHORT)\n\t\tadsize = sizeof(struct short_ad);\n\telse if (iinfo->i_alloc_type == ICBTAG_FLAG_AD_LONG)\n\t\tadsize = sizeof(struct long_ad);\n\telse\n\t\tBUG();\n\n\tetype = inode_bmap(inode, first_block, &epos, &eloc, &elen, &offset);\n\n\t/* File has extent covering the new size (could happen when extending\n\t * inside a block)? */\n\tif (etype != -1)\n\t\treturn 0;\n\tif (newsize & (sb->s_blocksize - 1))\n\t\toffset++;\n\t/* Extended file just to the boundary of the last file block? */\n\tif (offset == 0)\n\t\treturn 0;\n\n\t/* Truncate is extending the file by 'offset' blocks */\n\tif ((!epos.bh && epos.offset == udf_file_entry_alloc_offset(inode)) ||\n\t    (epos.bh && epos.offset == sizeof(struct allocExtDesc))) {\n\t\t/* File has no extents at all or has empty last\n\t\t * indirect extent! Create a fake extent... */\n\t\textent.extLocation.logicalBlockNum = 0;\n\t\textent.extLocation.partitionReferenceNum = 0;\n\t\textent.extLength = EXT_NOT_RECORDED_NOT_ALLOCATED;\n\t} else {\n\t\tepos.offset -= adsize;\n\t\tetype = udf_next_aext(inode, &epos, &extent.extLocation,\n\t\t\t\t      &extent.extLength, 0);\n\t\textent.extLength |= etype << 30;\n\t}\n\terr = udf_do_extend_file(inode, &epos, &extent, offset);\n\tif (err < 0)\n\t\tgoto out;\n\terr = 0;\n\tiinfo->i_lenExtents = newsize;\nout:\n\tbrelse(epos.bh);\n\treturn err;\n}",
          "includes": [
            "#include \"udf_sb.h\"",
            "#include \"udf_i.h\"",
            "#include <linux/aio.h>",
            "#include <linux/mpage.h>",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int udf_update_inode(struct inode *, int);",
            "static int udf_sync_inode(struct inode *inode);",
            "static int udf_alloc_i_data(struct inode *inode, size_t size);",
            "static sector_t inode_getblk(struct inode *, sector_t, int *, int *);",
            "static int8_t udf_insert_aext(struct inode *, struct extent_position,\n\t\t\t      struct kernel_lb_addr, uint32_t);",
            "static void udf_split_extents(struct inode *, int *, int, int,\n\t\t\t      struct kernel_long_ad[EXTENT_MERGE_SIZE], int *);",
            "static void udf_prealloc_extents(struct inode *, int, int,\n\t\t\t\t struct kernel_long_ad[EXTENT_MERGE_SIZE], int *);",
            "static void udf_merge_extents(struct inode *,\n\t\t\t      struct kernel_long_ad[EXTENT_MERGE_SIZE], int *);",
            "static void udf_update_extents(struct inode *,\n\t\t\t       struct kernel_long_ad[EXTENT_MERGE_SIZE], int, int,\n\t\t\t       struct extent_position *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/crc-itu-t.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include \"udfdecl.h\"\n\nstatic int udf_update_inode(struct inode *, int);\nstatic int udf_sync_inode(struct inode *inode);\nstatic int udf_alloc_i_data(struct inode *inode, size_t size);\nstatic sector_t inode_getblk(struct inode *, sector_t, int *, int *);\nstatic int8_t udf_insert_aext(struct inode *, struct extent_position,\n\t\t\t      struct kernel_lb_addr, uint32_t);\nstatic void udf_split_extents(struct inode *, int *, int, int,\n\t\t\t      struct kernel_long_ad[EXTENT_MERGE_SIZE], int *);\nstatic void udf_prealloc_extents(struct inode *, int, int,\n\t\t\t\t struct kernel_long_ad[EXTENT_MERGE_SIZE], int *);\nstatic void udf_merge_extents(struct inode *,\n\t\t\t      struct kernel_long_ad[EXTENT_MERGE_SIZE], int *);\nstatic void udf_update_extents(struct inode *,\n\t\t\t       struct kernel_long_ad[EXTENT_MERGE_SIZE], int, int,\n\t\t\t       struct extent_position *);\n\nstatic int udf_extend_file(struct inode *inode, loff_t newsize)\n{\n\n\tstruct extent_position epos;\n\tstruct kernel_lb_addr eloc;\n\tuint32_t elen;\n\tint8_t etype;\n\tstruct super_block *sb = inode->i_sb;\n\tsector_t first_block = newsize >> sb->s_blocksize_bits, offset;\n\tint adsize;\n\tstruct udf_inode_info *iinfo = UDF_I(inode);\n\tstruct kernel_long_ad extent;\n\tint err;\n\n\tif (iinfo->i_alloc_type == ICBTAG_FLAG_AD_SHORT)\n\t\tadsize = sizeof(struct short_ad);\n\telse if (iinfo->i_alloc_type == ICBTAG_FLAG_AD_LONG)\n\t\tadsize = sizeof(struct long_ad);\n\telse\n\t\tBUG();\n\n\tetype = inode_bmap(inode, first_block, &epos, &eloc, &elen, &offset);\n\n\t/* File has extent covering the new size (could happen when extending\n\t * inside a block)? */\n\tif (etype != -1)\n\t\treturn 0;\n\tif (newsize & (sb->s_blocksize - 1))\n\t\toffset++;\n\t/* Extended file just to the boundary of the last file block? */\n\tif (offset == 0)\n\t\treturn 0;\n\n\t/* Truncate is extending the file by 'offset' blocks */\n\tif ((!epos.bh && epos.offset == udf_file_entry_alloc_offset(inode)) ||\n\t    (epos.bh && epos.offset == sizeof(struct allocExtDesc))) {\n\t\t/* File has no extents at all or has empty last\n\t\t * indirect extent! Create a fake extent... */\n\t\textent.extLocation.logicalBlockNum = 0;\n\t\textent.extLocation.partitionReferenceNum = 0;\n\t\textent.extLength = EXT_NOT_RECORDED_NOT_ALLOCATED;\n\t} else {\n\t\tepos.offset -= adsize;\n\t\tetype = udf_next_aext(inode, &epos, &extent.extLocation,\n\t\t\t\t      &extent.extLength, 0);\n\t\textent.extLength |= etype << 30;\n\t}\n\terr = udf_do_extend_file(inode, &epos, &extent, offset);\n\tif (err < 0)\n\t\tgoto out;\n\terr = 0;\n\tiinfo->i_lenExtents = newsize;\nout:\n\tbrelse(epos.bh);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&iinfo->i_data_sem"
          ],
          "line": 1228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udf_expand_file_adinicb",
          "args": [
            "inode"
          ],
          "line": 1225
        },
        "resolved": true,
        "details": {
          "function_name": "udf_expand_file_adinicb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/inode.c",
          "lines": "256-328",
          "snippet": "int udf_expand_file_adinicb(struct inode *inode)\n{\n\tstruct page *page;\n\tchar *kaddr;\n\tstruct udf_inode_info *iinfo = UDF_I(inode);\n\tint err;\n\tstruct writeback_control udf_wbc = {\n\t\t.sync_mode = WB_SYNC_NONE,\n\t\t.nr_to_write = 1,\n\t};\n\n\tWARN_ON_ONCE(!mutex_is_locked(&inode->i_mutex));\n\tif (!iinfo->i_lenAlloc) {\n\t\tif (UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_USE_SHORT_AD))\n\t\t\tiinfo->i_alloc_type = ICBTAG_FLAG_AD_SHORT;\n\t\telse\n\t\t\tiinfo->i_alloc_type = ICBTAG_FLAG_AD_LONG;\n\t\t/* from now on we have normal address_space methods */\n\t\tinode->i_data.a_ops = &udf_aops;\n\t\tup_write(&iinfo->i_data_sem);\n\t\tmark_inode_dirty(inode);\n\t\treturn 0;\n\t}\n\t/*\n\t * Release i_data_sem so that we can lock a page - page lock ranks\n\t * above i_data_sem. i_mutex still protects us against file changes.\n\t */\n\tup_write(&iinfo->i_data_sem);\n\n\tpage = find_or_create_page(inode->i_mapping, 0, GFP_NOFS);\n\tif (!page)\n\t\treturn -ENOMEM;\n\n\tif (!PageUptodate(page)) {\n\t\tkaddr = kmap(page);\n\t\tmemset(kaddr + iinfo->i_lenAlloc, 0x00,\n\t\t       PAGE_CACHE_SIZE - iinfo->i_lenAlloc);\n\t\tmemcpy(kaddr, iinfo->i_ext.i_data + iinfo->i_lenEAttr,\n\t\t\tiinfo->i_lenAlloc);\n\t\tflush_dcache_page(page);\n\t\tSetPageUptodate(page);\n\t\tkunmap(page);\n\t}\n\tdown_write(&iinfo->i_data_sem);\n\tmemset(iinfo->i_ext.i_data + iinfo->i_lenEAttr, 0x00,\n\t       iinfo->i_lenAlloc);\n\tiinfo->i_lenAlloc = 0;\n\tif (UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_USE_SHORT_AD))\n\t\tiinfo->i_alloc_type = ICBTAG_FLAG_AD_SHORT;\n\telse\n\t\tiinfo->i_alloc_type = ICBTAG_FLAG_AD_LONG;\n\t/* from now on we have normal address_space methods */\n\tinode->i_data.a_ops = &udf_aops;\n\tup_write(&iinfo->i_data_sem);\n\terr = inode->i_data.a_ops->writepage(page, &udf_wbc);\n\tif (err) {\n\t\t/* Restore everything back so that we don't lose data... */\n\t\tlock_page(page);\n\t\tkaddr = kmap(page);\n\t\tdown_write(&iinfo->i_data_sem);\n\t\tmemcpy(iinfo->i_ext.i_data + iinfo->i_lenEAttr, kaddr,\n\t\t       inode->i_size);\n\t\tkunmap(page);\n\t\tunlock_page(page);\n\t\tiinfo->i_alloc_type = ICBTAG_FLAG_AD_IN_ICB;\n\t\tinode->i_data.a_ops = &udf_adinicb_aops;\n\t\tup_write(&iinfo->i_data_sem);\n\t}\n\tpage_cache_release(page);\n\tmark_inode_dirty(inode);\n\n\treturn err;\n}",
          "includes": [
            "#include \"udf_sb.h\"",
            "#include \"udf_i.h\"",
            "#include <linux/aio.h>",
            "#include <linux/mpage.h>",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int udf_update_inode(struct inode *, int);",
            "static int udf_sync_inode(struct inode *inode);",
            "const struct address_space_operations udf_aops = {\n\t.readpage\t= udf_readpage,\n\t.readpages\t= udf_readpages,\n\t.writepage\t= udf_writepage,\n\t.writepages\t= udf_writepages,\n\t.write_begin\t= udf_write_begin,\n\t.write_end\t= generic_write_end,\n\t.direct_IO\t= udf_direct_IO,\n\t.bmap\t\t= udf_bmap,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/crc-itu-t.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include \"udfdecl.h\"\n\nstatic int udf_update_inode(struct inode *, int);\nstatic int udf_sync_inode(struct inode *inode);\nconst struct address_space_operations udf_aops = {\n\t.readpage\t= udf_readpage,\n\t.readpages\t= udf_readpages,\n\t.writepage\t= udf_writepage,\n\t.writepages\t= udf_writepages,\n\t.write_begin\t= udf_write_begin,\n\t.write_end\t= generic_write_end,\n\t.direct_IO\t= udf_direct_IO,\n\t.bmap\t\t= udf_bmap,\n};\n\nint udf_expand_file_adinicb(struct inode *inode)\n{\n\tstruct page *page;\n\tchar *kaddr;\n\tstruct udf_inode_info *iinfo = UDF_I(inode);\n\tint err;\n\tstruct writeback_control udf_wbc = {\n\t\t.sync_mode = WB_SYNC_NONE,\n\t\t.nr_to_write = 1,\n\t};\n\n\tWARN_ON_ONCE(!mutex_is_locked(&inode->i_mutex));\n\tif (!iinfo->i_lenAlloc) {\n\t\tif (UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_USE_SHORT_AD))\n\t\t\tiinfo->i_alloc_type = ICBTAG_FLAG_AD_SHORT;\n\t\telse\n\t\t\tiinfo->i_alloc_type = ICBTAG_FLAG_AD_LONG;\n\t\t/* from now on we have normal address_space methods */\n\t\tinode->i_data.a_ops = &udf_aops;\n\t\tup_write(&iinfo->i_data_sem);\n\t\tmark_inode_dirty(inode);\n\t\treturn 0;\n\t}\n\t/*\n\t * Release i_data_sem so that we can lock a page - page lock ranks\n\t * above i_data_sem. i_mutex still protects us against file changes.\n\t */\n\tup_write(&iinfo->i_data_sem);\n\n\tpage = find_or_create_page(inode->i_mapping, 0, GFP_NOFS);\n\tif (!page)\n\t\treturn -ENOMEM;\n\n\tif (!PageUptodate(page)) {\n\t\tkaddr = kmap(page);\n\t\tmemset(kaddr + iinfo->i_lenAlloc, 0x00,\n\t\t       PAGE_CACHE_SIZE - iinfo->i_lenAlloc);\n\t\tmemcpy(kaddr, iinfo->i_ext.i_data + iinfo->i_lenEAttr,\n\t\t\tiinfo->i_lenAlloc);\n\t\tflush_dcache_page(page);\n\t\tSetPageUptodate(page);\n\t\tkunmap(page);\n\t}\n\tdown_write(&iinfo->i_data_sem);\n\tmemset(iinfo->i_ext.i_data + iinfo->i_lenEAttr, 0x00,\n\t       iinfo->i_lenAlloc);\n\tiinfo->i_lenAlloc = 0;\n\tif (UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_USE_SHORT_AD))\n\t\tiinfo->i_alloc_type = ICBTAG_FLAG_AD_SHORT;\n\telse\n\t\tiinfo->i_alloc_type = ICBTAG_FLAG_AD_LONG;\n\t/* from now on we have normal address_space methods */\n\tinode->i_data.a_ops = &udf_aops;\n\tup_write(&iinfo->i_data_sem);\n\terr = inode->i_data.a_ops->writepage(page, &udf_wbc);\n\tif (err) {\n\t\t/* Restore everything back so that we don't lose data... */\n\t\tlock_page(page);\n\t\tkaddr = kmap(page);\n\t\tdown_write(&iinfo->i_data_sem);\n\t\tmemcpy(iinfo->i_ext.i_data + iinfo->i_lenEAttr, kaddr,\n\t\t       inode->i_size);\n\t\tkunmap(page);\n\t\tunlock_page(page);\n\t\tiinfo->i_alloc_type = ICBTAG_FLAG_AD_IN_ICB;\n\t\tinode->i_data.a_ops = &udf_adinicb_aops;\n\t\tup_write(&iinfo->i_data_sem);\n\t}\n\tpage_cache_release(page);\n\tmark_inode_dirty(inode);\n\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&iinfo->i_data_sem"
          ],
          "line": 1221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UDF_I",
          "args": [
            "inode"
          ],
          "line": 1219
        },
        "resolved": true,
        "details": {
          "function_name": "UDF_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/udf_i.h",
          "lines": "57-60",
          "snippet": "static inline struct udf_inode_info *UDF_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct udf_inode_info, vfs_inode);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline struct udf_inode_info *UDF_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct udf_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_IMMUTABLE",
          "args": [
            "inode"
          ],
          "line": 1216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_APPEND",
          "args": [
            "inode"
          ],
          "line": 1216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISLNK",
          "args": [
            "inode->i_mode"
          ],
          "line": 1214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "inode->i_mode"
          ],
          "line": 1213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "inode->i_mode"
          ],
          "line": 1213
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/crc-itu-t.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include \"udfdecl.h\"\n\nstatic int udf_update_inode(struct inode *, int);\nstatic int udf_sync_inode(struct inode *inode);\n\nint udf_setsize(struct inode *inode, loff_t newsize)\n{\n\tint err;\n\tstruct udf_inode_info *iinfo;\n\tint bsize = 1 << inode->i_blkbits;\n\n\tif (!(S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode) ||\n\t      S_ISLNK(inode->i_mode)))\n\t\treturn -EINVAL;\n\tif (IS_APPEND(inode) || IS_IMMUTABLE(inode))\n\t\treturn -EPERM;\n\n\tiinfo = UDF_I(inode);\n\tif (newsize > inode->i_size) {\n\t\tdown_write(&iinfo->i_data_sem);\n\t\tif (iinfo->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB) {\n\t\t\tif (bsize <\n\t\t\t    (udf_file_entry_alloc_offset(inode) + newsize)) {\n\t\t\t\terr = udf_expand_file_adinicb(inode);\n\t\t\t\tif (err)\n\t\t\t\t\treturn err;\n\t\t\t\tdown_write(&iinfo->i_data_sem);\n\t\t\t} else {\n\t\t\t\tiinfo->i_lenAlloc = newsize;\n\t\t\t\tgoto set_size;\n\t\t\t}\n\t\t}\n\t\terr = udf_extend_file(inode, newsize);\n\t\tif (err) {\n\t\t\tup_write(&iinfo->i_data_sem);\n\t\t\treturn err;\n\t\t}\nset_size:\n\t\ttruncate_setsize(inode, newsize);\n\t\tup_write(&iinfo->i_data_sem);\n\t} else {\n\t\tif (iinfo->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB) {\n\t\t\tdown_write(&iinfo->i_data_sem);\n\t\t\tudf_clear_extent_cache(inode);\n\t\t\tmemset(iinfo->i_ext.i_data + iinfo->i_lenEAttr + newsize,\n\t\t\t       0x00, bsize - newsize -\n\t\t\t       udf_file_entry_alloc_offset(inode));\n\t\t\tiinfo->i_lenAlloc = newsize;\n\t\t\ttruncate_setsize(inode, newsize);\n\t\t\tup_write(&iinfo->i_data_sem);\n\t\t\tgoto update_time;\n\t\t}\n\t\terr = block_truncate_page(inode->i_mapping, newsize,\n\t\t\t\t\t  udf_get_block);\n\t\tif (err)\n\t\t\treturn err;\n\t\tdown_write(&iinfo->i_data_sem);\n\t\tudf_clear_extent_cache(inode);\n\t\ttruncate_setsize(inode, newsize);\n\t\tudf_truncate_extents(inode);\n\t\tup_write(&iinfo->i_data_sem);\n\t}\nupdate_time:\n\tinode->i_mtime = inode->i_ctime = current_fs_time(inode->i_sb);\n\tif (IS_SYNC(inode))\n\t\tudf_sync_inode(inode);\n\telse\n\t\tmark_inode_dirty(inode);\n\treturn 0;\n}"
  },
  {
    "function_name": "udf_bread",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/inode.c",
    "lines": "1184-1205",
    "snippet": "struct buffer_head *udf_bread(struct inode *inode, int block,\n\t\t\t      int create, int *err)\n{\n\tstruct buffer_head *bh = NULL;\n\n\tbh = udf_getblk(inode, block, create, err);\n\tif (!bh)\n\t\treturn NULL;\n\n\tif (buffer_uptodate(bh))\n\t\treturn bh;\n\n\tll_rw_block(READ, 1, &bh);\n\n\twait_on_buffer(bh);\n\tif (buffer_uptodate(bh))\n\t\treturn bh;\n\n\tbrelse(bh);\n\t*err = -EIO;\n\treturn NULL;\n}",
    "includes": [
      "#include \"udf_sb.h\"",
      "#include \"udf_i.h\"",
      "#include <linux/aio.h>",
      "#include <linux/mpage.h>",
      "#include <linux/crc-itu-t.h>",
      "#include <linux/slab.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include \"udfdecl.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int udf_update_inode(struct inode *, int);",
      "static int udf_sync_inode(struct inode *inode);",
      "static int udf_get_block(struct inode *, sector_t, struct buffer_head *, int);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 1202
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "buffer_uptodate",
          "args": [
            "bh"
          ],
          "line": 1199
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3758-3761",
          "snippet": "int btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_on_buffer",
          "args": [
            "bh"
          ],
          "line": 1198
        },
        "resolved": true,
        "details": {
          "function_name": "__wait_on_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "117-120",
          "snippet": "void __wait_on_buffer(struct buffer_head * bh)\n{\n\twait_on_bit_io(&bh->b_state, BH_Lock, TASK_UNINTERRUPTIBLE);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __wait_on_buffer(struct buffer_head * bh)\n{\n\twait_on_bit_io(&bh->b_state, BH_Lock, TASK_UNINTERRUPTIBLE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ll_rw_block",
          "args": [
            "READ",
            "1",
            "&bh"
          ],
          "line": 1196
        },
        "resolved": true,
        "details": {
          "function_name": "ll_rw_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "3086-3112",
          "snippet": "void ll_rw_block(int rw, int nr, struct buffer_head *bhs[])\n{\n\tint i;\n\n\tfor (i = 0; i < nr; i++) {\n\t\tstruct buffer_head *bh = bhs[i];\n\n\t\tif (!trylock_buffer(bh))\n\t\t\tcontinue;\n\t\tif (rw == WRITE) {\n\t\t\tif (test_clear_buffer_dirty(bh)) {\n\t\t\t\tbh->b_end_io = end_buffer_write_sync;\n\t\t\t\tget_bh(bh);\n\t\t\t\tsubmit_bh(WRITE, bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t} else {\n\t\t\tif (!buffer_uptodate(bh)) {\n\t\t\t\tbh->b_end_io = end_buffer_read_sync;\n\t\t\t\tget_bh(bh);\n\t\t\t\tsubmit_bh(rw, bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tunlock_buffer(bh);\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid ll_rw_block(int rw, int nr, struct buffer_head *bhs[])\n{\n\tint i;\n\n\tfor (i = 0; i < nr; i++) {\n\t\tstruct buffer_head *bh = bhs[i];\n\n\t\tif (!trylock_buffer(bh))\n\t\t\tcontinue;\n\t\tif (rw == WRITE) {\n\t\t\tif (test_clear_buffer_dirty(bh)) {\n\t\t\t\tbh->b_end_io = end_buffer_write_sync;\n\t\t\t\tget_bh(bh);\n\t\t\t\tsubmit_bh(WRITE, bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t} else {\n\t\t\tif (!buffer_uptodate(bh)) {\n\t\t\t\tbh->b_end_io = end_buffer_read_sync;\n\t\t\t\tget_bh(bh);\n\t\t\t\tsubmit_bh(rw, bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tunlock_buffer(bh);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_getblk",
          "args": [
            "inode",
            "block",
            "create",
            "err"
          ],
          "line": 1189
        },
        "resolved": true,
        "details": {
          "function_name": "udf_getblk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/inode.c",
          "lines": "460-482",
          "snippet": "static struct buffer_head *udf_getblk(struct inode *inode, long block,\n\t\t\t\t      int create, int *err)\n{\n\tstruct buffer_head *bh;\n\tstruct buffer_head dummy;\n\n\tdummy.b_state = 0;\n\tdummy.b_blocknr = -1000;\n\t*err = udf_get_block(inode, block, &dummy, create);\n\tif (!*err && buffer_mapped(&dummy)) {\n\t\tbh = sb_getblk(inode->i_sb, dummy.b_blocknr);\n\t\tif (buffer_new(&dummy)) {\n\t\t\tlock_buffer(bh);\n\t\t\tmemset(bh->b_data, 0x00, inode->i_sb->s_blocksize);\n\t\t\tset_buffer_uptodate(bh);\n\t\t\tunlock_buffer(bh);\n\t\t\tmark_buffer_dirty_inode(bh, inode);\n\t\t}\n\t\treturn bh;\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"udf_sb.h\"",
            "#include \"udf_i.h\"",
            "#include <linux/aio.h>",
            "#include <linux/mpage.h>",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int udf_update_inode(struct inode *, int);",
            "static int udf_sync_inode(struct inode *inode);",
            "static int udf_get_block(struct inode *, sector_t, struct buffer_head *, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/crc-itu-t.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include \"udfdecl.h\"\n\nstatic int udf_update_inode(struct inode *, int);\nstatic int udf_sync_inode(struct inode *inode);\nstatic int udf_get_block(struct inode *, sector_t, struct buffer_head *, int);\n\nstatic struct buffer_head *udf_getblk(struct inode *inode, long block,\n\t\t\t\t      int create, int *err)\n{\n\tstruct buffer_head *bh;\n\tstruct buffer_head dummy;\n\n\tdummy.b_state = 0;\n\tdummy.b_blocknr = -1000;\n\t*err = udf_get_block(inode, block, &dummy, create);\n\tif (!*err && buffer_mapped(&dummy)) {\n\t\tbh = sb_getblk(inode->i_sb, dummy.b_blocknr);\n\t\tif (buffer_new(&dummy)) {\n\t\t\tlock_buffer(bh);\n\t\t\tmemset(bh->b_data, 0x00, inode->i_sb->s_blocksize);\n\t\t\tset_buffer_uptodate(bh);\n\t\t\tunlock_buffer(bh);\n\t\t\tmark_buffer_dirty_inode(bh, inode);\n\t\t}\n\t\treturn bh;\n\t}\n\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/crc-itu-t.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include \"udfdecl.h\"\n\nstatic int udf_update_inode(struct inode *, int);\nstatic int udf_sync_inode(struct inode *inode);\nstatic int udf_get_block(struct inode *, sector_t, struct buffer_head *, int);\n\nstruct buffer_head *udf_bread(struct inode *inode, int block,\n\t\t\t      int create, int *err)\n{\n\tstruct buffer_head *bh = NULL;\n\n\tbh = udf_getblk(inode, block, create, err);\n\tif (!bh)\n\t\treturn NULL;\n\n\tif (buffer_uptodate(bh))\n\t\treturn bh;\n\n\tll_rw_block(READ, 1, &bh);\n\n\twait_on_buffer(bh);\n\tif (buffer_uptodate(bh))\n\t\treturn bh;\n\n\tbrelse(bh);\n\t*err = -EIO;\n\treturn NULL;\n}"
  },
  {
    "function_name": "udf_update_extents",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/inode.c",
    "lines": "1154-1182",
    "snippet": "static void udf_update_extents(struct inode *inode,\n\t\t\t       struct kernel_long_ad laarr[EXTENT_MERGE_SIZE],\n\t\t\t       int startnum, int endnum,\n\t\t\t       struct extent_position *epos)\n{\n\tint start = 0, i;\n\tstruct kernel_lb_addr tmploc;\n\tuint32_t tmplen;\n\n\tif (startnum > endnum) {\n\t\tfor (i = 0; i < (startnum - endnum); i++)\n\t\t\tudf_delete_aext(inode, *epos, laarr[i].extLocation,\n\t\t\t\t\tlaarr[i].extLength);\n\t} else if (startnum < endnum) {\n\t\tfor (i = 0; i < (endnum - startnum); i++) {\n\t\t\tudf_insert_aext(inode, *epos, laarr[i].extLocation,\n\t\t\t\t\tlaarr[i].extLength);\n\t\t\tudf_next_aext(inode, epos, &laarr[i].extLocation,\n\t\t\t\t      &laarr[i].extLength, 1);\n\t\t\tstart++;\n\t\t}\n\t}\n\n\tfor (i = start; i < endnum; i++) {\n\t\tudf_next_aext(inode, epos, &tmploc, &tmplen, 0);\n\t\tudf_write_aext(inode, epos, &laarr[i].extLocation,\n\t\t\t       laarr[i].extLength, 1);\n\t}\n}",
    "includes": [
      "#include \"udf_sb.h\"",
      "#include \"udf_i.h\"",
      "#include <linux/aio.h>",
      "#include <linux/mpage.h>",
      "#include <linux/crc-itu-t.h>",
      "#include <linux/slab.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include \"udfdecl.h\""
    ],
    "macros_used": [
      "#define EXTENT_MERGE_SIZE 5"
    ],
    "globals_used": [
      "static int udf_update_inode(struct inode *, int);",
      "static int udf_sync_inode(struct inode *inode);",
      "static int8_t udf_insert_aext(struct inode *, struct extent_position,\n\t\t\t      struct kernel_lb_addr, uint32_t);",
      "static void udf_split_extents(struct inode *, int *, int, int,\n\t\t\t      struct kernel_long_ad[EXTENT_MERGE_SIZE], int *);",
      "static void udf_prealloc_extents(struct inode *, int, int,\n\t\t\t\t struct kernel_long_ad[EXTENT_MERGE_SIZE], int *);",
      "static void udf_merge_extents(struct inode *,\n\t\t\t      struct kernel_long_ad[EXTENT_MERGE_SIZE], int *);",
      "static void udf_update_extents(struct inode *,\n\t\t\t       struct kernel_long_ad[EXTENT_MERGE_SIZE], int, int,\n\t\t\t       struct extent_position *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "udf_write_aext",
          "args": [
            "inode",
            "epos",
            "&laarr[i].extLocation",
            "laarr[i].extLength",
            "1"
          ],
          "line": 1179
        },
        "resolved": true,
        "details": {
          "function_name": "udf_write_aext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/inode.c",
          "lines": "2005-2055",
          "snippet": "void udf_write_aext(struct inode *inode, struct extent_position *epos,\n\t\t    struct kernel_lb_addr *eloc, uint32_t elen, int inc)\n{\n\tint adsize;\n\tuint8_t *ptr;\n\tstruct short_ad *sad;\n\tstruct long_ad *lad;\n\tstruct udf_inode_info *iinfo = UDF_I(inode);\n\n\tif (!epos->bh)\n\t\tptr = iinfo->i_ext.i_data + epos->offset -\n\t\t\tudf_file_entry_alloc_offset(inode) +\n\t\t\tiinfo->i_lenEAttr;\n\telse\n\t\tptr = epos->bh->b_data + epos->offset;\n\n\tswitch (iinfo->i_alloc_type) {\n\tcase ICBTAG_FLAG_AD_SHORT:\n\t\tsad = (struct short_ad *)ptr;\n\t\tsad->extLength = cpu_to_le32(elen);\n\t\tsad->extPosition = cpu_to_le32(eloc->logicalBlockNum);\n\t\tadsize = sizeof(struct short_ad);\n\t\tbreak;\n\tcase ICBTAG_FLAG_AD_LONG:\n\t\tlad = (struct long_ad *)ptr;\n\t\tlad->extLength = cpu_to_le32(elen);\n\t\tlad->extLocation = cpu_to_lelb(*eloc);\n\t\tmemset(lad->impUse, 0x00, sizeof(lad->impUse));\n\t\tadsize = sizeof(struct long_ad);\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\n\tif (epos->bh) {\n\t\tif (!UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_STRICT) ||\n\t\t    UDF_SB(inode->i_sb)->s_udfrev >= 0x0201) {\n\t\t\tstruct allocExtDesc *aed =\n\t\t\t\t(struct allocExtDesc *)epos->bh->b_data;\n\t\t\tudf_update_tag(epos->bh->b_data,\n\t\t\t\t       le32_to_cpu(aed->lengthAllocDescs) +\n\t\t\t\t       sizeof(struct allocExtDesc));\n\t\t}\n\t\tmark_buffer_dirty_inode(epos->bh, inode);\n\t} else {\n\t\tmark_inode_dirty(inode);\n\t}\n\n\tif (inc)\n\t\tepos->offset += adsize;\n}",
          "includes": [
            "#include \"udf_sb.h\"",
            "#include \"udf_i.h\"",
            "#include <linux/aio.h>",
            "#include <linux/mpage.h>",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int udf_update_inode(struct inode *, int);",
            "static int udf_sync_inode(struct inode *inode);",
            "static int8_t udf_insert_aext(struct inode *, struct extent_position,\n\t\t\t      struct kernel_lb_addr, uint32_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/crc-itu-t.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include \"udfdecl.h\"\n\nstatic int udf_update_inode(struct inode *, int);\nstatic int udf_sync_inode(struct inode *inode);\nstatic int8_t udf_insert_aext(struct inode *, struct extent_position,\n\t\t\t      struct kernel_lb_addr, uint32_t);\n\nvoid udf_write_aext(struct inode *inode, struct extent_position *epos,\n\t\t    struct kernel_lb_addr *eloc, uint32_t elen, int inc)\n{\n\tint adsize;\n\tuint8_t *ptr;\n\tstruct short_ad *sad;\n\tstruct long_ad *lad;\n\tstruct udf_inode_info *iinfo = UDF_I(inode);\n\n\tif (!epos->bh)\n\t\tptr = iinfo->i_ext.i_data + epos->offset -\n\t\t\tudf_file_entry_alloc_offset(inode) +\n\t\t\tiinfo->i_lenEAttr;\n\telse\n\t\tptr = epos->bh->b_data + epos->offset;\n\n\tswitch (iinfo->i_alloc_type) {\n\tcase ICBTAG_FLAG_AD_SHORT:\n\t\tsad = (struct short_ad *)ptr;\n\t\tsad->extLength = cpu_to_le32(elen);\n\t\tsad->extPosition = cpu_to_le32(eloc->logicalBlockNum);\n\t\tadsize = sizeof(struct short_ad);\n\t\tbreak;\n\tcase ICBTAG_FLAG_AD_LONG:\n\t\tlad = (struct long_ad *)ptr;\n\t\tlad->extLength = cpu_to_le32(elen);\n\t\tlad->extLocation = cpu_to_lelb(*eloc);\n\t\tmemset(lad->impUse, 0x00, sizeof(lad->impUse));\n\t\tadsize = sizeof(struct long_ad);\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\n\tif (epos->bh) {\n\t\tif (!UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_STRICT) ||\n\t\t    UDF_SB(inode->i_sb)->s_udfrev >= 0x0201) {\n\t\t\tstruct allocExtDesc *aed =\n\t\t\t\t(struct allocExtDesc *)epos->bh->b_data;\n\t\t\tudf_update_tag(epos->bh->b_data,\n\t\t\t\t       le32_to_cpu(aed->lengthAllocDescs) +\n\t\t\t\t       sizeof(struct allocExtDesc));\n\t\t}\n\t\tmark_buffer_dirty_inode(epos->bh, inode);\n\t} else {\n\t\tmark_inode_dirty(inode);\n\t}\n\n\tif (inc)\n\t\tepos->offset += adsize;\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_next_aext",
          "args": [
            "inode",
            "epos",
            "&tmploc",
            "&tmplen",
            "0"
          ],
          "line": 1178
        },
        "resolved": true,
        "details": {
          "function_name": "udf_next_aext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/inode.c",
          "lines": "2057-2077",
          "snippet": "int8_t udf_next_aext(struct inode *inode, struct extent_position *epos,\n\t\t     struct kernel_lb_addr *eloc, uint32_t *elen, int inc)\n{\n\tint8_t etype;\n\n\twhile ((etype = udf_current_aext(inode, epos, eloc, elen, inc)) ==\n\t       (EXT_NEXT_EXTENT_ALLOCDECS >> 30)) {\n\t\tint block;\n\t\tepos->block = *eloc;\n\t\tepos->offset = sizeof(struct allocExtDesc);\n\t\tbrelse(epos->bh);\n\t\tblock = udf_get_lb_pblock(inode->i_sb, &epos->block, 0);\n\t\tepos->bh = udf_tread(inode->i_sb, block);\n\t\tif (!epos->bh) {\n\t\t\tudf_debug(\"reading block %d failed!\\n\", block);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn etype;\n}",
          "includes": [
            "#include \"udf_sb.h\"",
            "#include \"udf_i.h\"",
            "#include <linux/aio.h>",
            "#include <linux/mpage.h>",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int udf_update_inode(struct inode *, int);",
            "static int udf_sync_inode(struct inode *inode);",
            "static int8_t udf_insert_aext(struct inode *, struct extent_position,\n\t\t\t      struct kernel_lb_addr, uint32_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/crc-itu-t.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include \"udfdecl.h\"\n\nstatic int udf_update_inode(struct inode *, int);\nstatic int udf_sync_inode(struct inode *inode);\nstatic int8_t udf_insert_aext(struct inode *, struct extent_position,\n\t\t\t      struct kernel_lb_addr, uint32_t);\n\nint8_t udf_next_aext(struct inode *inode, struct extent_position *epos,\n\t\t     struct kernel_lb_addr *eloc, uint32_t *elen, int inc)\n{\n\tint8_t etype;\n\n\twhile ((etype = udf_current_aext(inode, epos, eloc, elen, inc)) ==\n\t       (EXT_NEXT_EXTENT_ALLOCDECS >> 30)) {\n\t\tint block;\n\t\tepos->block = *eloc;\n\t\tepos->offset = sizeof(struct allocExtDesc);\n\t\tbrelse(epos->bh);\n\t\tblock = udf_get_lb_pblock(inode->i_sb, &epos->block, 0);\n\t\tepos->bh = udf_tread(inode->i_sb, block);\n\t\tif (!epos->bh) {\n\t\t\tudf_debug(\"reading block %d failed!\\n\", block);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn etype;\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_insert_aext",
          "args": [
            "inode",
            "*epos",
            "laarr[i].extLocation",
            "laarr[i].extLength"
          ],
          "line": 1169
        },
        "resolved": true,
        "details": {
          "function_name": "udf_insert_aext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/inode.c",
          "lines": "2133-2152",
          "snippet": "static int8_t udf_insert_aext(struct inode *inode, struct extent_position epos,\n\t\t\t      struct kernel_lb_addr neloc, uint32_t nelen)\n{\n\tstruct kernel_lb_addr oeloc;\n\tuint32_t oelen;\n\tint8_t etype;\n\n\tif (epos.bh)\n\t\tget_bh(epos.bh);\n\n\twhile ((etype = udf_next_aext(inode, &epos, &oeloc, &oelen, 0)) != -1) {\n\t\tudf_write_aext(inode, &epos, &neloc, nelen, 1);\n\t\tneloc = oeloc;\n\t\tnelen = (etype << 30) | oelen;\n\t}\n\tudf_add_aext(inode, &epos, &neloc, nelen, 1);\n\tbrelse(epos.bh);\n\n\treturn (nelen >> 30);\n}",
          "includes": [
            "#include \"udf_sb.h\"",
            "#include \"udf_i.h\"",
            "#include <linux/aio.h>",
            "#include <linux/mpage.h>",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int udf_update_inode(struct inode *, int);",
            "static int udf_sync_inode(struct inode *inode);",
            "static int8_t udf_insert_aext(struct inode *, struct extent_position,\n\t\t\t      struct kernel_lb_addr, uint32_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/crc-itu-t.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include \"udfdecl.h\"\n\nstatic int udf_update_inode(struct inode *, int);\nstatic int udf_sync_inode(struct inode *inode);\nstatic int8_t udf_insert_aext(struct inode *, struct extent_position,\n\t\t\t      struct kernel_lb_addr, uint32_t);\n\nstatic int8_t udf_insert_aext(struct inode *inode, struct extent_position epos,\n\t\t\t      struct kernel_lb_addr neloc, uint32_t nelen)\n{\n\tstruct kernel_lb_addr oeloc;\n\tuint32_t oelen;\n\tint8_t etype;\n\n\tif (epos.bh)\n\t\tget_bh(epos.bh);\n\n\twhile ((etype = udf_next_aext(inode, &epos, &oeloc, &oelen, 0)) != -1) {\n\t\tudf_write_aext(inode, &epos, &neloc, nelen, 1);\n\t\tneloc = oeloc;\n\t\tnelen = (etype << 30) | oelen;\n\t}\n\tudf_add_aext(inode, &epos, &neloc, nelen, 1);\n\tbrelse(epos.bh);\n\n\treturn (nelen >> 30);\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_delete_aext",
          "args": [
            "inode",
            "*epos",
            "laarr[i].extLocation",
            "laarr[i].extLength"
          ],
          "line": 1165
        },
        "resolved": true,
        "details": {
          "function_name": "udf_delete_aext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/inode.c",
          "lines": "2154-2235",
          "snippet": "int8_t udf_delete_aext(struct inode *inode, struct extent_position epos,\n\t\t       struct kernel_lb_addr eloc, uint32_t elen)\n{\n\tstruct extent_position oepos;\n\tint adsize;\n\tint8_t etype;\n\tstruct allocExtDesc *aed;\n\tstruct udf_inode_info *iinfo;\n\n\tif (epos.bh) {\n\t\tget_bh(epos.bh);\n\t\tget_bh(epos.bh);\n\t}\n\n\tiinfo = UDF_I(inode);\n\tif (iinfo->i_alloc_type == ICBTAG_FLAG_AD_SHORT)\n\t\tadsize = sizeof(struct short_ad);\n\telse if (iinfo->i_alloc_type == ICBTAG_FLAG_AD_LONG)\n\t\tadsize = sizeof(struct long_ad);\n\telse\n\t\tadsize = 0;\n\n\toepos = epos;\n\tif (udf_next_aext(inode, &epos, &eloc, &elen, 1) == -1)\n\t\treturn -1;\n\n\twhile ((etype = udf_next_aext(inode, &epos, &eloc, &elen, 1)) != -1) {\n\t\tudf_write_aext(inode, &oepos, &eloc, (etype << 30) | elen, 1);\n\t\tif (oepos.bh != epos.bh) {\n\t\t\toepos.block = epos.block;\n\t\t\tbrelse(oepos.bh);\n\t\t\tget_bh(epos.bh);\n\t\t\toepos.bh = epos.bh;\n\t\t\toepos.offset = epos.offset - adsize;\n\t\t}\n\t}\n\tmemset(&eloc, 0x00, sizeof(struct kernel_lb_addr));\n\telen = 0;\n\n\tif (epos.bh != oepos.bh) {\n\t\tudf_free_blocks(inode->i_sb, inode, &epos.block, 0, 1);\n\t\tudf_write_aext(inode, &oepos, &eloc, elen, 1);\n\t\tudf_write_aext(inode, &oepos, &eloc, elen, 1);\n\t\tif (!oepos.bh) {\n\t\t\tiinfo->i_lenAlloc -= (adsize * 2);\n\t\t\tmark_inode_dirty(inode);\n\t\t} else {\n\t\t\taed = (struct allocExtDesc *)oepos.bh->b_data;\n\t\t\tle32_add_cpu(&aed->lengthAllocDescs, -(2 * adsize));\n\t\t\tif (!UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_STRICT) ||\n\t\t\t    UDF_SB(inode->i_sb)->s_udfrev >= 0x0201)\n\t\t\t\tudf_update_tag(oepos.bh->b_data,\n\t\t\t\t\t\toepos.offset - (2 * adsize));\n\t\t\telse\n\t\t\t\tudf_update_tag(oepos.bh->b_data,\n\t\t\t\t\t\tsizeof(struct allocExtDesc));\n\t\t\tmark_buffer_dirty_inode(oepos.bh, inode);\n\t\t}\n\t} else {\n\t\tudf_write_aext(inode, &oepos, &eloc, elen, 1);\n\t\tif (!oepos.bh) {\n\t\t\tiinfo->i_lenAlloc -= adsize;\n\t\t\tmark_inode_dirty(inode);\n\t\t} else {\n\t\t\taed = (struct allocExtDesc *)oepos.bh->b_data;\n\t\t\tle32_add_cpu(&aed->lengthAllocDescs, -adsize);\n\t\t\tif (!UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_STRICT) ||\n\t\t\t    UDF_SB(inode->i_sb)->s_udfrev >= 0x0201)\n\t\t\t\tudf_update_tag(oepos.bh->b_data,\n\t\t\t\t\t\tepos.offset - adsize);\n\t\t\telse\n\t\t\t\tudf_update_tag(oepos.bh->b_data,\n\t\t\t\t\t\tsizeof(struct allocExtDesc));\n\t\t\tmark_buffer_dirty_inode(oepos.bh, inode);\n\t\t}\n\t}\n\n\tbrelse(epos.bh);\n\tbrelse(oepos.bh);\n\n\treturn (elen >> 30);\n}",
          "includes": [
            "#include \"udf_sb.h\"",
            "#include \"udf_i.h\"",
            "#include <linux/aio.h>",
            "#include <linux/mpage.h>",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int udf_update_inode(struct inode *, int);",
            "static int udf_sync_inode(struct inode *inode);",
            "static int8_t udf_insert_aext(struct inode *, struct extent_position,\n\t\t\t      struct kernel_lb_addr, uint32_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/crc-itu-t.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include \"udfdecl.h\"\n\nstatic int udf_update_inode(struct inode *, int);\nstatic int udf_sync_inode(struct inode *inode);\nstatic int8_t udf_insert_aext(struct inode *, struct extent_position,\n\t\t\t      struct kernel_lb_addr, uint32_t);\n\nint8_t udf_delete_aext(struct inode *inode, struct extent_position epos,\n\t\t       struct kernel_lb_addr eloc, uint32_t elen)\n{\n\tstruct extent_position oepos;\n\tint adsize;\n\tint8_t etype;\n\tstruct allocExtDesc *aed;\n\tstruct udf_inode_info *iinfo;\n\n\tif (epos.bh) {\n\t\tget_bh(epos.bh);\n\t\tget_bh(epos.bh);\n\t}\n\n\tiinfo = UDF_I(inode);\n\tif (iinfo->i_alloc_type == ICBTAG_FLAG_AD_SHORT)\n\t\tadsize = sizeof(struct short_ad);\n\telse if (iinfo->i_alloc_type == ICBTAG_FLAG_AD_LONG)\n\t\tadsize = sizeof(struct long_ad);\n\telse\n\t\tadsize = 0;\n\n\toepos = epos;\n\tif (udf_next_aext(inode, &epos, &eloc, &elen, 1) == -1)\n\t\treturn -1;\n\n\twhile ((etype = udf_next_aext(inode, &epos, &eloc, &elen, 1)) != -1) {\n\t\tudf_write_aext(inode, &oepos, &eloc, (etype << 30) | elen, 1);\n\t\tif (oepos.bh != epos.bh) {\n\t\t\toepos.block = epos.block;\n\t\t\tbrelse(oepos.bh);\n\t\t\tget_bh(epos.bh);\n\t\t\toepos.bh = epos.bh;\n\t\t\toepos.offset = epos.offset - adsize;\n\t\t}\n\t}\n\tmemset(&eloc, 0x00, sizeof(struct kernel_lb_addr));\n\telen = 0;\n\n\tif (epos.bh != oepos.bh) {\n\t\tudf_free_blocks(inode->i_sb, inode, &epos.block, 0, 1);\n\t\tudf_write_aext(inode, &oepos, &eloc, elen, 1);\n\t\tudf_write_aext(inode, &oepos, &eloc, elen, 1);\n\t\tif (!oepos.bh) {\n\t\t\tiinfo->i_lenAlloc -= (adsize * 2);\n\t\t\tmark_inode_dirty(inode);\n\t\t} else {\n\t\t\taed = (struct allocExtDesc *)oepos.bh->b_data;\n\t\t\tle32_add_cpu(&aed->lengthAllocDescs, -(2 * adsize));\n\t\t\tif (!UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_STRICT) ||\n\t\t\t    UDF_SB(inode->i_sb)->s_udfrev >= 0x0201)\n\t\t\t\tudf_update_tag(oepos.bh->b_data,\n\t\t\t\t\t\toepos.offset - (2 * adsize));\n\t\t\telse\n\t\t\t\tudf_update_tag(oepos.bh->b_data,\n\t\t\t\t\t\tsizeof(struct allocExtDesc));\n\t\t\tmark_buffer_dirty_inode(oepos.bh, inode);\n\t\t}\n\t} else {\n\t\tudf_write_aext(inode, &oepos, &eloc, elen, 1);\n\t\tif (!oepos.bh) {\n\t\t\tiinfo->i_lenAlloc -= adsize;\n\t\t\tmark_inode_dirty(inode);\n\t\t} else {\n\t\t\taed = (struct allocExtDesc *)oepos.bh->b_data;\n\t\t\tle32_add_cpu(&aed->lengthAllocDescs, -adsize);\n\t\t\tif (!UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_STRICT) ||\n\t\t\t    UDF_SB(inode->i_sb)->s_udfrev >= 0x0201)\n\t\t\t\tudf_update_tag(oepos.bh->b_data,\n\t\t\t\t\t\tepos.offset - adsize);\n\t\t\telse\n\t\t\t\tudf_update_tag(oepos.bh->b_data,\n\t\t\t\t\t\tsizeof(struct allocExtDesc));\n\t\t\tmark_buffer_dirty_inode(oepos.bh, inode);\n\t\t}\n\t}\n\n\tbrelse(epos.bh);\n\tbrelse(oepos.bh);\n\n\treturn (elen >> 30);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/crc-itu-t.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include \"udfdecl.h\"\n\n#define EXTENT_MERGE_SIZE 5\n\nstatic int udf_update_inode(struct inode *, int);\nstatic int udf_sync_inode(struct inode *inode);\nstatic int8_t udf_insert_aext(struct inode *, struct extent_position,\n\t\t\t      struct kernel_lb_addr, uint32_t);\nstatic void udf_split_extents(struct inode *, int *, int, int,\n\t\t\t      struct kernel_long_ad[EXTENT_MERGE_SIZE], int *);\nstatic void udf_prealloc_extents(struct inode *, int, int,\n\t\t\t\t struct kernel_long_ad[EXTENT_MERGE_SIZE], int *);\nstatic void udf_merge_extents(struct inode *,\n\t\t\t      struct kernel_long_ad[EXTENT_MERGE_SIZE], int *);\nstatic void udf_update_extents(struct inode *,\n\t\t\t       struct kernel_long_ad[EXTENT_MERGE_SIZE], int, int,\n\t\t\t       struct extent_position *);\n\nstatic void udf_update_extents(struct inode *inode,\n\t\t\t       struct kernel_long_ad laarr[EXTENT_MERGE_SIZE],\n\t\t\t       int startnum, int endnum,\n\t\t\t       struct extent_position *epos)\n{\n\tint start = 0, i;\n\tstruct kernel_lb_addr tmploc;\n\tuint32_t tmplen;\n\n\tif (startnum > endnum) {\n\t\tfor (i = 0; i < (startnum - endnum); i++)\n\t\t\tudf_delete_aext(inode, *epos, laarr[i].extLocation,\n\t\t\t\t\tlaarr[i].extLength);\n\t} else if (startnum < endnum) {\n\t\tfor (i = 0; i < (endnum - startnum); i++) {\n\t\t\tudf_insert_aext(inode, *epos, laarr[i].extLocation,\n\t\t\t\t\tlaarr[i].extLength);\n\t\t\tudf_next_aext(inode, epos, &laarr[i].extLocation,\n\t\t\t\t      &laarr[i].extLength, 1);\n\t\t\tstart++;\n\t\t}\n\t}\n\n\tfor (i = start; i < endnum; i++) {\n\t\tudf_next_aext(inode, epos, &tmploc, &tmplen, 0);\n\t\tudf_write_aext(inode, epos, &laarr[i].extLocation,\n\t\t\t       laarr[i].extLength, 1);\n\t}\n}"
  },
  {
    "function_name": "udf_merge_extents",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/inode.c",
    "lines": "1054-1152",
    "snippet": "static void udf_merge_extents(struct inode *inode,\n\t\t\t      struct kernel_long_ad laarr[EXTENT_MERGE_SIZE],\n\t\t\t      int *endnum)\n{\n\tint i;\n\tunsigned long blocksize = inode->i_sb->s_blocksize;\n\tunsigned char blocksize_bits = inode->i_sb->s_blocksize_bits;\n\n\tfor (i = 0; i < (*endnum - 1); i++) {\n\t\tstruct kernel_long_ad *li /*l[i]*/ = &laarr[i];\n\t\tstruct kernel_long_ad *lip1 /*l[i plus 1]*/ = &laarr[i + 1];\n\n\t\tif (((li->extLength >> 30) == (lip1->extLength >> 30)) &&\n\t\t\t(((li->extLength >> 30) ==\n\t\t\t\t(EXT_NOT_RECORDED_NOT_ALLOCATED >> 30)) ||\n\t\t\t((lip1->extLocation.logicalBlockNum -\n\t\t\t  li->extLocation.logicalBlockNum) ==\n\t\t\t(((li->extLength & UDF_EXTENT_LENGTH_MASK) +\n\t\t\tblocksize - 1) >> blocksize_bits)))) {\n\n\t\t\tif (((li->extLength & UDF_EXTENT_LENGTH_MASK) +\n\t\t\t\t(lip1->extLength & UDF_EXTENT_LENGTH_MASK) +\n\t\t\t\tblocksize - 1) & ~UDF_EXTENT_LENGTH_MASK) {\n\t\t\t\tlip1->extLength = (lip1->extLength -\n\t\t\t\t\t\t  (li->extLength &\n\t\t\t\t\t\t   UDF_EXTENT_LENGTH_MASK) +\n\t\t\t\t\t\t   UDF_EXTENT_LENGTH_MASK) &\n\t\t\t\t\t\t\t~(blocksize - 1);\n\t\t\t\tli->extLength = (li->extLength &\n\t\t\t\t\t\t UDF_EXTENT_FLAG_MASK) +\n\t\t\t\t\t\t(UDF_EXTENT_LENGTH_MASK + 1) -\n\t\t\t\t\t\tblocksize;\n\t\t\t\tlip1->extLocation.logicalBlockNum =\n\t\t\t\t\tli->extLocation.logicalBlockNum +\n\t\t\t\t\t((li->extLength &\n\t\t\t\t\t\tUDF_EXTENT_LENGTH_MASK) >>\n\t\t\t\t\t\tblocksize_bits);\n\t\t\t} else {\n\t\t\t\tli->extLength = lip1->extLength +\n\t\t\t\t\t(((li->extLength &\n\t\t\t\t\t\tUDF_EXTENT_LENGTH_MASK) +\n\t\t\t\t\t blocksize - 1) & ~(blocksize - 1));\n\t\t\t\tif (*endnum > (i + 2))\n\t\t\t\t\tmemmove(&laarr[i + 1], &laarr[i + 2],\n\t\t\t\t\t\tsizeof(struct long_ad) *\n\t\t\t\t\t\t(*endnum - (i + 2)));\n\t\t\t\ti--;\n\t\t\t\t(*endnum)--;\n\t\t\t}\n\t\t} else if (((li->extLength >> 30) ==\n\t\t\t\t(EXT_NOT_RECORDED_ALLOCATED >> 30)) &&\n\t\t\t   ((lip1->extLength >> 30) ==\n\t\t\t\t(EXT_NOT_RECORDED_NOT_ALLOCATED >> 30))) {\n\t\t\tudf_free_blocks(inode->i_sb, inode, &li->extLocation, 0,\n\t\t\t\t\t((li->extLength &\n\t\t\t\t\t  UDF_EXTENT_LENGTH_MASK) +\n\t\t\t\t\t blocksize - 1) >> blocksize_bits);\n\t\t\tli->extLocation.logicalBlockNum = 0;\n\t\t\tli->extLocation.partitionReferenceNum = 0;\n\n\t\t\tif (((li->extLength & UDF_EXTENT_LENGTH_MASK) +\n\t\t\t     (lip1->extLength & UDF_EXTENT_LENGTH_MASK) +\n\t\t\t     blocksize - 1) & ~UDF_EXTENT_LENGTH_MASK) {\n\t\t\t\tlip1->extLength = (lip1->extLength -\n\t\t\t\t\t\t   (li->extLength &\n\t\t\t\t\t\t   UDF_EXTENT_LENGTH_MASK) +\n\t\t\t\t\t\t   UDF_EXTENT_LENGTH_MASK) &\n\t\t\t\t\t\t   ~(blocksize - 1);\n\t\t\t\tli->extLength = (li->extLength &\n\t\t\t\t\t\t UDF_EXTENT_FLAG_MASK) +\n\t\t\t\t\t\t(UDF_EXTENT_LENGTH_MASK + 1) -\n\t\t\t\t\t\tblocksize;\n\t\t\t} else {\n\t\t\t\tli->extLength = lip1->extLength +\n\t\t\t\t\t(((li->extLength &\n\t\t\t\t\t\tUDF_EXTENT_LENGTH_MASK) +\n\t\t\t\t\t  blocksize - 1) & ~(blocksize - 1));\n\t\t\t\tif (*endnum > (i + 2))\n\t\t\t\t\tmemmove(&laarr[i + 1], &laarr[i + 2],\n\t\t\t\t\t\tsizeof(struct long_ad) *\n\t\t\t\t\t\t(*endnum - (i + 2)));\n\t\t\t\ti--;\n\t\t\t\t(*endnum)--;\n\t\t\t}\n\t\t} else if ((li->extLength >> 30) ==\n\t\t\t\t\t(EXT_NOT_RECORDED_ALLOCATED >> 30)) {\n\t\t\tudf_free_blocks(inode->i_sb, inode,\n\t\t\t\t\t&li->extLocation, 0,\n\t\t\t\t\t((li->extLength &\n\t\t\t\t\t\tUDF_EXTENT_LENGTH_MASK) +\n\t\t\t\t\t blocksize - 1) >> blocksize_bits);\n\t\t\tli->extLocation.logicalBlockNum = 0;\n\t\t\tli->extLocation.partitionReferenceNum = 0;\n\t\t\tli->extLength = (li->extLength &\n\t\t\t\t\t\tUDF_EXTENT_LENGTH_MASK) |\n\t\t\t\t\t\tEXT_NOT_RECORDED_NOT_ALLOCATED;\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"udf_sb.h\"",
      "#include \"udf_i.h\"",
      "#include <linux/aio.h>",
      "#include <linux/mpage.h>",
      "#include <linux/crc-itu-t.h>",
      "#include <linux/slab.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include \"udfdecl.h\""
    ],
    "macros_used": [
      "#define EXTENT_MERGE_SIZE 5"
    ],
    "globals_used": [
      "static int udf_update_inode(struct inode *, int);",
      "static int udf_sync_inode(struct inode *inode);",
      "static void udf_split_extents(struct inode *, int *, int, int,\n\t\t\t      struct kernel_long_ad[EXTENT_MERGE_SIZE], int *);",
      "static void udf_prealloc_extents(struct inode *, int, int,\n\t\t\t\t struct kernel_long_ad[EXTENT_MERGE_SIZE], int *);",
      "static void udf_merge_extents(struct inode *,\n\t\t\t      struct kernel_long_ad[EXTENT_MERGE_SIZE], int *);",
      "static void udf_update_extents(struct inode *,\n\t\t\t       struct kernel_long_ad[EXTENT_MERGE_SIZE], int, int,\n\t\t\t       struct extent_position *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "udf_free_blocks",
          "args": [
            "inode->i_sb",
            "inode",
            "&li->extLocation",
            "0",
            "((li->extLength &\n\t\t\t\t\t\tUDF_EXTENT_LENGTH_MASK) +\n\t\t\t\t\t blocksize - 1) >> blocksize_bits"
          ],
          "line": 1140
        },
        "resolved": true,
        "details": {
          "function_name": "udf_free_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/balloc.c",
          "lines": "732-757",
          "snippet": "void udf_free_blocks(struct super_block *sb, struct inode *inode,\n\t\t     struct kernel_lb_addr *bloc, uint32_t offset,\n\t\t     uint32_t count)\n{\n\tuint16_t partition = bloc->partitionReferenceNum;\n\tstruct udf_part_map *map = &UDF_SB(sb)->s_partmaps[partition];\n\n\tif (map->s_partition_flags & UDF_PART_FLAG_UNALLOC_BITMAP) {\n\t\tudf_bitmap_free_blocks(sb, map->s_uspace.s_bitmap,\n\t\t\t\t       bloc, offset, count);\n\t} else if (map->s_partition_flags & UDF_PART_FLAG_UNALLOC_TABLE) {\n\t\tudf_table_free_blocks(sb, map->s_uspace.s_table,\n\t\t\t\t      bloc, offset, count);\n\t} else if (map->s_partition_flags & UDF_PART_FLAG_FREED_BITMAP) {\n\t\tudf_bitmap_free_blocks(sb, map->s_fspace.s_bitmap,\n\t\t\t\t       bloc, offset, count);\n\t} else if (map->s_partition_flags & UDF_PART_FLAG_FREED_TABLE) {\n\t\tudf_table_free_blocks(sb, map->s_fspace.s_table,\n\t\t\t\t      bloc, offset, count);\n\t}\n\n\tif (inode) {\n\t\tinode_sub_bytes(inode,\n\t\t\t\t((sector_t)count) << sb->s_blocksize_bits);\n\t}\n}",
          "includes": [
            "#include \"udf_sb.h\"",
            "#include \"udf_i.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/buffer_head.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/bitops.h>\n#include <linux/buffer_head.h>\n#include \"udfdecl.h\"\n\nvoid udf_free_blocks(struct super_block *sb, struct inode *inode,\n\t\t     struct kernel_lb_addr *bloc, uint32_t offset,\n\t\t     uint32_t count)\n{\n\tuint16_t partition = bloc->partitionReferenceNum;\n\tstruct udf_part_map *map = &UDF_SB(sb)->s_partmaps[partition];\n\n\tif (map->s_partition_flags & UDF_PART_FLAG_UNALLOC_BITMAP) {\n\t\tudf_bitmap_free_blocks(sb, map->s_uspace.s_bitmap,\n\t\t\t\t       bloc, offset, count);\n\t} else if (map->s_partition_flags & UDF_PART_FLAG_UNALLOC_TABLE) {\n\t\tudf_table_free_blocks(sb, map->s_uspace.s_table,\n\t\t\t\t      bloc, offset, count);\n\t} else if (map->s_partition_flags & UDF_PART_FLAG_FREED_BITMAP) {\n\t\tudf_bitmap_free_blocks(sb, map->s_fspace.s_bitmap,\n\t\t\t\t       bloc, offset, count);\n\t} else if (map->s_partition_flags & UDF_PART_FLAG_FREED_TABLE) {\n\t\tudf_table_free_blocks(sb, map->s_fspace.s_table,\n\t\t\t\t      bloc, offset, count);\n\t}\n\n\tif (inode) {\n\t\tinode_sub_bytes(inode,\n\t\t\t\t((sector_t)count) << sb->s_blocksize_bits);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "&laarr[i + 1]",
            "&laarr[i + 2]",
            "sizeof(struct long_ad) *\n\t\t\t\t\t\t(*endnum - (i + 2))"
          ],
          "line": 1132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "&laarr[i + 1]",
            "&laarr[i + 2]",
            "sizeof(struct long_ad) *\n\t\t\t\t\t\t(*endnum - (i + 2))"
          ],
          "line": 1097
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/crc-itu-t.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include \"udfdecl.h\"\n\n#define EXTENT_MERGE_SIZE 5\n\nstatic int udf_update_inode(struct inode *, int);\nstatic int udf_sync_inode(struct inode *inode);\nstatic void udf_split_extents(struct inode *, int *, int, int,\n\t\t\t      struct kernel_long_ad[EXTENT_MERGE_SIZE], int *);\nstatic void udf_prealloc_extents(struct inode *, int, int,\n\t\t\t\t struct kernel_long_ad[EXTENT_MERGE_SIZE], int *);\nstatic void udf_merge_extents(struct inode *,\n\t\t\t      struct kernel_long_ad[EXTENT_MERGE_SIZE], int *);\nstatic void udf_update_extents(struct inode *,\n\t\t\t       struct kernel_long_ad[EXTENT_MERGE_SIZE], int, int,\n\t\t\t       struct extent_position *);\n\nstatic void udf_merge_extents(struct inode *inode,\n\t\t\t      struct kernel_long_ad laarr[EXTENT_MERGE_SIZE],\n\t\t\t      int *endnum)\n{\n\tint i;\n\tunsigned long blocksize = inode->i_sb->s_blocksize;\n\tunsigned char blocksize_bits = inode->i_sb->s_blocksize_bits;\n\n\tfor (i = 0; i < (*endnum - 1); i++) {\n\t\tstruct kernel_long_ad *li /*l[i]*/ = &laarr[i];\n\t\tstruct kernel_long_ad *lip1 /*l[i plus 1]*/ = &laarr[i + 1];\n\n\t\tif (((li->extLength >> 30) == (lip1->extLength >> 30)) &&\n\t\t\t(((li->extLength >> 30) ==\n\t\t\t\t(EXT_NOT_RECORDED_NOT_ALLOCATED >> 30)) ||\n\t\t\t((lip1->extLocation.logicalBlockNum -\n\t\t\t  li->extLocation.logicalBlockNum) ==\n\t\t\t(((li->extLength & UDF_EXTENT_LENGTH_MASK) +\n\t\t\tblocksize - 1) >> blocksize_bits)))) {\n\n\t\t\tif (((li->extLength & UDF_EXTENT_LENGTH_MASK) +\n\t\t\t\t(lip1->extLength & UDF_EXTENT_LENGTH_MASK) +\n\t\t\t\tblocksize - 1) & ~UDF_EXTENT_LENGTH_MASK) {\n\t\t\t\tlip1->extLength = (lip1->extLength -\n\t\t\t\t\t\t  (li->extLength &\n\t\t\t\t\t\t   UDF_EXTENT_LENGTH_MASK) +\n\t\t\t\t\t\t   UDF_EXTENT_LENGTH_MASK) &\n\t\t\t\t\t\t\t~(blocksize - 1);\n\t\t\t\tli->extLength = (li->extLength &\n\t\t\t\t\t\t UDF_EXTENT_FLAG_MASK) +\n\t\t\t\t\t\t(UDF_EXTENT_LENGTH_MASK + 1) -\n\t\t\t\t\t\tblocksize;\n\t\t\t\tlip1->extLocation.logicalBlockNum =\n\t\t\t\t\tli->extLocation.logicalBlockNum +\n\t\t\t\t\t((li->extLength &\n\t\t\t\t\t\tUDF_EXTENT_LENGTH_MASK) >>\n\t\t\t\t\t\tblocksize_bits);\n\t\t\t} else {\n\t\t\t\tli->extLength = lip1->extLength +\n\t\t\t\t\t(((li->extLength &\n\t\t\t\t\t\tUDF_EXTENT_LENGTH_MASK) +\n\t\t\t\t\t blocksize - 1) & ~(blocksize - 1));\n\t\t\t\tif (*endnum > (i + 2))\n\t\t\t\t\tmemmove(&laarr[i + 1], &laarr[i + 2],\n\t\t\t\t\t\tsizeof(struct long_ad) *\n\t\t\t\t\t\t(*endnum - (i + 2)));\n\t\t\t\ti--;\n\t\t\t\t(*endnum)--;\n\t\t\t}\n\t\t} else if (((li->extLength >> 30) ==\n\t\t\t\t(EXT_NOT_RECORDED_ALLOCATED >> 30)) &&\n\t\t\t   ((lip1->extLength >> 30) ==\n\t\t\t\t(EXT_NOT_RECORDED_NOT_ALLOCATED >> 30))) {\n\t\t\tudf_free_blocks(inode->i_sb, inode, &li->extLocation, 0,\n\t\t\t\t\t((li->extLength &\n\t\t\t\t\t  UDF_EXTENT_LENGTH_MASK) +\n\t\t\t\t\t blocksize - 1) >> blocksize_bits);\n\t\t\tli->extLocation.logicalBlockNum = 0;\n\t\t\tli->extLocation.partitionReferenceNum = 0;\n\n\t\t\tif (((li->extLength & UDF_EXTENT_LENGTH_MASK) +\n\t\t\t     (lip1->extLength & UDF_EXTENT_LENGTH_MASK) +\n\t\t\t     blocksize - 1) & ~UDF_EXTENT_LENGTH_MASK) {\n\t\t\t\tlip1->extLength = (lip1->extLength -\n\t\t\t\t\t\t   (li->extLength &\n\t\t\t\t\t\t   UDF_EXTENT_LENGTH_MASK) +\n\t\t\t\t\t\t   UDF_EXTENT_LENGTH_MASK) &\n\t\t\t\t\t\t   ~(blocksize - 1);\n\t\t\t\tli->extLength = (li->extLength &\n\t\t\t\t\t\t UDF_EXTENT_FLAG_MASK) +\n\t\t\t\t\t\t(UDF_EXTENT_LENGTH_MASK + 1) -\n\t\t\t\t\t\tblocksize;\n\t\t\t} else {\n\t\t\t\tli->extLength = lip1->extLength +\n\t\t\t\t\t(((li->extLength &\n\t\t\t\t\t\tUDF_EXTENT_LENGTH_MASK) +\n\t\t\t\t\t  blocksize - 1) & ~(blocksize - 1));\n\t\t\t\tif (*endnum > (i + 2))\n\t\t\t\t\tmemmove(&laarr[i + 1], &laarr[i + 2],\n\t\t\t\t\t\tsizeof(struct long_ad) *\n\t\t\t\t\t\t(*endnum - (i + 2)));\n\t\t\t\ti--;\n\t\t\t\t(*endnum)--;\n\t\t\t}\n\t\t} else if ((li->extLength >> 30) ==\n\t\t\t\t\t(EXT_NOT_RECORDED_ALLOCATED >> 30)) {\n\t\t\tudf_free_blocks(inode->i_sb, inode,\n\t\t\t\t\t&li->extLocation, 0,\n\t\t\t\t\t((li->extLength &\n\t\t\t\t\t\tUDF_EXTENT_LENGTH_MASK) +\n\t\t\t\t\t blocksize - 1) >> blocksize_bits);\n\t\t\tli->extLocation.logicalBlockNum = 0;\n\t\t\tli->extLocation.partitionReferenceNum = 0;\n\t\t\tli->extLength = (li->extLength &\n\t\t\t\t\t\tUDF_EXTENT_LENGTH_MASK) |\n\t\t\t\t\t\tEXT_NOT_RECORDED_NOT_ALLOCATED;\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "udf_prealloc_extents",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/inode.c",
    "lines": "958-1052",
    "snippet": "static void udf_prealloc_extents(struct inode *inode, int c, int lastblock,\n\t\t\t\t struct kernel_long_ad laarr[EXTENT_MERGE_SIZE],\n\t\t\t\t int *endnum)\n{\n\tint start, length = 0, currlength = 0, i;\n\n\tif (*endnum >= (c + 1)) {\n\t\tif (!lastblock)\n\t\t\treturn;\n\t\telse\n\t\t\tstart = c;\n\t} else {\n\t\tif ((laarr[c + 1].extLength >> 30) ==\n\t\t\t\t\t(EXT_NOT_RECORDED_ALLOCATED >> 30)) {\n\t\t\tstart = c + 1;\n\t\t\tlength = currlength =\n\t\t\t\t(((laarr[c + 1].extLength &\n\t\t\t\t\tUDF_EXTENT_LENGTH_MASK) +\n\t\t\t\tinode->i_sb->s_blocksize - 1) >>\n\t\t\t\tinode->i_sb->s_blocksize_bits);\n\t\t} else\n\t\t\tstart = c;\n\t}\n\n\tfor (i = start + 1; i <= *endnum; i++) {\n\t\tif (i == *endnum) {\n\t\t\tif (lastblock)\n\t\t\t\tlength += UDF_DEFAULT_PREALLOC_BLOCKS;\n\t\t} else if ((laarr[i].extLength >> 30) ==\n\t\t\t\t(EXT_NOT_RECORDED_NOT_ALLOCATED >> 30)) {\n\t\t\tlength += (((laarr[i].extLength &\n\t\t\t\t\t\tUDF_EXTENT_LENGTH_MASK) +\n\t\t\t\t    inode->i_sb->s_blocksize - 1) >>\n\t\t\t\t    inode->i_sb->s_blocksize_bits);\n\t\t} else\n\t\t\tbreak;\n\t}\n\n\tif (length) {\n\t\tint next = laarr[start].extLocation.logicalBlockNum +\n\t\t\t(((laarr[start].extLength & UDF_EXTENT_LENGTH_MASK) +\n\t\t\t  inode->i_sb->s_blocksize - 1) >>\n\t\t\t  inode->i_sb->s_blocksize_bits);\n\t\tint numalloc = udf_prealloc_blocks(inode->i_sb, inode,\n\t\t\t\tlaarr[start].extLocation.partitionReferenceNum,\n\t\t\t\tnext, (UDF_DEFAULT_PREALLOC_BLOCKS > length ?\n\t\t\t\tlength : UDF_DEFAULT_PREALLOC_BLOCKS) -\n\t\t\t\tcurrlength);\n\t\tif (numalloc) \t{\n\t\t\tif (start == (c + 1))\n\t\t\t\tlaarr[start].extLength +=\n\t\t\t\t\t(numalloc <<\n\t\t\t\t\t inode->i_sb->s_blocksize_bits);\n\t\t\telse {\n\t\t\t\tmemmove(&laarr[c + 2], &laarr[c + 1],\n\t\t\t\t\tsizeof(struct long_ad) * (*endnum - (c + 1)));\n\t\t\t\t(*endnum)++;\n\t\t\t\tlaarr[c + 1].extLocation.logicalBlockNum = next;\n\t\t\t\tlaarr[c + 1].extLocation.partitionReferenceNum =\n\t\t\t\t\tlaarr[c].extLocation.\n\t\t\t\t\t\t\tpartitionReferenceNum;\n\t\t\t\tlaarr[c + 1].extLength =\n\t\t\t\t\tEXT_NOT_RECORDED_ALLOCATED |\n\t\t\t\t\t(numalloc <<\n\t\t\t\t\t inode->i_sb->s_blocksize_bits);\n\t\t\t\tstart = c + 1;\n\t\t\t}\n\n\t\t\tfor (i = start + 1; numalloc && i < *endnum; i++) {\n\t\t\t\tint elen = ((laarr[i].extLength &\n\t\t\t\t\t\tUDF_EXTENT_LENGTH_MASK) +\n\t\t\t\t\t    inode->i_sb->s_blocksize - 1) >>\n\t\t\t\t\t    inode->i_sb->s_blocksize_bits;\n\n\t\t\t\tif (elen > numalloc) {\n\t\t\t\t\tlaarr[i].extLength -=\n\t\t\t\t\t\t(numalloc <<\n\t\t\t\t\t\t inode->i_sb->s_blocksize_bits);\n\t\t\t\t\tnumalloc = 0;\n\t\t\t\t} else {\n\t\t\t\t\tnumalloc -= elen;\n\t\t\t\t\tif (*endnum > (i + 1))\n\t\t\t\t\t\tmemmove(&laarr[i],\n\t\t\t\t\t\t\t&laarr[i + 1],\n\t\t\t\t\t\t\tsizeof(struct long_ad) *\n\t\t\t\t\t\t\t(*endnum - (i + 1)));\n\t\t\t\t\ti--;\n\t\t\t\t\t(*endnum)--;\n\t\t\t\t}\n\t\t\t}\n\t\t\tUDF_I(inode)->i_lenExtents +=\n\t\t\t\tnumalloc << inode->i_sb->s_blocksize_bits;\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"udf_sb.h\"",
      "#include \"udf_i.h\"",
      "#include <linux/aio.h>",
      "#include <linux/mpage.h>",
      "#include <linux/crc-itu-t.h>",
      "#include <linux/slab.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include \"udfdecl.h\""
    ],
    "macros_used": [
      "#define EXTENT_MERGE_SIZE 5"
    ],
    "globals_used": [
      "static int udf_update_inode(struct inode *, int);",
      "static int udf_sync_inode(struct inode *inode);",
      "static void udf_split_extents(struct inode *, int *, int, int,\n\t\t\t      struct kernel_long_ad[EXTENT_MERGE_SIZE], int *);",
      "static void udf_prealloc_extents(struct inode *, int, int,\n\t\t\t\t struct kernel_long_ad[EXTENT_MERGE_SIZE], int *);",
      "static void udf_merge_extents(struct inode *,\n\t\t\t      struct kernel_long_ad[EXTENT_MERGE_SIZE], int *);",
      "static void udf_update_extents(struct inode *,\n\t\t\t       struct kernel_long_ad[EXTENT_MERGE_SIZE], int, int,\n\t\t\t       struct extent_position *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "UDF_I",
          "args": [
            "inode"
          ],
          "line": 1048
        },
        "resolved": true,
        "details": {
          "function_name": "UDF_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/udf_i.h",
          "lines": "57-60",
          "snippet": "static inline struct udf_inode_info *UDF_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct udf_inode_info, vfs_inode);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline struct udf_inode_info *UDF_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct udf_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "&laarr[i]",
            "&laarr[i + 1]",
            "sizeof(struct long_ad) *\n\t\t\t\t\t\t\t(*endnum - (i + 1))"
          ],
          "line": 1040
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "&laarr[c + 2]",
            "&laarr[c + 1]",
            "sizeof(struct long_ad) * (*endnum - (c + 1))"
          ],
          "line": 1012
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udf_prealloc_blocks",
          "args": [
            "inode->i_sb",
            "inode",
            "laarr[start].extLocation.partitionReferenceNum",
            "next",
            "(UDF_DEFAULT_PREALLOC_BLOCKS > length ?\n\t\t\t\tlength : UDF_DEFAULT_PREALLOC_BLOCKS) -\n\t\t\t\tcurrlength"
          ],
          "line": 1001
        },
        "resolved": true,
        "details": {
          "function_name": "udf_prealloc_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/balloc.c",
          "lines": "759-793",
          "snippet": "inline int udf_prealloc_blocks(struct super_block *sb,\n\t\t\t       struct inode *inode,\n\t\t\t       uint16_t partition, uint32_t first_block,\n\t\t\t       uint32_t block_count)\n{\n\tstruct udf_part_map *map = &UDF_SB(sb)->s_partmaps[partition];\n\tsector_t allocated;\n\n\tif (map->s_partition_flags & UDF_PART_FLAG_UNALLOC_BITMAP)\n\t\tallocated = udf_bitmap_prealloc_blocks(sb,\n\t\t\t\t\t\t       map->s_uspace.s_bitmap,\n\t\t\t\t\t\t       partition, first_block,\n\t\t\t\t\t\t       block_count);\n\telse if (map->s_partition_flags & UDF_PART_FLAG_UNALLOC_TABLE)\n\t\tallocated = udf_table_prealloc_blocks(sb,\n\t\t\t\t\t\t      map->s_uspace.s_table,\n\t\t\t\t\t\t      partition, first_block,\n\t\t\t\t\t\t      block_count);\n\telse if (map->s_partition_flags & UDF_PART_FLAG_FREED_BITMAP)\n\t\tallocated = udf_bitmap_prealloc_blocks(sb,\n\t\t\t\t\t\t       map->s_fspace.s_bitmap,\n\t\t\t\t\t\t       partition, first_block,\n\t\t\t\t\t\t       block_count);\n\telse if (map->s_partition_flags & UDF_PART_FLAG_FREED_TABLE)\n\t\tallocated = udf_table_prealloc_blocks(sb,\n\t\t\t\t\t\t      map->s_fspace.s_table,\n\t\t\t\t\t\t      partition, first_block,\n\t\t\t\t\t\t      block_count);\n\telse\n\t\treturn 0;\n\n\tif (inode && allocated > 0)\n\t\tinode_add_bytes(inode, allocated << sb->s_blocksize_bits);\n\treturn allocated;\n}",
          "includes": [
            "#include \"udf_sb.h\"",
            "#include \"udf_i.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/buffer_head.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/bitops.h>\n#include <linux/buffer_head.h>\n#include \"udfdecl.h\"\n\ninline int udf_prealloc_blocks(struct super_block *sb,\n\t\t\t       struct inode *inode,\n\t\t\t       uint16_t partition, uint32_t first_block,\n\t\t\t       uint32_t block_count)\n{\n\tstruct udf_part_map *map = &UDF_SB(sb)->s_partmaps[partition];\n\tsector_t allocated;\n\n\tif (map->s_partition_flags & UDF_PART_FLAG_UNALLOC_BITMAP)\n\t\tallocated = udf_bitmap_prealloc_blocks(sb,\n\t\t\t\t\t\t       map->s_uspace.s_bitmap,\n\t\t\t\t\t\t       partition, first_block,\n\t\t\t\t\t\t       block_count);\n\telse if (map->s_partition_flags & UDF_PART_FLAG_UNALLOC_TABLE)\n\t\tallocated = udf_table_prealloc_blocks(sb,\n\t\t\t\t\t\t      map->s_uspace.s_table,\n\t\t\t\t\t\t      partition, first_block,\n\t\t\t\t\t\t      block_count);\n\telse if (map->s_partition_flags & UDF_PART_FLAG_FREED_BITMAP)\n\t\tallocated = udf_bitmap_prealloc_blocks(sb,\n\t\t\t\t\t\t       map->s_fspace.s_bitmap,\n\t\t\t\t\t\t       partition, first_block,\n\t\t\t\t\t\t       block_count);\n\telse if (map->s_partition_flags & UDF_PART_FLAG_FREED_TABLE)\n\t\tallocated = udf_table_prealloc_blocks(sb,\n\t\t\t\t\t\t      map->s_fspace.s_table,\n\t\t\t\t\t\t      partition, first_block,\n\t\t\t\t\t\t      block_count);\n\telse\n\t\treturn 0;\n\n\tif (inode && allocated > 0)\n\t\tinode_add_bytes(inode, allocated << sb->s_blocksize_bits);\n\treturn allocated;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/crc-itu-t.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include \"udfdecl.h\"\n\n#define EXTENT_MERGE_SIZE 5\n\nstatic int udf_update_inode(struct inode *, int);\nstatic int udf_sync_inode(struct inode *inode);\nstatic void udf_split_extents(struct inode *, int *, int, int,\n\t\t\t      struct kernel_long_ad[EXTENT_MERGE_SIZE], int *);\nstatic void udf_prealloc_extents(struct inode *, int, int,\n\t\t\t\t struct kernel_long_ad[EXTENT_MERGE_SIZE], int *);\nstatic void udf_merge_extents(struct inode *,\n\t\t\t      struct kernel_long_ad[EXTENT_MERGE_SIZE], int *);\nstatic void udf_update_extents(struct inode *,\n\t\t\t       struct kernel_long_ad[EXTENT_MERGE_SIZE], int, int,\n\t\t\t       struct extent_position *);\n\nstatic void udf_prealloc_extents(struct inode *inode, int c, int lastblock,\n\t\t\t\t struct kernel_long_ad laarr[EXTENT_MERGE_SIZE],\n\t\t\t\t int *endnum)\n{\n\tint start, length = 0, currlength = 0, i;\n\n\tif (*endnum >= (c + 1)) {\n\t\tif (!lastblock)\n\t\t\treturn;\n\t\telse\n\t\t\tstart = c;\n\t} else {\n\t\tif ((laarr[c + 1].extLength >> 30) ==\n\t\t\t\t\t(EXT_NOT_RECORDED_ALLOCATED >> 30)) {\n\t\t\tstart = c + 1;\n\t\t\tlength = currlength =\n\t\t\t\t(((laarr[c + 1].extLength &\n\t\t\t\t\tUDF_EXTENT_LENGTH_MASK) +\n\t\t\t\tinode->i_sb->s_blocksize - 1) >>\n\t\t\t\tinode->i_sb->s_blocksize_bits);\n\t\t} else\n\t\t\tstart = c;\n\t}\n\n\tfor (i = start + 1; i <= *endnum; i++) {\n\t\tif (i == *endnum) {\n\t\t\tif (lastblock)\n\t\t\t\tlength += UDF_DEFAULT_PREALLOC_BLOCKS;\n\t\t} else if ((laarr[i].extLength >> 30) ==\n\t\t\t\t(EXT_NOT_RECORDED_NOT_ALLOCATED >> 30)) {\n\t\t\tlength += (((laarr[i].extLength &\n\t\t\t\t\t\tUDF_EXTENT_LENGTH_MASK) +\n\t\t\t\t    inode->i_sb->s_blocksize - 1) >>\n\t\t\t\t    inode->i_sb->s_blocksize_bits);\n\t\t} else\n\t\t\tbreak;\n\t}\n\n\tif (length) {\n\t\tint next = laarr[start].extLocation.logicalBlockNum +\n\t\t\t(((laarr[start].extLength & UDF_EXTENT_LENGTH_MASK) +\n\t\t\t  inode->i_sb->s_blocksize - 1) >>\n\t\t\t  inode->i_sb->s_blocksize_bits);\n\t\tint numalloc = udf_prealloc_blocks(inode->i_sb, inode,\n\t\t\t\tlaarr[start].extLocation.partitionReferenceNum,\n\t\t\t\tnext, (UDF_DEFAULT_PREALLOC_BLOCKS > length ?\n\t\t\t\tlength : UDF_DEFAULT_PREALLOC_BLOCKS) -\n\t\t\t\tcurrlength);\n\t\tif (numalloc) \t{\n\t\t\tif (start == (c + 1))\n\t\t\t\tlaarr[start].extLength +=\n\t\t\t\t\t(numalloc <<\n\t\t\t\t\t inode->i_sb->s_blocksize_bits);\n\t\t\telse {\n\t\t\t\tmemmove(&laarr[c + 2], &laarr[c + 1],\n\t\t\t\t\tsizeof(struct long_ad) * (*endnum - (c + 1)));\n\t\t\t\t(*endnum)++;\n\t\t\t\tlaarr[c + 1].extLocation.logicalBlockNum = next;\n\t\t\t\tlaarr[c + 1].extLocation.partitionReferenceNum =\n\t\t\t\t\tlaarr[c].extLocation.\n\t\t\t\t\t\t\tpartitionReferenceNum;\n\t\t\t\tlaarr[c + 1].extLength =\n\t\t\t\t\tEXT_NOT_RECORDED_ALLOCATED |\n\t\t\t\t\t(numalloc <<\n\t\t\t\t\t inode->i_sb->s_blocksize_bits);\n\t\t\t\tstart = c + 1;\n\t\t\t}\n\n\t\t\tfor (i = start + 1; numalloc && i < *endnum; i++) {\n\t\t\t\tint elen = ((laarr[i].extLength &\n\t\t\t\t\t\tUDF_EXTENT_LENGTH_MASK) +\n\t\t\t\t\t    inode->i_sb->s_blocksize - 1) >>\n\t\t\t\t\t    inode->i_sb->s_blocksize_bits;\n\n\t\t\t\tif (elen > numalloc) {\n\t\t\t\t\tlaarr[i].extLength -=\n\t\t\t\t\t\t(numalloc <<\n\t\t\t\t\t\t inode->i_sb->s_blocksize_bits);\n\t\t\t\t\tnumalloc = 0;\n\t\t\t\t} else {\n\t\t\t\t\tnumalloc -= elen;\n\t\t\t\t\tif (*endnum > (i + 1))\n\t\t\t\t\t\tmemmove(&laarr[i],\n\t\t\t\t\t\t\t&laarr[i + 1],\n\t\t\t\t\t\t\tsizeof(struct long_ad) *\n\t\t\t\t\t\t\t(*endnum - (i + 1)));\n\t\t\t\t\ti--;\n\t\t\t\t\t(*endnum)--;\n\t\t\t\t}\n\t\t\t}\n\t\t\tUDF_I(inode)->i_lenExtents +=\n\t\t\t\tnumalloc << inode->i_sb->s_blocksize_bits;\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "udf_split_extents",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/inode.c",
    "lines": "893-956",
    "snippet": "static void udf_split_extents(struct inode *inode, int *c, int offset,\n\t\t\t      int newblocknum,\n\t\t\t      struct kernel_long_ad laarr[EXTENT_MERGE_SIZE],\n\t\t\t      int *endnum)\n{\n\tunsigned long blocksize = inode->i_sb->s_blocksize;\n\tunsigned char blocksize_bits = inode->i_sb->s_blocksize_bits;\n\n\tif ((laarr[*c].extLength >> 30) == (EXT_NOT_RECORDED_ALLOCATED >> 30) ||\n\t    (laarr[*c].extLength >> 30) ==\n\t\t\t\t(EXT_NOT_RECORDED_NOT_ALLOCATED >> 30)) {\n\t\tint curr = *c;\n\t\tint blen = ((laarr[curr].extLength & UDF_EXTENT_LENGTH_MASK) +\n\t\t\t    blocksize - 1) >> blocksize_bits;\n\t\tint8_t etype = (laarr[curr].extLength >> 30);\n\n\t\tif (blen == 1)\n\t\t\t;\n\t\telse if (!offset || blen == offset + 1) {\n\t\t\tlaarr[curr + 2] = laarr[curr + 1];\n\t\t\tlaarr[curr + 1] = laarr[curr];\n\t\t} else {\n\t\t\tlaarr[curr + 3] = laarr[curr + 1];\n\t\t\tlaarr[curr + 2] = laarr[curr + 1] = laarr[curr];\n\t\t}\n\n\t\tif (offset) {\n\t\t\tif (etype == (EXT_NOT_RECORDED_ALLOCATED >> 30)) {\n\t\t\t\tudf_free_blocks(inode->i_sb, inode,\n\t\t\t\t\t\t&laarr[curr].extLocation,\n\t\t\t\t\t\t0, offset);\n\t\t\t\tlaarr[curr].extLength =\n\t\t\t\t\tEXT_NOT_RECORDED_NOT_ALLOCATED |\n\t\t\t\t\t(offset << blocksize_bits);\n\t\t\t\tlaarr[curr].extLocation.logicalBlockNum = 0;\n\t\t\t\tlaarr[curr].extLocation.\n\t\t\t\t\t\tpartitionReferenceNum = 0;\n\t\t\t} else\n\t\t\t\tlaarr[curr].extLength = (etype << 30) |\n\t\t\t\t\t(offset << blocksize_bits);\n\t\t\tcurr++;\n\t\t\t(*c)++;\n\t\t\t(*endnum)++;\n\t\t}\n\n\t\tlaarr[curr].extLocation.logicalBlockNum = newblocknum;\n\t\tif (etype == (EXT_NOT_RECORDED_NOT_ALLOCATED >> 30))\n\t\t\tlaarr[curr].extLocation.partitionReferenceNum =\n\t\t\t\tUDF_I(inode)->i_location.partitionReferenceNum;\n\t\tlaarr[curr].extLength = EXT_RECORDED_ALLOCATED |\n\t\t\tblocksize;\n\t\tcurr++;\n\n\t\tif (blen != offset + 1) {\n\t\t\tif (etype == (EXT_NOT_RECORDED_ALLOCATED >> 30))\n\t\t\t\tlaarr[curr].extLocation.logicalBlockNum +=\n\t\t\t\t\t\t\t\toffset + 1;\n\t\t\tlaarr[curr].extLength = (etype << 30) |\n\t\t\t\t((blen - (offset + 1)) << blocksize_bits);\n\t\t\tcurr++;\n\t\t\t(*endnum)++;\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"udf_sb.h\"",
      "#include \"udf_i.h\"",
      "#include <linux/aio.h>",
      "#include <linux/mpage.h>",
      "#include <linux/crc-itu-t.h>",
      "#include <linux/slab.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include \"udfdecl.h\""
    ],
    "macros_used": [
      "#define EXTENT_MERGE_SIZE 5"
    ],
    "globals_used": [
      "static int udf_update_inode(struct inode *, int);",
      "static int udf_sync_inode(struct inode *inode);",
      "static void udf_split_extents(struct inode *, int *, int, int,\n\t\t\t      struct kernel_long_ad[EXTENT_MERGE_SIZE], int *);",
      "static void udf_prealloc_extents(struct inode *, int, int,\n\t\t\t\t struct kernel_long_ad[EXTENT_MERGE_SIZE], int *);",
      "static void udf_merge_extents(struct inode *,\n\t\t\t      struct kernel_long_ad[EXTENT_MERGE_SIZE], int *);",
      "static void udf_update_extents(struct inode *,\n\t\t\t       struct kernel_long_ad[EXTENT_MERGE_SIZE], int, int,\n\t\t\t       struct extent_position *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "UDF_I",
          "args": [
            "inode"
          ],
          "line": 941
        },
        "resolved": true,
        "details": {
          "function_name": "UDF_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/udf_i.h",
          "lines": "57-60",
          "snippet": "static inline struct udf_inode_info *UDF_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct udf_inode_info, vfs_inode);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline struct udf_inode_info *UDF_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct udf_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_free_blocks",
          "args": [
            "inode->i_sb",
            "inode",
            "&laarr[curr].extLocation",
            "0",
            "offset"
          ],
          "line": 921
        },
        "resolved": true,
        "details": {
          "function_name": "udf_free_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/balloc.c",
          "lines": "732-757",
          "snippet": "void udf_free_blocks(struct super_block *sb, struct inode *inode,\n\t\t     struct kernel_lb_addr *bloc, uint32_t offset,\n\t\t     uint32_t count)\n{\n\tuint16_t partition = bloc->partitionReferenceNum;\n\tstruct udf_part_map *map = &UDF_SB(sb)->s_partmaps[partition];\n\n\tif (map->s_partition_flags & UDF_PART_FLAG_UNALLOC_BITMAP) {\n\t\tudf_bitmap_free_blocks(sb, map->s_uspace.s_bitmap,\n\t\t\t\t       bloc, offset, count);\n\t} else if (map->s_partition_flags & UDF_PART_FLAG_UNALLOC_TABLE) {\n\t\tudf_table_free_blocks(sb, map->s_uspace.s_table,\n\t\t\t\t      bloc, offset, count);\n\t} else if (map->s_partition_flags & UDF_PART_FLAG_FREED_BITMAP) {\n\t\tudf_bitmap_free_blocks(sb, map->s_fspace.s_bitmap,\n\t\t\t\t       bloc, offset, count);\n\t} else if (map->s_partition_flags & UDF_PART_FLAG_FREED_TABLE) {\n\t\tudf_table_free_blocks(sb, map->s_fspace.s_table,\n\t\t\t\t      bloc, offset, count);\n\t}\n\n\tif (inode) {\n\t\tinode_sub_bytes(inode,\n\t\t\t\t((sector_t)count) << sb->s_blocksize_bits);\n\t}\n}",
          "includes": [
            "#include \"udf_sb.h\"",
            "#include \"udf_i.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/buffer_head.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/bitops.h>\n#include <linux/buffer_head.h>\n#include \"udfdecl.h\"\n\nvoid udf_free_blocks(struct super_block *sb, struct inode *inode,\n\t\t     struct kernel_lb_addr *bloc, uint32_t offset,\n\t\t     uint32_t count)\n{\n\tuint16_t partition = bloc->partitionReferenceNum;\n\tstruct udf_part_map *map = &UDF_SB(sb)->s_partmaps[partition];\n\n\tif (map->s_partition_flags & UDF_PART_FLAG_UNALLOC_BITMAP) {\n\t\tudf_bitmap_free_blocks(sb, map->s_uspace.s_bitmap,\n\t\t\t\t       bloc, offset, count);\n\t} else if (map->s_partition_flags & UDF_PART_FLAG_UNALLOC_TABLE) {\n\t\tudf_table_free_blocks(sb, map->s_uspace.s_table,\n\t\t\t\t      bloc, offset, count);\n\t} else if (map->s_partition_flags & UDF_PART_FLAG_FREED_BITMAP) {\n\t\tudf_bitmap_free_blocks(sb, map->s_fspace.s_bitmap,\n\t\t\t\t       bloc, offset, count);\n\t} else if (map->s_partition_flags & UDF_PART_FLAG_FREED_TABLE) {\n\t\tudf_table_free_blocks(sb, map->s_fspace.s_table,\n\t\t\t\t      bloc, offset, count);\n\t}\n\n\tif (inode) {\n\t\tinode_sub_bytes(inode,\n\t\t\t\t((sector_t)count) << sb->s_blocksize_bits);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/crc-itu-t.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include \"udfdecl.h\"\n\n#define EXTENT_MERGE_SIZE 5\n\nstatic int udf_update_inode(struct inode *, int);\nstatic int udf_sync_inode(struct inode *inode);\nstatic void udf_split_extents(struct inode *, int *, int, int,\n\t\t\t      struct kernel_long_ad[EXTENT_MERGE_SIZE], int *);\nstatic void udf_prealloc_extents(struct inode *, int, int,\n\t\t\t\t struct kernel_long_ad[EXTENT_MERGE_SIZE], int *);\nstatic void udf_merge_extents(struct inode *,\n\t\t\t      struct kernel_long_ad[EXTENT_MERGE_SIZE], int *);\nstatic void udf_update_extents(struct inode *,\n\t\t\t       struct kernel_long_ad[EXTENT_MERGE_SIZE], int, int,\n\t\t\t       struct extent_position *);\n\nstatic void udf_split_extents(struct inode *inode, int *c, int offset,\n\t\t\t      int newblocknum,\n\t\t\t      struct kernel_long_ad laarr[EXTENT_MERGE_SIZE],\n\t\t\t      int *endnum)\n{\n\tunsigned long blocksize = inode->i_sb->s_blocksize;\n\tunsigned char blocksize_bits = inode->i_sb->s_blocksize_bits;\n\n\tif ((laarr[*c].extLength >> 30) == (EXT_NOT_RECORDED_ALLOCATED >> 30) ||\n\t    (laarr[*c].extLength >> 30) ==\n\t\t\t\t(EXT_NOT_RECORDED_NOT_ALLOCATED >> 30)) {\n\t\tint curr = *c;\n\t\tint blen = ((laarr[curr].extLength & UDF_EXTENT_LENGTH_MASK) +\n\t\t\t    blocksize - 1) >> blocksize_bits;\n\t\tint8_t etype = (laarr[curr].extLength >> 30);\n\n\t\tif (blen == 1)\n\t\t\t;\n\t\telse if (!offset || blen == offset + 1) {\n\t\t\tlaarr[curr + 2] = laarr[curr + 1];\n\t\t\tlaarr[curr + 1] = laarr[curr];\n\t\t} else {\n\t\t\tlaarr[curr + 3] = laarr[curr + 1];\n\t\t\tlaarr[curr + 2] = laarr[curr + 1] = laarr[curr];\n\t\t}\n\n\t\tif (offset) {\n\t\t\tif (etype == (EXT_NOT_RECORDED_ALLOCATED >> 30)) {\n\t\t\t\tudf_free_blocks(inode->i_sb, inode,\n\t\t\t\t\t\t&laarr[curr].extLocation,\n\t\t\t\t\t\t0, offset);\n\t\t\t\tlaarr[curr].extLength =\n\t\t\t\t\tEXT_NOT_RECORDED_NOT_ALLOCATED |\n\t\t\t\t\t(offset << blocksize_bits);\n\t\t\t\tlaarr[curr].extLocation.logicalBlockNum = 0;\n\t\t\t\tlaarr[curr].extLocation.\n\t\t\t\t\t\tpartitionReferenceNum = 0;\n\t\t\t} else\n\t\t\t\tlaarr[curr].extLength = (etype << 30) |\n\t\t\t\t\t(offset << blocksize_bits);\n\t\t\tcurr++;\n\t\t\t(*c)++;\n\t\t\t(*endnum)++;\n\t\t}\n\n\t\tlaarr[curr].extLocation.logicalBlockNum = newblocknum;\n\t\tif (etype == (EXT_NOT_RECORDED_NOT_ALLOCATED >> 30))\n\t\t\tlaarr[curr].extLocation.partitionReferenceNum =\n\t\t\t\tUDF_I(inode)->i_location.partitionReferenceNum;\n\t\tlaarr[curr].extLength = EXT_RECORDED_ALLOCATED |\n\t\t\tblocksize;\n\t\tcurr++;\n\n\t\tif (blen != offset + 1) {\n\t\t\tif (etype == (EXT_NOT_RECORDED_ALLOCATED >> 30))\n\t\t\t\tlaarr[curr].extLocation.logicalBlockNum +=\n\t\t\t\t\t\t\t\toffset + 1;\n\t\t\tlaarr[curr].extLength = (etype << 30) |\n\t\t\t\t((blen - (offset + 1)) << blocksize_bits);\n\t\t\tcurr++;\n\t\t\t(*endnum)++;\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "inode_getblk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/inode.c",
    "lines": "658-891",
    "snippet": "static sector_t inode_getblk(struct inode *inode, sector_t block,\n\t\t\t     int *err, int *new)\n{\n\tstruct kernel_long_ad laarr[EXTENT_MERGE_SIZE];\n\tstruct extent_position prev_epos, cur_epos, next_epos;\n\tint count = 0, startnum = 0, endnum = 0;\n\tuint32_t elen = 0, tmpelen;\n\tstruct kernel_lb_addr eloc, tmpeloc;\n\tint c = 1;\n\tloff_t lbcount = 0, b_off = 0;\n\tuint32_t newblocknum, newblock;\n\tsector_t offset = 0;\n\tint8_t etype;\n\tstruct udf_inode_info *iinfo = UDF_I(inode);\n\tint goal = 0, pgoal = iinfo->i_location.logicalBlockNum;\n\tint lastblock = 0;\n\tbool isBeyondEOF;\n\n\t*err = 0;\n\t*new = 0;\n\tprev_epos.offset = udf_file_entry_alloc_offset(inode);\n\tprev_epos.block = iinfo->i_location;\n\tprev_epos.bh = NULL;\n\tcur_epos = next_epos = prev_epos;\n\tb_off = (loff_t)block << inode->i_sb->s_blocksize_bits;\n\n\t/* find the extent which contains the block we are looking for.\n\t   alternate between laarr[0] and laarr[1] for locations of the\n\t   current extent, and the previous extent */\n\tdo {\n\t\tif (prev_epos.bh != cur_epos.bh) {\n\t\t\tbrelse(prev_epos.bh);\n\t\t\tget_bh(cur_epos.bh);\n\t\t\tprev_epos.bh = cur_epos.bh;\n\t\t}\n\t\tif (cur_epos.bh != next_epos.bh) {\n\t\t\tbrelse(cur_epos.bh);\n\t\t\tget_bh(next_epos.bh);\n\t\t\tcur_epos.bh = next_epos.bh;\n\t\t}\n\n\t\tlbcount += elen;\n\n\t\tprev_epos.block = cur_epos.block;\n\t\tcur_epos.block = next_epos.block;\n\n\t\tprev_epos.offset = cur_epos.offset;\n\t\tcur_epos.offset = next_epos.offset;\n\n\t\tetype = udf_next_aext(inode, &next_epos, &eloc, &elen, 1);\n\t\tif (etype == -1)\n\t\t\tbreak;\n\n\t\tc = !c;\n\n\t\tlaarr[c].extLength = (etype << 30) | elen;\n\t\tlaarr[c].extLocation = eloc;\n\n\t\tif (etype != (EXT_NOT_RECORDED_NOT_ALLOCATED >> 30))\n\t\t\tpgoal = eloc.logicalBlockNum +\n\t\t\t\t((elen + inode->i_sb->s_blocksize - 1) >>\n\t\t\t\t inode->i_sb->s_blocksize_bits);\n\n\t\tcount++;\n\t} while (lbcount + elen <= b_off);\n\n\tb_off -= lbcount;\n\toffset = b_off >> inode->i_sb->s_blocksize_bits;\n\t/*\n\t * Move prev_epos and cur_epos into indirect extent if we are at\n\t * the pointer to it\n\t */\n\tudf_next_aext(inode, &prev_epos, &tmpeloc, &tmpelen, 0);\n\tudf_next_aext(inode, &cur_epos, &tmpeloc, &tmpelen, 0);\n\n\t/* if the extent is allocated and recorded, return the block\n\t   if the extent is not a multiple of the blocksize, round up */\n\n\tif (etype == (EXT_RECORDED_ALLOCATED >> 30)) {\n\t\tif (elen & (inode->i_sb->s_blocksize - 1)) {\n\t\t\telen = EXT_RECORDED_ALLOCATED |\n\t\t\t\t((elen + inode->i_sb->s_blocksize - 1) &\n\t\t\t\t ~(inode->i_sb->s_blocksize - 1));\n\t\t\tudf_write_aext(inode, &cur_epos, &eloc, elen, 1);\n\t\t}\n\t\tbrelse(prev_epos.bh);\n\t\tbrelse(cur_epos.bh);\n\t\tbrelse(next_epos.bh);\n\t\tnewblock = udf_get_lb_pblock(inode->i_sb, &eloc, offset);\n\t\treturn newblock;\n\t}\n\n\t/* Are we beyond EOF? */\n\tif (etype == -1) {\n\t\tint ret;\n\t\tisBeyondEOF = true;\n\t\tif (count) {\n\t\t\tif (c)\n\t\t\t\tlaarr[0] = laarr[1];\n\t\t\tstartnum = 1;\n\t\t} else {\n\t\t\t/* Create a fake extent when there's not one */\n\t\t\tmemset(&laarr[0].extLocation, 0x00,\n\t\t\t\tsizeof(struct kernel_lb_addr));\n\t\t\tlaarr[0].extLength = EXT_NOT_RECORDED_NOT_ALLOCATED;\n\t\t\t/* Will udf_do_extend_file() create real extent from\n\t\t\t   a fake one? */\n\t\t\tstartnum = (offset > 0);\n\t\t}\n\t\t/* Create extents for the hole between EOF and offset */\n\t\tret = udf_do_extend_file(inode, &prev_epos, laarr, offset);\n\t\tif (ret < 0) {\n\t\t\tbrelse(prev_epos.bh);\n\t\t\tbrelse(cur_epos.bh);\n\t\t\tbrelse(next_epos.bh);\n\t\t\t*err = ret;\n\t\t\treturn 0;\n\t\t}\n\t\tc = 0;\n\t\toffset = 0;\n\t\tcount += ret;\n\t\t/* We are not covered by a preallocated extent? */\n\t\tif ((laarr[0].extLength & UDF_EXTENT_FLAG_MASK) !=\n\t\t\t\t\t\tEXT_NOT_RECORDED_ALLOCATED) {\n\t\t\t/* Is there any real extent? - otherwise we overwrite\n\t\t\t * the fake one... */\n\t\t\tif (count)\n\t\t\t\tc = !c;\n\t\t\tlaarr[c].extLength = EXT_NOT_RECORDED_NOT_ALLOCATED |\n\t\t\t\tinode->i_sb->s_blocksize;\n\t\t\tmemset(&laarr[c].extLocation, 0x00,\n\t\t\t\tsizeof(struct kernel_lb_addr));\n\t\t\tcount++;\n\t\t}\n\t\tendnum = c + 1;\n\t\tlastblock = 1;\n\t} else {\n\t\tisBeyondEOF = false;\n\t\tendnum = startnum = ((count > 2) ? 2 : count);\n\n\t\t/* if the current extent is in position 0,\n\t\t   swap it with the previous */\n\t\tif (!c && count != 1) {\n\t\t\tlaarr[2] = laarr[0];\n\t\t\tlaarr[0] = laarr[1];\n\t\t\tlaarr[1] = laarr[2];\n\t\t\tc = 1;\n\t\t}\n\n\t\t/* if the current block is located in an extent,\n\t\t   read the next extent */\n\t\tetype = udf_next_aext(inode, &next_epos, &eloc, &elen, 0);\n\t\tif (etype != -1) {\n\t\t\tlaarr[c + 1].extLength = (etype << 30) | elen;\n\t\t\tlaarr[c + 1].extLocation = eloc;\n\t\t\tcount++;\n\t\t\tstartnum++;\n\t\t\tendnum++;\n\t\t} else\n\t\t\tlastblock = 1;\n\t}\n\n\t/* if the current extent is not recorded but allocated, get the\n\t * block in the extent corresponding to the requested block */\n\tif ((laarr[c].extLength >> 30) == (EXT_NOT_RECORDED_ALLOCATED >> 30))\n\t\tnewblocknum = laarr[c].extLocation.logicalBlockNum + offset;\n\telse { /* otherwise, allocate a new block */\n\t\tif (iinfo->i_next_alloc_block == block)\n\t\t\tgoal = iinfo->i_next_alloc_goal;\n\n\t\tif (!goal) {\n\t\t\tif (!(goal = pgoal)) /* XXX: what was intended here? */\n\t\t\t\tgoal = iinfo->i_location.logicalBlockNum + 1;\n\t\t}\n\n\t\tnewblocknum = udf_new_block(inode->i_sb, inode,\n\t\t\t\tiinfo->i_location.partitionReferenceNum,\n\t\t\t\tgoal, err);\n\t\tif (!newblocknum) {\n\t\t\tbrelse(prev_epos.bh);\n\t\t\tbrelse(cur_epos.bh);\n\t\t\tbrelse(next_epos.bh);\n\t\t\t*err = -ENOSPC;\n\t\t\treturn 0;\n\t\t}\n\t\tif (isBeyondEOF)\n\t\t\tiinfo->i_lenExtents += inode->i_sb->s_blocksize;\n\t}\n\n\t/* if the extent the requsted block is located in contains multiple\n\t * blocks, split the extent into at most three extents. blocks prior\n\t * to requested block, requested block, and blocks after requested\n\t * block */\n\tudf_split_extents(inode, &c, offset, newblocknum, laarr, &endnum);\n\n#ifdef UDF_PREALLOCATE\n\t/* We preallocate blocks only for regular files. It also makes sense\n\t * for directories but there's a problem when to drop the\n\t * preallocation. We might use some delayed work for that but I feel\n\t * it's overengineering for a filesystem like UDF. */\n\tif (S_ISREG(inode->i_mode))\n\t\tudf_prealloc_extents(inode, c, lastblock, laarr, &endnum);\n#endif\n\n\t/* merge any continuous blocks in laarr */\n\tudf_merge_extents(inode, laarr, &endnum);\n\n\t/* write back the new extents, inserting new extents if the new number\n\t * of extents is greater than the old number, and deleting extents if\n\t * the new number of extents is less than the old number */\n\tudf_update_extents(inode, laarr, startnum, endnum, &prev_epos);\n\n\tbrelse(prev_epos.bh);\n\tbrelse(cur_epos.bh);\n\tbrelse(next_epos.bh);\n\n\tnewblock = udf_get_pblock(inode->i_sb, newblocknum,\n\t\t\t\tiinfo->i_location.partitionReferenceNum, 0);\n\tif (!newblock) {\n\t\t*err = -EIO;\n\t\treturn 0;\n\t}\n\t*new = 1;\n\tiinfo->i_next_alloc_block = block;\n\tiinfo->i_next_alloc_goal = newblocknum;\n\tinode->i_ctime = current_fs_time(inode->i_sb);\n\n\tif (IS_SYNC(inode))\n\t\tudf_sync_inode(inode);\n\telse\n\t\tmark_inode_dirty(inode);\n\n\treturn newblock;\n}",
    "includes": [
      "#include \"udf_sb.h\"",
      "#include \"udf_i.h\"",
      "#include <linux/aio.h>",
      "#include <linux/mpage.h>",
      "#include <linux/crc-itu-t.h>",
      "#include <linux/slab.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include \"udfdecl.h\""
    ],
    "macros_used": [
      "#define EXTENT_MERGE_SIZE 5"
    ],
    "globals_used": [
      "static int udf_update_inode(struct inode *, int);",
      "static int udf_sync_inode(struct inode *inode);",
      "static sector_t inode_getblk(struct inode *, sector_t, int *, int *);",
      "static int8_t udf_insert_aext(struct inode *, struct extent_position,\n\t\t\t      struct kernel_lb_addr, uint32_t);",
      "static void udf_split_extents(struct inode *, int *, int, int,\n\t\t\t      struct kernel_long_ad[EXTENT_MERGE_SIZE], int *);",
      "static void udf_prealloc_extents(struct inode *, int, int,\n\t\t\t\t struct kernel_long_ad[EXTENT_MERGE_SIZE], int *);",
      "static void udf_merge_extents(struct inode *,\n\t\t\t      struct kernel_long_ad[EXTENT_MERGE_SIZE], int *);",
      "static void udf_update_extents(struct inode *,\n\t\t\t       struct kernel_long_ad[EXTENT_MERGE_SIZE], int, int,\n\t\t\t       struct extent_position *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mark_inode_dirty",
          "args": [
            "inode"
          ],
          "line": 888
        },
        "resolved": true,
        "details": {
          "function_name": "block_dump___mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1134-1154",
          "snippet": "static noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_sync_inode",
          "args": [
            "inode"
          ],
          "line": 886
        },
        "resolved": true,
        "details": {
          "function_name": "udf_sync_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/inode.c",
          "lines": "1617-1620",
          "snippet": "static int udf_sync_inode(struct inode *inode)\n{\n\treturn udf_update_inode(inode, 1);\n}",
          "includes": [
            "#include \"udf_sb.h\"",
            "#include \"udf_i.h\"",
            "#include <linux/aio.h>",
            "#include <linux/mpage.h>",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int udf_update_inode(struct inode *, int);",
            "static int udf_sync_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/crc-itu-t.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include \"udfdecl.h\"\n\nstatic int udf_update_inode(struct inode *, int);\nstatic int udf_sync_inode(struct inode *inode);\n\nstatic int udf_sync_inode(struct inode *inode)\n{\n\treturn udf_update_inode(inode, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_SYNC",
          "args": [
            "inode"
          ],
          "line": 885
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_fs_time",
          "args": [
            "inode->i_sb"
          ],
          "line": 883
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udf_get_pblock",
          "args": [
            "inode->i_sb",
            "newblocknum",
            "iinfo->i_location.partitionReferenceNum",
            "0"
          ],
          "line": 874
        },
        "resolved": true,
        "details": {
          "function_name": "udf_get_pblock_meta25",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/partition.c",
          "lines": "306-339",
          "snippet": "uint32_t udf_get_pblock_meta25(struct super_block *sb, uint32_t block,\n\t\t\t\tuint16_t partition, uint32_t offset)\n{\n\tstruct udf_sb_info *sbi = UDF_SB(sb);\n\tstruct udf_part_map *map;\n\tstruct udf_meta_data *mdata;\n\tuint32_t retblk;\n\tstruct inode *inode;\n\n\tudf_debug(\"READING from METADATA\\n\");\n\n\tmap = &sbi->s_partmaps[partition];\n\tmdata = &map->s_type_specific.s_metadata;\n\tinode = mdata->s_metadata_fe ? : mdata->s_mirror_fe;\n\n\t/* We shouldn't mount such media... */\n\tBUG_ON(!inode);\n\tretblk = udf_try_read_meta(inode, block, partition, offset);\n\tif (retblk == 0xFFFFFFFF && mdata->s_metadata_fe) {\n\t\tudf_warn(sb, \"error reading from METADATA, trying to read from MIRROR\\n\");\n\t\tif (!(mdata->s_flags & MF_MIRROR_FE_LOADED)) {\n\t\t\tmdata->s_mirror_fe = udf_find_metadata_inode_efe(sb,\n\t\t\t\tmdata->s_mirror_file_loc, map->s_partition_num);\n\t\t\tmdata->s_flags |= MF_MIRROR_FE_LOADED;\n\t\t}\n\n\t\tinode = mdata->s_mirror_fe;\n\t\tif (!inode)\n\t\t\treturn 0xFFFFFFFF;\n\t\tretblk = udf_try_read_meta(inode, block, partition, offset);\n\t}\n\n\treturn retblk;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>",
            "#include \"udf_i.h\"",
            "#include \"udf_sb.h\"",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include \"udf_i.h\"\n#include \"udf_sb.h\"\n#include \"udfdecl.h\"\n\nuint32_t udf_get_pblock_meta25(struct super_block *sb, uint32_t block,\n\t\t\t\tuint16_t partition, uint32_t offset)\n{\n\tstruct udf_sb_info *sbi = UDF_SB(sb);\n\tstruct udf_part_map *map;\n\tstruct udf_meta_data *mdata;\n\tuint32_t retblk;\n\tstruct inode *inode;\n\n\tudf_debug(\"READING from METADATA\\n\");\n\n\tmap = &sbi->s_partmaps[partition];\n\tmdata = &map->s_type_specific.s_metadata;\n\tinode = mdata->s_metadata_fe ? : mdata->s_mirror_fe;\n\n\t/* We shouldn't mount such media... */\n\tBUG_ON(!inode);\n\tretblk = udf_try_read_meta(inode, block, partition, offset);\n\tif (retblk == 0xFFFFFFFF && mdata->s_metadata_fe) {\n\t\tudf_warn(sb, \"error reading from METADATA, trying to read from MIRROR\\n\");\n\t\tif (!(mdata->s_flags & MF_MIRROR_FE_LOADED)) {\n\t\t\tmdata->s_mirror_fe = udf_find_metadata_inode_efe(sb,\n\t\t\t\tmdata->s_mirror_file_loc, map->s_partition_num);\n\t\t\tmdata->s_flags |= MF_MIRROR_FE_LOADED;\n\t\t}\n\n\t\tinode = mdata->s_mirror_fe;\n\t\tif (!inode)\n\t\t\treturn 0xFFFFFFFF;\n\t\tretblk = udf_try_read_meta(inode, block, partition, offset);\n\t}\n\n\treturn retblk;\n}"
        }
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "next_epos.bh"
          ],
          "line": 872
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_update_extents",
          "args": [
            "inode",
            "laarr",
            "startnum",
            "endnum",
            "&prev_epos"
          ],
          "line": 868
        },
        "resolved": true,
        "details": {
          "function_name": "udf_update_extents",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/inode.c",
          "lines": "1154-1182",
          "snippet": "static void udf_update_extents(struct inode *inode,\n\t\t\t       struct kernel_long_ad laarr[EXTENT_MERGE_SIZE],\n\t\t\t       int startnum, int endnum,\n\t\t\t       struct extent_position *epos)\n{\n\tint start = 0, i;\n\tstruct kernel_lb_addr tmploc;\n\tuint32_t tmplen;\n\n\tif (startnum > endnum) {\n\t\tfor (i = 0; i < (startnum - endnum); i++)\n\t\t\tudf_delete_aext(inode, *epos, laarr[i].extLocation,\n\t\t\t\t\tlaarr[i].extLength);\n\t} else if (startnum < endnum) {\n\t\tfor (i = 0; i < (endnum - startnum); i++) {\n\t\t\tudf_insert_aext(inode, *epos, laarr[i].extLocation,\n\t\t\t\t\tlaarr[i].extLength);\n\t\t\tudf_next_aext(inode, epos, &laarr[i].extLocation,\n\t\t\t\t      &laarr[i].extLength, 1);\n\t\t\tstart++;\n\t\t}\n\t}\n\n\tfor (i = start; i < endnum; i++) {\n\t\tudf_next_aext(inode, epos, &tmploc, &tmplen, 0);\n\t\tudf_write_aext(inode, epos, &laarr[i].extLocation,\n\t\t\t       laarr[i].extLength, 1);\n\t}\n}",
          "includes": [
            "#include \"udf_sb.h\"",
            "#include \"udf_i.h\"",
            "#include <linux/aio.h>",
            "#include <linux/mpage.h>",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [
            "#define EXTENT_MERGE_SIZE 5"
          ],
          "globals_used": [
            "static int udf_update_inode(struct inode *, int);",
            "static int udf_sync_inode(struct inode *inode);",
            "static int8_t udf_insert_aext(struct inode *, struct extent_position,\n\t\t\t      struct kernel_lb_addr, uint32_t);",
            "static void udf_split_extents(struct inode *, int *, int, int,\n\t\t\t      struct kernel_long_ad[EXTENT_MERGE_SIZE], int *);",
            "static void udf_prealloc_extents(struct inode *, int, int,\n\t\t\t\t struct kernel_long_ad[EXTENT_MERGE_SIZE], int *);",
            "static void udf_merge_extents(struct inode *,\n\t\t\t      struct kernel_long_ad[EXTENT_MERGE_SIZE], int *);",
            "static void udf_update_extents(struct inode *,\n\t\t\t       struct kernel_long_ad[EXTENT_MERGE_SIZE], int, int,\n\t\t\t       struct extent_position *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/crc-itu-t.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include \"udfdecl.h\"\n\n#define EXTENT_MERGE_SIZE 5\n\nstatic int udf_update_inode(struct inode *, int);\nstatic int udf_sync_inode(struct inode *inode);\nstatic int8_t udf_insert_aext(struct inode *, struct extent_position,\n\t\t\t      struct kernel_lb_addr, uint32_t);\nstatic void udf_split_extents(struct inode *, int *, int, int,\n\t\t\t      struct kernel_long_ad[EXTENT_MERGE_SIZE], int *);\nstatic void udf_prealloc_extents(struct inode *, int, int,\n\t\t\t\t struct kernel_long_ad[EXTENT_MERGE_SIZE], int *);\nstatic void udf_merge_extents(struct inode *,\n\t\t\t      struct kernel_long_ad[EXTENT_MERGE_SIZE], int *);\nstatic void udf_update_extents(struct inode *,\n\t\t\t       struct kernel_long_ad[EXTENT_MERGE_SIZE], int, int,\n\t\t\t       struct extent_position *);\n\nstatic void udf_update_extents(struct inode *inode,\n\t\t\t       struct kernel_long_ad laarr[EXTENT_MERGE_SIZE],\n\t\t\t       int startnum, int endnum,\n\t\t\t       struct extent_position *epos)\n{\n\tint start = 0, i;\n\tstruct kernel_lb_addr tmploc;\n\tuint32_t tmplen;\n\n\tif (startnum > endnum) {\n\t\tfor (i = 0; i < (startnum - endnum); i++)\n\t\t\tudf_delete_aext(inode, *epos, laarr[i].extLocation,\n\t\t\t\t\tlaarr[i].extLength);\n\t} else if (startnum < endnum) {\n\t\tfor (i = 0; i < (endnum - startnum); i++) {\n\t\t\tudf_insert_aext(inode, *epos, laarr[i].extLocation,\n\t\t\t\t\tlaarr[i].extLength);\n\t\t\tudf_next_aext(inode, epos, &laarr[i].extLocation,\n\t\t\t\t      &laarr[i].extLength, 1);\n\t\t\tstart++;\n\t\t}\n\t}\n\n\tfor (i = start; i < endnum; i++) {\n\t\tudf_next_aext(inode, epos, &tmploc, &tmplen, 0);\n\t\tudf_write_aext(inode, epos, &laarr[i].extLocation,\n\t\t\t       laarr[i].extLength, 1);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_merge_extents",
          "args": [
            "inode",
            "laarr",
            "&endnum"
          ],
          "line": 863
        },
        "resolved": true,
        "details": {
          "function_name": "udf_merge_extents",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/inode.c",
          "lines": "1054-1152",
          "snippet": "static void udf_merge_extents(struct inode *inode,\n\t\t\t      struct kernel_long_ad laarr[EXTENT_MERGE_SIZE],\n\t\t\t      int *endnum)\n{\n\tint i;\n\tunsigned long blocksize = inode->i_sb->s_blocksize;\n\tunsigned char blocksize_bits = inode->i_sb->s_blocksize_bits;\n\n\tfor (i = 0; i < (*endnum - 1); i++) {\n\t\tstruct kernel_long_ad *li /*l[i]*/ = &laarr[i];\n\t\tstruct kernel_long_ad *lip1 /*l[i plus 1]*/ = &laarr[i + 1];\n\n\t\tif (((li->extLength >> 30) == (lip1->extLength >> 30)) &&\n\t\t\t(((li->extLength >> 30) ==\n\t\t\t\t(EXT_NOT_RECORDED_NOT_ALLOCATED >> 30)) ||\n\t\t\t((lip1->extLocation.logicalBlockNum -\n\t\t\t  li->extLocation.logicalBlockNum) ==\n\t\t\t(((li->extLength & UDF_EXTENT_LENGTH_MASK) +\n\t\t\tblocksize - 1) >> blocksize_bits)))) {\n\n\t\t\tif (((li->extLength & UDF_EXTENT_LENGTH_MASK) +\n\t\t\t\t(lip1->extLength & UDF_EXTENT_LENGTH_MASK) +\n\t\t\t\tblocksize - 1) & ~UDF_EXTENT_LENGTH_MASK) {\n\t\t\t\tlip1->extLength = (lip1->extLength -\n\t\t\t\t\t\t  (li->extLength &\n\t\t\t\t\t\t   UDF_EXTENT_LENGTH_MASK) +\n\t\t\t\t\t\t   UDF_EXTENT_LENGTH_MASK) &\n\t\t\t\t\t\t\t~(blocksize - 1);\n\t\t\t\tli->extLength = (li->extLength &\n\t\t\t\t\t\t UDF_EXTENT_FLAG_MASK) +\n\t\t\t\t\t\t(UDF_EXTENT_LENGTH_MASK + 1) -\n\t\t\t\t\t\tblocksize;\n\t\t\t\tlip1->extLocation.logicalBlockNum =\n\t\t\t\t\tli->extLocation.logicalBlockNum +\n\t\t\t\t\t((li->extLength &\n\t\t\t\t\t\tUDF_EXTENT_LENGTH_MASK) >>\n\t\t\t\t\t\tblocksize_bits);\n\t\t\t} else {\n\t\t\t\tli->extLength = lip1->extLength +\n\t\t\t\t\t(((li->extLength &\n\t\t\t\t\t\tUDF_EXTENT_LENGTH_MASK) +\n\t\t\t\t\t blocksize - 1) & ~(blocksize - 1));\n\t\t\t\tif (*endnum > (i + 2))\n\t\t\t\t\tmemmove(&laarr[i + 1], &laarr[i + 2],\n\t\t\t\t\t\tsizeof(struct long_ad) *\n\t\t\t\t\t\t(*endnum - (i + 2)));\n\t\t\t\ti--;\n\t\t\t\t(*endnum)--;\n\t\t\t}\n\t\t} else if (((li->extLength >> 30) ==\n\t\t\t\t(EXT_NOT_RECORDED_ALLOCATED >> 30)) &&\n\t\t\t   ((lip1->extLength >> 30) ==\n\t\t\t\t(EXT_NOT_RECORDED_NOT_ALLOCATED >> 30))) {\n\t\t\tudf_free_blocks(inode->i_sb, inode, &li->extLocation, 0,\n\t\t\t\t\t((li->extLength &\n\t\t\t\t\t  UDF_EXTENT_LENGTH_MASK) +\n\t\t\t\t\t blocksize - 1) >> blocksize_bits);\n\t\t\tli->extLocation.logicalBlockNum = 0;\n\t\t\tli->extLocation.partitionReferenceNum = 0;\n\n\t\t\tif (((li->extLength & UDF_EXTENT_LENGTH_MASK) +\n\t\t\t     (lip1->extLength & UDF_EXTENT_LENGTH_MASK) +\n\t\t\t     blocksize - 1) & ~UDF_EXTENT_LENGTH_MASK) {\n\t\t\t\tlip1->extLength = (lip1->extLength -\n\t\t\t\t\t\t   (li->extLength &\n\t\t\t\t\t\t   UDF_EXTENT_LENGTH_MASK) +\n\t\t\t\t\t\t   UDF_EXTENT_LENGTH_MASK) &\n\t\t\t\t\t\t   ~(blocksize - 1);\n\t\t\t\tli->extLength = (li->extLength &\n\t\t\t\t\t\t UDF_EXTENT_FLAG_MASK) +\n\t\t\t\t\t\t(UDF_EXTENT_LENGTH_MASK + 1) -\n\t\t\t\t\t\tblocksize;\n\t\t\t} else {\n\t\t\t\tli->extLength = lip1->extLength +\n\t\t\t\t\t(((li->extLength &\n\t\t\t\t\t\tUDF_EXTENT_LENGTH_MASK) +\n\t\t\t\t\t  blocksize - 1) & ~(blocksize - 1));\n\t\t\t\tif (*endnum > (i + 2))\n\t\t\t\t\tmemmove(&laarr[i + 1], &laarr[i + 2],\n\t\t\t\t\t\tsizeof(struct long_ad) *\n\t\t\t\t\t\t(*endnum - (i + 2)));\n\t\t\t\ti--;\n\t\t\t\t(*endnum)--;\n\t\t\t}\n\t\t} else if ((li->extLength >> 30) ==\n\t\t\t\t\t(EXT_NOT_RECORDED_ALLOCATED >> 30)) {\n\t\t\tudf_free_blocks(inode->i_sb, inode,\n\t\t\t\t\t&li->extLocation, 0,\n\t\t\t\t\t((li->extLength &\n\t\t\t\t\t\tUDF_EXTENT_LENGTH_MASK) +\n\t\t\t\t\t blocksize - 1) >> blocksize_bits);\n\t\t\tli->extLocation.logicalBlockNum = 0;\n\t\t\tli->extLocation.partitionReferenceNum = 0;\n\t\t\tli->extLength = (li->extLength &\n\t\t\t\t\t\tUDF_EXTENT_LENGTH_MASK) |\n\t\t\t\t\t\tEXT_NOT_RECORDED_NOT_ALLOCATED;\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"udf_sb.h\"",
            "#include \"udf_i.h\"",
            "#include <linux/aio.h>",
            "#include <linux/mpage.h>",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [
            "#define EXTENT_MERGE_SIZE 5"
          ],
          "globals_used": [
            "static int udf_update_inode(struct inode *, int);",
            "static int udf_sync_inode(struct inode *inode);",
            "static void udf_split_extents(struct inode *, int *, int, int,\n\t\t\t      struct kernel_long_ad[EXTENT_MERGE_SIZE], int *);",
            "static void udf_prealloc_extents(struct inode *, int, int,\n\t\t\t\t struct kernel_long_ad[EXTENT_MERGE_SIZE], int *);",
            "static void udf_merge_extents(struct inode *,\n\t\t\t      struct kernel_long_ad[EXTENT_MERGE_SIZE], int *);",
            "static void udf_update_extents(struct inode *,\n\t\t\t       struct kernel_long_ad[EXTENT_MERGE_SIZE], int, int,\n\t\t\t       struct extent_position *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/crc-itu-t.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include \"udfdecl.h\"\n\n#define EXTENT_MERGE_SIZE 5\n\nstatic int udf_update_inode(struct inode *, int);\nstatic int udf_sync_inode(struct inode *inode);\nstatic void udf_split_extents(struct inode *, int *, int, int,\n\t\t\t      struct kernel_long_ad[EXTENT_MERGE_SIZE], int *);\nstatic void udf_prealloc_extents(struct inode *, int, int,\n\t\t\t\t struct kernel_long_ad[EXTENT_MERGE_SIZE], int *);\nstatic void udf_merge_extents(struct inode *,\n\t\t\t      struct kernel_long_ad[EXTENT_MERGE_SIZE], int *);\nstatic void udf_update_extents(struct inode *,\n\t\t\t       struct kernel_long_ad[EXTENT_MERGE_SIZE], int, int,\n\t\t\t       struct extent_position *);\n\nstatic void udf_merge_extents(struct inode *inode,\n\t\t\t      struct kernel_long_ad laarr[EXTENT_MERGE_SIZE],\n\t\t\t      int *endnum)\n{\n\tint i;\n\tunsigned long blocksize = inode->i_sb->s_blocksize;\n\tunsigned char blocksize_bits = inode->i_sb->s_blocksize_bits;\n\n\tfor (i = 0; i < (*endnum - 1); i++) {\n\t\tstruct kernel_long_ad *li /*l[i]*/ = &laarr[i];\n\t\tstruct kernel_long_ad *lip1 /*l[i plus 1]*/ = &laarr[i + 1];\n\n\t\tif (((li->extLength >> 30) == (lip1->extLength >> 30)) &&\n\t\t\t(((li->extLength >> 30) ==\n\t\t\t\t(EXT_NOT_RECORDED_NOT_ALLOCATED >> 30)) ||\n\t\t\t((lip1->extLocation.logicalBlockNum -\n\t\t\t  li->extLocation.logicalBlockNum) ==\n\t\t\t(((li->extLength & UDF_EXTENT_LENGTH_MASK) +\n\t\t\tblocksize - 1) >> blocksize_bits)))) {\n\n\t\t\tif (((li->extLength & UDF_EXTENT_LENGTH_MASK) +\n\t\t\t\t(lip1->extLength & UDF_EXTENT_LENGTH_MASK) +\n\t\t\t\tblocksize - 1) & ~UDF_EXTENT_LENGTH_MASK) {\n\t\t\t\tlip1->extLength = (lip1->extLength -\n\t\t\t\t\t\t  (li->extLength &\n\t\t\t\t\t\t   UDF_EXTENT_LENGTH_MASK) +\n\t\t\t\t\t\t   UDF_EXTENT_LENGTH_MASK) &\n\t\t\t\t\t\t\t~(blocksize - 1);\n\t\t\t\tli->extLength = (li->extLength &\n\t\t\t\t\t\t UDF_EXTENT_FLAG_MASK) +\n\t\t\t\t\t\t(UDF_EXTENT_LENGTH_MASK + 1) -\n\t\t\t\t\t\tblocksize;\n\t\t\t\tlip1->extLocation.logicalBlockNum =\n\t\t\t\t\tli->extLocation.logicalBlockNum +\n\t\t\t\t\t((li->extLength &\n\t\t\t\t\t\tUDF_EXTENT_LENGTH_MASK) >>\n\t\t\t\t\t\tblocksize_bits);\n\t\t\t} else {\n\t\t\t\tli->extLength = lip1->extLength +\n\t\t\t\t\t(((li->extLength &\n\t\t\t\t\t\tUDF_EXTENT_LENGTH_MASK) +\n\t\t\t\t\t blocksize - 1) & ~(blocksize - 1));\n\t\t\t\tif (*endnum > (i + 2))\n\t\t\t\t\tmemmove(&laarr[i + 1], &laarr[i + 2],\n\t\t\t\t\t\tsizeof(struct long_ad) *\n\t\t\t\t\t\t(*endnum - (i + 2)));\n\t\t\t\ti--;\n\t\t\t\t(*endnum)--;\n\t\t\t}\n\t\t} else if (((li->extLength >> 30) ==\n\t\t\t\t(EXT_NOT_RECORDED_ALLOCATED >> 30)) &&\n\t\t\t   ((lip1->extLength >> 30) ==\n\t\t\t\t(EXT_NOT_RECORDED_NOT_ALLOCATED >> 30))) {\n\t\t\tudf_free_blocks(inode->i_sb, inode, &li->extLocation, 0,\n\t\t\t\t\t((li->extLength &\n\t\t\t\t\t  UDF_EXTENT_LENGTH_MASK) +\n\t\t\t\t\t blocksize - 1) >> blocksize_bits);\n\t\t\tli->extLocation.logicalBlockNum = 0;\n\t\t\tli->extLocation.partitionReferenceNum = 0;\n\n\t\t\tif (((li->extLength & UDF_EXTENT_LENGTH_MASK) +\n\t\t\t     (lip1->extLength & UDF_EXTENT_LENGTH_MASK) +\n\t\t\t     blocksize - 1) & ~UDF_EXTENT_LENGTH_MASK) {\n\t\t\t\tlip1->extLength = (lip1->extLength -\n\t\t\t\t\t\t   (li->extLength &\n\t\t\t\t\t\t   UDF_EXTENT_LENGTH_MASK) +\n\t\t\t\t\t\t   UDF_EXTENT_LENGTH_MASK) &\n\t\t\t\t\t\t   ~(blocksize - 1);\n\t\t\t\tli->extLength = (li->extLength &\n\t\t\t\t\t\t UDF_EXTENT_FLAG_MASK) +\n\t\t\t\t\t\t(UDF_EXTENT_LENGTH_MASK + 1) -\n\t\t\t\t\t\tblocksize;\n\t\t\t} else {\n\t\t\t\tli->extLength = lip1->extLength +\n\t\t\t\t\t(((li->extLength &\n\t\t\t\t\t\tUDF_EXTENT_LENGTH_MASK) +\n\t\t\t\t\t  blocksize - 1) & ~(blocksize - 1));\n\t\t\t\tif (*endnum > (i + 2))\n\t\t\t\t\tmemmove(&laarr[i + 1], &laarr[i + 2],\n\t\t\t\t\t\tsizeof(struct long_ad) *\n\t\t\t\t\t\t(*endnum - (i + 2)));\n\t\t\t\ti--;\n\t\t\t\t(*endnum)--;\n\t\t\t}\n\t\t} else if ((li->extLength >> 30) ==\n\t\t\t\t\t(EXT_NOT_RECORDED_ALLOCATED >> 30)) {\n\t\t\tudf_free_blocks(inode->i_sb, inode,\n\t\t\t\t\t&li->extLocation, 0,\n\t\t\t\t\t((li->extLength &\n\t\t\t\t\t\tUDF_EXTENT_LENGTH_MASK) +\n\t\t\t\t\t blocksize - 1) >> blocksize_bits);\n\t\t\tli->extLocation.logicalBlockNum = 0;\n\t\t\tli->extLocation.partitionReferenceNum = 0;\n\t\t\tli->extLength = (li->extLength &\n\t\t\t\t\t\tUDF_EXTENT_LENGTH_MASK) |\n\t\t\t\t\t\tEXT_NOT_RECORDED_NOT_ALLOCATED;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_prealloc_extents",
          "args": [
            "inode",
            "c",
            "lastblock",
            "laarr",
            "&endnum"
          ],
          "line": 859
        },
        "resolved": true,
        "details": {
          "function_name": "udf_prealloc_extents",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/inode.c",
          "lines": "958-1052",
          "snippet": "static void udf_prealloc_extents(struct inode *inode, int c, int lastblock,\n\t\t\t\t struct kernel_long_ad laarr[EXTENT_MERGE_SIZE],\n\t\t\t\t int *endnum)\n{\n\tint start, length = 0, currlength = 0, i;\n\n\tif (*endnum >= (c + 1)) {\n\t\tif (!lastblock)\n\t\t\treturn;\n\t\telse\n\t\t\tstart = c;\n\t} else {\n\t\tif ((laarr[c + 1].extLength >> 30) ==\n\t\t\t\t\t(EXT_NOT_RECORDED_ALLOCATED >> 30)) {\n\t\t\tstart = c + 1;\n\t\t\tlength = currlength =\n\t\t\t\t(((laarr[c + 1].extLength &\n\t\t\t\t\tUDF_EXTENT_LENGTH_MASK) +\n\t\t\t\tinode->i_sb->s_blocksize - 1) >>\n\t\t\t\tinode->i_sb->s_blocksize_bits);\n\t\t} else\n\t\t\tstart = c;\n\t}\n\n\tfor (i = start + 1; i <= *endnum; i++) {\n\t\tif (i == *endnum) {\n\t\t\tif (lastblock)\n\t\t\t\tlength += UDF_DEFAULT_PREALLOC_BLOCKS;\n\t\t} else if ((laarr[i].extLength >> 30) ==\n\t\t\t\t(EXT_NOT_RECORDED_NOT_ALLOCATED >> 30)) {\n\t\t\tlength += (((laarr[i].extLength &\n\t\t\t\t\t\tUDF_EXTENT_LENGTH_MASK) +\n\t\t\t\t    inode->i_sb->s_blocksize - 1) >>\n\t\t\t\t    inode->i_sb->s_blocksize_bits);\n\t\t} else\n\t\t\tbreak;\n\t}\n\n\tif (length) {\n\t\tint next = laarr[start].extLocation.logicalBlockNum +\n\t\t\t(((laarr[start].extLength & UDF_EXTENT_LENGTH_MASK) +\n\t\t\t  inode->i_sb->s_blocksize - 1) >>\n\t\t\t  inode->i_sb->s_blocksize_bits);\n\t\tint numalloc = udf_prealloc_blocks(inode->i_sb, inode,\n\t\t\t\tlaarr[start].extLocation.partitionReferenceNum,\n\t\t\t\tnext, (UDF_DEFAULT_PREALLOC_BLOCKS > length ?\n\t\t\t\tlength : UDF_DEFAULT_PREALLOC_BLOCKS) -\n\t\t\t\tcurrlength);\n\t\tif (numalloc) \t{\n\t\t\tif (start == (c + 1))\n\t\t\t\tlaarr[start].extLength +=\n\t\t\t\t\t(numalloc <<\n\t\t\t\t\t inode->i_sb->s_blocksize_bits);\n\t\t\telse {\n\t\t\t\tmemmove(&laarr[c + 2], &laarr[c + 1],\n\t\t\t\t\tsizeof(struct long_ad) * (*endnum - (c + 1)));\n\t\t\t\t(*endnum)++;\n\t\t\t\tlaarr[c + 1].extLocation.logicalBlockNum = next;\n\t\t\t\tlaarr[c + 1].extLocation.partitionReferenceNum =\n\t\t\t\t\tlaarr[c].extLocation.\n\t\t\t\t\t\t\tpartitionReferenceNum;\n\t\t\t\tlaarr[c + 1].extLength =\n\t\t\t\t\tEXT_NOT_RECORDED_ALLOCATED |\n\t\t\t\t\t(numalloc <<\n\t\t\t\t\t inode->i_sb->s_blocksize_bits);\n\t\t\t\tstart = c + 1;\n\t\t\t}\n\n\t\t\tfor (i = start + 1; numalloc && i < *endnum; i++) {\n\t\t\t\tint elen = ((laarr[i].extLength &\n\t\t\t\t\t\tUDF_EXTENT_LENGTH_MASK) +\n\t\t\t\t\t    inode->i_sb->s_blocksize - 1) >>\n\t\t\t\t\t    inode->i_sb->s_blocksize_bits;\n\n\t\t\t\tif (elen > numalloc) {\n\t\t\t\t\tlaarr[i].extLength -=\n\t\t\t\t\t\t(numalloc <<\n\t\t\t\t\t\t inode->i_sb->s_blocksize_bits);\n\t\t\t\t\tnumalloc = 0;\n\t\t\t\t} else {\n\t\t\t\t\tnumalloc -= elen;\n\t\t\t\t\tif (*endnum > (i + 1))\n\t\t\t\t\t\tmemmove(&laarr[i],\n\t\t\t\t\t\t\t&laarr[i + 1],\n\t\t\t\t\t\t\tsizeof(struct long_ad) *\n\t\t\t\t\t\t\t(*endnum - (i + 1)));\n\t\t\t\t\ti--;\n\t\t\t\t\t(*endnum)--;\n\t\t\t\t}\n\t\t\t}\n\t\t\tUDF_I(inode)->i_lenExtents +=\n\t\t\t\tnumalloc << inode->i_sb->s_blocksize_bits;\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"udf_sb.h\"",
            "#include \"udf_i.h\"",
            "#include <linux/aio.h>",
            "#include <linux/mpage.h>",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [
            "#define EXTENT_MERGE_SIZE 5"
          ],
          "globals_used": [
            "static int udf_update_inode(struct inode *, int);",
            "static int udf_sync_inode(struct inode *inode);",
            "static void udf_split_extents(struct inode *, int *, int, int,\n\t\t\t      struct kernel_long_ad[EXTENT_MERGE_SIZE], int *);",
            "static void udf_prealloc_extents(struct inode *, int, int,\n\t\t\t\t struct kernel_long_ad[EXTENT_MERGE_SIZE], int *);",
            "static void udf_merge_extents(struct inode *,\n\t\t\t      struct kernel_long_ad[EXTENT_MERGE_SIZE], int *);",
            "static void udf_update_extents(struct inode *,\n\t\t\t       struct kernel_long_ad[EXTENT_MERGE_SIZE], int, int,\n\t\t\t       struct extent_position *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/crc-itu-t.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include \"udfdecl.h\"\n\n#define EXTENT_MERGE_SIZE 5\n\nstatic int udf_update_inode(struct inode *, int);\nstatic int udf_sync_inode(struct inode *inode);\nstatic void udf_split_extents(struct inode *, int *, int, int,\n\t\t\t      struct kernel_long_ad[EXTENT_MERGE_SIZE], int *);\nstatic void udf_prealloc_extents(struct inode *, int, int,\n\t\t\t\t struct kernel_long_ad[EXTENT_MERGE_SIZE], int *);\nstatic void udf_merge_extents(struct inode *,\n\t\t\t      struct kernel_long_ad[EXTENT_MERGE_SIZE], int *);\nstatic void udf_update_extents(struct inode *,\n\t\t\t       struct kernel_long_ad[EXTENT_MERGE_SIZE], int, int,\n\t\t\t       struct extent_position *);\n\nstatic void udf_prealloc_extents(struct inode *inode, int c, int lastblock,\n\t\t\t\t struct kernel_long_ad laarr[EXTENT_MERGE_SIZE],\n\t\t\t\t int *endnum)\n{\n\tint start, length = 0, currlength = 0, i;\n\n\tif (*endnum >= (c + 1)) {\n\t\tif (!lastblock)\n\t\t\treturn;\n\t\telse\n\t\t\tstart = c;\n\t} else {\n\t\tif ((laarr[c + 1].extLength >> 30) ==\n\t\t\t\t\t(EXT_NOT_RECORDED_ALLOCATED >> 30)) {\n\t\t\tstart = c + 1;\n\t\t\tlength = currlength =\n\t\t\t\t(((laarr[c + 1].extLength &\n\t\t\t\t\tUDF_EXTENT_LENGTH_MASK) +\n\t\t\t\tinode->i_sb->s_blocksize - 1) >>\n\t\t\t\tinode->i_sb->s_blocksize_bits);\n\t\t} else\n\t\t\tstart = c;\n\t}\n\n\tfor (i = start + 1; i <= *endnum; i++) {\n\t\tif (i == *endnum) {\n\t\t\tif (lastblock)\n\t\t\t\tlength += UDF_DEFAULT_PREALLOC_BLOCKS;\n\t\t} else if ((laarr[i].extLength >> 30) ==\n\t\t\t\t(EXT_NOT_RECORDED_NOT_ALLOCATED >> 30)) {\n\t\t\tlength += (((laarr[i].extLength &\n\t\t\t\t\t\tUDF_EXTENT_LENGTH_MASK) +\n\t\t\t\t    inode->i_sb->s_blocksize - 1) >>\n\t\t\t\t    inode->i_sb->s_blocksize_bits);\n\t\t} else\n\t\t\tbreak;\n\t}\n\n\tif (length) {\n\t\tint next = laarr[start].extLocation.logicalBlockNum +\n\t\t\t(((laarr[start].extLength & UDF_EXTENT_LENGTH_MASK) +\n\t\t\t  inode->i_sb->s_blocksize - 1) >>\n\t\t\t  inode->i_sb->s_blocksize_bits);\n\t\tint numalloc = udf_prealloc_blocks(inode->i_sb, inode,\n\t\t\t\tlaarr[start].extLocation.partitionReferenceNum,\n\t\t\t\tnext, (UDF_DEFAULT_PREALLOC_BLOCKS > length ?\n\t\t\t\tlength : UDF_DEFAULT_PREALLOC_BLOCKS) -\n\t\t\t\tcurrlength);\n\t\tif (numalloc) \t{\n\t\t\tif (start == (c + 1))\n\t\t\t\tlaarr[start].extLength +=\n\t\t\t\t\t(numalloc <<\n\t\t\t\t\t inode->i_sb->s_blocksize_bits);\n\t\t\telse {\n\t\t\t\tmemmove(&laarr[c + 2], &laarr[c + 1],\n\t\t\t\t\tsizeof(struct long_ad) * (*endnum - (c + 1)));\n\t\t\t\t(*endnum)++;\n\t\t\t\tlaarr[c + 1].extLocation.logicalBlockNum = next;\n\t\t\t\tlaarr[c + 1].extLocation.partitionReferenceNum =\n\t\t\t\t\tlaarr[c].extLocation.\n\t\t\t\t\t\t\tpartitionReferenceNum;\n\t\t\t\tlaarr[c + 1].extLength =\n\t\t\t\t\tEXT_NOT_RECORDED_ALLOCATED |\n\t\t\t\t\t(numalloc <<\n\t\t\t\t\t inode->i_sb->s_blocksize_bits);\n\t\t\t\tstart = c + 1;\n\t\t\t}\n\n\t\t\tfor (i = start + 1; numalloc && i < *endnum; i++) {\n\t\t\t\tint elen = ((laarr[i].extLength &\n\t\t\t\t\t\tUDF_EXTENT_LENGTH_MASK) +\n\t\t\t\t\t    inode->i_sb->s_blocksize - 1) >>\n\t\t\t\t\t    inode->i_sb->s_blocksize_bits;\n\n\t\t\t\tif (elen > numalloc) {\n\t\t\t\t\tlaarr[i].extLength -=\n\t\t\t\t\t\t(numalloc <<\n\t\t\t\t\t\t inode->i_sb->s_blocksize_bits);\n\t\t\t\t\tnumalloc = 0;\n\t\t\t\t} else {\n\t\t\t\t\tnumalloc -= elen;\n\t\t\t\t\tif (*endnum > (i + 1))\n\t\t\t\t\t\tmemmove(&laarr[i],\n\t\t\t\t\t\t\t&laarr[i + 1],\n\t\t\t\t\t\t\tsizeof(struct long_ad) *\n\t\t\t\t\t\t\t(*endnum - (i + 1)));\n\t\t\t\t\ti--;\n\t\t\t\t\t(*endnum)--;\n\t\t\t\t}\n\t\t\t}\n\t\t\tUDF_I(inode)->i_lenExtents +=\n\t\t\t\tnumalloc << inode->i_sb->s_blocksize_bits;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "inode->i_mode"
          ],
          "line": 858
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udf_split_extents",
          "args": [
            "inode",
            "&c",
            "offset",
            "newblocknum",
            "laarr",
            "&endnum"
          ],
          "line": 851
        },
        "resolved": true,
        "details": {
          "function_name": "udf_split_extents",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/inode.c",
          "lines": "893-956",
          "snippet": "static void udf_split_extents(struct inode *inode, int *c, int offset,\n\t\t\t      int newblocknum,\n\t\t\t      struct kernel_long_ad laarr[EXTENT_MERGE_SIZE],\n\t\t\t      int *endnum)\n{\n\tunsigned long blocksize = inode->i_sb->s_blocksize;\n\tunsigned char blocksize_bits = inode->i_sb->s_blocksize_bits;\n\n\tif ((laarr[*c].extLength >> 30) == (EXT_NOT_RECORDED_ALLOCATED >> 30) ||\n\t    (laarr[*c].extLength >> 30) ==\n\t\t\t\t(EXT_NOT_RECORDED_NOT_ALLOCATED >> 30)) {\n\t\tint curr = *c;\n\t\tint blen = ((laarr[curr].extLength & UDF_EXTENT_LENGTH_MASK) +\n\t\t\t    blocksize - 1) >> blocksize_bits;\n\t\tint8_t etype = (laarr[curr].extLength >> 30);\n\n\t\tif (blen == 1)\n\t\t\t;\n\t\telse if (!offset || blen == offset + 1) {\n\t\t\tlaarr[curr + 2] = laarr[curr + 1];\n\t\t\tlaarr[curr + 1] = laarr[curr];\n\t\t} else {\n\t\t\tlaarr[curr + 3] = laarr[curr + 1];\n\t\t\tlaarr[curr + 2] = laarr[curr + 1] = laarr[curr];\n\t\t}\n\n\t\tif (offset) {\n\t\t\tif (etype == (EXT_NOT_RECORDED_ALLOCATED >> 30)) {\n\t\t\t\tudf_free_blocks(inode->i_sb, inode,\n\t\t\t\t\t\t&laarr[curr].extLocation,\n\t\t\t\t\t\t0, offset);\n\t\t\t\tlaarr[curr].extLength =\n\t\t\t\t\tEXT_NOT_RECORDED_NOT_ALLOCATED |\n\t\t\t\t\t(offset << blocksize_bits);\n\t\t\t\tlaarr[curr].extLocation.logicalBlockNum = 0;\n\t\t\t\tlaarr[curr].extLocation.\n\t\t\t\t\t\tpartitionReferenceNum = 0;\n\t\t\t} else\n\t\t\t\tlaarr[curr].extLength = (etype << 30) |\n\t\t\t\t\t(offset << blocksize_bits);\n\t\t\tcurr++;\n\t\t\t(*c)++;\n\t\t\t(*endnum)++;\n\t\t}\n\n\t\tlaarr[curr].extLocation.logicalBlockNum = newblocknum;\n\t\tif (etype == (EXT_NOT_RECORDED_NOT_ALLOCATED >> 30))\n\t\t\tlaarr[curr].extLocation.partitionReferenceNum =\n\t\t\t\tUDF_I(inode)->i_location.partitionReferenceNum;\n\t\tlaarr[curr].extLength = EXT_RECORDED_ALLOCATED |\n\t\t\tblocksize;\n\t\tcurr++;\n\n\t\tif (blen != offset + 1) {\n\t\t\tif (etype == (EXT_NOT_RECORDED_ALLOCATED >> 30))\n\t\t\t\tlaarr[curr].extLocation.logicalBlockNum +=\n\t\t\t\t\t\t\t\toffset + 1;\n\t\t\tlaarr[curr].extLength = (etype << 30) |\n\t\t\t\t((blen - (offset + 1)) << blocksize_bits);\n\t\t\tcurr++;\n\t\t\t(*endnum)++;\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"udf_sb.h\"",
            "#include \"udf_i.h\"",
            "#include <linux/aio.h>",
            "#include <linux/mpage.h>",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [
            "#define EXTENT_MERGE_SIZE 5"
          ],
          "globals_used": [
            "static int udf_update_inode(struct inode *, int);",
            "static int udf_sync_inode(struct inode *inode);",
            "static void udf_split_extents(struct inode *, int *, int, int,\n\t\t\t      struct kernel_long_ad[EXTENT_MERGE_SIZE], int *);",
            "static void udf_prealloc_extents(struct inode *, int, int,\n\t\t\t\t struct kernel_long_ad[EXTENT_MERGE_SIZE], int *);",
            "static void udf_merge_extents(struct inode *,\n\t\t\t      struct kernel_long_ad[EXTENT_MERGE_SIZE], int *);",
            "static void udf_update_extents(struct inode *,\n\t\t\t       struct kernel_long_ad[EXTENT_MERGE_SIZE], int, int,\n\t\t\t       struct extent_position *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/crc-itu-t.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include \"udfdecl.h\"\n\n#define EXTENT_MERGE_SIZE 5\n\nstatic int udf_update_inode(struct inode *, int);\nstatic int udf_sync_inode(struct inode *inode);\nstatic void udf_split_extents(struct inode *, int *, int, int,\n\t\t\t      struct kernel_long_ad[EXTENT_MERGE_SIZE], int *);\nstatic void udf_prealloc_extents(struct inode *, int, int,\n\t\t\t\t struct kernel_long_ad[EXTENT_MERGE_SIZE], int *);\nstatic void udf_merge_extents(struct inode *,\n\t\t\t      struct kernel_long_ad[EXTENT_MERGE_SIZE], int *);\nstatic void udf_update_extents(struct inode *,\n\t\t\t       struct kernel_long_ad[EXTENT_MERGE_SIZE], int, int,\n\t\t\t       struct extent_position *);\n\nstatic void udf_split_extents(struct inode *inode, int *c, int offset,\n\t\t\t      int newblocknum,\n\t\t\t      struct kernel_long_ad laarr[EXTENT_MERGE_SIZE],\n\t\t\t      int *endnum)\n{\n\tunsigned long blocksize = inode->i_sb->s_blocksize;\n\tunsigned char blocksize_bits = inode->i_sb->s_blocksize_bits;\n\n\tif ((laarr[*c].extLength >> 30) == (EXT_NOT_RECORDED_ALLOCATED >> 30) ||\n\t    (laarr[*c].extLength >> 30) ==\n\t\t\t\t(EXT_NOT_RECORDED_NOT_ALLOCATED >> 30)) {\n\t\tint curr = *c;\n\t\tint blen = ((laarr[curr].extLength & UDF_EXTENT_LENGTH_MASK) +\n\t\t\t    blocksize - 1) >> blocksize_bits;\n\t\tint8_t etype = (laarr[curr].extLength >> 30);\n\n\t\tif (blen == 1)\n\t\t\t;\n\t\telse if (!offset || blen == offset + 1) {\n\t\t\tlaarr[curr + 2] = laarr[curr + 1];\n\t\t\tlaarr[curr + 1] = laarr[curr];\n\t\t} else {\n\t\t\tlaarr[curr + 3] = laarr[curr + 1];\n\t\t\tlaarr[curr + 2] = laarr[curr + 1] = laarr[curr];\n\t\t}\n\n\t\tif (offset) {\n\t\t\tif (etype == (EXT_NOT_RECORDED_ALLOCATED >> 30)) {\n\t\t\t\tudf_free_blocks(inode->i_sb, inode,\n\t\t\t\t\t\t&laarr[curr].extLocation,\n\t\t\t\t\t\t0, offset);\n\t\t\t\tlaarr[curr].extLength =\n\t\t\t\t\tEXT_NOT_RECORDED_NOT_ALLOCATED |\n\t\t\t\t\t(offset << blocksize_bits);\n\t\t\t\tlaarr[curr].extLocation.logicalBlockNum = 0;\n\t\t\t\tlaarr[curr].extLocation.\n\t\t\t\t\t\tpartitionReferenceNum = 0;\n\t\t\t} else\n\t\t\t\tlaarr[curr].extLength = (etype << 30) |\n\t\t\t\t\t(offset << blocksize_bits);\n\t\t\tcurr++;\n\t\t\t(*c)++;\n\t\t\t(*endnum)++;\n\t\t}\n\n\t\tlaarr[curr].extLocation.logicalBlockNum = newblocknum;\n\t\tif (etype == (EXT_NOT_RECORDED_NOT_ALLOCATED >> 30))\n\t\t\tlaarr[curr].extLocation.partitionReferenceNum =\n\t\t\t\tUDF_I(inode)->i_location.partitionReferenceNum;\n\t\tlaarr[curr].extLength = EXT_RECORDED_ALLOCATED |\n\t\t\tblocksize;\n\t\tcurr++;\n\n\t\tif (blen != offset + 1) {\n\t\t\tif (etype == (EXT_NOT_RECORDED_ALLOCATED >> 30))\n\t\t\t\tlaarr[curr].extLocation.logicalBlockNum +=\n\t\t\t\t\t\t\t\toffset + 1;\n\t\t\tlaarr[curr].extLength = (etype << 30) |\n\t\t\t\t((blen - (offset + 1)) << blocksize_bits);\n\t\t\tcurr++;\n\t\t\t(*endnum)++;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_new_block",
          "args": [
            "inode->i_sb",
            "inode",
            "iinfo->i_location.partitionReferenceNum",
            "goal",
            "err"
          ],
          "line": 833
        },
        "resolved": true,
        "details": {
          "function_name": "udf_new_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/balloc.c",
          "lines": "795-825",
          "snippet": "inline int udf_new_block(struct super_block *sb,\n\t\t\t struct inode *inode,\n\t\t\t uint16_t partition, uint32_t goal, int *err)\n{\n\tstruct udf_part_map *map = &UDF_SB(sb)->s_partmaps[partition];\n\tint block;\n\n\tif (map->s_partition_flags & UDF_PART_FLAG_UNALLOC_BITMAP)\n\t\tblock = udf_bitmap_new_block(sb,\n\t\t\t\t\t     map->s_uspace.s_bitmap,\n\t\t\t\t\t     partition, goal, err);\n\telse if (map->s_partition_flags & UDF_PART_FLAG_UNALLOC_TABLE)\n\t\tblock = udf_table_new_block(sb,\n\t\t\t\t\t    map->s_uspace.s_table,\n\t\t\t\t\t    partition, goal, err);\n\telse if (map->s_partition_flags & UDF_PART_FLAG_FREED_BITMAP)\n\t\tblock = udf_bitmap_new_block(sb,\n\t\t\t\t\t     map->s_fspace.s_bitmap,\n\t\t\t\t\t     partition, goal, err);\n\telse if (map->s_partition_flags & UDF_PART_FLAG_FREED_TABLE)\n\t\tblock = udf_table_new_block(sb,\n\t\t\t\t\t    map->s_fspace.s_table,\n\t\t\t\t\t    partition, goal, err);\n\telse {\n\t\t*err = -EIO;\n\t\treturn 0;\n\t}\n\tif (inode && block)\n\t\tinode_add_bytes(inode, sb->s_blocksize);\n\treturn block;\n}",
          "includes": [
            "#include \"udf_sb.h\"",
            "#include \"udf_i.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/buffer_head.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/bitops.h>\n#include <linux/buffer_head.h>\n#include \"udfdecl.h\"\n\ninline int udf_new_block(struct super_block *sb,\n\t\t\t struct inode *inode,\n\t\t\t uint16_t partition, uint32_t goal, int *err)\n{\n\tstruct udf_part_map *map = &UDF_SB(sb)->s_partmaps[partition];\n\tint block;\n\n\tif (map->s_partition_flags & UDF_PART_FLAG_UNALLOC_BITMAP)\n\t\tblock = udf_bitmap_new_block(sb,\n\t\t\t\t\t     map->s_uspace.s_bitmap,\n\t\t\t\t\t     partition, goal, err);\n\telse if (map->s_partition_flags & UDF_PART_FLAG_UNALLOC_TABLE)\n\t\tblock = udf_table_new_block(sb,\n\t\t\t\t\t    map->s_uspace.s_table,\n\t\t\t\t\t    partition, goal, err);\n\telse if (map->s_partition_flags & UDF_PART_FLAG_FREED_BITMAP)\n\t\tblock = udf_bitmap_new_block(sb,\n\t\t\t\t\t     map->s_fspace.s_bitmap,\n\t\t\t\t\t     partition, goal, err);\n\telse if (map->s_partition_flags & UDF_PART_FLAG_FREED_TABLE)\n\t\tblock = udf_table_new_block(sb,\n\t\t\t\t\t    map->s_fspace.s_table,\n\t\t\t\t\t    partition, goal, err);\n\telse {\n\t\t*err = -EIO;\n\t\treturn 0;\n\t}\n\tif (inode && block)\n\t\tinode_add_bytes(inode, sb->s_blocksize);\n\treturn block;\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_next_aext",
          "args": [
            "inode",
            "&next_epos",
            "&eloc",
            "&elen",
            "0"
          ],
          "line": 809
        },
        "resolved": true,
        "details": {
          "function_name": "udf_next_aext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/inode.c",
          "lines": "2057-2077",
          "snippet": "int8_t udf_next_aext(struct inode *inode, struct extent_position *epos,\n\t\t     struct kernel_lb_addr *eloc, uint32_t *elen, int inc)\n{\n\tint8_t etype;\n\n\twhile ((etype = udf_current_aext(inode, epos, eloc, elen, inc)) ==\n\t       (EXT_NEXT_EXTENT_ALLOCDECS >> 30)) {\n\t\tint block;\n\t\tepos->block = *eloc;\n\t\tepos->offset = sizeof(struct allocExtDesc);\n\t\tbrelse(epos->bh);\n\t\tblock = udf_get_lb_pblock(inode->i_sb, &epos->block, 0);\n\t\tepos->bh = udf_tread(inode->i_sb, block);\n\t\tif (!epos->bh) {\n\t\t\tudf_debug(\"reading block %d failed!\\n\", block);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn etype;\n}",
          "includes": [
            "#include \"udf_sb.h\"",
            "#include \"udf_i.h\"",
            "#include <linux/aio.h>",
            "#include <linux/mpage.h>",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int udf_update_inode(struct inode *, int);",
            "static int udf_sync_inode(struct inode *inode);",
            "static int8_t udf_insert_aext(struct inode *, struct extent_position,\n\t\t\t      struct kernel_lb_addr, uint32_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/crc-itu-t.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include \"udfdecl.h\"\n\nstatic int udf_update_inode(struct inode *, int);\nstatic int udf_sync_inode(struct inode *inode);\nstatic int8_t udf_insert_aext(struct inode *, struct extent_position,\n\t\t\t      struct kernel_lb_addr, uint32_t);\n\nint8_t udf_next_aext(struct inode *inode, struct extent_position *epos,\n\t\t     struct kernel_lb_addr *eloc, uint32_t *elen, int inc)\n{\n\tint8_t etype;\n\n\twhile ((etype = udf_current_aext(inode, epos, eloc, elen, inc)) ==\n\t       (EXT_NEXT_EXTENT_ALLOCDECS >> 30)) {\n\t\tint block;\n\t\tepos->block = *eloc;\n\t\tepos->offset = sizeof(struct allocExtDesc);\n\t\tbrelse(epos->bh);\n\t\tblock = udf_get_lb_pblock(inode->i_sb, &epos->block, 0);\n\t\tepos->bh = udf_tread(inode->i_sb, block);\n\t\tif (!epos->bh) {\n\t\t\tudf_debug(\"reading block %d failed!\\n\", block);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn etype;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&laarr[c].extLocation",
            "0x00",
            "sizeof(struct kernel_lb_addr)"
          ],
          "line": 788
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udf_do_extend_file",
          "args": [
            "inode",
            "&prev_epos",
            "laarr",
            "offset"
          ],
          "line": 768
        },
        "resolved": true,
        "details": {
          "function_name": "udf_do_extend_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/inode.c",
          "lines": "485-599",
          "snippet": "static int udf_do_extend_file(struct inode *inode,\n\t\t\t      struct extent_position *last_pos,\n\t\t\t      struct kernel_long_ad *last_ext,\n\t\t\t      sector_t blocks)\n{\n\tsector_t add;\n\tint count = 0, fake = !(last_ext->extLength & UDF_EXTENT_LENGTH_MASK);\n\tstruct super_block *sb = inode->i_sb;\n\tstruct kernel_lb_addr prealloc_loc = {};\n\tint prealloc_len = 0;\n\tstruct udf_inode_info *iinfo;\n\tint err;\n\n\t/* The previous extent is fake and we should not extend by anything\n\t * - there's nothing to do... */\n\tif (!blocks && fake)\n\t\treturn 0;\n\n\tiinfo = UDF_I(inode);\n\t/* Round the last extent up to a multiple of block size */\n\tif (last_ext->extLength & (sb->s_blocksize - 1)) {\n\t\tlast_ext->extLength =\n\t\t\t(last_ext->extLength & UDF_EXTENT_FLAG_MASK) |\n\t\t\t(((last_ext->extLength & UDF_EXTENT_LENGTH_MASK) +\n\t\t\t  sb->s_blocksize - 1) & ~(sb->s_blocksize - 1));\n\t\tiinfo->i_lenExtents =\n\t\t\t(iinfo->i_lenExtents + sb->s_blocksize - 1) &\n\t\t\t~(sb->s_blocksize - 1);\n\t}\n\n\t/* Last extent are just preallocated blocks? */\n\tif ((last_ext->extLength & UDF_EXTENT_FLAG_MASK) ==\n\t\t\t\t\t\tEXT_NOT_RECORDED_ALLOCATED) {\n\t\t/* Save the extent so that we can reattach it to the end */\n\t\tprealloc_loc = last_ext->extLocation;\n\t\tprealloc_len = last_ext->extLength;\n\t\t/* Mark the extent as a hole */\n\t\tlast_ext->extLength = EXT_NOT_RECORDED_NOT_ALLOCATED |\n\t\t\t(last_ext->extLength & UDF_EXTENT_LENGTH_MASK);\n\t\tlast_ext->extLocation.logicalBlockNum = 0;\n\t\tlast_ext->extLocation.partitionReferenceNum = 0;\n\t}\n\n\t/* Can we merge with the previous extent? */\n\tif ((last_ext->extLength & UDF_EXTENT_FLAG_MASK) ==\n\t\t\t\t\tEXT_NOT_RECORDED_NOT_ALLOCATED) {\n\t\tadd = ((1 << 30) - sb->s_blocksize -\n\t\t\t(last_ext->extLength & UDF_EXTENT_LENGTH_MASK)) >>\n\t\t\tsb->s_blocksize_bits;\n\t\tif (add > blocks)\n\t\t\tadd = blocks;\n\t\tblocks -= add;\n\t\tlast_ext->extLength += add << sb->s_blocksize_bits;\n\t}\n\n\tif (fake) {\n\t\tudf_add_aext(inode, last_pos, &last_ext->extLocation,\n\t\t\t     last_ext->extLength, 1);\n\t\tcount++;\n\t} else\n\t\tudf_write_aext(inode, last_pos, &last_ext->extLocation,\n\t\t\t\tlast_ext->extLength, 1);\n\n\t/* Managed to do everything necessary? */\n\tif (!blocks)\n\t\tgoto out;\n\n\t/* All further extents will be NOT_RECORDED_NOT_ALLOCATED */\n\tlast_ext->extLocation.logicalBlockNum = 0;\n\tlast_ext->extLocation.partitionReferenceNum = 0;\n\tadd = (1 << (30-sb->s_blocksize_bits)) - 1;\n\tlast_ext->extLength = EXT_NOT_RECORDED_NOT_ALLOCATED |\n\t\t\t\t(add << sb->s_blocksize_bits);\n\n\t/* Create enough extents to cover the whole hole */\n\twhile (blocks > add) {\n\t\tblocks -= add;\n\t\terr = udf_add_aext(inode, last_pos, &last_ext->extLocation,\n\t\t\t\t   last_ext->extLength, 1);\n\t\tif (err)\n\t\t\treturn err;\n\t\tcount++;\n\t}\n\tif (blocks) {\n\t\tlast_ext->extLength = EXT_NOT_RECORDED_NOT_ALLOCATED |\n\t\t\t(blocks << sb->s_blocksize_bits);\n\t\terr = udf_add_aext(inode, last_pos, &last_ext->extLocation,\n\t\t\t\t   last_ext->extLength, 1);\n\t\tif (err)\n\t\t\treturn err;\n\t\tcount++;\n\t}\n\nout:\n\t/* Do we have some preallocated blocks saved? */\n\tif (prealloc_len) {\n\t\terr = udf_add_aext(inode, last_pos, &prealloc_loc,\n\t\t\t\t   prealloc_len, 1);\n\t\tif (err)\n\t\t\treturn err;\n\t\tlast_ext->extLocation = prealloc_loc;\n\t\tlast_ext->extLength = prealloc_len;\n\t\tcount++;\n\t}\n\n\t/* last_pos should point to the last written extent... */\n\tif (iinfo->i_alloc_type == ICBTAG_FLAG_AD_SHORT)\n\t\tlast_pos->offset -= sizeof(struct short_ad);\n\telse if (iinfo->i_alloc_type == ICBTAG_FLAG_AD_LONG)\n\t\tlast_pos->offset -= sizeof(struct long_ad);\n\telse\n\t\treturn -EIO;\n\n\treturn count;\n}",
          "includes": [
            "#include \"udf_sb.h\"",
            "#include \"udf_i.h\"",
            "#include <linux/aio.h>",
            "#include <linux/mpage.h>",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int udf_update_inode(struct inode *, int);",
            "static int udf_sync_inode(struct inode *inode);",
            "static int udf_alloc_i_data(struct inode *inode, size_t size);",
            "static sector_t inode_getblk(struct inode *, sector_t, int *, int *);",
            "static void udf_split_extents(struct inode *, int *, int, int,\n\t\t\t      struct kernel_long_ad[EXTENT_MERGE_SIZE], int *);",
            "static void udf_prealloc_extents(struct inode *, int, int,\n\t\t\t\t struct kernel_long_ad[EXTENT_MERGE_SIZE], int *);",
            "static void udf_merge_extents(struct inode *,\n\t\t\t      struct kernel_long_ad[EXTENT_MERGE_SIZE], int *);",
            "static void udf_update_extents(struct inode *,\n\t\t\t       struct kernel_long_ad[EXTENT_MERGE_SIZE], int, int,\n\t\t\t       struct extent_position *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/crc-itu-t.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include \"udfdecl.h\"\n\nstatic int udf_update_inode(struct inode *, int);\nstatic int udf_sync_inode(struct inode *inode);\nstatic int udf_alloc_i_data(struct inode *inode, size_t size);\nstatic sector_t inode_getblk(struct inode *, sector_t, int *, int *);\nstatic void udf_split_extents(struct inode *, int *, int, int,\n\t\t\t      struct kernel_long_ad[EXTENT_MERGE_SIZE], int *);\nstatic void udf_prealloc_extents(struct inode *, int, int,\n\t\t\t\t struct kernel_long_ad[EXTENT_MERGE_SIZE], int *);\nstatic void udf_merge_extents(struct inode *,\n\t\t\t      struct kernel_long_ad[EXTENT_MERGE_SIZE], int *);\nstatic void udf_update_extents(struct inode *,\n\t\t\t       struct kernel_long_ad[EXTENT_MERGE_SIZE], int, int,\n\t\t\t       struct extent_position *);\n\nstatic int udf_do_extend_file(struct inode *inode,\n\t\t\t      struct extent_position *last_pos,\n\t\t\t      struct kernel_long_ad *last_ext,\n\t\t\t      sector_t blocks)\n{\n\tsector_t add;\n\tint count = 0, fake = !(last_ext->extLength & UDF_EXTENT_LENGTH_MASK);\n\tstruct super_block *sb = inode->i_sb;\n\tstruct kernel_lb_addr prealloc_loc = {};\n\tint prealloc_len = 0;\n\tstruct udf_inode_info *iinfo;\n\tint err;\n\n\t/* The previous extent is fake and we should not extend by anything\n\t * - there's nothing to do... */\n\tif (!blocks && fake)\n\t\treturn 0;\n\n\tiinfo = UDF_I(inode);\n\t/* Round the last extent up to a multiple of block size */\n\tif (last_ext->extLength & (sb->s_blocksize - 1)) {\n\t\tlast_ext->extLength =\n\t\t\t(last_ext->extLength & UDF_EXTENT_FLAG_MASK) |\n\t\t\t(((last_ext->extLength & UDF_EXTENT_LENGTH_MASK) +\n\t\t\t  sb->s_blocksize - 1) & ~(sb->s_blocksize - 1));\n\t\tiinfo->i_lenExtents =\n\t\t\t(iinfo->i_lenExtents + sb->s_blocksize - 1) &\n\t\t\t~(sb->s_blocksize - 1);\n\t}\n\n\t/* Last extent are just preallocated blocks? */\n\tif ((last_ext->extLength & UDF_EXTENT_FLAG_MASK) ==\n\t\t\t\t\t\tEXT_NOT_RECORDED_ALLOCATED) {\n\t\t/* Save the extent so that we can reattach it to the end */\n\t\tprealloc_loc = last_ext->extLocation;\n\t\tprealloc_len = last_ext->extLength;\n\t\t/* Mark the extent as a hole */\n\t\tlast_ext->extLength = EXT_NOT_RECORDED_NOT_ALLOCATED |\n\t\t\t(last_ext->extLength & UDF_EXTENT_LENGTH_MASK);\n\t\tlast_ext->extLocation.logicalBlockNum = 0;\n\t\tlast_ext->extLocation.partitionReferenceNum = 0;\n\t}\n\n\t/* Can we merge with the previous extent? */\n\tif ((last_ext->extLength & UDF_EXTENT_FLAG_MASK) ==\n\t\t\t\t\tEXT_NOT_RECORDED_NOT_ALLOCATED) {\n\t\tadd = ((1 << 30) - sb->s_blocksize -\n\t\t\t(last_ext->extLength & UDF_EXTENT_LENGTH_MASK)) >>\n\t\t\tsb->s_blocksize_bits;\n\t\tif (add > blocks)\n\t\t\tadd = blocks;\n\t\tblocks -= add;\n\t\tlast_ext->extLength += add << sb->s_blocksize_bits;\n\t}\n\n\tif (fake) {\n\t\tudf_add_aext(inode, last_pos, &last_ext->extLocation,\n\t\t\t     last_ext->extLength, 1);\n\t\tcount++;\n\t} else\n\t\tudf_write_aext(inode, last_pos, &last_ext->extLocation,\n\t\t\t\tlast_ext->extLength, 1);\n\n\t/* Managed to do everything necessary? */\n\tif (!blocks)\n\t\tgoto out;\n\n\t/* All further extents will be NOT_RECORDED_NOT_ALLOCATED */\n\tlast_ext->extLocation.logicalBlockNum = 0;\n\tlast_ext->extLocation.partitionReferenceNum = 0;\n\tadd = (1 << (30-sb->s_blocksize_bits)) - 1;\n\tlast_ext->extLength = EXT_NOT_RECORDED_NOT_ALLOCATED |\n\t\t\t\t(add << sb->s_blocksize_bits);\n\n\t/* Create enough extents to cover the whole hole */\n\twhile (blocks > add) {\n\t\tblocks -= add;\n\t\terr = udf_add_aext(inode, last_pos, &last_ext->extLocation,\n\t\t\t\t   last_ext->extLength, 1);\n\t\tif (err)\n\t\t\treturn err;\n\t\tcount++;\n\t}\n\tif (blocks) {\n\t\tlast_ext->extLength = EXT_NOT_RECORDED_NOT_ALLOCATED |\n\t\t\t(blocks << sb->s_blocksize_bits);\n\t\terr = udf_add_aext(inode, last_pos, &last_ext->extLocation,\n\t\t\t\t   last_ext->extLength, 1);\n\t\tif (err)\n\t\t\treturn err;\n\t\tcount++;\n\t}\n\nout:\n\t/* Do we have some preallocated blocks saved? */\n\tif (prealloc_len) {\n\t\terr = udf_add_aext(inode, last_pos, &prealloc_loc,\n\t\t\t\t   prealloc_len, 1);\n\t\tif (err)\n\t\t\treturn err;\n\t\tlast_ext->extLocation = prealloc_loc;\n\t\tlast_ext->extLength = prealloc_len;\n\t\tcount++;\n\t}\n\n\t/* last_pos should point to the last written extent... */\n\tif (iinfo->i_alloc_type == ICBTAG_FLAG_AD_SHORT)\n\t\tlast_pos->offset -= sizeof(struct short_ad);\n\telse if (iinfo->i_alloc_type == ICBTAG_FLAG_AD_LONG)\n\t\tlast_pos->offset -= sizeof(struct long_ad);\n\telse\n\t\treturn -EIO;\n\n\treturn count;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&laarr[0].extLocation",
            "0x00",
            "sizeof(struct kernel_lb_addr)"
          ],
          "line": 760
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udf_get_lb_pblock",
          "args": [
            "inode->i_sb",
            "&eloc",
            "offset"
          ],
          "line": 746
        },
        "resolved": true,
        "details": {
          "function_name": "udf_get_lb_pblock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/udfdecl.h",
          "lines": "205-211",
          "snippet": "static inline uint32_t\nudf_get_lb_pblock(struct super_block *sb, struct kernel_lb_addr *loc,\n\t\t  uint32_t offset)\n{\n\treturn udf_get_pblock(sb, loc->logicalBlockNum,\n\t\t\tloc->partitionReferenceNum, offset);\n}",
          "includes": [
            "#include \"udf_i.h\"",
            "#include \"udfend.h\"",
            "#include \"udf_sb.h\"",
            "#include <linux/udf_fs_i.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include \"osta_udf.h\"",
            "#include \"ecma_167.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_i.h\"\n#include \"udfend.h\"\n#include \"udf_sb.h\"\n#include <linux/udf_fs_i.h>\n#include <linux/buffer_head.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include \"osta_udf.h\"\n#include \"ecma_167.h\"\n\nstatic inline uint32_t\nudf_get_lb_pblock(struct super_block *sb, struct kernel_lb_addr *loc,\n\t\t  uint32_t offset)\n{\n\treturn udf_get_pblock(sb, loc->logicalBlockNum,\n\t\t\tloc->partitionReferenceNum, offset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_write_aext",
          "args": [
            "inode",
            "&cur_epos",
            "&eloc",
            "elen",
            "1"
          ],
          "line": 741
        },
        "resolved": true,
        "details": {
          "function_name": "udf_write_aext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/inode.c",
          "lines": "2005-2055",
          "snippet": "void udf_write_aext(struct inode *inode, struct extent_position *epos,\n\t\t    struct kernel_lb_addr *eloc, uint32_t elen, int inc)\n{\n\tint adsize;\n\tuint8_t *ptr;\n\tstruct short_ad *sad;\n\tstruct long_ad *lad;\n\tstruct udf_inode_info *iinfo = UDF_I(inode);\n\n\tif (!epos->bh)\n\t\tptr = iinfo->i_ext.i_data + epos->offset -\n\t\t\tudf_file_entry_alloc_offset(inode) +\n\t\t\tiinfo->i_lenEAttr;\n\telse\n\t\tptr = epos->bh->b_data + epos->offset;\n\n\tswitch (iinfo->i_alloc_type) {\n\tcase ICBTAG_FLAG_AD_SHORT:\n\t\tsad = (struct short_ad *)ptr;\n\t\tsad->extLength = cpu_to_le32(elen);\n\t\tsad->extPosition = cpu_to_le32(eloc->logicalBlockNum);\n\t\tadsize = sizeof(struct short_ad);\n\t\tbreak;\n\tcase ICBTAG_FLAG_AD_LONG:\n\t\tlad = (struct long_ad *)ptr;\n\t\tlad->extLength = cpu_to_le32(elen);\n\t\tlad->extLocation = cpu_to_lelb(*eloc);\n\t\tmemset(lad->impUse, 0x00, sizeof(lad->impUse));\n\t\tadsize = sizeof(struct long_ad);\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\n\tif (epos->bh) {\n\t\tif (!UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_STRICT) ||\n\t\t    UDF_SB(inode->i_sb)->s_udfrev >= 0x0201) {\n\t\t\tstruct allocExtDesc *aed =\n\t\t\t\t(struct allocExtDesc *)epos->bh->b_data;\n\t\t\tudf_update_tag(epos->bh->b_data,\n\t\t\t\t       le32_to_cpu(aed->lengthAllocDescs) +\n\t\t\t\t       sizeof(struct allocExtDesc));\n\t\t}\n\t\tmark_buffer_dirty_inode(epos->bh, inode);\n\t} else {\n\t\tmark_inode_dirty(inode);\n\t}\n\n\tif (inc)\n\t\tepos->offset += adsize;\n}",
          "includes": [
            "#include \"udf_sb.h\"",
            "#include \"udf_i.h\"",
            "#include <linux/aio.h>",
            "#include <linux/mpage.h>",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int udf_update_inode(struct inode *, int);",
            "static int udf_sync_inode(struct inode *inode);",
            "static int8_t udf_insert_aext(struct inode *, struct extent_position,\n\t\t\t      struct kernel_lb_addr, uint32_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/crc-itu-t.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include \"udfdecl.h\"\n\nstatic int udf_update_inode(struct inode *, int);\nstatic int udf_sync_inode(struct inode *inode);\nstatic int8_t udf_insert_aext(struct inode *, struct extent_position,\n\t\t\t      struct kernel_lb_addr, uint32_t);\n\nvoid udf_write_aext(struct inode *inode, struct extent_position *epos,\n\t\t    struct kernel_lb_addr *eloc, uint32_t elen, int inc)\n{\n\tint adsize;\n\tuint8_t *ptr;\n\tstruct short_ad *sad;\n\tstruct long_ad *lad;\n\tstruct udf_inode_info *iinfo = UDF_I(inode);\n\n\tif (!epos->bh)\n\t\tptr = iinfo->i_ext.i_data + epos->offset -\n\t\t\tudf_file_entry_alloc_offset(inode) +\n\t\t\tiinfo->i_lenEAttr;\n\telse\n\t\tptr = epos->bh->b_data + epos->offset;\n\n\tswitch (iinfo->i_alloc_type) {\n\tcase ICBTAG_FLAG_AD_SHORT:\n\t\tsad = (struct short_ad *)ptr;\n\t\tsad->extLength = cpu_to_le32(elen);\n\t\tsad->extPosition = cpu_to_le32(eloc->logicalBlockNum);\n\t\tadsize = sizeof(struct short_ad);\n\t\tbreak;\n\tcase ICBTAG_FLAG_AD_LONG:\n\t\tlad = (struct long_ad *)ptr;\n\t\tlad->extLength = cpu_to_le32(elen);\n\t\tlad->extLocation = cpu_to_lelb(*eloc);\n\t\tmemset(lad->impUse, 0x00, sizeof(lad->impUse));\n\t\tadsize = sizeof(struct long_ad);\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\n\tif (epos->bh) {\n\t\tif (!UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_STRICT) ||\n\t\t    UDF_SB(inode->i_sb)->s_udfrev >= 0x0201) {\n\t\t\tstruct allocExtDesc *aed =\n\t\t\t\t(struct allocExtDesc *)epos->bh->b_data;\n\t\t\tudf_update_tag(epos->bh->b_data,\n\t\t\t\t       le32_to_cpu(aed->lengthAllocDescs) +\n\t\t\t\t       sizeof(struct allocExtDesc));\n\t\t}\n\t\tmark_buffer_dirty_inode(epos->bh, inode);\n\t} else {\n\t\tmark_inode_dirty(inode);\n\t}\n\n\tif (inc)\n\t\tepos->offset += adsize;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_bh",
          "args": [
            "next_epos.bh"
          ],
          "line": 695
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_bh",
          "args": [
            "cur_epos.bh"
          ],
          "line": 690
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udf_file_entry_alloc_offset",
          "args": [
            "inode"
          ],
          "line": 678
        },
        "resolved": true,
        "details": {
          "function_name": "udf_file_entry_alloc_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/udfdecl.h",
          "lines": "55-64",
          "snippet": "static inline size_t udf_file_entry_alloc_offset(struct inode *inode)\n{\n\tstruct udf_inode_info *iinfo = UDF_I(inode);\n\tif (iinfo->i_use)\n\t\treturn sizeof(struct unallocSpaceEntry);\n\telse if (iinfo->i_efe)\n\t\treturn sizeof(struct extendedFileEntry) + iinfo->i_lenEAttr;\n\telse\n\t\treturn sizeof(struct fileEntry) + iinfo->i_lenEAttr;\n}",
          "includes": [
            "#include \"udf_i.h\"",
            "#include \"udfend.h\"",
            "#include \"udf_sb.h\"",
            "#include <linux/udf_fs_i.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include \"osta_udf.h\"",
            "#include \"ecma_167.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_i.h\"\n#include \"udfend.h\"\n#include \"udf_sb.h\"\n#include <linux/udf_fs_i.h>\n#include <linux/buffer_head.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include \"osta_udf.h\"\n#include \"ecma_167.h\"\n\nstatic inline size_t udf_file_entry_alloc_offset(struct inode *inode)\n{\n\tstruct udf_inode_info *iinfo = UDF_I(inode);\n\tif (iinfo->i_use)\n\t\treturn sizeof(struct unallocSpaceEntry);\n\telse if (iinfo->i_efe)\n\t\treturn sizeof(struct extendedFileEntry) + iinfo->i_lenEAttr;\n\telse\n\t\treturn sizeof(struct fileEntry) + iinfo->i_lenEAttr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "UDF_I",
          "args": [
            "inode"
          ],
          "line": 671
        },
        "resolved": true,
        "details": {
          "function_name": "UDF_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/udf_i.h",
          "lines": "57-60",
          "snippet": "static inline struct udf_inode_info *UDF_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct udf_inode_info, vfs_inode);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline struct udf_inode_info *UDF_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct udf_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/crc-itu-t.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include \"udfdecl.h\"\n\n#define EXTENT_MERGE_SIZE 5\n\nstatic int udf_update_inode(struct inode *, int);\nstatic int udf_sync_inode(struct inode *inode);\nstatic sector_t inode_getblk(struct inode *, sector_t, int *, int *);\nstatic int8_t udf_insert_aext(struct inode *, struct extent_position,\n\t\t\t      struct kernel_lb_addr, uint32_t);\nstatic void udf_split_extents(struct inode *, int *, int, int,\n\t\t\t      struct kernel_long_ad[EXTENT_MERGE_SIZE], int *);\nstatic void udf_prealloc_extents(struct inode *, int, int,\n\t\t\t\t struct kernel_long_ad[EXTENT_MERGE_SIZE], int *);\nstatic void udf_merge_extents(struct inode *,\n\t\t\t      struct kernel_long_ad[EXTENT_MERGE_SIZE], int *);\nstatic void udf_update_extents(struct inode *,\n\t\t\t       struct kernel_long_ad[EXTENT_MERGE_SIZE], int, int,\n\t\t\t       struct extent_position *);\n\nstatic sector_t inode_getblk(struct inode *inode, sector_t block,\n\t\t\t     int *err, int *new)\n{\n\tstruct kernel_long_ad laarr[EXTENT_MERGE_SIZE];\n\tstruct extent_position prev_epos, cur_epos, next_epos;\n\tint count = 0, startnum = 0, endnum = 0;\n\tuint32_t elen = 0, tmpelen;\n\tstruct kernel_lb_addr eloc, tmpeloc;\n\tint c = 1;\n\tloff_t lbcount = 0, b_off = 0;\n\tuint32_t newblocknum, newblock;\n\tsector_t offset = 0;\n\tint8_t etype;\n\tstruct udf_inode_info *iinfo = UDF_I(inode);\n\tint goal = 0, pgoal = iinfo->i_location.logicalBlockNum;\n\tint lastblock = 0;\n\tbool isBeyondEOF;\n\n\t*err = 0;\n\t*new = 0;\n\tprev_epos.offset = udf_file_entry_alloc_offset(inode);\n\tprev_epos.block = iinfo->i_location;\n\tprev_epos.bh = NULL;\n\tcur_epos = next_epos = prev_epos;\n\tb_off = (loff_t)block << inode->i_sb->s_blocksize_bits;\n\n\t/* find the extent which contains the block we are looking for.\n\t   alternate between laarr[0] and laarr[1] for locations of the\n\t   current extent, and the previous extent */\n\tdo {\n\t\tif (prev_epos.bh != cur_epos.bh) {\n\t\t\tbrelse(prev_epos.bh);\n\t\t\tget_bh(cur_epos.bh);\n\t\t\tprev_epos.bh = cur_epos.bh;\n\t\t}\n\t\tif (cur_epos.bh != next_epos.bh) {\n\t\t\tbrelse(cur_epos.bh);\n\t\t\tget_bh(next_epos.bh);\n\t\t\tcur_epos.bh = next_epos.bh;\n\t\t}\n\n\t\tlbcount += elen;\n\n\t\tprev_epos.block = cur_epos.block;\n\t\tcur_epos.block = next_epos.block;\n\n\t\tprev_epos.offset = cur_epos.offset;\n\t\tcur_epos.offset = next_epos.offset;\n\n\t\tetype = udf_next_aext(inode, &next_epos, &eloc, &elen, 1);\n\t\tif (etype == -1)\n\t\t\tbreak;\n\n\t\tc = !c;\n\n\t\tlaarr[c].extLength = (etype << 30) | elen;\n\t\tlaarr[c].extLocation = eloc;\n\n\t\tif (etype != (EXT_NOT_RECORDED_NOT_ALLOCATED >> 30))\n\t\t\tpgoal = eloc.logicalBlockNum +\n\t\t\t\t((elen + inode->i_sb->s_blocksize - 1) >>\n\t\t\t\t inode->i_sb->s_blocksize_bits);\n\n\t\tcount++;\n\t} while (lbcount + elen <= b_off);\n\n\tb_off -= lbcount;\n\toffset = b_off >> inode->i_sb->s_blocksize_bits;\n\t/*\n\t * Move prev_epos and cur_epos into indirect extent if we are at\n\t * the pointer to it\n\t */\n\tudf_next_aext(inode, &prev_epos, &tmpeloc, &tmpelen, 0);\n\tudf_next_aext(inode, &cur_epos, &tmpeloc, &tmpelen, 0);\n\n\t/* if the extent is allocated and recorded, return the block\n\t   if the extent is not a multiple of the blocksize, round up */\n\n\tif (etype == (EXT_RECORDED_ALLOCATED >> 30)) {\n\t\tif (elen & (inode->i_sb->s_blocksize - 1)) {\n\t\t\telen = EXT_RECORDED_ALLOCATED |\n\t\t\t\t((elen + inode->i_sb->s_blocksize - 1) &\n\t\t\t\t ~(inode->i_sb->s_blocksize - 1));\n\t\t\tudf_write_aext(inode, &cur_epos, &eloc, elen, 1);\n\t\t}\n\t\tbrelse(prev_epos.bh);\n\t\tbrelse(cur_epos.bh);\n\t\tbrelse(next_epos.bh);\n\t\tnewblock = udf_get_lb_pblock(inode->i_sb, &eloc, offset);\n\t\treturn newblock;\n\t}\n\n\t/* Are we beyond EOF? */\n\tif (etype == -1) {\n\t\tint ret;\n\t\tisBeyondEOF = true;\n\t\tif (count) {\n\t\t\tif (c)\n\t\t\t\tlaarr[0] = laarr[1];\n\t\t\tstartnum = 1;\n\t\t} else {\n\t\t\t/* Create a fake extent when there's not one */\n\t\t\tmemset(&laarr[0].extLocation, 0x00,\n\t\t\t\tsizeof(struct kernel_lb_addr));\n\t\t\tlaarr[0].extLength = EXT_NOT_RECORDED_NOT_ALLOCATED;\n\t\t\t/* Will udf_do_extend_file() create real extent from\n\t\t\t   a fake one? */\n\t\t\tstartnum = (offset > 0);\n\t\t}\n\t\t/* Create extents for the hole between EOF and offset */\n\t\tret = udf_do_extend_file(inode, &prev_epos, laarr, offset);\n\t\tif (ret < 0) {\n\t\t\tbrelse(prev_epos.bh);\n\t\t\tbrelse(cur_epos.bh);\n\t\t\tbrelse(next_epos.bh);\n\t\t\t*err = ret;\n\t\t\treturn 0;\n\t\t}\n\t\tc = 0;\n\t\toffset = 0;\n\t\tcount += ret;\n\t\t/* We are not covered by a preallocated extent? */\n\t\tif ((laarr[0].extLength & UDF_EXTENT_FLAG_MASK) !=\n\t\t\t\t\t\tEXT_NOT_RECORDED_ALLOCATED) {\n\t\t\t/* Is there any real extent? - otherwise we overwrite\n\t\t\t * the fake one... */\n\t\t\tif (count)\n\t\t\t\tc = !c;\n\t\t\tlaarr[c].extLength = EXT_NOT_RECORDED_NOT_ALLOCATED |\n\t\t\t\tinode->i_sb->s_blocksize;\n\t\t\tmemset(&laarr[c].extLocation, 0x00,\n\t\t\t\tsizeof(struct kernel_lb_addr));\n\t\t\tcount++;\n\t\t}\n\t\tendnum = c + 1;\n\t\tlastblock = 1;\n\t} else {\n\t\tisBeyondEOF = false;\n\t\tendnum = startnum = ((count > 2) ? 2 : count);\n\n\t\t/* if the current extent is in position 0,\n\t\t   swap it with the previous */\n\t\tif (!c && count != 1) {\n\t\t\tlaarr[2] = laarr[0];\n\t\t\tlaarr[0] = laarr[1];\n\t\t\tlaarr[1] = laarr[2];\n\t\t\tc = 1;\n\t\t}\n\n\t\t/* if the current block is located in an extent,\n\t\t   read the next extent */\n\t\tetype = udf_next_aext(inode, &next_epos, &eloc, &elen, 0);\n\t\tif (etype != -1) {\n\t\t\tlaarr[c + 1].extLength = (etype << 30) | elen;\n\t\t\tlaarr[c + 1].extLocation = eloc;\n\t\t\tcount++;\n\t\t\tstartnum++;\n\t\t\tendnum++;\n\t\t} else\n\t\t\tlastblock = 1;\n\t}\n\n\t/* if the current extent is not recorded but allocated, get the\n\t * block in the extent corresponding to the requested block */\n\tif ((laarr[c].extLength >> 30) == (EXT_NOT_RECORDED_ALLOCATED >> 30))\n\t\tnewblocknum = laarr[c].extLocation.logicalBlockNum + offset;\n\telse { /* otherwise, allocate a new block */\n\t\tif (iinfo->i_next_alloc_block == block)\n\t\t\tgoal = iinfo->i_next_alloc_goal;\n\n\t\tif (!goal) {\n\t\t\tif (!(goal = pgoal)) /* XXX: what was intended here? */\n\t\t\t\tgoal = iinfo->i_location.logicalBlockNum + 1;\n\t\t}\n\n\t\tnewblocknum = udf_new_block(inode->i_sb, inode,\n\t\t\t\tiinfo->i_location.partitionReferenceNum,\n\t\t\t\tgoal, err);\n\t\tif (!newblocknum) {\n\t\t\tbrelse(prev_epos.bh);\n\t\t\tbrelse(cur_epos.bh);\n\t\t\tbrelse(next_epos.bh);\n\t\t\t*err = -ENOSPC;\n\t\t\treturn 0;\n\t\t}\n\t\tif (isBeyondEOF)\n\t\t\tiinfo->i_lenExtents += inode->i_sb->s_blocksize;\n\t}\n\n\t/* if the extent the requsted block is located in contains multiple\n\t * blocks, split the extent into at most three extents. blocks prior\n\t * to requested block, requested block, and blocks after requested\n\t * block */\n\tudf_split_extents(inode, &c, offset, newblocknum, laarr, &endnum);\n\n#ifdef UDF_PREALLOCATE\n\t/* We preallocate blocks only for regular files. It also makes sense\n\t * for directories but there's a problem when to drop the\n\t * preallocation. We might use some delayed work for that but I feel\n\t * it's overengineering for a filesystem like UDF. */\n\tif (S_ISREG(inode->i_mode))\n\t\tudf_prealloc_extents(inode, c, lastblock, laarr, &endnum);\n#endif\n\n\t/* merge any continuous blocks in laarr */\n\tudf_merge_extents(inode, laarr, &endnum);\n\n\t/* write back the new extents, inserting new extents if the new number\n\t * of extents is greater than the old number, and deleting extents if\n\t * the new number of extents is less than the old number */\n\tudf_update_extents(inode, laarr, startnum, endnum, &prev_epos);\n\n\tbrelse(prev_epos.bh);\n\tbrelse(cur_epos.bh);\n\tbrelse(next_epos.bh);\n\n\tnewblock = udf_get_pblock(inode->i_sb, newblocknum,\n\t\t\t\tiinfo->i_location.partitionReferenceNum, 0);\n\tif (!newblock) {\n\t\t*err = -EIO;\n\t\treturn 0;\n\t}\n\t*new = 1;\n\tiinfo->i_next_alloc_block = block;\n\tiinfo->i_next_alloc_goal = newblocknum;\n\tinode->i_ctime = current_fs_time(inode->i_sb);\n\n\tif (IS_SYNC(inode))\n\t\tudf_sync_inode(inode);\n\telse\n\t\tmark_inode_dirty(inode);\n\n\treturn newblock;\n}"
  },
  {
    "function_name": "udf_extend_file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/inode.c",
    "lines": "601-656",
    "snippet": "static int udf_extend_file(struct inode *inode, loff_t newsize)\n{\n\n\tstruct extent_position epos;\n\tstruct kernel_lb_addr eloc;\n\tuint32_t elen;\n\tint8_t etype;\n\tstruct super_block *sb = inode->i_sb;\n\tsector_t first_block = newsize >> sb->s_blocksize_bits, offset;\n\tint adsize;\n\tstruct udf_inode_info *iinfo = UDF_I(inode);\n\tstruct kernel_long_ad extent;\n\tint err;\n\n\tif (iinfo->i_alloc_type == ICBTAG_FLAG_AD_SHORT)\n\t\tadsize = sizeof(struct short_ad);\n\telse if (iinfo->i_alloc_type == ICBTAG_FLAG_AD_LONG)\n\t\tadsize = sizeof(struct long_ad);\n\telse\n\t\tBUG();\n\n\tetype = inode_bmap(inode, first_block, &epos, &eloc, &elen, &offset);\n\n\t/* File has extent covering the new size (could happen when extending\n\t * inside a block)? */\n\tif (etype != -1)\n\t\treturn 0;\n\tif (newsize & (sb->s_blocksize - 1))\n\t\toffset++;\n\t/* Extended file just to the boundary of the last file block? */\n\tif (offset == 0)\n\t\treturn 0;\n\n\t/* Truncate is extending the file by 'offset' blocks */\n\tif ((!epos.bh && epos.offset == udf_file_entry_alloc_offset(inode)) ||\n\t    (epos.bh && epos.offset == sizeof(struct allocExtDesc))) {\n\t\t/* File has no extents at all or has empty last\n\t\t * indirect extent! Create a fake extent... */\n\t\textent.extLocation.logicalBlockNum = 0;\n\t\textent.extLocation.partitionReferenceNum = 0;\n\t\textent.extLength = EXT_NOT_RECORDED_NOT_ALLOCATED;\n\t} else {\n\t\tepos.offset -= adsize;\n\t\tetype = udf_next_aext(inode, &epos, &extent.extLocation,\n\t\t\t\t      &extent.extLength, 0);\n\t\textent.extLength |= etype << 30;\n\t}\n\terr = udf_do_extend_file(inode, &epos, &extent, offset);\n\tif (err < 0)\n\t\tgoto out;\n\terr = 0;\n\tiinfo->i_lenExtents = newsize;\nout:\n\tbrelse(epos.bh);\n\treturn err;\n}",
    "includes": [
      "#include \"udf_sb.h\"",
      "#include \"udf_i.h\"",
      "#include <linux/aio.h>",
      "#include <linux/mpage.h>",
      "#include <linux/crc-itu-t.h>",
      "#include <linux/slab.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include \"udfdecl.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int udf_update_inode(struct inode *, int);",
      "static int udf_sync_inode(struct inode *inode);",
      "static int udf_alloc_i_data(struct inode *inode, size_t size);",
      "static sector_t inode_getblk(struct inode *, sector_t, int *, int *);",
      "static int8_t udf_insert_aext(struct inode *, struct extent_position,\n\t\t\t      struct kernel_lb_addr, uint32_t);",
      "static void udf_split_extents(struct inode *, int *, int, int,\n\t\t\t      struct kernel_long_ad[EXTENT_MERGE_SIZE], int *);",
      "static void udf_prealloc_extents(struct inode *, int, int,\n\t\t\t\t struct kernel_long_ad[EXTENT_MERGE_SIZE], int *);",
      "static void udf_merge_extents(struct inode *,\n\t\t\t      struct kernel_long_ad[EXTENT_MERGE_SIZE], int *);",
      "static void udf_update_extents(struct inode *,\n\t\t\t       struct kernel_long_ad[EXTENT_MERGE_SIZE], int, int,\n\t\t\t       struct extent_position *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "epos.bh"
          ],
          "line": 654
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_do_extend_file",
          "args": [
            "inode",
            "&epos",
            "&extent",
            "offset"
          ],
          "line": 648
        },
        "resolved": true,
        "details": {
          "function_name": "udf_do_extend_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/inode.c",
          "lines": "485-599",
          "snippet": "static int udf_do_extend_file(struct inode *inode,\n\t\t\t      struct extent_position *last_pos,\n\t\t\t      struct kernel_long_ad *last_ext,\n\t\t\t      sector_t blocks)\n{\n\tsector_t add;\n\tint count = 0, fake = !(last_ext->extLength & UDF_EXTENT_LENGTH_MASK);\n\tstruct super_block *sb = inode->i_sb;\n\tstruct kernel_lb_addr prealloc_loc = {};\n\tint prealloc_len = 0;\n\tstruct udf_inode_info *iinfo;\n\tint err;\n\n\t/* The previous extent is fake and we should not extend by anything\n\t * - there's nothing to do... */\n\tif (!blocks && fake)\n\t\treturn 0;\n\n\tiinfo = UDF_I(inode);\n\t/* Round the last extent up to a multiple of block size */\n\tif (last_ext->extLength & (sb->s_blocksize - 1)) {\n\t\tlast_ext->extLength =\n\t\t\t(last_ext->extLength & UDF_EXTENT_FLAG_MASK) |\n\t\t\t(((last_ext->extLength & UDF_EXTENT_LENGTH_MASK) +\n\t\t\t  sb->s_blocksize - 1) & ~(sb->s_blocksize - 1));\n\t\tiinfo->i_lenExtents =\n\t\t\t(iinfo->i_lenExtents + sb->s_blocksize - 1) &\n\t\t\t~(sb->s_blocksize - 1);\n\t}\n\n\t/* Last extent are just preallocated blocks? */\n\tif ((last_ext->extLength & UDF_EXTENT_FLAG_MASK) ==\n\t\t\t\t\t\tEXT_NOT_RECORDED_ALLOCATED) {\n\t\t/* Save the extent so that we can reattach it to the end */\n\t\tprealloc_loc = last_ext->extLocation;\n\t\tprealloc_len = last_ext->extLength;\n\t\t/* Mark the extent as a hole */\n\t\tlast_ext->extLength = EXT_NOT_RECORDED_NOT_ALLOCATED |\n\t\t\t(last_ext->extLength & UDF_EXTENT_LENGTH_MASK);\n\t\tlast_ext->extLocation.logicalBlockNum = 0;\n\t\tlast_ext->extLocation.partitionReferenceNum = 0;\n\t}\n\n\t/* Can we merge with the previous extent? */\n\tif ((last_ext->extLength & UDF_EXTENT_FLAG_MASK) ==\n\t\t\t\t\tEXT_NOT_RECORDED_NOT_ALLOCATED) {\n\t\tadd = ((1 << 30) - sb->s_blocksize -\n\t\t\t(last_ext->extLength & UDF_EXTENT_LENGTH_MASK)) >>\n\t\t\tsb->s_blocksize_bits;\n\t\tif (add > blocks)\n\t\t\tadd = blocks;\n\t\tblocks -= add;\n\t\tlast_ext->extLength += add << sb->s_blocksize_bits;\n\t}\n\n\tif (fake) {\n\t\tudf_add_aext(inode, last_pos, &last_ext->extLocation,\n\t\t\t     last_ext->extLength, 1);\n\t\tcount++;\n\t} else\n\t\tudf_write_aext(inode, last_pos, &last_ext->extLocation,\n\t\t\t\tlast_ext->extLength, 1);\n\n\t/* Managed to do everything necessary? */\n\tif (!blocks)\n\t\tgoto out;\n\n\t/* All further extents will be NOT_RECORDED_NOT_ALLOCATED */\n\tlast_ext->extLocation.logicalBlockNum = 0;\n\tlast_ext->extLocation.partitionReferenceNum = 0;\n\tadd = (1 << (30-sb->s_blocksize_bits)) - 1;\n\tlast_ext->extLength = EXT_NOT_RECORDED_NOT_ALLOCATED |\n\t\t\t\t(add << sb->s_blocksize_bits);\n\n\t/* Create enough extents to cover the whole hole */\n\twhile (blocks > add) {\n\t\tblocks -= add;\n\t\terr = udf_add_aext(inode, last_pos, &last_ext->extLocation,\n\t\t\t\t   last_ext->extLength, 1);\n\t\tif (err)\n\t\t\treturn err;\n\t\tcount++;\n\t}\n\tif (blocks) {\n\t\tlast_ext->extLength = EXT_NOT_RECORDED_NOT_ALLOCATED |\n\t\t\t(blocks << sb->s_blocksize_bits);\n\t\terr = udf_add_aext(inode, last_pos, &last_ext->extLocation,\n\t\t\t\t   last_ext->extLength, 1);\n\t\tif (err)\n\t\t\treturn err;\n\t\tcount++;\n\t}\n\nout:\n\t/* Do we have some preallocated blocks saved? */\n\tif (prealloc_len) {\n\t\terr = udf_add_aext(inode, last_pos, &prealloc_loc,\n\t\t\t\t   prealloc_len, 1);\n\t\tif (err)\n\t\t\treturn err;\n\t\tlast_ext->extLocation = prealloc_loc;\n\t\tlast_ext->extLength = prealloc_len;\n\t\tcount++;\n\t}\n\n\t/* last_pos should point to the last written extent... */\n\tif (iinfo->i_alloc_type == ICBTAG_FLAG_AD_SHORT)\n\t\tlast_pos->offset -= sizeof(struct short_ad);\n\telse if (iinfo->i_alloc_type == ICBTAG_FLAG_AD_LONG)\n\t\tlast_pos->offset -= sizeof(struct long_ad);\n\telse\n\t\treturn -EIO;\n\n\treturn count;\n}",
          "includes": [
            "#include \"udf_sb.h\"",
            "#include \"udf_i.h\"",
            "#include <linux/aio.h>",
            "#include <linux/mpage.h>",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int udf_update_inode(struct inode *, int);",
            "static int udf_sync_inode(struct inode *inode);",
            "static int udf_alloc_i_data(struct inode *inode, size_t size);",
            "static sector_t inode_getblk(struct inode *, sector_t, int *, int *);",
            "static void udf_split_extents(struct inode *, int *, int, int,\n\t\t\t      struct kernel_long_ad[EXTENT_MERGE_SIZE], int *);",
            "static void udf_prealloc_extents(struct inode *, int, int,\n\t\t\t\t struct kernel_long_ad[EXTENT_MERGE_SIZE], int *);",
            "static void udf_merge_extents(struct inode *,\n\t\t\t      struct kernel_long_ad[EXTENT_MERGE_SIZE], int *);",
            "static void udf_update_extents(struct inode *,\n\t\t\t       struct kernel_long_ad[EXTENT_MERGE_SIZE], int, int,\n\t\t\t       struct extent_position *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/crc-itu-t.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include \"udfdecl.h\"\n\nstatic int udf_update_inode(struct inode *, int);\nstatic int udf_sync_inode(struct inode *inode);\nstatic int udf_alloc_i_data(struct inode *inode, size_t size);\nstatic sector_t inode_getblk(struct inode *, sector_t, int *, int *);\nstatic void udf_split_extents(struct inode *, int *, int, int,\n\t\t\t      struct kernel_long_ad[EXTENT_MERGE_SIZE], int *);\nstatic void udf_prealloc_extents(struct inode *, int, int,\n\t\t\t\t struct kernel_long_ad[EXTENT_MERGE_SIZE], int *);\nstatic void udf_merge_extents(struct inode *,\n\t\t\t      struct kernel_long_ad[EXTENT_MERGE_SIZE], int *);\nstatic void udf_update_extents(struct inode *,\n\t\t\t       struct kernel_long_ad[EXTENT_MERGE_SIZE], int, int,\n\t\t\t       struct extent_position *);\n\nstatic int udf_do_extend_file(struct inode *inode,\n\t\t\t      struct extent_position *last_pos,\n\t\t\t      struct kernel_long_ad *last_ext,\n\t\t\t      sector_t blocks)\n{\n\tsector_t add;\n\tint count = 0, fake = !(last_ext->extLength & UDF_EXTENT_LENGTH_MASK);\n\tstruct super_block *sb = inode->i_sb;\n\tstruct kernel_lb_addr prealloc_loc = {};\n\tint prealloc_len = 0;\n\tstruct udf_inode_info *iinfo;\n\tint err;\n\n\t/* The previous extent is fake and we should not extend by anything\n\t * - there's nothing to do... */\n\tif (!blocks && fake)\n\t\treturn 0;\n\n\tiinfo = UDF_I(inode);\n\t/* Round the last extent up to a multiple of block size */\n\tif (last_ext->extLength & (sb->s_blocksize - 1)) {\n\t\tlast_ext->extLength =\n\t\t\t(last_ext->extLength & UDF_EXTENT_FLAG_MASK) |\n\t\t\t(((last_ext->extLength & UDF_EXTENT_LENGTH_MASK) +\n\t\t\t  sb->s_blocksize - 1) & ~(sb->s_blocksize - 1));\n\t\tiinfo->i_lenExtents =\n\t\t\t(iinfo->i_lenExtents + sb->s_blocksize - 1) &\n\t\t\t~(sb->s_blocksize - 1);\n\t}\n\n\t/* Last extent are just preallocated blocks? */\n\tif ((last_ext->extLength & UDF_EXTENT_FLAG_MASK) ==\n\t\t\t\t\t\tEXT_NOT_RECORDED_ALLOCATED) {\n\t\t/* Save the extent so that we can reattach it to the end */\n\t\tprealloc_loc = last_ext->extLocation;\n\t\tprealloc_len = last_ext->extLength;\n\t\t/* Mark the extent as a hole */\n\t\tlast_ext->extLength = EXT_NOT_RECORDED_NOT_ALLOCATED |\n\t\t\t(last_ext->extLength & UDF_EXTENT_LENGTH_MASK);\n\t\tlast_ext->extLocation.logicalBlockNum = 0;\n\t\tlast_ext->extLocation.partitionReferenceNum = 0;\n\t}\n\n\t/* Can we merge with the previous extent? */\n\tif ((last_ext->extLength & UDF_EXTENT_FLAG_MASK) ==\n\t\t\t\t\tEXT_NOT_RECORDED_NOT_ALLOCATED) {\n\t\tadd = ((1 << 30) - sb->s_blocksize -\n\t\t\t(last_ext->extLength & UDF_EXTENT_LENGTH_MASK)) >>\n\t\t\tsb->s_blocksize_bits;\n\t\tif (add > blocks)\n\t\t\tadd = blocks;\n\t\tblocks -= add;\n\t\tlast_ext->extLength += add << sb->s_blocksize_bits;\n\t}\n\n\tif (fake) {\n\t\tudf_add_aext(inode, last_pos, &last_ext->extLocation,\n\t\t\t     last_ext->extLength, 1);\n\t\tcount++;\n\t} else\n\t\tudf_write_aext(inode, last_pos, &last_ext->extLocation,\n\t\t\t\tlast_ext->extLength, 1);\n\n\t/* Managed to do everything necessary? */\n\tif (!blocks)\n\t\tgoto out;\n\n\t/* All further extents will be NOT_RECORDED_NOT_ALLOCATED */\n\tlast_ext->extLocation.logicalBlockNum = 0;\n\tlast_ext->extLocation.partitionReferenceNum = 0;\n\tadd = (1 << (30-sb->s_blocksize_bits)) - 1;\n\tlast_ext->extLength = EXT_NOT_RECORDED_NOT_ALLOCATED |\n\t\t\t\t(add << sb->s_blocksize_bits);\n\n\t/* Create enough extents to cover the whole hole */\n\twhile (blocks > add) {\n\t\tblocks -= add;\n\t\terr = udf_add_aext(inode, last_pos, &last_ext->extLocation,\n\t\t\t\t   last_ext->extLength, 1);\n\t\tif (err)\n\t\t\treturn err;\n\t\tcount++;\n\t}\n\tif (blocks) {\n\t\tlast_ext->extLength = EXT_NOT_RECORDED_NOT_ALLOCATED |\n\t\t\t(blocks << sb->s_blocksize_bits);\n\t\terr = udf_add_aext(inode, last_pos, &last_ext->extLocation,\n\t\t\t\t   last_ext->extLength, 1);\n\t\tif (err)\n\t\t\treturn err;\n\t\tcount++;\n\t}\n\nout:\n\t/* Do we have some preallocated blocks saved? */\n\tif (prealloc_len) {\n\t\terr = udf_add_aext(inode, last_pos, &prealloc_loc,\n\t\t\t\t   prealloc_len, 1);\n\t\tif (err)\n\t\t\treturn err;\n\t\tlast_ext->extLocation = prealloc_loc;\n\t\tlast_ext->extLength = prealloc_len;\n\t\tcount++;\n\t}\n\n\t/* last_pos should point to the last written extent... */\n\tif (iinfo->i_alloc_type == ICBTAG_FLAG_AD_SHORT)\n\t\tlast_pos->offset -= sizeof(struct short_ad);\n\telse if (iinfo->i_alloc_type == ICBTAG_FLAG_AD_LONG)\n\t\tlast_pos->offset -= sizeof(struct long_ad);\n\telse\n\t\treturn -EIO;\n\n\treturn count;\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_next_aext",
          "args": [
            "inode",
            "&epos",
            "&extent.extLocation",
            "&extent.extLength",
            "0"
          ],
          "line": 644
        },
        "resolved": true,
        "details": {
          "function_name": "udf_next_aext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/inode.c",
          "lines": "2057-2077",
          "snippet": "int8_t udf_next_aext(struct inode *inode, struct extent_position *epos,\n\t\t     struct kernel_lb_addr *eloc, uint32_t *elen, int inc)\n{\n\tint8_t etype;\n\n\twhile ((etype = udf_current_aext(inode, epos, eloc, elen, inc)) ==\n\t       (EXT_NEXT_EXTENT_ALLOCDECS >> 30)) {\n\t\tint block;\n\t\tepos->block = *eloc;\n\t\tepos->offset = sizeof(struct allocExtDesc);\n\t\tbrelse(epos->bh);\n\t\tblock = udf_get_lb_pblock(inode->i_sb, &epos->block, 0);\n\t\tepos->bh = udf_tread(inode->i_sb, block);\n\t\tif (!epos->bh) {\n\t\t\tudf_debug(\"reading block %d failed!\\n\", block);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn etype;\n}",
          "includes": [
            "#include \"udf_sb.h\"",
            "#include \"udf_i.h\"",
            "#include <linux/aio.h>",
            "#include <linux/mpage.h>",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int udf_update_inode(struct inode *, int);",
            "static int udf_sync_inode(struct inode *inode);",
            "static int8_t udf_insert_aext(struct inode *, struct extent_position,\n\t\t\t      struct kernel_lb_addr, uint32_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/crc-itu-t.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include \"udfdecl.h\"\n\nstatic int udf_update_inode(struct inode *, int);\nstatic int udf_sync_inode(struct inode *inode);\nstatic int8_t udf_insert_aext(struct inode *, struct extent_position,\n\t\t\t      struct kernel_lb_addr, uint32_t);\n\nint8_t udf_next_aext(struct inode *inode, struct extent_position *epos,\n\t\t     struct kernel_lb_addr *eloc, uint32_t *elen, int inc)\n{\n\tint8_t etype;\n\n\twhile ((etype = udf_current_aext(inode, epos, eloc, elen, inc)) ==\n\t       (EXT_NEXT_EXTENT_ALLOCDECS >> 30)) {\n\t\tint block;\n\t\tepos->block = *eloc;\n\t\tepos->offset = sizeof(struct allocExtDesc);\n\t\tbrelse(epos->bh);\n\t\tblock = udf_get_lb_pblock(inode->i_sb, &epos->block, 0);\n\t\tepos->bh = udf_tread(inode->i_sb, block);\n\t\tif (!epos->bh) {\n\t\t\tudf_debug(\"reading block %d failed!\\n\", block);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn etype;\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_file_entry_alloc_offset",
          "args": [
            "inode"
          ],
          "line": 635
        },
        "resolved": true,
        "details": {
          "function_name": "udf_file_entry_alloc_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/udfdecl.h",
          "lines": "55-64",
          "snippet": "static inline size_t udf_file_entry_alloc_offset(struct inode *inode)\n{\n\tstruct udf_inode_info *iinfo = UDF_I(inode);\n\tif (iinfo->i_use)\n\t\treturn sizeof(struct unallocSpaceEntry);\n\telse if (iinfo->i_efe)\n\t\treturn sizeof(struct extendedFileEntry) + iinfo->i_lenEAttr;\n\telse\n\t\treturn sizeof(struct fileEntry) + iinfo->i_lenEAttr;\n}",
          "includes": [
            "#include \"udf_i.h\"",
            "#include \"udfend.h\"",
            "#include \"udf_sb.h\"",
            "#include <linux/udf_fs_i.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include \"osta_udf.h\"",
            "#include \"ecma_167.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_i.h\"\n#include \"udfend.h\"\n#include \"udf_sb.h\"\n#include <linux/udf_fs_i.h>\n#include <linux/buffer_head.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include \"osta_udf.h\"\n#include \"ecma_167.h\"\n\nstatic inline size_t udf_file_entry_alloc_offset(struct inode *inode)\n{\n\tstruct udf_inode_info *iinfo = UDF_I(inode);\n\tif (iinfo->i_use)\n\t\treturn sizeof(struct unallocSpaceEntry);\n\telse if (iinfo->i_efe)\n\t\treturn sizeof(struct extendedFileEntry) + iinfo->i_lenEAttr;\n\telse\n\t\treturn sizeof(struct fileEntry) + iinfo->i_lenEAttr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_bmap",
          "args": [
            "inode",
            "first_block",
            "&epos",
            "&eloc",
            "&elen",
            "&offset"
          ],
          "line": 622
        },
        "resolved": true,
        "details": {
          "function_name": "inode_bmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/inode.c",
          "lines": "2237-2268",
          "snippet": "int8_t inode_bmap(struct inode *inode, sector_t block,\n\t\t  struct extent_position *pos, struct kernel_lb_addr *eloc,\n\t\t  uint32_t *elen, sector_t *offset)\n{\n\tunsigned char blocksize_bits = inode->i_sb->s_blocksize_bits;\n\tloff_t lbcount = 0, bcount =\n\t    (loff_t) block << blocksize_bits;\n\tint8_t etype;\n\tstruct udf_inode_info *iinfo;\n\n\tiinfo = UDF_I(inode);\n\tif (!udf_read_extent_cache(inode, bcount, &lbcount, pos)) {\n\t\tpos->offset = 0;\n\t\tpos->block = iinfo->i_location;\n\t\tpos->bh = NULL;\n\t}\n\t*elen = 0;\n\tdo {\n\t\tetype = udf_next_aext(inode, pos, eloc, elen, 1);\n\t\tif (etype == -1) {\n\t\t\t*offset = (bcount - lbcount) >> blocksize_bits;\n\t\t\tiinfo->i_lenExtents = lbcount;\n\t\t\treturn -1;\n\t\t}\n\t\tlbcount += *elen;\n\t} while (lbcount <= bcount);\n\t/* update extent cache */\n\tudf_update_extent_cache(inode, lbcount - *elen, pos, 1);\n\t*offset = (bcount + *elen - lbcount) >> blocksize_bits;\n\n\treturn etype;\n}",
          "includes": [
            "#include \"udf_sb.h\"",
            "#include \"udf_i.h\"",
            "#include <linux/aio.h>",
            "#include <linux/mpage.h>",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int udf_update_inode(struct inode *, int);",
            "static int udf_sync_inode(struct inode *inode);",
            "static sector_t inode_getblk(struct inode *, sector_t, int *, int *);",
            "static int8_t udf_insert_aext(struct inode *, struct extent_position,\n\t\t\t      struct kernel_lb_addr, uint32_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/crc-itu-t.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include \"udfdecl.h\"\n\nstatic int udf_update_inode(struct inode *, int);\nstatic int udf_sync_inode(struct inode *inode);\nstatic sector_t inode_getblk(struct inode *, sector_t, int *, int *);\nstatic int8_t udf_insert_aext(struct inode *, struct extent_position,\n\t\t\t      struct kernel_lb_addr, uint32_t);\n\nint8_t inode_bmap(struct inode *inode, sector_t block,\n\t\t  struct extent_position *pos, struct kernel_lb_addr *eloc,\n\t\t  uint32_t *elen, sector_t *offset)\n{\n\tunsigned char blocksize_bits = inode->i_sb->s_blocksize_bits;\n\tloff_t lbcount = 0, bcount =\n\t    (loff_t) block << blocksize_bits;\n\tint8_t etype;\n\tstruct udf_inode_info *iinfo;\n\n\tiinfo = UDF_I(inode);\n\tif (!udf_read_extent_cache(inode, bcount, &lbcount, pos)) {\n\t\tpos->offset = 0;\n\t\tpos->block = iinfo->i_location;\n\t\tpos->bh = NULL;\n\t}\n\t*elen = 0;\n\tdo {\n\t\tetype = udf_next_aext(inode, pos, eloc, elen, 1);\n\t\tif (etype == -1) {\n\t\t\t*offset = (bcount - lbcount) >> blocksize_bits;\n\t\t\tiinfo->i_lenExtents = lbcount;\n\t\t\treturn -1;\n\t\t}\n\t\tlbcount += *elen;\n\t} while (lbcount <= bcount);\n\t/* update extent cache */\n\tudf_update_extent_cache(inode, lbcount - *elen, pos, 1);\n\t*offset = (bcount + *elen - lbcount) >> blocksize_bits;\n\n\treturn etype;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 620
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UDF_I",
          "args": [
            "inode"
          ],
          "line": 611
        },
        "resolved": true,
        "details": {
          "function_name": "UDF_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/udf_i.h",
          "lines": "57-60",
          "snippet": "static inline struct udf_inode_info *UDF_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct udf_inode_info, vfs_inode);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline struct udf_inode_info *UDF_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct udf_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/crc-itu-t.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include \"udfdecl.h\"\n\nstatic int udf_update_inode(struct inode *, int);\nstatic int udf_sync_inode(struct inode *inode);\nstatic int udf_alloc_i_data(struct inode *inode, size_t size);\nstatic sector_t inode_getblk(struct inode *, sector_t, int *, int *);\nstatic int8_t udf_insert_aext(struct inode *, struct extent_position,\n\t\t\t      struct kernel_lb_addr, uint32_t);\nstatic void udf_split_extents(struct inode *, int *, int, int,\n\t\t\t      struct kernel_long_ad[EXTENT_MERGE_SIZE], int *);\nstatic void udf_prealloc_extents(struct inode *, int, int,\n\t\t\t\t struct kernel_long_ad[EXTENT_MERGE_SIZE], int *);\nstatic void udf_merge_extents(struct inode *,\n\t\t\t      struct kernel_long_ad[EXTENT_MERGE_SIZE], int *);\nstatic void udf_update_extents(struct inode *,\n\t\t\t       struct kernel_long_ad[EXTENT_MERGE_SIZE], int, int,\n\t\t\t       struct extent_position *);\n\nstatic int udf_extend_file(struct inode *inode, loff_t newsize)\n{\n\n\tstruct extent_position epos;\n\tstruct kernel_lb_addr eloc;\n\tuint32_t elen;\n\tint8_t etype;\n\tstruct super_block *sb = inode->i_sb;\n\tsector_t first_block = newsize >> sb->s_blocksize_bits, offset;\n\tint adsize;\n\tstruct udf_inode_info *iinfo = UDF_I(inode);\n\tstruct kernel_long_ad extent;\n\tint err;\n\n\tif (iinfo->i_alloc_type == ICBTAG_FLAG_AD_SHORT)\n\t\tadsize = sizeof(struct short_ad);\n\telse if (iinfo->i_alloc_type == ICBTAG_FLAG_AD_LONG)\n\t\tadsize = sizeof(struct long_ad);\n\telse\n\t\tBUG();\n\n\tetype = inode_bmap(inode, first_block, &epos, &eloc, &elen, &offset);\n\n\t/* File has extent covering the new size (could happen when extending\n\t * inside a block)? */\n\tif (etype != -1)\n\t\treturn 0;\n\tif (newsize & (sb->s_blocksize - 1))\n\t\toffset++;\n\t/* Extended file just to the boundary of the last file block? */\n\tif (offset == 0)\n\t\treturn 0;\n\n\t/* Truncate is extending the file by 'offset' blocks */\n\tif ((!epos.bh && epos.offset == udf_file_entry_alloc_offset(inode)) ||\n\t    (epos.bh && epos.offset == sizeof(struct allocExtDesc))) {\n\t\t/* File has no extents at all or has empty last\n\t\t * indirect extent! Create a fake extent... */\n\t\textent.extLocation.logicalBlockNum = 0;\n\t\textent.extLocation.partitionReferenceNum = 0;\n\t\textent.extLength = EXT_NOT_RECORDED_NOT_ALLOCATED;\n\t} else {\n\t\tepos.offset -= adsize;\n\t\tetype = udf_next_aext(inode, &epos, &extent.extLocation,\n\t\t\t\t      &extent.extLength, 0);\n\t\textent.extLength |= etype << 30;\n\t}\n\terr = udf_do_extend_file(inode, &epos, &extent, offset);\n\tif (err < 0)\n\t\tgoto out;\n\terr = 0;\n\tiinfo->i_lenExtents = newsize;\nout:\n\tbrelse(epos.bh);\n\treturn err;\n}"
  },
  {
    "function_name": "udf_do_extend_file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/inode.c",
    "lines": "485-599",
    "snippet": "static int udf_do_extend_file(struct inode *inode,\n\t\t\t      struct extent_position *last_pos,\n\t\t\t      struct kernel_long_ad *last_ext,\n\t\t\t      sector_t blocks)\n{\n\tsector_t add;\n\tint count = 0, fake = !(last_ext->extLength & UDF_EXTENT_LENGTH_MASK);\n\tstruct super_block *sb = inode->i_sb;\n\tstruct kernel_lb_addr prealloc_loc = {};\n\tint prealloc_len = 0;\n\tstruct udf_inode_info *iinfo;\n\tint err;\n\n\t/* The previous extent is fake and we should not extend by anything\n\t * - there's nothing to do... */\n\tif (!blocks && fake)\n\t\treturn 0;\n\n\tiinfo = UDF_I(inode);\n\t/* Round the last extent up to a multiple of block size */\n\tif (last_ext->extLength & (sb->s_blocksize - 1)) {\n\t\tlast_ext->extLength =\n\t\t\t(last_ext->extLength & UDF_EXTENT_FLAG_MASK) |\n\t\t\t(((last_ext->extLength & UDF_EXTENT_LENGTH_MASK) +\n\t\t\t  sb->s_blocksize - 1) & ~(sb->s_blocksize - 1));\n\t\tiinfo->i_lenExtents =\n\t\t\t(iinfo->i_lenExtents + sb->s_blocksize - 1) &\n\t\t\t~(sb->s_blocksize - 1);\n\t}\n\n\t/* Last extent are just preallocated blocks? */\n\tif ((last_ext->extLength & UDF_EXTENT_FLAG_MASK) ==\n\t\t\t\t\t\tEXT_NOT_RECORDED_ALLOCATED) {\n\t\t/* Save the extent so that we can reattach it to the end */\n\t\tprealloc_loc = last_ext->extLocation;\n\t\tprealloc_len = last_ext->extLength;\n\t\t/* Mark the extent as a hole */\n\t\tlast_ext->extLength = EXT_NOT_RECORDED_NOT_ALLOCATED |\n\t\t\t(last_ext->extLength & UDF_EXTENT_LENGTH_MASK);\n\t\tlast_ext->extLocation.logicalBlockNum = 0;\n\t\tlast_ext->extLocation.partitionReferenceNum = 0;\n\t}\n\n\t/* Can we merge with the previous extent? */\n\tif ((last_ext->extLength & UDF_EXTENT_FLAG_MASK) ==\n\t\t\t\t\tEXT_NOT_RECORDED_NOT_ALLOCATED) {\n\t\tadd = ((1 << 30) - sb->s_blocksize -\n\t\t\t(last_ext->extLength & UDF_EXTENT_LENGTH_MASK)) >>\n\t\t\tsb->s_blocksize_bits;\n\t\tif (add > blocks)\n\t\t\tadd = blocks;\n\t\tblocks -= add;\n\t\tlast_ext->extLength += add << sb->s_blocksize_bits;\n\t}\n\n\tif (fake) {\n\t\tudf_add_aext(inode, last_pos, &last_ext->extLocation,\n\t\t\t     last_ext->extLength, 1);\n\t\tcount++;\n\t} else\n\t\tudf_write_aext(inode, last_pos, &last_ext->extLocation,\n\t\t\t\tlast_ext->extLength, 1);\n\n\t/* Managed to do everything necessary? */\n\tif (!blocks)\n\t\tgoto out;\n\n\t/* All further extents will be NOT_RECORDED_NOT_ALLOCATED */\n\tlast_ext->extLocation.logicalBlockNum = 0;\n\tlast_ext->extLocation.partitionReferenceNum = 0;\n\tadd = (1 << (30-sb->s_blocksize_bits)) - 1;\n\tlast_ext->extLength = EXT_NOT_RECORDED_NOT_ALLOCATED |\n\t\t\t\t(add << sb->s_blocksize_bits);\n\n\t/* Create enough extents to cover the whole hole */\n\twhile (blocks > add) {\n\t\tblocks -= add;\n\t\terr = udf_add_aext(inode, last_pos, &last_ext->extLocation,\n\t\t\t\t   last_ext->extLength, 1);\n\t\tif (err)\n\t\t\treturn err;\n\t\tcount++;\n\t}\n\tif (blocks) {\n\t\tlast_ext->extLength = EXT_NOT_RECORDED_NOT_ALLOCATED |\n\t\t\t(blocks << sb->s_blocksize_bits);\n\t\terr = udf_add_aext(inode, last_pos, &last_ext->extLocation,\n\t\t\t\t   last_ext->extLength, 1);\n\t\tif (err)\n\t\t\treturn err;\n\t\tcount++;\n\t}\n\nout:\n\t/* Do we have some preallocated blocks saved? */\n\tif (prealloc_len) {\n\t\terr = udf_add_aext(inode, last_pos, &prealloc_loc,\n\t\t\t\t   prealloc_len, 1);\n\t\tif (err)\n\t\t\treturn err;\n\t\tlast_ext->extLocation = prealloc_loc;\n\t\tlast_ext->extLength = prealloc_len;\n\t\tcount++;\n\t}\n\n\t/* last_pos should point to the last written extent... */\n\tif (iinfo->i_alloc_type == ICBTAG_FLAG_AD_SHORT)\n\t\tlast_pos->offset -= sizeof(struct short_ad);\n\telse if (iinfo->i_alloc_type == ICBTAG_FLAG_AD_LONG)\n\t\tlast_pos->offset -= sizeof(struct long_ad);\n\telse\n\t\treturn -EIO;\n\n\treturn count;\n}",
    "includes": [
      "#include \"udf_sb.h\"",
      "#include \"udf_i.h\"",
      "#include <linux/aio.h>",
      "#include <linux/mpage.h>",
      "#include <linux/crc-itu-t.h>",
      "#include <linux/slab.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include \"udfdecl.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int udf_update_inode(struct inode *, int);",
      "static int udf_sync_inode(struct inode *inode);",
      "static int udf_alloc_i_data(struct inode *inode, size_t size);",
      "static sector_t inode_getblk(struct inode *, sector_t, int *, int *);",
      "static void udf_split_extents(struct inode *, int *, int, int,\n\t\t\t      struct kernel_long_ad[EXTENT_MERGE_SIZE], int *);",
      "static void udf_prealloc_extents(struct inode *, int, int,\n\t\t\t\t struct kernel_long_ad[EXTENT_MERGE_SIZE], int *);",
      "static void udf_merge_extents(struct inode *,\n\t\t\t      struct kernel_long_ad[EXTENT_MERGE_SIZE], int *);",
      "static void udf_update_extents(struct inode *,\n\t\t\t       struct kernel_long_ad[EXTENT_MERGE_SIZE], int, int,\n\t\t\t       struct extent_position *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "udf_add_aext",
          "args": [
            "inode",
            "last_pos",
            "&prealloc_loc",
            "prealloc_len",
            "1"
          ],
          "line": 581
        },
        "resolved": true,
        "details": {
          "function_name": "udf_add_aext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/inode.c",
          "lines": "1876-2003",
          "snippet": "int udf_add_aext(struct inode *inode, struct extent_position *epos,\n\t\t struct kernel_lb_addr *eloc, uint32_t elen, int inc)\n{\n\tint adsize;\n\tstruct short_ad *sad = NULL;\n\tstruct long_ad *lad = NULL;\n\tstruct allocExtDesc *aed;\n\tuint8_t *ptr;\n\tstruct udf_inode_info *iinfo = UDF_I(inode);\n\n\tif (!epos->bh)\n\t\tptr = iinfo->i_ext.i_data + epos->offset -\n\t\t\tudf_file_entry_alloc_offset(inode) +\n\t\t\tiinfo->i_lenEAttr;\n\telse\n\t\tptr = epos->bh->b_data + epos->offset;\n\n\tif (iinfo->i_alloc_type == ICBTAG_FLAG_AD_SHORT)\n\t\tadsize = sizeof(struct short_ad);\n\telse if (iinfo->i_alloc_type == ICBTAG_FLAG_AD_LONG)\n\t\tadsize = sizeof(struct long_ad);\n\telse\n\t\treturn -EIO;\n\n\tif (epos->offset + (2 * adsize) > inode->i_sb->s_blocksize) {\n\t\tunsigned char *sptr, *dptr;\n\t\tstruct buffer_head *nbh;\n\t\tint err, loffset;\n\t\tstruct kernel_lb_addr obloc = epos->block;\n\n\t\tepos->block.logicalBlockNum = udf_new_block(inode->i_sb, NULL,\n\t\t\t\t\t\tobloc.partitionReferenceNum,\n\t\t\t\t\t\tobloc.logicalBlockNum, &err);\n\t\tif (!epos->block.logicalBlockNum)\n\t\t\treturn -ENOSPC;\n\t\tnbh = udf_tgetblk(inode->i_sb, udf_get_lb_pblock(inode->i_sb,\n\t\t\t\t\t\t\t\t &epos->block,\n\t\t\t\t\t\t\t\t 0));\n\t\tif (!nbh)\n\t\t\treturn -EIO;\n\t\tlock_buffer(nbh);\n\t\tmemset(nbh->b_data, 0x00, inode->i_sb->s_blocksize);\n\t\tset_buffer_uptodate(nbh);\n\t\tunlock_buffer(nbh);\n\t\tmark_buffer_dirty_inode(nbh, inode);\n\n\t\taed = (struct allocExtDesc *)(nbh->b_data);\n\t\tif (!UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_STRICT))\n\t\t\taed->previousAllocExtLocation =\n\t\t\t\t\tcpu_to_le32(obloc.logicalBlockNum);\n\t\tif (epos->offset + adsize > inode->i_sb->s_blocksize) {\n\t\t\tloffset = epos->offset;\n\t\t\taed->lengthAllocDescs = cpu_to_le32(adsize);\n\t\t\tsptr = ptr - adsize;\n\t\t\tdptr = nbh->b_data + sizeof(struct allocExtDesc);\n\t\t\tmemcpy(dptr, sptr, adsize);\n\t\t\tepos->offset = sizeof(struct allocExtDesc) + adsize;\n\t\t} else {\n\t\t\tloffset = epos->offset + adsize;\n\t\t\taed->lengthAllocDescs = cpu_to_le32(0);\n\t\t\tsptr = ptr;\n\t\t\tepos->offset = sizeof(struct allocExtDesc);\n\n\t\t\tif (epos->bh) {\n\t\t\t\taed = (struct allocExtDesc *)epos->bh->b_data;\n\t\t\t\tle32_add_cpu(&aed->lengthAllocDescs, adsize);\n\t\t\t} else {\n\t\t\t\tiinfo->i_lenAlloc += adsize;\n\t\t\t\tmark_inode_dirty(inode);\n\t\t\t}\n\t\t}\n\t\tif (UDF_SB(inode->i_sb)->s_udfrev >= 0x0200)\n\t\t\tudf_new_tag(nbh->b_data, TAG_IDENT_AED, 3, 1,\n\t\t\t\t    epos->block.logicalBlockNum, sizeof(struct tag));\n\t\telse\n\t\t\tudf_new_tag(nbh->b_data, TAG_IDENT_AED, 2, 1,\n\t\t\t\t    epos->block.logicalBlockNum, sizeof(struct tag));\n\t\tswitch (iinfo->i_alloc_type) {\n\t\tcase ICBTAG_FLAG_AD_SHORT:\n\t\t\tsad = (struct short_ad *)sptr;\n\t\t\tsad->extLength = cpu_to_le32(EXT_NEXT_EXTENT_ALLOCDECS |\n\t\t\t\t\t\t     inode->i_sb->s_blocksize);\n\t\t\tsad->extPosition =\n\t\t\t\tcpu_to_le32(epos->block.logicalBlockNum);\n\t\t\tbreak;\n\t\tcase ICBTAG_FLAG_AD_LONG:\n\t\t\tlad = (struct long_ad *)sptr;\n\t\t\tlad->extLength = cpu_to_le32(EXT_NEXT_EXTENT_ALLOCDECS |\n\t\t\t\t\t\t     inode->i_sb->s_blocksize);\n\t\t\tlad->extLocation = cpu_to_lelb(epos->block);\n\t\t\tmemset(lad->impUse, 0x00, sizeof(lad->impUse));\n\t\t\tbreak;\n\t\t}\n\t\tif (epos->bh) {\n\t\t\tif (!UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_STRICT) ||\n\t\t\t    UDF_SB(inode->i_sb)->s_udfrev >= 0x0201)\n\t\t\t\tudf_update_tag(epos->bh->b_data, loffset);\n\t\t\telse\n\t\t\t\tudf_update_tag(epos->bh->b_data,\n\t\t\t\t\t\tsizeof(struct allocExtDesc));\n\t\t\tmark_buffer_dirty_inode(epos->bh, inode);\n\t\t\tbrelse(epos->bh);\n\t\t} else {\n\t\t\tmark_inode_dirty(inode);\n\t\t}\n\t\tepos->bh = nbh;\n\t}\n\n\tudf_write_aext(inode, epos, eloc, elen, inc);\n\n\tif (!epos->bh) {\n\t\tiinfo->i_lenAlloc += adsize;\n\t\tmark_inode_dirty(inode);\n\t} else {\n\t\taed = (struct allocExtDesc *)epos->bh->b_data;\n\t\tle32_add_cpu(&aed->lengthAllocDescs, adsize);\n\t\tif (!UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_STRICT) ||\n\t\t\t\tUDF_SB(inode->i_sb)->s_udfrev >= 0x0201)\n\t\t\tudf_update_tag(epos->bh->b_data,\n\t\t\t\t\tepos->offset + (inc ? 0 : adsize));\n\t\telse\n\t\t\tudf_update_tag(epos->bh->b_data,\n\t\t\t\t\tsizeof(struct allocExtDesc));\n\t\tmark_buffer_dirty_inode(epos->bh, inode);\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"udf_sb.h\"",
            "#include \"udf_i.h\"",
            "#include <linux/aio.h>",
            "#include <linux/mpage.h>",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int udf_update_inode(struct inode *, int);",
            "static int udf_sync_inode(struct inode *inode);",
            "static int8_t udf_insert_aext(struct inode *, struct extent_position,\n\t\t\t      struct kernel_lb_addr, uint32_t);",
            "static int udf_get_block(struct inode *, sector_t, struct buffer_head *, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/crc-itu-t.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include \"udfdecl.h\"\n\nstatic int udf_update_inode(struct inode *, int);\nstatic int udf_sync_inode(struct inode *inode);\nstatic int8_t udf_insert_aext(struct inode *, struct extent_position,\n\t\t\t      struct kernel_lb_addr, uint32_t);\nstatic int udf_get_block(struct inode *, sector_t, struct buffer_head *, int);\n\nint udf_add_aext(struct inode *inode, struct extent_position *epos,\n\t\t struct kernel_lb_addr *eloc, uint32_t elen, int inc)\n{\n\tint adsize;\n\tstruct short_ad *sad = NULL;\n\tstruct long_ad *lad = NULL;\n\tstruct allocExtDesc *aed;\n\tuint8_t *ptr;\n\tstruct udf_inode_info *iinfo = UDF_I(inode);\n\n\tif (!epos->bh)\n\t\tptr = iinfo->i_ext.i_data + epos->offset -\n\t\t\tudf_file_entry_alloc_offset(inode) +\n\t\t\tiinfo->i_lenEAttr;\n\telse\n\t\tptr = epos->bh->b_data + epos->offset;\n\n\tif (iinfo->i_alloc_type == ICBTAG_FLAG_AD_SHORT)\n\t\tadsize = sizeof(struct short_ad);\n\telse if (iinfo->i_alloc_type == ICBTAG_FLAG_AD_LONG)\n\t\tadsize = sizeof(struct long_ad);\n\telse\n\t\treturn -EIO;\n\n\tif (epos->offset + (2 * adsize) > inode->i_sb->s_blocksize) {\n\t\tunsigned char *sptr, *dptr;\n\t\tstruct buffer_head *nbh;\n\t\tint err, loffset;\n\t\tstruct kernel_lb_addr obloc = epos->block;\n\n\t\tepos->block.logicalBlockNum = udf_new_block(inode->i_sb, NULL,\n\t\t\t\t\t\tobloc.partitionReferenceNum,\n\t\t\t\t\t\tobloc.logicalBlockNum, &err);\n\t\tif (!epos->block.logicalBlockNum)\n\t\t\treturn -ENOSPC;\n\t\tnbh = udf_tgetblk(inode->i_sb, udf_get_lb_pblock(inode->i_sb,\n\t\t\t\t\t\t\t\t &epos->block,\n\t\t\t\t\t\t\t\t 0));\n\t\tif (!nbh)\n\t\t\treturn -EIO;\n\t\tlock_buffer(nbh);\n\t\tmemset(nbh->b_data, 0x00, inode->i_sb->s_blocksize);\n\t\tset_buffer_uptodate(nbh);\n\t\tunlock_buffer(nbh);\n\t\tmark_buffer_dirty_inode(nbh, inode);\n\n\t\taed = (struct allocExtDesc *)(nbh->b_data);\n\t\tif (!UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_STRICT))\n\t\t\taed->previousAllocExtLocation =\n\t\t\t\t\tcpu_to_le32(obloc.logicalBlockNum);\n\t\tif (epos->offset + adsize > inode->i_sb->s_blocksize) {\n\t\t\tloffset = epos->offset;\n\t\t\taed->lengthAllocDescs = cpu_to_le32(adsize);\n\t\t\tsptr = ptr - adsize;\n\t\t\tdptr = nbh->b_data + sizeof(struct allocExtDesc);\n\t\t\tmemcpy(dptr, sptr, adsize);\n\t\t\tepos->offset = sizeof(struct allocExtDesc) + adsize;\n\t\t} else {\n\t\t\tloffset = epos->offset + adsize;\n\t\t\taed->lengthAllocDescs = cpu_to_le32(0);\n\t\t\tsptr = ptr;\n\t\t\tepos->offset = sizeof(struct allocExtDesc);\n\n\t\t\tif (epos->bh) {\n\t\t\t\taed = (struct allocExtDesc *)epos->bh->b_data;\n\t\t\t\tle32_add_cpu(&aed->lengthAllocDescs, adsize);\n\t\t\t} else {\n\t\t\t\tiinfo->i_lenAlloc += adsize;\n\t\t\t\tmark_inode_dirty(inode);\n\t\t\t}\n\t\t}\n\t\tif (UDF_SB(inode->i_sb)->s_udfrev >= 0x0200)\n\t\t\tudf_new_tag(nbh->b_data, TAG_IDENT_AED, 3, 1,\n\t\t\t\t    epos->block.logicalBlockNum, sizeof(struct tag));\n\t\telse\n\t\t\tudf_new_tag(nbh->b_data, TAG_IDENT_AED, 2, 1,\n\t\t\t\t    epos->block.logicalBlockNum, sizeof(struct tag));\n\t\tswitch (iinfo->i_alloc_type) {\n\t\tcase ICBTAG_FLAG_AD_SHORT:\n\t\t\tsad = (struct short_ad *)sptr;\n\t\t\tsad->extLength = cpu_to_le32(EXT_NEXT_EXTENT_ALLOCDECS |\n\t\t\t\t\t\t     inode->i_sb->s_blocksize);\n\t\t\tsad->extPosition =\n\t\t\t\tcpu_to_le32(epos->block.logicalBlockNum);\n\t\t\tbreak;\n\t\tcase ICBTAG_FLAG_AD_LONG:\n\t\t\tlad = (struct long_ad *)sptr;\n\t\t\tlad->extLength = cpu_to_le32(EXT_NEXT_EXTENT_ALLOCDECS |\n\t\t\t\t\t\t     inode->i_sb->s_blocksize);\n\t\t\tlad->extLocation = cpu_to_lelb(epos->block);\n\t\t\tmemset(lad->impUse, 0x00, sizeof(lad->impUse));\n\t\t\tbreak;\n\t\t}\n\t\tif (epos->bh) {\n\t\t\tif (!UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_STRICT) ||\n\t\t\t    UDF_SB(inode->i_sb)->s_udfrev >= 0x0201)\n\t\t\t\tudf_update_tag(epos->bh->b_data, loffset);\n\t\t\telse\n\t\t\t\tudf_update_tag(epos->bh->b_data,\n\t\t\t\t\t\tsizeof(struct allocExtDesc));\n\t\t\tmark_buffer_dirty_inode(epos->bh, inode);\n\t\t\tbrelse(epos->bh);\n\t\t} else {\n\t\t\tmark_inode_dirty(inode);\n\t\t}\n\t\tepos->bh = nbh;\n\t}\n\n\tudf_write_aext(inode, epos, eloc, elen, inc);\n\n\tif (!epos->bh) {\n\t\tiinfo->i_lenAlloc += adsize;\n\t\tmark_inode_dirty(inode);\n\t} else {\n\t\taed = (struct allocExtDesc *)epos->bh->b_data;\n\t\tle32_add_cpu(&aed->lengthAllocDescs, adsize);\n\t\tif (!UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_STRICT) ||\n\t\t\t\tUDF_SB(inode->i_sb)->s_udfrev >= 0x0201)\n\t\t\tudf_update_tag(epos->bh->b_data,\n\t\t\t\t\tepos->offset + (inc ? 0 : adsize));\n\t\telse\n\t\t\tudf_update_tag(epos->bh->b_data,\n\t\t\t\t\tsizeof(struct allocExtDesc));\n\t\tmark_buffer_dirty_inode(epos->bh, inode);\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_write_aext",
          "args": [
            "inode",
            "last_pos",
            "&last_ext->extLocation",
            "last_ext->extLength",
            "1"
          ],
          "line": 545
        },
        "resolved": true,
        "details": {
          "function_name": "udf_write_aext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/inode.c",
          "lines": "2005-2055",
          "snippet": "void udf_write_aext(struct inode *inode, struct extent_position *epos,\n\t\t    struct kernel_lb_addr *eloc, uint32_t elen, int inc)\n{\n\tint adsize;\n\tuint8_t *ptr;\n\tstruct short_ad *sad;\n\tstruct long_ad *lad;\n\tstruct udf_inode_info *iinfo = UDF_I(inode);\n\n\tif (!epos->bh)\n\t\tptr = iinfo->i_ext.i_data + epos->offset -\n\t\t\tudf_file_entry_alloc_offset(inode) +\n\t\t\tiinfo->i_lenEAttr;\n\telse\n\t\tptr = epos->bh->b_data + epos->offset;\n\n\tswitch (iinfo->i_alloc_type) {\n\tcase ICBTAG_FLAG_AD_SHORT:\n\t\tsad = (struct short_ad *)ptr;\n\t\tsad->extLength = cpu_to_le32(elen);\n\t\tsad->extPosition = cpu_to_le32(eloc->logicalBlockNum);\n\t\tadsize = sizeof(struct short_ad);\n\t\tbreak;\n\tcase ICBTAG_FLAG_AD_LONG:\n\t\tlad = (struct long_ad *)ptr;\n\t\tlad->extLength = cpu_to_le32(elen);\n\t\tlad->extLocation = cpu_to_lelb(*eloc);\n\t\tmemset(lad->impUse, 0x00, sizeof(lad->impUse));\n\t\tadsize = sizeof(struct long_ad);\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\n\tif (epos->bh) {\n\t\tif (!UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_STRICT) ||\n\t\t    UDF_SB(inode->i_sb)->s_udfrev >= 0x0201) {\n\t\t\tstruct allocExtDesc *aed =\n\t\t\t\t(struct allocExtDesc *)epos->bh->b_data;\n\t\t\tudf_update_tag(epos->bh->b_data,\n\t\t\t\t       le32_to_cpu(aed->lengthAllocDescs) +\n\t\t\t\t       sizeof(struct allocExtDesc));\n\t\t}\n\t\tmark_buffer_dirty_inode(epos->bh, inode);\n\t} else {\n\t\tmark_inode_dirty(inode);\n\t}\n\n\tif (inc)\n\t\tepos->offset += adsize;\n}",
          "includes": [
            "#include \"udf_sb.h\"",
            "#include \"udf_i.h\"",
            "#include <linux/aio.h>",
            "#include <linux/mpage.h>",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int udf_update_inode(struct inode *, int);",
            "static int udf_sync_inode(struct inode *inode);",
            "static int8_t udf_insert_aext(struct inode *, struct extent_position,\n\t\t\t      struct kernel_lb_addr, uint32_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/crc-itu-t.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include \"udfdecl.h\"\n\nstatic int udf_update_inode(struct inode *, int);\nstatic int udf_sync_inode(struct inode *inode);\nstatic int8_t udf_insert_aext(struct inode *, struct extent_position,\n\t\t\t      struct kernel_lb_addr, uint32_t);\n\nvoid udf_write_aext(struct inode *inode, struct extent_position *epos,\n\t\t    struct kernel_lb_addr *eloc, uint32_t elen, int inc)\n{\n\tint adsize;\n\tuint8_t *ptr;\n\tstruct short_ad *sad;\n\tstruct long_ad *lad;\n\tstruct udf_inode_info *iinfo = UDF_I(inode);\n\n\tif (!epos->bh)\n\t\tptr = iinfo->i_ext.i_data + epos->offset -\n\t\t\tudf_file_entry_alloc_offset(inode) +\n\t\t\tiinfo->i_lenEAttr;\n\telse\n\t\tptr = epos->bh->b_data + epos->offset;\n\n\tswitch (iinfo->i_alloc_type) {\n\tcase ICBTAG_FLAG_AD_SHORT:\n\t\tsad = (struct short_ad *)ptr;\n\t\tsad->extLength = cpu_to_le32(elen);\n\t\tsad->extPosition = cpu_to_le32(eloc->logicalBlockNum);\n\t\tadsize = sizeof(struct short_ad);\n\t\tbreak;\n\tcase ICBTAG_FLAG_AD_LONG:\n\t\tlad = (struct long_ad *)ptr;\n\t\tlad->extLength = cpu_to_le32(elen);\n\t\tlad->extLocation = cpu_to_lelb(*eloc);\n\t\tmemset(lad->impUse, 0x00, sizeof(lad->impUse));\n\t\tadsize = sizeof(struct long_ad);\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\n\tif (epos->bh) {\n\t\tif (!UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_STRICT) ||\n\t\t    UDF_SB(inode->i_sb)->s_udfrev >= 0x0201) {\n\t\t\tstruct allocExtDesc *aed =\n\t\t\t\t(struct allocExtDesc *)epos->bh->b_data;\n\t\t\tudf_update_tag(epos->bh->b_data,\n\t\t\t\t       le32_to_cpu(aed->lengthAllocDescs) +\n\t\t\t\t       sizeof(struct allocExtDesc));\n\t\t}\n\t\tmark_buffer_dirty_inode(epos->bh, inode);\n\t} else {\n\t\tmark_inode_dirty(inode);\n\t}\n\n\tif (inc)\n\t\tepos->offset += adsize;\n}"
        }
      },
      {
        "call_info": {
          "callee": "UDF_I",
          "args": [
            "inode"
          ],
          "line": 503
        },
        "resolved": true,
        "details": {
          "function_name": "UDF_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/udf_i.h",
          "lines": "57-60",
          "snippet": "static inline struct udf_inode_info *UDF_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct udf_inode_info, vfs_inode);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline struct udf_inode_info *UDF_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct udf_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/crc-itu-t.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include \"udfdecl.h\"\n\nstatic int udf_update_inode(struct inode *, int);\nstatic int udf_sync_inode(struct inode *inode);\nstatic int udf_alloc_i_data(struct inode *inode, size_t size);\nstatic sector_t inode_getblk(struct inode *, sector_t, int *, int *);\nstatic void udf_split_extents(struct inode *, int *, int, int,\n\t\t\t      struct kernel_long_ad[EXTENT_MERGE_SIZE], int *);\nstatic void udf_prealloc_extents(struct inode *, int, int,\n\t\t\t\t struct kernel_long_ad[EXTENT_MERGE_SIZE], int *);\nstatic void udf_merge_extents(struct inode *,\n\t\t\t      struct kernel_long_ad[EXTENT_MERGE_SIZE], int *);\nstatic void udf_update_extents(struct inode *,\n\t\t\t       struct kernel_long_ad[EXTENT_MERGE_SIZE], int, int,\n\t\t\t       struct extent_position *);\n\nstatic int udf_do_extend_file(struct inode *inode,\n\t\t\t      struct extent_position *last_pos,\n\t\t\t      struct kernel_long_ad *last_ext,\n\t\t\t      sector_t blocks)\n{\n\tsector_t add;\n\tint count = 0, fake = !(last_ext->extLength & UDF_EXTENT_LENGTH_MASK);\n\tstruct super_block *sb = inode->i_sb;\n\tstruct kernel_lb_addr prealloc_loc = {};\n\tint prealloc_len = 0;\n\tstruct udf_inode_info *iinfo;\n\tint err;\n\n\t/* The previous extent is fake and we should not extend by anything\n\t * - there's nothing to do... */\n\tif (!blocks && fake)\n\t\treturn 0;\n\n\tiinfo = UDF_I(inode);\n\t/* Round the last extent up to a multiple of block size */\n\tif (last_ext->extLength & (sb->s_blocksize - 1)) {\n\t\tlast_ext->extLength =\n\t\t\t(last_ext->extLength & UDF_EXTENT_FLAG_MASK) |\n\t\t\t(((last_ext->extLength & UDF_EXTENT_LENGTH_MASK) +\n\t\t\t  sb->s_blocksize - 1) & ~(sb->s_blocksize - 1));\n\t\tiinfo->i_lenExtents =\n\t\t\t(iinfo->i_lenExtents + sb->s_blocksize - 1) &\n\t\t\t~(sb->s_blocksize - 1);\n\t}\n\n\t/* Last extent are just preallocated blocks? */\n\tif ((last_ext->extLength & UDF_EXTENT_FLAG_MASK) ==\n\t\t\t\t\t\tEXT_NOT_RECORDED_ALLOCATED) {\n\t\t/* Save the extent so that we can reattach it to the end */\n\t\tprealloc_loc = last_ext->extLocation;\n\t\tprealloc_len = last_ext->extLength;\n\t\t/* Mark the extent as a hole */\n\t\tlast_ext->extLength = EXT_NOT_RECORDED_NOT_ALLOCATED |\n\t\t\t(last_ext->extLength & UDF_EXTENT_LENGTH_MASK);\n\t\tlast_ext->extLocation.logicalBlockNum = 0;\n\t\tlast_ext->extLocation.partitionReferenceNum = 0;\n\t}\n\n\t/* Can we merge with the previous extent? */\n\tif ((last_ext->extLength & UDF_EXTENT_FLAG_MASK) ==\n\t\t\t\t\tEXT_NOT_RECORDED_NOT_ALLOCATED) {\n\t\tadd = ((1 << 30) - sb->s_blocksize -\n\t\t\t(last_ext->extLength & UDF_EXTENT_LENGTH_MASK)) >>\n\t\t\tsb->s_blocksize_bits;\n\t\tif (add > blocks)\n\t\t\tadd = blocks;\n\t\tblocks -= add;\n\t\tlast_ext->extLength += add << sb->s_blocksize_bits;\n\t}\n\n\tif (fake) {\n\t\tudf_add_aext(inode, last_pos, &last_ext->extLocation,\n\t\t\t     last_ext->extLength, 1);\n\t\tcount++;\n\t} else\n\t\tudf_write_aext(inode, last_pos, &last_ext->extLocation,\n\t\t\t\tlast_ext->extLength, 1);\n\n\t/* Managed to do everything necessary? */\n\tif (!blocks)\n\t\tgoto out;\n\n\t/* All further extents will be NOT_RECORDED_NOT_ALLOCATED */\n\tlast_ext->extLocation.logicalBlockNum = 0;\n\tlast_ext->extLocation.partitionReferenceNum = 0;\n\tadd = (1 << (30-sb->s_blocksize_bits)) - 1;\n\tlast_ext->extLength = EXT_NOT_RECORDED_NOT_ALLOCATED |\n\t\t\t\t(add << sb->s_blocksize_bits);\n\n\t/* Create enough extents to cover the whole hole */\n\twhile (blocks > add) {\n\t\tblocks -= add;\n\t\terr = udf_add_aext(inode, last_pos, &last_ext->extLocation,\n\t\t\t\t   last_ext->extLength, 1);\n\t\tif (err)\n\t\t\treturn err;\n\t\tcount++;\n\t}\n\tif (blocks) {\n\t\tlast_ext->extLength = EXT_NOT_RECORDED_NOT_ALLOCATED |\n\t\t\t(blocks << sb->s_blocksize_bits);\n\t\terr = udf_add_aext(inode, last_pos, &last_ext->extLocation,\n\t\t\t\t   last_ext->extLength, 1);\n\t\tif (err)\n\t\t\treturn err;\n\t\tcount++;\n\t}\n\nout:\n\t/* Do we have some preallocated blocks saved? */\n\tif (prealloc_len) {\n\t\terr = udf_add_aext(inode, last_pos, &prealloc_loc,\n\t\t\t\t   prealloc_len, 1);\n\t\tif (err)\n\t\t\treturn err;\n\t\tlast_ext->extLocation = prealloc_loc;\n\t\tlast_ext->extLength = prealloc_len;\n\t\tcount++;\n\t}\n\n\t/* last_pos should point to the last written extent... */\n\tif (iinfo->i_alloc_type == ICBTAG_FLAG_AD_SHORT)\n\t\tlast_pos->offset -= sizeof(struct short_ad);\n\telse if (iinfo->i_alloc_type == ICBTAG_FLAG_AD_LONG)\n\t\tlast_pos->offset -= sizeof(struct long_ad);\n\telse\n\t\treturn -EIO;\n\n\treturn count;\n}"
  },
  {
    "function_name": "udf_getblk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/inode.c",
    "lines": "460-482",
    "snippet": "static struct buffer_head *udf_getblk(struct inode *inode, long block,\n\t\t\t\t      int create, int *err)\n{\n\tstruct buffer_head *bh;\n\tstruct buffer_head dummy;\n\n\tdummy.b_state = 0;\n\tdummy.b_blocknr = -1000;\n\t*err = udf_get_block(inode, block, &dummy, create);\n\tif (!*err && buffer_mapped(&dummy)) {\n\t\tbh = sb_getblk(inode->i_sb, dummy.b_blocknr);\n\t\tif (buffer_new(&dummy)) {\n\t\t\tlock_buffer(bh);\n\t\t\tmemset(bh->b_data, 0x00, inode->i_sb->s_blocksize);\n\t\t\tset_buffer_uptodate(bh);\n\t\t\tunlock_buffer(bh);\n\t\t\tmark_buffer_dirty_inode(bh, inode);\n\t\t}\n\t\treturn bh;\n\t}\n\n\treturn NULL;\n}",
    "includes": [
      "#include \"udf_sb.h\"",
      "#include \"udf_i.h\"",
      "#include <linux/aio.h>",
      "#include <linux/mpage.h>",
      "#include <linux/crc-itu-t.h>",
      "#include <linux/slab.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include \"udfdecl.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int udf_update_inode(struct inode *, int);",
      "static int udf_sync_inode(struct inode *inode);",
      "static int udf_get_block(struct inode *, sector_t, struct buffer_head *, int);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mark_buffer_dirty_inode",
          "args": [
            "bh",
            "inode"
          ],
          "line": 476
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_dirty_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "599-617",
          "snippet": "void mark_buffer_dirty_inode(struct buffer_head *bh, struct inode *inode)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tstruct address_space *buffer_mapping = bh->b_page->mapping;\n\n\tmark_buffer_dirty(bh);\n\tif (!mapping->private_data) {\n\t\tmapping->private_data = buffer_mapping;\n\t} else {\n\t\tBUG_ON(mapping->private_data != buffer_mapping);\n\t}\n\tif (!bh->b_assoc_map) {\n\t\tspin_lock(&buffer_mapping->private_lock);\n\t\tlist_move_tail(&bh->b_assoc_buffers,\n\t\t\t\t&mapping->private_list);\n\t\tbh->b_assoc_map = mapping;\n\t\tspin_unlock(&buffer_mapping->private_lock);\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_dirty_inode(struct buffer_head *bh, struct inode *inode)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tstruct address_space *buffer_mapping = bh->b_page->mapping;\n\n\tmark_buffer_dirty(bh);\n\tif (!mapping->private_data) {\n\t\tmapping->private_data = buffer_mapping;\n\t} else {\n\t\tBUG_ON(mapping->private_data != buffer_mapping);\n\t}\n\tif (!bh->b_assoc_map) {\n\t\tspin_lock(&buffer_mapping->private_lock);\n\t\tlist_move_tail(&bh->b_assoc_buffers,\n\t\t\t\t&mapping->private_list);\n\t\tbh->b_assoc_map = mapping;\n\t\tspin_unlock(&buffer_mapping->private_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_buffer",
          "args": [
            "bh"
          ],
          "line": 475
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "70-75",
          "snippet": "void unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_buffer_uptodate",
          "args": [
            "bh"
          ],
          "line": 474
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3758-3761",
          "snippet": "int btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "bh->b_data",
            "0x00",
            "inode->i_sb->s_blocksize"
          ],
          "line": 473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_new",
          "args": [
            "&dummy"
          ],
          "line": 471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_getblk",
          "args": [
            "inode->i_sb",
            "dummy.b_blocknr"
          ],
          "line": 470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_mapped",
          "args": [
            "&dummy"
          ],
          "line": 469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udf_get_block",
          "args": [
            "inode",
            "block",
            "&dummy",
            "create"
          ],
          "line": 468
        },
        "resolved": true,
        "details": {
          "function_name": "udf_get_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/inode.c",
          "lines": "422-458",
          "snippet": "static int udf_get_block(struct inode *inode, sector_t block,\n\t\t\t struct buffer_head *bh_result, int create)\n{\n\tint err, new;\n\tsector_t phys = 0;\n\tstruct udf_inode_info *iinfo;\n\n\tif (!create) {\n\t\tphys = udf_block_map(inode, block);\n\t\tif (phys)\n\t\t\tmap_bh(bh_result, inode->i_sb, phys);\n\t\treturn 0;\n\t}\n\n\terr = -EIO;\n\tnew = 0;\n\tiinfo = UDF_I(inode);\n\n\tdown_write(&iinfo->i_data_sem);\n\tif (block == iinfo->i_next_alloc_block + 1) {\n\t\tiinfo->i_next_alloc_block++;\n\t\tiinfo->i_next_alloc_goal++;\n\t}\n\n\tudf_clear_extent_cache(inode);\n\tphys = inode_getblk(inode, block, &err, &new);\n\tif (!phys)\n\t\tgoto abort;\n\n\tif (new)\n\t\tset_buffer_new(bh_result);\n\tmap_bh(bh_result, inode->i_sb, phys);\n\nabort:\n\tup_write(&iinfo->i_data_sem);\n\treturn err;\n}",
          "includes": [
            "#include \"udf_sb.h\"",
            "#include \"udf_i.h\"",
            "#include <linux/aio.h>",
            "#include <linux/mpage.h>",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int udf_update_inode(struct inode *, int);",
            "static int udf_sync_inode(struct inode *inode);",
            "static sector_t inode_getblk(struct inode *, sector_t, int *, int *);",
            "static int udf_get_block(struct inode *, sector_t, struct buffer_head *, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/crc-itu-t.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include \"udfdecl.h\"\n\nstatic int udf_update_inode(struct inode *, int);\nstatic int udf_sync_inode(struct inode *inode);\nstatic sector_t inode_getblk(struct inode *, sector_t, int *, int *);\nstatic int udf_get_block(struct inode *, sector_t, struct buffer_head *, int);\n\nstatic int udf_get_block(struct inode *inode, sector_t block,\n\t\t\t struct buffer_head *bh_result, int create)\n{\n\tint err, new;\n\tsector_t phys = 0;\n\tstruct udf_inode_info *iinfo;\n\n\tif (!create) {\n\t\tphys = udf_block_map(inode, block);\n\t\tif (phys)\n\t\t\tmap_bh(bh_result, inode->i_sb, phys);\n\t\treturn 0;\n\t}\n\n\terr = -EIO;\n\tnew = 0;\n\tiinfo = UDF_I(inode);\n\n\tdown_write(&iinfo->i_data_sem);\n\tif (block == iinfo->i_next_alloc_block + 1) {\n\t\tiinfo->i_next_alloc_block++;\n\t\tiinfo->i_next_alloc_goal++;\n\t}\n\n\tudf_clear_extent_cache(inode);\n\tphys = inode_getblk(inode, block, &err, &new);\n\tif (!phys)\n\t\tgoto abort;\n\n\tif (new)\n\t\tset_buffer_new(bh_result);\n\tmap_bh(bh_result, inode->i_sb, phys);\n\nabort:\n\tup_write(&iinfo->i_data_sem);\n\treturn err;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/crc-itu-t.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include \"udfdecl.h\"\n\nstatic int udf_update_inode(struct inode *, int);\nstatic int udf_sync_inode(struct inode *inode);\nstatic int udf_get_block(struct inode *, sector_t, struct buffer_head *, int);\n\nstatic struct buffer_head *udf_getblk(struct inode *inode, long block,\n\t\t\t\t      int create, int *err)\n{\n\tstruct buffer_head *bh;\n\tstruct buffer_head dummy;\n\n\tdummy.b_state = 0;\n\tdummy.b_blocknr = -1000;\n\t*err = udf_get_block(inode, block, &dummy, create);\n\tif (!*err && buffer_mapped(&dummy)) {\n\t\tbh = sb_getblk(inode->i_sb, dummy.b_blocknr);\n\t\tif (buffer_new(&dummy)) {\n\t\t\tlock_buffer(bh);\n\t\t\tmemset(bh->b_data, 0x00, inode->i_sb->s_blocksize);\n\t\t\tset_buffer_uptodate(bh);\n\t\t\tunlock_buffer(bh);\n\t\t\tmark_buffer_dirty_inode(bh, inode);\n\t\t}\n\t\treturn bh;\n\t}\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "udf_get_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/inode.c",
    "lines": "422-458",
    "snippet": "static int udf_get_block(struct inode *inode, sector_t block,\n\t\t\t struct buffer_head *bh_result, int create)\n{\n\tint err, new;\n\tsector_t phys = 0;\n\tstruct udf_inode_info *iinfo;\n\n\tif (!create) {\n\t\tphys = udf_block_map(inode, block);\n\t\tif (phys)\n\t\t\tmap_bh(bh_result, inode->i_sb, phys);\n\t\treturn 0;\n\t}\n\n\terr = -EIO;\n\tnew = 0;\n\tiinfo = UDF_I(inode);\n\n\tdown_write(&iinfo->i_data_sem);\n\tif (block == iinfo->i_next_alloc_block + 1) {\n\t\tiinfo->i_next_alloc_block++;\n\t\tiinfo->i_next_alloc_goal++;\n\t}\n\n\tudf_clear_extent_cache(inode);\n\tphys = inode_getblk(inode, block, &err, &new);\n\tif (!phys)\n\t\tgoto abort;\n\n\tif (new)\n\t\tset_buffer_new(bh_result);\n\tmap_bh(bh_result, inode->i_sb, phys);\n\nabort:\n\tup_write(&iinfo->i_data_sem);\n\treturn err;\n}",
    "includes": [
      "#include \"udf_sb.h\"",
      "#include \"udf_i.h\"",
      "#include <linux/aio.h>",
      "#include <linux/mpage.h>",
      "#include <linux/crc-itu-t.h>",
      "#include <linux/slab.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include \"udfdecl.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int udf_update_inode(struct inode *, int);",
      "static int udf_sync_inode(struct inode *inode);",
      "static sector_t inode_getblk(struct inode *, sector_t, int *, int *);",
      "static int udf_get_block(struct inode *, sector_t, struct buffer_head *, int);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&iinfo->i_data_sem"
          ],
          "line": 456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "map_bh",
          "args": [
            "bh_result",
            "inode->i_sb",
            "phys"
          ],
          "line": 453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_buffer_new",
          "args": [
            "bh_result"
          ],
          "line": 452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode_getblk",
          "args": [
            "inode",
            "block",
            "&err",
            "&new"
          ],
          "line": 447
        },
        "resolved": true,
        "details": {
          "function_name": "inode_getblk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/inode.c",
          "lines": "658-891",
          "snippet": "static sector_t inode_getblk(struct inode *inode, sector_t block,\n\t\t\t     int *err, int *new)\n{\n\tstruct kernel_long_ad laarr[EXTENT_MERGE_SIZE];\n\tstruct extent_position prev_epos, cur_epos, next_epos;\n\tint count = 0, startnum = 0, endnum = 0;\n\tuint32_t elen = 0, tmpelen;\n\tstruct kernel_lb_addr eloc, tmpeloc;\n\tint c = 1;\n\tloff_t lbcount = 0, b_off = 0;\n\tuint32_t newblocknum, newblock;\n\tsector_t offset = 0;\n\tint8_t etype;\n\tstruct udf_inode_info *iinfo = UDF_I(inode);\n\tint goal = 0, pgoal = iinfo->i_location.logicalBlockNum;\n\tint lastblock = 0;\n\tbool isBeyondEOF;\n\n\t*err = 0;\n\t*new = 0;\n\tprev_epos.offset = udf_file_entry_alloc_offset(inode);\n\tprev_epos.block = iinfo->i_location;\n\tprev_epos.bh = NULL;\n\tcur_epos = next_epos = prev_epos;\n\tb_off = (loff_t)block << inode->i_sb->s_blocksize_bits;\n\n\t/* find the extent which contains the block we are looking for.\n\t   alternate between laarr[0] and laarr[1] for locations of the\n\t   current extent, and the previous extent */\n\tdo {\n\t\tif (prev_epos.bh != cur_epos.bh) {\n\t\t\tbrelse(prev_epos.bh);\n\t\t\tget_bh(cur_epos.bh);\n\t\t\tprev_epos.bh = cur_epos.bh;\n\t\t}\n\t\tif (cur_epos.bh != next_epos.bh) {\n\t\t\tbrelse(cur_epos.bh);\n\t\t\tget_bh(next_epos.bh);\n\t\t\tcur_epos.bh = next_epos.bh;\n\t\t}\n\n\t\tlbcount += elen;\n\n\t\tprev_epos.block = cur_epos.block;\n\t\tcur_epos.block = next_epos.block;\n\n\t\tprev_epos.offset = cur_epos.offset;\n\t\tcur_epos.offset = next_epos.offset;\n\n\t\tetype = udf_next_aext(inode, &next_epos, &eloc, &elen, 1);\n\t\tif (etype == -1)\n\t\t\tbreak;\n\n\t\tc = !c;\n\n\t\tlaarr[c].extLength = (etype << 30) | elen;\n\t\tlaarr[c].extLocation = eloc;\n\n\t\tif (etype != (EXT_NOT_RECORDED_NOT_ALLOCATED >> 30))\n\t\t\tpgoal = eloc.logicalBlockNum +\n\t\t\t\t((elen + inode->i_sb->s_blocksize - 1) >>\n\t\t\t\t inode->i_sb->s_blocksize_bits);\n\n\t\tcount++;\n\t} while (lbcount + elen <= b_off);\n\n\tb_off -= lbcount;\n\toffset = b_off >> inode->i_sb->s_blocksize_bits;\n\t/*\n\t * Move prev_epos and cur_epos into indirect extent if we are at\n\t * the pointer to it\n\t */\n\tudf_next_aext(inode, &prev_epos, &tmpeloc, &tmpelen, 0);\n\tudf_next_aext(inode, &cur_epos, &tmpeloc, &tmpelen, 0);\n\n\t/* if the extent is allocated and recorded, return the block\n\t   if the extent is not a multiple of the blocksize, round up */\n\n\tif (etype == (EXT_RECORDED_ALLOCATED >> 30)) {\n\t\tif (elen & (inode->i_sb->s_blocksize - 1)) {\n\t\t\telen = EXT_RECORDED_ALLOCATED |\n\t\t\t\t((elen + inode->i_sb->s_blocksize - 1) &\n\t\t\t\t ~(inode->i_sb->s_blocksize - 1));\n\t\t\tudf_write_aext(inode, &cur_epos, &eloc, elen, 1);\n\t\t}\n\t\tbrelse(prev_epos.bh);\n\t\tbrelse(cur_epos.bh);\n\t\tbrelse(next_epos.bh);\n\t\tnewblock = udf_get_lb_pblock(inode->i_sb, &eloc, offset);\n\t\treturn newblock;\n\t}\n\n\t/* Are we beyond EOF? */\n\tif (etype == -1) {\n\t\tint ret;\n\t\tisBeyondEOF = true;\n\t\tif (count) {\n\t\t\tif (c)\n\t\t\t\tlaarr[0] = laarr[1];\n\t\t\tstartnum = 1;\n\t\t} else {\n\t\t\t/* Create a fake extent when there's not one */\n\t\t\tmemset(&laarr[0].extLocation, 0x00,\n\t\t\t\tsizeof(struct kernel_lb_addr));\n\t\t\tlaarr[0].extLength = EXT_NOT_RECORDED_NOT_ALLOCATED;\n\t\t\t/* Will udf_do_extend_file() create real extent from\n\t\t\t   a fake one? */\n\t\t\tstartnum = (offset > 0);\n\t\t}\n\t\t/* Create extents for the hole between EOF and offset */\n\t\tret = udf_do_extend_file(inode, &prev_epos, laarr, offset);\n\t\tif (ret < 0) {\n\t\t\tbrelse(prev_epos.bh);\n\t\t\tbrelse(cur_epos.bh);\n\t\t\tbrelse(next_epos.bh);\n\t\t\t*err = ret;\n\t\t\treturn 0;\n\t\t}\n\t\tc = 0;\n\t\toffset = 0;\n\t\tcount += ret;\n\t\t/* We are not covered by a preallocated extent? */\n\t\tif ((laarr[0].extLength & UDF_EXTENT_FLAG_MASK) !=\n\t\t\t\t\t\tEXT_NOT_RECORDED_ALLOCATED) {\n\t\t\t/* Is there any real extent? - otherwise we overwrite\n\t\t\t * the fake one... */\n\t\t\tif (count)\n\t\t\t\tc = !c;\n\t\t\tlaarr[c].extLength = EXT_NOT_RECORDED_NOT_ALLOCATED |\n\t\t\t\tinode->i_sb->s_blocksize;\n\t\t\tmemset(&laarr[c].extLocation, 0x00,\n\t\t\t\tsizeof(struct kernel_lb_addr));\n\t\t\tcount++;\n\t\t}\n\t\tendnum = c + 1;\n\t\tlastblock = 1;\n\t} else {\n\t\tisBeyondEOF = false;\n\t\tendnum = startnum = ((count > 2) ? 2 : count);\n\n\t\t/* if the current extent is in position 0,\n\t\t   swap it with the previous */\n\t\tif (!c && count != 1) {\n\t\t\tlaarr[2] = laarr[0];\n\t\t\tlaarr[0] = laarr[1];\n\t\t\tlaarr[1] = laarr[2];\n\t\t\tc = 1;\n\t\t}\n\n\t\t/* if the current block is located in an extent,\n\t\t   read the next extent */\n\t\tetype = udf_next_aext(inode, &next_epos, &eloc, &elen, 0);\n\t\tif (etype != -1) {\n\t\t\tlaarr[c + 1].extLength = (etype << 30) | elen;\n\t\t\tlaarr[c + 1].extLocation = eloc;\n\t\t\tcount++;\n\t\t\tstartnum++;\n\t\t\tendnum++;\n\t\t} else\n\t\t\tlastblock = 1;\n\t}\n\n\t/* if the current extent is not recorded but allocated, get the\n\t * block in the extent corresponding to the requested block */\n\tif ((laarr[c].extLength >> 30) == (EXT_NOT_RECORDED_ALLOCATED >> 30))\n\t\tnewblocknum = laarr[c].extLocation.logicalBlockNum + offset;\n\telse { /* otherwise, allocate a new block */\n\t\tif (iinfo->i_next_alloc_block == block)\n\t\t\tgoal = iinfo->i_next_alloc_goal;\n\n\t\tif (!goal) {\n\t\t\tif (!(goal = pgoal)) /* XXX: what was intended here? */\n\t\t\t\tgoal = iinfo->i_location.logicalBlockNum + 1;\n\t\t}\n\n\t\tnewblocknum = udf_new_block(inode->i_sb, inode,\n\t\t\t\tiinfo->i_location.partitionReferenceNum,\n\t\t\t\tgoal, err);\n\t\tif (!newblocknum) {\n\t\t\tbrelse(prev_epos.bh);\n\t\t\tbrelse(cur_epos.bh);\n\t\t\tbrelse(next_epos.bh);\n\t\t\t*err = -ENOSPC;\n\t\t\treturn 0;\n\t\t}\n\t\tif (isBeyondEOF)\n\t\t\tiinfo->i_lenExtents += inode->i_sb->s_blocksize;\n\t}\n\n\t/* if the extent the requsted block is located in contains multiple\n\t * blocks, split the extent into at most three extents. blocks prior\n\t * to requested block, requested block, and blocks after requested\n\t * block */\n\tudf_split_extents(inode, &c, offset, newblocknum, laarr, &endnum);\n\n#ifdef UDF_PREALLOCATE\n\t/* We preallocate blocks only for regular files. It also makes sense\n\t * for directories but there's a problem when to drop the\n\t * preallocation. We might use some delayed work for that but I feel\n\t * it's overengineering for a filesystem like UDF. */\n\tif (S_ISREG(inode->i_mode))\n\t\tudf_prealloc_extents(inode, c, lastblock, laarr, &endnum);\n#endif\n\n\t/* merge any continuous blocks in laarr */\n\tudf_merge_extents(inode, laarr, &endnum);\n\n\t/* write back the new extents, inserting new extents if the new number\n\t * of extents is greater than the old number, and deleting extents if\n\t * the new number of extents is less than the old number */\n\tudf_update_extents(inode, laarr, startnum, endnum, &prev_epos);\n\n\tbrelse(prev_epos.bh);\n\tbrelse(cur_epos.bh);\n\tbrelse(next_epos.bh);\n\n\tnewblock = udf_get_pblock(inode->i_sb, newblocknum,\n\t\t\t\tiinfo->i_location.partitionReferenceNum, 0);\n\tif (!newblock) {\n\t\t*err = -EIO;\n\t\treturn 0;\n\t}\n\t*new = 1;\n\tiinfo->i_next_alloc_block = block;\n\tiinfo->i_next_alloc_goal = newblocknum;\n\tinode->i_ctime = current_fs_time(inode->i_sb);\n\n\tif (IS_SYNC(inode))\n\t\tudf_sync_inode(inode);\n\telse\n\t\tmark_inode_dirty(inode);\n\n\treturn newblock;\n}",
          "includes": [
            "#include \"udf_sb.h\"",
            "#include \"udf_i.h\"",
            "#include <linux/aio.h>",
            "#include <linux/mpage.h>",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [
            "#define EXTENT_MERGE_SIZE 5"
          ],
          "globals_used": [
            "static int udf_update_inode(struct inode *, int);",
            "static int udf_sync_inode(struct inode *inode);",
            "static sector_t inode_getblk(struct inode *, sector_t, int *, int *);",
            "static int8_t udf_insert_aext(struct inode *, struct extent_position,\n\t\t\t      struct kernel_lb_addr, uint32_t);",
            "static void udf_split_extents(struct inode *, int *, int, int,\n\t\t\t      struct kernel_long_ad[EXTENT_MERGE_SIZE], int *);",
            "static void udf_prealloc_extents(struct inode *, int, int,\n\t\t\t\t struct kernel_long_ad[EXTENT_MERGE_SIZE], int *);",
            "static void udf_merge_extents(struct inode *,\n\t\t\t      struct kernel_long_ad[EXTENT_MERGE_SIZE], int *);",
            "static void udf_update_extents(struct inode *,\n\t\t\t       struct kernel_long_ad[EXTENT_MERGE_SIZE], int, int,\n\t\t\t       struct extent_position *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/crc-itu-t.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include \"udfdecl.h\"\n\n#define EXTENT_MERGE_SIZE 5\n\nstatic int udf_update_inode(struct inode *, int);\nstatic int udf_sync_inode(struct inode *inode);\nstatic sector_t inode_getblk(struct inode *, sector_t, int *, int *);\nstatic int8_t udf_insert_aext(struct inode *, struct extent_position,\n\t\t\t      struct kernel_lb_addr, uint32_t);\nstatic void udf_split_extents(struct inode *, int *, int, int,\n\t\t\t      struct kernel_long_ad[EXTENT_MERGE_SIZE], int *);\nstatic void udf_prealloc_extents(struct inode *, int, int,\n\t\t\t\t struct kernel_long_ad[EXTENT_MERGE_SIZE], int *);\nstatic void udf_merge_extents(struct inode *,\n\t\t\t      struct kernel_long_ad[EXTENT_MERGE_SIZE], int *);\nstatic void udf_update_extents(struct inode *,\n\t\t\t       struct kernel_long_ad[EXTENT_MERGE_SIZE], int, int,\n\t\t\t       struct extent_position *);\n\nstatic sector_t inode_getblk(struct inode *inode, sector_t block,\n\t\t\t     int *err, int *new)\n{\n\tstruct kernel_long_ad laarr[EXTENT_MERGE_SIZE];\n\tstruct extent_position prev_epos, cur_epos, next_epos;\n\tint count = 0, startnum = 0, endnum = 0;\n\tuint32_t elen = 0, tmpelen;\n\tstruct kernel_lb_addr eloc, tmpeloc;\n\tint c = 1;\n\tloff_t lbcount = 0, b_off = 0;\n\tuint32_t newblocknum, newblock;\n\tsector_t offset = 0;\n\tint8_t etype;\n\tstruct udf_inode_info *iinfo = UDF_I(inode);\n\tint goal = 0, pgoal = iinfo->i_location.logicalBlockNum;\n\tint lastblock = 0;\n\tbool isBeyondEOF;\n\n\t*err = 0;\n\t*new = 0;\n\tprev_epos.offset = udf_file_entry_alloc_offset(inode);\n\tprev_epos.block = iinfo->i_location;\n\tprev_epos.bh = NULL;\n\tcur_epos = next_epos = prev_epos;\n\tb_off = (loff_t)block << inode->i_sb->s_blocksize_bits;\n\n\t/* find the extent which contains the block we are looking for.\n\t   alternate between laarr[0] and laarr[1] for locations of the\n\t   current extent, and the previous extent */\n\tdo {\n\t\tif (prev_epos.bh != cur_epos.bh) {\n\t\t\tbrelse(prev_epos.bh);\n\t\t\tget_bh(cur_epos.bh);\n\t\t\tprev_epos.bh = cur_epos.bh;\n\t\t}\n\t\tif (cur_epos.bh != next_epos.bh) {\n\t\t\tbrelse(cur_epos.bh);\n\t\t\tget_bh(next_epos.bh);\n\t\t\tcur_epos.bh = next_epos.bh;\n\t\t}\n\n\t\tlbcount += elen;\n\n\t\tprev_epos.block = cur_epos.block;\n\t\tcur_epos.block = next_epos.block;\n\n\t\tprev_epos.offset = cur_epos.offset;\n\t\tcur_epos.offset = next_epos.offset;\n\n\t\tetype = udf_next_aext(inode, &next_epos, &eloc, &elen, 1);\n\t\tif (etype == -1)\n\t\t\tbreak;\n\n\t\tc = !c;\n\n\t\tlaarr[c].extLength = (etype << 30) | elen;\n\t\tlaarr[c].extLocation = eloc;\n\n\t\tif (etype != (EXT_NOT_RECORDED_NOT_ALLOCATED >> 30))\n\t\t\tpgoal = eloc.logicalBlockNum +\n\t\t\t\t((elen + inode->i_sb->s_blocksize - 1) >>\n\t\t\t\t inode->i_sb->s_blocksize_bits);\n\n\t\tcount++;\n\t} while (lbcount + elen <= b_off);\n\n\tb_off -= lbcount;\n\toffset = b_off >> inode->i_sb->s_blocksize_bits;\n\t/*\n\t * Move prev_epos and cur_epos into indirect extent if we are at\n\t * the pointer to it\n\t */\n\tudf_next_aext(inode, &prev_epos, &tmpeloc, &tmpelen, 0);\n\tudf_next_aext(inode, &cur_epos, &tmpeloc, &tmpelen, 0);\n\n\t/* if the extent is allocated and recorded, return the block\n\t   if the extent is not a multiple of the blocksize, round up */\n\n\tif (etype == (EXT_RECORDED_ALLOCATED >> 30)) {\n\t\tif (elen & (inode->i_sb->s_blocksize - 1)) {\n\t\t\telen = EXT_RECORDED_ALLOCATED |\n\t\t\t\t((elen + inode->i_sb->s_blocksize - 1) &\n\t\t\t\t ~(inode->i_sb->s_blocksize - 1));\n\t\t\tudf_write_aext(inode, &cur_epos, &eloc, elen, 1);\n\t\t}\n\t\tbrelse(prev_epos.bh);\n\t\tbrelse(cur_epos.bh);\n\t\tbrelse(next_epos.bh);\n\t\tnewblock = udf_get_lb_pblock(inode->i_sb, &eloc, offset);\n\t\treturn newblock;\n\t}\n\n\t/* Are we beyond EOF? */\n\tif (etype == -1) {\n\t\tint ret;\n\t\tisBeyondEOF = true;\n\t\tif (count) {\n\t\t\tif (c)\n\t\t\t\tlaarr[0] = laarr[1];\n\t\t\tstartnum = 1;\n\t\t} else {\n\t\t\t/* Create a fake extent when there's not one */\n\t\t\tmemset(&laarr[0].extLocation, 0x00,\n\t\t\t\tsizeof(struct kernel_lb_addr));\n\t\t\tlaarr[0].extLength = EXT_NOT_RECORDED_NOT_ALLOCATED;\n\t\t\t/* Will udf_do_extend_file() create real extent from\n\t\t\t   a fake one? */\n\t\t\tstartnum = (offset > 0);\n\t\t}\n\t\t/* Create extents for the hole between EOF and offset */\n\t\tret = udf_do_extend_file(inode, &prev_epos, laarr, offset);\n\t\tif (ret < 0) {\n\t\t\tbrelse(prev_epos.bh);\n\t\t\tbrelse(cur_epos.bh);\n\t\t\tbrelse(next_epos.bh);\n\t\t\t*err = ret;\n\t\t\treturn 0;\n\t\t}\n\t\tc = 0;\n\t\toffset = 0;\n\t\tcount += ret;\n\t\t/* We are not covered by a preallocated extent? */\n\t\tif ((laarr[0].extLength & UDF_EXTENT_FLAG_MASK) !=\n\t\t\t\t\t\tEXT_NOT_RECORDED_ALLOCATED) {\n\t\t\t/* Is there any real extent? - otherwise we overwrite\n\t\t\t * the fake one... */\n\t\t\tif (count)\n\t\t\t\tc = !c;\n\t\t\tlaarr[c].extLength = EXT_NOT_RECORDED_NOT_ALLOCATED |\n\t\t\t\tinode->i_sb->s_blocksize;\n\t\t\tmemset(&laarr[c].extLocation, 0x00,\n\t\t\t\tsizeof(struct kernel_lb_addr));\n\t\t\tcount++;\n\t\t}\n\t\tendnum = c + 1;\n\t\tlastblock = 1;\n\t} else {\n\t\tisBeyondEOF = false;\n\t\tendnum = startnum = ((count > 2) ? 2 : count);\n\n\t\t/* if the current extent is in position 0,\n\t\t   swap it with the previous */\n\t\tif (!c && count != 1) {\n\t\t\tlaarr[2] = laarr[0];\n\t\t\tlaarr[0] = laarr[1];\n\t\t\tlaarr[1] = laarr[2];\n\t\t\tc = 1;\n\t\t}\n\n\t\t/* if the current block is located in an extent,\n\t\t   read the next extent */\n\t\tetype = udf_next_aext(inode, &next_epos, &eloc, &elen, 0);\n\t\tif (etype != -1) {\n\t\t\tlaarr[c + 1].extLength = (etype << 30) | elen;\n\t\t\tlaarr[c + 1].extLocation = eloc;\n\t\t\tcount++;\n\t\t\tstartnum++;\n\t\t\tendnum++;\n\t\t} else\n\t\t\tlastblock = 1;\n\t}\n\n\t/* if the current extent is not recorded but allocated, get the\n\t * block in the extent corresponding to the requested block */\n\tif ((laarr[c].extLength >> 30) == (EXT_NOT_RECORDED_ALLOCATED >> 30))\n\t\tnewblocknum = laarr[c].extLocation.logicalBlockNum + offset;\n\telse { /* otherwise, allocate a new block */\n\t\tif (iinfo->i_next_alloc_block == block)\n\t\t\tgoal = iinfo->i_next_alloc_goal;\n\n\t\tif (!goal) {\n\t\t\tif (!(goal = pgoal)) /* XXX: what was intended here? */\n\t\t\t\tgoal = iinfo->i_location.logicalBlockNum + 1;\n\t\t}\n\n\t\tnewblocknum = udf_new_block(inode->i_sb, inode,\n\t\t\t\tiinfo->i_location.partitionReferenceNum,\n\t\t\t\tgoal, err);\n\t\tif (!newblocknum) {\n\t\t\tbrelse(prev_epos.bh);\n\t\t\tbrelse(cur_epos.bh);\n\t\t\tbrelse(next_epos.bh);\n\t\t\t*err = -ENOSPC;\n\t\t\treturn 0;\n\t\t}\n\t\tif (isBeyondEOF)\n\t\t\tiinfo->i_lenExtents += inode->i_sb->s_blocksize;\n\t}\n\n\t/* if the extent the requsted block is located in contains multiple\n\t * blocks, split the extent into at most three extents. blocks prior\n\t * to requested block, requested block, and blocks after requested\n\t * block */\n\tudf_split_extents(inode, &c, offset, newblocknum, laarr, &endnum);\n\n#ifdef UDF_PREALLOCATE\n\t/* We preallocate blocks only for regular files. It also makes sense\n\t * for directories but there's a problem when to drop the\n\t * preallocation. We might use some delayed work for that but I feel\n\t * it's overengineering for a filesystem like UDF. */\n\tif (S_ISREG(inode->i_mode))\n\t\tudf_prealloc_extents(inode, c, lastblock, laarr, &endnum);\n#endif\n\n\t/* merge any continuous blocks in laarr */\n\tudf_merge_extents(inode, laarr, &endnum);\n\n\t/* write back the new extents, inserting new extents if the new number\n\t * of extents is greater than the old number, and deleting extents if\n\t * the new number of extents is less than the old number */\n\tudf_update_extents(inode, laarr, startnum, endnum, &prev_epos);\n\n\tbrelse(prev_epos.bh);\n\tbrelse(cur_epos.bh);\n\tbrelse(next_epos.bh);\n\n\tnewblock = udf_get_pblock(inode->i_sb, newblocknum,\n\t\t\t\tiinfo->i_location.partitionReferenceNum, 0);\n\tif (!newblock) {\n\t\t*err = -EIO;\n\t\treturn 0;\n\t}\n\t*new = 1;\n\tiinfo->i_next_alloc_block = block;\n\tiinfo->i_next_alloc_goal = newblocknum;\n\tinode->i_ctime = current_fs_time(inode->i_sb);\n\n\tif (IS_SYNC(inode))\n\t\tudf_sync_inode(inode);\n\telse\n\t\tmark_inode_dirty(inode);\n\n\treturn newblock;\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_clear_extent_cache",
          "args": [
            "inode"
          ],
          "line": 446
        },
        "resolved": true,
        "details": {
          "function_name": "udf_clear_extent_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/inode.c",
          "lines": "81-88",
          "snippet": "static void udf_clear_extent_cache(struct inode *inode)\n{\n\tstruct udf_inode_info *iinfo = UDF_I(inode);\n\n\tspin_lock(&iinfo->i_extent_cache_lock);\n\t__udf_clear_extent_cache(inode);\n\tspin_unlock(&iinfo->i_extent_cache_lock);\n}",
          "includes": [
            "#include \"udf_sb.h\"",
            "#include \"udf_i.h\"",
            "#include <linux/aio.h>",
            "#include <linux/mpage.h>",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int udf_update_inode(struct inode *, int);",
            "static int udf_sync_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/crc-itu-t.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include \"udfdecl.h\"\n\nstatic int udf_update_inode(struct inode *, int);\nstatic int udf_sync_inode(struct inode *inode);\n\nstatic void udf_clear_extent_cache(struct inode *inode)\n{\n\tstruct udf_inode_info *iinfo = UDF_I(inode);\n\n\tspin_lock(&iinfo->i_extent_cache_lock);\n\t__udf_clear_extent_cache(inode);\n\tspin_unlock(&iinfo->i_extent_cache_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&iinfo->i_data_sem"
          ],
          "line": 440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UDF_I",
          "args": [
            "inode"
          ],
          "line": 438
        },
        "resolved": true,
        "details": {
          "function_name": "UDF_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/udf_i.h",
          "lines": "57-60",
          "snippet": "static inline struct udf_inode_info *UDF_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct udf_inode_info, vfs_inode);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline struct udf_inode_info *UDF_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct udf_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "map_bh",
          "args": [
            "bh_result",
            "inode->i_sb",
            "phys"
          ],
          "line": 432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udf_block_map",
          "args": [
            "inode",
            "block"
          ],
          "line": 430
        },
        "resolved": true,
        "details": {
          "function_name": "udf_block_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/inode.c",
          "lines": "2270-2293",
          "snippet": "long udf_block_map(struct inode *inode, sector_t block)\n{\n\tstruct kernel_lb_addr eloc;\n\tuint32_t elen;\n\tsector_t offset;\n\tstruct extent_position epos = {};\n\tint ret;\n\n\tdown_read(&UDF_I(inode)->i_data_sem);\n\n\tif (inode_bmap(inode, block, &epos, &eloc, &elen, &offset) ==\n\t\t\t\t\t\t(EXT_RECORDED_ALLOCATED >> 30))\n\t\tret = udf_get_lb_pblock(inode->i_sb, &eloc, offset);\n\telse\n\t\tret = 0;\n\n\tup_read(&UDF_I(inode)->i_data_sem);\n\tbrelse(epos.bh);\n\n\tif (UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_VARCONV))\n\t\treturn udf_fixed_to_variable(ret);\n\telse\n\t\treturn ret;\n}",
          "includes": [
            "#include \"udf_sb.h\"",
            "#include \"udf_i.h\"",
            "#include <linux/aio.h>",
            "#include <linux/mpage.h>",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int udf_update_inode(struct inode *, int);",
            "static int udf_sync_inode(struct inode *inode);",
            "static sector_t inode_getblk(struct inode *, sector_t, int *, int *);",
            "static int8_t udf_insert_aext(struct inode *, struct extent_position,\n\t\t\t      struct kernel_lb_addr, uint32_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/crc-itu-t.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include \"udfdecl.h\"\n\nstatic int udf_update_inode(struct inode *, int);\nstatic int udf_sync_inode(struct inode *inode);\nstatic sector_t inode_getblk(struct inode *, sector_t, int *, int *);\nstatic int8_t udf_insert_aext(struct inode *, struct extent_position,\n\t\t\t      struct kernel_lb_addr, uint32_t);\n\nlong udf_block_map(struct inode *inode, sector_t block)\n{\n\tstruct kernel_lb_addr eloc;\n\tuint32_t elen;\n\tsector_t offset;\n\tstruct extent_position epos = {};\n\tint ret;\n\n\tdown_read(&UDF_I(inode)->i_data_sem);\n\n\tif (inode_bmap(inode, block, &epos, &eloc, &elen, &offset) ==\n\t\t\t\t\t\t(EXT_RECORDED_ALLOCATED >> 30))\n\t\tret = udf_get_lb_pblock(inode->i_sb, &eloc, offset);\n\telse\n\t\tret = 0;\n\n\tup_read(&UDF_I(inode)->i_data_sem);\n\tbrelse(epos.bh);\n\n\tif (UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_VARCONV))\n\t\treturn udf_fixed_to_variable(ret);\n\telse\n\t\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/crc-itu-t.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include \"udfdecl.h\"\n\nstatic int udf_update_inode(struct inode *, int);\nstatic int udf_sync_inode(struct inode *inode);\nstatic sector_t inode_getblk(struct inode *, sector_t, int *, int *);\nstatic int udf_get_block(struct inode *, sector_t, struct buffer_head *, int);\n\nstatic int udf_get_block(struct inode *inode, sector_t block,\n\t\t\t struct buffer_head *bh_result, int create)\n{\n\tint err, new;\n\tsector_t phys = 0;\n\tstruct udf_inode_info *iinfo;\n\n\tif (!create) {\n\t\tphys = udf_block_map(inode, block);\n\t\tif (phys)\n\t\t\tmap_bh(bh_result, inode->i_sb, phys);\n\t\treturn 0;\n\t}\n\n\terr = -EIO;\n\tnew = 0;\n\tiinfo = UDF_I(inode);\n\n\tdown_write(&iinfo->i_data_sem);\n\tif (block == iinfo->i_next_alloc_block + 1) {\n\t\tiinfo->i_next_alloc_block++;\n\t\tiinfo->i_next_alloc_goal++;\n\t}\n\n\tudf_clear_extent_cache(inode);\n\tphys = inode_getblk(inode, block, &err, &new);\n\tif (!phys)\n\t\tgoto abort;\n\n\tif (new)\n\t\tset_buffer_new(bh_result);\n\tmap_bh(bh_result, inode->i_sb, phys);\n\nabort:\n\tup_write(&iinfo->i_data_sem);\n\treturn err;\n}"
  },
  {
    "function_name": "udf_expand_dir_adinicb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/inode.c",
    "lines": "330-420",
    "snippet": "struct buffer_head *udf_expand_dir_adinicb(struct inode *inode, int *block,\n\t\t\t\t\t   int *err)\n{\n\tint newblock;\n\tstruct buffer_head *dbh = NULL;\n\tstruct kernel_lb_addr eloc;\n\tuint8_t alloctype;\n\tstruct extent_position epos;\n\n\tstruct udf_fileident_bh sfibh, dfibh;\n\tloff_t f_pos = udf_ext0_offset(inode);\n\tint size = udf_ext0_offset(inode) + inode->i_size;\n\tstruct fileIdentDesc cfi, *sfi, *dfi;\n\tstruct udf_inode_info *iinfo = UDF_I(inode);\n\n\tif (UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_USE_SHORT_AD))\n\t\talloctype = ICBTAG_FLAG_AD_SHORT;\n\telse\n\t\talloctype = ICBTAG_FLAG_AD_LONG;\n\n\tif (!inode->i_size) {\n\t\tiinfo->i_alloc_type = alloctype;\n\t\tmark_inode_dirty(inode);\n\t\treturn NULL;\n\t}\n\n\t/* alloc block, and copy data to it */\n\t*block = udf_new_block(inode->i_sb, inode,\n\t\t\t       iinfo->i_location.partitionReferenceNum,\n\t\t\t       iinfo->i_location.logicalBlockNum, err);\n\tif (!(*block))\n\t\treturn NULL;\n\tnewblock = udf_get_pblock(inode->i_sb, *block,\n\t\t\t\t  iinfo->i_location.partitionReferenceNum,\n\t\t\t\t0);\n\tif (!newblock)\n\t\treturn NULL;\n\tdbh = udf_tgetblk(inode->i_sb, newblock);\n\tif (!dbh)\n\t\treturn NULL;\n\tlock_buffer(dbh);\n\tmemset(dbh->b_data, 0x00, inode->i_sb->s_blocksize);\n\tset_buffer_uptodate(dbh);\n\tunlock_buffer(dbh);\n\tmark_buffer_dirty_inode(dbh, inode);\n\n\tsfibh.soffset = sfibh.eoffset =\n\t\t\tf_pos & (inode->i_sb->s_blocksize - 1);\n\tsfibh.sbh = sfibh.ebh = NULL;\n\tdfibh.soffset = dfibh.eoffset = 0;\n\tdfibh.sbh = dfibh.ebh = dbh;\n\twhile (f_pos < size) {\n\t\tiinfo->i_alloc_type = ICBTAG_FLAG_AD_IN_ICB;\n\t\tsfi = udf_fileident_read(inode, &f_pos, &sfibh, &cfi, NULL,\n\t\t\t\t\t NULL, NULL, NULL);\n\t\tif (!sfi) {\n\t\t\tbrelse(dbh);\n\t\t\treturn NULL;\n\t\t}\n\t\tiinfo->i_alloc_type = alloctype;\n\t\tsfi->descTag.tagLocation = cpu_to_le32(*block);\n\t\tdfibh.soffset = dfibh.eoffset;\n\t\tdfibh.eoffset += (sfibh.eoffset - sfibh.soffset);\n\t\tdfi = (struct fileIdentDesc *)(dbh->b_data + dfibh.soffset);\n\t\tif (udf_write_fi(inode, sfi, dfi, &dfibh, sfi->impUse,\n\t\t\t\t sfi->fileIdent +\n\t\t\t\t\tle16_to_cpu(sfi->lengthOfImpUse))) {\n\t\t\tiinfo->i_alloc_type = ICBTAG_FLAG_AD_IN_ICB;\n\t\t\tbrelse(dbh);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\tmark_buffer_dirty_inode(dbh, inode);\n\n\tmemset(iinfo->i_ext.i_data + iinfo->i_lenEAttr, 0,\n\t\tiinfo->i_lenAlloc);\n\tiinfo->i_lenAlloc = 0;\n\teloc.logicalBlockNum = *block;\n\teloc.partitionReferenceNum =\n\t\t\t\tiinfo->i_location.partitionReferenceNum;\n\tiinfo->i_lenExtents = inode->i_size;\n\tepos.bh = NULL;\n\tepos.block = iinfo->i_location;\n\tepos.offset = udf_file_entry_alloc_offset(inode);\n\tudf_add_aext(inode, &epos, &eloc, inode->i_size, 0);\n\t/* UniqueID stuff */\n\n\tbrelse(epos.bh);\n\tmark_inode_dirty(inode);\n\treturn dbh;\n}",
    "includes": [
      "#include \"udf_sb.h\"",
      "#include \"udf_i.h\"",
      "#include <linux/aio.h>",
      "#include <linux/mpage.h>",
      "#include <linux/crc-itu-t.h>",
      "#include <linux/slab.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include \"udfdecl.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int udf_update_inode(struct inode *, int);",
      "static int udf_sync_inode(struct inode *inode);",
      "static int udf_alloc_i_data(struct inode *inode, size_t size);",
      "static int udf_get_block(struct inode *, sector_t, struct buffer_head *, int);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mark_inode_dirty",
          "args": [
            "inode"
          ],
          "line": 418
        },
        "resolved": true,
        "details": {
          "function_name": "block_dump___mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1134-1154",
          "snippet": "static noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "epos.bh"
          ],
          "line": 417
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_add_aext",
          "args": [
            "inode",
            "&epos",
            "&eloc",
            "inode->i_size",
            "0"
          ],
          "line": 414
        },
        "resolved": true,
        "details": {
          "function_name": "udf_add_aext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/inode.c",
          "lines": "1876-2003",
          "snippet": "int udf_add_aext(struct inode *inode, struct extent_position *epos,\n\t\t struct kernel_lb_addr *eloc, uint32_t elen, int inc)\n{\n\tint adsize;\n\tstruct short_ad *sad = NULL;\n\tstruct long_ad *lad = NULL;\n\tstruct allocExtDesc *aed;\n\tuint8_t *ptr;\n\tstruct udf_inode_info *iinfo = UDF_I(inode);\n\n\tif (!epos->bh)\n\t\tptr = iinfo->i_ext.i_data + epos->offset -\n\t\t\tudf_file_entry_alloc_offset(inode) +\n\t\t\tiinfo->i_lenEAttr;\n\telse\n\t\tptr = epos->bh->b_data + epos->offset;\n\n\tif (iinfo->i_alloc_type == ICBTAG_FLAG_AD_SHORT)\n\t\tadsize = sizeof(struct short_ad);\n\telse if (iinfo->i_alloc_type == ICBTAG_FLAG_AD_LONG)\n\t\tadsize = sizeof(struct long_ad);\n\telse\n\t\treturn -EIO;\n\n\tif (epos->offset + (2 * adsize) > inode->i_sb->s_blocksize) {\n\t\tunsigned char *sptr, *dptr;\n\t\tstruct buffer_head *nbh;\n\t\tint err, loffset;\n\t\tstruct kernel_lb_addr obloc = epos->block;\n\n\t\tepos->block.logicalBlockNum = udf_new_block(inode->i_sb, NULL,\n\t\t\t\t\t\tobloc.partitionReferenceNum,\n\t\t\t\t\t\tobloc.logicalBlockNum, &err);\n\t\tif (!epos->block.logicalBlockNum)\n\t\t\treturn -ENOSPC;\n\t\tnbh = udf_tgetblk(inode->i_sb, udf_get_lb_pblock(inode->i_sb,\n\t\t\t\t\t\t\t\t &epos->block,\n\t\t\t\t\t\t\t\t 0));\n\t\tif (!nbh)\n\t\t\treturn -EIO;\n\t\tlock_buffer(nbh);\n\t\tmemset(nbh->b_data, 0x00, inode->i_sb->s_blocksize);\n\t\tset_buffer_uptodate(nbh);\n\t\tunlock_buffer(nbh);\n\t\tmark_buffer_dirty_inode(nbh, inode);\n\n\t\taed = (struct allocExtDesc *)(nbh->b_data);\n\t\tif (!UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_STRICT))\n\t\t\taed->previousAllocExtLocation =\n\t\t\t\t\tcpu_to_le32(obloc.logicalBlockNum);\n\t\tif (epos->offset + adsize > inode->i_sb->s_blocksize) {\n\t\t\tloffset = epos->offset;\n\t\t\taed->lengthAllocDescs = cpu_to_le32(adsize);\n\t\t\tsptr = ptr - adsize;\n\t\t\tdptr = nbh->b_data + sizeof(struct allocExtDesc);\n\t\t\tmemcpy(dptr, sptr, adsize);\n\t\t\tepos->offset = sizeof(struct allocExtDesc) + adsize;\n\t\t} else {\n\t\t\tloffset = epos->offset + adsize;\n\t\t\taed->lengthAllocDescs = cpu_to_le32(0);\n\t\t\tsptr = ptr;\n\t\t\tepos->offset = sizeof(struct allocExtDesc);\n\n\t\t\tif (epos->bh) {\n\t\t\t\taed = (struct allocExtDesc *)epos->bh->b_data;\n\t\t\t\tle32_add_cpu(&aed->lengthAllocDescs, adsize);\n\t\t\t} else {\n\t\t\t\tiinfo->i_lenAlloc += adsize;\n\t\t\t\tmark_inode_dirty(inode);\n\t\t\t}\n\t\t}\n\t\tif (UDF_SB(inode->i_sb)->s_udfrev >= 0x0200)\n\t\t\tudf_new_tag(nbh->b_data, TAG_IDENT_AED, 3, 1,\n\t\t\t\t    epos->block.logicalBlockNum, sizeof(struct tag));\n\t\telse\n\t\t\tudf_new_tag(nbh->b_data, TAG_IDENT_AED, 2, 1,\n\t\t\t\t    epos->block.logicalBlockNum, sizeof(struct tag));\n\t\tswitch (iinfo->i_alloc_type) {\n\t\tcase ICBTAG_FLAG_AD_SHORT:\n\t\t\tsad = (struct short_ad *)sptr;\n\t\t\tsad->extLength = cpu_to_le32(EXT_NEXT_EXTENT_ALLOCDECS |\n\t\t\t\t\t\t     inode->i_sb->s_blocksize);\n\t\t\tsad->extPosition =\n\t\t\t\tcpu_to_le32(epos->block.logicalBlockNum);\n\t\t\tbreak;\n\t\tcase ICBTAG_FLAG_AD_LONG:\n\t\t\tlad = (struct long_ad *)sptr;\n\t\t\tlad->extLength = cpu_to_le32(EXT_NEXT_EXTENT_ALLOCDECS |\n\t\t\t\t\t\t     inode->i_sb->s_blocksize);\n\t\t\tlad->extLocation = cpu_to_lelb(epos->block);\n\t\t\tmemset(lad->impUse, 0x00, sizeof(lad->impUse));\n\t\t\tbreak;\n\t\t}\n\t\tif (epos->bh) {\n\t\t\tif (!UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_STRICT) ||\n\t\t\t    UDF_SB(inode->i_sb)->s_udfrev >= 0x0201)\n\t\t\t\tudf_update_tag(epos->bh->b_data, loffset);\n\t\t\telse\n\t\t\t\tudf_update_tag(epos->bh->b_data,\n\t\t\t\t\t\tsizeof(struct allocExtDesc));\n\t\t\tmark_buffer_dirty_inode(epos->bh, inode);\n\t\t\tbrelse(epos->bh);\n\t\t} else {\n\t\t\tmark_inode_dirty(inode);\n\t\t}\n\t\tepos->bh = nbh;\n\t}\n\n\tudf_write_aext(inode, epos, eloc, elen, inc);\n\n\tif (!epos->bh) {\n\t\tiinfo->i_lenAlloc += adsize;\n\t\tmark_inode_dirty(inode);\n\t} else {\n\t\taed = (struct allocExtDesc *)epos->bh->b_data;\n\t\tle32_add_cpu(&aed->lengthAllocDescs, adsize);\n\t\tif (!UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_STRICT) ||\n\t\t\t\tUDF_SB(inode->i_sb)->s_udfrev >= 0x0201)\n\t\t\tudf_update_tag(epos->bh->b_data,\n\t\t\t\t\tepos->offset + (inc ? 0 : adsize));\n\t\telse\n\t\t\tudf_update_tag(epos->bh->b_data,\n\t\t\t\t\tsizeof(struct allocExtDesc));\n\t\tmark_buffer_dirty_inode(epos->bh, inode);\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"udf_sb.h\"",
            "#include \"udf_i.h\"",
            "#include <linux/aio.h>",
            "#include <linux/mpage.h>",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int udf_update_inode(struct inode *, int);",
            "static int udf_sync_inode(struct inode *inode);",
            "static int8_t udf_insert_aext(struct inode *, struct extent_position,\n\t\t\t      struct kernel_lb_addr, uint32_t);",
            "static int udf_get_block(struct inode *, sector_t, struct buffer_head *, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/crc-itu-t.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include \"udfdecl.h\"\n\nstatic int udf_update_inode(struct inode *, int);\nstatic int udf_sync_inode(struct inode *inode);\nstatic int8_t udf_insert_aext(struct inode *, struct extent_position,\n\t\t\t      struct kernel_lb_addr, uint32_t);\nstatic int udf_get_block(struct inode *, sector_t, struct buffer_head *, int);\n\nint udf_add_aext(struct inode *inode, struct extent_position *epos,\n\t\t struct kernel_lb_addr *eloc, uint32_t elen, int inc)\n{\n\tint adsize;\n\tstruct short_ad *sad = NULL;\n\tstruct long_ad *lad = NULL;\n\tstruct allocExtDesc *aed;\n\tuint8_t *ptr;\n\tstruct udf_inode_info *iinfo = UDF_I(inode);\n\n\tif (!epos->bh)\n\t\tptr = iinfo->i_ext.i_data + epos->offset -\n\t\t\tudf_file_entry_alloc_offset(inode) +\n\t\t\tiinfo->i_lenEAttr;\n\telse\n\t\tptr = epos->bh->b_data + epos->offset;\n\n\tif (iinfo->i_alloc_type == ICBTAG_FLAG_AD_SHORT)\n\t\tadsize = sizeof(struct short_ad);\n\telse if (iinfo->i_alloc_type == ICBTAG_FLAG_AD_LONG)\n\t\tadsize = sizeof(struct long_ad);\n\telse\n\t\treturn -EIO;\n\n\tif (epos->offset + (2 * adsize) > inode->i_sb->s_blocksize) {\n\t\tunsigned char *sptr, *dptr;\n\t\tstruct buffer_head *nbh;\n\t\tint err, loffset;\n\t\tstruct kernel_lb_addr obloc = epos->block;\n\n\t\tepos->block.logicalBlockNum = udf_new_block(inode->i_sb, NULL,\n\t\t\t\t\t\tobloc.partitionReferenceNum,\n\t\t\t\t\t\tobloc.logicalBlockNum, &err);\n\t\tif (!epos->block.logicalBlockNum)\n\t\t\treturn -ENOSPC;\n\t\tnbh = udf_tgetblk(inode->i_sb, udf_get_lb_pblock(inode->i_sb,\n\t\t\t\t\t\t\t\t &epos->block,\n\t\t\t\t\t\t\t\t 0));\n\t\tif (!nbh)\n\t\t\treturn -EIO;\n\t\tlock_buffer(nbh);\n\t\tmemset(nbh->b_data, 0x00, inode->i_sb->s_blocksize);\n\t\tset_buffer_uptodate(nbh);\n\t\tunlock_buffer(nbh);\n\t\tmark_buffer_dirty_inode(nbh, inode);\n\n\t\taed = (struct allocExtDesc *)(nbh->b_data);\n\t\tif (!UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_STRICT))\n\t\t\taed->previousAllocExtLocation =\n\t\t\t\t\tcpu_to_le32(obloc.logicalBlockNum);\n\t\tif (epos->offset + adsize > inode->i_sb->s_blocksize) {\n\t\t\tloffset = epos->offset;\n\t\t\taed->lengthAllocDescs = cpu_to_le32(adsize);\n\t\t\tsptr = ptr - adsize;\n\t\t\tdptr = nbh->b_data + sizeof(struct allocExtDesc);\n\t\t\tmemcpy(dptr, sptr, adsize);\n\t\t\tepos->offset = sizeof(struct allocExtDesc) + adsize;\n\t\t} else {\n\t\t\tloffset = epos->offset + adsize;\n\t\t\taed->lengthAllocDescs = cpu_to_le32(0);\n\t\t\tsptr = ptr;\n\t\t\tepos->offset = sizeof(struct allocExtDesc);\n\n\t\t\tif (epos->bh) {\n\t\t\t\taed = (struct allocExtDesc *)epos->bh->b_data;\n\t\t\t\tle32_add_cpu(&aed->lengthAllocDescs, adsize);\n\t\t\t} else {\n\t\t\t\tiinfo->i_lenAlloc += adsize;\n\t\t\t\tmark_inode_dirty(inode);\n\t\t\t}\n\t\t}\n\t\tif (UDF_SB(inode->i_sb)->s_udfrev >= 0x0200)\n\t\t\tudf_new_tag(nbh->b_data, TAG_IDENT_AED, 3, 1,\n\t\t\t\t    epos->block.logicalBlockNum, sizeof(struct tag));\n\t\telse\n\t\t\tudf_new_tag(nbh->b_data, TAG_IDENT_AED, 2, 1,\n\t\t\t\t    epos->block.logicalBlockNum, sizeof(struct tag));\n\t\tswitch (iinfo->i_alloc_type) {\n\t\tcase ICBTAG_FLAG_AD_SHORT:\n\t\t\tsad = (struct short_ad *)sptr;\n\t\t\tsad->extLength = cpu_to_le32(EXT_NEXT_EXTENT_ALLOCDECS |\n\t\t\t\t\t\t     inode->i_sb->s_blocksize);\n\t\t\tsad->extPosition =\n\t\t\t\tcpu_to_le32(epos->block.logicalBlockNum);\n\t\t\tbreak;\n\t\tcase ICBTAG_FLAG_AD_LONG:\n\t\t\tlad = (struct long_ad *)sptr;\n\t\t\tlad->extLength = cpu_to_le32(EXT_NEXT_EXTENT_ALLOCDECS |\n\t\t\t\t\t\t     inode->i_sb->s_blocksize);\n\t\t\tlad->extLocation = cpu_to_lelb(epos->block);\n\t\t\tmemset(lad->impUse, 0x00, sizeof(lad->impUse));\n\t\t\tbreak;\n\t\t}\n\t\tif (epos->bh) {\n\t\t\tif (!UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_STRICT) ||\n\t\t\t    UDF_SB(inode->i_sb)->s_udfrev >= 0x0201)\n\t\t\t\tudf_update_tag(epos->bh->b_data, loffset);\n\t\t\telse\n\t\t\t\tudf_update_tag(epos->bh->b_data,\n\t\t\t\t\t\tsizeof(struct allocExtDesc));\n\t\t\tmark_buffer_dirty_inode(epos->bh, inode);\n\t\t\tbrelse(epos->bh);\n\t\t} else {\n\t\t\tmark_inode_dirty(inode);\n\t\t}\n\t\tepos->bh = nbh;\n\t}\n\n\tudf_write_aext(inode, epos, eloc, elen, inc);\n\n\tif (!epos->bh) {\n\t\tiinfo->i_lenAlloc += adsize;\n\t\tmark_inode_dirty(inode);\n\t} else {\n\t\taed = (struct allocExtDesc *)epos->bh->b_data;\n\t\tle32_add_cpu(&aed->lengthAllocDescs, adsize);\n\t\tif (!UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_STRICT) ||\n\t\t\t\tUDF_SB(inode->i_sb)->s_udfrev >= 0x0201)\n\t\t\tudf_update_tag(epos->bh->b_data,\n\t\t\t\t\tepos->offset + (inc ? 0 : adsize));\n\t\telse\n\t\t\tudf_update_tag(epos->bh->b_data,\n\t\t\t\t\tsizeof(struct allocExtDesc));\n\t\tmark_buffer_dirty_inode(epos->bh, inode);\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_file_entry_alloc_offset",
          "args": [
            "inode"
          ],
          "line": 413
        },
        "resolved": true,
        "details": {
          "function_name": "udf_file_entry_alloc_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/udfdecl.h",
          "lines": "55-64",
          "snippet": "static inline size_t udf_file_entry_alloc_offset(struct inode *inode)\n{\n\tstruct udf_inode_info *iinfo = UDF_I(inode);\n\tif (iinfo->i_use)\n\t\treturn sizeof(struct unallocSpaceEntry);\n\telse if (iinfo->i_efe)\n\t\treturn sizeof(struct extendedFileEntry) + iinfo->i_lenEAttr;\n\telse\n\t\treturn sizeof(struct fileEntry) + iinfo->i_lenEAttr;\n}",
          "includes": [
            "#include \"udf_i.h\"",
            "#include \"udfend.h\"",
            "#include \"udf_sb.h\"",
            "#include <linux/udf_fs_i.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include \"osta_udf.h\"",
            "#include \"ecma_167.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_i.h\"\n#include \"udfend.h\"\n#include \"udf_sb.h\"\n#include <linux/udf_fs_i.h>\n#include <linux/buffer_head.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include \"osta_udf.h\"\n#include \"ecma_167.h\"\n\nstatic inline size_t udf_file_entry_alloc_offset(struct inode *inode)\n{\n\tstruct udf_inode_info *iinfo = UDF_I(inode);\n\tif (iinfo->i_use)\n\t\treturn sizeof(struct unallocSpaceEntry);\n\telse if (iinfo->i_efe)\n\t\treturn sizeof(struct extendedFileEntry) + iinfo->i_lenEAttr;\n\telse\n\t\treturn sizeof(struct fileEntry) + iinfo->i_lenEAttr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "iinfo->i_ext.i_data + iinfo->i_lenEAttr",
            "0",
            "iinfo->i_lenAlloc"
          ],
          "line": 404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mark_buffer_dirty_inode",
          "args": [
            "dbh",
            "inode"
          ],
          "line": 402
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_dirty_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "599-617",
          "snippet": "void mark_buffer_dirty_inode(struct buffer_head *bh, struct inode *inode)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tstruct address_space *buffer_mapping = bh->b_page->mapping;\n\n\tmark_buffer_dirty(bh);\n\tif (!mapping->private_data) {\n\t\tmapping->private_data = buffer_mapping;\n\t} else {\n\t\tBUG_ON(mapping->private_data != buffer_mapping);\n\t}\n\tif (!bh->b_assoc_map) {\n\t\tspin_lock(&buffer_mapping->private_lock);\n\t\tlist_move_tail(&bh->b_assoc_buffers,\n\t\t\t\t&mapping->private_list);\n\t\tbh->b_assoc_map = mapping;\n\t\tspin_unlock(&buffer_mapping->private_lock);\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_dirty_inode(struct buffer_head *bh, struct inode *inode)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tstruct address_space *buffer_mapping = bh->b_page->mapping;\n\n\tmark_buffer_dirty(bh);\n\tif (!mapping->private_data) {\n\t\tmapping->private_data = buffer_mapping;\n\t} else {\n\t\tBUG_ON(mapping->private_data != buffer_mapping);\n\t}\n\tif (!bh->b_assoc_map) {\n\t\tspin_lock(&buffer_mapping->private_lock);\n\t\tlist_move_tail(&bh->b_assoc_buffers,\n\t\t\t\t&mapping->private_list);\n\t\tbh->b_assoc_map = mapping;\n\t\tspin_unlock(&buffer_mapping->private_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_write_fi",
          "args": [
            "inode",
            "sfi",
            "dfi",
            "&dfibh",
            "sfi->impUse",
            "sfi->fileIdent +\n\t\t\t\t\tle16_to_cpu(sfi->lengthOfImpUse)"
          ],
          "line": 394
        },
        "resolved": true,
        "details": {
          "function_name": "udf_write_fi",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/namei.c",
          "lines": "44-140",
          "snippet": "int udf_write_fi(struct inode *inode, struct fileIdentDesc *cfi,\n\t\t struct fileIdentDesc *sfi, struct udf_fileident_bh *fibh,\n\t\t uint8_t *impuse, uint8_t *fileident)\n{\n\tuint16_t crclen = fibh->eoffset - fibh->soffset - sizeof(struct tag);\n\tuint16_t crc;\n\tint offset;\n\tuint16_t liu = le16_to_cpu(cfi->lengthOfImpUse);\n\tuint8_t lfi = cfi->lengthFileIdent;\n\tint padlen = fibh->eoffset - fibh->soffset - liu - lfi -\n\t\tsizeof(struct fileIdentDesc);\n\tint adinicb = 0;\n\n\tif (UDF_I(inode)->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB)\n\t\tadinicb = 1;\n\n\toffset = fibh->soffset + sizeof(struct fileIdentDesc);\n\n\tif (impuse) {\n\t\tif (adinicb || (offset + liu < 0)) {\n\t\t\tmemcpy((uint8_t *)sfi->impUse, impuse, liu);\n\t\t} else if (offset >= 0) {\n\t\t\tmemcpy(fibh->ebh->b_data + offset, impuse, liu);\n\t\t} else {\n\t\t\tmemcpy((uint8_t *)sfi->impUse, impuse, -offset);\n\t\t\tmemcpy(fibh->ebh->b_data, impuse - offset,\n\t\t\t\tliu + offset);\n\t\t}\n\t}\n\n\toffset += liu;\n\n\tif (fileident) {\n\t\tif (adinicb || (offset + lfi < 0)) {\n\t\t\tmemcpy((uint8_t *)sfi->fileIdent + liu, fileident, lfi);\n\t\t} else if (offset >= 0) {\n\t\t\tmemcpy(fibh->ebh->b_data + offset, fileident, lfi);\n\t\t} else {\n\t\t\tmemcpy((uint8_t *)sfi->fileIdent + liu, fileident,\n\t\t\t\t-offset);\n\t\t\tmemcpy(fibh->ebh->b_data, fileident - offset,\n\t\t\t\tlfi + offset);\n\t\t}\n\t}\n\n\toffset += lfi;\n\n\tif (adinicb || (offset + padlen < 0)) {\n\t\tmemset((uint8_t *)sfi->padding + liu + lfi, 0x00, padlen);\n\t} else if (offset >= 0) {\n\t\tmemset(fibh->ebh->b_data + offset, 0x00, padlen);\n\t} else {\n\t\tmemset((uint8_t *)sfi->padding + liu + lfi, 0x00, -offset);\n\t\tmemset(fibh->ebh->b_data, 0x00, padlen + offset);\n\t}\n\n\tcrc = crc_itu_t(0, (uint8_t *)cfi + sizeof(struct tag),\n\t\t      sizeof(struct fileIdentDesc) - sizeof(struct tag));\n\n\tif (fibh->sbh == fibh->ebh) {\n\t\tcrc = crc_itu_t(crc, (uint8_t *)sfi->impUse,\n\t\t\t      crclen + sizeof(struct tag) -\n\t\t\t      sizeof(struct fileIdentDesc));\n\t} else if (sizeof(struct fileIdentDesc) >= -fibh->soffset) {\n\t\tcrc = crc_itu_t(crc, fibh->ebh->b_data +\n\t\t\t\t\tsizeof(struct fileIdentDesc) +\n\t\t\t\t\tfibh->soffset,\n\t\t\t      crclen + sizeof(struct tag) -\n\t\t\t\t\tsizeof(struct fileIdentDesc));\n\t} else {\n\t\tcrc = crc_itu_t(crc, (uint8_t *)sfi->impUse,\n\t\t\t      -fibh->soffset - sizeof(struct fileIdentDesc));\n\t\tcrc = crc_itu_t(crc, fibh->ebh->b_data, fibh->eoffset);\n\t}\n\n\tcfi->descTag.descCRC = cpu_to_le16(crc);\n\tcfi->descTag.descCRCLength = cpu_to_le16(crclen);\n\tcfi->descTag.tagChecksum = udf_tag_checksum(&cfi->descTag);\n\n\tif (adinicb || (sizeof(struct fileIdentDesc) <= -fibh->soffset)) {\n\t\tmemcpy((uint8_t *)sfi, (uint8_t *)cfi,\n\t\t\tsizeof(struct fileIdentDesc));\n\t} else {\n\t\tmemcpy((uint8_t *)sfi, (uint8_t *)cfi, -fibh->soffset);\n\t\tmemcpy(fibh->ebh->b_data, (uint8_t *)cfi - fibh->soffset,\n\t\t       sizeof(struct fileIdentDesc) + fibh->soffset);\n\t}\n\n\tif (adinicb) {\n\t\tmark_inode_dirty(inode);\n\t} else {\n\t\tif (fibh->sbh != fibh->ebh)\n\t\t\tmark_buffer_dirty_inode(fibh->ebh, inode);\n\t\tmark_buffer_dirty_inode(fibh->sbh, inode);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <linux/exportfs.h>",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/sched.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include \"udf_sb.h\"",
            "#include \"udf_i.h\"",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/crc-itu-t.h>\n#include <linux/sched.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include \"udfdecl.h\"\n\nint udf_write_fi(struct inode *inode, struct fileIdentDesc *cfi,\n\t\t struct fileIdentDesc *sfi, struct udf_fileident_bh *fibh,\n\t\t uint8_t *impuse, uint8_t *fileident)\n{\n\tuint16_t crclen = fibh->eoffset - fibh->soffset - sizeof(struct tag);\n\tuint16_t crc;\n\tint offset;\n\tuint16_t liu = le16_to_cpu(cfi->lengthOfImpUse);\n\tuint8_t lfi = cfi->lengthFileIdent;\n\tint padlen = fibh->eoffset - fibh->soffset - liu - lfi -\n\t\tsizeof(struct fileIdentDesc);\n\tint adinicb = 0;\n\n\tif (UDF_I(inode)->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB)\n\t\tadinicb = 1;\n\n\toffset = fibh->soffset + sizeof(struct fileIdentDesc);\n\n\tif (impuse) {\n\t\tif (adinicb || (offset + liu < 0)) {\n\t\t\tmemcpy((uint8_t *)sfi->impUse, impuse, liu);\n\t\t} else if (offset >= 0) {\n\t\t\tmemcpy(fibh->ebh->b_data + offset, impuse, liu);\n\t\t} else {\n\t\t\tmemcpy((uint8_t *)sfi->impUse, impuse, -offset);\n\t\t\tmemcpy(fibh->ebh->b_data, impuse - offset,\n\t\t\t\tliu + offset);\n\t\t}\n\t}\n\n\toffset += liu;\n\n\tif (fileident) {\n\t\tif (adinicb || (offset + lfi < 0)) {\n\t\t\tmemcpy((uint8_t *)sfi->fileIdent + liu, fileident, lfi);\n\t\t} else if (offset >= 0) {\n\t\t\tmemcpy(fibh->ebh->b_data + offset, fileident, lfi);\n\t\t} else {\n\t\t\tmemcpy((uint8_t *)sfi->fileIdent + liu, fileident,\n\t\t\t\t-offset);\n\t\t\tmemcpy(fibh->ebh->b_data, fileident - offset,\n\t\t\t\tlfi + offset);\n\t\t}\n\t}\n\n\toffset += lfi;\n\n\tif (adinicb || (offset + padlen < 0)) {\n\t\tmemset((uint8_t *)sfi->padding + liu + lfi, 0x00, padlen);\n\t} else if (offset >= 0) {\n\t\tmemset(fibh->ebh->b_data + offset, 0x00, padlen);\n\t} else {\n\t\tmemset((uint8_t *)sfi->padding + liu + lfi, 0x00, -offset);\n\t\tmemset(fibh->ebh->b_data, 0x00, padlen + offset);\n\t}\n\n\tcrc = crc_itu_t(0, (uint8_t *)cfi + sizeof(struct tag),\n\t\t      sizeof(struct fileIdentDesc) - sizeof(struct tag));\n\n\tif (fibh->sbh == fibh->ebh) {\n\t\tcrc = crc_itu_t(crc, (uint8_t *)sfi->impUse,\n\t\t\t      crclen + sizeof(struct tag) -\n\t\t\t      sizeof(struct fileIdentDesc));\n\t} else if (sizeof(struct fileIdentDesc) >= -fibh->soffset) {\n\t\tcrc = crc_itu_t(crc, fibh->ebh->b_data +\n\t\t\t\t\tsizeof(struct fileIdentDesc) +\n\t\t\t\t\tfibh->soffset,\n\t\t\t      crclen + sizeof(struct tag) -\n\t\t\t\t\tsizeof(struct fileIdentDesc));\n\t} else {\n\t\tcrc = crc_itu_t(crc, (uint8_t *)sfi->impUse,\n\t\t\t      -fibh->soffset - sizeof(struct fileIdentDesc));\n\t\tcrc = crc_itu_t(crc, fibh->ebh->b_data, fibh->eoffset);\n\t}\n\n\tcfi->descTag.descCRC = cpu_to_le16(crc);\n\tcfi->descTag.descCRCLength = cpu_to_le16(crclen);\n\tcfi->descTag.tagChecksum = udf_tag_checksum(&cfi->descTag);\n\n\tif (adinicb || (sizeof(struct fileIdentDesc) <= -fibh->soffset)) {\n\t\tmemcpy((uint8_t *)sfi, (uint8_t *)cfi,\n\t\t\tsizeof(struct fileIdentDesc));\n\t} else {\n\t\tmemcpy((uint8_t *)sfi, (uint8_t *)cfi, -fibh->soffset);\n\t\tmemcpy(fibh->ebh->b_data, (uint8_t *)cfi - fibh->soffset,\n\t\t       sizeof(struct fileIdentDesc) + fibh->soffset);\n\t}\n\n\tif (adinicb) {\n\t\tmark_inode_dirty(inode);\n\t} else {\n\t\tif (fibh->sbh != fibh->ebh)\n\t\t\tmark_buffer_dirty_inode(fibh->ebh, inode);\n\t\tmark_buffer_dirty_inode(fibh->sbh, inode);\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "sfi->lengthOfImpUse"
          ],
          "line": 396
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "*block"
          ],
          "line": 390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udf_fileident_read",
          "args": [
            "inode",
            "&f_pos",
            "&sfibh",
            "&cfi",
            "NULL",
            "NULL",
            "NULL",
            "NULL"
          ],
          "line": 383
        },
        "resolved": true,
        "details": {
          "function_name": "udf_fileident_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/directory.c",
          "lines": "21-155",
          "snippet": "struct fileIdentDesc *udf_fileident_read(struct inode *dir, loff_t *nf_pos,\n\t\t\t\t\t struct udf_fileident_bh *fibh,\n\t\t\t\t\t struct fileIdentDesc *cfi,\n\t\t\t\t\t struct extent_position *epos,\n\t\t\t\t\t struct kernel_lb_addr *eloc, uint32_t *elen,\n\t\t\t\t\t sector_t *offset)\n{\n\tstruct fileIdentDesc *fi;\n\tint i, num, block;\n\tstruct buffer_head *tmp, *bha[16];\n\tstruct udf_inode_info *iinfo = UDF_I(dir);\n\n\tfibh->soffset = fibh->eoffset;\n\n\tif (iinfo->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB) {\n\t\tfi = udf_get_fileident(iinfo->i_ext.i_data -\n\t\t\t\t       (iinfo->i_efe ?\n\t\t\t\t\tsizeof(struct extendedFileEntry) :\n\t\t\t\t\tsizeof(struct fileEntry)),\n\t\t\t\t       dir->i_sb->s_blocksize,\n\t\t\t\t       &(fibh->eoffset));\n\t\tif (!fi)\n\t\t\treturn NULL;\n\n\t\t*nf_pos += fibh->eoffset - fibh->soffset;\n\n\t\tmemcpy((uint8_t *)cfi, (uint8_t *)fi,\n\t\t       sizeof(struct fileIdentDesc));\n\n\t\treturn fi;\n\t}\n\n\tif (fibh->eoffset == dir->i_sb->s_blocksize) {\n\t\tint lextoffset = epos->offset;\n\t\tunsigned char blocksize_bits = dir->i_sb->s_blocksize_bits;\n\n\t\tif (udf_next_aext(dir, epos, eloc, elen, 1) !=\n\t\t    (EXT_RECORDED_ALLOCATED >> 30))\n\t\t\treturn NULL;\n\n\t\tblock = udf_get_lb_pblock(dir->i_sb, eloc, *offset);\n\n\t\t(*offset)++;\n\n\t\tif ((*offset << blocksize_bits) >= *elen)\n\t\t\t*offset = 0;\n\t\telse\n\t\t\tepos->offset = lextoffset;\n\n\t\tbrelse(fibh->sbh);\n\t\tfibh->sbh = fibh->ebh = udf_tread(dir->i_sb, block);\n\t\tif (!fibh->sbh)\n\t\t\treturn NULL;\n\t\tfibh->soffset = fibh->eoffset = 0;\n\n\t\tif (!(*offset & ((16 >> (blocksize_bits - 9)) - 1))) {\n\t\t\ti = 16 >> (blocksize_bits - 9);\n\t\t\tif (i + *offset > (*elen >> blocksize_bits))\n\t\t\t\ti = (*elen >> blocksize_bits)-*offset;\n\t\t\tfor (num = 0; i > 0; i--) {\n\t\t\t\tblock = udf_get_lb_pblock(dir->i_sb, eloc,\n\t\t\t\t\t\t\t  *offset + i);\n\t\t\t\ttmp = udf_tgetblk(dir->i_sb, block);\n\t\t\t\tif (tmp && !buffer_uptodate(tmp) &&\n\t\t\t\t\t\t!buffer_locked(tmp))\n\t\t\t\t\tbha[num++] = tmp;\n\t\t\t\telse\n\t\t\t\t\tbrelse(tmp);\n\t\t\t}\n\t\t\tif (num) {\n\t\t\t\tll_rw_block(READA, num, bha);\n\t\t\t\tfor (i = 0; i < num; i++)\n\t\t\t\t\tbrelse(bha[i]);\n\t\t\t}\n\t\t}\n\t} else if (fibh->sbh != fibh->ebh) {\n\t\tbrelse(fibh->sbh);\n\t\tfibh->sbh = fibh->ebh;\n\t}\n\n\tfi = udf_get_fileident(fibh->sbh->b_data, dir->i_sb->s_blocksize,\n\t\t\t       &(fibh->eoffset));\n\n\tif (!fi)\n\t\treturn NULL;\n\n\t*nf_pos += fibh->eoffset - fibh->soffset;\n\n\tif (fibh->eoffset <= dir->i_sb->s_blocksize) {\n\t\tmemcpy((uint8_t *)cfi, (uint8_t *)fi,\n\t\t       sizeof(struct fileIdentDesc));\n\t} else if (fibh->eoffset > dir->i_sb->s_blocksize) {\n\t\tint lextoffset = epos->offset;\n\n\t\tif (udf_next_aext(dir, epos, eloc, elen, 1) !=\n\t\t    (EXT_RECORDED_ALLOCATED >> 30))\n\t\t\treturn NULL;\n\n\t\tblock = udf_get_lb_pblock(dir->i_sb, eloc, *offset);\n\n\t\t(*offset)++;\n\n\t\tif ((*offset << dir->i_sb->s_blocksize_bits) >= *elen)\n\t\t\t*offset = 0;\n\t\telse\n\t\t\tepos->offset = lextoffset;\n\n\t\tfibh->soffset -= dir->i_sb->s_blocksize;\n\t\tfibh->eoffset -= dir->i_sb->s_blocksize;\n\n\t\tfibh->ebh = udf_tread(dir->i_sb, block);\n\t\tif (!fibh->ebh)\n\t\t\treturn NULL;\n\n\t\tif (sizeof(struct fileIdentDesc) > -fibh->soffset) {\n\t\t\tint fi_len;\n\n\t\t\tmemcpy((uint8_t *)cfi, (uint8_t *)fi, -fibh->soffset);\n\t\t\tmemcpy((uint8_t *)cfi - fibh->soffset,\n\t\t\t       fibh->ebh->b_data,\n\t\t\t       sizeof(struct fileIdentDesc) + fibh->soffset);\n\n\t\t\tfi_len = (sizeof(struct fileIdentDesc) +\n\t\t\t\t  cfi->lengthFileIdent +\n\t\t\t\t  le16_to_cpu(cfi->lengthOfImpUse) + 3) & ~3;\n\n\t\t\t*nf_pos += fi_len - (fibh->eoffset - fibh->soffset);\n\t\t\tfibh->eoffset = fibh->soffset + fi_len;\n\t\t} else {\n\t\t\tmemcpy((uint8_t *)cfi, (uint8_t *)fi,\n\t\t\t       sizeof(struct fileIdentDesc));\n\t\t}\n\t}\n\treturn fi;\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>",
            "#include \"udf_i.h\"",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include \"udf_i.h\"\n#include \"udfdecl.h\"\n\nstruct fileIdentDesc *udf_fileident_read(struct inode *dir, loff_t *nf_pos,\n\t\t\t\t\t struct udf_fileident_bh *fibh,\n\t\t\t\t\t struct fileIdentDesc *cfi,\n\t\t\t\t\t struct extent_position *epos,\n\t\t\t\t\t struct kernel_lb_addr *eloc, uint32_t *elen,\n\t\t\t\t\t sector_t *offset)\n{\n\tstruct fileIdentDesc *fi;\n\tint i, num, block;\n\tstruct buffer_head *tmp, *bha[16];\n\tstruct udf_inode_info *iinfo = UDF_I(dir);\n\n\tfibh->soffset = fibh->eoffset;\n\n\tif (iinfo->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB) {\n\t\tfi = udf_get_fileident(iinfo->i_ext.i_data -\n\t\t\t\t       (iinfo->i_efe ?\n\t\t\t\t\tsizeof(struct extendedFileEntry) :\n\t\t\t\t\tsizeof(struct fileEntry)),\n\t\t\t\t       dir->i_sb->s_blocksize,\n\t\t\t\t       &(fibh->eoffset));\n\t\tif (!fi)\n\t\t\treturn NULL;\n\n\t\t*nf_pos += fibh->eoffset - fibh->soffset;\n\n\t\tmemcpy((uint8_t *)cfi, (uint8_t *)fi,\n\t\t       sizeof(struct fileIdentDesc));\n\n\t\treturn fi;\n\t}\n\n\tif (fibh->eoffset == dir->i_sb->s_blocksize) {\n\t\tint lextoffset = epos->offset;\n\t\tunsigned char blocksize_bits = dir->i_sb->s_blocksize_bits;\n\n\t\tif (udf_next_aext(dir, epos, eloc, elen, 1) !=\n\t\t    (EXT_RECORDED_ALLOCATED >> 30))\n\t\t\treturn NULL;\n\n\t\tblock = udf_get_lb_pblock(dir->i_sb, eloc, *offset);\n\n\t\t(*offset)++;\n\n\t\tif ((*offset << blocksize_bits) >= *elen)\n\t\t\t*offset = 0;\n\t\telse\n\t\t\tepos->offset = lextoffset;\n\n\t\tbrelse(fibh->sbh);\n\t\tfibh->sbh = fibh->ebh = udf_tread(dir->i_sb, block);\n\t\tif (!fibh->sbh)\n\t\t\treturn NULL;\n\t\tfibh->soffset = fibh->eoffset = 0;\n\n\t\tif (!(*offset & ((16 >> (blocksize_bits - 9)) - 1))) {\n\t\t\ti = 16 >> (blocksize_bits - 9);\n\t\t\tif (i + *offset > (*elen >> blocksize_bits))\n\t\t\t\ti = (*elen >> blocksize_bits)-*offset;\n\t\t\tfor (num = 0; i > 0; i--) {\n\t\t\t\tblock = udf_get_lb_pblock(dir->i_sb, eloc,\n\t\t\t\t\t\t\t  *offset + i);\n\t\t\t\ttmp = udf_tgetblk(dir->i_sb, block);\n\t\t\t\tif (tmp && !buffer_uptodate(tmp) &&\n\t\t\t\t\t\t!buffer_locked(tmp))\n\t\t\t\t\tbha[num++] = tmp;\n\t\t\t\telse\n\t\t\t\t\tbrelse(tmp);\n\t\t\t}\n\t\t\tif (num) {\n\t\t\t\tll_rw_block(READA, num, bha);\n\t\t\t\tfor (i = 0; i < num; i++)\n\t\t\t\t\tbrelse(bha[i]);\n\t\t\t}\n\t\t}\n\t} else if (fibh->sbh != fibh->ebh) {\n\t\tbrelse(fibh->sbh);\n\t\tfibh->sbh = fibh->ebh;\n\t}\n\n\tfi = udf_get_fileident(fibh->sbh->b_data, dir->i_sb->s_blocksize,\n\t\t\t       &(fibh->eoffset));\n\n\tif (!fi)\n\t\treturn NULL;\n\n\t*nf_pos += fibh->eoffset - fibh->soffset;\n\n\tif (fibh->eoffset <= dir->i_sb->s_blocksize) {\n\t\tmemcpy((uint8_t *)cfi, (uint8_t *)fi,\n\t\t       sizeof(struct fileIdentDesc));\n\t} else if (fibh->eoffset > dir->i_sb->s_blocksize) {\n\t\tint lextoffset = epos->offset;\n\n\t\tif (udf_next_aext(dir, epos, eloc, elen, 1) !=\n\t\t    (EXT_RECORDED_ALLOCATED >> 30))\n\t\t\treturn NULL;\n\n\t\tblock = udf_get_lb_pblock(dir->i_sb, eloc, *offset);\n\n\t\t(*offset)++;\n\n\t\tif ((*offset << dir->i_sb->s_blocksize_bits) >= *elen)\n\t\t\t*offset = 0;\n\t\telse\n\t\t\tepos->offset = lextoffset;\n\n\t\tfibh->soffset -= dir->i_sb->s_blocksize;\n\t\tfibh->eoffset -= dir->i_sb->s_blocksize;\n\n\t\tfibh->ebh = udf_tread(dir->i_sb, block);\n\t\tif (!fibh->ebh)\n\t\t\treturn NULL;\n\n\t\tif (sizeof(struct fileIdentDesc) > -fibh->soffset) {\n\t\t\tint fi_len;\n\n\t\t\tmemcpy((uint8_t *)cfi, (uint8_t *)fi, -fibh->soffset);\n\t\t\tmemcpy((uint8_t *)cfi - fibh->soffset,\n\t\t\t       fibh->ebh->b_data,\n\t\t\t       sizeof(struct fileIdentDesc) + fibh->soffset);\n\n\t\t\tfi_len = (sizeof(struct fileIdentDesc) +\n\t\t\t\t  cfi->lengthFileIdent +\n\t\t\t\t  le16_to_cpu(cfi->lengthOfImpUse) + 3) & ~3;\n\n\t\t\t*nf_pos += fi_len - (fibh->eoffset - fibh->soffset);\n\t\t\tfibh->eoffset = fibh->soffset + fi_len;\n\t\t} else {\n\t\t\tmemcpy((uint8_t *)cfi, (uint8_t *)fi,\n\t\t\t       sizeof(struct fileIdentDesc));\n\t\t}\n\t}\n\treturn fi;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_buffer",
          "args": [
            "dbh"
          ],
          "line": 373
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "70-75",
          "snippet": "void unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_buffer_uptodate",
          "args": [
            "dbh"
          ],
          "line": 372
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3758-3761",
          "snippet": "int btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "dbh->b_data",
            "0x00",
            "inode->i_sb->s_blocksize"
          ],
          "line": 371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udf_tgetblk",
          "args": [
            "inode->i_sb",
            "newblock"
          ],
          "line": 367
        },
        "resolved": true,
        "details": {
          "function_name": "udf_tgetblk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/misc.c",
          "lines": "32-38",
          "snippet": "struct buffer_head *udf_tgetblk(struct super_block *sb, int block)\n{\n\tif (UDF_QUERY_FLAG(sb, UDF_FLAG_VARCONV))\n\t\treturn sb_getblk(sb, udf_fixed_to_variable(block));\n\telse\n\t\treturn sb_getblk(sb, block);\n}",
          "includes": [
            "#include \"udf_sb.h\"",
            "#include \"udf_i.h\"",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/crc-itu-t.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include \"udfdecl.h\"\n\nstruct buffer_head *udf_tgetblk(struct super_block *sb, int block)\n{\n\tif (UDF_QUERY_FLAG(sb, UDF_FLAG_VARCONV))\n\t\treturn sb_getblk(sb, udf_fixed_to_variable(block));\n\telse\n\t\treturn sb_getblk(sb, block);\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_get_pblock",
          "args": [
            "inode->i_sb",
            "*block",
            "iinfo->i_location.partitionReferenceNum",
            "0"
          ],
          "line": 362
        },
        "resolved": true,
        "details": {
          "function_name": "udf_get_pblock_meta25",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/partition.c",
          "lines": "306-339",
          "snippet": "uint32_t udf_get_pblock_meta25(struct super_block *sb, uint32_t block,\n\t\t\t\tuint16_t partition, uint32_t offset)\n{\n\tstruct udf_sb_info *sbi = UDF_SB(sb);\n\tstruct udf_part_map *map;\n\tstruct udf_meta_data *mdata;\n\tuint32_t retblk;\n\tstruct inode *inode;\n\n\tudf_debug(\"READING from METADATA\\n\");\n\n\tmap = &sbi->s_partmaps[partition];\n\tmdata = &map->s_type_specific.s_metadata;\n\tinode = mdata->s_metadata_fe ? : mdata->s_mirror_fe;\n\n\t/* We shouldn't mount such media... */\n\tBUG_ON(!inode);\n\tretblk = udf_try_read_meta(inode, block, partition, offset);\n\tif (retblk == 0xFFFFFFFF && mdata->s_metadata_fe) {\n\t\tudf_warn(sb, \"error reading from METADATA, trying to read from MIRROR\\n\");\n\t\tif (!(mdata->s_flags & MF_MIRROR_FE_LOADED)) {\n\t\t\tmdata->s_mirror_fe = udf_find_metadata_inode_efe(sb,\n\t\t\t\tmdata->s_mirror_file_loc, map->s_partition_num);\n\t\t\tmdata->s_flags |= MF_MIRROR_FE_LOADED;\n\t\t}\n\n\t\tinode = mdata->s_mirror_fe;\n\t\tif (!inode)\n\t\t\treturn 0xFFFFFFFF;\n\t\tretblk = udf_try_read_meta(inode, block, partition, offset);\n\t}\n\n\treturn retblk;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>",
            "#include \"udf_i.h\"",
            "#include \"udf_sb.h\"",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include \"udf_i.h\"\n#include \"udf_sb.h\"\n#include \"udfdecl.h\"\n\nuint32_t udf_get_pblock_meta25(struct super_block *sb, uint32_t block,\n\t\t\t\tuint16_t partition, uint32_t offset)\n{\n\tstruct udf_sb_info *sbi = UDF_SB(sb);\n\tstruct udf_part_map *map;\n\tstruct udf_meta_data *mdata;\n\tuint32_t retblk;\n\tstruct inode *inode;\n\n\tudf_debug(\"READING from METADATA\\n\");\n\n\tmap = &sbi->s_partmaps[partition];\n\tmdata = &map->s_type_specific.s_metadata;\n\tinode = mdata->s_metadata_fe ? : mdata->s_mirror_fe;\n\n\t/* We shouldn't mount such media... */\n\tBUG_ON(!inode);\n\tretblk = udf_try_read_meta(inode, block, partition, offset);\n\tif (retblk == 0xFFFFFFFF && mdata->s_metadata_fe) {\n\t\tudf_warn(sb, \"error reading from METADATA, trying to read from MIRROR\\n\");\n\t\tif (!(mdata->s_flags & MF_MIRROR_FE_LOADED)) {\n\t\t\tmdata->s_mirror_fe = udf_find_metadata_inode_efe(sb,\n\t\t\t\tmdata->s_mirror_file_loc, map->s_partition_num);\n\t\t\tmdata->s_flags |= MF_MIRROR_FE_LOADED;\n\t\t}\n\n\t\tinode = mdata->s_mirror_fe;\n\t\tif (!inode)\n\t\t\treturn 0xFFFFFFFF;\n\t\tretblk = udf_try_read_meta(inode, block, partition, offset);\n\t}\n\n\treturn retblk;\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_new_block",
          "args": [
            "inode->i_sb",
            "inode",
            "iinfo->i_location.partitionReferenceNum",
            "iinfo->i_location.logicalBlockNum",
            "err"
          ],
          "line": 357
        },
        "resolved": true,
        "details": {
          "function_name": "udf_new_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/balloc.c",
          "lines": "795-825",
          "snippet": "inline int udf_new_block(struct super_block *sb,\n\t\t\t struct inode *inode,\n\t\t\t uint16_t partition, uint32_t goal, int *err)\n{\n\tstruct udf_part_map *map = &UDF_SB(sb)->s_partmaps[partition];\n\tint block;\n\n\tif (map->s_partition_flags & UDF_PART_FLAG_UNALLOC_BITMAP)\n\t\tblock = udf_bitmap_new_block(sb,\n\t\t\t\t\t     map->s_uspace.s_bitmap,\n\t\t\t\t\t     partition, goal, err);\n\telse if (map->s_partition_flags & UDF_PART_FLAG_UNALLOC_TABLE)\n\t\tblock = udf_table_new_block(sb,\n\t\t\t\t\t    map->s_uspace.s_table,\n\t\t\t\t\t    partition, goal, err);\n\telse if (map->s_partition_flags & UDF_PART_FLAG_FREED_BITMAP)\n\t\tblock = udf_bitmap_new_block(sb,\n\t\t\t\t\t     map->s_fspace.s_bitmap,\n\t\t\t\t\t     partition, goal, err);\n\telse if (map->s_partition_flags & UDF_PART_FLAG_FREED_TABLE)\n\t\tblock = udf_table_new_block(sb,\n\t\t\t\t\t    map->s_fspace.s_table,\n\t\t\t\t\t    partition, goal, err);\n\telse {\n\t\t*err = -EIO;\n\t\treturn 0;\n\t}\n\tif (inode && block)\n\t\tinode_add_bytes(inode, sb->s_blocksize);\n\treturn block;\n}",
          "includes": [
            "#include \"udf_sb.h\"",
            "#include \"udf_i.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/buffer_head.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/bitops.h>\n#include <linux/buffer_head.h>\n#include \"udfdecl.h\"\n\ninline int udf_new_block(struct super_block *sb,\n\t\t\t struct inode *inode,\n\t\t\t uint16_t partition, uint32_t goal, int *err)\n{\n\tstruct udf_part_map *map = &UDF_SB(sb)->s_partmaps[partition];\n\tint block;\n\n\tif (map->s_partition_flags & UDF_PART_FLAG_UNALLOC_BITMAP)\n\t\tblock = udf_bitmap_new_block(sb,\n\t\t\t\t\t     map->s_uspace.s_bitmap,\n\t\t\t\t\t     partition, goal, err);\n\telse if (map->s_partition_flags & UDF_PART_FLAG_UNALLOC_TABLE)\n\t\tblock = udf_table_new_block(sb,\n\t\t\t\t\t    map->s_uspace.s_table,\n\t\t\t\t\t    partition, goal, err);\n\telse if (map->s_partition_flags & UDF_PART_FLAG_FREED_BITMAP)\n\t\tblock = udf_bitmap_new_block(sb,\n\t\t\t\t\t     map->s_fspace.s_bitmap,\n\t\t\t\t\t     partition, goal, err);\n\telse if (map->s_partition_flags & UDF_PART_FLAG_FREED_TABLE)\n\t\tblock = udf_table_new_block(sb,\n\t\t\t\t\t    map->s_fspace.s_table,\n\t\t\t\t\t    partition, goal, err);\n\telse {\n\t\t*err = -EIO;\n\t\treturn 0;\n\t}\n\tif (inode && block)\n\t\tinode_add_bytes(inode, sb->s_blocksize);\n\treturn block;\n}"
        }
      },
      {
        "call_info": {
          "callee": "UDF_QUERY_FLAG",
          "args": [
            "inode->i_sb",
            "UDF_FLAG_USE_SHORT_AD"
          ],
          "line": 345
        },
        "resolved": true,
        "details": {
          "function_name": "UDF_QUERY_FLAG",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/udf_sb.h",
          "lines": "169-172",
          "snippet": "static inline int UDF_QUERY_FLAG(struct super_block *sb, int flag)\n{\n\treturn test_bit(flag, &UDF_SB(sb)->s_flags);\n}",
          "includes": [
            "#include <linux/bitops.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bitops.h>\n#include <linux/mutex.h>\n\nstatic inline int UDF_QUERY_FLAG(struct super_block *sb, int flag)\n{\n\treturn test_bit(flag, &UDF_SB(sb)->s_flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "UDF_I",
          "args": [
            "inode"
          ],
          "line": 343
        },
        "resolved": true,
        "details": {
          "function_name": "UDF_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/udf_i.h",
          "lines": "57-60",
          "snippet": "static inline struct udf_inode_info *UDF_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct udf_inode_info, vfs_inode);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline struct udf_inode_info *UDF_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct udf_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_ext0_offset",
          "args": [
            "inode"
          ],
          "line": 341
        },
        "resolved": true,
        "details": {
          "function_name": "udf_ext0_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/udfdecl.h",
          "lines": "66-72",
          "snippet": "static inline size_t udf_ext0_offset(struct inode *inode)\n{\n\tif (UDF_I(inode)->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB)\n\t\treturn udf_file_entry_alloc_offset(inode);\n\telse\n\t\treturn 0;\n}",
          "includes": [
            "#include \"udf_i.h\"",
            "#include \"udfend.h\"",
            "#include \"udf_sb.h\"",
            "#include <linux/udf_fs_i.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include \"osta_udf.h\"",
            "#include \"ecma_167.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_i.h\"\n#include \"udfend.h\"\n#include \"udf_sb.h\"\n#include <linux/udf_fs_i.h>\n#include <linux/buffer_head.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include \"osta_udf.h\"\n#include \"ecma_167.h\"\n\nstatic inline size_t udf_ext0_offset(struct inode *inode)\n{\n\tif (UDF_I(inode)->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB)\n\t\treturn udf_file_entry_alloc_offset(inode);\n\telse\n\t\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/crc-itu-t.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include \"udfdecl.h\"\n\nstatic int udf_update_inode(struct inode *, int);\nstatic int udf_sync_inode(struct inode *inode);\nstatic int udf_alloc_i_data(struct inode *inode, size_t size);\nstatic int udf_get_block(struct inode *, sector_t, struct buffer_head *, int);\n\nstruct buffer_head *udf_expand_dir_adinicb(struct inode *inode, int *block,\n\t\t\t\t\t   int *err)\n{\n\tint newblock;\n\tstruct buffer_head *dbh = NULL;\n\tstruct kernel_lb_addr eloc;\n\tuint8_t alloctype;\n\tstruct extent_position epos;\n\n\tstruct udf_fileident_bh sfibh, dfibh;\n\tloff_t f_pos = udf_ext0_offset(inode);\n\tint size = udf_ext0_offset(inode) + inode->i_size;\n\tstruct fileIdentDesc cfi, *sfi, *dfi;\n\tstruct udf_inode_info *iinfo = UDF_I(inode);\n\n\tif (UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_USE_SHORT_AD))\n\t\talloctype = ICBTAG_FLAG_AD_SHORT;\n\telse\n\t\talloctype = ICBTAG_FLAG_AD_LONG;\n\n\tif (!inode->i_size) {\n\t\tiinfo->i_alloc_type = alloctype;\n\t\tmark_inode_dirty(inode);\n\t\treturn NULL;\n\t}\n\n\t/* alloc block, and copy data to it */\n\t*block = udf_new_block(inode->i_sb, inode,\n\t\t\t       iinfo->i_location.partitionReferenceNum,\n\t\t\t       iinfo->i_location.logicalBlockNum, err);\n\tif (!(*block))\n\t\treturn NULL;\n\tnewblock = udf_get_pblock(inode->i_sb, *block,\n\t\t\t\t  iinfo->i_location.partitionReferenceNum,\n\t\t\t\t0);\n\tif (!newblock)\n\t\treturn NULL;\n\tdbh = udf_tgetblk(inode->i_sb, newblock);\n\tif (!dbh)\n\t\treturn NULL;\n\tlock_buffer(dbh);\n\tmemset(dbh->b_data, 0x00, inode->i_sb->s_blocksize);\n\tset_buffer_uptodate(dbh);\n\tunlock_buffer(dbh);\n\tmark_buffer_dirty_inode(dbh, inode);\n\n\tsfibh.soffset = sfibh.eoffset =\n\t\t\tf_pos & (inode->i_sb->s_blocksize - 1);\n\tsfibh.sbh = sfibh.ebh = NULL;\n\tdfibh.soffset = dfibh.eoffset = 0;\n\tdfibh.sbh = dfibh.ebh = dbh;\n\twhile (f_pos < size) {\n\t\tiinfo->i_alloc_type = ICBTAG_FLAG_AD_IN_ICB;\n\t\tsfi = udf_fileident_read(inode, &f_pos, &sfibh, &cfi, NULL,\n\t\t\t\t\t NULL, NULL, NULL);\n\t\tif (!sfi) {\n\t\t\tbrelse(dbh);\n\t\t\treturn NULL;\n\t\t}\n\t\tiinfo->i_alloc_type = alloctype;\n\t\tsfi->descTag.tagLocation = cpu_to_le32(*block);\n\t\tdfibh.soffset = dfibh.eoffset;\n\t\tdfibh.eoffset += (sfibh.eoffset - sfibh.soffset);\n\t\tdfi = (struct fileIdentDesc *)(dbh->b_data + dfibh.soffset);\n\t\tif (udf_write_fi(inode, sfi, dfi, &dfibh, sfi->impUse,\n\t\t\t\t sfi->fileIdent +\n\t\t\t\t\tle16_to_cpu(sfi->lengthOfImpUse))) {\n\t\t\tiinfo->i_alloc_type = ICBTAG_FLAG_AD_IN_ICB;\n\t\t\tbrelse(dbh);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\tmark_buffer_dirty_inode(dbh, inode);\n\n\tmemset(iinfo->i_ext.i_data + iinfo->i_lenEAttr, 0,\n\t\tiinfo->i_lenAlloc);\n\tiinfo->i_lenAlloc = 0;\n\teloc.logicalBlockNum = *block;\n\teloc.partitionReferenceNum =\n\t\t\t\tiinfo->i_location.partitionReferenceNum;\n\tiinfo->i_lenExtents = inode->i_size;\n\tepos.bh = NULL;\n\tepos.block = iinfo->i_location;\n\tepos.offset = udf_file_entry_alloc_offset(inode);\n\tudf_add_aext(inode, &epos, &eloc, inode->i_size, 0);\n\t/* UniqueID stuff */\n\n\tbrelse(epos.bh);\n\tmark_inode_dirty(inode);\n\treturn dbh;\n}"
  },
  {
    "function_name": "udf_expand_file_adinicb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/inode.c",
    "lines": "256-328",
    "snippet": "int udf_expand_file_adinicb(struct inode *inode)\n{\n\tstruct page *page;\n\tchar *kaddr;\n\tstruct udf_inode_info *iinfo = UDF_I(inode);\n\tint err;\n\tstruct writeback_control udf_wbc = {\n\t\t.sync_mode = WB_SYNC_NONE,\n\t\t.nr_to_write = 1,\n\t};\n\n\tWARN_ON_ONCE(!mutex_is_locked(&inode->i_mutex));\n\tif (!iinfo->i_lenAlloc) {\n\t\tif (UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_USE_SHORT_AD))\n\t\t\tiinfo->i_alloc_type = ICBTAG_FLAG_AD_SHORT;\n\t\telse\n\t\t\tiinfo->i_alloc_type = ICBTAG_FLAG_AD_LONG;\n\t\t/* from now on we have normal address_space methods */\n\t\tinode->i_data.a_ops = &udf_aops;\n\t\tup_write(&iinfo->i_data_sem);\n\t\tmark_inode_dirty(inode);\n\t\treturn 0;\n\t}\n\t/*\n\t * Release i_data_sem so that we can lock a page - page lock ranks\n\t * above i_data_sem. i_mutex still protects us against file changes.\n\t */\n\tup_write(&iinfo->i_data_sem);\n\n\tpage = find_or_create_page(inode->i_mapping, 0, GFP_NOFS);\n\tif (!page)\n\t\treturn -ENOMEM;\n\n\tif (!PageUptodate(page)) {\n\t\tkaddr = kmap(page);\n\t\tmemset(kaddr + iinfo->i_lenAlloc, 0x00,\n\t\t       PAGE_CACHE_SIZE - iinfo->i_lenAlloc);\n\t\tmemcpy(kaddr, iinfo->i_ext.i_data + iinfo->i_lenEAttr,\n\t\t\tiinfo->i_lenAlloc);\n\t\tflush_dcache_page(page);\n\t\tSetPageUptodate(page);\n\t\tkunmap(page);\n\t}\n\tdown_write(&iinfo->i_data_sem);\n\tmemset(iinfo->i_ext.i_data + iinfo->i_lenEAttr, 0x00,\n\t       iinfo->i_lenAlloc);\n\tiinfo->i_lenAlloc = 0;\n\tif (UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_USE_SHORT_AD))\n\t\tiinfo->i_alloc_type = ICBTAG_FLAG_AD_SHORT;\n\telse\n\t\tiinfo->i_alloc_type = ICBTAG_FLAG_AD_LONG;\n\t/* from now on we have normal address_space methods */\n\tinode->i_data.a_ops = &udf_aops;\n\tup_write(&iinfo->i_data_sem);\n\terr = inode->i_data.a_ops->writepage(page, &udf_wbc);\n\tif (err) {\n\t\t/* Restore everything back so that we don't lose data... */\n\t\tlock_page(page);\n\t\tkaddr = kmap(page);\n\t\tdown_write(&iinfo->i_data_sem);\n\t\tmemcpy(iinfo->i_ext.i_data + iinfo->i_lenEAttr, kaddr,\n\t\t       inode->i_size);\n\t\tkunmap(page);\n\t\tunlock_page(page);\n\t\tiinfo->i_alloc_type = ICBTAG_FLAG_AD_IN_ICB;\n\t\tinode->i_data.a_ops = &udf_adinicb_aops;\n\t\tup_write(&iinfo->i_data_sem);\n\t}\n\tpage_cache_release(page);\n\tmark_inode_dirty(inode);\n\n\treturn err;\n}",
    "includes": [
      "#include \"udf_sb.h\"",
      "#include \"udf_i.h\"",
      "#include <linux/aio.h>",
      "#include <linux/mpage.h>",
      "#include <linux/crc-itu-t.h>",
      "#include <linux/slab.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include \"udfdecl.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int udf_update_inode(struct inode *, int);",
      "static int udf_sync_inode(struct inode *inode);",
      "const struct address_space_operations udf_aops = {\n\t.readpage\t= udf_readpage,\n\t.readpages\t= udf_readpages,\n\t.writepage\t= udf_writepage,\n\t.writepages\t= udf_writepages,\n\t.write_begin\t= udf_write_begin,\n\t.write_end\t= generic_write_end,\n\t.direct_IO\t= udf_direct_IO,\n\t.bmap\t\t= udf_bmap,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mark_inode_dirty",
          "args": [
            "inode"
          ],
          "line": 325
        },
        "resolved": true,
        "details": {
          "function_name": "block_dump___mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1134-1154",
          "snippet": "static noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "page"
          ],
          "line": 324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&iinfo->i_data_sem"
          ],
          "line": 322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 319
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kunmap",
          "args": [
            "page"
          ],
          "line": 318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "iinfo->i_ext.i_data + iinfo->i_lenEAttr",
            "kaddr",
            "inode->i_size"
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&iinfo->i_data_sem"
          ],
          "line": 315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmap",
          "args": [
            "page"
          ],
          "line": 314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode->i_data.a_ops->writepage",
          "args": [
            "page",
            "&udf_wbc"
          ],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&iinfo->i_data_sem"
          ],
          "line": 309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UDF_QUERY_FLAG",
          "args": [
            "inode->i_sb",
            "UDF_FLAG_USE_SHORT_AD"
          ],
          "line": 303
        },
        "resolved": true,
        "details": {
          "function_name": "UDF_QUERY_FLAG",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/udf_sb.h",
          "lines": "169-172",
          "snippet": "static inline int UDF_QUERY_FLAG(struct super_block *sb, int flag)\n{\n\treturn test_bit(flag, &UDF_SB(sb)->s_flags);\n}",
          "includes": [
            "#include <linux/bitops.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bitops.h>\n#include <linux/mutex.h>\n\nstatic inline int UDF_QUERY_FLAG(struct super_block *sb, int flag)\n{\n\treturn test_bit(flag, &UDF_SB(sb)->s_flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "iinfo->i_ext.i_data + iinfo->i_lenEAttr",
            "0x00",
            "iinfo->i_lenAlloc"
          ],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&iinfo->i_data_sem"
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kunmap",
          "args": [
            "page"
          ],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetPageUptodate",
          "args": [
            "page"
          ],
          "line": 296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flush_dcache_page",
          "args": [
            "page"
          ],
          "line": 295
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_index_entry_flush_dcache_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/index.h",
          "lines": "111-117",
          "snippet": "static inline void ntfs_index_entry_flush_dcache_page(ntfs_index_context *ictx)\n{\n\tif (ictx->is_in_root)\n\t\tflush_dcache_mft_record_page(ictx->actx->ntfs_ino);\n\telse\n\t\tflush_dcache_page(ictx->page);\n}",
          "includes": [
            "#include \"aops.h\"",
            "#include \"mft.h\"",
            "#include \"attrib.h\"",
            "#include \"inode.h\"",
            "#include \"layout.h\"",
            "#include \"types.h\"",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"aops.h\"\n#include \"mft.h\"\n#include \"attrib.h\"\n#include \"inode.h\"\n#include \"layout.h\"\n#include \"types.h\"\n#include <linux/fs.h>\n\nstatic inline void ntfs_index_entry_flush_dcache_page(ntfs_index_context *ictx)\n{\n\tif (ictx->is_in_root)\n\t\tflush_dcache_mft_record_page(ictx->actx->ntfs_ino);\n\telse\n\t\tflush_dcache_page(ictx->page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "kaddr",
            "iinfo->i_ext.i_data + iinfo->i_lenEAttr",
            "iinfo->i_lenAlloc"
          ],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "kaddr + iinfo->i_lenAlloc",
            "0x00",
            "PAGE_CACHE_SIZE - iinfo->i_lenAlloc"
          ],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmap",
          "args": [
            "page"
          ],
          "line": 290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "page"
          ],
          "line": 289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_or_create_page",
          "args": [
            "inode->i_mapping",
            "0",
            "GFP_NOFS"
          ],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&iinfo->i_data_sem"
          ],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&iinfo->i_data_sem"
          ],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!mutex_is_locked(&inode->i_mutex)"
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_is_locked",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UDF_I",
          "args": [
            "inode"
          ],
          "line": 260
        },
        "resolved": true,
        "details": {
          "function_name": "UDF_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/udf_i.h",
          "lines": "57-60",
          "snippet": "static inline struct udf_inode_info *UDF_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct udf_inode_info, vfs_inode);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline struct udf_inode_info *UDF_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct udf_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/crc-itu-t.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include \"udfdecl.h\"\n\nstatic int udf_update_inode(struct inode *, int);\nstatic int udf_sync_inode(struct inode *inode);\nconst struct address_space_operations udf_aops = {\n\t.readpage\t= udf_readpage,\n\t.readpages\t= udf_readpages,\n\t.writepage\t= udf_writepage,\n\t.writepages\t= udf_writepages,\n\t.write_begin\t= udf_write_begin,\n\t.write_end\t= generic_write_end,\n\t.direct_IO\t= udf_direct_IO,\n\t.bmap\t\t= udf_bmap,\n};\n\nint udf_expand_file_adinicb(struct inode *inode)\n{\n\tstruct page *page;\n\tchar *kaddr;\n\tstruct udf_inode_info *iinfo = UDF_I(inode);\n\tint err;\n\tstruct writeback_control udf_wbc = {\n\t\t.sync_mode = WB_SYNC_NONE,\n\t\t.nr_to_write = 1,\n\t};\n\n\tWARN_ON_ONCE(!mutex_is_locked(&inode->i_mutex));\n\tif (!iinfo->i_lenAlloc) {\n\t\tif (UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_USE_SHORT_AD))\n\t\t\tiinfo->i_alloc_type = ICBTAG_FLAG_AD_SHORT;\n\t\telse\n\t\t\tiinfo->i_alloc_type = ICBTAG_FLAG_AD_LONG;\n\t\t/* from now on we have normal address_space methods */\n\t\tinode->i_data.a_ops = &udf_aops;\n\t\tup_write(&iinfo->i_data_sem);\n\t\tmark_inode_dirty(inode);\n\t\treturn 0;\n\t}\n\t/*\n\t * Release i_data_sem so that we can lock a page - page lock ranks\n\t * above i_data_sem. i_mutex still protects us against file changes.\n\t */\n\tup_write(&iinfo->i_data_sem);\n\n\tpage = find_or_create_page(inode->i_mapping, 0, GFP_NOFS);\n\tif (!page)\n\t\treturn -ENOMEM;\n\n\tif (!PageUptodate(page)) {\n\t\tkaddr = kmap(page);\n\t\tmemset(kaddr + iinfo->i_lenAlloc, 0x00,\n\t\t       PAGE_CACHE_SIZE - iinfo->i_lenAlloc);\n\t\tmemcpy(kaddr, iinfo->i_ext.i_data + iinfo->i_lenEAttr,\n\t\t\tiinfo->i_lenAlloc);\n\t\tflush_dcache_page(page);\n\t\tSetPageUptodate(page);\n\t\tkunmap(page);\n\t}\n\tdown_write(&iinfo->i_data_sem);\n\tmemset(iinfo->i_ext.i_data + iinfo->i_lenEAttr, 0x00,\n\t       iinfo->i_lenAlloc);\n\tiinfo->i_lenAlloc = 0;\n\tif (UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_USE_SHORT_AD))\n\t\tiinfo->i_alloc_type = ICBTAG_FLAG_AD_SHORT;\n\telse\n\t\tiinfo->i_alloc_type = ICBTAG_FLAG_AD_LONG;\n\t/* from now on we have normal address_space methods */\n\tinode->i_data.a_ops = &udf_aops;\n\tup_write(&iinfo->i_data_sem);\n\terr = inode->i_data.a_ops->writepage(page, &udf_wbc);\n\tif (err) {\n\t\t/* Restore everything back so that we don't lose data... */\n\t\tlock_page(page);\n\t\tkaddr = kmap(page);\n\t\tdown_write(&iinfo->i_data_sem);\n\t\tmemcpy(iinfo->i_ext.i_data + iinfo->i_lenEAttr, kaddr,\n\t\t       inode->i_size);\n\t\tkunmap(page);\n\t\tunlock_page(page);\n\t\tiinfo->i_alloc_type = ICBTAG_FLAG_AD_IN_ICB;\n\t\tinode->i_data.a_ops = &udf_adinicb_aops;\n\t\tup_write(&iinfo->i_data_sem);\n\t}\n\tpage_cache_release(page);\n\tmark_inode_dirty(inode);\n\n\treturn err;\n}"
  },
  {
    "function_name": "udf_bmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/inode.c",
    "lines": "234-237",
    "snippet": "static sector_t udf_bmap(struct address_space *mapping, sector_t block)\n{\n\treturn generic_block_bmap(mapping, block, udf_get_block);\n}",
    "includes": [
      "#include \"udf_sb.h\"",
      "#include \"udf_i.h\"",
      "#include <linux/aio.h>",
      "#include <linux/mpage.h>",
      "#include <linux/crc-itu-t.h>",
      "#include <linux/slab.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include \"udfdecl.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static sector_t inode_getblk(struct inode *, sector_t, int *, int *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "generic_block_bmap",
          "args": [
            "mapping",
            "block",
            "udf_get_block"
          ],
          "line": 236
        },
        "resolved": true,
        "details": {
          "function_name": "generic_block_bmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "2924-2934",
          "snippet": "sector_t generic_block_bmap(struct address_space *mapping, sector_t block,\n\t\t\t    get_block_t *get_block)\n{\n\tstruct buffer_head tmp;\n\tstruct inode *inode = mapping->host;\n\ttmp.b_state = 0;\n\ttmp.b_blocknr = 0;\n\ttmp.b_size = 1 << inode->i_blkbits;\n\tget_block(inode, block, &tmp, 0);\n\treturn tmp.b_blocknr;\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nsector_t generic_block_bmap(struct address_space *mapping, sector_t block,\n\t\t\t    get_block_t *get_block)\n{\n\tstruct buffer_head tmp;\n\tstruct inode *inode = mapping->host;\n\ttmp.b_state = 0;\n\ttmp.b_blocknr = 0;\n\ttmp.b_size = 1 << inode->i_blkbits;\n\tget_block(inode, block, &tmp, 0);\n\treturn tmp.b_blocknr;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/crc-itu-t.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include \"udfdecl.h\"\n\nstatic sector_t inode_getblk(struct inode *, sector_t, int *, int *);\n\nstatic sector_t udf_bmap(struct address_space *mapping, sector_t block)\n{\n\treturn generic_block_bmap(mapping, block, udf_get_block);\n}"
  },
  {
    "function_name": "udf_direct_IO",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/inode.c",
    "lines": "218-232",
    "snippet": "static ssize_t udf_direct_IO(int rw, struct kiocb *iocb,\n\t\t\t     struct iov_iter *iter,\n\t\t\t     loff_t offset)\n{\n\tstruct file *file = iocb->ki_filp;\n\tstruct address_space *mapping = file->f_mapping;\n\tstruct inode *inode = mapping->host;\n\tsize_t count = iov_iter_count(iter);\n\tssize_t ret;\n\n\tret = blockdev_direct_IO(rw, iocb, inode, iter, offset, udf_get_block);\n\tif (unlikely(ret < 0 && (rw & WRITE)))\n\t\tudf_write_failed(mapping, offset + count);\n\treturn ret;\n}",
    "includes": [
      "#include \"udf_sb.h\"",
      "#include \"udf_i.h\"",
      "#include <linux/aio.h>",
      "#include <linux/mpage.h>",
      "#include <linux/crc-itu-t.h>",
      "#include <linux/slab.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include \"udfdecl.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int udf_update_inode(struct inode *, int);",
      "static int udf_sync_inode(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "udf_write_failed",
          "args": [
            "mapping",
            "offset + count"
          ],
          "line": 230
        },
        "resolved": true,
        "details": {
          "function_name": "udf_write_failed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/inode.c",
          "lines": "167-182",
          "snippet": "static void udf_write_failed(struct address_space *mapping, loff_t to)\n{\n\tstruct inode *inode = mapping->host;\n\tstruct udf_inode_info *iinfo = UDF_I(inode);\n\tloff_t isize = inode->i_size;\n\n\tif (to > isize) {\n\t\ttruncate_pagecache(inode, isize);\n\t\tif (iinfo->i_alloc_type != ICBTAG_FLAG_AD_IN_ICB) {\n\t\t\tdown_write(&iinfo->i_data_sem);\n\t\t\tudf_clear_extent_cache(inode);\n\t\t\tudf_truncate_extents(inode);\n\t\t\tup_write(&iinfo->i_data_sem);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"udf_sb.h\"",
            "#include \"udf_i.h\"",
            "#include <linux/aio.h>",
            "#include <linux/mpage.h>",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int udf_update_inode(struct inode *, int);",
            "static int udf_sync_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/crc-itu-t.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include \"udfdecl.h\"\n\nstatic int udf_update_inode(struct inode *, int);\nstatic int udf_sync_inode(struct inode *inode);\n\nstatic void udf_write_failed(struct address_space *mapping, loff_t to)\n{\n\tstruct inode *inode = mapping->host;\n\tstruct udf_inode_info *iinfo = UDF_I(inode);\n\tloff_t isize = inode->i_size;\n\n\tif (to > isize) {\n\t\ttruncate_pagecache(inode, isize);\n\t\tif (iinfo->i_alloc_type != ICBTAG_FLAG_AD_IN_ICB) {\n\t\t\tdown_write(&iinfo->i_data_sem);\n\t\t\tudf_clear_extent_cache(inode);\n\t\t\tudf_truncate_extents(inode);\n\t\t\tup_write(&iinfo->i_data_sem);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ret < 0 && (rw & WRITE)"
          ],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "blockdev_direct_IO",
          "args": [
            "rw",
            "iocb",
            "inode",
            "iter",
            "offset",
            "udf_get_block"
          ],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iov_iter_count",
          "args": [
            "iter"
          ],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/crc-itu-t.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include \"udfdecl.h\"\n\nstatic int udf_update_inode(struct inode *, int);\nstatic int udf_sync_inode(struct inode *inode);\n\nstatic ssize_t udf_direct_IO(int rw, struct kiocb *iocb,\n\t\t\t     struct iov_iter *iter,\n\t\t\t     loff_t offset)\n{\n\tstruct file *file = iocb->ki_filp;\n\tstruct address_space *mapping = file->f_mapping;\n\tstruct inode *inode = mapping->host;\n\tsize_t count = iov_iter_count(iter);\n\tssize_t ret;\n\n\tret = blockdev_direct_IO(rw, iocb, inode, iter, offset, udf_get_block);\n\tif (unlikely(ret < 0 && (rw & WRITE)))\n\t\tudf_write_failed(mapping, offset + count);\n\treturn ret;\n}"
  },
  {
    "function_name": "udf_write_begin",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/inode.c",
    "lines": "206-216",
    "snippet": "static int udf_write_begin(struct file *file, struct address_space *mapping,\n\t\t\tloff_t pos, unsigned len, unsigned flags,\n\t\t\tstruct page **pagep, void **fsdata)\n{\n\tint ret;\n\n\tret = block_write_begin(mapping, pos, len, flags, pagep, udf_get_block);\n\tif (unlikely(ret))\n\t\tudf_write_failed(mapping, pos + len);\n\treturn ret;\n}",
    "includes": [
      "#include \"udf_sb.h\"",
      "#include \"udf_i.h\"",
      "#include <linux/aio.h>",
      "#include <linux/mpage.h>",
      "#include <linux/crc-itu-t.h>",
      "#include <linux/slab.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include \"udfdecl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "udf_write_failed",
          "args": [
            "mapping",
            "pos + len"
          ],
          "line": 214
        },
        "resolved": true,
        "details": {
          "function_name": "udf_write_failed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/inode.c",
          "lines": "167-182",
          "snippet": "static void udf_write_failed(struct address_space *mapping, loff_t to)\n{\n\tstruct inode *inode = mapping->host;\n\tstruct udf_inode_info *iinfo = UDF_I(inode);\n\tloff_t isize = inode->i_size;\n\n\tif (to > isize) {\n\t\ttruncate_pagecache(inode, isize);\n\t\tif (iinfo->i_alloc_type != ICBTAG_FLAG_AD_IN_ICB) {\n\t\t\tdown_write(&iinfo->i_data_sem);\n\t\t\tudf_clear_extent_cache(inode);\n\t\t\tudf_truncate_extents(inode);\n\t\t\tup_write(&iinfo->i_data_sem);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"udf_sb.h\"",
            "#include \"udf_i.h\"",
            "#include <linux/aio.h>",
            "#include <linux/mpage.h>",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int udf_update_inode(struct inode *, int);",
            "static int udf_sync_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/crc-itu-t.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include \"udfdecl.h\"\n\nstatic int udf_update_inode(struct inode *, int);\nstatic int udf_sync_inode(struct inode *inode);\n\nstatic void udf_write_failed(struct address_space *mapping, loff_t to)\n{\n\tstruct inode *inode = mapping->host;\n\tstruct udf_inode_info *iinfo = UDF_I(inode);\n\tloff_t isize = inode->i_size;\n\n\tif (to > isize) {\n\t\ttruncate_pagecache(inode, isize);\n\t\tif (iinfo->i_alloc_type != ICBTAG_FLAG_AD_IN_ICB) {\n\t\t\tdown_write(&iinfo->i_data_sem);\n\t\t\tudf_clear_extent_cache(inode);\n\t\t\tudf_truncate_extents(inode);\n\t\t\tup_write(&iinfo->i_data_sem);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ret"
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "block_write_begin",
          "args": [
            "mapping",
            "pos",
            "len",
            "flags",
            "pagep",
            "udf_get_block"
          ],
          "line": 212
        },
        "resolved": true,
        "details": {
          "function_name": "block_write_begin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "2008-2028",
          "snippet": "int block_write_begin(struct address_space *mapping, loff_t pos, unsigned len,\n\t\tunsigned flags, struct page **pagep, get_block_t *get_block)\n{\n\tpgoff_t index = pos >> PAGE_CACHE_SHIFT;\n\tstruct page *page;\n\tint status;\n\n\tpage = grab_cache_page_write_begin(mapping, index, flags);\n\tif (!page)\n\t\treturn -ENOMEM;\n\n\tstatus = __block_write_begin(page, pos, len, get_block);\n\tif (unlikely(status)) {\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t\tpage = NULL;\n\t}\n\n\t*pagep = page;\n\treturn status;\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint block_write_begin(struct address_space *mapping, loff_t pos, unsigned len,\n\t\tunsigned flags, struct page **pagep, get_block_t *get_block)\n{\n\tpgoff_t index = pos >> PAGE_CACHE_SHIFT;\n\tstruct page *page;\n\tint status;\n\n\tpage = grab_cache_page_write_begin(mapping, index, flags);\n\tif (!page)\n\t\treturn -ENOMEM;\n\n\tstatus = __block_write_begin(page, pos, len, get_block);\n\tif (unlikely(status)) {\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t\tpage = NULL;\n\t}\n\n\t*pagep = page;\n\treturn status;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/crc-itu-t.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include \"udfdecl.h\"\n\nstatic int udf_write_begin(struct file *file, struct address_space *mapping,\n\t\t\tloff_t pos, unsigned len, unsigned flags,\n\t\t\tstruct page **pagep, void **fsdata)\n{\n\tint ret;\n\n\tret = block_write_begin(mapping, pos, len, flags, pagep, udf_get_block);\n\tif (unlikely(ret))\n\t\tudf_write_failed(mapping, pos + len);\n\treturn ret;\n}"
  },
  {
    "function_name": "udf_readpages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/inode.c",
    "lines": "200-204",
    "snippet": "static int udf_readpages(struct file *file, struct address_space *mapping,\n\t\t\tstruct list_head *pages, unsigned nr_pages)\n{\n\treturn mpage_readpages(mapping, pages, nr_pages, udf_get_block);\n}",
    "includes": [
      "#include \"udf_sb.h\"",
      "#include \"udf_i.h\"",
      "#include <linux/aio.h>",
      "#include <linux/mpage.h>",
      "#include <linux/crc-itu-t.h>",
      "#include <linux/slab.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include \"udfdecl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mpage_readpages",
          "args": [
            "mapping",
            "pages",
            "nr_pages",
            "udf_get_block"
          ],
          "line": 203
        },
        "resolved": true,
        "details": {
          "function_name": "mpage_readpages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mpage.c",
          "lines": "355-386",
          "snippet": "int\nmpage_readpages(struct address_space *mapping, struct list_head *pages,\n\t\t\t\tunsigned nr_pages, get_block_t get_block)\n{\n\tstruct bio *bio = NULL;\n\tunsigned page_idx;\n\tsector_t last_block_in_bio = 0;\n\tstruct buffer_head map_bh;\n\tunsigned long first_logical_block = 0;\n\n\tmap_bh.b_state = 0;\n\tmap_bh.b_size = 0;\n\tfor (page_idx = 0; page_idx < nr_pages; page_idx++) {\n\t\tstruct page *page = list_entry(pages->prev, struct page, lru);\n\n\t\tprefetchw(&page->flags);\n\t\tlist_del(&page->lru);\n\t\tif (!add_to_page_cache_lru(page, mapping,\n\t\t\t\t\tpage->index, GFP_KERNEL)) {\n\t\t\tbio = do_mpage_readpage(bio, page,\n\t\t\t\t\tnr_pages - page_idx,\n\t\t\t\t\t&last_block_in_bio, &map_bh,\n\t\t\t\t\t&first_logical_block,\n\t\t\t\t\tget_block);\n\t\t}\n\t\tpage_cache_release(page);\n\t}\n\tBUG_ON(!list_empty(pages));\n\tif (bio)\n\t\tmpage_bio_submit(READ, bio);\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/highmem.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/bio.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/cleancache.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/prefetch.h>\n#include <linux/highmem.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/bio.h>\n#include <linux/gfp.h>\n#include <linux/kdev_t.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nint\nmpage_readpages(struct address_space *mapping, struct list_head *pages,\n\t\t\t\tunsigned nr_pages, get_block_t get_block)\n{\n\tstruct bio *bio = NULL;\n\tunsigned page_idx;\n\tsector_t last_block_in_bio = 0;\n\tstruct buffer_head map_bh;\n\tunsigned long first_logical_block = 0;\n\n\tmap_bh.b_state = 0;\n\tmap_bh.b_size = 0;\n\tfor (page_idx = 0; page_idx < nr_pages; page_idx++) {\n\t\tstruct page *page = list_entry(pages->prev, struct page, lru);\n\n\t\tprefetchw(&page->flags);\n\t\tlist_del(&page->lru);\n\t\tif (!add_to_page_cache_lru(page, mapping,\n\t\t\t\t\tpage->index, GFP_KERNEL)) {\n\t\t\tbio = do_mpage_readpage(bio, page,\n\t\t\t\t\tnr_pages - page_idx,\n\t\t\t\t\t&last_block_in_bio, &map_bh,\n\t\t\t\t\t&first_logical_block,\n\t\t\t\t\tget_block);\n\t\t}\n\t\tpage_cache_release(page);\n\t}\n\tBUG_ON(!list_empty(pages));\n\tif (bio)\n\t\tmpage_bio_submit(READ, bio);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/crc-itu-t.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include \"udfdecl.h\"\n\nstatic int udf_readpages(struct file *file, struct address_space *mapping,\n\t\t\tstruct list_head *pages, unsigned nr_pages)\n{\n\treturn mpage_readpages(mapping, pages, nr_pages, udf_get_block);\n}"
  },
  {
    "function_name": "udf_readpage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/inode.c",
    "lines": "195-198",
    "snippet": "static int udf_readpage(struct file *file, struct page *page)\n{\n\treturn mpage_readpage(page, udf_get_block);\n}",
    "includes": [
      "#include \"udf_sb.h\"",
      "#include \"udf_i.h\"",
      "#include <linux/aio.h>",
      "#include <linux/mpage.h>",
      "#include <linux/crc-itu-t.h>",
      "#include <linux/slab.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include \"udfdecl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mpage_readpage",
          "args": [
            "page",
            "udf_get_block"
          ],
          "line": 197
        },
        "resolved": true,
        "details": {
          "function_name": "mpage_readpage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mpage.c",
          "lines": "392-406",
          "snippet": "int mpage_readpage(struct page *page, get_block_t get_block)\n{\n\tstruct bio *bio = NULL;\n\tsector_t last_block_in_bio = 0;\n\tstruct buffer_head map_bh;\n\tunsigned long first_logical_block = 0;\n\n\tmap_bh.b_state = 0;\n\tmap_bh.b_size = 0;\n\tbio = do_mpage_readpage(bio, page, 1, &last_block_in_bio,\n\t\t\t&map_bh, &first_logical_block, get_block);\n\tif (bio)\n\t\tmpage_bio_submit(READ, bio);\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/highmem.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/bio.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/cleancache.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/prefetch.h>\n#include <linux/highmem.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/bio.h>\n#include <linux/gfp.h>\n#include <linux/kdev_t.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nint mpage_readpage(struct page *page, get_block_t get_block)\n{\n\tstruct bio *bio = NULL;\n\tsector_t last_block_in_bio = 0;\n\tstruct buffer_head map_bh;\n\tunsigned long first_logical_block = 0;\n\n\tmap_bh.b_state = 0;\n\tmap_bh.b_size = 0;\n\tbio = do_mpage_readpage(bio, page, 1, &last_block_in_bio,\n\t\t\t&map_bh, &first_logical_block, get_block);\n\tif (bio)\n\t\tmpage_bio_submit(READ, bio);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/crc-itu-t.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include \"udfdecl.h\"\n\nstatic int udf_readpage(struct file *file, struct page *page)\n{\n\treturn mpage_readpage(page, udf_get_block);\n}"
  },
  {
    "function_name": "udf_writepages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/inode.c",
    "lines": "189-193",
    "snippet": "static int udf_writepages(struct address_space *mapping,\n\t\t\tstruct writeback_control *wbc)\n{\n\treturn mpage_writepages(mapping, wbc, udf_get_block);\n}",
    "includes": [
      "#include \"udf_sb.h\"",
      "#include \"udf_i.h\"",
      "#include <linux/aio.h>",
      "#include <linux/mpage.h>",
      "#include <linux/crc-itu-t.h>",
      "#include <linux/slab.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include \"udfdecl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mpage_writepages",
          "args": [
            "mapping",
            "wbc",
            "udf_get_block"
          ],
          "line": 192
        },
        "resolved": true,
        "details": {
          "function_name": "mpage_writepages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mpage.c",
          "lines": "675-700",
          "snippet": "int\nmpage_writepages(struct address_space *mapping,\n\t\tstruct writeback_control *wbc, get_block_t get_block)\n{\n\tstruct blk_plug plug;\n\tint ret;\n\n\tblk_start_plug(&plug);\n\n\tif (!get_block)\n\t\tret = generic_writepages(mapping, wbc);\n\telse {\n\t\tstruct mpage_data mpd = {\n\t\t\t.bio = NULL,\n\t\t\t.last_block_in_bio = 0,\n\t\t\t.get_block = get_block,\n\t\t\t.use_writepage = 1,\n\t\t};\n\n\t\tret = write_cache_pages(mapping, wbc, __mpage_writepage, &mpd);\n\t\tif (mpd.bio)\n\t\t\tmpage_bio_submit(WRITE, mpd.bio);\n\t}\n\tblk_finish_plug(&plug);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/highmem.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/bio.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/cleancache.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/prefetch.h>\n#include <linux/highmem.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/bio.h>\n#include <linux/gfp.h>\n#include <linux/kdev_t.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nint\nmpage_writepages(struct address_space *mapping,\n\t\tstruct writeback_control *wbc, get_block_t get_block)\n{\n\tstruct blk_plug plug;\n\tint ret;\n\n\tblk_start_plug(&plug);\n\n\tif (!get_block)\n\t\tret = generic_writepages(mapping, wbc);\n\telse {\n\t\tstruct mpage_data mpd = {\n\t\t\t.bio = NULL,\n\t\t\t.last_block_in_bio = 0,\n\t\t\t.get_block = get_block,\n\t\t\t.use_writepage = 1,\n\t\t};\n\n\t\tret = write_cache_pages(mapping, wbc, __mpage_writepage, &mpd);\n\t\tif (mpd.bio)\n\t\t\tmpage_bio_submit(WRITE, mpd.bio);\n\t}\n\tblk_finish_plug(&plug);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/crc-itu-t.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include \"udfdecl.h\"\n\nstatic int udf_writepages(struct address_space *mapping,\n\t\t\tstruct writeback_control *wbc)\n{\n\treturn mpage_writepages(mapping, wbc, udf_get_block);\n}"
  },
  {
    "function_name": "udf_writepage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/inode.c",
    "lines": "184-187",
    "snippet": "static int udf_writepage(struct page *page, struct writeback_control *wbc)\n{\n\treturn block_write_full_page(page, udf_get_block, wbc);\n}",
    "includes": [
      "#include \"udf_sb.h\"",
      "#include \"udf_i.h\"",
      "#include <linux/aio.h>",
      "#include <linux/mpage.h>",
      "#include <linux/crc-itu-t.h>",
      "#include <linux/slab.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include \"udfdecl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "block_write_full_page",
          "args": [
            "page",
            "udf_get_block",
            "wbc"
          ],
          "line": 186
        },
        "resolved": true,
        "details": {
          "function_name": "block_write_full_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "2885-2921",
          "snippet": "int block_write_full_page(struct page *page, get_block_t *get_block,\n\t\t\tstruct writeback_control *wbc)\n{\n\tstruct inode * const inode = page->mapping->host;\n\tloff_t i_size = i_size_read(inode);\n\tconst pgoff_t end_index = i_size >> PAGE_CACHE_SHIFT;\n\tunsigned offset;\n\n\t/* Is the page fully inside i_size? */\n\tif (page->index < end_index)\n\t\treturn __block_write_full_page(inode, page, get_block, wbc,\n\t\t\t\t\t       end_buffer_async_write);\n\n\t/* Is the page fully outside i_size? (truncate in progress) */\n\toffset = i_size & (PAGE_CACHE_SIZE-1);\n\tif (page->index >= end_index+1 || !offset) {\n\t\t/*\n\t\t * The page may have dirty, unmapped buffers.  For example,\n\t\t * they may have been added in ext3_writepage().  Make them\n\t\t * freeable here, so the page does not leak.\n\t\t */\n\t\tdo_invalidatepage(page, 0, PAGE_CACHE_SIZE);\n\t\tunlock_page(page);\n\t\treturn 0; /* don't care */\n\t}\n\n\t/*\n\t * The page straddles i_size.  It must be zeroed out on each and every\n\t * writepage invocation because it may be mmapped.  \"A file is mapped\n\t * in multiples of the page size.  For a file that is not a multiple of\n\t * the  page size, the remaining memory is zeroed when mapped, and\n\t * writes to that region are not written out to the file.\"\n\t */\n\tzero_user_segment(page, offset, PAGE_CACHE_SIZE);\n\treturn __block_write_full_page(inode, page, get_block, wbc,\n\t\t\t\t\t\t\tend_buffer_async_write);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint block_write_full_page(struct page *page, get_block_t *get_block,\n\t\t\tstruct writeback_control *wbc)\n{\n\tstruct inode * const inode = page->mapping->host;\n\tloff_t i_size = i_size_read(inode);\n\tconst pgoff_t end_index = i_size >> PAGE_CACHE_SHIFT;\n\tunsigned offset;\n\n\t/* Is the page fully inside i_size? */\n\tif (page->index < end_index)\n\t\treturn __block_write_full_page(inode, page, get_block, wbc,\n\t\t\t\t\t       end_buffer_async_write);\n\n\t/* Is the page fully outside i_size? (truncate in progress) */\n\toffset = i_size & (PAGE_CACHE_SIZE-1);\n\tif (page->index >= end_index+1 || !offset) {\n\t\t/*\n\t\t * The page may have dirty, unmapped buffers.  For example,\n\t\t * they may have been added in ext3_writepage().  Make them\n\t\t * freeable here, so the page does not leak.\n\t\t */\n\t\tdo_invalidatepage(page, 0, PAGE_CACHE_SIZE);\n\t\tunlock_page(page);\n\t\treturn 0; /* don't care */\n\t}\n\n\t/*\n\t * The page straddles i_size.  It must be zeroed out on each and every\n\t * writepage invocation because it may be mmapped.  \"A file is mapped\n\t * in multiples of the page size.  For a file that is not a multiple of\n\t * the  page size, the remaining memory is zeroed when mapped, and\n\t * writes to that region are not written out to the file.\"\n\t */\n\tzero_user_segment(page, offset, PAGE_CACHE_SIZE);\n\treturn __block_write_full_page(inode, page, get_block, wbc,\n\t\t\t\t\t\t\tend_buffer_async_write);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/crc-itu-t.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include \"udfdecl.h\"\n\nstatic int udf_writepage(struct page *page, struct writeback_control *wbc)\n{\n\treturn block_write_full_page(page, udf_get_block, wbc);\n}"
  },
  {
    "function_name": "udf_write_failed",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/inode.c",
    "lines": "167-182",
    "snippet": "static void udf_write_failed(struct address_space *mapping, loff_t to)\n{\n\tstruct inode *inode = mapping->host;\n\tstruct udf_inode_info *iinfo = UDF_I(inode);\n\tloff_t isize = inode->i_size;\n\n\tif (to > isize) {\n\t\ttruncate_pagecache(inode, isize);\n\t\tif (iinfo->i_alloc_type != ICBTAG_FLAG_AD_IN_ICB) {\n\t\t\tdown_write(&iinfo->i_data_sem);\n\t\t\tudf_clear_extent_cache(inode);\n\t\t\tudf_truncate_extents(inode);\n\t\t\tup_write(&iinfo->i_data_sem);\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"udf_sb.h\"",
      "#include \"udf_i.h\"",
      "#include <linux/aio.h>",
      "#include <linux/mpage.h>",
      "#include <linux/crc-itu-t.h>",
      "#include <linux/slab.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include \"udfdecl.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int udf_update_inode(struct inode *, int);",
      "static int udf_sync_inode(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&iinfo->i_data_sem"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udf_truncate_extents",
          "args": [
            "inode"
          ],
          "line": 178
        },
        "resolved": true,
        "details": {
          "function_name": "udf_truncate_extents",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/truncate.c",
          "lines": "203-287",
          "snippet": "void udf_truncate_extents(struct inode *inode)\n{\n\tstruct extent_position epos;\n\tstruct kernel_lb_addr eloc, neloc = {};\n\tuint32_t elen, nelen = 0, indirect_ext_len = 0, lenalloc;\n\tint8_t etype;\n\tstruct super_block *sb = inode->i_sb;\n\tsector_t first_block = inode->i_size >> sb->s_blocksize_bits, offset;\n\tloff_t byte_offset;\n\tint adsize;\n\tstruct udf_inode_info *iinfo = UDF_I(inode);\n\n\tif (iinfo->i_alloc_type == ICBTAG_FLAG_AD_SHORT)\n\t\tadsize = sizeof(struct short_ad);\n\telse if (iinfo->i_alloc_type == ICBTAG_FLAG_AD_LONG)\n\t\tadsize = sizeof(struct long_ad);\n\telse\n\t\tBUG();\n\n\tetype = inode_bmap(inode, first_block, &epos, &eloc, &elen, &offset);\n\tbyte_offset = (offset << sb->s_blocksize_bits) +\n\t\t(inode->i_size & (sb->s_blocksize - 1));\n\tif (etype == -1) {\n\t\t/* We should extend the file? */\n\t\tWARN_ON(byte_offset);\n\t\treturn;\n\t}\n\tepos.offset -= adsize;\n\textent_trunc(inode, &epos, &eloc, etype, elen, byte_offset);\n\tepos.offset += adsize;\n\tif (byte_offset)\n\t\tlenalloc = epos.offset;\n\telse\n\t\tlenalloc = epos.offset - adsize;\n\n\tif (!epos.bh)\n\t\tlenalloc -= udf_file_entry_alloc_offset(inode);\n\telse\n\t\tlenalloc -= sizeof(struct allocExtDesc);\n\n\twhile ((etype = udf_current_aext(inode, &epos, &eloc,\n\t\t\t\t\t &elen, 0)) != -1) {\n\t\tif (etype == (EXT_NEXT_EXTENT_ALLOCDECS >> 30)) {\n\t\t\tudf_write_aext(inode, &epos, &neloc, nelen, 0);\n\t\t\tif (indirect_ext_len) {\n\t\t\t\t/* We managed to free all extents in the\n\t\t\t\t * indirect extent - free it too */\n\t\t\t\tBUG_ON(!epos.bh);\n\t\t\t\tudf_free_blocks(sb, NULL, &epos.block,\n\t\t\t\t\t\t0, indirect_ext_len);\n\t\t\t} else if (!epos.bh) {\n\t\t\t\tiinfo->i_lenAlloc = lenalloc;\n\t\t\t\tmark_inode_dirty(inode);\n\t\t\t} else\n\t\t\t\tudf_update_alloc_ext_desc(inode,\n\t\t\t\t\t\t&epos, lenalloc);\n\t\t\tbrelse(epos.bh);\n\t\t\tepos.offset = sizeof(struct allocExtDesc);\n\t\t\tepos.block = eloc;\n\t\t\tepos.bh = udf_tread(sb,\n\t\t\t\t\tudf_get_lb_pblock(sb, &eloc, 0));\n\t\t\tif (elen)\n\t\t\t\tindirect_ext_len =\n\t\t\t\t\t(elen + sb->s_blocksize - 1) >>\n\t\t\t\t\tsb->s_blocksize_bits;\n\t\t\telse\n\t\t\t\tindirect_ext_len = 1;\n\t\t} else {\n\t\t\textent_trunc(inode, &epos, &eloc, etype, elen, 0);\n\t\t\tepos.offset += adsize;\n\t\t}\n\t}\n\n\tif (indirect_ext_len) {\n\t\tBUG_ON(!epos.bh);\n\t\tudf_free_blocks(sb, NULL, &epos.block, 0, indirect_ext_len);\n\t} else if (!epos.bh) {\n\t\tiinfo->i_lenAlloc = lenalloc;\n\t\tmark_inode_dirty(inode);\n\t} else\n\t\tudf_update_alloc_ext_desc(inode, &epos, lenalloc);\n\tiinfo->i_lenExtents = inode->i_size;\n\n\tbrelse(epos.bh);\n}",
          "includes": [
            "#include \"udf_sb.h\"",
            "#include \"udf_i.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/buffer_head.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include \"udfdecl.h\"\n\nvoid udf_truncate_extents(struct inode *inode)\n{\n\tstruct extent_position epos;\n\tstruct kernel_lb_addr eloc, neloc = {};\n\tuint32_t elen, nelen = 0, indirect_ext_len = 0, lenalloc;\n\tint8_t etype;\n\tstruct super_block *sb = inode->i_sb;\n\tsector_t first_block = inode->i_size >> sb->s_blocksize_bits, offset;\n\tloff_t byte_offset;\n\tint adsize;\n\tstruct udf_inode_info *iinfo = UDF_I(inode);\n\n\tif (iinfo->i_alloc_type == ICBTAG_FLAG_AD_SHORT)\n\t\tadsize = sizeof(struct short_ad);\n\telse if (iinfo->i_alloc_type == ICBTAG_FLAG_AD_LONG)\n\t\tadsize = sizeof(struct long_ad);\n\telse\n\t\tBUG();\n\n\tetype = inode_bmap(inode, first_block, &epos, &eloc, &elen, &offset);\n\tbyte_offset = (offset << sb->s_blocksize_bits) +\n\t\t(inode->i_size & (sb->s_blocksize - 1));\n\tif (etype == -1) {\n\t\t/* We should extend the file? */\n\t\tWARN_ON(byte_offset);\n\t\treturn;\n\t}\n\tepos.offset -= adsize;\n\textent_trunc(inode, &epos, &eloc, etype, elen, byte_offset);\n\tepos.offset += adsize;\n\tif (byte_offset)\n\t\tlenalloc = epos.offset;\n\telse\n\t\tlenalloc = epos.offset - adsize;\n\n\tif (!epos.bh)\n\t\tlenalloc -= udf_file_entry_alloc_offset(inode);\n\telse\n\t\tlenalloc -= sizeof(struct allocExtDesc);\n\n\twhile ((etype = udf_current_aext(inode, &epos, &eloc,\n\t\t\t\t\t &elen, 0)) != -1) {\n\t\tif (etype == (EXT_NEXT_EXTENT_ALLOCDECS >> 30)) {\n\t\t\tudf_write_aext(inode, &epos, &neloc, nelen, 0);\n\t\t\tif (indirect_ext_len) {\n\t\t\t\t/* We managed to free all extents in the\n\t\t\t\t * indirect extent - free it too */\n\t\t\t\tBUG_ON(!epos.bh);\n\t\t\t\tudf_free_blocks(sb, NULL, &epos.block,\n\t\t\t\t\t\t0, indirect_ext_len);\n\t\t\t} else if (!epos.bh) {\n\t\t\t\tiinfo->i_lenAlloc = lenalloc;\n\t\t\t\tmark_inode_dirty(inode);\n\t\t\t} else\n\t\t\t\tudf_update_alloc_ext_desc(inode,\n\t\t\t\t\t\t&epos, lenalloc);\n\t\t\tbrelse(epos.bh);\n\t\t\tepos.offset = sizeof(struct allocExtDesc);\n\t\t\tepos.block = eloc;\n\t\t\tepos.bh = udf_tread(sb,\n\t\t\t\t\tudf_get_lb_pblock(sb, &eloc, 0));\n\t\t\tif (elen)\n\t\t\t\tindirect_ext_len =\n\t\t\t\t\t(elen + sb->s_blocksize - 1) >>\n\t\t\t\t\tsb->s_blocksize_bits;\n\t\t\telse\n\t\t\t\tindirect_ext_len = 1;\n\t\t} else {\n\t\t\textent_trunc(inode, &epos, &eloc, etype, elen, 0);\n\t\t\tepos.offset += adsize;\n\t\t}\n\t}\n\n\tif (indirect_ext_len) {\n\t\tBUG_ON(!epos.bh);\n\t\tudf_free_blocks(sb, NULL, &epos.block, 0, indirect_ext_len);\n\t} else if (!epos.bh) {\n\t\tiinfo->i_lenAlloc = lenalloc;\n\t\tmark_inode_dirty(inode);\n\t} else\n\t\tudf_update_alloc_ext_desc(inode, &epos, lenalloc);\n\tiinfo->i_lenExtents = inode->i_size;\n\n\tbrelse(epos.bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_clear_extent_cache",
          "args": [
            "inode"
          ],
          "line": 177
        },
        "resolved": true,
        "details": {
          "function_name": "udf_clear_extent_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/inode.c",
          "lines": "81-88",
          "snippet": "static void udf_clear_extent_cache(struct inode *inode)\n{\n\tstruct udf_inode_info *iinfo = UDF_I(inode);\n\n\tspin_lock(&iinfo->i_extent_cache_lock);\n\t__udf_clear_extent_cache(inode);\n\tspin_unlock(&iinfo->i_extent_cache_lock);\n}",
          "includes": [
            "#include \"udf_sb.h\"",
            "#include \"udf_i.h\"",
            "#include <linux/aio.h>",
            "#include <linux/mpage.h>",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int udf_update_inode(struct inode *, int);",
            "static int udf_sync_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/crc-itu-t.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include \"udfdecl.h\"\n\nstatic int udf_update_inode(struct inode *, int);\nstatic int udf_sync_inode(struct inode *inode);\n\nstatic void udf_clear_extent_cache(struct inode *inode)\n{\n\tstruct udf_inode_info *iinfo = UDF_I(inode);\n\n\tspin_lock(&iinfo->i_extent_cache_lock);\n\t__udf_clear_extent_cache(inode);\n\tspin_unlock(&iinfo->i_extent_cache_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&iinfo->i_data_sem"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "truncate_pagecache",
          "args": [
            "inode",
            "isize"
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UDF_I",
          "args": [
            "inode"
          ],
          "line": 170
        },
        "resolved": true,
        "details": {
          "function_name": "UDF_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/udf_i.h",
          "lines": "57-60",
          "snippet": "static inline struct udf_inode_info *UDF_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct udf_inode_info, vfs_inode);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline struct udf_inode_info *UDF_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct udf_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/crc-itu-t.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include \"udfdecl.h\"\n\nstatic int udf_update_inode(struct inode *, int);\nstatic int udf_sync_inode(struct inode *inode);\n\nstatic void udf_write_failed(struct address_space *mapping, loff_t to)\n{\n\tstruct inode *inode = mapping->host;\n\tstruct udf_inode_info *iinfo = UDF_I(inode);\n\tloff_t isize = inode->i_size;\n\n\tif (to > isize) {\n\t\ttruncate_pagecache(inode, isize);\n\t\tif (iinfo->i_alloc_type != ICBTAG_FLAG_AD_IN_ICB) {\n\t\t\tdown_write(&iinfo->i_data_sem);\n\t\t\tudf_clear_extent_cache(inode);\n\t\t\tudf_truncate_extents(inode);\n\t\t\tup_write(&iinfo->i_data_sem);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "udf_evict_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/inode.c",
    "lines": "139-165",
    "snippet": "void udf_evict_inode(struct inode *inode)\n{\n\tstruct udf_inode_info *iinfo = UDF_I(inode);\n\tint want_delete = 0;\n\n\tif (!inode->i_nlink && !is_bad_inode(inode)) {\n\t\twant_delete = 1;\n\t\tudf_setsize(inode, 0);\n\t\tudf_update_inode(inode, IS_SYNC(inode));\n\t}\n\ttruncate_inode_pages_final(&inode->i_data);\n\tinvalidate_inode_buffers(inode);\n\tclear_inode(inode);\n\tif (iinfo->i_alloc_type != ICBTAG_FLAG_AD_IN_ICB &&\n\t    inode->i_size != iinfo->i_lenExtents) {\n\t\tudf_warn(inode->i_sb, \"Inode %lu (mode %o) has inode size %llu different from extent length %llu. Filesystem need not be standards compliant.\\n\",\n\t\t\t inode->i_ino, inode->i_mode,\n\t\t\t (unsigned long long)inode->i_size,\n\t\t\t (unsigned long long)iinfo->i_lenExtents);\n\t}\n\tkfree(iinfo->i_ext.i_data);\n\tiinfo->i_ext.i_data = NULL;\n\tudf_clear_extent_cache(inode);\n\tif (want_delete) {\n\t\tudf_free_inode(inode);\n\t}\n}",
    "includes": [
      "#include \"udf_sb.h\"",
      "#include \"udf_i.h\"",
      "#include <linux/aio.h>",
      "#include <linux/mpage.h>",
      "#include <linux/crc-itu-t.h>",
      "#include <linux/slab.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include \"udfdecl.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int udf_update_inode(struct inode *, int);",
      "static int udf_sync_inode(struct inode *inode);",
      "static int udf_alloc_i_data(struct inode *inode, size_t size);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "udf_free_inode",
          "args": [
            "inode"
          ],
          "line": 163
        },
        "resolved": true,
        "details": {
          "function_name": "udf_free_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/ialloc.c",
          "lines": "29-46",
          "snippet": "void udf_free_inode(struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct udf_sb_info *sbi = UDF_SB(sb);\n\tstruct logicalVolIntegrityDescImpUse *lvidiu = udf_sb_lvidiu(sb);\n\n\tif (lvidiu) {\n\t\tmutex_lock(&sbi->s_alloc_mutex);\n\t\tif (S_ISDIR(inode->i_mode))\n\t\t\tle32_add_cpu(&lvidiu->numDirs, -1);\n\t\telse\n\t\t\tle32_add_cpu(&lvidiu->numFiles, -1);\n\t\tudf_updated_lvid(sb);\n\t\tmutex_unlock(&sbi->s_alloc_mutex);\n\t}\n\n\tudf_free_blocks(sb, NULL, &UDF_I(inode)->i_location, 0, 1);\n}",
          "includes": [
            "#include \"udf_sb.h\"",
            "#include \"udf_i.h\"",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include \"udfdecl.h\"\n\nvoid udf_free_inode(struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct udf_sb_info *sbi = UDF_SB(sb);\n\tstruct logicalVolIntegrityDescImpUse *lvidiu = udf_sb_lvidiu(sb);\n\n\tif (lvidiu) {\n\t\tmutex_lock(&sbi->s_alloc_mutex);\n\t\tif (S_ISDIR(inode->i_mode))\n\t\t\tle32_add_cpu(&lvidiu->numDirs, -1);\n\t\telse\n\t\t\tle32_add_cpu(&lvidiu->numFiles, -1);\n\t\tudf_updated_lvid(sb);\n\t\tmutex_unlock(&sbi->s_alloc_mutex);\n\t}\n\n\tudf_free_blocks(sb, NULL, &UDF_I(inode)->i_location, 0, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_clear_extent_cache",
          "args": [
            "inode"
          ],
          "line": 161
        },
        "resolved": true,
        "details": {
          "function_name": "udf_clear_extent_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/inode.c",
          "lines": "81-88",
          "snippet": "static void udf_clear_extent_cache(struct inode *inode)\n{\n\tstruct udf_inode_info *iinfo = UDF_I(inode);\n\n\tspin_lock(&iinfo->i_extent_cache_lock);\n\t__udf_clear_extent_cache(inode);\n\tspin_unlock(&iinfo->i_extent_cache_lock);\n}",
          "includes": [
            "#include \"udf_sb.h\"",
            "#include \"udf_i.h\"",
            "#include <linux/aio.h>",
            "#include <linux/mpage.h>",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int udf_update_inode(struct inode *, int);",
            "static int udf_sync_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/crc-itu-t.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include \"udfdecl.h\"\n\nstatic int udf_update_inode(struct inode *, int);\nstatic int udf_sync_inode(struct inode *inode);\n\nstatic void udf_clear_extent_cache(struct inode *inode)\n{\n\tstruct udf_inode_info *iinfo = UDF_I(inode);\n\n\tspin_lock(&iinfo->i_extent_cache_lock);\n\t__udf_clear_extent_cache(inode);\n\tspin_unlock(&iinfo->i_extent_cache_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "iinfo->i_ext.i_data"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udf_warn",
          "args": [
            "inode->i_sb",
            "\"Inode %lu (mode %o) has inode size %llu different from extent length %llu. Filesystem need not be standards compliant.\\n\"",
            "inode->i_ino",
            "inode->i_mode",
            "(unsigned long long)inode->i_size",
            "(unsigned long long)iinfo->i_lenExtents"
          ],
          "line": 154
        },
        "resolved": true,
        "details": {
          "function_name": "_udf_warn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/super.c",
          "lines": "2272-2286",
          "snippet": "void _udf_warn(struct super_block *sb, const char *function,\n\t       const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tpr_warn(\"warning (device %s): %s: %pV\", sb->s_id, function, &vaf);\n\n\tva_end(args);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/init.h>",
            "#include \"udf_i.h\"",
            "#include \"udf_sb.h\"",
            "#include <asm/byteorder.h>",
            "#include <linux/log2.h>",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/errno.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/vfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/nls.h>",
            "#include <linux/cdrom.h>",
            "#include <linux/stat.h>",
            "#include <linux/parser.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int udf_fill_super(struct super_block *, void *, int);",
            "static void udf_put_super(struct super_block *);",
            "static int udf_sync_fs(struct super_block *, int);",
            "static int udf_remount_fs(struct super_block *, int *, char *);",
            "static void udf_open_lvid(struct super_block *);",
            "static void udf_close_lvid(struct super_block *);",
            "static unsigned int udf_count_free(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/init.h>\n#include \"udf_i.h\"\n#include \"udf_sb.h\"\n#include <asm/byteorder.h>\n#include <linux/log2.h>\n#include <linux/crc-itu-t.h>\n#include <linux/bitmap.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/errno.h>\n#include <linux/vmalloc.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/nls.h>\n#include <linux/cdrom.h>\n#include <linux/stat.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include \"udfdecl.h\"\n\nstatic int udf_fill_super(struct super_block *, void *, int);\nstatic void udf_put_super(struct super_block *);\nstatic int udf_sync_fs(struct super_block *, int);\nstatic int udf_remount_fs(struct super_block *, int *, char *);\nstatic void udf_open_lvid(struct super_block *);\nstatic void udf_close_lvid(struct super_block *);\nstatic unsigned int udf_count_free(struct super_block *);\n\nvoid _udf_warn(struct super_block *sb, const char *function,\n\t       const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tpr_warn(\"warning (device %s): %s: %pV\", sb->s_id, function, &vaf);\n\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_inode",
          "args": [
            "inode"
          ],
          "line": 151
        },
        "resolved": true,
        "details": {
          "function_name": "clear_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "488-505",
          "snippet": "void clear_inode(struct inode *inode)\n{\n\tmight_sleep();\n\t/*\n\t * We have to cycle tree_lock here because reclaim can be still in the\n\t * process of removing the last page (in __delete_from_page_cache())\n\t * and we must not free mapping under it.\n\t */\n\tspin_lock_irq(&inode->i_data.tree_lock);\n\tBUG_ON(inode->i_data.nrpages);\n\tBUG_ON(inode->i_data.nrshadows);\n\tspin_unlock_irq(&inode->i_data.tree_lock);\n\tBUG_ON(!list_empty(&inode->i_data.private_list));\n\tBUG_ON(!(inode->i_state & I_FREEING));\n\tBUG_ON(inode->i_state & I_CLEAR);\n\t/* don't need i_lock here, no concurrent mods to i_state */\n\tinode->i_state = I_FREEING | I_CLEAR;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid clear_inode(struct inode *inode)\n{\n\tmight_sleep();\n\t/*\n\t * We have to cycle tree_lock here because reclaim can be still in the\n\t * process of removing the last page (in __delete_from_page_cache())\n\t * and we must not free mapping under it.\n\t */\n\tspin_lock_irq(&inode->i_data.tree_lock);\n\tBUG_ON(inode->i_data.nrpages);\n\tBUG_ON(inode->i_data.nrshadows);\n\tspin_unlock_irq(&inode->i_data.tree_lock);\n\tBUG_ON(!list_empty(&inode->i_data.private_list));\n\tBUG_ON(!(inode->i_state & I_FREEING));\n\tBUG_ON(inode->i_state & I_CLEAR);\n\t/* don't need i_lock here, no concurrent mods to i_state */\n\tinode->i_state = I_FREEING | I_CLEAR;\n}"
        }
      },
      {
        "call_info": {
          "callee": "invalidate_inode_buffers",
          "args": [
            "inode"
          ],
          "line": 150
        },
        "resolved": true,
        "details": {
          "function_name": "invalidate_inode_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "802-814",
          "snippet": "void invalidate_inode_buffers(struct inode *inode)\n{\n\tif (inode_has_buffers(inode)) {\n\t\tstruct address_space *mapping = &inode->i_data;\n\t\tstruct list_head *list = &mapping->private_list;\n\t\tstruct address_space *buffer_mapping = mapping->private_data;\n\n\t\tspin_lock(&buffer_mapping->private_lock);\n\t\twhile (!list_empty(list))\n\t\t\t__remove_assoc_queue(BH_ENTRY(list->next));\n\t\tspin_unlock(&buffer_mapping->private_lock);\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int fsync_buffers_list(spinlock_t *lock, struct list_head *list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nstatic int fsync_buffers_list(spinlock_t *lock, struct list_head *list);\n\nvoid invalidate_inode_buffers(struct inode *inode)\n{\n\tif (inode_has_buffers(inode)) {\n\t\tstruct address_space *mapping = &inode->i_data;\n\t\tstruct list_head *list = &mapping->private_list;\n\t\tstruct address_space *buffer_mapping = mapping->private_data;\n\n\t\tspin_lock(&buffer_mapping->private_lock);\n\t\twhile (!list_empty(list))\n\t\t\t__remove_assoc_queue(BH_ENTRY(list->next));\n\t\tspin_unlock(&buffer_mapping->private_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "truncate_inode_pages_final",
          "args": [
            "&inode->i_data"
          ],
          "line": 149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udf_update_inode",
          "args": [
            "inode",
            "IS_SYNC(inode)"
          ],
          "line": 147
        },
        "resolved": true,
        "details": {
          "function_name": "udf_update_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/inode.c",
          "lines": "1622-1850",
          "snippet": "static int udf_update_inode(struct inode *inode, int do_sync)\n{\n\tstruct buffer_head *bh = NULL;\n\tstruct fileEntry *fe;\n\tstruct extendedFileEntry *efe;\n\tuint64_t lb_recorded;\n\tuint32_t udfperms;\n\tuint16_t icbflags;\n\tuint16_t crclen;\n\tint err = 0;\n\tstruct udf_sb_info *sbi = UDF_SB(inode->i_sb);\n\tunsigned char blocksize_bits = inode->i_sb->s_blocksize_bits;\n\tstruct udf_inode_info *iinfo = UDF_I(inode);\n\n\tbh = udf_tgetblk(inode->i_sb,\n\t\t\tudf_get_lb_pblock(inode->i_sb, &iinfo->i_location, 0));\n\tif (!bh) {\n\t\tudf_debug(\"getblk failure\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tlock_buffer(bh);\n\tmemset(bh->b_data, 0, inode->i_sb->s_blocksize);\n\tfe = (struct fileEntry *)bh->b_data;\n\tefe = (struct extendedFileEntry *)bh->b_data;\n\n\tif (iinfo->i_use) {\n\t\tstruct unallocSpaceEntry *use =\n\t\t\t(struct unallocSpaceEntry *)bh->b_data;\n\n\t\tuse->lengthAllocDescs = cpu_to_le32(iinfo->i_lenAlloc);\n\t\tmemcpy(bh->b_data + sizeof(struct unallocSpaceEntry),\n\t\t       iinfo->i_ext.i_data, inode->i_sb->s_blocksize -\n\t\t\t\t\tsizeof(struct unallocSpaceEntry));\n\t\tuse->descTag.tagIdent = cpu_to_le16(TAG_IDENT_USE);\n\t\tuse->descTag.tagLocation =\n\t\t\t\tcpu_to_le32(iinfo->i_location.logicalBlockNum);\n\t\tcrclen = sizeof(struct unallocSpaceEntry) +\n\t\t\t\tiinfo->i_lenAlloc - sizeof(struct tag);\n\t\tuse->descTag.descCRCLength = cpu_to_le16(crclen);\n\t\tuse->descTag.descCRC = cpu_to_le16(crc_itu_t(0, (char *)use +\n\t\t\t\t\t\t\t   sizeof(struct tag),\n\t\t\t\t\t\t\t   crclen));\n\t\tuse->descTag.tagChecksum = udf_tag_checksum(&use->descTag);\n\n\t\tgoto out;\n\t}\n\n\tif (UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_UID_FORGET))\n\t\tfe->uid = cpu_to_le32(-1);\n\telse\n\t\tfe->uid = cpu_to_le32(i_uid_read(inode));\n\n\tif (UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_GID_FORGET))\n\t\tfe->gid = cpu_to_le32(-1);\n\telse\n\t\tfe->gid = cpu_to_le32(i_gid_read(inode));\n\n\tudfperms = ((inode->i_mode & S_IRWXO)) |\n\t\t   ((inode->i_mode & S_IRWXG) << 2) |\n\t\t   ((inode->i_mode & S_IRWXU) << 4);\n\n\tudfperms |= (le32_to_cpu(fe->permissions) &\n\t\t    (FE_PERM_O_DELETE | FE_PERM_O_CHATTR |\n\t\t     FE_PERM_G_DELETE | FE_PERM_G_CHATTR |\n\t\t     FE_PERM_U_DELETE | FE_PERM_U_CHATTR));\n\tfe->permissions = cpu_to_le32(udfperms);\n\n\tif (S_ISDIR(inode->i_mode) && inode->i_nlink > 0)\n\t\tfe->fileLinkCount = cpu_to_le16(inode->i_nlink - 1);\n\telse\n\t\tfe->fileLinkCount = cpu_to_le16(inode->i_nlink);\n\n\tfe->informationLength = cpu_to_le64(inode->i_size);\n\n\tif (S_ISCHR(inode->i_mode) || S_ISBLK(inode->i_mode)) {\n\t\tstruct regid *eid;\n\t\tstruct deviceSpec *dsea =\n\t\t\t(struct deviceSpec *)udf_get_extendedattr(inode, 12, 1);\n\t\tif (!dsea) {\n\t\t\tdsea = (struct deviceSpec *)\n\t\t\t\tudf_add_extendedattr(inode,\n\t\t\t\t\t\t     sizeof(struct deviceSpec) +\n\t\t\t\t\t\t     sizeof(struct regid), 12, 0x3);\n\t\t\tdsea->attrType = cpu_to_le32(12);\n\t\t\tdsea->attrSubtype = 1;\n\t\t\tdsea->attrLength = cpu_to_le32(\n\t\t\t\t\t\tsizeof(struct deviceSpec) +\n\t\t\t\t\t\tsizeof(struct regid));\n\t\t\tdsea->impUseLength = cpu_to_le32(sizeof(struct regid));\n\t\t}\n\t\teid = (struct regid *)dsea->impUse;\n\t\tmemset(eid, 0, sizeof(struct regid));\n\t\tstrcpy(eid->ident, UDF_ID_DEVELOPER);\n\t\teid->identSuffix[0] = UDF_OS_CLASS_UNIX;\n\t\teid->identSuffix[1] = UDF_OS_ID_LINUX;\n\t\tdsea->majorDeviceIdent = cpu_to_le32(imajor(inode));\n\t\tdsea->minorDeviceIdent = cpu_to_le32(iminor(inode));\n\t}\n\n\tif (iinfo->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB)\n\t\tlb_recorded = 0; /* No extents => no blocks! */\n\telse\n\t\tlb_recorded =\n\t\t\t(inode->i_blocks + (1 << (blocksize_bits - 9)) - 1) >>\n\t\t\t(blocksize_bits - 9);\n\n\tif (iinfo->i_efe == 0) {\n\t\tmemcpy(bh->b_data + sizeof(struct fileEntry),\n\t\t       iinfo->i_ext.i_data,\n\t\t       inode->i_sb->s_blocksize - sizeof(struct fileEntry));\n\t\tfe->logicalBlocksRecorded = cpu_to_le64(lb_recorded);\n\n\t\tudf_time_to_disk_stamp(&fe->accessTime, inode->i_atime);\n\t\tudf_time_to_disk_stamp(&fe->modificationTime, inode->i_mtime);\n\t\tudf_time_to_disk_stamp(&fe->attrTime, inode->i_ctime);\n\t\tmemset(&(fe->impIdent), 0, sizeof(struct regid));\n\t\tstrcpy(fe->impIdent.ident, UDF_ID_DEVELOPER);\n\t\tfe->impIdent.identSuffix[0] = UDF_OS_CLASS_UNIX;\n\t\tfe->impIdent.identSuffix[1] = UDF_OS_ID_LINUX;\n\t\tfe->uniqueID = cpu_to_le64(iinfo->i_unique);\n\t\tfe->lengthExtendedAttr = cpu_to_le32(iinfo->i_lenEAttr);\n\t\tfe->lengthAllocDescs = cpu_to_le32(iinfo->i_lenAlloc);\n\t\tfe->checkpoint = cpu_to_le32(iinfo->i_checkpoint);\n\t\tfe->descTag.tagIdent = cpu_to_le16(TAG_IDENT_FE);\n\t\tcrclen = sizeof(struct fileEntry);\n\t} else {\n\t\tmemcpy(bh->b_data + sizeof(struct extendedFileEntry),\n\t\t       iinfo->i_ext.i_data,\n\t\t       inode->i_sb->s_blocksize -\n\t\t\t\t\tsizeof(struct extendedFileEntry));\n\t\tefe->objectSize = cpu_to_le64(inode->i_size);\n\t\tefe->logicalBlocksRecorded = cpu_to_le64(lb_recorded);\n\n\t\tif (iinfo->i_crtime.tv_sec > inode->i_atime.tv_sec ||\n\t\t    (iinfo->i_crtime.tv_sec == inode->i_atime.tv_sec &&\n\t\t     iinfo->i_crtime.tv_nsec > inode->i_atime.tv_nsec))\n\t\t\tiinfo->i_crtime = inode->i_atime;\n\n\t\tif (iinfo->i_crtime.tv_sec > inode->i_mtime.tv_sec ||\n\t\t    (iinfo->i_crtime.tv_sec == inode->i_mtime.tv_sec &&\n\t\t     iinfo->i_crtime.tv_nsec > inode->i_mtime.tv_nsec))\n\t\t\tiinfo->i_crtime = inode->i_mtime;\n\n\t\tif (iinfo->i_crtime.tv_sec > inode->i_ctime.tv_sec ||\n\t\t    (iinfo->i_crtime.tv_sec == inode->i_ctime.tv_sec &&\n\t\t     iinfo->i_crtime.tv_nsec > inode->i_ctime.tv_nsec))\n\t\t\tiinfo->i_crtime = inode->i_ctime;\n\n\t\tudf_time_to_disk_stamp(&efe->accessTime, inode->i_atime);\n\t\tudf_time_to_disk_stamp(&efe->modificationTime, inode->i_mtime);\n\t\tudf_time_to_disk_stamp(&efe->createTime, iinfo->i_crtime);\n\t\tudf_time_to_disk_stamp(&efe->attrTime, inode->i_ctime);\n\n\t\tmemset(&(efe->impIdent), 0, sizeof(struct regid));\n\t\tstrcpy(efe->impIdent.ident, UDF_ID_DEVELOPER);\n\t\tefe->impIdent.identSuffix[0] = UDF_OS_CLASS_UNIX;\n\t\tefe->impIdent.identSuffix[1] = UDF_OS_ID_LINUX;\n\t\tefe->uniqueID = cpu_to_le64(iinfo->i_unique);\n\t\tefe->lengthExtendedAttr = cpu_to_le32(iinfo->i_lenEAttr);\n\t\tefe->lengthAllocDescs = cpu_to_le32(iinfo->i_lenAlloc);\n\t\tefe->checkpoint = cpu_to_le32(iinfo->i_checkpoint);\n\t\tefe->descTag.tagIdent = cpu_to_le16(TAG_IDENT_EFE);\n\t\tcrclen = sizeof(struct extendedFileEntry);\n\t}\n\tif (iinfo->i_strat4096) {\n\t\tfe->icbTag.strategyType = cpu_to_le16(4096);\n\t\tfe->icbTag.strategyParameter = cpu_to_le16(1);\n\t\tfe->icbTag.numEntries = cpu_to_le16(2);\n\t} else {\n\t\tfe->icbTag.strategyType = cpu_to_le16(4);\n\t\tfe->icbTag.numEntries = cpu_to_le16(1);\n\t}\n\n\tif (S_ISDIR(inode->i_mode))\n\t\tfe->icbTag.fileType = ICBTAG_FILE_TYPE_DIRECTORY;\n\telse if (S_ISREG(inode->i_mode))\n\t\tfe->icbTag.fileType = ICBTAG_FILE_TYPE_REGULAR;\n\telse if (S_ISLNK(inode->i_mode))\n\t\tfe->icbTag.fileType = ICBTAG_FILE_TYPE_SYMLINK;\n\telse if (S_ISBLK(inode->i_mode))\n\t\tfe->icbTag.fileType = ICBTAG_FILE_TYPE_BLOCK;\n\telse if (S_ISCHR(inode->i_mode))\n\t\tfe->icbTag.fileType = ICBTAG_FILE_TYPE_CHAR;\n\telse if (S_ISFIFO(inode->i_mode))\n\t\tfe->icbTag.fileType = ICBTAG_FILE_TYPE_FIFO;\n\telse if (S_ISSOCK(inode->i_mode))\n\t\tfe->icbTag.fileType = ICBTAG_FILE_TYPE_SOCKET;\n\n\ticbflags =\tiinfo->i_alloc_type |\n\t\t\t((inode->i_mode & S_ISUID) ? ICBTAG_FLAG_SETUID : 0) |\n\t\t\t((inode->i_mode & S_ISGID) ? ICBTAG_FLAG_SETGID : 0) |\n\t\t\t((inode->i_mode & S_ISVTX) ? ICBTAG_FLAG_STICKY : 0) |\n\t\t\t(le16_to_cpu(fe->icbTag.flags) &\n\t\t\t\t~(ICBTAG_FLAG_AD_MASK | ICBTAG_FLAG_SETUID |\n\t\t\t\tICBTAG_FLAG_SETGID | ICBTAG_FLAG_STICKY));\n\n\tfe->icbTag.flags = cpu_to_le16(icbflags);\n\tif (sbi->s_udfrev >= 0x0200)\n\t\tfe->descTag.descVersion = cpu_to_le16(3);\n\telse\n\t\tfe->descTag.descVersion = cpu_to_le16(2);\n\tfe->descTag.tagSerialNum = cpu_to_le16(sbi->s_serial_number);\n\tfe->descTag.tagLocation = cpu_to_le32(\n\t\t\t\t\tiinfo->i_location.logicalBlockNum);\n\tcrclen += iinfo->i_lenEAttr + iinfo->i_lenAlloc - sizeof(struct tag);\n\tfe->descTag.descCRCLength = cpu_to_le16(crclen);\n\tfe->descTag.descCRC = cpu_to_le16(crc_itu_t(0, (char *)fe + sizeof(struct tag),\n\t\t\t\t\t\t  crclen));\n\tfe->descTag.tagChecksum = udf_tag_checksum(&fe->descTag);\n\nout:\n\tset_buffer_uptodate(bh);\n\tunlock_buffer(bh);\n\n\t/* write the data blocks */\n\tmark_buffer_dirty(bh);\n\tif (do_sync) {\n\t\tsync_dirty_buffer(bh);\n\t\tif (buffer_write_io_error(bh)) {\n\t\t\tudf_warn(inode->i_sb, \"IO error syncing udf inode [%08lx]\\n\",\n\t\t\t\t inode->i_ino);\n\t\t\terr = -EIO;\n\t\t}\n\t}\n\tbrelse(bh);\n\n\treturn err;\n}",
          "includes": [
            "#include \"udf_sb.h\"",
            "#include \"udf_i.h\"",
            "#include <linux/aio.h>",
            "#include <linux/mpage.h>",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static umode_t udf_convert_permissions(struct fileEntry *);",
            "static int udf_update_inode(struct inode *, int);",
            "static int udf_sync_inode(struct inode *inode);",
            "static int8_t udf_insert_aext(struct inode *, struct extent_position,\n\t\t\t      struct kernel_lb_addr, uint32_t);",
            "static int udf_get_block(struct inode *, sector_t, struct buffer_head *, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/crc-itu-t.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include \"udfdecl.h\"\n\nstatic umode_t udf_convert_permissions(struct fileEntry *);\nstatic int udf_update_inode(struct inode *, int);\nstatic int udf_sync_inode(struct inode *inode);\nstatic int8_t udf_insert_aext(struct inode *, struct extent_position,\n\t\t\t      struct kernel_lb_addr, uint32_t);\nstatic int udf_get_block(struct inode *, sector_t, struct buffer_head *, int);\n\nstatic int udf_update_inode(struct inode *inode, int do_sync)\n{\n\tstruct buffer_head *bh = NULL;\n\tstruct fileEntry *fe;\n\tstruct extendedFileEntry *efe;\n\tuint64_t lb_recorded;\n\tuint32_t udfperms;\n\tuint16_t icbflags;\n\tuint16_t crclen;\n\tint err = 0;\n\tstruct udf_sb_info *sbi = UDF_SB(inode->i_sb);\n\tunsigned char blocksize_bits = inode->i_sb->s_blocksize_bits;\n\tstruct udf_inode_info *iinfo = UDF_I(inode);\n\n\tbh = udf_tgetblk(inode->i_sb,\n\t\t\tudf_get_lb_pblock(inode->i_sb, &iinfo->i_location, 0));\n\tif (!bh) {\n\t\tudf_debug(\"getblk failure\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tlock_buffer(bh);\n\tmemset(bh->b_data, 0, inode->i_sb->s_blocksize);\n\tfe = (struct fileEntry *)bh->b_data;\n\tefe = (struct extendedFileEntry *)bh->b_data;\n\n\tif (iinfo->i_use) {\n\t\tstruct unallocSpaceEntry *use =\n\t\t\t(struct unallocSpaceEntry *)bh->b_data;\n\n\t\tuse->lengthAllocDescs = cpu_to_le32(iinfo->i_lenAlloc);\n\t\tmemcpy(bh->b_data + sizeof(struct unallocSpaceEntry),\n\t\t       iinfo->i_ext.i_data, inode->i_sb->s_blocksize -\n\t\t\t\t\tsizeof(struct unallocSpaceEntry));\n\t\tuse->descTag.tagIdent = cpu_to_le16(TAG_IDENT_USE);\n\t\tuse->descTag.tagLocation =\n\t\t\t\tcpu_to_le32(iinfo->i_location.logicalBlockNum);\n\t\tcrclen = sizeof(struct unallocSpaceEntry) +\n\t\t\t\tiinfo->i_lenAlloc - sizeof(struct tag);\n\t\tuse->descTag.descCRCLength = cpu_to_le16(crclen);\n\t\tuse->descTag.descCRC = cpu_to_le16(crc_itu_t(0, (char *)use +\n\t\t\t\t\t\t\t   sizeof(struct tag),\n\t\t\t\t\t\t\t   crclen));\n\t\tuse->descTag.tagChecksum = udf_tag_checksum(&use->descTag);\n\n\t\tgoto out;\n\t}\n\n\tif (UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_UID_FORGET))\n\t\tfe->uid = cpu_to_le32(-1);\n\telse\n\t\tfe->uid = cpu_to_le32(i_uid_read(inode));\n\n\tif (UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_GID_FORGET))\n\t\tfe->gid = cpu_to_le32(-1);\n\telse\n\t\tfe->gid = cpu_to_le32(i_gid_read(inode));\n\n\tudfperms = ((inode->i_mode & S_IRWXO)) |\n\t\t   ((inode->i_mode & S_IRWXG) << 2) |\n\t\t   ((inode->i_mode & S_IRWXU) << 4);\n\n\tudfperms |= (le32_to_cpu(fe->permissions) &\n\t\t    (FE_PERM_O_DELETE | FE_PERM_O_CHATTR |\n\t\t     FE_PERM_G_DELETE | FE_PERM_G_CHATTR |\n\t\t     FE_PERM_U_DELETE | FE_PERM_U_CHATTR));\n\tfe->permissions = cpu_to_le32(udfperms);\n\n\tif (S_ISDIR(inode->i_mode) && inode->i_nlink > 0)\n\t\tfe->fileLinkCount = cpu_to_le16(inode->i_nlink - 1);\n\telse\n\t\tfe->fileLinkCount = cpu_to_le16(inode->i_nlink);\n\n\tfe->informationLength = cpu_to_le64(inode->i_size);\n\n\tif (S_ISCHR(inode->i_mode) || S_ISBLK(inode->i_mode)) {\n\t\tstruct regid *eid;\n\t\tstruct deviceSpec *dsea =\n\t\t\t(struct deviceSpec *)udf_get_extendedattr(inode, 12, 1);\n\t\tif (!dsea) {\n\t\t\tdsea = (struct deviceSpec *)\n\t\t\t\tudf_add_extendedattr(inode,\n\t\t\t\t\t\t     sizeof(struct deviceSpec) +\n\t\t\t\t\t\t     sizeof(struct regid), 12, 0x3);\n\t\t\tdsea->attrType = cpu_to_le32(12);\n\t\t\tdsea->attrSubtype = 1;\n\t\t\tdsea->attrLength = cpu_to_le32(\n\t\t\t\t\t\tsizeof(struct deviceSpec) +\n\t\t\t\t\t\tsizeof(struct regid));\n\t\t\tdsea->impUseLength = cpu_to_le32(sizeof(struct regid));\n\t\t}\n\t\teid = (struct regid *)dsea->impUse;\n\t\tmemset(eid, 0, sizeof(struct regid));\n\t\tstrcpy(eid->ident, UDF_ID_DEVELOPER);\n\t\teid->identSuffix[0] = UDF_OS_CLASS_UNIX;\n\t\teid->identSuffix[1] = UDF_OS_ID_LINUX;\n\t\tdsea->majorDeviceIdent = cpu_to_le32(imajor(inode));\n\t\tdsea->minorDeviceIdent = cpu_to_le32(iminor(inode));\n\t}\n\n\tif (iinfo->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB)\n\t\tlb_recorded = 0; /* No extents => no blocks! */\n\telse\n\t\tlb_recorded =\n\t\t\t(inode->i_blocks + (1 << (blocksize_bits - 9)) - 1) >>\n\t\t\t(blocksize_bits - 9);\n\n\tif (iinfo->i_efe == 0) {\n\t\tmemcpy(bh->b_data + sizeof(struct fileEntry),\n\t\t       iinfo->i_ext.i_data,\n\t\t       inode->i_sb->s_blocksize - sizeof(struct fileEntry));\n\t\tfe->logicalBlocksRecorded = cpu_to_le64(lb_recorded);\n\n\t\tudf_time_to_disk_stamp(&fe->accessTime, inode->i_atime);\n\t\tudf_time_to_disk_stamp(&fe->modificationTime, inode->i_mtime);\n\t\tudf_time_to_disk_stamp(&fe->attrTime, inode->i_ctime);\n\t\tmemset(&(fe->impIdent), 0, sizeof(struct regid));\n\t\tstrcpy(fe->impIdent.ident, UDF_ID_DEVELOPER);\n\t\tfe->impIdent.identSuffix[0] = UDF_OS_CLASS_UNIX;\n\t\tfe->impIdent.identSuffix[1] = UDF_OS_ID_LINUX;\n\t\tfe->uniqueID = cpu_to_le64(iinfo->i_unique);\n\t\tfe->lengthExtendedAttr = cpu_to_le32(iinfo->i_lenEAttr);\n\t\tfe->lengthAllocDescs = cpu_to_le32(iinfo->i_lenAlloc);\n\t\tfe->checkpoint = cpu_to_le32(iinfo->i_checkpoint);\n\t\tfe->descTag.tagIdent = cpu_to_le16(TAG_IDENT_FE);\n\t\tcrclen = sizeof(struct fileEntry);\n\t} else {\n\t\tmemcpy(bh->b_data + sizeof(struct extendedFileEntry),\n\t\t       iinfo->i_ext.i_data,\n\t\t       inode->i_sb->s_blocksize -\n\t\t\t\t\tsizeof(struct extendedFileEntry));\n\t\tefe->objectSize = cpu_to_le64(inode->i_size);\n\t\tefe->logicalBlocksRecorded = cpu_to_le64(lb_recorded);\n\n\t\tif (iinfo->i_crtime.tv_sec > inode->i_atime.tv_sec ||\n\t\t    (iinfo->i_crtime.tv_sec == inode->i_atime.tv_sec &&\n\t\t     iinfo->i_crtime.tv_nsec > inode->i_atime.tv_nsec))\n\t\t\tiinfo->i_crtime = inode->i_atime;\n\n\t\tif (iinfo->i_crtime.tv_sec > inode->i_mtime.tv_sec ||\n\t\t    (iinfo->i_crtime.tv_sec == inode->i_mtime.tv_sec &&\n\t\t     iinfo->i_crtime.tv_nsec > inode->i_mtime.tv_nsec))\n\t\t\tiinfo->i_crtime = inode->i_mtime;\n\n\t\tif (iinfo->i_crtime.tv_sec > inode->i_ctime.tv_sec ||\n\t\t    (iinfo->i_crtime.tv_sec == inode->i_ctime.tv_sec &&\n\t\t     iinfo->i_crtime.tv_nsec > inode->i_ctime.tv_nsec))\n\t\t\tiinfo->i_crtime = inode->i_ctime;\n\n\t\tudf_time_to_disk_stamp(&efe->accessTime, inode->i_atime);\n\t\tudf_time_to_disk_stamp(&efe->modificationTime, inode->i_mtime);\n\t\tudf_time_to_disk_stamp(&efe->createTime, iinfo->i_crtime);\n\t\tudf_time_to_disk_stamp(&efe->attrTime, inode->i_ctime);\n\n\t\tmemset(&(efe->impIdent), 0, sizeof(struct regid));\n\t\tstrcpy(efe->impIdent.ident, UDF_ID_DEVELOPER);\n\t\tefe->impIdent.identSuffix[0] = UDF_OS_CLASS_UNIX;\n\t\tefe->impIdent.identSuffix[1] = UDF_OS_ID_LINUX;\n\t\tefe->uniqueID = cpu_to_le64(iinfo->i_unique);\n\t\tefe->lengthExtendedAttr = cpu_to_le32(iinfo->i_lenEAttr);\n\t\tefe->lengthAllocDescs = cpu_to_le32(iinfo->i_lenAlloc);\n\t\tefe->checkpoint = cpu_to_le32(iinfo->i_checkpoint);\n\t\tefe->descTag.tagIdent = cpu_to_le16(TAG_IDENT_EFE);\n\t\tcrclen = sizeof(struct extendedFileEntry);\n\t}\n\tif (iinfo->i_strat4096) {\n\t\tfe->icbTag.strategyType = cpu_to_le16(4096);\n\t\tfe->icbTag.strategyParameter = cpu_to_le16(1);\n\t\tfe->icbTag.numEntries = cpu_to_le16(2);\n\t} else {\n\t\tfe->icbTag.strategyType = cpu_to_le16(4);\n\t\tfe->icbTag.numEntries = cpu_to_le16(1);\n\t}\n\n\tif (S_ISDIR(inode->i_mode))\n\t\tfe->icbTag.fileType = ICBTAG_FILE_TYPE_DIRECTORY;\n\telse if (S_ISREG(inode->i_mode))\n\t\tfe->icbTag.fileType = ICBTAG_FILE_TYPE_REGULAR;\n\telse if (S_ISLNK(inode->i_mode))\n\t\tfe->icbTag.fileType = ICBTAG_FILE_TYPE_SYMLINK;\n\telse if (S_ISBLK(inode->i_mode))\n\t\tfe->icbTag.fileType = ICBTAG_FILE_TYPE_BLOCK;\n\telse if (S_ISCHR(inode->i_mode))\n\t\tfe->icbTag.fileType = ICBTAG_FILE_TYPE_CHAR;\n\telse if (S_ISFIFO(inode->i_mode))\n\t\tfe->icbTag.fileType = ICBTAG_FILE_TYPE_FIFO;\n\telse if (S_ISSOCK(inode->i_mode))\n\t\tfe->icbTag.fileType = ICBTAG_FILE_TYPE_SOCKET;\n\n\ticbflags =\tiinfo->i_alloc_type |\n\t\t\t((inode->i_mode & S_ISUID) ? ICBTAG_FLAG_SETUID : 0) |\n\t\t\t((inode->i_mode & S_ISGID) ? ICBTAG_FLAG_SETGID : 0) |\n\t\t\t((inode->i_mode & S_ISVTX) ? ICBTAG_FLAG_STICKY : 0) |\n\t\t\t(le16_to_cpu(fe->icbTag.flags) &\n\t\t\t\t~(ICBTAG_FLAG_AD_MASK | ICBTAG_FLAG_SETUID |\n\t\t\t\tICBTAG_FLAG_SETGID | ICBTAG_FLAG_STICKY));\n\n\tfe->icbTag.flags = cpu_to_le16(icbflags);\n\tif (sbi->s_udfrev >= 0x0200)\n\t\tfe->descTag.descVersion = cpu_to_le16(3);\n\telse\n\t\tfe->descTag.descVersion = cpu_to_le16(2);\n\tfe->descTag.tagSerialNum = cpu_to_le16(sbi->s_serial_number);\n\tfe->descTag.tagLocation = cpu_to_le32(\n\t\t\t\t\tiinfo->i_location.logicalBlockNum);\n\tcrclen += iinfo->i_lenEAttr + iinfo->i_lenAlloc - sizeof(struct tag);\n\tfe->descTag.descCRCLength = cpu_to_le16(crclen);\n\tfe->descTag.descCRC = cpu_to_le16(crc_itu_t(0, (char *)fe + sizeof(struct tag),\n\t\t\t\t\t\t  crclen));\n\tfe->descTag.tagChecksum = udf_tag_checksum(&fe->descTag);\n\nout:\n\tset_buffer_uptodate(bh);\n\tunlock_buffer(bh);\n\n\t/* write the data blocks */\n\tmark_buffer_dirty(bh);\n\tif (do_sync) {\n\t\tsync_dirty_buffer(bh);\n\t\tif (buffer_write_io_error(bh)) {\n\t\t\tudf_warn(inode->i_sb, \"IO error syncing udf inode [%08lx]\\n\",\n\t\t\t\t inode->i_ino);\n\t\t\terr = -EIO;\n\t\t}\n\t}\n\tbrelse(bh);\n\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_SYNC",
          "args": [
            "inode"
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udf_setsize",
          "args": [
            "inode",
            "0"
          ],
          "line": 146
        },
        "resolved": true,
        "details": {
          "function_name": "udf_setsize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/inode.c",
          "lines": "1207-1271",
          "snippet": "int udf_setsize(struct inode *inode, loff_t newsize)\n{\n\tint err;\n\tstruct udf_inode_info *iinfo;\n\tint bsize = 1 << inode->i_blkbits;\n\n\tif (!(S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode) ||\n\t      S_ISLNK(inode->i_mode)))\n\t\treturn -EINVAL;\n\tif (IS_APPEND(inode) || IS_IMMUTABLE(inode))\n\t\treturn -EPERM;\n\n\tiinfo = UDF_I(inode);\n\tif (newsize > inode->i_size) {\n\t\tdown_write(&iinfo->i_data_sem);\n\t\tif (iinfo->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB) {\n\t\t\tif (bsize <\n\t\t\t    (udf_file_entry_alloc_offset(inode) + newsize)) {\n\t\t\t\terr = udf_expand_file_adinicb(inode);\n\t\t\t\tif (err)\n\t\t\t\t\treturn err;\n\t\t\t\tdown_write(&iinfo->i_data_sem);\n\t\t\t} else {\n\t\t\t\tiinfo->i_lenAlloc = newsize;\n\t\t\t\tgoto set_size;\n\t\t\t}\n\t\t}\n\t\terr = udf_extend_file(inode, newsize);\n\t\tif (err) {\n\t\t\tup_write(&iinfo->i_data_sem);\n\t\t\treturn err;\n\t\t}\nset_size:\n\t\ttruncate_setsize(inode, newsize);\n\t\tup_write(&iinfo->i_data_sem);\n\t} else {\n\t\tif (iinfo->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB) {\n\t\t\tdown_write(&iinfo->i_data_sem);\n\t\t\tudf_clear_extent_cache(inode);\n\t\t\tmemset(iinfo->i_ext.i_data + iinfo->i_lenEAttr + newsize,\n\t\t\t       0x00, bsize - newsize -\n\t\t\t       udf_file_entry_alloc_offset(inode));\n\t\t\tiinfo->i_lenAlloc = newsize;\n\t\t\ttruncate_setsize(inode, newsize);\n\t\t\tup_write(&iinfo->i_data_sem);\n\t\t\tgoto update_time;\n\t\t}\n\t\terr = block_truncate_page(inode->i_mapping, newsize,\n\t\t\t\t\t  udf_get_block);\n\t\tif (err)\n\t\t\treturn err;\n\t\tdown_write(&iinfo->i_data_sem);\n\t\tudf_clear_extent_cache(inode);\n\t\ttruncate_setsize(inode, newsize);\n\t\tudf_truncate_extents(inode);\n\t\tup_write(&iinfo->i_data_sem);\n\t}\nupdate_time:\n\tinode->i_mtime = inode->i_ctime = current_fs_time(inode->i_sb);\n\tif (IS_SYNC(inode))\n\t\tudf_sync_inode(inode);\n\telse\n\t\tmark_inode_dirty(inode);\n\treturn 0;\n}",
          "includes": [
            "#include \"udf_sb.h\"",
            "#include \"udf_i.h\"",
            "#include <linux/aio.h>",
            "#include <linux/mpage.h>",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int udf_update_inode(struct inode *, int);",
            "static int udf_sync_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/crc-itu-t.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include \"udfdecl.h\"\n\nstatic int udf_update_inode(struct inode *, int);\nstatic int udf_sync_inode(struct inode *inode);\n\nint udf_setsize(struct inode *inode, loff_t newsize)\n{\n\tint err;\n\tstruct udf_inode_info *iinfo;\n\tint bsize = 1 << inode->i_blkbits;\n\n\tif (!(S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode) ||\n\t      S_ISLNK(inode->i_mode)))\n\t\treturn -EINVAL;\n\tif (IS_APPEND(inode) || IS_IMMUTABLE(inode))\n\t\treturn -EPERM;\n\n\tiinfo = UDF_I(inode);\n\tif (newsize > inode->i_size) {\n\t\tdown_write(&iinfo->i_data_sem);\n\t\tif (iinfo->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB) {\n\t\t\tif (bsize <\n\t\t\t    (udf_file_entry_alloc_offset(inode) + newsize)) {\n\t\t\t\terr = udf_expand_file_adinicb(inode);\n\t\t\t\tif (err)\n\t\t\t\t\treturn err;\n\t\t\t\tdown_write(&iinfo->i_data_sem);\n\t\t\t} else {\n\t\t\t\tiinfo->i_lenAlloc = newsize;\n\t\t\t\tgoto set_size;\n\t\t\t}\n\t\t}\n\t\terr = udf_extend_file(inode, newsize);\n\t\tif (err) {\n\t\t\tup_write(&iinfo->i_data_sem);\n\t\t\treturn err;\n\t\t}\nset_size:\n\t\ttruncate_setsize(inode, newsize);\n\t\tup_write(&iinfo->i_data_sem);\n\t} else {\n\t\tif (iinfo->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB) {\n\t\t\tdown_write(&iinfo->i_data_sem);\n\t\t\tudf_clear_extent_cache(inode);\n\t\t\tmemset(iinfo->i_ext.i_data + iinfo->i_lenEAttr + newsize,\n\t\t\t       0x00, bsize - newsize -\n\t\t\t       udf_file_entry_alloc_offset(inode));\n\t\t\tiinfo->i_lenAlloc = newsize;\n\t\t\ttruncate_setsize(inode, newsize);\n\t\t\tup_write(&iinfo->i_data_sem);\n\t\t\tgoto update_time;\n\t\t}\n\t\terr = block_truncate_page(inode->i_mapping, newsize,\n\t\t\t\t\t  udf_get_block);\n\t\tif (err)\n\t\t\treturn err;\n\t\tdown_write(&iinfo->i_data_sem);\n\t\tudf_clear_extent_cache(inode);\n\t\ttruncate_setsize(inode, newsize);\n\t\tudf_truncate_extents(inode);\n\t\tup_write(&iinfo->i_data_sem);\n\t}\nupdate_time:\n\tinode->i_mtime = inode->i_ctime = current_fs_time(inode->i_sb);\n\tif (IS_SYNC(inode))\n\t\tudf_sync_inode(inode);\n\telse\n\t\tmark_inode_dirty(inode);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_bad_inode",
          "args": [
            "inode"
          ],
          "line": 144
        },
        "resolved": true,
        "details": {
          "function_name": "is_bad_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/bad_inode.c",
          "lines": "195-198",
          "snippet": "int is_bad_inode(struct inode *inode)\n{\n\treturn (inode->i_op == &bad_inode_ops);\t\n}",
          "includes": [
            "#include <linux/poll.h>",
            "#include <linux/namei.h>",
            "#include <linux/time.h>",
            "#include <linux/stat.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct inode_operations bad_inode_ops =\n{\n\t.create\t\t= bad_inode_create,\n\t.lookup\t\t= bad_inode_lookup,\n\t.link\t\t= bad_inode_link,\n\t.unlink\t\t= bad_inode_unlink,\n\t.symlink\t= bad_inode_symlink,\n\t.mkdir\t\t= bad_inode_mkdir,\n\t.rmdir\t\t= bad_inode_rmdir,\n\t.mknod\t\t= bad_inode_mknod,\n\t.rename2\t= bad_inode_rename2,\n\t.readlink\t= bad_inode_readlink,\n\t/* follow_link must be no-op, otherwise unmounting this inode\n\t   won't work */\n\t/* put_link returns void */\n\t/* truncate returns void */\n\t.permission\t= bad_inode_permission,\n\t.getattr\t= bad_inode_getattr,\n\t.setattr\t= bad_inode_setattr,\n\t.setxattr\t= bad_inode_setxattr,\n\t.getxattr\t= bad_inode_getxattr,\n\t.listxattr\t= bad_inode_listxattr,\n\t.removexattr\t= bad_inode_removexattr,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/poll.h>\n#include <linux/namei.h>\n#include <linux/time.h>\n#include <linux/stat.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nstatic const struct inode_operations bad_inode_ops =\n{\n\t.create\t\t= bad_inode_create,\n\t.lookup\t\t= bad_inode_lookup,\n\t.link\t\t= bad_inode_link,\n\t.unlink\t\t= bad_inode_unlink,\n\t.symlink\t= bad_inode_symlink,\n\t.mkdir\t\t= bad_inode_mkdir,\n\t.rmdir\t\t= bad_inode_rmdir,\n\t.mknod\t\t= bad_inode_mknod,\n\t.rename2\t= bad_inode_rename2,\n\t.readlink\t= bad_inode_readlink,\n\t/* follow_link must be no-op, otherwise unmounting this inode\n\t   won't work */\n\t/* put_link returns void */\n\t/* truncate returns void */\n\t.permission\t= bad_inode_permission,\n\t.getattr\t= bad_inode_getattr,\n\t.setattr\t= bad_inode_setattr,\n\t.setxattr\t= bad_inode_setxattr,\n\t.getxattr\t= bad_inode_getxattr,\n\t.listxattr\t= bad_inode_listxattr,\n\t.removexattr\t= bad_inode_removexattr,\n};\n\nint is_bad_inode(struct inode *inode)\n{\n\treturn (inode->i_op == &bad_inode_ops);\t\n}"
        }
      },
      {
        "call_info": {
          "callee": "UDF_I",
          "args": [
            "inode"
          ],
          "line": 141
        },
        "resolved": true,
        "details": {
          "function_name": "UDF_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/udf_i.h",
          "lines": "57-60",
          "snippet": "static inline struct udf_inode_info *UDF_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct udf_inode_info, vfs_inode);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline struct udf_inode_info *UDF_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct udf_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/crc-itu-t.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include \"udfdecl.h\"\n\nstatic int udf_update_inode(struct inode *, int);\nstatic int udf_sync_inode(struct inode *inode);\nstatic int udf_alloc_i_data(struct inode *inode, size_t size);\n\nvoid udf_evict_inode(struct inode *inode)\n{\n\tstruct udf_inode_info *iinfo = UDF_I(inode);\n\tint want_delete = 0;\n\n\tif (!inode->i_nlink && !is_bad_inode(inode)) {\n\t\twant_delete = 1;\n\t\tudf_setsize(inode, 0);\n\t\tudf_update_inode(inode, IS_SYNC(inode));\n\t}\n\ttruncate_inode_pages_final(&inode->i_data);\n\tinvalidate_inode_buffers(inode);\n\tclear_inode(inode);\n\tif (iinfo->i_alloc_type != ICBTAG_FLAG_AD_IN_ICB &&\n\t    inode->i_size != iinfo->i_lenExtents) {\n\t\tudf_warn(inode->i_sb, \"Inode %lu (mode %o) has inode size %llu different from extent length %llu. Filesystem need not be standards compliant.\\n\",\n\t\t\t inode->i_ino, inode->i_mode,\n\t\t\t (unsigned long long)inode->i_size,\n\t\t\t (unsigned long long)iinfo->i_lenExtents);\n\t}\n\tkfree(iinfo->i_ext.i_data);\n\tiinfo->i_ext.i_data = NULL;\n\tudf_clear_extent_cache(inode);\n\tif (want_delete) {\n\t\tudf_free_inode(inode);\n\t}\n}"
  },
  {
    "function_name": "udf_update_extent_cache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/inode.c",
    "lines": "113-137",
    "snippet": "static void udf_update_extent_cache(struct inode *inode, loff_t estart,\n\t\t\t\t    struct extent_position *pos, int next_epos)\n{\n\tstruct udf_inode_info *iinfo = UDF_I(inode);\n\n\tspin_lock(&iinfo->i_extent_cache_lock);\n\t/* Invalidate previously cached extent */\n\t__udf_clear_extent_cache(inode);\n\tif (pos->bh)\n\t\tget_bh(pos->bh);\n\tmemcpy(&iinfo->cached_extent.epos, pos,\n\t       sizeof(struct extent_position));\n\tiinfo->cached_extent.lstart = estart;\n\tif (next_epos)\n\t\tswitch (iinfo->i_alloc_type) {\n\t\tcase ICBTAG_FLAG_AD_SHORT:\n\t\t\tiinfo->cached_extent.epos.offset -=\n\t\t\tsizeof(struct short_ad);\n\t\t\tbreak;\n\t\tcase ICBTAG_FLAG_AD_LONG:\n\t\t\tiinfo->cached_extent.epos.offset -=\n\t\t\tsizeof(struct long_ad);\n\t\t}\n\tspin_unlock(&iinfo->i_extent_cache_lock);\n}",
    "includes": [
      "#include \"udf_sb.h\"",
      "#include \"udf_i.h\"",
      "#include <linux/aio.h>",
      "#include <linux/mpage.h>",
      "#include <linux/crc-itu-t.h>",
      "#include <linux/slab.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include \"udfdecl.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int udf_update_inode(struct inode *, int);",
      "static int udf_sync_inode(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&iinfo->i_extent_cache_lock"
          ],
          "line": 136
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&iinfo->cached_extent.epos",
            "pos",
            "sizeof(struct extent_position)"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_bh",
          "args": [
            "pos->bh"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__udf_clear_extent_cache",
          "args": [
            "inode"
          ],
          "line": 120
        },
        "resolved": true,
        "details": {
          "function_name": "__udf_clear_extent_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/inode.c",
          "lines": "70-78",
          "snippet": "static void __udf_clear_extent_cache(struct inode *inode)\n{\n\tstruct udf_inode_info *iinfo = UDF_I(inode);\n\n\tif (iinfo->cached_extent.lstart != -1) {\n\t\tbrelse(iinfo->cached_extent.epos.bh);\n\t\tiinfo->cached_extent.lstart = -1;\n\t}\n}",
          "includes": [
            "#include \"udf_sb.h\"",
            "#include \"udf_i.h\"",
            "#include <linux/aio.h>",
            "#include <linux/mpage.h>",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int udf_update_inode(struct inode *, int);",
            "static int udf_sync_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/crc-itu-t.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include \"udfdecl.h\"\n\nstatic int udf_update_inode(struct inode *, int);\nstatic int udf_sync_inode(struct inode *inode);\n\nstatic void __udf_clear_extent_cache(struct inode *inode)\n{\n\tstruct udf_inode_info *iinfo = UDF_I(inode);\n\n\tif (iinfo->cached_extent.lstart != -1) {\n\t\tbrelse(iinfo->cached_extent.epos.bh);\n\t\tiinfo->cached_extent.lstart = -1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&iinfo->i_extent_cache_lock"
          ],
          "line": 118
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "UDF_I",
          "args": [
            "inode"
          ],
          "line": 116
        },
        "resolved": true,
        "details": {
          "function_name": "UDF_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/udf_i.h",
          "lines": "57-60",
          "snippet": "static inline struct udf_inode_info *UDF_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct udf_inode_info, vfs_inode);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline struct udf_inode_info *UDF_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct udf_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/crc-itu-t.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include \"udfdecl.h\"\n\nstatic int udf_update_inode(struct inode *, int);\nstatic int udf_sync_inode(struct inode *inode);\n\nstatic void udf_update_extent_cache(struct inode *inode, loff_t estart,\n\t\t\t\t    struct extent_position *pos, int next_epos)\n{\n\tstruct udf_inode_info *iinfo = UDF_I(inode);\n\n\tspin_lock(&iinfo->i_extent_cache_lock);\n\t/* Invalidate previously cached extent */\n\t__udf_clear_extent_cache(inode);\n\tif (pos->bh)\n\t\tget_bh(pos->bh);\n\tmemcpy(&iinfo->cached_extent.epos, pos,\n\t       sizeof(struct extent_position));\n\tiinfo->cached_extent.lstart = estart;\n\tif (next_epos)\n\t\tswitch (iinfo->i_alloc_type) {\n\t\tcase ICBTAG_FLAG_AD_SHORT:\n\t\t\tiinfo->cached_extent.epos.offset -=\n\t\t\tsizeof(struct short_ad);\n\t\t\tbreak;\n\t\tcase ICBTAG_FLAG_AD_LONG:\n\t\t\tiinfo->cached_extent.epos.offset -=\n\t\t\tsizeof(struct long_ad);\n\t\t}\n\tspin_unlock(&iinfo->i_extent_cache_lock);\n}"
  },
  {
    "function_name": "udf_read_extent_cache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/inode.c",
    "lines": "91-110",
    "snippet": "static int udf_read_extent_cache(struct inode *inode, loff_t bcount,\n\t\t\t\t loff_t *lbcount, struct extent_position *pos)\n{\n\tstruct udf_inode_info *iinfo = UDF_I(inode);\n\tint ret = 0;\n\n\tspin_lock(&iinfo->i_extent_cache_lock);\n\tif ((iinfo->cached_extent.lstart <= bcount) &&\n\t    (iinfo->cached_extent.lstart != -1)) {\n\t\t/* Cache hit */\n\t\t*lbcount = iinfo->cached_extent.lstart;\n\t\tmemcpy(pos, &iinfo->cached_extent.epos,\n\t\t       sizeof(struct extent_position));\n\t\tif (pos->bh)\n\t\t\tget_bh(pos->bh);\n\t\tret = 1;\n\t}\n\tspin_unlock(&iinfo->i_extent_cache_lock);\n\treturn ret;\n}",
    "includes": [
      "#include \"udf_sb.h\"",
      "#include \"udf_i.h\"",
      "#include <linux/aio.h>",
      "#include <linux/mpage.h>",
      "#include <linux/crc-itu-t.h>",
      "#include <linux/slab.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include \"udfdecl.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int udf_update_inode(struct inode *, int);",
      "static int udf_sync_inode(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&iinfo->i_extent_cache_lock"
          ],
          "line": 108
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_bh",
          "args": [
            "pos->bh"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "pos",
            "&iinfo->cached_extent.epos",
            "sizeof(struct extent_position)"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&iinfo->i_extent_cache_lock"
          ],
          "line": 97
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "UDF_I",
          "args": [
            "inode"
          ],
          "line": 94
        },
        "resolved": true,
        "details": {
          "function_name": "UDF_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/udf_i.h",
          "lines": "57-60",
          "snippet": "static inline struct udf_inode_info *UDF_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct udf_inode_info, vfs_inode);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline struct udf_inode_info *UDF_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct udf_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/crc-itu-t.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include \"udfdecl.h\"\n\nstatic int udf_update_inode(struct inode *, int);\nstatic int udf_sync_inode(struct inode *inode);\n\nstatic int udf_read_extent_cache(struct inode *inode, loff_t bcount,\n\t\t\t\t loff_t *lbcount, struct extent_position *pos)\n{\n\tstruct udf_inode_info *iinfo = UDF_I(inode);\n\tint ret = 0;\n\n\tspin_lock(&iinfo->i_extent_cache_lock);\n\tif ((iinfo->cached_extent.lstart <= bcount) &&\n\t    (iinfo->cached_extent.lstart != -1)) {\n\t\t/* Cache hit */\n\t\t*lbcount = iinfo->cached_extent.lstart;\n\t\tmemcpy(pos, &iinfo->cached_extent.epos,\n\t\t       sizeof(struct extent_position));\n\t\tif (pos->bh)\n\t\t\tget_bh(pos->bh);\n\t\tret = 1;\n\t}\n\tspin_unlock(&iinfo->i_extent_cache_lock);\n\treturn ret;\n}"
  },
  {
    "function_name": "udf_clear_extent_cache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/inode.c",
    "lines": "81-88",
    "snippet": "static void udf_clear_extent_cache(struct inode *inode)\n{\n\tstruct udf_inode_info *iinfo = UDF_I(inode);\n\n\tspin_lock(&iinfo->i_extent_cache_lock);\n\t__udf_clear_extent_cache(inode);\n\tspin_unlock(&iinfo->i_extent_cache_lock);\n}",
    "includes": [
      "#include \"udf_sb.h\"",
      "#include \"udf_i.h\"",
      "#include <linux/aio.h>",
      "#include <linux/mpage.h>",
      "#include <linux/crc-itu-t.h>",
      "#include <linux/slab.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include \"udfdecl.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int udf_update_inode(struct inode *, int);",
      "static int udf_sync_inode(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&iinfo->i_extent_cache_lock"
          ],
          "line": 87
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "__udf_clear_extent_cache",
          "args": [
            "inode"
          ],
          "line": 86
        },
        "resolved": true,
        "details": {
          "function_name": "__udf_clear_extent_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/inode.c",
          "lines": "70-78",
          "snippet": "static void __udf_clear_extent_cache(struct inode *inode)\n{\n\tstruct udf_inode_info *iinfo = UDF_I(inode);\n\n\tif (iinfo->cached_extent.lstart != -1) {\n\t\tbrelse(iinfo->cached_extent.epos.bh);\n\t\tiinfo->cached_extent.lstart = -1;\n\t}\n}",
          "includes": [
            "#include \"udf_sb.h\"",
            "#include \"udf_i.h\"",
            "#include <linux/aio.h>",
            "#include <linux/mpage.h>",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int udf_update_inode(struct inode *, int);",
            "static int udf_sync_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/crc-itu-t.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include \"udfdecl.h\"\n\nstatic int udf_update_inode(struct inode *, int);\nstatic int udf_sync_inode(struct inode *inode);\n\nstatic void __udf_clear_extent_cache(struct inode *inode)\n{\n\tstruct udf_inode_info *iinfo = UDF_I(inode);\n\n\tif (iinfo->cached_extent.lstart != -1) {\n\t\tbrelse(iinfo->cached_extent.epos.bh);\n\t\tiinfo->cached_extent.lstart = -1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&iinfo->i_extent_cache_lock"
          ],
          "line": 85
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "UDF_I",
          "args": [
            "inode"
          ],
          "line": 83
        },
        "resolved": true,
        "details": {
          "function_name": "UDF_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/udf_i.h",
          "lines": "57-60",
          "snippet": "static inline struct udf_inode_info *UDF_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct udf_inode_info, vfs_inode);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline struct udf_inode_info *UDF_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct udf_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/crc-itu-t.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include \"udfdecl.h\"\n\nstatic int udf_update_inode(struct inode *, int);\nstatic int udf_sync_inode(struct inode *inode);\n\nstatic void udf_clear_extent_cache(struct inode *inode)\n{\n\tstruct udf_inode_info *iinfo = UDF_I(inode);\n\n\tspin_lock(&iinfo->i_extent_cache_lock);\n\t__udf_clear_extent_cache(inode);\n\tspin_unlock(&iinfo->i_extent_cache_lock);\n}"
  },
  {
    "function_name": "__udf_clear_extent_cache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/inode.c",
    "lines": "70-78",
    "snippet": "static void __udf_clear_extent_cache(struct inode *inode)\n{\n\tstruct udf_inode_info *iinfo = UDF_I(inode);\n\n\tif (iinfo->cached_extent.lstart != -1) {\n\t\tbrelse(iinfo->cached_extent.epos.bh);\n\t\tiinfo->cached_extent.lstart = -1;\n\t}\n}",
    "includes": [
      "#include \"udf_sb.h\"",
      "#include \"udf_i.h\"",
      "#include <linux/aio.h>",
      "#include <linux/mpage.h>",
      "#include <linux/crc-itu-t.h>",
      "#include <linux/slab.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include \"udfdecl.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int udf_update_inode(struct inode *, int);",
      "static int udf_sync_inode(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "iinfo->cached_extent.epos.bh"
          ],
          "line": 75
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "UDF_I",
          "args": [
            "inode"
          ],
          "line": 72
        },
        "resolved": true,
        "details": {
          "function_name": "UDF_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/udf_i.h",
          "lines": "57-60",
          "snippet": "static inline struct udf_inode_info *UDF_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct udf_inode_info, vfs_inode);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline struct udf_inode_info *UDF_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct udf_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/crc-itu-t.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include \"udfdecl.h\"\n\nstatic int udf_update_inode(struct inode *, int);\nstatic int udf_sync_inode(struct inode *inode);\n\nstatic void __udf_clear_extent_cache(struct inode *inode)\n{\n\tstruct udf_inode_info *iinfo = UDF_I(inode);\n\n\tif (iinfo->cached_extent.lstart != -1) {\n\t\tbrelse(iinfo->cached_extent.epos.bh);\n\t\tiinfo->cached_extent.lstart = -1;\n\t}\n}"
  }
]