[
  {
    "function_name": "ext3_should_writeback_data",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
    "lines": "1321-1330",
    "snippet": "static inline int ext3_should_writeback_data(struct inode *inode)\n{\n\tif (!S_ISREG(inode->i_mode))\n\t\treturn 0;\n\tif (EXT3_I(inode)->i_flags & EXT3_JOURNAL_DATA_FL)\n\t\treturn 0;\n\tif (test_opt(inode->i_sb, DATA_FLAGS) == EXT3_MOUNT_WRITEBACK_DATA)\n\t\treturn 1;\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/ext3.h>",
      "#include <linux/blockgroup_lock.h>",
      "#include <linux/bug.h>",
      "#include <linux/magic.h>",
      "#include <linux/jbd.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [
      "#define EXT3_MOUNT_WRITEBACK_DATA\t0x00C00\t/* No data ordering */",
      "#define EXT3_JOURNAL_DATA_FL\t\t0x00004000 /* file data should be journaled */"
    ],
    "globals_used": [
      "extern void ext3_init_block_alloc_info(struct inode *);",
      "extern void ext3_free_inode (handle_t *, struct inode *);",
      "struct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);",
      "struct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);",
      "extern void ext3_evict_inode (struct inode *);",
      "extern int  ext3_sync_inode (handle_t *, struct inode *);",
      "extern void ext3_discard_reservation (struct inode *);",
      "extern void ext3_dirty_inode(struct inode *, int);",
      "extern int ext3_change_inode_journal_flag(struct inode *, int);",
      "extern int ext3_can_truncate(struct inode *inode);",
      "extern void ext3_truncate(struct inode *inode);",
      "extern void ext3_set_inode_flags(struct inode *);",
      "extern void ext3_set_aops(struct inode *inode);",
      "extern int ext3_orphan_add(handle_t *, struct inode *);",
      "extern int ext3_orphan_del(handle_t *, struct inode *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "test_opt",
          "args": [
            "inode->i_sb",
            "DATA_FLAGS"
          ],
          "line": 1327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT3_I",
          "args": [
            "inode"
          ],
          "line": 1325
        },
        "resolved": true,
        "details": {
          "function_name": "EXT3_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "693-696",
          "snippet": "static inline struct ext3_inode_info *EXT3_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext3_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void ext3_init_block_alloc_info(struct inode *);",
            "extern void ext3_free_inode (handle_t *, struct inode *);",
            "struct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);",
            "struct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);",
            "extern void ext3_evict_inode (struct inode *);",
            "extern int  ext3_sync_inode (handle_t *, struct inode *);",
            "extern void ext3_discard_reservation (struct inode *);",
            "extern void ext3_dirty_inode(struct inode *, int);",
            "extern int ext3_change_inode_journal_flag(struct inode *, int);",
            "extern int ext3_can_truncate(struct inode *inode);",
            "extern void ext3_truncate(struct inode *inode);",
            "extern void ext3_set_inode_flags(struct inode *);",
            "extern void ext3_get_inode_flags(struct ext3_inode_info *);",
            "extern void ext3_set_aops(struct inode *inode);",
            "extern int ext3_orphan_add(handle_t *, struct inode *);",
            "extern int ext3_orphan_del(handle_t *, struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nextern void ext3_init_block_alloc_info(struct inode *);\nextern void ext3_free_inode (handle_t *, struct inode *);\nstruct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);\nstruct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);\nextern void ext3_evict_inode (struct inode *);\nextern int  ext3_sync_inode (handle_t *, struct inode *);\nextern void ext3_discard_reservation (struct inode *);\nextern void ext3_dirty_inode(struct inode *, int);\nextern int ext3_change_inode_journal_flag(struct inode *, int);\nextern int ext3_can_truncate(struct inode *inode);\nextern void ext3_truncate(struct inode *inode);\nextern void ext3_set_inode_flags(struct inode *);\nextern void ext3_get_inode_flags(struct ext3_inode_info *);\nextern void ext3_set_aops(struct inode *inode);\nextern int ext3_orphan_add(handle_t *, struct inode *);\nextern int ext3_orphan_del(handle_t *, struct inode *);\n\nstatic inline struct ext3_inode_info *EXT3_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext3_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "inode->i_mode"
          ],
          "line": 1323
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\n#define EXT3_MOUNT_WRITEBACK_DATA\t0x00C00\t/* No data ordering */\n#define EXT3_JOURNAL_DATA_FL\t\t0x00004000 /* file data should be journaled */\n\nextern void ext3_init_block_alloc_info(struct inode *);\nextern void ext3_free_inode (handle_t *, struct inode *);\nstruct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);\nstruct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);\nextern void ext3_evict_inode (struct inode *);\nextern int  ext3_sync_inode (handle_t *, struct inode *);\nextern void ext3_discard_reservation (struct inode *);\nextern void ext3_dirty_inode(struct inode *, int);\nextern int ext3_change_inode_journal_flag(struct inode *, int);\nextern int ext3_can_truncate(struct inode *inode);\nextern void ext3_truncate(struct inode *inode);\nextern void ext3_set_inode_flags(struct inode *);\nextern void ext3_set_aops(struct inode *inode);\nextern int ext3_orphan_add(handle_t *, struct inode *);\nextern int ext3_orphan_del(handle_t *, struct inode *);\n\nstatic inline int ext3_should_writeback_data(struct inode *inode)\n{\n\tif (!S_ISREG(inode->i_mode))\n\t\treturn 0;\n\tif (EXT3_I(inode)->i_flags & EXT3_JOURNAL_DATA_FL)\n\t\treturn 0;\n\tif (test_opt(inode->i_sb, DATA_FLAGS) == EXT3_MOUNT_WRITEBACK_DATA)\n\t\treturn 1;\n\treturn 0;\n}"
  },
  {
    "function_name": "ext3_should_order_data",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
    "lines": "1310-1319",
    "snippet": "static inline int ext3_should_order_data(struct inode *inode)\n{\n\tif (!S_ISREG(inode->i_mode))\n\t\treturn 0;\n\tif (EXT3_I(inode)->i_flags & EXT3_JOURNAL_DATA_FL)\n\t\treturn 0;\n\tif (test_opt(inode->i_sb, DATA_FLAGS) == EXT3_MOUNT_ORDERED_DATA)\n\t\treturn 1;\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/ext3.h>",
      "#include <linux/blockgroup_lock.h>",
      "#include <linux/bug.h>",
      "#include <linux/magic.h>",
      "#include <linux/jbd.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [
      "#define EXT3_MOUNT_ORDERED_DATA\t\t0x00800\t/* Flush data before commit */",
      "#define EXT3_JOURNAL_DATA_FL\t\t0x00004000 /* file data should be journaled */"
    ],
    "globals_used": [
      "extern void ext3_init_block_alloc_info(struct inode *);",
      "extern void ext3_free_inode (handle_t *, struct inode *);",
      "struct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);",
      "struct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);",
      "extern void ext3_evict_inode (struct inode *);",
      "extern int  ext3_sync_inode (handle_t *, struct inode *);",
      "extern void ext3_discard_reservation (struct inode *);",
      "extern void ext3_dirty_inode(struct inode *, int);",
      "extern int ext3_change_inode_journal_flag(struct inode *, int);",
      "extern int ext3_can_truncate(struct inode *inode);",
      "extern void ext3_truncate(struct inode *inode);",
      "extern void ext3_set_inode_flags(struct inode *);",
      "extern void ext3_set_aops(struct inode *inode);",
      "extern int ext3_orphan_add(handle_t *, struct inode *);",
      "extern int ext3_orphan_del(handle_t *, struct inode *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "test_opt",
          "args": [
            "inode->i_sb",
            "DATA_FLAGS"
          ],
          "line": 1316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT3_I",
          "args": [
            "inode"
          ],
          "line": 1314
        },
        "resolved": true,
        "details": {
          "function_name": "EXT3_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "693-696",
          "snippet": "static inline struct ext3_inode_info *EXT3_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext3_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void ext3_init_block_alloc_info(struct inode *);",
            "extern void ext3_free_inode (handle_t *, struct inode *);",
            "struct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);",
            "struct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);",
            "extern void ext3_evict_inode (struct inode *);",
            "extern int  ext3_sync_inode (handle_t *, struct inode *);",
            "extern void ext3_discard_reservation (struct inode *);",
            "extern void ext3_dirty_inode(struct inode *, int);",
            "extern int ext3_change_inode_journal_flag(struct inode *, int);",
            "extern int ext3_can_truncate(struct inode *inode);",
            "extern void ext3_truncate(struct inode *inode);",
            "extern void ext3_set_inode_flags(struct inode *);",
            "extern void ext3_get_inode_flags(struct ext3_inode_info *);",
            "extern void ext3_set_aops(struct inode *inode);",
            "extern int ext3_orphan_add(handle_t *, struct inode *);",
            "extern int ext3_orphan_del(handle_t *, struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nextern void ext3_init_block_alloc_info(struct inode *);\nextern void ext3_free_inode (handle_t *, struct inode *);\nstruct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);\nstruct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);\nextern void ext3_evict_inode (struct inode *);\nextern int  ext3_sync_inode (handle_t *, struct inode *);\nextern void ext3_discard_reservation (struct inode *);\nextern void ext3_dirty_inode(struct inode *, int);\nextern int ext3_change_inode_journal_flag(struct inode *, int);\nextern int ext3_can_truncate(struct inode *inode);\nextern void ext3_truncate(struct inode *inode);\nextern void ext3_set_inode_flags(struct inode *);\nextern void ext3_get_inode_flags(struct ext3_inode_info *);\nextern void ext3_set_aops(struct inode *inode);\nextern int ext3_orphan_add(handle_t *, struct inode *);\nextern int ext3_orphan_del(handle_t *, struct inode *);\n\nstatic inline struct ext3_inode_info *EXT3_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext3_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "inode->i_mode"
          ],
          "line": 1312
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\n#define EXT3_MOUNT_ORDERED_DATA\t\t0x00800\t/* Flush data before commit */\n#define EXT3_JOURNAL_DATA_FL\t\t0x00004000 /* file data should be journaled */\n\nextern void ext3_init_block_alloc_info(struct inode *);\nextern void ext3_free_inode (handle_t *, struct inode *);\nstruct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);\nstruct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);\nextern void ext3_evict_inode (struct inode *);\nextern int  ext3_sync_inode (handle_t *, struct inode *);\nextern void ext3_discard_reservation (struct inode *);\nextern void ext3_dirty_inode(struct inode *, int);\nextern int ext3_change_inode_journal_flag(struct inode *, int);\nextern int ext3_can_truncate(struct inode *inode);\nextern void ext3_truncate(struct inode *inode);\nextern void ext3_set_inode_flags(struct inode *);\nextern void ext3_set_aops(struct inode *inode);\nextern int ext3_orphan_add(handle_t *, struct inode *);\nextern int ext3_orphan_del(handle_t *, struct inode *);\n\nstatic inline int ext3_should_order_data(struct inode *inode)\n{\n\tif (!S_ISREG(inode->i_mode))\n\t\treturn 0;\n\tif (EXT3_I(inode)->i_flags & EXT3_JOURNAL_DATA_FL)\n\t\treturn 0;\n\tif (test_opt(inode->i_sb, DATA_FLAGS) == EXT3_MOUNT_ORDERED_DATA)\n\t\treturn 1;\n\treturn 0;\n}"
  },
  {
    "function_name": "ext3_should_journal_data",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
    "lines": "1299-1308",
    "snippet": "static inline int ext3_should_journal_data(struct inode *inode)\n{\n\tif (!S_ISREG(inode->i_mode))\n\t\treturn 1;\n\tif (test_opt(inode->i_sb, DATA_FLAGS) == EXT3_MOUNT_JOURNAL_DATA)\n\t\treturn 1;\n\tif (EXT3_I(inode)->i_flags & EXT3_JOURNAL_DATA_FL)\n\t\treturn 1;\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/ext3.h>",
      "#include <linux/blockgroup_lock.h>",
      "#include <linux/bug.h>",
      "#include <linux/magic.h>",
      "#include <linux/jbd.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [
      "#define EXT3_MOUNT_JOURNAL_DATA\t\t0x00400\t/* Write data to journal */",
      "#define EXT3_JOURNAL_DATA_FL\t\t0x00004000 /* file data should be journaled */"
    ],
    "globals_used": [
      "extern void ext3_init_block_alloc_info(struct inode *);",
      "extern void ext3_free_inode (handle_t *, struct inode *);",
      "struct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);",
      "struct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);",
      "extern void ext3_evict_inode (struct inode *);",
      "extern int  ext3_sync_inode (handle_t *, struct inode *);",
      "extern void ext3_discard_reservation (struct inode *);",
      "extern void ext3_dirty_inode(struct inode *, int);",
      "extern int ext3_change_inode_journal_flag(struct inode *, int);",
      "extern int ext3_can_truncate(struct inode *inode);",
      "extern void ext3_truncate(struct inode *inode);",
      "extern void ext3_set_inode_flags(struct inode *);",
      "extern void ext3_set_aops(struct inode *inode);",
      "extern int ext3_orphan_add(handle_t *, struct inode *);",
      "extern int ext3_orphan_del(handle_t *, struct inode *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "EXT3_I",
          "args": [
            "inode"
          ],
          "line": 1305
        },
        "resolved": true,
        "details": {
          "function_name": "EXT3_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "693-696",
          "snippet": "static inline struct ext3_inode_info *EXT3_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext3_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void ext3_init_block_alloc_info(struct inode *);",
            "extern void ext3_free_inode (handle_t *, struct inode *);",
            "struct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);",
            "struct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);",
            "extern void ext3_evict_inode (struct inode *);",
            "extern int  ext3_sync_inode (handle_t *, struct inode *);",
            "extern void ext3_discard_reservation (struct inode *);",
            "extern void ext3_dirty_inode(struct inode *, int);",
            "extern int ext3_change_inode_journal_flag(struct inode *, int);",
            "extern int ext3_can_truncate(struct inode *inode);",
            "extern void ext3_truncate(struct inode *inode);",
            "extern void ext3_set_inode_flags(struct inode *);",
            "extern void ext3_get_inode_flags(struct ext3_inode_info *);",
            "extern void ext3_set_aops(struct inode *inode);",
            "extern int ext3_orphan_add(handle_t *, struct inode *);",
            "extern int ext3_orphan_del(handle_t *, struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nextern void ext3_init_block_alloc_info(struct inode *);\nextern void ext3_free_inode (handle_t *, struct inode *);\nstruct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);\nstruct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);\nextern void ext3_evict_inode (struct inode *);\nextern int  ext3_sync_inode (handle_t *, struct inode *);\nextern void ext3_discard_reservation (struct inode *);\nextern void ext3_dirty_inode(struct inode *, int);\nextern int ext3_change_inode_journal_flag(struct inode *, int);\nextern int ext3_can_truncate(struct inode *inode);\nextern void ext3_truncate(struct inode *inode);\nextern void ext3_set_inode_flags(struct inode *);\nextern void ext3_get_inode_flags(struct ext3_inode_info *);\nextern void ext3_set_aops(struct inode *inode);\nextern int ext3_orphan_add(handle_t *, struct inode *);\nextern int ext3_orphan_del(handle_t *, struct inode *);\n\nstatic inline struct ext3_inode_info *EXT3_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext3_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_opt",
          "args": [
            "inode->i_sb",
            "DATA_FLAGS"
          ],
          "line": 1303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "inode->i_mode"
          ],
          "line": 1301
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\n#define EXT3_MOUNT_JOURNAL_DATA\t\t0x00400\t/* Write data to journal */\n#define EXT3_JOURNAL_DATA_FL\t\t0x00004000 /* file data should be journaled */\n\nextern void ext3_init_block_alloc_info(struct inode *);\nextern void ext3_free_inode (handle_t *, struct inode *);\nstruct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);\nstruct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);\nextern void ext3_evict_inode (struct inode *);\nextern int  ext3_sync_inode (handle_t *, struct inode *);\nextern void ext3_discard_reservation (struct inode *);\nextern void ext3_dirty_inode(struct inode *, int);\nextern int ext3_change_inode_journal_flag(struct inode *, int);\nextern int ext3_can_truncate(struct inode *inode);\nextern void ext3_truncate(struct inode *inode);\nextern void ext3_set_inode_flags(struct inode *);\nextern void ext3_set_aops(struct inode *inode);\nextern int ext3_orphan_add(handle_t *, struct inode *);\nextern int ext3_orphan_del(handle_t *, struct inode *);\n\nstatic inline int ext3_should_journal_data(struct inode *inode)\n{\n\tif (!S_ISREG(inode->i_mode))\n\t\treturn 1;\n\tif (test_opt(inode->i_sb, DATA_FLAGS) == EXT3_MOUNT_JOURNAL_DATA)\n\t\treturn 1;\n\tif (EXT3_I(inode)->i_flags & EXT3_JOURNAL_DATA_FL)\n\t\treturn 1;\n\treturn 0;\n}"
  },
  {
    "function_name": "ext3_journal_force_commit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
    "lines": "1291-1294",
    "snippet": "static inline int ext3_journal_force_commit(journal_t *journal)\n{\n\treturn journal_force_commit(journal);\n}",
    "includes": [
      "#include <trace/events/ext3.h>",
      "#include <linux/blockgroup_lock.h>",
      "#include <linux/bug.h>",
      "#include <linux/magic.h>",
      "#include <linux/jbd.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "journal_force_commit",
          "args": [
            "journal"
          ],
          "line": 1293
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_journal_force_commit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "1291-1294",
          "snippet": "static inline int ext3_journal_force_commit(journal_t *journal)\n{\n\treturn journal_force_commit(journal);\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nstatic inline int ext3_journal_force_commit(journal_t *journal)\n{\n\treturn journal_force_commit(journal);\n}"
  },
  {
    "function_name": "ext3_journal_blocks_per_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
    "lines": "1286-1289",
    "snippet": "static inline int ext3_journal_blocks_per_page(struct inode *inode)\n{\n\treturn journal_blocks_per_page(inode);\n}",
    "includes": [
      "#include <trace/events/ext3.h>",
      "#include <linux/blockgroup_lock.h>",
      "#include <linux/bug.h>",
      "#include <linux/magic.h>",
      "#include <linux/jbd.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "extern void ext3_init_block_alloc_info(struct inode *);",
      "extern void ext3_free_inode (handle_t *, struct inode *);",
      "struct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);",
      "struct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);",
      "extern void ext3_evict_inode (struct inode *);",
      "extern int  ext3_sync_inode (handle_t *, struct inode *);",
      "extern void ext3_discard_reservation (struct inode *);",
      "extern void ext3_dirty_inode(struct inode *, int);",
      "extern int ext3_change_inode_journal_flag(struct inode *, int);",
      "extern int ext3_can_truncate(struct inode *inode);",
      "extern void ext3_truncate(struct inode *inode);",
      "extern void ext3_set_inode_flags(struct inode *);",
      "extern void ext3_set_aops(struct inode *inode);",
      "extern int ext3_orphan_add(handle_t *, struct inode *);",
      "extern int ext3_orphan_del(handle_t *, struct inode *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "journal_blocks_per_page",
          "args": [
            "inode"
          ],
          "line": 1288
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_journal_blocks_per_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "1286-1289",
          "snippet": "static inline int ext3_journal_blocks_per_page(struct inode *inode)\n{\n\treturn journal_blocks_per_page(inode);\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nextern void ext3_init_block_alloc_info(struct inode *);\nextern void ext3_free_inode (handle_t *, struct inode *);\nstruct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);\nstruct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);\nextern void ext3_evict_inode (struct inode *);\nextern int  ext3_sync_inode (handle_t *, struct inode *);\nextern void ext3_discard_reservation (struct inode *);\nextern void ext3_dirty_inode(struct inode *, int);\nextern int ext3_change_inode_journal_flag(struct inode *, int);\nextern int ext3_can_truncate(struct inode *inode);\nextern void ext3_truncate(struct inode *inode);\nextern void ext3_set_inode_flags(struct inode *);\nextern void ext3_set_aops(struct inode *inode);\nextern int ext3_orphan_add(handle_t *, struct inode *);\nextern int ext3_orphan_del(handle_t *, struct inode *);\n\nstatic inline int ext3_journal_blocks_per_page(struct inode *inode)\n{\n\treturn journal_blocks_per_page(inode);\n}"
  },
  {
    "function_name": "ext3_journal_restart",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
    "lines": "1281-1284",
    "snippet": "static inline int ext3_journal_restart(handle_t *handle, int nblocks)\n{\n\treturn journal_restart(handle, nblocks);\n}",
    "includes": [
      "#include <trace/events/ext3.h>",
      "#include <linux/blockgroup_lock.h>",
      "#include <linux/bug.h>",
      "#include <linux/magic.h>",
      "#include <linux/jbd.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "handle_t *ext3_journal_start_sb(struct super_block *sb, int nblocks);",
      "int __ext3_journal_stop(const char *where, handle_t *handle);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "journal_restart",
          "args": [
            "handle",
            "nblocks"
          ],
          "line": 1283
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_journal_restart",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "1281-1284",
          "snippet": "static inline int ext3_journal_restart(handle_t *handle, int nblocks)\n{\n\treturn journal_restart(handle, nblocks);\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nhandle_t *ext3_journal_start_sb(struct super_block *sb, int nblocks);\nint __ext3_journal_stop(const char *where, handle_t *handle);\n\nstatic inline int ext3_journal_restart(handle_t *handle, int nblocks)\n{\n\treturn journal_restart(handle, nblocks);\n}"
  },
  {
    "function_name": "ext3_journal_extend",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
    "lines": "1276-1279",
    "snippet": "static inline int ext3_journal_extend(handle_t *handle, int nblocks)\n{\n\treturn journal_extend(handle, nblocks);\n}",
    "includes": [
      "#include <trace/events/ext3.h>",
      "#include <linux/blockgroup_lock.h>",
      "#include <linux/bug.h>",
      "#include <linux/magic.h>",
      "#include <linux/jbd.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "handle_t *ext3_journal_start_sb(struct super_block *sb, int nblocks);",
      "int __ext3_journal_stop(const char *where, handle_t *handle);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "journal_extend",
          "args": [
            "handle",
            "nblocks"
          ],
          "line": 1278
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_journal_extend",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "1276-1279",
          "snippet": "static inline int ext3_journal_extend(handle_t *handle, int nblocks)\n{\n\treturn journal_extend(handle, nblocks);\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nhandle_t *ext3_journal_start_sb(struct super_block *sb, int nblocks);\nint __ext3_journal_stop(const char *where, handle_t *handle);\n\nstatic inline int ext3_journal_extend(handle_t *handle, int nblocks)\n{\n\treturn journal_extend(handle, nblocks);\n}"
  },
  {
    "function_name": "ext3_journal_current_handle",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
    "lines": "1271-1274",
    "snippet": "static inline handle_t *ext3_journal_current_handle(void)\n{\n\treturn journal_current_handle();\n}",
    "includes": [
      "#include <trace/events/ext3.h>",
      "#include <linux/blockgroup_lock.h>",
      "#include <linux/bug.h>",
      "#include <linux/magic.h>",
      "#include <linux/jbd.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "journal_current_handle",
          "args": [],
          "line": 1273
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_journal_current_handle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "1271-1274",
          "snippet": "static inline handle_t *ext3_journal_current_handle(void)\n{\n\treturn journal_current_handle();\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nstatic inline handle_t *ext3_journal_current_handle(void)\n{\n\treturn journal_current_handle();\n}"
  },
  {
    "function_name": "ext3_journal_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
    "lines": "1263-1266",
    "snippet": "static inline handle_t *ext3_journal_start(struct inode *inode, int nblocks)\n{\n\treturn ext3_journal_start_sb(inode->i_sb, nblocks);\n}",
    "includes": [
      "#include <trace/events/ext3.h>",
      "#include <linux/blockgroup_lock.h>",
      "#include <linux/bug.h>",
      "#include <linux/magic.h>",
      "#include <linux/jbd.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "extern void ext3_init_block_alloc_info(struct inode *);",
      "extern void ext3_free_inode (handle_t *, struct inode *);",
      "struct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);",
      "struct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);",
      "extern void ext3_evict_inode (struct inode *);",
      "extern int  ext3_sync_inode (handle_t *, struct inode *);",
      "extern void ext3_discard_reservation (struct inode *);",
      "extern void ext3_dirty_inode(struct inode *, int);",
      "extern int ext3_change_inode_journal_flag(struct inode *, int);",
      "extern int ext3_can_truncate(struct inode *inode);",
      "extern void ext3_truncate(struct inode *inode);",
      "extern void ext3_set_inode_flags(struct inode *);",
      "extern void ext3_set_aops(struct inode *inode);",
      "extern int ext3_orphan_add(handle_t *, struct inode *);",
      "extern int ext3_orphan_del(handle_t *, struct inode *);",
      "handle_t *ext3_journal_start_sb(struct super_block *sb, int nblocks);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext3_journal_start_sb",
          "args": [
            "inode->i_sb",
            "nblocks"
          ],
          "line": 1265
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_journal_start_sb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/super.c",
          "lines": "69-87",
          "snippet": "handle_t *ext3_journal_start_sb(struct super_block *sb, int nblocks)\n{\n\tjournal_t *journal;\n\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn ERR_PTR(-EROFS);\n\n\t/* Special case here: if the journal has aborted behind our\n\t * backs (eg. EIO in the commit thread), then we still need to\n\t * take the FS itself readonly cleanly. */\n\tjournal = EXT3_SB(sb)->s_journal;\n\tif (is_journal_aborted(journal)) {\n\t\text3_abort(sb, __func__,\n\t\t\t   \"Detected aborted journal\");\n\t\treturn ERR_PTR(-EROFS);\n\t}\n\n\treturn journal_start(journal, nblocks);\n}",
          "includes": [
            "#include \"namei.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/statfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_unfreeze(struct super_block *sb);",
            "static int ext3_freeze(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"namei.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/exportfs.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/module.h>\n\nstatic int ext3_unfreeze(struct super_block *sb);\nstatic int ext3_freeze(struct super_block *sb);\n\nhandle_t *ext3_journal_start_sb(struct super_block *sb, int nblocks)\n{\n\tjournal_t *journal;\n\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn ERR_PTR(-EROFS);\n\n\t/* Special case here: if the journal has aborted behind our\n\t * backs (eg. EIO in the commit thread), then we still need to\n\t * take the FS itself readonly cleanly. */\n\tjournal = EXT3_SB(sb)->s_journal;\n\tif (is_journal_aborted(journal)) {\n\t\text3_abort(sb, __func__,\n\t\t\t   \"Detected aborted journal\");\n\t\treturn ERR_PTR(-EROFS);\n\t}\n\n\treturn journal_start(journal, nblocks);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nextern void ext3_init_block_alloc_info(struct inode *);\nextern void ext3_free_inode (handle_t *, struct inode *);\nstruct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);\nstruct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);\nextern void ext3_evict_inode (struct inode *);\nextern int  ext3_sync_inode (handle_t *, struct inode *);\nextern void ext3_discard_reservation (struct inode *);\nextern void ext3_dirty_inode(struct inode *, int);\nextern int ext3_change_inode_journal_flag(struct inode *, int);\nextern int ext3_can_truncate(struct inode *inode);\nextern void ext3_truncate(struct inode *inode);\nextern void ext3_set_inode_flags(struct inode *);\nextern void ext3_set_aops(struct inode *inode);\nextern int ext3_orphan_add(handle_t *, struct inode *);\nextern int ext3_orphan_del(handle_t *, struct inode *);\nhandle_t *ext3_journal_start_sb(struct super_block *sb, int nblocks);\n\nstatic inline handle_t *ext3_journal_start(struct inode *inode, int nblocks)\n{\n\treturn ext3_journal_start_sb(inode->i_sb, nblocks);\n}"
  },
  {
    "function_name": "ext3_group_first_block_no",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
    "lines": "972-977",
    "snippet": "static inline ext3_fsblk_t\next3_group_first_block_no(struct super_block *sb, unsigned long group_no)\n{\n\treturn group_no * (ext3_fsblk_t)EXT3_BLOCKS_PER_GROUP(sb) +\n\t\tle32_to_cpu(EXT3_SB(sb)->s_es->s_first_data_block);\n}",
    "includes": [
      "#include <trace/events/ext3.h>",
      "#include <linux/blockgroup_lock.h>",
      "#include <linux/bug.h>",
      "#include <linux/magic.h>",
      "#include <linux/jbd.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "extern ext3_fsblk_t ext3_count_free_blocks (struct super_block *);",
      "extern void ext3_check_blocks_bitmap (struct super_block *);",
      "extern struct inode * ext3_orphan_get (struct super_block *, unsigned long);",
      "extern unsigned long ext3_count_free_inodes (struct super_block *);",
      "extern unsigned long ext3_count_dirs (struct super_block *);",
      "extern void ext3_check_inodes_bitmap (struct super_block *);",
      "extern struct inode *ext3_iget(struct super_block *, unsigned long);",
      "int ext3_force_commit(struct super_block *sb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "EXT3_SB(sb)->s_es->s_first_data_block"
          ],
          "line": 976
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT3_SB",
          "args": [
            "sb"
          ],
          "line": 976
        },
        "resolved": true,
        "details": {
          "function_name": "EXT3_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "689-692",
          "snippet": "static inline struct ext3_sb_info * EXT3_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern ext3_fsblk_t ext3_count_free_blocks (struct super_block *);",
            "extern void ext3_check_blocks_bitmap (struct super_block *);",
            "extern struct inode * ext3_orphan_get (struct super_block *, unsigned long);",
            "extern unsigned long ext3_count_free_inodes (struct super_block *);",
            "extern unsigned long ext3_count_dirs (struct super_block *);",
            "extern void ext3_check_inodes_bitmap (struct super_block *);",
            "extern struct inode *ext3_iget(struct super_block *, unsigned long);",
            "int ext3_force_commit(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nextern ext3_fsblk_t ext3_count_free_blocks (struct super_block *);\nextern void ext3_check_blocks_bitmap (struct super_block *);\nextern struct inode * ext3_orphan_get (struct super_block *, unsigned long);\nextern unsigned long ext3_count_free_inodes (struct super_block *);\nextern unsigned long ext3_count_dirs (struct super_block *);\nextern void ext3_check_inodes_bitmap (struct super_block *);\nextern struct inode *ext3_iget(struct super_block *, unsigned long);\nint ext3_force_commit(struct super_block *sb);\n\nstatic inline struct ext3_sb_info * EXT3_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT3_BLOCKS_PER_GROUP",
          "args": [
            "sb"
          ],
          "line": 975
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nextern ext3_fsblk_t ext3_count_free_blocks (struct super_block *);\nextern void ext3_check_blocks_bitmap (struct super_block *);\nextern struct inode * ext3_orphan_get (struct super_block *, unsigned long);\nextern unsigned long ext3_count_free_inodes (struct super_block *);\nextern unsigned long ext3_count_dirs (struct super_block *);\nextern void ext3_check_inodes_bitmap (struct super_block *);\nextern struct inode *ext3_iget(struct super_block *, unsigned long);\nint ext3_force_commit(struct super_block *sb);\n\nstatic inline ext3_fsblk_t\next3_group_first_block_no(struct super_block *sb, unsigned long group_no)\n{\n\treturn group_no * (ext3_fsblk_t)EXT3_BLOCKS_PER_GROUP(sb) +\n\t\tle32_to_cpu(EXT3_SB(sb)->s_es->s_first_data_block);\n}"
  },
  {
    "function_name": "ext3_raw_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
    "lines": "951-954",
    "snippet": "static inline struct ext3_inode *ext3_raw_inode(struct ext3_iloc *iloc)\n{\n\treturn (struct ext3_inode *) (iloc->bh->b_data + iloc->offset);\n}",
    "includes": [
      "#include <trace/events/ext3.h>",
      "#include <linux/blockgroup_lock.h>",
      "#include <linux/bug.h>",
      "#include <linux/magic.h>",
      "#include <linux/jbd.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "extern struct ext3_group_desc * ext3_get_group_desc(struct super_block * sb,\n\t\t\t\t\t\t    unsigned int block_group,\n\t\t\t\t\t\t    struct buffer_head ** bh);",
      "extern int ext3_get_inode_loc(struct inode *, struct ext3_iloc *);",
      "extern __printf(3, 4)\nvoid ext3_error(struct super_block *, const char *, const char *, ...);\nextern void __ext3_std_error (struct super_block *, const char *, int);\nextern __printf(3, 4)\nvoid ext3_abort(struct super_block *, const char *, const char *, ...);\nextern __printf(3, 4)\nvoid ext3_warning(struct super_block *, const char *, const char *, ...);\nextern __printf(3, 4)\nvoid ext3_msg(struct super_block *, const char *, const char *, ...);\nextern void ext3_update_dynamic_rev (struct super_block *sb);\n\n#define ext3_std_error(sb, errno)\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\\\n\tif ((errno))\t\t\t\t\t\t\\\n\t\t__ext3_std_error((sb), __func__, (errno));\t\\\n} while (0)\n\n/*\n * Inodes and files operations\n */\n\n/* dir.c */\nextern const struct file_operations ext3_dir_operations;\n\n/* file.c */\nextern const struct inode_operations ext3_file_inode_operations;\nextern const struct file_operations ext3_file_operations;\n\n/* namei.c */\nextern const struct inode_operations ext3_dir_inode_operations;\nextern const struct inode_operations ext3_special_inode_operations;\n\n/* symlink.c */\nextern const struct inode_operations ext3_symlink_inode_operations;\nextern const struct inode_operations ext3_fast_symlink_inode_operations;\n\n#define EXT3_JOURNAL(inode)\t(EXT3_SB((inode)->i_sb)->s_journal)\n\n/* Define the number of blocks we need to account to a transaction to\n * modify one block of data.\n *\n * We may have to touch one inode, one bitmap buffer, up to three\n * indirection blocks, the group and superblock summaries, and the data\n * block to complete the transaction.  */\n\n#define EXT3_SINGLEDATA_TRANS_BLOCKS\t8U\n\n/* Extended attribute operations touch at most two data buffers,\n * two bitmap buffers, and two group summaries, in addition to the inode\n * and the superblock, which are already accounted for. */\n\n#define EXT3_XATTR_TRANS_BLOCKS\t\t6U\n\n/* Define the minimum size for a transaction which modifies data.  This\n * needs to take into account the fact that we may end up modifying two\n * quota files too (one for the group, one for the user quota).  The\n * superblock only gets updated once, of course, so don't bother\n * counting that again for the quota updates. */\n\n#define EXT3_DATA_TRANS_BLOCKS(sb)\t(EXT3_SINGLEDATA_TRANS_BLOCKS + \\\n\t\t\t\t\t EXT3_XATTR_TRANS_BLOCKS - 2 + \\\n\t\t\t\t\t EXT3_MAXQUOTAS_TRANS_BLOCKS(sb))\n\n/* Delete operations potentially hit one directory's namespace plus an\n * entire inode, plus arbitrary amounts of bitmap/indirection data.  Be\n * generous.  We can grow the delete transaction later if necessary. */\n\n#define EXT3_DELETE_TRANS_BLOCKS(sb)   (EXT3_MAXQUOTAS_TRANS_BLOCKS(sb) + 64)\n\n/* Define an arbitrary limit for the amount of data we will anticipate\n * writing to any given transaction.  For unbounded transactions such as\n * write(2) and truncate(2) we can write more than this, but we always\n * start off at the maximum transaction size and grow the transaction\n * optimistically as we go. */\n\n#define EXT3_MAX_TRANS_DATA\t\t64U\n\n/* We break up a large truncate or write transaction once the handle's\n * buffer credits gets this low, we need either to extend the\n * transaction or to start a new one.  Reserve enough space here for\n * inode, bitmap, superblock, group and indirection updates for at least\n * one block, plus two quota updates.  Quota allocations are not\n * needed. */\n\n#define EXT3_RESERVE_TRANS_BLOCKS\t12U\n\n#define EXT3_INDEX_EXTRA_TRANS_BLOCKS\t8\n\n#ifdef CONFIG_QUOTA\n/* Amount of blocks needed for quota update - we know that the structure was\n * allocated so we need to update only inode+data */\n#define EXT3_QUOTA_TRANS_BLOCKS(sb) (test_opt(sb, QUOTA) ? 2 : 0)\n/* Amount of blocks needed for quota insert/delete - we do some block writes\n * but inode, sb and group updates are done only once */\n#define EXT3_QUOTA_INIT_BLOCKS(sb) (test_opt(sb, QUOTA) ? (DQUOT_INIT_ALLOC*\\\n\t\t(EXT3_SINGLEDATA_TRANS_BLOCKS-3)+3+DQUOT_INIT_REWRITE) : 0)\n#define EXT3_QUOTA_DEL_BLOCKS(sb) (test_opt(sb, QUOTA) ? (DQUOT_DEL_ALLOC*\\\n\t\t(EXT3_SINGLEDATA_TRANS_BLOCKS-3)+3+DQUOT_DEL_REWRITE) : 0)\n#else\n#define EXT3_QUOTA_TRANS_BLOCKS(sb) 0\n#define EXT3_QUOTA_INIT_BLOCKS(sb) 0\n#define EXT3_QUOTA_DEL_BLOCKS(sb) 0\n#endif\n#define EXT3_MAXQUOTAS_TRANS_BLOCKS(sb) (EXT3_MAXQUOTAS*EXT3_QUOTA_TRANS_BLOCKS(sb))\n#define EXT3_MAXQUOTAS_INIT_BLOCKS(sb) (EXT3_MAXQUOTAS*EXT3_QUOTA_INIT_BLOCKS(sb))\n#define EXT3_MAXQUOTAS_DEL_BLOCKS(sb) (EXT3_MAXQUOTAS*EXT3_QUOTA_DEL_BLOCKS(sb))\n\nint\next3_mark_iloc_dirty(handle_t *handle,\n\t\t     struct inode *inode,\n\t\t     struct ext3_iloc *iloc);\n\n/*\n * On success, We end up with an outstanding reference count against\n * iloc->bh.  This _must_ be cleaned up later.\n */\n\nint ext3_reserve_inode_write(handle_t *handle, struct inode *inode,\n\t\t\tstruct ext3_iloc *iloc);\n\nint ext3_mark_inode_dirty(handle_t *handle, struct inode *inode);\n\n/*\n * Wrapper functions with which ext3 calls into JBD.  The intent here is\n * to allow these to be turned into appropriate stubs so ext3 can control\n * ext2 filesystems, so ext2+ext3 systems only nee one fs.  This work hasn't\n * been done yet.\n */\n\nstatic inline void ext3_journal_release_buffer(handle_t *handle,\n\t\t\t\t\t\tstruct buffer_head *bh)\n{\n\tjournal_release_buffer(handle, bh);\n}\n\nvoid ext3_journal_abort_handle(const char *caller, const char *err_fn,\n\t\tstruct buffer_head *bh, handle_t *handle, int err);\n\nint __ext3_journal_get_undo_access(const char *where, handle_t *handle,\n\t\t\t\tstruct buffer_head *bh);\n\nint __ext3_journal_get_write_access(const char *where, handle_t *handle,\n\t\t\t\tstruct buffer_head *bh);\n\nint __ext3_journal_forget(const char *where, handle_t *handle,\n\t\t\t\tstruct buffer_head *bh);\n\nint __ext3_journal_revoke(const char *where, handle_t *handle,\n\t\t\t\tunsigned long blocknr, struct buffer_head *bh);\n\nint __ext3_journal_get_create_access(const char *where,\n\t\t\t\thandle_t *handle, struct buffer_head *bh);\n\nint __ext3_journal_dirty_metadata(const char *where,\n\t\t\t\thandle_t *handle, struct buffer_head *bh);\n\n#define ext3_journal_get_undo_access(handle, bh) \\\n\t__ext3_journal_get_undo_access(__func__, (handle), (bh))\n#define ext3_journal_get_write_access(handle, bh) \\\n\t__ext3_journal_get_write_access(__func__, (handle), (bh))",
      "int ext3_journal_dirty_data(handle_t *handle, struct buffer_head *bh);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nextern struct ext3_group_desc * ext3_get_group_desc(struct super_block * sb,\n\t\t\t\t\t\t    unsigned int block_group,\n\t\t\t\t\t\t    struct buffer_head ** bh);\nextern int ext3_get_inode_loc(struct inode *, struct ext3_iloc *);\nextern __printf(3, 4)\nvoid ext3_error(struct super_block *, const char *, const char *, ...);\nextern void __ext3_std_error (struct super_block *, const char *, int);\nextern __printf(3, 4)\nvoid ext3_abort(struct super_block *, const char *, const char *, ...);\nextern __printf(3, 4)\nvoid ext3_warning(struct super_block *, const char *, const char *, ...);\nextern __printf(3, 4)\nvoid ext3_msg(struct super_block *, const char *, const char *, ...);\nextern void ext3_update_dynamic_rev (struct super_block *sb);\n\n#define ext3_std_error(sb, errno)\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\\\n\tif ((errno))\t\t\t\t\t\t\\\n\t\t__ext3_std_error((sb), __func__, (errno));\t\\\n} while (0)\n\n/*\n * Inodes and files operations\n */\n\n/* dir.c */\nextern const struct file_operations ext3_dir_operations;\n\n/* file.c */\nextern const struct inode_operations ext3_file_inode_operations;\nextern const struct file_operations ext3_file_operations;\n\n/* namei.c */\nextern const struct inode_operations ext3_dir_inode_operations;\nextern const struct inode_operations ext3_special_inode_operations;\n\n/* symlink.c */\nextern const struct inode_operations ext3_symlink_inode_operations;\nextern const struct inode_operations ext3_fast_symlink_inode_operations;\n\n#define EXT3_JOURNAL(inode)\t(EXT3_SB((inode)->i_sb)->s_journal)\n\n/* Define the number of blocks we need to account to a transaction to\n * modify one block of data.\n *\n * We may have to touch one inode, one bitmap buffer, up to three\n * indirection blocks, the group and superblock summaries, and the data\n * block to complete the transaction.  */\n\n#define EXT3_SINGLEDATA_TRANS_BLOCKS\t8U\n\n/* Extended attribute operations touch at most two data buffers,\n * two bitmap buffers, and two group summaries, in addition to the inode\n * and the superblock, which are already accounted for. */\n\n#define EXT3_XATTR_TRANS_BLOCKS\t\t6U\n\n/* Define the minimum size for a transaction which modifies data.  This\n * needs to take into account the fact that we may end up modifying two\n * quota files too (one for the group, one for the user quota).  The\n * superblock only gets updated once, of course, so don't bother\n * counting that again for the quota updates. */\n\n#define EXT3_DATA_TRANS_BLOCKS(sb)\t(EXT3_SINGLEDATA_TRANS_BLOCKS + \\\n\t\t\t\t\t EXT3_XATTR_TRANS_BLOCKS - 2 + \\\n\t\t\t\t\t EXT3_MAXQUOTAS_TRANS_BLOCKS(sb))\n\n/* Delete operations potentially hit one directory's namespace plus an\n * entire inode, plus arbitrary amounts of bitmap/indirection data.  Be\n * generous.  We can grow the delete transaction later if necessary. */\n\n#define EXT3_DELETE_TRANS_BLOCKS(sb)   (EXT3_MAXQUOTAS_TRANS_BLOCKS(sb) + 64)\n\n/* Define an arbitrary limit for the amount of data we will anticipate\n * writing to any given transaction.  For unbounded transactions such as\n * write(2) and truncate(2) we can write more than this, but we always\n * start off at the maximum transaction size and grow the transaction\n * optimistically as we go. */\n\n#define EXT3_MAX_TRANS_DATA\t\t64U\n\n/* We break up a large truncate or write transaction once the handle's\n * buffer credits gets this low, we need either to extend the\n * transaction or to start a new one.  Reserve enough space here for\n * inode, bitmap, superblock, group and indirection updates for at least\n * one block, plus two quota updates.  Quota allocations are not\n * needed. */\n\n#define EXT3_RESERVE_TRANS_BLOCKS\t12U\n\n#define EXT3_INDEX_EXTRA_TRANS_BLOCKS\t8\n\n#ifdef CONFIG_QUOTA\n/* Amount of blocks needed for quota update - we know that the structure was\n * allocated so we need to update only inode+data */\n#define EXT3_QUOTA_TRANS_BLOCKS(sb) (test_opt(sb, QUOTA) ? 2 : 0)\n/* Amount of blocks needed for quota insert/delete - we do some block writes\n * but inode, sb and group updates are done only once */\n#define EXT3_QUOTA_INIT_BLOCKS(sb) (test_opt(sb, QUOTA) ? (DQUOT_INIT_ALLOC*\\\n\t\t(EXT3_SINGLEDATA_TRANS_BLOCKS-3)+3+DQUOT_INIT_REWRITE) : 0)\n#define EXT3_QUOTA_DEL_BLOCKS(sb) (test_opt(sb, QUOTA) ? (DQUOT_DEL_ALLOC*\\\n\t\t(EXT3_SINGLEDATA_TRANS_BLOCKS-3)+3+DQUOT_DEL_REWRITE) : 0)\n#else\n#define EXT3_QUOTA_TRANS_BLOCKS(sb) 0\n#define EXT3_QUOTA_INIT_BLOCKS(sb) 0\n#define EXT3_QUOTA_DEL_BLOCKS(sb) 0\n#endif\n#define EXT3_MAXQUOTAS_TRANS_BLOCKS(sb) (EXT3_MAXQUOTAS*EXT3_QUOTA_TRANS_BLOCKS(sb))\n#define EXT3_MAXQUOTAS_INIT_BLOCKS(sb) (EXT3_MAXQUOTAS*EXT3_QUOTA_INIT_BLOCKS(sb))\n#define EXT3_MAXQUOTAS_DEL_BLOCKS(sb) (EXT3_MAXQUOTAS*EXT3_QUOTA_DEL_BLOCKS(sb))\n\nint\next3_mark_iloc_dirty(handle_t *handle,\n\t\t     struct inode *inode,\n\t\t     struct ext3_iloc *iloc);\n\n/*\n * On success, We end up with an outstanding reference count against\n * iloc->bh.  This _must_ be cleaned up later.\n */\n\nint ext3_reserve_inode_write(handle_t *handle, struct inode *inode,\n\t\t\tstruct ext3_iloc *iloc);\n\nint ext3_mark_inode_dirty(handle_t *handle, struct inode *inode);\n\n/*\n * Wrapper functions with which ext3 calls into JBD.  The intent here is\n * to allow these to be turned into appropriate stubs so ext3 can control\n * ext2 filesystems, so ext2+ext3 systems only nee one fs.  This work hasn't\n * been done yet.\n */\n\nstatic inline void ext3_journal_release_buffer(handle_t *handle,\n\t\t\t\t\t\tstruct buffer_head *bh)\n{\n\tjournal_release_buffer(handle, bh);\n}\n\nvoid ext3_journal_abort_handle(const char *caller, const char *err_fn,\n\t\tstruct buffer_head *bh, handle_t *handle, int err);\n\nint __ext3_journal_get_undo_access(const char *where, handle_t *handle,\n\t\t\t\tstruct buffer_head *bh);\n\nint __ext3_journal_get_write_access(const char *where, handle_t *handle,\n\t\t\t\tstruct buffer_head *bh);\n\nint __ext3_journal_forget(const char *where, handle_t *handle,\n\t\t\t\tstruct buffer_head *bh);\n\nint __ext3_journal_revoke(const char *where, handle_t *handle,\n\t\t\t\tunsigned long blocknr, struct buffer_head *bh);\n\nint __ext3_journal_get_create_access(const char *where,\n\t\t\t\thandle_t *handle, struct buffer_head *bh);\n\nint __ext3_journal_dirty_metadata(const char *where,\n\t\t\t\thandle_t *handle, struct buffer_head *bh);\n\n#define ext3_journal_get_undo_access(handle, bh) \\\n\t__ext3_journal_get_undo_access(__func__, (handle), (bh))\n#define ext3_journal_get_write_access(handle, bh) \\\n\t__ext3_journal_get_write_access(__func__, (handle), (bh));\nint ext3_journal_dirty_data(handle_t *handle, struct buffer_head *bh);\n\nstatic inline struct ext3_inode *ext3_raw_inode(struct ext3_iloc *iloc)\n{\n\treturn (struct ext3_inode *) (iloc->bh->b_data + iloc->offset);\n}"
  },
  {
    "function_name": "ext3_rec_len_to_disk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
    "lines": "889-898",
    "snippet": "static inline __le16 ext3_rec_len_to_disk(unsigned len)\n{\n#if (PAGE_CACHE_SIZE >= 65536)\n\tif (len == (1 << 16))\n\t\treturn cpu_to_le16(EXT3_MAX_REC_LEN);\n\telse if (len > (1 << 16))\n\t\tBUG();\n#endif\n\treturn cpu_to_le16(len);\n}",
    "includes": [
      "#include <trace/events/ext3.h>",
      "#include <linux/blockgroup_lock.h>",
      "#include <linux/bug.h>",
      "#include <linux/magic.h>",
      "#include <linux/jbd.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [
      "#define EXT3_MAX_REC_LEN\t\t((1<<16)-1)"
    ],
    "globals_used": [
      "extern int ext3_fiemap(struct inode *inode, struct fiemap_extent_info *fieinfo,\n\t\t       u64 start, u64 len);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "len"
          ],
          "line": 897
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 895
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "EXT3_MAX_REC_LEN"
          ],
          "line": 893
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\n#define EXT3_MAX_REC_LEN\t\t((1<<16)-1)\n\nextern int ext3_fiemap(struct inode *inode, struct fiemap_extent_info *fieinfo,\n\t\t       u64 start, u64 len);\n\nstatic inline __le16 ext3_rec_len_to_disk(unsigned len)\n{\n#if (PAGE_CACHE_SIZE >= 65536)\n\tif (len == (1 << 16))\n\t\treturn cpu_to_le16(EXT3_MAX_REC_LEN);\n\telse if (len > (1 << 16))\n\t\tBUG();\n#endif\n\treturn cpu_to_le16(len);\n}"
  },
  {
    "function_name": "ext3_rec_len_from_disk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
    "lines": "878-887",
    "snippet": "static inline unsigned ext3_rec_len_from_disk(__le16 dlen)\n{\n\tunsigned len = le16_to_cpu(dlen);\n\n#if (PAGE_CACHE_SIZE >= 65536)\n\tif (len == EXT3_MAX_REC_LEN)\n\t\treturn 1 << 16;\n#endif\n\treturn len;\n}",
    "includes": [
      "#include <trace/events/ext3.h>",
      "#include <linux/blockgroup_lock.h>",
      "#include <linux/bug.h>",
      "#include <linux/magic.h>",
      "#include <linux/jbd.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [
      "#define EXT3_MAX_REC_LEN\t\t((1<<16)-1)"
    ],
    "globals_used": [
      "extern int ext3_fiemap(struct inode *inode, struct fiemap_extent_info *fieinfo,\n\t\t       u64 start, u64 len);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "dlen"
          ],
          "line": 880
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\n#define EXT3_MAX_REC_LEN\t\t((1<<16)-1)\n\nextern int ext3_fiemap(struct inode *inode, struct fiemap_extent_info *fieinfo,\n\t\t       u64 start, u64 len);\n\nstatic inline unsigned ext3_rec_len_from_disk(__le16 dlen)\n{\n\tunsigned len = le16_to_cpu(dlen);\n\n#if (PAGE_CACHE_SIZE >= 65536)\n\tif (len == EXT3_MAX_REC_LEN)\n\t\treturn 1 << 16;\n#endif\n\treturn len;\n}"
  },
  {
    "function_name": "ext3_clear_inode_state",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
    "lines": "727-730",
    "snippet": "static inline void ext3_clear_inode_state(struct inode *inode, int bit)\n{\n\tclear_bit(bit, &EXT3_I(inode)->i_state_flags);\n}",
    "includes": [
      "#include <trace/events/ext3.h>",
      "#include <linux/blockgroup_lock.h>",
      "#include <linux/bug.h>",
      "#include <linux/magic.h>",
      "#include <linux/jbd.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "extern void ext3_init_block_alloc_info(struct inode *);",
      "extern void ext3_free_inode (handle_t *, struct inode *);",
      "struct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);",
      "struct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);",
      "extern void ext3_evict_inode (struct inode *);",
      "extern int  ext3_sync_inode (handle_t *, struct inode *);",
      "extern void ext3_discard_reservation (struct inode *);",
      "extern void ext3_dirty_inode(struct inode *, int);",
      "extern int ext3_change_inode_journal_flag(struct inode *, int);",
      "extern int ext3_can_truncate(struct inode *inode);",
      "extern void ext3_truncate(struct inode *inode);",
      "extern void ext3_set_inode_flags(struct inode *);",
      "extern void ext3_set_aops(struct inode *inode);",
      "extern int ext3_orphan_add(handle_t *, struct inode *);",
      "extern int ext3_orphan_del(handle_t *, struct inode *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "bit",
            "&EXT3_I(inode)->i_state_flags"
          ],
          "line": 729
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clear_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "892-896",
          "snippet": "static inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT3_I",
          "args": [
            "inode"
          ],
          "line": 729
        },
        "resolved": true,
        "details": {
          "function_name": "EXT3_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "693-696",
          "snippet": "static inline struct ext3_inode_info *EXT3_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext3_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void ext3_init_block_alloc_info(struct inode *);",
            "extern void ext3_free_inode (handle_t *, struct inode *);",
            "struct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);",
            "struct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);",
            "extern void ext3_evict_inode (struct inode *);",
            "extern int  ext3_sync_inode (handle_t *, struct inode *);",
            "extern void ext3_discard_reservation (struct inode *);",
            "extern void ext3_dirty_inode(struct inode *, int);",
            "extern int ext3_change_inode_journal_flag(struct inode *, int);",
            "extern int ext3_can_truncate(struct inode *inode);",
            "extern void ext3_truncate(struct inode *inode);",
            "extern void ext3_set_inode_flags(struct inode *);",
            "extern void ext3_get_inode_flags(struct ext3_inode_info *);",
            "extern void ext3_set_aops(struct inode *inode);",
            "extern int ext3_orphan_add(handle_t *, struct inode *);",
            "extern int ext3_orphan_del(handle_t *, struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nextern void ext3_init_block_alloc_info(struct inode *);\nextern void ext3_free_inode (handle_t *, struct inode *);\nstruct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);\nstruct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);\nextern void ext3_evict_inode (struct inode *);\nextern int  ext3_sync_inode (handle_t *, struct inode *);\nextern void ext3_discard_reservation (struct inode *);\nextern void ext3_dirty_inode(struct inode *, int);\nextern int ext3_change_inode_journal_flag(struct inode *, int);\nextern int ext3_can_truncate(struct inode *inode);\nextern void ext3_truncate(struct inode *inode);\nextern void ext3_set_inode_flags(struct inode *);\nextern void ext3_get_inode_flags(struct ext3_inode_info *);\nextern void ext3_set_aops(struct inode *inode);\nextern int ext3_orphan_add(handle_t *, struct inode *);\nextern int ext3_orphan_del(handle_t *, struct inode *);\n\nstatic inline struct ext3_inode_info *EXT3_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext3_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nextern void ext3_init_block_alloc_info(struct inode *);\nextern void ext3_free_inode (handle_t *, struct inode *);\nstruct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);\nstruct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);\nextern void ext3_evict_inode (struct inode *);\nextern int  ext3_sync_inode (handle_t *, struct inode *);\nextern void ext3_discard_reservation (struct inode *);\nextern void ext3_dirty_inode(struct inode *, int);\nextern int ext3_change_inode_journal_flag(struct inode *, int);\nextern int ext3_can_truncate(struct inode *inode);\nextern void ext3_truncate(struct inode *inode);\nextern void ext3_set_inode_flags(struct inode *);\nextern void ext3_set_aops(struct inode *inode);\nextern int ext3_orphan_add(handle_t *, struct inode *);\nextern int ext3_orphan_del(handle_t *, struct inode *);\n\nstatic inline void ext3_clear_inode_state(struct inode *inode, int bit)\n{\n\tclear_bit(bit, &EXT3_I(inode)->i_state_flags);\n}"
  },
  {
    "function_name": "ext3_set_inode_state",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
    "lines": "722-725",
    "snippet": "static inline void ext3_set_inode_state(struct inode *inode, int bit)\n{\n\tset_bit(bit, &EXT3_I(inode)->i_state_flags);\n}",
    "includes": [
      "#include <trace/events/ext3.h>",
      "#include <linux/blockgroup_lock.h>",
      "#include <linux/bug.h>",
      "#include <linux/magic.h>",
      "#include <linux/jbd.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "extern void ext3_init_block_alloc_info(struct inode *);",
      "extern void ext3_free_inode (handle_t *, struct inode *);",
      "struct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);",
      "struct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);",
      "extern void ext3_evict_inode (struct inode *);",
      "extern int  ext3_sync_inode (handle_t *, struct inode *);",
      "extern void ext3_discard_reservation (struct inode *);",
      "extern void ext3_dirty_inode(struct inode *, int);",
      "extern int ext3_change_inode_journal_flag(struct inode *, int);",
      "extern int ext3_can_truncate(struct inode *inode);",
      "extern void ext3_truncate(struct inode *inode);",
      "extern void ext3_set_inode_flags(struct inode *);",
      "extern void ext3_set_aops(struct inode *inode);",
      "extern int ext3_orphan_add(handle_t *, struct inode *);",
      "extern int ext3_orphan_del(handle_t *, struct inode *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "bit",
            "&EXT3_I(inode)->i_state_flags"
          ],
          "line": 724
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT3_I",
          "args": [
            "inode"
          ],
          "line": 724
        },
        "resolved": true,
        "details": {
          "function_name": "EXT3_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "693-696",
          "snippet": "static inline struct ext3_inode_info *EXT3_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext3_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void ext3_init_block_alloc_info(struct inode *);",
            "extern void ext3_free_inode (handle_t *, struct inode *);",
            "struct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);",
            "struct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);",
            "extern void ext3_evict_inode (struct inode *);",
            "extern int  ext3_sync_inode (handle_t *, struct inode *);",
            "extern void ext3_discard_reservation (struct inode *);",
            "extern void ext3_dirty_inode(struct inode *, int);",
            "extern int ext3_change_inode_journal_flag(struct inode *, int);",
            "extern int ext3_can_truncate(struct inode *inode);",
            "extern void ext3_truncate(struct inode *inode);",
            "extern void ext3_set_inode_flags(struct inode *);",
            "extern void ext3_get_inode_flags(struct ext3_inode_info *);",
            "extern void ext3_set_aops(struct inode *inode);",
            "extern int ext3_orphan_add(handle_t *, struct inode *);",
            "extern int ext3_orphan_del(handle_t *, struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nextern void ext3_init_block_alloc_info(struct inode *);\nextern void ext3_free_inode (handle_t *, struct inode *);\nstruct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);\nstruct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);\nextern void ext3_evict_inode (struct inode *);\nextern int  ext3_sync_inode (handle_t *, struct inode *);\nextern void ext3_discard_reservation (struct inode *);\nextern void ext3_dirty_inode(struct inode *, int);\nextern int ext3_change_inode_journal_flag(struct inode *, int);\nextern int ext3_can_truncate(struct inode *inode);\nextern void ext3_truncate(struct inode *inode);\nextern void ext3_set_inode_flags(struct inode *);\nextern void ext3_get_inode_flags(struct ext3_inode_info *);\nextern void ext3_set_aops(struct inode *inode);\nextern int ext3_orphan_add(handle_t *, struct inode *);\nextern int ext3_orphan_del(handle_t *, struct inode *);\n\nstatic inline struct ext3_inode_info *EXT3_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext3_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nextern void ext3_init_block_alloc_info(struct inode *);\nextern void ext3_free_inode (handle_t *, struct inode *);\nstruct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);\nstruct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);\nextern void ext3_evict_inode (struct inode *);\nextern int  ext3_sync_inode (handle_t *, struct inode *);\nextern void ext3_discard_reservation (struct inode *);\nextern void ext3_dirty_inode(struct inode *, int);\nextern int ext3_change_inode_journal_flag(struct inode *, int);\nextern int ext3_can_truncate(struct inode *inode);\nextern void ext3_truncate(struct inode *inode);\nextern void ext3_set_inode_flags(struct inode *);\nextern void ext3_set_aops(struct inode *inode);\nextern int ext3_orphan_add(handle_t *, struct inode *);\nextern int ext3_orphan_del(handle_t *, struct inode *);\n\nstatic inline void ext3_set_inode_state(struct inode *inode, int bit)\n{\n\tset_bit(bit, &EXT3_I(inode)->i_state_flags);\n}"
  },
  {
    "function_name": "ext3_test_inode_state",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
    "lines": "717-720",
    "snippet": "static inline int ext3_test_inode_state(struct inode *inode, int bit)\n{\n\treturn test_bit(bit, &EXT3_I(inode)->i_state_flags);\n}",
    "includes": [
      "#include <trace/events/ext3.h>",
      "#include <linux/blockgroup_lock.h>",
      "#include <linux/bug.h>",
      "#include <linux/magic.h>",
      "#include <linux/jbd.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "extern void ext3_init_block_alloc_info(struct inode *);",
      "extern void ext3_free_inode (handle_t *, struct inode *);",
      "struct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);",
      "struct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);",
      "extern void ext3_evict_inode (struct inode *);",
      "extern int  ext3_sync_inode (handle_t *, struct inode *);",
      "extern void ext3_discard_reservation (struct inode *);",
      "extern void ext3_dirty_inode(struct inode *, int);",
      "extern int ext3_change_inode_journal_flag(struct inode *, int);",
      "extern int ext3_can_truncate(struct inode *inode);",
      "extern void ext3_truncate(struct inode *inode);",
      "extern void ext3_set_inode_flags(struct inode *);",
      "extern void ext3_set_aops(struct inode *inode);",
      "extern int ext3_orphan_add(handle_t *, struct inode *);",
      "extern int ext3_orphan_del(handle_t *, struct inode *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "bit",
            "&EXT3_I(inode)->i_state_flags"
          ],
          "line": 719
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT3_I",
          "args": [
            "inode"
          ],
          "line": 719
        },
        "resolved": true,
        "details": {
          "function_name": "EXT3_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "693-696",
          "snippet": "static inline struct ext3_inode_info *EXT3_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext3_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void ext3_init_block_alloc_info(struct inode *);",
            "extern void ext3_free_inode (handle_t *, struct inode *);",
            "struct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);",
            "struct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);",
            "extern void ext3_evict_inode (struct inode *);",
            "extern int  ext3_sync_inode (handle_t *, struct inode *);",
            "extern void ext3_discard_reservation (struct inode *);",
            "extern void ext3_dirty_inode(struct inode *, int);",
            "extern int ext3_change_inode_journal_flag(struct inode *, int);",
            "extern int ext3_can_truncate(struct inode *inode);",
            "extern void ext3_truncate(struct inode *inode);",
            "extern void ext3_set_inode_flags(struct inode *);",
            "extern void ext3_get_inode_flags(struct ext3_inode_info *);",
            "extern void ext3_set_aops(struct inode *inode);",
            "extern int ext3_orphan_add(handle_t *, struct inode *);",
            "extern int ext3_orphan_del(handle_t *, struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nextern void ext3_init_block_alloc_info(struct inode *);\nextern void ext3_free_inode (handle_t *, struct inode *);\nstruct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);\nstruct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);\nextern void ext3_evict_inode (struct inode *);\nextern int  ext3_sync_inode (handle_t *, struct inode *);\nextern void ext3_discard_reservation (struct inode *);\nextern void ext3_dirty_inode(struct inode *, int);\nextern int ext3_change_inode_journal_flag(struct inode *, int);\nextern int ext3_can_truncate(struct inode *inode);\nextern void ext3_truncate(struct inode *inode);\nextern void ext3_set_inode_flags(struct inode *);\nextern void ext3_get_inode_flags(struct ext3_inode_info *);\nextern void ext3_set_aops(struct inode *inode);\nextern int ext3_orphan_add(handle_t *, struct inode *);\nextern int ext3_orphan_del(handle_t *, struct inode *);\n\nstatic inline struct ext3_inode_info *EXT3_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext3_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nextern void ext3_init_block_alloc_info(struct inode *);\nextern void ext3_free_inode (handle_t *, struct inode *);\nstruct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);\nstruct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);\nextern void ext3_evict_inode (struct inode *);\nextern int  ext3_sync_inode (handle_t *, struct inode *);\nextern void ext3_discard_reservation (struct inode *);\nextern void ext3_dirty_inode(struct inode *, int);\nextern int ext3_change_inode_journal_flag(struct inode *, int);\nextern int ext3_can_truncate(struct inode *inode);\nextern void ext3_truncate(struct inode *inode);\nextern void ext3_set_inode_flags(struct inode *);\nextern void ext3_set_aops(struct inode *inode);\nextern int ext3_orphan_add(handle_t *, struct inode *);\nextern int ext3_orphan_del(handle_t *, struct inode *);\n\nstatic inline int ext3_test_inode_state(struct inode *inode, int bit)\n{\n\treturn test_bit(bit, &EXT3_I(inode)->i_state_flags);\n}"
  },
  {
    "function_name": "ext3_valid_inum",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
    "lines": "698-705",
    "snippet": "static inline int ext3_valid_inum(struct super_block *sb, unsigned long ino)\n{\n\treturn ino == EXT3_ROOT_INO ||\n\t\tino == EXT3_JOURNAL_INO ||\n\t\tino == EXT3_RESIZE_INO ||\n\t\t(ino >= EXT3_FIRST_INO(sb) &&\n\t\t ino <= le32_to_cpu(EXT3_SB(sb)->s_es->s_inodes_count));\n}",
    "includes": [
      "#include <trace/events/ext3.h>",
      "#include <linux/blockgroup_lock.h>",
      "#include <linux/bug.h>",
      "#include <linux/magic.h>",
      "#include <linux/jbd.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [
      "#define EXT3_JOURNAL_INO\t 8\t/* Journal inode */",
      "#define EXT3_RESIZE_INO\t\t 7\t/* Reserved group descriptors inode */",
      "#define EXT3_ROOT_INO\t\t 2\t/* Root inode */"
    ],
    "globals_used": [
      "extern ext3_fsblk_t ext3_count_free_blocks (struct super_block *);",
      "extern void ext3_check_blocks_bitmap (struct super_block *);",
      "extern struct inode * ext3_orphan_get (struct super_block *, unsigned long);",
      "extern unsigned long ext3_count_free_inodes (struct super_block *);",
      "extern unsigned long ext3_count_dirs (struct super_block *);",
      "extern void ext3_check_inodes_bitmap (struct super_block *);",
      "extern struct inode *ext3_iget(struct super_block *, unsigned long);",
      "int ext3_force_commit(struct super_block *sb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "EXT3_SB(sb)->s_es->s_inodes_count"
          ],
          "line": 704
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT3_SB",
          "args": [
            "sb"
          ],
          "line": 704
        },
        "resolved": true,
        "details": {
          "function_name": "EXT3_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "689-692",
          "snippet": "static inline struct ext3_sb_info * EXT3_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern ext3_fsblk_t ext3_count_free_blocks (struct super_block *);",
            "extern void ext3_check_blocks_bitmap (struct super_block *);",
            "extern struct inode * ext3_orphan_get (struct super_block *, unsigned long);",
            "extern unsigned long ext3_count_free_inodes (struct super_block *);",
            "extern unsigned long ext3_count_dirs (struct super_block *);",
            "extern void ext3_check_inodes_bitmap (struct super_block *);",
            "extern struct inode *ext3_iget(struct super_block *, unsigned long);",
            "int ext3_force_commit(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nextern ext3_fsblk_t ext3_count_free_blocks (struct super_block *);\nextern void ext3_check_blocks_bitmap (struct super_block *);\nextern struct inode * ext3_orphan_get (struct super_block *, unsigned long);\nextern unsigned long ext3_count_free_inodes (struct super_block *);\nextern unsigned long ext3_count_dirs (struct super_block *);\nextern void ext3_check_inodes_bitmap (struct super_block *);\nextern struct inode *ext3_iget(struct super_block *, unsigned long);\nint ext3_force_commit(struct super_block *sb);\n\nstatic inline struct ext3_sb_info * EXT3_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT3_FIRST_INO",
          "args": [
            "sb"
          ],
          "line": 703
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\n#define EXT3_JOURNAL_INO\t 8\t/* Journal inode */\n#define EXT3_RESIZE_INO\t\t 7\t/* Reserved group descriptors inode */\n#define EXT3_ROOT_INO\t\t 2\t/* Root inode */\n\nextern ext3_fsblk_t ext3_count_free_blocks (struct super_block *);\nextern void ext3_check_blocks_bitmap (struct super_block *);\nextern struct inode * ext3_orphan_get (struct super_block *, unsigned long);\nextern unsigned long ext3_count_free_inodes (struct super_block *);\nextern unsigned long ext3_count_dirs (struct super_block *);\nextern void ext3_check_inodes_bitmap (struct super_block *);\nextern struct inode *ext3_iget(struct super_block *, unsigned long);\nint ext3_force_commit(struct super_block *sb);\n\nstatic inline int ext3_valid_inum(struct super_block *sb, unsigned long ino)\n{\n\treturn ino == EXT3_ROOT_INO ||\n\t\tino == EXT3_JOURNAL_INO ||\n\t\tino == EXT3_RESIZE_INO ||\n\t\t(ino >= EXT3_FIRST_INO(sb) &&\n\t\t ino <= le32_to_cpu(EXT3_SB(sb)->s_es->s_inodes_count));\n}"
  },
  {
    "function_name": "EXT3_I",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
    "lines": "693-696",
    "snippet": "static inline struct ext3_inode_info *EXT3_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext3_inode_info, vfs_inode);\n}",
    "includes": [
      "#include <trace/events/ext3.h>",
      "#include <linux/blockgroup_lock.h>",
      "#include <linux/bug.h>",
      "#include <linux/magic.h>",
      "#include <linux/jbd.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "extern void ext3_init_block_alloc_info(struct inode *);",
      "extern void ext3_free_inode (handle_t *, struct inode *);",
      "struct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);",
      "struct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);",
      "extern void ext3_evict_inode (struct inode *);",
      "extern int  ext3_sync_inode (handle_t *, struct inode *);",
      "extern void ext3_discard_reservation (struct inode *);",
      "extern void ext3_dirty_inode(struct inode *, int);",
      "extern int ext3_change_inode_journal_flag(struct inode *, int);",
      "extern int ext3_can_truncate(struct inode *inode);",
      "extern void ext3_truncate(struct inode *inode);",
      "extern void ext3_set_inode_flags(struct inode *);",
      "extern void ext3_get_inode_flags(struct ext3_inode_info *);",
      "extern void ext3_set_aops(struct inode *inode);",
      "extern int ext3_orphan_add(handle_t *, struct inode *);",
      "extern int ext3_orphan_del(handle_t *, struct inode *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "inode",
            "structext3_inode_info",
            "vfs_inode"
          ],
          "line": 695
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nextern void ext3_init_block_alloc_info(struct inode *);\nextern void ext3_free_inode (handle_t *, struct inode *);\nstruct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);\nstruct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);\nextern void ext3_evict_inode (struct inode *);\nextern int  ext3_sync_inode (handle_t *, struct inode *);\nextern void ext3_discard_reservation (struct inode *);\nextern void ext3_dirty_inode(struct inode *, int);\nextern int ext3_change_inode_journal_flag(struct inode *, int);\nextern int ext3_can_truncate(struct inode *inode);\nextern void ext3_truncate(struct inode *inode);\nextern void ext3_set_inode_flags(struct inode *);\nextern void ext3_get_inode_flags(struct ext3_inode_info *);\nextern void ext3_set_aops(struct inode *inode);\nextern int ext3_orphan_add(handle_t *, struct inode *);\nextern int ext3_orphan_del(handle_t *, struct inode *);\n\nstatic inline struct ext3_inode_info *EXT3_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext3_inode_info, vfs_inode);\n}"
  },
  {
    "function_name": "EXT3_SB",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
    "lines": "689-692",
    "snippet": "static inline struct ext3_sb_info * EXT3_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
    "includes": [
      "#include <trace/events/ext3.h>",
      "#include <linux/blockgroup_lock.h>",
      "#include <linux/bug.h>",
      "#include <linux/magic.h>",
      "#include <linux/jbd.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "extern ext3_fsblk_t ext3_count_free_blocks (struct super_block *);",
      "extern void ext3_check_blocks_bitmap (struct super_block *);",
      "extern struct inode * ext3_orphan_get (struct super_block *, unsigned long);",
      "extern unsigned long ext3_count_free_inodes (struct super_block *);",
      "extern unsigned long ext3_count_dirs (struct super_block *);",
      "extern void ext3_check_inodes_bitmap (struct super_block *);",
      "extern struct inode *ext3_iget(struct super_block *, unsigned long);",
      "int ext3_force_commit(struct super_block *sb);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nextern ext3_fsblk_t ext3_count_free_blocks (struct super_block *);\nextern void ext3_check_blocks_bitmap (struct super_block *);\nextern struct inode * ext3_orphan_get (struct super_block *, unsigned long);\nextern unsigned long ext3_count_free_inodes (struct super_block *);\nextern unsigned long ext3_count_dirs (struct super_block *);\nextern void ext3_check_inodes_bitmap (struct super_block *);\nextern struct inode *ext3_iget(struct super_block *, unsigned long);\nint ext3_force_commit(struct super_block *sb);\n\nstatic inline struct ext3_sb_info * EXT3_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
  },
  {
    "function_name": "sb_bgl_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
    "lines": "683-687",
    "snippet": "static inline spinlock_t *\nsb_bgl_lock(struct ext3_sb_info *sbi, unsigned int block_group)\n{\n\treturn bgl_lock_ptr(sbi->s_blockgroup_lock, block_group);\n}",
    "includes": [
      "#include <trace/events/ext3.h>",
      "#include <linux/blockgroup_lock.h>",
      "#include <linux/bug.h>",
      "#include <linux/magic.h>",
      "#include <linux/jbd.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bgl_lock_ptr",
          "args": [
            "sbi->s_blockgroup_lock",
            "block_group"
          ],
          "line": 686
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nstatic inline spinlock_t *\nsb_bgl_lock(struct ext3_sb_info *sbi, unsigned int block_group)\n{\n\treturn bgl_lock_ptr(sbi->s_blockgroup_lock, block_group);\n}"
  },
  {
    "function_name": "ext3_mask_flags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
    "lines": "173-181",
    "snippet": "static inline __u32 ext3_mask_flags(umode_t mode, __u32 flags)\n{\n\tif (S_ISDIR(mode))\n\t\treturn flags;\n\telse if (S_ISREG(mode))\n\t\treturn flags & EXT3_REG_FLMASK;\n\telse\n\t\treturn flags & EXT3_OTHER_FLMASK;\n}",
    "includes": [
      "#include <trace/events/ext3.h>",
      "#include <linux/blockgroup_lock.h>",
      "#include <linux/bug.h>",
      "#include <linux/magic.h>",
      "#include <linux/jbd.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [
      "#define EXT3_OTHER_FLMASK (EXT3_NODUMP_FL | EXT3_NOATIME_FL)",
      "#define EXT3_REG_FLMASK (~(EXT3_DIRSYNC_FL | EXT3_TOPDIR_FL))"
    ],
    "globals_used": [
      "extern struct inode * ext3_new_inode (handle_t *, struct inode *,\n\t\t\t\t      const struct qstr *, umode_t);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "mode"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "mode"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\n#define EXT3_OTHER_FLMASK (EXT3_NODUMP_FL | EXT3_NOATIME_FL)\n#define EXT3_REG_FLMASK (~(EXT3_DIRSYNC_FL | EXT3_TOPDIR_FL))\n\nextern struct inode * ext3_new_inode (handle_t *, struct inode *,\n\t\t\t\t      const struct qstr *, umode_t);\n\nstatic inline __u32 ext3_mask_flags(umode_t mode, __u32 flags)\n{\n\tif (S_ISDIR(mode))\n\t\treturn flags;\n\telse if (S_ISREG(mode))\n\t\treturn flags & EXT3_REG_FLMASK;\n\telse\n\t\treturn flags & EXT3_OTHER_FLMASK;\n}"
  }
]