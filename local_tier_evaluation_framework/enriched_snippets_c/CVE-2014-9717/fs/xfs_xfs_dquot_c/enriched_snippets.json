[
  {
    "function_name": "xfs_qm_exit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_dquot.c",
    "lines": "1099-1104",
    "snippet": "void\nxfs_qm_exit(void)\n{\n\tkmem_zone_destroy(xfs_qm_dqtrxzone);\n\tkmem_zone_destroy(xfs_qm_dqzone);\n}",
    "includes": [
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_qm.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "struct kmem_zone\t\t*xfs_qm_dqtrxzone;",
      "static struct kmem_zone\t\t*xfs_qm_dqzone;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_zone_destroy",
          "args": [
            "xfs_qm_dqzone"
          ],
          "line": 1103
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_zone_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/kmem.h",
          "lines": "110-115",
          "snippet": "static inline void\nkmem_zone_destroy(kmem_zone_t *zone)\n{\n\tif (zone)\n\t\tkmem_cache_destroy(zone);\n}",
          "includes": [
            "#include <linux/vmalloc.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [
            "#define kmem_zone_t\tstruct kmem_cache"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n\n#define kmem_zone_t\tstruct kmem_cache\n\nstatic inline void\nkmem_zone_destroy(kmem_zone_t *zone)\n{\n\tif (zone)\n\t\tkmem_cache_destroy(zone);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_qm.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstruct kmem_zone\t\t*xfs_qm_dqtrxzone;\nstatic struct kmem_zone\t\t*xfs_qm_dqzone;\n\nvoid\nxfs_qm_exit(void)\n{\n\tkmem_zone_destroy(xfs_qm_dqtrxzone);\n\tkmem_zone_destroy(xfs_qm_dqzone);\n}"
  },
  {
    "function_name": "xfs_qm_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_dquot.c",
    "lines": "1078-1097",
    "snippet": "int __init\nxfs_qm_init(void)\n{\n\txfs_qm_dqzone =\n\t\tkmem_zone_init(sizeof(struct xfs_dquot), \"xfs_dquot\");\n\tif (!xfs_qm_dqzone)\n\t\tgoto out;\n\n\txfs_qm_dqtrxzone =\n\t\tkmem_zone_init(sizeof(struct xfs_dquot_acct), \"xfs_dqtrx\");\n\tif (!xfs_qm_dqtrxzone)\n\t\tgoto out_free_dqzone;\n\n\treturn 0;\n\nout_free_dqzone:\n\tkmem_zone_destroy(xfs_qm_dqzone);\nout:\n\treturn -ENOMEM;\n}",
    "includes": [
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_qm.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "struct kmem_zone\t\t*xfs_qm_dqtrxzone;",
      "static struct kmem_zone\t\t*xfs_qm_dqzone;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_zone_destroy",
          "args": [
            "xfs_qm_dqzone"
          ],
          "line": 1094
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_zone_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/kmem.h",
          "lines": "110-115",
          "snippet": "static inline void\nkmem_zone_destroy(kmem_zone_t *zone)\n{\n\tif (zone)\n\t\tkmem_cache_destroy(zone);\n}",
          "includes": [
            "#include <linux/vmalloc.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [
            "#define kmem_zone_t\tstruct kmem_cache"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n\n#define kmem_zone_t\tstruct kmem_cache\n\nstatic inline void\nkmem_zone_destroy(kmem_zone_t *zone)\n{\n\tif (zone)\n\t\tkmem_cache_destroy(zone);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmem_zone_init",
          "args": [
            "sizeof(struct xfs_dquot_acct)",
            "\"xfs_dqtrx\""
          ],
          "line": 1087
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_zone_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/kmem.h",
          "lines": "91-95",
          "snippet": "static inline kmem_zone_t *\nkmem_zone_init(int size, char *zone_name)\n{\n\treturn kmem_cache_create(zone_name, size, 0, 0, NULL);\n}",
          "includes": [
            "#include <linux/vmalloc.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [
            "#define kmem_zone_t\tstruct kmem_cache"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n\n#define kmem_zone_t\tstruct kmem_cache\n\nstatic inline kmem_zone_t *\nkmem_zone_init(int size, char *zone_name)\n{\n\treturn kmem_cache_create(zone_name, size, 0, 0, NULL);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_qm.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstruct kmem_zone\t\t*xfs_qm_dqtrxzone;\nstatic struct kmem_zone\t\t*xfs_qm_dqzone;\n\nint __init\nxfs_qm_init(void)\n{\n\txfs_qm_dqzone =\n\t\tkmem_zone_init(sizeof(struct xfs_dquot), \"xfs_dquot\");\n\tif (!xfs_qm_dqzone)\n\t\tgoto out;\n\n\txfs_qm_dqtrxzone =\n\t\tkmem_zone_init(sizeof(struct xfs_dquot_acct), \"xfs_dqtrx\");\n\tif (!xfs_qm_dqtrxzone)\n\t\tgoto out_free_dqzone;\n\n\treturn 0;\n\nout_free_dqzone:\n\tkmem_zone_destroy(xfs_qm_dqzone);\nout:\n\treturn -ENOMEM;\n}"
  },
  {
    "function_name": "xfs_dqlock2",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_dquot.c",
    "lines": "1056-1076",
    "snippet": "void\nxfs_dqlock2(\n\txfs_dquot_t\t*d1,\n\txfs_dquot_t\t*d2)\n{\n\tif (d1 && d2) {\n\t\tASSERT(d1 != d2);\n\t\tif (be32_to_cpu(d1->q_core.d_id) >\n\t\t    be32_to_cpu(d2->q_core.d_id)) {\n\t\t\tmutex_lock(&d2->q_qlock);\n\t\t\tmutex_lock_nested(&d1->q_qlock, XFS_QLOCK_NESTED);\n\t\t} else {\n\t\t\tmutex_lock(&d1->q_qlock);\n\t\t\tmutex_lock_nested(&d2->q_qlock, XFS_QLOCK_NESTED);\n\t\t}\n\t} else if (d1) {\n\t\tmutex_lock(&d1->q_qlock);\n\t} else if (d2) {\n\t\tmutex_lock(&d2->q_qlock);\n\t}\n}",
    "includes": [
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_qm.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&d2->q_qlock"
          ],
          "line": 1074
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&d1->q_qlock"
          ],
          "line": 1072
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock_nested",
          "args": [
            "&d2->q_qlock",
            "XFS_QLOCK_NESTED"
          ],
          "line": 1069
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&d1->q_qlock"
          ],
          "line": 1068
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock_nested",
          "args": [
            "&d1->q_qlock",
            "XFS_QLOCK_NESTED"
          ],
          "line": 1066
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&d2->q_qlock"
          ],
          "line": 1065
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "d2->q_core.d_id"
          ],
          "line": 1064
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "d1->q_core.d_id"
          ],
          "line": 1063
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "d1 != d2"
          ],
          "line": 1062
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_qm.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_dqlock2(\n\txfs_dquot_t\t*d1,\n\txfs_dquot_t\t*d2)\n{\n\tif (d1 && d2) {\n\t\tASSERT(d1 != d2);\n\t\tif (be32_to_cpu(d1->q_core.d_id) >\n\t\t    be32_to_cpu(d2->q_core.d_id)) {\n\t\t\tmutex_lock(&d2->q_qlock);\n\t\t\tmutex_lock_nested(&d1->q_qlock, XFS_QLOCK_NESTED);\n\t\t} else {\n\t\t\tmutex_lock(&d1->q_qlock);\n\t\t\tmutex_lock_nested(&d2->q_qlock, XFS_QLOCK_NESTED);\n\t\t}\n\t} else if (d1) {\n\t\tmutex_lock(&d1->q_qlock);\n\t} else if (d2) {\n\t\tmutex_lock(&d2->q_qlock);\n\t}\n}"
  },
  {
    "function_name": "xfs_qm_dqflush",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_dquot.c",
    "lines": "930-1048",
    "snippet": "int\nxfs_qm_dqflush(\n\tstruct xfs_dquot\t*dqp,\n\tstruct xfs_buf\t\t**bpp)\n{\n\tstruct xfs_mount\t*mp = dqp->q_mount;\n\tstruct xfs_buf\t\t*bp;\n\tstruct xfs_disk_dquot\t*ddqp;\n\tint\t\t\terror;\n\n\tASSERT(XFS_DQ_IS_LOCKED(dqp));\n\tASSERT(!completion_done(&dqp->q_flush));\n\n\ttrace_xfs_dqflush(dqp);\n\n\t*bpp = NULL;\n\n\txfs_qm_dqunpin_wait(dqp);\n\n\t/*\n\t * This may have been unpinned because the filesystem is shutting\n\t * down forcibly. If that's the case we must not write this dquot\n\t * to disk, because the log record didn't make it to disk.\n\t *\n\t * We also have to remove the log item from the AIL in this case,\n\t * as we wait for an emptry AIL as part of the unmount process.\n\t */\n\tif (XFS_FORCED_SHUTDOWN(mp)) {\n\t\tstruct xfs_log_item\t*lip = &dqp->q_logitem.qli_item;\n\t\tdqp->dq_flags &= ~XFS_DQ_DIRTY;\n\n\t\tspin_lock(&mp->m_ail->xa_lock);\n\t\tif (lip->li_flags & XFS_LI_IN_AIL)\n\t\t\txfs_trans_ail_delete(mp->m_ail, lip,\n\t\t\t\t\t     SHUTDOWN_CORRUPT_INCORE);\n\t\telse\n\t\t\tspin_unlock(&mp->m_ail->xa_lock);\n\t\terror = -EIO;\n\t\tgoto out_unlock;\n\t}\n\n\t/*\n\t * Get the buffer containing the on-disk dquot\n\t */\n\terror = xfs_trans_read_buf(mp, NULL, mp->m_ddev_targp, dqp->q_blkno,\n\t\t\t\t   mp->m_quotainfo->qi_dqchunklen, 0, &bp,\n\t\t\t\t   &xfs_dquot_buf_ops);\n\tif (error)\n\t\tgoto out_unlock;\n\n\t/*\n\t * Calculate the location of the dquot inside the buffer.\n\t */\n\tddqp = bp->b_addr + dqp->q_bufoffset;\n\n\t/*\n\t * A simple sanity check in case we got a corrupted dquot..\n\t */\n\terror = xfs_dqcheck(mp, &dqp->q_core, be32_to_cpu(ddqp->d_id), 0,\n\t\t\t   XFS_QMOPT_DOWARN, \"dqflush (incore copy)\");\n\tif (error) {\n\t\txfs_buf_relse(bp);\n\t\txfs_dqfunlock(dqp);\n\t\txfs_force_shutdown(mp, SHUTDOWN_CORRUPT_INCORE);\n\t\treturn -EIO;\n\t}\n\n\t/* This is the only portion of data that needs to persist */\n\tmemcpy(ddqp, &dqp->q_core, sizeof(xfs_disk_dquot_t));\n\n\t/*\n\t * Clear the dirty field and remember the flush lsn for later use.\n\t */\n\tdqp->dq_flags &= ~XFS_DQ_DIRTY;\n\n\txfs_trans_ail_copy_lsn(mp->m_ail, &dqp->q_logitem.qli_flush_lsn,\n\t\t\t\t\t&dqp->q_logitem.qli_item.li_lsn);\n\n\t/*\n\t * copy the lsn into the on-disk dquot now while we have the in memory\n\t * dquot here. This can't be done later in the write verifier as we\n\t * can't get access to the log item at that point in time.\n\t *\n\t * We also calculate the CRC here so that the on-disk dquot in the\n\t * buffer always has a valid CRC. This ensures there is no possibility\n\t * of a dquot without an up-to-date CRC getting to disk.\n\t */\n\tif (xfs_sb_version_hascrc(&mp->m_sb)) {\n\t\tstruct xfs_dqblk *dqb = (struct xfs_dqblk *)ddqp;\n\n\t\tdqb->dd_lsn = cpu_to_be64(dqp->q_logitem.qli_item.li_lsn);\n\t\txfs_update_cksum((char *)dqb, sizeof(struct xfs_dqblk),\n\t\t\t\t XFS_DQUOT_CRC_OFF);\n\t}\n\n\t/*\n\t * Attach an iodone routine so that we can remove this dquot from the\n\t * AIL and release the flush lock once the dquot is synced to disk.\n\t */\n\txfs_buf_attach_iodone(bp, xfs_qm_dqflush_done,\n\t\t\t\t  &dqp->q_logitem.qli_item);\n\n\t/*\n\t * If the buffer is pinned then push on the log so we won't\n\t * get stuck waiting in the write for too long.\n\t */\n\tif (xfs_buf_ispinned(bp)) {\n\t\ttrace_xfs_dqflush_force(dqp);\n\t\txfs_log_force(mp, 0);\n\t}\n\n\ttrace_xfs_dqflush_done(dqp);\n\t*bpp = bp;\n\treturn 0;\n\nout_unlock:\n\txfs_dqfunlock(dqp);\n\treturn -EIO;\n}",
    "includes": [
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_qm.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_dqfunlock",
          "args": [
            "dqp"
          ],
          "line": 1046
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dqfunlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_dquot.h",
          "lines": "94-97",
          "snippet": "static inline void xfs_dqfunlock(xfs_dquot_t *dqp)\n{\n\tcomplete(&dqp->q_flush);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void xfs_dqfunlock(xfs_dquot_t *dqp)\n{\n\tcomplete(&dqp->q_flush);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_xfs_dqflush_done",
          "args": [
            "dqp"
          ],
          "line": 1041
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_log_force",
          "args": [
            "mp",
            "0"
          ],
          "line": 1038
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_log_force_umount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
          "lines": "3896-3988",
          "snippet": "int\nxfs_log_force_umount(\n\tstruct xfs_mount\t*mp,\n\tint\t\t\tlogerror)\n{\n\tstruct xlog\t*log;\n\tint\t\tretval;\n\n\tlog = mp->m_log;\n\n\t/*\n\t * If this happens during log recovery, don't worry about\n\t * locking; the log isn't open for business yet.\n\t */\n\tif (!log ||\n\t    log->l_flags & XLOG_ACTIVE_RECOVERY) {\n\t\tmp->m_flags |= XFS_MOUNT_FS_SHUTDOWN;\n\t\tif (mp->m_sb_bp)\n\t\t\tXFS_BUF_DONE(mp->m_sb_bp);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Somebody could've already done the hard work for us.\n\t * No need to get locks for this.\n\t */\n\tif (logerror && log->l_iclog->ic_state & XLOG_STATE_IOERROR) {\n\t\tASSERT(XLOG_FORCED_SHUTDOWN(log));\n\t\treturn 1;\n\t}\n\n\t/*\n\t * Flush all the completed transactions to disk before marking the log\n\t * being shut down. We need to do it in this order to ensure that\n\t * completed operations are safely on disk before we shut down, and that\n\t * we don't have to issue any buffer IO after the shutdown flags are set\n\t * to guarantee this.\n\t */\n\tif (!logerror)\n\t\t_xfs_log_force(mp, XFS_LOG_SYNC, NULL);\n\n\t/*\n\t * mark the filesystem and the as in a shutdown state and wake\n\t * everybody up to tell them the bad news.\n\t */\n\tspin_lock(&log->l_icloglock);\n\tmp->m_flags |= XFS_MOUNT_FS_SHUTDOWN;\n\tif (mp->m_sb_bp)\n\t\tXFS_BUF_DONE(mp->m_sb_bp);\n\n\t/*\n\t * Mark the log and the iclogs with IO error flags to prevent any\n\t * further log IO from being issued or completed.\n\t */\n\tlog->l_flags |= XLOG_IO_ERROR;\n\tretval = xlog_state_ioerror(log);\n\tspin_unlock(&log->l_icloglock);\n\n\t/*\n\t * We don't want anybody waiting for log reservations after this. That\n\t * means we have to wake up everybody queued up on reserveq as well as\n\t * writeq.  In addition, we make sure in xlog_{re}grant_log_space that\n\t * we don't enqueue anything once the SHUTDOWN flag is set, and this\n\t * action is protected by the grant locks.\n\t */\n\txlog_grant_head_wake_all(&log->l_reserve_head);\n\txlog_grant_head_wake_all(&log->l_write_head);\n\n\t/*\n\t * Wake up everybody waiting on xfs_log_force. Wake the CIL push first\n\t * as if the log writes were completed. The abort handling in the log\n\t * item committed callback functions will do this again under lock to\n\t * avoid races.\n\t */\n\twake_up_all(&log->l_cilp->xc_commit_wait);\n\txlog_state_do_callback(log, XFS_LI_ABORTED, NULL);\n\n#ifdef XFSERRORDEBUG\n\t{\n\t\txlog_in_core_t\t*iclog;\n\n\t\tspin_lock(&log->l_icloglock);\n\t\ticlog = log->l_iclog;\n\t\tdo {\n\t\t\tASSERT(iclog->ic_callback == 0);\n\t\t\ticlog = iclog->ic_next;\n\t\t} while (iclog != log->l_iclog);\n\t\tspin_unlock(&log->l_icloglock);\n\t}\n#endif\n\t/* return non-zero if log IOERROR transition had already happened */\n\treturn retval;\n}",
          "includes": [
            "#include \"xfs_sb.h\"",
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC int\nxlog_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);",
            "STATIC void xlog_state_done_syncing(xlog_in_core_t *iclog, int);",
            "STATIC void\nxlog_state_do_callback(\n\tstruct xlog\t\t*log,\n\tint\t\t\taborted,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC int\nxlog_state_release_iclog(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC void\nxlog_state_want_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC int\nxlog_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);\nSTATIC void xlog_state_done_syncing(xlog_in_core_t *iclog, int);\nSTATIC void\nxlog_state_do_callback(\n\tstruct xlog\t\t*log,\n\tint\t\t\taborted,\n\tstruct xlog_in_core\t*iclog);\nSTATIC int\nxlog_state_release_iclog(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC void\nxlog_state_want_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);\nSTATIC struct;\n\nint\nxfs_log_force_umount(\n\tstruct xfs_mount\t*mp,\n\tint\t\t\tlogerror)\n{\n\tstruct xlog\t*log;\n\tint\t\tretval;\n\n\tlog = mp->m_log;\n\n\t/*\n\t * If this happens during log recovery, don't worry about\n\t * locking; the log isn't open for business yet.\n\t */\n\tif (!log ||\n\t    log->l_flags & XLOG_ACTIVE_RECOVERY) {\n\t\tmp->m_flags |= XFS_MOUNT_FS_SHUTDOWN;\n\t\tif (mp->m_sb_bp)\n\t\t\tXFS_BUF_DONE(mp->m_sb_bp);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Somebody could've already done the hard work for us.\n\t * No need to get locks for this.\n\t */\n\tif (logerror && log->l_iclog->ic_state & XLOG_STATE_IOERROR) {\n\t\tASSERT(XLOG_FORCED_SHUTDOWN(log));\n\t\treturn 1;\n\t}\n\n\t/*\n\t * Flush all the completed transactions to disk before marking the log\n\t * being shut down. We need to do it in this order to ensure that\n\t * completed operations are safely on disk before we shut down, and that\n\t * we don't have to issue any buffer IO after the shutdown flags are set\n\t * to guarantee this.\n\t */\n\tif (!logerror)\n\t\t_xfs_log_force(mp, XFS_LOG_SYNC, NULL);\n\n\t/*\n\t * mark the filesystem and the as in a shutdown state and wake\n\t * everybody up to tell them the bad news.\n\t */\n\tspin_lock(&log->l_icloglock);\n\tmp->m_flags |= XFS_MOUNT_FS_SHUTDOWN;\n\tif (mp->m_sb_bp)\n\t\tXFS_BUF_DONE(mp->m_sb_bp);\n\n\t/*\n\t * Mark the log and the iclogs with IO error flags to prevent any\n\t * further log IO from being issued or completed.\n\t */\n\tlog->l_flags |= XLOG_IO_ERROR;\n\tretval = xlog_state_ioerror(log);\n\tspin_unlock(&log->l_icloglock);\n\n\t/*\n\t * We don't want anybody waiting for log reservations after this. That\n\t * means we have to wake up everybody queued up on reserveq as well as\n\t * writeq.  In addition, we make sure in xlog_{re}grant_log_space that\n\t * we don't enqueue anything once the SHUTDOWN flag is set, and this\n\t * action is protected by the grant locks.\n\t */\n\txlog_grant_head_wake_all(&log->l_reserve_head);\n\txlog_grant_head_wake_all(&log->l_write_head);\n\n\t/*\n\t * Wake up everybody waiting on xfs_log_force. Wake the CIL push first\n\t * as if the log writes were completed. The abort handling in the log\n\t * item committed callback functions will do this again under lock to\n\t * avoid races.\n\t */\n\twake_up_all(&log->l_cilp->xc_commit_wait);\n\txlog_state_do_callback(log, XFS_LI_ABORTED, NULL);\n\n#ifdef XFSERRORDEBUG\n\t{\n\t\txlog_in_core_t\t*iclog;\n\n\t\tspin_lock(&log->l_icloglock);\n\t\ticlog = log->l_iclog;\n\t\tdo {\n\t\t\tASSERT(iclog->ic_callback == 0);\n\t\t\ticlog = iclog->ic_next;\n\t\t} while (iclog != log->l_iclog);\n\t\tspin_unlock(&log->l_icloglock);\n\t}\n#endif\n\t/* return non-zero if log IOERROR transition had already happened */\n\treturn retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_xfs_dqflush_force",
          "args": [
            "dqp"
          ],
          "line": 1037
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_buf_ispinned",
          "args": [
            "bp"
          ],
          "line": 1036
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_ispinned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.h",
          "lines": "356-359",
          "snippet": "static inline int xfs_buf_ispinned(struct xfs_buf *bp)\n{\n\treturn atomic_read(&bp->b_pin_count);\n}",
          "includes": [
            "#include <linux/list_lru.h>",
            "#include <linux/uio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/list_lru.h>\n#include <linux/uio.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/list.h>\n\nstatic inline int xfs_buf_ispinned(struct xfs_buf *bp)\n{\n\treturn atomic_read(&bp->b_pin_count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_buf_attach_iodone",
          "args": [
            "bp",
            "xfs_qm_dqflush_done",
            "&dqp->q_logitem.qli_item"
          ],
          "line": 1029
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_attach_iodone",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf_item.c",
          "lines": "987-1009",
          "snippet": "void\nxfs_buf_attach_iodone(\n\txfs_buf_t\t*bp,\n\tvoid\t\t(*cb)(xfs_buf_t *, xfs_log_item_t *),\n\txfs_log_item_t\t*lip)\n{\n\txfs_log_item_t\t*head_lip;\n\n\tASSERT(xfs_buf_islocked(bp));\n\n\tlip->li_cb = cb;\n\thead_lip = bp->b_fspriv;\n\tif (head_lip) {\n\t\tlip->li_bio_list = head_lip->li_bio_list;\n\t\thead_lip->li_bio_list = lip;\n\t} else {\n\t\tbp->b_fspriv = lip;\n\t}\n\n\tASSERT(bp->b_iodone == NULL ||\n\t       bp->b_iodone == xfs_buf_iodone_callbacks);\n\tbp->b_iodone = xfs_buf_iodone_callbacks;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC void\txfs_buf_do_callbacks(struct xfs_buf *bp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\txfs_buf_do_callbacks(struct xfs_buf *bp);\n\nvoid\nxfs_buf_attach_iodone(\n\txfs_buf_t\t*bp,\n\tvoid\t\t(*cb)(xfs_buf_t *, xfs_log_item_t *),\n\txfs_log_item_t\t*lip)\n{\n\txfs_log_item_t\t*head_lip;\n\n\tASSERT(xfs_buf_islocked(bp));\n\n\tlip->li_cb = cb;\n\thead_lip = bp->b_fspriv;\n\tif (head_lip) {\n\t\tlip->li_bio_list = head_lip->li_bio_list;\n\t\thead_lip->li_bio_list = lip;\n\t} else {\n\t\tbp->b_fspriv = lip;\n\t}\n\n\tASSERT(bp->b_iodone == NULL ||\n\t       bp->b_iodone == xfs_buf_iodone_callbacks);\n\tbp->b_iodone = xfs_buf_iodone_callbacks;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_update_cksum",
          "args": [
            "(char *)dqb",
            "sizeof(struct xfs_dqblk)",
            "XFS_DQUOT_CRC_OFF"
          ],
          "line": 1021
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_update_cksum",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_cksum.h",
          "lines": "44-50",
          "snippet": "static inline void\nxfs_update_cksum(char *buffer, size_t length, unsigned long cksum_offset)\n{\n\t__uint32_t crc = xfs_start_cksum(buffer, length, cksum_offset);\n\n\t*(__le32 *)(buffer + cksum_offset) = xfs_end_cksum(crc);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void\nxfs_update_cksum(char *buffer, size_t length, unsigned long cksum_offset)\n{\n\t__uint32_t crc = xfs_start_cksum(buffer, length, cksum_offset);\n\n\t*(__le32 *)(buffer + cksum_offset) = xfs_end_cksum(crc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "dqp->q_logitem.qli_item.li_lsn"
          ],
          "line": 1020
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_sb_version_hascrc",
          "args": [
            "&mp->m_sb"
          ],
          "line": 1017
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_sb_version_hascrc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_format.h",
          "lines": "547-550",
          "snippet": "static inline int xfs_sb_version_hascrc(struct xfs_sb *sbp)\n{\n\treturn XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5;\n}",
          "includes": [],
          "macros_used": [
            "#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */\n\nstatic inline int xfs_sb_version_hascrc(struct xfs_sb *sbp)\n{\n\treturn XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_ail_copy_lsn",
          "args": [
            "mp->m_ail",
            "&dqp->q_logitem.qli_flush_lsn",
            "&dqp->q_logitem.qli_item.li_lsn"
          ],
          "line": 1005
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_ail_copy_lsn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_priv.h",
          "lines": "151-159",
          "snippet": "static inline void\nxfs_trans_ail_copy_lsn(\n\tstruct xfs_ail\t*ailp,\n\txfs_lsn_t\t*dst,\n\txfs_lsn_t\t*src)\n{\n\tASSERT(sizeof(xfs_lsn_t) == 8);\n\t*dst = *src;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void\nxfs_trans_ail_copy_lsn(\n\tstruct xfs_ail\t*ailp,\n\txfs_lsn_t\t*dst,\n\txfs_lsn_t\t*src)\n{\n\tASSERT(sizeof(xfs_lsn_t) == 8);\n\t*dst = *src;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "ddqp",
            "&dqp->q_core",
            "sizeof(xfs_disk_dquot_t)"
          ],
          "line": 998
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_force_shutdown",
          "args": [
            "mp",
            "SHUTDOWN_CORRUPT_INCORE"
          ],
          "line": 993
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_buf_relse",
          "args": [
            "bp"
          ],
          "line": 991
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_relse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.h",
          "lines": "361-365",
          "snippet": "static inline void xfs_buf_relse(xfs_buf_t *bp)\n{\n\txfs_buf_unlock(bp);\n\txfs_buf_rele(bp);\n}",
          "includes": [
            "#include <linux/list_lru.h>",
            "#include <linux/uio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/list_lru.h>\n#include <linux/uio.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/list.h>\n\nstatic inline void xfs_buf_relse(xfs_buf_t *bp)\n{\n\txfs_buf_unlock(bp);\n\txfs_buf_rele(bp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dqcheck",
          "args": [
            "mp",
            "&dqp->q_core",
            "be32_to_cpu(ddqp->d_id)",
            "0",
            "XFS_QMOPT_DOWARN",
            "\"dqflush (incore copy)\""
          ],
          "line": 988
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dqcheck",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dquot_buf.c",
          "lines": "50-172",
          "snippet": "int\nxfs_dqcheck(\n\tstruct xfs_mount *mp,\n\txfs_disk_dquot_t *ddq,\n\txfs_dqid_t\t id,\n\tuint\t\t type,\t  /* used only when IO_dorepair is true */\n\tuint\t\t flags,\n\tchar\t\t *str)\n{\n\txfs_dqblk_t\t *d = (xfs_dqblk_t *)ddq;\n\tint\t\terrs = 0;\n\n\t/*\n\t * We can encounter an uninitialized dquot buffer for 2 reasons:\n\t * 1. If we crash while deleting the quotainode(s), and those blks got\n\t *    used for user data. This is because we take the path of regular\n\t *    file deletion; however, the size field of quotainodes is never\n\t *    updated, so all the tricks that we play in itruncate_finish\n\t *    don't quite matter.\n\t *\n\t * 2. We don't play the quota buffers when there's a quotaoff logitem.\n\t *    But the allocation will be replayed so we'll end up with an\n\t *    uninitialized quota block.\n\t *\n\t * This is all fine; things are still consistent, and we haven't lost\n\t * any quota information. Just don't complain about bad dquot blks.\n\t */\n\tif (ddq->d_magic != cpu_to_be16(XFS_DQUOT_MAGIC)) {\n\t\tif (flags & XFS_QMOPT_DOWARN)\n\t\t\txfs_alert(mp,\n\t\t\t\"%s : XFS dquot ID 0x%x, magic 0x%x != 0x%x\",\n\t\t\tstr, id, be16_to_cpu(ddq->d_magic), XFS_DQUOT_MAGIC);\n\t\terrs++;\n\t}\n\tif (ddq->d_version != XFS_DQUOT_VERSION) {\n\t\tif (flags & XFS_QMOPT_DOWARN)\n\t\t\txfs_alert(mp,\n\t\t\t\"%s : XFS dquot ID 0x%x, version 0x%x != 0x%x\",\n\t\t\tstr, id, ddq->d_version, XFS_DQUOT_VERSION);\n\t\terrs++;\n\t}\n\n\tif (ddq->d_flags != XFS_DQ_USER &&\n\t    ddq->d_flags != XFS_DQ_PROJ &&\n\t    ddq->d_flags != XFS_DQ_GROUP) {\n\t\tif (flags & XFS_QMOPT_DOWARN)\n\t\t\txfs_alert(mp,\n\t\t\t\"%s : XFS dquot ID 0x%x, unknown flags 0x%x\",\n\t\t\tstr, id, ddq->d_flags);\n\t\terrs++;\n\t}\n\n\tif (id != -1 && id != be32_to_cpu(ddq->d_id)) {\n\t\tif (flags & XFS_QMOPT_DOWARN)\n\t\t\txfs_alert(mp,\n\t\t\t\"%s : ondisk-dquot 0x%p, ID mismatch: \"\n\t\t\t\"0x%x expected, found id 0x%x\",\n\t\t\tstr, ddq, id, be32_to_cpu(ddq->d_id));\n\t\terrs++;\n\t}\n\n\tif (!errs && ddq->d_id) {\n\t\tif (ddq->d_blk_softlimit &&\n\t\t    be64_to_cpu(ddq->d_bcount) >\n\t\t\t\tbe64_to_cpu(ddq->d_blk_softlimit)) {\n\t\t\tif (!ddq->d_btimer) {\n\t\t\t\tif (flags & XFS_QMOPT_DOWARN)\n\t\t\t\t\txfs_alert(mp,\n\t\t\t\"%s : Dquot ID 0x%x (0x%p) BLK TIMER NOT STARTED\",\n\t\t\t\t\tstr, (int)be32_to_cpu(ddq->d_id), ddq);\n\t\t\t\terrs++;\n\t\t\t}\n\t\t}\n\t\tif (ddq->d_ino_softlimit &&\n\t\t    be64_to_cpu(ddq->d_icount) >\n\t\t\t\tbe64_to_cpu(ddq->d_ino_softlimit)) {\n\t\t\tif (!ddq->d_itimer) {\n\t\t\t\tif (flags & XFS_QMOPT_DOWARN)\n\t\t\t\t\txfs_alert(mp,\n\t\t\t\"%s : Dquot ID 0x%x (0x%p) INODE TIMER NOT STARTED\",\n\t\t\t\t\tstr, (int)be32_to_cpu(ddq->d_id), ddq);\n\t\t\t\terrs++;\n\t\t\t}\n\t\t}\n\t\tif (ddq->d_rtb_softlimit &&\n\t\t    be64_to_cpu(ddq->d_rtbcount) >\n\t\t\t\tbe64_to_cpu(ddq->d_rtb_softlimit)) {\n\t\t\tif (!ddq->d_rtbtimer) {\n\t\t\t\tif (flags & XFS_QMOPT_DOWARN)\n\t\t\t\t\txfs_alert(mp,\n\t\t\t\"%s : Dquot ID 0x%x (0x%p) RTBLK TIMER NOT STARTED\",\n\t\t\t\t\tstr, (int)be32_to_cpu(ddq->d_id), ddq);\n\t\t\t\terrs++;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!errs || !(flags & XFS_QMOPT_DQREPAIR))\n\t\treturn errs;\n\n\tif (flags & XFS_QMOPT_DOWARN)\n\t\txfs_notice(mp, \"Re-initializing dquot ID 0x%x\", id);\n\n\t/*\n\t * Typically, a repair is only requested by quotacheck.\n\t */\n\tASSERT(id != -1);\n\tASSERT(flags & XFS_QMOPT_DQREPAIR);\n\tmemset(d, 0, sizeof(xfs_dqblk_t));\n\n\td->dd_diskdq.d_magic = cpu_to_be16(XFS_DQUOT_MAGIC);\n\td->dd_diskdq.d_version = XFS_DQUOT_VERSION;\n\td->dd_diskdq.d_flags = type;\n\td->dd_diskdq.d_id = cpu_to_be32(id);\n\n\tif (xfs_sb_version_hascrc(&mp->m_sb)) {\n\t\tuuid_copy(&d->dd_uuid, &mp->m_sb.sb_uuid);\n\t\txfs_update_cksum((char *)d, sizeof(struct xfs_dqblk),\n\t\t\t\t XFS_DQUOT_CRC_OFF);\n\t}\n\n\treturn errs;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_qm.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_error.h\"\n#include \"xfs_qm.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_dqcheck(\n\tstruct xfs_mount *mp,\n\txfs_disk_dquot_t *ddq,\n\txfs_dqid_t\t id,\n\tuint\t\t type,\t  /* used only when IO_dorepair is true */\n\tuint\t\t flags,\n\tchar\t\t *str)\n{\n\txfs_dqblk_t\t *d = (xfs_dqblk_t *)ddq;\n\tint\t\terrs = 0;\n\n\t/*\n\t * We can encounter an uninitialized dquot buffer for 2 reasons:\n\t * 1. If we crash while deleting the quotainode(s), and those blks got\n\t *    used for user data. This is because we take the path of regular\n\t *    file deletion; however, the size field of quotainodes is never\n\t *    updated, so all the tricks that we play in itruncate_finish\n\t *    don't quite matter.\n\t *\n\t * 2. We don't play the quota buffers when there's a quotaoff logitem.\n\t *    But the allocation will be replayed so we'll end up with an\n\t *    uninitialized quota block.\n\t *\n\t * This is all fine; things are still consistent, and we haven't lost\n\t * any quota information. Just don't complain about bad dquot blks.\n\t */\n\tif (ddq->d_magic != cpu_to_be16(XFS_DQUOT_MAGIC)) {\n\t\tif (flags & XFS_QMOPT_DOWARN)\n\t\t\txfs_alert(mp,\n\t\t\t\"%s : XFS dquot ID 0x%x, magic 0x%x != 0x%x\",\n\t\t\tstr, id, be16_to_cpu(ddq->d_magic), XFS_DQUOT_MAGIC);\n\t\terrs++;\n\t}\n\tif (ddq->d_version != XFS_DQUOT_VERSION) {\n\t\tif (flags & XFS_QMOPT_DOWARN)\n\t\t\txfs_alert(mp,\n\t\t\t\"%s : XFS dquot ID 0x%x, version 0x%x != 0x%x\",\n\t\t\tstr, id, ddq->d_version, XFS_DQUOT_VERSION);\n\t\terrs++;\n\t}\n\n\tif (ddq->d_flags != XFS_DQ_USER &&\n\t    ddq->d_flags != XFS_DQ_PROJ &&\n\t    ddq->d_flags != XFS_DQ_GROUP) {\n\t\tif (flags & XFS_QMOPT_DOWARN)\n\t\t\txfs_alert(mp,\n\t\t\t\"%s : XFS dquot ID 0x%x, unknown flags 0x%x\",\n\t\t\tstr, id, ddq->d_flags);\n\t\terrs++;\n\t}\n\n\tif (id != -1 && id != be32_to_cpu(ddq->d_id)) {\n\t\tif (flags & XFS_QMOPT_DOWARN)\n\t\t\txfs_alert(mp,\n\t\t\t\"%s : ondisk-dquot 0x%p, ID mismatch: \"\n\t\t\t\"0x%x expected, found id 0x%x\",\n\t\t\tstr, ddq, id, be32_to_cpu(ddq->d_id));\n\t\terrs++;\n\t}\n\n\tif (!errs && ddq->d_id) {\n\t\tif (ddq->d_blk_softlimit &&\n\t\t    be64_to_cpu(ddq->d_bcount) >\n\t\t\t\tbe64_to_cpu(ddq->d_blk_softlimit)) {\n\t\t\tif (!ddq->d_btimer) {\n\t\t\t\tif (flags & XFS_QMOPT_DOWARN)\n\t\t\t\t\txfs_alert(mp,\n\t\t\t\"%s : Dquot ID 0x%x (0x%p) BLK TIMER NOT STARTED\",\n\t\t\t\t\tstr, (int)be32_to_cpu(ddq->d_id), ddq);\n\t\t\t\terrs++;\n\t\t\t}\n\t\t}\n\t\tif (ddq->d_ino_softlimit &&\n\t\t    be64_to_cpu(ddq->d_icount) >\n\t\t\t\tbe64_to_cpu(ddq->d_ino_softlimit)) {\n\t\t\tif (!ddq->d_itimer) {\n\t\t\t\tif (flags & XFS_QMOPT_DOWARN)\n\t\t\t\t\txfs_alert(mp,\n\t\t\t\"%s : Dquot ID 0x%x (0x%p) INODE TIMER NOT STARTED\",\n\t\t\t\t\tstr, (int)be32_to_cpu(ddq->d_id), ddq);\n\t\t\t\terrs++;\n\t\t\t}\n\t\t}\n\t\tif (ddq->d_rtb_softlimit &&\n\t\t    be64_to_cpu(ddq->d_rtbcount) >\n\t\t\t\tbe64_to_cpu(ddq->d_rtb_softlimit)) {\n\t\t\tif (!ddq->d_rtbtimer) {\n\t\t\t\tif (flags & XFS_QMOPT_DOWARN)\n\t\t\t\t\txfs_alert(mp,\n\t\t\t\"%s : Dquot ID 0x%x (0x%p) RTBLK TIMER NOT STARTED\",\n\t\t\t\t\tstr, (int)be32_to_cpu(ddq->d_id), ddq);\n\t\t\t\terrs++;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!errs || !(flags & XFS_QMOPT_DQREPAIR))\n\t\treturn errs;\n\n\tif (flags & XFS_QMOPT_DOWARN)\n\t\txfs_notice(mp, \"Re-initializing dquot ID 0x%x\", id);\n\n\t/*\n\t * Typically, a repair is only requested by quotacheck.\n\t */\n\tASSERT(id != -1);\n\tASSERT(flags & XFS_QMOPT_DQREPAIR);\n\tmemset(d, 0, sizeof(xfs_dqblk_t));\n\n\td->dd_diskdq.d_magic = cpu_to_be16(XFS_DQUOT_MAGIC);\n\td->dd_diskdq.d_version = XFS_DQUOT_VERSION;\n\td->dd_diskdq.d_flags = type;\n\td->dd_diskdq.d_id = cpu_to_be32(id);\n\n\tif (xfs_sb_version_hascrc(&mp->m_sb)) {\n\t\tuuid_copy(&d->dd_uuid, &mp->m_sb.sb_uuid);\n\t\txfs_update_cksum((char *)d, sizeof(struct xfs_dqblk),\n\t\t\t\t XFS_DQUOT_CRC_OFF);\n\t}\n\n\treturn errs;\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "ddqp->d_id"
          ],
          "line": 988
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_trans_read_buf",
          "args": [
            "mp",
            "NULL",
            "mp->m_ddev_targp",
            "dqp->q_blkno",
            "mp->m_quotainfo->qi_dqchunklen",
            "0",
            "&bp",
            "&xfs_dquot_buf_ops"
          ],
          "line": 974
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_read_buf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.h",
          "lines": "186-200",
          "snippet": "static inline int\nxfs_trans_read_buf(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_buftarg\t*target,\n\txfs_daddr_t\t\tblkno,\n\tint\t\t\tnumblks,\n\txfs_buf_flags_t\t\tflags,\n\tstruct xfs_buf\t\t**bpp,\n\tconst struct xfs_buf_ops *ops)\n{\n\tDEFINE_SINGLE_BUF_MAP(map, blkno, numblks);\n\treturn xfs_trans_read_buf_map(mp, tp, target, &map, 1,\n\t\t\t\t      flags, bpp, ops);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int\nxfs_trans_read_buf(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_buftarg\t*target,\n\txfs_daddr_t\t\tblkno,\n\tint\t\t\tnumblks,\n\txfs_buf_flags_t\t\tflags,\n\tstruct xfs_buf\t\t**bpp,\n\tconst struct xfs_buf_ops *ops)\n{\n\tDEFINE_SINGLE_BUF_MAP(map, blkno, numblks);\n\treturn xfs_trans_read_buf_map(mp, tp, target, &map, 1,\n\t\t\t\t      flags, bpp, ops);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&mp->m_ail->xa_lock"
          ],
          "line": 966
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_ail_delete",
          "args": [
            "mp->m_ail",
            "lip",
            "SHUTDOWN_CORRUPT_INCORE"
          ],
          "line": 963
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_ail_delete",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_priv.h",
          "lines": "113-120",
          "snippet": "static inline void\nxfs_trans_ail_delete(\n\tstruct xfs_ail\t*ailp,\n\txfs_log_item_t\t*lip,\n\tint\t\tshutdown_type) __releases(ailp->xa_lock)\n{\n\txfs_trans_ail_delete_bulk(ailp, &lip, 1, shutdown_type);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void\nxfs_trans_ail_delete(\n\tstruct xfs_ail\t*ailp,\n\txfs_log_item_t\t*lip,\n\tint\t\tshutdown_type) __releases(ailp->xa_lock)\n{\n\txfs_trans_ail_delete_bulk(ailp, &lip, 1, shutdown_type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&mp->m_ail->xa_lock"
          ],
          "line": 961
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_FORCED_SHUTDOWN",
          "args": [
            "mp"
          ],
          "line": 957
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_qm_dqunpin_wait",
          "args": [
            "dqp"
          ],
          "line": 947
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_qm_dqunpin_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_dquot_item.c",
          "lines": "125-138",
          "snippet": "void\nxfs_qm_dqunpin_wait(\n\tstruct xfs_dquot\t*dqp)\n{\n\tASSERT(XFS_DQ_IS_LOCKED(dqp));\n\tif (atomic_read(&dqp->q_pincount) == 0)\n\t\treturn;\n\n\t/*\n\t * Give the log a push so we don't wait here too long.\n\t */\n\txfs_log_force(dqp->q_mount, 0);\n\twait_event(dqp->q_pinwait, (atomic_read(&dqp->q_pincount) == 0));\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_qm.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_qm.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_qm_dqunpin_wait(\n\tstruct xfs_dquot\t*dqp)\n{\n\tASSERT(XFS_DQ_IS_LOCKED(dqp));\n\tif (atomic_read(&dqp->q_pincount) == 0)\n\t\treturn;\n\n\t/*\n\t * Give the log a push so we don't wait here too long.\n\t */\n\txfs_log_force(dqp->q_mount, 0);\n\twait_event(dqp->q_pinwait, (atomic_read(&dqp->q_pincount) == 0));\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_xfs_dqflush",
          "args": [
            "dqp"
          ],
          "line": 943
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "!completion_done(&dqp->q_flush)"
          ],
          "line": 941
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "completion_done",
          "args": [
            "&dqp->q_flush"
          ],
          "line": 941
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "XFS_DQ_IS_LOCKED(dqp)"
          ],
          "line": 940
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_DQ_IS_LOCKED",
          "args": [
            "dqp"
          ],
          "line": 940
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_qm.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_qm_dqflush(\n\tstruct xfs_dquot\t*dqp,\n\tstruct xfs_buf\t\t**bpp)\n{\n\tstruct xfs_mount\t*mp = dqp->q_mount;\n\tstruct xfs_buf\t\t*bp;\n\tstruct xfs_disk_dquot\t*ddqp;\n\tint\t\t\terror;\n\n\tASSERT(XFS_DQ_IS_LOCKED(dqp));\n\tASSERT(!completion_done(&dqp->q_flush));\n\n\ttrace_xfs_dqflush(dqp);\n\n\t*bpp = NULL;\n\n\txfs_qm_dqunpin_wait(dqp);\n\n\t/*\n\t * This may have been unpinned because the filesystem is shutting\n\t * down forcibly. If that's the case we must not write this dquot\n\t * to disk, because the log record didn't make it to disk.\n\t *\n\t * We also have to remove the log item from the AIL in this case,\n\t * as we wait for an emptry AIL as part of the unmount process.\n\t */\n\tif (XFS_FORCED_SHUTDOWN(mp)) {\n\t\tstruct xfs_log_item\t*lip = &dqp->q_logitem.qli_item;\n\t\tdqp->dq_flags &= ~XFS_DQ_DIRTY;\n\n\t\tspin_lock(&mp->m_ail->xa_lock);\n\t\tif (lip->li_flags & XFS_LI_IN_AIL)\n\t\t\txfs_trans_ail_delete(mp->m_ail, lip,\n\t\t\t\t\t     SHUTDOWN_CORRUPT_INCORE);\n\t\telse\n\t\t\tspin_unlock(&mp->m_ail->xa_lock);\n\t\terror = -EIO;\n\t\tgoto out_unlock;\n\t}\n\n\t/*\n\t * Get the buffer containing the on-disk dquot\n\t */\n\terror = xfs_trans_read_buf(mp, NULL, mp->m_ddev_targp, dqp->q_blkno,\n\t\t\t\t   mp->m_quotainfo->qi_dqchunklen, 0, &bp,\n\t\t\t\t   &xfs_dquot_buf_ops);\n\tif (error)\n\t\tgoto out_unlock;\n\n\t/*\n\t * Calculate the location of the dquot inside the buffer.\n\t */\n\tddqp = bp->b_addr + dqp->q_bufoffset;\n\n\t/*\n\t * A simple sanity check in case we got a corrupted dquot..\n\t */\n\terror = xfs_dqcheck(mp, &dqp->q_core, be32_to_cpu(ddqp->d_id), 0,\n\t\t\t   XFS_QMOPT_DOWARN, \"dqflush (incore copy)\");\n\tif (error) {\n\t\txfs_buf_relse(bp);\n\t\txfs_dqfunlock(dqp);\n\t\txfs_force_shutdown(mp, SHUTDOWN_CORRUPT_INCORE);\n\t\treturn -EIO;\n\t}\n\n\t/* This is the only portion of data that needs to persist */\n\tmemcpy(ddqp, &dqp->q_core, sizeof(xfs_disk_dquot_t));\n\n\t/*\n\t * Clear the dirty field and remember the flush lsn for later use.\n\t */\n\tdqp->dq_flags &= ~XFS_DQ_DIRTY;\n\n\txfs_trans_ail_copy_lsn(mp->m_ail, &dqp->q_logitem.qli_flush_lsn,\n\t\t\t\t\t&dqp->q_logitem.qli_item.li_lsn);\n\n\t/*\n\t * copy the lsn into the on-disk dquot now while we have the in memory\n\t * dquot here. This can't be done later in the write verifier as we\n\t * can't get access to the log item at that point in time.\n\t *\n\t * We also calculate the CRC here so that the on-disk dquot in the\n\t * buffer always has a valid CRC. This ensures there is no possibility\n\t * of a dquot without an up-to-date CRC getting to disk.\n\t */\n\tif (xfs_sb_version_hascrc(&mp->m_sb)) {\n\t\tstruct xfs_dqblk *dqb = (struct xfs_dqblk *)ddqp;\n\n\t\tdqb->dd_lsn = cpu_to_be64(dqp->q_logitem.qli_item.li_lsn);\n\t\txfs_update_cksum((char *)dqb, sizeof(struct xfs_dqblk),\n\t\t\t\t XFS_DQUOT_CRC_OFF);\n\t}\n\n\t/*\n\t * Attach an iodone routine so that we can remove this dquot from the\n\t * AIL and release the flush lock once the dquot is synced to disk.\n\t */\n\txfs_buf_attach_iodone(bp, xfs_qm_dqflush_done,\n\t\t\t\t  &dqp->q_logitem.qli_item);\n\n\t/*\n\t * If the buffer is pinned then push on the log so we won't\n\t * get stuck waiting in the write for too long.\n\t */\n\tif (xfs_buf_ispinned(bp)) {\n\t\ttrace_xfs_dqflush_force(dqp);\n\t\txfs_log_force(mp, 0);\n\t}\n\n\ttrace_xfs_dqflush_done(dqp);\n\t*bpp = bp;\n\treturn 0;\n\nout_unlock:\n\txfs_dqfunlock(dqp);\n\treturn -EIO;\n}"
  },
  {
    "function_name": "xfs_qm_dqflush_done",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_dquot.c",
    "lines": "888-920",
    "snippet": "STATIC void\nxfs_qm_dqflush_done(\n\tstruct xfs_buf\t\t*bp,\n\tstruct xfs_log_item\t*lip)\n{\n\txfs_dq_logitem_t\t*qip = (struct xfs_dq_logitem *)lip;\n\txfs_dquot_t\t\t*dqp = qip->qli_dquot;\n\tstruct xfs_ail\t\t*ailp = lip->li_ailp;\n\n\t/*\n\t * We only want to pull the item from the AIL if its\n\t * location in the log has not changed since we started the flush.\n\t * Thus, we only bother if the dquot's lsn has\n\t * not changed. First we check the lsn outside the lock\n\t * since it's cheaper, and then we recheck while\n\t * holding the lock before removing the dquot from the AIL.\n\t */\n\tif ((lip->li_flags & XFS_LI_IN_AIL) &&\n\t    lip->li_lsn == qip->qli_flush_lsn) {\n\n\t\t/* xfs_trans_ail_delete() drops the AIL lock. */\n\t\tspin_lock(&ailp->xa_lock);\n\t\tif (lip->li_lsn == qip->qli_flush_lsn)\n\t\t\txfs_trans_ail_delete(ailp, lip, SHUTDOWN_CORRUPT_INCORE);\n\t\telse\n\t\t\tspin_unlock(&ailp->xa_lock);\n\t}\n\n\t/*\n\t * Release the dq's flush lock since we're done with it.\n\t */\n\txfs_dqfunlock(dqp);\n}",
    "includes": [
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_qm.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_dqfunlock",
          "args": [
            "dqp"
          ],
          "line": 919
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dqfunlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_dquot.h",
          "lines": "94-97",
          "snippet": "static inline void xfs_dqfunlock(xfs_dquot_t *dqp)\n{\n\tcomplete(&dqp->q_flush);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void xfs_dqfunlock(xfs_dquot_t *dqp)\n{\n\tcomplete(&dqp->q_flush);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ailp->xa_lock"
          ],
          "line": 913
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_ail_delete",
          "args": [
            "ailp",
            "lip",
            "SHUTDOWN_CORRUPT_INCORE"
          ],
          "line": 911
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_ail_delete",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_priv.h",
          "lines": "113-120",
          "snippet": "static inline void\nxfs_trans_ail_delete(\n\tstruct xfs_ail\t*ailp,\n\txfs_log_item_t\t*lip,\n\tint\t\tshutdown_type) __releases(ailp->xa_lock)\n{\n\txfs_trans_ail_delete_bulk(ailp, &lip, 1, shutdown_type);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void\nxfs_trans_ail_delete(\n\tstruct xfs_ail\t*ailp,\n\txfs_log_item_t\t*lip,\n\tint\t\tshutdown_type) __releases(ailp->xa_lock)\n{\n\txfs_trans_ail_delete_bulk(ailp, &lip, 1, shutdown_type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ailp->xa_lock"
          ],
          "line": 909
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_qm.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\nxfs_qm_dqflush_done(\n\tstruct xfs_buf\t\t*bp,\n\tstruct xfs_log_item\t*lip)\n{\n\txfs_dq_logitem_t\t*qip = (struct xfs_dq_logitem *)lip;\n\txfs_dquot_t\t\t*dqp = qip->qli_dquot;\n\tstruct xfs_ail\t\t*ailp = lip->li_ailp;\n\n\t/*\n\t * We only want to pull the item from the AIL if its\n\t * location in the log has not changed since we started the flush.\n\t * Thus, we only bother if the dquot's lsn has\n\t * not changed. First we check the lsn outside the lock\n\t * since it's cheaper, and then we recheck while\n\t * holding the lock before removing the dquot from the AIL.\n\t */\n\tif ((lip->li_flags & XFS_LI_IN_AIL) &&\n\t    lip->li_lsn == qip->qli_flush_lsn) {\n\n\t\t/* xfs_trans_ail_delete() drops the AIL lock. */\n\t\tspin_lock(&ailp->xa_lock);\n\t\tif (lip->li_lsn == qip->qli_flush_lsn)\n\t\t\txfs_trans_ail_delete(ailp, lip, SHUTDOWN_CORRUPT_INCORE);\n\t\telse\n\t\t\tspin_unlock(&ailp->xa_lock);\n\t}\n\n\t/*\n\t * Release the dq's flush lock since we're done with it.\n\t */\n\txfs_dqfunlock(dqp);\n}"
  },
  {
    "function_name": "xfs_qm_dqrele",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_dquot.c",
    "lines": "862-879",
    "snippet": "void\nxfs_qm_dqrele(\n\txfs_dquot_t\t*dqp)\n{\n\tif (!dqp)\n\t\treturn;\n\n\ttrace_xfs_dqrele(dqp);\n\n\txfs_dqlock(dqp);\n\t/*\n\t * We don't care to flush it if the dquot is dirty here.\n\t * That will create stutters that we want to avoid.\n\t * Instead we do a delayed write when we try to reclaim\n\t * a dirty dquot. Also xfs_sync will take part of the burden...\n\t */\n\txfs_qm_dqput(dqp);\n}",
    "includes": [
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_qm.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_qm_dqput",
          "args": [
            "dqp"
          ],
          "line": 878
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_qm_dqput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_dquot.c",
          "lines": "839-856",
          "snippet": "void\nxfs_qm_dqput(\n\tstruct xfs_dquot\t*dqp)\n{\n\tASSERT(dqp->q_nrefs > 0);\n\tASSERT(XFS_DQ_IS_LOCKED(dqp));\n\n\ttrace_xfs_dqput(dqp);\n\n\tif (--dqp->q_nrefs == 0) {\n\t\tstruct xfs_quotainfo\t*qi = dqp->q_mount->m_quotainfo;\n\t\ttrace_xfs_dqput_free(dqp);\n\n\t\tif (list_lru_add(&qi->qi_lru, &dqp->q_lru))\n\t\t\tXFS_STATS_INC(xs_qm_dquot_unused);\n\t}\n\txfs_dqunlock(dqp);\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_qm.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_qm.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_qm_dqput(\n\tstruct xfs_dquot\t*dqp)\n{\n\tASSERT(dqp->q_nrefs > 0);\n\tASSERT(XFS_DQ_IS_LOCKED(dqp));\n\n\ttrace_xfs_dqput(dqp);\n\n\tif (--dqp->q_nrefs == 0) {\n\t\tstruct xfs_quotainfo\t*qi = dqp->q_mount->m_quotainfo;\n\t\ttrace_xfs_dqput_free(dqp);\n\n\t\tif (list_lru_add(&qi->qi_lru, &dqp->q_lru))\n\t\t\tXFS_STATS_INC(xs_qm_dquot_unused);\n\t}\n\txfs_dqunlock(dqp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dqlock",
          "args": [
            "dqp"
          ],
          "line": 871
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dqlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_dquot.h",
          "lines": "104-107",
          "snippet": "static inline void xfs_dqlock(struct xfs_dquot *dqp)\n{\n\tmutex_lock(&dqp->q_qlock);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void xfs_dqlock(struct xfs_dquot *dqp)\n{\n\tmutex_lock(&dqp->q_qlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_xfs_dqrele",
          "args": [
            "dqp"
          ],
          "line": 869
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_qm.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_qm_dqrele(\n\txfs_dquot_t\t*dqp)\n{\n\tif (!dqp)\n\t\treturn;\n\n\ttrace_xfs_dqrele(dqp);\n\n\txfs_dqlock(dqp);\n\t/*\n\t * We don't care to flush it if the dquot is dirty here.\n\t * That will create stutters that we want to avoid.\n\t * Instead we do a delayed write when we try to reclaim\n\t * a dirty dquot. Also xfs_sync will take part of the burden...\n\t */\n\txfs_qm_dqput(dqp);\n}"
  },
  {
    "function_name": "xfs_qm_dqput",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_dquot.c",
    "lines": "839-856",
    "snippet": "void\nxfs_qm_dqput(\n\tstruct xfs_dquot\t*dqp)\n{\n\tASSERT(dqp->q_nrefs > 0);\n\tASSERT(XFS_DQ_IS_LOCKED(dqp));\n\n\ttrace_xfs_dqput(dqp);\n\n\tif (--dqp->q_nrefs == 0) {\n\t\tstruct xfs_quotainfo\t*qi = dqp->q_mount->m_quotainfo;\n\t\ttrace_xfs_dqput_free(dqp);\n\n\t\tif (list_lru_add(&qi->qi_lru, &dqp->q_lru))\n\t\t\tXFS_STATS_INC(xs_qm_dquot_unused);\n\t}\n\txfs_dqunlock(dqp);\n}",
    "includes": [
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_qm.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_dqunlock",
          "args": [
            "dqp"
          ],
          "line": 855
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dqunlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_dquot.h",
          "lines": "109-112",
          "snippet": "static inline void xfs_dqunlock(struct xfs_dquot *dqp)\n{\n\tmutex_unlock(&dqp->q_qlock);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void xfs_dqunlock(struct xfs_dquot *dqp)\n{\n\tmutex_unlock(&dqp->q_qlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_STATS_INC",
          "args": [
            "xs_qm_dquot_unused"
          ],
          "line": 853
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_lru_add",
          "args": [
            "&qi->qi_lru",
            "&dqp->q_lru"
          ],
          "line": 852
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_xfs_dqput_free",
          "args": [
            "dqp"
          ],
          "line": 850
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_xfs_dqput",
          "args": [
            "dqp"
          ],
          "line": 846
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "XFS_DQ_IS_LOCKED(dqp)"
          ],
          "line": 844
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_DQ_IS_LOCKED",
          "args": [
            "dqp"
          ],
          "line": 844
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "dqp->q_nrefs > 0"
          ],
          "line": 843
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_qm.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_qm_dqput(\n\tstruct xfs_dquot\t*dqp)\n{\n\tASSERT(dqp->q_nrefs > 0);\n\tASSERT(XFS_DQ_IS_LOCKED(dqp));\n\n\ttrace_xfs_dqput(dqp);\n\n\tif (--dqp->q_nrefs == 0) {\n\t\tstruct xfs_quotainfo\t*qi = dqp->q_mount->m_quotainfo;\n\t\ttrace_xfs_dqput_free(dqp);\n\n\t\tif (list_lru_add(&qi->qi_lru, &dqp->q_lru))\n\t\t\tXFS_STATS_INC(xs_qm_dquot_unused);\n\t}\n\txfs_dqunlock(dqp);\n}"
  },
  {
    "function_name": "xfs_qm_dqget",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_dquot.c",
    "lines": "698-831",
    "snippet": "int\nxfs_qm_dqget(\n\txfs_mount_t\t*mp,\n\txfs_inode_t\t*ip,\t  /* locked inode (optional) */\n\txfs_dqid_t\tid,\t  /* uid/projid/gid depending on type */\n\tuint\t\ttype,\t  /* XFS_DQ_USER/XFS_DQ_PROJ/XFS_DQ_GROUP */\n\tuint\t\tflags,\t  /* DQALLOC, DQSUSER, DQREPAIR, DOWARN */\n\txfs_dquot_t\t**O_dqpp) /* OUT : locked incore dquot */\n{\n\tstruct xfs_quotainfo\t*qi = mp->m_quotainfo;\n\tstruct radix_tree_root *tree = xfs_dquot_tree(qi, type);\n\tstruct xfs_dquot\t*dqp;\n\tint\t\t\terror;\n\n\tASSERT(XFS_IS_QUOTA_RUNNING(mp));\n\tif ((! XFS_IS_UQUOTA_ON(mp) && type == XFS_DQ_USER) ||\n\t    (! XFS_IS_PQUOTA_ON(mp) && type == XFS_DQ_PROJ) ||\n\t    (! XFS_IS_GQUOTA_ON(mp) && type == XFS_DQ_GROUP)) {\n\t\treturn -ESRCH;\n\t}\n\n#ifdef DEBUG\n\tif (xfs_do_dqerror) {\n\t\tif ((xfs_dqerror_target == mp->m_ddev_targp) &&\n\t\t    (xfs_dqreq_num++ % xfs_dqerror_mod) == 0) {\n\t\t\txfs_debug(mp, \"Returning error in dqget\");\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\n\tASSERT(type == XFS_DQ_USER ||\n\t       type == XFS_DQ_PROJ ||\n\t       type == XFS_DQ_GROUP);\n\tif (ip) {\n\t\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\t\tASSERT(xfs_inode_dquot(ip, type) == NULL);\n\t}\n#endif\n\nrestart:\n\tmutex_lock(&qi->qi_tree_lock);\n\tdqp = radix_tree_lookup(tree, id);\n\tif (dqp) {\n\t\txfs_dqlock(dqp);\n\t\tif (dqp->dq_flags & XFS_DQ_FREEING) {\n\t\t\txfs_dqunlock(dqp);\n\t\t\tmutex_unlock(&qi->qi_tree_lock);\n\t\t\ttrace_xfs_dqget_freeing(dqp);\n\t\t\tdelay(1);\n\t\t\tgoto restart;\n\t\t}\n\n\t\tdqp->q_nrefs++;\n\t\tmutex_unlock(&qi->qi_tree_lock);\n\n\t\ttrace_xfs_dqget_hit(dqp);\n\t\tXFS_STATS_INC(xs_qm_dqcachehits);\n\t\t*O_dqpp = dqp;\n\t\treturn 0;\n\t}\n\tmutex_unlock(&qi->qi_tree_lock);\n\tXFS_STATS_INC(xs_qm_dqcachemisses);\n\n\t/*\n\t * Dquot cache miss. We don't want to keep the inode lock across\n\t * a (potential) disk read. Also we don't want to deal with the lock\n\t * ordering between quotainode and this inode. OTOH, dropping the inode\n\t * lock here means dealing with a chown that can happen before\n\t * we re-acquire the lock.\n\t */\n\tif (ip)\n\t\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\n\terror = xfs_qm_dqread(mp, id, type, flags, &dqp);\n\n\tif (ip)\n\t\txfs_ilock(ip, XFS_ILOCK_EXCL);\n\n\tif (error)\n\t\treturn error;\n\n\tif (ip) {\n\t\t/*\n\t\t * A dquot could be attached to this inode by now, since\n\t\t * we had dropped the ilock.\n\t\t */\n\t\tif (xfs_this_quota_on(mp, type)) {\n\t\t\tstruct xfs_dquot\t*dqp1;\n\n\t\t\tdqp1 = xfs_inode_dquot(ip, type);\n\t\t\tif (dqp1) {\n\t\t\t\txfs_qm_dqdestroy(dqp);\n\t\t\t\tdqp = dqp1;\n\t\t\t\txfs_dqlock(dqp);\n\t\t\t\tgoto dqret;\n\t\t\t}\n\t\t} else {\n\t\t\t/* inode stays locked on return */\n\t\t\txfs_qm_dqdestroy(dqp);\n\t\t\treturn -ESRCH;\n\t\t}\n\t}\n\n\tmutex_lock(&qi->qi_tree_lock);\n\terror = radix_tree_insert(tree, id, dqp);\n\tif (unlikely(error)) {\n\t\tWARN_ON(error != -EEXIST);\n\n\t\t/*\n\t\t * Duplicate found. Just throw away the new dquot and start\n\t\t * over.\n\t\t */\n\t\tmutex_unlock(&qi->qi_tree_lock);\n\t\ttrace_xfs_dqget_dup(dqp);\n\t\txfs_qm_dqdestroy(dqp);\n\t\tXFS_STATS_INC(xs_qm_dquot_dups);\n\t\tgoto restart;\n\t}\n\n\t/*\n\t * We return a locked dquot to the caller, with a reference taken\n\t */\n\txfs_dqlock(dqp);\n\tdqp->q_nrefs = 1;\n\n\tqi->qi_dquots++;\n\tmutex_unlock(&qi->qi_tree_lock);\n\n dqret:\n\tASSERT((ip == NULL) || xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\ttrace_xfs_dqget_miss(dqp);\n\t*O_dqpp = dqp;\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_qm.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_xfs_dqget_miss",
          "args": [
            "dqp"
          ],
          "line": 828
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "(ip == NULL) || xfs_isilocked(ip, XFS_ILOCK_EXCL)"
          ],
          "line": 827
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_isilocked",
          "args": [
            "ip",
            "XFS_ILOCK_EXCL"
          ],
          "line": 827
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_isilocked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
          "lines": "286-305",
          "snippet": "int\nxfs_isilocked(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\tif (lock_flags & (XFS_ILOCK_EXCL|XFS_ILOCK_SHARED)) {\n\t\tif (!(lock_flags & XFS_ILOCK_SHARED))\n\t\t\treturn !!ip->i_lock.mr_writer;\n\t\treturn rwsem_is_locked(&ip->i_lock.mr_lock);\n\t}\n\n\tif (lock_flags & (XFS_IOLOCK_EXCL|XFS_IOLOCK_SHARED)) {\n\t\tif (!(lock_flags & XFS_IOLOCK_SHARED))\n\t\t\treturn !!ip->i_iolock.mr_writer;\n\t\treturn rwsem_is_locked(&ip->i_iolock.mr_lock);\n\t}\n\n\tASSERT(0);\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);\n\nint\nxfs_isilocked(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\tif (lock_flags & (XFS_ILOCK_EXCL|XFS_ILOCK_SHARED)) {\n\t\tif (!(lock_flags & XFS_ILOCK_SHARED))\n\t\t\treturn !!ip->i_lock.mr_writer;\n\t\treturn rwsem_is_locked(&ip->i_lock.mr_lock);\n\t}\n\n\tif (lock_flags & (XFS_IOLOCK_EXCL|XFS_IOLOCK_SHARED)) {\n\t\tif (!(lock_flags & XFS_IOLOCK_SHARED))\n\t\t\treturn !!ip->i_iolock.mr_writer;\n\t\treturn rwsem_is_locked(&ip->i_iolock.mr_lock);\n\t}\n\n\tASSERT(0);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&qi->qi_tree_lock"
          ],
          "line": 824
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dqlock",
          "args": [
            "dqp"
          ],
          "line": 820
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dqlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_dquot.h",
          "lines": "104-107",
          "snippet": "static inline void xfs_dqlock(struct xfs_dquot *dqp)\n{\n\tmutex_lock(&dqp->q_qlock);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void xfs_dqlock(struct xfs_dquot *dqp)\n{\n\tmutex_lock(&dqp->q_qlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_STATS_INC",
          "args": [
            "xs_qm_dquot_dups"
          ],
          "line": 813
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_qm_dqdestroy",
          "args": [
            "dqp"
          ],
          "line": 812
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_qm_dqdestroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_dquot.c",
          "lines": "71-81",
          "snippet": "void\nxfs_qm_dqdestroy(\n\txfs_dquot_t\t*dqp)\n{\n\tASSERT(list_empty(&dqp->q_lru));\n\n\tmutex_destroy(&dqp->q_qlock);\n\tkmem_zone_free(xfs_qm_dqzone, dqp);\n\n\tXFS_STATS_DEC(xs_qm_dquot);\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_qm.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_zone\t\t*xfs_qm_dqzone;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_qm.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic struct kmem_zone\t\t*xfs_qm_dqzone;\n\nvoid\nxfs_qm_dqdestroy(\n\txfs_dquot_t\t*dqp)\n{\n\tASSERT(list_empty(&dqp->q_lru));\n\n\tmutex_destroy(&dqp->q_qlock);\n\tkmem_zone_free(xfs_qm_dqzone, dqp);\n\n\tXFS_STATS_DEC(xs_qm_dquot);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_xfs_dqget_dup",
          "args": [
            "dqp"
          ],
          "line": 811
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&qi->qi_tree_lock"
          ],
          "line": 810
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "error != -EEXIST"
          ],
          "line": 804
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "error"
          ],
          "line": 803
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "radix_tree_insert",
          "args": [
            "tree",
            "id",
            "dqp"
          ],
          "line": 802
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_radix_tree_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1078-1083",
          "snippet": "static inline void f2fs_radix_tree_insert(struct radix_tree_root *root,\n\t\t\t\tunsigned long index, void *item)\n{\n\twhile (radix_tree_insert(root, index, item))\n\t\tcond_resched();\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void f2fs_radix_tree_insert(struct radix_tree_root *root,\n\t\t\t\tunsigned long index, void *item)\n{\n\twhile (radix_tree_insert(root, index, item))\n\t\tcond_resched();\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&qi->qi_tree_lock"
          ],
          "line": 801
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_inode_dquot",
          "args": [
            "ip",
            "type"
          ],
          "line": 787
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_inode_dquot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_dquot.h",
          "lines": "128-140",
          "snippet": "static inline xfs_dquot_t *xfs_inode_dquot(struct xfs_inode *ip, int type)\n{\n\tswitch (type & XFS_DQ_ALLTYPES) {\n\tcase XFS_DQ_USER:\n\t\treturn ip->i_udquot;\n\tcase XFS_DQ_GROUP:\n\t\treturn ip->i_gdquot;\n\tcase XFS_DQ_PROJ:\n\t\treturn ip->i_pdquot;\n\tdefault:\n\t\treturn NULL;\n\t}\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline xfs_dquot_t *xfs_inode_dquot(struct xfs_inode *ip, int type)\n{\n\tswitch (type & XFS_DQ_ALLTYPES) {\n\tcase XFS_DQ_USER:\n\t\treturn ip->i_udquot;\n\tcase XFS_DQ_GROUP:\n\t\treturn ip->i_gdquot;\n\tcase XFS_DQ_PROJ:\n\t\treturn ip->i_pdquot;\n\tdefault:\n\t\treturn NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_this_quota_on",
          "args": [
            "mp",
            "type"
          ],
          "line": 784
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_this_quota_on",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_dquot.h",
          "lines": "114-126",
          "snippet": "static inline int xfs_this_quota_on(struct xfs_mount *mp, int type)\n{\n\tswitch (type & XFS_DQ_ALLTYPES) {\n\tcase XFS_DQ_USER:\n\t\treturn XFS_IS_UQUOTA_ON(mp);\n\tcase XFS_DQ_GROUP:\n\t\treturn XFS_IS_GQUOTA_ON(mp);\n\tcase XFS_DQ_PROJ:\n\t\treturn XFS_IS_PQUOTA_ON(mp);\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int xfs_this_quota_on(struct xfs_mount *mp, int type)\n{\n\tswitch (type & XFS_DQ_ALLTYPES) {\n\tcase XFS_DQ_USER:\n\t\treturn XFS_IS_UQUOTA_ON(mp);\n\tcase XFS_DQ_GROUP:\n\t\treturn XFS_IS_GQUOTA_ON(mp);\n\tcase XFS_DQ_PROJ:\n\t\treturn XFS_IS_PQUOTA_ON(mp);\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_ilock",
          "args": [
            "ip",
            "XFS_ILOCK_EXCL"
          ],
          "line": 774
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_ilock_demote",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
          "lines": "269-283",
          "snippet": "void\nxfs_ilock_demote(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\tASSERT(lock_flags & (XFS_IOLOCK_EXCL|XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_IOLOCK_EXCL|XFS_ILOCK_EXCL)) == 0);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrdemote(&ip->i_lock);\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrdemote(&ip->i_iolock);\n\n\ttrace_xfs_ilock_demote(ip, lock_flags, _RET_IP_);\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);\n\nvoid\nxfs_ilock_demote(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\tASSERT(lock_flags & (XFS_IOLOCK_EXCL|XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_IOLOCK_EXCL|XFS_ILOCK_EXCL)) == 0);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrdemote(&ip->i_lock);\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrdemote(&ip->i_iolock);\n\n\ttrace_xfs_ilock_demote(ip, lock_flags, _RET_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_qm_dqread",
          "args": [
            "mp",
            "id",
            "type",
            "flags",
            "&dqp"
          ],
          "line": 771
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_qm_dqread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_dquot.c",
          "lines": "558-688",
          "snippet": "int\nxfs_qm_dqread(\n\tstruct xfs_mount\t*mp,\n\txfs_dqid_t\t\tid,\n\tuint\t\t\ttype,\n\tuint\t\t\tflags,\n\tstruct xfs_dquot\t**O_dqpp)\n{\n\tstruct xfs_dquot\t*dqp;\n\tstruct xfs_disk_dquot\t*ddqp;\n\tstruct xfs_buf\t\t*bp;\n\tstruct xfs_trans\t*tp = NULL;\n\tint\t\t\terror;\n\tint\t\t\tcancelflags = 0;\n\n\n\tdqp = kmem_zone_zalloc(xfs_qm_dqzone, KM_SLEEP);\n\n\tdqp->dq_flags = type;\n\tdqp->q_core.d_id = cpu_to_be32(id);\n\tdqp->q_mount = mp;\n\tINIT_LIST_HEAD(&dqp->q_lru);\n\tmutex_init(&dqp->q_qlock);\n\tinit_waitqueue_head(&dqp->q_pinwait);\n\n\t/*\n\t * Because we want to use a counting completion, complete\n\t * the flush completion once to allow a single access to\n\t * the flush completion without blocking.\n\t */\n\tinit_completion(&dqp->q_flush);\n\tcomplete(&dqp->q_flush);\n\n\t/*\n\t * Make sure group quotas have a different lock class than user\n\t * quotas.\n\t */\n\tswitch (type) {\n\tcase XFS_DQ_USER:\n\t\t/* uses the default lock class */\n\t\tbreak;\n\tcase XFS_DQ_GROUP:\n\t\tlockdep_set_class(&dqp->q_qlock, &xfs_dquot_group_class);\n\t\tbreak;\n\tcase XFS_DQ_PROJ:\n\t\tlockdep_set_class(&dqp->q_qlock, &xfs_dquot_project_class);\n\t\tbreak;\n\tdefault:\n\t\tASSERT(0);\n\t\tbreak;\n\t}\n\n\tXFS_STATS_INC(xs_qm_dquot);\n\n\ttrace_xfs_dqread(dqp);\n\n\tif (flags & XFS_QMOPT_DQALLOC) {\n\t\ttp = xfs_trans_alloc(mp, XFS_TRANS_QM_DQALLOC);\n\t\terror = xfs_trans_reserve(tp, &M_RES(mp)->tr_qm_dqalloc,\n\t\t\t\t\t  XFS_QM_DQALLOC_SPACE_RES(mp), 0);\n\t\tif (error)\n\t\t\tgoto error1;\n\t\tcancelflags = XFS_TRANS_RELEASE_LOG_RES;\n\t}\n\n\t/*\n\t * get a pointer to the on-disk dquot and the buffer containing it\n\t * dqp already knows its own type (GROUP/USER).\n\t */\n\terror = xfs_qm_dqtobp(&tp, dqp, &ddqp, &bp, flags);\n\tif (error) {\n\t\t/*\n\t\t * This can happen if quotas got turned off (ESRCH),\n\t\t * or if the dquot didn't exist on disk and we ask to\n\t\t * allocate (ENOENT).\n\t\t */\n\t\ttrace_xfs_dqread_fail(dqp);\n\t\tcancelflags |= XFS_TRANS_ABORT;\n\t\tgoto error1;\n\t}\n\n\t/* copy everything from disk dquot to the incore dquot */\n\tmemcpy(&dqp->q_core, ddqp, sizeof(xfs_disk_dquot_t));\n\txfs_qm_dquot_logitem_init(dqp);\n\n\t/*\n\t * Reservation counters are defined as reservation plus current usage\n\t * to avoid having to add every time.\n\t */\n\tdqp->q_res_bcount = be64_to_cpu(ddqp->d_bcount);\n\tdqp->q_res_icount = be64_to_cpu(ddqp->d_icount);\n\tdqp->q_res_rtbcount = be64_to_cpu(ddqp->d_rtbcount);\n\n\t/* initialize the dquot speculative prealloc thresholds */\n\txfs_dquot_set_prealloc_limits(dqp);\n\n\t/* Mark the buf so that this will stay incore a little longer */\n\txfs_buf_set_ref(bp, XFS_DQUOT_REF);\n\n\t/*\n\t * We got the buffer with a xfs_trans_read_buf() (in dqtobp())\n\t * So we need to release with xfs_trans_brelse().\n\t * The strategy here is identical to that of inodes; we lock\n\t * the dquot in xfs_qm_dqget() before making it accessible to\n\t * others. This is because dquots, like inodes, need a good level of\n\t * concurrency, and we don't want to take locks on the entire buffers\n\t * for dquot accesses.\n\t * Note also that the dquot buffer may even be dirty at this point, if\n\t * this particular dquot was repaired. We still aren't afraid to\n\t * brelse it because we have the changes incore.\n\t */\n\tASSERT(xfs_buf_islocked(bp));\n\txfs_trans_brelse(tp, bp);\n\n\tif (tp) {\n\t\terror = xfs_trans_commit(tp, XFS_TRANS_RELEASE_LOG_RES);\n\t\tif (error)\n\t\t\tgoto error0;\n\t}\n\n\t*O_dqpp = dqp;\n\treturn error;\n\nerror1:\n\tif (tp)\n\t\txfs_trans_cancel(tp, cancelflags);\nerror0:\n\txfs_qm_dqdestroy(dqp);\n\t*O_dqpp = NULL;\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_qm.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_zone\t\t*xfs_qm_dqzone;",
            "static struct lock_class_key xfs_dquot_group_class;",
            "static struct lock_class_key xfs_dquot_project_class;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_qm.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic struct kmem_zone\t\t*xfs_qm_dqzone;\nstatic struct lock_class_key xfs_dquot_group_class;\nstatic struct lock_class_key xfs_dquot_project_class;\n\nint\nxfs_qm_dqread(\n\tstruct xfs_mount\t*mp,\n\txfs_dqid_t\t\tid,\n\tuint\t\t\ttype,\n\tuint\t\t\tflags,\n\tstruct xfs_dquot\t**O_dqpp)\n{\n\tstruct xfs_dquot\t*dqp;\n\tstruct xfs_disk_dquot\t*ddqp;\n\tstruct xfs_buf\t\t*bp;\n\tstruct xfs_trans\t*tp = NULL;\n\tint\t\t\terror;\n\tint\t\t\tcancelflags = 0;\n\n\n\tdqp = kmem_zone_zalloc(xfs_qm_dqzone, KM_SLEEP);\n\n\tdqp->dq_flags = type;\n\tdqp->q_core.d_id = cpu_to_be32(id);\n\tdqp->q_mount = mp;\n\tINIT_LIST_HEAD(&dqp->q_lru);\n\tmutex_init(&dqp->q_qlock);\n\tinit_waitqueue_head(&dqp->q_pinwait);\n\n\t/*\n\t * Because we want to use a counting completion, complete\n\t * the flush completion once to allow a single access to\n\t * the flush completion without blocking.\n\t */\n\tinit_completion(&dqp->q_flush);\n\tcomplete(&dqp->q_flush);\n\n\t/*\n\t * Make sure group quotas have a different lock class than user\n\t * quotas.\n\t */\n\tswitch (type) {\n\tcase XFS_DQ_USER:\n\t\t/* uses the default lock class */\n\t\tbreak;\n\tcase XFS_DQ_GROUP:\n\t\tlockdep_set_class(&dqp->q_qlock, &xfs_dquot_group_class);\n\t\tbreak;\n\tcase XFS_DQ_PROJ:\n\t\tlockdep_set_class(&dqp->q_qlock, &xfs_dquot_project_class);\n\t\tbreak;\n\tdefault:\n\t\tASSERT(0);\n\t\tbreak;\n\t}\n\n\tXFS_STATS_INC(xs_qm_dquot);\n\n\ttrace_xfs_dqread(dqp);\n\n\tif (flags & XFS_QMOPT_DQALLOC) {\n\t\ttp = xfs_trans_alloc(mp, XFS_TRANS_QM_DQALLOC);\n\t\terror = xfs_trans_reserve(tp, &M_RES(mp)->tr_qm_dqalloc,\n\t\t\t\t\t  XFS_QM_DQALLOC_SPACE_RES(mp), 0);\n\t\tif (error)\n\t\t\tgoto error1;\n\t\tcancelflags = XFS_TRANS_RELEASE_LOG_RES;\n\t}\n\n\t/*\n\t * get a pointer to the on-disk dquot and the buffer containing it\n\t * dqp already knows its own type (GROUP/USER).\n\t */\n\terror = xfs_qm_dqtobp(&tp, dqp, &ddqp, &bp, flags);\n\tif (error) {\n\t\t/*\n\t\t * This can happen if quotas got turned off (ESRCH),\n\t\t * or if the dquot didn't exist on disk and we ask to\n\t\t * allocate (ENOENT).\n\t\t */\n\t\ttrace_xfs_dqread_fail(dqp);\n\t\tcancelflags |= XFS_TRANS_ABORT;\n\t\tgoto error1;\n\t}\n\n\t/* copy everything from disk dquot to the incore dquot */\n\tmemcpy(&dqp->q_core, ddqp, sizeof(xfs_disk_dquot_t));\n\txfs_qm_dquot_logitem_init(dqp);\n\n\t/*\n\t * Reservation counters are defined as reservation plus current usage\n\t * to avoid having to add every time.\n\t */\n\tdqp->q_res_bcount = be64_to_cpu(ddqp->d_bcount);\n\tdqp->q_res_icount = be64_to_cpu(ddqp->d_icount);\n\tdqp->q_res_rtbcount = be64_to_cpu(ddqp->d_rtbcount);\n\n\t/* initialize the dquot speculative prealloc thresholds */\n\txfs_dquot_set_prealloc_limits(dqp);\n\n\t/* Mark the buf so that this will stay incore a little longer */\n\txfs_buf_set_ref(bp, XFS_DQUOT_REF);\n\n\t/*\n\t * We got the buffer with a xfs_trans_read_buf() (in dqtobp())\n\t * So we need to release with xfs_trans_brelse().\n\t * The strategy here is identical to that of inodes; we lock\n\t * the dquot in xfs_qm_dqget() before making it accessible to\n\t * others. This is because dquots, like inodes, need a good level of\n\t * concurrency, and we don't want to take locks on the entire buffers\n\t * for dquot accesses.\n\t * Note also that the dquot buffer may even be dirty at this point, if\n\t * this particular dquot was repaired. We still aren't afraid to\n\t * brelse it because we have the changes incore.\n\t */\n\tASSERT(xfs_buf_islocked(bp));\n\txfs_trans_brelse(tp, bp);\n\n\tif (tp) {\n\t\terror = xfs_trans_commit(tp, XFS_TRANS_RELEASE_LOG_RES);\n\t\tif (error)\n\t\t\tgoto error0;\n\t}\n\n\t*O_dqpp = dqp;\n\treturn error;\n\nerror1:\n\tif (tp)\n\t\txfs_trans_cancel(tp, cancelflags);\nerror0:\n\txfs_qm_dqdestroy(dqp);\n\t*O_dqpp = NULL;\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_iunlock",
          "args": [
            "ip",
            "XFS_ILOCK_EXCL"
          ],
          "line": 769
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_iunlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
          "lines": "235-263",
          "snippet": "void\nxfs_iunlock(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\t/*\n\t * You can't set both SHARED and EXCL for the same lock,\n\t * and only XFS_IOLOCK_SHARED, XFS_IOLOCK_EXCL, XFS_ILOCK_SHARED,\n\t * and XFS_ILOCK_EXCL are valid values to set in lock_flags.\n\t */\n\tASSERT((lock_flags & (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL)) !=\n\t       (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL));\n\tASSERT((lock_flags & (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL)) !=\n\t       (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_LOCK_MASK | XFS_LOCK_DEP_MASK)) == 0);\n\tASSERT(lock_flags != 0);\n\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_iolock);\n\telse if (lock_flags & XFS_IOLOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_iolock);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_lock);\n\telse if (lock_flags & XFS_ILOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_lock);\n\n\ttrace_xfs_iunlock(ip, lock_flags, _RET_IP_);\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);\n\nvoid\nxfs_iunlock(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\t/*\n\t * You can't set both SHARED and EXCL for the same lock,\n\t * and only XFS_IOLOCK_SHARED, XFS_IOLOCK_EXCL, XFS_ILOCK_SHARED,\n\t * and XFS_ILOCK_EXCL are valid values to set in lock_flags.\n\t */\n\tASSERT((lock_flags & (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL)) !=\n\t       (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL));\n\tASSERT((lock_flags & (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL)) !=\n\t       (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_LOCK_MASK | XFS_LOCK_DEP_MASK)) == 0);\n\tASSERT(lock_flags != 0);\n\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_iolock);\n\telse if (lock_flags & XFS_IOLOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_iolock);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_lock);\n\telse if (lock_flags & XFS_ILOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_lock);\n\n\ttrace_xfs_iunlock(ip, lock_flags, _RET_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_STATS_INC",
          "args": [
            "xs_qm_dqcachemisses"
          ],
          "line": 759
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&qi->qi_tree_lock"
          ],
          "line": 758
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_STATS_INC",
          "args": [
            "xs_qm_dqcachehits"
          ],
          "line": 754
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_xfs_dqget_hit",
          "args": [
            "dqp"
          ],
          "line": 753
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&qi->qi_tree_lock"
          ],
          "line": 751
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "delay",
          "args": [
            "1"
          ],
          "line": 746
        },
        "resolved": true,
        "details": {
          "function_name": "delay",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_linux.h",
          "lines": "181-184",
          "snippet": "static inline void delay(long ticks)\n{\n\tschedule_timeout_uninterruptible(ticks);\n}",
          "includes": [
            "#include \"xfs_message.h\"",
            "#include \"xfs_buf.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_super.h\"",
            "#include \"xfs_aops.h\"",
            "#include \"xfs_iops.h\"",
            "#include \"xfs_sysctl.h\"",
            "#include \"xfs_stats.h\"",
            "#include \"xfs_fs.h\"",
            "#include <asm/unaligned.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/param.h>",
            "#include <asm/div64.h>",
            "#include <asm/page.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/capability.h>",
            "#include <linux/writeback.h>",
            "#include <linux/ctype.h>",
            "#include <linux/random.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/log2.h>",
            "#include <linux/delay.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sort.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/list.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/vfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/major.h>",
            "#include <linux/bitops.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>",
            "#include <linux/swap.h>",
            "#include <linux/file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/crc32c.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mm.h>",
            "#include <linux/semaphore.h>",
            "#include \"uuid.h\"",
            "#include \"mrlock.h\"",
            "#include \"kmem.h\"",
            "#include \"xfs_types.h\"",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_message.h\"\n#include \"xfs_buf.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_super.h\"\n#include \"xfs_aops.h\"\n#include \"xfs_iops.h\"\n#include \"xfs_sysctl.h\"\n#include \"xfs_stats.h\"\n#include \"xfs_fs.h\"\n#include <asm/unaligned.h>\n#include <asm/byteorder.h>\n#include <asm/uaccess.h>\n#include <asm/param.h>\n#include <asm/div64.h>\n#include <asm/page.h>\n#include <linux/ratelimit.h>\n#include <linux/list_sort.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/capability.h>\n#include <linux/writeback.h>\n#include <linux/ctype.h>\n#include <linux/random.h>\n#include <linux/spinlock.h>\n#include <linux/log2.h>\n#include <linux/delay.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/sort.h>\n#include <linux/proc_fs.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/vfs.h>\n#include <linux/pagemap.h>\n#include <linux/major.h>\n#include <linux/bitops.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/swap.h>\n#include <linux/file.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/crc32c.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n#include <linux/mm.h>\n#include <linux/semaphore.h>\n#include \"uuid.h\"\n#include \"mrlock.h\"\n#include \"kmem.h\"\n#include \"xfs_types.h\"\n#include <linux/types.h>\n\nstatic inline void delay(long ticks)\n{\n\tschedule_timeout_uninterruptible(ticks);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_xfs_dqget_freeing",
          "args": [
            "dqp"
          ],
          "line": 745
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&qi->qi_tree_lock"
          ],
          "line": 744
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dqunlock",
          "args": [
            "dqp"
          ],
          "line": 743
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dqunlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_dquot.h",
          "lines": "109-112",
          "snippet": "static inline void xfs_dqunlock(struct xfs_dquot *dqp)\n{\n\tmutex_unlock(&dqp->q_qlock);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void xfs_dqunlock(struct xfs_dquot *dqp)\n{\n\tmutex_unlock(&dqp->q_qlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "radix_tree_lookup",
          "args": [
            "tree",
            "id"
          ],
          "line": 739
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&qi->qi_tree_lock"
          ],
          "line": 738
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "xfs_inode_dquot(ip, type) == NULL"
          ],
          "line": 733
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "xfs_isilocked(ip, XFS_ILOCK_EXCL)"
          ],
          "line": 732
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "type == XFS_DQ_USER ||\n\t       type == XFS_DQ_PROJ ||\n\t       type == XFS_DQ_GROUP"
          ],
          "line": 728
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_debug",
          "args": [
            "mp",
            "\"Returning error in dqget\""
          ],
          "line": 723
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_IS_GQUOTA_ON",
          "args": [
            "mp"
          ],
          "line": 715
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_IS_PQUOTA_ON",
          "args": [
            "mp"
          ],
          "line": 714
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_IS_UQUOTA_ON",
          "args": [
            "mp"
          ],
          "line": 713
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "XFS_IS_QUOTA_RUNNING(mp)"
          ],
          "line": 712
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_IS_QUOTA_RUNNING",
          "args": [
            "mp"
          ],
          "line": 712
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dquot_tree",
          "args": [
            "qi",
            "type"
          ],
          "line": 708
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dquot_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_qm.h",
          "lines": "88-104",
          "snippet": "static inline struct radix_tree_root *\nxfs_dquot_tree(\n\tstruct xfs_quotainfo\t*qi,\n\tint\t\t\ttype)\n{\n\tswitch (type) {\n\tcase XFS_DQ_USER:\n\t\treturn &qi->qi_uquota_tree;\n\tcase XFS_DQ_GROUP:\n\t\treturn &qi->qi_gquota_tree;\n\tcase XFS_DQ_PROJ:\n\t\treturn &qi->qi_pquota_tree;\n\tdefault:\n\t\tASSERT(0);\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"xfs_dquot.h\"",
            "#include \"xfs_dquot_item.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_dquot.h\"\n#include \"xfs_dquot_item.h\"\n\nstatic inline struct radix_tree_root *\nxfs_dquot_tree(\n\tstruct xfs_quotainfo\t*qi,\n\tint\t\t\ttype)\n{\n\tswitch (type) {\n\tcase XFS_DQ_USER:\n\t\treturn &qi->qi_uquota_tree;\n\tcase XFS_DQ_GROUP:\n\t\treturn &qi->qi_gquota_tree;\n\tcase XFS_DQ_PROJ:\n\t\treturn &qi->qi_pquota_tree;\n\tdefault:\n\t\tASSERT(0);\n\t}\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_qm.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_qm_dqget(\n\txfs_mount_t\t*mp,\n\txfs_inode_t\t*ip,\t  /* locked inode (optional) */\n\txfs_dqid_t\tid,\t  /* uid/projid/gid depending on type */\n\tuint\t\ttype,\t  /* XFS_DQ_USER/XFS_DQ_PROJ/XFS_DQ_GROUP */\n\tuint\t\tflags,\t  /* DQALLOC, DQSUSER, DQREPAIR, DOWARN */\n\txfs_dquot_t\t**O_dqpp) /* OUT : locked incore dquot */\n{\n\tstruct xfs_quotainfo\t*qi = mp->m_quotainfo;\n\tstruct radix_tree_root *tree = xfs_dquot_tree(qi, type);\n\tstruct xfs_dquot\t*dqp;\n\tint\t\t\terror;\n\n\tASSERT(XFS_IS_QUOTA_RUNNING(mp));\n\tif ((! XFS_IS_UQUOTA_ON(mp) && type == XFS_DQ_USER) ||\n\t    (! XFS_IS_PQUOTA_ON(mp) && type == XFS_DQ_PROJ) ||\n\t    (! XFS_IS_GQUOTA_ON(mp) && type == XFS_DQ_GROUP)) {\n\t\treturn -ESRCH;\n\t}\n\n#ifdef DEBUG\n\tif (xfs_do_dqerror) {\n\t\tif ((xfs_dqerror_target == mp->m_ddev_targp) &&\n\t\t    (xfs_dqreq_num++ % xfs_dqerror_mod) == 0) {\n\t\t\txfs_debug(mp, \"Returning error in dqget\");\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\n\tASSERT(type == XFS_DQ_USER ||\n\t       type == XFS_DQ_PROJ ||\n\t       type == XFS_DQ_GROUP);\n\tif (ip) {\n\t\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\t\tASSERT(xfs_inode_dquot(ip, type) == NULL);\n\t}\n#endif\n\nrestart:\n\tmutex_lock(&qi->qi_tree_lock);\n\tdqp = radix_tree_lookup(tree, id);\n\tif (dqp) {\n\t\txfs_dqlock(dqp);\n\t\tif (dqp->dq_flags & XFS_DQ_FREEING) {\n\t\t\txfs_dqunlock(dqp);\n\t\t\tmutex_unlock(&qi->qi_tree_lock);\n\t\t\ttrace_xfs_dqget_freeing(dqp);\n\t\t\tdelay(1);\n\t\t\tgoto restart;\n\t\t}\n\n\t\tdqp->q_nrefs++;\n\t\tmutex_unlock(&qi->qi_tree_lock);\n\n\t\ttrace_xfs_dqget_hit(dqp);\n\t\tXFS_STATS_INC(xs_qm_dqcachehits);\n\t\t*O_dqpp = dqp;\n\t\treturn 0;\n\t}\n\tmutex_unlock(&qi->qi_tree_lock);\n\tXFS_STATS_INC(xs_qm_dqcachemisses);\n\n\t/*\n\t * Dquot cache miss. We don't want to keep the inode lock across\n\t * a (potential) disk read. Also we don't want to deal with the lock\n\t * ordering between quotainode and this inode. OTOH, dropping the inode\n\t * lock here means dealing with a chown that can happen before\n\t * we re-acquire the lock.\n\t */\n\tif (ip)\n\t\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\n\terror = xfs_qm_dqread(mp, id, type, flags, &dqp);\n\n\tif (ip)\n\t\txfs_ilock(ip, XFS_ILOCK_EXCL);\n\n\tif (error)\n\t\treturn error;\n\n\tif (ip) {\n\t\t/*\n\t\t * A dquot could be attached to this inode by now, since\n\t\t * we had dropped the ilock.\n\t\t */\n\t\tif (xfs_this_quota_on(mp, type)) {\n\t\t\tstruct xfs_dquot\t*dqp1;\n\n\t\t\tdqp1 = xfs_inode_dquot(ip, type);\n\t\t\tif (dqp1) {\n\t\t\t\txfs_qm_dqdestroy(dqp);\n\t\t\t\tdqp = dqp1;\n\t\t\t\txfs_dqlock(dqp);\n\t\t\t\tgoto dqret;\n\t\t\t}\n\t\t} else {\n\t\t\t/* inode stays locked on return */\n\t\t\txfs_qm_dqdestroy(dqp);\n\t\t\treturn -ESRCH;\n\t\t}\n\t}\n\n\tmutex_lock(&qi->qi_tree_lock);\n\terror = radix_tree_insert(tree, id, dqp);\n\tif (unlikely(error)) {\n\t\tWARN_ON(error != -EEXIST);\n\n\t\t/*\n\t\t * Duplicate found. Just throw away the new dquot and start\n\t\t * over.\n\t\t */\n\t\tmutex_unlock(&qi->qi_tree_lock);\n\t\ttrace_xfs_dqget_dup(dqp);\n\t\txfs_qm_dqdestroy(dqp);\n\t\tXFS_STATS_INC(xs_qm_dquot_dups);\n\t\tgoto restart;\n\t}\n\n\t/*\n\t * We return a locked dquot to the caller, with a reference taken\n\t */\n\txfs_dqlock(dqp);\n\tdqp->q_nrefs = 1;\n\n\tqi->qi_dquots++;\n\tmutex_unlock(&qi->qi_tree_lock);\n\n dqret:\n\tASSERT((ip == NULL) || xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\ttrace_xfs_dqget_miss(dqp);\n\t*O_dqpp = dqp;\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_qm_dqread",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_dquot.c",
    "lines": "558-688",
    "snippet": "int\nxfs_qm_dqread(\n\tstruct xfs_mount\t*mp,\n\txfs_dqid_t\t\tid,\n\tuint\t\t\ttype,\n\tuint\t\t\tflags,\n\tstruct xfs_dquot\t**O_dqpp)\n{\n\tstruct xfs_dquot\t*dqp;\n\tstruct xfs_disk_dquot\t*ddqp;\n\tstruct xfs_buf\t\t*bp;\n\tstruct xfs_trans\t*tp = NULL;\n\tint\t\t\terror;\n\tint\t\t\tcancelflags = 0;\n\n\n\tdqp = kmem_zone_zalloc(xfs_qm_dqzone, KM_SLEEP);\n\n\tdqp->dq_flags = type;\n\tdqp->q_core.d_id = cpu_to_be32(id);\n\tdqp->q_mount = mp;\n\tINIT_LIST_HEAD(&dqp->q_lru);\n\tmutex_init(&dqp->q_qlock);\n\tinit_waitqueue_head(&dqp->q_pinwait);\n\n\t/*\n\t * Because we want to use a counting completion, complete\n\t * the flush completion once to allow a single access to\n\t * the flush completion without blocking.\n\t */\n\tinit_completion(&dqp->q_flush);\n\tcomplete(&dqp->q_flush);\n\n\t/*\n\t * Make sure group quotas have a different lock class than user\n\t * quotas.\n\t */\n\tswitch (type) {\n\tcase XFS_DQ_USER:\n\t\t/* uses the default lock class */\n\t\tbreak;\n\tcase XFS_DQ_GROUP:\n\t\tlockdep_set_class(&dqp->q_qlock, &xfs_dquot_group_class);\n\t\tbreak;\n\tcase XFS_DQ_PROJ:\n\t\tlockdep_set_class(&dqp->q_qlock, &xfs_dquot_project_class);\n\t\tbreak;\n\tdefault:\n\t\tASSERT(0);\n\t\tbreak;\n\t}\n\n\tXFS_STATS_INC(xs_qm_dquot);\n\n\ttrace_xfs_dqread(dqp);\n\n\tif (flags & XFS_QMOPT_DQALLOC) {\n\t\ttp = xfs_trans_alloc(mp, XFS_TRANS_QM_DQALLOC);\n\t\terror = xfs_trans_reserve(tp, &M_RES(mp)->tr_qm_dqalloc,\n\t\t\t\t\t  XFS_QM_DQALLOC_SPACE_RES(mp), 0);\n\t\tif (error)\n\t\t\tgoto error1;\n\t\tcancelflags = XFS_TRANS_RELEASE_LOG_RES;\n\t}\n\n\t/*\n\t * get a pointer to the on-disk dquot and the buffer containing it\n\t * dqp already knows its own type (GROUP/USER).\n\t */\n\terror = xfs_qm_dqtobp(&tp, dqp, &ddqp, &bp, flags);\n\tif (error) {\n\t\t/*\n\t\t * This can happen if quotas got turned off (ESRCH),\n\t\t * or if the dquot didn't exist on disk and we ask to\n\t\t * allocate (ENOENT).\n\t\t */\n\t\ttrace_xfs_dqread_fail(dqp);\n\t\tcancelflags |= XFS_TRANS_ABORT;\n\t\tgoto error1;\n\t}\n\n\t/* copy everything from disk dquot to the incore dquot */\n\tmemcpy(&dqp->q_core, ddqp, sizeof(xfs_disk_dquot_t));\n\txfs_qm_dquot_logitem_init(dqp);\n\n\t/*\n\t * Reservation counters are defined as reservation plus current usage\n\t * to avoid having to add every time.\n\t */\n\tdqp->q_res_bcount = be64_to_cpu(ddqp->d_bcount);\n\tdqp->q_res_icount = be64_to_cpu(ddqp->d_icount);\n\tdqp->q_res_rtbcount = be64_to_cpu(ddqp->d_rtbcount);\n\n\t/* initialize the dquot speculative prealloc thresholds */\n\txfs_dquot_set_prealloc_limits(dqp);\n\n\t/* Mark the buf so that this will stay incore a little longer */\n\txfs_buf_set_ref(bp, XFS_DQUOT_REF);\n\n\t/*\n\t * We got the buffer with a xfs_trans_read_buf() (in dqtobp())\n\t * So we need to release with xfs_trans_brelse().\n\t * The strategy here is identical to that of inodes; we lock\n\t * the dquot in xfs_qm_dqget() before making it accessible to\n\t * others. This is because dquots, like inodes, need a good level of\n\t * concurrency, and we don't want to take locks on the entire buffers\n\t * for dquot accesses.\n\t * Note also that the dquot buffer may even be dirty at this point, if\n\t * this particular dquot was repaired. We still aren't afraid to\n\t * brelse it because we have the changes incore.\n\t */\n\tASSERT(xfs_buf_islocked(bp));\n\txfs_trans_brelse(tp, bp);\n\n\tif (tp) {\n\t\terror = xfs_trans_commit(tp, XFS_TRANS_RELEASE_LOG_RES);\n\t\tif (error)\n\t\t\tgoto error0;\n\t}\n\n\t*O_dqpp = dqp;\n\treturn error;\n\nerror1:\n\tif (tp)\n\t\txfs_trans_cancel(tp, cancelflags);\nerror0:\n\txfs_qm_dqdestroy(dqp);\n\t*O_dqpp = NULL;\n\treturn error;\n}",
    "includes": [
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_qm.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_zone\t\t*xfs_qm_dqzone;",
      "static struct lock_class_key xfs_dquot_group_class;",
      "static struct lock_class_key xfs_dquot_project_class;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_qm_dqdestroy",
          "args": [
            "dqp"
          ],
          "line": 685
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_qm_dqdestroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_dquot.c",
          "lines": "71-81",
          "snippet": "void\nxfs_qm_dqdestroy(\n\txfs_dquot_t\t*dqp)\n{\n\tASSERT(list_empty(&dqp->q_lru));\n\n\tmutex_destroy(&dqp->q_qlock);\n\tkmem_zone_free(xfs_qm_dqzone, dqp);\n\n\tXFS_STATS_DEC(xs_qm_dquot);\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_qm.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_zone\t\t*xfs_qm_dqzone;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_qm.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic struct kmem_zone\t\t*xfs_qm_dqzone;\n\nvoid\nxfs_qm_dqdestroy(\n\txfs_dquot_t\t*dqp)\n{\n\tASSERT(list_empty(&dqp->q_lru));\n\n\tmutex_destroy(&dqp->q_qlock);\n\tkmem_zone_free(xfs_qm_dqzone, dqp);\n\n\tXFS_STATS_DEC(xs_qm_dquot);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_cancel",
          "args": [
            "tp",
            "cancelflags"
          ],
          "line": 683
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_cancel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.c",
          "lines": "937-986",
          "snippet": "void\nxfs_trans_cancel(\n\txfs_trans_t\t\t*tp,\n\tint\t\t\tflags)\n{\n\tint\t\t\tlog_flags;\n\txfs_mount_t\t\t*mp = tp->t_mountp;\n\n\t/*\n\t * See if the caller is being too lazy to figure out if\n\t * the transaction really needs an abort.\n\t */\n\tif ((flags & XFS_TRANS_ABORT) && !(tp->t_flags & XFS_TRANS_DIRTY))\n\t\tflags &= ~XFS_TRANS_ABORT;\n\t/*\n\t * See if the caller is relying on us to shut down the\n\t * filesystem.  This happens in paths where we detect\n\t * corruption and decide to give up.\n\t */\n\tif ((tp->t_flags & XFS_TRANS_DIRTY) && !XFS_FORCED_SHUTDOWN(mp)) {\n\t\tXFS_ERROR_REPORT(\"xfs_trans_cancel\", XFS_ERRLEVEL_LOW, mp);\n\t\txfs_force_shutdown(mp, SHUTDOWN_CORRUPT_INCORE);\n\t}\n#ifdef DEBUG\n\tif (!(flags & XFS_TRANS_ABORT) && !XFS_FORCED_SHUTDOWN(mp)) {\n\t\tstruct xfs_log_item_desc *lidp;\n\n\t\tlist_for_each_entry(lidp, &tp->t_items, lid_trans)\n\t\t\tASSERT(!(lidp->lid_item->li_type == XFS_LI_EFD));\n\t}\n#endif\n\txfs_trans_unreserve_and_mod_sb(tp);\n\txfs_trans_unreserve_and_mod_dquots(tp);\n\n\tif (tp->t_ticket) {\n\t\tif (flags & XFS_TRANS_RELEASE_LOG_RES) {\n\t\t\tASSERT(tp->t_flags & XFS_TRANS_PERM_LOG_RES);\n\t\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t\t} else {\n\t\t\tlog_flags = 0;\n\t\t}\n\t\txfs_log_done(mp, tp->t_ticket, NULL, log_flags);\n\t}\n\n\t/* mark this thread as no longer being in a transaction */\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\txfs_trans_free_items(tp, NULLCOMMITLSN, flags);\n\txfs_trans_free(tp);\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_cancel(\n\txfs_trans_t\t\t*tp,\n\tint\t\t\tflags)\n{\n\tint\t\t\tlog_flags;\n\txfs_mount_t\t\t*mp = tp->t_mountp;\n\n\t/*\n\t * See if the caller is being too lazy to figure out if\n\t * the transaction really needs an abort.\n\t */\n\tif ((flags & XFS_TRANS_ABORT) && !(tp->t_flags & XFS_TRANS_DIRTY))\n\t\tflags &= ~XFS_TRANS_ABORT;\n\t/*\n\t * See if the caller is relying on us to shut down the\n\t * filesystem.  This happens in paths where we detect\n\t * corruption and decide to give up.\n\t */\n\tif ((tp->t_flags & XFS_TRANS_DIRTY) && !XFS_FORCED_SHUTDOWN(mp)) {\n\t\tXFS_ERROR_REPORT(\"xfs_trans_cancel\", XFS_ERRLEVEL_LOW, mp);\n\t\txfs_force_shutdown(mp, SHUTDOWN_CORRUPT_INCORE);\n\t}\n#ifdef DEBUG\n\tif (!(flags & XFS_TRANS_ABORT) && !XFS_FORCED_SHUTDOWN(mp)) {\n\t\tstruct xfs_log_item_desc *lidp;\n\n\t\tlist_for_each_entry(lidp, &tp->t_items, lid_trans)\n\t\t\tASSERT(!(lidp->lid_item->li_type == XFS_LI_EFD));\n\t}\n#endif\n\txfs_trans_unreserve_and_mod_sb(tp);\n\txfs_trans_unreserve_and_mod_dquots(tp);\n\n\tif (tp->t_ticket) {\n\t\tif (flags & XFS_TRANS_RELEASE_LOG_RES) {\n\t\t\tASSERT(tp->t_flags & XFS_TRANS_PERM_LOG_RES);\n\t\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t\t} else {\n\t\t\tlog_flags = 0;\n\t\t}\n\t\txfs_log_done(mp, tp->t_ticket, NULL, log_flags);\n\t}\n\n\t/* mark this thread as no longer being in a transaction */\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\txfs_trans_free_items(tp, NULLCOMMITLSN, flags);\n\txfs_trans_free(tp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_commit",
          "args": [
            "tp",
            "XFS_TRANS_RELEASE_LOG_RES"
          ],
          "line": 673
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_commit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.c",
          "lines": "845-927",
          "snippet": "int\nxfs_trans_commit(\n\tstruct xfs_trans\t*tp,\n\tuint\t\t\tflags)\n{\n\tstruct xfs_mount\t*mp = tp->t_mountp;\n\txfs_lsn_t\t\tcommit_lsn = -1;\n\tint\t\t\terror = 0;\n\tint\t\t\tlog_flags = 0;\n\tint\t\t\tsync = tp->t_flags & XFS_TRANS_SYNC;\n\n\t/*\n\t * Determine whether this commit is releasing a permanent\n\t * log reservation or not.\n\t */\n\tif (flags & XFS_TRANS_RELEASE_LOG_RES) {\n\t\tASSERT(tp->t_flags & XFS_TRANS_PERM_LOG_RES);\n\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t}\n\n\t/*\n\t * If there is nothing to be logged by the transaction,\n\t * then unlock all of the items associated with the\n\t * transaction and free the transaction structure.\n\t * Also make sure to return any reserved blocks to\n\t * the free pool.\n\t */\n\tif (!(tp->t_flags & XFS_TRANS_DIRTY))\n\t\tgoto out_unreserve;\n\n\tif (XFS_FORCED_SHUTDOWN(mp)) {\n\t\terror = -EIO;\n\t\tgoto out_unreserve;\n\t}\n\n\tASSERT(tp->t_ticket != NULL);\n\n\t/*\n\t * If we need to update the superblock, then do it now.\n\t */\n\tif (tp->t_flags & XFS_TRANS_SB_DIRTY)\n\t\txfs_trans_apply_sb_deltas(tp);\n\txfs_trans_apply_dquot_deltas(tp);\n\n\txfs_log_commit_cil(mp, tp, &commit_lsn, flags);\n\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\txfs_trans_free(tp);\n\n\t/*\n\t * If the transaction needs to be synchronous, then force the\n\t * log out now and wait for it.\n\t */\n\tif (sync) {\n\t\terror = _xfs_log_force_lsn(mp, commit_lsn, XFS_LOG_SYNC, NULL);\n\t\tXFS_STATS_INC(xs_trans_sync);\n\t} else {\n\t\tXFS_STATS_INC(xs_trans_async);\n\t}\n\n\treturn error;\n\nout_unreserve:\n\txfs_trans_unreserve_and_mod_sb(tp);\n\n\t/*\n\t * It is indeed possible for the transaction to be not dirty but\n\t * the dqinfo portion to be.  All that means is that we have some\n\t * (non-persistent) quota reservations that need to be unreserved.\n\t */\n\txfs_trans_unreserve_and_mod_dquots(tp);\n\tif (tp->t_ticket) {\n\t\tcommit_lsn = xfs_log_done(mp, tp->t_ticket, NULL, log_flags);\n\t\tif (commit_lsn == -1 && !error)\n\t\t\terror = -EIO;\n\t}\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\txfs_trans_free_items(tp, NULLCOMMITLSN, error ? XFS_TRANS_ABORT : 0);\n\txfs_trans_free(tp);\n\n\tXFS_STATS_INC(xs_trans_empty);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_trans_commit(\n\tstruct xfs_trans\t*tp,\n\tuint\t\t\tflags)\n{\n\tstruct xfs_mount\t*mp = tp->t_mountp;\n\txfs_lsn_t\t\tcommit_lsn = -1;\n\tint\t\t\terror = 0;\n\tint\t\t\tlog_flags = 0;\n\tint\t\t\tsync = tp->t_flags & XFS_TRANS_SYNC;\n\n\t/*\n\t * Determine whether this commit is releasing a permanent\n\t * log reservation or not.\n\t */\n\tif (flags & XFS_TRANS_RELEASE_LOG_RES) {\n\t\tASSERT(tp->t_flags & XFS_TRANS_PERM_LOG_RES);\n\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t}\n\n\t/*\n\t * If there is nothing to be logged by the transaction,\n\t * then unlock all of the items associated with the\n\t * transaction and free the transaction structure.\n\t * Also make sure to return any reserved blocks to\n\t * the free pool.\n\t */\n\tif (!(tp->t_flags & XFS_TRANS_DIRTY))\n\t\tgoto out_unreserve;\n\n\tif (XFS_FORCED_SHUTDOWN(mp)) {\n\t\terror = -EIO;\n\t\tgoto out_unreserve;\n\t}\n\n\tASSERT(tp->t_ticket != NULL);\n\n\t/*\n\t * If we need to update the superblock, then do it now.\n\t */\n\tif (tp->t_flags & XFS_TRANS_SB_DIRTY)\n\t\txfs_trans_apply_sb_deltas(tp);\n\txfs_trans_apply_dquot_deltas(tp);\n\n\txfs_log_commit_cil(mp, tp, &commit_lsn, flags);\n\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\txfs_trans_free(tp);\n\n\t/*\n\t * If the transaction needs to be synchronous, then force the\n\t * log out now and wait for it.\n\t */\n\tif (sync) {\n\t\terror = _xfs_log_force_lsn(mp, commit_lsn, XFS_LOG_SYNC, NULL);\n\t\tXFS_STATS_INC(xs_trans_sync);\n\t} else {\n\t\tXFS_STATS_INC(xs_trans_async);\n\t}\n\n\treturn error;\n\nout_unreserve:\n\txfs_trans_unreserve_and_mod_sb(tp);\n\n\t/*\n\t * It is indeed possible for the transaction to be not dirty but\n\t * the dqinfo portion to be.  All that means is that we have some\n\t * (non-persistent) quota reservations that need to be unreserved.\n\t */\n\txfs_trans_unreserve_and_mod_dquots(tp);\n\tif (tp->t_ticket) {\n\t\tcommit_lsn = xfs_log_done(mp, tp->t_ticket, NULL, log_flags);\n\t\tif (commit_lsn == -1 && !error)\n\t\t\terror = -EIO;\n\t}\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\txfs_trans_free_items(tp, NULLCOMMITLSN, error ? XFS_TRANS_ABORT : 0);\n\txfs_trans_free(tp);\n\n\tXFS_STATS_INC(xs_trans_empty);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_brelse",
          "args": [
            "tp",
            "bp"
          ],
          "line": 670
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_buf.c",
          "lines": "354-443",
          "snippet": "void\nxfs_trans_brelse(xfs_trans_t\t*tp,\n\t\t xfs_buf_t\t*bp)\n{\n\txfs_buf_log_item_t\t*bip;\n\n\t/*\n\t * Default to a normal brelse() call if the tp is NULL.\n\t */\n\tif (tp == NULL) {\n\t\tASSERT(bp->b_transp == NULL);\n\t\txfs_buf_relse(bp);\n\t\treturn;\n\t}\n\n\tASSERT(bp->b_transp == tp);\n\tbip = bp->b_fspriv;\n\tASSERT(bip->bli_item.li_type == XFS_LI_BUF);\n\tASSERT(!(bip->bli_flags & XFS_BLI_STALE));\n\tASSERT(!(bip->__bli_format.blf_flags & XFS_BLF_CANCEL));\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\n\ttrace_xfs_trans_brelse(bip);\n\n\t/*\n\t * If the release is just for a recursive lock,\n\t * then decrement the count and return.\n\t */\n\tif (bip->bli_recur > 0) {\n\t\tbip->bli_recur--;\n\t\treturn;\n\t}\n\n\t/*\n\t * If the buffer is dirty within this transaction, we can't\n\t * release it until we commit.\n\t */\n\tif (bip->bli_item.li_desc->lid_flags & XFS_LID_DIRTY)\n\t\treturn;\n\n\t/*\n\t * If the buffer has been invalidated, then we can't release\n\t * it until the transaction commits to disk unless it is re-dirtied\n\t * as part of this transaction.  This prevents us from pulling\n\t * the item from the AIL before we should.\n\t */\n\tif (bip->bli_flags & XFS_BLI_STALE)\n\t\treturn;\n\n\tASSERT(!(bip->bli_flags & XFS_BLI_LOGGED));\n\n\t/*\n\t * Free up the log item descriptor tracking the released item.\n\t */\n\txfs_trans_del_item(&bip->bli_item);\n\n\t/*\n\t * Clear the hold flag in the buf log item if it is set.\n\t * We wouldn't want the next user of the buffer to\n\t * get confused.\n\t */\n\tif (bip->bli_flags & XFS_BLI_HOLD) {\n\t\tbip->bli_flags &= ~XFS_BLI_HOLD;\n\t}\n\n\t/*\n\t * Drop our reference to the buf log item.\n\t */\n\tatomic_dec(&bip->bli_refcount);\n\n\t/*\n\t * If the buf item is not tracking data in the log, then\n\t * we must free it before releasing the buffer back to the\n\t * free pool.  Before releasing the buffer to the free pool,\n\t * clear the transaction pointer in b_fsprivate2 to dissolve\n\t * its relation to this transaction.\n\t */\n\tif (!xfs_buf_item_dirty(bip)) {\n/***\n\t\tASSERT(bp->b_pincount == 0);\n***/\n\t\tASSERT(atomic_read(&bip->bli_refcount) == 0);\n\t\tASSERT(!(bip->bli_item.li_flags & XFS_LI_IN_AIL));\n\t\tASSERT(!(bip->bli_flags & XFS_BLI_INODE_ALLOC_BUF));\n\t\txfs_buf_item_relse(bp);\n\t}\n\n\tbp->b_transp = NULL;\n\txfs_buf_relse(bp);\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_brelse(xfs_trans_t\t*tp,\n\t\t xfs_buf_t\t*bp)\n{\n\txfs_buf_log_item_t\t*bip;\n\n\t/*\n\t * Default to a normal brelse() call if the tp is NULL.\n\t */\n\tif (tp == NULL) {\n\t\tASSERT(bp->b_transp == NULL);\n\t\txfs_buf_relse(bp);\n\t\treturn;\n\t}\n\n\tASSERT(bp->b_transp == tp);\n\tbip = bp->b_fspriv;\n\tASSERT(bip->bli_item.li_type == XFS_LI_BUF);\n\tASSERT(!(bip->bli_flags & XFS_BLI_STALE));\n\tASSERT(!(bip->__bli_format.blf_flags & XFS_BLF_CANCEL));\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\n\ttrace_xfs_trans_brelse(bip);\n\n\t/*\n\t * If the release is just for a recursive lock,\n\t * then decrement the count and return.\n\t */\n\tif (bip->bli_recur > 0) {\n\t\tbip->bli_recur--;\n\t\treturn;\n\t}\n\n\t/*\n\t * If the buffer is dirty within this transaction, we can't\n\t * release it until we commit.\n\t */\n\tif (bip->bli_item.li_desc->lid_flags & XFS_LID_DIRTY)\n\t\treturn;\n\n\t/*\n\t * If the buffer has been invalidated, then we can't release\n\t * it until the transaction commits to disk unless it is re-dirtied\n\t * as part of this transaction.  This prevents us from pulling\n\t * the item from the AIL before we should.\n\t */\n\tif (bip->bli_flags & XFS_BLI_STALE)\n\t\treturn;\n\n\tASSERT(!(bip->bli_flags & XFS_BLI_LOGGED));\n\n\t/*\n\t * Free up the log item descriptor tracking the released item.\n\t */\n\txfs_trans_del_item(&bip->bli_item);\n\n\t/*\n\t * Clear the hold flag in the buf log item if it is set.\n\t * We wouldn't want the next user of the buffer to\n\t * get confused.\n\t */\n\tif (bip->bli_flags & XFS_BLI_HOLD) {\n\t\tbip->bli_flags &= ~XFS_BLI_HOLD;\n\t}\n\n\t/*\n\t * Drop our reference to the buf log item.\n\t */\n\tatomic_dec(&bip->bli_refcount);\n\n\t/*\n\t * If the buf item is not tracking data in the log, then\n\t * we must free it before releasing the buffer back to the\n\t * free pool.  Before releasing the buffer to the free pool,\n\t * clear the transaction pointer in b_fsprivate2 to dissolve\n\t * its relation to this transaction.\n\t */\n\tif (!xfs_buf_item_dirty(bip)) {\n/***\n\t\tASSERT(bp->b_pincount == 0);\n***/\n\t\tASSERT(atomic_read(&bip->bli_refcount) == 0);\n\t\tASSERT(!(bip->bli_item.li_flags & XFS_LI_IN_AIL));\n\t\tASSERT(!(bip->bli_flags & XFS_BLI_INODE_ALLOC_BUF));\n\t\txfs_buf_item_relse(bp);\n\t}\n\n\tbp->b_transp = NULL;\n\txfs_buf_relse(bp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "xfs_buf_islocked(bp)"
          ],
          "line": 669
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_buf_islocked",
          "args": [
            "bp"
          ],
          "line": 669
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_buf_set_ref",
          "args": [
            "bp",
            "XFS_DQUOT_REF"
          ],
          "line": 655
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_set_ref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.h",
          "lines": "351-354",
          "snippet": "static inline void xfs_buf_set_ref(struct xfs_buf *bp, int lru_ref)\n{\n\tatomic_set(&bp->b_lru_ref, lru_ref);\n}",
          "includes": [
            "#include <linux/list_lru.h>",
            "#include <linux/uio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/list_lru.h>\n#include <linux/uio.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/list.h>\n\nstatic inline void xfs_buf_set_ref(struct xfs_buf *bp, int lru_ref)\n{\n\tatomic_set(&bp->b_lru_ref, lru_ref);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dquot_set_prealloc_limits",
          "args": [
            "dqp"
          ],
          "line": 652
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dquot_set_prealloc_limits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_dquot.c",
          "lines": "272-291",
          "snippet": "void\nxfs_dquot_set_prealloc_limits(struct xfs_dquot *dqp)\n{\n\t__uint64_t space;\n\n\tdqp->q_prealloc_hi_wmark = be64_to_cpu(dqp->q_core.d_blk_hardlimit);\n\tdqp->q_prealloc_lo_wmark = be64_to_cpu(dqp->q_core.d_blk_softlimit);\n\tif (!dqp->q_prealloc_lo_wmark) {\n\t\tdqp->q_prealloc_lo_wmark = dqp->q_prealloc_hi_wmark;\n\t\tdo_div(dqp->q_prealloc_lo_wmark, 100);\n\t\tdqp->q_prealloc_lo_wmark *= 95;\n\t}\n\n\tspace = dqp->q_prealloc_hi_wmark;\n\n\tdo_div(space, 100);\n\tdqp->q_low_space[XFS_QLOWSP_1_PCNT] = space;\n\tdqp->q_low_space[XFS_QLOWSP_3_PCNT] = space * 3;\n\tdqp->q_low_space[XFS_QLOWSP_5_PCNT] = space * 5;\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_qm.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_qm.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_dquot_set_prealloc_limits(struct xfs_dquot *dqp)\n{\n\t__uint64_t space;\n\n\tdqp->q_prealloc_hi_wmark = be64_to_cpu(dqp->q_core.d_blk_hardlimit);\n\tdqp->q_prealloc_lo_wmark = be64_to_cpu(dqp->q_core.d_blk_softlimit);\n\tif (!dqp->q_prealloc_lo_wmark) {\n\t\tdqp->q_prealloc_lo_wmark = dqp->q_prealloc_hi_wmark;\n\t\tdo_div(dqp->q_prealloc_lo_wmark, 100);\n\t\tdqp->q_prealloc_lo_wmark *= 95;\n\t}\n\n\tspace = dqp->q_prealloc_hi_wmark;\n\n\tdo_div(space, 100);\n\tdqp->q_low_space[XFS_QLOWSP_1_PCNT] = space;\n\tdqp->q_low_space[XFS_QLOWSP_3_PCNT] = space * 3;\n\tdqp->q_low_space[XFS_QLOWSP_5_PCNT] = space * 5;\n}"
        }
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "ddqp->d_rtbcount"
          ],
          "line": 649
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "ddqp->d_icount"
          ],
          "line": 648
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "ddqp->d_bcount"
          ],
          "line": 647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_qm_dquot_logitem_init",
          "args": [
            "dqp"
          ],
          "line": 641
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_qm_dquot_logitem_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_dquot_item.c",
          "lines": "253-262",
          "snippet": "void\nxfs_qm_dquot_logitem_init(\n\tstruct xfs_dquot\t*dqp)\n{\n\tstruct xfs_dq_logitem\t*lp = &dqp->q_logitem;\n\n\txfs_log_item_init(dqp->q_mount, &lp->qli_item, XFS_LI_DQUOT,\n\t\t\t\t\t&xfs_dquot_item_ops);\n\tlp->qli_dquot = dqp;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_qm.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct xfs_item_ops xfs_dquot_item_ops = {\n\t.iop_size\t= xfs_qm_dquot_logitem_size,\n\t.iop_format\t= xfs_qm_dquot_logitem_format,\n\t.iop_pin\t= xfs_qm_dquot_logitem_pin,\n\t.iop_unpin\t= xfs_qm_dquot_logitem_unpin,\n\t.iop_unlock\t= xfs_qm_dquot_logitem_unlock,\n\t.iop_committed\t= xfs_qm_dquot_logitem_committed,\n\t.iop_push\t= xfs_qm_dquot_logitem_push,\n\t.iop_committing = xfs_qm_dquot_logitem_committing\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_qm.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic const struct xfs_item_ops xfs_dquot_item_ops = {\n\t.iop_size\t= xfs_qm_dquot_logitem_size,\n\t.iop_format\t= xfs_qm_dquot_logitem_format,\n\t.iop_pin\t= xfs_qm_dquot_logitem_pin,\n\t.iop_unpin\t= xfs_qm_dquot_logitem_unpin,\n\t.iop_unlock\t= xfs_qm_dquot_logitem_unlock,\n\t.iop_committed\t= xfs_qm_dquot_logitem_committed,\n\t.iop_push\t= xfs_qm_dquot_logitem_push,\n\t.iop_committing = xfs_qm_dquot_logitem_committing\n};\n\nvoid\nxfs_qm_dquot_logitem_init(\n\tstruct xfs_dquot\t*dqp)\n{\n\tstruct xfs_dq_logitem\t*lp = &dqp->q_logitem;\n\n\txfs_log_item_init(dqp->q_mount, &lp->qli_item, XFS_LI_DQUOT,\n\t\t\t\t\t&xfs_dquot_item_ops);\n\tlp->qli_dquot = dqp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&dqp->q_core",
            "ddqp",
            "sizeof(xfs_disk_dquot_t)"
          ],
          "line": 640
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_xfs_dqread_fail",
          "args": [
            "dqp"
          ],
          "line": 634
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_qm_dqtobp",
          "args": [
            "&tp",
            "dqp",
            "&ddqp",
            "&bp",
            "flags"
          ],
          "line": 627
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_qm_dqtobp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_dquot.c",
          "lines": "455-549",
          "snippet": "STATIC int\nxfs_qm_dqtobp(\n\txfs_trans_t\t\t**tpp,\n\txfs_dquot_t\t\t*dqp,\n\txfs_disk_dquot_t\t**O_ddpp,\n\txfs_buf_t\t\t**O_bpp,\n\tuint\t\t\tflags)\n{\n\tstruct xfs_bmbt_irec\tmap;\n\tint\t\t\tnmaps = 1, error;\n\tstruct xfs_buf\t\t*bp;\n\tstruct xfs_inode\t*quotip = xfs_dq_to_quota_inode(dqp);\n\tstruct xfs_mount\t*mp = dqp->q_mount;\n\txfs_dqid_t\t\tid = be32_to_cpu(dqp->q_core.d_id);\n\tstruct xfs_trans\t*tp = (tpp ? *tpp : NULL);\n\tuint\t\t\tlock_mode;\n\n\tdqp->q_fileoffset = (xfs_fileoff_t)id / mp->m_quotainfo->qi_dqperchunk;\n\n\tlock_mode = xfs_ilock_data_map_shared(quotip);\n\tif (!xfs_this_quota_on(dqp->q_mount, dqp->dq_flags)) {\n\t\t/*\n\t\t * Return if this type of quotas is turned off while we\n\t\t * didn't have the quota inode lock.\n\t\t */\n\t\txfs_iunlock(quotip, lock_mode);\n\t\treturn -ESRCH;\n\t}\n\n\t/*\n\t * Find the block map; no allocations yet\n\t */\n\terror = xfs_bmapi_read(quotip, dqp->q_fileoffset,\n\t\t\t       XFS_DQUOT_CLUSTER_SIZE_FSB, &map, &nmaps, 0);\n\n\txfs_iunlock(quotip, lock_mode);\n\tif (error)\n\t\treturn error;\n\n\tASSERT(nmaps == 1);\n\tASSERT(map.br_blockcount == 1);\n\n\t/*\n\t * Offset of dquot in the (fixed sized) dquot chunk.\n\t */\n\tdqp->q_bufoffset = (id % mp->m_quotainfo->qi_dqperchunk) *\n\t\tsizeof(xfs_dqblk_t);\n\n\tASSERT(map.br_startblock != DELAYSTARTBLOCK);\n\tif (map.br_startblock == HOLESTARTBLOCK) {\n\t\t/*\n\t\t * We don't allocate unless we're asked to\n\t\t */\n\t\tif (!(flags & XFS_QMOPT_DQALLOC))\n\t\t\treturn -ENOENT;\n\n\t\tASSERT(tp);\n\t\terror = xfs_qm_dqalloc(tpp, mp, dqp, quotip,\n\t\t\t\t\tdqp->q_fileoffset, &bp);\n\t\tif (error)\n\t\t\treturn error;\n\t\ttp = *tpp;\n\t} else {\n\t\ttrace_xfs_dqtobp_read(dqp);\n\n\t\t/*\n\t\t * store the blkno etc so that we don't have to do the\n\t\t * mapping all the time\n\t\t */\n\t\tdqp->q_blkno = XFS_FSB_TO_DADDR(mp, map.br_startblock);\n\n\t\terror = xfs_trans_read_buf(mp, tp, mp->m_ddev_targp,\n\t\t\t\t\t   dqp->q_blkno,\n\t\t\t\t\t   mp->m_quotainfo->qi_dqchunklen,\n\t\t\t\t\t   0, &bp, &xfs_dquot_buf_ops);\n\n\t\tif (error == -EFSCORRUPTED && (flags & XFS_QMOPT_DQREPAIR)) {\n\t\t\txfs_dqid_t firstid = (xfs_dqid_t)map.br_startoff *\n\t\t\t\t\t\tmp->m_quotainfo->qi_dqperchunk;\n\t\t\tASSERT(bp == NULL);\n\t\t\terror = xfs_qm_dqrepair(mp, tp, dqp, firstid, &bp);\n\t\t}\n\n\t\tif (error) {\n\t\t\tASSERT(bp == NULL);\n\t\t\treturn error;\n\t\t}\n\t}\n\n\tASSERT(xfs_buf_islocked(bp));\n\t*O_bpp = bp;\n\t*O_ddpp = bp->b_addr + dqp->q_bufoffset;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_qm.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_qm.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxfs_qm_dqtobp(\n\txfs_trans_t\t\t**tpp,\n\txfs_dquot_t\t\t*dqp,\n\txfs_disk_dquot_t\t**O_ddpp,\n\txfs_buf_t\t\t**O_bpp,\n\tuint\t\t\tflags)\n{\n\tstruct xfs_bmbt_irec\tmap;\n\tint\t\t\tnmaps = 1, error;\n\tstruct xfs_buf\t\t*bp;\n\tstruct xfs_inode\t*quotip = xfs_dq_to_quota_inode(dqp);\n\tstruct xfs_mount\t*mp = dqp->q_mount;\n\txfs_dqid_t\t\tid = be32_to_cpu(dqp->q_core.d_id);\n\tstruct xfs_trans\t*tp = (tpp ? *tpp : NULL);\n\tuint\t\t\tlock_mode;\n\n\tdqp->q_fileoffset = (xfs_fileoff_t)id / mp->m_quotainfo->qi_dqperchunk;\n\n\tlock_mode = xfs_ilock_data_map_shared(quotip);\n\tif (!xfs_this_quota_on(dqp->q_mount, dqp->dq_flags)) {\n\t\t/*\n\t\t * Return if this type of quotas is turned off while we\n\t\t * didn't have the quota inode lock.\n\t\t */\n\t\txfs_iunlock(quotip, lock_mode);\n\t\treturn -ESRCH;\n\t}\n\n\t/*\n\t * Find the block map; no allocations yet\n\t */\n\terror = xfs_bmapi_read(quotip, dqp->q_fileoffset,\n\t\t\t       XFS_DQUOT_CLUSTER_SIZE_FSB, &map, &nmaps, 0);\n\n\txfs_iunlock(quotip, lock_mode);\n\tif (error)\n\t\treturn error;\n\n\tASSERT(nmaps == 1);\n\tASSERT(map.br_blockcount == 1);\n\n\t/*\n\t * Offset of dquot in the (fixed sized) dquot chunk.\n\t */\n\tdqp->q_bufoffset = (id % mp->m_quotainfo->qi_dqperchunk) *\n\t\tsizeof(xfs_dqblk_t);\n\n\tASSERT(map.br_startblock != DELAYSTARTBLOCK);\n\tif (map.br_startblock == HOLESTARTBLOCK) {\n\t\t/*\n\t\t * We don't allocate unless we're asked to\n\t\t */\n\t\tif (!(flags & XFS_QMOPT_DQALLOC))\n\t\t\treturn -ENOENT;\n\n\t\tASSERT(tp);\n\t\terror = xfs_qm_dqalloc(tpp, mp, dqp, quotip,\n\t\t\t\t\tdqp->q_fileoffset, &bp);\n\t\tif (error)\n\t\t\treturn error;\n\t\ttp = *tpp;\n\t} else {\n\t\ttrace_xfs_dqtobp_read(dqp);\n\n\t\t/*\n\t\t * store the blkno etc so that we don't have to do the\n\t\t * mapping all the time\n\t\t */\n\t\tdqp->q_blkno = XFS_FSB_TO_DADDR(mp, map.br_startblock);\n\n\t\terror = xfs_trans_read_buf(mp, tp, mp->m_ddev_targp,\n\t\t\t\t\t   dqp->q_blkno,\n\t\t\t\t\t   mp->m_quotainfo->qi_dqchunklen,\n\t\t\t\t\t   0, &bp, &xfs_dquot_buf_ops);\n\n\t\tif (error == -EFSCORRUPTED && (flags & XFS_QMOPT_DQREPAIR)) {\n\t\t\txfs_dqid_t firstid = (xfs_dqid_t)map.br_startoff *\n\t\t\t\t\t\tmp->m_quotainfo->qi_dqperchunk;\n\t\t\tASSERT(bp == NULL);\n\t\t\terror = xfs_qm_dqrepair(mp, tp, dqp, firstid, &bp);\n\t\t}\n\n\t\tif (error) {\n\t\t\tASSERT(bp == NULL);\n\t\t\treturn error;\n\t\t}\n\t}\n\n\tASSERT(xfs_buf_islocked(bp));\n\t*O_bpp = bp;\n\t*O_ddpp = bp->b_addr + dqp->q_bufoffset;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_reserve",
          "args": [
            "tp",
            "&M_RES(mp)->tr_qm_dqalloc",
            "XFS_QM_DQALLOC_SPACE_RES(mp)",
            "0"
          ],
          "line": 616
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_reserve",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.c",
          "lines": "168-279",
          "snippet": "int\nxfs_trans_reserve(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_trans_res\t*resp,\n\tuint\t\t\tblocks,\n\tuint\t\t\trtextents)\n{\n\tint\t\terror = 0;\n\tint\t\trsvd = (tp->t_flags & XFS_TRANS_RESERVE) != 0;\n\n\t/* Mark this thread as being in a transaction */\n\tcurrent_set_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\t/*\n\t * Attempt to reserve the needed disk blocks by decrementing\n\t * the number needed from the number available.  This will\n\t * fail if the count would go below zero.\n\t */\n\tif (blocks > 0) {\n\t\terror = xfs_icsb_modify_counters(tp->t_mountp, XFS_SBS_FDBLOCKS,\n\t\t\t\t\t  -((int64_t)blocks), rsvd);\n\t\tif (error != 0) {\n\t\t\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\t\t\treturn -ENOSPC;\n\t\t}\n\t\ttp->t_blk_res += blocks;\n\t}\n\n\t/*\n\t * Reserve the log space needed for this transaction.\n\t */\n\tif (resp->tr_logres > 0) {\n\t\tbool\tpermanent = false;\n\n\t\tASSERT(tp->t_log_res == 0 ||\n\t\t       tp->t_log_res == resp->tr_logres);\n\t\tASSERT(tp->t_log_count == 0 ||\n\t\t       tp->t_log_count == resp->tr_logcount);\n\n\t\tif (resp->tr_logflags & XFS_TRANS_PERM_LOG_RES) {\n\t\t\ttp->t_flags |= XFS_TRANS_PERM_LOG_RES;\n\t\t\tpermanent = true;\n\t\t} else {\n\t\t\tASSERT(tp->t_ticket == NULL);\n\t\t\tASSERT(!(tp->t_flags & XFS_TRANS_PERM_LOG_RES));\n\t\t}\n\n\t\tif (tp->t_ticket != NULL) {\n\t\t\tASSERT(resp->tr_logflags & XFS_TRANS_PERM_LOG_RES);\n\t\t\terror = xfs_log_regrant(tp->t_mountp, tp->t_ticket);\n\t\t} else {\n\t\t\terror = xfs_log_reserve(tp->t_mountp,\n\t\t\t\t\t\tresp->tr_logres,\n\t\t\t\t\t\tresp->tr_logcount,\n\t\t\t\t\t\t&tp->t_ticket, XFS_TRANSACTION,\n\t\t\t\t\t\tpermanent, tp->t_type);\n\t\t}\n\n\t\tif (error)\n\t\t\tgoto undo_blocks;\n\n\t\ttp->t_log_res = resp->tr_logres;\n\t\ttp->t_log_count = resp->tr_logcount;\n\t}\n\n\t/*\n\t * Attempt to reserve the needed realtime extents by decrementing\n\t * the number needed from the number available.  This will\n\t * fail if the count would go below zero.\n\t */\n\tif (rtextents > 0) {\n\t\terror = xfs_mod_incore_sb(tp->t_mountp, XFS_SBS_FREXTENTS,\n\t\t\t\t\t  -((int64_t)rtextents), rsvd);\n\t\tif (error) {\n\t\t\terror = -ENOSPC;\n\t\t\tgoto undo_log;\n\t\t}\n\t\ttp->t_rtx_res += rtextents;\n\t}\n\n\treturn 0;\n\n\t/*\n\t * Error cases jump to one of these labels to undo any\n\t * reservations which have already been performed.\n\t */\nundo_log:\n\tif (resp->tr_logres > 0) {\n\t\tint\t\tlog_flags;\n\n\t\tif (resp->tr_logflags & XFS_TRANS_PERM_LOG_RES) {\n\t\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t\t} else {\n\t\t\tlog_flags = 0;\n\t\t}\n\t\txfs_log_done(tp->t_mountp, tp->t_ticket, NULL, log_flags);\n\t\ttp->t_ticket = NULL;\n\t\ttp->t_log_res = 0;\n\t\ttp->t_flags &= ~XFS_TRANS_PERM_LOG_RES;\n\t}\n\nundo_blocks:\n\tif (blocks > 0) {\n\t\txfs_icsb_modify_counters(tp->t_mountp, XFS_SBS_FDBLOCKS,\n\t\t\t\t\t (int64_t)blocks, rsvd);\n\t\ttp->t_blk_res = 0;\n\t}\n\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_trans_reserve(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_trans_res\t*resp,\n\tuint\t\t\tblocks,\n\tuint\t\t\trtextents)\n{\n\tint\t\terror = 0;\n\tint\t\trsvd = (tp->t_flags & XFS_TRANS_RESERVE) != 0;\n\n\t/* Mark this thread as being in a transaction */\n\tcurrent_set_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\t/*\n\t * Attempt to reserve the needed disk blocks by decrementing\n\t * the number needed from the number available.  This will\n\t * fail if the count would go below zero.\n\t */\n\tif (blocks > 0) {\n\t\terror = xfs_icsb_modify_counters(tp->t_mountp, XFS_SBS_FDBLOCKS,\n\t\t\t\t\t  -((int64_t)blocks), rsvd);\n\t\tif (error != 0) {\n\t\t\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\t\t\treturn -ENOSPC;\n\t\t}\n\t\ttp->t_blk_res += blocks;\n\t}\n\n\t/*\n\t * Reserve the log space needed for this transaction.\n\t */\n\tif (resp->tr_logres > 0) {\n\t\tbool\tpermanent = false;\n\n\t\tASSERT(tp->t_log_res == 0 ||\n\t\t       tp->t_log_res == resp->tr_logres);\n\t\tASSERT(tp->t_log_count == 0 ||\n\t\t       tp->t_log_count == resp->tr_logcount);\n\n\t\tif (resp->tr_logflags & XFS_TRANS_PERM_LOG_RES) {\n\t\t\ttp->t_flags |= XFS_TRANS_PERM_LOG_RES;\n\t\t\tpermanent = true;\n\t\t} else {\n\t\t\tASSERT(tp->t_ticket == NULL);\n\t\t\tASSERT(!(tp->t_flags & XFS_TRANS_PERM_LOG_RES));\n\t\t}\n\n\t\tif (tp->t_ticket != NULL) {\n\t\t\tASSERT(resp->tr_logflags & XFS_TRANS_PERM_LOG_RES);\n\t\t\terror = xfs_log_regrant(tp->t_mountp, tp->t_ticket);\n\t\t} else {\n\t\t\terror = xfs_log_reserve(tp->t_mountp,\n\t\t\t\t\t\tresp->tr_logres,\n\t\t\t\t\t\tresp->tr_logcount,\n\t\t\t\t\t\t&tp->t_ticket, XFS_TRANSACTION,\n\t\t\t\t\t\tpermanent, tp->t_type);\n\t\t}\n\n\t\tif (error)\n\t\t\tgoto undo_blocks;\n\n\t\ttp->t_log_res = resp->tr_logres;\n\t\ttp->t_log_count = resp->tr_logcount;\n\t}\n\n\t/*\n\t * Attempt to reserve the needed realtime extents by decrementing\n\t * the number needed from the number available.  This will\n\t * fail if the count would go below zero.\n\t */\n\tif (rtextents > 0) {\n\t\terror = xfs_mod_incore_sb(tp->t_mountp, XFS_SBS_FREXTENTS,\n\t\t\t\t\t  -((int64_t)rtextents), rsvd);\n\t\tif (error) {\n\t\t\terror = -ENOSPC;\n\t\t\tgoto undo_log;\n\t\t}\n\t\ttp->t_rtx_res += rtextents;\n\t}\n\n\treturn 0;\n\n\t/*\n\t * Error cases jump to one of these labels to undo any\n\t * reservations which have already been performed.\n\t */\nundo_log:\n\tif (resp->tr_logres > 0) {\n\t\tint\t\tlog_flags;\n\n\t\tif (resp->tr_logflags & XFS_TRANS_PERM_LOG_RES) {\n\t\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t\t} else {\n\t\t\tlog_flags = 0;\n\t\t}\n\t\txfs_log_done(tp->t_mountp, tp->t_ticket, NULL, log_flags);\n\t\ttp->t_ticket = NULL;\n\t\ttp->t_log_res = 0;\n\t\ttp->t_flags &= ~XFS_TRANS_PERM_LOG_RES;\n\t}\n\nundo_blocks:\n\tif (blocks > 0) {\n\t\txfs_icsb_modify_counters(tp->t_mountp, XFS_SBS_FDBLOCKS,\n\t\t\t\t\t (int64_t)blocks, rsvd);\n\t\ttp->t_blk_res = 0;\n\t}\n\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_QM_DQALLOC_SPACE_RES",
          "args": [
            "mp"
          ],
          "line": 617
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "M_RES",
          "args": [
            "mp"
          ],
          "line": 616
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_trans_alloc",
          "args": [
            "mp",
            "XFS_TRANS_QM_DQALLOC"
          ],
          "line": 615
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.c",
          "lines": "57-68",
          "snippet": "xfs_trans_t *\nxfs_trans_alloc(\n\txfs_mount_t\t*mp,\n\tuint\t\ttype)\n{\n\txfs_trans_t     *tp;\n\n\tsb_start_intwrite(mp->m_super);\n\ttp = _xfs_trans_alloc(mp, type, KM_SLEEP);\n\ttp->t_flags |= XFS_TRANS_FREEZE_PROT;\n\treturn tp;\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nxfs_trans_t *\nxfs_trans_alloc(\n\txfs_mount_t\t*mp,\n\tuint\t\ttype)\n{\n\txfs_trans_t     *tp;\n\n\tsb_start_intwrite(mp->m_super);\n\ttp = _xfs_trans_alloc(mp, type, KM_SLEEP);\n\ttp->t_flags |= XFS_TRANS_FREEZE_PROT;\n\treturn tp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_xfs_dqread",
          "args": [
            "dqp"
          ],
          "line": 612
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_STATS_INC",
          "args": [
            "xs_qm_dquot"
          ],
          "line": 610
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "0"
          ],
          "line": 606
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_set_class",
          "args": [
            "&dqp->q_qlock",
            "&xfs_dquot_project_class"
          ],
          "line": 603
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_set_class",
          "args": [
            "&dqp->q_qlock",
            "&xfs_dquot_group_class"
          ],
          "line": 600
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "complete",
          "args": [
            "&dqp->q_flush"
          ],
          "line": 589
        },
        "resolved": true,
        "details": {
          "function_name": "dio_aio_complete_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/direct-io.c",
          "lines": "275-280",
          "snippet": "static void dio_aio_complete_work(struct work_struct *work)\n{\n\tstruct dio *dio = container_of(work, struct dio, complete_work);\n\n\tdio_complete(dio, dio->iocb->ki_pos, 0, true);\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/atomic.h>",
            "#include <linux/uio.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/err.h>",
            "#include <linux/wait.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/prefetch.h>\n#include <linux/atomic.h>\n#include <linux/uio.h>\n#include <linux/rwsem.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/err.h>\n#include <linux/wait.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/types.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic void dio_aio_complete_work(struct work_struct *work)\n{\n\tstruct dio *dio = container_of(work, struct dio, complete_work);\n\n\tdio_complete(dio, dio->iocb->ki_pos, 0, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_completion",
          "args": [
            "&dqp->q_flush"
          ],
          "line": 588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_waitqueue_head",
          "args": [
            "&dqp->q_pinwait"
          ],
          "line": 581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_init",
          "args": [
            "&dqp->q_qlock"
          ],
          "line": 580
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&dqp->q_lru"
          ],
          "line": 579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "id"
          ],
          "line": 577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_zone_zalloc",
          "args": [
            "xfs_qm_dqzone",
            "KM_SLEEP"
          ],
          "line": 574
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_zone_zalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/kmem.h",
          "lines": "119-123",
          "snippet": "static inline void *\nkmem_zone_zalloc(kmem_zone_t *zone, xfs_km_flags_t flags)\n{\n\treturn kmem_zone_alloc(zone, flags | KM_ZERO);\n}",
          "includes": [
            "#include <linux/vmalloc.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [
            "#define kmem_zone_t\tstruct kmem_cache",
            "#define KM_ZERO\t\t((__force xfs_km_flags_t)0x0010u)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n\n#define kmem_zone_t\tstruct kmem_cache\n#define KM_ZERO\t\t((__force xfs_km_flags_t)0x0010u)\n\nstatic inline void *\nkmem_zone_zalloc(kmem_zone_t *zone, xfs_km_flags_t flags)\n{\n\treturn kmem_zone_alloc(zone, flags | KM_ZERO);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_qm.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic struct kmem_zone\t\t*xfs_qm_dqzone;\nstatic struct lock_class_key xfs_dquot_group_class;\nstatic struct lock_class_key xfs_dquot_project_class;\n\nint\nxfs_qm_dqread(\n\tstruct xfs_mount\t*mp,\n\txfs_dqid_t\t\tid,\n\tuint\t\t\ttype,\n\tuint\t\t\tflags,\n\tstruct xfs_dquot\t**O_dqpp)\n{\n\tstruct xfs_dquot\t*dqp;\n\tstruct xfs_disk_dquot\t*ddqp;\n\tstruct xfs_buf\t\t*bp;\n\tstruct xfs_trans\t*tp = NULL;\n\tint\t\t\terror;\n\tint\t\t\tcancelflags = 0;\n\n\n\tdqp = kmem_zone_zalloc(xfs_qm_dqzone, KM_SLEEP);\n\n\tdqp->dq_flags = type;\n\tdqp->q_core.d_id = cpu_to_be32(id);\n\tdqp->q_mount = mp;\n\tINIT_LIST_HEAD(&dqp->q_lru);\n\tmutex_init(&dqp->q_qlock);\n\tinit_waitqueue_head(&dqp->q_pinwait);\n\n\t/*\n\t * Because we want to use a counting completion, complete\n\t * the flush completion once to allow a single access to\n\t * the flush completion without blocking.\n\t */\n\tinit_completion(&dqp->q_flush);\n\tcomplete(&dqp->q_flush);\n\n\t/*\n\t * Make sure group quotas have a different lock class than user\n\t * quotas.\n\t */\n\tswitch (type) {\n\tcase XFS_DQ_USER:\n\t\t/* uses the default lock class */\n\t\tbreak;\n\tcase XFS_DQ_GROUP:\n\t\tlockdep_set_class(&dqp->q_qlock, &xfs_dquot_group_class);\n\t\tbreak;\n\tcase XFS_DQ_PROJ:\n\t\tlockdep_set_class(&dqp->q_qlock, &xfs_dquot_project_class);\n\t\tbreak;\n\tdefault:\n\t\tASSERT(0);\n\t\tbreak;\n\t}\n\n\tXFS_STATS_INC(xs_qm_dquot);\n\n\ttrace_xfs_dqread(dqp);\n\n\tif (flags & XFS_QMOPT_DQALLOC) {\n\t\ttp = xfs_trans_alloc(mp, XFS_TRANS_QM_DQALLOC);\n\t\terror = xfs_trans_reserve(tp, &M_RES(mp)->tr_qm_dqalloc,\n\t\t\t\t\t  XFS_QM_DQALLOC_SPACE_RES(mp), 0);\n\t\tif (error)\n\t\t\tgoto error1;\n\t\tcancelflags = XFS_TRANS_RELEASE_LOG_RES;\n\t}\n\n\t/*\n\t * get a pointer to the on-disk dquot and the buffer containing it\n\t * dqp already knows its own type (GROUP/USER).\n\t */\n\terror = xfs_qm_dqtobp(&tp, dqp, &ddqp, &bp, flags);\n\tif (error) {\n\t\t/*\n\t\t * This can happen if quotas got turned off (ESRCH),\n\t\t * or if the dquot didn't exist on disk and we ask to\n\t\t * allocate (ENOENT).\n\t\t */\n\t\ttrace_xfs_dqread_fail(dqp);\n\t\tcancelflags |= XFS_TRANS_ABORT;\n\t\tgoto error1;\n\t}\n\n\t/* copy everything from disk dquot to the incore dquot */\n\tmemcpy(&dqp->q_core, ddqp, sizeof(xfs_disk_dquot_t));\n\txfs_qm_dquot_logitem_init(dqp);\n\n\t/*\n\t * Reservation counters are defined as reservation plus current usage\n\t * to avoid having to add every time.\n\t */\n\tdqp->q_res_bcount = be64_to_cpu(ddqp->d_bcount);\n\tdqp->q_res_icount = be64_to_cpu(ddqp->d_icount);\n\tdqp->q_res_rtbcount = be64_to_cpu(ddqp->d_rtbcount);\n\n\t/* initialize the dquot speculative prealloc thresholds */\n\txfs_dquot_set_prealloc_limits(dqp);\n\n\t/* Mark the buf so that this will stay incore a little longer */\n\txfs_buf_set_ref(bp, XFS_DQUOT_REF);\n\n\t/*\n\t * We got the buffer with a xfs_trans_read_buf() (in dqtobp())\n\t * So we need to release with xfs_trans_brelse().\n\t * The strategy here is identical to that of inodes; we lock\n\t * the dquot in xfs_qm_dqget() before making it accessible to\n\t * others. This is because dquots, like inodes, need a good level of\n\t * concurrency, and we don't want to take locks on the entire buffers\n\t * for dquot accesses.\n\t * Note also that the dquot buffer may even be dirty at this point, if\n\t * this particular dquot was repaired. We still aren't afraid to\n\t * brelse it because we have the changes incore.\n\t */\n\tASSERT(xfs_buf_islocked(bp));\n\txfs_trans_brelse(tp, bp);\n\n\tif (tp) {\n\t\terror = xfs_trans_commit(tp, XFS_TRANS_RELEASE_LOG_RES);\n\t\tif (error)\n\t\t\tgoto error0;\n\t}\n\n\t*O_dqpp = dqp;\n\treturn error;\n\nerror1:\n\tif (tp)\n\t\txfs_trans_cancel(tp, cancelflags);\nerror0:\n\txfs_qm_dqdestroy(dqp);\n\t*O_dqpp = NULL;\n\treturn error;\n}"
  },
  {
    "function_name": "xfs_qm_dqtobp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_dquot.c",
    "lines": "455-549",
    "snippet": "STATIC int\nxfs_qm_dqtobp(\n\txfs_trans_t\t\t**tpp,\n\txfs_dquot_t\t\t*dqp,\n\txfs_disk_dquot_t\t**O_ddpp,\n\txfs_buf_t\t\t**O_bpp,\n\tuint\t\t\tflags)\n{\n\tstruct xfs_bmbt_irec\tmap;\n\tint\t\t\tnmaps = 1, error;\n\tstruct xfs_buf\t\t*bp;\n\tstruct xfs_inode\t*quotip = xfs_dq_to_quota_inode(dqp);\n\tstruct xfs_mount\t*mp = dqp->q_mount;\n\txfs_dqid_t\t\tid = be32_to_cpu(dqp->q_core.d_id);\n\tstruct xfs_trans\t*tp = (tpp ? *tpp : NULL);\n\tuint\t\t\tlock_mode;\n\n\tdqp->q_fileoffset = (xfs_fileoff_t)id / mp->m_quotainfo->qi_dqperchunk;\n\n\tlock_mode = xfs_ilock_data_map_shared(quotip);\n\tif (!xfs_this_quota_on(dqp->q_mount, dqp->dq_flags)) {\n\t\t/*\n\t\t * Return if this type of quotas is turned off while we\n\t\t * didn't have the quota inode lock.\n\t\t */\n\t\txfs_iunlock(quotip, lock_mode);\n\t\treturn -ESRCH;\n\t}\n\n\t/*\n\t * Find the block map; no allocations yet\n\t */\n\terror = xfs_bmapi_read(quotip, dqp->q_fileoffset,\n\t\t\t       XFS_DQUOT_CLUSTER_SIZE_FSB, &map, &nmaps, 0);\n\n\txfs_iunlock(quotip, lock_mode);\n\tif (error)\n\t\treturn error;\n\n\tASSERT(nmaps == 1);\n\tASSERT(map.br_blockcount == 1);\n\n\t/*\n\t * Offset of dquot in the (fixed sized) dquot chunk.\n\t */\n\tdqp->q_bufoffset = (id % mp->m_quotainfo->qi_dqperchunk) *\n\t\tsizeof(xfs_dqblk_t);\n\n\tASSERT(map.br_startblock != DELAYSTARTBLOCK);\n\tif (map.br_startblock == HOLESTARTBLOCK) {\n\t\t/*\n\t\t * We don't allocate unless we're asked to\n\t\t */\n\t\tif (!(flags & XFS_QMOPT_DQALLOC))\n\t\t\treturn -ENOENT;\n\n\t\tASSERT(tp);\n\t\terror = xfs_qm_dqalloc(tpp, mp, dqp, quotip,\n\t\t\t\t\tdqp->q_fileoffset, &bp);\n\t\tif (error)\n\t\t\treturn error;\n\t\ttp = *tpp;\n\t} else {\n\t\ttrace_xfs_dqtobp_read(dqp);\n\n\t\t/*\n\t\t * store the blkno etc so that we don't have to do the\n\t\t * mapping all the time\n\t\t */\n\t\tdqp->q_blkno = XFS_FSB_TO_DADDR(mp, map.br_startblock);\n\n\t\terror = xfs_trans_read_buf(mp, tp, mp->m_ddev_targp,\n\t\t\t\t\t   dqp->q_blkno,\n\t\t\t\t\t   mp->m_quotainfo->qi_dqchunklen,\n\t\t\t\t\t   0, &bp, &xfs_dquot_buf_ops);\n\n\t\tif (error == -EFSCORRUPTED && (flags & XFS_QMOPT_DQREPAIR)) {\n\t\t\txfs_dqid_t firstid = (xfs_dqid_t)map.br_startoff *\n\t\t\t\t\t\tmp->m_quotainfo->qi_dqperchunk;\n\t\t\tASSERT(bp == NULL);\n\t\t\terror = xfs_qm_dqrepair(mp, tp, dqp, firstid, &bp);\n\t\t}\n\n\t\tif (error) {\n\t\t\tASSERT(bp == NULL);\n\t\t\treturn error;\n\t\t}\n\t}\n\n\tASSERT(xfs_buf_islocked(bp));\n\t*O_bpp = bp;\n\t*O_ddpp = bp->b_addr + dqp->q_bufoffset;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_qm.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "xfs_buf_islocked(bp)"
          ],
          "line": 544
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_buf_islocked",
          "args": [
            "bp"
          ],
          "line": 544
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "bp == NULL"
          ],
          "line": 539
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_qm_dqrepair",
          "args": [
            "mp",
            "tp",
            "dqp",
            "firstid",
            "&bp"
          ],
          "line": 535
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_qm_dqrepair",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_dquot.c",
          "lines": "404-448",
          "snippet": "STATIC int\nxfs_qm_dqrepair(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_dquot\t*dqp,\n\txfs_dqid_t\t\tfirstid,\n\tstruct xfs_buf\t\t**bpp)\n{\n\tint\t\t\terror;\n\tstruct xfs_disk_dquot\t*ddq;\n\tstruct xfs_dqblk\t*d;\n\tint\t\t\ti;\n\n\t/*\n\t * Read the buffer without verification so we get the corrupted\n\t * buffer returned to us. make sure we verify it on write, though.\n\t */\n\terror = xfs_trans_read_buf(mp, tp, mp->m_ddev_targp, dqp->q_blkno,\n\t\t\t\t   mp->m_quotainfo->qi_dqchunklen,\n\t\t\t\t   0, bpp, NULL);\n\n\tif (error) {\n\t\tASSERT(*bpp == NULL);\n\t\treturn error;\n\t}\n\t(*bpp)->b_ops = &xfs_dquot_buf_ops;\n\n\tASSERT(xfs_buf_islocked(*bpp));\n\td = (struct xfs_dqblk *)(*bpp)->b_addr;\n\n\t/* Do the actual repair of dquots in this buffer */\n\tfor (i = 0; i < mp->m_quotainfo->qi_dqperchunk; i++) {\n\t\tddq = &d[i].dd_diskdq;\n\t\terror = xfs_dqcheck(mp, ddq, firstid + i,\n\t\t\t\t       dqp->dq_flags & XFS_DQ_ALLTYPES,\n\t\t\t\t       XFS_QMOPT_DQREPAIR, \"xfs_qm_dqrepair\");\n\t\tif (error) {\n\t\t\t/* repair failed, we're screwed */\n\t\t\txfs_trans_brelse(tp, *bpp);\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_qm.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_qm.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxfs_qm_dqrepair(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_dquot\t*dqp,\n\txfs_dqid_t\t\tfirstid,\n\tstruct xfs_buf\t\t**bpp)\n{\n\tint\t\t\terror;\n\tstruct xfs_disk_dquot\t*ddq;\n\tstruct xfs_dqblk\t*d;\n\tint\t\t\ti;\n\n\t/*\n\t * Read the buffer without verification so we get the corrupted\n\t * buffer returned to us. make sure we verify it on write, though.\n\t */\n\terror = xfs_trans_read_buf(mp, tp, mp->m_ddev_targp, dqp->q_blkno,\n\t\t\t\t   mp->m_quotainfo->qi_dqchunklen,\n\t\t\t\t   0, bpp, NULL);\n\n\tif (error) {\n\t\tASSERT(*bpp == NULL);\n\t\treturn error;\n\t}\n\t(*bpp)->b_ops = &xfs_dquot_buf_ops;\n\n\tASSERT(xfs_buf_islocked(*bpp));\n\td = (struct xfs_dqblk *)(*bpp)->b_addr;\n\n\t/* Do the actual repair of dquots in this buffer */\n\tfor (i = 0; i < mp->m_quotainfo->qi_dqperchunk; i++) {\n\t\tddq = &d[i].dd_diskdq;\n\t\terror = xfs_dqcheck(mp, ddq, firstid + i,\n\t\t\t\t       dqp->dq_flags & XFS_DQ_ALLTYPES,\n\t\t\t\t       XFS_QMOPT_DQREPAIR, \"xfs_qm_dqrepair\");\n\t\tif (error) {\n\t\t\t/* repair failed, we're screwed */\n\t\t\txfs_trans_brelse(tp, *bpp);\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "bp == NULL"
          ],
          "line": 534
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_trans_read_buf",
          "args": [
            "mp",
            "tp",
            "mp->m_ddev_targp",
            "dqp->q_blkno",
            "mp->m_quotainfo->qi_dqchunklen",
            "0",
            "&bp",
            "&xfs_dquot_buf_ops"
          ],
          "line": 526
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_read_buf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.h",
          "lines": "186-200",
          "snippet": "static inline int\nxfs_trans_read_buf(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_buftarg\t*target,\n\txfs_daddr_t\t\tblkno,\n\tint\t\t\tnumblks,\n\txfs_buf_flags_t\t\tflags,\n\tstruct xfs_buf\t\t**bpp,\n\tconst struct xfs_buf_ops *ops)\n{\n\tDEFINE_SINGLE_BUF_MAP(map, blkno, numblks);\n\treturn xfs_trans_read_buf_map(mp, tp, target, &map, 1,\n\t\t\t\t      flags, bpp, ops);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int\nxfs_trans_read_buf(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_buftarg\t*target,\n\txfs_daddr_t\t\tblkno,\n\tint\t\t\tnumblks,\n\txfs_buf_flags_t\t\tflags,\n\tstruct xfs_buf\t\t**bpp,\n\tconst struct xfs_buf_ops *ops)\n{\n\tDEFINE_SINGLE_BUF_MAP(map, blkno, numblks);\n\treturn xfs_trans_read_buf_map(mp, tp, target, &map, 1,\n\t\t\t\t      flags, bpp, ops);\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_FSB_TO_DADDR",
          "args": [
            "mp",
            "map.br_startblock"
          ],
          "line": 524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_xfs_dqtobp_read",
          "args": [
            "dqp"
          ],
          "line": 518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_qm_dqalloc",
          "args": [
            "tpp",
            "mp",
            "dqp",
            "quotip",
            "dqp->q_fileoffset",
            "&bp"
          ],
          "line": 512
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_qm_dqalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_dquot.c",
          "lines": "297-402",
          "snippet": "STATIC int\nxfs_qm_dqalloc(\n\txfs_trans_t\t**tpp,\n\txfs_mount_t\t*mp,\n\txfs_dquot_t\t*dqp,\n\txfs_inode_t\t*quotip,\n\txfs_fileoff_t\toffset_fsb,\n\txfs_buf_t\t**O_bpp)\n{\n\txfs_fsblock_t\tfirstblock;\n\txfs_bmap_free_t flist;\n\txfs_bmbt_irec_t map;\n\tint\t\tnmaps, error, committed;\n\txfs_buf_t\t*bp;\n\txfs_trans_t\t*tp = *tpp;\n\n\tASSERT(tp != NULL);\n\n\ttrace_xfs_dqalloc(dqp);\n\n\t/*\n\t * Initialize the bmap freelist prior to calling bmapi code.\n\t */\n\txfs_bmap_init(&flist, &firstblock);\n\txfs_ilock(quotip, XFS_ILOCK_EXCL);\n\t/*\n\t * Return if this type of quotas is turned off while we didn't\n\t * have an inode lock\n\t */\n\tif (!xfs_this_quota_on(dqp->q_mount, dqp->dq_flags)) {\n\t\txfs_iunlock(quotip, XFS_ILOCK_EXCL);\n\t\treturn -ESRCH;\n\t}\n\n\txfs_trans_ijoin(tp, quotip, XFS_ILOCK_EXCL);\n\tnmaps = 1;\n\terror = xfs_bmapi_write(tp, quotip, offset_fsb,\n\t\t\t\tXFS_DQUOT_CLUSTER_SIZE_FSB, XFS_BMAPI_METADATA,\n\t\t\t\t&firstblock, XFS_QM_DQALLOC_SPACE_RES(mp),\n\t\t\t\t&map, &nmaps, &flist);\n\tif (error)\n\t\tgoto error0;\n\tASSERT(map.br_blockcount == XFS_DQUOT_CLUSTER_SIZE_FSB);\n\tASSERT(nmaps == 1);\n\tASSERT((map.br_startblock != DELAYSTARTBLOCK) &&\n\t       (map.br_startblock != HOLESTARTBLOCK));\n\n\t/*\n\t * Keep track of the blkno to save a lookup later\n\t */\n\tdqp->q_blkno = XFS_FSB_TO_DADDR(mp, map.br_startblock);\n\n\t/* now we can just get the buffer (there's nothing to read yet) */\n\tbp = xfs_trans_get_buf(tp, mp->m_ddev_targp,\n\t\t\t       dqp->q_blkno,\n\t\t\t       mp->m_quotainfo->qi_dqchunklen,\n\t\t\t       0);\n\tif (!bp) {\n\t\terror = -ENOMEM;\n\t\tgoto error1;\n\t}\n\tbp->b_ops = &xfs_dquot_buf_ops;\n\n\t/*\n\t * Make a chunk of dquots out of this buffer and log\n\t * the entire thing.\n\t */\n\txfs_qm_init_dquot_blk(tp, mp, be32_to_cpu(dqp->q_core.d_id),\n\t\t\t      dqp->dq_flags & XFS_DQ_ALLTYPES, bp);\n\n\t/*\n\t * xfs_bmap_finish() may commit the current transaction and\n\t * start a second transaction if the freelist is not empty.\n\t *\n\t * Since we still want to modify this buffer, we need to\n\t * ensure that the buffer is not released on commit of\n\t * the first transaction and ensure the buffer is added to the\n\t * second transaction.\n\t *\n\t * If there is only one transaction then don't stop the buffer\n\t * from being released when it commits later on.\n\t */\n\n\txfs_trans_bhold(tp, bp);\n\n\tif ((error = xfs_bmap_finish(tpp, &flist, &committed))) {\n\t\tgoto error1;\n\t}\n\n\tif (committed) {\n\t\ttp = *tpp;\n\t\txfs_trans_bjoin(tp, bp);\n\t} else {\n\t\txfs_trans_bhold_release(tp, bp);\n\t}\n\n\t*O_bpp = bp;\n\treturn 0;\n\n      error1:\n\txfs_bmap_cancel(&flist);\n      error0:\n\txfs_iunlock(quotip, XFS_ILOCK_EXCL);\n\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_qm.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_qm.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxfs_qm_dqalloc(\n\txfs_trans_t\t**tpp,\n\txfs_mount_t\t*mp,\n\txfs_dquot_t\t*dqp,\n\txfs_inode_t\t*quotip,\n\txfs_fileoff_t\toffset_fsb,\n\txfs_buf_t\t**O_bpp)\n{\n\txfs_fsblock_t\tfirstblock;\n\txfs_bmap_free_t flist;\n\txfs_bmbt_irec_t map;\n\tint\t\tnmaps, error, committed;\n\txfs_buf_t\t*bp;\n\txfs_trans_t\t*tp = *tpp;\n\n\tASSERT(tp != NULL);\n\n\ttrace_xfs_dqalloc(dqp);\n\n\t/*\n\t * Initialize the bmap freelist prior to calling bmapi code.\n\t */\n\txfs_bmap_init(&flist, &firstblock);\n\txfs_ilock(quotip, XFS_ILOCK_EXCL);\n\t/*\n\t * Return if this type of quotas is turned off while we didn't\n\t * have an inode lock\n\t */\n\tif (!xfs_this_quota_on(dqp->q_mount, dqp->dq_flags)) {\n\t\txfs_iunlock(quotip, XFS_ILOCK_EXCL);\n\t\treturn -ESRCH;\n\t}\n\n\txfs_trans_ijoin(tp, quotip, XFS_ILOCK_EXCL);\n\tnmaps = 1;\n\terror = xfs_bmapi_write(tp, quotip, offset_fsb,\n\t\t\t\tXFS_DQUOT_CLUSTER_SIZE_FSB, XFS_BMAPI_METADATA,\n\t\t\t\t&firstblock, XFS_QM_DQALLOC_SPACE_RES(mp),\n\t\t\t\t&map, &nmaps, &flist);\n\tif (error)\n\t\tgoto error0;\n\tASSERT(map.br_blockcount == XFS_DQUOT_CLUSTER_SIZE_FSB);\n\tASSERT(nmaps == 1);\n\tASSERT((map.br_startblock != DELAYSTARTBLOCK) &&\n\t       (map.br_startblock != HOLESTARTBLOCK));\n\n\t/*\n\t * Keep track of the blkno to save a lookup later\n\t */\n\tdqp->q_blkno = XFS_FSB_TO_DADDR(mp, map.br_startblock);\n\n\t/* now we can just get the buffer (there's nothing to read yet) */\n\tbp = xfs_trans_get_buf(tp, mp->m_ddev_targp,\n\t\t\t       dqp->q_blkno,\n\t\t\t       mp->m_quotainfo->qi_dqchunklen,\n\t\t\t       0);\n\tif (!bp) {\n\t\terror = -ENOMEM;\n\t\tgoto error1;\n\t}\n\tbp->b_ops = &xfs_dquot_buf_ops;\n\n\t/*\n\t * Make a chunk of dquots out of this buffer and log\n\t * the entire thing.\n\t */\n\txfs_qm_init_dquot_blk(tp, mp, be32_to_cpu(dqp->q_core.d_id),\n\t\t\t      dqp->dq_flags & XFS_DQ_ALLTYPES, bp);\n\n\t/*\n\t * xfs_bmap_finish() may commit the current transaction and\n\t * start a second transaction if the freelist is not empty.\n\t *\n\t * Since we still want to modify this buffer, we need to\n\t * ensure that the buffer is not released on commit of\n\t * the first transaction and ensure the buffer is added to the\n\t * second transaction.\n\t *\n\t * If there is only one transaction then don't stop the buffer\n\t * from being released when it commits later on.\n\t */\n\n\txfs_trans_bhold(tp, bp);\n\n\tif ((error = xfs_bmap_finish(tpp, &flist, &committed))) {\n\t\tgoto error1;\n\t}\n\n\tif (committed) {\n\t\ttp = *tpp;\n\t\txfs_trans_bjoin(tp, bp);\n\t} else {\n\t\txfs_trans_bhold_release(tp, bp);\n\t}\n\n\t*O_bpp = bp;\n\treturn 0;\n\n      error1:\n\txfs_bmap_cancel(&flist);\n      error0:\n\txfs_iunlock(quotip, XFS_ILOCK_EXCL);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "tp"
          ],
          "line": 511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "map.br_startblock != DELAYSTARTBLOCK"
          ],
          "line": 503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "map.br_blockcount == 1"
          ],
          "line": 495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "nmaps == 1"
          ],
          "line": 494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_iunlock",
          "args": [
            "quotip",
            "lock_mode"
          ],
          "line": 490
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_iunlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
          "lines": "235-263",
          "snippet": "void\nxfs_iunlock(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\t/*\n\t * You can't set both SHARED and EXCL for the same lock,\n\t * and only XFS_IOLOCK_SHARED, XFS_IOLOCK_EXCL, XFS_ILOCK_SHARED,\n\t * and XFS_ILOCK_EXCL are valid values to set in lock_flags.\n\t */\n\tASSERT((lock_flags & (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL)) !=\n\t       (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL));\n\tASSERT((lock_flags & (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL)) !=\n\t       (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_LOCK_MASK | XFS_LOCK_DEP_MASK)) == 0);\n\tASSERT(lock_flags != 0);\n\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_iolock);\n\telse if (lock_flags & XFS_IOLOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_iolock);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_lock);\n\telse if (lock_flags & XFS_ILOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_lock);\n\n\ttrace_xfs_iunlock(ip, lock_flags, _RET_IP_);\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);\n\nvoid\nxfs_iunlock(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\t/*\n\t * You can't set both SHARED and EXCL for the same lock,\n\t * and only XFS_IOLOCK_SHARED, XFS_IOLOCK_EXCL, XFS_ILOCK_SHARED,\n\t * and XFS_ILOCK_EXCL are valid values to set in lock_flags.\n\t */\n\tASSERT((lock_flags & (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL)) !=\n\t       (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL));\n\tASSERT((lock_flags & (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL)) !=\n\t       (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_LOCK_MASK | XFS_LOCK_DEP_MASK)) == 0);\n\tASSERT(lock_flags != 0);\n\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_iolock);\n\telse if (lock_flags & XFS_IOLOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_iolock);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_lock);\n\telse if (lock_flags & XFS_ILOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_lock);\n\n\ttrace_xfs_iunlock(ip, lock_flags, _RET_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_bmapi_read",
          "args": [
            "quotip",
            "dqp->q_fileoffset",
            "XFS_DQUOT_CLUSTER_SIZE_FSB",
            "&map",
            "&nmaps",
            "0"
          ],
          "line": 487
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmapi_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.c",
          "lines": "4017-4103",
          "snippet": "int\nxfs_bmapi_read(\n\tstruct xfs_inode\t*ip,\n\txfs_fileoff_t\t\tbno,\n\txfs_filblks_t\t\tlen,\n\tstruct xfs_bmbt_irec\t*mval,\n\tint\t\t\t*nmap,\n\tint\t\t\tflags)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tstruct xfs_ifork\t*ifp;\n\tstruct xfs_bmbt_irec\tgot;\n\tstruct xfs_bmbt_irec\tprev;\n\txfs_fileoff_t\t\tobno;\n\txfs_fileoff_t\t\tend;\n\txfs_extnum_t\t\tlastx;\n\tint\t\t\terror;\n\tint\t\t\teof;\n\tint\t\t\tn = 0;\n\tint\t\t\twhichfork = (flags & XFS_BMAPI_ATTRFORK) ?\n\t\t\t\t\t\tXFS_ATTR_FORK : XFS_DATA_FORK;\n\n\tASSERT(*nmap >= 1);\n\tASSERT(!(flags & ~(XFS_BMAPI_ATTRFORK|XFS_BMAPI_ENTIRE|\n\t\t\t   XFS_BMAPI_IGSTATE)));\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_SHARED|XFS_ILOCK_EXCL));\n\n\tif (unlikely(XFS_TEST_ERROR(\n\t    (XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_EXTENTS &&\n\t     XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_BTREE),\n\t     mp, XFS_ERRTAG_BMAPIFORMAT, XFS_RANDOM_BMAPIFORMAT))) {\n\t\tXFS_ERROR_REPORT(\"xfs_bmapi_read\", XFS_ERRLEVEL_LOW, mp);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\tif (XFS_FORCED_SHUTDOWN(mp))\n\t\treturn -EIO;\n\n\tXFS_STATS_INC(xs_blk_mapr);\n\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\n\tif (!(ifp->if_flags & XFS_IFEXTENTS)) {\n\t\terror = xfs_iread_extents(NULL, ip, whichfork);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\txfs_bmap_search_extents(ip, bno, whichfork, &eof, &lastx, &got, &prev);\n\tend = bno + len;\n\tobno = bno;\n\n\twhile (bno < end && n < *nmap) {\n\t\t/* Reading past eof, act as though there's a hole up to end. */\n\t\tif (eof)\n\t\t\tgot.br_startoff = end;\n\t\tif (got.br_startoff > bno) {\n\t\t\t/* Reading in a hole.  */\n\t\t\tmval->br_startoff = bno;\n\t\t\tmval->br_startblock = HOLESTARTBLOCK;\n\t\t\tmval->br_blockcount =\n\t\t\t\tXFS_FILBLKS_MIN(len, got.br_startoff - bno);\n\t\t\tmval->br_state = XFS_EXT_NORM;\n\t\t\tbno += mval->br_blockcount;\n\t\t\tlen -= mval->br_blockcount;\n\t\t\tmval++;\n\t\t\tn++;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* set up the extent map to return. */\n\t\txfs_bmapi_trim_map(mval, &got, &bno, len, obno, end, n, flags);\n\t\txfs_bmapi_update_map(&mval, &bno, &len, obno, end, &n, flags);\n\n\t\t/* If we're done, stop now. */\n\t\tif (bno >= end || n >= *nmap)\n\t\t\tbreak;\n\n\t\t/* Else go on to the next record. */\n\t\tif (++lastx < ifp->if_bytes / sizeof(xfs_bmbt_rec_t))\n\t\t\txfs_bmbt_get_all(xfs_iext_get_ext(ifp, lastx), &got);\n\t\telse\n\t\t\teof = 1;\n\t}\n\t*nmap = n;\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_bmapi_read(\n\tstruct xfs_inode\t*ip,\n\txfs_fileoff_t\t\tbno,\n\txfs_filblks_t\t\tlen,\n\tstruct xfs_bmbt_irec\t*mval,\n\tint\t\t\t*nmap,\n\tint\t\t\tflags)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tstruct xfs_ifork\t*ifp;\n\tstruct xfs_bmbt_irec\tgot;\n\tstruct xfs_bmbt_irec\tprev;\n\txfs_fileoff_t\t\tobno;\n\txfs_fileoff_t\t\tend;\n\txfs_extnum_t\t\tlastx;\n\tint\t\t\terror;\n\tint\t\t\teof;\n\tint\t\t\tn = 0;\n\tint\t\t\twhichfork = (flags & XFS_BMAPI_ATTRFORK) ?\n\t\t\t\t\t\tXFS_ATTR_FORK : XFS_DATA_FORK;\n\n\tASSERT(*nmap >= 1);\n\tASSERT(!(flags & ~(XFS_BMAPI_ATTRFORK|XFS_BMAPI_ENTIRE|\n\t\t\t   XFS_BMAPI_IGSTATE)));\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_SHARED|XFS_ILOCK_EXCL));\n\n\tif (unlikely(XFS_TEST_ERROR(\n\t    (XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_EXTENTS &&\n\t     XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_BTREE),\n\t     mp, XFS_ERRTAG_BMAPIFORMAT, XFS_RANDOM_BMAPIFORMAT))) {\n\t\tXFS_ERROR_REPORT(\"xfs_bmapi_read\", XFS_ERRLEVEL_LOW, mp);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\tif (XFS_FORCED_SHUTDOWN(mp))\n\t\treturn -EIO;\n\n\tXFS_STATS_INC(xs_blk_mapr);\n\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\n\tif (!(ifp->if_flags & XFS_IFEXTENTS)) {\n\t\terror = xfs_iread_extents(NULL, ip, whichfork);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\txfs_bmap_search_extents(ip, bno, whichfork, &eof, &lastx, &got, &prev);\n\tend = bno + len;\n\tobno = bno;\n\n\twhile (bno < end && n < *nmap) {\n\t\t/* Reading past eof, act as though there's a hole up to end. */\n\t\tif (eof)\n\t\t\tgot.br_startoff = end;\n\t\tif (got.br_startoff > bno) {\n\t\t\t/* Reading in a hole.  */\n\t\t\tmval->br_startoff = bno;\n\t\t\tmval->br_startblock = HOLESTARTBLOCK;\n\t\t\tmval->br_blockcount =\n\t\t\t\tXFS_FILBLKS_MIN(len, got.br_startoff - bno);\n\t\t\tmval->br_state = XFS_EXT_NORM;\n\t\t\tbno += mval->br_blockcount;\n\t\t\tlen -= mval->br_blockcount;\n\t\t\tmval++;\n\t\t\tn++;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* set up the extent map to return. */\n\t\txfs_bmapi_trim_map(mval, &got, &bno, len, obno, end, n, flags);\n\t\txfs_bmapi_update_map(&mval, &bno, &len, obno, end, &n, flags);\n\n\t\t/* If we're done, stop now. */\n\t\tif (bno >= end || n >= *nmap)\n\t\t\tbreak;\n\n\t\t/* Else go on to the next record. */\n\t\tif (++lastx < ifp->if_bytes / sizeof(xfs_bmbt_rec_t))\n\t\t\txfs_bmbt_get_all(xfs_iext_get_ext(ifp, lastx), &got);\n\t\telse\n\t\t\teof = 1;\n\t}\n\t*nmap = n;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_this_quota_on",
          "args": [
            "dqp->q_mount",
            "dqp->dq_flags"
          ],
          "line": 475
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_this_quota_on",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_dquot.h",
          "lines": "114-126",
          "snippet": "static inline int xfs_this_quota_on(struct xfs_mount *mp, int type)\n{\n\tswitch (type & XFS_DQ_ALLTYPES) {\n\tcase XFS_DQ_USER:\n\t\treturn XFS_IS_UQUOTA_ON(mp);\n\tcase XFS_DQ_GROUP:\n\t\treturn XFS_IS_GQUOTA_ON(mp);\n\tcase XFS_DQ_PROJ:\n\t\treturn XFS_IS_PQUOTA_ON(mp);\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int xfs_this_quota_on(struct xfs_mount *mp, int type)\n{\n\tswitch (type & XFS_DQ_ALLTYPES) {\n\tcase XFS_DQ_USER:\n\t\treturn XFS_IS_UQUOTA_ON(mp);\n\tcase XFS_DQ_GROUP:\n\t\treturn XFS_IS_GQUOTA_ON(mp);\n\tcase XFS_DQ_PROJ:\n\t\treturn XFS_IS_PQUOTA_ON(mp);\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_ilock_data_map_shared",
          "args": [
            "quotip"
          ],
          "line": 474
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_ilock_data_map_shared",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
          "lines": "93-104",
          "snippet": "uint\nxfs_ilock_data_map_shared(\n\tstruct xfs_inode\t*ip)\n{\n\tuint\t\t\tlock_mode = XFS_ILOCK_SHARED;\n\n\tif (ip->i_d.di_format == XFS_DINODE_FMT_BTREE &&\n\t    (ip->i_df.if_flags & XFS_IFEXTENTS) == 0)\n\t\tlock_mode = XFS_ILOCK_EXCL;\n\txfs_ilock(ip, lock_mode);\n\treturn lock_mode;\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nuint\nxfs_ilock_data_map_shared(\n\tstruct xfs_inode\t*ip)\n{\n\tuint\t\t\tlock_mode = XFS_ILOCK_SHARED;\n\n\tif (ip->i_d.di_format == XFS_DINODE_FMT_BTREE &&\n\t    (ip->i_df.if_flags & XFS_IFEXTENTS) == 0)\n\t\tlock_mode = XFS_ILOCK_EXCL;\n\txfs_ilock(ip, lock_mode);\n\treturn lock_mode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "dqp->q_core.d_id"
          ],
          "line": 468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dq_to_quota_inode",
          "args": [
            "dqp"
          ],
          "line": 466
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dq_to_quota_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_qm.h",
          "lines": "106-120",
          "snippet": "static inline struct xfs_inode *\nxfs_dq_to_quota_inode(struct xfs_dquot *dqp)\n{\n\tswitch (dqp->dq_flags & XFS_DQ_ALLTYPES) {\n\tcase XFS_DQ_USER:\n\t\treturn dqp->q_mount->m_quotainfo->qi_uquotaip;\n\tcase XFS_DQ_GROUP:\n\t\treturn dqp->q_mount->m_quotainfo->qi_gquotaip;\n\tcase XFS_DQ_PROJ:\n\t\treturn dqp->q_mount->m_quotainfo->qi_pquotaip;\n\tdefault:\n\t\tASSERT(0);\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"xfs_dquot.h\"",
            "#include \"xfs_dquot_item.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_dquot.h\"\n#include \"xfs_dquot_item.h\"\n\nstatic inline struct xfs_inode *\nxfs_dq_to_quota_inode(struct xfs_dquot *dqp)\n{\n\tswitch (dqp->dq_flags & XFS_DQ_ALLTYPES) {\n\tcase XFS_DQ_USER:\n\t\treturn dqp->q_mount->m_quotainfo->qi_uquotaip;\n\tcase XFS_DQ_GROUP:\n\t\treturn dqp->q_mount->m_quotainfo->qi_gquotaip;\n\tcase XFS_DQ_PROJ:\n\t\treturn dqp->q_mount->m_quotainfo->qi_pquotaip;\n\tdefault:\n\t\tASSERT(0);\n\t}\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_qm.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxfs_qm_dqtobp(\n\txfs_trans_t\t\t**tpp,\n\txfs_dquot_t\t\t*dqp,\n\txfs_disk_dquot_t\t**O_ddpp,\n\txfs_buf_t\t\t**O_bpp,\n\tuint\t\t\tflags)\n{\n\tstruct xfs_bmbt_irec\tmap;\n\tint\t\t\tnmaps = 1, error;\n\tstruct xfs_buf\t\t*bp;\n\tstruct xfs_inode\t*quotip = xfs_dq_to_quota_inode(dqp);\n\tstruct xfs_mount\t*mp = dqp->q_mount;\n\txfs_dqid_t\t\tid = be32_to_cpu(dqp->q_core.d_id);\n\tstruct xfs_trans\t*tp = (tpp ? *tpp : NULL);\n\tuint\t\t\tlock_mode;\n\n\tdqp->q_fileoffset = (xfs_fileoff_t)id / mp->m_quotainfo->qi_dqperchunk;\n\n\tlock_mode = xfs_ilock_data_map_shared(quotip);\n\tif (!xfs_this_quota_on(dqp->q_mount, dqp->dq_flags)) {\n\t\t/*\n\t\t * Return if this type of quotas is turned off while we\n\t\t * didn't have the quota inode lock.\n\t\t */\n\t\txfs_iunlock(quotip, lock_mode);\n\t\treturn -ESRCH;\n\t}\n\n\t/*\n\t * Find the block map; no allocations yet\n\t */\n\terror = xfs_bmapi_read(quotip, dqp->q_fileoffset,\n\t\t\t       XFS_DQUOT_CLUSTER_SIZE_FSB, &map, &nmaps, 0);\n\n\txfs_iunlock(quotip, lock_mode);\n\tif (error)\n\t\treturn error;\n\n\tASSERT(nmaps == 1);\n\tASSERT(map.br_blockcount == 1);\n\n\t/*\n\t * Offset of dquot in the (fixed sized) dquot chunk.\n\t */\n\tdqp->q_bufoffset = (id % mp->m_quotainfo->qi_dqperchunk) *\n\t\tsizeof(xfs_dqblk_t);\n\n\tASSERT(map.br_startblock != DELAYSTARTBLOCK);\n\tif (map.br_startblock == HOLESTARTBLOCK) {\n\t\t/*\n\t\t * We don't allocate unless we're asked to\n\t\t */\n\t\tif (!(flags & XFS_QMOPT_DQALLOC))\n\t\t\treturn -ENOENT;\n\n\t\tASSERT(tp);\n\t\terror = xfs_qm_dqalloc(tpp, mp, dqp, quotip,\n\t\t\t\t\tdqp->q_fileoffset, &bp);\n\t\tif (error)\n\t\t\treturn error;\n\t\ttp = *tpp;\n\t} else {\n\t\ttrace_xfs_dqtobp_read(dqp);\n\n\t\t/*\n\t\t * store the blkno etc so that we don't have to do the\n\t\t * mapping all the time\n\t\t */\n\t\tdqp->q_blkno = XFS_FSB_TO_DADDR(mp, map.br_startblock);\n\n\t\terror = xfs_trans_read_buf(mp, tp, mp->m_ddev_targp,\n\t\t\t\t\t   dqp->q_blkno,\n\t\t\t\t\t   mp->m_quotainfo->qi_dqchunklen,\n\t\t\t\t\t   0, &bp, &xfs_dquot_buf_ops);\n\n\t\tif (error == -EFSCORRUPTED && (flags & XFS_QMOPT_DQREPAIR)) {\n\t\t\txfs_dqid_t firstid = (xfs_dqid_t)map.br_startoff *\n\t\t\t\t\t\tmp->m_quotainfo->qi_dqperchunk;\n\t\t\tASSERT(bp == NULL);\n\t\t\terror = xfs_qm_dqrepair(mp, tp, dqp, firstid, &bp);\n\t\t}\n\n\t\tif (error) {\n\t\t\tASSERT(bp == NULL);\n\t\t\treturn error;\n\t\t}\n\t}\n\n\tASSERT(xfs_buf_islocked(bp));\n\t*O_bpp = bp;\n\t*O_ddpp = bp->b_addr + dqp->q_bufoffset;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_qm_dqrepair",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_dquot.c",
    "lines": "404-448",
    "snippet": "STATIC int\nxfs_qm_dqrepair(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_dquot\t*dqp,\n\txfs_dqid_t\t\tfirstid,\n\tstruct xfs_buf\t\t**bpp)\n{\n\tint\t\t\terror;\n\tstruct xfs_disk_dquot\t*ddq;\n\tstruct xfs_dqblk\t*d;\n\tint\t\t\ti;\n\n\t/*\n\t * Read the buffer without verification so we get the corrupted\n\t * buffer returned to us. make sure we verify it on write, though.\n\t */\n\terror = xfs_trans_read_buf(mp, tp, mp->m_ddev_targp, dqp->q_blkno,\n\t\t\t\t   mp->m_quotainfo->qi_dqchunklen,\n\t\t\t\t   0, bpp, NULL);\n\n\tif (error) {\n\t\tASSERT(*bpp == NULL);\n\t\treturn error;\n\t}\n\t(*bpp)->b_ops = &xfs_dquot_buf_ops;\n\n\tASSERT(xfs_buf_islocked(*bpp));\n\td = (struct xfs_dqblk *)(*bpp)->b_addr;\n\n\t/* Do the actual repair of dquots in this buffer */\n\tfor (i = 0; i < mp->m_quotainfo->qi_dqperchunk; i++) {\n\t\tddq = &d[i].dd_diskdq;\n\t\terror = xfs_dqcheck(mp, ddq, firstid + i,\n\t\t\t\t       dqp->dq_flags & XFS_DQ_ALLTYPES,\n\t\t\t\t       XFS_QMOPT_DQREPAIR, \"xfs_qm_dqrepair\");\n\t\tif (error) {\n\t\t\t/* repair failed, we're screwed */\n\t\t\txfs_trans_brelse(tp, *bpp);\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_qm.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_trans_brelse",
          "args": [
            "tp",
            "*bpp"
          ],
          "line": 442
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_buf.c",
          "lines": "354-443",
          "snippet": "void\nxfs_trans_brelse(xfs_trans_t\t*tp,\n\t\t xfs_buf_t\t*bp)\n{\n\txfs_buf_log_item_t\t*bip;\n\n\t/*\n\t * Default to a normal brelse() call if the tp is NULL.\n\t */\n\tif (tp == NULL) {\n\t\tASSERT(bp->b_transp == NULL);\n\t\txfs_buf_relse(bp);\n\t\treturn;\n\t}\n\n\tASSERT(bp->b_transp == tp);\n\tbip = bp->b_fspriv;\n\tASSERT(bip->bli_item.li_type == XFS_LI_BUF);\n\tASSERT(!(bip->bli_flags & XFS_BLI_STALE));\n\tASSERT(!(bip->__bli_format.blf_flags & XFS_BLF_CANCEL));\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\n\ttrace_xfs_trans_brelse(bip);\n\n\t/*\n\t * If the release is just for a recursive lock,\n\t * then decrement the count and return.\n\t */\n\tif (bip->bli_recur > 0) {\n\t\tbip->bli_recur--;\n\t\treturn;\n\t}\n\n\t/*\n\t * If the buffer is dirty within this transaction, we can't\n\t * release it until we commit.\n\t */\n\tif (bip->bli_item.li_desc->lid_flags & XFS_LID_DIRTY)\n\t\treturn;\n\n\t/*\n\t * If the buffer has been invalidated, then we can't release\n\t * it until the transaction commits to disk unless it is re-dirtied\n\t * as part of this transaction.  This prevents us from pulling\n\t * the item from the AIL before we should.\n\t */\n\tif (bip->bli_flags & XFS_BLI_STALE)\n\t\treturn;\n\n\tASSERT(!(bip->bli_flags & XFS_BLI_LOGGED));\n\n\t/*\n\t * Free up the log item descriptor tracking the released item.\n\t */\n\txfs_trans_del_item(&bip->bli_item);\n\n\t/*\n\t * Clear the hold flag in the buf log item if it is set.\n\t * We wouldn't want the next user of the buffer to\n\t * get confused.\n\t */\n\tif (bip->bli_flags & XFS_BLI_HOLD) {\n\t\tbip->bli_flags &= ~XFS_BLI_HOLD;\n\t}\n\n\t/*\n\t * Drop our reference to the buf log item.\n\t */\n\tatomic_dec(&bip->bli_refcount);\n\n\t/*\n\t * If the buf item is not tracking data in the log, then\n\t * we must free it before releasing the buffer back to the\n\t * free pool.  Before releasing the buffer to the free pool,\n\t * clear the transaction pointer in b_fsprivate2 to dissolve\n\t * its relation to this transaction.\n\t */\n\tif (!xfs_buf_item_dirty(bip)) {\n/***\n\t\tASSERT(bp->b_pincount == 0);\n***/\n\t\tASSERT(atomic_read(&bip->bli_refcount) == 0);\n\t\tASSERT(!(bip->bli_item.li_flags & XFS_LI_IN_AIL));\n\t\tASSERT(!(bip->bli_flags & XFS_BLI_INODE_ALLOC_BUF));\n\t\txfs_buf_item_relse(bp);\n\t}\n\n\tbp->b_transp = NULL;\n\txfs_buf_relse(bp);\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_brelse(xfs_trans_t\t*tp,\n\t\t xfs_buf_t\t*bp)\n{\n\txfs_buf_log_item_t\t*bip;\n\n\t/*\n\t * Default to a normal brelse() call if the tp is NULL.\n\t */\n\tif (tp == NULL) {\n\t\tASSERT(bp->b_transp == NULL);\n\t\txfs_buf_relse(bp);\n\t\treturn;\n\t}\n\n\tASSERT(bp->b_transp == tp);\n\tbip = bp->b_fspriv;\n\tASSERT(bip->bli_item.li_type == XFS_LI_BUF);\n\tASSERT(!(bip->bli_flags & XFS_BLI_STALE));\n\tASSERT(!(bip->__bli_format.blf_flags & XFS_BLF_CANCEL));\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\n\ttrace_xfs_trans_brelse(bip);\n\n\t/*\n\t * If the release is just for a recursive lock,\n\t * then decrement the count and return.\n\t */\n\tif (bip->bli_recur > 0) {\n\t\tbip->bli_recur--;\n\t\treturn;\n\t}\n\n\t/*\n\t * If the buffer is dirty within this transaction, we can't\n\t * release it until we commit.\n\t */\n\tif (bip->bli_item.li_desc->lid_flags & XFS_LID_DIRTY)\n\t\treturn;\n\n\t/*\n\t * If the buffer has been invalidated, then we can't release\n\t * it until the transaction commits to disk unless it is re-dirtied\n\t * as part of this transaction.  This prevents us from pulling\n\t * the item from the AIL before we should.\n\t */\n\tif (bip->bli_flags & XFS_BLI_STALE)\n\t\treturn;\n\n\tASSERT(!(bip->bli_flags & XFS_BLI_LOGGED));\n\n\t/*\n\t * Free up the log item descriptor tracking the released item.\n\t */\n\txfs_trans_del_item(&bip->bli_item);\n\n\t/*\n\t * Clear the hold flag in the buf log item if it is set.\n\t * We wouldn't want the next user of the buffer to\n\t * get confused.\n\t */\n\tif (bip->bli_flags & XFS_BLI_HOLD) {\n\t\tbip->bli_flags &= ~XFS_BLI_HOLD;\n\t}\n\n\t/*\n\t * Drop our reference to the buf log item.\n\t */\n\tatomic_dec(&bip->bli_refcount);\n\n\t/*\n\t * If the buf item is not tracking data in the log, then\n\t * we must free it before releasing the buffer back to the\n\t * free pool.  Before releasing the buffer to the free pool,\n\t * clear the transaction pointer in b_fsprivate2 to dissolve\n\t * its relation to this transaction.\n\t */\n\tif (!xfs_buf_item_dirty(bip)) {\n/***\n\t\tASSERT(bp->b_pincount == 0);\n***/\n\t\tASSERT(atomic_read(&bip->bli_refcount) == 0);\n\t\tASSERT(!(bip->bli_item.li_flags & XFS_LI_IN_AIL));\n\t\tASSERT(!(bip->bli_flags & XFS_BLI_INODE_ALLOC_BUF));\n\t\txfs_buf_item_relse(bp);\n\t}\n\n\tbp->b_transp = NULL;\n\txfs_buf_relse(bp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dqcheck",
          "args": [
            "mp",
            "ddq",
            "firstid + i",
            "dqp->dq_flags & XFS_DQ_ALLTYPES",
            "XFS_QMOPT_DQREPAIR",
            "\"xfs_qm_dqrepair\""
          ],
          "line": 437
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dqcheck",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dquot_buf.c",
          "lines": "50-172",
          "snippet": "int\nxfs_dqcheck(\n\tstruct xfs_mount *mp,\n\txfs_disk_dquot_t *ddq,\n\txfs_dqid_t\t id,\n\tuint\t\t type,\t  /* used only when IO_dorepair is true */\n\tuint\t\t flags,\n\tchar\t\t *str)\n{\n\txfs_dqblk_t\t *d = (xfs_dqblk_t *)ddq;\n\tint\t\terrs = 0;\n\n\t/*\n\t * We can encounter an uninitialized dquot buffer for 2 reasons:\n\t * 1. If we crash while deleting the quotainode(s), and those blks got\n\t *    used for user data. This is because we take the path of regular\n\t *    file deletion; however, the size field of quotainodes is never\n\t *    updated, so all the tricks that we play in itruncate_finish\n\t *    don't quite matter.\n\t *\n\t * 2. We don't play the quota buffers when there's a quotaoff logitem.\n\t *    But the allocation will be replayed so we'll end up with an\n\t *    uninitialized quota block.\n\t *\n\t * This is all fine; things are still consistent, and we haven't lost\n\t * any quota information. Just don't complain about bad dquot blks.\n\t */\n\tif (ddq->d_magic != cpu_to_be16(XFS_DQUOT_MAGIC)) {\n\t\tif (flags & XFS_QMOPT_DOWARN)\n\t\t\txfs_alert(mp,\n\t\t\t\"%s : XFS dquot ID 0x%x, magic 0x%x != 0x%x\",\n\t\t\tstr, id, be16_to_cpu(ddq->d_magic), XFS_DQUOT_MAGIC);\n\t\terrs++;\n\t}\n\tif (ddq->d_version != XFS_DQUOT_VERSION) {\n\t\tif (flags & XFS_QMOPT_DOWARN)\n\t\t\txfs_alert(mp,\n\t\t\t\"%s : XFS dquot ID 0x%x, version 0x%x != 0x%x\",\n\t\t\tstr, id, ddq->d_version, XFS_DQUOT_VERSION);\n\t\terrs++;\n\t}\n\n\tif (ddq->d_flags != XFS_DQ_USER &&\n\t    ddq->d_flags != XFS_DQ_PROJ &&\n\t    ddq->d_flags != XFS_DQ_GROUP) {\n\t\tif (flags & XFS_QMOPT_DOWARN)\n\t\t\txfs_alert(mp,\n\t\t\t\"%s : XFS dquot ID 0x%x, unknown flags 0x%x\",\n\t\t\tstr, id, ddq->d_flags);\n\t\terrs++;\n\t}\n\n\tif (id != -1 && id != be32_to_cpu(ddq->d_id)) {\n\t\tif (flags & XFS_QMOPT_DOWARN)\n\t\t\txfs_alert(mp,\n\t\t\t\"%s : ondisk-dquot 0x%p, ID mismatch: \"\n\t\t\t\"0x%x expected, found id 0x%x\",\n\t\t\tstr, ddq, id, be32_to_cpu(ddq->d_id));\n\t\terrs++;\n\t}\n\n\tif (!errs && ddq->d_id) {\n\t\tif (ddq->d_blk_softlimit &&\n\t\t    be64_to_cpu(ddq->d_bcount) >\n\t\t\t\tbe64_to_cpu(ddq->d_blk_softlimit)) {\n\t\t\tif (!ddq->d_btimer) {\n\t\t\t\tif (flags & XFS_QMOPT_DOWARN)\n\t\t\t\t\txfs_alert(mp,\n\t\t\t\"%s : Dquot ID 0x%x (0x%p) BLK TIMER NOT STARTED\",\n\t\t\t\t\tstr, (int)be32_to_cpu(ddq->d_id), ddq);\n\t\t\t\terrs++;\n\t\t\t}\n\t\t}\n\t\tif (ddq->d_ino_softlimit &&\n\t\t    be64_to_cpu(ddq->d_icount) >\n\t\t\t\tbe64_to_cpu(ddq->d_ino_softlimit)) {\n\t\t\tif (!ddq->d_itimer) {\n\t\t\t\tif (flags & XFS_QMOPT_DOWARN)\n\t\t\t\t\txfs_alert(mp,\n\t\t\t\"%s : Dquot ID 0x%x (0x%p) INODE TIMER NOT STARTED\",\n\t\t\t\t\tstr, (int)be32_to_cpu(ddq->d_id), ddq);\n\t\t\t\terrs++;\n\t\t\t}\n\t\t}\n\t\tif (ddq->d_rtb_softlimit &&\n\t\t    be64_to_cpu(ddq->d_rtbcount) >\n\t\t\t\tbe64_to_cpu(ddq->d_rtb_softlimit)) {\n\t\t\tif (!ddq->d_rtbtimer) {\n\t\t\t\tif (flags & XFS_QMOPT_DOWARN)\n\t\t\t\t\txfs_alert(mp,\n\t\t\t\"%s : Dquot ID 0x%x (0x%p) RTBLK TIMER NOT STARTED\",\n\t\t\t\t\tstr, (int)be32_to_cpu(ddq->d_id), ddq);\n\t\t\t\terrs++;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!errs || !(flags & XFS_QMOPT_DQREPAIR))\n\t\treturn errs;\n\n\tif (flags & XFS_QMOPT_DOWARN)\n\t\txfs_notice(mp, \"Re-initializing dquot ID 0x%x\", id);\n\n\t/*\n\t * Typically, a repair is only requested by quotacheck.\n\t */\n\tASSERT(id != -1);\n\tASSERT(flags & XFS_QMOPT_DQREPAIR);\n\tmemset(d, 0, sizeof(xfs_dqblk_t));\n\n\td->dd_diskdq.d_magic = cpu_to_be16(XFS_DQUOT_MAGIC);\n\td->dd_diskdq.d_version = XFS_DQUOT_VERSION;\n\td->dd_diskdq.d_flags = type;\n\td->dd_diskdq.d_id = cpu_to_be32(id);\n\n\tif (xfs_sb_version_hascrc(&mp->m_sb)) {\n\t\tuuid_copy(&d->dd_uuid, &mp->m_sb.sb_uuid);\n\t\txfs_update_cksum((char *)d, sizeof(struct xfs_dqblk),\n\t\t\t\t XFS_DQUOT_CRC_OFF);\n\t}\n\n\treturn errs;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_qm.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_error.h\"\n#include \"xfs_qm.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_dqcheck(\n\tstruct xfs_mount *mp,\n\txfs_disk_dquot_t *ddq,\n\txfs_dqid_t\t id,\n\tuint\t\t type,\t  /* used only when IO_dorepair is true */\n\tuint\t\t flags,\n\tchar\t\t *str)\n{\n\txfs_dqblk_t\t *d = (xfs_dqblk_t *)ddq;\n\tint\t\terrs = 0;\n\n\t/*\n\t * We can encounter an uninitialized dquot buffer for 2 reasons:\n\t * 1. If we crash while deleting the quotainode(s), and those blks got\n\t *    used for user data. This is because we take the path of regular\n\t *    file deletion; however, the size field of quotainodes is never\n\t *    updated, so all the tricks that we play in itruncate_finish\n\t *    don't quite matter.\n\t *\n\t * 2. We don't play the quota buffers when there's a quotaoff logitem.\n\t *    But the allocation will be replayed so we'll end up with an\n\t *    uninitialized quota block.\n\t *\n\t * This is all fine; things are still consistent, and we haven't lost\n\t * any quota information. Just don't complain about bad dquot blks.\n\t */\n\tif (ddq->d_magic != cpu_to_be16(XFS_DQUOT_MAGIC)) {\n\t\tif (flags & XFS_QMOPT_DOWARN)\n\t\t\txfs_alert(mp,\n\t\t\t\"%s : XFS dquot ID 0x%x, magic 0x%x != 0x%x\",\n\t\t\tstr, id, be16_to_cpu(ddq->d_magic), XFS_DQUOT_MAGIC);\n\t\terrs++;\n\t}\n\tif (ddq->d_version != XFS_DQUOT_VERSION) {\n\t\tif (flags & XFS_QMOPT_DOWARN)\n\t\t\txfs_alert(mp,\n\t\t\t\"%s : XFS dquot ID 0x%x, version 0x%x != 0x%x\",\n\t\t\tstr, id, ddq->d_version, XFS_DQUOT_VERSION);\n\t\terrs++;\n\t}\n\n\tif (ddq->d_flags != XFS_DQ_USER &&\n\t    ddq->d_flags != XFS_DQ_PROJ &&\n\t    ddq->d_flags != XFS_DQ_GROUP) {\n\t\tif (flags & XFS_QMOPT_DOWARN)\n\t\t\txfs_alert(mp,\n\t\t\t\"%s : XFS dquot ID 0x%x, unknown flags 0x%x\",\n\t\t\tstr, id, ddq->d_flags);\n\t\terrs++;\n\t}\n\n\tif (id != -1 && id != be32_to_cpu(ddq->d_id)) {\n\t\tif (flags & XFS_QMOPT_DOWARN)\n\t\t\txfs_alert(mp,\n\t\t\t\"%s : ondisk-dquot 0x%p, ID mismatch: \"\n\t\t\t\"0x%x expected, found id 0x%x\",\n\t\t\tstr, ddq, id, be32_to_cpu(ddq->d_id));\n\t\terrs++;\n\t}\n\n\tif (!errs && ddq->d_id) {\n\t\tif (ddq->d_blk_softlimit &&\n\t\t    be64_to_cpu(ddq->d_bcount) >\n\t\t\t\tbe64_to_cpu(ddq->d_blk_softlimit)) {\n\t\t\tif (!ddq->d_btimer) {\n\t\t\t\tif (flags & XFS_QMOPT_DOWARN)\n\t\t\t\t\txfs_alert(mp,\n\t\t\t\"%s : Dquot ID 0x%x (0x%p) BLK TIMER NOT STARTED\",\n\t\t\t\t\tstr, (int)be32_to_cpu(ddq->d_id), ddq);\n\t\t\t\terrs++;\n\t\t\t}\n\t\t}\n\t\tif (ddq->d_ino_softlimit &&\n\t\t    be64_to_cpu(ddq->d_icount) >\n\t\t\t\tbe64_to_cpu(ddq->d_ino_softlimit)) {\n\t\t\tif (!ddq->d_itimer) {\n\t\t\t\tif (flags & XFS_QMOPT_DOWARN)\n\t\t\t\t\txfs_alert(mp,\n\t\t\t\"%s : Dquot ID 0x%x (0x%p) INODE TIMER NOT STARTED\",\n\t\t\t\t\tstr, (int)be32_to_cpu(ddq->d_id), ddq);\n\t\t\t\terrs++;\n\t\t\t}\n\t\t}\n\t\tif (ddq->d_rtb_softlimit &&\n\t\t    be64_to_cpu(ddq->d_rtbcount) >\n\t\t\t\tbe64_to_cpu(ddq->d_rtb_softlimit)) {\n\t\t\tif (!ddq->d_rtbtimer) {\n\t\t\t\tif (flags & XFS_QMOPT_DOWARN)\n\t\t\t\t\txfs_alert(mp,\n\t\t\t\"%s : Dquot ID 0x%x (0x%p) RTBLK TIMER NOT STARTED\",\n\t\t\t\t\tstr, (int)be32_to_cpu(ddq->d_id), ddq);\n\t\t\t\terrs++;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!errs || !(flags & XFS_QMOPT_DQREPAIR))\n\t\treturn errs;\n\n\tif (flags & XFS_QMOPT_DOWARN)\n\t\txfs_notice(mp, \"Re-initializing dquot ID 0x%x\", id);\n\n\t/*\n\t * Typically, a repair is only requested by quotacheck.\n\t */\n\tASSERT(id != -1);\n\tASSERT(flags & XFS_QMOPT_DQREPAIR);\n\tmemset(d, 0, sizeof(xfs_dqblk_t));\n\n\td->dd_diskdq.d_magic = cpu_to_be16(XFS_DQUOT_MAGIC);\n\td->dd_diskdq.d_version = XFS_DQUOT_VERSION;\n\td->dd_diskdq.d_flags = type;\n\td->dd_diskdq.d_id = cpu_to_be32(id);\n\n\tif (xfs_sb_version_hascrc(&mp->m_sb)) {\n\t\tuuid_copy(&d->dd_uuid, &mp->m_sb.sb_uuid);\n\t\txfs_update_cksum((char *)d, sizeof(struct xfs_dqblk),\n\t\t\t\t XFS_DQUOT_CRC_OFF);\n\t}\n\n\treturn errs;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "xfs_buf_islocked(*bpp)"
          ],
          "line": 431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_buf_islocked",
          "args": [
            "*bpp"
          ],
          "line": 431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "*bpp == NULL"
          ],
          "line": 426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_trans_read_buf",
          "args": [
            "mp",
            "tp",
            "mp->m_ddev_targp",
            "dqp->q_blkno",
            "mp->m_quotainfo->qi_dqchunklen",
            "0",
            "bpp",
            "NULL"
          ],
          "line": 421
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_read_buf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.h",
          "lines": "186-200",
          "snippet": "static inline int\nxfs_trans_read_buf(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_buftarg\t*target,\n\txfs_daddr_t\t\tblkno,\n\tint\t\t\tnumblks,\n\txfs_buf_flags_t\t\tflags,\n\tstruct xfs_buf\t\t**bpp,\n\tconst struct xfs_buf_ops *ops)\n{\n\tDEFINE_SINGLE_BUF_MAP(map, blkno, numblks);\n\treturn xfs_trans_read_buf_map(mp, tp, target, &map, 1,\n\t\t\t\t      flags, bpp, ops);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int\nxfs_trans_read_buf(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_buftarg\t*target,\n\txfs_daddr_t\t\tblkno,\n\tint\t\t\tnumblks,\n\txfs_buf_flags_t\t\tflags,\n\tstruct xfs_buf\t\t**bpp,\n\tconst struct xfs_buf_ops *ops)\n{\n\tDEFINE_SINGLE_BUF_MAP(map, blkno, numblks);\n\treturn xfs_trans_read_buf_map(mp, tp, target, &map, 1,\n\t\t\t\t      flags, bpp, ops);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_qm.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxfs_qm_dqrepair(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_dquot\t*dqp,\n\txfs_dqid_t\t\tfirstid,\n\tstruct xfs_buf\t\t**bpp)\n{\n\tint\t\t\terror;\n\tstruct xfs_disk_dquot\t*ddq;\n\tstruct xfs_dqblk\t*d;\n\tint\t\t\ti;\n\n\t/*\n\t * Read the buffer without verification so we get the corrupted\n\t * buffer returned to us. make sure we verify it on write, though.\n\t */\n\terror = xfs_trans_read_buf(mp, tp, mp->m_ddev_targp, dqp->q_blkno,\n\t\t\t\t   mp->m_quotainfo->qi_dqchunklen,\n\t\t\t\t   0, bpp, NULL);\n\n\tif (error) {\n\t\tASSERT(*bpp == NULL);\n\t\treturn error;\n\t}\n\t(*bpp)->b_ops = &xfs_dquot_buf_ops;\n\n\tASSERT(xfs_buf_islocked(*bpp));\n\td = (struct xfs_dqblk *)(*bpp)->b_addr;\n\n\t/* Do the actual repair of dquots in this buffer */\n\tfor (i = 0; i < mp->m_quotainfo->qi_dqperchunk; i++) {\n\t\tddq = &d[i].dd_diskdq;\n\t\terror = xfs_dqcheck(mp, ddq, firstid + i,\n\t\t\t\t       dqp->dq_flags & XFS_DQ_ALLTYPES,\n\t\t\t\t       XFS_QMOPT_DQREPAIR, \"xfs_qm_dqrepair\");\n\t\tif (error) {\n\t\t\t/* repair failed, we're screwed */\n\t\t\txfs_trans_brelse(tp, *bpp);\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_qm_dqalloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_dquot.c",
    "lines": "297-402",
    "snippet": "STATIC int\nxfs_qm_dqalloc(\n\txfs_trans_t\t**tpp,\n\txfs_mount_t\t*mp,\n\txfs_dquot_t\t*dqp,\n\txfs_inode_t\t*quotip,\n\txfs_fileoff_t\toffset_fsb,\n\txfs_buf_t\t**O_bpp)\n{\n\txfs_fsblock_t\tfirstblock;\n\txfs_bmap_free_t flist;\n\txfs_bmbt_irec_t map;\n\tint\t\tnmaps, error, committed;\n\txfs_buf_t\t*bp;\n\txfs_trans_t\t*tp = *tpp;\n\n\tASSERT(tp != NULL);\n\n\ttrace_xfs_dqalloc(dqp);\n\n\t/*\n\t * Initialize the bmap freelist prior to calling bmapi code.\n\t */\n\txfs_bmap_init(&flist, &firstblock);\n\txfs_ilock(quotip, XFS_ILOCK_EXCL);\n\t/*\n\t * Return if this type of quotas is turned off while we didn't\n\t * have an inode lock\n\t */\n\tif (!xfs_this_quota_on(dqp->q_mount, dqp->dq_flags)) {\n\t\txfs_iunlock(quotip, XFS_ILOCK_EXCL);\n\t\treturn -ESRCH;\n\t}\n\n\txfs_trans_ijoin(tp, quotip, XFS_ILOCK_EXCL);\n\tnmaps = 1;\n\terror = xfs_bmapi_write(tp, quotip, offset_fsb,\n\t\t\t\tXFS_DQUOT_CLUSTER_SIZE_FSB, XFS_BMAPI_METADATA,\n\t\t\t\t&firstblock, XFS_QM_DQALLOC_SPACE_RES(mp),\n\t\t\t\t&map, &nmaps, &flist);\n\tif (error)\n\t\tgoto error0;\n\tASSERT(map.br_blockcount == XFS_DQUOT_CLUSTER_SIZE_FSB);\n\tASSERT(nmaps == 1);\n\tASSERT((map.br_startblock != DELAYSTARTBLOCK) &&\n\t       (map.br_startblock != HOLESTARTBLOCK));\n\n\t/*\n\t * Keep track of the blkno to save a lookup later\n\t */\n\tdqp->q_blkno = XFS_FSB_TO_DADDR(mp, map.br_startblock);\n\n\t/* now we can just get the buffer (there's nothing to read yet) */\n\tbp = xfs_trans_get_buf(tp, mp->m_ddev_targp,\n\t\t\t       dqp->q_blkno,\n\t\t\t       mp->m_quotainfo->qi_dqchunklen,\n\t\t\t       0);\n\tif (!bp) {\n\t\terror = -ENOMEM;\n\t\tgoto error1;\n\t}\n\tbp->b_ops = &xfs_dquot_buf_ops;\n\n\t/*\n\t * Make a chunk of dquots out of this buffer and log\n\t * the entire thing.\n\t */\n\txfs_qm_init_dquot_blk(tp, mp, be32_to_cpu(dqp->q_core.d_id),\n\t\t\t      dqp->dq_flags & XFS_DQ_ALLTYPES, bp);\n\n\t/*\n\t * xfs_bmap_finish() may commit the current transaction and\n\t * start a second transaction if the freelist is not empty.\n\t *\n\t * Since we still want to modify this buffer, we need to\n\t * ensure that the buffer is not released on commit of\n\t * the first transaction and ensure the buffer is added to the\n\t * second transaction.\n\t *\n\t * If there is only one transaction then don't stop the buffer\n\t * from being released when it commits later on.\n\t */\n\n\txfs_trans_bhold(tp, bp);\n\n\tif ((error = xfs_bmap_finish(tpp, &flist, &committed))) {\n\t\tgoto error1;\n\t}\n\n\tif (committed) {\n\t\ttp = *tpp;\n\t\txfs_trans_bjoin(tp, bp);\n\t} else {\n\t\txfs_trans_bhold_release(tp, bp);\n\t}\n\n\t*O_bpp = bp;\n\treturn 0;\n\n      error1:\n\txfs_bmap_cancel(&flist);\n      error0:\n\txfs_iunlock(quotip, XFS_ILOCK_EXCL);\n\n\treturn error;\n}",
    "includes": [
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_qm.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_iunlock",
          "args": [
            "quotip",
            "XFS_ILOCK_EXCL"
          ],
          "line": 399
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_iunlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
          "lines": "235-263",
          "snippet": "void\nxfs_iunlock(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\t/*\n\t * You can't set both SHARED and EXCL for the same lock,\n\t * and only XFS_IOLOCK_SHARED, XFS_IOLOCK_EXCL, XFS_ILOCK_SHARED,\n\t * and XFS_ILOCK_EXCL are valid values to set in lock_flags.\n\t */\n\tASSERT((lock_flags & (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL)) !=\n\t       (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL));\n\tASSERT((lock_flags & (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL)) !=\n\t       (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_LOCK_MASK | XFS_LOCK_DEP_MASK)) == 0);\n\tASSERT(lock_flags != 0);\n\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_iolock);\n\telse if (lock_flags & XFS_IOLOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_iolock);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_lock);\n\telse if (lock_flags & XFS_ILOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_lock);\n\n\ttrace_xfs_iunlock(ip, lock_flags, _RET_IP_);\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);\n\nvoid\nxfs_iunlock(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\t/*\n\t * You can't set both SHARED and EXCL for the same lock,\n\t * and only XFS_IOLOCK_SHARED, XFS_IOLOCK_EXCL, XFS_ILOCK_SHARED,\n\t * and XFS_ILOCK_EXCL are valid values to set in lock_flags.\n\t */\n\tASSERT((lock_flags & (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL)) !=\n\t       (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL));\n\tASSERT((lock_flags & (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL)) !=\n\t       (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_LOCK_MASK | XFS_LOCK_DEP_MASK)) == 0);\n\tASSERT(lock_flags != 0);\n\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_iolock);\n\telse if (lock_flags & XFS_IOLOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_iolock);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_lock);\n\telse if (lock_flags & XFS_ILOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_lock);\n\n\ttrace_xfs_iunlock(ip, lock_flags, _RET_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_bmap_cancel",
          "args": [
            "&flist"
          ],
          "line": 397
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmap_cancel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.c",
          "lines": "658-673",
          "snippet": "void\nxfs_bmap_cancel(\n\txfs_bmap_free_t\t\t*flist)\t/* list of bmap_free_items */\n{\n\txfs_bmap_free_item_t\t*free;\t/* free list item */\n\txfs_bmap_free_item_t\t*next;\n\n\tif (flist->xbf_count == 0)\n\t\treturn;\n\tASSERT(flist->xbf_first != NULL);\n\tfor (free = flist->xbf_first; free; free = next) {\n\t\tnext = free->xbfi_next;\n\t\txfs_bmap_del_free(flist, NULL, free);\n\t}\n\tASSERT(flist->xbf_count == 0);\n}",
          "includes": [
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_bmap_cancel(\n\txfs_bmap_free_t\t\t*flist)\t/* list of bmap_free_items */\n{\n\txfs_bmap_free_item_t\t*free;\t/* free list item */\n\txfs_bmap_free_item_t\t*next;\n\n\tif (flist->xbf_count == 0)\n\t\treturn;\n\tASSERT(flist->xbf_first != NULL);\n\tfor (free = flist->xbf_first; free; free = next) {\n\t\tnext = free->xbfi_next;\n\t\txfs_bmap_del_free(flist, NULL, free);\n\t}\n\tASSERT(flist->xbf_count == 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_bhold_release",
          "args": [
            "tp",
            "bp"
          ],
          "line": 390
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_bhold_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_buf.c",
          "lines": "471-486",
          "snippet": "void\nxfs_trans_bhold_release(xfs_trans_t\t*tp,\n\t\t\txfs_buf_t\t*bp)\n{\n\txfs_buf_log_item_t\t*bip = bp->b_fspriv;\n\n\tASSERT(bp->b_transp == tp);\n\tASSERT(bip != NULL);\n\tASSERT(!(bip->bli_flags & XFS_BLI_STALE));\n\tASSERT(!(bip->__bli_format.blf_flags & XFS_BLF_CANCEL));\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\tASSERT(bip->bli_flags & XFS_BLI_HOLD);\n\n\tbip->bli_flags &= ~XFS_BLI_HOLD;\n\ttrace_xfs_trans_bhold_release(bip);\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_bhold_release(xfs_trans_t\t*tp,\n\t\t\txfs_buf_t\t*bp)\n{\n\txfs_buf_log_item_t\t*bip = bp->b_fspriv;\n\n\tASSERT(bp->b_transp == tp);\n\tASSERT(bip != NULL);\n\tASSERT(!(bip->bli_flags & XFS_BLI_STALE));\n\tASSERT(!(bip->__bli_format.blf_flags & XFS_BLF_CANCEL));\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\tASSERT(bip->bli_flags & XFS_BLI_HOLD);\n\n\tbip->bli_flags &= ~XFS_BLI_HOLD;\n\ttrace_xfs_trans_bhold_release(bip);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_bjoin",
          "args": [
            "tp",
            "bp"
          ],
          "line": 388
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_bjoin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_buf.c",
          "lines": "115-122",
          "snippet": "void\nxfs_trans_bjoin(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_buf\t\t*bp)\n{\n\t_xfs_trans_bjoin(tp, bp, 0);\n\ttrace_xfs_trans_bjoin(bp->b_fspriv);\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nvoid\nxfs_trans_bjoin(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_buf\t\t*bp)\n{\n\t_xfs_trans_bjoin(tp, bp, 0);\n\ttrace_xfs_trans_bjoin(bp->b_fspriv);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_bmap_finish",
          "args": [
            "tpp",
            "&flist",
            "&committed"
          ],
          "line": 382
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmap_finish",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_bmap_util.c",
          "lines": "68-143",
          "snippet": "int\t\t\t\t\t\t/* error */\nxfs_bmap_finish(\n\txfs_trans_t\t\t**tp,\t\t/* transaction pointer addr */\n\txfs_bmap_free_t\t\t*flist,\t\t/* i/o: list extents to free */\n\tint\t\t\t*committed)\t/* xact committed or not */\n{\n\txfs_efd_log_item_t\t*efd;\t\t/* extent free data */\n\txfs_efi_log_item_t\t*efi;\t\t/* extent free intention */\n\tint\t\t\terror;\t\t/* error return value */\n\txfs_bmap_free_item_t\t*free;\t\t/* free extent item */\n\tstruct xfs_trans_res\ttres;\t\t/* new log reservation */\n\txfs_mount_t\t\t*mp;\t\t/* filesystem mount structure */\n\txfs_bmap_free_item_t\t*next;\t\t/* next item on free list */\n\txfs_trans_t\t\t*ntp;\t\t/* new transaction pointer */\n\n\tASSERT((*tp)->t_flags & XFS_TRANS_PERM_LOG_RES);\n\tif (flist->xbf_count == 0) {\n\t\t*committed = 0;\n\t\treturn 0;\n\t}\n\tntp = *tp;\n\tefi = xfs_trans_get_efi(ntp, flist->xbf_count);\n\tfor (free = flist->xbf_first; free; free = free->xbfi_next)\n\t\txfs_trans_log_efi_extent(ntp, efi, free->xbfi_startblock,\n\t\t\tfree->xbfi_blockcount);\n\n\ttres.tr_logres = ntp->t_log_res;\n\ttres.tr_logcount = ntp->t_log_count;\n\ttres.tr_logflags = XFS_TRANS_PERM_LOG_RES;\n\tntp = xfs_trans_dup(*tp);\n\terror = xfs_trans_commit(*tp, 0);\n\t*tp = ntp;\n\t*committed = 1;\n\t/*\n\t * We have a new transaction, so we should return committed=1,\n\t * even though we're returning an error.\n\t */\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * transaction commit worked ok so we can drop the extra ticket\n\t * reference that we gained in xfs_trans_dup()\n\t */\n\txfs_log_ticket_put(ntp->t_ticket);\n\n\terror = xfs_trans_reserve(ntp, &tres, 0, 0);\n\tif (error)\n\t\treturn error;\n\tefd = xfs_trans_get_efd(ntp, efi, flist->xbf_count);\n\tfor (free = flist->xbf_first; free != NULL; free = next) {\n\t\tnext = free->xbfi_next;\n\t\tif ((error = xfs_free_extent(ntp, free->xbfi_startblock,\n\t\t\t\tfree->xbfi_blockcount))) {\n\t\t\t/*\n\t\t\t * The bmap free list will be cleaned up at a\n\t\t\t * higher level.  The EFI will be canceled when\n\t\t\t * this transaction is aborted.\n\t\t\t * Need to force shutdown here to make sure it\n\t\t\t * happens, since this transaction may not be\n\t\t\t * dirty yet.\n\t\t\t */\n\t\t\tmp = ntp->t_mountp;\n\t\t\tif (!XFS_FORCED_SHUTDOWN(mp))\n\t\t\t\txfs_force_shutdown(mp,\n\t\t\t\t\t\t   (error == -EFSCORRUPTED) ?\n\t\t\t\t\t\t   SHUTDOWN_CORRUPT_INCORE :\n\t\t\t\t\t\t   SHUTDOWN_META_IO_ERROR);\n\t\t\treturn error;\n\t\t}\n\t\txfs_trans_log_efd_extent(ntp, efd, free->xbfi_startblock,\n\t\t\tfree->xbfi_blockcount);\n\t\txfs_bmap_del_free(flist, NULL, free);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\t\t\t\t\t\t/* error */\nxfs_bmap_finish(\n\txfs_trans_t\t\t**tp,\t\t/* transaction pointer addr */\n\txfs_bmap_free_t\t\t*flist,\t\t/* i/o: list extents to free */\n\tint\t\t\t*committed)\t/* xact committed or not */\n{\n\txfs_efd_log_item_t\t*efd;\t\t/* extent free data */\n\txfs_efi_log_item_t\t*efi;\t\t/* extent free intention */\n\tint\t\t\terror;\t\t/* error return value */\n\txfs_bmap_free_item_t\t*free;\t\t/* free extent item */\n\tstruct xfs_trans_res\ttres;\t\t/* new log reservation */\n\txfs_mount_t\t\t*mp;\t\t/* filesystem mount structure */\n\txfs_bmap_free_item_t\t*next;\t\t/* next item on free list */\n\txfs_trans_t\t\t*ntp;\t\t/* new transaction pointer */\n\n\tASSERT((*tp)->t_flags & XFS_TRANS_PERM_LOG_RES);\n\tif (flist->xbf_count == 0) {\n\t\t*committed = 0;\n\t\treturn 0;\n\t}\n\tntp = *tp;\n\tefi = xfs_trans_get_efi(ntp, flist->xbf_count);\n\tfor (free = flist->xbf_first; free; free = free->xbfi_next)\n\t\txfs_trans_log_efi_extent(ntp, efi, free->xbfi_startblock,\n\t\t\tfree->xbfi_blockcount);\n\n\ttres.tr_logres = ntp->t_log_res;\n\ttres.tr_logcount = ntp->t_log_count;\n\ttres.tr_logflags = XFS_TRANS_PERM_LOG_RES;\n\tntp = xfs_trans_dup(*tp);\n\terror = xfs_trans_commit(*tp, 0);\n\t*tp = ntp;\n\t*committed = 1;\n\t/*\n\t * We have a new transaction, so we should return committed=1,\n\t * even though we're returning an error.\n\t */\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * transaction commit worked ok so we can drop the extra ticket\n\t * reference that we gained in xfs_trans_dup()\n\t */\n\txfs_log_ticket_put(ntp->t_ticket);\n\n\terror = xfs_trans_reserve(ntp, &tres, 0, 0);\n\tif (error)\n\t\treturn error;\n\tefd = xfs_trans_get_efd(ntp, efi, flist->xbf_count);\n\tfor (free = flist->xbf_first; free != NULL; free = next) {\n\t\tnext = free->xbfi_next;\n\t\tif ((error = xfs_free_extent(ntp, free->xbfi_startblock,\n\t\t\t\tfree->xbfi_blockcount))) {\n\t\t\t/*\n\t\t\t * The bmap free list will be cleaned up at a\n\t\t\t * higher level.  The EFI will be canceled when\n\t\t\t * this transaction is aborted.\n\t\t\t * Need to force shutdown here to make sure it\n\t\t\t * happens, since this transaction may not be\n\t\t\t * dirty yet.\n\t\t\t */\n\t\t\tmp = ntp->t_mountp;\n\t\t\tif (!XFS_FORCED_SHUTDOWN(mp))\n\t\t\t\txfs_force_shutdown(mp,\n\t\t\t\t\t\t   (error == -EFSCORRUPTED) ?\n\t\t\t\t\t\t   SHUTDOWN_CORRUPT_INCORE :\n\t\t\t\t\t\t   SHUTDOWN_META_IO_ERROR);\n\t\t\treturn error;\n\t\t}\n\t\txfs_trans_log_efd_extent(ntp, efd, free->xbfi_startblock,\n\t\t\tfree->xbfi_blockcount);\n\t\txfs_bmap_del_free(flist, NULL, free);\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_qm_init_dquot_blk",
          "args": [
            "tp",
            "mp",
            "be32_to_cpu(dqp->q_core.d_id)",
            "dqp->dq_flags & XFS_DQ_ALLTYPES",
            "bp"
          ],
          "line": 364
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_qm_init_dquot_blk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_dquot.c",
          "lines": "225-265",
          "snippet": "STATIC void\nxfs_qm_init_dquot_blk(\n\txfs_trans_t\t*tp,\n\txfs_mount_t\t*mp,\n\txfs_dqid_t\tid,\n\tuint\t\ttype,\n\txfs_buf_t\t*bp)\n{\n\tstruct xfs_quotainfo\t*q = mp->m_quotainfo;\n\txfs_dqblk_t\t*d;\n\tint\t\tcurid, i;\n\n\tASSERT(tp);\n\tASSERT(xfs_buf_islocked(bp));\n\n\td = bp->b_addr;\n\n\t/*\n\t * ID of the first dquot in the block - id's are zero based.\n\t */\n\tcurid = id - (id % q->qi_dqperchunk);\n\tASSERT(curid >= 0);\n\tmemset(d, 0, BBTOB(q->qi_dqchunklen));\n\tfor (i = 0; i < q->qi_dqperchunk; i++, d++, curid++) {\n\t\td->dd_diskdq.d_magic = cpu_to_be16(XFS_DQUOT_MAGIC);\n\t\td->dd_diskdq.d_version = XFS_DQUOT_VERSION;\n\t\td->dd_diskdq.d_id = cpu_to_be32(curid);\n\t\td->dd_diskdq.d_flags = type;\n\t\tif (xfs_sb_version_hascrc(&mp->m_sb)) {\n\t\t\tuuid_copy(&d->dd_uuid, &mp->m_sb.sb_uuid);\n\t\t\txfs_update_cksum((char *)d, sizeof(struct xfs_dqblk),\n\t\t\t\t\t XFS_DQUOT_CRC_OFF);\n\t\t}\n\t}\n\n\txfs_trans_dquot_buf(tp, bp,\n\t\t\t    (type & XFS_DQ_USER ? XFS_BLF_UDQUOT_BUF :\n\t\t\t    ((type & XFS_DQ_PROJ) ? XFS_BLF_PDQUOT_BUF :\n\t\t\t     XFS_BLF_GDQUOT_BUF)));\n\txfs_trans_log_buf(tp, bp, 0, BBTOB(q->qi_dqchunklen) - 1);\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_qm.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_qm.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\nxfs_qm_init_dquot_blk(\n\txfs_trans_t\t*tp,\n\txfs_mount_t\t*mp,\n\txfs_dqid_t\tid,\n\tuint\t\ttype,\n\txfs_buf_t\t*bp)\n{\n\tstruct xfs_quotainfo\t*q = mp->m_quotainfo;\n\txfs_dqblk_t\t*d;\n\tint\t\tcurid, i;\n\n\tASSERT(tp);\n\tASSERT(xfs_buf_islocked(bp));\n\n\td = bp->b_addr;\n\n\t/*\n\t * ID of the first dquot in the block - id's are zero based.\n\t */\n\tcurid = id - (id % q->qi_dqperchunk);\n\tASSERT(curid >= 0);\n\tmemset(d, 0, BBTOB(q->qi_dqchunklen));\n\tfor (i = 0; i < q->qi_dqperchunk; i++, d++, curid++) {\n\t\td->dd_diskdq.d_magic = cpu_to_be16(XFS_DQUOT_MAGIC);\n\t\td->dd_diskdq.d_version = XFS_DQUOT_VERSION;\n\t\td->dd_diskdq.d_id = cpu_to_be32(curid);\n\t\td->dd_diskdq.d_flags = type;\n\t\tif (xfs_sb_version_hascrc(&mp->m_sb)) {\n\t\t\tuuid_copy(&d->dd_uuid, &mp->m_sb.sb_uuid);\n\t\t\txfs_update_cksum((char *)d, sizeof(struct xfs_dqblk),\n\t\t\t\t\t XFS_DQUOT_CRC_OFF);\n\t\t}\n\t}\n\n\txfs_trans_dquot_buf(tp, bp,\n\t\t\t    (type & XFS_DQ_USER ? XFS_BLF_UDQUOT_BUF :\n\t\t\t    ((type & XFS_DQ_PROJ) ? XFS_BLF_PDQUOT_BUF :\n\t\t\t     XFS_BLF_GDQUOT_BUF)));\n\txfs_trans_log_buf(tp, bp, 0, BBTOB(q->qi_dqchunklen) - 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "dqp->q_core.d_id"
          ],
          "line": 364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_trans_get_buf",
          "args": [
            "tp",
            "mp->m_ddev_targp",
            "dqp->q_blkno",
            "mp->m_quotainfo->qi_dqchunklen",
            "0"
          ],
          "line": 350
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_get_buf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.h",
          "lines": "166-176",
          "snippet": "static inline struct xfs_buf *\nxfs_trans_get_buf(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_buftarg\t*target,\n\txfs_daddr_t\t\tblkno,\n\tint\t\t\tnumblks,\n\tuint\t\t\tflags)\n{\n\tDEFINE_SINGLE_BUF_MAP(map, blkno, numblks);\n\treturn xfs_trans_get_buf_map(tp, target, &map, 1, flags);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline struct xfs_buf *\nxfs_trans_get_buf(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_buftarg\t*target,\n\txfs_daddr_t\t\tblkno,\n\tint\t\t\tnumblks,\n\tuint\t\t\tflags)\n{\n\tDEFINE_SINGLE_BUF_MAP(map, blkno, numblks);\n\treturn xfs_trans_get_buf_map(tp, target, &map, 1, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_FSB_TO_DADDR",
          "args": [
            "mp",
            "map.br_startblock"
          ],
          "line": 347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "(map.br_startblock != DELAYSTARTBLOCK) &&\n\t       (map.br_startblock != HOLESTARTBLOCK)"
          ],
          "line": 341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "nmaps == 1"
          ],
          "line": 340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "map.br_blockcount == XFS_DQUOT_CLUSTER_SIZE_FSB"
          ],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_bmapi_write",
          "args": [
            "tp",
            "quotip",
            "offset_fsb",
            "XFS_DQUOT_CLUSTER_SIZE_FSB",
            "XFS_BMAPI_METADATA",
            "&firstblock",
            "XFS_QM_DQALLOC_SPACE_RES(mp)",
            "&map",
            "&nmaps",
            "&flist"
          ],
          "line": 333
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmapi_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.c",
          "lines": "4483-4700",
          "snippet": "int\nxfs_bmapi_write(\n\tstruct xfs_trans\t*tp,\t\t/* transaction pointer */\n\tstruct xfs_inode\t*ip,\t\t/* incore inode */\n\txfs_fileoff_t\t\tbno,\t\t/* starting file offs. mapped */\n\txfs_filblks_t\t\tlen,\t\t/* length to map in file */\n\tint\t\t\tflags,\t\t/* XFS_BMAPI_... */\n\txfs_fsblock_t\t\t*firstblock,\t/* first allocated block\n\t\t\t\t\t\t   controls a.g. for allocs */\n\txfs_extlen_t\t\ttotal,\t\t/* total blocks needed */\n\tstruct xfs_bmbt_irec\t*mval,\t\t/* output: map values */\n\tint\t\t\t*nmap,\t\t/* i/o: mval size/count */\n\tstruct xfs_bmap_free\t*flist)\t\t/* i/o: list extents to free */\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tstruct xfs_ifork\t*ifp;\n\tstruct xfs_bmalloca\tbma = { NULL };\t/* args for xfs_bmap_alloc */\n\txfs_fileoff_t\t\tend;\t\t/* end of mapped file region */\n\tint\t\t\teof;\t\t/* after the end of extents */\n\tint\t\t\terror;\t\t/* error return */\n\tint\t\t\tn;\t\t/* current extent index */\n\txfs_fileoff_t\t\tobno;\t\t/* old block number (offset) */\n\tint\t\t\twhichfork;\t/* data or attr fork */\n\tchar\t\t\tinhole;\t\t/* current location is hole in file */\n\tchar\t\t\twasdelay;\t/* old extent was delayed */\n\n#ifdef DEBUG\n\txfs_fileoff_t\t\torig_bno;\t/* original block number value */\n\tint\t\t\torig_flags;\t/* original flags arg value */\n\txfs_filblks_t\t\torig_len;\t/* original value of len arg */\n\tstruct xfs_bmbt_irec\t*orig_mval;\t/* original value of mval */\n\tint\t\t\torig_nmap;\t/* original value of *nmap */\n\n\torig_bno = bno;\n\torig_len = len;\n\torig_flags = flags;\n\torig_mval = mval;\n\torig_nmap = *nmap;\n#endif\n\twhichfork = (flags & XFS_BMAPI_ATTRFORK) ?\n\t\tXFS_ATTR_FORK : XFS_DATA_FORK;\n\n\tASSERT(*nmap >= 1);\n\tASSERT(*nmap <= XFS_BMAP_MAX_NMAP);\n\tASSERT(!(flags & XFS_BMAPI_IGSTATE));\n\tASSERT(tp != NULL);\n\tASSERT(len > 0);\n\tASSERT(XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_LOCAL);\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\n\tif (unlikely(XFS_TEST_ERROR(\n\t    (XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_EXTENTS &&\n\t     XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_BTREE),\n\t     mp, XFS_ERRTAG_BMAPIFORMAT, XFS_RANDOM_BMAPIFORMAT))) {\n\t\tXFS_ERROR_REPORT(\"xfs_bmapi_write\", XFS_ERRLEVEL_LOW, mp);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\tif (XFS_FORCED_SHUTDOWN(mp))\n\t\treturn -EIO;\n\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\n\tXFS_STATS_INC(xs_blk_mapw);\n\n\tif (*firstblock == NULLFSBLOCK) {\n\t\tif (XFS_IFORK_FORMAT(ip, whichfork) == XFS_DINODE_FMT_BTREE)\n\t\t\tbma.minleft = be16_to_cpu(ifp->if_broot->bb_level) + 1;\n\t\telse\n\t\t\tbma.minleft = 1;\n\t} else {\n\t\tbma.minleft = 0;\n\t}\n\n\tif (!(ifp->if_flags & XFS_IFEXTENTS)) {\n\t\terror = xfs_iread_extents(tp, ip, whichfork);\n\t\tif (error)\n\t\t\tgoto error0;\n\t}\n\n\txfs_bmap_search_extents(ip, bno, whichfork, &eof, &bma.idx, &bma.got,\n\t\t\t\t&bma.prev);\n\tn = 0;\n\tend = bno + len;\n\tobno = bno;\n\n\tbma.tp = tp;\n\tbma.ip = ip;\n\tbma.total = total;\n\tbma.userdata = 0;\n\tbma.flist = flist;\n\tbma.firstblock = firstblock;\n\n\twhile (bno < end && n < *nmap) {\n\t\tinhole = eof || bma.got.br_startoff > bno;\n\t\twasdelay = !inhole && isnullstartblock(bma.got.br_startblock);\n\n\t\t/*\n\t\t * First, deal with the hole before the allocated space\n\t\t * that we found, if any.\n\t\t */\n\t\tif (inhole || wasdelay) {\n\t\t\tbma.eof = eof;\n\t\t\tbma.conv = !!(flags & XFS_BMAPI_CONVERT);\n\t\t\tbma.wasdel = wasdelay;\n\t\t\tbma.offset = bno;\n\t\t\tbma.flags = flags;\n\n\t\t\t/*\n\t\t\t * There's a 32/64 bit type mismatch between the\n\t\t\t * allocation length request (which can be 64 bits in\n\t\t\t * length) and the bma length request, which is\n\t\t\t * xfs_extlen_t and therefore 32 bits. Hence we have to\n\t\t\t * check for 32-bit overflows and handle them here.\n\t\t\t */\n\t\t\tif (len > (xfs_filblks_t)MAXEXTLEN)\n\t\t\t\tbma.length = MAXEXTLEN;\n\t\t\telse\n\t\t\t\tbma.length = len;\n\n\t\t\tASSERT(len > 0);\n\t\t\tASSERT(bma.length > 0);\n\t\t\terror = xfs_bmapi_allocate(&bma);\n\t\t\tif (error)\n\t\t\t\tgoto error0;\n\t\t\tif (bma.blkno == NULLFSBLOCK)\n\t\t\t\tbreak;\n\t\t}\n\n\t\t/* Deal with the allocated space we found.  */\n\t\txfs_bmapi_trim_map(mval, &bma.got, &bno, len, obno,\n\t\t\t\t\t\t\tend, n, flags);\n\n\t\t/* Execute unwritten extent conversion if necessary */\n\t\terror = xfs_bmapi_convert_unwritten(&bma, mval, len, flags);\n\t\tif (error == -EAGAIN)\n\t\t\tcontinue;\n\t\tif (error)\n\t\t\tgoto error0;\n\n\t\t/* update the extent map to return */\n\t\txfs_bmapi_update_map(&mval, &bno, &len, obno, end, &n, flags);\n\n\t\t/*\n\t\t * If we're done, stop now.  Stop when we've allocated\n\t\t * XFS_BMAP_MAX_NMAP extents no matter what.  Otherwise\n\t\t * the transaction may get too big.\n\t\t */\n\t\tif (bno >= end || n >= *nmap || bma.nallocs >= *nmap)\n\t\t\tbreak;\n\n\t\t/* Else go on to the next record. */\n\t\tbma.prev = bma.got;\n\t\tif (++bma.idx < ifp->if_bytes / sizeof(xfs_bmbt_rec_t)) {\n\t\t\txfs_bmbt_get_all(xfs_iext_get_ext(ifp, bma.idx),\n\t\t\t\t\t &bma.got);\n\t\t} else\n\t\t\teof = 1;\n\t}\n\t*nmap = n;\n\n\t/*\n\t * Transform from btree to extents, give it cur.\n\t */\n\tif (xfs_bmap_wants_extents(ip, whichfork)) {\n\t\tint\t\ttmp_logflags = 0;\n\n\t\tASSERT(bma.cur);\n\t\terror = xfs_bmap_btree_to_extents(tp, ip, bma.cur,\n\t\t\t&tmp_logflags, whichfork);\n\t\tbma.logflags |= tmp_logflags;\n\t\tif (error)\n\t\t\tgoto error0;\n\t}\n\n\tASSERT(XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_BTREE ||\n\t       XFS_IFORK_NEXTENTS(ip, whichfork) >\n\t\tXFS_IFORK_MAXEXT(ip, whichfork));\n\terror = 0;\nerror0:\n\t/*\n\t * Log everything.  Do this after conversion, there's no point in\n\t * logging the extent records if we've converted to btree format.\n\t */\n\tif ((bma.logflags & xfs_ilog_fext(whichfork)) &&\n\t    XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_EXTENTS)\n\t\tbma.logflags &= ~xfs_ilog_fext(whichfork);\n\telse if ((bma.logflags & xfs_ilog_fbroot(whichfork)) &&\n\t\t XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_BTREE)\n\t\tbma.logflags &= ~xfs_ilog_fbroot(whichfork);\n\t/*\n\t * Log whatever the flags say, even if error.  Otherwise we might miss\n\t * detecting a case where the data is changed, there's an error,\n\t * and it's not logged so we don't shutdown when we should.\n\t */\n\tif (bma.logflags)\n\t\txfs_trans_log_inode(tp, ip, bma.logflags);\n\n\tif (bma.cur) {\n\t\tif (!error) {\n\t\t\tASSERT(*firstblock == NULLFSBLOCK ||\n\t\t\t       XFS_FSB_TO_AGNO(mp, *firstblock) ==\n\t\t\t       XFS_FSB_TO_AGNO(mp,\n\t\t\t\t       bma.cur->bc_private.b.firstblock) ||\n\t\t\t       (flist->xbf_low &&\n\t\t\t\tXFS_FSB_TO_AGNO(mp, *firstblock) <\n\t\t\t\tXFS_FSB_TO_AGNO(mp,\n\t\t\t\t\tbma.cur->bc_private.b.firstblock)));\n\t\t\t*firstblock = bma.cur->bc_private.b.firstblock;\n\t\t}\n\t\txfs_btree_del_cursor(bma.cur,\n\t\t\terror ? XFS_BTREE_ERROR : XFS_BTREE_NOERROR);\n\t}\n\tif (!error)\n\t\txfs_bmap_validate_ret(orig_bno, orig_len, orig_flags, orig_mval,\n\t\t\torig_nmap, *nmap);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_bmapi_write(\n\tstruct xfs_trans\t*tp,\t\t/* transaction pointer */\n\tstruct xfs_inode\t*ip,\t\t/* incore inode */\n\txfs_fileoff_t\t\tbno,\t\t/* starting file offs. mapped */\n\txfs_filblks_t\t\tlen,\t\t/* length to map in file */\n\tint\t\t\tflags,\t\t/* XFS_BMAPI_... */\n\txfs_fsblock_t\t\t*firstblock,\t/* first allocated block\n\t\t\t\t\t\t   controls a.g. for allocs */\n\txfs_extlen_t\t\ttotal,\t\t/* total blocks needed */\n\tstruct xfs_bmbt_irec\t*mval,\t\t/* output: map values */\n\tint\t\t\t*nmap,\t\t/* i/o: mval size/count */\n\tstruct xfs_bmap_free\t*flist)\t\t/* i/o: list extents to free */\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tstruct xfs_ifork\t*ifp;\n\tstruct xfs_bmalloca\tbma = { NULL };\t/* args for xfs_bmap_alloc */\n\txfs_fileoff_t\t\tend;\t\t/* end of mapped file region */\n\tint\t\t\teof;\t\t/* after the end of extents */\n\tint\t\t\terror;\t\t/* error return */\n\tint\t\t\tn;\t\t/* current extent index */\n\txfs_fileoff_t\t\tobno;\t\t/* old block number (offset) */\n\tint\t\t\twhichfork;\t/* data or attr fork */\n\tchar\t\t\tinhole;\t\t/* current location is hole in file */\n\tchar\t\t\twasdelay;\t/* old extent was delayed */\n\n#ifdef DEBUG\n\txfs_fileoff_t\t\torig_bno;\t/* original block number value */\n\tint\t\t\torig_flags;\t/* original flags arg value */\n\txfs_filblks_t\t\torig_len;\t/* original value of len arg */\n\tstruct xfs_bmbt_irec\t*orig_mval;\t/* original value of mval */\n\tint\t\t\torig_nmap;\t/* original value of *nmap */\n\n\torig_bno = bno;\n\torig_len = len;\n\torig_flags = flags;\n\torig_mval = mval;\n\torig_nmap = *nmap;\n#endif\n\twhichfork = (flags & XFS_BMAPI_ATTRFORK) ?\n\t\tXFS_ATTR_FORK : XFS_DATA_FORK;\n\n\tASSERT(*nmap >= 1);\n\tASSERT(*nmap <= XFS_BMAP_MAX_NMAP);\n\tASSERT(!(flags & XFS_BMAPI_IGSTATE));\n\tASSERT(tp != NULL);\n\tASSERT(len > 0);\n\tASSERT(XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_LOCAL);\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\n\tif (unlikely(XFS_TEST_ERROR(\n\t    (XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_EXTENTS &&\n\t     XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_BTREE),\n\t     mp, XFS_ERRTAG_BMAPIFORMAT, XFS_RANDOM_BMAPIFORMAT))) {\n\t\tXFS_ERROR_REPORT(\"xfs_bmapi_write\", XFS_ERRLEVEL_LOW, mp);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\tif (XFS_FORCED_SHUTDOWN(mp))\n\t\treturn -EIO;\n\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\n\tXFS_STATS_INC(xs_blk_mapw);\n\n\tif (*firstblock == NULLFSBLOCK) {\n\t\tif (XFS_IFORK_FORMAT(ip, whichfork) == XFS_DINODE_FMT_BTREE)\n\t\t\tbma.minleft = be16_to_cpu(ifp->if_broot->bb_level) + 1;\n\t\telse\n\t\t\tbma.minleft = 1;\n\t} else {\n\t\tbma.minleft = 0;\n\t}\n\n\tif (!(ifp->if_flags & XFS_IFEXTENTS)) {\n\t\terror = xfs_iread_extents(tp, ip, whichfork);\n\t\tif (error)\n\t\t\tgoto error0;\n\t}\n\n\txfs_bmap_search_extents(ip, bno, whichfork, &eof, &bma.idx, &bma.got,\n\t\t\t\t&bma.prev);\n\tn = 0;\n\tend = bno + len;\n\tobno = bno;\n\n\tbma.tp = tp;\n\tbma.ip = ip;\n\tbma.total = total;\n\tbma.userdata = 0;\n\tbma.flist = flist;\n\tbma.firstblock = firstblock;\n\n\twhile (bno < end && n < *nmap) {\n\t\tinhole = eof || bma.got.br_startoff > bno;\n\t\twasdelay = !inhole && isnullstartblock(bma.got.br_startblock);\n\n\t\t/*\n\t\t * First, deal with the hole before the allocated space\n\t\t * that we found, if any.\n\t\t */\n\t\tif (inhole || wasdelay) {\n\t\t\tbma.eof = eof;\n\t\t\tbma.conv = !!(flags & XFS_BMAPI_CONVERT);\n\t\t\tbma.wasdel = wasdelay;\n\t\t\tbma.offset = bno;\n\t\t\tbma.flags = flags;\n\n\t\t\t/*\n\t\t\t * There's a 32/64 bit type mismatch between the\n\t\t\t * allocation length request (which can be 64 bits in\n\t\t\t * length) and the bma length request, which is\n\t\t\t * xfs_extlen_t and therefore 32 bits. Hence we have to\n\t\t\t * check for 32-bit overflows and handle them here.\n\t\t\t */\n\t\t\tif (len > (xfs_filblks_t)MAXEXTLEN)\n\t\t\t\tbma.length = MAXEXTLEN;\n\t\t\telse\n\t\t\t\tbma.length = len;\n\n\t\t\tASSERT(len > 0);\n\t\t\tASSERT(bma.length > 0);\n\t\t\terror = xfs_bmapi_allocate(&bma);\n\t\t\tif (error)\n\t\t\t\tgoto error0;\n\t\t\tif (bma.blkno == NULLFSBLOCK)\n\t\t\t\tbreak;\n\t\t}\n\n\t\t/* Deal with the allocated space we found.  */\n\t\txfs_bmapi_trim_map(mval, &bma.got, &bno, len, obno,\n\t\t\t\t\t\t\tend, n, flags);\n\n\t\t/* Execute unwritten extent conversion if necessary */\n\t\terror = xfs_bmapi_convert_unwritten(&bma, mval, len, flags);\n\t\tif (error == -EAGAIN)\n\t\t\tcontinue;\n\t\tif (error)\n\t\t\tgoto error0;\n\n\t\t/* update the extent map to return */\n\t\txfs_bmapi_update_map(&mval, &bno, &len, obno, end, &n, flags);\n\n\t\t/*\n\t\t * If we're done, stop now.  Stop when we've allocated\n\t\t * XFS_BMAP_MAX_NMAP extents no matter what.  Otherwise\n\t\t * the transaction may get too big.\n\t\t */\n\t\tif (bno >= end || n >= *nmap || bma.nallocs >= *nmap)\n\t\t\tbreak;\n\n\t\t/* Else go on to the next record. */\n\t\tbma.prev = bma.got;\n\t\tif (++bma.idx < ifp->if_bytes / sizeof(xfs_bmbt_rec_t)) {\n\t\t\txfs_bmbt_get_all(xfs_iext_get_ext(ifp, bma.idx),\n\t\t\t\t\t &bma.got);\n\t\t} else\n\t\t\teof = 1;\n\t}\n\t*nmap = n;\n\n\t/*\n\t * Transform from btree to extents, give it cur.\n\t */\n\tif (xfs_bmap_wants_extents(ip, whichfork)) {\n\t\tint\t\ttmp_logflags = 0;\n\n\t\tASSERT(bma.cur);\n\t\terror = xfs_bmap_btree_to_extents(tp, ip, bma.cur,\n\t\t\t&tmp_logflags, whichfork);\n\t\tbma.logflags |= tmp_logflags;\n\t\tif (error)\n\t\t\tgoto error0;\n\t}\n\n\tASSERT(XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_BTREE ||\n\t       XFS_IFORK_NEXTENTS(ip, whichfork) >\n\t\tXFS_IFORK_MAXEXT(ip, whichfork));\n\terror = 0;\nerror0:\n\t/*\n\t * Log everything.  Do this after conversion, there's no point in\n\t * logging the extent records if we've converted to btree format.\n\t */\n\tif ((bma.logflags & xfs_ilog_fext(whichfork)) &&\n\t    XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_EXTENTS)\n\t\tbma.logflags &= ~xfs_ilog_fext(whichfork);\n\telse if ((bma.logflags & xfs_ilog_fbroot(whichfork)) &&\n\t\t XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_BTREE)\n\t\tbma.logflags &= ~xfs_ilog_fbroot(whichfork);\n\t/*\n\t * Log whatever the flags say, even if error.  Otherwise we might miss\n\t * detecting a case where the data is changed, there's an error,\n\t * and it's not logged so we don't shutdown when we should.\n\t */\n\tif (bma.logflags)\n\t\txfs_trans_log_inode(tp, ip, bma.logflags);\n\n\tif (bma.cur) {\n\t\tif (!error) {\n\t\t\tASSERT(*firstblock == NULLFSBLOCK ||\n\t\t\t       XFS_FSB_TO_AGNO(mp, *firstblock) ==\n\t\t\t       XFS_FSB_TO_AGNO(mp,\n\t\t\t\t       bma.cur->bc_private.b.firstblock) ||\n\t\t\t       (flist->xbf_low &&\n\t\t\t\tXFS_FSB_TO_AGNO(mp, *firstblock) <\n\t\t\t\tXFS_FSB_TO_AGNO(mp,\n\t\t\t\t\tbma.cur->bc_private.b.firstblock)));\n\t\t\t*firstblock = bma.cur->bc_private.b.firstblock;\n\t\t}\n\t\txfs_btree_del_cursor(bma.cur,\n\t\t\terror ? XFS_BTREE_ERROR : XFS_BTREE_NOERROR);\n\t}\n\tif (!error)\n\t\txfs_bmap_validate_ret(orig_bno, orig_len, orig_flags, orig_mval,\n\t\t\torig_nmap, *nmap);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_QM_DQALLOC_SPACE_RES",
          "args": [
            "mp"
          ],
          "line": 335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_trans_ijoin",
          "args": [
            "tp",
            "quotip",
            "XFS_ILOCK_EXCL"
          ],
          "line": 331
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_ijoin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_inode.c",
          "lines": "37-57",
          "snippet": "void\nxfs_trans_ijoin(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\txfs_inode_log_item_t\t*iip;\n\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\tif (ip->i_itemp == NULL)\n\t\txfs_inode_item_init(ip, ip->i_mount);\n\tiip = ip->i_itemp;\n\n\tASSERT(iip->ili_lock_flags == 0);\n\tiip->ili_lock_flags = lock_flags;\n\n\t/*\n\t * Get a log_item_desc to point at the new item.\n\t */\n\txfs_trans_add_item(tp, &iip->ili_item);\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_ijoin(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\txfs_inode_log_item_t\t*iip;\n\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\tif (ip->i_itemp == NULL)\n\t\txfs_inode_item_init(ip, ip->i_mount);\n\tiip = ip->i_itemp;\n\n\tASSERT(iip->ili_lock_flags == 0);\n\tiip->ili_lock_flags = lock_flags;\n\n\t/*\n\t * Get a log_item_desc to point at the new item.\n\t */\n\txfs_trans_add_item(tp, &iip->ili_item);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_this_quota_on",
          "args": [
            "dqp->q_mount",
            "dqp->dq_flags"
          ],
          "line": 326
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_this_quota_on",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_dquot.h",
          "lines": "114-126",
          "snippet": "static inline int xfs_this_quota_on(struct xfs_mount *mp, int type)\n{\n\tswitch (type & XFS_DQ_ALLTYPES) {\n\tcase XFS_DQ_USER:\n\t\treturn XFS_IS_UQUOTA_ON(mp);\n\tcase XFS_DQ_GROUP:\n\t\treturn XFS_IS_GQUOTA_ON(mp);\n\tcase XFS_DQ_PROJ:\n\t\treturn XFS_IS_PQUOTA_ON(mp);\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int xfs_this_quota_on(struct xfs_mount *mp, int type)\n{\n\tswitch (type & XFS_DQ_ALLTYPES) {\n\tcase XFS_DQ_USER:\n\t\treturn XFS_IS_UQUOTA_ON(mp);\n\tcase XFS_DQ_GROUP:\n\t\treturn XFS_IS_GQUOTA_ON(mp);\n\tcase XFS_DQ_PROJ:\n\t\treturn XFS_IS_PQUOTA_ON(mp);\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_ilock",
          "args": [
            "quotip",
            "XFS_ILOCK_EXCL"
          ],
          "line": 321
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_ilock_demote",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
          "lines": "269-283",
          "snippet": "void\nxfs_ilock_demote(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\tASSERT(lock_flags & (XFS_IOLOCK_EXCL|XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_IOLOCK_EXCL|XFS_ILOCK_EXCL)) == 0);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrdemote(&ip->i_lock);\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrdemote(&ip->i_iolock);\n\n\ttrace_xfs_ilock_demote(ip, lock_flags, _RET_IP_);\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);\n\nvoid\nxfs_ilock_demote(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\tASSERT(lock_flags & (XFS_IOLOCK_EXCL|XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_IOLOCK_EXCL|XFS_ILOCK_EXCL)) == 0);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrdemote(&ip->i_lock);\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrdemote(&ip->i_iolock);\n\n\ttrace_xfs_ilock_demote(ip, lock_flags, _RET_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_bmap_init",
          "args": [
            "&flist",
            "&firstblock"
          ],
          "line": 320
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmap_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.h",
          "lines": "133-137",
          "snippet": "static inline void xfs_bmap_init(xfs_bmap_free_t *flp, xfs_fsblock_t *fbp)\n{\n\t((flp)->xbf_first = NULL, (flp)->xbf_count = 0, \\\n\t\t(flp)->xbf_low = 0, *(fbp) = NULLFSBLOCK);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void xfs_bmap_init(xfs_bmap_free_t *flp, xfs_fsblock_t *fbp)\n{\n\t((flp)->xbf_first = NULL, (flp)->xbf_count = 0, \\\n\t\t(flp)->xbf_low = 0, *(fbp) = NULLFSBLOCK);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_xfs_dqalloc",
          "args": [
            "dqp"
          ],
          "line": 315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "tp != NULL"
          ],
          "line": 313
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_qm.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxfs_qm_dqalloc(\n\txfs_trans_t\t**tpp,\n\txfs_mount_t\t*mp,\n\txfs_dquot_t\t*dqp,\n\txfs_inode_t\t*quotip,\n\txfs_fileoff_t\toffset_fsb,\n\txfs_buf_t\t**O_bpp)\n{\n\txfs_fsblock_t\tfirstblock;\n\txfs_bmap_free_t flist;\n\txfs_bmbt_irec_t map;\n\tint\t\tnmaps, error, committed;\n\txfs_buf_t\t*bp;\n\txfs_trans_t\t*tp = *tpp;\n\n\tASSERT(tp != NULL);\n\n\ttrace_xfs_dqalloc(dqp);\n\n\t/*\n\t * Initialize the bmap freelist prior to calling bmapi code.\n\t */\n\txfs_bmap_init(&flist, &firstblock);\n\txfs_ilock(quotip, XFS_ILOCK_EXCL);\n\t/*\n\t * Return if this type of quotas is turned off while we didn't\n\t * have an inode lock\n\t */\n\tif (!xfs_this_quota_on(dqp->q_mount, dqp->dq_flags)) {\n\t\txfs_iunlock(quotip, XFS_ILOCK_EXCL);\n\t\treturn -ESRCH;\n\t}\n\n\txfs_trans_ijoin(tp, quotip, XFS_ILOCK_EXCL);\n\tnmaps = 1;\n\terror = xfs_bmapi_write(tp, quotip, offset_fsb,\n\t\t\t\tXFS_DQUOT_CLUSTER_SIZE_FSB, XFS_BMAPI_METADATA,\n\t\t\t\t&firstblock, XFS_QM_DQALLOC_SPACE_RES(mp),\n\t\t\t\t&map, &nmaps, &flist);\n\tif (error)\n\t\tgoto error0;\n\tASSERT(map.br_blockcount == XFS_DQUOT_CLUSTER_SIZE_FSB);\n\tASSERT(nmaps == 1);\n\tASSERT((map.br_startblock != DELAYSTARTBLOCK) &&\n\t       (map.br_startblock != HOLESTARTBLOCK));\n\n\t/*\n\t * Keep track of the blkno to save a lookup later\n\t */\n\tdqp->q_blkno = XFS_FSB_TO_DADDR(mp, map.br_startblock);\n\n\t/* now we can just get the buffer (there's nothing to read yet) */\n\tbp = xfs_trans_get_buf(tp, mp->m_ddev_targp,\n\t\t\t       dqp->q_blkno,\n\t\t\t       mp->m_quotainfo->qi_dqchunklen,\n\t\t\t       0);\n\tif (!bp) {\n\t\terror = -ENOMEM;\n\t\tgoto error1;\n\t}\n\tbp->b_ops = &xfs_dquot_buf_ops;\n\n\t/*\n\t * Make a chunk of dquots out of this buffer and log\n\t * the entire thing.\n\t */\n\txfs_qm_init_dquot_blk(tp, mp, be32_to_cpu(dqp->q_core.d_id),\n\t\t\t      dqp->dq_flags & XFS_DQ_ALLTYPES, bp);\n\n\t/*\n\t * xfs_bmap_finish() may commit the current transaction and\n\t * start a second transaction if the freelist is not empty.\n\t *\n\t * Since we still want to modify this buffer, we need to\n\t * ensure that the buffer is not released on commit of\n\t * the first transaction and ensure the buffer is added to the\n\t * second transaction.\n\t *\n\t * If there is only one transaction then don't stop the buffer\n\t * from being released when it commits later on.\n\t */\n\n\txfs_trans_bhold(tp, bp);\n\n\tif ((error = xfs_bmap_finish(tpp, &flist, &committed))) {\n\t\tgoto error1;\n\t}\n\n\tif (committed) {\n\t\ttp = *tpp;\n\t\txfs_trans_bjoin(tp, bp);\n\t} else {\n\t\txfs_trans_bhold_release(tp, bp);\n\t}\n\n\t*O_bpp = bp;\n\treturn 0;\n\n      error1:\n\txfs_bmap_cancel(&flist);\n      error0:\n\txfs_iunlock(quotip, XFS_ILOCK_EXCL);\n\n\treturn error;\n}"
  },
  {
    "function_name": "xfs_dquot_set_prealloc_limits",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_dquot.c",
    "lines": "272-291",
    "snippet": "void\nxfs_dquot_set_prealloc_limits(struct xfs_dquot *dqp)\n{\n\t__uint64_t space;\n\n\tdqp->q_prealloc_hi_wmark = be64_to_cpu(dqp->q_core.d_blk_hardlimit);\n\tdqp->q_prealloc_lo_wmark = be64_to_cpu(dqp->q_core.d_blk_softlimit);\n\tif (!dqp->q_prealloc_lo_wmark) {\n\t\tdqp->q_prealloc_lo_wmark = dqp->q_prealloc_hi_wmark;\n\t\tdo_div(dqp->q_prealloc_lo_wmark, 100);\n\t\tdqp->q_prealloc_lo_wmark *= 95;\n\t}\n\n\tspace = dqp->q_prealloc_hi_wmark;\n\n\tdo_div(space, 100);\n\tdqp->q_low_space[XFS_QLOWSP_1_PCNT] = space;\n\tdqp->q_low_space[XFS_QLOWSP_3_PCNT] = space * 3;\n\tdqp->q_low_space[XFS_QLOWSP_5_PCNT] = space * 5;\n}",
    "includes": [
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_qm.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_div",
          "args": [
            "space",
            "100"
          ],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_div",
          "args": [
            "dqp->q_prealloc_lo_wmark",
            "100"
          ],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "dqp->q_core.d_blk_softlimit"
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "dqp->q_core.d_blk_hardlimit"
          ],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_qm.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_dquot_set_prealloc_limits(struct xfs_dquot *dqp)\n{\n\t__uint64_t space;\n\n\tdqp->q_prealloc_hi_wmark = be64_to_cpu(dqp->q_core.d_blk_hardlimit);\n\tdqp->q_prealloc_lo_wmark = be64_to_cpu(dqp->q_core.d_blk_softlimit);\n\tif (!dqp->q_prealloc_lo_wmark) {\n\t\tdqp->q_prealloc_lo_wmark = dqp->q_prealloc_hi_wmark;\n\t\tdo_div(dqp->q_prealloc_lo_wmark, 100);\n\t\tdqp->q_prealloc_lo_wmark *= 95;\n\t}\n\n\tspace = dqp->q_prealloc_hi_wmark;\n\n\tdo_div(space, 100);\n\tdqp->q_low_space[XFS_QLOWSP_1_PCNT] = space;\n\tdqp->q_low_space[XFS_QLOWSP_3_PCNT] = space * 3;\n\tdqp->q_low_space[XFS_QLOWSP_5_PCNT] = space * 5;\n}"
  },
  {
    "function_name": "xfs_qm_init_dquot_blk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_dquot.c",
    "lines": "225-265",
    "snippet": "STATIC void\nxfs_qm_init_dquot_blk(\n\txfs_trans_t\t*tp,\n\txfs_mount_t\t*mp,\n\txfs_dqid_t\tid,\n\tuint\t\ttype,\n\txfs_buf_t\t*bp)\n{\n\tstruct xfs_quotainfo\t*q = mp->m_quotainfo;\n\txfs_dqblk_t\t*d;\n\tint\t\tcurid, i;\n\n\tASSERT(tp);\n\tASSERT(xfs_buf_islocked(bp));\n\n\td = bp->b_addr;\n\n\t/*\n\t * ID of the first dquot in the block - id's are zero based.\n\t */\n\tcurid = id - (id % q->qi_dqperchunk);\n\tASSERT(curid >= 0);\n\tmemset(d, 0, BBTOB(q->qi_dqchunklen));\n\tfor (i = 0; i < q->qi_dqperchunk; i++, d++, curid++) {\n\t\td->dd_diskdq.d_magic = cpu_to_be16(XFS_DQUOT_MAGIC);\n\t\td->dd_diskdq.d_version = XFS_DQUOT_VERSION;\n\t\td->dd_diskdq.d_id = cpu_to_be32(curid);\n\t\td->dd_diskdq.d_flags = type;\n\t\tif (xfs_sb_version_hascrc(&mp->m_sb)) {\n\t\t\tuuid_copy(&d->dd_uuid, &mp->m_sb.sb_uuid);\n\t\t\txfs_update_cksum((char *)d, sizeof(struct xfs_dqblk),\n\t\t\t\t\t XFS_DQUOT_CRC_OFF);\n\t\t}\n\t}\n\n\txfs_trans_dquot_buf(tp, bp,\n\t\t\t    (type & XFS_DQ_USER ? XFS_BLF_UDQUOT_BUF :\n\t\t\t    ((type & XFS_DQ_PROJ) ? XFS_BLF_PDQUOT_BUF :\n\t\t\t     XFS_BLF_GDQUOT_BUF)));\n\txfs_trans_log_buf(tp, bp, 0, BBTOB(q->qi_dqchunklen) - 1);\n}",
    "includes": [
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_qm.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_trans_log_buf",
          "args": [
            "tp",
            "bp",
            "0",
            "BBTOB(q->qi_dqchunklen) - 1"
          ],
          "line": 264
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_log_buf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_buf.c",
          "lines": "497-552",
          "snippet": "void\nxfs_trans_log_buf(xfs_trans_t\t*tp,\n\t\t  xfs_buf_t\t*bp,\n\t\t  uint\t\tfirst,\n\t\t  uint\t\tlast)\n{\n\txfs_buf_log_item_t\t*bip = bp->b_fspriv;\n\n\tASSERT(bp->b_transp == tp);\n\tASSERT(bip != NULL);\n\tASSERT(first <= last && last < BBTOB(bp->b_length));\n\tASSERT(bp->b_iodone == NULL ||\n\t       bp->b_iodone == xfs_buf_iodone_callbacks);\n\n\t/*\n\t * Mark the buffer as needing to be written out eventually,\n\t * and set its iodone function to remove the buffer's buf log\n\t * item from the AIL and free it when the buffer is flushed\n\t * to disk.  See xfs_buf_attach_iodone() for more details\n\t * on li_cb and xfs_buf_iodone_callbacks().\n\t * If we end up aborting this transaction, we trap this buffer\n\t * inside the b_bdstrat callback so that this won't get written to\n\t * disk.\n\t */\n\tXFS_BUF_DONE(bp);\n\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\tbp->b_iodone = xfs_buf_iodone_callbacks;\n\tbip->bli_item.li_cb = xfs_buf_iodone;\n\n\ttrace_xfs_trans_log_buf(bip);\n\n\t/*\n\t * If we invalidated the buffer within this transaction, then\n\t * cancel the invalidation now that we're dirtying the buffer\n\t * again.  There are no races with the code in xfs_buf_item_unpin(),\n\t * because we have a reference to the buffer this entire time.\n\t */\n\tif (bip->bli_flags & XFS_BLI_STALE) {\n\t\tbip->bli_flags &= ~XFS_BLI_STALE;\n\t\tASSERT(XFS_BUF_ISSTALE(bp));\n\t\tXFS_BUF_UNSTALE(bp);\n\t\tbip->__bli_format.blf_flags &= ~XFS_BLF_CANCEL;\n\t}\n\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n\tbip->bli_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n\n\t/*\n\t * If we have an ordered buffer we are not logging any dirty range but\n\t * it still needs to be marked dirty and that it has been logged.\n\t */\n\tbip->bli_flags |= XFS_BLI_DIRTY | XFS_BLI_LOGGED;\n\tif (!(bip->bli_flags & XFS_BLI_ORDERED))\n\t\txfs_buf_item_log(bip, first, last);\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_log_buf(xfs_trans_t\t*tp,\n\t\t  xfs_buf_t\t*bp,\n\t\t  uint\t\tfirst,\n\t\t  uint\t\tlast)\n{\n\txfs_buf_log_item_t\t*bip = bp->b_fspriv;\n\n\tASSERT(bp->b_transp == tp);\n\tASSERT(bip != NULL);\n\tASSERT(first <= last && last < BBTOB(bp->b_length));\n\tASSERT(bp->b_iodone == NULL ||\n\t       bp->b_iodone == xfs_buf_iodone_callbacks);\n\n\t/*\n\t * Mark the buffer as needing to be written out eventually,\n\t * and set its iodone function to remove the buffer's buf log\n\t * item from the AIL and free it when the buffer is flushed\n\t * to disk.  See xfs_buf_attach_iodone() for more details\n\t * on li_cb and xfs_buf_iodone_callbacks().\n\t * If we end up aborting this transaction, we trap this buffer\n\t * inside the b_bdstrat callback so that this won't get written to\n\t * disk.\n\t */\n\tXFS_BUF_DONE(bp);\n\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\tbp->b_iodone = xfs_buf_iodone_callbacks;\n\tbip->bli_item.li_cb = xfs_buf_iodone;\n\n\ttrace_xfs_trans_log_buf(bip);\n\n\t/*\n\t * If we invalidated the buffer within this transaction, then\n\t * cancel the invalidation now that we're dirtying the buffer\n\t * again.  There are no races with the code in xfs_buf_item_unpin(),\n\t * because we have a reference to the buffer this entire time.\n\t */\n\tif (bip->bli_flags & XFS_BLI_STALE) {\n\t\tbip->bli_flags &= ~XFS_BLI_STALE;\n\t\tASSERT(XFS_BUF_ISSTALE(bp));\n\t\tXFS_BUF_UNSTALE(bp);\n\t\tbip->__bli_format.blf_flags &= ~XFS_BLF_CANCEL;\n\t}\n\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n\tbip->bli_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n\n\t/*\n\t * If we have an ordered buffer we are not logging any dirty range but\n\t * it still needs to be marked dirty and that it has been logged.\n\t */\n\tbip->bli_flags |= XFS_BLI_DIRTY | XFS_BLI_LOGGED;\n\tif (!(bip->bli_flags & XFS_BLI_ORDERED))\n\t\txfs_buf_item_log(bip, first, last);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BBTOB",
          "args": [
            "q->qi_dqchunklen"
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_trans_dquot_buf",
          "args": [
            "tp",
            "bp",
            "(type & XFS_DQ_USER ? XFS_BLF_UDQUOT_BUF :\n\t\t\t    ((type & XFS_DQ_PROJ) ? XFS_BLF_PDQUOT_BUF :\n\t\t\t     XFS_BLF_GDQUOT_BUF))"
          ],
          "line": 260
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_dquot_buf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_buf.c",
          "lines": "772-802",
          "snippet": "void\nxfs_trans_dquot_buf(\n\txfs_trans_t\t*tp,\n\txfs_buf_t\t*bp,\n\tuint\t\ttype)\n{\n\tstruct xfs_buf_log_item\t*bip = bp->b_fspriv;\n\n\tASSERT(type == XFS_BLF_UDQUOT_BUF ||\n\t       type == XFS_BLF_PDQUOT_BUF ||\n\t       type == XFS_BLF_GDQUOT_BUF);\n\n\tbip->__bli_format.blf_flags |= type;\n\n\tswitch (type) {\n\tcase XFS_BLF_UDQUOT_BUF:\n\t\ttype = XFS_BLFT_UDQUOT_BUF;\n\t\tbreak;\n\tcase XFS_BLF_PDQUOT_BUF:\n\t\ttype = XFS_BLFT_PDQUOT_BUF;\n\t\tbreak;\n\tcase XFS_BLF_GDQUOT_BUF:\n\t\ttype = XFS_BLFT_GDQUOT_BUF;\n\t\tbreak;\n\tdefault:\n\t\ttype = XFS_BLFT_UNKNOWN_BUF;\n\t\tbreak;\n\t}\n\n\txfs_trans_buf_set_type(tp, bp, type);\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nvoid\nxfs_trans_dquot_buf(\n\txfs_trans_t\t*tp,\n\txfs_buf_t\t*bp,\n\tuint\t\ttype)\n{\n\tstruct xfs_buf_log_item\t*bip = bp->b_fspriv;\n\n\tASSERT(type == XFS_BLF_UDQUOT_BUF ||\n\t       type == XFS_BLF_PDQUOT_BUF ||\n\t       type == XFS_BLF_GDQUOT_BUF);\n\n\tbip->__bli_format.blf_flags |= type;\n\n\tswitch (type) {\n\tcase XFS_BLF_UDQUOT_BUF:\n\t\ttype = XFS_BLFT_UDQUOT_BUF;\n\t\tbreak;\n\tcase XFS_BLF_PDQUOT_BUF:\n\t\ttype = XFS_BLFT_PDQUOT_BUF;\n\t\tbreak;\n\tcase XFS_BLF_GDQUOT_BUF:\n\t\ttype = XFS_BLFT_GDQUOT_BUF;\n\t\tbreak;\n\tdefault:\n\t\ttype = XFS_BLFT_UNKNOWN_BUF;\n\t\tbreak;\n\t}\n\n\txfs_trans_buf_set_type(tp, bp, type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_update_cksum",
          "args": [
            "(char *)d",
            "sizeof(struct xfs_dqblk)",
            "XFS_DQUOT_CRC_OFF"
          ],
          "line": 255
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_update_cksum",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_cksum.h",
          "lines": "44-50",
          "snippet": "static inline void\nxfs_update_cksum(char *buffer, size_t length, unsigned long cksum_offset)\n{\n\t__uint32_t crc = xfs_start_cksum(buffer, length, cksum_offset);\n\n\t*(__le32 *)(buffer + cksum_offset) = xfs_end_cksum(crc);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void\nxfs_update_cksum(char *buffer, size_t length, unsigned long cksum_offset)\n{\n\t__uint32_t crc = xfs_start_cksum(buffer, length, cksum_offset);\n\n\t*(__le32 *)(buffer + cksum_offset) = xfs_end_cksum(crc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "uuid_copy",
          "args": [
            "&d->dd_uuid",
            "&mp->m_sb.sb_uuid"
          ],
          "line": 254
        },
        "resolved": true,
        "details": {
          "function_name": "uuid_copy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/uuid.h",
          "lines": "29-33",
          "snippet": "static inline void\nuuid_copy(uuid_t *dst, uuid_t *src)\n{\n\tmemcpy(dst, src, sizeof(uuid_t));\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void\nuuid_copy(uuid_t *dst, uuid_t *src)\n{\n\tmemcpy(dst, src, sizeof(uuid_t));\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_sb_version_hascrc",
          "args": [
            "&mp->m_sb"
          ],
          "line": 253
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_sb_version_hascrc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_format.h",
          "lines": "547-550",
          "snippet": "static inline int xfs_sb_version_hascrc(struct xfs_sb *sbp)\n{\n\treturn XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5;\n}",
          "includes": [],
          "macros_used": [
            "#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */\n\nstatic inline int xfs_sb_version_hascrc(struct xfs_sb *sbp)\n{\n\treturn XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "curid"
          ],
          "line": 251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "XFS_DQUOT_MAGIC"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "d",
            "0",
            "BBTOB(q->qi_dqchunklen)"
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BBTOB",
          "args": [
            "q->qi_dqchunklen"
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "curid >= 0"
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "xfs_buf_islocked(bp)"
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_buf_islocked",
          "args": [
            "bp"
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "tp"
          ],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_qm.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\nxfs_qm_init_dquot_blk(\n\txfs_trans_t\t*tp,\n\txfs_mount_t\t*mp,\n\txfs_dqid_t\tid,\n\tuint\t\ttype,\n\txfs_buf_t\t*bp)\n{\n\tstruct xfs_quotainfo\t*q = mp->m_quotainfo;\n\txfs_dqblk_t\t*d;\n\tint\t\tcurid, i;\n\n\tASSERT(tp);\n\tASSERT(xfs_buf_islocked(bp));\n\n\td = bp->b_addr;\n\n\t/*\n\t * ID of the first dquot in the block - id's are zero based.\n\t */\n\tcurid = id - (id % q->qi_dqperchunk);\n\tASSERT(curid >= 0);\n\tmemset(d, 0, BBTOB(q->qi_dqchunklen));\n\tfor (i = 0; i < q->qi_dqperchunk; i++, d++, curid++) {\n\t\td->dd_diskdq.d_magic = cpu_to_be16(XFS_DQUOT_MAGIC);\n\t\td->dd_diskdq.d_version = XFS_DQUOT_VERSION;\n\t\td->dd_diskdq.d_id = cpu_to_be32(curid);\n\t\td->dd_diskdq.d_flags = type;\n\t\tif (xfs_sb_version_hascrc(&mp->m_sb)) {\n\t\t\tuuid_copy(&d->dd_uuid, &mp->m_sb.sb_uuid);\n\t\t\txfs_update_cksum((char *)d, sizeof(struct xfs_dqblk),\n\t\t\t\t\t XFS_DQUOT_CRC_OFF);\n\t\t}\n\t}\n\n\txfs_trans_dquot_buf(tp, bp,\n\t\t\t    (type & XFS_DQ_USER ? XFS_BLF_UDQUOT_BUF :\n\t\t\t    ((type & XFS_DQ_PROJ) ? XFS_BLF_PDQUOT_BUF :\n\t\t\t     XFS_BLF_GDQUOT_BUF)));\n\txfs_trans_log_buf(tp, bp, 0, BBTOB(q->qi_dqchunklen) - 1);\n}"
  },
  {
    "function_name": "xfs_qm_adjust_dqtimers",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_dquot.c",
    "lines": "133-220",
    "snippet": "void\nxfs_qm_adjust_dqtimers(\n\txfs_mount_t\t\t*mp,\n\txfs_disk_dquot_t\t*d)\n{\n\tASSERT(d->d_id);\n\n#ifdef DEBUG\n\tif (d->d_blk_hardlimit)\n\t\tASSERT(be64_to_cpu(d->d_blk_softlimit) <=\n\t\t       be64_to_cpu(d->d_blk_hardlimit));\n\tif (d->d_ino_hardlimit)\n\t\tASSERT(be64_to_cpu(d->d_ino_softlimit) <=\n\t\t       be64_to_cpu(d->d_ino_hardlimit));\n\tif (d->d_rtb_hardlimit)\n\t\tASSERT(be64_to_cpu(d->d_rtb_softlimit) <=\n\t\t       be64_to_cpu(d->d_rtb_hardlimit));\n#endif\n\n\tif (!d->d_btimer) {\n\t\tif ((d->d_blk_softlimit &&\n\t\t     (be64_to_cpu(d->d_bcount) >\n\t\t      be64_to_cpu(d->d_blk_softlimit))) ||\n\t\t    (d->d_blk_hardlimit &&\n\t\t     (be64_to_cpu(d->d_bcount) >\n\t\t      be64_to_cpu(d->d_blk_hardlimit)))) {\n\t\t\td->d_btimer = cpu_to_be32(get_seconds() +\n\t\t\t\t\tmp->m_quotainfo->qi_btimelimit);\n\t\t} else {\n\t\t\td->d_bwarns = 0;\n\t\t}\n\t} else {\n\t\tif ((!d->d_blk_softlimit ||\n\t\t     (be64_to_cpu(d->d_bcount) <=\n\t\t      be64_to_cpu(d->d_blk_softlimit))) &&\n\t\t    (!d->d_blk_hardlimit ||\n\t\t    (be64_to_cpu(d->d_bcount) <=\n\t\t     be64_to_cpu(d->d_blk_hardlimit)))) {\n\t\t\td->d_btimer = 0;\n\t\t}\n\t}\n\n\tif (!d->d_itimer) {\n\t\tif ((d->d_ino_softlimit &&\n\t\t     (be64_to_cpu(d->d_icount) >\n\t\t      be64_to_cpu(d->d_ino_softlimit))) ||\n\t\t    (d->d_ino_hardlimit &&\n\t\t     (be64_to_cpu(d->d_icount) >\n\t\t      be64_to_cpu(d->d_ino_hardlimit)))) {\n\t\t\td->d_itimer = cpu_to_be32(get_seconds() +\n\t\t\t\t\tmp->m_quotainfo->qi_itimelimit);\n\t\t} else {\n\t\t\td->d_iwarns = 0;\n\t\t}\n\t} else {\n\t\tif ((!d->d_ino_softlimit ||\n\t\t     (be64_to_cpu(d->d_icount) <=\n\t\t      be64_to_cpu(d->d_ino_softlimit)))  &&\n\t\t    (!d->d_ino_hardlimit ||\n\t\t     (be64_to_cpu(d->d_icount) <=\n\t\t      be64_to_cpu(d->d_ino_hardlimit)))) {\n\t\t\td->d_itimer = 0;\n\t\t}\n\t}\n\n\tif (!d->d_rtbtimer) {\n\t\tif ((d->d_rtb_softlimit &&\n\t\t     (be64_to_cpu(d->d_rtbcount) >\n\t\t      be64_to_cpu(d->d_rtb_softlimit))) ||\n\t\t    (d->d_rtb_hardlimit &&\n\t\t     (be64_to_cpu(d->d_rtbcount) >\n\t\t      be64_to_cpu(d->d_rtb_hardlimit)))) {\n\t\t\td->d_rtbtimer = cpu_to_be32(get_seconds() +\n\t\t\t\t\tmp->m_quotainfo->qi_rtbtimelimit);\n\t\t} else {\n\t\t\td->d_rtbwarns = 0;\n\t\t}\n\t} else {\n\t\tif ((!d->d_rtb_softlimit ||\n\t\t     (be64_to_cpu(d->d_rtbcount) <=\n\t\t      be64_to_cpu(d->d_rtb_softlimit))) &&\n\t\t    (!d->d_rtb_hardlimit ||\n\t\t     (be64_to_cpu(d->d_rtbcount) <=\n\t\t      be64_to_cpu(d->d_rtb_hardlimit)))) {\n\t\t\td->d_rtbtimer = 0;\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_qm.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "d->d_rtb_hardlimit"
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "d->d_rtbcount"
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "d->d_rtb_softlimit"
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "d->d_rtbcount"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "get_seconds() +\n\t\t\t\t\tmp->m_quotainfo->qi_rtbtimelimit"
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_seconds",
          "args": [],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "d->d_rtb_hardlimit"
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "d->d_rtbcount"
          ],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "d->d_rtb_softlimit"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "d->d_rtbcount"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "d->d_ino_hardlimit"
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "d->d_icount"
          ],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "d->d_ino_softlimit"
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "d->d_icount"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "get_seconds() +\n\t\t\t\t\tmp->m_quotainfo->qi_itimelimit"
          ],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_seconds",
          "args": [],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "d->d_ino_hardlimit"
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "d->d_icount"
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "d->d_ino_softlimit"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "d->d_icount"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "d->d_blk_hardlimit"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "d->d_bcount"
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "d->d_blk_softlimit"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "d->d_bcount"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "get_seconds() +\n\t\t\t\t\tmp->m_quotainfo->qi_btimelimit"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_seconds",
          "args": [],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "d->d_blk_hardlimit"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "d->d_bcount"
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "d->d_blk_softlimit"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "d->d_bcount"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "be64_to_cpu(d->d_rtb_softlimit) <=\n\t\t       be64_to_cpu(d->d_rtb_hardlimit)"
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "d->d_rtb_hardlimit"
          ],
          "line": 149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "d->d_rtb_softlimit"
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "be64_to_cpu(d->d_ino_softlimit) <=\n\t\t       be64_to_cpu(d->d_ino_hardlimit)"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "d->d_ino_hardlimit"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "d->d_ino_softlimit"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "be64_to_cpu(d->d_blk_softlimit) <=\n\t\t       be64_to_cpu(d->d_blk_hardlimit)"
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "d->d_blk_hardlimit"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "d->d_blk_softlimit"
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "d->d_id"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_qm.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_qm_adjust_dqtimers(\n\txfs_mount_t\t\t*mp,\n\txfs_disk_dquot_t\t*d)\n{\n\tASSERT(d->d_id);\n\n#ifdef DEBUG\n\tif (d->d_blk_hardlimit)\n\t\tASSERT(be64_to_cpu(d->d_blk_softlimit) <=\n\t\t       be64_to_cpu(d->d_blk_hardlimit));\n\tif (d->d_ino_hardlimit)\n\t\tASSERT(be64_to_cpu(d->d_ino_softlimit) <=\n\t\t       be64_to_cpu(d->d_ino_hardlimit));\n\tif (d->d_rtb_hardlimit)\n\t\tASSERT(be64_to_cpu(d->d_rtb_softlimit) <=\n\t\t       be64_to_cpu(d->d_rtb_hardlimit));\n#endif\n\n\tif (!d->d_btimer) {\n\t\tif ((d->d_blk_softlimit &&\n\t\t     (be64_to_cpu(d->d_bcount) >\n\t\t      be64_to_cpu(d->d_blk_softlimit))) ||\n\t\t    (d->d_blk_hardlimit &&\n\t\t     (be64_to_cpu(d->d_bcount) >\n\t\t      be64_to_cpu(d->d_blk_hardlimit)))) {\n\t\t\td->d_btimer = cpu_to_be32(get_seconds() +\n\t\t\t\t\tmp->m_quotainfo->qi_btimelimit);\n\t\t} else {\n\t\t\td->d_bwarns = 0;\n\t\t}\n\t} else {\n\t\tif ((!d->d_blk_softlimit ||\n\t\t     (be64_to_cpu(d->d_bcount) <=\n\t\t      be64_to_cpu(d->d_blk_softlimit))) &&\n\t\t    (!d->d_blk_hardlimit ||\n\t\t    (be64_to_cpu(d->d_bcount) <=\n\t\t     be64_to_cpu(d->d_blk_hardlimit)))) {\n\t\t\td->d_btimer = 0;\n\t\t}\n\t}\n\n\tif (!d->d_itimer) {\n\t\tif ((d->d_ino_softlimit &&\n\t\t     (be64_to_cpu(d->d_icount) >\n\t\t      be64_to_cpu(d->d_ino_softlimit))) ||\n\t\t    (d->d_ino_hardlimit &&\n\t\t     (be64_to_cpu(d->d_icount) >\n\t\t      be64_to_cpu(d->d_ino_hardlimit)))) {\n\t\t\td->d_itimer = cpu_to_be32(get_seconds() +\n\t\t\t\t\tmp->m_quotainfo->qi_itimelimit);\n\t\t} else {\n\t\t\td->d_iwarns = 0;\n\t\t}\n\t} else {\n\t\tif ((!d->d_ino_softlimit ||\n\t\t     (be64_to_cpu(d->d_icount) <=\n\t\t      be64_to_cpu(d->d_ino_softlimit)))  &&\n\t\t    (!d->d_ino_hardlimit ||\n\t\t     (be64_to_cpu(d->d_icount) <=\n\t\t      be64_to_cpu(d->d_ino_hardlimit)))) {\n\t\t\td->d_itimer = 0;\n\t\t}\n\t}\n\n\tif (!d->d_rtbtimer) {\n\t\tif ((d->d_rtb_softlimit &&\n\t\t     (be64_to_cpu(d->d_rtbcount) >\n\t\t      be64_to_cpu(d->d_rtb_softlimit))) ||\n\t\t    (d->d_rtb_hardlimit &&\n\t\t     (be64_to_cpu(d->d_rtbcount) >\n\t\t      be64_to_cpu(d->d_rtb_hardlimit)))) {\n\t\t\td->d_rtbtimer = cpu_to_be32(get_seconds() +\n\t\t\t\t\tmp->m_quotainfo->qi_rtbtimelimit);\n\t\t} else {\n\t\t\td->d_rtbwarns = 0;\n\t\t}\n\t} else {\n\t\tif ((!d->d_rtb_softlimit ||\n\t\t     (be64_to_cpu(d->d_rtbcount) <=\n\t\t      be64_to_cpu(d->d_rtb_softlimit))) &&\n\t\t    (!d->d_rtb_hardlimit ||\n\t\t     (be64_to_cpu(d->d_rtbcount) <=\n\t\t      be64_to_cpu(d->d_rtb_hardlimit)))) {\n\t\t\td->d_rtbtimer = 0;\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "xfs_qm_adjust_dqlimits",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_dquot.c",
    "lines": "88-118",
    "snippet": "void\nxfs_qm_adjust_dqlimits(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_dquot\t*dq)\n{\n\tstruct xfs_quotainfo\t*q = mp->m_quotainfo;\n\tstruct xfs_disk_dquot\t*d = &dq->q_core;\n\tint\t\t\tprealloc = 0;\n\n\tASSERT(d->d_id);\n\n\tif (q->qi_bsoftlimit && !d->d_blk_softlimit) {\n\t\td->d_blk_softlimit = cpu_to_be64(q->qi_bsoftlimit);\n\t\tprealloc = 1;\n\t}\n\tif (q->qi_bhardlimit && !d->d_blk_hardlimit) {\n\t\td->d_blk_hardlimit = cpu_to_be64(q->qi_bhardlimit);\n\t\tprealloc = 1;\n\t}\n\tif (q->qi_isoftlimit && !d->d_ino_softlimit)\n\t\td->d_ino_softlimit = cpu_to_be64(q->qi_isoftlimit);\n\tif (q->qi_ihardlimit && !d->d_ino_hardlimit)\n\t\td->d_ino_hardlimit = cpu_to_be64(q->qi_ihardlimit);\n\tif (q->qi_rtbsoftlimit && !d->d_rtb_softlimit)\n\t\td->d_rtb_softlimit = cpu_to_be64(q->qi_rtbsoftlimit);\n\tif (q->qi_rtbhardlimit && !d->d_rtb_hardlimit)\n\t\td->d_rtb_hardlimit = cpu_to_be64(q->qi_rtbhardlimit);\n\n\tif (prealloc)\n\t\txfs_dquot_set_prealloc_limits(dq);\n}",
    "includes": [
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_qm.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_dquot_set_prealloc_limits",
          "args": [
            "dq"
          ],
          "line": 117
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dquot_set_prealloc_limits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_dquot.c",
          "lines": "272-291",
          "snippet": "void\nxfs_dquot_set_prealloc_limits(struct xfs_dquot *dqp)\n{\n\t__uint64_t space;\n\n\tdqp->q_prealloc_hi_wmark = be64_to_cpu(dqp->q_core.d_blk_hardlimit);\n\tdqp->q_prealloc_lo_wmark = be64_to_cpu(dqp->q_core.d_blk_softlimit);\n\tif (!dqp->q_prealloc_lo_wmark) {\n\t\tdqp->q_prealloc_lo_wmark = dqp->q_prealloc_hi_wmark;\n\t\tdo_div(dqp->q_prealloc_lo_wmark, 100);\n\t\tdqp->q_prealloc_lo_wmark *= 95;\n\t}\n\n\tspace = dqp->q_prealloc_hi_wmark;\n\n\tdo_div(space, 100);\n\tdqp->q_low_space[XFS_QLOWSP_1_PCNT] = space;\n\tdqp->q_low_space[XFS_QLOWSP_3_PCNT] = space * 3;\n\tdqp->q_low_space[XFS_QLOWSP_5_PCNT] = space * 5;\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_qm.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_qm.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_dquot_set_prealloc_limits(struct xfs_dquot *dqp)\n{\n\t__uint64_t space;\n\n\tdqp->q_prealloc_hi_wmark = be64_to_cpu(dqp->q_core.d_blk_hardlimit);\n\tdqp->q_prealloc_lo_wmark = be64_to_cpu(dqp->q_core.d_blk_softlimit);\n\tif (!dqp->q_prealloc_lo_wmark) {\n\t\tdqp->q_prealloc_lo_wmark = dqp->q_prealloc_hi_wmark;\n\t\tdo_div(dqp->q_prealloc_lo_wmark, 100);\n\t\tdqp->q_prealloc_lo_wmark *= 95;\n\t}\n\n\tspace = dqp->q_prealloc_hi_wmark;\n\n\tdo_div(space, 100);\n\tdqp->q_low_space[XFS_QLOWSP_1_PCNT] = space;\n\tdqp->q_low_space[XFS_QLOWSP_3_PCNT] = space * 3;\n\tdqp->q_low_space[XFS_QLOWSP_5_PCNT] = space * 5;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "q->qi_rtbhardlimit"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "q->qi_rtbsoftlimit"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "q->qi_ihardlimit"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "q->qi_isoftlimit"
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "q->qi_bhardlimit"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "q->qi_bsoftlimit"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "d->d_id"
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_qm.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_qm_adjust_dqlimits(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_dquot\t*dq)\n{\n\tstruct xfs_quotainfo\t*q = mp->m_quotainfo;\n\tstruct xfs_disk_dquot\t*d = &dq->q_core;\n\tint\t\t\tprealloc = 0;\n\n\tASSERT(d->d_id);\n\n\tif (q->qi_bsoftlimit && !d->d_blk_softlimit) {\n\t\td->d_blk_softlimit = cpu_to_be64(q->qi_bsoftlimit);\n\t\tprealloc = 1;\n\t}\n\tif (q->qi_bhardlimit && !d->d_blk_hardlimit) {\n\t\td->d_blk_hardlimit = cpu_to_be64(q->qi_bhardlimit);\n\t\tprealloc = 1;\n\t}\n\tif (q->qi_isoftlimit && !d->d_ino_softlimit)\n\t\td->d_ino_softlimit = cpu_to_be64(q->qi_isoftlimit);\n\tif (q->qi_ihardlimit && !d->d_ino_hardlimit)\n\t\td->d_ino_hardlimit = cpu_to_be64(q->qi_ihardlimit);\n\tif (q->qi_rtbsoftlimit && !d->d_rtb_softlimit)\n\t\td->d_rtb_softlimit = cpu_to_be64(q->qi_rtbsoftlimit);\n\tif (q->qi_rtbhardlimit && !d->d_rtb_hardlimit)\n\t\td->d_rtb_hardlimit = cpu_to_be64(q->qi_rtbhardlimit);\n\n\tif (prealloc)\n\t\txfs_dquot_set_prealloc_limits(dq);\n}"
  },
  {
    "function_name": "xfs_qm_dqdestroy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_dquot.c",
    "lines": "71-81",
    "snippet": "void\nxfs_qm_dqdestroy(\n\txfs_dquot_t\t*dqp)\n{\n\tASSERT(list_empty(&dqp->q_lru));\n\n\tmutex_destroy(&dqp->q_qlock);\n\tkmem_zone_free(xfs_qm_dqzone, dqp);\n\n\tXFS_STATS_DEC(xs_qm_dquot);\n}",
    "includes": [
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_qm.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_zone\t\t*xfs_qm_dqzone;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "XFS_STATS_DEC",
          "args": [
            "xs_qm_dquot"
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_zone_free",
          "args": [
            "xfs_qm_dqzone",
            "dqp"
          ],
          "line": 78
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_zone_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/kmem.h",
          "lines": "104-108",
          "snippet": "static inline void\nkmem_zone_free(kmem_zone_t *zone, void *ptr)\n{\n\tkmem_cache_free(zone, ptr);\n}",
          "includes": [
            "#include <linux/vmalloc.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [
            "#define kmem_zone_t\tstruct kmem_cache"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n\n#define kmem_zone_t\tstruct kmem_cache\n\nstatic inline void\nkmem_zone_free(kmem_zone_t *zone, void *ptr)\n{\n\tkmem_cache_free(zone, ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_destroy",
          "args": [
            "&dqp->q_qlock"
          ],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "list_empty(&dqp->q_lru)"
          ],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&dqp->q_lru"
          ],
          "line": 75
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_qm.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic struct kmem_zone\t\t*xfs_qm_dqzone;\n\nvoid\nxfs_qm_dqdestroy(\n\txfs_dquot_t\t*dqp)\n{\n\tASSERT(list_empty(&dqp->q_lru));\n\n\tmutex_destroy(&dqp->q_qlock);\n\tkmem_zone_free(xfs_qm_dqzone, dqp);\n\n\tXFS_STATS_DEC(xs_qm_dquot);\n}"
  }
]