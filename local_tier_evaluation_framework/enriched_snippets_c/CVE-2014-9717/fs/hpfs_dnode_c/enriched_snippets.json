[
  {
    "function_name": "map_fnode_dirent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/dnode.c",
    "lines": "996-1093",
    "snippet": "struct hpfs_dirent *map_fnode_dirent(struct super_block *s, fnode_secno fno,\n\t\t\t\t     struct fnode *f, struct quad_buffer_head *qbh)\n{\n\tunsigned char *name1;\n\tunsigned char *name2;\n\tint name1len, name2len;\n\tstruct dnode *d;\n\tdnode_secno dno, downd;\n\tstruct fnode *upf;\n\tstruct buffer_head *bh;\n\tstruct hpfs_dirent *de, *de_end;\n\tint c;\n\tint c1, c2 = 0;\n\tint d1, d2 = 0;\n\tname1 = f->name;\n\tif (!(name2 = kmalloc(256, GFP_NOFS))) {\n\t\tpr_err(\"out of memory, can't map dirent\\n\");\n\t\treturn NULL;\n\t}\n\tif (f->len <= 15)\n\t\tmemcpy(name2, name1, name1len = name2len = f->len);\n\telse {\n\t\tmemcpy(name2, name1, 15);\n\t\tmemset(name2 + 15, 0xff, 256 - 15);\n\t\t/*name2[15] = 0xff;*/\n\t\tname1len = 15; name2len = 256;\n\t}\n\tif (!(upf = hpfs_map_fnode(s, le32_to_cpu(f->up), &bh))) {\n\t\tkfree(name2);\n\t\treturn NULL;\n\t}\t\n\tif (!fnode_is_dir(upf)) {\n\t\tbrelse(bh);\n\t\thpfs_error(s, \"fnode %08x has non-directory parent %08x\", fno, le32_to_cpu(f->up));\n\t\tkfree(name2);\n\t\treturn NULL;\n\t}\n\tdno = le32_to_cpu(upf->u.external[0].disk_secno);\n\tbrelse(bh);\n\tgo_down:\n\tdownd = 0;\n\tgo_up:\n\tif (!(d = hpfs_map_dnode(s, dno, qbh))) {\n\t\tkfree(name2);\n\t\treturn NULL;\n\t}\n\tde_end = dnode_end_de(d);\n\tde = dnode_first_de(d);\n\tif (downd) {\n\t\twhile (de < de_end) {\n\t\t\tif (de->down) if (de_down_pointer(de) == downd) goto f;\n\t\t\tde = de_next_de(de);\n\t\t}\n\t\thpfs_error(s, \"pointer to dnode %08x not found in dnode %08x\", downd, dno);\n\t\thpfs_brelse4(qbh);\n\t\tkfree(name2);\n\t\treturn NULL;\n\t}\n\tnext_de:\n\tif (le32_to_cpu(de->fnode) == fno) {\n\t\tkfree(name2);\n\t\treturn de;\n\t}\n\tc = hpfs_compare_names(s, name1, name1len, de->name, de->namelen, de->last);\n\tif (c < 0 && de->down) {\n\t\tdno = de_down_pointer(de);\n\t\thpfs_brelse4(qbh);\n\t\tif (hpfs_sb(s)->sb_chk)\n\t\t\tif (hpfs_stop_cycles(s, dno, &c1, &c2, \"map_fnode_dirent #1\")) {\n\t\t\t\tkfree(name2);\n\t\t\t\treturn NULL;\n\t\t}\n\t\tgoto go_down;\n\t}\n\tf:\n\tif (le32_to_cpu(de->fnode) == fno) {\n\t\tkfree(name2);\n\t\treturn de;\n\t}\n\tc = hpfs_compare_names(s, name2, name2len, de->name, de->namelen, de->last);\n\tif (c < 0 && !de->last) goto not_found;\n\tif ((de = de_next_de(de)) < de_end) goto next_de;\n\tif (d->root_dnode) goto not_found;\n\tdownd = dno;\n\tdno = le32_to_cpu(d->up);\n\thpfs_brelse4(qbh);\n\tif (hpfs_sb(s)->sb_chk)\n\t\tif (hpfs_stop_cycles(s, downd, &d1, &d2, \"map_fnode_dirent #2\")) {\n\t\t\tkfree(name2);\n\t\t\treturn NULL;\n\t\t}\n\tgoto go_up;\n\tnot_found:\n\thpfs_brelse4(qbh);\n\thpfs_error(s, \"dirent for fnode %08x not found\", fno);\n\tkfree(name2);\n\treturn NULL;\n}",
    "includes": [
      "#include \"hpfs_fn.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "name2"
          ],
          "line": 1091
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hpfs_error",
          "args": [
            "s",
            "\"dirent for fnode %08x not found\"",
            "fno"
          ],
          "line": 1090
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/super.c",
          "lines": "57-86",
          "snippet": "void hpfs_error(struct super_block *s, const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvsnprintf(err_buf, sizeof(err_buf), fmt, args);\n\tva_end(args);\n\n\tpr_err(\"filesystem error: %s\", err_buf);\n\tif (!hpfs_sb(s)->sb_was_error) {\n\t\tif (hpfs_sb(s)->sb_err == 2) {\n\t\t\tpr_cont(\"; crashing the system because you wanted it\\n\");\n\t\t\tmark_dirty(s, 0);\n\t\t\tpanic(\"HPFS panic\");\n\t\t} else if (hpfs_sb(s)->sb_err == 1) {\n\t\t\tif (s->s_flags & MS_RDONLY)\n\t\t\t\tpr_cont(\"; already mounted read-only\\n\");\n\t\t\telse {\n\t\t\t\tpr_cont(\"; remounting read-only\\n\");\n\t\t\t\tmark_dirty(s, 0);\n\t\t\t\ts->s_flags |= MS_RDONLY;\n\t\t\t}\n\t\t} else if (s->s_flags & MS_RDONLY)\n\t\t\t\tpr_cont(\"; going on - but anything won't be destroyed because it's read-only\\n\");\n\t\telse\n\t\t\tpr_cont(\"; corrupted filesystem mounted read/write - your computer will explode within 20 seconds ... but you wanted it so!\\n\");\n\t} else\n\t\tpr_cont(\"\\n\");\n\thpfs_sb(s)->sb_was_error = 1;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/sched.h>",
            "#include <linux/magic.h>",
            "#include <linux/statfs.h>",
            "#include <linux/init.h>",
            "#include <linux/parser.h>",
            "#include <linux/module.h>",
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static char err_buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/bitmap.h>\n#include <linux/sched.h>\n#include <linux/magic.h>\n#include <linux/statfs.h>\n#include <linux/init.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include \"hpfs_fn.h\"\n\nstatic char err_buf[1024];\n\nvoid hpfs_error(struct super_block *s, const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvsnprintf(err_buf, sizeof(err_buf), fmt, args);\n\tva_end(args);\n\n\tpr_err(\"filesystem error: %s\", err_buf);\n\tif (!hpfs_sb(s)->sb_was_error) {\n\t\tif (hpfs_sb(s)->sb_err == 2) {\n\t\t\tpr_cont(\"; crashing the system because you wanted it\\n\");\n\t\t\tmark_dirty(s, 0);\n\t\t\tpanic(\"HPFS panic\");\n\t\t} else if (hpfs_sb(s)->sb_err == 1) {\n\t\t\tif (s->s_flags & MS_RDONLY)\n\t\t\t\tpr_cont(\"; already mounted read-only\\n\");\n\t\t\telse {\n\t\t\t\tpr_cont(\"; remounting read-only\\n\");\n\t\t\t\tmark_dirty(s, 0);\n\t\t\t\ts->s_flags |= MS_RDONLY;\n\t\t\t}\n\t\t} else if (s->s_flags & MS_RDONLY)\n\t\t\t\tpr_cont(\"; going on - but anything won't be destroyed because it's read-only\\n\");\n\t\telse\n\t\t\tpr_cont(\"; corrupted filesystem mounted read/write - your computer will explode within 20 seconds ... but you wanted it so!\\n\");\n\t} else\n\t\tpr_cont(\"\\n\");\n\thpfs_sb(s)->sb_was_error = 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_brelse4",
          "args": [
            "qbh"
          ],
          "line": 1089
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_brelse4",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/buffer.c",
          "lines": "182-190",
          "snippet": "void hpfs_brelse4(struct quad_buffer_head *qbh)\n{\n\tif (unlikely(qbh->data != qbh->bh[0]->b_data))\n\t\tkfree(qbh->data);\n\tbrelse(qbh->bh[0]);\n\tbrelse(qbh->bh[1]);\n\tbrelse(qbh->bh[2]);\n\tbrelse(qbh->bh[3]);\n}",
          "includes": [
            "#include \"hpfs_fn.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid hpfs_brelse4(struct quad_buffer_head *qbh)\n{\n\tif (unlikely(qbh->data != qbh->bh[0]->b_data))\n\t\tkfree(qbh->data);\n\tbrelse(qbh->bh[0]);\n\tbrelse(qbh->bh[1]);\n\tbrelse(qbh->bh[2]);\n\tbrelse(qbh->bh[3]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "name2"
          ],
          "line": 1084
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hpfs_stop_cycles",
          "args": [
            "s",
            "downd",
            "&d1",
            "&d2",
            "\"map_fnode_dirent #2\""
          ],
          "line": 1083
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_stop_cycles",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/super.c",
          "lines": "96-106",
          "snippet": "int hpfs_stop_cycles(struct super_block *s, int key, int *c1, int *c2,\n\t\tchar *msg)\n{\n\tif (*c2 && *c1 == key) {\n\t\thpfs_error(s, \"cycle detected on key %08x in %s\", key, msg);\n\t\treturn 1;\n\t}\n\t(*c2)++;\n\tif (!((*c2 - 1) & *c2)) *c1 = key;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/sched.h>",
            "#include <linux/magic.h>",
            "#include <linux/statfs.h>",
            "#include <linux/init.h>",
            "#include <linux/parser.h>",
            "#include <linux/module.h>",
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/bitmap.h>\n#include <linux/sched.h>\n#include <linux/magic.h>\n#include <linux/statfs.h>\n#include <linux/init.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include \"hpfs_fn.h\"\n\nint hpfs_stop_cycles(struct super_block *s, int key, int *c1, int *c2,\n\t\tchar *msg)\n{\n\tif (*c2 && *c1 == key) {\n\t\thpfs_error(s, \"cycle detected on key %08x in %s\", key, msg);\n\t\treturn 1;\n\t}\n\t(*c2)++;\n\tif (!((*c2 - 1) & *c2)) *c1 = key;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_sb",
          "args": [
            "s"
          ],
          "line": 1082
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_sb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "310-313",
          "snippet": "static inline struct hpfs_sb_info *hpfs_sb(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_check_free_dnodes(struct super_block *, int);",
            "void hpfs_prefetch_sectors(struct super_block *, unsigned, int);",
            "void hpfs_prefetch_bitmap(struct super_block *, unsigned);",
            "unsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);",
            "int hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);",
            "void hpfs_error(struct super_block *, const char *, ...);",
            "int hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);",
            "unsigned hpfs_get_free_dnodes(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_check_free_dnodes(struct super_block *, int);\nvoid hpfs_prefetch_sectors(struct super_block *, unsigned, int);\nvoid hpfs_prefetch_bitmap(struct super_block *, unsigned);\nunsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);\nint hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);\nvoid hpfs_error(struct super_block *, const char *, ...);\nint hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);\nunsigned hpfs_get_free_dnodes(struct super_block *);\n\nstatic inline struct hpfs_sb_info *hpfs_sb(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "d->up"
          ],
          "line": 1080
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "de_next_de",
          "args": [
            "de"
          ],
          "line": 1077
        },
        "resolved": true,
        "details": {
          "function_name": "de_next_de",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "123-127",
          "snippet": "static inline struct hpfs_dirent *de_next_de (struct hpfs_dirent *de)\n{\n  CHKCOND(le16_to_cpu(de->length)>=0x20 && le16_to_cpu(de->length)<0x800,(\"HPFS: de_next_de: de->length = %x\\n\",(unsigned)le16_to_cpu(de->length)));\n  return (void *) de + le16_to_cpu(de->length);\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_add_dirent(struct inode *, const unsigned char *, unsigned,\n\t\t    struct hpfs_dirent *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_add_dirent(struct inode *, const unsigned char *, unsigned,\n\t\t    struct hpfs_dirent *);\n\nstatic inline struct hpfs_dirent *de_next_de (struct hpfs_dirent *de)\n{\n  CHKCOND(le16_to_cpu(de->length)>=0x20 && le16_to_cpu(de->length)<0x800,(\"HPFS: de_next_de: de->length = %x\\n\",(unsigned)le16_to_cpu(de->length)));\n  return (void *) de + le16_to_cpu(de->length);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_compare_names",
          "args": [
            "s",
            "name2",
            "name2len",
            "de->name",
            "de->namelen",
            "de->last"
          ],
          "line": 1075
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_compare_names",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/name.c",
          "lines": "74-90",
          "snippet": "int hpfs_compare_names(struct super_block *s,\n\t\t       const unsigned char *n1, unsigned l1,\n\t\t       const unsigned char *n2, unsigned l2, int last)\n{\n\tunsigned l = l1 < l2 ? l1 : l2;\n\tunsigned i;\n\tif (last) return -1;\n\tfor (i = 0; i < l; i++) {\n\t\tunsigned char c1 = upcase(hpfs_sb(s)->sb_cp_table,n1[i]);\n\t\tunsigned char c2 = upcase(hpfs_sb(s)->sb_cp_table,n2[i]);\n\t\tif (c1 < c2) return -1;\n\t\tif (c1 > c2) return 1;\n\t}\n\tif (l1 < l2) return -1;\n\tif (l1 > l2) return 1;\n\treturn 0;\n}",
          "includes": [
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n\nint hpfs_compare_names(struct super_block *s,\n\t\t       const unsigned char *n1, unsigned l1,\n\t\t       const unsigned char *n2, unsigned l2, int last)\n{\n\tunsigned l = l1 < l2 ? l1 : l2;\n\tunsigned i;\n\tif (last) return -1;\n\tfor (i = 0; i < l; i++) {\n\t\tunsigned char c1 = upcase(hpfs_sb(s)->sb_cp_table,n1[i]);\n\t\tunsigned char c2 = upcase(hpfs_sb(s)->sb_cp_table,n2[i]);\n\t\tif (c1 < c2) return -1;\n\t\tif (c1 > c2) return 1;\n\t}\n\tif (l1 < l2) return -1;\n\tif (l1 > l2) return 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "name2"
          ],
          "line": 1072
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "name2"
          ],
          "line": 1065
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "de_down_pointer",
          "args": [
            "de"
          ],
          "line": 1061
        },
        "resolved": true,
        "details": {
          "function_name": "de_down_pointer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "100-104",
          "snippet": "static inline dnode_secno de_down_pointer (struct hpfs_dirent *de)\n{\n  CHKCOND(de->down,(\"HPFS: de_down_pointer: !de->down\\n\"));\n  return le32_to_cpu(*(__le32 *) ((void *) de + le16_to_cpu(de->length) - 4));\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_add_dirent(struct inode *, const unsigned char *, unsigned,\n\t\t    struct hpfs_dirent *);",
            "void hpfs_count_dnodes(struct super_block *, dnode_secno, int *, int *, int *);",
            "void hpfs_remove_dtree(struct super_block *, dnode_secno);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_add_dirent(struct inode *, const unsigned char *, unsigned,\n\t\t    struct hpfs_dirent *);\nvoid hpfs_count_dnodes(struct super_block *, dnode_secno, int *, int *, int *);\nvoid hpfs_remove_dtree(struct super_block *, dnode_secno);\n\nstatic inline dnode_secno de_down_pointer (struct hpfs_dirent *de)\n{\n  CHKCOND(de->down,(\"HPFS: de_down_pointer: !de->down\\n\"));\n  return le32_to_cpu(*(__le32 *) ((void *) de + le16_to_cpu(de->length) - 4));\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "name2"
          ],
          "line": 1056
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "name2"
          ],
          "line": 1051
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dnode_first_de",
          "args": [
            "d"
          ],
          "line": 1043
        },
        "resolved": true,
        "details": {
          "function_name": "dnode_first_de",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "108-111",
          "snippet": "static inline struct hpfs_dirent *dnode_first_de (struct dnode *dnode)\n{\n  return (void *) dnode->dirent;\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_add_dirent(struct inode *, const unsigned char *, unsigned,\n\t\t    struct hpfs_dirent *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_add_dirent(struct inode *, const unsigned char *, unsigned,\n\t\t    struct hpfs_dirent *);\n\nstatic inline struct hpfs_dirent *dnode_first_de (struct dnode *dnode)\n{\n  return (void *) dnode->dirent;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dnode_end_de",
          "args": [
            "d"
          ],
          "line": 1042
        },
        "resolved": true,
        "details": {
          "function_name": "dnode_end_de",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "115-119",
          "snippet": "static inline struct hpfs_dirent *dnode_end_de (struct dnode *dnode)\n{\n  CHKCOND(le32_to_cpu(dnode->first_free)>=0x14 && le32_to_cpu(dnode->first_free)<=0xa00,(\"HPFS: dnode_end_de: dnode->first_free = %x\\n\",(unsigned)le32_to_cpu(dnode->first_free)));\n  return (void *) dnode + le32_to_cpu(dnode->first_free);\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_add_dirent(struct inode *, const unsigned char *, unsigned,\n\t\t    struct hpfs_dirent *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_add_dirent(struct inode *, const unsigned char *, unsigned,\n\t\t    struct hpfs_dirent *);\n\nstatic inline struct hpfs_dirent *dnode_end_de (struct dnode *dnode)\n{\n  CHKCOND(le32_to_cpu(dnode->first_free)>=0x14 && le32_to_cpu(dnode->first_free)<=0xa00,(\"HPFS: dnode_end_de: dnode->first_free = %x\\n\",(unsigned)le32_to_cpu(dnode->first_free)));\n  return (void *) dnode + le32_to_cpu(dnode->first_free);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "name2"
          ],
          "line": 1039
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hpfs_map_dnode",
          "args": [
            "s",
            "dno",
            "qbh"
          ],
          "line": 1038
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_map_dnode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/map.c",
          "lines": "229-293",
          "snippet": "struct dnode *hpfs_map_dnode(struct super_block *s, unsigned secno,\n\t\t\t     struct quad_buffer_head *qbh)\n{\n\tstruct dnode *dnode;\n\tif (hpfs_sb(s)->sb_chk) {\n\t\tif (hpfs_chk_sectors(s, secno, 4, \"dnode\")) return NULL;\n\t\tif (secno & 3) {\n\t\t\thpfs_error(s, \"dnode %08x not byte-aligned\", secno);\n\t\t\treturn NULL;\n\t\t}\t\n\t}\n\tif ((dnode = hpfs_map_4sectors(s, secno, qbh, DNODE_RD_AHEAD)))\n\t\tif (hpfs_sb(s)->sb_chk) {\n\t\t\tunsigned p, pp = 0;\n\t\t\tunsigned char *d = (unsigned char *)dnode;\n\t\t\tint b = 0;\n\t\t\tif (le32_to_cpu(dnode->magic) != DNODE_MAGIC) {\n\t\t\t\thpfs_error(s, \"bad magic on dnode %08x\", secno);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tif (le32_to_cpu(dnode->self) != secno)\n\t\t\t\thpfs_error(s, \"bad self pointer on dnode %08x self = %08x\", secno, le32_to_cpu(dnode->self));\n\t\t\t/* Check dirents - bad dirents would cause infinite\n\t\t\t   loops or shooting to memory */\n\t\t\tif (le32_to_cpu(dnode->first_free) > 2048) {\n\t\t\t\thpfs_error(s, \"dnode %08x has first_free == %08x\", secno, le32_to_cpu(dnode->first_free));\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tfor (p = 20; p < le32_to_cpu(dnode->first_free); p += d[p] + (d[p+1] << 8)) {\n\t\t\t\tstruct hpfs_dirent *de = (struct hpfs_dirent *)((char *)dnode + p);\n\t\t\t\tif (le16_to_cpu(de->length) > 292 || (le16_to_cpu(de->length) < 32) || (le16_to_cpu(de->length) & 3) || p + le16_to_cpu(de->length) > 2048) {\n\t\t\t\t\thpfs_error(s, \"bad dirent size in dnode %08x, dirent %03x, last %03x\", secno, p, pp);\n\t\t\t\t\tgoto bail;\n\t\t\t\t}\n\t\t\t\tif (((31 + de->namelen + de->down*4 + 3) & ~3) != le16_to_cpu(de->length)) {\n\t\t\t\t\tif (((31 + de->namelen + de->down*4 + 3) & ~3) < le16_to_cpu(de->length) && s->s_flags & MS_RDONLY) goto ok;\n\t\t\t\t\thpfs_error(s, \"namelen does not match dirent size in dnode %08x, dirent %03x, last %03x\", secno, p, pp);\n\t\t\t\t\tgoto bail;\n\t\t\t\t}\n\t\t\t\tok:\n\t\t\t\tif (hpfs_sb(s)->sb_chk >= 2) b |= 1 << de->down;\n\t\t\t\tif (de->down) if (de_down_pointer(de) < 0x10) {\n\t\t\t\t\thpfs_error(s, \"bad down pointer in dnode %08x, dirent %03x, last %03x\", secno, p, pp);\n\t\t\t\t\tgoto bail;\n\t\t\t\t}\n\t\t\t\tpp = p;\n\t\t\t\t\n\t\t\t}\n\t\t\tif (p != le32_to_cpu(dnode->first_free)) {\n\t\t\t\thpfs_error(s, \"size on last dirent does not match first_free; dnode %08x\", secno);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tif (d[pp + 30] != 1 || d[pp + 31] != 255) {\n\t\t\t\thpfs_error(s, \"dnode %08x does not end with \\\\377 entry\", secno);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tif (b == 3)\n\t\t\t\tpr_err(\"unbalanced dnode tree, dnode %08x; see hpfs.txt 4 more info\\n\",\n\t\t\t\t\tsecno);\n\t\t}\n\treturn dnode;\n\tbail:\n\thpfs_brelse4(qbh);\n\treturn NULL;\n}",
          "includes": [
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n\nstruct dnode *hpfs_map_dnode(struct super_block *s, unsigned secno,\n\t\t\t     struct quad_buffer_head *qbh)\n{\n\tstruct dnode *dnode;\n\tif (hpfs_sb(s)->sb_chk) {\n\t\tif (hpfs_chk_sectors(s, secno, 4, \"dnode\")) return NULL;\n\t\tif (secno & 3) {\n\t\t\thpfs_error(s, \"dnode %08x not byte-aligned\", secno);\n\t\t\treturn NULL;\n\t\t}\t\n\t}\n\tif ((dnode = hpfs_map_4sectors(s, secno, qbh, DNODE_RD_AHEAD)))\n\t\tif (hpfs_sb(s)->sb_chk) {\n\t\t\tunsigned p, pp = 0;\n\t\t\tunsigned char *d = (unsigned char *)dnode;\n\t\t\tint b = 0;\n\t\t\tif (le32_to_cpu(dnode->magic) != DNODE_MAGIC) {\n\t\t\t\thpfs_error(s, \"bad magic on dnode %08x\", secno);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tif (le32_to_cpu(dnode->self) != secno)\n\t\t\t\thpfs_error(s, \"bad self pointer on dnode %08x self = %08x\", secno, le32_to_cpu(dnode->self));\n\t\t\t/* Check dirents - bad dirents would cause infinite\n\t\t\t   loops or shooting to memory */\n\t\t\tif (le32_to_cpu(dnode->first_free) > 2048) {\n\t\t\t\thpfs_error(s, \"dnode %08x has first_free == %08x\", secno, le32_to_cpu(dnode->first_free));\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tfor (p = 20; p < le32_to_cpu(dnode->first_free); p += d[p] + (d[p+1] << 8)) {\n\t\t\t\tstruct hpfs_dirent *de = (struct hpfs_dirent *)((char *)dnode + p);\n\t\t\t\tif (le16_to_cpu(de->length) > 292 || (le16_to_cpu(de->length) < 32) || (le16_to_cpu(de->length) & 3) || p + le16_to_cpu(de->length) > 2048) {\n\t\t\t\t\thpfs_error(s, \"bad dirent size in dnode %08x, dirent %03x, last %03x\", secno, p, pp);\n\t\t\t\t\tgoto bail;\n\t\t\t\t}\n\t\t\t\tif (((31 + de->namelen + de->down*4 + 3) & ~3) != le16_to_cpu(de->length)) {\n\t\t\t\t\tif (((31 + de->namelen + de->down*4 + 3) & ~3) < le16_to_cpu(de->length) && s->s_flags & MS_RDONLY) goto ok;\n\t\t\t\t\thpfs_error(s, \"namelen does not match dirent size in dnode %08x, dirent %03x, last %03x\", secno, p, pp);\n\t\t\t\t\tgoto bail;\n\t\t\t\t}\n\t\t\t\tok:\n\t\t\t\tif (hpfs_sb(s)->sb_chk >= 2) b |= 1 << de->down;\n\t\t\t\tif (de->down) if (de_down_pointer(de) < 0x10) {\n\t\t\t\t\thpfs_error(s, \"bad down pointer in dnode %08x, dirent %03x, last %03x\", secno, p, pp);\n\t\t\t\t\tgoto bail;\n\t\t\t\t}\n\t\t\t\tpp = p;\n\t\t\t\t\n\t\t\t}\n\t\t\tif (p != le32_to_cpu(dnode->first_free)) {\n\t\t\t\thpfs_error(s, \"size on last dirent does not match first_free; dnode %08x\", secno);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tif (d[pp + 30] != 1 || d[pp + 31] != 255) {\n\t\t\t\thpfs_error(s, \"dnode %08x does not end with \\\\377 entry\", secno);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tif (b == 3)\n\t\t\t\tpr_err(\"unbalanced dnode tree, dnode %08x; see hpfs.txt 4 more info\\n\",\n\t\t\t\t\tsecno);\n\t\t}\n\treturn dnode;\n\tbail:\n\thpfs_brelse4(qbh);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "name2"
          ],
          "line": 1030
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fnode_is_dir",
          "args": [
            "upf"
          ],
          "line": 1027
        },
        "resolved": true,
        "details": {
          "function_name": "fnode_is_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs.h",
          "lines": "480-483",
          "snippet": "static inline bool fnode_is_dir(struct fnode *p)\n{\n\treturn (p->flags & FNODE_dir) != 0;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline bool fnode_is_dir(struct fnode *p)\n{\n\treturn (p->flags & FNODE_dir) != 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "name2"
          ],
          "line": 1024
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hpfs_map_fnode",
          "args": [
            "s",
            "le32_to_cpu(f->up)",
            "&bh"
          ],
          "line": 1023
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_map_fnode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/map.c",
          "lines": "137-192",
          "snippet": "struct fnode *hpfs_map_fnode(struct super_block *s, ino_t ino, struct buffer_head **bhp)\n{\n\tstruct fnode *fnode;\n\tif (hpfs_sb(s)->sb_chk) if (hpfs_chk_sectors(s, ino, 1, \"fnode\")) {\n\t\treturn NULL;\n\t}\n\tif ((fnode = hpfs_map_sector(s, ino, bhp, FNODE_RD_AHEAD))) {\n\t\tif (hpfs_sb(s)->sb_chk) {\n\t\t\tstruct extended_attribute *ea;\n\t\t\tstruct extended_attribute *ea_end;\n\t\t\tif (le32_to_cpu(fnode->magic) != FNODE_MAGIC) {\n\t\t\t\thpfs_error(s, \"bad magic on fnode %08lx\",\n\t\t\t\t\t(unsigned long)ino);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tif (!fnode_is_dir(fnode)) {\n\t\t\t\tif ((unsigned)fnode->btree.n_used_nodes + (unsigned)fnode->btree.n_free_nodes !=\n\t\t\t\t    (bp_internal(&fnode->btree) ? 12 : 8)) {\n\t\t\t\t\thpfs_error(s,\n\t\t\t\t\t   \"bad number of nodes in fnode %08lx\",\n\t\t\t\t\t    (unsigned long)ino);\n\t\t\t\t\tgoto bail;\n\t\t\t\t}\n\t\t\t\tif (le16_to_cpu(fnode->btree.first_free) !=\n\t\t\t\t    8 + fnode->btree.n_used_nodes * (bp_internal(&fnode->btree) ? 8 : 12)) {\n\t\t\t\t\thpfs_error(s,\n\t\t\t\t\t    \"bad first_free pointer in fnode %08lx\",\n\t\t\t\t\t    (unsigned long)ino);\n\t\t\t\t\tgoto bail;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (le16_to_cpu(fnode->ea_size_s) && (le16_to_cpu(fnode->ea_offs) < 0xc4 ||\n\t\t\t   le16_to_cpu(fnode->ea_offs) + le16_to_cpu(fnode->acl_size_s) + le16_to_cpu(fnode->ea_size_s) > 0x200)) {\n\t\t\t\thpfs_error(s,\n\t\t\t\t\t\"bad EA info in fnode %08lx: ea_offs == %04x ea_size_s == %04x\",\n\t\t\t\t\t(unsigned long)ino,\n\t\t\t\t\tle16_to_cpu(fnode->ea_offs), le16_to_cpu(fnode->ea_size_s));\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tea = fnode_ea(fnode);\n\t\t\tea_end = fnode_end_ea(fnode);\n\t\t\twhile (ea != ea_end) {\n\t\t\t\tif (ea > ea_end) {\n\t\t\t\t\thpfs_error(s, \"bad EA in fnode %08lx\",\n\t\t\t\t\t\t(unsigned long)ino);\n\t\t\t\t\tgoto bail;\n\t\t\t\t}\n\t\t\t\tea = next_ea(ea);\n\t\t\t}\n\t\t}\n\t}\n\treturn fnode;\n\tbail:\n\tbrelse(*bhp);\n\treturn NULL;\n}",
          "includes": [
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n\nstruct fnode *hpfs_map_fnode(struct super_block *s, ino_t ino, struct buffer_head **bhp)\n{\n\tstruct fnode *fnode;\n\tif (hpfs_sb(s)->sb_chk) if (hpfs_chk_sectors(s, ino, 1, \"fnode\")) {\n\t\treturn NULL;\n\t}\n\tif ((fnode = hpfs_map_sector(s, ino, bhp, FNODE_RD_AHEAD))) {\n\t\tif (hpfs_sb(s)->sb_chk) {\n\t\t\tstruct extended_attribute *ea;\n\t\t\tstruct extended_attribute *ea_end;\n\t\t\tif (le32_to_cpu(fnode->magic) != FNODE_MAGIC) {\n\t\t\t\thpfs_error(s, \"bad magic on fnode %08lx\",\n\t\t\t\t\t(unsigned long)ino);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tif (!fnode_is_dir(fnode)) {\n\t\t\t\tif ((unsigned)fnode->btree.n_used_nodes + (unsigned)fnode->btree.n_free_nodes !=\n\t\t\t\t    (bp_internal(&fnode->btree) ? 12 : 8)) {\n\t\t\t\t\thpfs_error(s,\n\t\t\t\t\t   \"bad number of nodes in fnode %08lx\",\n\t\t\t\t\t    (unsigned long)ino);\n\t\t\t\t\tgoto bail;\n\t\t\t\t}\n\t\t\t\tif (le16_to_cpu(fnode->btree.first_free) !=\n\t\t\t\t    8 + fnode->btree.n_used_nodes * (bp_internal(&fnode->btree) ? 8 : 12)) {\n\t\t\t\t\thpfs_error(s,\n\t\t\t\t\t    \"bad first_free pointer in fnode %08lx\",\n\t\t\t\t\t    (unsigned long)ino);\n\t\t\t\t\tgoto bail;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (le16_to_cpu(fnode->ea_size_s) && (le16_to_cpu(fnode->ea_offs) < 0xc4 ||\n\t\t\t   le16_to_cpu(fnode->ea_offs) + le16_to_cpu(fnode->acl_size_s) + le16_to_cpu(fnode->ea_size_s) > 0x200)) {\n\t\t\t\thpfs_error(s,\n\t\t\t\t\t\"bad EA info in fnode %08lx: ea_offs == %04x ea_size_s == %04x\",\n\t\t\t\t\t(unsigned long)ino,\n\t\t\t\t\tle16_to_cpu(fnode->ea_offs), le16_to_cpu(fnode->ea_size_s));\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tea = fnode_ea(fnode);\n\t\t\tea_end = fnode_end_ea(fnode);\n\t\t\twhile (ea != ea_end) {\n\t\t\t\tif (ea > ea_end) {\n\t\t\t\t\thpfs_error(s, \"bad EA in fnode %08lx\",\n\t\t\t\t\t\t(unsigned long)ino);\n\t\t\t\t\tgoto bail;\n\t\t\t\t}\n\t\t\t\tea = next_ea(ea);\n\t\t\t}\n\t\t}\n\t}\n\treturn fnode;\n\tbail:\n\tbrelse(*bhp);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "name2 + 15",
            "0xff",
            "256 - 15"
          ],
          "line": 1019
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "name2",
            "name1",
            "15"
          ],
          "line": 1018
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "name2",
            "name1",
            "name1len = name2len = f->len"
          ],
          "line": 1016
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"out of memory, can't map dirent\\n\""
          ],
          "line": 1012
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "256",
            "GFP_NOFS"
          ],
          "line": 1011
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hpfs_fn.h\"\n\nstruct hpfs_dirent *map_fnode_dirent(struct super_block *s, fnode_secno fno,\n\t\t\t\t     struct fnode *f, struct quad_buffer_head *qbh)\n{\n\tunsigned char *name1;\n\tunsigned char *name2;\n\tint name1len, name2len;\n\tstruct dnode *d;\n\tdnode_secno dno, downd;\n\tstruct fnode *upf;\n\tstruct buffer_head *bh;\n\tstruct hpfs_dirent *de, *de_end;\n\tint c;\n\tint c1, c2 = 0;\n\tint d1, d2 = 0;\n\tname1 = f->name;\n\tif (!(name2 = kmalloc(256, GFP_NOFS))) {\n\t\tpr_err(\"out of memory, can't map dirent\\n\");\n\t\treturn NULL;\n\t}\n\tif (f->len <= 15)\n\t\tmemcpy(name2, name1, name1len = name2len = f->len);\n\telse {\n\t\tmemcpy(name2, name1, 15);\n\t\tmemset(name2 + 15, 0xff, 256 - 15);\n\t\t/*name2[15] = 0xff;*/\n\t\tname1len = 15; name2len = 256;\n\t}\n\tif (!(upf = hpfs_map_fnode(s, le32_to_cpu(f->up), &bh))) {\n\t\tkfree(name2);\n\t\treturn NULL;\n\t}\t\n\tif (!fnode_is_dir(upf)) {\n\t\tbrelse(bh);\n\t\thpfs_error(s, \"fnode %08x has non-directory parent %08x\", fno, le32_to_cpu(f->up));\n\t\tkfree(name2);\n\t\treturn NULL;\n\t}\n\tdno = le32_to_cpu(upf->u.external[0].disk_secno);\n\tbrelse(bh);\n\tgo_down:\n\tdownd = 0;\n\tgo_up:\n\tif (!(d = hpfs_map_dnode(s, dno, qbh))) {\n\t\tkfree(name2);\n\t\treturn NULL;\n\t}\n\tde_end = dnode_end_de(d);\n\tde = dnode_first_de(d);\n\tif (downd) {\n\t\twhile (de < de_end) {\n\t\t\tif (de->down) if (de_down_pointer(de) == downd) goto f;\n\t\t\tde = de_next_de(de);\n\t\t}\n\t\thpfs_error(s, \"pointer to dnode %08x not found in dnode %08x\", downd, dno);\n\t\thpfs_brelse4(qbh);\n\t\tkfree(name2);\n\t\treturn NULL;\n\t}\n\tnext_de:\n\tif (le32_to_cpu(de->fnode) == fno) {\n\t\tkfree(name2);\n\t\treturn de;\n\t}\n\tc = hpfs_compare_names(s, name1, name1len, de->name, de->namelen, de->last);\n\tif (c < 0 && de->down) {\n\t\tdno = de_down_pointer(de);\n\t\thpfs_brelse4(qbh);\n\t\tif (hpfs_sb(s)->sb_chk)\n\t\t\tif (hpfs_stop_cycles(s, dno, &c1, &c2, \"map_fnode_dirent #1\")) {\n\t\t\t\tkfree(name2);\n\t\t\t\treturn NULL;\n\t\t}\n\t\tgoto go_down;\n\t}\n\tf:\n\tif (le32_to_cpu(de->fnode) == fno) {\n\t\tkfree(name2);\n\t\treturn de;\n\t}\n\tc = hpfs_compare_names(s, name2, name2len, de->name, de->namelen, de->last);\n\tif (c < 0 && !de->last) goto not_found;\n\tif ((de = de_next_de(de)) < de_end) goto next_de;\n\tif (d->root_dnode) goto not_found;\n\tdownd = dno;\n\tdno = le32_to_cpu(d->up);\n\thpfs_brelse4(qbh);\n\tif (hpfs_sb(s)->sb_chk)\n\t\tif (hpfs_stop_cycles(s, downd, &d1, &d2, \"map_fnode_dirent #2\")) {\n\t\t\tkfree(name2);\n\t\t\treturn NULL;\n\t\t}\n\tgoto go_up;\n\tnot_found:\n\thpfs_brelse4(qbh);\n\thpfs_error(s, \"dirent for fnode %08x not found\", fno);\n\tkfree(name2);\n\treturn NULL;\n}"
  },
  {
    "function_name": "hpfs_remove_dtree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/dnode.c",
    "lines": "948-989",
    "snippet": "void hpfs_remove_dtree(struct super_block *s, dnode_secno dno)\n{\n\tstruct quad_buffer_head qbh;\n\tstruct dnode *dnode;\n\tstruct hpfs_dirent *de;\n\tdnode_secno d1, d2, rdno = dno;\n\twhile (1) {\n\t\tif (!(dnode = hpfs_map_dnode(s, dno, &qbh))) return;\n\t\tde = dnode_first_de(dnode);\n\t\tif (de->last) {\n\t\t\tif (de->down) d1 = de_down_pointer(de);\n\t\t\telse goto error;\n\t\t\thpfs_brelse4(&qbh);\n\t\t\thpfs_free_dnode(s, dno);\n\t\t\tdno = d1;\n\t\t} else break;\n\t}\n\tif (!de->first) goto error;\n\td1 = de->down ? de_down_pointer(de) : 0;\n\tde = de_next_de(de);\n\tif (!de->last) goto error;\n\td2 = de->down ? de_down_pointer(de) : 0;\n\thpfs_brelse4(&qbh);\n\thpfs_free_dnode(s, dno);\n\tdo {\n\t\twhile (d1) {\n\t\t\tif (!(dnode = hpfs_map_dnode(s, dno = d1, &qbh))) return;\n\t\t\tde = dnode_first_de(dnode);\n\t\t\tif (!de->last) goto error;\n\t\t\td1 = de->down ? de_down_pointer(de) : 0;\n\t\t\thpfs_brelse4(&qbh);\n\t\t\thpfs_free_dnode(s, dno);\n\t\t}\n\t\td1 = d2;\n\t\td2 = 0;\n\t} while (d1);\n\treturn;\n\terror:\n\thpfs_brelse4(&qbh);\n\thpfs_free_dnode(s, dno);\n\thpfs_error(s, \"directory %08x is corrupted or not empty\", rdno);\n}",
    "includes": [
      "#include \"hpfs_fn.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hpfs_error",
          "args": [
            "s",
            "\"directory %08x is corrupted or not empty\"",
            "rdno"
          ],
          "line": 988
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/super.c",
          "lines": "57-86",
          "snippet": "void hpfs_error(struct super_block *s, const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvsnprintf(err_buf, sizeof(err_buf), fmt, args);\n\tva_end(args);\n\n\tpr_err(\"filesystem error: %s\", err_buf);\n\tif (!hpfs_sb(s)->sb_was_error) {\n\t\tif (hpfs_sb(s)->sb_err == 2) {\n\t\t\tpr_cont(\"; crashing the system because you wanted it\\n\");\n\t\t\tmark_dirty(s, 0);\n\t\t\tpanic(\"HPFS panic\");\n\t\t} else if (hpfs_sb(s)->sb_err == 1) {\n\t\t\tif (s->s_flags & MS_RDONLY)\n\t\t\t\tpr_cont(\"; already mounted read-only\\n\");\n\t\t\telse {\n\t\t\t\tpr_cont(\"; remounting read-only\\n\");\n\t\t\t\tmark_dirty(s, 0);\n\t\t\t\ts->s_flags |= MS_RDONLY;\n\t\t\t}\n\t\t} else if (s->s_flags & MS_RDONLY)\n\t\t\t\tpr_cont(\"; going on - but anything won't be destroyed because it's read-only\\n\");\n\t\telse\n\t\t\tpr_cont(\"; corrupted filesystem mounted read/write - your computer will explode within 20 seconds ... but you wanted it so!\\n\");\n\t} else\n\t\tpr_cont(\"\\n\");\n\thpfs_sb(s)->sb_was_error = 1;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/sched.h>",
            "#include <linux/magic.h>",
            "#include <linux/statfs.h>",
            "#include <linux/init.h>",
            "#include <linux/parser.h>",
            "#include <linux/module.h>",
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static char err_buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/bitmap.h>\n#include <linux/sched.h>\n#include <linux/magic.h>\n#include <linux/statfs.h>\n#include <linux/init.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include \"hpfs_fn.h\"\n\nstatic char err_buf[1024];\n\nvoid hpfs_error(struct super_block *s, const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvsnprintf(err_buf, sizeof(err_buf), fmt, args);\n\tva_end(args);\n\n\tpr_err(\"filesystem error: %s\", err_buf);\n\tif (!hpfs_sb(s)->sb_was_error) {\n\t\tif (hpfs_sb(s)->sb_err == 2) {\n\t\t\tpr_cont(\"; crashing the system because you wanted it\\n\");\n\t\t\tmark_dirty(s, 0);\n\t\t\tpanic(\"HPFS panic\");\n\t\t} else if (hpfs_sb(s)->sb_err == 1) {\n\t\t\tif (s->s_flags & MS_RDONLY)\n\t\t\t\tpr_cont(\"; already mounted read-only\\n\");\n\t\t\telse {\n\t\t\t\tpr_cont(\"; remounting read-only\\n\");\n\t\t\t\tmark_dirty(s, 0);\n\t\t\t\ts->s_flags |= MS_RDONLY;\n\t\t\t}\n\t\t} else if (s->s_flags & MS_RDONLY)\n\t\t\t\tpr_cont(\"; going on - but anything won't be destroyed because it's read-only\\n\");\n\t\telse\n\t\t\tpr_cont(\"; corrupted filesystem mounted read/write - your computer will explode within 20 seconds ... but you wanted it so!\\n\");\n\t} else\n\t\tpr_cont(\"\\n\");\n\thpfs_sb(s)->sb_was_error = 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_free_dnode",
          "args": [
            "s",
            "dno"
          ],
          "line": 987
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_free_dnode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/alloc.c",
          "lines": "404-425",
          "snippet": "void hpfs_free_dnode(struct super_block *s, dnode_secno dno)\n{\n\tif (hpfs_sb(s)->sb_chk) if (dno & 3) {\n\t\thpfs_error(s, \"hpfs_free_dnode: dnode %08x not aligned\", dno);\n\t\treturn;\n\t}\n\tif (dno < hpfs_sb(s)->sb_dirband_start ||\n\t    dno >= hpfs_sb(s)->sb_dirband_start + hpfs_sb(s)->sb_dirband_size) {\n\t\thpfs_free_sectors(s, dno, 4);\n\t} else {\n\t\tstruct quad_buffer_head qbh;\n\t\t__le32 *bmp;\n\t\tunsigned ssec = (dno - hpfs_sb(s)->sb_dirband_start) / 4;\n\t\tif (!(bmp = hpfs_map_dnode_bitmap(s, &qbh))) {\n\t\t\treturn;\n\t\t}\n\t\tbmp[ssec >> 5] |= cpu_to_le32(1 << (ssec & 0x1f));\n\t\thpfs_mark_4buffers_dirty(&qbh);\n\t\thpfs_brelse4(&qbh);\n\t\thpfs_claim_dirband_free(s, dno);\n\t}\n}",
          "includes": [
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n\nvoid hpfs_free_dnode(struct super_block *s, dnode_secno dno)\n{\n\tif (hpfs_sb(s)->sb_chk) if (dno & 3) {\n\t\thpfs_error(s, \"hpfs_free_dnode: dnode %08x not aligned\", dno);\n\t\treturn;\n\t}\n\tif (dno < hpfs_sb(s)->sb_dirband_start ||\n\t    dno >= hpfs_sb(s)->sb_dirband_start + hpfs_sb(s)->sb_dirband_size) {\n\t\thpfs_free_sectors(s, dno, 4);\n\t} else {\n\t\tstruct quad_buffer_head qbh;\n\t\t__le32 *bmp;\n\t\tunsigned ssec = (dno - hpfs_sb(s)->sb_dirband_start) / 4;\n\t\tif (!(bmp = hpfs_map_dnode_bitmap(s, &qbh))) {\n\t\t\treturn;\n\t\t}\n\t\tbmp[ssec >> 5] |= cpu_to_le32(1 << (ssec & 0x1f));\n\t\thpfs_mark_4buffers_dirty(&qbh);\n\t\thpfs_brelse4(&qbh);\n\t\thpfs_claim_dirband_free(s, dno);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_brelse4",
          "args": [
            "&qbh"
          ],
          "line": 986
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_brelse4",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/buffer.c",
          "lines": "182-190",
          "snippet": "void hpfs_brelse4(struct quad_buffer_head *qbh)\n{\n\tif (unlikely(qbh->data != qbh->bh[0]->b_data))\n\t\tkfree(qbh->data);\n\tbrelse(qbh->bh[0]);\n\tbrelse(qbh->bh[1]);\n\tbrelse(qbh->bh[2]);\n\tbrelse(qbh->bh[3]);\n}",
          "includes": [
            "#include \"hpfs_fn.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid hpfs_brelse4(struct quad_buffer_head *qbh)\n{\n\tif (unlikely(qbh->data != qbh->bh[0]->b_data))\n\t\tkfree(qbh->data);\n\tbrelse(qbh->bh[0]);\n\tbrelse(qbh->bh[1]);\n\tbrelse(qbh->bh[2]);\n\tbrelse(qbh->bh[3]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "de_down_pointer",
          "args": [
            "de"
          ],
          "line": 977
        },
        "resolved": true,
        "details": {
          "function_name": "de_down_pointer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "100-104",
          "snippet": "static inline dnode_secno de_down_pointer (struct hpfs_dirent *de)\n{\n  CHKCOND(de->down,(\"HPFS: de_down_pointer: !de->down\\n\"));\n  return le32_to_cpu(*(__le32 *) ((void *) de + le16_to_cpu(de->length) - 4));\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_add_dirent(struct inode *, const unsigned char *, unsigned,\n\t\t    struct hpfs_dirent *);",
            "void hpfs_count_dnodes(struct super_block *, dnode_secno, int *, int *, int *);",
            "void hpfs_remove_dtree(struct super_block *, dnode_secno);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_add_dirent(struct inode *, const unsigned char *, unsigned,\n\t\t    struct hpfs_dirent *);\nvoid hpfs_count_dnodes(struct super_block *, dnode_secno, int *, int *, int *);\nvoid hpfs_remove_dtree(struct super_block *, dnode_secno);\n\nstatic inline dnode_secno de_down_pointer (struct hpfs_dirent *de)\n{\n  CHKCOND(de->down,(\"HPFS: de_down_pointer: !de->down\\n\"));\n  return le32_to_cpu(*(__le32 *) ((void *) de + le16_to_cpu(de->length) - 4));\n}"
        }
      },
      {
        "call_info": {
          "callee": "dnode_first_de",
          "args": [
            "dnode"
          ],
          "line": 975
        },
        "resolved": true,
        "details": {
          "function_name": "dnode_first_de",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "108-111",
          "snippet": "static inline struct hpfs_dirent *dnode_first_de (struct dnode *dnode)\n{\n  return (void *) dnode->dirent;\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_add_dirent(struct inode *, const unsigned char *, unsigned,\n\t\t    struct hpfs_dirent *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_add_dirent(struct inode *, const unsigned char *, unsigned,\n\t\t    struct hpfs_dirent *);\n\nstatic inline struct hpfs_dirent *dnode_first_de (struct dnode *dnode)\n{\n  return (void *) dnode->dirent;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_map_dnode",
          "args": [
            "s",
            "dno = d1",
            "&qbh"
          ],
          "line": 974
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_map_dnode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/map.c",
          "lines": "229-293",
          "snippet": "struct dnode *hpfs_map_dnode(struct super_block *s, unsigned secno,\n\t\t\t     struct quad_buffer_head *qbh)\n{\n\tstruct dnode *dnode;\n\tif (hpfs_sb(s)->sb_chk) {\n\t\tif (hpfs_chk_sectors(s, secno, 4, \"dnode\")) return NULL;\n\t\tif (secno & 3) {\n\t\t\thpfs_error(s, \"dnode %08x not byte-aligned\", secno);\n\t\t\treturn NULL;\n\t\t}\t\n\t}\n\tif ((dnode = hpfs_map_4sectors(s, secno, qbh, DNODE_RD_AHEAD)))\n\t\tif (hpfs_sb(s)->sb_chk) {\n\t\t\tunsigned p, pp = 0;\n\t\t\tunsigned char *d = (unsigned char *)dnode;\n\t\t\tint b = 0;\n\t\t\tif (le32_to_cpu(dnode->magic) != DNODE_MAGIC) {\n\t\t\t\thpfs_error(s, \"bad magic on dnode %08x\", secno);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tif (le32_to_cpu(dnode->self) != secno)\n\t\t\t\thpfs_error(s, \"bad self pointer on dnode %08x self = %08x\", secno, le32_to_cpu(dnode->self));\n\t\t\t/* Check dirents - bad dirents would cause infinite\n\t\t\t   loops or shooting to memory */\n\t\t\tif (le32_to_cpu(dnode->first_free) > 2048) {\n\t\t\t\thpfs_error(s, \"dnode %08x has first_free == %08x\", secno, le32_to_cpu(dnode->first_free));\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tfor (p = 20; p < le32_to_cpu(dnode->first_free); p += d[p] + (d[p+1] << 8)) {\n\t\t\t\tstruct hpfs_dirent *de = (struct hpfs_dirent *)((char *)dnode + p);\n\t\t\t\tif (le16_to_cpu(de->length) > 292 || (le16_to_cpu(de->length) < 32) || (le16_to_cpu(de->length) & 3) || p + le16_to_cpu(de->length) > 2048) {\n\t\t\t\t\thpfs_error(s, \"bad dirent size in dnode %08x, dirent %03x, last %03x\", secno, p, pp);\n\t\t\t\t\tgoto bail;\n\t\t\t\t}\n\t\t\t\tif (((31 + de->namelen + de->down*4 + 3) & ~3) != le16_to_cpu(de->length)) {\n\t\t\t\t\tif (((31 + de->namelen + de->down*4 + 3) & ~3) < le16_to_cpu(de->length) && s->s_flags & MS_RDONLY) goto ok;\n\t\t\t\t\thpfs_error(s, \"namelen does not match dirent size in dnode %08x, dirent %03x, last %03x\", secno, p, pp);\n\t\t\t\t\tgoto bail;\n\t\t\t\t}\n\t\t\t\tok:\n\t\t\t\tif (hpfs_sb(s)->sb_chk >= 2) b |= 1 << de->down;\n\t\t\t\tif (de->down) if (de_down_pointer(de) < 0x10) {\n\t\t\t\t\thpfs_error(s, \"bad down pointer in dnode %08x, dirent %03x, last %03x\", secno, p, pp);\n\t\t\t\t\tgoto bail;\n\t\t\t\t}\n\t\t\t\tpp = p;\n\t\t\t\t\n\t\t\t}\n\t\t\tif (p != le32_to_cpu(dnode->first_free)) {\n\t\t\t\thpfs_error(s, \"size on last dirent does not match first_free; dnode %08x\", secno);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tif (d[pp + 30] != 1 || d[pp + 31] != 255) {\n\t\t\t\thpfs_error(s, \"dnode %08x does not end with \\\\377 entry\", secno);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tif (b == 3)\n\t\t\t\tpr_err(\"unbalanced dnode tree, dnode %08x; see hpfs.txt 4 more info\\n\",\n\t\t\t\t\tsecno);\n\t\t}\n\treturn dnode;\n\tbail:\n\thpfs_brelse4(qbh);\n\treturn NULL;\n}",
          "includes": [
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n\nstruct dnode *hpfs_map_dnode(struct super_block *s, unsigned secno,\n\t\t\t     struct quad_buffer_head *qbh)\n{\n\tstruct dnode *dnode;\n\tif (hpfs_sb(s)->sb_chk) {\n\t\tif (hpfs_chk_sectors(s, secno, 4, \"dnode\")) return NULL;\n\t\tif (secno & 3) {\n\t\t\thpfs_error(s, \"dnode %08x not byte-aligned\", secno);\n\t\t\treturn NULL;\n\t\t}\t\n\t}\n\tif ((dnode = hpfs_map_4sectors(s, secno, qbh, DNODE_RD_AHEAD)))\n\t\tif (hpfs_sb(s)->sb_chk) {\n\t\t\tunsigned p, pp = 0;\n\t\t\tunsigned char *d = (unsigned char *)dnode;\n\t\t\tint b = 0;\n\t\t\tif (le32_to_cpu(dnode->magic) != DNODE_MAGIC) {\n\t\t\t\thpfs_error(s, \"bad magic on dnode %08x\", secno);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tif (le32_to_cpu(dnode->self) != secno)\n\t\t\t\thpfs_error(s, \"bad self pointer on dnode %08x self = %08x\", secno, le32_to_cpu(dnode->self));\n\t\t\t/* Check dirents - bad dirents would cause infinite\n\t\t\t   loops or shooting to memory */\n\t\t\tif (le32_to_cpu(dnode->first_free) > 2048) {\n\t\t\t\thpfs_error(s, \"dnode %08x has first_free == %08x\", secno, le32_to_cpu(dnode->first_free));\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tfor (p = 20; p < le32_to_cpu(dnode->first_free); p += d[p] + (d[p+1] << 8)) {\n\t\t\t\tstruct hpfs_dirent *de = (struct hpfs_dirent *)((char *)dnode + p);\n\t\t\t\tif (le16_to_cpu(de->length) > 292 || (le16_to_cpu(de->length) < 32) || (le16_to_cpu(de->length) & 3) || p + le16_to_cpu(de->length) > 2048) {\n\t\t\t\t\thpfs_error(s, \"bad dirent size in dnode %08x, dirent %03x, last %03x\", secno, p, pp);\n\t\t\t\t\tgoto bail;\n\t\t\t\t}\n\t\t\t\tif (((31 + de->namelen + de->down*4 + 3) & ~3) != le16_to_cpu(de->length)) {\n\t\t\t\t\tif (((31 + de->namelen + de->down*4 + 3) & ~3) < le16_to_cpu(de->length) && s->s_flags & MS_RDONLY) goto ok;\n\t\t\t\t\thpfs_error(s, \"namelen does not match dirent size in dnode %08x, dirent %03x, last %03x\", secno, p, pp);\n\t\t\t\t\tgoto bail;\n\t\t\t\t}\n\t\t\t\tok:\n\t\t\t\tif (hpfs_sb(s)->sb_chk >= 2) b |= 1 << de->down;\n\t\t\t\tif (de->down) if (de_down_pointer(de) < 0x10) {\n\t\t\t\t\thpfs_error(s, \"bad down pointer in dnode %08x, dirent %03x, last %03x\", secno, p, pp);\n\t\t\t\t\tgoto bail;\n\t\t\t\t}\n\t\t\t\tpp = p;\n\t\t\t\t\n\t\t\t}\n\t\t\tif (p != le32_to_cpu(dnode->first_free)) {\n\t\t\t\thpfs_error(s, \"size on last dirent does not match first_free; dnode %08x\", secno);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tif (d[pp + 30] != 1 || d[pp + 31] != 255) {\n\t\t\t\thpfs_error(s, \"dnode %08x does not end with \\\\377 entry\", secno);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tif (b == 3)\n\t\t\t\tpr_err(\"unbalanced dnode tree, dnode %08x; see hpfs.txt 4 more info\\n\",\n\t\t\t\t\tsecno);\n\t\t}\n\treturn dnode;\n\tbail:\n\thpfs_brelse4(qbh);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "de_next_de",
          "args": [
            "de"
          ],
          "line": 967
        },
        "resolved": true,
        "details": {
          "function_name": "de_next_de",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "123-127",
          "snippet": "static inline struct hpfs_dirent *de_next_de (struct hpfs_dirent *de)\n{\n  CHKCOND(le16_to_cpu(de->length)>=0x20 && le16_to_cpu(de->length)<0x800,(\"HPFS: de_next_de: de->length = %x\\n\",(unsigned)le16_to_cpu(de->length)));\n  return (void *) de + le16_to_cpu(de->length);\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_add_dirent(struct inode *, const unsigned char *, unsigned,\n\t\t    struct hpfs_dirent *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_add_dirent(struct inode *, const unsigned char *, unsigned,\n\t\t    struct hpfs_dirent *);\n\nstatic inline struct hpfs_dirent *de_next_de (struct hpfs_dirent *de)\n{\n  CHKCOND(le16_to_cpu(de->length)>=0x20 && le16_to_cpu(de->length)<0x800,(\"HPFS: de_next_de: de->length = %x\\n\",(unsigned)le16_to_cpu(de->length)));\n  return (void *) de + le16_to_cpu(de->length);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hpfs_fn.h\"\n\nvoid hpfs_remove_dtree(struct super_block *s, dnode_secno dno)\n{\n\tstruct quad_buffer_head qbh;\n\tstruct dnode *dnode;\n\tstruct hpfs_dirent *de;\n\tdnode_secno d1, d2, rdno = dno;\n\twhile (1) {\n\t\tif (!(dnode = hpfs_map_dnode(s, dno, &qbh))) return;\n\t\tde = dnode_first_de(dnode);\n\t\tif (de->last) {\n\t\t\tif (de->down) d1 = de_down_pointer(de);\n\t\t\telse goto error;\n\t\t\thpfs_brelse4(&qbh);\n\t\t\thpfs_free_dnode(s, dno);\n\t\t\tdno = d1;\n\t\t} else break;\n\t}\n\tif (!de->first) goto error;\n\td1 = de->down ? de_down_pointer(de) : 0;\n\tde = de_next_de(de);\n\tif (!de->last) goto error;\n\td2 = de->down ? de_down_pointer(de) : 0;\n\thpfs_brelse4(&qbh);\n\thpfs_free_dnode(s, dno);\n\tdo {\n\t\twhile (d1) {\n\t\t\tif (!(dnode = hpfs_map_dnode(s, dno = d1, &qbh))) return;\n\t\t\tde = dnode_first_de(dnode);\n\t\t\tif (!de->last) goto error;\n\t\t\td1 = de->down ? de_down_pointer(de) : 0;\n\t\t\thpfs_brelse4(&qbh);\n\t\t\thpfs_free_dnode(s, dno);\n\t\t}\n\t\td1 = d2;\n\t\td2 = 0;\n\t} while (d1);\n\treturn;\n\terror:\n\thpfs_brelse4(&qbh);\n\thpfs_free_dnode(s, dno);\n\thpfs_error(s, \"directory %08x is corrupted or not empty\", rdno);\n}"
  },
  {
    "function_name": "map_dirent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/dnode.c",
    "lines": "907-940",
    "snippet": "struct hpfs_dirent *map_dirent(struct inode *inode, dnode_secno dno,\n\t\t\t       const unsigned char *name, unsigned len,\n\t\t\t       dnode_secno *dd, struct quad_buffer_head *qbh)\n{\n\tstruct dnode *dnode;\n\tstruct hpfs_dirent *de;\n\tstruct hpfs_dirent *de_end;\n\tint c1, c2 = 0;\n\n\tif (!S_ISDIR(inode->i_mode)) hpfs_error(inode->i_sb, \"map_dirent: not a directory\\n\");\n\tagain:\n\tif (hpfs_sb(inode->i_sb)->sb_chk)\n\t\tif (hpfs_stop_cycles(inode->i_sb, dno, &c1, &c2, \"map_dirent\")) return NULL;\n\tif (!(dnode = hpfs_map_dnode(inode->i_sb, dno, qbh))) return NULL;\n\t\n\tde_end = dnode_end_de(dnode);\n\tfor (de = dnode_first_de(dnode); de < de_end; de = de_next_de(de)) {\n\t\tint t = hpfs_compare_names(inode->i_sb, name, len, de->name, de->namelen, de->last);\n\t\tif (!t) {\n\t\t\tif (dd) *dd = dno;\n\t\t\treturn de;\n\t\t}\n\t\tif (t < 0) {\n\t\t\tif (de->down) {\n\t\t\t\tdno = de_down_pointer(de);\n\t\t\t\thpfs_brelse4(qbh);\n\t\t\t\tgoto again;\n\t\t\t}\n\t\tbreak;\n\t\t}\n\t}\n\thpfs_brelse4(qbh);\n\treturn NULL;\n}",
    "includes": [
      "#include \"hpfs_fn.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hpfs_brelse4",
          "args": [
            "qbh"
          ],
          "line": 938
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_brelse4",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/buffer.c",
          "lines": "182-190",
          "snippet": "void hpfs_brelse4(struct quad_buffer_head *qbh)\n{\n\tif (unlikely(qbh->data != qbh->bh[0]->b_data))\n\t\tkfree(qbh->data);\n\tbrelse(qbh->bh[0]);\n\tbrelse(qbh->bh[1]);\n\tbrelse(qbh->bh[2]);\n\tbrelse(qbh->bh[3]);\n}",
          "includes": [
            "#include \"hpfs_fn.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid hpfs_brelse4(struct quad_buffer_head *qbh)\n{\n\tif (unlikely(qbh->data != qbh->bh[0]->b_data))\n\t\tkfree(qbh->data);\n\tbrelse(qbh->bh[0]);\n\tbrelse(qbh->bh[1]);\n\tbrelse(qbh->bh[2]);\n\tbrelse(qbh->bh[3]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "de_down_pointer",
          "args": [
            "de"
          ],
          "line": 931
        },
        "resolved": true,
        "details": {
          "function_name": "de_down_pointer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "100-104",
          "snippet": "static inline dnode_secno de_down_pointer (struct hpfs_dirent *de)\n{\n  CHKCOND(de->down,(\"HPFS: de_down_pointer: !de->down\\n\"));\n  return le32_to_cpu(*(__le32 *) ((void *) de + le16_to_cpu(de->length) - 4));\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_add_dirent(struct inode *, const unsigned char *, unsigned,\n\t\t    struct hpfs_dirent *);",
            "void hpfs_count_dnodes(struct super_block *, dnode_secno, int *, int *, int *);",
            "void hpfs_remove_dtree(struct super_block *, dnode_secno);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_add_dirent(struct inode *, const unsigned char *, unsigned,\n\t\t    struct hpfs_dirent *);\nvoid hpfs_count_dnodes(struct super_block *, dnode_secno, int *, int *, int *);\nvoid hpfs_remove_dtree(struct super_block *, dnode_secno);\n\nstatic inline dnode_secno de_down_pointer (struct hpfs_dirent *de)\n{\n  CHKCOND(de->down,(\"HPFS: de_down_pointer: !de->down\\n\"));\n  return le32_to_cpu(*(__le32 *) ((void *) de + le16_to_cpu(de->length) - 4));\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_compare_names",
          "args": [
            "inode->i_sb",
            "name",
            "len",
            "de->name",
            "de->namelen",
            "de->last"
          ],
          "line": 924
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_compare_names",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/name.c",
          "lines": "74-90",
          "snippet": "int hpfs_compare_names(struct super_block *s,\n\t\t       const unsigned char *n1, unsigned l1,\n\t\t       const unsigned char *n2, unsigned l2, int last)\n{\n\tunsigned l = l1 < l2 ? l1 : l2;\n\tunsigned i;\n\tif (last) return -1;\n\tfor (i = 0; i < l; i++) {\n\t\tunsigned char c1 = upcase(hpfs_sb(s)->sb_cp_table,n1[i]);\n\t\tunsigned char c2 = upcase(hpfs_sb(s)->sb_cp_table,n2[i]);\n\t\tif (c1 < c2) return -1;\n\t\tif (c1 > c2) return 1;\n\t}\n\tif (l1 < l2) return -1;\n\tif (l1 > l2) return 1;\n\treturn 0;\n}",
          "includes": [
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n\nint hpfs_compare_names(struct super_block *s,\n\t\t       const unsigned char *n1, unsigned l1,\n\t\t       const unsigned char *n2, unsigned l2, int last)\n{\n\tunsigned l = l1 < l2 ? l1 : l2;\n\tunsigned i;\n\tif (last) return -1;\n\tfor (i = 0; i < l; i++) {\n\t\tunsigned char c1 = upcase(hpfs_sb(s)->sb_cp_table,n1[i]);\n\t\tunsigned char c2 = upcase(hpfs_sb(s)->sb_cp_table,n2[i]);\n\t\tif (c1 < c2) return -1;\n\t\tif (c1 > c2) return 1;\n\t}\n\tif (l1 < l2) return -1;\n\tif (l1 > l2) return 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "de_next_de",
          "args": [
            "de"
          ],
          "line": 923
        },
        "resolved": true,
        "details": {
          "function_name": "de_next_de",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "123-127",
          "snippet": "static inline struct hpfs_dirent *de_next_de (struct hpfs_dirent *de)\n{\n  CHKCOND(le16_to_cpu(de->length)>=0x20 && le16_to_cpu(de->length)<0x800,(\"HPFS: de_next_de: de->length = %x\\n\",(unsigned)le16_to_cpu(de->length)));\n  return (void *) de + le16_to_cpu(de->length);\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_add_dirent(struct inode *, const unsigned char *, unsigned,\n\t\t    struct hpfs_dirent *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_add_dirent(struct inode *, const unsigned char *, unsigned,\n\t\t    struct hpfs_dirent *);\n\nstatic inline struct hpfs_dirent *de_next_de (struct hpfs_dirent *de)\n{\n  CHKCOND(le16_to_cpu(de->length)>=0x20 && le16_to_cpu(de->length)<0x800,(\"HPFS: de_next_de: de->length = %x\\n\",(unsigned)le16_to_cpu(de->length)));\n  return (void *) de + le16_to_cpu(de->length);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dnode_first_de",
          "args": [
            "dnode"
          ],
          "line": 923
        },
        "resolved": true,
        "details": {
          "function_name": "dnode_first_de",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "108-111",
          "snippet": "static inline struct hpfs_dirent *dnode_first_de (struct dnode *dnode)\n{\n  return (void *) dnode->dirent;\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_add_dirent(struct inode *, const unsigned char *, unsigned,\n\t\t    struct hpfs_dirent *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_add_dirent(struct inode *, const unsigned char *, unsigned,\n\t\t    struct hpfs_dirent *);\n\nstatic inline struct hpfs_dirent *dnode_first_de (struct dnode *dnode)\n{\n  return (void *) dnode->dirent;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dnode_end_de",
          "args": [
            "dnode"
          ],
          "line": 922
        },
        "resolved": true,
        "details": {
          "function_name": "dnode_end_de",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "115-119",
          "snippet": "static inline struct hpfs_dirent *dnode_end_de (struct dnode *dnode)\n{\n  CHKCOND(le32_to_cpu(dnode->first_free)>=0x14 && le32_to_cpu(dnode->first_free)<=0xa00,(\"HPFS: dnode_end_de: dnode->first_free = %x\\n\",(unsigned)le32_to_cpu(dnode->first_free)));\n  return (void *) dnode + le32_to_cpu(dnode->first_free);\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_add_dirent(struct inode *, const unsigned char *, unsigned,\n\t\t    struct hpfs_dirent *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_add_dirent(struct inode *, const unsigned char *, unsigned,\n\t\t    struct hpfs_dirent *);\n\nstatic inline struct hpfs_dirent *dnode_end_de (struct dnode *dnode)\n{\n  CHKCOND(le32_to_cpu(dnode->first_free)>=0x14 && le32_to_cpu(dnode->first_free)<=0xa00,(\"HPFS: dnode_end_de: dnode->first_free = %x\\n\",(unsigned)le32_to_cpu(dnode->first_free)));\n  return (void *) dnode + le32_to_cpu(dnode->first_free);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_map_dnode",
          "args": [
            "inode->i_sb",
            "dno",
            "qbh"
          ],
          "line": 920
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_map_dnode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/map.c",
          "lines": "229-293",
          "snippet": "struct dnode *hpfs_map_dnode(struct super_block *s, unsigned secno,\n\t\t\t     struct quad_buffer_head *qbh)\n{\n\tstruct dnode *dnode;\n\tif (hpfs_sb(s)->sb_chk) {\n\t\tif (hpfs_chk_sectors(s, secno, 4, \"dnode\")) return NULL;\n\t\tif (secno & 3) {\n\t\t\thpfs_error(s, \"dnode %08x not byte-aligned\", secno);\n\t\t\treturn NULL;\n\t\t}\t\n\t}\n\tif ((dnode = hpfs_map_4sectors(s, secno, qbh, DNODE_RD_AHEAD)))\n\t\tif (hpfs_sb(s)->sb_chk) {\n\t\t\tunsigned p, pp = 0;\n\t\t\tunsigned char *d = (unsigned char *)dnode;\n\t\t\tint b = 0;\n\t\t\tif (le32_to_cpu(dnode->magic) != DNODE_MAGIC) {\n\t\t\t\thpfs_error(s, \"bad magic on dnode %08x\", secno);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tif (le32_to_cpu(dnode->self) != secno)\n\t\t\t\thpfs_error(s, \"bad self pointer on dnode %08x self = %08x\", secno, le32_to_cpu(dnode->self));\n\t\t\t/* Check dirents - bad dirents would cause infinite\n\t\t\t   loops or shooting to memory */\n\t\t\tif (le32_to_cpu(dnode->first_free) > 2048) {\n\t\t\t\thpfs_error(s, \"dnode %08x has first_free == %08x\", secno, le32_to_cpu(dnode->first_free));\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tfor (p = 20; p < le32_to_cpu(dnode->first_free); p += d[p] + (d[p+1] << 8)) {\n\t\t\t\tstruct hpfs_dirent *de = (struct hpfs_dirent *)((char *)dnode + p);\n\t\t\t\tif (le16_to_cpu(de->length) > 292 || (le16_to_cpu(de->length) < 32) || (le16_to_cpu(de->length) & 3) || p + le16_to_cpu(de->length) > 2048) {\n\t\t\t\t\thpfs_error(s, \"bad dirent size in dnode %08x, dirent %03x, last %03x\", secno, p, pp);\n\t\t\t\t\tgoto bail;\n\t\t\t\t}\n\t\t\t\tif (((31 + de->namelen + de->down*4 + 3) & ~3) != le16_to_cpu(de->length)) {\n\t\t\t\t\tif (((31 + de->namelen + de->down*4 + 3) & ~3) < le16_to_cpu(de->length) && s->s_flags & MS_RDONLY) goto ok;\n\t\t\t\t\thpfs_error(s, \"namelen does not match dirent size in dnode %08x, dirent %03x, last %03x\", secno, p, pp);\n\t\t\t\t\tgoto bail;\n\t\t\t\t}\n\t\t\t\tok:\n\t\t\t\tif (hpfs_sb(s)->sb_chk >= 2) b |= 1 << de->down;\n\t\t\t\tif (de->down) if (de_down_pointer(de) < 0x10) {\n\t\t\t\t\thpfs_error(s, \"bad down pointer in dnode %08x, dirent %03x, last %03x\", secno, p, pp);\n\t\t\t\t\tgoto bail;\n\t\t\t\t}\n\t\t\t\tpp = p;\n\t\t\t\t\n\t\t\t}\n\t\t\tif (p != le32_to_cpu(dnode->first_free)) {\n\t\t\t\thpfs_error(s, \"size on last dirent does not match first_free; dnode %08x\", secno);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tif (d[pp + 30] != 1 || d[pp + 31] != 255) {\n\t\t\t\thpfs_error(s, \"dnode %08x does not end with \\\\377 entry\", secno);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tif (b == 3)\n\t\t\t\tpr_err(\"unbalanced dnode tree, dnode %08x; see hpfs.txt 4 more info\\n\",\n\t\t\t\t\tsecno);\n\t\t}\n\treturn dnode;\n\tbail:\n\thpfs_brelse4(qbh);\n\treturn NULL;\n}",
          "includes": [
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n\nstruct dnode *hpfs_map_dnode(struct super_block *s, unsigned secno,\n\t\t\t     struct quad_buffer_head *qbh)\n{\n\tstruct dnode *dnode;\n\tif (hpfs_sb(s)->sb_chk) {\n\t\tif (hpfs_chk_sectors(s, secno, 4, \"dnode\")) return NULL;\n\t\tif (secno & 3) {\n\t\t\thpfs_error(s, \"dnode %08x not byte-aligned\", secno);\n\t\t\treturn NULL;\n\t\t}\t\n\t}\n\tif ((dnode = hpfs_map_4sectors(s, secno, qbh, DNODE_RD_AHEAD)))\n\t\tif (hpfs_sb(s)->sb_chk) {\n\t\t\tunsigned p, pp = 0;\n\t\t\tunsigned char *d = (unsigned char *)dnode;\n\t\t\tint b = 0;\n\t\t\tif (le32_to_cpu(dnode->magic) != DNODE_MAGIC) {\n\t\t\t\thpfs_error(s, \"bad magic on dnode %08x\", secno);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tif (le32_to_cpu(dnode->self) != secno)\n\t\t\t\thpfs_error(s, \"bad self pointer on dnode %08x self = %08x\", secno, le32_to_cpu(dnode->self));\n\t\t\t/* Check dirents - bad dirents would cause infinite\n\t\t\t   loops or shooting to memory */\n\t\t\tif (le32_to_cpu(dnode->first_free) > 2048) {\n\t\t\t\thpfs_error(s, \"dnode %08x has first_free == %08x\", secno, le32_to_cpu(dnode->first_free));\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tfor (p = 20; p < le32_to_cpu(dnode->first_free); p += d[p] + (d[p+1] << 8)) {\n\t\t\t\tstruct hpfs_dirent *de = (struct hpfs_dirent *)((char *)dnode + p);\n\t\t\t\tif (le16_to_cpu(de->length) > 292 || (le16_to_cpu(de->length) < 32) || (le16_to_cpu(de->length) & 3) || p + le16_to_cpu(de->length) > 2048) {\n\t\t\t\t\thpfs_error(s, \"bad dirent size in dnode %08x, dirent %03x, last %03x\", secno, p, pp);\n\t\t\t\t\tgoto bail;\n\t\t\t\t}\n\t\t\t\tif (((31 + de->namelen + de->down*4 + 3) & ~3) != le16_to_cpu(de->length)) {\n\t\t\t\t\tif (((31 + de->namelen + de->down*4 + 3) & ~3) < le16_to_cpu(de->length) && s->s_flags & MS_RDONLY) goto ok;\n\t\t\t\t\thpfs_error(s, \"namelen does not match dirent size in dnode %08x, dirent %03x, last %03x\", secno, p, pp);\n\t\t\t\t\tgoto bail;\n\t\t\t\t}\n\t\t\t\tok:\n\t\t\t\tif (hpfs_sb(s)->sb_chk >= 2) b |= 1 << de->down;\n\t\t\t\tif (de->down) if (de_down_pointer(de) < 0x10) {\n\t\t\t\t\thpfs_error(s, \"bad down pointer in dnode %08x, dirent %03x, last %03x\", secno, p, pp);\n\t\t\t\t\tgoto bail;\n\t\t\t\t}\n\t\t\t\tpp = p;\n\t\t\t\t\n\t\t\t}\n\t\t\tif (p != le32_to_cpu(dnode->first_free)) {\n\t\t\t\thpfs_error(s, \"size on last dirent does not match first_free; dnode %08x\", secno);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tif (d[pp + 30] != 1 || d[pp + 31] != 255) {\n\t\t\t\thpfs_error(s, \"dnode %08x does not end with \\\\377 entry\", secno);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tif (b == 3)\n\t\t\t\tpr_err(\"unbalanced dnode tree, dnode %08x; see hpfs.txt 4 more info\\n\",\n\t\t\t\t\tsecno);\n\t\t}\n\treturn dnode;\n\tbail:\n\thpfs_brelse4(qbh);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_stop_cycles",
          "args": [
            "inode->i_sb",
            "dno",
            "&c1",
            "&c2",
            "\"map_dirent\""
          ],
          "line": 919
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_stop_cycles",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/super.c",
          "lines": "96-106",
          "snippet": "int hpfs_stop_cycles(struct super_block *s, int key, int *c1, int *c2,\n\t\tchar *msg)\n{\n\tif (*c2 && *c1 == key) {\n\t\thpfs_error(s, \"cycle detected on key %08x in %s\", key, msg);\n\t\treturn 1;\n\t}\n\t(*c2)++;\n\tif (!((*c2 - 1) & *c2)) *c1 = key;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/sched.h>",
            "#include <linux/magic.h>",
            "#include <linux/statfs.h>",
            "#include <linux/init.h>",
            "#include <linux/parser.h>",
            "#include <linux/module.h>",
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/bitmap.h>\n#include <linux/sched.h>\n#include <linux/magic.h>\n#include <linux/statfs.h>\n#include <linux/init.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include \"hpfs_fn.h\"\n\nint hpfs_stop_cycles(struct super_block *s, int key, int *c1, int *c2,\n\t\tchar *msg)\n{\n\tif (*c2 && *c1 == key) {\n\t\thpfs_error(s, \"cycle detected on key %08x in %s\", key, msg);\n\t\treturn 1;\n\t}\n\t(*c2)++;\n\tif (!((*c2 - 1) & *c2)) *c1 = key;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_sb",
          "args": [
            "inode->i_sb"
          ],
          "line": 918
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_sb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "310-313",
          "snippet": "static inline struct hpfs_sb_info *hpfs_sb(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_check_free_dnodes(struct super_block *, int);",
            "void hpfs_prefetch_sectors(struct super_block *, unsigned, int);",
            "void hpfs_prefetch_bitmap(struct super_block *, unsigned);",
            "unsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);",
            "int hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);",
            "void hpfs_error(struct super_block *, const char *, ...);",
            "int hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);",
            "unsigned hpfs_get_free_dnodes(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_check_free_dnodes(struct super_block *, int);\nvoid hpfs_prefetch_sectors(struct super_block *, unsigned, int);\nvoid hpfs_prefetch_bitmap(struct super_block *, unsigned);\nunsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);\nint hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);\nvoid hpfs_error(struct super_block *, const char *, ...);\nint hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);\nunsigned hpfs_get_free_dnodes(struct super_block *);\n\nstatic inline struct hpfs_sb_info *hpfs_sb(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_error",
          "args": [
            "inode->i_sb",
            "\"map_dirent: not a directory\\n\""
          ],
          "line": 916
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/super.c",
          "lines": "57-86",
          "snippet": "void hpfs_error(struct super_block *s, const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvsnprintf(err_buf, sizeof(err_buf), fmt, args);\n\tva_end(args);\n\n\tpr_err(\"filesystem error: %s\", err_buf);\n\tif (!hpfs_sb(s)->sb_was_error) {\n\t\tif (hpfs_sb(s)->sb_err == 2) {\n\t\t\tpr_cont(\"; crashing the system because you wanted it\\n\");\n\t\t\tmark_dirty(s, 0);\n\t\t\tpanic(\"HPFS panic\");\n\t\t} else if (hpfs_sb(s)->sb_err == 1) {\n\t\t\tif (s->s_flags & MS_RDONLY)\n\t\t\t\tpr_cont(\"; already mounted read-only\\n\");\n\t\t\telse {\n\t\t\t\tpr_cont(\"; remounting read-only\\n\");\n\t\t\t\tmark_dirty(s, 0);\n\t\t\t\ts->s_flags |= MS_RDONLY;\n\t\t\t}\n\t\t} else if (s->s_flags & MS_RDONLY)\n\t\t\t\tpr_cont(\"; going on - but anything won't be destroyed because it's read-only\\n\");\n\t\telse\n\t\t\tpr_cont(\"; corrupted filesystem mounted read/write - your computer will explode within 20 seconds ... but you wanted it so!\\n\");\n\t} else\n\t\tpr_cont(\"\\n\");\n\thpfs_sb(s)->sb_was_error = 1;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/sched.h>",
            "#include <linux/magic.h>",
            "#include <linux/statfs.h>",
            "#include <linux/init.h>",
            "#include <linux/parser.h>",
            "#include <linux/module.h>",
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static char err_buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/bitmap.h>\n#include <linux/sched.h>\n#include <linux/magic.h>\n#include <linux/statfs.h>\n#include <linux/init.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include \"hpfs_fn.h\"\n\nstatic char err_buf[1024];\n\nvoid hpfs_error(struct super_block *s, const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvsnprintf(err_buf, sizeof(err_buf), fmt, args);\n\tva_end(args);\n\n\tpr_err(\"filesystem error: %s\", err_buf);\n\tif (!hpfs_sb(s)->sb_was_error) {\n\t\tif (hpfs_sb(s)->sb_err == 2) {\n\t\t\tpr_cont(\"; crashing the system because you wanted it\\n\");\n\t\t\tmark_dirty(s, 0);\n\t\t\tpanic(\"HPFS panic\");\n\t\t} else if (hpfs_sb(s)->sb_err == 1) {\n\t\t\tif (s->s_flags & MS_RDONLY)\n\t\t\t\tpr_cont(\"; already mounted read-only\\n\");\n\t\t\telse {\n\t\t\t\tpr_cont(\"; remounting read-only\\n\");\n\t\t\t\tmark_dirty(s, 0);\n\t\t\t\ts->s_flags |= MS_RDONLY;\n\t\t\t}\n\t\t} else if (s->s_flags & MS_RDONLY)\n\t\t\t\tpr_cont(\"; going on - but anything won't be destroyed because it's read-only\\n\");\n\t\telse\n\t\t\tpr_cont(\"; corrupted filesystem mounted read/write - your computer will explode within 20 seconds ... but you wanted it so!\\n\");\n\t} else\n\t\tpr_cont(\"\\n\");\n\thpfs_sb(s)->sb_was_error = 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "inode->i_mode"
          ],
          "line": 916
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"hpfs_fn.h\"\n\nstruct hpfs_dirent *map_dirent(struct inode *inode, dnode_secno dno,\n\t\t\t       const unsigned char *name, unsigned len,\n\t\t\t       dnode_secno *dd, struct quad_buffer_head *qbh)\n{\n\tstruct dnode *dnode;\n\tstruct hpfs_dirent *de;\n\tstruct hpfs_dirent *de_end;\n\tint c1, c2 = 0;\n\n\tif (!S_ISDIR(inode->i_mode)) hpfs_error(inode->i_sb, \"map_dirent: not a directory\\n\");\n\tagain:\n\tif (hpfs_sb(inode->i_sb)->sb_chk)\n\t\tif (hpfs_stop_cycles(inode->i_sb, dno, &c1, &c2, \"map_dirent\")) return NULL;\n\tif (!(dnode = hpfs_map_dnode(inode->i_sb, dno, qbh))) return NULL;\n\t\n\tde_end = dnode_end_de(dnode);\n\tfor (de = dnode_first_de(dnode); de < de_end; de = de_next_de(de)) {\n\t\tint t = hpfs_compare_names(inode->i_sb, name, len, de->name, de->namelen, de->last);\n\t\tif (!t) {\n\t\t\tif (dd) *dd = dno;\n\t\t\treturn de;\n\t\t}\n\t\tif (t < 0) {\n\t\t\tif (de->down) {\n\t\t\t\tdno = de_down_pointer(de);\n\t\t\t\thpfs_brelse4(qbh);\n\t\t\t\tgoto again;\n\t\t\t}\n\t\tbreak;\n\t\t}\n\t}\n\thpfs_brelse4(qbh);\n\treturn NULL;\n}"
  },
  {
    "function_name": "map_pos_dirent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/dnode.c",
    "lines": "842-903",
    "snippet": "struct hpfs_dirent *map_pos_dirent(struct inode *inode, loff_t *posp,\n\t\t\t\t   struct quad_buffer_head *qbh)\n{\n\tloff_t pos;\n\tunsigned c;\n\tdnode_secno dno;\n\tstruct hpfs_dirent *de, *d;\n\tstruct hpfs_dirent *up_de;\n\tstruct hpfs_dirent *end_up_de;\n\tstruct dnode *dnode;\n\tstruct dnode *up_dnode;\n\tstruct quad_buffer_head qbh0;\n\n\tpos = *posp;\n\tdno = pos >> 6 << 2;\n\tpos &= 077;\n\tif (!(de = map_nth_dirent(inode->i_sb, dno, pos, qbh, &dnode)))\n\t\tgoto bail;\n\n\t/* Going to the next dirent */\n\tif ((d = de_next_de(de)) < dnode_end_de(dnode)) {\n\t\tif (!(++*posp & 077)) {\n\t\t\thpfs_error(inode->i_sb,\n\t\t\t\t\"map_pos_dirent: pos crossed dnode boundary; pos = %08llx\",\n\t\t\t\t(unsigned long long)*posp);\n\t\t\tgoto bail;\n\t\t}\n\t\t/* We're going down the tree */\n\t\tif (d->down) {\n\t\t\t*posp = ((loff_t) hpfs_de_as_down_as_possible(inode->i_sb, de_down_pointer(d)) << 4) + 1;\n\t\t}\n\t\n\t\treturn de;\n\t}\n\n\t/* Going up */\n\tif (dnode->root_dnode) goto bail;\n\n\tif (!(up_dnode = hpfs_map_dnode(inode->i_sb, le32_to_cpu(dnode->up), &qbh0)))\n\t\tgoto bail;\n\n\tend_up_de = dnode_end_de(up_dnode);\n\tc = 0;\n\tfor (up_de = dnode_first_de(up_dnode); up_de < end_up_de;\n\t     up_de = de_next_de(up_de)) {\n\t\tif (!(++c & 077)) hpfs_error(inode->i_sb,\n\t\t\t\"map_pos_dirent: pos crossed dnode boundary; dnode = %08x\", le32_to_cpu(dnode->up));\n\t\tif (up_de->down && de_down_pointer(up_de) == dno) {\n\t\t\t*posp = ((loff_t) le32_to_cpu(dnode->up) << 4) + c;\n\t\t\thpfs_brelse4(&qbh0);\n\t\t\treturn de;\n\t\t}\n\t}\n\t\n\thpfs_error(inode->i_sb, \"map_pos_dirent: pointer to dnode %08x not found in parent dnode %08x\",\n\t\tdno, le32_to_cpu(dnode->up));\n\thpfs_brelse4(&qbh0);\n\t\n\tbail:\n\t*posp = 12;\n\treturn de;\n}",
    "includes": [
      "#include \"hpfs_fn.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hpfs_brelse4",
          "args": [
            "&qbh0"
          ],
          "line": 898
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_brelse4",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/buffer.c",
          "lines": "182-190",
          "snippet": "void hpfs_brelse4(struct quad_buffer_head *qbh)\n{\n\tif (unlikely(qbh->data != qbh->bh[0]->b_data))\n\t\tkfree(qbh->data);\n\tbrelse(qbh->bh[0]);\n\tbrelse(qbh->bh[1]);\n\tbrelse(qbh->bh[2]);\n\tbrelse(qbh->bh[3]);\n}",
          "includes": [
            "#include \"hpfs_fn.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid hpfs_brelse4(struct quad_buffer_head *qbh)\n{\n\tif (unlikely(qbh->data != qbh->bh[0]->b_data))\n\t\tkfree(qbh->data);\n\tbrelse(qbh->bh[0]);\n\tbrelse(qbh->bh[1]);\n\tbrelse(qbh->bh[2]);\n\tbrelse(qbh->bh[3]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_error",
          "args": [
            "inode->i_sb",
            "\"map_pos_dirent: pointer to dnode %08x not found in parent dnode %08x\"",
            "dno",
            "le32_to_cpu(dnode->up)"
          ],
          "line": 896
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/super.c",
          "lines": "57-86",
          "snippet": "void hpfs_error(struct super_block *s, const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvsnprintf(err_buf, sizeof(err_buf), fmt, args);\n\tva_end(args);\n\n\tpr_err(\"filesystem error: %s\", err_buf);\n\tif (!hpfs_sb(s)->sb_was_error) {\n\t\tif (hpfs_sb(s)->sb_err == 2) {\n\t\t\tpr_cont(\"; crashing the system because you wanted it\\n\");\n\t\t\tmark_dirty(s, 0);\n\t\t\tpanic(\"HPFS panic\");\n\t\t} else if (hpfs_sb(s)->sb_err == 1) {\n\t\t\tif (s->s_flags & MS_RDONLY)\n\t\t\t\tpr_cont(\"; already mounted read-only\\n\");\n\t\t\telse {\n\t\t\t\tpr_cont(\"; remounting read-only\\n\");\n\t\t\t\tmark_dirty(s, 0);\n\t\t\t\ts->s_flags |= MS_RDONLY;\n\t\t\t}\n\t\t} else if (s->s_flags & MS_RDONLY)\n\t\t\t\tpr_cont(\"; going on - but anything won't be destroyed because it's read-only\\n\");\n\t\telse\n\t\t\tpr_cont(\"; corrupted filesystem mounted read/write - your computer will explode within 20 seconds ... but you wanted it so!\\n\");\n\t} else\n\t\tpr_cont(\"\\n\");\n\thpfs_sb(s)->sb_was_error = 1;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/sched.h>",
            "#include <linux/magic.h>",
            "#include <linux/statfs.h>",
            "#include <linux/init.h>",
            "#include <linux/parser.h>",
            "#include <linux/module.h>",
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static char err_buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/bitmap.h>\n#include <linux/sched.h>\n#include <linux/magic.h>\n#include <linux/statfs.h>\n#include <linux/init.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include \"hpfs_fn.h\"\n\nstatic char err_buf[1024];\n\nvoid hpfs_error(struct super_block *s, const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvsnprintf(err_buf, sizeof(err_buf), fmt, args);\n\tva_end(args);\n\n\tpr_err(\"filesystem error: %s\", err_buf);\n\tif (!hpfs_sb(s)->sb_was_error) {\n\t\tif (hpfs_sb(s)->sb_err == 2) {\n\t\t\tpr_cont(\"; crashing the system because you wanted it\\n\");\n\t\t\tmark_dirty(s, 0);\n\t\t\tpanic(\"HPFS panic\");\n\t\t} else if (hpfs_sb(s)->sb_err == 1) {\n\t\t\tif (s->s_flags & MS_RDONLY)\n\t\t\t\tpr_cont(\"; already mounted read-only\\n\");\n\t\t\telse {\n\t\t\t\tpr_cont(\"; remounting read-only\\n\");\n\t\t\t\tmark_dirty(s, 0);\n\t\t\t\ts->s_flags |= MS_RDONLY;\n\t\t\t}\n\t\t} else if (s->s_flags & MS_RDONLY)\n\t\t\t\tpr_cont(\"; going on - but anything won't be destroyed because it's read-only\\n\");\n\t\telse\n\t\t\tpr_cont(\"; corrupted filesystem mounted read/write - your computer will explode within 20 seconds ... but you wanted it so!\\n\");\n\t} else\n\t\tpr_cont(\"\\n\");\n\thpfs_sb(s)->sb_was_error = 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "dnode->up"
          ],
          "line": 897
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "de_down_pointer",
          "args": [
            "up_de"
          ],
          "line": 889
        },
        "resolved": true,
        "details": {
          "function_name": "de_down_pointer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "100-104",
          "snippet": "static inline dnode_secno de_down_pointer (struct hpfs_dirent *de)\n{\n  CHKCOND(de->down,(\"HPFS: de_down_pointer: !de->down\\n\"));\n  return le32_to_cpu(*(__le32 *) ((void *) de + le16_to_cpu(de->length) - 4));\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_add_dirent(struct inode *, const unsigned char *, unsigned,\n\t\t    struct hpfs_dirent *);",
            "void hpfs_count_dnodes(struct super_block *, dnode_secno, int *, int *, int *);",
            "void hpfs_remove_dtree(struct super_block *, dnode_secno);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_add_dirent(struct inode *, const unsigned char *, unsigned,\n\t\t    struct hpfs_dirent *);\nvoid hpfs_count_dnodes(struct super_block *, dnode_secno, int *, int *, int *);\nvoid hpfs_remove_dtree(struct super_block *, dnode_secno);\n\nstatic inline dnode_secno de_down_pointer (struct hpfs_dirent *de)\n{\n  CHKCOND(de->down,(\"HPFS: de_down_pointer: !de->down\\n\"));\n  return le32_to_cpu(*(__le32 *) ((void *) de + le16_to_cpu(de->length) - 4));\n}"
        }
      },
      {
        "call_info": {
          "callee": "de_next_de",
          "args": [
            "up_de"
          ],
          "line": 886
        },
        "resolved": true,
        "details": {
          "function_name": "de_next_de",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "123-127",
          "snippet": "static inline struct hpfs_dirent *de_next_de (struct hpfs_dirent *de)\n{\n  CHKCOND(le16_to_cpu(de->length)>=0x20 && le16_to_cpu(de->length)<0x800,(\"HPFS: de_next_de: de->length = %x\\n\",(unsigned)le16_to_cpu(de->length)));\n  return (void *) de + le16_to_cpu(de->length);\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_add_dirent(struct inode *, const unsigned char *, unsigned,\n\t\t    struct hpfs_dirent *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_add_dirent(struct inode *, const unsigned char *, unsigned,\n\t\t    struct hpfs_dirent *);\n\nstatic inline struct hpfs_dirent *de_next_de (struct hpfs_dirent *de)\n{\n  CHKCOND(le16_to_cpu(de->length)>=0x20 && le16_to_cpu(de->length)<0x800,(\"HPFS: de_next_de: de->length = %x\\n\",(unsigned)le16_to_cpu(de->length)));\n  return (void *) de + le16_to_cpu(de->length);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dnode_first_de",
          "args": [
            "up_dnode"
          ],
          "line": 885
        },
        "resolved": true,
        "details": {
          "function_name": "dnode_first_de",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "108-111",
          "snippet": "static inline struct hpfs_dirent *dnode_first_de (struct dnode *dnode)\n{\n  return (void *) dnode->dirent;\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_add_dirent(struct inode *, const unsigned char *, unsigned,\n\t\t    struct hpfs_dirent *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_add_dirent(struct inode *, const unsigned char *, unsigned,\n\t\t    struct hpfs_dirent *);\n\nstatic inline struct hpfs_dirent *dnode_first_de (struct dnode *dnode)\n{\n  return (void *) dnode->dirent;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dnode_end_de",
          "args": [
            "up_dnode"
          ],
          "line": 883
        },
        "resolved": true,
        "details": {
          "function_name": "dnode_end_de",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "115-119",
          "snippet": "static inline struct hpfs_dirent *dnode_end_de (struct dnode *dnode)\n{\n  CHKCOND(le32_to_cpu(dnode->first_free)>=0x14 && le32_to_cpu(dnode->first_free)<=0xa00,(\"HPFS: dnode_end_de: dnode->first_free = %x\\n\",(unsigned)le32_to_cpu(dnode->first_free)));\n  return (void *) dnode + le32_to_cpu(dnode->first_free);\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_add_dirent(struct inode *, const unsigned char *, unsigned,\n\t\t    struct hpfs_dirent *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_add_dirent(struct inode *, const unsigned char *, unsigned,\n\t\t    struct hpfs_dirent *);\n\nstatic inline struct hpfs_dirent *dnode_end_de (struct dnode *dnode)\n{\n  CHKCOND(le32_to_cpu(dnode->first_free)>=0x14 && le32_to_cpu(dnode->first_free)<=0xa00,(\"HPFS: dnode_end_de: dnode->first_free = %x\\n\",(unsigned)le32_to_cpu(dnode->first_free)));\n  return (void *) dnode + le32_to_cpu(dnode->first_free);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_map_dnode",
          "args": [
            "inode->i_sb",
            "le32_to_cpu(dnode->up)",
            "&qbh0"
          ],
          "line": 880
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_map_dnode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/map.c",
          "lines": "229-293",
          "snippet": "struct dnode *hpfs_map_dnode(struct super_block *s, unsigned secno,\n\t\t\t     struct quad_buffer_head *qbh)\n{\n\tstruct dnode *dnode;\n\tif (hpfs_sb(s)->sb_chk) {\n\t\tif (hpfs_chk_sectors(s, secno, 4, \"dnode\")) return NULL;\n\t\tif (secno & 3) {\n\t\t\thpfs_error(s, \"dnode %08x not byte-aligned\", secno);\n\t\t\treturn NULL;\n\t\t}\t\n\t}\n\tif ((dnode = hpfs_map_4sectors(s, secno, qbh, DNODE_RD_AHEAD)))\n\t\tif (hpfs_sb(s)->sb_chk) {\n\t\t\tunsigned p, pp = 0;\n\t\t\tunsigned char *d = (unsigned char *)dnode;\n\t\t\tint b = 0;\n\t\t\tif (le32_to_cpu(dnode->magic) != DNODE_MAGIC) {\n\t\t\t\thpfs_error(s, \"bad magic on dnode %08x\", secno);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tif (le32_to_cpu(dnode->self) != secno)\n\t\t\t\thpfs_error(s, \"bad self pointer on dnode %08x self = %08x\", secno, le32_to_cpu(dnode->self));\n\t\t\t/* Check dirents - bad dirents would cause infinite\n\t\t\t   loops or shooting to memory */\n\t\t\tif (le32_to_cpu(dnode->first_free) > 2048) {\n\t\t\t\thpfs_error(s, \"dnode %08x has first_free == %08x\", secno, le32_to_cpu(dnode->first_free));\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tfor (p = 20; p < le32_to_cpu(dnode->first_free); p += d[p] + (d[p+1] << 8)) {\n\t\t\t\tstruct hpfs_dirent *de = (struct hpfs_dirent *)((char *)dnode + p);\n\t\t\t\tif (le16_to_cpu(de->length) > 292 || (le16_to_cpu(de->length) < 32) || (le16_to_cpu(de->length) & 3) || p + le16_to_cpu(de->length) > 2048) {\n\t\t\t\t\thpfs_error(s, \"bad dirent size in dnode %08x, dirent %03x, last %03x\", secno, p, pp);\n\t\t\t\t\tgoto bail;\n\t\t\t\t}\n\t\t\t\tif (((31 + de->namelen + de->down*4 + 3) & ~3) != le16_to_cpu(de->length)) {\n\t\t\t\t\tif (((31 + de->namelen + de->down*4 + 3) & ~3) < le16_to_cpu(de->length) && s->s_flags & MS_RDONLY) goto ok;\n\t\t\t\t\thpfs_error(s, \"namelen does not match dirent size in dnode %08x, dirent %03x, last %03x\", secno, p, pp);\n\t\t\t\t\tgoto bail;\n\t\t\t\t}\n\t\t\t\tok:\n\t\t\t\tif (hpfs_sb(s)->sb_chk >= 2) b |= 1 << de->down;\n\t\t\t\tif (de->down) if (de_down_pointer(de) < 0x10) {\n\t\t\t\t\thpfs_error(s, \"bad down pointer in dnode %08x, dirent %03x, last %03x\", secno, p, pp);\n\t\t\t\t\tgoto bail;\n\t\t\t\t}\n\t\t\t\tpp = p;\n\t\t\t\t\n\t\t\t}\n\t\t\tif (p != le32_to_cpu(dnode->first_free)) {\n\t\t\t\thpfs_error(s, \"size on last dirent does not match first_free; dnode %08x\", secno);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tif (d[pp + 30] != 1 || d[pp + 31] != 255) {\n\t\t\t\thpfs_error(s, \"dnode %08x does not end with \\\\377 entry\", secno);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tif (b == 3)\n\t\t\t\tpr_err(\"unbalanced dnode tree, dnode %08x; see hpfs.txt 4 more info\\n\",\n\t\t\t\t\tsecno);\n\t\t}\n\treturn dnode;\n\tbail:\n\thpfs_brelse4(qbh);\n\treturn NULL;\n}",
          "includes": [
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n\nstruct dnode *hpfs_map_dnode(struct super_block *s, unsigned secno,\n\t\t\t     struct quad_buffer_head *qbh)\n{\n\tstruct dnode *dnode;\n\tif (hpfs_sb(s)->sb_chk) {\n\t\tif (hpfs_chk_sectors(s, secno, 4, \"dnode\")) return NULL;\n\t\tif (secno & 3) {\n\t\t\thpfs_error(s, \"dnode %08x not byte-aligned\", secno);\n\t\t\treturn NULL;\n\t\t}\t\n\t}\n\tif ((dnode = hpfs_map_4sectors(s, secno, qbh, DNODE_RD_AHEAD)))\n\t\tif (hpfs_sb(s)->sb_chk) {\n\t\t\tunsigned p, pp = 0;\n\t\t\tunsigned char *d = (unsigned char *)dnode;\n\t\t\tint b = 0;\n\t\t\tif (le32_to_cpu(dnode->magic) != DNODE_MAGIC) {\n\t\t\t\thpfs_error(s, \"bad magic on dnode %08x\", secno);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tif (le32_to_cpu(dnode->self) != secno)\n\t\t\t\thpfs_error(s, \"bad self pointer on dnode %08x self = %08x\", secno, le32_to_cpu(dnode->self));\n\t\t\t/* Check dirents - bad dirents would cause infinite\n\t\t\t   loops or shooting to memory */\n\t\t\tif (le32_to_cpu(dnode->first_free) > 2048) {\n\t\t\t\thpfs_error(s, \"dnode %08x has first_free == %08x\", secno, le32_to_cpu(dnode->first_free));\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tfor (p = 20; p < le32_to_cpu(dnode->first_free); p += d[p] + (d[p+1] << 8)) {\n\t\t\t\tstruct hpfs_dirent *de = (struct hpfs_dirent *)((char *)dnode + p);\n\t\t\t\tif (le16_to_cpu(de->length) > 292 || (le16_to_cpu(de->length) < 32) || (le16_to_cpu(de->length) & 3) || p + le16_to_cpu(de->length) > 2048) {\n\t\t\t\t\thpfs_error(s, \"bad dirent size in dnode %08x, dirent %03x, last %03x\", secno, p, pp);\n\t\t\t\t\tgoto bail;\n\t\t\t\t}\n\t\t\t\tif (((31 + de->namelen + de->down*4 + 3) & ~3) != le16_to_cpu(de->length)) {\n\t\t\t\t\tif (((31 + de->namelen + de->down*4 + 3) & ~3) < le16_to_cpu(de->length) && s->s_flags & MS_RDONLY) goto ok;\n\t\t\t\t\thpfs_error(s, \"namelen does not match dirent size in dnode %08x, dirent %03x, last %03x\", secno, p, pp);\n\t\t\t\t\tgoto bail;\n\t\t\t\t}\n\t\t\t\tok:\n\t\t\t\tif (hpfs_sb(s)->sb_chk >= 2) b |= 1 << de->down;\n\t\t\t\tif (de->down) if (de_down_pointer(de) < 0x10) {\n\t\t\t\t\thpfs_error(s, \"bad down pointer in dnode %08x, dirent %03x, last %03x\", secno, p, pp);\n\t\t\t\t\tgoto bail;\n\t\t\t\t}\n\t\t\t\tpp = p;\n\t\t\t\t\n\t\t\t}\n\t\t\tif (p != le32_to_cpu(dnode->first_free)) {\n\t\t\t\thpfs_error(s, \"size on last dirent does not match first_free; dnode %08x\", secno);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tif (d[pp + 30] != 1 || d[pp + 31] != 255) {\n\t\t\t\thpfs_error(s, \"dnode %08x does not end with \\\\377 entry\", secno);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tif (b == 3)\n\t\t\t\tpr_err(\"unbalanced dnode tree, dnode %08x; see hpfs.txt 4 more info\\n\",\n\t\t\t\t\tsecno);\n\t\t}\n\treturn dnode;\n\tbail:\n\thpfs_brelse4(qbh);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_de_as_down_as_possible",
          "args": [
            "inode->i_sb",
            "de_down_pointer(d)"
          ],
          "line": 871
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_de_as_down_as_possible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/dnode.c",
          "lines": "816-840",
          "snippet": "dnode_secno hpfs_de_as_down_as_possible(struct super_block *s, dnode_secno dno)\n{\n\tstruct quad_buffer_head qbh;\n\tdnode_secno d = dno;\n\tdnode_secno up = 0;\n\tstruct hpfs_dirent *de;\n\tint c1, c2 = 0;\n\n\tagain:\n\tif (hpfs_sb(s)->sb_chk)\n\t\tif (hpfs_stop_cycles(s, d, &c1, &c2, \"hpfs_de_as_down_as_possible\"))\n\t\t\treturn d;\n\tif (!(de = map_nth_dirent(s, d, 1, &qbh, NULL))) return dno;\n\tif (hpfs_sb(s)->sb_chk)\n\t\tif (up && le32_to_cpu(((struct dnode *)qbh.data)->up) != up)\n\t\t\thpfs_error(s, \"hpfs_de_as_down_as_possible: bad up pointer; dnode %08x, down %08x points to %08x\", up, d, le32_to_cpu(((struct dnode *)qbh.data)->up));\n\tif (!de->down) {\n\t\thpfs_brelse4(&qbh);\n\t\treturn d;\n\t}\n\tup = d;\n\td = de_down_pointer(de);\n\thpfs_brelse4(&qbh);\n\tgoto again;\n}",
          "includes": [
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n\ndnode_secno hpfs_de_as_down_as_possible(struct super_block *s, dnode_secno dno)\n{\n\tstruct quad_buffer_head qbh;\n\tdnode_secno d = dno;\n\tdnode_secno up = 0;\n\tstruct hpfs_dirent *de;\n\tint c1, c2 = 0;\n\n\tagain:\n\tif (hpfs_sb(s)->sb_chk)\n\t\tif (hpfs_stop_cycles(s, d, &c1, &c2, \"hpfs_de_as_down_as_possible\"))\n\t\t\treturn d;\n\tif (!(de = map_nth_dirent(s, d, 1, &qbh, NULL))) return dno;\n\tif (hpfs_sb(s)->sb_chk)\n\t\tif (up && le32_to_cpu(((struct dnode *)qbh.data)->up) != up)\n\t\t\thpfs_error(s, \"hpfs_de_as_down_as_possible: bad up pointer; dnode %08x, down %08x points to %08x\", up, d, le32_to_cpu(((struct dnode *)qbh.data)->up));\n\tif (!de->down) {\n\t\thpfs_brelse4(&qbh);\n\t\treturn d;\n\t}\n\tup = d;\n\td = de_down_pointer(de);\n\thpfs_brelse4(&qbh);\n\tgoto again;\n}"
        }
      },
      {
        "call_info": {
          "callee": "map_nth_dirent",
          "args": [
            "inode->i_sb",
            "dno",
            "pos",
            "qbh",
            "&dnode"
          ],
          "line": 858
        },
        "resolved": true,
        "details": {
          "function_name": "map_nth_dirent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/dnode.c",
          "lines": "794-814",
          "snippet": "static struct hpfs_dirent *map_nth_dirent(struct super_block *s, dnode_secno dno, int n,\n\t\t\t\t\t  struct quad_buffer_head *qbh, struct dnode **dn)\n{\n\tint i;\n\tstruct hpfs_dirent *de, *de_end;\n\tstruct dnode *dnode;\n\tdnode = hpfs_map_dnode(s, dno, qbh);\n\tif (!dnode) return NULL;\n\tif (dn) *dn=dnode;\n\tde = dnode_first_de(dnode);\n\tde_end = dnode_end_de(dnode);\n\tfor (i = 1; de < de_end; i++, de = de_next_de(de)) {\n\t\tif (i == n) {\n\t\t\treturn de;\n\t\t}\t\n\t\tif (de->last) break;\n\t}\n\thpfs_brelse4(qbh);\n\thpfs_error(s, \"map_nth_dirent: n too high; dnode = %08x, requested %08x\", dno, n);\n\treturn NULL;\n}",
          "includes": [
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n\nstatic struct hpfs_dirent *map_nth_dirent(struct super_block *s, dnode_secno dno, int n,\n\t\t\t\t\t  struct quad_buffer_head *qbh, struct dnode **dn)\n{\n\tint i;\n\tstruct hpfs_dirent *de, *de_end;\n\tstruct dnode *dnode;\n\tdnode = hpfs_map_dnode(s, dno, qbh);\n\tif (!dnode) return NULL;\n\tif (dn) *dn=dnode;\n\tde = dnode_first_de(dnode);\n\tde_end = dnode_end_de(dnode);\n\tfor (i = 1; de < de_end; i++, de = de_next_de(de)) {\n\t\tif (i == n) {\n\t\t\treturn de;\n\t\t}\t\n\t\tif (de->last) break;\n\t}\n\thpfs_brelse4(qbh);\n\thpfs_error(s, \"map_nth_dirent: n too high; dnode = %08x, requested %08x\", dno, n);\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hpfs_fn.h\"\n\nstruct hpfs_dirent *map_pos_dirent(struct inode *inode, loff_t *posp,\n\t\t\t\t   struct quad_buffer_head *qbh)\n{\n\tloff_t pos;\n\tunsigned c;\n\tdnode_secno dno;\n\tstruct hpfs_dirent *de, *d;\n\tstruct hpfs_dirent *up_de;\n\tstruct hpfs_dirent *end_up_de;\n\tstruct dnode *dnode;\n\tstruct dnode *up_dnode;\n\tstruct quad_buffer_head qbh0;\n\n\tpos = *posp;\n\tdno = pos >> 6 << 2;\n\tpos &= 077;\n\tif (!(de = map_nth_dirent(inode->i_sb, dno, pos, qbh, &dnode)))\n\t\tgoto bail;\n\n\t/* Going to the next dirent */\n\tif ((d = de_next_de(de)) < dnode_end_de(dnode)) {\n\t\tif (!(++*posp & 077)) {\n\t\t\thpfs_error(inode->i_sb,\n\t\t\t\t\"map_pos_dirent: pos crossed dnode boundary; pos = %08llx\",\n\t\t\t\t(unsigned long long)*posp);\n\t\t\tgoto bail;\n\t\t}\n\t\t/* We're going down the tree */\n\t\tif (d->down) {\n\t\t\t*posp = ((loff_t) hpfs_de_as_down_as_possible(inode->i_sb, de_down_pointer(d)) << 4) + 1;\n\t\t}\n\t\n\t\treturn de;\n\t}\n\n\t/* Going up */\n\tif (dnode->root_dnode) goto bail;\n\n\tif (!(up_dnode = hpfs_map_dnode(inode->i_sb, le32_to_cpu(dnode->up), &qbh0)))\n\t\tgoto bail;\n\n\tend_up_de = dnode_end_de(up_dnode);\n\tc = 0;\n\tfor (up_de = dnode_first_de(up_dnode); up_de < end_up_de;\n\t     up_de = de_next_de(up_de)) {\n\t\tif (!(++c & 077)) hpfs_error(inode->i_sb,\n\t\t\t\"map_pos_dirent: pos crossed dnode boundary; dnode = %08x\", le32_to_cpu(dnode->up));\n\t\tif (up_de->down && de_down_pointer(up_de) == dno) {\n\t\t\t*posp = ((loff_t) le32_to_cpu(dnode->up) << 4) + c;\n\t\t\thpfs_brelse4(&qbh0);\n\t\t\treturn de;\n\t\t}\n\t}\n\t\n\thpfs_error(inode->i_sb, \"map_pos_dirent: pointer to dnode %08x not found in parent dnode %08x\",\n\t\tdno, le32_to_cpu(dnode->up));\n\thpfs_brelse4(&qbh0);\n\t\n\tbail:\n\t*posp = 12;\n\treturn de;\n}"
  },
  {
    "function_name": "hpfs_de_as_down_as_possible",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/dnode.c",
    "lines": "816-840",
    "snippet": "dnode_secno hpfs_de_as_down_as_possible(struct super_block *s, dnode_secno dno)\n{\n\tstruct quad_buffer_head qbh;\n\tdnode_secno d = dno;\n\tdnode_secno up = 0;\n\tstruct hpfs_dirent *de;\n\tint c1, c2 = 0;\n\n\tagain:\n\tif (hpfs_sb(s)->sb_chk)\n\t\tif (hpfs_stop_cycles(s, d, &c1, &c2, \"hpfs_de_as_down_as_possible\"))\n\t\t\treturn d;\n\tif (!(de = map_nth_dirent(s, d, 1, &qbh, NULL))) return dno;\n\tif (hpfs_sb(s)->sb_chk)\n\t\tif (up && le32_to_cpu(((struct dnode *)qbh.data)->up) != up)\n\t\t\thpfs_error(s, \"hpfs_de_as_down_as_possible: bad up pointer; dnode %08x, down %08x points to %08x\", up, d, le32_to_cpu(((struct dnode *)qbh.data)->up));\n\tif (!de->down) {\n\t\thpfs_brelse4(&qbh);\n\t\treturn d;\n\t}\n\tup = d;\n\td = de_down_pointer(de);\n\thpfs_brelse4(&qbh);\n\tgoto again;\n}",
    "includes": [
      "#include \"hpfs_fn.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hpfs_brelse4",
          "args": [
            "&qbh"
          ],
          "line": 838
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_brelse4",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/buffer.c",
          "lines": "182-190",
          "snippet": "void hpfs_brelse4(struct quad_buffer_head *qbh)\n{\n\tif (unlikely(qbh->data != qbh->bh[0]->b_data))\n\t\tkfree(qbh->data);\n\tbrelse(qbh->bh[0]);\n\tbrelse(qbh->bh[1]);\n\tbrelse(qbh->bh[2]);\n\tbrelse(qbh->bh[3]);\n}",
          "includes": [
            "#include \"hpfs_fn.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid hpfs_brelse4(struct quad_buffer_head *qbh)\n{\n\tif (unlikely(qbh->data != qbh->bh[0]->b_data))\n\t\tkfree(qbh->data);\n\tbrelse(qbh->bh[0]);\n\tbrelse(qbh->bh[1]);\n\tbrelse(qbh->bh[2]);\n\tbrelse(qbh->bh[3]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "de_down_pointer",
          "args": [
            "de"
          ],
          "line": 837
        },
        "resolved": true,
        "details": {
          "function_name": "de_down_pointer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "100-104",
          "snippet": "static inline dnode_secno de_down_pointer (struct hpfs_dirent *de)\n{\n  CHKCOND(de->down,(\"HPFS: de_down_pointer: !de->down\\n\"));\n  return le32_to_cpu(*(__le32 *) ((void *) de + le16_to_cpu(de->length) - 4));\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_add_dirent(struct inode *, const unsigned char *, unsigned,\n\t\t    struct hpfs_dirent *);",
            "void hpfs_count_dnodes(struct super_block *, dnode_secno, int *, int *, int *);",
            "void hpfs_remove_dtree(struct super_block *, dnode_secno);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_add_dirent(struct inode *, const unsigned char *, unsigned,\n\t\t    struct hpfs_dirent *);\nvoid hpfs_count_dnodes(struct super_block *, dnode_secno, int *, int *, int *);\nvoid hpfs_remove_dtree(struct super_block *, dnode_secno);\n\nstatic inline dnode_secno de_down_pointer (struct hpfs_dirent *de)\n{\n  CHKCOND(de->down,(\"HPFS: de_down_pointer: !de->down\\n\"));\n  return le32_to_cpu(*(__le32 *) ((void *) de + le16_to_cpu(de->length) - 4));\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_error",
          "args": [
            "s",
            "\"hpfs_de_as_down_as_possible: bad up pointer; dnode %08x, down %08x points to %08x\"",
            "up",
            "d",
            "le32_to_cpu(((struct dnode *)qbh.data)->up)"
          ],
          "line": 831
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/super.c",
          "lines": "57-86",
          "snippet": "void hpfs_error(struct super_block *s, const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvsnprintf(err_buf, sizeof(err_buf), fmt, args);\n\tva_end(args);\n\n\tpr_err(\"filesystem error: %s\", err_buf);\n\tif (!hpfs_sb(s)->sb_was_error) {\n\t\tif (hpfs_sb(s)->sb_err == 2) {\n\t\t\tpr_cont(\"; crashing the system because you wanted it\\n\");\n\t\t\tmark_dirty(s, 0);\n\t\t\tpanic(\"HPFS panic\");\n\t\t} else if (hpfs_sb(s)->sb_err == 1) {\n\t\t\tif (s->s_flags & MS_RDONLY)\n\t\t\t\tpr_cont(\"; already mounted read-only\\n\");\n\t\t\telse {\n\t\t\t\tpr_cont(\"; remounting read-only\\n\");\n\t\t\t\tmark_dirty(s, 0);\n\t\t\t\ts->s_flags |= MS_RDONLY;\n\t\t\t}\n\t\t} else if (s->s_flags & MS_RDONLY)\n\t\t\t\tpr_cont(\"; going on - but anything won't be destroyed because it's read-only\\n\");\n\t\telse\n\t\t\tpr_cont(\"; corrupted filesystem mounted read/write - your computer will explode within 20 seconds ... but you wanted it so!\\n\");\n\t} else\n\t\tpr_cont(\"\\n\");\n\thpfs_sb(s)->sb_was_error = 1;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/sched.h>",
            "#include <linux/magic.h>",
            "#include <linux/statfs.h>",
            "#include <linux/init.h>",
            "#include <linux/parser.h>",
            "#include <linux/module.h>",
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static char err_buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/bitmap.h>\n#include <linux/sched.h>\n#include <linux/magic.h>\n#include <linux/statfs.h>\n#include <linux/init.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include \"hpfs_fn.h\"\n\nstatic char err_buf[1024];\n\nvoid hpfs_error(struct super_block *s, const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvsnprintf(err_buf, sizeof(err_buf), fmt, args);\n\tva_end(args);\n\n\tpr_err(\"filesystem error: %s\", err_buf);\n\tif (!hpfs_sb(s)->sb_was_error) {\n\t\tif (hpfs_sb(s)->sb_err == 2) {\n\t\t\tpr_cont(\"; crashing the system because you wanted it\\n\");\n\t\t\tmark_dirty(s, 0);\n\t\t\tpanic(\"HPFS panic\");\n\t\t} else if (hpfs_sb(s)->sb_err == 1) {\n\t\t\tif (s->s_flags & MS_RDONLY)\n\t\t\t\tpr_cont(\"; already mounted read-only\\n\");\n\t\t\telse {\n\t\t\t\tpr_cont(\"; remounting read-only\\n\");\n\t\t\t\tmark_dirty(s, 0);\n\t\t\t\ts->s_flags |= MS_RDONLY;\n\t\t\t}\n\t\t} else if (s->s_flags & MS_RDONLY)\n\t\t\t\tpr_cont(\"; going on - but anything won't be destroyed because it's read-only\\n\");\n\t\telse\n\t\t\tpr_cont(\"; corrupted filesystem mounted read/write - your computer will explode within 20 seconds ... but you wanted it so!\\n\");\n\t} else\n\t\tpr_cont(\"\\n\");\n\thpfs_sb(s)->sb_was_error = 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "((struct dnode *)qbh.data)->up"
          ],
          "line": 831
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_sb",
          "args": [
            "s"
          ],
          "line": 829
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_sb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "310-313",
          "snippet": "static inline struct hpfs_sb_info *hpfs_sb(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_check_free_dnodes(struct super_block *, int);",
            "void hpfs_prefetch_sectors(struct super_block *, unsigned, int);",
            "void hpfs_prefetch_bitmap(struct super_block *, unsigned);",
            "unsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);",
            "int hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);",
            "void hpfs_error(struct super_block *, const char *, ...);",
            "int hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);",
            "unsigned hpfs_get_free_dnodes(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_check_free_dnodes(struct super_block *, int);\nvoid hpfs_prefetch_sectors(struct super_block *, unsigned, int);\nvoid hpfs_prefetch_bitmap(struct super_block *, unsigned);\nunsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);\nint hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);\nvoid hpfs_error(struct super_block *, const char *, ...);\nint hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);\nunsigned hpfs_get_free_dnodes(struct super_block *);\n\nstatic inline struct hpfs_sb_info *hpfs_sb(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "map_nth_dirent",
          "args": [
            "s",
            "d",
            "1",
            "&qbh",
            "NULL"
          ],
          "line": 828
        },
        "resolved": true,
        "details": {
          "function_name": "map_nth_dirent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/dnode.c",
          "lines": "794-814",
          "snippet": "static struct hpfs_dirent *map_nth_dirent(struct super_block *s, dnode_secno dno, int n,\n\t\t\t\t\t  struct quad_buffer_head *qbh, struct dnode **dn)\n{\n\tint i;\n\tstruct hpfs_dirent *de, *de_end;\n\tstruct dnode *dnode;\n\tdnode = hpfs_map_dnode(s, dno, qbh);\n\tif (!dnode) return NULL;\n\tif (dn) *dn=dnode;\n\tde = dnode_first_de(dnode);\n\tde_end = dnode_end_de(dnode);\n\tfor (i = 1; de < de_end; i++, de = de_next_de(de)) {\n\t\tif (i == n) {\n\t\t\treturn de;\n\t\t}\t\n\t\tif (de->last) break;\n\t}\n\thpfs_brelse4(qbh);\n\thpfs_error(s, \"map_nth_dirent: n too high; dnode = %08x, requested %08x\", dno, n);\n\treturn NULL;\n}",
          "includes": [
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n\nstatic struct hpfs_dirent *map_nth_dirent(struct super_block *s, dnode_secno dno, int n,\n\t\t\t\t\t  struct quad_buffer_head *qbh, struct dnode **dn)\n{\n\tint i;\n\tstruct hpfs_dirent *de, *de_end;\n\tstruct dnode *dnode;\n\tdnode = hpfs_map_dnode(s, dno, qbh);\n\tif (!dnode) return NULL;\n\tif (dn) *dn=dnode;\n\tde = dnode_first_de(dnode);\n\tde_end = dnode_end_de(dnode);\n\tfor (i = 1; de < de_end; i++, de = de_next_de(de)) {\n\t\tif (i == n) {\n\t\t\treturn de;\n\t\t}\t\n\t\tif (de->last) break;\n\t}\n\thpfs_brelse4(qbh);\n\thpfs_error(s, \"map_nth_dirent: n too high; dnode = %08x, requested %08x\", dno, n);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_stop_cycles",
          "args": [
            "s",
            "d",
            "&c1",
            "&c2",
            "\"hpfs_de_as_down_as_possible\""
          ],
          "line": 826
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_stop_cycles",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/super.c",
          "lines": "96-106",
          "snippet": "int hpfs_stop_cycles(struct super_block *s, int key, int *c1, int *c2,\n\t\tchar *msg)\n{\n\tif (*c2 && *c1 == key) {\n\t\thpfs_error(s, \"cycle detected on key %08x in %s\", key, msg);\n\t\treturn 1;\n\t}\n\t(*c2)++;\n\tif (!((*c2 - 1) & *c2)) *c1 = key;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/sched.h>",
            "#include <linux/magic.h>",
            "#include <linux/statfs.h>",
            "#include <linux/init.h>",
            "#include <linux/parser.h>",
            "#include <linux/module.h>",
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/bitmap.h>\n#include <linux/sched.h>\n#include <linux/magic.h>\n#include <linux/statfs.h>\n#include <linux/init.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include \"hpfs_fn.h\"\n\nint hpfs_stop_cycles(struct super_block *s, int key, int *c1, int *c2,\n\t\tchar *msg)\n{\n\tif (*c2 && *c1 == key) {\n\t\thpfs_error(s, \"cycle detected on key %08x in %s\", key, msg);\n\t\treturn 1;\n\t}\n\t(*c2)++;\n\tif (!((*c2 - 1) & *c2)) *c1 = key;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hpfs_fn.h\"\n\ndnode_secno hpfs_de_as_down_as_possible(struct super_block *s, dnode_secno dno)\n{\n\tstruct quad_buffer_head qbh;\n\tdnode_secno d = dno;\n\tdnode_secno up = 0;\n\tstruct hpfs_dirent *de;\n\tint c1, c2 = 0;\n\n\tagain:\n\tif (hpfs_sb(s)->sb_chk)\n\t\tif (hpfs_stop_cycles(s, d, &c1, &c2, \"hpfs_de_as_down_as_possible\"))\n\t\t\treturn d;\n\tif (!(de = map_nth_dirent(s, d, 1, &qbh, NULL))) return dno;\n\tif (hpfs_sb(s)->sb_chk)\n\t\tif (up && le32_to_cpu(((struct dnode *)qbh.data)->up) != up)\n\t\t\thpfs_error(s, \"hpfs_de_as_down_as_possible: bad up pointer; dnode %08x, down %08x points to %08x\", up, d, le32_to_cpu(((struct dnode *)qbh.data)->up));\n\tif (!de->down) {\n\t\thpfs_brelse4(&qbh);\n\t\treturn d;\n\t}\n\tup = d;\n\td = de_down_pointer(de);\n\thpfs_brelse4(&qbh);\n\tgoto again;\n}"
  },
  {
    "function_name": "map_nth_dirent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/dnode.c",
    "lines": "794-814",
    "snippet": "static struct hpfs_dirent *map_nth_dirent(struct super_block *s, dnode_secno dno, int n,\n\t\t\t\t\t  struct quad_buffer_head *qbh, struct dnode **dn)\n{\n\tint i;\n\tstruct hpfs_dirent *de, *de_end;\n\tstruct dnode *dnode;\n\tdnode = hpfs_map_dnode(s, dno, qbh);\n\tif (!dnode) return NULL;\n\tif (dn) *dn=dnode;\n\tde = dnode_first_de(dnode);\n\tde_end = dnode_end_de(dnode);\n\tfor (i = 1; de < de_end; i++, de = de_next_de(de)) {\n\t\tif (i == n) {\n\t\t\treturn de;\n\t\t}\t\n\t\tif (de->last) break;\n\t}\n\thpfs_brelse4(qbh);\n\thpfs_error(s, \"map_nth_dirent: n too high; dnode = %08x, requested %08x\", dno, n);\n\treturn NULL;\n}",
    "includes": [
      "#include \"hpfs_fn.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hpfs_error",
          "args": [
            "s",
            "\"map_nth_dirent: n too high; dnode = %08x, requested %08x\"",
            "dno",
            "n"
          ],
          "line": 812
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/super.c",
          "lines": "57-86",
          "snippet": "void hpfs_error(struct super_block *s, const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvsnprintf(err_buf, sizeof(err_buf), fmt, args);\n\tva_end(args);\n\n\tpr_err(\"filesystem error: %s\", err_buf);\n\tif (!hpfs_sb(s)->sb_was_error) {\n\t\tif (hpfs_sb(s)->sb_err == 2) {\n\t\t\tpr_cont(\"; crashing the system because you wanted it\\n\");\n\t\t\tmark_dirty(s, 0);\n\t\t\tpanic(\"HPFS panic\");\n\t\t} else if (hpfs_sb(s)->sb_err == 1) {\n\t\t\tif (s->s_flags & MS_RDONLY)\n\t\t\t\tpr_cont(\"; already mounted read-only\\n\");\n\t\t\telse {\n\t\t\t\tpr_cont(\"; remounting read-only\\n\");\n\t\t\t\tmark_dirty(s, 0);\n\t\t\t\ts->s_flags |= MS_RDONLY;\n\t\t\t}\n\t\t} else if (s->s_flags & MS_RDONLY)\n\t\t\t\tpr_cont(\"; going on - but anything won't be destroyed because it's read-only\\n\");\n\t\telse\n\t\t\tpr_cont(\"; corrupted filesystem mounted read/write - your computer will explode within 20 seconds ... but you wanted it so!\\n\");\n\t} else\n\t\tpr_cont(\"\\n\");\n\thpfs_sb(s)->sb_was_error = 1;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/sched.h>",
            "#include <linux/magic.h>",
            "#include <linux/statfs.h>",
            "#include <linux/init.h>",
            "#include <linux/parser.h>",
            "#include <linux/module.h>",
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static char err_buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/bitmap.h>\n#include <linux/sched.h>\n#include <linux/magic.h>\n#include <linux/statfs.h>\n#include <linux/init.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include \"hpfs_fn.h\"\n\nstatic char err_buf[1024];\n\nvoid hpfs_error(struct super_block *s, const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvsnprintf(err_buf, sizeof(err_buf), fmt, args);\n\tva_end(args);\n\n\tpr_err(\"filesystem error: %s\", err_buf);\n\tif (!hpfs_sb(s)->sb_was_error) {\n\t\tif (hpfs_sb(s)->sb_err == 2) {\n\t\t\tpr_cont(\"; crashing the system because you wanted it\\n\");\n\t\t\tmark_dirty(s, 0);\n\t\t\tpanic(\"HPFS panic\");\n\t\t} else if (hpfs_sb(s)->sb_err == 1) {\n\t\t\tif (s->s_flags & MS_RDONLY)\n\t\t\t\tpr_cont(\"; already mounted read-only\\n\");\n\t\t\telse {\n\t\t\t\tpr_cont(\"; remounting read-only\\n\");\n\t\t\t\tmark_dirty(s, 0);\n\t\t\t\ts->s_flags |= MS_RDONLY;\n\t\t\t}\n\t\t} else if (s->s_flags & MS_RDONLY)\n\t\t\t\tpr_cont(\"; going on - but anything won't be destroyed because it's read-only\\n\");\n\t\telse\n\t\t\tpr_cont(\"; corrupted filesystem mounted read/write - your computer will explode within 20 seconds ... but you wanted it so!\\n\");\n\t} else\n\t\tpr_cont(\"\\n\");\n\thpfs_sb(s)->sb_was_error = 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_brelse4",
          "args": [
            "qbh"
          ],
          "line": 811
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_brelse4",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/buffer.c",
          "lines": "182-190",
          "snippet": "void hpfs_brelse4(struct quad_buffer_head *qbh)\n{\n\tif (unlikely(qbh->data != qbh->bh[0]->b_data))\n\t\tkfree(qbh->data);\n\tbrelse(qbh->bh[0]);\n\tbrelse(qbh->bh[1]);\n\tbrelse(qbh->bh[2]);\n\tbrelse(qbh->bh[3]);\n}",
          "includes": [
            "#include \"hpfs_fn.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid hpfs_brelse4(struct quad_buffer_head *qbh)\n{\n\tif (unlikely(qbh->data != qbh->bh[0]->b_data))\n\t\tkfree(qbh->data);\n\tbrelse(qbh->bh[0]);\n\tbrelse(qbh->bh[1]);\n\tbrelse(qbh->bh[2]);\n\tbrelse(qbh->bh[3]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "de_next_de",
          "args": [
            "de"
          ],
          "line": 805
        },
        "resolved": true,
        "details": {
          "function_name": "de_next_de",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "123-127",
          "snippet": "static inline struct hpfs_dirent *de_next_de (struct hpfs_dirent *de)\n{\n  CHKCOND(le16_to_cpu(de->length)>=0x20 && le16_to_cpu(de->length)<0x800,(\"HPFS: de_next_de: de->length = %x\\n\",(unsigned)le16_to_cpu(de->length)));\n  return (void *) de + le16_to_cpu(de->length);\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_add_dirent(struct inode *, const unsigned char *, unsigned,\n\t\t    struct hpfs_dirent *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_add_dirent(struct inode *, const unsigned char *, unsigned,\n\t\t    struct hpfs_dirent *);\n\nstatic inline struct hpfs_dirent *de_next_de (struct hpfs_dirent *de)\n{\n  CHKCOND(le16_to_cpu(de->length)>=0x20 && le16_to_cpu(de->length)<0x800,(\"HPFS: de_next_de: de->length = %x\\n\",(unsigned)le16_to_cpu(de->length)));\n  return (void *) de + le16_to_cpu(de->length);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dnode_end_de",
          "args": [
            "dnode"
          ],
          "line": 804
        },
        "resolved": true,
        "details": {
          "function_name": "dnode_end_de",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "115-119",
          "snippet": "static inline struct hpfs_dirent *dnode_end_de (struct dnode *dnode)\n{\n  CHKCOND(le32_to_cpu(dnode->first_free)>=0x14 && le32_to_cpu(dnode->first_free)<=0xa00,(\"HPFS: dnode_end_de: dnode->first_free = %x\\n\",(unsigned)le32_to_cpu(dnode->first_free)));\n  return (void *) dnode + le32_to_cpu(dnode->first_free);\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_add_dirent(struct inode *, const unsigned char *, unsigned,\n\t\t    struct hpfs_dirent *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_add_dirent(struct inode *, const unsigned char *, unsigned,\n\t\t    struct hpfs_dirent *);\n\nstatic inline struct hpfs_dirent *dnode_end_de (struct dnode *dnode)\n{\n  CHKCOND(le32_to_cpu(dnode->first_free)>=0x14 && le32_to_cpu(dnode->first_free)<=0xa00,(\"HPFS: dnode_end_de: dnode->first_free = %x\\n\",(unsigned)le32_to_cpu(dnode->first_free)));\n  return (void *) dnode + le32_to_cpu(dnode->first_free);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dnode_first_de",
          "args": [
            "dnode"
          ],
          "line": 803
        },
        "resolved": true,
        "details": {
          "function_name": "dnode_first_de",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "108-111",
          "snippet": "static inline struct hpfs_dirent *dnode_first_de (struct dnode *dnode)\n{\n  return (void *) dnode->dirent;\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_add_dirent(struct inode *, const unsigned char *, unsigned,\n\t\t    struct hpfs_dirent *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_add_dirent(struct inode *, const unsigned char *, unsigned,\n\t\t    struct hpfs_dirent *);\n\nstatic inline struct hpfs_dirent *dnode_first_de (struct dnode *dnode)\n{\n  return (void *) dnode->dirent;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_map_dnode",
          "args": [
            "s",
            "dno",
            "qbh"
          ],
          "line": 800
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_map_dnode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/map.c",
          "lines": "229-293",
          "snippet": "struct dnode *hpfs_map_dnode(struct super_block *s, unsigned secno,\n\t\t\t     struct quad_buffer_head *qbh)\n{\n\tstruct dnode *dnode;\n\tif (hpfs_sb(s)->sb_chk) {\n\t\tif (hpfs_chk_sectors(s, secno, 4, \"dnode\")) return NULL;\n\t\tif (secno & 3) {\n\t\t\thpfs_error(s, \"dnode %08x not byte-aligned\", secno);\n\t\t\treturn NULL;\n\t\t}\t\n\t}\n\tif ((dnode = hpfs_map_4sectors(s, secno, qbh, DNODE_RD_AHEAD)))\n\t\tif (hpfs_sb(s)->sb_chk) {\n\t\t\tunsigned p, pp = 0;\n\t\t\tunsigned char *d = (unsigned char *)dnode;\n\t\t\tint b = 0;\n\t\t\tif (le32_to_cpu(dnode->magic) != DNODE_MAGIC) {\n\t\t\t\thpfs_error(s, \"bad magic on dnode %08x\", secno);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tif (le32_to_cpu(dnode->self) != secno)\n\t\t\t\thpfs_error(s, \"bad self pointer on dnode %08x self = %08x\", secno, le32_to_cpu(dnode->self));\n\t\t\t/* Check dirents - bad dirents would cause infinite\n\t\t\t   loops or shooting to memory */\n\t\t\tif (le32_to_cpu(dnode->first_free) > 2048) {\n\t\t\t\thpfs_error(s, \"dnode %08x has first_free == %08x\", secno, le32_to_cpu(dnode->first_free));\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tfor (p = 20; p < le32_to_cpu(dnode->first_free); p += d[p] + (d[p+1] << 8)) {\n\t\t\t\tstruct hpfs_dirent *de = (struct hpfs_dirent *)((char *)dnode + p);\n\t\t\t\tif (le16_to_cpu(de->length) > 292 || (le16_to_cpu(de->length) < 32) || (le16_to_cpu(de->length) & 3) || p + le16_to_cpu(de->length) > 2048) {\n\t\t\t\t\thpfs_error(s, \"bad dirent size in dnode %08x, dirent %03x, last %03x\", secno, p, pp);\n\t\t\t\t\tgoto bail;\n\t\t\t\t}\n\t\t\t\tif (((31 + de->namelen + de->down*4 + 3) & ~3) != le16_to_cpu(de->length)) {\n\t\t\t\t\tif (((31 + de->namelen + de->down*4 + 3) & ~3) < le16_to_cpu(de->length) && s->s_flags & MS_RDONLY) goto ok;\n\t\t\t\t\thpfs_error(s, \"namelen does not match dirent size in dnode %08x, dirent %03x, last %03x\", secno, p, pp);\n\t\t\t\t\tgoto bail;\n\t\t\t\t}\n\t\t\t\tok:\n\t\t\t\tif (hpfs_sb(s)->sb_chk >= 2) b |= 1 << de->down;\n\t\t\t\tif (de->down) if (de_down_pointer(de) < 0x10) {\n\t\t\t\t\thpfs_error(s, \"bad down pointer in dnode %08x, dirent %03x, last %03x\", secno, p, pp);\n\t\t\t\t\tgoto bail;\n\t\t\t\t}\n\t\t\t\tpp = p;\n\t\t\t\t\n\t\t\t}\n\t\t\tif (p != le32_to_cpu(dnode->first_free)) {\n\t\t\t\thpfs_error(s, \"size on last dirent does not match first_free; dnode %08x\", secno);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tif (d[pp + 30] != 1 || d[pp + 31] != 255) {\n\t\t\t\thpfs_error(s, \"dnode %08x does not end with \\\\377 entry\", secno);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tif (b == 3)\n\t\t\t\tpr_err(\"unbalanced dnode tree, dnode %08x; see hpfs.txt 4 more info\\n\",\n\t\t\t\t\tsecno);\n\t\t}\n\treturn dnode;\n\tbail:\n\thpfs_brelse4(qbh);\n\treturn NULL;\n}",
          "includes": [
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n\nstruct dnode *hpfs_map_dnode(struct super_block *s, unsigned secno,\n\t\t\t     struct quad_buffer_head *qbh)\n{\n\tstruct dnode *dnode;\n\tif (hpfs_sb(s)->sb_chk) {\n\t\tif (hpfs_chk_sectors(s, secno, 4, \"dnode\")) return NULL;\n\t\tif (secno & 3) {\n\t\t\thpfs_error(s, \"dnode %08x not byte-aligned\", secno);\n\t\t\treturn NULL;\n\t\t}\t\n\t}\n\tif ((dnode = hpfs_map_4sectors(s, secno, qbh, DNODE_RD_AHEAD)))\n\t\tif (hpfs_sb(s)->sb_chk) {\n\t\t\tunsigned p, pp = 0;\n\t\t\tunsigned char *d = (unsigned char *)dnode;\n\t\t\tint b = 0;\n\t\t\tif (le32_to_cpu(dnode->magic) != DNODE_MAGIC) {\n\t\t\t\thpfs_error(s, \"bad magic on dnode %08x\", secno);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tif (le32_to_cpu(dnode->self) != secno)\n\t\t\t\thpfs_error(s, \"bad self pointer on dnode %08x self = %08x\", secno, le32_to_cpu(dnode->self));\n\t\t\t/* Check dirents - bad dirents would cause infinite\n\t\t\t   loops or shooting to memory */\n\t\t\tif (le32_to_cpu(dnode->first_free) > 2048) {\n\t\t\t\thpfs_error(s, \"dnode %08x has first_free == %08x\", secno, le32_to_cpu(dnode->first_free));\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tfor (p = 20; p < le32_to_cpu(dnode->first_free); p += d[p] + (d[p+1] << 8)) {\n\t\t\t\tstruct hpfs_dirent *de = (struct hpfs_dirent *)((char *)dnode + p);\n\t\t\t\tif (le16_to_cpu(de->length) > 292 || (le16_to_cpu(de->length) < 32) || (le16_to_cpu(de->length) & 3) || p + le16_to_cpu(de->length) > 2048) {\n\t\t\t\t\thpfs_error(s, \"bad dirent size in dnode %08x, dirent %03x, last %03x\", secno, p, pp);\n\t\t\t\t\tgoto bail;\n\t\t\t\t}\n\t\t\t\tif (((31 + de->namelen + de->down*4 + 3) & ~3) != le16_to_cpu(de->length)) {\n\t\t\t\t\tif (((31 + de->namelen + de->down*4 + 3) & ~3) < le16_to_cpu(de->length) && s->s_flags & MS_RDONLY) goto ok;\n\t\t\t\t\thpfs_error(s, \"namelen does not match dirent size in dnode %08x, dirent %03x, last %03x\", secno, p, pp);\n\t\t\t\t\tgoto bail;\n\t\t\t\t}\n\t\t\t\tok:\n\t\t\t\tif (hpfs_sb(s)->sb_chk >= 2) b |= 1 << de->down;\n\t\t\t\tif (de->down) if (de_down_pointer(de) < 0x10) {\n\t\t\t\t\thpfs_error(s, \"bad down pointer in dnode %08x, dirent %03x, last %03x\", secno, p, pp);\n\t\t\t\t\tgoto bail;\n\t\t\t\t}\n\t\t\t\tpp = p;\n\t\t\t\t\n\t\t\t}\n\t\t\tif (p != le32_to_cpu(dnode->first_free)) {\n\t\t\t\thpfs_error(s, \"size on last dirent does not match first_free; dnode %08x\", secno);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tif (d[pp + 30] != 1 || d[pp + 31] != 255) {\n\t\t\t\thpfs_error(s, \"dnode %08x does not end with \\\\377 entry\", secno);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tif (b == 3)\n\t\t\t\tpr_err(\"unbalanced dnode tree, dnode %08x; see hpfs.txt 4 more info\\n\",\n\t\t\t\t\tsecno);\n\t\t}\n\treturn dnode;\n\tbail:\n\thpfs_brelse4(qbh);\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hpfs_fn.h\"\n\nstatic struct hpfs_dirent *map_nth_dirent(struct super_block *s, dnode_secno dno, int n,\n\t\t\t\t\t  struct quad_buffer_head *qbh, struct dnode **dn)\n{\n\tint i;\n\tstruct hpfs_dirent *de, *de_end;\n\tstruct dnode *dnode;\n\tdnode = hpfs_map_dnode(s, dno, qbh);\n\tif (!dnode) return NULL;\n\tif (dn) *dn=dnode;\n\tde = dnode_first_de(dnode);\n\tde_end = dnode_end_de(dnode);\n\tfor (i = 1; de < de_end; i++, de = de_next_de(de)) {\n\t\tif (i == n) {\n\t\t\treturn de;\n\t\t}\t\n\t\tif (de->last) break;\n\t}\n\thpfs_brelse4(qbh);\n\thpfs_error(s, \"map_nth_dirent: n too high; dnode = %08x, requested %08x\", dno, n);\n\treturn NULL;\n}"
  },
  {
    "function_name": "hpfs_count_dnodes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/dnode.c",
    "lines": "741-792",
    "snippet": "void hpfs_count_dnodes(struct super_block *s, dnode_secno dno, int *n_dnodes,\n\t\t       int *n_subdirs, int *n_items)\n{\n\tstruct dnode *dnode;\n\tstruct quad_buffer_head qbh;\n\tstruct hpfs_dirent *de;\n\tdnode_secno ptr, odno = 0;\n\tint c1, c2 = 0;\n\tint d1, d2 = 0;\n\tgo_down:\n\tif (n_dnodes) (*n_dnodes)++;\n\tif (hpfs_sb(s)->sb_chk)\n\t\tif (hpfs_stop_cycles(s, dno, &c1, &c2, \"hpfs_count_dnodes #1\")) return;\n\tptr = 0;\n\tgo_up:\n\tif (!(dnode = hpfs_map_dnode(s, dno, &qbh))) return;\n\tif (hpfs_sb(s)->sb_chk) if (odno && odno != -1 && le32_to_cpu(dnode->up) != odno)\n\t\thpfs_error(s, \"hpfs_count_dnodes: bad up pointer; dnode %08x, down %08x points to %08x\", odno, dno, le32_to_cpu(dnode->up));\n\tde = dnode_first_de(dnode);\n\tif (ptr) while(1) {\n\t\tif (de->down) if (de_down_pointer(de) == ptr) goto process_de;\n\t\tif (de->last) {\n\t\t\thpfs_brelse4(&qbh);\n\t\t\thpfs_error(s, \"hpfs_count_dnodes: pointer to dnode %08x not found in dnode %08x, got here from %08x\",\n\t\t\t\tptr, dno, odno);\n\t\t\treturn;\n\t\t}\n\t\tde = de_next_de(de);\n\t}\n\tnext_de:\n\tif (de->down) {\n\t\todno = dno;\n\t\tdno = de_down_pointer(de);\n\t\thpfs_brelse4(&qbh);\n\t\tgoto go_down;\n\t}\n\tprocess_de:\n\tif (!de->first && !de->last && de->directory && n_subdirs) (*n_subdirs)++;\n\tif (!de->first && !de->last && n_items) (*n_items)++;\n\tif ((de = de_next_de(de)) < dnode_end_de(dnode)) goto next_de;\n\tptr = dno;\n\tdno = le32_to_cpu(dnode->up);\n\tif (dnode->root_dnode) {\n\t\thpfs_brelse4(&qbh);\n\t\treturn;\n\t}\n\thpfs_brelse4(&qbh);\n\tif (hpfs_sb(s)->sb_chk)\n\t\tif (hpfs_stop_cycles(s, ptr, &d1, &d2, \"hpfs_count_dnodes #2\")) return;\n\todno = -1;\n\tgoto go_up;\n}",
    "includes": [
      "#include \"hpfs_fn.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hpfs_stop_cycles",
          "args": [
            "s",
            "ptr",
            "&d1",
            "&d2",
            "\"hpfs_count_dnodes #2\""
          ],
          "line": 789
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_stop_cycles",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/super.c",
          "lines": "96-106",
          "snippet": "int hpfs_stop_cycles(struct super_block *s, int key, int *c1, int *c2,\n\t\tchar *msg)\n{\n\tif (*c2 && *c1 == key) {\n\t\thpfs_error(s, \"cycle detected on key %08x in %s\", key, msg);\n\t\treturn 1;\n\t}\n\t(*c2)++;\n\tif (!((*c2 - 1) & *c2)) *c1 = key;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/sched.h>",
            "#include <linux/magic.h>",
            "#include <linux/statfs.h>",
            "#include <linux/init.h>",
            "#include <linux/parser.h>",
            "#include <linux/module.h>",
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/bitmap.h>\n#include <linux/sched.h>\n#include <linux/magic.h>\n#include <linux/statfs.h>\n#include <linux/init.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include \"hpfs_fn.h\"\n\nint hpfs_stop_cycles(struct super_block *s, int key, int *c1, int *c2,\n\t\tchar *msg)\n{\n\tif (*c2 && *c1 == key) {\n\t\thpfs_error(s, \"cycle detected on key %08x in %s\", key, msg);\n\t\treturn 1;\n\t}\n\t(*c2)++;\n\tif (!((*c2 - 1) & *c2)) *c1 = key;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_sb",
          "args": [
            "s"
          ],
          "line": 788
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_sb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "310-313",
          "snippet": "static inline struct hpfs_sb_info *hpfs_sb(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_check_free_dnodes(struct super_block *, int);",
            "void hpfs_prefetch_sectors(struct super_block *, unsigned, int);",
            "void hpfs_prefetch_bitmap(struct super_block *, unsigned);",
            "unsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);",
            "int hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);",
            "void hpfs_error(struct super_block *, const char *, ...);",
            "int hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);",
            "unsigned hpfs_get_free_dnodes(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_check_free_dnodes(struct super_block *, int);\nvoid hpfs_prefetch_sectors(struct super_block *, unsigned, int);\nvoid hpfs_prefetch_bitmap(struct super_block *, unsigned);\nunsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);\nint hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);\nvoid hpfs_error(struct super_block *, const char *, ...);\nint hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);\nunsigned hpfs_get_free_dnodes(struct super_block *);\n\nstatic inline struct hpfs_sb_info *hpfs_sb(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_brelse4",
          "args": [
            "&qbh"
          ],
          "line": 787
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_brelse4",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/buffer.c",
          "lines": "182-190",
          "snippet": "void hpfs_brelse4(struct quad_buffer_head *qbh)\n{\n\tif (unlikely(qbh->data != qbh->bh[0]->b_data))\n\t\tkfree(qbh->data);\n\tbrelse(qbh->bh[0]);\n\tbrelse(qbh->bh[1]);\n\tbrelse(qbh->bh[2]);\n\tbrelse(qbh->bh[3]);\n}",
          "includes": [
            "#include \"hpfs_fn.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid hpfs_brelse4(struct quad_buffer_head *qbh)\n{\n\tif (unlikely(qbh->data != qbh->bh[0]->b_data))\n\t\tkfree(qbh->data);\n\tbrelse(qbh->bh[0]);\n\tbrelse(qbh->bh[1]);\n\tbrelse(qbh->bh[2]);\n\tbrelse(qbh->bh[3]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "dnode->up"
          ],
          "line": 782
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dnode_end_de",
          "args": [
            "dnode"
          ],
          "line": 780
        },
        "resolved": true,
        "details": {
          "function_name": "dnode_end_de",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "115-119",
          "snippet": "static inline struct hpfs_dirent *dnode_end_de (struct dnode *dnode)\n{\n  CHKCOND(le32_to_cpu(dnode->first_free)>=0x14 && le32_to_cpu(dnode->first_free)<=0xa00,(\"HPFS: dnode_end_de: dnode->first_free = %x\\n\",(unsigned)le32_to_cpu(dnode->first_free)));\n  return (void *) dnode + le32_to_cpu(dnode->first_free);\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_add_dirent(struct inode *, const unsigned char *, unsigned,\n\t\t    struct hpfs_dirent *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_add_dirent(struct inode *, const unsigned char *, unsigned,\n\t\t    struct hpfs_dirent *);\n\nstatic inline struct hpfs_dirent *dnode_end_de (struct dnode *dnode)\n{\n  CHKCOND(le32_to_cpu(dnode->first_free)>=0x14 && le32_to_cpu(dnode->first_free)<=0xa00,(\"HPFS: dnode_end_de: dnode->first_free = %x\\n\",(unsigned)le32_to_cpu(dnode->first_free)));\n  return (void *) dnode + le32_to_cpu(dnode->first_free);\n}"
        }
      },
      {
        "call_info": {
          "callee": "de_next_de",
          "args": [
            "de"
          ],
          "line": 780
        },
        "resolved": true,
        "details": {
          "function_name": "de_next_de",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "123-127",
          "snippet": "static inline struct hpfs_dirent *de_next_de (struct hpfs_dirent *de)\n{\n  CHKCOND(le16_to_cpu(de->length)>=0x20 && le16_to_cpu(de->length)<0x800,(\"HPFS: de_next_de: de->length = %x\\n\",(unsigned)le16_to_cpu(de->length)));\n  return (void *) de + le16_to_cpu(de->length);\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_add_dirent(struct inode *, const unsigned char *, unsigned,\n\t\t    struct hpfs_dirent *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_add_dirent(struct inode *, const unsigned char *, unsigned,\n\t\t    struct hpfs_dirent *);\n\nstatic inline struct hpfs_dirent *de_next_de (struct hpfs_dirent *de)\n{\n  CHKCOND(le16_to_cpu(de->length)>=0x20 && le16_to_cpu(de->length)<0x800,(\"HPFS: de_next_de: de->length = %x\\n\",(unsigned)le16_to_cpu(de->length)));\n  return (void *) de + le16_to_cpu(de->length);\n}"
        }
      },
      {
        "call_info": {
          "callee": "de_down_pointer",
          "args": [
            "de"
          ],
          "line": 773
        },
        "resolved": true,
        "details": {
          "function_name": "de_down_pointer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "100-104",
          "snippet": "static inline dnode_secno de_down_pointer (struct hpfs_dirent *de)\n{\n  CHKCOND(de->down,(\"HPFS: de_down_pointer: !de->down\\n\"));\n  return le32_to_cpu(*(__le32 *) ((void *) de + le16_to_cpu(de->length) - 4));\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_add_dirent(struct inode *, const unsigned char *, unsigned,\n\t\t    struct hpfs_dirent *);",
            "void hpfs_count_dnodes(struct super_block *, dnode_secno, int *, int *, int *);",
            "void hpfs_remove_dtree(struct super_block *, dnode_secno);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_add_dirent(struct inode *, const unsigned char *, unsigned,\n\t\t    struct hpfs_dirent *);\nvoid hpfs_count_dnodes(struct super_block *, dnode_secno, int *, int *, int *);\nvoid hpfs_remove_dtree(struct super_block *, dnode_secno);\n\nstatic inline dnode_secno de_down_pointer (struct hpfs_dirent *de)\n{\n  CHKCOND(de->down,(\"HPFS: de_down_pointer: !de->down\\n\"));\n  return le32_to_cpu(*(__le32 *) ((void *) de + le16_to_cpu(de->length) - 4));\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_error",
          "args": [
            "s",
            "\"hpfs_count_dnodes: pointer to dnode %08x not found in dnode %08x, got here from %08x\"",
            "ptr",
            "dno",
            "odno"
          ],
          "line": 764
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/super.c",
          "lines": "57-86",
          "snippet": "void hpfs_error(struct super_block *s, const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvsnprintf(err_buf, sizeof(err_buf), fmt, args);\n\tva_end(args);\n\n\tpr_err(\"filesystem error: %s\", err_buf);\n\tif (!hpfs_sb(s)->sb_was_error) {\n\t\tif (hpfs_sb(s)->sb_err == 2) {\n\t\t\tpr_cont(\"; crashing the system because you wanted it\\n\");\n\t\t\tmark_dirty(s, 0);\n\t\t\tpanic(\"HPFS panic\");\n\t\t} else if (hpfs_sb(s)->sb_err == 1) {\n\t\t\tif (s->s_flags & MS_RDONLY)\n\t\t\t\tpr_cont(\"; already mounted read-only\\n\");\n\t\t\telse {\n\t\t\t\tpr_cont(\"; remounting read-only\\n\");\n\t\t\t\tmark_dirty(s, 0);\n\t\t\t\ts->s_flags |= MS_RDONLY;\n\t\t\t}\n\t\t} else if (s->s_flags & MS_RDONLY)\n\t\t\t\tpr_cont(\"; going on - but anything won't be destroyed because it's read-only\\n\");\n\t\telse\n\t\t\tpr_cont(\"; corrupted filesystem mounted read/write - your computer will explode within 20 seconds ... but you wanted it so!\\n\");\n\t} else\n\t\tpr_cont(\"\\n\");\n\thpfs_sb(s)->sb_was_error = 1;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/sched.h>",
            "#include <linux/magic.h>",
            "#include <linux/statfs.h>",
            "#include <linux/init.h>",
            "#include <linux/parser.h>",
            "#include <linux/module.h>",
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static char err_buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/bitmap.h>\n#include <linux/sched.h>\n#include <linux/magic.h>\n#include <linux/statfs.h>\n#include <linux/init.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include \"hpfs_fn.h\"\n\nstatic char err_buf[1024];\n\nvoid hpfs_error(struct super_block *s, const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvsnprintf(err_buf, sizeof(err_buf), fmt, args);\n\tva_end(args);\n\n\tpr_err(\"filesystem error: %s\", err_buf);\n\tif (!hpfs_sb(s)->sb_was_error) {\n\t\tif (hpfs_sb(s)->sb_err == 2) {\n\t\t\tpr_cont(\"; crashing the system because you wanted it\\n\");\n\t\t\tmark_dirty(s, 0);\n\t\t\tpanic(\"HPFS panic\");\n\t\t} else if (hpfs_sb(s)->sb_err == 1) {\n\t\t\tif (s->s_flags & MS_RDONLY)\n\t\t\t\tpr_cont(\"; already mounted read-only\\n\");\n\t\t\telse {\n\t\t\t\tpr_cont(\"; remounting read-only\\n\");\n\t\t\t\tmark_dirty(s, 0);\n\t\t\t\ts->s_flags |= MS_RDONLY;\n\t\t\t}\n\t\t} else if (s->s_flags & MS_RDONLY)\n\t\t\t\tpr_cont(\"; going on - but anything won't be destroyed because it's read-only\\n\");\n\t\telse\n\t\t\tpr_cont(\"; corrupted filesystem mounted read/write - your computer will explode within 20 seconds ... but you wanted it so!\\n\");\n\t} else\n\t\tpr_cont(\"\\n\");\n\thpfs_sb(s)->sb_was_error = 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dnode_first_de",
          "args": [
            "dnode"
          ],
          "line": 759
        },
        "resolved": true,
        "details": {
          "function_name": "dnode_first_de",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "108-111",
          "snippet": "static inline struct hpfs_dirent *dnode_first_de (struct dnode *dnode)\n{\n  return (void *) dnode->dirent;\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_add_dirent(struct inode *, const unsigned char *, unsigned,\n\t\t    struct hpfs_dirent *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_add_dirent(struct inode *, const unsigned char *, unsigned,\n\t\t    struct hpfs_dirent *);\n\nstatic inline struct hpfs_dirent *dnode_first_de (struct dnode *dnode)\n{\n  return (void *) dnode->dirent;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_map_dnode",
          "args": [
            "s",
            "dno",
            "&qbh"
          ],
          "line": 756
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_map_dnode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/map.c",
          "lines": "229-293",
          "snippet": "struct dnode *hpfs_map_dnode(struct super_block *s, unsigned secno,\n\t\t\t     struct quad_buffer_head *qbh)\n{\n\tstruct dnode *dnode;\n\tif (hpfs_sb(s)->sb_chk) {\n\t\tif (hpfs_chk_sectors(s, secno, 4, \"dnode\")) return NULL;\n\t\tif (secno & 3) {\n\t\t\thpfs_error(s, \"dnode %08x not byte-aligned\", secno);\n\t\t\treturn NULL;\n\t\t}\t\n\t}\n\tif ((dnode = hpfs_map_4sectors(s, secno, qbh, DNODE_RD_AHEAD)))\n\t\tif (hpfs_sb(s)->sb_chk) {\n\t\t\tunsigned p, pp = 0;\n\t\t\tunsigned char *d = (unsigned char *)dnode;\n\t\t\tint b = 0;\n\t\t\tif (le32_to_cpu(dnode->magic) != DNODE_MAGIC) {\n\t\t\t\thpfs_error(s, \"bad magic on dnode %08x\", secno);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tif (le32_to_cpu(dnode->self) != secno)\n\t\t\t\thpfs_error(s, \"bad self pointer on dnode %08x self = %08x\", secno, le32_to_cpu(dnode->self));\n\t\t\t/* Check dirents - bad dirents would cause infinite\n\t\t\t   loops or shooting to memory */\n\t\t\tif (le32_to_cpu(dnode->first_free) > 2048) {\n\t\t\t\thpfs_error(s, \"dnode %08x has first_free == %08x\", secno, le32_to_cpu(dnode->first_free));\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tfor (p = 20; p < le32_to_cpu(dnode->first_free); p += d[p] + (d[p+1] << 8)) {\n\t\t\t\tstruct hpfs_dirent *de = (struct hpfs_dirent *)((char *)dnode + p);\n\t\t\t\tif (le16_to_cpu(de->length) > 292 || (le16_to_cpu(de->length) < 32) || (le16_to_cpu(de->length) & 3) || p + le16_to_cpu(de->length) > 2048) {\n\t\t\t\t\thpfs_error(s, \"bad dirent size in dnode %08x, dirent %03x, last %03x\", secno, p, pp);\n\t\t\t\t\tgoto bail;\n\t\t\t\t}\n\t\t\t\tif (((31 + de->namelen + de->down*4 + 3) & ~3) != le16_to_cpu(de->length)) {\n\t\t\t\t\tif (((31 + de->namelen + de->down*4 + 3) & ~3) < le16_to_cpu(de->length) && s->s_flags & MS_RDONLY) goto ok;\n\t\t\t\t\thpfs_error(s, \"namelen does not match dirent size in dnode %08x, dirent %03x, last %03x\", secno, p, pp);\n\t\t\t\t\tgoto bail;\n\t\t\t\t}\n\t\t\t\tok:\n\t\t\t\tif (hpfs_sb(s)->sb_chk >= 2) b |= 1 << de->down;\n\t\t\t\tif (de->down) if (de_down_pointer(de) < 0x10) {\n\t\t\t\t\thpfs_error(s, \"bad down pointer in dnode %08x, dirent %03x, last %03x\", secno, p, pp);\n\t\t\t\t\tgoto bail;\n\t\t\t\t}\n\t\t\t\tpp = p;\n\t\t\t\t\n\t\t\t}\n\t\t\tif (p != le32_to_cpu(dnode->first_free)) {\n\t\t\t\thpfs_error(s, \"size on last dirent does not match first_free; dnode %08x\", secno);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tif (d[pp + 30] != 1 || d[pp + 31] != 255) {\n\t\t\t\thpfs_error(s, \"dnode %08x does not end with \\\\377 entry\", secno);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tif (b == 3)\n\t\t\t\tpr_err(\"unbalanced dnode tree, dnode %08x; see hpfs.txt 4 more info\\n\",\n\t\t\t\t\tsecno);\n\t\t}\n\treturn dnode;\n\tbail:\n\thpfs_brelse4(qbh);\n\treturn NULL;\n}",
          "includes": [
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n\nstruct dnode *hpfs_map_dnode(struct super_block *s, unsigned secno,\n\t\t\t     struct quad_buffer_head *qbh)\n{\n\tstruct dnode *dnode;\n\tif (hpfs_sb(s)->sb_chk) {\n\t\tif (hpfs_chk_sectors(s, secno, 4, \"dnode\")) return NULL;\n\t\tif (secno & 3) {\n\t\t\thpfs_error(s, \"dnode %08x not byte-aligned\", secno);\n\t\t\treturn NULL;\n\t\t}\t\n\t}\n\tif ((dnode = hpfs_map_4sectors(s, secno, qbh, DNODE_RD_AHEAD)))\n\t\tif (hpfs_sb(s)->sb_chk) {\n\t\t\tunsigned p, pp = 0;\n\t\t\tunsigned char *d = (unsigned char *)dnode;\n\t\t\tint b = 0;\n\t\t\tif (le32_to_cpu(dnode->magic) != DNODE_MAGIC) {\n\t\t\t\thpfs_error(s, \"bad magic on dnode %08x\", secno);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tif (le32_to_cpu(dnode->self) != secno)\n\t\t\t\thpfs_error(s, \"bad self pointer on dnode %08x self = %08x\", secno, le32_to_cpu(dnode->self));\n\t\t\t/* Check dirents - bad dirents would cause infinite\n\t\t\t   loops or shooting to memory */\n\t\t\tif (le32_to_cpu(dnode->first_free) > 2048) {\n\t\t\t\thpfs_error(s, \"dnode %08x has first_free == %08x\", secno, le32_to_cpu(dnode->first_free));\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tfor (p = 20; p < le32_to_cpu(dnode->first_free); p += d[p] + (d[p+1] << 8)) {\n\t\t\t\tstruct hpfs_dirent *de = (struct hpfs_dirent *)((char *)dnode + p);\n\t\t\t\tif (le16_to_cpu(de->length) > 292 || (le16_to_cpu(de->length) < 32) || (le16_to_cpu(de->length) & 3) || p + le16_to_cpu(de->length) > 2048) {\n\t\t\t\t\thpfs_error(s, \"bad dirent size in dnode %08x, dirent %03x, last %03x\", secno, p, pp);\n\t\t\t\t\tgoto bail;\n\t\t\t\t}\n\t\t\t\tif (((31 + de->namelen + de->down*4 + 3) & ~3) != le16_to_cpu(de->length)) {\n\t\t\t\t\tif (((31 + de->namelen + de->down*4 + 3) & ~3) < le16_to_cpu(de->length) && s->s_flags & MS_RDONLY) goto ok;\n\t\t\t\t\thpfs_error(s, \"namelen does not match dirent size in dnode %08x, dirent %03x, last %03x\", secno, p, pp);\n\t\t\t\t\tgoto bail;\n\t\t\t\t}\n\t\t\t\tok:\n\t\t\t\tif (hpfs_sb(s)->sb_chk >= 2) b |= 1 << de->down;\n\t\t\t\tif (de->down) if (de_down_pointer(de) < 0x10) {\n\t\t\t\t\thpfs_error(s, \"bad down pointer in dnode %08x, dirent %03x, last %03x\", secno, p, pp);\n\t\t\t\t\tgoto bail;\n\t\t\t\t}\n\t\t\t\tpp = p;\n\t\t\t\t\n\t\t\t}\n\t\t\tif (p != le32_to_cpu(dnode->first_free)) {\n\t\t\t\thpfs_error(s, \"size on last dirent does not match first_free; dnode %08x\", secno);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tif (d[pp + 30] != 1 || d[pp + 31] != 255) {\n\t\t\t\thpfs_error(s, \"dnode %08x does not end with \\\\377 entry\", secno);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tif (b == 3)\n\t\t\t\tpr_err(\"unbalanced dnode tree, dnode %08x; see hpfs.txt 4 more info\\n\",\n\t\t\t\t\tsecno);\n\t\t}\n\treturn dnode;\n\tbail:\n\thpfs_brelse4(qbh);\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hpfs_fn.h\"\n\nvoid hpfs_count_dnodes(struct super_block *s, dnode_secno dno, int *n_dnodes,\n\t\t       int *n_subdirs, int *n_items)\n{\n\tstruct dnode *dnode;\n\tstruct quad_buffer_head qbh;\n\tstruct hpfs_dirent *de;\n\tdnode_secno ptr, odno = 0;\n\tint c1, c2 = 0;\n\tint d1, d2 = 0;\n\tgo_down:\n\tif (n_dnodes) (*n_dnodes)++;\n\tif (hpfs_sb(s)->sb_chk)\n\t\tif (hpfs_stop_cycles(s, dno, &c1, &c2, \"hpfs_count_dnodes #1\")) return;\n\tptr = 0;\n\tgo_up:\n\tif (!(dnode = hpfs_map_dnode(s, dno, &qbh))) return;\n\tif (hpfs_sb(s)->sb_chk) if (odno && odno != -1 && le32_to_cpu(dnode->up) != odno)\n\t\thpfs_error(s, \"hpfs_count_dnodes: bad up pointer; dnode %08x, down %08x points to %08x\", odno, dno, le32_to_cpu(dnode->up));\n\tde = dnode_first_de(dnode);\n\tif (ptr) while(1) {\n\t\tif (de->down) if (de_down_pointer(de) == ptr) goto process_de;\n\t\tif (de->last) {\n\t\t\thpfs_brelse4(&qbh);\n\t\t\thpfs_error(s, \"hpfs_count_dnodes: pointer to dnode %08x not found in dnode %08x, got here from %08x\",\n\t\t\t\tptr, dno, odno);\n\t\t\treturn;\n\t\t}\n\t\tde = de_next_de(de);\n\t}\n\tnext_de:\n\tif (de->down) {\n\t\todno = dno;\n\t\tdno = de_down_pointer(de);\n\t\thpfs_brelse4(&qbh);\n\t\tgoto go_down;\n\t}\n\tprocess_de:\n\tif (!de->first && !de->last && de->directory && n_subdirs) (*n_subdirs)++;\n\tif (!de->first && !de->last && n_items) (*n_items)++;\n\tif ((de = de_next_de(de)) < dnode_end_de(dnode)) goto next_de;\n\tptr = dno;\n\tdno = le32_to_cpu(dnode->up);\n\tif (dnode->root_dnode) {\n\t\thpfs_brelse4(&qbh);\n\t\treturn;\n\t}\n\thpfs_brelse4(&qbh);\n\tif (hpfs_sb(s)->sb_chk)\n\t\tif (hpfs_stop_cycles(s, ptr, &d1, &d2, \"hpfs_count_dnodes #2\")) return;\n\todno = -1;\n\tgoto go_up;\n}"
  },
  {
    "function_name": "hpfs_remove_dirent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/dnode.c",
    "lines": "708-739",
    "snippet": "int hpfs_remove_dirent(struct inode *i, dnode_secno dno, struct hpfs_dirent *de,\n\t\t       struct quad_buffer_head *qbh, int depth)\n{\n\tstruct dnode *dnode = qbh->data;\n\tdnode_secno down = 0;\n\tloff_t t;\n\tif (de->first || de->last) {\n\t\thpfs_error(i->i_sb, \"hpfs_remove_dirent: attempt to delete first or last dirent in dnode %08x\", dno);\n\t\thpfs_brelse4(qbh);\n\t\treturn 1;\n\t}\n\tif (de->down) down = de_down_pointer(de);\n\tif (depth && (de->down || (de == dnode_first_de(dnode) && de_next_de(de)->last))) {\n\t\tif (hpfs_check_free_dnodes(i->i_sb, FREE_DNODES_DEL)) {\n\t\t\thpfs_brelse4(qbh);\n\t\t\treturn 2;\n\t\t}\n\t}\n\ti->i_version++;\n\tfor_all_poss(i, hpfs_pos_del, (t = get_pos(dnode, de)) + 1, 1);\n\thpfs_delete_de(i->i_sb, dnode, de);\n\thpfs_mark_4buffers_dirty(qbh);\n\thpfs_brelse4(qbh);\n\tif (down) {\n\t\tdnode_secno a = move_to_top(i, down, dno);\n\t\tfor_all_poss(i, hpfs_pos_subst, 5, t);\n\t\tif (a) delete_empty_dnode(i, a);\n\t\treturn !a;\n\t}\n\tdelete_empty_dnode(i, dno);\n\treturn 0;\n}",
    "includes": [
      "#include \"hpfs_fn.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "delete_empty_dnode",
          "args": [
            "i",
            "dno"
          ],
          "line": 737
        },
        "resolved": true,
        "details": {
          "function_name": "delete_empty_dnode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/dnode.c",
          "lines": "515-703",
          "snippet": "static void delete_empty_dnode(struct inode *i, dnode_secno dno)\n{\n\tstruct hpfs_inode_info *hpfs_inode = hpfs_i(i);\n\tstruct quad_buffer_head qbh;\n\tstruct dnode *dnode;\n\tdnode_secno down, up, ndown;\n\tint p;\n\tstruct hpfs_dirent *de;\n\tint c1, c2 = 0;\n\ttry_it_again:\n\tif (hpfs_stop_cycles(i->i_sb, dno, &c1, &c2, \"delete_empty_dnode\")) return;\n\tif (!(dnode = hpfs_map_dnode(i->i_sb, dno, &qbh))) return;\n\tif (le32_to_cpu(dnode->first_free) > 56) goto end;\n\tif (le32_to_cpu(dnode->first_free) == 52 || le32_to_cpu(dnode->first_free) == 56) {\n\t\tstruct hpfs_dirent *de_end;\n\t\tint root = dnode->root_dnode;\n\t\tup = le32_to_cpu(dnode->up);\n\t\tde = dnode_first_de(dnode);\n\t\tdown = de->down ? de_down_pointer(de) : 0;\n\t\tif (hpfs_sb(i->i_sb)->sb_chk) if (root && !down) {\n\t\t\thpfs_error(i->i_sb, \"delete_empty_dnode: root dnode %08x is empty\", dno);\n\t\t\tgoto end;\n\t\t}\n\t\thpfs_brelse4(&qbh);\n\t\thpfs_free_dnode(i->i_sb, dno);\n\t\ti->i_size -= 2048;\n\t\ti->i_blocks -= 4;\n\t\tif (root) {\n\t\t\tstruct fnode *fnode;\n\t\t\tstruct buffer_head *bh;\n\t\t\tstruct dnode *d1;\n\t\t\tstruct quad_buffer_head qbh1;\n\t\t\tif (hpfs_sb(i->i_sb)->sb_chk)\n\t\t\t\tif (up != i->i_ino) {\n\t\t\t\t\thpfs_error(i->i_sb,\n\t\t\t\t\t\t   \"bad pointer to fnode, dnode %08x, pointing to %08x, should be %08lx\",\n\t\t\t\t\t\t   dno, up,\n\t\t\t\t\t\t   (unsigned long)i->i_ino);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\tif ((d1 = hpfs_map_dnode(i->i_sb, down, &qbh1))) {\n\t\t\t\td1->up = cpu_to_le32(up);\n\t\t\t\td1->root_dnode = 1;\n\t\t\t\thpfs_mark_4buffers_dirty(&qbh1);\n\t\t\t\thpfs_brelse4(&qbh1);\n\t\t\t}\n\t\t\tif ((fnode = hpfs_map_fnode(i->i_sb, up, &bh))) {\n\t\t\t\tfnode->u.external[0].disk_secno = cpu_to_le32(down);\n\t\t\t\tmark_buffer_dirty(bh);\n\t\t\t\tbrelse(bh);\n\t\t\t}\n\t\t\thpfs_inode->i_dno = down;\n\t\t\tfor_all_poss(i, hpfs_pos_subst, ((loff_t)dno << 4) | 1, (loff_t) 12);\n\t\t\treturn;\n\t\t}\n\t\tif (!(dnode = hpfs_map_dnode(i->i_sb, up, &qbh))) return;\n\t\tp = 1;\n\t\tde_end = dnode_end_de(dnode);\n\t\tfor (de = dnode_first_de(dnode); de < de_end; de = de_next_de(de), p++)\n\t\t\tif (de->down) if (de_down_pointer(de) == dno) goto fnd;\n\t\thpfs_error(i->i_sb, \"delete_empty_dnode: pointer to dnode %08x not found in dnode %08x\", dno, up);\n\t\tgoto end;\n\t\tfnd:\n\t\tfor_all_poss(i, hpfs_pos_subst, ((loff_t)dno << 4) | 1, ((loff_t)up << 4) | p);\n\t\tif (!down) {\n\t\t\tde->down = 0;\n\t\t\tle16_add_cpu(&de->length, -4);\n\t\t\tle32_add_cpu(&dnode->first_free, -4);\n\t\t\tmemmove(de_next_de(de), (char *)de_next_de(de) + 4,\n\t\t\t\t(char *)dnode + le32_to_cpu(dnode->first_free) - (char *)de_next_de(de));\n\t\t} else {\n\t\t\tstruct dnode *d1;\n\t\t\tstruct quad_buffer_head qbh1;\n\t\t\t*(dnode_secno *) ((void *) de + le16_to_cpu(de->length) - 4) = down;\n\t\t\tif ((d1 = hpfs_map_dnode(i->i_sb, down, &qbh1))) {\n\t\t\t\td1->up = cpu_to_le32(up);\n\t\t\t\thpfs_mark_4buffers_dirty(&qbh1);\n\t\t\t\thpfs_brelse4(&qbh1);\n\t\t\t}\n\t\t}\n\t} else {\n\t\thpfs_error(i->i_sb, \"delete_empty_dnode: dnode %08x, first_free == %03x\", dno, le32_to_cpu(dnode->first_free));\n\t\tgoto end;\n\t}\n\n\tif (!de->last) {\n\t\tstruct hpfs_dirent *de_next = de_next_de(de);\n\t\tstruct hpfs_dirent *de_cp;\n\t\tstruct dnode *d1;\n\t\tstruct quad_buffer_head qbh1;\n\t\tif (!de_next->down) goto endm;\n\t\tndown = de_down_pointer(de_next);\n\t\tif (!(de_cp = kmalloc(le16_to_cpu(de->length), GFP_NOFS))) {\n\t\t\tpr_err(\"out of memory for dtree balancing\\n\");\n\t\t\tgoto endm;\n\t\t}\n\t\tmemcpy(de_cp, de, le16_to_cpu(de->length));\n\t\thpfs_delete_de(i->i_sb, dnode, de);\n\t\thpfs_mark_4buffers_dirty(&qbh);\n\t\thpfs_brelse4(&qbh);\n\t\tfor_all_poss(i, hpfs_pos_subst, ((loff_t)up << 4) | p, 4);\n\t\tfor_all_poss(i, hpfs_pos_del, ((loff_t)up << 4) | p, 1);\n\t\tif (de_cp->down) if ((d1 = hpfs_map_dnode(i->i_sb, de_down_pointer(de_cp), &qbh1))) {\n\t\t\td1->up = cpu_to_le32(ndown);\n\t\t\thpfs_mark_4buffers_dirty(&qbh1);\n\t\t\thpfs_brelse4(&qbh1);\n\t\t}\n\t\thpfs_add_to_dnode(i, ndown, de_cp->name, de_cp->namelen, de_cp, de_cp->down ? de_down_pointer(de_cp) : 0);\n\t\t/*pr_info(\"UP-TO-DNODE: %08x (ndown = %08x, down = %08x, dno = %08x)\\n\",\n\t\t  up, ndown, down, dno);*/\n\t\tdno = up;\n\t\tkfree(de_cp);\n\t\tgoto try_it_again;\n\t} else {\n\t\tstruct hpfs_dirent *de_prev = dnode_pre_last_de(dnode);\n\t\tstruct hpfs_dirent *de_cp;\n\t\tstruct dnode *d1;\n\t\tstruct quad_buffer_head qbh1;\n\t\tdnode_secno dlp;\n\t\tif (!de_prev) {\n\t\t\thpfs_error(i->i_sb, \"delete_empty_dnode: empty dnode %08x\", up);\n\t\t\thpfs_mark_4buffers_dirty(&qbh);\n\t\t\thpfs_brelse4(&qbh);\n\t\t\tdno = up;\n\t\t\tgoto try_it_again;\n\t\t}\n\t\tif (!de_prev->down) goto endm;\n\t\tndown = de_down_pointer(de_prev);\n\t\tif ((d1 = hpfs_map_dnode(i->i_sb, ndown, &qbh1))) {\n\t\t\tstruct hpfs_dirent *del = dnode_last_de(d1);\n\t\t\tdlp = del->down ? de_down_pointer(del) : 0;\n\t\t\tif (!dlp && down) {\n\t\t\t\tif (le32_to_cpu(d1->first_free) > 2044) {\n\t\t\t\t\tif (hpfs_sb(i->i_sb)->sb_chk >= 2) {\n\t\t\t\t\t\tpr_err(\"unbalanced dnode tree, see hpfs.txt 4 more info\\n\");\n\t\t\t\t\t\tpr_err(\"terminating balancing operation\\n\");\n\t\t\t\t\t}\n\t\t\t\t\thpfs_brelse4(&qbh1);\n\t\t\t\t\tgoto endm;\n\t\t\t\t}\n\t\t\t\tif (hpfs_sb(i->i_sb)->sb_chk >= 2) {\n\t\t\t\t\tpr_err(\"unbalanced dnode tree, see hpfs.txt 4 more info\\n\");\n\t\t\t\t\tpr_err(\"goin'on\\n\");\n\t\t\t\t}\n\t\t\t\tle16_add_cpu(&del->length, 4);\n\t\t\t\tdel->down = 1;\n\t\t\t\tle32_add_cpu(&d1->first_free, 4);\n\t\t\t}\n\t\t\tif (dlp && !down) {\n\t\t\t\tle16_add_cpu(&del->length, -4);\n\t\t\t\tdel->down = 0;\n\t\t\t\tle32_add_cpu(&d1->first_free, -4);\n\t\t\t} else if (down)\n\t\t\t\t*(__le32 *) ((void *) del + le16_to_cpu(del->length) - 4) = cpu_to_le32(down);\n\t\t} else goto endm;\n\t\tif (!(de_cp = kmalloc(le16_to_cpu(de_prev->length), GFP_NOFS))) {\n\t\t\tpr_err(\"out of memory for dtree balancing\\n\");\n\t\t\thpfs_brelse4(&qbh1);\n\t\t\tgoto endm;\n\t\t}\n\t\thpfs_mark_4buffers_dirty(&qbh1);\n\t\thpfs_brelse4(&qbh1);\n\t\tmemcpy(de_cp, de_prev, le16_to_cpu(de_prev->length));\n\t\thpfs_delete_de(i->i_sb, dnode, de_prev);\n\t\tif (!de_prev->down) {\n\t\t\tle16_add_cpu(&de_prev->length, 4);\n\t\t\tde_prev->down = 1;\n\t\t\tle32_add_cpu(&dnode->first_free, 4);\n\t\t}\n\t\t*(__le32 *) ((void *) de_prev + le16_to_cpu(de_prev->length) - 4) = cpu_to_le32(ndown);\n\t\thpfs_mark_4buffers_dirty(&qbh);\n\t\thpfs_brelse4(&qbh);\n\t\tfor_all_poss(i, hpfs_pos_subst, ((loff_t)up << 4) | (p - 1), 4);\n\t\tfor_all_poss(i, hpfs_pos_subst, ((loff_t)up << 4) | p, ((loff_t)up << 4) | (p - 1));\n\t\tif (down) if ((d1 = hpfs_map_dnode(i->i_sb, de_down_pointer(de), &qbh1))) {\n\t\t\td1->up = cpu_to_le32(ndown);\n\t\t\thpfs_mark_4buffers_dirty(&qbh1);\n\t\t\thpfs_brelse4(&qbh1);\n\t\t}\n\t\thpfs_add_to_dnode(i, ndown, de_cp->name, de_cp->namelen, de_cp, dlp);\n\t\tdno = up;\n\t\tkfree(de_cp);\n\t\tgoto try_it_again;\n\t}\n\tendm:\n\thpfs_mark_4buffers_dirty(&qbh);\n\tend:\n\thpfs_brelse4(&qbh);\n}",
          "includes": [
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n\nstatic void delete_empty_dnode(struct inode *i, dnode_secno dno)\n{\n\tstruct hpfs_inode_info *hpfs_inode = hpfs_i(i);\n\tstruct quad_buffer_head qbh;\n\tstruct dnode *dnode;\n\tdnode_secno down, up, ndown;\n\tint p;\n\tstruct hpfs_dirent *de;\n\tint c1, c2 = 0;\n\ttry_it_again:\n\tif (hpfs_stop_cycles(i->i_sb, dno, &c1, &c2, \"delete_empty_dnode\")) return;\n\tif (!(dnode = hpfs_map_dnode(i->i_sb, dno, &qbh))) return;\n\tif (le32_to_cpu(dnode->first_free) > 56) goto end;\n\tif (le32_to_cpu(dnode->first_free) == 52 || le32_to_cpu(dnode->first_free) == 56) {\n\t\tstruct hpfs_dirent *de_end;\n\t\tint root = dnode->root_dnode;\n\t\tup = le32_to_cpu(dnode->up);\n\t\tde = dnode_first_de(dnode);\n\t\tdown = de->down ? de_down_pointer(de) : 0;\n\t\tif (hpfs_sb(i->i_sb)->sb_chk) if (root && !down) {\n\t\t\thpfs_error(i->i_sb, \"delete_empty_dnode: root dnode %08x is empty\", dno);\n\t\t\tgoto end;\n\t\t}\n\t\thpfs_brelse4(&qbh);\n\t\thpfs_free_dnode(i->i_sb, dno);\n\t\ti->i_size -= 2048;\n\t\ti->i_blocks -= 4;\n\t\tif (root) {\n\t\t\tstruct fnode *fnode;\n\t\t\tstruct buffer_head *bh;\n\t\t\tstruct dnode *d1;\n\t\t\tstruct quad_buffer_head qbh1;\n\t\t\tif (hpfs_sb(i->i_sb)->sb_chk)\n\t\t\t\tif (up != i->i_ino) {\n\t\t\t\t\thpfs_error(i->i_sb,\n\t\t\t\t\t\t   \"bad pointer to fnode, dnode %08x, pointing to %08x, should be %08lx\",\n\t\t\t\t\t\t   dno, up,\n\t\t\t\t\t\t   (unsigned long)i->i_ino);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\tif ((d1 = hpfs_map_dnode(i->i_sb, down, &qbh1))) {\n\t\t\t\td1->up = cpu_to_le32(up);\n\t\t\t\td1->root_dnode = 1;\n\t\t\t\thpfs_mark_4buffers_dirty(&qbh1);\n\t\t\t\thpfs_brelse4(&qbh1);\n\t\t\t}\n\t\t\tif ((fnode = hpfs_map_fnode(i->i_sb, up, &bh))) {\n\t\t\t\tfnode->u.external[0].disk_secno = cpu_to_le32(down);\n\t\t\t\tmark_buffer_dirty(bh);\n\t\t\t\tbrelse(bh);\n\t\t\t}\n\t\t\thpfs_inode->i_dno = down;\n\t\t\tfor_all_poss(i, hpfs_pos_subst, ((loff_t)dno << 4) | 1, (loff_t) 12);\n\t\t\treturn;\n\t\t}\n\t\tif (!(dnode = hpfs_map_dnode(i->i_sb, up, &qbh))) return;\n\t\tp = 1;\n\t\tde_end = dnode_end_de(dnode);\n\t\tfor (de = dnode_first_de(dnode); de < de_end; de = de_next_de(de), p++)\n\t\t\tif (de->down) if (de_down_pointer(de) == dno) goto fnd;\n\t\thpfs_error(i->i_sb, \"delete_empty_dnode: pointer to dnode %08x not found in dnode %08x\", dno, up);\n\t\tgoto end;\n\t\tfnd:\n\t\tfor_all_poss(i, hpfs_pos_subst, ((loff_t)dno << 4) | 1, ((loff_t)up << 4) | p);\n\t\tif (!down) {\n\t\t\tde->down = 0;\n\t\t\tle16_add_cpu(&de->length, -4);\n\t\t\tle32_add_cpu(&dnode->first_free, -4);\n\t\t\tmemmove(de_next_de(de), (char *)de_next_de(de) + 4,\n\t\t\t\t(char *)dnode + le32_to_cpu(dnode->first_free) - (char *)de_next_de(de));\n\t\t} else {\n\t\t\tstruct dnode *d1;\n\t\t\tstruct quad_buffer_head qbh1;\n\t\t\t*(dnode_secno *) ((void *) de + le16_to_cpu(de->length) - 4) = down;\n\t\t\tif ((d1 = hpfs_map_dnode(i->i_sb, down, &qbh1))) {\n\t\t\t\td1->up = cpu_to_le32(up);\n\t\t\t\thpfs_mark_4buffers_dirty(&qbh1);\n\t\t\t\thpfs_brelse4(&qbh1);\n\t\t\t}\n\t\t}\n\t} else {\n\t\thpfs_error(i->i_sb, \"delete_empty_dnode: dnode %08x, first_free == %03x\", dno, le32_to_cpu(dnode->first_free));\n\t\tgoto end;\n\t}\n\n\tif (!de->last) {\n\t\tstruct hpfs_dirent *de_next = de_next_de(de);\n\t\tstruct hpfs_dirent *de_cp;\n\t\tstruct dnode *d1;\n\t\tstruct quad_buffer_head qbh1;\n\t\tif (!de_next->down) goto endm;\n\t\tndown = de_down_pointer(de_next);\n\t\tif (!(de_cp = kmalloc(le16_to_cpu(de->length), GFP_NOFS))) {\n\t\t\tpr_err(\"out of memory for dtree balancing\\n\");\n\t\t\tgoto endm;\n\t\t}\n\t\tmemcpy(de_cp, de, le16_to_cpu(de->length));\n\t\thpfs_delete_de(i->i_sb, dnode, de);\n\t\thpfs_mark_4buffers_dirty(&qbh);\n\t\thpfs_brelse4(&qbh);\n\t\tfor_all_poss(i, hpfs_pos_subst, ((loff_t)up << 4) | p, 4);\n\t\tfor_all_poss(i, hpfs_pos_del, ((loff_t)up << 4) | p, 1);\n\t\tif (de_cp->down) if ((d1 = hpfs_map_dnode(i->i_sb, de_down_pointer(de_cp), &qbh1))) {\n\t\t\td1->up = cpu_to_le32(ndown);\n\t\t\thpfs_mark_4buffers_dirty(&qbh1);\n\t\t\thpfs_brelse4(&qbh1);\n\t\t}\n\t\thpfs_add_to_dnode(i, ndown, de_cp->name, de_cp->namelen, de_cp, de_cp->down ? de_down_pointer(de_cp) : 0);\n\t\t/*pr_info(\"UP-TO-DNODE: %08x (ndown = %08x, down = %08x, dno = %08x)\\n\",\n\t\t  up, ndown, down, dno);*/\n\t\tdno = up;\n\t\tkfree(de_cp);\n\t\tgoto try_it_again;\n\t} else {\n\t\tstruct hpfs_dirent *de_prev = dnode_pre_last_de(dnode);\n\t\tstruct hpfs_dirent *de_cp;\n\t\tstruct dnode *d1;\n\t\tstruct quad_buffer_head qbh1;\n\t\tdnode_secno dlp;\n\t\tif (!de_prev) {\n\t\t\thpfs_error(i->i_sb, \"delete_empty_dnode: empty dnode %08x\", up);\n\t\t\thpfs_mark_4buffers_dirty(&qbh);\n\t\t\thpfs_brelse4(&qbh);\n\t\t\tdno = up;\n\t\t\tgoto try_it_again;\n\t\t}\n\t\tif (!de_prev->down) goto endm;\n\t\tndown = de_down_pointer(de_prev);\n\t\tif ((d1 = hpfs_map_dnode(i->i_sb, ndown, &qbh1))) {\n\t\t\tstruct hpfs_dirent *del = dnode_last_de(d1);\n\t\t\tdlp = del->down ? de_down_pointer(del) : 0;\n\t\t\tif (!dlp && down) {\n\t\t\t\tif (le32_to_cpu(d1->first_free) > 2044) {\n\t\t\t\t\tif (hpfs_sb(i->i_sb)->sb_chk >= 2) {\n\t\t\t\t\t\tpr_err(\"unbalanced dnode tree, see hpfs.txt 4 more info\\n\");\n\t\t\t\t\t\tpr_err(\"terminating balancing operation\\n\");\n\t\t\t\t\t}\n\t\t\t\t\thpfs_brelse4(&qbh1);\n\t\t\t\t\tgoto endm;\n\t\t\t\t}\n\t\t\t\tif (hpfs_sb(i->i_sb)->sb_chk >= 2) {\n\t\t\t\t\tpr_err(\"unbalanced dnode tree, see hpfs.txt 4 more info\\n\");\n\t\t\t\t\tpr_err(\"goin'on\\n\");\n\t\t\t\t}\n\t\t\t\tle16_add_cpu(&del->length, 4);\n\t\t\t\tdel->down = 1;\n\t\t\t\tle32_add_cpu(&d1->first_free, 4);\n\t\t\t}\n\t\t\tif (dlp && !down) {\n\t\t\t\tle16_add_cpu(&del->length, -4);\n\t\t\t\tdel->down = 0;\n\t\t\t\tle32_add_cpu(&d1->first_free, -4);\n\t\t\t} else if (down)\n\t\t\t\t*(__le32 *) ((void *) del + le16_to_cpu(del->length) - 4) = cpu_to_le32(down);\n\t\t} else goto endm;\n\t\tif (!(de_cp = kmalloc(le16_to_cpu(de_prev->length), GFP_NOFS))) {\n\t\t\tpr_err(\"out of memory for dtree balancing\\n\");\n\t\t\thpfs_brelse4(&qbh1);\n\t\t\tgoto endm;\n\t\t}\n\t\thpfs_mark_4buffers_dirty(&qbh1);\n\t\thpfs_brelse4(&qbh1);\n\t\tmemcpy(de_cp, de_prev, le16_to_cpu(de_prev->length));\n\t\thpfs_delete_de(i->i_sb, dnode, de_prev);\n\t\tif (!de_prev->down) {\n\t\t\tle16_add_cpu(&de_prev->length, 4);\n\t\t\tde_prev->down = 1;\n\t\t\tle32_add_cpu(&dnode->first_free, 4);\n\t\t}\n\t\t*(__le32 *) ((void *) de_prev + le16_to_cpu(de_prev->length) - 4) = cpu_to_le32(ndown);\n\t\thpfs_mark_4buffers_dirty(&qbh);\n\t\thpfs_brelse4(&qbh);\n\t\tfor_all_poss(i, hpfs_pos_subst, ((loff_t)up << 4) | (p - 1), 4);\n\t\tfor_all_poss(i, hpfs_pos_subst, ((loff_t)up << 4) | p, ((loff_t)up << 4) | (p - 1));\n\t\tif (down) if ((d1 = hpfs_map_dnode(i->i_sb, de_down_pointer(de), &qbh1))) {\n\t\t\td1->up = cpu_to_le32(ndown);\n\t\t\thpfs_mark_4buffers_dirty(&qbh1);\n\t\t\thpfs_brelse4(&qbh1);\n\t\t}\n\t\thpfs_add_to_dnode(i, ndown, de_cp->name, de_cp->namelen, de_cp, dlp);\n\t\tdno = up;\n\t\tkfree(de_cp);\n\t\tgoto try_it_again;\n\t}\n\tendm:\n\thpfs_mark_4buffers_dirty(&qbh);\n\tend:\n\thpfs_brelse4(&qbh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_all_poss",
          "args": [
            "i",
            "hpfs_pos_subst",
            "5",
            "t"
          ],
          "line": 733
        },
        "resolved": true,
        "details": {
          "function_name": "for_all_poss",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/dnode.c",
          "lines": "71-80",
          "snippet": "static void for_all_poss(struct inode *inode, void (*f)(loff_t *, loff_t, loff_t),\n\t\t\t loff_t p1, loff_t p2)\n{\n\tstruct hpfs_inode_info *hpfs_inode = hpfs_i(inode);\n\tloff_t **i;\n\n\tif (!hpfs_inode->i_rddir_off) return;\n\tfor (i = hpfs_inode->i_rddir_off; *i; i++) (*f)(*i, p1, p2);\n\treturn;\n}",
          "includes": [
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n\nstatic void for_all_poss(struct inode *inode, void (*f)(loff_t *, loff_t, loff_t),\n\t\t\t loff_t p1, loff_t p2)\n{\n\tstruct hpfs_inode_info *hpfs_inode = hpfs_i(inode);\n\tloff_t **i;\n\n\tif (!hpfs_inode->i_rddir_off) return;\n\tfor (i = hpfs_inode->i_rddir_off; *i; i++) (*f)(*i, p1, p2);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "move_to_top",
          "args": [
            "i",
            "down",
            "dno"
          ],
          "line": 732
        },
        "resolved": true,
        "details": {
          "function_name": "move_to_top",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/dnode.c",
          "lines": "430-508",
          "snippet": "static secno move_to_top(struct inode *i, dnode_secno from, dnode_secno to)\n{\n\tdnode_secno dno, ddno;\n\tdnode_secno chk_up = to;\n\tstruct dnode *dnode;\n\tstruct quad_buffer_head qbh;\n\tstruct hpfs_dirent *de, *nde;\n\tint a;\n\tloff_t t;\n\tint c1, c2 = 0;\n\tdno = from;\n\twhile (1) {\n\t\tif (hpfs_sb(i->i_sb)->sb_chk)\n\t\t\tif (hpfs_stop_cycles(i->i_sb, dno, &c1, &c2, \"move_to_top\"))\n\t\t\t\treturn 0;\n\t\tif (!(dnode = hpfs_map_dnode(i->i_sb, dno, &qbh))) return 0;\n\t\tif (hpfs_sb(i->i_sb)->sb_chk) {\n\t\t\tif (le32_to_cpu(dnode->up) != chk_up) {\n\t\t\t\thpfs_error(i->i_sb, \"move_to_top: up pointer from %08x should be %08x, is %08x\",\n\t\t\t\t\tdno, chk_up, le32_to_cpu(dnode->up));\n\t\t\t\thpfs_brelse4(&qbh);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tchk_up = dno;\n\t\t}\n\t\tif (!(de = dnode_last_de(dnode))) {\n\t\t\thpfs_error(i->i_sb, \"move_to_top: dnode %08x has no last de\", dno);\n\t\t\thpfs_brelse4(&qbh);\n\t\t\treturn 0;\n\t\t}\n\t\tif (!de->down) break;\n\t\tdno = de_down_pointer(de);\n\t\thpfs_brelse4(&qbh);\n\t}\n\twhile (!(de = dnode_pre_last_de(dnode))) {\n\t\tdnode_secno up = le32_to_cpu(dnode->up);\n\t\thpfs_brelse4(&qbh);\n\t\thpfs_free_dnode(i->i_sb, dno);\n\t\ti->i_size -= 2048;\n\t\ti->i_blocks -= 4;\n\t\tfor_all_poss(i, hpfs_pos_subst, ((loff_t)dno << 4) | 1, 5);\n\t\tif (up == to) return to;\n\t\tif (!(dnode = hpfs_map_dnode(i->i_sb, up, &qbh))) return 0;\n\t\tif (dnode->root_dnode) {\n\t\t\thpfs_error(i->i_sb, \"move_to_top: got to root_dnode while moving from %08x to %08x\", from, to);\n\t\t\thpfs_brelse4(&qbh);\n\t\t\treturn 0;\n\t\t}\n\t\tde = dnode_last_de(dnode);\n\t\tif (!de || !de->down) {\n\t\t\thpfs_error(i->i_sb, \"move_to_top: dnode %08x doesn't point down to %08x\", up, dno);\n\t\t\thpfs_brelse4(&qbh);\n\t\t\treturn 0;\n\t\t}\n\t\tle32_add_cpu(&dnode->first_free, -4);\n\t\tle16_add_cpu(&de->length, -4);\n\t\tde->down = 0;\n\t\thpfs_mark_4buffers_dirty(&qbh);\n\t\tdno = up;\n\t}\n\tt = get_pos(dnode, de);\n\tfor_all_poss(i, hpfs_pos_subst, t, 4);\n\tfor_all_poss(i, hpfs_pos_subst, t + 1, 5);\n\tif (!(nde = kmalloc(le16_to_cpu(de->length), GFP_NOFS))) {\n\t\thpfs_error(i->i_sb, \"out of memory for dirent - directory will be corrupted\");\n\t\thpfs_brelse4(&qbh);\n\t\treturn 0;\n\t}\n\tmemcpy(nde, de, le16_to_cpu(de->length));\n\tddno = de->down ? de_down_pointer(de) : 0;\n\thpfs_delete_de(i->i_sb, dnode, de);\n\tset_last_pointer(i->i_sb, dnode, ddno);\n\thpfs_mark_4buffers_dirty(&qbh);\n\thpfs_brelse4(&qbh);\n\ta = hpfs_add_to_dnode(i, to, nde->name, nde->namelen, nde, from);\n\tkfree(nde);\n\tif (a) return 0;\n\treturn dno;\n}",
          "includes": [
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n\nstatic secno move_to_top(struct inode *i, dnode_secno from, dnode_secno to)\n{\n\tdnode_secno dno, ddno;\n\tdnode_secno chk_up = to;\n\tstruct dnode *dnode;\n\tstruct quad_buffer_head qbh;\n\tstruct hpfs_dirent *de, *nde;\n\tint a;\n\tloff_t t;\n\tint c1, c2 = 0;\n\tdno = from;\n\twhile (1) {\n\t\tif (hpfs_sb(i->i_sb)->sb_chk)\n\t\t\tif (hpfs_stop_cycles(i->i_sb, dno, &c1, &c2, \"move_to_top\"))\n\t\t\t\treturn 0;\n\t\tif (!(dnode = hpfs_map_dnode(i->i_sb, dno, &qbh))) return 0;\n\t\tif (hpfs_sb(i->i_sb)->sb_chk) {\n\t\t\tif (le32_to_cpu(dnode->up) != chk_up) {\n\t\t\t\thpfs_error(i->i_sb, \"move_to_top: up pointer from %08x should be %08x, is %08x\",\n\t\t\t\t\tdno, chk_up, le32_to_cpu(dnode->up));\n\t\t\t\thpfs_brelse4(&qbh);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tchk_up = dno;\n\t\t}\n\t\tif (!(de = dnode_last_de(dnode))) {\n\t\t\thpfs_error(i->i_sb, \"move_to_top: dnode %08x has no last de\", dno);\n\t\t\thpfs_brelse4(&qbh);\n\t\t\treturn 0;\n\t\t}\n\t\tif (!de->down) break;\n\t\tdno = de_down_pointer(de);\n\t\thpfs_brelse4(&qbh);\n\t}\n\twhile (!(de = dnode_pre_last_de(dnode))) {\n\t\tdnode_secno up = le32_to_cpu(dnode->up);\n\t\thpfs_brelse4(&qbh);\n\t\thpfs_free_dnode(i->i_sb, dno);\n\t\ti->i_size -= 2048;\n\t\ti->i_blocks -= 4;\n\t\tfor_all_poss(i, hpfs_pos_subst, ((loff_t)dno << 4) | 1, 5);\n\t\tif (up == to) return to;\n\t\tif (!(dnode = hpfs_map_dnode(i->i_sb, up, &qbh))) return 0;\n\t\tif (dnode->root_dnode) {\n\t\t\thpfs_error(i->i_sb, \"move_to_top: got to root_dnode while moving from %08x to %08x\", from, to);\n\t\t\thpfs_brelse4(&qbh);\n\t\t\treturn 0;\n\t\t}\n\t\tde = dnode_last_de(dnode);\n\t\tif (!de || !de->down) {\n\t\t\thpfs_error(i->i_sb, \"move_to_top: dnode %08x doesn't point down to %08x\", up, dno);\n\t\t\thpfs_brelse4(&qbh);\n\t\t\treturn 0;\n\t\t}\n\t\tle32_add_cpu(&dnode->first_free, -4);\n\t\tle16_add_cpu(&de->length, -4);\n\t\tde->down = 0;\n\t\thpfs_mark_4buffers_dirty(&qbh);\n\t\tdno = up;\n\t}\n\tt = get_pos(dnode, de);\n\tfor_all_poss(i, hpfs_pos_subst, t, 4);\n\tfor_all_poss(i, hpfs_pos_subst, t + 1, 5);\n\tif (!(nde = kmalloc(le16_to_cpu(de->length), GFP_NOFS))) {\n\t\thpfs_error(i->i_sb, \"out of memory for dirent - directory will be corrupted\");\n\t\thpfs_brelse4(&qbh);\n\t\treturn 0;\n\t}\n\tmemcpy(nde, de, le16_to_cpu(de->length));\n\tddno = de->down ? de_down_pointer(de) : 0;\n\thpfs_delete_de(i->i_sb, dnode, de);\n\tset_last_pointer(i->i_sb, dnode, ddno);\n\thpfs_mark_4buffers_dirty(&qbh);\n\thpfs_brelse4(&qbh);\n\ta = hpfs_add_to_dnode(i, to, nde->name, nde->namelen, nde, from);\n\tkfree(nde);\n\tif (a) return 0;\n\treturn dno;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_brelse4",
          "args": [
            "qbh"
          ],
          "line": 730
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_brelse4",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/buffer.c",
          "lines": "182-190",
          "snippet": "void hpfs_brelse4(struct quad_buffer_head *qbh)\n{\n\tif (unlikely(qbh->data != qbh->bh[0]->b_data))\n\t\tkfree(qbh->data);\n\tbrelse(qbh->bh[0]);\n\tbrelse(qbh->bh[1]);\n\tbrelse(qbh->bh[2]);\n\tbrelse(qbh->bh[3]);\n}",
          "includes": [
            "#include \"hpfs_fn.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid hpfs_brelse4(struct quad_buffer_head *qbh)\n{\n\tif (unlikely(qbh->data != qbh->bh[0]->b_data))\n\t\tkfree(qbh->data);\n\tbrelse(qbh->bh[0]);\n\tbrelse(qbh->bh[1]);\n\tbrelse(qbh->bh[2]);\n\tbrelse(qbh->bh[3]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_mark_4buffers_dirty",
          "args": [
            "qbh"
          ],
          "line": 729
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_mark_4buffers_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/buffer.c",
          "lines": "192-204",
          "snippet": "void hpfs_mark_4buffers_dirty(struct quad_buffer_head *qbh)\n{\n\tif (unlikely(qbh->data != qbh->bh[0]->b_data)) {\n\t\tmemcpy(qbh->bh[0]->b_data, qbh->data + 0 * 512, 512);\n\t\tmemcpy(qbh->bh[1]->b_data, qbh->data + 1 * 512, 512);\n\t\tmemcpy(qbh->bh[2]->b_data, qbh->data + 2 * 512, 512);\n\t\tmemcpy(qbh->bh[3]->b_data, qbh->data + 3 * 512, 512);\n\t}\n\tmark_buffer_dirty(qbh->bh[0]);\n\tmark_buffer_dirty(qbh->bh[1]);\n\tmark_buffer_dirty(qbh->bh[2]);\n\tmark_buffer_dirty(qbh->bh[3]);\n}",
          "includes": [
            "#include \"hpfs_fn.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid hpfs_mark_4buffers_dirty(struct quad_buffer_head *qbh)\n{\n\tif (unlikely(qbh->data != qbh->bh[0]->b_data)) {\n\t\tmemcpy(qbh->bh[0]->b_data, qbh->data + 0 * 512, 512);\n\t\tmemcpy(qbh->bh[1]->b_data, qbh->data + 1 * 512, 512);\n\t\tmemcpy(qbh->bh[2]->b_data, qbh->data + 2 * 512, 512);\n\t\tmemcpy(qbh->bh[3]->b_data, qbh->data + 3 * 512, 512);\n\t}\n\tmark_buffer_dirty(qbh->bh[0]);\n\tmark_buffer_dirty(qbh->bh[1]);\n\tmark_buffer_dirty(qbh->bh[2]);\n\tmark_buffer_dirty(qbh->bh[3]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_delete_de",
          "args": [
            "i->i_sb",
            "dnode",
            "de"
          ],
          "line": 728
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_delete_de",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/dnode.c",
          "lines": "200-209",
          "snippet": "static void hpfs_delete_de(struct super_block *s, struct dnode *d,\n\t\t\t   struct hpfs_dirent *de)\n{\n\tif (de->last) {\n\t\thpfs_error(s, \"attempt to delete last dirent in dnode %08x\", le32_to_cpu(d->self));\n\t\treturn;\n\t}\n\td->first_free = cpu_to_le32(le32_to_cpu(d->first_free) - le16_to_cpu(de->length));\n\tmemmove(de, de_next_de(de), le32_to_cpu(d->first_free) + (char *)d - (char *)de);\n}",
          "includes": [
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n\nstatic void hpfs_delete_de(struct super_block *s, struct dnode *d,\n\t\t\t   struct hpfs_dirent *de)\n{\n\tif (de->last) {\n\t\thpfs_error(s, \"attempt to delete last dirent in dnode %08x\", le32_to_cpu(d->self));\n\t\treturn;\n\t}\n\td->first_free = cpu_to_le32(le32_to_cpu(d->first_free) - le16_to_cpu(de->length));\n\tmemmove(de, de_next_de(de), le32_to_cpu(d->first_free) + (char *)d - (char *)de);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_pos",
          "args": [
            "dnode",
            "de"
          ],
          "line": 727
        },
        "resolved": true,
        "details": {
          "function_name": "get_pos",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/dnode.c",
          "lines": "11-22",
          "snippet": "static loff_t get_pos(struct dnode *d, struct hpfs_dirent *fde)\n{\n\tstruct hpfs_dirent *de;\n\tstruct hpfs_dirent *de_end = dnode_end_de(d);\n\tint i = 1;\n\tfor (de = dnode_first_de(d); de < de_end; de = de_next_de(de)) {\n\t\tif (de == fde) return ((loff_t) le32_to_cpu(d->self) << 4) | (loff_t)i;\n\t\ti++;\n\t}\n\tpr_info(\"%s(): not_found\\n\", __func__);\n\treturn ((loff_t)le32_to_cpu(d->self) << 4) | (loff_t)1;\n}",
          "includes": [
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n\nstatic loff_t get_pos(struct dnode *d, struct hpfs_dirent *fde)\n{\n\tstruct hpfs_dirent *de;\n\tstruct hpfs_dirent *de_end = dnode_end_de(d);\n\tint i = 1;\n\tfor (de = dnode_first_de(d); de < de_end; de = de_next_de(de)) {\n\t\tif (de == fde) return ((loff_t) le32_to_cpu(d->self) << 4) | (loff_t)i;\n\t\ti++;\n\t}\n\tpr_info(\"%s(): not_found\\n\", __func__);\n\treturn ((loff_t)le32_to_cpu(d->self) << 4) | (loff_t)1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_check_free_dnodes",
          "args": [
            "i->i_sb",
            "FREE_DNODES_DEL"
          ],
          "line": 721
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_check_free_dnodes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/alloc.c",
          "lines": "358-402",
          "snippet": "int hpfs_check_free_dnodes(struct super_block *s, int n)\n{\n\tint n_bmps = (hpfs_sb(s)->sb_fs_size + 0x4000 - 1) >> 14;\n\tint b = hpfs_sb(s)->sb_c_bitmap & 0x0fffffff;\n\tint i, j;\n\t__le32 *bmp;\n\tstruct quad_buffer_head qbh;\n\tif ((bmp = hpfs_map_dnode_bitmap(s, &qbh))) {\n\t\tfor (j = 0; j < 512; j++) {\n\t\t\tunsigned k;\n\t\t\tif (!le32_to_cpu(bmp[j])) continue;\n\t\t\tfor (k = le32_to_cpu(bmp[j]); k; k >>= 1) if (k & 1) if (!--n) {\n\t\t\t\thpfs_brelse4(&qbh);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\thpfs_brelse4(&qbh);\n\ti = 0;\n\tif (hpfs_sb(s)->sb_c_bitmap != -1) {\n\t\tbmp = hpfs_map_bitmap(s, b, &qbh, \"chkdn1\");\n\t\tgoto chk_bmp;\n\t}\n\tchk_next:\n\tif (i == b) i++;\n\tif (i >= n_bmps) return 1;\n\tbmp = hpfs_map_bitmap(s, i, &qbh, \"chkdn2\");\n\tchk_bmp:\n\tif (bmp) {\n\t\tfor (j = 0; j < 512; j++) {\n\t\t\tu32 k;\n\t\t\tif (!le32_to_cpu(bmp[j])) continue;\n\t\t\tfor (k = 0xf; k; k <<= 4)\n\t\t\t\tif ((le32_to_cpu(bmp[j]) & k) == k) {\n\t\t\t\t\tif (!--n) {\n\t\t\t\t\t\thpfs_brelse4(&qbh);\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t}\n\t\thpfs_brelse4(&qbh);\n\t}\n\ti++;\n\tgoto chk_next;\n}",
          "includes": [
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n\nint hpfs_check_free_dnodes(struct super_block *s, int n)\n{\n\tint n_bmps = (hpfs_sb(s)->sb_fs_size + 0x4000 - 1) >> 14;\n\tint b = hpfs_sb(s)->sb_c_bitmap & 0x0fffffff;\n\tint i, j;\n\t__le32 *bmp;\n\tstruct quad_buffer_head qbh;\n\tif ((bmp = hpfs_map_dnode_bitmap(s, &qbh))) {\n\t\tfor (j = 0; j < 512; j++) {\n\t\t\tunsigned k;\n\t\t\tif (!le32_to_cpu(bmp[j])) continue;\n\t\t\tfor (k = le32_to_cpu(bmp[j]); k; k >>= 1) if (k & 1) if (!--n) {\n\t\t\t\thpfs_brelse4(&qbh);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\thpfs_brelse4(&qbh);\n\ti = 0;\n\tif (hpfs_sb(s)->sb_c_bitmap != -1) {\n\t\tbmp = hpfs_map_bitmap(s, b, &qbh, \"chkdn1\");\n\t\tgoto chk_bmp;\n\t}\n\tchk_next:\n\tif (i == b) i++;\n\tif (i >= n_bmps) return 1;\n\tbmp = hpfs_map_bitmap(s, i, &qbh, \"chkdn2\");\n\tchk_bmp:\n\tif (bmp) {\n\t\tfor (j = 0; j < 512; j++) {\n\t\t\tu32 k;\n\t\t\tif (!le32_to_cpu(bmp[j])) continue;\n\t\t\tfor (k = 0xf; k; k <<= 4)\n\t\t\t\tif ((le32_to_cpu(bmp[j]) & k) == k) {\n\t\t\t\t\tif (!--n) {\n\t\t\t\t\t\thpfs_brelse4(&qbh);\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t}\n\t\thpfs_brelse4(&qbh);\n\t}\n\ti++;\n\tgoto chk_next;\n}"
        }
      },
      {
        "call_info": {
          "callee": "de_next_de",
          "args": [
            "de"
          ],
          "line": 720
        },
        "resolved": true,
        "details": {
          "function_name": "de_next_de",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "123-127",
          "snippet": "static inline struct hpfs_dirent *de_next_de (struct hpfs_dirent *de)\n{\n  CHKCOND(le16_to_cpu(de->length)>=0x20 && le16_to_cpu(de->length)<0x800,(\"HPFS: de_next_de: de->length = %x\\n\",(unsigned)le16_to_cpu(de->length)));\n  return (void *) de + le16_to_cpu(de->length);\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_add_dirent(struct inode *, const unsigned char *, unsigned,\n\t\t    struct hpfs_dirent *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_add_dirent(struct inode *, const unsigned char *, unsigned,\n\t\t    struct hpfs_dirent *);\n\nstatic inline struct hpfs_dirent *de_next_de (struct hpfs_dirent *de)\n{\n  CHKCOND(le16_to_cpu(de->length)>=0x20 && le16_to_cpu(de->length)<0x800,(\"HPFS: de_next_de: de->length = %x\\n\",(unsigned)le16_to_cpu(de->length)));\n  return (void *) de + le16_to_cpu(de->length);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dnode_first_de",
          "args": [
            "dnode"
          ],
          "line": 720
        },
        "resolved": true,
        "details": {
          "function_name": "dnode_first_de",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "108-111",
          "snippet": "static inline struct hpfs_dirent *dnode_first_de (struct dnode *dnode)\n{\n  return (void *) dnode->dirent;\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_add_dirent(struct inode *, const unsigned char *, unsigned,\n\t\t    struct hpfs_dirent *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_add_dirent(struct inode *, const unsigned char *, unsigned,\n\t\t    struct hpfs_dirent *);\n\nstatic inline struct hpfs_dirent *dnode_first_de (struct dnode *dnode)\n{\n  return (void *) dnode->dirent;\n}"
        }
      },
      {
        "call_info": {
          "callee": "de_down_pointer",
          "args": [
            "de"
          ],
          "line": 719
        },
        "resolved": true,
        "details": {
          "function_name": "de_down_pointer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "100-104",
          "snippet": "static inline dnode_secno de_down_pointer (struct hpfs_dirent *de)\n{\n  CHKCOND(de->down,(\"HPFS: de_down_pointer: !de->down\\n\"));\n  return le32_to_cpu(*(__le32 *) ((void *) de + le16_to_cpu(de->length) - 4));\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_add_dirent(struct inode *, const unsigned char *, unsigned,\n\t\t    struct hpfs_dirent *);",
            "void hpfs_count_dnodes(struct super_block *, dnode_secno, int *, int *, int *);",
            "void hpfs_remove_dtree(struct super_block *, dnode_secno);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_add_dirent(struct inode *, const unsigned char *, unsigned,\n\t\t    struct hpfs_dirent *);\nvoid hpfs_count_dnodes(struct super_block *, dnode_secno, int *, int *, int *);\nvoid hpfs_remove_dtree(struct super_block *, dnode_secno);\n\nstatic inline dnode_secno de_down_pointer (struct hpfs_dirent *de)\n{\n  CHKCOND(de->down,(\"HPFS: de_down_pointer: !de->down\\n\"));\n  return le32_to_cpu(*(__le32 *) ((void *) de + le16_to_cpu(de->length) - 4));\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_error",
          "args": [
            "i->i_sb",
            "\"hpfs_remove_dirent: attempt to delete first or last dirent in dnode %08x\"",
            "dno"
          ],
          "line": 715
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/super.c",
          "lines": "57-86",
          "snippet": "void hpfs_error(struct super_block *s, const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvsnprintf(err_buf, sizeof(err_buf), fmt, args);\n\tva_end(args);\n\n\tpr_err(\"filesystem error: %s\", err_buf);\n\tif (!hpfs_sb(s)->sb_was_error) {\n\t\tif (hpfs_sb(s)->sb_err == 2) {\n\t\t\tpr_cont(\"; crashing the system because you wanted it\\n\");\n\t\t\tmark_dirty(s, 0);\n\t\t\tpanic(\"HPFS panic\");\n\t\t} else if (hpfs_sb(s)->sb_err == 1) {\n\t\t\tif (s->s_flags & MS_RDONLY)\n\t\t\t\tpr_cont(\"; already mounted read-only\\n\");\n\t\t\telse {\n\t\t\t\tpr_cont(\"; remounting read-only\\n\");\n\t\t\t\tmark_dirty(s, 0);\n\t\t\t\ts->s_flags |= MS_RDONLY;\n\t\t\t}\n\t\t} else if (s->s_flags & MS_RDONLY)\n\t\t\t\tpr_cont(\"; going on - but anything won't be destroyed because it's read-only\\n\");\n\t\telse\n\t\t\tpr_cont(\"; corrupted filesystem mounted read/write - your computer will explode within 20 seconds ... but you wanted it so!\\n\");\n\t} else\n\t\tpr_cont(\"\\n\");\n\thpfs_sb(s)->sb_was_error = 1;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/sched.h>",
            "#include <linux/magic.h>",
            "#include <linux/statfs.h>",
            "#include <linux/init.h>",
            "#include <linux/parser.h>",
            "#include <linux/module.h>",
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static char err_buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/bitmap.h>\n#include <linux/sched.h>\n#include <linux/magic.h>\n#include <linux/statfs.h>\n#include <linux/init.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include \"hpfs_fn.h\"\n\nstatic char err_buf[1024];\n\nvoid hpfs_error(struct super_block *s, const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvsnprintf(err_buf, sizeof(err_buf), fmt, args);\n\tva_end(args);\n\n\tpr_err(\"filesystem error: %s\", err_buf);\n\tif (!hpfs_sb(s)->sb_was_error) {\n\t\tif (hpfs_sb(s)->sb_err == 2) {\n\t\t\tpr_cont(\"; crashing the system because you wanted it\\n\");\n\t\t\tmark_dirty(s, 0);\n\t\t\tpanic(\"HPFS panic\");\n\t\t} else if (hpfs_sb(s)->sb_err == 1) {\n\t\t\tif (s->s_flags & MS_RDONLY)\n\t\t\t\tpr_cont(\"; already mounted read-only\\n\");\n\t\t\telse {\n\t\t\t\tpr_cont(\"; remounting read-only\\n\");\n\t\t\t\tmark_dirty(s, 0);\n\t\t\t\ts->s_flags |= MS_RDONLY;\n\t\t\t}\n\t\t} else if (s->s_flags & MS_RDONLY)\n\t\t\t\tpr_cont(\"; going on - but anything won't be destroyed because it's read-only\\n\");\n\t\telse\n\t\t\tpr_cont(\"; corrupted filesystem mounted read/write - your computer will explode within 20 seconds ... but you wanted it so!\\n\");\n\t} else\n\t\tpr_cont(\"\\n\");\n\thpfs_sb(s)->sb_was_error = 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hpfs_fn.h\"\n\nint hpfs_remove_dirent(struct inode *i, dnode_secno dno, struct hpfs_dirent *de,\n\t\t       struct quad_buffer_head *qbh, int depth)\n{\n\tstruct dnode *dnode = qbh->data;\n\tdnode_secno down = 0;\n\tloff_t t;\n\tif (de->first || de->last) {\n\t\thpfs_error(i->i_sb, \"hpfs_remove_dirent: attempt to delete first or last dirent in dnode %08x\", dno);\n\t\thpfs_brelse4(qbh);\n\t\treturn 1;\n\t}\n\tif (de->down) down = de_down_pointer(de);\n\tif (depth && (de->down || (de == dnode_first_de(dnode) && de_next_de(de)->last))) {\n\t\tif (hpfs_check_free_dnodes(i->i_sb, FREE_DNODES_DEL)) {\n\t\t\thpfs_brelse4(qbh);\n\t\t\treturn 2;\n\t\t}\n\t}\n\ti->i_version++;\n\tfor_all_poss(i, hpfs_pos_del, (t = get_pos(dnode, de)) + 1, 1);\n\thpfs_delete_de(i->i_sb, dnode, de);\n\thpfs_mark_4buffers_dirty(qbh);\n\thpfs_brelse4(qbh);\n\tif (down) {\n\t\tdnode_secno a = move_to_top(i, down, dno);\n\t\tfor_all_poss(i, hpfs_pos_subst, 5, t);\n\t\tif (a) delete_empty_dnode(i, a);\n\t\treturn !a;\n\t}\n\tdelete_empty_dnode(i, dno);\n\treturn 0;\n}"
  },
  {
    "function_name": "delete_empty_dnode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/dnode.c",
    "lines": "515-703",
    "snippet": "static void delete_empty_dnode(struct inode *i, dnode_secno dno)\n{\n\tstruct hpfs_inode_info *hpfs_inode = hpfs_i(i);\n\tstruct quad_buffer_head qbh;\n\tstruct dnode *dnode;\n\tdnode_secno down, up, ndown;\n\tint p;\n\tstruct hpfs_dirent *de;\n\tint c1, c2 = 0;\n\ttry_it_again:\n\tif (hpfs_stop_cycles(i->i_sb, dno, &c1, &c2, \"delete_empty_dnode\")) return;\n\tif (!(dnode = hpfs_map_dnode(i->i_sb, dno, &qbh))) return;\n\tif (le32_to_cpu(dnode->first_free) > 56) goto end;\n\tif (le32_to_cpu(dnode->first_free) == 52 || le32_to_cpu(dnode->first_free) == 56) {\n\t\tstruct hpfs_dirent *de_end;\n\t\tint root = dnode->root_dnode;\n\t\tup = le32_to_cpu(dnode->up);\n\t\tde = dnode_first_de(dnode);\n\t\tdown = de->down ? de_down_pointer(de) : 0;\n\t\tif (hpfs_sb(i->i_sb)->sb_chk) if (root && !down) {\n\t\t\thpfs_error(i->i_sb, \"delete_empty_dnode: root dnode %08x is empty\", dno);\n\t\t\tgoto end;\n\t\t}\n\t\thpfs_brelse4(&qbh);\n\t\thpfs_free_dnode(i->i_sb, dno);\n\t\ti->i_size -= 2048;\n\t\ti->i_blocks -= 4;\n\t\tif (root) {\n\t\t\tstruct fnode *fnode;\n\t\t\tstruct buffer_head *bh;\n\t\t\tstruct dnode *d1;\n\t\t\tstruct quad_buffer_head qbh1;\n\t\t\tif (hpfs_sb(i->i_sb)->sb_chk)\n\t\t\t\tif (up != i->i_ino) {\n\t\t\t\t\thpfs_error(i->i_sb,\n\t\t\t\t\t\t   \"bad pointer to fnode, dnode %08x, pointing to %08x, should be %08lx\",\n\t\t\t\t\t\t   dno, up,\n\t\t\t\t\t\t   (unsigned long)i->i_ino);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\tif ((d1 = hpfs_map_dnode(i->i_sb, down, &qbh1))) {\n\t\t\t\td1->up = cpu_to_le32(up);\n\t\t\t\td1->root_dnode = 1;\n\t\t\t\thpfs_mark_4buffers_dirty(&qbh1);\n\t\t\t\thpfs_brelse4(&qbh1);\n\t\t\t}\n\t\t\tif ((fnode = hpfs_map_fnode(i->i_sb, up, &bh))) {\n\t\t\t\tfnode->u.external[0].disk_secno = cpu_to_le32(down);\n\t\t\t\tmark_buffer_dirty(bh);\n\t\t\t\tbrelse(bh);\n\t\t\t}\n\t\t\thpfs_inode->i_dno = down;\n\t\t\tfor_all_poss(i, hpfs_pos_subst, ((loff_t)dno << 4) | 1, (loff_t) 12);\n\t\t\treturn;\n\t\t}\n\t\tif (!(dnode = hpfs_map_dnode(i->i_sb, up, &qbh))) return;\n\t\tp = 1;\n\t\tde_end = dnode_end_de(dnode);\n\t\tfor (de = dnode_first_de(dnode); de < de_end; de = de_next_de(de), p++)\n\t\t\tif (de->down) if (de_down_pointer(de) == dno) goto fnd;\n\t\thpfs_error(i->i_sb, \"delete_empty_dnode: pointer to dnode %08x not found in dnode %08x\", dno, up);\n\t\tgoto end;\n\t\tfnd:\n\t\tfor_all_poss(i, hpfs_pos_subst, ((loff_t)dno << 4) | 1, ((loff_t)up << 4) | p);\n\t\tif (!down) {\n\t\t\tde->down = 0;\n\t\t\tle16_add_cpu(&de->length, -4);\n\t\t\tle32_add_cpu(&dnode->first_free, -4);\n\t\t\tmemmove(de_next_de(de), (char *)de_next_de(de) + 4,\n\t\t\t\t(char *)dnode + le32_to_cpu(dnode->first_free) - (char *)de_next_de(de));\n\t\t} else {\n\t\t\tstruct dnode *d1;\n\t\t\tstruct quad_buffer_head qbh1;\n\t\t\t*(dnode_secno *) ((void *) de + le16_to_cpu(de->length) - 4) = down;\n\t\t\tif ((d1 = hpfs_map_dnode(i->i_sb, down, &qbh1))) {\n\t\t\t\td1->up = cpu_to_le32(up);\n\t\t\t\thpfs_mark_4buffers_dirty(&qbh1);\n\t\t\t\thpfs_brelse4(&qbh1);\n\t\t\t}\n\t\t}\n\t} else {\n\t\thpfs_error(i->i_sb, \"delete_empty_dnode: dnode %08x, first_free == %03x\", dno, le32_to_cpu(dnode->first_free));\n\t\tgoto end;\n\t}\n\n\tif (!de->last) {\n\t\tstruct hpfs_dirent *de_next = de_next_de(de);\n\t\tstruct hpfs_dirent *de_cp;\n\t\tstruct dnode *d1;\n\t\tstruct quad_buffer_head qbh1;\n\t\tif (!de_next->down) goto endm;\n\t\tndown = de_down_pointer(de_next);\n\t\tif (!(de_cp = kmalloc(le16_to_cpu(de->length), GFP_NOFS))) {\n\t\t\tpr_err(\"out of memory for dtree balancing\\n\");\n\t\t\tgoto endm;\n\t\t}\n\t\tmemcpy(de_cp, de, le16_to_cpu(de->length));\n\t\thpfs_delete_de(i->i_sb, dnode, de);\n\t\thpfs_mark_4buffers_dirty(&qbh);\n\t\thpfs_brelse4(&qbh);\n\t\tfor_all_poss(i, hpfs_pos_subst, ((loff_t)up << 4) | p, 4);\n\t\tfor_all_poss(i, hpfs_pos_del, ((loff_t)up << 4) | p, 1);\n\t\tif (de_cp->down) if ((d1 = hpfs_map_dnode(i->i_sb, de_down_pointer(de_cp), &qbh1))) {\n\t\t\td1->up = cpu_to_le32(ndown);\n\t\t\thpfs_mark_4buffers_dirty(&qbh1);\n\t\t\thpfs_brelse4(&qbh1);\n\t\t}\n\t\thpfs_add_to_dnode(i, ndown, de_cp->name, de_cp->namelen, de_cp, de_cp->down ? de_down_pointer(de_cp) : 0);\n\t\t/*pr_info(\"UP-TO-DNODE: %08x (ndown = %08x, down = %08x, dno = %08x)\\n\",\n\t\t  up, ndown, down, dno);*/\n\t\tdno = up;\n\t\tkfree(de_cp);\n\t\tgoto try_it_again;\n\t} else {\n\t\tstruct hpfs_dirent *de_prev = dnode_pre_last_de(dnode);\n\t\tstruct hpfs_dirent *de_cp;\n\t\tstruct dnode *d1;\n\t\tstruct quad_buffer_head qbh1;\n\t\tdnode_secno dlp;\n\t\tif (!de_prev) {\n\t\t\thpfs_error(i->i_sb, \"delete_empty_dnode: empty dnode %08x\", up);\n\t\t\thpfs_mark_4buffers_dirty(&qbh);\n\t\t\thpfs_brelse4(&qbh);\n\t\t\tdno = up;\n\t\t\tgoto try_it_again;\n\t\t}\n\t\tif (!de_prev->down) goto endm;\n\t\tndown = de_down_pointer(de_prev);\n\t\tif ((d1 = hpfs_map_dnode(i->i_sb, ndown, &qbh1))) {\n\t\t\tstruct hpfs_dirent *del = dnode_last_de(d1);\n\t\t\tdlp = del->down ? de_down_pointer(del) : 0;\n\t\t\tif (!dlp && down) {\n\t\t\t\tif (le32_to_cpu(d1->first_free) > 2044) {\n\t\t\t\t\tif (hpfs_sb(i->i_sb)->sb_chk >= 2) {\n\t\t\t\t\t\tpr_err(\"unbalanced dnode tree, see hpfs.txt 4 more info\\n\");\n\t\t\t\t\t\tpr_err(\"terminating balancing operation\\n\");\n\t\t\t\t\t}\n\t\t\t\t\thpfs_brelse4(&qbh1);\n\t\t\t\t\tgoto endm;\n\t\t\t\t}\n\t\t\t\tif (hpfs_sb(i->i_sb)->sb_chk >= 2) {\n\t\t\t\t\tpr_err(\"unbalanced dnode tree, see hpfs.txt 4 more info\\n\");\n\t\t\t\t\tpr_err(\"goin'on\\n\");\n\t\t\t\t}\n\t\t\t\tle16_add_cpu(&del->length, 4);\n\t\t\t\tdel->down = 1;\n\t\t\t\tle32_add_cpu(&d1->first_free, 4);\n\t\t\t}\n\t\t\tif (dlp && !down) {\n\t\t\t\tle16_add_cpu(&del->length, -4);\n\t\t\t\tdel->down = 0;\n\t\t\t\tle32_add_cpu(&d1->first_free, -4);\n\t\t\t} else if (down)\n\t\t\t\t*(__le32 *) ((void *) del + le16_to_cpu(del->length) - 4) = cpu_to_le32(down);\n\t\t} else goto endm;\n\t\tif (!(de_cp = kmalloc(le16_to_cpu(de_prev->length), GFP_NOFS))) {\n\t\t\tpr_err(\"out of memory for dtree balancing\\n\");\n\t\t\thpfs_brelse4(&qbh1);\n\t\t\tgoto endm;\n\t\t}\n\t\thpfs_mark_4buffers_dirty(&qbh1);\n\t\thpfs_brelse4(&qbh1);\n\t\tmemcpy(de_cp, de_prev, le16_to_cpu(de_prev->length));\n\t\thpfs_delete_de(i->i_sb, dnode, de_prev);\n\t\tif (!de_prev->down) {\n\t\t\tle16_add_cpu(&de_prev->length, 4);\n\t\t\tde_prev->down = 1;\n\t\t\tle32_add_cpu(&dnode->first_free, 4);\n\t\t}\n\t\t*(__le32 *) ((void *) de_prev + le16_to_cpu(de_prev->length) - 4) = cpu_to_le32(ndown);\n\t\thpfs_mark_4buffers_dirty(&qbh);\n\t\thpfs_brelse4(&qbh);\n\t\tfor_all_poss(i, hpfs_pos_subst, ((loff_t)up << 4) | (p - 1), 4);\n\t\tfor_all_poss(i, hpfs_pos_subst, ((loff_t)up << 4) | p, ((loff_t)up << 4) | (p - 1));\n\t\tif (down) if ((d1 = hpfs_map_dnode(i->i_sb, de_down_pointer(de), &qbh1))) {\n\t\t\td1->up = cpu_to_le32(ndown);\n\t\t\thpfs_mark_4buffers_dirty(&qbh1);\n\t\t\thpfs_brelse4(&qbh1);\n\t\t}\n\t\thpfs_add_to_dnode(i, ndown, de_cp->name, de_cp->namelen, de_cp, dlp);\n\t\tdno = up;\n\t\tkfree(de_cp);\n\t\tgoto try_it_again;\n\t}\n\tendm:\n\thpfs_mark_4buffers_dirty(&qbh);\n\tend:\n\thpfs_brelse4(&qbh);\n}",
    "includes": [
      "#include \"hpfs_fn.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hpfs_brelse4",
          "args": [
            "&qbh"
          ],
          "line": 702
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_brelse4",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/buffer.c",
          "lines": "182-190",
          "snippet": "void hpfs_brelse4(struct quad_buffer_head *qbh)\n{\n\tif (unlikely(qbh->data != qbh->bh[0]->b_data))\n\t\tkfree(qbh->data);\n\tbrelse(qbh->bh[0]);\n\tbrelse(qbh->bh[1]);\n\tbrelse(qbh->bh[2]);\n\tbrelse(qbh->bh[3]);\n}",
          "includes": [
            "#include \"hpfs_fn.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid hpfs_brelse4(struct quad_buffer_head *qbh)\n{\n\tif (unlikely(qbh->data != qbh->bh[0]->b_data))\n\t\tkfree(qbh->data);\n\tbrelse(qbh->bh[0]);\n\tbrelse(qbh->bh[1]);\n\tbrelse(qbh->bh[2]);\n\tbrelse(qbh->bh[3]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_mark_4buffers_dirty",
          "args": [
            "&qbh"
          ],
          "line": 700
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_mark_4buffers_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/buffer.c",
          "lines": "192-204",
          "snippet": "void hpfs_mark_4buffers_dirty(struct quad_buffer_head *qbh)\n{\n\tif (unlikely(qbh->data != qbh->bh[0]->b_data)) {\n\t\tmemcpy(qbh->bh[0]->b_data, qbh->data + 0 * 512, 512);\n\t\tmemcpy(qbh->bh[1]->b_data, qbh->data + 1 * 512, 512);\n\t\tmemcpy(qbh->bh[2]->b_data, qbh->data + 2 * 512, 512);\n\t\tmemcpy(qbh->bh[3]->b_data, qbh->data + 3 * 512, 512);\n\t}\n\tmark_buffer_dirty(qbh->bh[0]);\n\tmark_buffer_dirty(qbh->bh[1]);\n\tmark_buffer_dirty(qbh->bh[2]);\n\tmark_buffer_dirty(qbh->bh[3]);\n}",
          "includes": [
            "#include \"hpfs_fn.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid hpfs_mark_4buffers_dirty(struct quad_buffer_head *qbh)\n{\n\tif (unlikely(qbh->data != qbh->bh[0]->b_data)) {\n\t\tmemcpy(qbh->bh[0]->b_data, qbh->data + 0 * 512, 512);\n\t\tmemcpy(qbh->bh[1]->b_data, qbh->data + 1 * 512, 512);\n\t\tmemcpy(qbh->bh[2]->b_data, qbh->data + 2 * 512, 512);\n\t\tmemcpy(qbh->bh[3]->b_data, qbh->data + 3 * 512, 512);\n\t}\n\tmark_buffer_dirty(qbh->bh[0]);\n\tmark_buffer_dirty(qbh->bh[1]);\n\tmark_buffer_dirty(qbh->bh[2]);\n\tmark_buffer_dirty(qbh->bh[3]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "de_cp"
          ],
          "line": 696
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hpfs_add_to_dnode",
          "args": [
            "i",
            "ndown",
            "de_cp->name",
            "de_cp->namelen",
            "de_cp",
            "dlp"
          ],
          "line": 694
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_add_to_dnode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/dnode.c",
          "lines": "233-373",
          "snippet": "static int hpfs_add_to_dnode(struct inode *i, dnode_secno dno,\n\t\t\t     const unsigned char *name, unsigned namelen,\n\t\t\t     struct hpfs_dirent *new_de, dnode_secno down_ptr)\n{\n\tstruct quad_buffer_head qbh, qbh1, qbh2;\n\tstruct dnode *d, *ad, *rd, *nd = NULL;\n\tdnode_secno adno, rdno;\n\tstruct hpfs_dirent *de;\n\tstruct hpfs_dirent nde;\n\tunsigned char *nname;\n\tint h;\n\tint pos;\n\tstruct buffer_head *bh;\n\tstruct fnode *fnode;\n\tint c1, c2 = 0;\n\tif (!(nname = kmalloc(256, GFP_NOFS))) {\n\t\tpr_err(\"out of memory, can't add to dnode\\n\");\n\t\treturn 1;\n\t}\n\tgo_up:\n\tif (namelen >= 256) {\n\t\thpfs_error(i->i_sb, \"%s(): namelen == %d\", __func__, namelen);\n\t\tkfree(nd);\n\t\tkfree(nname);\n\t\treturn 1;\n\t}\n\tif (!(d = hpfs_map_dnode(i->i_sb, dno, &qbh))) {\n\t\tkfree(nd);\n\t\tkfree(nname);\n\t\treturn 1;\n\t}\n\tgo_up_a:\n\tif (hpfs_sb(i->i_sb)->sb_chk)\n\t\tif (hpfs_stop_cycles(i->i_sb, dno, &c1, &c2, \"hpfs_add_to_dnode\")) {\n\t\t\thpfs_brelse4(&qbh);\n\t\t\tkfree(nd);\n\t\t\tkfree(nname);\n\t\t\treturn 1;\n\t\t}\n\tif (le32_to_cpu(d->first_free) + de_size(namelen, down_ptr) <= 2048) {\n\t\tloff_t t;\n\t\tcopy_de(de=hpfs_add_de(i->i_sb, d, name, namelen, down_ptr), new_de);\n\t\tt = get_pos(d, de);\n\t\tfor_all_poss(i, hpfs_pos_ins, t, 1);\n\t\tfor_all_poss(i, hpfs_pos_subst, 4, t);\n\t\tfor_all_poss(i, hpfs_pos_subst, 5, t + 1);\n\t\thpfs_mark_4buffers_dirty(&qbh);\n\t\thpfs_brelse4(&qbh);\n\t\tkfree(nd);\n\t\tkfree(nname);\n\t\treturn 0;\n\t}\n\tif (!nd) if (!(nd = kmalloc(0x924, GFP_NOFS))) {\n\t\t/* 0x924 is a max size of dnode after adding a dirent with\n\t\t   max name length. We alloc this only once. There must\n\t\t   not be any error while splitting dnodes, otherwise the\n\t\t   whole directory, not only file we're adding, would\n\t\t   be lost. */\n\t\tpr_err(\"out of memory for dnode splitting\\n\");\n\t\thpfs_brelse4(&qbh);\n\t\tkfree(nname);\n\t\treturn 1;\n\t}\t\n\tmemcpy(nd, d, le32_to_cpu(d->first_free));\n\tcopy_de(de = hpfs_add_de(i->i_sb, nd, name, namelen, down_ptr), new_de);\n\tfor_all_poss(i, hpfs_pos_ins, get_pos(nd, de), 1);\n\th = ((char *)dnode_last_de(nd) - (char *)nd) / 2 + 10;\n\tif (!(ad = hpfs_alloc_dnode(i->i_sb, le32_to_cpu(d->up), &adno, &qbh1))) {\n\t\thpfs_error(i->i_sb, \"unable to alloc dnode - dnode tree will be corrupted\");\n\t\thpfs_brelse4(&qbh);\n\t\tkfree(nd);\n\t\tkfree(nname);\n\t\treturn 1;\n\t}\n\ti->i_size += 2048;\n\ti->i_blocks += 4;\n\tpos = 1;\n\tfor (de = dnode_first_de(nd); (char *)de_next_de(de) - (char *)nd < h; de = de_next_de(de)) {\n\t\tcopy_de(hpfs_add_de(i->i_sb, ad, de->name, de->namelen, de->down ? de_down_pointer(de) : 0), de);\n\t\tfor_all_poss(i, hpfs_pos_subst, ((loff_t)dno << 4) | pos, ((loff_t)adno << 4) | pos);\n\t\tpos++;\n\t}\n\tcopy_de(new_de = &nde, de);\n\tmemcpy(nname, de->name, de->namelen);\n\tname = nname;\n\tnamelen = de->namelen;\n\tfor_all_poss(i, hpfs_pos_subst, ((loff_t)dno << 4) | pos, 4);\n\tdown_ptr = adno;\n\tset_last_pointer(i->i_sb, ad, de->down ? de_down_pointer(de) : 0);\n\tde = de_next_de(de);\n\tmemmove((char *)nd + 20, de, le32_to_cpu(nd->first_free) + (char *)nd - (char *)de);\n\tle32_add_cpu(&nd->first_free, -((char *)de - (char *)nd - 20));\n\tmemcpy(d, nd, le32_to_cpu(nd->first_free));\n\tfor_all_poss(i, hpfs_pos_del, (loff_t)dno << 4, pos);\n\tfix_up_ptrs(i->i_sb, ad);\n\tif (!d->root_dnode) {\n\t\tad->up = d->up;\n\t\tdno = le32_to_cpu(ad->up);\n\t\thpfs_mark_4buffers_dirty(&qbh);\n\t\thpfs_brelse4(&qbh);\n\t\thpfs_mark_4buffers_dirty(&qbh1);\n\t\thpfs_brelse4(&qbh1);\n\t\tgoto go_up;\n\t}\n\tif (!(rd = hpfs_alloc_dnode(i->i_sb, le32_to_cpu(d->up), &rdno, &qbh2))) {\n\t\thpfs_error(i->i_sb, \"unable to alloc dnode - dnode tree will be corrupted\");\n\t\thpfs_brelse4(&qbh);\n\t\thpfs_brelse4(&qbh1);\n\t\tkfree(nd);\n\t\tkfree(nname);\n\t\treturn 1;\n\t}\n\ti->i_size += 2048;\n\ti->i_blocks += 4;\n\trd->root_dnode = 1;\n\trd->up = d->up;\n\tif (!(fnode = hpfs_map_fnode(i->i_sb, le32_to_cpu(d->up), &bh))) {\n\t\thpfs_free_dnode(i->i_sb, rdno);\n\t\thpfs_brelse4(&qbh);\n\t\thpfs_brelse4(&qbh1);\n\t\thpfs_brelse4(&qbh2);\n\t\tkfree(nd);\n\t\tkfree(nname);\n\t\treturn 1;\n\t}\n\tfnode->u.external[0].disk_secno = cpu_to_le32(rdno);\n\tmark_buffer_dirty(bh);\n\tbrelse(bh);\n\thpfs_i(i)->i_dno = rdno;\n\td->up = ad->up = cpu_to_le32(rdno);\n\td->root_dnode = ad->root_dnode = 0;\n\thpfs_mark_4buffers_dirty(&qbh);\n\thpfs_brelse4(&qbh);\n\thpfs_mark_4buffers_dirty(&qbh1);\n\thpfs_brelse4(&qbh1);\n\tqbh = qbh2;\n\tset_last_pointer(i->i_sb, rd, dno);\n\tdno = rdno;\n\td = rd;\n\tgoto go_up_a;\n}",
          "includes": [
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n\nstatic int hpfs_add_to_dnode(struct inode *i, dnode_secno dno,\n\t\t\t     const unsigned char *name, unsigned namelen,\n\t\t\t     struct hpfs_dirent *new_de, dnode_secno down_ptr)\n{\n\tstruct quad_buffer_head qbh, qbh1, qbh2;\n\tstruct dnode *d, *ad, *rd, *nd = NULL;\n\tdnode_secno adno, rdno;\n\tstruct hpfs_dirent *de;\n\tstruct hpfs_dirent nde;\n\tunsigned char *nname;\n\tint h;\n\tint pos;\n\tstruct buffer_head *bh;\n\tstruct fnode *fnode;\n\tint c1, c2 = 0;\n\tif (!(nname = kmalloc(256, GFP_NOFS))) {\n\t\tpr_err(\"out of memory, can't add to dnode\\n\");\n\t\treturn 1;\n\t}\n\tgo_up:\n\tif (namelen >= 256) {\n\t\thpfs_error(i->i_sb, \"%s(): namelen == %d\", __func__, namelen);\n\t\tkfree(nd);\n\t\tkfree(nname);\n\t\treturn 1;\n\t}\n\tif (!(d = hpfs_map_dnode(i->i_sb, dno, &qbh))) {\n\t\tkfree(nd);\n\t\tkfree(nname);\n\t\treturn 1;\n\t}\n\tgo_up_a:\n\tif (hpfs_sb(i->i_sb)->sb_chk)\n\t\tif (hpfs_stop_cycles(i->i_sb, dno, &c1, &c2, \"hpfs_add_to_dnode\")) {\n\t\t\thpfs_brelse4(&qbh);\n\t\t\tkfree(nd);\n\t\t\tkfree(nname);\n\t\t\treturn 1;\n\t\t}\n\tif (le32_to_cpu(d->first_free) + de_size(namelen, down_ptr) <= 2048) {\n\t\tloff_t t;\n\t\tcopy_de(de=hpfs_add_de(i->i_sb, d, name, namelen, down_ptr), new_de);\n\t\tt = get_pos(d, de);\n\t\tfor_all_poss(i, hpfs_pos_ins, t, 1);\n\t\tfor_all_poss(i, hpfs_pos_subst, 4, t);\n\t\tfor_all_poss(i, hpfs_pos_subst, 5, t + 1);\n\t\thpfs_mark_4buffers_dirty(&qbh);\n\t\thpfs_brelse4(&qbh);\n\t\tkfree(nd);\n\t\tkfree(nname);\n\t\treturn 0;\n\t}\n\tif (!nd) if (!(nd = kmalloc(0x924, GFP_NOFS))) {\n\t\t/* 0x924 is a max size of dnode after adding a dirent with\n\t\t   max name length. We alloc this only once. There must\n\t\t   not be any error while splitting dnodes, otherwise the\n\t\t   whole directory, not only file we're adding, would\n\t\t   be lost. */\n\t\tpr_err(\"out of memory for dnode splitting\\n\");\n\t\thpfs_brelse4(&qbh);\n\t\tkfree(nname);\n\t\treturn 1;\n\t}\t\n\tmemcpy(nd, d, le32_to_cpu(d->first_free));\n\tcopy_de(de = hpfs_add_de(i->i_sb, nd, name, namelen, down_ptr), new_de);\n\tfor_all_poss(i, hpfs_pos_ins, get_pos(nd, de), 1);\n\th = ((char *)dnode_last_de(nd) - (char *)nd) / 2 + 10;\n\tif (!(ad = hpfs_alloc_dnode(i->i_sb, le32_to_cpu(d->up), &adno, &qbh1))) {\n\t\thpfs_error(i->i_sb, \"unable to alloc dnode - dnode tree will be corrupted\");\n\t\thpfs_brelse4(&qbh);\n\t\tkfree(nd);\n\t\tkfree(nname);\n\t\treturn 1;\n\t}\n\ti->i_size += 2048;\n\ti->i_blocks += 4;\n\tpos = 1;\n\tfor (de = dnode_first_de(nd); (char *)de_next_de(de) - (char *)nd < h; de = de_next_de(de)) {\n\t\tcopy_de(hpfs_add_de(i->i_sb, ad, de->name, de->namelen, de->down ? de_down_pointer(de) : 0), de);\n\t\tfor_all_poss(i, hpfs_pos_subst, ((loff_t)dno << 4) | pos, ((loff_t)adno << 4) | pos);\n\t\tpos++;\n\t}\n\tcopy_de(new_de = &nde, de);\n\tmemcpy(nname, de->name, de->namelen);\n\tname = nname;\n\tnamelen = de->namelen;\n\tfor_all_poss(i, hpfs_pos_subst, ((loff_t)dno << 4) | pos, 4);\n\tdown_ptr = adno;\n\tset_last_pointer(i->i_sb, ad, de->down ? de_down_pointer(de) : 0);\n\tde = de_next_de(de);\n\tmemmove((char *)nd + 20, de, le32_to_cpu(nd->first_free) + (char *)nd - (char *)de);\n\tle32_add_cpu(&nd->first_free, -((char *)de - (char *)nd - 20));\n\tmemcpy(d, nd, le32_to_cpu(nd->first_free));\n\tfor_all_poss(i, hpfs_pos_del, (loff_t)dno << 4, pos);\n\tfix_up_ptrs(i->i_sb, ad);\n\tif (!d->root_dnode) {\n\t\tad->up = d->up;\n\t\tdno = le32_to_cpu(ad->up);\n\t\thpfs_mark_4buffers_dirty(&qbh);\n\t\thpfs_brelse4(&qbh);\n\t\thpfs_mark_4buffers_dirty(&qbh1);\n\t\thpfs_brelse4(&qbh1);\n\t\tgoto go_up;\n\t}\n\tif (!(rd = hpfs_alloc_dnode(i->i_sb, le32_to_cpu(d->up), &rdno, &qbh2))) {\n\t\thpfs_error(i->i_sb, \"unable to alloc dnode - dnode tree will be corrupted\");\n\t\thpfs_brelse4(&qbh);\n\t\thpfs_brelse4(&qbh1);\n\t\tkfree(nd);\n\t\tkfree(nname);\n\t\treturn 1;\n\t}\n\ti->i_size += 2048;\n\ti->i_blocks += 4;\n\trd->root_dnode = 1;\n\trd->up = d->up;\n\tif (!(fnode = hpfs_map_fnode(i->i_sb, le32_to_cpu(d->up), &bh))) {\n\t\thpfs_free_dnode(i->i_sb, rdno);\n\t\thpfs_brelse4(&qbh);\n\t\thpfs_brelse4(&qbh1);\n\t\thpfs_brelse4(&qbh2);\n\t\tkfree(nd);\n\t\tkfree(nname);\n\t\treturn 1;\n\t}\n\tfnode->u.external[0].disk_secno = cpu_to_le32(rdno);\n\tmark_buffer_dirty(bh);\n\tbrelse(bh);\n\thpfs_i(i)->i_dno = rdno;\n\td->up = ad->up = cpu_to_le32(rdno);\n\td->root_dnode = ad->root_dnode = 0;\n\thpfs_mark_4buffers_dirty(&qbh);\n\thpfs_brelse4(&qbh);\n\thpfs_mark_4buffers_dirty(&qbh1);\n\thpfs_brelse4(&qbh1);\n\tqbh = qbh2;\n\tset_last_pointer(i->i_sb, rd, dno);\n\tdno = rdno;\n\td = rd;\n\tgoto go_up_a;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "ndown"
          ],
          "line": 690
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hpfs_map_dnode",
          "args": [
            "i->i_sb",
            "de_down_pointer(de)",
            "&qbh1"
          ],
          "line": 689
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_map_dnode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/map.c",
          "lines": "229-293",
          "snippet": "struct dnode *hpfs_map_dnode(struct super_block *s, unsigned secno,\n\t\t\t     struct quad_buffer_head *qbh)\n{\n\tstruct dnode *dnode;\n\tif (hpfs_sb(s)->sb_chk) {\n\t\tif (hpfs_chk_sectors(s, secno, 4, \"dnode\")) return NULL;\n\t\tif (secno & 3) {\n\t\t\thpfs_error(s, \"dnode %08x not byte-aligned\", secno);\n\t\t\treturn NULL;\n\t\t}\t\n\t}\n\tif ((dnode = hpfs_map_4sectors(s, secno, qbh, DNODE_RD_AHEAD)))\n\t\tif (hpfs_sb(s)->sb_chk) {\n\t\t\tunsigned p, pp = 0;\n\t\t\tunsigned char *d = (unsigned char *)dnode;\n\t\t\tint b = 0;\n\t\t\tif (le32_to_cpu(dnode->magic) != DNODE_MAGIC) {\n\t\t\t\thpfs_error(s, \"bad magic on dnode %08x\", secno);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tif (le32_to_cpu(dnode->self) != secno)\n\t\t\t\thpfs_error(s, \"bad self pointer on dnode %08x self = %08x\", secno, le32_to_cpu(dnode->self));\n\t\t\t/* Check dirents - bad dirents would cause infinite\n\t\t\t   loops or shooting to memory */\n\t\t\tif (le32_to_cpu(dnode->first_free) > 2048) {\n\t\t\t\thpfs_error(s, \"dnode %08x has first_free == %08x\", secno, le32_to_cpu(dnode->first_free));\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tfor (p = 20; p < le32_to_cpu(dnode->first_free); p += d[p] + (d[p+1] << 8)) {\n\t\t\t\tstruct hpfs_dirent *de = (struct hpfs_dirent *)((char *)dnode + p);\n\t\t\t\tif (le16_to_cpu(de->length) > 292 || (le16_to_cpu(de->length) < 32) || (le16_to_cpu(de->length) & 3) || p + le16_to_cpu(de->length) > 2048) {\n\t\t\t\t\thpfs_error(s, \"bad dirent size in dnode %08x, dirent %03x, last %03x\", secno, p, pp);\n\t\t\t\t\tgoto bail;\n\t\t\t\t}\n\t\t\t\tif (((31 + de->namelen + de->down*4 + 3) & ~3) != le16_to_cpu(de->length)) {\n\t\t\t\t\tif (((31 + de->namelen + de->down*4 + 3) & ~3) < le16_to_cpu(de->length) && s->s_flags & MS_RDONLY) goto ok;\n\t\t\t\t\thpfs_error(s, \"namelen does not match dirent size in dnode %08x, dirent %03x, last %03x\", secno, p, pp);\n\t\t\t\t\tgoto bail;\n\t\t\t\t}\n\t\t\t\tok:\n\t\t\t\tif (hpfs_sb(s)->sb_chk >= 2) b |= 1 << de->down;\n\t\t\t\tif (de->down) if (de_down_pointer(de) < 0x10) {\n\t\t\t\t\thpfs_error(s, \"bad down pointer in dnode %08x, dirent %03x, last %03x\", secno, p, pp);\n\t\t\t\t\tgoto bail;\n\t\t\t\t}\n\t\t\t\tpp = p;\n\t\t\t\t\n\t\t\t}\n\t\t\tif (p != le32_to_cpu(dnode->first_free)) {\n\t\t\t\thpfs_error(s, \"size on last dirent does not match first_free; dnode %08x\", secno);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tif (d[pp + 30] != 1 || d[pp + 31] != 255) {\n\t\t\t\thpfs_error(s, \"dnode %08x does not end with \\\\377 entry\", secno);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tif (b == 3)\n\t\t\t\tpr_err(\"unbalanced dnode tree, dnode %08x; see hpfs.txt 4 more info\\n\",\n\t\t\t\t\tsecno);\n\t\t}\n\treturn dnode;\n\tbail:\n\thpfs_brelse4(qbh);\n\treturn NULL;\n}",
          "includes": [
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n\nstruct dnode *hpfs_map_dnode(struct super_block *s, unsigned secno,\n\t\t\t     struct quad_buffer_head *qbh)\n{\n\tstruct dnode *dnode;\n\tif (hpfs_sb(s)->sb_chk) {\n\t\tif (hpfs_chk_sectors(s, secno, 4, \"dnode\")) return NULL;\n\t\tif (secno & 3) {\n\t\t\thpfs_error(s, \"dnode %08x not byte-aligned\", secno);\n\t\t\treturn NULL;\n\t\t}\t\n\t}\n\tif ((dnode = hpfs_map_4sectors(s, secno, qbh, DNODE_RD_AHEAD)))\n\t\tif (hpfs_sb(s)->sb_chk) {\n\t\t\tunsigned p, pp = 0;\n\t\t\tunsigned char *d = (unsigned char *)dnode;\n\t\t\tint b = 0;\n\t\t\tif (le32_to_cpu(dnode->magic) != DNODE_MAGIC) {\n\t\t\t\thpfs_error(s, \"bad magic on dnode %08x\", secno);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tif (le32_to_cpu(dnode->self) != secno)\n\t\t\t\thpfs_error(s, \"bad self pointer on dnode %08x self = %08x\", secno, le32_to_cpu(dnode->self));\n\t\t\t/* Check dirents - bad dirents would cause infinite\n\t\t\t   loops or shooting to memory */\n\t\t\tif (le32_to_cpu(dnode->first_free) > 2048) {\n\t\t\t\thpfs_error(s, \"dnode %08x has first_free == %08x\", secno, le32_to_cpu(dnode->first_free));\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tfor (p = 20; p < le32_to_cpu(dnode->first_free); p += d[p] + (d[p+1] << 8)) {\n\t\t\t\tstruct hpfs_dirent *de = (struct hpfs_dirent *)((char *)dnode + p);\n\t\t\t\tif (le16_to_cpu(de->length) > 292 || (le16_to_cpu(de->length) < 32) || (le16_to_cpu(de->length) & 3) || p + le16_to_cpu(de->length) > 2048) {\n\t\t\t\t\thpfs_error(s, \"bad dirent size in dnode %08x, dirent %03x, last %03x\", secno, p, pp);\n\t\t\t\t\tgoto bail;\n\t\t\t\t}\n\t\t\t\tif (((31 + de->namelen + de->down*4 + 3) & ~3) != le16_to_cpu(de->length)) {\n\t\t\t\t\tif (((31 + de->namelen + de->down*4 + 3) & ~3) < le16_to_cpu(de->length) && s->s_flags & MS_RDONLY) goto ok;\n\t\t\t\t\thpfs_error(s, \"namelen does not match dirent size in dnode %08x, dirent %03x, last %03x\", secno, p, pp);\n\t\t\t\t\tgoto bail;\n\t\t\t\t}\n\t\t\t\tok:\n\t\t\t\tif (hpfs_sb(s)->sb_chk >= 2) b |= 1 << de->down;\n\t\t\t\tif (de->down) if (de_down_pointer(de) < 0x10) {\n\t\t\t\t\thpfs_error(s, \"bad down pointer in dnode %08x, dirent %03x, last %03x\", secno, p, pp);\n\t\t\t\t\tgoto bail;\n\t\t\t\t}\n\t\t\t\tpp = p;\n\t\t\t\t\n\t\t\t}\n\t\t\tif (p != le32_to_cpu(dnode->first_free)) {\n\t\t\t\thpfs_error(s, \"size on last dirent does not match first_free; dnode %08x\", secno);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tif (d[pp + 30] != 1 || d[pp + 31] != 255) {\n\t\t\t\thpfs_error(s, \"dnode %08x does not end with \\\\377 entry\", secno);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tif (b == 3)\n\t\t\t\tpr_err(\"unbalanced dnode tree, dnode %08x; see hpfs.txt 4 more info\\n\",\n\t\t\t\t\tsecno);\n\t\t}\n\treturn dnode;\n\tbail:\n\thpfs_brelse4(qbh);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "de_down_pointer",
          "args": [
            "de"
          ],
          "line": 689
        },
        "resolved": true,
        "details": {
          "function_name": "de_down_pointer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "100-104",
          "snippet": "static inline dnode_secno de_down_pointer (struct hpfs_dirent *de)\n{\n  CHKCOND(de->down,(\"HPFS: de_down_pointer: !de->down\\n\"));\n  return le32_to_cpu(*(__le32 *) ((void *) de + le16_to_cpu(de->length) - 4));\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_add_dirent(struct inode *, const unsigned char *, unsigned,\n\t\t    struct hpfs_dirent *);",
            "void hpfs_count_dnodes(struct super_block *, dnode_secno, int *, int *, int *);",
            "void hpfs_remove_dtree(struct super_block *, dnode_secno);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_add_dirent(struct inode *, const unsigned char *, unsigned,\n\t\t    struct hpfs_dirent *);\nvoid hpfs_count_dnodes(struct super_block *, dnode_secno, int *, int *, int *);\nvoid hpfs_remove_dtree(struct super_block *, dnode_secno);\n\nstatic inline dnode_secno de_down_pointer (struct hpfs_dirent *de)\n{\n  CHKCOND(de->down,(\"HPFS: de_down_pointer: !de->down\\n\"));\n  return le32_to_cpu(*(__le32 *) ((void *) de + le16_to_cpu(de->length) - 4));\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_all_poss",
          "args": [
            "i",
            "hpfs_pos_subst",
            "((loff_t)up << 4) | p",
            "((loff_t)up << 4) | (p - 1)"
          ],
          "line": 688
        },
        "resolved": true,
        "details": {
          "function_name": "for_all_poss",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/dnode.c",
          "lines": "71-80",
          "snippet": "static void for_all_poss(struct inode *inode, void (*f)(loff_t *, loff_t, loff_t),\n\t\t\t loff_t p1, loff_t p2)\n{\n\tstruct hpfs_inode_info *hpfs_inode = hpfs_i(inode);\n\tloff_t **i;\n\n\tif (!hpfs_inode->i_rddir_off) return;\n\tfor (i = hpfs_inode->i_rddir_off; *i; i++) (*f)(*i, p1, p2);\n\treturn;\n}",
          "includes": [
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n\nstatic void for_all_poss(struct inode *inode, void (*f)(loff_t *, loff_t, loff_t),\n\t\t\t loff_t p1, loff_t p2)\n{\n\tstruct hpfs_inode_info *hpfs_inode = hpfs_i(inode);\n\tloff_t **i;\n\n\tif (!hpfs_inode->i_rddir_off) return;\n\tfor (i = hpfs_inode->i_rddir_off; *i; i++) (*f)(*i, p1, p2);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "ndown"
          ],
          "line": 684
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "de_prev->length"
          ],
          "line": 684
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_add_cpu",
          "args": [
            "&dnode->first_free",
            "4"
          ],
          "line": 682
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_add_cpu",
          "args": [
            "&de_prev->length",
            "4"
          ],
          "line": 680
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hpfs_delete_de",
          "args": [
            "i->i_sb",
            "dnode",
            "de_prev"
          ],
          "line": 678
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_delete_de",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/dnode.c",
          "lines": "200-209",
          "snippet": "static void hpfs_delete_de(struct super_block *s, struct dnode *d,\n\t\t\t   struct hpfs_dirent *de)\n{\n\tif (de->last) {\n\t\thpfs_error(s, \"attempt to delete last dirent in dnode %08x\", le32_to_cpu(d->self));\n\t\treturn;\n\t}\n\td->first_free = cpu_to_le32(le32_to_cpu(d->first_free) - le16_to_cpu(de->length));\n\tmemmove(de, de_next_de(de), le32_to_cpu(d->first_free) + (char *)d - (char *)de);\n}",
          "includes": [
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n\nstatic void hpfs_delete_de(struct super_block *s, struct dnode *d,\n\t\t\t   struct hpfs_dirent *de)\n{\n\tif (de->last) {\n\t\thpfs_error(s, \"attempt to delete last dirent in dnode %08x\", le32_to_cpu(d->self));\n\t\treturn;\n\t}\n\td->first_free = cpu_to_le32(le32_to_cpu(d->first_free) - le16_to_cpu(de->length));\n\tmemmove(de, de_next_de(de), le32_to_cpu(d->first_free) + (char *)d - (char *)de);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "de_cp",
            "de_prev",
            "le16_to_cpu(de_prev->length)"
          ],
          "line": 677
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"out of memory for dtree balancing\\n\""
          ],
          "line": 671
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "le16_to_cpu(de_prev->length)",
            "GFP_NOFS"
          ],
          "line": 670
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "down"
          ],
          "line": 668
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_add_cpu",
          "args": [
            "&d1->first_free",
            "-4"
          ],
          "line": 666
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_add_cpu",
          "args": [
            "&del->length",
            "-4"
          ],
          "line": 664
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_add_cpu",
          "args": [
            "&d1->first_free",
            "4"
          ],
          "line": 661
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_add_cpu",
          "args": [
            "&del->length",
            "4"
          ],
          "line": 659
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"goin'on\\n\""
          ],
          "line": 657
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"unbalanced dnode tree, see hpfs.txt 4 more info\\n\""
          ],
          "line": 656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hpfs_sb",
          "args": [
            "i->i_sb"
          ],
          "line": 655
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_sb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "310-313",
          "snippet": "static inline struct hpfs_sb_info *hpfs_sb(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_check_free_dnodes(struct super_block *, int);",
            "void hpfs_prefetch_sectors(struct super_block *, unsigned, int);",
            "void hpfs_prefetch_bitmap(struct super_block *, unsigned);",
            "unsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);",
            "int hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);",
            "void hpfs_error(struct super_block *, const char *, ...);",
            "int hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);",
            "unsigned hpfs_get_free_dnodes(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_check_free_dnodes(struct super_block *, int);\nvoid hpfs_prefetch_sectors(struct super_block *, unsigned, int);\nvoid hpfs_prefetch_bitmap(struct super_block *, unsigned);\nunsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);\nint hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);\nvoid hpfs_error(struct super_block *, const char *, ...);\nint hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);\nunsigned hpfs_get_free_dnodes(struct super_block *);\n\nstatic inline struct hpfs_sb_info *hpfs_sb(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"terminating balancing operation\\n\""
          ],
          "line": 650
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"unbalanced dnode tree, see hpfs.txt 4 more info\\n\""
          ],
          "line": 649
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "d1->first_free"
          ],
          "line": 647
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dnode_last_de",
          "args": [
            "d1"
          ],
          "line": 644
        },
        "resolved": true,
        "details": {
          "function_name": "dnode_last_de",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/dnode.c",
          "lines": "126-134",
          "snippet": "static struct hpfs_dirent *dnode_last_de(struct dnode *d)\n{\n\tstruct hpfs_dirent *de, *de_end, *dee = NULL;\n\tde_end = dnode_end_de(d);\n\tfor (de = dnode_first_de(d); de < de_end; de = de_next_de(de)) {\n\t\tdee = de;\n\t}\t\n\treturn dee;\n}",
          "includes": [
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n\nstatic struct hpfs_dirent *dnode_last_de(struct dnode *d)\n{\n\tstruct hpfs_dirent *de, *de_end, *dee = NULL;\n\tde_end = dnode_end_de(d);\n\tfor (de = dnode_first_de(d); de < de_end; de = de_next_de(de)) {\n\t\tdee = de;\n\t}\t\n\treturn dee;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_error",
          "args": [
            "i->i_sb",
            "\"delete_empty_dnode: empty dnode %08x\"",
            "up"
          ],
          "line": 635
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/super.c",
          "lines": "57-86",
          "snippet": "void hpfs_error(struct super_block *s, const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvsnprintf(err_buf, sizeof(err_buf), fmt, args);\n\tva_end(args);\n\n\tpr_err(\"filesystem error: %s\", err_buf);\n\tif (!hpfs_sb(s)->sb_was_error) {\n\t\tif (hpfs_sb(s)->sb_err == 2) {\n\t\t\tpr_cont(\"; crashing the system because you wanted it\\n\");\n\t\t\tmark_dirty(s, 0);\n\t\t\tpanic(\"HPFS panic\");\n\t\t} else if (hpfs_sb(s)->sb_err == 1) {\n\t\t\tif (s->s_flags & MS_RDONLY)\n\t\t\t\tpr_cont(\"; already mounted read-only\\n\");\n\t\t\telse {\n\t\t\t\tpr_cont(\"; remounting read-only\\n\");\n\t\t\t\tmark_dirty(s, 0);\n\t\t\t\ts->s_flags |= MS_RDONLY;\n\t\t\t}\n\t\t} else if (s->s_flags & MS_RDONLY)\n\t\t\t\tpr_cont(\"; going on - but anything won't be destroyed because it's read-only\\n\");\n\t\telse\n\t\t\tpr_cont(\"; corrupted filesystem mounted read/write - your computer will explode within 20 seconds ... but you wanted it so!\\n\");\n\t} else\n\t\tpr_cont(\"\\n\");\n\thpfs_sb(s)->sb_was_error = 1;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/sched.h>",
            "#include <linux/magic.h>",
            "#include <linux/statfs.h>",
            "#include <linux/init.h>",
            "#include <linux/parser.h>",
            "#include <linux/module.h>",
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static char err_buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/bitmap.h>\n#include <linux/sched.h>\n#include <linux/magic.h>\n#include <linux/statfs.h>\n#include <linux/init.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include \"hpfs_fn.h\"\n\nstatic char err_buf[1024];\n\nvoid hpfs_error(struct super_block *s, const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvsnprintf(err_buf, sizeof(err_buf), fmt, args);\n\tva_end(args);\n\n\tpr_err(\"filesystem error: %s\", err_buf);\n\tif (!hpfs_sb(s)->sb_was_error) {\n\t\tif (hpfs_sb(s)->sb_err == 2) {\n\t\t\tpr_cont(\"; crashing the system because you wanted it\\n\");\n\t\t\tmark_dirty(s, 0);\n\t\t\tpanic(\"HPFS panic\");\n\t\t} else if (hpfs_sb(s)->sb_err == 1) {\n\t\t\tif (s->s_flags & MS_RDONLY)\n\t\t\t\tpr_cont(\"; already mounted read-only\\n\");\n\t\t\telse {\n\t\t\t\tpr_cont(\"; remounting read-only\\n\");\n\t\t\t\tmark_dirty(s, 0);\n\t\t\t\ts->s_flags |= MS_RDONLY;\n\t\t\t}\n\t\t} else if (s->s_flags & MS_RDONLY)\n\t\t\t\tpr_cont(\"; going on - but anything won't be destroyed because it's read-only\\n\");\n\t\telse\n\t\t\tpr_cont(\"; corrupted filesystem mounted read/write - your computer will explode within 20 seconds ... but you wanted it so!\\n\");\n\t} else\n\t\tpr_cont(\"\\n\");\n\thpfs_sb(s)->sb_was_error = 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dnode_pre_last_de",
          "args": [
            "dnode"
          ],
          "line": 629
        },
        "resolved": true,
        "details": {
          "function_name": "dnode_pre_last_de",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/dnode.c",
          "lines": "116-124",
          "snippet": "static struct hpfs_dirent *dnode_pre_last_de(struct dnode *d)\n{\n\tstruct hpfs_dirent *de, *de_end, *dee = NULL, *deee = NULL;\n\tde_end = dnode_end_de(d);\n\tfor (de = dnode_first_de(d); de < de_end; de = de_next_de(de)) {\n\t\tdeee = dee; dee = de;\n\t}\t\n\treturn deee;\n}",
          "includes": [
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n\nstatic struct hpfs_dirent *dnode_pre_last_de(struct dnode *d)\n{\n\tstruct hpfs_dirent *de, *de_end, *dee = NULL, *deee = NULL;\n\tde_end = dnode_end_de(d);\n\tfor (de = dnode_first_de(d); de < de_end; de = de_next_de(de)) {\n\t\tdeee = dee; dee = de;\n\t}\t\n\treturn deee;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "de_cp"
          ],
          "line": 626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "ndown"
          ],
          "line": 618
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "de_cp",
            "de",
            "le16_to_cpu(de->length)"
          ],
          "line": 611
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"out of memory for dtree balancing\\n\""
          ],
          "line": 608
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "de_next_de",
          "args": [
            "de"
          ],
          "line": 601
        },
        "resolved": true,
        "details": {
          "function_name": "de_next_de",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "123-127",
          "snippet": "static inline struct hpfs_dirent *de_next_de (struct hpfs_dirent *de)\n{\n  CHKCOND(le16_to_cpu(de->length)>=0x20 && le16_to_cpu(de->length)<0x800,(\"HPFS: de_next_de: de->length = %x\\n\",(unsigned)le16_to_cpu(de->length)));\n  return (void *) de + le16_to_cpu(de->length);\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_add_dirent(struct inode *, const unsigned char *, unsigned,\n\t\t    struct hpfs_dirent *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_add_dirent(struct inode *, const unsigned char *, unsigned,\n\t\t    struct hpfs_dirent *);\n\nstatic inline struct hpfs_dirent *de_next_de (struct hpfs_dirent *de)\n{\n  CHKCOND(le16_to_cpu(de->length)>=0x20 && le16_to_cpu(de->length)<0x800,(\"HPFS: de_next_de: de->length = %x\\n\",(unsigned)le16_to_cpu(de->length)));\n  return (void *) de + le16_to_cpu(de->length);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "up"
          ],
          "line": 590
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "de_next_de(de)",
            "(char *)de_next_de(de) + 4",
            "(char *)dnode + le32_to_cpu(dnode->first_free) - (char *)de_next_de(de)"
          ],
          "line": 583
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_add_cpu",
          "args": [
            "&dnode->first_free",
            "-4"
          ],
          "line": 582
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_add_cpu",
          "args": [
            "&de->length",
            "-4"
          ],
          "line": 581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dnode_first_de",
          "args": [
            "dnode"
          ],
          "line": 573
        },
        "resolved": true,
        "details": {
          "function_name": "dnode_first_de",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "108-111",
          "snippet": "static inline struct hpfs_dirent *dnode_first_de (struct dnode *dnode)\n{\n  return (void *) dnode->dirent;\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_add_dirent(struct inode *, const unsigned char *, unsigned,\n\t\t    struct hpfs_dirent *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_add_dirent(struct inode *, const unsigned char *, unsigned,\n\t\t    struct hpfs_dirent *);\n\nstatic inline struct hpfs_dirent *dnode_first_de (struct dnode *dnode)\n{\n  return (void *) dnode->dirent;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dnode_end_de",
          "args": [
            "dnode"
          ],
          "line": 572
        },
        "resolved": true,
        "details": {
          "function_name": "dnode_end_de",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "115-119",
          "snippet": "static inline struct hpfs_dirent *dnode_end_de (struct dnode *dnode)\n{\n  CHKCOND(le32_to_cpu(dnode->first_free)>=0x14 && le32_to_cpu(dnode->first_free)<=0xa00,(\"HPFS: dnode_end_de: dnode->first_free = %x\\n\",(unsigned)le32_to_cpu(dnode->first_free)));\n  return (void *) dnode + le32_to_cpu(dnode->first_free);\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_add_dirent(struct inode *, const unsigned char *, unsigned,\n\t\t    struct hpfs_dirent *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_add_dirent(struct inode *, const unsigned char *, unsigned,\n\t\t    struct hpfs_dirent *);\n\nstatic inline struct hpfs_dirent *dnode_end_de (struct dnode *dnode)\n{\n  CHKCOND(le32_to_cpu(dnode->first_free)>=0x14 && le32_to_cpu(dnode->first_free)<=0xa00,(\"HPFS: dnode_end_de: dnode->first_free = %x\\n\",(unsigned)le32_to_cpu(dnode->first_free)));\n  return (void *) dnode + le32_to_cpu(dnode->first_free);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_buffer_dirty",
          "args": [
            "bh"
          ],
          "line": 563
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1141-1167",
          "snippet": "void mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "down"
          ],
          "line": 562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hpfs_map_fnode",
          "args": [
            "i->i_sb",
            "up",
            "&bh"
          ],
          "line": 561
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_map_fnode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/map.c",
          "lines": "137-192",
          "snippet": "struct fnode *hpfs_map_fnode(struct super_block *s, ino_t ino, struct buffer_head **bhp)\n{\n\tstruct fnode *fnode;\n\tif (hpfs_sb(s)->sb_chk) if (hpfs_chk_sectors(s, ino, 1, \"fnode\")) {\n\t\treturn NULL;\n\t}\n\tif ((fnode = hpfs_map_sector(s, ino, bhp, FNODE_RD_AHEAD))) {\n\t\tif (hpfs_sb(s)->sb_chk) {\n\t\t\tstruct extended_attribute *ea;\n\t\t\tstruct extended_attribute *ea_end;\n\t\t\tif (le32_to_cpu(fnode->magic) != FNODE_MAGIC) {\n\t\t\t\thpfs_error(s, \"bad magic on fnode %08lx\",\n\t\t\t\t\t(unsigned long)ino);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tif (!fnode_is_dir(fnode)) {\n\t\t\t\tif ((unsigned)fnode->btree.n_used_nodes + (unsigned)fnode->btree.n_free_nodes !=\n\t\t\t\t    (bp_internal(&fnode->btree) ? 12 : 8)) {\n\t\t\t\t\thpfs_error(s,\n\t\t\t\t\t   \"bad number of nodes in fnode %08lx\",\n\t\t\t\t\t    (unsigned long)ino);\n\t\t\t\t\tgoto bail;\n\t\t\t\t}\n\t\t\t\tif (le16_to_cpu(fnode->btree.first_free) !=\n\t\t\t\t    8 + fnode->btree.n_used_nodes * (bp_internal(&fnode->btree) ? 8 : 12)) {\n\t\t\t\t\thpfs_error(s,\n\t\t\t\t\t    \"bad first_free pointer in fnode %08lx\",\n\t\t\t\t\t    (unsigned long)ino);\n\t\t\t\t\tgoto bail;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (le16_to_cpu(fnode->ea_size_s) && (le16_to_cpu(fnode->ea_offs) < 0xc4 ||\n\t\t\t   le16_to_cpu(fnode->ea_offs) + le16_to_cpu(fnode->acl_size_s) + le16_to_cpu(fnode->ea_size_s) > 0x200)) {\n\t\t\t\thpfs_error(s,\n\t\t\t\t\t\"bad EA info in fnode %08lx: ea_offs == %04x ea_size_s == %04x\",\n\t\t\t\t\t(unsigned long)ino,\n\t\t\t\t\tle16_to_cpu(fnode->ea_offs), le16_to_cpu(fnode->ea_size_s));\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tea = fnode_ea(fnode);\n\t\t\tea_end = fnode_end_ea(fnode);\n\t\t\twhile (ea != ea_end) {\n\t\t\t\tif (ea > ea_end) {\n\t\t\t\t\thpfs_error(s, \"bad EA in fnode %08lx\",\n\t\t\t\t\t\t(unsigned long)ino);\n\t\t\t\t\tgoto bail;\n\t\t\t\t}\n\t\t\t\tea = next_ea(ea);\n\t\t\t}\n\t\t}\n\t}\n\treturn fnode;\n\tbail:\n\tbrelse(*bhp);\n\treturn NULL;\n}",
          "includes": [
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n\nstruct fnode *hpfs_map_fnode(struct super_block *s, ino_t ino, struct buffer_head **bhp)\n{\n\tstruct fnode *fnode;\n\tif (hpfs_sb(s)->sb_chk) if (hpfs_chk_sectors(s, ino, 1, \"fnode\")) {\n\t\treturn NULL;\n\t}\n\tif ((fnode = hpfs_map_sector(s, ino, bhp, FNODE_RD_AHEAD))) {\n\t\tif (hpfs_sb(s)->sb_chk) {\n\t\t\tstruct extended_attribute *ea;\n\t\t\tstruct extended_attribute *ea_end;\n\t\t\tif (le32_to_cpu(fnode->magic) != FNODE_MAGIC) {\n\t\t\t\thpfs_error(s, \"bad magic on fnode %08lx\",\n\t\t\t\t\t(unsigned long)ino);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tif (!fnode_is_dir(fnode)) {\n\t\t\t\tif ((unsigned)fnode->btree.n_used_nodes + (unsigned)fnode->btree.n_free_nodes !=\n\t\t\t\t    (bp_internal(&fnode->btree) ? 12 : 8)) {\n\t\t\t\t\thpfs_error(s,\n\t\t\t\t\t   \"bad number of nodes in fnode %08lx\",\n\t\t\t\t\t    (unsigned long)ino);\n\t\t\t\t\tgoto bail;\n\t\t\t\t}\n\t\t\t\tif (le16_to_cpu(fnode->btree.first_free) !=\n\t\t\t\t    8 + fnode->btree.n_used_nodes * (bp_internal(&fnode->btree) ? 8 : 12)) {\n\t\t\t\t\thpfs_error(s,\n\t\t\t\t\t    \"bad first_free pointer in fnode %08lx\",\n\t\t\t\t\t    (unsigned long)ino);\n\t\t\t\t\tgoto bail;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (le16_to_cpu(fnode->ea_size_s) && (le16_to_cpu(fnode->ea_offs) < 0xc4 ||\n\t\t\t   le16_to_cpu(fnode->ea_offs) + le16_to_cpu(fnode->acl_size_s) + le16_to_cpu(fnode->ea_size_s) > 0x200)) {\n\t\t\t\thpfs_error(s,\n\t\t\t\t\t\"bad EA info in fnode %08lx: ea_offs == %04x ea_size_s == %04x\",\n\t\t\t\t\t(unsigned long)ino,\n\t\t\t\t\tle16_to_cpu(fnode->ea_offs), le16_to_cpu(fnode->ea_size_s));\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tea = fnode_ea(fnode);\n\t\t\tea_end = fnode_end_ea(fnode);\n\t\t\twhile (ea != ea_end) {\n\t\t\t\tif (ea > ea_end) {\n\t\t\t\t\thpfs_error(s, \"bad EA in fnode %08lx\",\n\t\t\t\t\t\t(unsigned long)ino);\n\t\t\t\t\tgoto bail;\n\t\t\t\t}\n\t\t\t\tea = next_ea(ea);\n\t\t\t}\n\t\t}\n\t}\n\treturn fnode;\n\tbail:\n\tbrelse(*bhp);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "up"
          ],
          "line": 556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hpfs_free_dnode",
          "args": [
            "i->i_sb",
            "dno"
          ],
          "line": 539
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_free_dnode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/alloc.c",
          "lines": "404-425",
          "snippet": "void hpfs_free_dnode(struct super_block *s, dnode_secno dno)\n{\n\tif (hpfs_sb(s)->sb_chk) if (dno & 3) {\n\t\thpfs_error(s, \"hpfs_free_dnode: dnode %08x not aligned\", dno);\n\t\treturn;\n\t}\n\tif (dno < hpfs_sb(s)->sb_dirband_start ||\n\t    dno >= hpfs_sb(s)->sb_dirband_start + hpfs_sb(s)->sb_dirband_size) {\n\t\thpfs_free_sectors(s, dno, 4);\n\t} else {\n\t\tstruct quad_buffer_head qbh;\n\t\t__le32 *bmp;\n\t\tunsigned ssec = (dno - hpfs_sb(s)->sb_dirband_start) / 4;\n\t\tif (!(bmp = hpfs_map_dnode_bitmap(s, &qbh))) {\n\t\t\treturn;\n\t\t}\n\t\tbmp[ssec >> 5] |= cpu_to_le32(1 << (ssec & 0x1f));\n\t\thpfs_mark_4buffers_dirty(&qbh);\n\t\thpfs_brelse4(&qbh);\n\t\thpfs_claim_dirband_free(s, dno);\n\t}\n}",
          "includes": [
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n\nvoid hpfs_free_dnode(struct super_block *s, dnode_secno dno)\n{\n\tif (hpfs_sb(s)->sb_chk) if (dno & 3) {\n\t\thpfs_error(s, \"hpfs_free_dnode: dnode %08x not aligned\", dno);\n\t\treturn;\n\t}\n\tif (dno < hpfs_sb(s)->sb_dirband_start ||\n\t    dno >= hpfs_sb(s)->sb_dirband_start + hpfs_sb(s)->sb_dirband_size) {\n\t\thpfs_free_sectors(s, dno, 4);\n\t} else {\n\t\tstruct quad_buffer_head qbh;\n\t\t__le32 *bmp;\n\t\tunsigned ssec = (dno - hpfs_sb(s)->sb_dirband_start) / 4;\n\t\tif (!(bmp = hpfs_map_dnode_bitmap(s, &qbh))) {\n\t\t\treturn;\n\t\t}\n\t\tbmp[ssec >> 5] |= cpu_to_le32(1 << (ssec & 0x1f));\n\t\thpfs_mark_4buffers_dirty(&qbh);\n\t\thpfs_brelse4(&qbh);\n\t\thpfs_claim_dirband_free(s, dno);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_stop_cycles",
          "args": [
            "i->i_sb",
            "dno",
            "&c1",
            "&c2",
            "\"delete_empty_dnode\""
          ],
          "line": 525
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_stop_cycles",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/super.c",
          "lines": "96-106",
          "snippet": "int hpfs_stop_cycles(struct super_block *s, int key, int *c1, int *c2,\n\t\tchar *msg)\n{\n\tif (*c2 && *c1 == key) {\n\t\thpfs_error(s, \"cycle detected on key %08x in %s\", key, msg);\n\t\treturn 1;\n\t}\n\t(*c2)++;\n\tif (!((*c2 - 1) & *c2)) *c1 = key;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/sched.h>",
            "#include <linux/magic.h>",
            "#include <linux/statfs.h>",
            "#include <linux/init.h>",
            "#include <linux/parser.h>",
            "#include <linux/module.h>",
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/bitmap.h>\n#include <linux/sched.h>\n#include <linux/magic.h>\n#include <linux/statfs.h>\n#include <linux/init.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include \"hpfs_fn.h\"\n\nint hpfs_stop_cycles(struct super_block *s, int key, int *c1, int *c2,\n\t\tchar *msg)\n{\n\tif (*c2 && *c1 == key) {\n\t\thpfs_error(s, \"cycle detected on key %08x in %s\", key, msg);\n\t\treturn 1;\n\t}\n\t(*c2)++;\n\tif (!((*c2 - 1) & *c2)) *c1 = key;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_i",
          "args": [
            "i"
          ],
          "line": 517
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_i",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "305-308",
          "snippet": "static inline struct hpfs_inode_info *hpfs_i(struct inode *inode)\n{\n\treturn list_entry(inode, struct hpfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void hpfs_truncate(struct inode *);",
            "void hpfs_init_inode(struct inode *);",
            "void hpfs_read_inode(struct inode *);",
            "void hpfs_write_inode(struct inode *);",
            "void hpfs_write_inode_nolock(struct inode *);",
            "void hpfs_write_if_changed(struct inode *);",
            "void hpfs_evict_inode(struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nvoid hpfs_truncate(struct inode *);\nvoid hpfs_init_inode(struct inode *);\nvoid hpfs_read_inode(struct inode *);\nvoid hpfs_write_inode(struct inode *);\nvoid hpfs_write_inode_nolock(struct inode *);\nvoid hpfs_write_if_changed(struct inode *);\nvoid hpfs_evict_inode(struct inode *);\n\nstatic inline struct hpfs_inode_info *hpfs_i(struct inode *inode)\n{\n\treturn list_entry(inode, struct hpfs_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hpfs_fn.h\"\n\nstatic void delete_empty_dnode(struct inode *i, dnode_secno dno)\n{\n\tstruct hpfs_inode_info *hpfs_inode = hpfs_i(i);\n\tstruct quad_buffer_head qbh;\n\tstruct dnode *dnode;\n\tdnode_secno down, up, ndown;\n\tint p;\n\tstruct hpfs_dirent *de;\n\tint c1, c2 = 0;\n\ttry_it_again:\n\tif (hpfs_stop_cycles(i->i_sb, dno, &c1, &c2, \"delete_empty_dnode\")) return;\n\tif (!(dnode = hpfs_map_dnode(i->i_sb, dno, &qbh))) return;\n\tif (le32_to_cpu(dnode->first_free) > 56) goto end;\n\tif (le32_to_cpu(dnode->first_free) == 52 || le32_to_cpu(dnode->first_free) == 56) {\n\t\tstruct hpfs_dirent *de_end;\n\t\tint root = dnode->root_dnode;\n\t\tup = le32_to_cpu(dnode->up);\n\t\tde = dnode_first_de(dnode);\n\t\tdown = de->down ? de_down_pointer(de) : 0;\n\t\tif (hpfs_sb(i->i_sb)->sb_chk) if (root && !down) {\n\t\t\thpfs_error(i->i_sb, \"delete_empty_dnode: root dnode %08x is empty\", dno);\n\t\t\tgoto end;\n\t\t}\n\t\thpfs_brelse4(&qbh);\n\t\thpfs_free_dnode(i->i_sb, dno);\n\t\ti->i_size -= 2048;\n\t\ti->i_blocks -= 4;\n\t\tif (root) {\n\t\t\tstruct fnode *fnode;\n\t\t\tstruct buffer_head *bh;\n\t\t\tstruct dnode *d1;\n\t\t\tstruct quad_buffer_head qbh1;\n\t\t\tif (hpfs_sb(i->i_sb)->sb_chk)\n\t\t\t\tif (up != i->i_ino) {\n\t\t\t\t\thpfs_error(i->i_sb,\n\t\t\t\t\t\t   \"bad pointer to fnode, dnode %08x, pointing to %08x, should be %08lx\",\n\t\t\t\t\t\t   dno, up,\n\t\t\t\t\t\t   (unsigned long)i->i_ino);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\tif ((d1 = hpfs_map_dnode(i->i_sb, down, &qbh1))) {\n\t\t\t\td1->up = cpu_to_le32(up);\n\t\t\t\td1->root_dnode = 1;\n\t\t\t\thpfs_mark_4buffers_dirty(&qbh1);\n\t\t\t\thpfs_brelse4(&qbh1);\n\t\t\t}\n\t\t\tif ((fnode = hpfs_map_fnode(i->i_sb, up, &bh))) {\n\t\t\t\tfnode->u.external[0].disk_secno = cpu_to_le32(down);\n\t\t\t\tmark_buffer_dirty(bh);\n\t\t\t\tbrelse(bh);\n\t\t\t}\n\t\t\thpfs_inode->i_dno = down;\n\t\t\tfor_all_poss(i, hpfs_pos_subst, ((loff_t)dno << 4) | 1, (loff_t) 12);\n\t\t\treturn;\n\t\t}\n\t\tif (!(dnode = hpfs_map_dnode(i->i_sb, up, &qbh))) return;\n\t\tp = 1;\n\t\tde_end = dnode_end_de(dnode);\n\t\tfor (de = dnode_first_de(dnode); de < de_end; de = de_next_de(de), p++)\n\t\t\tif (de->down) if (de_down_pointer(de) == dno) goto fnd;\n\t\thpfs_error(i->i_sb, \"delete_empty_dnode: pointer to dnode %08x not found in dnode %08x\", dno, up);\n\t\tgoto end;\n\t\tfnd:\n\t\tfor_all_poss(i, hpfs_pos_subst, ((loff_t)dno << 4) | 1, ((loff_t)up << 4) | p);\n\t\tif (!down) {\n\t\t\tde->down = 0;\n\t\t\tle16_add_cpu(&de->length, -4);\n\t\t\tle32_add_cpu(&dnode->first_free, -4);\n\t\t\tmemmove(de_next_de(de), (char *)de_next_de(de) + 4,\n\t\t\t\t(char *)dnode + le32_to_cpu(dnode->first_free) - (char *)de_next_de(de));\n\t\t} else {\n\t\t\tstruct dnode *d1;\n\t\t\tstruct quad_buffer_head qbh1;\n\t\t\t*(dnode_secno *) ((void *) de + le16_to_cpu(de->length) - 4) = down;\n\t\t\tif ((d1 = hpfs_map_dnode(i->i_sb, down, &qbh1))) {\n\t\t\t\td1->up = cpu_to_le32(up);\n\t\t\t\thpfs_mark_4buffers_dirty(&qbh1);\n\t\t\t\thpfs_brelse4(&qbh1);\n\t\t\t}\n\t\t}\n\t} else {\n\t\thpfs_error(i->i_sb, \"delete_empty_dnode: dnode %08x, first_free == %03x\", dno, le32_to_cpu(dnode->first_free));\n\t\tgoto end;\n\t}\n\n\tif (!de->last) {\n\t\tstruct hpfs_dirent *de_next = de_next_de(de);\n\t\tstruct hpfs_dirent *de_cp;\n\t\tstruct dnode *d1;\n\t\tstruct quad_buffer_head qbh1;\n\t\tif (!de_next->down) goto endm;\n\t\tndown = de_down_pointer(de_next);\n\t\tif (!(de_cp = kmalloc(le16_to_cpu(de->length), GFP_NOFS))) {\n\t\t\tpr_err(\"out of memory for dtree balancing\\n\");\n\t\t\tgoto endm;\n\t\t}\n\t\tmemcpy(de_cp, de, le16_to_cpu(de->length));\n\t\thpfs_delete_de(i->i_sb, dnode, de);\n\t\thpfs_mark_4buffers_dirty(&qbh);\n\t\thpfs_brelse4(&qbh);\n\t\tfor_all_poss(i, hpfs_pos_subst, ((loff_t)up << 4) | p, 4);\n\t\tfor_all_poss(i, hpfs_pos_del, ((loff_t)up << 4) | p, 1);\n\t\tif (de_cp->down) if ((d1 = hpfs_map_dnode(i->i_sb, de_down_pointer(de_cp), &qbh1))) {\n\t\t\td1->up = cpu_to_le32(ndown);\n\t\t\thpfs_mark_4buffers_dirty(&qbh1);\n\t\t\thpfs_brelse4(&qbh1);\n\t\t}\n\t\thpfs_add_to_dnode(i, ndown, de_cp->name, de_cp->namelen, de_cp, de_cp->down ? de_down_pointer(de_cp) : 0);\n\t\t/*pr_info(\"UP-TO-DNODE: %08x (ndown = %08x, down = %08x, dno = %08x)\\n\",\n\t\t  up, ndown, down, dno);*/\n\t\tdno = up;\n\t\tkfree(de_cp);\n\t\tgoto try_it_again;\n\t} else {\n\t\tstruct hpfs_dirent *de_prev = dnode_pre_last_de(dnode);\n\t\tstruct hpfs_dirent *de_cp;\n\t\tstruct dnode *d1;\n\t\tstruct quad_buffer_head qbh1;\n\t\tdnode_secno dlp;\n\t\tif (!de_prev) {\n\t\t\thpfs_error(i->i_sb, \"delete_empty_dnode: empty dnode %08x\", up);\n\t\t\thpfs_mark_4buffers_dirty(&qbh);\n\t\t\thpfs_brelse4(&qbh);\n\t\t\tdno = up;\n\t\t\tgoto try_it_again;\n\t\t}\n\t\tif (!de_prev->down) goto endm;\n\t\tndown = de_down_pointer(de_prev);\n\t\tif ((d1 = hpfs_map_dnode(i->i_sb, ndown, &qbh1))) {\n\t\t\tstruct hpfs_dirent *del = dnode_last_de(d1);\n\t\t\tdlp = del->down ? de_down_pointer(del) : 0;\n\t\t\tif (!dlp && down) {\n\t\t\t\tif (le32_to_cpu(d1->first_free) > 2044) {\n\t\t\t\t\tif (hpfs_sb(i->i_sb)->sb_chk >= 2) {\n\t\t\t\t\t\tpr_err(\"unbalanced dnode tree, see hpfs.txt 4 more info\\n\");\n\t\t\t\t\t\tpr_err(\"terminating balancing operation\\n\");\n\t\t\t\t\t}\n\t\t\t\t\thpfs_brelse4(&qbh1);\n\t\t\t\t\tgoto endm;\n\t\t\t\t}\n\t\t\t\tif (hpfs_sb(i->i_sb)->sb_chk >= 2) {\n\t\t\t\t\tpr_err(\"unbalanced dnode tree, see hpfs.txt 4 more info\\n\");\n\t\t\t\t\tpr_err(\"goin'on\\n\");\n\t\t\t\t}\n\t\t\t\tle16_add_cpu(&del->length, 4);\n\t\t\t\tdel->down = 1;\n\t\t\t\tle32_add_cpu(&d1->first_free, 4);\n\t\t\t}\n\t\t\tif (dlp && !down) {\n\t\t\t\tle16_add_cpu(&del->length, -4);\n\t\t\t\tdel->down = 0;\n\t\t\t\tle32_add_cpu(&d1->first_free, -4);\n\t\t\t} else if (down)\n\t\t\t\t*(__le32 *) ((void *) del + le16_to_cpu(del->length) - 4) = cpu_to_le32(down);\n\t\t} else goto endm;\n\t\tif (!(de_cp = kmalloc(le16_to_cpu(de_prev->length), GFP_NOFS))) {\n\t\t\tpr_err(\"out of memory for dtree balancing\\n\");\n\t\t\thpfs_brelse4(&qbh1);\n\t\t\tgoto endm;\n\t\t}\n\t\thpfs_mark_4buffers_dirty(&qbh1);\n\t\thpfs_brelse4(&qbh1);\n\t\tmemcpy(de_cp, de_prev, le16_to_cpu(de_prev->length));\n\t\thpfs_delete_de(i->i_sb, dnode, de_prev);\n\t\tif (!de_prev->down) {\n\t\t\tle16_add_cpu(&de_prev->length, 4);\n\t\t\tde_prev->down = 1;\n\t\t\tle32_add_cpu(&dnode->first_free, 4);\n\t\t}\n\t\t*(__le32 *) ((void *) de_prev + le16_to_cpu(de_prev->length) - 4) = cpu_to_le32(ndown);\n\t\thpfs_mark_4buffers_dirty(&qbh);\n\t\thpfs_brelse4(&qbh);\n\t\tfor_all_poss(i, hpfs_pos_subst, ((loff_t)up << 4) | (p - 1), 4);\n\t\tfor_all_poss(i, hpfs_pos_subst, ((loff_t)up << 4) | p, ((loff_t)up << 4) | (p - 1));\n\t\tif (down) if ((d1 = hpfs_map_dnode(i->i_sb, de_down_pointer(de), &qbh1))) {\n\t\t\td1->up = cpu_to_le32(ndown);\n\t\t\thpfs_mark_4buffers_dirty(&qbh1);\n\t\t\thpfs_brelse4(&qbh1);\n\t\t}\n\t\thpfs_add_to_dnode(i, ndown, de_cp->name, de_cp->namelen, de_cp, dlp);\n\t\tdno = up;\n\t\tkfree(de_cp);\n\t\tgoto try_it_again;\n\t}\n\tendm:\n\thpfs_mark_4buffers_dirty(&qbh);\n\tend:\n\thpfs_brelse4(&qbh);\n}"
  },
  {
    "function_name": "move_to_top",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/dnode.c",
    "lines": "430-508",
    "snippet": "static secno move_to_top(struct inode *i, dnode_secno from, dnode_secno to)\n{\n\tdnode_secno dno, ddno;\n\tdnode_secno chk_up = to;\n\tstruct dnode *dnode;\n\tstruct quad_buffer_head qbh;\n\tstruct hpfs_dirent *de, *nde;\n\tint a;\n\tloff_t t;\n\tint c1, c2 = 0;\n\tdno = from;\n\twhile (1) {\n\t\tif (hpfs_sb(i->i_sb)->sb_chk)\n\t\t\tif (hpfs_stop_cycles(i->i_sb, dno, &c1, &c2, \"move_to_top\"))\n\t\t\t\treturn 0;\n\t\tif (!(dnode = hpfs_map_dnode(i->i_sb, dno, &qbh))) return 0;\n\t\tif (hpfs_sb(i->i_sb)->sb_chk) {\n\t\t\tif (le32_to_cpu(dnode->up) != chk_up) {\n\t\t\t\thpfs_error(i->i_sb, \"move_to_top: up pointer from %08x should be %08x, is %08x\",\n\t\t\t\t\tdno, chk_up, le32_to_cpu(dnode->up));\n\t\t\t\thpfs_brelse4(&qbh);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tchk_up = dno;\n\t\t}\n\t\tif (!(de = dnode_last_de(dnode))) {\n\t\t\thpfs_error(i->i_sb, \"move_to_top: dnode %08x has no last de\", dno);\n\t\t\thpfs_brelse4(&qbh);\n\t\t\treturn 0;\n\t\t}\n\t\tif (!de->down) break;\n\t\tdno = de_down_pointer(de);\n\t\thpfs_brelse4(&qbh);\n\t}\n\twhile (!(de = dnode_pre_last_de(dnode))) {\n\t\tdnode_secno up = le32_to_cpu(dnode->up);\n\t\thpfs_brelse4(&qbh);\n\t\thpfs_free_dnode(i->i_sb, dno);\n\t\ti->i_size -= 2048;\n\t\ti->i_blocks -= 4;\n\t\tfor_all_poss(i, hpfs_pos_subst, ((loff_t)dno << 4) | 1, 5);\n\t\tif (up == to) return to;\n\t\tif (!(dnode = hpfs_map_dnode(i->i_sb, up, &qbh))) return 0;\n\t\tif (dnode->root_dnode) {\n\t\t\thpfs_error(i->i_sb, \"move_to_top: got to root_dnode while moving from %08x to %08x\", from, to);\n\t\t\thpfs_brelse4(&qbh);\n\t\t\treturn 0;\n\t\t}\n\t\tde = dnode_last_de(dnode);\n\t\tif (!de || !de->down) {\n\t\t\thpfs_error(i->i_sb, \"move_to_top: dnode %08x doesn't point down to %08x\", up, dno);\n\t\t\thpfs_brelse4(&qbh);\n\t\t\treturn 0;\n\t\t}\n\t\tle32_add_cpu(&dnode->first_free, -4);\n\t\tle16_add_cpu(&de->length, -4);\n\t\tde->down = 0;\n\t\thpfs_mark_4buffers_dirty(&qbh);\n\t\tdno = up;\n\t}\n\tt = get_pos(dnode, de);\n\tfor_all_poss(i, hpfs_pos_subst, t, 4);\n\tfor_all_poss(i, hpfs_pos_subst, t + 1, 5);\n\tif (!(nde = kmalloc(le16_to_cpu(de->length), GFP_NOFS))) {\n\t\thpfs_error(i->i_sb, \"out of memory for dirent - directory will be corrupted\");\n\t\thpfs_brelse4(&qbh);\n\t\treturn 0;\n\t}\n\tmemcpy(nde, de, le16_to_cpu(de->length));\n\tddno = de->down ? de_down_pointer(de) : 0;\n\thpfs_delete_de(i->i_sb, dnode, de);\n\tset_last_pointer(i->i_sb, dnode, ddno);\n\thpfs_mark_4buffers_dirty(&qbh);\n\thpfs_brelse4(&qbh);\n\ta = hpfs_add_to_dnode(i, to, nde->name, nde->namelen, nde, from);\n\tkfree(nde);\n\tif (a) return 0;\n\treturn dno;\n}",
    "includes": [
      "#include \"hpfs_fn.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "nde"
          ],
          "line": 505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hpfs_add_to_dnode",
          "args": [
            "i",
            "to",
            "nde->name",
            "nde->namelen",
            "nde",
            "from"
          ],
          "line": 504
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_add_to_dnode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/dnode.c",
          "lines": "233-373",
          "snippet": "static int hpfs_add_to_dnode(struct inode *i, dnode_secno dno,\n\t\t\t     const unsigned char *name, unsigned namelen,\n\t\t\t     struct hpfs_dirent *new_de, dnode_secno down_ptr)\n{\n\tstruct quad_buffer_head qbh, qbh1, qbh2;\n\tstruct dnode *d, *ad, *rd, *nd = NULL;\n\tdnode_secno adno, rdno;\n\tstruct hpfs_dirent *de;\n\tstruct hpfs_dirent nde;\n\tunsigned char *nname;\n\tint h;\n\tint pos;\n\tstruct buffer_head *bh;\n\tstruct fnode *fnode;\n\tint c1, c2 = 0;\n\tif (!(nname = kmalloc(256, GFP_NOFS))) {\n\t\tpr_err(\"out of memory, can't add to dnode\\n\");\n\t\treturn 1;\n\t}\n\tgo_up:\n\tif (namelen >= 256) {\n\t\thpfs_error(i->i_sb, \"%s(): namelen == %d\", __func__, namelen);\n\t\tkfree(nd);\n\t\tkfree(nname);\n\t\treturn 1;\n\t}\n\tif (!(d = hpfs_map_dnode(i->i_sb, dno, &qbh))) {\n\t\tkfree(nd);\n\t\tkfree(nname);\n\t\treturn 1;\n\t}\n\tgo_up_a:\n\tif (hpfs_sb(i->i_sb)->sb_chk)\n\t\tif (hpfs_stop_cycles(i->i_sb, dno, &c1, &c2, \"hpfs_add_to_dnode\")) {\n\t\t\thpfs_brelse4(&qbh);\n\t\t\tkfree(nd);\n\t\t\tkfree(nname);\n\t\t\treturn 1;\n\t\t}\n\tif (le32_to_cpu(d->first_free) + de_size(namelen, down_ptr) <= 2048) {\n\t\tloff_t t;\n\t\tcopy_de(de=hpfs_add_de(i->i_sb, d, name, namelen, down_ptr), new_de);\n\t\tt = get_pos(d, de);\n\t\tfor_all_poss(i, hpfs_pos_ins, t, 1);\n\t\tfor_all_poss(i, hpfs_pos_subst, 4, t);\n\t\tfor_all_poss(i, hpfs_pos_subst, 5, t + 1);\n\t\thpfs_mark_4buffers_dirty(&qbh);\n\t\thpfs_brelse4(&qbh);\n\t\tkfree(nd);\n\t\tkfree(nname);\n\t\treturn 0;\n\t}\n\tif (!nd) if (!(nd = kmalloc(0x924, GFP_NOFS))) {\n\t\t/* 0x924 is a max size of dnode after adding a dirent with\n\t\t   max name length. We alloc this only once. There must\n\t\t   not be any error while splitting dnodes, otherwise the\n\t\t   whole directory, not only file we're adding, would\n\t\t   be lost. */\n\t\tpr_err(\"out of memory for dnode splitting\\n\");\n\t\thpfs_brelse4(&qbh);\n\t\tkfree(nname);\n\t\treturn 1;\n\t}\t\n\tmemcpy(nd, d, le32_to_cpu(d->first_free));\n\tcopy_de(de = hpfs_add_de(i->i_sb, nd, name, namelen, down_ptr), new_de);\n\tfor_all_poss(i, hpfs_pos_ins, get_pos(nd, de), 1);\n\th = ((char *)dnode_last_de(nd) - (char *)nd) / 2 + 10;\n\tif (!(ad = hpfs_alloc_dnode(i->i_sb, le32_to_cpu(d->up), &adno, &qbh1))) {\n\t\thpfs_error(i->i_sb, \"unable to alloc dnode - dnode tree will be corrupted\");\n\t\thpfs_brelse4(&qbh);\n\t\tkfree(nd);\n\t\tkfree(nname);\n\t\treturn 1;\n\t}\n\ti->i_size += 2048;\n\ti->i_blocks += 4;\n\tpos = 1;\n\tfor (de = dnode_first_de(nd); (char *)de_next_de(de) - (char *)nd < h; de = de_next_de(de)) {\n\t\tcopy_de(hpfs_add_de(i->i_sb, ad, de->name, de->namelen, de->down ? de_down_pointer(de) : 0), de);\n\t\tfor_all_poss(i, hpfs_pos_subst, ((loff_t)dno << 4) | pos, ((loff_t)adno << 4) | pos);\n\t\tpos++;\n\t}\n\tcopy_de(new_de = &nde, de);\n\tmemcpy(nname, de->name, de->namelen);\n\tname = nname;\n\tnamelen = de->namelen;\n\tfor_all_poss(i, hpfs_pos_subst, ((loff_t)dno << 4) | pos, 4);\n\tdown_ptr = adno;\n\tset_last_pointer(i->i_sb, ad, de->down ? de_down_pointer(de) : 0);\n\tde = de_next_de(de);\n\tmemmove((char *)nd + 20, de, le32_to_cpu(nd->first_free) + (char *)nd - (char *)de);\n\tle32_add_cpu(&nd->first_free, -((char *)de - (char *)nd - 20));\n\tmemcpy(d, nd, le32_to_cpu(nd->first_free));\n\tfor_all_poss(i, hpfs_pos_del, (loff_t)dno << 4, pos);\n\tfix_up_ptrs(i->i_sb, ad);\n\tif (!d->root_dnode) {\n\t\tad->up = d->up;\n\t\tdno = le32_to_cpu(ad->up);\n\t\thpfs_mark_4buffers_dirty(&qbh);\n\t\thpfs_brelse4(&qbh);\n\t\thpfs_mark_4buffers_dirty(&qbh1);\n\t\thpfs_brelse4(&qbh1);\n\t\tgoto go_up;\n\t}\n\tif (!(rd = hpfs_alloc_dnode(i->i_sb, le32_to_cpu(d->up), &rdno, &qbh2))) {\n\t\thpfs_error(i->i_sb, \"unable to alloc dnode - dnode tree will be corrupted\");\n\t\thpfs_brelse4(&qbh);\n\t\thpfs_brelse4(&qbh1);\n\t\tkfree(nd);\n\t\tkfree(nname);\n\t\treturn 1;\n\t}\n\ti->i_size += 2048;\n\ti->i_blocks += 4;\n\trd->root_dnode = 1;\n\trd->up = d->up;\n\tif (!(fnode = hpfs_map_fnode(i->i_sb, le32_to_cpu(d->up), &bh))) {\n\t\thpfs_free_dnode(i->i_sb, rdno);\n\t\thpfs_brelse4(&qbh);\n\t\thpfs_brelse4(&qbh1);\n\t\thpfs_brelse4(&qbh2);\n\t\tkfree(nd);\n\t\tkfree(nname);\n\t\treturn 1;\n\t}\n\tfnode->u.external[0].disk_secno = cpu_to_le32(rdno);\n\tmark_buffer_dirty(bh);\n\tbrelse(bh);\n\thpfs_i(i)->i_dno = rdno;\n\td->up = ad->up = cpu_to_le32(rdno);\n\td->root_dnode = ad->root_dnode = 0;\n\thpfs_mark_4buffers_dirty(&qbh);\n\thpfs_brelse4(&qbh);\n\thpfs_mark_4buffers_dirty(&qbh1);\n\thpfs_brelse4(&qbh1);\n\tqbh = qbh2;\n\tset_last_pointer(i->i_sb, rd, dno);\n\tdno = rdno;\n\td = rd;\n\tgoto go_up_a;\n}",
          "includes": [
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n\nstatic int hpfs_add_to_dnode(struct inode *i, dnode_secno dno,\n\t\t\t     const unsigned char *name, unsigned namelen,\n\t\t\t     struct hpfs_dirent *new_de, dnode_secno down_ptr)\n{\n\tstruct quad_buffer_head qbh, qbh1, qbh2;\n\tstruct dnode *d, *ad, *rd, *nd = NULL;\n\tdnode_secno adno, rdno;\n\tstruct hpfs_dirent *de;\n\tstruct hpfs_dirent nde;\n\tunsigned char *nname;\n\tint h;\n\tint pos;\n\tstruct buffer_head *bh;\n\tstruct fnode *fnode;\n\tint c1, c2 = 0;\n\tif (!(nname = kmalloc(256, GFP_NOFS))) {\n\t\tpr_err(\"out of memory, can't add to dnode\\n\");\n\t\treturn 1;\n\t}\n\tgo_up:\n\tif (namelen >= 256) {\n\t\thpfs_error(i->i_sb, \"%s(): namelen == %d\", __func__, namelen);\n\t\tkfree(nd);\n\t\tkfree(nname);\n\t\treturn 1;\n\t}\n\tif (!(d = hpfs_map_dnode(i->i_sb, dno, &qbh))) {\n\t\tkfree(nd);\n\t\tkfree(nname);\n\t\treturn 1;\n\t}\n\tgo_up_a:\n\tif (hpfs_sb(i->i_sb)->sb_chk)\n\t\tif (hpfs_stop_cycles(i->i_sb, dno, &c1, &c2, \"hpfs_add_to_dnode\")) {\n\t\t\thpfs_brelse4(&qbh);\n\t\t\tkfree(nd);\n\t\t\tkfree(nname);\n\t\t\treturn 1;\n\t\t}\n\tif (le32_to_cpu(d->first_free) + de_size(namelen, down_ptr) <= 2048) {\n\t\tloff_t t;\n\t\tcopy_de(de=hpfs_add_de(i->i_sb, d, name, namelen, down_ptr), new_de);\n\t\tt = get_pos(d, de);\n\t\tfor_all_poss(i, hpfs_pos_ins, t, 1);\n\t\tfor_all_poss(i, hpfs_pos_subst, 4, t);\n\t\tfor_all_poss(i, hpfs_pos_subst, 5, t + 1);\n\t\thpfs_mark_4buffers_dirty(&qbh);\n\t\thpfs_brelse4(&qbh);\n\t\tkfree(nd);\n\t\tkfree(nname);\n\t\treturn 0;\n\t}\n\tif (!nd) if (!(nd = kmalloc(0x924, GFP_NOFS))) {\n\t\t/* 0x924 is a max size of dnode after adding a dirent with\n\t\t   max name length. We alloc this only once. There must\n\t\t   not be any error while splitting dnodes, otherwise the\n\t\t   whole directory, not only file we're adding, would\n\t\t   be lost. */\n\t\tpr_err(\"out of memory for dnode splitting\\n\");\n\t\thpfs_brelse4(&qbh);\n\t\tkfree(nname);\n\t\treturn 1;\n\t}\t\n\tmemcpy(nd, d, le32_to_cpu(d->first_free));\n\tcopy_de(de = hpfs_add_de(i->i_sb, nd, name, namelen, down_ptr), new_de);\n\tfor_all_poss(i, hpfs_pos_ins, get_pos(nd, de), 1);\n\th = ((char *)dnode_last_de(nd) - (char *)nd) / 2 + 10;\n\tif (!(ad = hpfs_alloc_dnode(i->i_sb, le32_to_cpu(d->up), &adno, &qbh1))) {\n\t\thpfs_error(i->i_sb, \"unable to alloc dnode - dnode tree will be corrupted\");\n\t\thpfs_brelse4(&qbh);\n\t\tkfree(nd);\n\t\tkfree(nname);\n\t\treturn 1;\n\t}\n\ti->i_size += 2048;\n\ti->i_blocks += 4;\n\tpos = 1;\n\tfor (de = dnode_first_de(nd); (char *)de_next_de(de) - (char *)nd < h; de = de_next_de(de)) {\n\t\tcopy_de(hpfs_add_de(i->i_sb, ad, de->name, de->namelen, de->down ? de_down_pointer(de) : 0), de);\n\t\tfor_all_poss(i, hpfs_pos_subst, ((loff_t)dno << 4) | pos, ((loff_t)adno << 4) | pos);\n\t\tpos++;\n\t}\n\tcopy_de(new_de = &nde, de);\n\tmemcpy(nname, de->name, de->namelen);\n\tname = nname;\n\tnamelen = de->namelen;\n\tfor_all_poss(i, hpfs_pos_subst, ((loff_t)dno << 4) | pos, 4);\n\tdown_ptr = adno;\n\tset_last_pointer(i->i_sb, ad, de->down ? de_down_pointer(de) : 0);\n\tde = de_next_de(de);\n\tmemmove((char *)nd + 20, de, le32_to_cpu(nd->first_free) + (char *)nd - (char *)de);\n\tle32_add_cpu(&nd->first_free, -((char *)de - (char *)nd - 20));\n\tmemcpy(d, nd, le32_to_cpu(nd->first_free));\n\tfor_all_poss(i, hpfs_pos_del, (loff_t)dno << 4, pos);\n\tfix_up_ptrs(i->i_sb, ad);\n\tif (!d->root_dnode) {\n\t\tad->up = d->up;\n\t\tdno = le32_to_cpu(ad->up);\n\t\thpfs_mark_4buffers_dirty(&qbh);\n\t\thpfs_brelse4(&qbh);\n\t\thpfs_mark_4buffers_dirty(&qbh1);\n\t\thpfs_brelse4(&qbh1);\n\t\tgoto go_up;\n\t}\n\tif (!(rd = hpfs_alloc_dnode(i->i_sb, le32_to_cpu(d->up), &rdno, &qbh2))) {\n\t\thpfs_error(i->i_sb, \"unable to alloc dnode - dnode tree will be corrupted\");\n\t\thpfs_brelse4(&qbh);\n\t\thpfs_brelse4(&qbh1);\n\t\tkfree(nd);\n\t\tkfree(nname);\n\t\treturn 1;\n\t}\n\ti->i_size += 2048;\n\ti->i_blocks += 4;\n\trd->root_dnode = 1;\n\trd->up = d->up;\n\tif (!(fnode = hpfs_map_fnode(i->i_sb, le32_to_cpu(d->up), &bh))) {\n\t\thpfs_free_dnode(i->i_sb, rdno);\n\t\thpfs_brelse4(&qbh);\n\t\thpfs_brelse4(&qbh1);\n\t\thpfs_brelse4(&qbh2);\n\t\tkfree(nd);\n\t\tkfree(nname);\n\t\treturn 1;\n\t}\n\tfnode->u.external[0].disk_secno = cpu_to_le32(rdno);\n\tmark_buffer_dirty(bh);\n\tbrelse(bh);\n\thpfs_i(i)->i_dno = rdno;\n\td->up = ad->up = cpu_to_le32(rdno);\n\td->root_dnode = ad->root_dnode = 0;\n\thpfs_mark_4buffers_dirty(&qbh);\n\thpfs_brelse4(&qbh);\n\thpfs_mark_4buffers_dirty(&qbh1);\n\thpfs_brelse4(&qbh1);\n\tqbh = qbh2;\n\tset_last_pointer(i->i_sb, rd, dno);\n\tdno = rdno;\n\td = rd;\n\tgoto go_up_a;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_brelse4",
          "args": [
            "&qbh"
          ],
          "line": 503
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_brelse4",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/buffer.c",
          "lines": "182-190",
          "snippet": "void hpfs_brelse4(struct quad_buffer_head *qbh)\n{\n\tif (unlikely(qbh->data != qbh->bh[0]->b_data))\n\t\tkfree(qbh->data);\n\tbrelse(qbh->bh[0]);\n\tbrelse(qbh->bh[1]);\n\tbrelse(qbh->bh[2]);\n\tbrelse(qbh->bh[3]);\n}",
          "includes": [
            "#include \"hpfs_fn.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid hpfs_brelse4(struct quad_buffer_head *qbh)\n{\n\tif (unlikely(qbh->data != qbh->bh[0]->b_data))\n\t\tkfree(qbh->data);\n\tbrelse(qbh->bh[0]);\n\tbrelse(qbh->bh[1]);\n\tbrelse(qbh->bh[2]);\n\tbrelse(qbh->bh[3]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_mark_4buffers_dirty",
          "args": [
            "&qbh"
          ],
          "line": 502
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_mark_4buffers_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/buffer.c",
          "lines": "192-204",
          "snippet": "void hpfs_mark_4buffers_dirty(struct quad_buffer_head *qbh)\n{\n\tif (unlikely(qbh->data != qbh->bh[0]->b_data)) {\n\t\tmemcpy(qbh->bh[0]->b_data, qbh->data + 0 * 512, 512);\n\t\tmemcpy(qbh->bh[1]->b_data, qbh->data + 1 * 512, 512);\n\t\tmemcpy(qbh->bh[2]->b_data, qbh->data + 2 * 512, 512);\n\t\tmemcpy(qbh->bh[3]->b_data, qbh->data + 3 * 512, 512);\n\t}\n\tmark_buffer_dirty(qbh->bh[0]);\n\tmark_buffer_dirty(qbh->bh[1]);\n\tmark_buffer_dirty(qbh->bh[2]);\n\tmark_buffer_dirty(qbh->bh[3]);\n}",
          "includes": [
            "#include \"hpfs_fn.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid hpfs_mark_4buffers_dirty(struct quad_buffer_head *qbh)\n{\n\tif (unlikely(qbh->data != qbh->bh[0]->b_data)) {\n\t\tmemcpy(qbh->bh[0]->b_data, qbh->data + 0 * 512, 512);\n\t\tmemcpy(qbh->bh[1]->b_data, qbh->data + 1 * 512, 512);\n\t\tmemcpy(qbh->bh[2]->b_data, qbh->data + 2 * 512, 512);\n\t\tmemcpy(qbh->bh[3]->b_data, qbh->data + 3 * 512, 512);\n\t}\n\tmark_buffer_dirty(qbh->bh[0]);\n\tmark_buffer_dirty(qbh->bh[1]);\n\tmark_buffer_dirty(qbh->bh[2]);\n\tmark_buffer_dirty(qbh->bh[3]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_last_pointer",
          "args": [
            "i->i_sb",
            "dnode",
            "ddno"
          ],
          "line": 501
        },
        "resolved": true,
        "details": {
          "function_name": "set_last_pointer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/dnode.c",
          "lines": "136-165",
          "snippet": "static void set_last_pointer(struct super_block *s, struct dnode *d, dnode_secno ptr)\n{\n\tstruct hpfs_dirent *de;\n\tif (!(de = dnode_last_de(d))) {\n\t\thpfs_error(s, \"set_last_pointer: empty dnode %08x\", le32_to_cpu(d->self));\n\t\treturn;\n\t}\n\tif (hpfs_sb(s)->sb_chk) {\n\t\tif (de->down) {\n\t\t\thpfs_error(s, \"set_last_pointer: dnode %08x has already last pointer %08x\",\n\t\t\t\tle32_to_cpu(d->self), de_down_pointer(de));\n\t\t\treturn;\n\t\t}\n\t\tif (le16_to_cpu(de->length) != 32) {\n\t\t\thpfs_error(s, \"set_last_pointer: bad last dirent in dnode %08x\", le32_to_cpu(d->self));\n\t\t\treturn;\n\t\t}\n\t}\n\tif (ptr) {\n\t\tle32_add_cpu(&d->first_free, 4);\n\t\tif (le32_to_cpu(d->first_free) > 2048) {\n\t\t\thpfs_error(s, \"set_last_pointer: too long dnode %08x\", le32_to_cpu(d->self));\n\t\t\tle32_add_cpu(&d->first_free, -4);\n\t\t\treturn;\n\t\t}\n\t\tde->length = cpu_to_le16(36);\n\t\tde->down = 1;\n\t\t*(__le32 *)((char *)de + 32) = cpu_to_le32(ptr);\n\t}\n}",
          "includes": [
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n\nstatic void set_last_pointer(struct super_block *s, struct dnode *d, dnode_secno ptr)\n{\n\tstruct hpfs_dirent *de;\n\tif (!(de = dnode_last_de(d))) {\n\t\thpfs_error(s, \"set_last_pointer: empty dnode %08x\", le32_to_cpu(d->self));\n\t\treturn;\n\t}\n\tif (hpfs_sb(s)->sb_chk) {\n\t\tif (de->down) {\n\t\t\thpfs_error(s, \"set_last_pointer: dnode %08x has already last pointer %08x\",\n\t\t\t\tle32_to_cpu(d->self), de_down_pointer(de));\n\t\t\treturn;\n\t\t}\n\t\tif (le16_to_cpu(de->length) != 32) {\n\t\t\thpfs_error(s, \"set_last_pointer: bad last dirent in dnode %08x\", le32_to_cpu(d->self));\n\t\t\treturn;\n\t\t}\n\t}\n\tif (ptr) {\n\t\tle32_add_cpu(&d->first_free, 4);\n\t\tif (le32_to_cpu(d->first_free) > 2048) {\n\t\t\thpfs_error(s, \"set_last_pointer: too long dnode %08x\", le32_to_cpu(d->self));\n\t\t\tle32_add_cpu(&d->first_free, -4);\n\t\t\treturn;\n\t\t}\n\t\tde->length = cpu_to_le16(36);\n\t\tde->down = 1;\n\t\t*(__le32 *)((char *)de + 32) = cpu_to_le32(ptr);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_delete_de",
          "args": [
            "i->i_sb",
            "dnode",
            "de"
          ],
          "line": 500
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_delete_de",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/dnode.c",
          "lines": "200-209",
          "snippet": "static void hpfs_delete_de(struct super_block *s, struct dnode *d,\n\t\t\t   struct hpfs_dirent *de)\n{\n\tif (de->last) {\n\t\thpfs_error(s, \"attempt to delete last dirent in dnode %08x\", le32_to_cpu(d->self));\n\t\treturn;\n\t}\n\td->first_free = cpu_to_le32(le32_to_cpu(d->first_free) - le16_to_cpu(de->length));\n\tmemmove(de, de_next_de(de), le32_to_cpu(d->first_free) + (char *)d - (char *)de);\n}",
          "includes": [
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n\nstatic void hpfs_delete_de(struct super_block *s, struct dnode *d,\n\t\t\t   struct hpfs_dirent *de)\n{\n\tif (de->last) {\n\t\thpfs_error(s, \"attempt to delete last dirent in dnode %08x\", le32_to_cpu(d->self));\n\t\treturn;\n\t}\n\td->first_free = cpu_to_le32(le32_to_cpu(d->first_free) - le16_to_cpu(de->length));\n\tmemmove(de, de_next_de(de), le32_to_cpu(d->first_free) + (char *)d - (char *)de);\n}"
        }
      },
      {
        "call_info": {
          "callee": "de_down_pointer",
          "args": [
            "de"
          ],
          "line": 499
        },
        "resolved": true,
        "details": {
          "function_name": "de_down_pointer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "100-104",
          "snippet": "static inline dnode_secno de_down_pointer (struct hpfs_dirent *de)\n{\n  CHKCOND(de->down,(\"HPFS: de_down_pointer: !de->down\\n\"));\n  return le32_to_cpu(*(__le32 *) ((void *) de + le16_to_cpu(de->length) - 4));\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_add_dirent(struct inode *, const unsigned char *, unsigned,\n\t\t    struct hpfs_dirent *);",
            "void hpfs_count_dnodes(struct super_block *, dnode_secno, int *, int *, int *);",
            "void hpfs_remove_dtree(struct super_block *, dnode_secno);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_add_dirent(struct inode *, const unsigned char *, unsigned,\n\t\t    struct hpfs_dirent *);\nvoid hpfs_count_dnodes(struct super_block *, dnode_secno, int *, int *, int *);\nvoid hpfs_remove_dtree(struct super_block *, dnode_secno);\n\nstatic inline dnode_secno de_down_pointer (struct hpfs_dirent *de)\n{\n  CHKCOND(de->down,(\"HPFS: de_down_pointer: !de->down\\n\"));\n  return le32_to_cpu(*(__le32 *) ((void *) de + le16_to_cpu(de->length) - 4));\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "nde",
            "de",
            "le16_to_cpu(de->length)"
          ],
          "line": 498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "de->length"
          ],
          "line": 498
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_error",
          "args": [
            "i->i_sb",
            "\"out of memory for dirent - directory will be corrupted\""
          ],
          "line": 494
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/super.c",
          "lines": "57-86",
          "snippet": "void hpfs_error(struct super_block *s, const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvsnprintf(err_buf, sizeof(err_buf), fmt, args);\n\tva_end(args);\n\n\tpr_err(\"filesystem error: %s\", err_buf);\n\tif (!hpfs_sb(s)->sb_was_error) {\n\t\tif (hpfs_sb(s)->sb_err == 2) {\n\t\t\tpr_cont(\"; crashing the system because you wanted it\\n\");\n\t\t\tmark_dirty(s, 0);\n\t\t\tpanic(\"HPFS panic\");\n\t\t} else if (hpfs_sb(s)->sb_err == 1) {\n\t\t\tif (s->s_flags & MS_RDONLY)\n\t\t\t\tpr_cont(\"; already mounted read-only\\n\");\n\t\t\telse {\n\t\t\t\tpr_cont(\"; remounting read-only\\n\");\n\t\t\t\tmark_dirty(s, 0);\n\t\t\t\ts->s_flags |= MS_RDONLY;\n\t\t\t}\n\t\t} else if (s->s_flags & MS_RDONLY)\n\t\t\t\tpr_cont(\"; going on - but anything won't be destroyed because it's read-only\\n\");\n\t\telse\n\t\t\tpr_cont(\"; corrupted filesystem mounted read/write - your computer will explode within 20 seconds ... but you wanted it so!\\n\");\n\t} else\n\t\tpr_cont(\"\\n\");\n\thpfs_sb(s)->sb_was_error = 1;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/sched.h>",
            "#include <linux/magic.h>",
            "#include <linux/statfs.h>",
            "#include <linux/init.h>",
            "#include <linux/parser.h>",
            "#include <linux/module.h>",
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static char err_buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/bitmap.h>\n#include <linux/sched.h>\n#include <linux/magic.h>\n#include <linux/statfs.h>\n#include <linux/init.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include \"hpfs_fn.h\"\n\nstatic char err_buf[1024];\n\nvoid hpfs_error(struct super_block *s, const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvsnprintf(err_buf, sizeof(err_buf), fmt, args);\n\tva_end(args);\n\n\tpr_err(\"filesystem error: %s\", err_buf);\n\tif (!hpfs_sb(s)->sb_was_error) {\n\t\tif (hpfs_sb(s)->sb_err == 2) {\n\t\t\tpr_cont(\"; crashing the system because you wanted it\\n\");\n\t\t\tmark_dirty(s, 0);\n\t\t\tpanic(\"HPFS panic\");\n\t\t} else if (hpfs_sb(s)->sb_err == 1) {\n\t\t\tif (s->s_flags & MS_RDONLY)\n\t\t\t\tpr_cont(\"; already mounted read-only\\n\");\n\t\t\telse {\n\t\t\t\tpr_cont(\"; remounting read-only\\n\");\n\t\t\t\tmark_dirty(s, 0);\n\t\t\t\ts->s_flags |= MS_RDONLY;\n\t\t\t}\n\t\t} else if (s->s_flags & MS_RDONLY)\n\t\t\t\tpr_cont(\"; going on - but anything won't be destroyed because it's read-only\\n\");\n\t\telse\n\t\t\tpr_cont(\"; corrupted filesystem mounted read/write - your computer will explode within 20 seconds ... but you wanted it so!\\n\");\n\t} else\n\t\tpr_cont(\"\\n\");\n\thpfs_sb(s)->sb_was_error = 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "le16_to_cpu(de->length)",
            "GFP_NOFS"
          ],
          "line": 493
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_all_poss",
          "args": [
            "i",
            "hpfs_pos_subst",
            "t + 1",
            "5"
          ],
          "line": 492
        },
        "resolved": true,
        "details": {
          "function_name": "for_all_poss",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/dnode.c",
          "lines": "71-80",
          "snippet": "static void for_all_poss(struct inode *inode, void (*f)(loff_t *, loff_t, loff_t),\n\t\t\t loff_t p1, loff_t p2)\n{\n\tstruct hpfs_inode_info *hpfs_inode = hpfs_i(inode);\n\tloff_t **i;\n\n\tif (!hpfs_inode->i_rddir_off) return;\n\tfor (i = hpfs_inode->i_rddir_off; *i; i++) (*f)(*i, p1, p2);\n\treturn;\n}",
          "includes": [
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n\nstatic void for_all_poss(struct inode *inode, void (*f)(loff_t *, loff_t, loff_t),\n\t\t\t loff_t p1, loff_t p2)\n{\n\tstruct hpfs_inode_info *hpfs_inode = hpfs_i(inode);\n\tloff_t **i;\n\n\tif (!hpfs_inode->i_rddir_off) return;\n\tfor (i = hpfs_inode->i_rddir_off; *i; i++) (*f)(*i, p1, p2);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_pos",
          "args": [
            "dnode",
            "de"
          ],
          "line": 490
        },
        "resolved": true,
        "details": {
          "function_name": "get_pos",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/dnode.c",
          "lines": "11-22",
          "snippet": "static loff_t get_pos(struct dnode *d, struct hpfs_dirent *fde)\n{\n\tstruct hpfs_dirent *de;\n\tstruct hpfs_dirent *de_end = dnode_end_de(d);\n\tint i = 1;\n\tfor (de = dnode_first_de(d); de < de_end; de = de_next_de(de)) {\n\t\tif (de == fde) return ((loff_t) le32_to_cpu(d->self) << 4) | (loff_t)i;\n\t\ti++;\n\t}\n\tpr_info(\"%s(): not_found\\n\", __func__);\n\treturn ((loff_t)le32_to_cpu(d->self) << 4) | (loff_t)1;\n}",
          "includes": [
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n\nstatic loff_t get_pos(struct dnode *d, struct hpfs_dirent *fde)\n{\n\tstruct hpfs_dirent *de;\n\tstruct hpfs_dirent *de_end = dnode_end_de(d);\n\tint i = 1;\n\tfor (de = dnode_first_de(d); de < de_end; de = de_next_de(de)) {\n\t\tif (de == fde) return ((loff_t) le32_to_cpu(d->self) << 4) | (loff_t)i;\n\t\ti++;\n\t}\n\tpr_info(\"%s(): not_found\\n\", __func__);\n\treturn ((loff_t)le32_to_cpu(d->self) << 4) | (loff_t)1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_add_cpu",
          "args": [
            "&de->length",
            "-4"
          ],
          "line": 485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_add_cpu",
          "args": [
            "&dnode->first_free",
            "-4"
          ],
          "line": 484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dnode_last_de",
          "args": [
            "dnode"
          ],
          "line": 478
        },
        "resolved": true,
        "details": {
          "function_name": "dnode_last_de",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/dnode.c",
          "lines": "126-134",
          "snippet": "static struct hpfs_dirent *dnode_last_de(struct dnode *d)\n{\n\tstruct hpfs_dirent *de, *de_end, *dee = NULL;\n\tde_end = dnode_end_de(d);\n\tfor (de = dnode_first_de(d); de < de_end; de = de_next_de(de)) {\n\t\tdee = de;\n\t}\t\n\treturn dee;\n}",
          "includes": [
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n\nstatic struct hpfs_dirent *dnode_last_de(struct dnode *d)\n{\n\tstruct hpfs_dirent *de, *de_end, *dee = NULL;\n\tde_end = dnode_end_de(d);\n\tfor (de = dnode_first_de(d); de < de_end; de = de_next_de(de)) {\n\t\tdee = de;\n\t}\t\n\treturn dee;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_map_dnode",
          "args": [
            "i->i_sb",
            "up",
            "&qbh"
          ],
          "line": 472
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_map_dnode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/map.c",
          "lines": "229-293",
          "snippet": "struct dnode *hpfs_map_dnode(struct super_block *s, unsigned secno,\n\t\t\t     struct quad_buffer_head *qbh)\n{\n\tstruct dnode *dnode;\n\tif (hpfs_sb(s)->sb_chk) {\n\t\tif (hpfs_chk_sectors(s, secno, 4, \"dnode\")) return NULL;\n\t\tif (secno & 3) {\n\t\t\thpfs_error(s, \"dnode %08x not byte-aligned\", secno);\n\t\t\treturn NULL;\n\t\t}\t\n\t}\n\tif ((dnode = hpfs_map_4sectors(s, secno, qbh, DNODE_RD_AHEAD)))\n\t\tif (hpfs_sb(s)->sb_chk) {\n\t\t\tunsigned p, pp = 0;\n\t\t\tunsigned char *d = (unsigned char *)dnode;\n\t\t\tint b = 0;\n\t\t\tif (le32_to_cpu(dnode->magic) != DNODE_MAGIC) {\n\t\t\t\thpfs_error(s, \"bad magic on dnode %08x\", secno);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tif (le32_to_cpu(dnode->self) != secno)\n\t\t\t\thpfs_error(s, \"bad self pointer on dnode %08x self = %08x\", secno, le32_to_cpu(dnode->self));\n\t\t\t/* Check dirents - bad dirents would cause infinite\n\t\t\t   loops or shooting to memory */\n\t\t\tif (le32_to_cpu(dnode->first_free) > 2048) {\n\t\t\t\thpfs_error(s, \"dnode %08x has first_free == %08x\", secno, le32_to_cpu(dnode->first_free));\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tfor (p = 20; p < le32_to_cpu(dnode->first_free); p += d[p] + (d[p+1] << 8)) {\n\t\t\t\tstruct hpfs_dirent *de = (struct hpfs_dirent *)((char *)dnode + p);\n\t\t\t\tif (le16_to_cpu(de->length) > 292 || (le16_to_cpu(de->length) < 32) || (le16_to_cpu(de->length) & 3) || p + le16_to_cpu(de->length) > 2048) {\n\t\t\t\t\thpfs_error(s, \"bad dirent size in dnode %08x, dirent %03x, last %03x\", secno, p, pp);\n\t\t\t\t\tgoto bail;\n\t\t\t\t}\n\t\t\t\tif (((31 + de->namelen + de->down*4 + 3) & ~3) != le16_to_cpu(de->length)) {\n\t\t\t\t\tif (((31 + de->namelen + de->down*4 + 3) & ~3) < le16_to_cpu(de->length) && s->s_flags & MS_RDONLY) goto ok;\n\t\t\t\t\thpfs_error(s, \"namelen does not match dirent size in dnode %08x, dirent %03x, last %03x\", secno, p, pp);\n\t\t\t\t\tgoto bail;\n\t\t\t\t}\n\t\t\t\tok:\n\t\t\t\tif (hpfs_sb(s)->sb_chk >= 2) b |= 1 << de->down;\n\t\t\t\tif (de->down) if (de_down_pointer(de) < 0x10) {\n\t\t\t\t\thpfs_error(s, \"bad down pointer in dnode %08x, dirent %03x, last %03x\", secno, p, pp);\n\t\t\t\t\tgoto bail;\n\t\t\t\t}\n\t\t\t\tpp = p;\n\t\t\t\t\n\t\t\t}\n\t\t\tif (p != le32_to_cpu(dnode->first_free)) {\n\t\t\t\thpfs_error(s, \"size on last dirent does not match first_free; dnode %08x\", secno);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tif (d[pp + 30] != 1 || d[pp + 31] != 255) {\n\t\t\t\thpfs_error(s, \"dnode %08x does not end with \\\\377 entry\", secno);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tif (b == 3)\n\t\t\t\tpr_err(\"unbalanced dnode tree, dnode %08x; see hpfs.txt 4 more info\\n\",\n\t\t\t\t\tsecno);\n\t\t}\n\treturn dnode;\n\tbail:\n\thpfs_brelse4(qbh);\n\treturn NULL;\n}",
          "includes": [
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n\nstruct dnode *hpfs_map_dnode(struct super_block *s, unsigned secno,\n\t\t\t     struct quad_buffer_head *qbh)\n{\n\tstruct dnode *dnode;\n\tif (hpfs_sb(s)->sb_chk) {\n\t\tif (hpfs_chk_sectors(s, secno, 4, \"dnode\")) return NULL;\n\t\tif (secno & 3) {\n\t\t\thpfs_error(s, \"dnode %08x not byte-aligned\", secno);\n\t\t\treturn NULL;\n\t\t}\t\n\t}\n\tif ((dnode = hpfs_map_4sectors(s, secno, qbh, DNODE_RD_AHEAD)))\n\t\tif (hpfs_sb(s)->sb_chk) {\n\t\t\tunsigned p, pp = 0;\n\t\t\tunsigned char *d = (unsigned char *)dnode;\n\t\t\tint b = 0;\n\t\t\tif (le32_to_cpu(dnode->magic) != DNODE_MAGIC) {\n\t\t\t\thpfs_error(s, \"bad magic on dnode %08x\", secno);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tif (le32_to_cpu(dnode->self) != secno)\n\t\t\t\thpfs_error(s, \"bad self pointer on dnode %08x self = %08x\", secno, le32_to_cpu(dnode->self));\n\t\t\t/* Check dirents - bad dirents would cause infinite\n\t\t\t   loops or shooting to memory */\n\t\t\tif (le32_to_cpu(dnode->first_free) > 2048) {\n\t\t\t\thpfs_error(s, \"dnode %08x has first_free == %08x\", secno, le32_to_cpu(dnode->first_free));\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tfor (p = 20; p < le32_to_cpu(dnode->first_free); p += d[p] + (d[p+1] << 8)) {\n\t\t\t\tstruct hpfs_dirent *de = (struct hpfs_dirent *)((char *)dnode + p);\n\t\t\t\tif (le16_to_cpu(de->length) > 292 || (le16_to_cpu(de->length) < 32) || (le16_to_cpu(de->length) & 3) || p + le16_to_cpu(de->length) > 2048) {\n\t\t\t\t\thpfs_error(s, \"bad dirent size in dnode %08x, dirent %03x, last %03x\", secno, p, pp);\n\t\t\t\t\tgoto bail;\n\t\t\t\t}\n\t\t\t\tif (((31 + de->namelen + de->down*4 + 3) & ~3) != le16_to_cpu(de->length)) {\n\t\t\t\t\tif (((31 + de->namelen + de->down*4 + 3) & ~3) < le16_to_cpu(de->length) && s->s_flags & MS_RDONLY) goto ok;\n\t\t\t\t\thpfs_error(s, \"namelen does not match dirent size in dnode %08x, dirent %03x, last %03x\", secno, p, pp);\n\t\t\t\t\tgoto bail;\n\t\t\t\t}\n\t\t\t\tok:\n\t\t\t\tif (hpfs_sb(s)->sb_chk >= 2) b |= 1 << de->down;\n\t\t\t\tif (de->down) if (de_down_pointer(de) < 0x10) {\n\t\t\t\t\thpfs_error(s, \"bad down pointer in dnode %08x, dirent %03x, last %03x\", secno, p, pp);\n\t\t\t\t\tgoto bail;\n\t\t\t\t}\n\t\t\t\tpp = p;\n\t\t\t\t\n\t\t\t}\n\t\t\tif (p != le32_to_cpu(dnode->first_free)) {\n\t\t\t\thpfs_error(s, \"size on last dirent does not match first_free; dnode %08x\", secno);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tif (d[pp + 30] != 1 || d[pp + 31] != 255) {\n\t\t\t\thpfs_error(s, \"dnode %08x does not end with \\\\377 entry\", secno);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tif (b == 3)\n\t\t\t\tpr_err(\"unbalanced dnode tree, dnode %08x; see hpfs.txt 4 more info\\n\",\n\t\t\t\t\tsecno);\n\t\t}\n\treturn dnode;\n\tbail:\n\thpfs_brelse4(qbh);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_free_dnode",
          "args": [
            "i->i_sb",
            "dno"
          ],
          "line": 467
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_free_dnode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/alloc.c",
          "lines": "404-425",
          "snippet": "void hpfs_free_dnode(struct super_block *s, dnode_secno dno)\n{\n\tif (hpfs_sb(s)->sb_chk) if (dno & 3) {\n\t\thpfs_error(s, \"hpfs_free_dnode: dnode %08x not aligned\", dno);\n\t\treturn;\n\t}\n\tif (dno < hpfs_sb(s)->sb_dirband_start ||\n\t    dno >= hpfs_sb(s)->sb_dirband_start + hpfs_sb(s)->sb_dirband_size) {\n\t\thpfs_free_sectors(s, dno, 4);\n\t} else {\n\t\tstruct quad_buffer_head qbh;\n\t\t__le32 *bmp;\n\t\tunsigned ssec = (dno - hpfs_sb(s)->sb_dirband_start) / 4;\n\t\tif (!(bmp = hpfs_map_dnode_bitmap(s, &qbh))) {\n\t\t\treturn;\n\t\t}\n\t\tbmp[ssec >> 5] |= cpu_to_le32(1 << (ssec & 0x1f));\n\t\thpfs_mark_4buffers_dirty(&qbh);\n\t\thpfs_brelse4(&qbh);\n\t\thpfs_claim_dirband_free(s, dno);\n\t}\n}",
          "includes": [
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n\nvoid hpfs_free_dnode(struct super_block *s, dnode_secno dno)\n{\n\tif (hpfs_sb(s)->sb_chk) if (dno & 3) {\n\t\thpfs_error(s, \"hpfs_free_dnode: dnode %08x not aligned\", dno);\n\t\treturn;\n\t}\n\tif (dno < hpfs_sb(s)->sb_dirband_start ||\n\t    dno >= hpfs_sb(s)->sb_dirband_start + hpfs_sb(s)->sb_dirband_size) {\n\t\thpfs_free_sectors(s, dno, 4);\n\t} else {\n\t\tstruct quad_buffer_head qbh;\n\t\t__le32 *bmp;\n\t\tunsigned ssec = (dno - hpfs_sb(s)->sb_dirband_start) / 4;\n\t\tif (!(bmp = hpfs_map_dnode_bitmap(s, &qbh))) {\n\t\t\treturn;\n\t\t}\n\t\tbmp[ssec >> 5] |= cpu_to_le32(1 << (ssec & 0x1f));\n\t\thpfs_mark_4buffers_dirty(&qbh);\n\t\thpfs_brelse4(&qbh);\n\t\thpfs_claim_dirband_free(s, dno);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "dnode->up"
          ],
          "line": 465
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dnode_pre_last_de",
          "args": [
            "dnode"
          ],
          "line": 464
        },
        "resolved": true,
        "details": {
          "function_name": "dnode_pre_last_de",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/dnode.c",
          "lines": "116-124",
          "snippet": "static struct hpfs_dirent *dnode_pre_last_de(struct dnode *d)\n{\n\tstruct hpfs_dirent *de, *de_end, *dee = NULL, *deee = NULL;\n\tde_end = dnode_end_de(d);\n\tfor (de = dnode_first_de(d); de < de_end; de = de_next_de(de)) {\n\t\tdeee = dee; dee = de;\n\t}\t\n\treturn deee;\n}",
          "includes": [
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n\nstatic struct hpfs_dirent *dnode_pre_last_de(struct dnode *d)\n{\n\tstruct hpfs_dirent *de, *de_end, *dee = NULL, *deee = NULL;\n\tde_end = dnode_end_de(d);\n\tfor (de = dnode_first_de(d); de < de_end; de = de_next_de(de)) {\n\t\tdeee = dee; dee = de;\n\t}\t\n\treturn deee;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_sb",
          "args": [
            "i->i_sb"
          ],
          "line": 446
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_sb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "310-313",
          "snippet": "static inline struct hpfs_sb_info *hpfs_sb(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_check_free_dnodes(struct super_block *, int);",
            "void hpfs_prefetch_sectors(struct super_block *, unsigned, int);",
            "void hpfs_prefetch_bitmap(struct super_block *, unsigned);",
            "unsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);",
            "int hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);",
            "void hpfs_error(struct super_block *, const char *, ...);",
            "int hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);",
            "unsigned hpfs_get_free_dnodes(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_check_free_dnodes(struct super_block *, int);\nvoid hpfs_prefetch_sectors(struct super_block *, unsigned, int);\nvoid hpfs_prefetch_bitmap(struct super_block *, unsigned);\nunsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);\nint hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);\nvoid hpfs_error(struct super_block *, const char *, ...);\nint hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);\nunsigned hpfs_get_free_dnodes(struct super_block *);\n\nstatic inline struct hpfs_sb_info *hpfs_sb(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_stop_cycles",
          "args": [
            "i->i_sb",
            "dno",
            "&c1",
            "&c2",
            "\"move_to_top\""
          ],
          "line": 443
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_stop_cycles",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/super.c",
          "lines": "96-106",
          "snippet": "int hpfs_stop_cycles(struct super_block *s, int key, int *c1, int *c2,\n\t\tchar *msg)\n{\n\tif (*c2 && *c1 == key) {\n\t\thpfs_error(s, \"cycle detected on key %08x in %s\", key, msg);\n\t\treturn 1;\n\t}\n\t(*c2)++;\n\tif (!((*c2 - 1) & *c2)) *c1 = key;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/sched.h>",
            "#include <linux/magic.h>",
            "#include <linux/statfs.h>",
            "#include <linux/init.h>",
            "#include <linux/parser.h>",
            "#include <linux/module.h>",
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/bitmap.h>\n#include <linux/sched.h>\n#include <linux/magic.h>\n#include <linux/statfs.h>\n#include <linux/init.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include \"hpfs_fn.h\"\n\nint hpfs_stop_cycles(struct super_block *s, int key, int *c1, int *c2,\n\t\tchar *msg)\n{\n\tif (*c2 && *c1 == key) {\n\t\thpfs_error(s, \"cycle detected on key %08x in %s\", key, msg);\n\t\treturn 1;\n\t}\n\t(*c2)++;\n\tif (!((*c2 - 1) & *c2)) *c1 = key;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hpfs_fn.h\"\n\nstatic secno move_to_top(struct inode *i, dnode_secno from, dnode_secno to)\n{\n\tdnode_secno dno, ddno;\n\tdnode_secno chk_up = to;\n\tstruct dnode *dnode;\n\tstruct quad_buffer_head qbh;\n\tstruct hpfs_dirent *de, *nde;\n\tint a;\n\tloff_t t;\n\tint c1, c2 = 0;\n\tdno = from;\n\twhile (1) {\n\t\tif (hpfs_sb(i->i_sb)->sb_chk)\n\t\t\tif (hpfs_stop_cycles(i->i_sb, dno, &c1, &c2, \"move_to_top\"))\n\t\t\t\treturn 0;\n\t\tif (!(dnode = hpfs_map_dnode(i->i_sb, dno, &qbh))) return 0;\n\t\tif (hpfs_sb(i->i_sb)->sb_chk) {\n\t\t\tif (le32_to_cpu(dnode->up) != chk_up) {\n\t\t\t\thpfs_error(i->i_sb, \"move_to_top: up pointer from %08x should be %08x, is %08x\",\n\t\t\t\t\tdno, chk_up, le32_to_cpu(dnode->up));\n\t\t\t\thpfs_brelse4(&qbh);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tchk_up = dno;\n\t\t}\n\t\tif (!(de = dnode_last_de(dnode))) {\n\t\t\thpfs_error(i->i_sb, \"move_to_top: dnode %08x has no last de\", dno);\n\t\t\thpfs_brelse4(&qbh);\n\t\t\treturn 0;\n\t\t}\n\t\tif (!de->down) break;\n\t\tdno = de_down_pointer(de);\n\t\thpfs_brelse4(&qbh);\n\t}\n\twhile (!(de = dnode_pre_last_de(dnode))) {\n\t\tdnode_secno up = le32_to_cpu(dnode->up);\n\t\thpfs_brelse4(&qbh);\n\t\thpfs_free_dnode(i->i_sb, dno);\n\t\ti->i_size -= 2048;\n\t\ti->i_blocks -= 4;\n\t\tfor_all_poss(i, hpfs_pos_subst, ((loff_t)dno << 4) | 1, 5);\n\t\tif (up == to) return to;\n\t\tif (!(dnode = hpfs_map_dnode(i->i_sb, up, &qbh))) return 0;\n\t\tif (dnode->root_dnode) {\n\t\t\thpfs_error(i->i_sb, \"move_to_top: got to root_dnode while moving from %08x to %08x\", from, to);\n\t\t\thpfs_brelse4(&qbh);\n\t\t\treturn 0;\n\t\t}\n\t\tde = dnode_last_de(dnode);\n\t\tif (!de || !de->down) {\n\t\t\thpfs_error(i->i_sb, \"move_to_top: dnode %08x doesn't point down to %08x\", up, dno);\n\t\t\thpfs_brelse4(&qbh);\n\t\t\treturn 0;\n\t\t}\n\t\tle32_add_cpu(&dnode->first_free, -4);\n\t\tle16_add_cpu(&de->length, -4);\n\t\tde->down = 0;\n\t\thpfs_mark_4buffers_dirty(&qbh);\n\t\tdno = up;\n\t}\n\tt = get_pos(dnode, de);\n\tfor_all_poss(i, hpfs_pos_subst, t, 4);\n\tfor_all_poss(i, hpfs_pos_subst, t + 1, 5);\n\tif (!(nde = kmalloc(le16_to_cpu(de->length), GFP_NOFS))) {\n\t\thpfs_error(i->i_sb, \"out of memory for dirent - directory will be corrupted\");\n\t\thpfs_brelse4(&qbh);\n\t\treturn 0;\n\t}\n\tmemcpy(nde, de, le16_to_cpu(de->length));\n\tddno = de->down ? de_down_pointer(de) : 0;\n\thpfs_delete_de(i->i_sb, dnode, de);\n\tset_last_pointer(i->i_sb, dnode, ddno);\n\thpfs_mark_4buffers_dirty(&qbh);\n\thpfs_brelse4(&qbh);\n\ta = hpfs_add_to_dnode(i, to, nde->name, nde->namelen, nde, from);\n\tkfree(nde);\n\tif (a) return 0;\n\treturn dno;\n}"
  },
  {
    "function_name": "hpfs_add_dirent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/dnode.c",
    "lines": "383-423",
    "snippet": "int hpfs_add_dirent(struct inode *i,\n\t\t    const unsigned char *name, unsigned namelen,\n\t\t    struct hpfs_dirent *new_de)\n{\n\tstruct hpfs_inode_info *hpfs_inode = hpfs_i(i);\n\tstruct dnode *d;\n\tstruct hpfs_dirent *de, *de_end;\n\tstruct quad_buffer_head qbh;\n\tdnode_secno dno;\n\tint c;\n\tint c1, c2 = 0;\n\tdno = hpfs_inode->i_dno;\n\tdown:\n\tif (hpfs_sb(i->i_sb)->sb_chk)\n\t\tif (hpfs_stop_cycles(i->i_sb, dno, &c1, &c2, \"hpfs_add_dirent\")) return 1;\n\tif (!(d = hpfs_map_dnode(i->i_sb, dno, &qbh))) return 1;\n\tde_end = dnode_end_de(d);\n\tfor (de = dnode_first_de(d); de < de_end; de = de_next_de(de)) {\n\t\tif (!(c = hpfs_compare_names(i->i_sb, name, namelen, de->name, de->namelen, de->last))) {\n\t\t\thpfs_brelse4(&qbh);\n\t\t\treturn -1;\n\t\t}\t\n\t\tif (c < 0) {\n\t\t\tif (de->down) {\n\t\t\t\tdno = de_down_pointer(de);\n\t\t\t\thpfs_brelse4(&qbh);\n\t\t\t\tgoto down;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\thpfs_brelse4(&qbh);\n\tif (hpfs_check_free_dnodes(i->i_sb, FREE_DNODES_ADD)) {\n\t\tc = 1;\n\t\tgoto ret;\n\t}\t\n\ti->i_version++;\n\tc = hpfs_add_to_dnode(i, dno, name, namelen, new_de, 0);\n\tret:\n\treturn c;\n}",
    "includes": [
      "#include \"hpfs_fn.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hpfs_add_to_dnode",
          "args": [
            "i",
            "dno",
            "name",
            "namelen",
            "new_de",
            "0"
          ],
          "line": 420
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_add_to_dnode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/dnode.c",
          "lines": "233-373",
          "snippet": "static int hpfs_add_to_dnode(struct inode *i, dnode_secno dno,\n\t\t\t     const unsigned char *name, unsigned namelen,\n\t\t\t     struct hpfs_dirent *new_de, dnode_secno down_ptr)\n{\n\tstruct quad_buffer_head qbh, qbh1, qbh2;\n\tstruct dnode *d, *ad, *rd, *nd = NULL;\n\tdnode_secno adno, rdno;\n\tstruct hpfs_dirent *de;\n\tstruct hpfs_dirent nde;\n\tunsigned char *nname;\n\tint h;\n\tint pos;\n\tstruct buffer_head *bh;\n\tstruct fnode *fnode;\n\tint c1, c2 = 0;\n\tif (!(nname = kmalloc(256, GFP_NOFS))) {\n\t\tpr_err(\"out of memory, can't add to dnode\\n\");\n\t\treturn 1;\n\t}\n\tgo_up:\n\tif (namelen >= 256) {\n\t\thpfs_error(i->i_sb, \"%s(): namelen == %d\", __func__, namelen);\n\t\tkfree(nd);\n\t\tkfree(nname);\n\t\treturn 1;\n\t}\n\tif (!(d = hpfs_map_dnode(i->i_sb, dno, &qbh))) {\n\t\tkfree(nd);\n\t\tkfree(nname);\n\t\treturn 1;\n\t}\n\tgo_up_a:\n\tif (hpfs_sb(i->i_sb)->sb_chk)\n\t\tif (hpfs_stop_cycles(i->i_sb, dno, &c1, &c2, \"hpfs_add_to_dnode\")) {\n\t\t\thpfs_brelse4(&qbh);\n\t\t\tkfree(nd);\n\t\t\tkfree(nname);\n\t\t\treturn 1;\n\t\t}\n\tif (le32_to_cpu(d->first_free) + de_size(namelen, down_ptr) <= 2048) {\n\t\tloff_t t;\n\t\tcopy_de(de=hpfs_add_de(i->i_sb, d, name, namelen, down_ptr), new_de);\n\t\tt = get_pos(d, de);\n\t\tfor_all_poss(i, hpfs_pos_ins, t, 1);\n\t\tfor_all_poss(i, hpfs_pos_subst, 4, t);\n\t\tfor_all_poss(i, hpfs_pos_subst, 5, t + 1);\n\t\thpfs_mark_4buffers_dirty(&qbh);\n\t\thpfs_brelse4(&qbh);\n\t\tkfree(nd);\n\t\tkfree(nname);\n\t\treturn 0;\n\t}\n\tif (!nd) if (!(nd = kmalloc(0x924, GFP_NOFS))) {\n\t\t/* 0x924 is a max size of dnode after adding a dirent with\n\t\t   max name length. We alloc this only once. There must\n\t\t   not be any error while splitting dnodes, otherwise the\n\t\t   whole directory, not only file we're adding, would\n\t\t   be lost. */\n\t\tpr_err(\"out of memory for dnode splitting\\n\");\n\t\thpfs_brelse4(&qbh);\n\t\tkfree(nname);\n\t\treturn 1;\n\t}\t\n\tmemcpy(nd, d, le32_to_cpu(d->first_free));\n\tcopy_de(de = hpfs_add_de(i->i_sb, nd, name, namelen, down_ptr), new_de);\n\tfor_all_poss(i, hpfs_pos_ins, get_pos(nd, de), 1);\n\th = ((char *)dnode_last_de(nd) - (char *)nd) / 2 + 10;\n\tif (!(ad = hpfs_alloc_dnode(i->i_sb, le32_to_cpu(d->up), &adno, &qbh1))) {\n\t\thpfs_error(i->i_sb, \"unable to alloc dnode - dnode tree will be corrupted\");\n\t\thpfs_brelse4(&qbh);\n\t\tkfree(nd);\n\t\tkfree(nname);\n\t\treturn 1;\n\t}\n\ti->i_size += 2048;\n\ti->i_blocks += 4;\n\tpos = 1;\n\tfor (de = dnode_first_de(nd); (char *)de_next_de(de) - (char *)nd < h; de = de_next_de(de)) {\n\t\tcopy_de(hpfs_add_de(i->i_sb, ad, de->name, de->namelen, de->down ? de_down_pointer(de) : 0), de);\n\t\tfor_all_poss(i, hpfs_pos_subst, ((loff_t)dno << 4) | pos, ((loff_t)adno << 4) | pos);\n\t\tpos++;\n\t}\n\tcopy_de(new_de = &nde, de);\n\tmemcpy(nname, de->name, de->namelen);\n\tname = nname;\n\tnamelen = de->namelen;\n\tfor_all_poss(i, hpfs_pos_subst, ((loff_t)dno << 4) | pos, 4);\n\tdown_ptr = adno;\n\tset_last_pointer(i->i_sb, ad, de->down ? de_down_pointer(de) : 0);\n\tde = de_next_de(de);\n\tmemmove((char *)nd + 20, de, le32_to_cpu(nd->first_free) + (char *)nd - (char *)de);\n\tle32_add_cpu(&nd->first_free, -((char *)de - (char *)nd - 20));\n\tmemcpy(d, nd, le32_to_cpu(nd->first_free));\n\tfor_all_poss(i, hpfs_pos_del, (loff_t)dno << 4, pos);\n\tfix_up_ptrs(i->i_sb, ad);\n\tif (!d->root_dnode) {\n\t\tad->up = d->up;\n\t\tdno = le32_to_cpu(ad->up);\n\t\thpfs_mark_4buffers_dirty(&qbh);\n\t\thpfs_brelse4(&qbh);\n\t\thpfs_mark_4buffers_dirty(&qbh1);\n\t\thpfs_brelse4(&qbh1);\n\t\tgoto go_up;\n\t}\n\tif (!(rd = hpfs_alloc_dnode(i->i_sb, le32_to_cpu(d->up), &rdno, &qbh2))) {\n\t\thpfs_error(i->i_sb, \"unable to alloc dnode - dnode tree will be corrupted\");\n\t\thpfs_brelse4(&qbh);\n\t\thpfs_brelse4(&qbh1);\n\t\tkfree(nd);\n\t\tkfree(nname);\n\t\treturn 1;\n\t}\n\ti->i_size += 2048;\n\ti->i_blocks += 4;\n\trd->root_dnode = 1;\n\trd->up = d->up;\n\tif (!(fnode = hpfs_map_fnode(i->i_sb, le32_to_cpu(d->up), &bh))) {\n\t\thpfs_free_dnode(i->i_sb, rdno);\n\t\thpfs_brelse4(&qbh);\n\t\thpfs_brelse4(&qbh1);\n\t\thpfs_brelse4(&qbh2);\n\t\tkfree(nd);\n\t\tkfree(nname);\n\t\treturn 1;\n\t}\n\tfnode->u.external[0].disk_secno = cpu_to_le32(rdno);\n\tmark_buffer_dirty(bh);\n\tbrelse(bh);\n\thpfs_i(i)->i_dno = rdno;\n\td->up = ad->up = cpu_to_le32(rdno);\n\td->root_dnode = ad->root_dnode = 0;\n\thpfs_mark_4buffers_dirty(&qbh);\n\thpfs_brelse4(&qbh);\n\thpfs_mark_4buffers_dirty(&qbh1);\n\thpfs_brelse4(&qbh1);\n\tqbh = qbh2;\n\tset_last_pointer(i->i_sb, rd, dno);\n\tdno = rdno;\n\td = rd;\n\tgoto go_up_a;\n}",
          "includes": [
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n\nstatic int hpfs_add_to_dnode(struct inode *i, dnode_secno dno,\n\t\t\t     const unsigned char *name, unsigned namelen,\n\t\t\t     struct hpfs_dirent *new_de, dnode_secno down_ptr)\n{\n\tstruct quad_buffer_head qbh, qbh1, qbh2;\n\tstruct dnode *d, *ad, *rd, *nd = NULL;\n\tdnode_secno adno, rdno;\n\tstruct hpfs_dirent *de;\n\tstruct hpfs_dirent nde;\n\tunsigned char *nname;\n\tint h;\n\tint pos;\n\tstruct buffer_head *bh;\n\tstruct fnode *fnode;\n\tint c1, c2 = 0;\n\tif (!(nname = kmalloc(256, GFP_NOFS))) {\n\t\tpr_err(\"out of memory, can't add to dnode\\n\");\n\t\treturn 1;\n\t}\n\tgo_up:\n\tif (namelen >= 256) {\n\t\thpfs_error(i->i_sb, \"%s(): namelen == %d\", __func__, namelen);\n\t\tkfree(nd);\n\t\tkfree(nname);\n\t\treturn 1;\n\t}\n\tif (!(d = hpfs_map_dnode(i->i_sb, dno, &qbh))) {\n\t\tkfree(nd);\n\t\tkfree(nname);\n\t\treturn 1;\n\t}\n\tgo_up_a:\n\tif (hpfs_sb(i->i_sb)->sb_chk)\n\t\tif (hpfs_stop_cycles(i->i_sb, dno, &c1, &c2, \"hpfs_add_to_dnode\")) {\n\t\t\thpfs_brelse4(&qbh);\n\t\t\tkfree(nd);\n\t\t\tkfree(nname);\n\t\t\treturn 1;\n\t\t}\n\tif (le32_to_cpu(d->first_free) + de_size(namelen, down_ptr) <= 2048) {\n\t\tloff_t t;\n\t\tcopy_de(de=hpfs_add_de(i->i_sb, d, name, namelen, down_ptr), new_de);\n\t\tt = get_pos(d, de);\n\t\tfor_all_poss(i, hpfs_pos_ins, t, 1);\n\t\tfor_all_poss(i, hpfs_pos_subst, 4, t);\n\t\tfor_all_poss(i, hpfs_pos_subst, 5, t + 1);\n\t\thpfs_mark_4buffers_dirty(&qbh);\n\t\thpfs_brelse4(&qbh);\n\t\tkfree(nd);\n\t\tkfree(nname);\n\t\treturn 0;\n\t}\n\tif (!nd) if (!(nd = kmalloc(0x924, GFP_NOFS))) {\n\t\t/* 0x924 is a max size of dnode after adding a dirent with\n\t\t   max name length. We alloc this only once. There must\n\t\t   not be any error while splitting dnodes, otherwise the\n\t\t   whole directory, not only file we're adding, would\n\t\t   be lost. */\n\t\tpr_err(\"out of memory for dnode splitting\\n\");\n\t\thpfs_brelse4(&qbh);\n\t\tkfree(nname);\n\t\treturn 1;\n\t}\t\n\tmemcpy(nd, d, le32_to_cpu(d->first_free));\n\tcopy_de(de = hpfs_add_de(i->i_sb, nd, name, namelen, down_ptr), new_de);\n\tfor_all_poss(i, hpfs_pos_ins, get_pos(nd, de), 1);\n\th = ((char *)dnode_last_de(nd) - (char *)nd) / 2 + 10;\n\tif (!(ad = hpfs_alloc_dnode(i->i_sb, le32_to_cpu(d->up), &adno, &qbh1))) {\n\t\thpfs_error(i->i_sb, \"unable to alloc dnode - dnode tree will be corrupted\");\n\t\thpfs_brelse4(&qbh);\n\t\tkfree(nd);\n\t\tkfree(nname);\n\t\treturn 1;\n\t}\n\ti->i_size += 2048;\n\ti->i_blocks += 4;\n\tpos = 1;\n\tfor (de = dnode_first_de(nd); (char *)de_next_de(de) - (char *)nd < h; de = de_next_de(de)) {\n\t\tcopy_de(hpfs_add_de(i->i_sb, ad, de->name, de->namelen, de->down ? de_down_pointer(de) : 0), de);\n\t\tfor_all_poss(i, hpfs_pos_subst, ((loff_t)dno << 4) | pos, ((loff_t)adno << 4) | pos);\n\t\tpos++;\n\t}\n\tcopy_de(new_de = &nde, de);\n\tmemcpy(nname, de->name, de->namelen);\n\tname = nname;\n\tnamelen = de->namelen;\n\tfor_all_poss(i, hpfs_pos_subst, ((loff_t)dno << 4) | pos, 4);\n\tdown_ptr = adno;\n\tset_last_pointer(i->i_sb, ad, de->down ? de_down_pointer(de) : 0);\n\tde = de_next_de(de);\n\tmemmove((char *)nd + 20, de, le32_to_cpu(nd->first_free) + (char *)nd - (char *)de);\n\tle32_add_cpu(&nd->first_free, -((char *)de - (char *)nd - 20));\n\tmemcpy(d, nd, le32_to_cpu(nd->first_free));\n\tfor_all_poss(i, hpfs_pos_del, (loff_t)dno << 4, pos);\n\tfix_up_ptrs(i->i_sb, ad);\n\tif (!d->root_dnode) {\n\t\tad->up = d->up;\n\t\tdno = le32_to_cpu(ad->up);\n\t\thpfs_mark_4buffers_dirty(&qbh);\n\t\thpfs_brelse4(&qbh);\n\t\thpfs_mark_4buffers_dirty(&qbh1);\n\t\thpfs_brelse4(&qbh1);\n\t\tgoto go_up;\n\t}\n\tif (!(rd = hpfs_alloc_dnode(i->i_sb, le32_to_cpu(d->up), &rdno, &qbh2))) {\n\t\thpfs_error(i->i_sb, \"unable to alloc dnode - dnode tree will be corrupted\");\n\t\thpfs_brelse4(&qbh);\n\t\thpfs_brelse4(&qbh1);\n\t\tkfree(nd);\n\t\tkfree(nname);\n\t\treturn 1;\n\t}\n\ti->i_size += 2048;\n\ti->i_blocks += 4;\n\trd->root_dnode = 1;\n\trd->up = d->up;\n\tif (!(fnode = hpfs_map_fnode(i->i_sb, le32_to_cpu(d->up), &bh))) {\n\t\thpfs_free_dnode(i->i_sb, rdno);\n\t\thpfs_brelse4(&qbh);\n\t\thpfs_brelse4(&qbh1);\n\t\thpfs_brelse4(&qbh2);\n\t\tkfree(nd);\n\t\tkfree(nname);\n\t\treturn 1;\n\t}\n\tfnode->u.external[0].disk_secno = cpu_to_le32(rdno);\n\tmark_buffer_dirty(bh);\n\tbrelse(bh);\n\thpfs_i(i)->i_dno = rdno;\n\td->up = ad->up = cpu_to_le32(rdno);\n\td->root_dnode = ad->root_dnode = 0;\n\thpfs_mark_4buffers_dirty(&qbh);\n\thpfs_brelse4(&qbh);\n\thpfs_mark_4buffers_dirty(&qbh1);\n\thpfs_brelse4(&qbh1);\n\tqbh = qbh2;\n\tset_last_pointer(i->i_sb, rd, dno);\n\tdno = rdno;\n\td = rd;\n\tgoto go_up_a;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_check_free_dnodes",
          "args": [
            "i->i_sb",
            "FREE_DNODES_ADD"
          ],
          "line": 415
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_check_free_dnodes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/alloc.c",
          "lines": "358-402",
          "snippet": "int hpfs_check_free_dnodes(struct super_block *s, int n)\n{\n\tint n_bmps = (hpfs_sb(s)->sb_fs_size + 0x4000 - 1) >> 14;\n\tint b = hpfs_sb(s)->sb_c_bitmap & 0x0fffffff;\n\tint i, j;\n\t__le32 *bmp;\n\tstruct quad_buffer_head qbh;\n\tif ((bmp = hpfs_map_dnode_bitmap(s, &qbh))) {\n\t\tfor (j = 0; j < 512; j++) {\n\t\t\tunsigned k;\n\t\t\tif (!le32_to_cpu(bmp[j])) continue;\n\t\t\tfor (k = le32_to_cpu(bmp[j]); k; k >>= 1) if (k & 1) if (!--n) {\n\t\t\t\thpfs_brelse4(&qbh);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\thpfs_brelse4(&qbh);\n\ti = 0;\n\tif (hpfs_sb(s)->sb_c_bitmap != -1) {\n\t\tbmp = hpfs_map_bitmap(s, b, &qbh, \"chkdn1\");\n\t\tgoto chk_bmp;\n\t}\n\tchk_next:\n\tif (i == b) i++;\n\tif (i >= n_bmps) return 1;\n\tbmp = hpfs_map_bitmap(s, i, &qbh, \"chkdn2\");\n\tchk_bmp:\n\tif (bmp) {\n\t\tfor (j = 0; j < 512; j++) {\n\t\t\tu32 k;\n\t\t\tif (!le32_to_cpu(bmp[j])) continue;\n\t\t\tfor (k = 0xf; k; k <<= 4)\n\t\t\t\tif ((le32_to_cpu(bmp[j]) & k) == k) {\n\t\t\t\t\tif (!--n) {\n\t\t\t\t\t\thpfs_brelse4(&qbh);\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t}\n\t\thpfs_brelse4(&qbh);\n\t}\n\ti++;\n\tgoto chk_next;\n}",
          "includes": [
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n\nint hpfs_check_free_dnodes(struct super_block *s, int n)\n{\n\tint n_bmps = (hpfs_sb(s)->sb_fs_size + 0x4000 - 1) >> 14;\n\tint b = hpfs_sb(s)->sb_c_bitmap & 0x0fffffff;\n\tint i, j;\n\t__le32 *bmp;\n\tstruct quad_buffer_head qbh;\n\tif ((bmp = hpfs_map_dnode_bitmap(s, &qbh))) {\n\t\tfor (j = 0; j < 512; j++) {\n\t\t\tunsigned k;\n\t\t\tif (!le32_to_cpu(bmp[j])) continue;\n\t\t\tfor (k = le32_to_cpu(bmp[j]); k; k >>= 1) if (k & 1) if (!--n) {\n\t\t\t\thpfs_brelse4(&qbh);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\thpfs_brelse4(&qbh);\n\ti = 0;\n\tif (hpfs_sb(s)->sb_c_bitmap != -1) {\n\t\tbmp = hpfs_map_bitmap(s, b, &qbh, \"chkdn1\");\n\t\tgoto chk_bmp;\n\t}\n\tchk_next:\n\tif (i == b) i++;\n\tif (i >= n_bmps) return 1;\n\tbmp = hpfs_map_bitmap(s, i, &qbh, \"chkdn2\");\n\tchk_bmp:\n\tif (bmp) {\n\t\tfor (j = 0; j < 512; j++) {\n\t\t\tu32 k;\n\t\t\tif (!le32_to_cpu(bmp[j])) continue;\n\t\t\tfor (k = 0xf; k; k <<= 4)\n\t\t\t\tif ((le32_to_cpu(bmp[j]) & k) == k) {\n\t\t\t\t\tif (!--n) {\n\t\t\t\t\t\thpfs_brelse4(&qbh);\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t}\n\t\thpfs_brelse4(&qbh);\n\t}\n\ti++;\n\tgoto chk_next;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_brelse4",
          "args": [
            "&qbh"
          ],
          "line": 414
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_brelse4",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/buffer.c",
          "lines": "182-190",
          "snippet": "void hpfs_brelse4(struct quad_buffer_head *qbh)\n{\n\tif (unlikely(qbh->data != qbh->bh[0]->b_data))\n\t\tkfree(qbh->data);\n\tbrelse(qbh->bh[0]);\n\tbrelse(qbh->bh[1]);\n\tbrelse(qbh->bh[2]);\n\tbrelse(qbh->bh[3]);\n}",
          "includes": [
            "#include \"hpfs_fn.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid hpfs_brelse4(struct quad_buffer_head *qbh)\n{\n\tif (unlikely(qbh->data != qbh->bh[0]->b_data))\n\t\tkfree(qbh->data);\n\tbrelse(qbh->bh[0]);\n\tbrelse(qbh->bh[1]);\n\tbrelse(qbh->bh[2]);\n\tbrelse(qbh->bh[3]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "de_down_pointer",
          "args": [
            "de"
          ],
          "line": 407
        },
        "resolved": true,
        "details": {
          "function_name": "de_down_pointer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "100-104",
          "snippet": "static inline dnode_secno de_down_pointer (struct hpfs_dirent *de)\n{\n  CHKCOND(de->down,(\"HPFS: de_down_pointer: !de->down\\n\"));\n  return le32_to_cpu(*(__le32 *) ((void *) de + le16_to_cpu(de->length) - 4));\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_add_dirent(struct inode *, const unsigned char *, unsigned,\n\t\t    struct hpfs_dirent *);",
            "void hpfs_count_dnodes(struct super_block *, dnode_secno, int *, int *, int *);",
            "void hpfs_remove_dtree(struct super_block *, dnode_secno);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_add_dirent(struct inode *, const unsigned char *, unsigned,\n\t\t    struct hpfs_dirent *);\nvoid hpfs_count_dnodes(struct super_block *, dnode_secno, int *, int *, int *);\nvoid hpfs_remove_dtree(struct super_block *, dnode_secno);\n\nstatic inline dnode_secno de_down_pointer (struct hpfs_dirent *de)\n{\n  CHKCOND(de->down,(\"HPFS: de_down_pointer: !de->down\\n\"));\n  return le32_to_cpu(*(__le32 *) ((void *) de + le16_to_cpu(de->length) - 4));\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_compare_names",
          "args": [
            "i->i_sb",
            "name",
            "namelen",
            "de->name",
            "de->namelen",
            "de->last"
          ],
          "line": 401
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_compare_names",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/name.c",
          "lines": "74-90",
          "snippet": "int hpfs_compare_names(struct super_block *s,\n\t\t       const unsigned char *n1, unsigned l1,\n\t\t       const unsigned char *n2, unsigned l2, int last)\n{\n\tunsigned l = l1 < l2 ? l1 : l2;\n\tunsigned i;\n\tif (last) return -1;\n\tfor (i = 0; i < l; i++) {\n\t\tunsigned char c1 = upcase(hpfs_sb(s)->sb_cp_table,n1[i]);\n\t\tunsigned char c2 = upcase(hpfs_sb(s)->sb_cp_table,n2[i]);\n\t\tif (c1 < c2) return -1;\n\t\tif (c1 > c2) return 1;\n\t}\n\tif (l1 < l2) return -1;\n\tif (l1 > l2) return 1;\n\treturn 0;\n}",
          "includes": [
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n\nint hpfs_compare_names(struct super_block *s,\n\t\t       const unsigned char *n1, unsigned l1,\n\t\t       const unsigned char *n2, unsigned l2, int last)\n{\n\tunsigned l = l1 < l2 ? l1 : l2;\n\tunsigned i;\n\tif (last) return -1;\n\tfor (i = 0; i < l; i++) {\n\t\tunsigned char c1 = upcase(hpfs_sb(s)->sb_cp_table,n1[i]);\n\t\tunsigned char c2 = upcase(hpfs_sb(s)->sb_cp_table,n2[i]);\n\t\tif (c1 < c2) return -1;\n\t\tif (c1 > c2) return 1;\n\t}\n\tif (l1 < l2) return -1;\n\tif (l1 > l2) return 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "de_next_de",
          "args": [
            "de"
          ],
          "line": 400
        },
        "resolved": true,
        "details": {
          "function_name": "de_next_de",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "123-127",
          "snippet": "static inline struct hpfs_dirent *de_next_de (struct hpfs_dirent *de)\n{\n  CHKCOND(le16_to_cpu(de->length)>=0x20 && le16_to_cpu(de->length)<0x800,(\"HPFS: de_next_de: de->length = %x\\n\",(unsigned)le16_to_cpu(de->length)));\n  return (void *) de + le16_to_cpu(de->length);\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_add_dirent(struct inode *, const unsigned char *, unsigned,\n\t\t    struct hpfs_dirent *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_add_dirent(struct inode *, const unsigned char *, unsigned,\n\t\t    struct hpfs_dirent *);\n\nstatic inline struct hpfs_dirent *de_next_de (struct hpfs_dirent *de)\n{\n  CHKCOND(le16_to_cpu(de->length)>=0x20 && le16_to_cpu(de->length)<0x800,(\"HPFS: de_next_de: de->length = %x\\n\",(unsigned)le16_to_cpu(de->length)));\n  return (void *) de + le16_to_cpu(de->length);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dnode_first_de",
          "args": [
            "d"
          ],
          "line": 400
        },
        "resolved": true,
        "details": {
          "function_name": "dnode_first_de",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "108-111",
          "snippet": "static inline struct hpfs_dirent *dnode_first_de (struct dnode *dnode)\n{\n  return (void *) dnode->dirent;\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_add_dirent(struct inode *, const unsigned char *, unsigned,\n\t\t    struct hpfs_dirent *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_add_dirent(struct inode *, const unsigned char *, unsigned,\n\t\t    struct hpfs_dirent *);\n\nstatic inline struct hpfs_dirent *dnode_first_de (struct dnode *dnode)\n{\n  return (void *) dnode->dirent;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dnode_end_de",
          "args": [
            "d"
          ],
          "line": 399
        },
        "resolved": true,
        "details": {
          "function_name": "dnode_end_de",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "115-119",
          "snippet": "static inline struct hpfs_dirent *dnode_end_de (struct dnode *dnode)\n{\n  CHKCOND(le32_to_cpu(dnode->first_free)>=0x14 && le32_to_cpu(dnode->first_free)<=0xa00,(\"HPFS: dnode_end_de: dnode->first_free = %x\\n\",(unsigned)le32_to_cpu(dnode->first_free)));\n  return (void *) dnode + le32_to_cpu(dnode->first_free);\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_add_dirent(struct inode *, const unsigned char *, unsigned,\n\t\t    struct hpfs_dirent *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_add_dirent(struct inode *, const unsigned char *, unsigned,\n\t\t    struct hpfs_dirent *);\n\nstatic inline struct hpfs_dirent *dnode_end_de (struct dnode *dnode)\n{\n  CHKCOND(le32_to_cpu(dnode->first_free)>=0x14 && le32_to_cpu(dnode->first_free)<=0xa00,(\"HPFS: dnode_end_de: dnode->first_free = %x\\n\",(unsigned)le32_to_cpu(dnode->first_free)));\n  return (void *) dnode + le32_to_cpu(dnode->first_free);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_map_dnode",
          "args": [
            "i->i_sb",
            "dno",
            "&qbh"
          ],
          "line": 398
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_map_dnode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/map.c",
          "lines": "229-293",
          "snippet": "struct dnode *hpfs_map_dnode(struct super_block *s, unsigned secno,\n\t\t\t     struct quad_buffer_head *qbh)\n{\n\tstruct dnode *dnode;\n\tif (hpfs_sb(s)->sb_chk) {\n\t\tif (hpfs_chk_sectors(s, secno, 4, \"dnode\")) return NULL;\n\t\tif (secno & 3) {\n\t\t\thpfs_error(s, \"dnode %08x not byte-aligned\", secno);\n\t\t\treturn NULL;\n\t\t}\t\n\t}\n\tif ((dnode = hpfs_map_4sectors(s, secno, qbh, DNODE_RD_AHEAD)))\n\t\tif (hpfs_sb(s)->sb_chk) {\n\t\t\tunsigned p, pp = 0;\n\t\t\tunsigned char *d = (unsigned char *)dnode;\n\t\t\tint b = 0;\n\t\t\tif (le32_to_cpu(dnode->magic) != DNODE_MAGIC) {\n\t\t\t\thpfs_error(s, \"bad magic on dnode %08x\", secno);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tif (le32_to_cpu(dnode->self) != secno)\n\t\t\t\thpfs_error(s, \"bad self pointer on dnode %08x self = %08x\", secno, le32_to_cpu(dnode->self));\n\t\t\t/* Check dirents - bad dirents would cause infinite\n\t\t\t   loops or shooting to memory */\n\t\t\tif (le32_to_cpu(dnode->first_free) > 2048) {\n\t\t\t\thpfs_error(s, \"dnode %08x has first_free == %08x\", secno, le32_to_cpu(dnode->first_free));\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tfor (p = 20; p < le32_to_cpu(dnode->first_free); p += d[p] + (d[p+1] << 8)) {\n\t\t\t\tstruct hpfs_dirent *de = (struct hpfs_dirent *)((char *)dnode + p);\n\t\t\t\tif (le16_to_cpu(de->length) > 292 || (le16_to_cpu(de->length) < 32) || (le16_to_cpu(de->length) & 3) || p + le16_to_cpu(de->length) > 2048) {\n\t\t\t\t\thpfs_error(s, \"bad dirent size in dnode %08x, dirent %03x, last %03x\", secno, p, pp);\n\t\t\t\t\tgoto bail;\n\t\t\t\t}\n\t\t\t\tif (((31 + de->namelen + de->down*4 + 3) & ~3) != le16_to_cpu(de->length)) {\n\t\t\t\t\tif (((31 + de->namelen + de->down*4 + 3) & ~3) < le16_to_cpu(de->length) && s->s_flags & MS_RDONLY) goto ok;\n\t\t\t\t\thpfs_error(s, \"namelen does not match dirent size in dnode %08x, dirent %03x, last %03x\", secno, p, pp);\n\t\t\t\t\tgoto bail;\n\t\t\t\t}\n\t\t\t\tok:\n\t\t\t\tif (hpfs_sb(s)->sb_chk >= 2) b |= 1 << de->down;\n\t\t\t\tif (de->down) if (de_down_pointer(de) < 0x10) {\n\t\t\t\t\thpfs_error(s, \"bad down pointer in dnode %08x, dirent %03x, last %03x\", secno, p, pp);\n\t\t\t\t\tgoto bail;\n\t\t\t\t}\n\t\t\t\tpp = p;\n\t\t\t\t\n\t\t\t}\n\t\t\tif (p != le32_to_cpu(dnode->first_free)) {\n\t\t\t\thpfs_error(s, \"size on last dirent does not match first_free; dnode %08x\", secno);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tif (d[pp + 30] != 1 || d[pp + 31] != 255) {\n\t\t\t\thpfs_error(s, \"dnode %08x does not end with \\\\377 entry\", secno);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tif (b == 3)\n\t\t\t\tpr_err(\"unbalanced dnode tree, dnode %08x; see hpfs.txt 4 more info\\n\",\n\t\t\t\t\tsecno);\n\t\t}\n\treturn dnode;\n\tbail:\n\thpfs_brelse4(qbh);\n\treturn NULL;\n}",
          "includes": [
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n\nstruct dnode *hpfs_map_dnode(struct super_block *s, unsigned secno,\n\t\t\t     struct quad_buffer_head *qbh)\n{\n\tstruct dnode *dnode;\n\tif (hpfs_sb(s)->sb_chk) {\n\t\tif (hpfs_chk_sectors(s, secno, 4, \"dnode\")) return NULL;\n\t\tif (secno & 3) {\n\t\t\thpfs_error(s, \"dnode %08x not byte-aligned\", secno);\n\t\t\treturn NULL;\n\t\t}\t\n\t}\n\tif ((dnode = hpfs_map_4sectors(s, secno, qbh, DNODE_RD_AHEAD)))\n\t\tif (hpfs_sb(s)->sb_chk) {\n\t\t\tunsigned p, pp = 0;\n\t\t\tunsigned char *d = (unsigned char *)dnode;\n\t\t\tint b = 0;\n\t\t\tif (le32_to_cpu(dnode->magic) != DNODE_MAGIC) {\n\t\t\t\thpfs_error(s, \"bad magic on dnode %08x\", secno);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tif (le32_to_cpu(dnode->self) != secno)\n\t\t\t\thpfs_error(s, \"bad self pointer on dnode %08x self = %08x\", secno, le32_to_cpu(dnode->self));\n\t\t\t/* Check dirents - bad dirents would cause infinite\n\t\t\t   loops or shooting to memory */\n\t\t\tif (le32_to_cpu(dnode->first_free) > 2048) {\n\t\t\t\thpfs_error(s, \"dnode %08x has first_free == %08x\", secno, le32_to_cpu(dnode->first_free));\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tfor (p = 20; p < le32_to_cpu(dnode->first_free); p += d[p] + (d[p+1] << 8)) {\n\t\t\t\tstruct hpfs_dirent *de = (struct hpfs_dirent *)((char *)dnode + p);\n\t\t\t\tif (le16_to_cpu(de->length) > 292 || (le16_to_cpu(de->length) < 32) || (le16_to_cpu(de->length) & 3) || p + le16_to_cpu(de->length) > 2048) {\n\t\t\t\t\thpfs_error(s, \"bad dirent size in dnode %08x, dirent %03x, last %03x\", secno, p, pp);\n\t\t\t\t\tgoto bail;\n\t\t\t\t}\n\t\t\t\tif (((31 + de->namelen + de->down*4 + 3) & ~3) != le16_to_cpu(de->length)) {\n\t\t\t\t\tif (((31 + de->namelen + de->down*4 + 3) & ~3) < le16_to_cpu(de->length) && s->s_flags & MS_RDONLY) goto ok;\n\t\t\t\t\thpfs_error(s, \"namelen does not match dirent size in dnode %08x, dirent %03x, last %03x\", secno, p, pp);\n\t\t\t\t\tgoto bail;\n\t\t\t\t}\n\t\t\t\tok:\n\t\t\t\tif (hpfs_sb(s)->sb_chk >= 2) b |= 1 << de->down;\n\t\t\t\tif (de->down) if (de_down_pointer(de) < 0x10) {\n\t\t\t\t\thpfs_error(s, \"bad down pointer in dnode %08x, dirent %03x, last %03x\", secno, p, pp);\n\t\t\t\t\tgoto bail;\n\t\t\t\t}\n\t\t\t\tpp = p;\n\t\t\t\t\n\t\t\t}\n\t\t\tif (p != le32_to_cpu(dnode->first_free)) {\n\t\t\t\thpfs_error(s, \"size on last dirent does not match first_free; dnode %08x\", secno);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tif (d[pp + 30] != 1 || d[pp + 31] != 255) {\n\t\t\t\thpfs_error(s, \"dnode %08x does not end with \\\\377 entry\", secno);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tif (b == 3)\n\t\t\t\tpr_err(\"unbalanced dnode tree, dnode %08x; see hpfs.txt 4 more info\\n\",\n\t\t\t\t\tsecno);\n\t\t}\n\treturn dnode;\n\tbail:\n\thpfs_brelse4(qbh);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_stop_cycles",
          "args": [
            "i->i_sb",
            "dno",
            "&c1",
            "&c2",
            "\"hpfs_add_dirent\""
          ],
          "line": 397
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_stop_cycles",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/super.c",
          "lines": "96-106",
          "snippet": "int hpfs_stop_cycles(struct super_block *s, int key, int *c1, int *c2,\n\t\tchar *msg)\n{\n\tif (*c2 && *c1 == key) {\n\t\thpfs_error(s, \"cycle detected on key %08x in %s\", key, msg);\n\t\treturn 1;\n\t}\n\t(*c2)++;\n\tif (!((*c2 - 1) & *c2)) *c1 = key;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/sched.h>",
            "#include <linux/magic.h>",
            "#include <linux/statfs.h>",
            "#include <linux/init.h>",
            "#include <linux/parser.h>",
            "#include <linux/module.h>",
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/bitmap.h>\n#include <linux/sched.h>\n#include <linux/magic.h>\n#include <linux/statfs.h>\n#include <linux/init.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include \"hpfs_fn.h\"\n\nint hpfs_stop_cycles(struct super_block *s, int key, int *c1, int *c2,\n\t\tchar *msg)\n{\n\tif (*c2 && *c1 == key) {\n\t\thpfs_error(s, \"cycle detected on key %08x in %s\", key, msg);\n\t\treturn 1;\n\t}\n\t(*c2)++;\n\tif (!((*c2 - 1) & *c2)) *c1 = key;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_sb",
          "args": [
            "i->i_sb"
          ],
          "line": 396
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_sb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "310-313",
          "snippet": "static inline struct hpfs_sb_info *hpfs_sb(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_check_free_dnodes(struct super_block *, int);",
            "void hpfs_prefetch_sectors(struct super_block *, unsigned, int);",
            "void hpfs_prefetch_bitmap(struct super_block *, unsigned);",
            "unsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);",
            "int hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);",
            "void hpfs_error(struct super_block *, const char *, ...);",
            "int hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);",
            "unsigned hpfs_get_free_dnodes(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_check_free_dnodes(struct super_block *, int);\nvoid hpfs_prefetch_sectors(struct super_block *, unsigned, int);\nvoid hpfs_prefetch_bitmap(struct super_block *, unsigned);\nunsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);\nint hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);\nvoid hpfs_error(struct super_block *, const char *, ...);\nint hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);\nunsigned hpfs_get_free_dnodes(struct super_block *);\n\nstatic inline struct hpfs_sb_info *hpfs_sb(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_i",
          "args": [
            "i"
          ],
          "line": 387
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_i",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "305-308",
          "snippet": "static inline struct hpfs_inode_info *hpfs_i(struct inode *inode)\n{\n\treturn list_entry(inode, struct hpfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void hpfs_truncate(struct inode *);",
            "void hpfs_init_inode(struct inode *);",
            "void hpfs_read_inode(struct inode *);",
            "void hpfs_write_inode(struct inode *);",
            "void hpfs_write_inode_nolock(struct inode *);",
            "void hpfs_write_if_changed(struct inode *);",
            "void hpfs_evict_inode(struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nvoid hpfs_truncate(struct inode *);\nvoid hpfs_init_inode(struct inode *);\nvoid hpfs_read_inode(struct inode *);\nvoid hpfs_write_inode(struct inode *);\nvoid hpfs_write_inode_nolock(struct inode *);\nvoid hpfs_write_if_changed(struct inode *);\nvoid hpfs_evict_inode(struct inode *);\n\nstatic inline struct hpfs_inode_info *hpfs_i(struct inode *inode)\n{\n\treturn list_entry(inode, struct hpfs_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hpfs_fn.h\"\n\nint hpfs_add_dirent(struct inode *i,\n\t\t    const unsigned char *name, unsigned namelen,\n\t\t    struct hpfs_dirent *new_de)\n{\n\tstruct hpfs_inode_info *hpfs_inode = hpfs_i(i);\n\tstruct dnode *d;\n\tstruct hpfs_dirent *de, *de_end;\n\tstruct quad_buffer_head qbh;\n\tdnode_secno dno;\n\tint c;\n\tint c1, c2 = 0;\n\tdno = hpfs_inode->i_dno;\n\tdown:\n\tif (hpfs_sb(i->i_sb)->sb_chk)\n\t\tif (hpfs_stop_cycles(i->i_sb, dno, &c1, &c2, \"hpfs_add_dirent\")) return 1;\n\tif (!(d = hpfs_map_dnode(i->i_sb, dno, &qbh))) return 1;\n\tde_end = dnode_end_de(d);\n\tfor (de = dnode_first_de(d); de < de_end; de = de_next_de(de)) {\n\t\tif (!(c = hpfs_compare_names(i->i_sb, name, namelen, de->name, de->namelen, de->last))) {\n\t\t\thpfs_brelse4(&qbh);\n\t\t\treturn -1;\n\t\t}\t\n\t\tif (c < 0) {\n\t\t\tif (de->down) {\n\t\t\t\tdno = de_down_pointer(de);\n\t\t\t\thpfs_brelse4(&qbh);\n\t\t\t\tgoto down;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\thpfs_brelse4(&qbh);\n\tif (hpfs_check_free_dnodes(i->i_sb, FREE_DNODES_ADD)) {\n\t\tc = 1;\n\t\tgoto ret;\n\t}\t\n\ti->i_version++;\n\tc = hpfs_add_to_dnode(i, dno, name, namelen, new_de, 0);\n\tret:\n\treturn c;\n}"
  },
  {
    "function_name": "hpfs_add_to_dnode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/dnode.c",
    "lines": "233-373",
    "snippet": "static int hpfs_add_to_dnode(struct inode *i, dnode_secno dno,\n\t\t\t     const unsigned char *name, unsigned namelen,\n\t\t\t     struct hpfs_dirent *new_de, dnode_secno down_ptr)\n{\n\tstruct quad_buffer_head qbh, qbh1, qbh2;\n\tstruct dnode *d, *ad, *rd, *nd = NULL;\n\tdnode_secno adno, rdno;\n\tstruct hpfs_dirent *de;\n\tstruct hpfs_dirent nde;\n\tunsigned char *nname;\n\tint h;\n\tint pos;\n\tstruct buffer_head *bh;\n\tstruct fnode *fnode;\n\tint c1, c2 = 0;\n\tif (!(nname = kmalloc(256, GFP_NOFS))) {\n\t\tpr_err(\"out of memory, can't add to dnode\\n\");\n\t\treturn 1;\n\t}\n\tgo_up:\n\tif (namelen >= 256) {\n\t\thpfs_error(i->i_sb, \"%s(): namelen == %d\", __func__, namelen);\n\t\tkfree(nd);\n\t\tkfree(nname);\n\t\treturn 1;\n\t}\n\tif (!(d = hpfs_map_dnode(i->i_sb, dno, &qbh))) {\n\t\tkfree(nd);\n\t\tkfree(nname);\n\t\treturn 1;\n\t}\n\tgo_up_a:\n\tif (hpfs_sb(i->i_sb)->sb_chk)\n\t\tif (hpfs_stop_cycles(i->i_sb, dno, &c1, &c2, \"hpfs_add_to_dnode\")) {\n\t\t\thpfs_brelse4(&qbh);\n\t\t\tkfree(nd);\n\t\t\tkfree(nname);\n\t\t\treturn 1;\n\t\t}\n\tif (le32_to_cpu(d->first_free) + de_size(namelen, down_ptr) <= 2048) {\n\t\tloff_t t;\n\t\tcopy_de(de=hpfs_add_de(i->i_sb, d, name, namelen, down_ptr), new_de);\n\t\tt = get_pos(d, de);\n\t\tfor_all_poss(i, hpfs_pos_ins, t, 1);\n\t\tfor_all_poss(i, hpfs_pos_subst, 4, t);\n\t\tfor_all_poss(i, hpfs_pos_subst, 5, t + 1);\n\t\thpfs_mark_4buffers_dirty(&qbh);\n\t\thpfs_brelse4(&qbh);\n\t\tkfree(nd);\n\t\tkfree(nname);\n\t\treturn 0;\n\t}\n\tif (!nd) if (!(nd = kmalloc(0x924, GFP_NOFS))) {\n\t\t/* 0x924 is a max size of dnode after adding a dirent with\n\t\t   max name length. We alloc this only once. There must\n\t\t   not be any error while splitting dnodes, otherwise the\n\t\t   whole directory, not only file we're adding, would\n\t\t   be lost. */\n\t\tpr_err(\"out of memory for dnode splitting\\n\");\n\t\thpfs_brelse4(&qbh);\n\t\tkfree(nname);\n\t\treturn 1;\n\t}\t\n\tmemcpy(nd, d, le32_to_cpu(d->first_free));\n\tcopy_de(de = hpfs_add_de(i->i_sb, nd, name, namelen, down_ptr), new_de);\n\tfor_all_poss(i, hpfs_pos_ins, get_pos(nd, de), 1);\n\th = ((char *)dnode_last_de(nd) - (char *)nd) / 2 + 10;\n\tif (!(ad = hpfs_alloc_dnode(i->i_sb, le32_to_cpu(d->up), &adno, &qbh1))) {\n\t\thpfs_error(i->i_sb, \"unable to alloc dnode - dnode tree will be corrupted\");\n\t\thpfs_brelse4(&qbh);\n\t\tkfree(nd);\n\t\tkfree(nname);\n\t\treturn 1;\n\t}\n\ti->i_size += 2048;\n\ti->i_blocks += 4;\n\tpos = 1;\n\tfor (de = dnode_first_de(nd); (char *)de_next_de(de) - (char *)nd < h; de = de_next_de(de)) {\n\t\tcopy_de(hpfs_add_de(i->i_sb, ad, de->name, de->namelen, de->down ? de_down_pointer(de) : 0), de);\n\t\tfor_all_poss(i, hpfs_pos_subst, ((loff_t)dno << 4) | pos, ((loff_t)adno << 4) | pos);\n\t\tpos++;\n\t}\n\tcopy_de(new_de = &nde, de);\n\tmemcpy(nname, de->name, de->namelen);\n\tname = nname;\n\tnamelen = de->namelen;\n\tfor_all_poss(i, hpfs_pos_subst, ((loff_t)dno << 4) | pos, 4);\n\tdown_ptr = adno;\n\tset_last_pointer(i->i_sb, ad, de->down ? de_down_pointer(de) : 0);\n\tde = de_next_de(de);\n\tmemmove((char *)nd + 20, de, le32_to_cpu(nd->first_free) + (char *)nd - (char *)de);\n\tle32_add_cpu(&nd->first_free, -((char *)de - (char *)nd - 20));\n\tmemcpy(d, nd, le32_to_cpu(nd->first_free));\n\tfor_all_poss(i, hpfs_pos_del, (loff_t)dno << 4, pos);\n\tfix_up_ptrs(i->i_sb, ad);\n\tif (!d->root_dnode) {\n\t\tad->up = d->up;\n\t\tdno = le32_to_cpu(ad->up);\n\t\thpfs_mark_4buffers_dirty(&qbh);\n\t\thpfs_brelse4(&qbh);\n\t\thpfs_mark_4buffers_dirty(&qbh1);\n\t\thpfs_brelse4(&qbh1);\n\t\tgoto go_up;\n\t}\n\tif (!(rd = hpfs_alloc_dnode(i->i_sb, le32_to_cpu(d->up), &rdno, &qbh2))) {\n\t\thpfs_error(i->i_sb, \"unable to alloc dnode - dnode tree will be corrupted\");\n\t\thpfs_brelse4(&qbh);\n\t\thpfs_brelse4(&qbh1);\n\t\tkfree(nd);\n\t\tkfree(nname);\n\t\treturn 1;\n\t}\n\ti->i_size += 2048;\n\ti->i_blocks += 4;\n\trd->root_dnode = 1;\n\trd->up = d->up;\n\tif (!(fnode = hpfs_map_fnode(i->i_sb, le32_to_cpu(d->up), &bh))) {\n\t\thpfs_free_dnode(i->i_sb, rdno);\n\t\thpfs_brelse4(&qbh);\n\t\thpfs_brelse4(&qbh1);\n\t\thpfs_brelse4(&qbh2);\n\t\tkfree(nd);\n\t\tkfree(nname);\n\t\treturn 1;\n\t}\n\tfnode->u.external[0].disk_secno = cpu_to_le32(rdno);\n\tmark_buffer_dirty(bh);\n\tbrelse(bh);\n\thpfs_i(i)->i_dno = rdno;\n\td->up = ad->up = cpu_to_le32(rdno);\n\td->root_dnode = ad->root_dnode = 0;\n\thpfs_mark_4buffers_dirty(&qbh);\n\thpfs_brelse4(&qbh);\n\thpfs_mark_4buffers_dirty(&qbh1);\n\thpfs_brelse4(&qbh1);\n\tqbh = qbh2;\n\tset_last_pointer(i->i_sb, rd, dno);\n\tdno = rdno;\n\td = rd;\n\tgoto go_up_a;\n}",
    "includes": [
      "#include \"hpfs_fn.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_last_pointer",
          "args": [
            "i->i_sb",
            "rd",
            "dno"
          ],
          "line": 369
        },
        "resolved": true,
        "details": {
          "function_name": "set_last_pointer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/dnode.c",
          "lines": "136-165",
          "snippet": "static void set_last_pointer(struct super_block *s, struct dnode *d, dnode_secno ptr)\n{\n\tstruct hpfs_dirent *de;\n\tif (!(de = dnode_last_de(d))) {\n\t\thpfs_error(s, \"set_last_pointer: empty dnode %08x\", le32_to_cpu(d->self));\n\t\treturn;\n\t}\n\tif (hpfs_sb(s)->sb_chk) {\n\t\tif (de->down) {\n\t\t\thpfs_error(s, \"set_last_pointer: dnode %08x has already last pointer %08x\",\n\t\t\t\tle32_to_cpu(d->self), de_down_pointer(de));\n\t\t\treturn;\n\t\t}\n\t\tif (le16_to_cpu(de->length) != 32) {\n\t\t\thpfs_error(s, \"set_last_pointer: bad last dirent in dnode %08x\", le32_to_cpu(d->self));\n\t\t\treturn;\n\t\t}\n\t}\n\tif (ptr) {\n\t\tle32_add_cpu(&d->first_free, 4);\n\t\tif (le32_to_cpu(d->first_free) > 2048) {\n\t\t\thpfs_error(s, \"set_last_pointer: too long dnode %08x\", le32_to_cpu(d->self));\n\t\t\tle32_add_cpu(&d->first_free, -4);\n\t\t\treturn;\n\t\t}\n\t\tde->length = cpu_to_le16(36);\n\t\tde->down = 1;\n\t\t*(__le32 *)((char *)de + 32) = cpu_to_le32(ptr);\n\t}\n}",
          "includes": [
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n\nstatic void set_last_pointer(struct super_block *s, struct dnode *d, dnode_secno ptr)\n{\n\tstruct hpfs_dirent *de;\n\tif (!(de = dnode_last_de(d))) {\n\t\thpfs_error(s, \"set_last_pointer: empty dnode %08x\", le32_to_cpu(d->self));\n\t\treturn;\n\t}\n\tif (hpfs_sb(s)->sb_chk) {\n\t\tif (de->down) {\n\t\t\thpfs_error(s, \"set_last_pointer: dnode %08x has already last pointer %08x\",\n\t\t\t\tle32_to_cpu(d->self), de_down_pointer(de));\n\t\t\treturn;\n\t\t}\n\t\tif (le16_to_cpu(de->length) != 32) {\n\t\t\thpfs_error(s, \"set_last_pointer: bad last dirent in dnode %08x\", le32_to_cpu(d->self));\n\t\t\treturn;\n\t\t}\n\t}\n\tif (ptr) {\n\t\tle32_add_cpu(&d->first_free, 4);\n\t\tif (le32_to_cpu(d->first_free) > 2048) {\n\t\t\thpfs_error(s, \"set_last_pointer: too long dnode %08x\", le32_to_cpu(d->self));\n\t\t\tle32_add_cpu(&d->first_free, -4);\n\t\t\treturn;\n\t\t}\n\t\tde->length = cpu_to_le16(36);\n\t\tde->down = 1;\n\t\t*(__le32 *)((char *)de + 32) = cpu_to_le32(ptr);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_brelse4",
          "args": [
            "&qbh1"
          ],
          "line": 367
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_brelse4",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/buffer.c",
          "lines": "182-190",
          "snippet": "void hpfs_brelse4(struct quad_buffer_head *qbh)\n{\n\tif (unlikely(qbh->data != qbh->bh[0]->b_data))\n\t\tkfree(qbh->data);\n\tbrelse(qbh->bh[0]);\n\tbrelse(qbh->bh[1]);\n\tbrelse(qbh->bh[2]);\n\tbrelse(qbh->bh[3]);\n}",
          "includes": [
            "#include \"hpfs_fn.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid hpfs_brelse4(struct quad_buffer_head *qbh)\n{\n\tif (unlikely(qbh->data != qbh->bh[0]->b_data))\n\t\tkfree(qbh->data);\n\tbrelse(qbh->bh[0]);\n\tbrelse(qbh->bh[1]);\n\tbrelse(qbh->bh[2]);\n\tbrelse(qbh->bh[3]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_mark_4buffers_dirty",
          "args": [
            "&qbh1"
          ],
          "line": 366
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_mark_4buffers_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/buffer.c",
          "lines": "192-204",
          "snippet": "void hpfs_mark_4buffers_dirty(struct quad_buffer_head *qbh)\n{\n\tif (unlikely(qbh->data != qbh->bh[0]->b_data)) {\n\t\tmemcpy(qbh->bh[0]->b_data, qbh->data + 0 * 512, 512);\n\t\tmemcpy(qbh->bh[1]->b_data, qbh->data + 1 * 512, 512);\n\t\tmemcpy(qbh->bh[2]->b_data, qbh->data + 2 * 512, 512);\n\t\tmemcpy(qbh->bh[3]->b_data, qbh->data + 3 * 512, 512);\n\t}\n\tmark_buffer_dirty(qbh->bh[0]);\n\tmark_buffer_dirty(qbh->bh[1]);\n\tmark_buffer_dirty(qbh->bh[2]);\n\tmark_buffer_dirty(qbh->bh[3]);\n}",
          "includes": [
            "#include \"hpfs_fn.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid hpfs_mark_4buffers_dirty(struct quad_buffer_head *qbh)\n{\n\tif (unlikely(qbh->data != qbh->bh[0]->b_data)) {\n\t\tmemcpy(qbh->bh[0]->b_data, qbh->data + 0 * 512, 512);\n\t\tmemcpy(qbh->bh[1]->b_data, qbh->data + 1 * 512, 512);\n\t\tmemcpy(qbh->bh[2]->b_data, qbh->data + 2 * 512, 512);\n\t\tmemcpy(qbh->bh[3]->b_data, qbh->data + 3 * 512, 512);\n\t}\n\tmark_buffer_dirty(qbh->bh[0]);\n\tmark_buffer_dirty(qbh->bh[1]);\n\tmark_buffer_dirty(qbh->bh[2]);\n\tmark_buffer_dirty(qbh->bh[3]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "rdno"
          ],
          "line": 362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hpfs_i",
          "args": [
            "i"
          ],
          "line": 361
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_i",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "305-308",
          "snippet": "static inline struct hpfs_inode_info *hpfs_i(struct inode *inode)\n{\n\treturn list_entry(inode, struct hpfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void hpfs_truncate(struct inode *);",
            "void hpfs_init_inode(struct inode *);",
            "void hpfs_read_inode(struct inode *);",
            "void hpfs_write_inode(struct inode *);",
            "void hpfs_write_inode_nolock(struct inode *);",
            "void hpfs_write_if_changed(struct inode *);",
            "void hpfs_evict_inode(struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nvoid hpfs_truncate(struct inode *);\nvoid hpfs_init_inode(struct inode *);\nvoid hpfs_read_inode(struct inode *);\nvoid hpfs_write_inode(struct inode *);\nvoid hpfs_write_inode_nolock(struct inode *);\nvoid hpfs_write_if_changed(struct inode *);\nvoid hpfs_evict_inode(struct inode *);\n\nstatic inline struct hpfs_inode_info *hpfs_i(struct inode *inode)\n{\n\treturn list_entry(inode, struct hpfs_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_buffer_dirty",
          "args": [
            "bh"
          ],
          "line": 359
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1141-1167",
          "snippet": "void mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "rdno"
          ],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "nname"
          ],
          "line": 355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "nd"
          ],
          "line": 354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hpfs_free_dnode",
          "args": [
            "i->i_sb",
            "rdno"
          ],
          "line": 350
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_free_dnode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/alloc.c",
          "lines": "404-425",
          "snippet": "void hpfs_free_dnode(struct super_block *s, dnode_secno dno)\n{\n\tif (hpfs_sb(s)->sb_chk) if (dno & 3) {\n\t\thpfs_error(s, \"hpfs_free_dnode: dnode %08x not aligned\", dno);\n\t\treturn;\n\t}\n\tif (dno < hpfs_sb(s)->sb_dirband_start ||\n\t    dno >= hpfs_sb(s)->sb_dirband_start + hpfs_sb(s)->sb_dirband_size) {\n\t\thpfs_free_sectors(s, dno, 4);\n\t} else {\n\t\tstruct quad_buffer_head qbh;\n\t\t__le32 *bmp;\n\t\tunsigned ssec = (dno - hpfs_sb(s)->sb_dirband_start) / 4;\n\t\tif (!(bmp = hpfs_map_dnode_bitmap(s, &qbh))) {\n\t\t\treturn;\n\t\t}\n\t\tbmp[ssec >> 5] |= cpu_to_le32(1 << (ssec & 0x1f));\n\t\thpfs_mark_4buffers_dirty(&qbh);\n\t\thpfs_brelse4(&qbh);\n\t\thpfs_claim_dirband_free(s, dno);\n\t}\n}",
          "includes": [
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n\nvoid hpfs_free_dnode(struct super_block *s, dnode_secno dno)\n{\n\tif (hpfs_sb(s)->sb_chk) if (dno & 3) {\n\t\thpfs_error(s, \"hpfs_free_dnode: dnode %08x not aligned\", dno);\n\t\treturn;\n\t}\n\tif (dno < hpfs_sb(s)->sb_dirband_start ||\n\t    dno >= hpfs_sb(s)->sb_dirband_start + hpfs_sb(s)->sb_dirband_size) {\n\t\thpfs_free_sectors(s, dno, 4);\n\t} else {\n\t\tstruct quad_buffer_head qbh;\n\t\t__le32 *bmp;\n\t\tunsigned ssec = (dno - hpfs_sb(s)->sb_dirband_start) / 4;\n\t\tif (!(bmp = hpfs_map_dnode_bitmap(s, &qbh))) {\n\t\t\treturn;\n\t\t}\n\t\tbmp[ssec >> 5] |= cpu_to_le32(1 << (ssec & 0x1f));\n\t\thpfs_mark_4buffers_dirty(&qbh);\n\t\thpfs_brelse4(&qbh);\n\t\thpfs_claim_dirband_free(s, dno);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_map_fnode",
          "args": [
            "i->i_sb",
            "le32_to_cpu(d->up)",
            "&bh"
          ],
          "line": 349
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_map_fnode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/map.c",
          "lines": "137-192",
          "snippet": "struct fnode *hpfs_map_fnode(struct super_block *s, ino_t ino, struct buffer_head **bhp)\n{\n\tstruct fnode *fnode;\n\tif (hpfs_sb(s)->sb_chk) if (hpfs_chk_sectors(s, ino, 1, \"fnode\")) {\n\t\treturn NULL;\n\t}\n\tif ((fnode = hpfs_map_sector(s, ino, bhp, FNODE_RD_AHEAD))) {\n\t\tif (hpfs_sb(s)->sb_chk) {\n\t\t\tstruct extended_attribute *ea;\n\t\t\tstruct extended_attribute *ea_end;\n\t\t\tif (le32_to_cpu(fnode->magic) != FNODE_MAGIC) {\n\t\t\t\thpfs_error(s, \"bad magic on fnode %08lx\",\n\t\t\t\t\t(unsigned long)ino);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tif (!fnode_is_dir(fnode)) {\n\t\t\t\tif ((unsigned)fnode->btree.n_used_nodes + (unsigned)fnode->btree.n_free_nodes !=\n\t\t\t\t    (bp_internal(&fnode->btree) ? 12 : 8)) {\n\t\t\t\t\thpfs_error(s,\n\t\t\t\t\t   \"bad number of nodes in fnode %08lx\",\n\t\t\t\t\t    (unsigned long)ino);\n\t\t\t\t\tgoto bail;\n\t\t\t\t}\n\t\t\t\tif (le16_to_cpu(fnode->btree.first_free) !=\n\t\t\t\t    8 + fnode->btree.n_used_nodes * (bp_internal(&fnode->btree) ? 8 : 12)) {\n\t\t\t\t\thpfs_error(s,\n\t\t\t\t\t    \"bad first_free pointer in fnode %08lx\",\n\t\t\t\t\t    (unsigned long)ino);\n\t\t\t\t\tgoto bail;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (le16_to_cpu(fnode->ea_size_s) && (le16_to_cpu(fnode->ea_offs) < 0xc4 ||\n\t\t\t   le16_to_cpu(fnode->ea_offs) + le16_to_cpu(fnode->acl_size_s) + le16_to_cpu(fnode->ea_size_s) > 0x200)) {\n\t\t\t\thpfs_error(s,\n\t\t\t\t\t\"bad EA info in fnode %08lx: ea_offs == %04x ea_size_s == %04x\",\n\t\t\t\t\t(unsigned long)ino,\n\t\t\t\t\tle16_to_cpu(fnode->ea_offs), le16_to_cpu(fnode->ea_size_s));\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tea = fnode_ea(fnode);\n\t\t\tea_end = fnode_end_ea(fnode);\n\t\t\twhile (ea != ea_end) {\n\t\t\t\tif (ea > ea_end) {\n\t\t\t\t\thpfs_error(s, \"bad EA in fnode %08lx\",\n\t\t\t\t\t\t(unsigned long)ino);\n\t\t\t\t\tgoto bail;\n\t\t\t\t}\n\t\t\t\tea = next_ea(ea);\n\t\t\t}\n\t\t}\n\t}\n\treturn fnode;\n\tbail:\n\tbrelse(*bhp);\n\treturn NULL;\n}",
          "includes": [
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n\nstruct fnode *hpfs_map_fnode(struct super_block *s, ino_t ino, struct buffer_head **bhp)\n{\n\tstruct fnode *fnode;\n\tif (hpfs_sb(s)->sb_chk) if (hpfs_chk_sectors(s, ino, 1, \"fnode\")) {\n\t\treturn NULL;\n\t}\n\tif ((fnode = hpfs_map_sector(s, ino, bhp, FNODE_RD_AHEAD))) {\n\t\tif (hpfs_sb(s)->sb_chk) {\n\t\t\tstruct extended_attribute *ea;\n\t\t\tstruct extended_attribute *ea_end;\n\t\t\tif (le32_to_cpu(fnode->magic) != FNODE_MAGIC) {\n\t\t\t\thpfs_error(s, \"bad magic on fnode %08lx\",\n\t\t\t\t\t(unsigned long)ino);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tif (!fnode_is_dir(fnode)) {\n\t\t\t\tif ((unsigned)fnode->btree.n_used_nodes + (unsigned)fnode->btree.n_free_nodes !=\n\t\t\t\t    (bp_internal(&fnode->btree) ? 12 : 8)) {\n\t\t\t\t\thpfs_error(s,\n\t\t\t\t\t   \"bad number of nodes in fnode %08lx\",\n\t\t\t\t\t    (unsigned long)ino);\n\t\t\t\t\tgoto bail;\n\t\t\t\t}\n\t\t\t\tif (le16_to_cpu(fnode->btree.first_free) !=\n\t\t\t\t    8 + fnode->btree.n_used_nodes * (bp_internal(&fnode->btree) ? 8 : 12)) {\n\t\t\t\t\thpfs_error(s,\n\t\t\t\t\t    \"bad first_free pointer in fnode %08lx\",\n\t\t\t\t\t    (unsigned long)ino);\n\t\t\t\t\tgoto bail;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (le16_to_cpu(fnode->ea_size_s) && (le16_to_cpu(fnode->ea_offs) < 0xc4 ||\n\t\t\t   le16_to_cpu(fnode->ea_offs) + le16_to_cpu(fnode->acl_size_s) + le16_to_cpu(fnode->ea_size_s) > 0x200)) {\n\t\t\t\thpfs_error(s,\n\t\t\t\t\t\"bad EA info in fnode %08lx: ea_offs == %04x ea_size_s == %04x\",\n\t\t\t\t\t(unsigned long)ino,\n\t\t\t\t\tle16_to_cpu(fnode->ea_offs), le16_to_cpu(fnode->ea_size_s));\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tea = fnode_ea(fnode);\n\t\t\tea_end = fnode_end_ea(fnode);\n\t\t\twhile (ea != ea_end) {\n\t\t\t\tif (ea > ea_end) {\n\t\t\t\t\thpfs_error(s, \"bad EA in fnode %08lx\",\n\t\t\t\t\t\t(unsigned long)ino);\n\t\t\t\t\tgoto bail;\n\t\t\t\t}\n\t\t\t\tea = next_ea(ea);\n\t\t\t}\n\t\t}\n\t}\n\treturn fnode;\n\tbail:\n\tbrelse(*bhp);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "d->up"
          ],
          "line": 349
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "nname"
          ],
          "line": 342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "nd"
          ],
          "line": 341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hpfs_error",
          "args": [
            "i->i_sb",
            "\"unable to alloc dnode - dnode tree will be corrupted\""
          ],
          "line": 338
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/super.c",
          "lines": "57-86",
          "snippet": "void hpfs_error(struct super_block *s, const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvsnprintf(err_buf, sizeof(err_buf), fmt, args);\n\tva_end(args);\n\n\tpr_err(\"filesystem error: %s\", err_buf);\n\tif (!hpfs_sb(s)->sb_was_error) {\n\t\tif (hpfs_sb(s)->sb_err == 2) {\n\t\t\tpr_cont(\"; crashing the system because you wanted it\\n\");\n\t\t\tmark_dirty(s, 0);\n\t\t\tpanic(\"HPFS panic\");\n\t\t} else if (hpfs_sb(s)->sb_err == 1) {\n\t\t\tif (s->s_flags & MS_RDONLY)\n\t\t\t\tpr_cont(\"; already mounted read-only\\n\");\n\t\t\telse {\n\t\t\t\tpr_cont(\"; remounting read-only\\n\");\n\t\t\t\tmark_dirty(s, 0);\n\t\t\t\ts->s_flags |= MS_RDONLY;\n\t\t\t}\n\t\t} else if (s->s_flags & MS_RDONLY)\n\t\t\t\tpr_cont(\"; going on - but anything won't be destroyed because it's read-only\\n\");\n\t\telse\n\t\t\tpr_cont(\"; corrupted filesystem mounted read/write - your computer will explode within 20 seconds ... but you wanted it so!\\n\");\n\t} else\n\t\tpr_cont(\"\\n\");\n\thpfs_sb(s)->sb_was_error = 1;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/sched.h>",
            "#include <linux/magic.h>",
            "#include <linux/statfs.h>",
            "#include <linux/init.h>",
            "#include <linux/parser.h>",
            "#include <linux/module.h>",
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static char err_buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/bitmap.h>\n#include <linux/sched.h>\n#include <linux/magic.h>\n#include <linux/statfs.h>\n#include <linux/init.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include \"hpfs_fn.h\"\n\nstatic char err_buf[1024];\n\nvoid hpfs_error(struct super_block *s, const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvsnprintf(err_buf, sizeof(err_buf), fmt, args);\n\tva_end(args);\n\n\tpr_err(\"filesystem error: %s\", err_buf);\n\tif (!hpfs_sb(s)->sb_was_error) {\n\t\tif (hpfs_sb(s)->sb_err == 2) {\n\t\t\tpr_cont(\"; crashing the system because you wanted it\\n\");\n\t\t\tmark_dirty(s, 0);\n\t\t\tpanic(\"HPFS panic\");\n\t\t} else if (hpfs_sb(s)->sb_err == 1) {\n\t\t\tif (s->s_flags & MS_RDONLY)\n\t\t\t\tpr_cont(\"; already mounted read-only\\n\");\n\t\t\telse {\n\t\t\t\tpr_cont(\"; remounting read-only\\n\");\n\t\t\t\tmark_dirty(s, 0);\n\t\t\t\ts->s_flags |= MS_RDONLY;\n\t\t\t}\n\t\t} else if (s->s_flags & MS_RDONLY)\n\t\t\t\tpr_cont(\"; going on - but anything won't be destroyed because it's read-only\\n\");\n\t\telse\n\t\t\tpr_cont(\"; corrupted filesystem mounted read/write - your computer will explode within 20 seconds ... but you wanted it so!\\n\");\n\t} else\n\t\tpr_cont(\"\\n\");\n\thpfs_sb(s)->sb_was_error = 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_alloc_dnode",
          "args": [
            "i->i_sb",
            "le32_to_cpu(d->up)",
            "&rdno",
            "&qbh2"
          ],
          "line": 337
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_alloc_dnode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/alloc.c",
          "lines": "427-451",
          "snippet": "struct dnode *hpfs_alloc_dnode(struct super_block *s, secno near,\n\t\t\t dnode_secno *dno, struct quad_buffer_head *qbh)\n{\n\tstruct dnode *d;\n\tif (hpfs_get_free_dnodes(s) > FREE_DNODES_ADD) {\n\t\tif (!(*dno = alloc_in_dirband(s, near)))\n\t\t\tif (!(*dno = hpfs_alloc_sector(s, near, 4, 0))) return NULL;\n\t} else {\n\t\tif (!(*dno = hpfs_alloc_sector(s, near, 4, 0)))\n\t\t\tif (!(*dno = alloc_in_dirband(s, near))) return NULL;\n\t}\n\tif (!(d = hpfs_get_4sectors(s, *dno, qbh))) {\n\t\thpfs_free_dnode(s, *dno);\n\t\treturn NULL;\n\t}\n\tmemset(d, 0, 2048);\n\td->magic = cpu_to_le32(DNODE_MAGIC);\n\td->first_free = cpu_to_le32(52);\n\td->dirent[0] = 32;\n\td->dirent[2] = 8;\n\td->dirent[30] = 1;\n\td->dirent[31] = 255;\n\td->self = cpu_to_le32(*dno);\n\treturn d;\n}",
          "includes": [
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n\nstruct dnode *hpfs_alloc_dnode(struct super_block *s, secno near,\n\t\t\t dnode_secno *dno, struct quad_buffer_head *qbh)\n{\n\tstruct dnode *d;\n\tif (hpfs_get_free_dnodes(s) > FREE_DNODES_ADD) {\n\t\tif (!(*dno = alloc_in_dirband(s, near)))\n\t\t\tif (!(*dno = hpfs_alloc_sector(s, near, 4, 0))) return NULL;\n\t} else {\n\t\tif (!(*dno = hpfs_alloc_sector(s, near, 4, 0)))\n\t\t\tif (!(*dno = alloc_in_dirband(s, near))) return NULL;\n\t}\n\tif (!(d = hpfs_get_4sectors(s, *dno, qbh))) {\n\t\thpfs_free_dnode(s, *dno);\n\t\treturn NULL;\n\t}\n\tmemset(d, 0, 2048);\n\td->magic = cpu_to_le32(DNODE_MAGIC);\n\td->first_free = cpu_to_le32(52);\n\td->dirent[0] = 32;\n\td->dirent[2] = 8;\n\td->dirent[30] = 1;\n\td->dirent[31] = 255;\n\td->self = cpu_to_le32(*dno);\n\treturn d;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fix_up_ptrs",
          "args": [
            "i->i_sb",
            "ad"
          ],
          "line": 327
        },
        "resolved": true,
        "details": {
          "function_name": "fix_up_ptrs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/dnode.c",
          "lines": "211-229",
          "snippet": "static void fix_up_ptrs(struct super_block *s, struct dnode *d)\n{\n\tstruct hpfs_dirent *de;\n\tstruct hpfs_dirent *de_end = dnode_end_de(d);\n\tdnode_secno dno = le32_to_cpu(d->self);\n\tfor (de = dnode_first_de(d); de < de_end; de = de_next_de(de))\n\t\tif (de->down) {\n\t\t\tstruct quad_buffer_head qbh;\n\t\t\tstruct dnode *dd;\n\t\t\tif ((dd = hpfs_map_dnode(s, de_down_pointer(de), &qbh))) {\n\t\t\t\tif (le32_to_cpu(dd->up) != dno || dd->root_dnode) {\n\t\t\t\t\tdd->up = cpu_to_le32(dno);\n\t\t\t\t\tdd->root_dnode = 0;\n\t\t\t\t\thpfs_mark_4buffers_dirty(&qbh);\n\t\t\t\t}\n\t\t\t\thpfs_brelse4(&qbh);\n\t\t\t}\n\t\t}\n}",
          "includes": [
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n\nstatic void fix_up_ptrs(struct super_block *s, struct dnode *d)\n{\n\tstruct hpfs_dirent *de;\n\tstruct hpfs_dirent *de_end = dnode_end_de(d);\n\tdnode_secno dno = le32_to_cpu(d->self);\n\tfor (de = dnode_first_de(d); de < de_end; de = de_next_de(de))\n\t\tif (de->down) {\n\t\t\tstruct quad_buffer_head qbh;\n\t\t\tstruct dnode *dd;\n\t\t\tif ((dd = hpfs_map_dnode(s, de_down_pointer(de), &qbh))) {\n\t\t\t\tif (le32_to_cpu(dd->up) != dno || dd->root_dnode) {\n\t\t\t\t\tdd->up = cpu_to_le32(dno);\n\t\t\t\t\tdd->root_dnode = 0;\n\t\t\t\t\thpfs_mark_4buffers_dirty(&qbh);\n\t\t\t\t}\n\t\t\t\thpfs_brelse4(&qbh);\n\t\t\t}\n\t\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_all_poss",
          "args": [
            "i",
            "hpfs_pos_del",
            "(loff_t)dno << 4",
            "pos"
          ],
          "line": 326
        },
        "resolved": true,
        "details": {
          "function_name": "for_all_poss",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/dnode.c",
          "lines": "71-80",
          "snippet": "static void for_all_poss(struct inode *inode, void (*f)(loff_t *, loff_t, loff_t),\n\t\t\t loff_t p1, loff_t p2)\n{\n\tstruct hpfs_inode_info *hpfs_inode = hpfs_i(inode);\n\tloff_t **i;\n\n\tif (!hpfs_inode->i_rddir_off) return;\n\tfor (i = hpfs_inode->i_rddir_off; *i; i++) (*f)(*i, p1, p2);\n\treturn;\n}",
          "includes": [
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n\nstatic void for_all_poss(struct inode *inode, void (*f)(loff_t *, loff_t, loff_t),\n\t\t\t loff_t p1, loff_t p2)\n{\n\tstruct hpfs_inode_info *hpfs_inode = hpfs_i(inode);\n\tloff_t **i;\n\n\tif (!hpfs_inode->i_rddir_off) return;\n\tfor (i = hpfs_inode->i_rddir_off; *i; i++) (*f)(*i, p1, p2);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "d",
            "nd",
            "le32_to_cpu(nd->first_free)"
          ],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_add_cpu",
          "args": [
            "&nd->first_free",
            "-((char *)de - (char *)nd - 20)"
          ],
          "line": 324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "(char *)nd + 20",
            "de",
            "le32_to_cpu(nd->first_free) + (char *)nd - (char *)de"
          ],
          "line": 323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "de_next_de",
          "args": [
            "de"
          ],
          "line": 322
        },
        "resolved": true,
        "details": {
          "function_name": "de_next_de",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "123-127",
          "snippet": "static inline struct hpfs_dirent *de_next_de (struct hpfs_dirent *de)\n{\n  CHKCOND(le16_to_cpu(de->length)>=0x20 && le16_to_cpu(de->length)<0x800,(\"HPFS: de_next_de: de->length = %x\\n\",(unsigned)le16_to_cpu(de->length)));\n  return (void *) de + le16_to_cpu(de->length);\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_add_dirent(struct inode *, const unsigned char *, unsigned,\n\t\t    struct hpfs_dirent *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_add_dirent(struct inode *, const unsigned char *, unsigned,\n\t\t    struct hpfs_dirent *);\n\nstatic inline struct hpfs_dirent *de_next_de (struct hpfs_dirent *de)\n{\n  CHKCOND(le16_to_cpu(de->length)>=0x20 && le16_to_cpu(de->length)<0x800,(\"HPFS: de_next_de: de->length = %x\\n\",(unsigned)le16_to_cpu(de->length)));\n  return (void *) de + le16_to_cpu(de->length);\n}"
        }
      },
      {
        "call_info": {
          "callee": "de_down_pointer",
          "args": [
            "de"
          ],
          "line": 321
        },
        "resolved": true,
        "details": {
          "function_name": "de_down_pointer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "100-104",
          "snippet": "static inline dnode_secno de_down_pointer (struct hpfs_dirent *de)\n{\n  CHKCOND(de->down,(\"HPFS: de_down_pointer: !de->down\\n\"));\n  return le32_to_cpu(*(__le32 *) ((void *) de + le16_to_cpu(de->length) - 4));\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_add_dirent(struct inode *, const unsigned char *, unsigned,\n\t\t    struct hpfs_dirent *);",
            "void hpfs_count_dnodes(struct super_block *, dnode_secno, int *, int *, int *);",
            "void hpfs_remove_dtree(struct super_block *, dnode_secno);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_add_dirent(struct inode *, const unsigned char *, unsigned,\n\t\t    struct hpfs_dirent *);\nvoid hpfs_count_dnodes(struct super_block *, dnode_secno, int *, int *, int *);\nvoid hpfs_remove_dtree(struct super_block *, dnode_secno);\n\nstatic inline dnode_secno de_down_pointer (struct hpfs_dirent *de)\n{\n  CHKCOND(de->down,(\"HPFS: de_down_pointer: !de->down\\n\"));\n  return le32_to_cpu(*(__le32 *) ((void *) de + le16_to_cpu(de->length) - 4));\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "nname",
            "de->name",
            "de->namelen"
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_de",
          "args": [
            "new_de = &nde",
            "de"
          ],
          "line": 315
        },
        "resolved": true,
        "details": {
          "function_name": "copy_de",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "169-179",
          "snippet": "static inline void copy_de(struct hpfs_dirent *dst, struct hpfs_dirent *src)\n{\n\tint a;\n\tint n;\n\tif (!dst || !src) return;\n\ta = dst->down;\n\tn = dst->not_8x3;\n\tmemcpy((char *)dst + 2, (char *)src + 2, 28);\n\tdst->down = a;\n\tdst->not_8x3 = n;\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_add_dirent(struct inode *, const unsigned char *, unsigned,\n\t\t    struct hpfs_dirent *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_add_dirent(struct inode *, const unsigned char *, unsigned,\n\t\t    struct hpfs_dirent *);\n\nstatic inline void copy_de(struct hpfs_dirent *dst, struct hpfs_dirent *src)\n{\n\tint a;\n\tint n;\n\tif (!dst || !src) return;\n\ta = dst->down;\n\tn = dst->not_8x3;\n\tmemcpy((char *)dst + 2, (char *)src + 2, 28);\n\tdst->down = a;\n\tdst->not_8x3 = n;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_add_de",
          "args": [
            "i->i_sb",
            "ad",
            "de->name",
            "de->namelen",
            "de->down ? de_down_pointer(de) : 0"
          ],
          "line": 311
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_add_de",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/dnode.c",
          "lines": "169-196",
          "snippet": "struct hpfs_dirent *hpfs_add_de(struct super_block *s, struct dnode *d,\n\t\t\t\tconst unsigned char *name,\n\t\t\t\tunsigned namelen, secno down_ptr)\n{\n\tstruct hpfs_dirent *de;\n\tstruct hpfs_dirent *de_end = dnode_end_de(d);\n\tunsigned d_size = de_size(namelen, down_ptr);\n\tfor (de = dnode_first_de(d); de < de_end; de = de_next_de(de)) {\n\t\tint c = hpfs_compare_names(s, name, namelen, de->name, de->namelen, de->last);\n\t\tif (!c) {\n\t\t\thpfs_error(s, \"name (%c,%d) already exists in dnode %08x\", *name, namelen, le32_to_cpu(d->self));\n\t\t\treturn NULL;\n\t\t}\n\t\tif (c < 0) break;\n\t}\n\tmemmove((char *)de + d_size, de, (char *)de_end - (char *)de);\n\tmemset(de, 0, d_size);\n\tif (down_ptr) {\n\t\t*(__le32 *)((char *)de + d_size - 4) = cpu_to_le32(down_ptr);\n\t\tde->down = 1;\n\t}\n\tde->length = cpu_to_le16(d_size);\n\tde->not_8x3 = hpfs_is_name_long(name, namelen);\n\tde->namelen = namelen;\n\tmemcpy(de->name, name, namelen);\n\tle32_add_cpu(&d->first_free, d_size);\n\treturn de;\n}",
          "includes": [
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n\nstruct hpfs_dirent *hpfs_add_de(struct super_block *s, struct dnode *d,\n\t\t\t\tconst unsigned char *name,\n\t\t\t\tunsigned namelen, secno down_ptr)\n{\n\tstruct hpfs_dirent *de;\n\tstruct hpfs_dirent *de_end = dnode_end_de(d);\n\tunsigned d_size = de_size(namelen, down_ptr);\n\tfor (de = dnode_first_de(d); de < de_end; de = de_next_de(de)) {\n\t\tint c = hpfs_compare_names(s, name, namelen, de->name, de->namelen, de->last);\n\t\tif (!c) {\n\t\t\thpfs_error(s, \"name (%c,%d) already exists in dnode %08x\", *name, namelen, le32_to_cpu(d->self));\n\t\t\treturn NULL;\n\t\t}\n\t\tif (c < 0) break;\n\t}\n\tmemmove((char *)de + d_size, de, (char *)de_end - (char *)de);\n\tmemset(de, 0, d_size);\n\tif (down_ptr) {\n\t\t*(__le32 *)((char *)de + d_size - 4) = cpu_to_le32(down_ptr);\n\t\tde->down = 1;\n\t}\n\tde->length = cpu_to_le16(d_size);\n\tde->not_8x3 = hpfs_is_name_long(name, namelen);\n\tde->namelen = namelen;\n\tmemcpy(de->name, name, namelen);\n\tle32_add_cpu(&d->first_free, d_size);\n\treturn de;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dnode_first_de",
          "args": [
            "nd"
          ],
          "line": 310
        },
        "resolved": true,
        "details": {
          "function_name": "dnode_first_de",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "108-111",
          "snippet": "static inline struct hpfs_dirent *dnode_first_de (struct dnode *dnode)\n{\n  return (void *) dnode->dirent;\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_add_dirent(struct inode *, const unsigned char *, unsigned,\n\t\t    struct hpfs_dirent *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_add_dirent(struct inode *, const unsigned char *, unsigned,\n\t\t    struct hpfs_dirent *);\n\nstatic inline struct hpfs_dirent *dnode_first_de (struct dnode *dnode)\n{\n  return (void *) dnode->dirent;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "nname"
          ],
          "line": 304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "nd"
          ],
          "line": 303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dnode_last_de",
          "args": [
            "nd"
          ],
          "line": 299
        },
        "resolved": true,
        "details": {
          "function_name": "dnode_last_de",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/dnode.c",
          "lines": "126-134",
          "snippet": "static struct hpfs_dirent *dnode_last_de(struct dnode *d)\n{\n\tstruct hpfs_dirent *de, *de_end, *dee = NULL;\n\tde_end = dnode_end_de(d);\n\tfor (de = dnode_first_de(d); de < de_end; de = de_next_de(de)) {\n\t\tdee = de;\n\t}\t\n\treturn dee;\n}",
          "includes": [
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n\nstatic struct hpfs_dirent *dnode_last_de(struct dnode *d)\n{\n\tstruct hpfs_dirent *de, *de_end, *dee = NULL;\n\tde_end = dnode_end_de(d);\n\tfor (de = dnode_first_de(d); de < de_end; de = de_next_de(de)) {\n\t\tdee = de;\n\t}\t\n\treturn dee;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_pos",
          "args": [
            "nd",
            "de"
          ],
          "line": 298
        },
        "resolved": true,
        "details": {
          "function_name": "get_pos",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/dnode.c",
          "lines": "11-22",
          "snippet": "static loff_t get_pos(struct dnode *d, struct hpfs_dirent *fde)\n{\n\tstruct hpfs_dirent *de;\n\tstruct hpfs_dirent *de_end = dnode_end_de(d);\n\tint i = 1;\n\tfor (de = dnode_first_de(d); de < de_end; de = de_next_de(de)) {\n\t\tif (de == fde) return ((loff_t) le32_to_cpu(d->self) << 4) | (loff_t)i;\n\t\ti++;\n\t}\n\tpr_info(\"%s(): not_found\\n\", __func__);\n\treturn ((loff_t)le32_to_cpu(d->self) << 4) | (loff_t)1;\n}",
          "includes": [
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n\nstatic loff_t get_pos(struct dnode *d, struct hpfs_dirent *fde)\n{\n\tstruct hpfs_dirent *de;\n\tstruct hpfs_dirent *de_end = dnode_end_de(d);\n\tint i = 1;\n\tfor (de = dnode_first_de(d); de < de_end; de = de_next_de(de)) {\n\t\tif (de == fde) return ((loff_t) le32_to_cpu(d->self) << 4) | (loff_t)i;\n\t\ti++;\n\t}\n\tpr_info(\"%s(): not_found\\n\", __func__);\n\treturn ((loff_t)le32_to_cpu(d->self) << 4) | (loff_t)1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "nd",
            "d",
            "le32_to_cpu(d->first_free)"
          ],
          "line": 296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "nname"
          ],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"out of memory for dnode splitting\\n\""
          ],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "0x924",
            "GFP_NOFS"
          ],
          "line": 285
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "nname"
          ],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "nd"
          ],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "de_size",
          "args": [
            "namelen",
            "down_ptr"
          ],
          "line": 272
        },
        "resolved": true,
        "details": {
          "function_name": "de_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "164-167",
          "snippet": "static inline unsigned de_size(int namelen, secno down_ptr)\n{\n\treturn ((0x1f + namelen + 3) & ~3) + (down_ptr ? 4 : 0);\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_chk_sectors(struct super_block *, secno, int, char *);",
            "secno hpfs_alloc_sector(struct super_block *, secno, unsigned, int);",
            "int hpfs_alloc_if_possible(struct super_block *, secno);",
            "void hpfs_free_sectors(struct super_block *, secno, unsigned);",
            "void hpfs_free_dnode(struct super_block *, secno);",
            "secno hpfs_add_sector_to_btree(struct super_block *, secno, int, unsigned);",
            "int hpfs_ea_read(struct super_block *, secno, int, unsigned, unsigned, char *);",
            "int hpfs_ea_write(struct super_block *, secno, int, unsigned, unsigned, const char *);",
            "void hpfs_ea_remove(struct super_block *, secno, int, unsigned);",
            "void hpfs_truncate_btree(struct super_block *, secno, int, unsigned);",
            "struct hpfs_dirent *hpfs_add_de(struct super_block *, struct dnode *,\n\t\t\t\tconst unsigned char *, unsigned, secno);",
            "void hpfs_ea_ext_remove(struct super_block *, secno, int, unsigned);",
            "unsigned char *hpfs_load_code_page(struct super_block *, secno);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_chk_sectors(struct super_block *, secno, int, char *);\nsecno hpfs_alloc_sector(struct super_block *, secno, unsigned, int);\nint hpfs_alloc_if_possible(struct super_block *, secno);\nvoid hpfs_free_sectors(struct super_block *, secno, unsigned);\nvoid hpfs_free_dnode(struct super_block *, secno);\nsecno hpfs_add_sector_to_btree(struct super_block *, secno, int, unsigned);\nint hpfs_ea_read(struct super_block *, secno, int, unsigned, unsigned, char *);\nint hpfs_ea_write(struct super_block *, secno, int, unsigned, unsigned, const char *);\nvoid hpfs_ea_remove(struct super_block *, secno, int, unsigned);\nvoid hpfs_truncate_btree(struct super_block *, secno, int, unsigned);\nstruct hpfs_dirent *hpfs_add_de(struct super_block *, struct dnode *,\n\t\t\t\tconst unsigned char *, unsigned, secno);\nvoid hpfs_ea_ext_remove(struct super_block *, secno, int, unsigned);\nunsigned char *hpfs_load_code_page(struct super_block *, secno);\n\nstatic inline unsigned de_size(int namelen, secno down_ptr)\n{\n\treturn ((0x1f + namelen + 3) & ~3) + (down_ptr ? 4 : 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "nname"
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "nd"
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hpfs_stop_cycles",
          "args": [
            "i->i_sb",
            "dno",
            "&c1",
            "&c2",
            "\"hpfs_add_to_dnode\""
          ],
          "line": 266
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_stop_cycles",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/super.c",
          "lines": "96-106",
          "snippet": "int hpfs_stop_cycles(struct super_block *s, int key, int *c1, int *c2,\n\t\tchar *msg)\n{\n\tif (*c2 && *c1 == key) {\n\t\thpfs_error(s, \"cycle detected on key %08x in %s\", key, msg);\n\t\treturn 1;\n\t}\n\t(*c2)++;\n\tif (!((*c2 - 1) & *c2)) *c1 = key;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/sched.h>",
            "#include <linux/magic.h>",
            "#include <linux/statfs.h>",
            "#include <linux/init.h>",
            "#include <linux/parser.h>",
            "#include <linux/module.h>",
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/bitmap.h>\n#include <linux/sched.h>\n#include <linux/magic.h>\n#include <linux/statfs.h>\n#include <linux/init.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include \"hpfs_fn.h\"\n\nint hpfs_stop_cycles(struct super_block *s, int key, int *c1, int *c2,\n\t\tchar *msg)\n{\n\tif (*c2 && *c1 == key) {\n\t\thpfs_error(s, \"cycle detected on key %08x in %s\", key, msg);\n\t\treturn 1;\n\t}\n\t(*c2)++;\n\tif (!((*c2 - 1) & *c2)) *c1 = key;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_sb",
          "args": [
            "i->i_sb"
          ],
          "line": 265
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_sb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "310-313",
          "snippet": "static inline struct hpfs_sb_info *hpfs_sb(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_check_free_dnodes(struct super_block *, int);",
            "void hpfs_prefetch_sectors(struct super_block *, unsigned, int);",
            "void hpfs_prefetch_bitmap(struct super_block *, unsigned);",
            "unsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);",
            "int hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);",
            "void hpfs_error(struct super_block *, const char *, ...);",
            "int hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);",
            "unsigned hpfs_get_free_dnodes(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_check_free_dnodes(struct super_block *, int);\nvoid hpfs_prefetch_sectors(struct super_block *, unsigned, int);\nvoid hpfs_prefetch_bitmap(struct super_block *, unsigned);\nunsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);\nint hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);\nvoid hpfs_error(struct super_block *, const char *, ...);\nint hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);\nunsigned hpfs_get_free_dnodes(struct super_block *);\n\nstatic inline struct hpfs_sb_info *hpfs_sb(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "nname"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "nd"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hpfs_map_dnode",
          "args": [
            "i->i_sb",
            "dno",
            "&qbh"
          ],
          "line": 259
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_map_dnode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/map.c",
          "lines": "229-293",
          "snippet": "struct dnode *hpfs_map_dnode(struct super_block *s, unsigned secno,\n\t\t\t     struct quad_buffer_head *qbh)\n{\n\tstruct dnode *dnode;\n\tif (hpfs_sb(s)->sb_chk) {\n\t\tif (hpfs_chk_sectors(s, secno, 4, \"dnode\")) return NULL;\n\t\tif (secno & 3) {\n\t\t\thpfs_error(s, \"dnode %08x not byte-aligned\", secno);\n\t\t\treturn NULL;\n\t\t}\t\n\t}\n\tif ((dnode = hpfs_map_4sectors(s, secno, qbh, DNODE_RD_AHEAD)))\n\t\tif (hpfs_sb(s)->sb_chk) {\n\t\t\tunsigned p, pp = 0;\n\t\t\tunsigned char *d = (unsigned char *)dnode;\n\t\t\tint b = 0;\n\t\t\tif (le32_to_cpu(dnode->magic) != DNODE_MAGIC) {\n\t\t\t\thpfs_error(s, \"bad magic on dnode %08x\", secno);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tif (le32_to_cpu(dnode->self) != secno)\n\t\t\t\thpfs_error(s, \"bad self pointer on dnode %08x self = %08x\", secno, le32_to_cpu(dnode->self));\n\t\t\t/* Check dirents - bad dirents would cause infinite\n\t\t\t   loops or shooting to memory */\n\t\t\tif (le32_to_cpu(dnode->first_free) > 2048) {\n\t\t\t\thpfs_error(s, \"dnode %08x has first_free == %08x\", secno, le32_to_cpu(dnode->first_free));\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tfor (p = 20; p < le32_to_cpu(dnode->first_free); p += d[p] + (d[p+1] << 8)) {\n\t\t\t\tstruct hpfs_dirent *de = (struct hpfs_dirent *)((char *)dnode + p);\n\t\t\t\tif (le16_to_cpu(de->length) > 292 || (le16_to_cpu(de->length) < 32) || (le16_to_cpu(de->length) & 3) || p + le16_to_cpu(de->length) > 2048) {\n\t\t\t\t\thpfs_error(s, \"bad dirent size in dnode %08x, dirent %03x, last %03x\", secno, p, pp);\n\t\t\t\t\tgoto bail;\n\t\t\t\t}\n\t\t\t\tif (((31 + de->namelen + de->down*4 + 3) & ~3) != le16_to_cpu(de->length)) {\n\t\t\t\t\tif (((31 + de->namelen + de->down*4 + 3) & ~3) < le16_to_cpu(de->length) && s->s_flags & MS_RDONLY) goto ok;\n\t\t\t\t\thpfs_error(s, \"namelen does not match dirent size in dnode %08x, dirent %03x, last %03x\", secno, p, pp);\n\t\t\t\t\tgoto bail;\n\t\t\t\t}\n\t\t\t\tok:\n\t\t\t\tif (hpfs_sb(s)->sb_chk >= 2) b |= 1 << de->down;\n\t\t\t\tif (de->down) if (de_down_pointer(de) < 0x10) {\n\t\t\t\t\thpfs_error(s, \"bad down pointer in dnode %08x, dirent %03x, last %03x\", secno, p, pp);\n\t\t\t\t\tgoto bail;\n\t\t\t\t}\n\t\t\t\tpp = p;\n\t\t\t\t\n\t\t\t}\n\t\t\tif (p != le32_to_cpu(dnode->first_free)) {\n\t\t\t\thpfs_error(s, \"size on last dirent does not match first_free; dnode %08x\", secno);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tif (d[pp + 30] != 1 || d[pp + 31] != 255) {\n\t\t\t\thpfs_error(s, \"dnode %08x does not end with \\\\377 entry\", secno);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tif (b == 3)\n\t\t\t\tpr_err(\"unbalanced dnode tree, dnode %08x; see hpfs.txt 4 more info\\n\",\n\t\t\t\t\tsecno);\n\t\t}\n\treturn dnode;\n\tbail:\n\thpfs_brelse4(qbh);\n\treturn NULL;\n}",
          "includes": [
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n\nstruct dnode *hpfs_map_dnode(struct super_block *s, unsigned secno,\n\t\t\t     struct quad_buffer_head *qbh)\n{\n\tstruct dnode *dnode;\n\tif (hpfs_sb(s)->sb_chk) {\n\t\tif (hpfs_chk_sectors(s, secno, 4, \"dnode\")) return NULL;\n\t\tif (secno & 3) {\n\t\t\thpfs_error(s, \"dnode %08x not byte-aligned\", secno);\n\t\t\treturn NULL;\n\t\t}\t\n\t}\n\tif ((dnode = hpfs_map_4sectors(s, secno, qbh, DNODE_RD_AHEAD)))\n\t\tif (hpfs_sb(s)->sb_chk) {\n\t\t\tunsigned p, pp = 0;\n\t\t\tunsigned char *d = (unsigned char *)dnode;\n\t\t\tint b = 0;\n\t\t\tif (le32_to_cpu(dnode->magic) != DNODE_MAGIC) {\n\t\t\t\thpfs_error(s, \"bad magic on dnode %08x\", secno);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tif (le32_to_cpu(dnode->self) != secno)\n\t\t\t\thpfs_error(s, \"bad self pointer on dnode %08x self = %08x\", secno, le32_to_cpu(dnode->self));\n\t\t\t/* Check dirents - bad dirents would cause infinite\n\t\t\t   loops or shooting to memory */\n\t\t\tif (le32_to_cpu(dnode->first_free) > 2048) {\n\t\t\t\thpfs_error(s, \"dnode %08x has first_free == %08x\", secno, le32_to_cpu(dnode->first_free));\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tfor (p = 20; p < le32_to_cpu(dnode->first_free); p += d[p] + (d[p+1] << 8)) {\n\t\t\t\tstruct hpfs_dirent *de = (struct hpfs_dirent *)((char *)dnode + p);\n\t\t\t\tif (le16_to_cpu(de->length) > 292 || (le16_to_cpu(de->length) < 32) || (le16_to_cpu(de->length) & 3) || p + le16_to_cpu(de->length) > 2048) {\n\t\t\t\t\thpfs_error(s, \"bad dirent size in dnode %08x, dirent %03x, last %03x\", secno, p, pp);\n\t\t\t\t\tgoto bail;\n\t\t\t\t}\n\t\t\t\tif (((31 + de->namelen + de->down*4 + 3) & ~3) != le16_to_cpu(de->length)) {\n\t\t\t\t\tif (((31 + de->namelen + de->down*4 + 3) & ~3) < le16_to_cpu(de->length) && s->s_flags & MS_RDONLY) goto ok;\n\t\t\t\t\thpfs_error(s, \"namelen does not match dirent size in dnode %08x, dirent %03x, last %03x\", secno, p, pp);\n\t\t\t\t\tgoto bail;\n\t\t\t\t}\n\t\t\t\tok:\n\t\t\t\tif (hpfs_sb(s)->sb_chk >= 2) b |= 1 << de->down;\n\t\t\t\tif (de->down) if (de_down_pointer(de) < 0x10) {\n\t\t\t\t\thpfs_error(s, \"bad down pointer in dnode %08x, dirent %03x, last %03x\", secno, p, pp);\n\t\t\t\t\tgoto bail;\n\t\t\t\t}\n\t\t\t\tpp = p;\n\t\t\t\t\n\t\t\t}\n\t\t\tif (p != le32_to_cpu(dnode->first_free)) {\n\t\t\t\thpfs_error(s, \"size on last dirent does not match first_free; dnode %08x\", secno);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tif (d[pp + 30] != 1 || d[pp + 31] != 255) {\n\t\t\t\thpfs_error(s, \"dnode %08x does not end with \\\\377 entry\", secno);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tif (b == 3)\n\t\t\t\tpr_err(\"unbalanced dnode tree, dnode %08x; see hpfs.txt 4 more info\\n\",\n\t\t\t\t\tsecno);\n\t\t}\n\treturn dnode;\n\tbail:\n\thpfs_brelse4(qbh);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "nname"
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "nd"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"out of memory, can't add to dnode\\n\""
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"hpfs_fn.h\"\n\nstatic int hpfs_add_to_dnode(struct inode *i, dnode_secno dno,\n\t\t\t     const unsigned char *name, unsigned namelen,\n\t\t\t     struct hpfs_dirent *new_de, dnode_secno down_ptr)\n{\n\tstruct quad_buffer_head qbh, qbh1, qbh2;\n\tstruct dnode *d, *ad, *rd, *nd = NULL;\n\tdnode_secno adno, rdno;\n\tstruct hpfs_dirent *de;\n\tstruct hpfs_dirent nde;\n\tunsigned char *nname;\n\tint h;\n\tint pos;\n\tstruct buffer_head *bh;\n\tstruct fnode *fnode;\n\tint c1, c2 = 0;\n\tif (!(nname = kmalloc(256, GFP_NOFS))) {\n\t\tpr_err(\"out of memory, can't add to dnode\\n\");\n\t\treturn 1;\n\t}\n\tgo_up:\n\tif (namelen >= 256) {\n\t\thpfs_error(i->i_sb, \"%s(): namelen == %d\", __func__, namelen);\n\t\tkfree(nd);\n\t\tkfree(nname);\n\t\treturn 1;\n\t}\n\tif (!(d = hpfs_map_dnode(i->i_sb, dno, &qbh))) {\n\t\tkfree(nd);\n\t\tkfree(nname);\n\t\treturn 1;\n\t}\n\tgo_up_a:\n\tif (hpfs_sb(i->i_sb)->sb_chk)\n\t\tif (hpfs_stop_cycles(i->i_sb, dno, &c1, &c2, \"hpfs_add_to_dnode\")) {\n\t\t\thpfs_brelse4(&qbh);\n\t\t\tkfree(nd);\n\t\t\tkfree(nname);\n\t\t\treturn 1;\n\t\t}\n\tif (le32_to_cpu(d->first_free) + de_size(namelen, down_ptr) <= 2048) {\n\t\tloff_t t;\n\t\tcopy_de(de=hpfs_add_de(i->i_sb, d, name, namelen, down_ptr), new_de);\n\t\tt = get_pos(d, de);\n\t\tfor_all_poss(i, hpfs_pos_ins, t, 1);\n\t\tfor_all_poss(i, hpfs_pos_subst, 4, t);\n\t\tfor_all_poss(i, hpfs_pos_subst, 5, t + 1);\n\t\thpfs_mark_4buffers_dirty(&qbh);\n\t\thpfs_brelse4(&qbh);\n\t\tkfree(nd);\n\t\tkfree(nname);\n\t\treturn 0;\n\t}\n\tif (!nd) if (!(nd = kmalloc(0x924, GFP_NOFS))) {\n\t\t/* 0x924 is a max size of dnode after adding a dirent with\n\t\t   max name length. We alloc this only once. There must\n\t\t   not be any error while splitting dnodes, otherwise the\n\t\t   whole directory, not only file we're adding, would\n\t\t   be lost. */\n\t\tpr_err(\"out of memory for dnode splitting\\n\");\n\t\thpfs_brelse4(&qbh);\n\t\tkfree(nname);\n\t\treturn 1;\n\t}\t\n\tmemcpy(nd, d, le32_to_cpu(d->first_free));\n\tcopy_de(de = hpfs_add_de(i->i_sb, nd, name, namelen, down_ptr), new_de);\n\tfor_all_poss(i, hpfs_pos_ins, get_pos(nd, de), 1);\n\th = ((char *)dnode_last_de(nd) - (char *)nd) / 2 + 10;\n\tif (!(ad = hpfs_alloc_dnode(i->i_sb, le32_to_cpu(d->up), &adno, &qbh1))) {\n\t\thpfs_error(i->i_sb, \"unable to alloc dnode - dnode tree will be corrupted\");\n\t\thpfs_brelse4(&qbh);\n\t\tkfree(nd);\n\t\tkfree(nname);\n\t\treturn 1;\n\t}\n\ti->i_size += 2048;\n\ti->i_blocks += 4;\n\tpos = 1;\n\tfor (de = dnode_first_de(nd); (char *)de_next_de(de) - (char *)nd < h; de = de_next_de(de)) {\n\t\tcopy_de(hpfs_add_de(i->i_sb, ad, de->name, de->namelen, de->down ? de_down_pointer(de) : 0), de);\n\t\tfor_all_poss(i, hpfs_pos_subst, ((loff_t)dno << 4) | pos, ((loff_t)adno << 4) | pos);\n\t\tpos++;\n\t}\n\tcopy_de(new_de = &nde, de);\n\tmemcpy(nname, de->name, de->namelen);\n\tname = nname;\n\tnamelen = de->namelen;\n\tfor_all_poss(i, hpfs_pos_subst, ((loff_t)dno << 4) | pos, 4);\n\tdown_ptr = adno;\n\tset_last_pointer(i->i_sb, ad, de->down ? de_down_pointer(de) : 0);\n\tde = de_next_de(de);\n\tmemmove((char *)nd + 20, de, le32_to_cpu(nd->first_free) + (char *)nd - (char *)de);\n\tle32_add_cpu(&nd->first_free, -((char *)de - (char *)nd - 20));\n\tmemcpy(d, nd, le32_to_cpu(nd->first_free));\n\tfor_all_poss(i, hpfs_pos_del, (loff_t)dno << 4, pos);\n\tfix_up_ptrs(i->i_sb, ad);\n\tif (!d->root_dnode) {\n\t\tad->up = d->up;\n\t\tdno = le32_to_cpu(ad->up);\n\t\thpfs_mark_4buffers_dirty(&qbh);\n\t\thpfs_brelse4(&qbh);\n\t\thpfs_mark_4buffers_dirty(&qbh1);\n\t\thpfs_brelse4(&qbh1);\n\t\tgoto go_up;\n\t}\n\tif (!(rd = hpfs_alloc_dnode(i->i_sb, le32_to_cpu(d->up), &rdno, &qbh2))) {\n\t\thpfs_error(i->i_sb, \"unable to alloc dnode - dnode tree will be corrupted\");\n\t\thpfs_brelse4(&qbh);\n\t\thpfs_brelse4(&qbh1);\n\t\tkfree(nd);\n\t\tkfree(nname);\n\t\treturn 1;\n\t}\n\ti->i_size += 2048;\n\ti->i_blocks += 4;\n\trd->root_dnode = 1;\n\trd->up = d->up;\n\tif (!(fnode = hpfs_map_fnode(i->i_sb, le32_to_cpu(d->up), &bh))) {\n\t\thpfs_free_dnode(i->i_sb, rdno);\n\t\thpfs_brelse4(&qbh);\n\t\thpfs_brelse4(&qbh1);\n\t\thpfs_brelse4(&qbh2);\n\t\tkfree(nd);\n\t\tkfree(nname);\n\t\treturn 1;\n\t}\n\tfnode->u.external[0].disk_secno = cpu_to_le32(rdno);\n\tmark_buffer_dirty(bh);\n\tbrelse(bh);\n\thpfs_i(i)->i_dno = rdno;\n\td->up = ad->up = cpu_to_le32(rdno);\n\td->root_dnode = ad->root_dnode = 0;\n\thpfs_mark_4buffers_dirty(&qbh);\n\thpfs_brelse4(&qbh);\n\thpfs_mark_4buffers_dirty(&qbh1);\n\thpfs_brelse4(&qbh1);\n\tqbh = qbh2;\n\tset_last_pointer(i->i_sb, rd, dno);\n\tdno = rdno;\n\td = rd;\n\tgoto go_up_a;\n}"
  },
  {
    "function_name": "fix_up_ptrs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/dnode.c",
    "lines": "211-229",
    "snippet": "static void fix_up_ptrs(struct super_block *s, struct dnode *d)\n{\n\tstruct hpfs_dirent *de;\n\tstruct hpfs_dirent *de_end = dnode_end_de(d);\n\tdnode_secno dno = le32_to_cpu(d->self);\n\tfor (de = dnode_first_de(d); de < de_end; de = de_next_de(de))\n\t\tif (de->down) {\n\t\t\tstruct quad_buffer_head qbh;\n\t\t\tstruct dnode *dd;\n\t\t\tif ((dd = hpfs_map_dnode(s, de_down_pointer(de), &qbh))) {\n\t\t\t\tif (le32_to_cpu(dd->up) != dno || dd->root_dnode) {\n\t\t\t\t\tdd->up = cpu_to_le32(dno);\n\t\t\t\t\tdd->root_dnode = 0;\n\t\t\t\t\thpfs_mark_4buffers_dirty(&qbh);\n\t\t\t\t}\n\t\t\t\thpfs_brelse4(&qbh);\n\t\t\t}\n\t\t}\n}",
    "includes": [
      "#include \"hpfs_fn.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hpfs_brelse4",
          "args": [
            "&qbh"
          ],
          "line": 226
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_brelse4",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/buffer.c",
          "lines": "182-190",
          "snippet": "void hpfs_brelse4(struct quad_buffer_head *qbh)\n{\n\tif (unlikely(qbh->data != qbh->bh[0]->b_data))\n\t\tkfree(qbh->data);\n\tbrelse(qbh->bh[0]);\n\tbrelse(qbh->bh[1]);\n\tbrelse(qbh->bh[2]);\n\tbrelse(qbh->bh[3]);\n}",
          "includes": [
            "#include \"hpfs_fn.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid hpfs_brelse4(struct quad_buffer_head *qbh)\n{\n\tif (unlikely(qbh->data != qbh->bh[0]->b_data))\n\t\tkfree(qbh->data);\n\tbrelse(qbh->bh[0]);\n\tbrelse(qbh->bh[1]);\n\tbrelse(qbh->bh[2]);\n\tbrelse(qbh->bh[3]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_mark_4buffers_dirty",
          "args": [
            "&qbh"
          ],
          "line": 224
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_mark_4buffers_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/buffer.c",
          "lines": "192-204",
          "snippet": "void hpfs_mark_4buffers_dirty(struct quad_buffer_head *qbh)\n{\n\tif (unlikely(qbh->data != qbh->bh[0]->b_data)) {\n\t\tmemcpy(qbh->bh[0]->b_data, qbh->data + 0 * 512, 512);\n\t\tmemcpy(qbh->bh[1]->b_data, qbh->data + 1 * 512, 512);\n\t\tmemcpy(qbh->bh[2]->b_data, qbh->data + 2 * 512, 512);\n\t\tmemcpy(qbh->bh[3]->b_data, qbh->data + 3 * 512, 512);\n\t}\n\tmark_buffer_dirty(qbh->bh[0]);\n\tmark_buffer_dirty(qbh->bh[1]);\n\tmark_buffer_dirty(qbh->bh[2]);\n\tmark_buffer_dirty(qbh->bh[3]);\n}",
          "includes": [
            "#include \"hpfs_fn.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid hpfs_mark_4buffers_dirty(struct quad_buffer_head *qbh)\n{\n\tif (unlikely(qbh->data != qbh->bh[0]->b_data)) {\n\t\tmemcpy(qbh->bh[0]->b_data, qbh->data + 0 * 512, 512);\n\t\tmemcpy(qbh->bh[1]->b_data, qbh->data + 1 * 512, 512);\n\t\tmemcpy(qbh->bh[2]->b_data, qbh->data + 2 * 512, 512);\n\t\tmemcpy(qbh->bh[3]->b_data, qbh->data + 3 * 512, 512);\n\t}\n\tmark_buffer_dirty(qbh->bh[0]);\n\tmark_buffer_dirty(qbh->bh[1]);\n\tmark_buffer_dirty(qbh->bh[2]);\n\tmark_buffer_dirty(qbh->bh[3]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "dno"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "dd->up"
          ],
          "line": 221
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_map_dnode",
          "args": [
            "s",
            "de_down_pointer(de)",
            "&qbh"
          ],
          "line": 220
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_map_dnode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/map.c",
          "lines": "229-293",
          "snippet": "struct dnode *hpfs_map_dnode(struct super_block *s, unsigned secno,\n\t\t\t     struct quad_buffer_head *qbh)\n{\n\tstruct dnode *dnode;\n\tif (hpfs_sb(s)->sb_chk) {\n\t\tif (hpfs_chk_sectors(s, secno, 4, \"dnode\")) return NULL;\n\t\tif (secno & 3) {\n\t\t\thpfs_error(s, \"dnode %08x not byte-aligned\", secno);\n\t\t\treturn NULL;\n\t\t}\t\n\t}\n\tif ((dnode = hpfs_map_4sectors(s, secno, qbh, DNODE_RD_AHEAD)))\n\t\tif (hpfs_sb(s)->sb_chk) {\n\t\t\tunsigned p, pp = 0;\n\t\t\tunsigned char *d = (unsigned char *)dnode;\n\t\t\tint b = 0;\n\t\t\tif (le32_to_cpu(dnode->magic) != DNODE_MAGIC) {\n\t\t\t\thpfs_error(s, \"bad magic on dnode %08x\", secno);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tif (le32_to_cpu(dnode->self) != secno)\n\t\t\t\thpfs_error(s, \"bad self pointer on dnode %08x self = %08x\", secno, le32_to_cpu(dnode->self));\n\t\t\t/* Check dirents - bad dirents would cause infinite\n\t\t\t   loops or shooting to memory */\n\t\t\tif (le32_to_cpu(dnode->first_free) > 2048) {\n\t\t\t\thpfs_error(s, \"dnode %08x has first_free == %08x\", secno, le32_to_cpu(dnode->first_free));\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tfor (p = 20; p < le32_to_cpu(dnode->first_free); p += d[p] + (d[p+1] << 8)) {\n\t\t\t\tstruct hpfs_dirent *de = (struct hpfs_dirent *)((char *)dnode + p);\n\t\t\t\tif (le16_to_cpu(de->length) > 292 || (le16_to_cpu(de->length) < 32) || (le16_to_cpu(de->length) & 3) || p + le16_to_cpu(de->length) > 2048) {\n\t\t\t\t\thpfs_error(s, \"bad dirent size in dnode %08x, dirent %03x, last %03x\", secno, p, pp);\n\t\t\t\t\tgoto bail;\n\t\t\t\t}\n\t\t\t\tif (((31 + de->namelen + de->down*4 + 3) & ~3) != le16_to_cpu(de->length)) {\n\t\t\t\t\tif (((31 + de->namelen + de->down*4 + 3) & ~3) < le16_to_cpu(de->length) && s->s_flags & MS_RDONLY) goto ok;\n\t\t\t\t\thpfs_error(s, \"namelen does not match dirent size in dnode %08x, dirent %03x, last %03x\", secno, p, pp);\n\t\t\t\t\tgoto bail;\n\t\t\t\t}\n\t\t\t\tok:\n\t\t\t\tif (hpfs_sb(s)->sb_chk >= 2) b |= 1 << de->down;\n\t\t\t\tif (de->down) if (de_down_pointer(de) < 0x10) {\n\t\t\t\t\thpfs_error(s, \"bad down pointer in dnode %08x, dirent %03x, last %03x\", secno, p, pp);\n\t\t\t\t\tgoto bail;\n\t\t\t\t}\n\t\t\t\tpp = p;\n\t\t\t\t\n\t\t\t}\n\t\t\tif (p != le32_to_cpu(dnode->first_free)) {\n\t\t\t\thpfs_error(s, \"size on last dirent does not match first_free; dnode %08x\", secno);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tif (d[pp + 30] != 1 || d[pp + 31] != 255) {\n\t\t\t\thpfs_error(s, \"dnode %08x does not end with \\\\377 entry\", secno);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tif (b == 3)\n\t\t\t\tpr_err(\"unbalanced dnode tree, dnode %08x; see hpfs.txt 4 more info\\n\",\n\t\t\t\t\tsecno);\n\t\t}\n\treturn dnode;\n\tbail:\n\thpfs_brelse4(qbh);\n\treturn NULL;\n}",
          "includes": [
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n\nstruct dnode *hpfs_map_dnode(struct super_block *s, unsigned secno,\n\t\t\t     struct quad_buffer_head *qbh)\n{\n\tstruct dnode *dnode;\n\tif (hpfs_sb(s)->sb_chk) {\n\t\tif (hpfs_chk_sectors(s, secno, 4, \"dnode\")) return NULL;\n\t\tif (secno & 3) {\n\t\t\thpfs_error(s, \"dnode %08x not byte-aligned\", secno);\n\t\t\treturn NULL;\n\t\t}\t\n\t}\n\tif ((dnode = hpfs_map_4sectors(s, secno, qbh, DNODE_RD_AHEAD)))\n\t\tif (hpfs_sb(s)->sb_chk) {\n\t\t\tunsigned p, pp = 0;\n\t\t\tunsigned char *d = (unsigned char *)dnode;\n\t\t\tint b = 0;\n\t\t\tif (le32_to_cpu(dnode->magic) != DNODE_MAGIC) {\n\t\t\t\thpfs_error(s, \"bad magic on dnode %08x\", secno);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tif (le32_to_cpu(dnode->self) != secno)\n\t\t\t\thpfs_error(s, \"bad self pointer on dnode %08x self = %08x\", secno, le32_to_cpu(dnode->self));\n\t\t\t/* Check dirents - bad dirents would cause infinite\n\t\t\t   loops or shooting to memory */\n\t\t\tif (le32_to_cpu(dnode->first_free) > 2048) {\n\t\t\t\thpfs_error(s, \"dnode %08x has first_free == %08x\", secno, le32_to_cpu(dnode->first_free));\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tfor (p = 20; p < le32_to_cpu(dnode->first_free); p += d[p] + (d[p+1] << 8)) {\n\t\t\t\tstruct hpfs_dirent *de = (struct hpfs_dirent *)((char *)dnode + p);\n\t\t\t\tif (le16_to_cpu(de->length) > 292 || (le16_to_cpu(de->length) < 32) || (le16_to_cpu(de->length) & 3) || p + le16_to_cpu(de->length) > 2048) {\n\t\t\t\t\thpfs_error(s, \"bad dirent size in dnode %08x, dirent %03x, last %03x\", secno, p, pp);\n\t\t\t\t\tgoto bail;\n\t\t\t\t}\n\t\t\t\tif (((31 + de->namelen + de->down*4 + 3) & ~3) != le16_to_cpu(de->length)) {\n\t\t\t\t\tif (((31 + de->namelen + de->down*4 + 3) & ~3) < le16_to_cpu(de->length) && s->s_flags & MS_RDONLY) goto ok;\n\t\t\t\t\thpfs_error(s, \"namelen does not match dirent size in dnode %08x, dirent %03x, last %03x\", secno, p, pp);\n\t\t\t\t\tgoto bail;\n\t\t\t\t}\n\t\t\t\tok:\n\t\t\t\tif (hpfs_sb(s)->sb_chk >= 2) b |= 1 << de->down;\n\t\t\t\tif (de->down) if (de_down_pointer(de) < 0x10) {\n\t\t\t\t\thpfs_error(s, \"bad down pointer in dnode %08x, dirent %03x, last %03x\", secno, p, pp);\n\t\t\t\t\tgoto bail;\n\t\t\t\t}\n\t\t\t\tpp = p;\n\t\t\t\t\n\t\t\t}\n\t\t\tif (p != le32_to_cpu(dnode->first_free)) {\n\t\t\t\thpfs_error(s, \"size on last dirent does not match first_free; dnode %08x\", secno);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tif (d[pp + 30] != 1 || d[pp + 31] != 255) {\n\t\t\t\thpfs_error(s, \"dnode %08x does not end with \\\\377 entry\", secno);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tif (b == 3)\n\t\t\t\tpr_err(\"unbalanced dnode tree, dnode %08x; see hpfs.txt 4 more info\\n\",\n\t\t\t\t\tsecno);\n\t\t}\n\treturn dnode;\n\tbail:\n\thpfs_brelse4(qbh);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "de_down_pointer",
          "args": [
            "de"
          ],
          "line": 220
        },
        "resolved": true,
        "details": {
          "function_name": "de_down_pointer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "100-104",
          "snippet": "static inline dnode_secno de_down_pointer (struct hpfs_dirent *de)\n{\n  CHKCOND(de->down,(\"HPFS: de_down_pointer: !de->down\\n\"));\n  return le32_to_cpu(*(__le32 *) ((void *) de + le16_to_cpu(de->length) - 4));\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_add_dirent(struct inode *, const unsigned char *, unsigned,\n\t\t    struct hpfs_dirent *);",
            "void hpfs_count_dnodes(struct super_block *, dnode_secno, int *, int *, int *);",
            "void hpfs_remove_dtree(struct super_block *, dnode_secno);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_add_dirent(struct inode *, const unsigned char *, unsigned,\n\t\t    struct hpfs_dirent *);\nvoid hpfs_count_dnodes(struct super_block *, dnode_secno, int *, int *, int *);\nvoid hpfs_remove_dtree(struct super_block *, dnode_secno);\n\nstatic inline dnode_secno de_down_pointer (struct hpfs_dirent *de)\n{\n  CHKCOND(de->down,(\"HPFS: de_down_pointer: !de->down\\n\"));\n  return le32_to_cpu(*(__le32 *) ((void *) de + le16_to_cpu(de->length) - 4));\n}"
        }
      },
      {
        "call_info": {
          "callee": "de_next_de",
          "args": [
            "de"
          ],
          "line": 216
        },
        "resolved": true,
        "details": {
          "function_name": "de_next_de",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "123-127",
          "snippet": "static inline struct hpfs_dirent *de_next_de (struct hpfs_dirent *de)\n{\n  CHKCOND(le16_to_cpu(de->length)>=0x20 && le16_to_cpu(de->length)<0x800,(\"HPFS: de_next_de: de->length = %x\\n\",(unsigned)le16_to_cpu(de->length)));\n  return (void *) de + le16_to_cpu(de->length);\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_add_dirent(struct inode *, const unsigned char *, unsigned,\n\t\t    struct hpfs_dirent *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_add_dirent(struct inode *, const unsigned char *, unsigned,\n\t\t    struct hpfs_dirent *);\n\nstatic inline struct hpfs_dirent *de_next_de (struct hpfs_dirent *de)\n{\n  CHKCOND(le16_to_cpu(de->length)>=0x20 && le16_to_cpu(de->length)<0x800,(\"HPFS: de_next_de: de->length = %x\\n\",(unsigned)le16_to_cpu(de->length)));\n  return (void *) de + le16_to_cpu(de->length);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dnode_first_de",
          "args": [
            "d"
          ],
          "line": 216
        },
        "resolved": true,
        "details": {
          "function_name": "dnode_first_de",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "108-111",
          "snippet": "static inline struct hpfs_dirent *dnode_first_de (struct dnode *dnode)\n{\n  return (void *) dnode->dirent;\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_add_dirent(struct inode *, const unsigned char *, unsigned,\n\t\t    struct hpfs_dirent *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_add_dirent(struct inode *, const unsigned char *, unsigned,\n\t\t    struct hpfs_dirent *);\n\nstatic inline struct hpfs_dirent *dnode_first_de (struct dnode *dnode)\n{\n  return (void *) dnode->dirent;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dnode_end_de",
          "args": [
            "d"
          ],
          "line": 214
        },
        "resolved": true,
        "details": {
          "function_name": "dnode_end_de",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "115-119",
          "snippet": "static inline struct hpfs_dirent *dnode_end_de (struct dnode *dnode)\n{\n  CHKCOND(le32_to_cpu(dnode->first_free)>=0x14 && le32_to_cpu(dnode->first_free)<=0xa00,(\"HPFS: dnode_end_de: dnode->first_free = %x\\n\",(unsigned)le32_to_cpu(dnode->first_free)));\n  return (void *) dnode + le32_to_cpu(dnode->first_free);\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_add_dirent(struct inode *, const unsigned char *, unsigned,\n\t\t    struct hpfs_dirent *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_add_dirent(struct inode *, const unsigned char *, unsigned,\n\t\t    struct hpfs_dirent *);\n\nstatic inline struct hpfs_dirent *dnode_end_de (struct dnode *dnode)\n{\n  CHKCOND(le32_to_cpu(dnode->first_free)>=0x14 && le32_to_cpu(dnode->first_free)<=0xa00,(\"HPFS: dnode_end_de: dnode->first_free = %x\\n\",(unsigned)le32_to_cpu(dnode->first_free)));\n  return (void *) dnode + le32_to_cpu(dnode->first_free);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hpfs_fn.h\"\n\nstatic void fix_up_ptrs(struct super_block *s, struct dnode *d)\n{\n\tstruct hpfs_dirent *de;\n\tstruct hpfs_dirent *de_end = dnode_end_de(d);\n\tdnode_secno dno = le32_to_cpu(d->self);\n\tfor (de = dnode_first_de(d); de < de_end; de = de_next_de(de))\n\t\tif (de->down) {\n\t\t\tstruct quad_buffer_head qbh;\n\t\t\tstruct dnode *dd;\n\t\t\tif ((dd = hpfs_map_dnode(s, de_down_pointer(de), &qbh))) {\n\t\t\t\tif (le32_to_cpu(dd->up) != dno || dd->root_dnode) {\n\t\t\t\t\tdd->up = cpu_to_le32(dno);\n\t\t\t\t\tdd->root_dnode = 0;\n\t\t\t\t\thpfs_mark_4buffers_dirty(&qbh);\n\t\t\t\t}\n\t\t\t\thpfs_brelse4(&qbh);\n\t\t\t}\n\t\t}\n}"
  },
  {
    "function_name": "hpfs_delete_de",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/dnode.c",
    "lines": "200-209",
    "snippet": "static void hpfs_delete_de(struct super_block *s, struct dnode *d,\n\t\t\t   struct hpfs_dirent *de)\n{\n\tif (de->last) {\n\t\thpfs_error(s, \"attempt to delete last dirent in dnode %08x\", le32_to_cpu(d->self));\n\t\treturn;\n\t}\n\td->first_free = cpu_to_le32(le32_to_cpu(d->first_free) - le16_to_cpu(de->length));\n\tmemmove(de, de_next_de(de), le32_to_cpu(d->first_free) + (char *)d - (char *)de);\n}",
    "includes": [
      "#include \"hpfs_fn.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "de",
            "de_next_de(de)",
            "le32_to_cpu(d->first_free) + (char *)d - (char *)de"
          ],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "d->first_free"
          ],
          "line": 208
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "de_next_de",
          "args": [
            "de"
          ],
          "line": 208
        },
        "resolved": true,
        "details": {
          "function_name": "de_next_de",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "123-127",
          "snippet": "static inline struct hpfs_dirent *de_next_de (struct hpfs_dirent *de)\n{\n  CHKCOND(le16_to_cpu(de->length)>=0x20 && le16_to_cpu(de->length)<0x800,(\"HPFS: de_next_de: de->length = %x\\n\",(unsigned)le16_to_cpu(de->length)));\n  return (void *) de + le16_to_cpu(de->length);\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_add_dirent(struct inode *, const unsigned char *, unsigned,\n\t\t    struct hpfs_dirent *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_add_dirent(struct inode *, const unsigned char *, unsigned,\n\t\t    struct hpfs_dirent *);\n\nstatic inline struct hpfs_dirent *de_next_de (struct hpfs_dirent *de)\n{\n  CHKCOND(le16_to_cpu(de->length)>=0x20 && le16_to_cpu(de->length)<0x800,(\"HPFS: de_next_de: de->length = %x\\n\",(unsigned)le16_to_cpu(de->length)));\n  return (void *) de + le16_to_cpu(de->length);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "le32_to_cpu(d->first_free) - le16_to_cpu(de->length)"
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "de->length"
          ],
          "line": 207
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_error",
          "args": [
            "s",
            "\"attempt to delete last dirent in dnode %08x\"",
            "le32_to_cpu(d->self)"
          ],
          "line": 204
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/super.c",
          "lines": "57-86",
          "snippet": "void hpfs_error(struct super_block *s, const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvsnprintf(err_buf, sizeof(err_buf), fmt, args);\n\tva_end(args);\n\n\tpr_err(\"filesystem error: %s\", err_buf);\n\tif (!hpfs_sb(s)->sb_was_error) {\n\t\tif (hpfs_sb(s)->sb_err == 2) {\n\t\t\tpr_cont(\"; crashing the system because you wanted it\\n\");\n\t\t\tmark_dirty(s, 0);\n\t\t\tpanic(\"HPFS panic\");\n\t\t} else if (hpfs_sb(s)->sb_err == 1) {\n\t\t\tif (s->s_flags & MS_RDONLY)\n\t\t\t\tpr_cont(\"; already mounted read-only\\n\");\n\t\t\telse {\n\t\t\t\tpr_cont(\"; remounting read-only\\n\");\n\t\t\t\tmark_dirty(s, 0);\n\t\t\t\ts->s_flags |= MS_RDONLY;\n\t\t\t}\n\t\t} else if (s->s_flags & MS_RDONLY)\n\t\t\t\tpr_cont(\"; going on - but anything won't be destroyed because it's read-only\\n\");\n\t\telse\n\t\t\tpr_cont(\"; corrupted filesystem mounted read/write - your computer will explode within 20 seconds ... but you wanted it so!\\n\");\n\t} else\n\t\tpr_cont(\"\\n\");\n\thpfs_sb(s)->sb_was_error = 1;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/sched.h>",
            "#include <linux/magic.h>",
            "#include <linux/statfs.h>",
            "#include <linux/init.h>",
            "#include <linux/parser.h>",
            "#include <linux/module.h>",
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static char err_buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/bitmap.h>\n#include <linux/sched.h>\n#include <linux/magic.h>\n#include <linux/statfs.h>\n#include <linux/init.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include \"hpfs_fn.h\"\n\nstatic char err_buf[1024];\n\nvoid hpfs_error(struct super_block *s, const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvsnprintf(err_buf, sizeof(err_buf), fmt, args);\n\tva_end(args);\n\n\tpr_err(\"filesystem error: %s\", err_buf);\n\tif (!hpfs_sb(s)->sb_was_error) {\n\t\tif (hpfs_sb(s)->sb_err == 2) {\n\t\t\tpr_cont(\"; crashing the system because you wanted it\\n\");\n\t\t\tmark_dirty(s, 0);\n\t\t\tpanic(\"HPFS panic\");\n\t\t} else if (hpfs_sb(s)->sb_err == 1) {\n\t\t\tif (s->s_flags & MS_RDONLY)\n\t\t\t\tpr_cont(\"; already mounted read-only\\n\");\n\t\t\telse {\n\t\t\t\tpr_cont(\"; remounting read-only\\n\");\n\t\t\t\tmark_dirty(s, 0);\n\t\t\t\ts->s_flags |= MS_RDONLY;\n\t\t\t}\n\t\t} else if (s->s_flags & MS_RDONLY)\n\t\t\t\tpr_cont(\"; going on - but anything won't be destroyed because it's read-only\\n\");\n\t\telse\n\t\t\tpr_cont(\"; corrupted filesystem mounted read/write - your computer will explode within 20 seconds ... but you wanted it so!\\n\");\n\t} else\n\t\tpr_cont(\"\\n\");\n\thpfs_sb(s)->sb_was_error = 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hpfs_fn.h\"\n\nstatic void hpfs_delete_de(struct super_block *s, struct dnode *d,\n\t\t\t   struct hpfs_dirent *de)\n{\n\tif (de->last) {\n\t\thpfs_error(s, \"attempt to delete last dirent in dnode %08x\", le32_to_cpu(d->self));\n\t\treturn;\n\t}\n\td->first_free = cpu_to_le32(le32_to_cpu(d->first_free) - le16_to_cpu(de->length));\n\tmemmove(de, de_next_de(de), le32_to_cpu(d->first_free) + (char *)d - (char *)de);\n}"
  },
  {
    "function_name": "hpfs_add_de",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/dnode.c",
    "lines": "169-196",
    "snippet": "struct hpfs_dirent *hpfs_add_de(struct super_block *s, struct dnode *d,\n\t\t\t\tconst unsigned char *name,\n\t\t\t\tunsigned namelen, secno down_ptr)\n{\n\tstruct hpfs_dirent *de;\n\tstruct hpfs_dirent *de_end = dnode_end_de(d);\n\tunsigned d_size = de_size(namelen, down_ptr);\n\tfor (de = dnode_first_de(d); de < de_end; de = de_next_de(de)) {\n\t\tint c = hpfs_compare_names(s, name, namelen, de->name, de->namelen, de->last);\n\t\tif (!c) {\n\t\t\thpfs_error(s, \"name (%c,%d) already exists in dnode %08x\", *name, namelen, le32_to_cpu(d->self));\n\t\t\treturn NULL;\n\t\t}\n\t\tif (c < 0) break;\n\t}\n\tmemmove((char *)de + d_size, de, (char *)de_end - (char *)de);\n\tmemset(de, 0, d_size);\n\tif (down_ptr) {\n\t\t*(__le32 *)((char *)de + d_size - 4) = cpu_to_le32(down_ptr);\n\t\tde->down = 1;\n\t}\n\tde->length = cpu_to_le16(d_size);\n\tde->not_8x3 = hpfs_is_name_long(name, namelen);\n\tde->namelen = namelen;\n\tmemcpy(de->name, name, namelen);\n\tle32_add_cpu(&d->first_free, d_size);\n\treturn de;\n}",
    "includes": [
      "#include \"hpfs_fn.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "le32_add_cpu",
          "args": [
            "&d->first_free",
            "d_size"
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "de->name",
            "name",
            "namelen"
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hpfs_is_name_long",
          "args": [
            "name",
            "namelen"
          ],
          "line": 191
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_is_name_long",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/name.c",
          "lines": "92-102",
          "snippet": "int hpfs_is_name_long(const unsigned char *name, unsigned len)\n{\n\tint i,j;\n\tfor (i = 0; i < len && name[i] != '.'; i++)\n\t\tif (no_dos_char(name[i])) return 1;\n\tif (!i || i > 8) return 1;\n\tif (i == len) return 0;\n\tfor (j = i + 1; j < len; j++)\n\t\tif (name[j] == '.' || no_dos_char(name[i])) return 1;\n\treturn j - i > 4;\n}",
          "includes": [
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n\nint hpfs_is_name_long(const unsigned char *name, unsigned len)\n{\n\tint i,j;\n\tfor (i = 0; i < len && name[i] != '.'; i++)\n\t\tif (no_dos_char(name[i])) return 1;\n\tif (!i || i > 8) return 1;\n\tif (i == len) return 0;\n\tfor (j = i + 1; j < len; j++)\n\t\tif (name[j] == '.' || no_dos_char(name[i])) return 1;\n\treturn j - i > 4;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "d_size"
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "down_ptr"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "de",
            "0",
            "d_size"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "(char *)de + d_size",
            "de",
            "(char *)de_end - (char *)de"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hpfs_error",
          "args": [
            "s",
            "\"name (%c,%d) already exists in dnode %08x\"",
            "*name",
            "namelen",
            "le32_to_cpu(d->self)"
          ],
          "line": 179
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/super.c",
          "lines": "57-86",
          "snippet": "void hpfs_error(struct super_block *s, const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvsnprintf(err_buf, sizeof(err_buf), fmt, args);\n\tva_end(args);\n\n\tpr_err(\"filesystem error: %s\", err_buf);\n\tif (!hpfs_sb(s)->sb_was_error) {\n\t\tif (hpfs_sb(s)->sb_err == 2) {\n\t\t\tpr_cont(\"; crashing the system because you wanted it\\n\");\n\t\t\tmark_dirty(s, 0);\n\t\t\tpanic(\"HPFS panic\");\n\t\t} else if (hpfs_sb(s)->sb_err == 1) {\n\t\t\tif (s->s_flags & MS_RDONLY)\n\t\t\t\tpr_cont(\"; already mounted read-only\\n\");\n\t\t\telse {\n\t\t\t\tpr_cont(\"; remounting read-only\\n\");\n\t\t\t\tmark_dirty(s, 0);\n\t\t\t\ts->s_flags |= MS_RDONLY;\n\t\t\t}\n\t\t} else if (s->s_flags & MS_RDONLY)\n\t\t\t\tpr_cont(\"; going on - but anything won't be destroyed because it's read-only\\n\");\n\t\telse\n\t\t\tpr_cont(\"; corrupted filesystem mounted read/write - your computer will explode within 20 seconds ... but you wanted it so!\\n\");\n\t} else\n\t\tpr_cont(\"\\n\");\n\thpfs_sb(s)->sb_was_error = 1;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/sched.h>",
            "#include <linux/magic.h>",
            "#include <linux/statfs.h>",
            "#include <linux/init.h>",
            "#include <linux/parser.h>",
            "#include <linux/module.h>",
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static char err_buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/bitmap.h>\n#include <linux/sched.h>\n#include <linux/magic.h>\n#include <linux/statfs.h>\n#include <linux/init.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include \"hpfs_fn.h\"\n\nstatic char err_buf[1024];\n\nvoid hpfs_error(struct super_block *s, const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvsnprintf(err_buf, sizeof(err_buf), fmt, args);\n\tva_end(args);\n\n\tpr_err(\"filesystem error: %s\", err_buf);\n\tif (!hpfs_sb(s)->sb_was_error) {\n\t\tif (hpfs_sb(s)->sb_err == 2) {\n\t\t\tpr_cont(\"; crashing the system because you wanted it\\n\");\n\t\t\tmark_dirty(s, 0);\n\t\t\tpanic(\"HPFS panic\");\n\t\t} else if (hpfs_sb(s)->sb_err == 1) {\n\t\t\tif (s->s_flags & MS_RDONLY)\n\t\t\t\tpr_cont(\"; already mounted read-only\\n\");\n\t\t\telse {\n\t\t\t\tpr_cont(\"; remounting read-only\\n\");\n\t\t\t\tmark_dirty(s, 0);\n\t\t\t\ts->s_flags |= MS_RDONLY;\n\t\t\t}\n\t\t} else if (s->s_flags & MS_RDONLY)\n\t\t\t\tpr_cont(\"; going on - but anything won't be destroyed because it's read-only\\n\");\n\t\telse\n\t\t\tpr_cont(\"; corrupted filesystem mounted read/write - your computer will explode within 20 seconds ... but you wanted it so!\\n\");\n\t} else\n\t\tpr_cont(\"\\n\");\n\thpfs_sb(s)->sb_was_error = 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "d->self"
          ],
          "line": 179
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_compare_names",
          "args": [
            "s",
            "name",
            "namelen",
            "de->name",
            "de->namelen",
            "de->last"
          ],
          "line": 177
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_compare_names",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/name.c",
          "lines": "74-90",
          "snippet": "int hpfs_compare_names(struct super_block *s,\n\t\t       const unsigned char *n1, unsigned l1,\n\t\t       const unsigned char *n2, unsigned l2, int last)\n{\n\tunsigned l = l1 < l2 ? l1 : l2;\n\tunsigned i;\n\tif (last) return -1;\n\tfor (i = 0; i < l; i++) {\n\t\tunsigned char c1 = upcase(hpfs_sb(s)->sb_cp_table,n1[i]);\n\t\tunsigned char c2 = upcase(hpfs_sb(s)->sb_cp_table,n2[i]);\n\t\tif (c1 < c2) return -1;\n\t\tif (c1 > c2) return 1;\n\t}\n\tif (l1 < l2) return -1;\n\tif (l1 > l2) return 1;\n\treturn 0;\n}",
          "includes": [
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n\nint hpfs_compare_names(struct super_block *s,\n\t\t       const unsigned char *n1, unsigned l1,\n\t\t       const unsigned char *n2, unsigned l2, int last)\n{\n\tunsigned l = l1 < l2 ? l1 : l2;\n\tunsigned i;\n\tif (last) return -1;\n\tfor (i = 0; i < l; i++) {\n\t\tunsigned char c1 = upcase(hpfs_sb(s)->sb_cp_table,n1[i]);\n\t\tunsigned char c2 = upcase(hpfs_sb(s)->sb_cp_table,n2[i]);\n\t\tif (c1 < c2) return -1;\n\t\tif (c1 > c2) return 1;\n\t}\n\tif (l1 < l2) return -1;\n\tif (l1 > l2) return 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "de_next_de",
          "args": [
            "de"
          ],
          "line": 176
        },
        "resolved": true,
        "details": {
          "function_name": "de_next_de",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "123-127",
          "snippet": "static inline struct hpfs_dirent *de_next_de (struct hpfs_dirent *de)\n{\n  CHKCOND(le16_to_cpu(de->length)>=0x20 && le16_to_cpu(de->length)<0x800,(\"HPFS: de_next_de: de->length = %x\\n\",(unsigned)le16_to_cpu(de->length)));\n  return (void *) de + le16_to_cpu(de->length);\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_add_dirent(struct inode *, const unsigned char *, unsigned,\n\t\t    struct hpfs_dirent *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_add_dirent(struct inode *, const unsigned char *, unsigned,\n\t\t    struct hpfs_dirent *);\n\nstatic inline struct hpfs_dirent *de_next_de (struct hpfs_dirent *de)\n{\n  CHKCOND(le16_to_cpu(de->length)>=0x20 && le16_to_cpu(de->length)<0x800,(\"HPFS: de_next_de: de->length = %x\\n\",(unsigned)le16_to_cpu(de->length)));\n  return (void *) de + le16_to_cpu(de->length);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dnode_first_de",
          "args": [
            "d"
          ],
          "line": 176
        },
        "resolved": true,
        "details": {
          "function_name": "dnode_first_de",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "108-111",
          "snippet": "static inline struct hpfs_dirent *dnode_first_de (struct dnode *dnode)\n{\n  return (void *) dnode->dirent;\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_add_dirent(struct inode *, const unsigned char *, unsigned,\n\t\t    struct hpfs_dirent *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_add_dirent(struct inode *, const unsigned char *, unsigned,\n\t\t    struct hpfs_dirent *);\n\nstatic inline struct hpfs_dirent *dnode_first_de (struct dnode *dnode)\n{\n  return (void *) dnode->dirent;\n}"
        }
      },
      {
        "call_info": {
          "callee": "de_size",
          "args": [
            "namelen",
            "down_ptr"
          ],
          "line": 175
        },
        "resolved": true,
        "details": {
          "function_name": "de_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "164-167",
          "snippet": "static inline unsigned de_size(int namelen, secno down_ptr)\n{\n\treturn ((0x1f + namelen + 3) & ~3) + (down_ptr ? 4 : 0);\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_chk_sectors(struct super_block *, secno, int, char *);",
            "secno hpfs_alloc_sector(struct super_block *, secno, unsigned, int);",
            "int hpfs_alloc_if_possible(struct super_block *, secno);",
            "void hpfs_free_sectors(struct super_block *, secno, unsigned);",
            "void hpfs_free_dnode(struct super_block *, secno);",
            "secno hpfs_add_sector_to_btree(struct super_block *, secno, int, unsigned);",
            "int hpfs_ea_read(struct super_block *, secno, int, unsigned, unsigned, char *);",
            "int hpfs_ea_write(struct super_block *, secno, int, unsigned, unsigned, const char *);",
            "void hpfs_ea_remove(struct super_block *, secno, int, unsigned);",
            "void hpfs_truncate_btree(struct super_block *, secno, int, unsigned);",
            "struct hpfs_dirent *hpfs_add_de(struct super_block *, struct dnode *,\n\t\t\t\tconst unsigned char *, unsigned, secno);",
            "void hpfs_ea_ext_remove(struct super_block *, secno, int, unsigned);",
            "unsigned char *hpfs_load_code_page(struct super_block *, secno);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_chk_sectors(struct super_block *, secno, int, char *);\nsecno hpfs_alloc_sector(struct super_block *, secno, unsigned, int);\nint hpfs_alloc_if_possible(struct super_block *, secno);\nvoid hpfs_free_sectors(struct super_block *, secno, unsigned);\nvoid hpfs_free_dnode(struct super_block *, secno);\nsecno hpfs_add_sector_to_btree(struct super_block *, secno, int, unsigned);\nint hpfs_ea_read(struct super_block *, secno, int, unsigned, unsigned, char *);\nint hpfs_ea_write(struct super_block *, secno, int, unsigned, unsigned, const char *);\nvoid hpfs_ea_remove(struct super_block *, secno, int, unsigned);\nvoid hpfs_truncate_btree(struct super_block *, secno, int, unsigned);\nstruct hpfs_dirent *hpfs_add_de(struct super_block *, struct dnode *,\n\t\t\t\tconst unsigned char *, unsigned, secno);\nvoid hpfs_ea_ext_remove(struct super_block *, secno, int, unsigned);\nunsigned char *hpfs_load_code_page(struct super_block *, secno);\n\nstatic inline unsigned de_size(int namelen, secno down_ptr)\n{\n\treturn ((0x1f + namelen + 3) & ~3) + (down_ptr ? 4 : 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dnode_end_de",
          "args": [
            "d"
          ],
          "line": 174
        },
        "resolved": true,
        "details": {
          "function_name": "dnode_end_de",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "115-119",
          "snippet": "static inline struct hpfs_dirent *dnode_end_de (struct dnode *dnode)\n{\n  CHKCOND(le32_to_cpu(dnode->first_free)>=0x14 && le32_to_cpu(dnode->first_free)<=0xa00,(\"HPFS: dnode_end_de: dnode->first_free = %x\\n\",(unsigned)le32_to_cpu(dnode->first_free)));\n  return (void *) dnode + le32_to_cpu(dnode->first_free);\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_add_dirent(struct inode *, const unsigned char *, unsigned,\n\t\t    struct hpfs_dirent *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_add_dirent(struct inode *, const unsigned char *, unsigned,\n\t\t    struct hpfs_dirent *);\n\nstatic inline struct hpfs_dirent *dnode_end_de (struct dnode *dnode)\n{\n  CHKCOND(le32_to_cpu(dnode->first_free)>=0x14 && le32_to_cpu(dnode->first_free)<=0xa00,(\"HPFS: dnode_end_de: dnode->first_free = %x\\n\",(unsigned)le32_to_cpu(dnode->first_free)));\n  return (void *) dnode + le32_to_cpu(dnode->first_free);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hpfs_fn.h\"\n\nstruct hpfs_dirent *hpfs_add_de(struct super_block *s, struct dnode *d,\n\t\t\t\tconst unsigned char *name,\n\t\t\t\tunsigned namelen, secno down_ptr)\n{\n\tstruct hpfs_dirent *de;\n\tstruct hpfs_dirent *de_end = dnode_end_de(d);\n\tunsigned d_size = de_size(namelen, down_ptr);\n\tfor (de = dnode_first_de(d); de < de_end; de = de_next_de(de)) {\n\t\tint c = hpfs_compare_names(s, name, namelen, de->name, de->namelen, de->last);\n\t\tif (!c) {\n\t\t\thpfs_error(s, \"name (%c,%d) already exists in dnode %08x\", *name, namelen, le32_to_cpu(d->self));\n\t\t\treturn NULL;\n\t\t}\n\t\tif (c < 0) break;\n\t}\n\tmemmove((char *)de + d_size, de, (char *)de_end - (char *)de);\n\tmemset(de, 0, d_size);\n\tif (down_ptr) {\n\t\t*(__le32 *)((char *)de + d_size - 4) = cpu_to_le32(down_ptr);\n\t\tde->down = 1;\n\t}\n\tde->length = cpu_to_le16(d_size);\n\tde->not_8x3 = hpfs_is_name_long(name, namelen);\n\tde->namelen = namelen;\n\tmemcpy(de->name, name, namelen);\n\tle32_add_cpu(&d->first_free, d_size);\n\treturn de;\n}"
  },
  {
    "function_name": "set_last_pointer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/dnode.c",
    "lines": "136-165",
    "snippet": "static void set_last_pointer(struct super_block *s, struct dnode *d, dnode_secno ptr)\n{\n\tstruct hpfs_dirent *de;\n\tif (!(de = dnode_last_de(d))) {\n\t\thpfs_error(s, \"set_last_pointer: empty dnode %08x\", le32_to_cpu(d->self));\n\t\treturn;\n\t}\n\tif (hpfs_sb(s)->sb_chk) {\n\t\tif (de->down) {\n\t\t\thpfs_error(s, \"set_last_pointer: dnode %08x has already last pointer %08x\",\n\t\t\t\tle32_to_cpu(d->self), de_down_pointer(de));\n\t\t\treturn;\n\t\t}\n\t\tif (le16_to_cpu(de->length) != 32) {\n\t\t\thpfs_error(s, \"set_last_pointer: bad last dirent in dnode %08x\", le32_to_cpu(d->self));\n\t\t\treturn;\n\t\t}\n\t}\n\tif (ptr) {\n\t\tle32_add_cpu(&d->first_free, 4);\n\t\tif (le32_to_cpu(d->first_free) > 2048) {\n\t\t\thpfs_error(s, \"set_last_pointer: too long dnode %08x\", le32_to_cpu(d->self));\n\t\t\tle32_add_cpu(&d->first_free, -4);\n\t\t\treturn;\n\t\t}\n\t\tde->length = cpu_to_le16(36);\n\t\tde->down = 1;\n\t\t*(__le32 *)((char *)de + 32) = cpu_to_le32(ptr);\n\t}\n}",
    "includes": [
      "#include \"hpfs_fn.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "ptr"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "36"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_add_cpu",
          "args": [
            "&d->first_free",
            "-4"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hpfs_error",
          "args": [
            "s",
            "\"set_last_pointer: too long dnode %08x\"",
            "le32_to_cpu(d->self)"
          ],
          "line": 157
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/super.c",
          "lines": "57-86",
          "snippet": "void hpfs_error(struct super_block *s, const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvsnprintf(err_buf, sizeof(err_buf), fmt, args);\n\tva_end(args);\n\n\tpr_err(\"filesystem error: %s\", err_buf);\n\tif (!hpfs_sb(s)->sb_was_error) {\n\t\tif (hpfs_sb(s)->sb_err == 2) {\n\t\t\tpr_cont(\"; crashing the system because you wanted it\\n\");\n\t\t\tmark_dirty(s, 0);\n\t\t\tpanic(\"HPFS panic\");\n\t\t} else if (hpfs_sb(s)->sb_err == 1) {\n\t\t\tif (s->s_flags & MS_RDONLY)\n\t\t\t\tpr_cont(\"; already mounted read-only\\n\");\n\t\t\telse {\n\t\t\t\tpr_cont(\"; remounting read-only\\n\");\n\t\t\t\tmark_dirty(s, 0);\n\t\t\t\ts->s_flags |= MS_RDONLY;\n\t\t\t}\n\t\t} else if (s->s_flags & MS_RDONLY)\n\t\t\t\tpr_cont(\"; going on - but anything won't be destroyed because it's read-only\\n\");\n\t\telse\n\t\t\tpr_cont(\"; corrupted filesystem mounted read/write - your computer will explode within 20 seconds ... but you wanted it so!\\n\");\n\t} else\n\t\tpr_cont(\"\\n\");\n\thpfs_sb(s)->sb_was_error = 1;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/sched.h>",
            "#include <linux/magic.h>",
            "#include <linux/statfs.h>",
            "#include <linux/init.h>",
            "#include <linux/parser.h>",
            "#include <linux/module.h>",
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static char err_buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/bitmap.h>\n#include <linux/sched.h>\n#include <linux/magic.h>\n#include <linux/statfs.h>\n#include <linux/init.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include \"hpfs_fn.h\"\n\nstatic char err_buf[1024];\n\nvoid hpfs_error(struct super_block *s, const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvsnprintf(err_buf, sizeof(err_buf), fmt, args);\n\tva_end(args);\n\n\tpr_err(\"filesystem error: %s\", err_buf);\n\tif (!hpfs_sb(s)->sb_was_error) {\n\t\tif (hpfs_sb(s)->sb_err == 2) {\n\t\t\tpr_cont(\"; crashing the system because you wanted it\\n\");\n\t\t\tmark_dirty(s, 0);\n\t\t\tpanic(\"HPFS panic\");\n\t\t} else if (hpfs_sb(s)->sb_err == 1) {\n\t\t\tif (s->s_flags & MS_RDONLY)\n\t\t\t\tpr_cont(\"; already mounted read-only\\n\");\n\t\t\telse {\n\t\t\t\tpr_cont(\"; remounting read-only\\n\");\n\t\t\t\tmark_dirty(s, 0);\n\t\t\t\ts->s_flags |= MS_RDONLY;\n\t\t\t}\n\t\t} else if (s->s_flags & MS_RDONLY)\n\t\t\t\tpr_cont(\"; going on - but anything won't be destroyed because it's read-only\\n\");\n\t\telse\n\t\t\tpr_cont(\"; corrupted filesystem mounted read/write - your computer will explode within 20 seconds ... but you wanted it so!\\n\");\n\t} else\n\t\tpr_cont(\"\\n\");\n\thpfs_sb(s)->sb_was_error = 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "d->self"
          ],
          "line": 157
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_add_cpu",
          "args": [
            "&d->first_free",
            "4"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "de->length"
          ],
          "line": 149
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "de_down_pointer",
          "args": [
            "de"
          ],
          "line": 146
        },
        "resolved": true,
        "details": {
          "function_name": "de_down_pointer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "100-104",
          "snippet": "static inline dnode_secno de_down_pointer (struct hpfs_dirent *de)\n{\n  CHKCOND(de->down,(\"HPFS: de_down_pointer: !de->down\\n\"));\n  return le32_to_cpu(*(__le32 *) ((void *) de + le16_to_cpu(de->length) - 4));\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_add_dirent(struct inode *, const unsigned char *, unsigned,\n\t\t    struct hpfs_dirent *);",
            "void hpfs_count_dnodes(struct super_block *, dnode_secno, int *, int *, int *);",
            "void hpfs_remove_dtree(struct super_block *, dnode_secno);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_add_dirent(struct inode *, const unsigned char *, unsigned,\n\t\t    struct hpfs_dirent *);\nvoid hpfs_count_dnodes(struct super_block *, dnode_secno, int *, int *, int *);\nvoid hpfs_remove_dtree(struct super_block *, dnode_secno);\n\nstatic inline dnode_secno de_down_pointer (struct hpfs_dirent *de)\n{\n  CHKCOND(de->down,(\"HPFS: de_down_pointer: !de->down\\n\"));\n  return le32_to_cpu(*(__le32 *) ((void *) de + le16_to_cpu(de->length) - 4));\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_sb",
          "args": [
            "s"
          ],
          "line": 143
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_sb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "310-313",
          "snippet": "static inline struct hpfs_sb_info *hpfs_sb(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_check_free_dnodes(struct super_block *, int);",
            "void hpfs_prefetch_sectors(struct super_block *, unsigned, int);",
            "void hpfs_prefetch_bitmap(struct super_block *, unsigned);",
            "unsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);",
            "int hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);",
            "void hpfs_error(struct super_block *, const char *, ...);",
            "int hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);",
            "unsigned hpfs_get_free_dnodes(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_check_free_dnodes(struct super_block *, int);\nvoid hpfs_prefetch_sectors(struct super_block *, unsigned, int);\nvoid hpfs_prefetch_bitmap(struct super_block *, unsigned);\nunsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);\nint hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);\nvoid hpfs_error(struct super_block *, const char *, ...);\nint hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);\nunsigned hpfs_get_free_dnodes(struct super_block *);\n\nstatic inline struct hpfs_sb_info *hpfs_sb(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dnode_last_de",
          "args": [
            "d"
          ],
          "line": 139
        },
        "resolved": true,
        "details": {
          "function_name": "dnode_last_de",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/dnode.c",
          "lines": "126-134",
          "snippet": "static struct hpfs_dirent *dnode_last_de(struct dnode *d)\n{\n\tstruct hpfs_dirent *de, *de_end, *dee = NULL;\n\tde_end = dnode_end_de(d);\n\tfor (de = dnode_first_de(d); de < de_end; de = de_next_de(de)) {\n\t\tdee = de;\n\t}\t\n\treturn dee;\n}",
          "includes": [
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n\nstatic struct hpfs_dirent *dnode_last_de(struct dnode *d)\n{\n\tstruct hpfs_dirent *de, *de_end, *dee = NULL;\n\tde_end = dnode_end_de(d);\n\tfor (de = dnode_first_de(d); de < de_end; de = de_next_de(de)) {\n\t\tdee = de;\n\t}\t\n\treturn dee;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hpfs_fn.h\"\n\nstatic void set_last_pointer(struct super_block *s, struct dnode *d, dnode_secno ptr)\n{\n\tstruct hpfs_dirent *de;\n\tif (!(de = dnode_last_de(d))) {\n\t\thpfs_error(s, \"set_last_pointer: empty dnode %08x\", le32_to_cpu(d->self));\n\t\treturn;\n\t}\n\tif (hpfs_sb(s)->sb_chk) {\n\t\tif (de->down) {\n\t\t\thpfs_error(s, \"set_last_pointer: dnode %08x has already last pointer %08x\",\n\t\t\t\tle32_to_cpu(d->self), de_down_pointer(de));\n\t\t\treturn;\n\t\t}\n\t\tif (le16_to_cpu(de->length) != 32) {\n\t\t\thpfs_error(s, \"set_last_pointer: bad last dirent in dnode %08x\", le32_to_cpu(d->self));\n\t\t\treturn;\n\t\t}\n\t}\n\tif (ptr) {\n\t\tle32_add_cpu(&d->first_free, 4);\n\t\tif (le32_to_cpu(d->first_free) > 2048) {\n\t\t\thpfs_error(s, \"set_last_pointer: too long dnode %08x\", le32_to_cpu(d->self));\n\t\t\tle32_add_cpu(&d->first_free, -4);\n\t\t\treturn;\n\t\t}\n\t\tde->length = cpu_to_le16(36);\n\t\tde->down = 1;\n\t\t*(__le32 *)((char *)de + 32) = cpu_to_le32(ptr);\n\t}\n}"
  },
  {
    "function_name": "dnode_last_de",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/dnode.c",
    "lines": "126-134",
    "snippet": "static struct hpfs_dirent *dnode_last_de(struct dnode *d)\n{\n\tstruct hpfs_dirent *de, *de_end, *dee = NULL;\n\tde_end = dnode_end_de(d);\n\tfor (de = dnode_first_de(d); de < de_end; de = de_next_de(de)) {\n\t\tdee = de;\n\t}\t\n\treturn dee;\n}",
    "includes": [
      "#include \"hpfs_fn.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "de_next_de",
          "args": [
            "de"
          ],
          "line": 130
        },
        "resolved": true,
        "details": {
          "function_name": "de_next_de",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "123-127",
          "snippet": "static inline struct hpfs_dirent *de_next_de (struct hpfs_dirent *de)\n{\n  CHKCOND(le16_to_cpu(de->length)>=0x20 && le16_to_cpu(de->length)<0x800,(\"HPFS: de_next_de: de->length = %x\\n\",(unsigned)le16_to_cpu(de->length)));\n  return (void *) de + le16_to_cpu(de->length);\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_add_dirent(struct inode *, const unsigned char *, unsigned,\n\t\t    struct hpfs_dirent *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_add_dirent(struct inode *, const unsigned char *, unsigned,\n\t\t    struct hpfs_dirent *);\n\nstatic inline struct hpfs_dirent *de_next_de (struct hpfs_dirent *de)\n{\n  CHKCOND(le16_to_cpu(de->length)>=0x20 && le16_to_cpu(de->length)<0x800,(\"HPFS: de_next_de: de->length = %x\\n\",(unsigned)le16_to_cpu(de->length)));\n  return (void *) de + le16_to_cpu(de->length);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dnode_first_de",
          "args": [
            "d"
          ],
          "line": 130
        },
        "resolved": true,
        "details": {
          "function_name": "dnode_first_de",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "108-111",
          "snippet": "static inline struct hpfs_dirent *dnode_first_de (struct dnode *dnode)\n{\n  return (void *) dnode->dirent;\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_add_dirent(struct inode *, const unsigned char *, unsigned,\n\t\t    struct hpfs_dirent *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_add_dirent(struct inode *, const unsigned char *, unsigned,\n\t\t    struct hpfs_dirent *);\n\nstatic inline struct hpfs_dirent *dnode_first_de (struct dnode *dnode)\n{\n  return (void *) dnode->dirent;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dnode_end_de",
          "args": [
            "d"
          ],
          "line": 129
        },
        "resolved": true,
        "details": {
          "function_name": "dnode_end_de",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "115-119",
          "snippet": "static inline struct hpfs_dirent *dnode_end_de (struct dnode *dnode)\n{\n  CHKCOND(le32_to_cpu(dnode->first_free)>=0x14 && le32_to_cpu(dnode->first_free)<=0xa00,(\"HPFS: dnode_end_de: dnode->first_free = %x\\n\",(unsigned)le32_to_cpu(dnode->first_free)));\n  return (void *) dnode + le32_to_cpu(dnode->first_free);\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_add_dirent(struct inode *, const unsigned char *, unsigned,\n\t\t    struct hpfs_dirent *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_add_dirent(struct inode *, const unsigned char *, unsigned,\n\t\t    struct hpfs_dirent *);\n\nstatic inline struct hpfs_dirent *dnode_end_de (struct dnode *dnode)\n{\n  CHKCOND(le32_to_cpu(dnode->first_free)>=0x14 && le32_to_cpu(dnode->first_free)<=0xa00,(\"HPFS: dnode_end_de: dnode->first_free = %x\\n\",(unsigned)le32_to_cpu(dnode->first_free)));\n  return (void *) dnode + le32_to_cpu(dnode->first_free);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hpfs_fn.h\"\n\nstatic struct hpfs_dirent *dnode_last_de(struct dnode *d)\n{\n\tstruct hpfs_dirent *de, *de_end, *dee = NULL;\n\tde_end = dnode_end_de(d);\n\tfor (de = dnode_first_de(d); de < de_end; de = de_next_de(de)) {\n\t\tdee = de;\n\t}\t\n\treturn dee;\n}"
  },
  {
    "function_name": "dnode_pre_last_de",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/dnode.c",
    "lines": "116-124",
    "snippet": "static struct hpfs_dirent *dnode_pre_last_de(struct dnode *d)\n{\n\tstruct hpfs_dirent *de, *de_end, *dee = NULL, *deee = NULL;\n\tde_end = dnode_end_de(d);\n\tfor (de = dnode_first_de(d); de < de_end; de = de_next_de(de)) {\n\t\tdeee = dee; dee = de;\n\t}\t\n\treturn deee;\n}",
    "includes": [
      "#include \"hpfs_fn.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "de_next_de",
          "args": [
            "de"
          ],
          "line": 120
        },
        "resolved": true,
        "details": {
          "function_name": "de_next_de",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "123-127",
          "snippet": "static inline struct hpfs_dirent *de_next_de (struct hpfs_dirent *de)\n{\n  CHKCOND(le16_to_cpu(de->length)>=0x20 && le16_to_cpu(de->length)<0x800,(\"HPFS: de_next_de: de->length = %x\\n\",(unsigned)le16_to_cpu(de->length)));\n  return (void *) de + le16_to_cpu(de->length);\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_add_dirent(struct inode *, const unsigned char *, unsigned,\n\t\t    struct hpfs_dirent *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_add_dirent(struct inode *, const unsigned char *, unsigned,\n\t\t    struct hpfs_dirent *);\n\nstatic inline struct hpfs_dirent *de_next_de (struct hpfs_dirent *de)\n{\n  CHKCOND(le16_to_cpu(de->length)>=0x20 && le16_to_cpu(de->length)<0x800,(\"HPFS: de_next_de: de->length = %x\\n\",(unsigned)le16_to_cpu(de->length)));\n  return (void *) de + le16_to_cpu(de->length);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dnode_first_de",
          "args": [
            "d"
          ],
          "line": 120
        },
        "resolved": true,
        "details": {
          "function_name": "dnode_first_de",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "108-111",
          "snippet": "static inline struct hpfs_dirent *dnode_first_de (struct dnode *dnode)\n{\n  return (void *) dnode->dirent;\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_add_dirent(struct inode *, const unsigned char *, unsigned,\n\t\t    struct hpfs_dirent *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_add_dirent(struct inode *, const unsigned char *, unsigned,\n\t\t    struct hpfs_dirent *);\n\nstatic inline struct hpfs_dirent *dnode_first_de (struct dnode *dnode)\n{\n  return (void *) dnode->dirent;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dnode_end_de",
          "args": [
            "d"
          ],
          "line": 119
        },
        "resolved": true,
        "details": {
          "function_name": "dnode_end_de",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "115-119",
          "snippet": "static inline struct hpfs_dirent *dnode_end_de (struct dnode *dnode)\n{\n  CHKCOND(le32_to_cpu(dnode->first_free)>=0x14 && le32_to_cpu(dnode->first_free)<=0xa00,(\"HPFS: dnode_end_de: dnode->first_free = %x\\n\",(unsigned)le32_to_cpu(dnode->first_free)));\n  return (void *) dnode + le32_to_cpu(dnode->first_free);\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_add_dirent(struct inode *, const unsigned char *, unsigned,\n\t\t    struct hpfs_dirent *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_add_dirent(struct inode *, const unsigned char *, unsigned,\n\t\t    struct hpfs_dirent *);\n\nstatic inline struct hpfs_dirent *dnode_end_de (struct dnode *dnode)\n{\n  CHKCOND(le32_to_cpu(dnode->first_free)>=0x14 && le32_to_cpu(dnode->first_free)<=0xa00,(\"HPFS: dnode_end_de: dnode->first_free = %x\\n\",(unsigned)le32_to_cpu(dnode->first_free)));\n  return (void *) dnode + le32_to_cpu(dnode->first_free);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hpfs_fn.h\"\n\nstatic struct hpfs_dirent *dnode_pre_last_de(struct dnode *d)\n{\n\tstruct hpfs_dirent *de, *de_end, *dee = NULL, *deee = NULL;\n\tde_end = dnode_end_de(d);\n\tfor (de = dnode_first_de(d); de < de_end; de = de_next_de(de)) {\n\t\tdeee = dee; dee = de;\n\t}\t\n\treturn deee;\n}"
  },
  {
    "function_name": "hpfs_pos_del",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/dnode.c",
    "lines": "104-114",
    "snippet": "static void hpfs_pos_del(loff_t *p, loff_t d, loff_t c)\n{\n\tif ((*p & ~0x3f) == (d & ~0x3f) && (*p & 0x3f) >= (d & 0x3f)) {\n\t\tint n = (*p & 0x3f) - c;\n\t\tif (n < 1)\n\t\t\tpr_err(\"%s(): %08x - %d\\n\",\n\t\t\t\t__func__, (int)*p, (int)c >> 8);\n\t\telse\n\t\t\t*p = (*p & ~0x3f) | n;\n\t}\n}",
    "includes": [
      "#include \"hpfs_fn.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%s(): %08x - %d\\n\"",
            "__func__",
            "(int)*p",
            "(int)c >> 8"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"hpfs_fn.h\"\n\nstatic void hpfs_pos_del(loff_t *p, loff_t d, loff_t c)\n{\n\tif ((*p & ~0x3f) == (d & ~0x3f) && (*p & 0x3f) >= (d & 0x3f)) {\n\t\tint n = (*p & 0x3f) - c;\n\t\tif (n < 1)\n\t\t\tpr_err(\"%s(): %08x - %d\\n\",\n\t\t\t\t__func__, (int)*p, (int)c >> 8);\n\t\telse\n\t\t\t*p = (*p & ~0x3f) | n;\n\t}\n}"
  },
  {
    "function_name": "hpfs_pos_ins",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/dnode.c",
    "lines": "92-102",
    "snippet": "static void hpfs_pos_ins(loff_t *p, loff_t d, loff_t c)\n{\n\tif ((*p & ~0x3f) == (d & ~0x3f) && (*p & 0x3f) >= (d & 0x3f)) {\n\t\tint n = (*p & 0x3f) + c;\n\t\tif (n > 0x3f)\n\t\t\tpr_err(\"%s(): %08x + %d\\n\",\n\t\t\t\t__func__, (int)*p, (int)c >> 8);\n\t\telse\n\t\t\t*p = (*p & ~0x3f) | n;\n\t}\n}",
    "includes": [
      "#include \"hpfs_fn.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%s(): %08x + %d\\n\"",
            "__func__",
            "(int)*p",
            "(int)c >> 8"
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"hpfs_fn.h\"\n\nstatic void hpfs_pos_ins(loff_t *p, loff_t d, loff_t c)\n{\n\tif ((*p & ~0x3f) == (d & ~0x3f) && (*p & 0x3f) >= (d & 0x3f)) {\n\t\tint n = (*p & 0x3f) + c;\n\t\tif (n > 0x3f)\n\t\t\tpr_err(\"%s(): %08x + %d\\n\",\n\t\t\t\t__func__, (int)*p, (int)c >> 8);\n\t\telse\n\t\t\t*p = (*p & ~0x3f) | n;\n\t}\n}"
  },
  {
    "function_name": "hpfs_pos_subst",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/dnode.c",
    "lines": "82-85",
    "snippet": "static void hpfs_pos_subst(loff_t *p, loff_t f, loff_t t)\n{\n\tif (*p == f) *p = t;\n}",
    "includes": [
      "#include \"hpfs_fn.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"hpfs_fn.h\"\n\nstatic void hpfs_pos_subst(loff_t *p, loff_t f, loff_t t)\n{\n\tif (*p == f) *p = t;\n}"
  },
  {
    "function_name": "for_all_poss",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/dnode.c",
    "lines": "71-80",
    "snippet": "static void for_all_poss(struct inode *inode, void (*f)(loff_t *, loff_t, loff_t),\n\t\t\t loff_t p1, loff_t p2)\n{\n\tstruct hpfs_inode_info *hpfs_inode = hpfs_i(inode);\n\tloff_t **i;\n\n\tif (!hpfs_inode->i_rddir_off) return;\n\tfor (i = hpfs_inode->i_rddir_off; *i; i++) (*f)(*i, p1, p2);\n\treturn;\n}",
    "includes": [
      "#include \"hpfs_fn.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "",
          "args": [
            "*i",
            "p1",
            "p2"
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hpfs_i",
          "args": [
            "inode"
          ],
          "line": 74
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_i",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "305-308",
          "snippet": "static inline struct hpfs_inode_info *hpfs_i(struct inode *inode)\n{\n\treturn list_entry(inode, struct hpfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void hpfs_truncate(struct inode *);",
            "void hpfs_init_inode(struct inode *);",
            "void hpfs_read_inode(struct inode *);",
            "void hpfs_write_inode(struct inode *);",
            "void hpfs_write_inode_nolock(struct inode *);",
            "void hpfs_write_if_changed(struct inode *);",
            "void hpfs_evict_inode(struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nvoid hpfs_truncate(struct inode *);\nvoid hpfs_init_inode(struct inode *);\nvoid hpfs_read_inode(struct inode *);\nvoid hpfs_write_inode(struct inode *);\nvoid hpfs_write_inode_nolock(struct inode *);\nvoid hpfs_write_if_changed(struct inode *);\nvoid hpfs_evict_inode(struct inode *);\n\nstatic inline struct hpfs_inode_info *hpfs_i(struct inode *inode)\n{\n\treturn list_entry(inode, struct hpfs_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hpfs_fn.h\"\n\nstatic void for_all_poss(struct inode *inode, void (*f)(loff_t *, loff_t, loff_t),\n\t\t\t loff_t p1, loff_t p2)\n{\n\tstruct hpfs_inode_info *hpfs_inode = hpfs_i(inode);\n\tloff_t **i;\n\n\tif (!hpfs_inode->i_rddir_off) return;\n\tfor (i = hpfs_inode->i_rddir_off; *i; i++) (*f)(*i, p1, p2);\n\treturn;\n}"
  },
  {
    "function_name": "hpfs_del_pos",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/dnode.c",
    "lines": "48-69",
    "snippet": "void hpfs_del_pos(struct inode *inode, loff_t *pos)\n{\n\tstruct hpfs_inode_info *hpfs_inode = hpfs_i(inode);\n\tloff_t **i, **j;\n\n\tif (!hpfs_inode->i_rddir_off) goto not_f;\n\tfor (i = hpfs_inode->i_rddir_off; *i; i++) if (*i == pos) goto fnd;\n\tgoto not_f;\n\tfnd:\n\tfor (j = i + 1; *j; j++) ;\n\t*i = *(j - 1);\n\t*(j - 1) = NULL;\n\tif (j - 1 == hpfs_inode->i_rddir_off) {\n\t\tkfree(hpfs_inode->i_rddir_off);\n\t\thpfs_inode->i_rddir_off = NULL;\n\t}\n\treturn;\n\tnot_f:\n\t/*pr_warn(\"position pointer %p->%08x not found\\n\",\n\t\t  pos, (int)*pos);*/\n\treturn;\n}",
    "includes": [
      "#include \"hpfs_fn.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "hpfs_inode->i_rddir_off"
          ],
          "line": 61
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hpfs_i",
          "args": [
            "inode"
          ],
          "line": 50
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_i",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "305-308",
          "snippet": "static inline struct hpfs_inode_info *hpfs_i(struct inode *inode)\n{\n\treturn list_entry(inode, struct hpfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void hpfs_truncate(struct inode *);",
            "void hpfs_init_inode(struct inode *);",
            "void hpfs_read_inode(struct inode *);",
            "void hpfs_write_inode(struct inode *);",
            "void hpfs_write_inode_nolock(struct inode *);",
            "void hpfs_write_if_changed(struct inode *);",
            "void hpfs_evict_inode(struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nvoid hpfs_truncate(struct inode *);\nvoid hpfs_init_inode(struct inode *);\nvoid hpfs_read_inode(struct inode *);\nvoid hpfs_write_inode(struct inode *);\nvoid hpfs_write_inode_nolock(struct inode *);\nvoid hpfs_write_if_changed(struct inode *);\nvoid hpfs_evict_inode(struct inode *);\n\nstatic inline struct hpfs_inode_info *hpfs_i(struct inode *inode)\n{\n\treturn list_entry(inode, struct hpfs_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hpfs_fn.h\"\n\nvoid hpfs_del_pos(struct inode *inode, loff_t *pos)\n{\n\tstruct hpfs_inode_info *hpfs_inode = hpfs_i(inode);\n\tloff_t **i, **j;\n\n\tif (!hpfs_inode->i_rddir_off) goto not_f;\n\tfor (i = hpfs_inode->i_rddir_off; *i; i++) if (*i == pos) goto fnd;\n\tgoto not_f;\n\tfnd:\n\tfor (j = i + 1; *j; j++) ;\n\t*i = *(j - 1);\n\t*(j - 1) = NULL;\n\tif (j - 1 == hpfs_inode->i_rddir_off) {\n\t\tkfree(hpfs_inode->i_rddir_off);\n\t\thpfs_inode->i_rddir_off = NULL;\n\t}\n\treturn;\n\tnot_f:\n\t/*pr_warn(\"position pointer %p->%08x not found\\n\",\n\t\t  pos, (int)*pos);*/\n\treturn;\n}"
  },
  {
    "function_name": "hpfs_add_pos",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/dnode.c",
    "lines": "24-46",
    "snippet": "void hpfs_add_pos(struct inode *inode, loff_t *pos)\n{\n\tstruct hpfs_inode_info *hpfs_inode = hpfs_i(inode);\n\tint i = 0;\n\tloff_t **ppos;\n\n\tif (hpfs_inode->i_rddir_off)\n\t\tfor (; hpfs_inode->i_rddir_off[i]; i++)\n\t\t\tif (hpfs_inode->i_rddir_off[i] == pos) return;\n\tif (!(i&0x0f)) {\n\t\tif (!(ppos = kmalloc((i+0x11) * sizeof(loff_t*), GFP_NOFS))) {\n\t\t\tpr_err(\"out of memory for position list\\n\");\n\t\t\treturn;\n\t\t}\n\t\tif (hpfs_inode->i_rddir_off) {\n\t\t\tmemcpy(ppos, hpfs_inode->i_rddir_off, i * sizeof(loff_t));\n\t\t\tkfree(hpfs_inode->i_rddir_off);\n\t\t}\n\t\thpfs_inode->i_rddir_off = ppos;\n\t}\n\thpfs_inode->i_rddir_off[i] = pos;\n\thpfs_inode->i_rddir_off[i + 1] = NULL;\n}",
    "includes": [
      "#include \"hpfs_fn.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "hpfs_inode->i_rddir_off"
          ],
          "line": 40
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "ppos",
            "hpfs_inode->i_rddir_off",
            "i * sizeof(loff_t)"
          ],
          "line": 39
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"out of memory for position list\\n\""
          ],
          "line": 35
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "(i+0x11) * sizeof(loff_t*)",
            "GFP_NOFS"
          ],
          "line": 34
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_i",
          "args": [
            "inode"
          ],
          "line": 26
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_i",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "305-308",
          "snippet": "static inline struct hpfs_inode_info *hpfs_i(struct inode *inode)\n{\n\treturn list_entry(inode, struct hpfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void hpfs_truncate(struct inode *);",
            "void hpfs_init_inode(struct inode *);",
            "void hpfs_read_inode(struct inode *);",
            "void hpfs_write_inode(struct inode *);",
            "void hpfs_write_inode_nolock(struct inode *);",
            "void hpfs_write_if_changed(struct inode *);",
            "void hpfs_evict_inode(struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nvoid hpfs_truncate(struct inode *);\nvoid hpfs_init_inode(struct inode *);\nvoid hpfs_read_inode(struct inode *);\nvoid hpfs_write_inode(struct inode *);\nvoid hpfs_write_inode_nolock(struct inode *);\nvoid hpfs_write_if_changed(struct inode *);\nvoid hpfs_evict_inode(struct inode *);\n\nstatic inline struct hpfs_inode_info *hpfs_i(struct inode *inode)\n{\n\treturn list_entry(inode, struct hpfs_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hpfs_fn.h\"\n\nvoid hpfs_add_pos(struct inode *inode, loff_t *pos)\n{\n\tstruct hpfs_inode_info *hpfs_inode = hpfs_i(inode);\n\tint i = 0;\n\tloff_t **ppos;\n\n\tif (hpfs_inode->i_rddir_off)\n\t\tfor (; hpfs_inode->i_rddir_off[i]; i++)\n\t\t\tif (hpfs_inode->i_rddir_off[i] == pos) return;\n\tif (!(i&0x0f)) {\n\t\tif (!(ppos = kmalloc((i+0x11) * sizeof(loff_t*), GFP_NOFS))) {\n\t\t\tpr_err(\"out of memory for position list\\n\");\n\t\t\treturn;\n\t\t}\n\t\tif (hpfs_inode->i_rddir_off) {\n\t\t\tmemcpy(ppos, hpfs_inode->i_rddir_off, i * sizeof(loff_t));\n\t\t\tkfree(hpfs_inode->i_rddir_off);\n\t\t}\n\t\thpfs_inode->i_rddir_off = ppos;\n\t}\n\thpfs_inode->i_rddir_off[i] = pos;\n\thpfs_inode->i_rddir_off[i + 1] = NULL;\n}"
  },
  {
    "function_name": "get_pos",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/dnode.c",
    "lines": "11-22",
    "snippet": "static loff_t get_pos(struct dnode *d, struct hpfs_dirent *fde)\n{\n\tstruct hpfs_dirent *de;\n\tstruct hpfs_dirent *de_end = dnode_end_de(d);\n\tint i = 1;\n\tfor (de = dnode_first_de(d); de < de_end; de = de_next_de(de)) {\n\t\tif (de == fde) return ((loff_t) le32_to_cpu(d->self) << 4) | (loff_t)i;\n\t\ti++;\n\t}\n\tpr_info(\"%s(): not_found\\n\", __func__);\n\treturn ((loff_t)le32_to_cpu(d->self) << 4) | (loff_t)1;\n}",
    "includes": [
      "#include \"hpfs_fn.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "d->self"
          ],
          "line": 21
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"%s(): not_found\\n\"",
            "__func__"
          ],
          "line": 20
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "de_next_de",
          "args": [
            "de"
          ],
          "line": 16
        },
        "resolved": true,
        "details": {
          "function_name": "de_next_de",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "123-127",
          "snippet": "static inline struct hpfs_dirent *de_next_de (struct hpfs_dirent *de)\n{\n  CHKCOND(le16_to_cpu(de->length)>=0x20 && le16_to_cpu(de->length)<0x800,(\"HPFS: de_next_de: de->length = %x\\n\",(unsigned)le16_to_cpu(de->length)));\n  return (void *) de + le16_to_cpu(de->length);\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_add_dirent(struct inode *, const unsigned char *, unsigned,\n\t\t    struct hpfs_dirent *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_add_dirent(struct inode *, const unsigned char *, unsigned,\n\t\t    struct hpfs_dirent *);\n\nstatic inline struct hpfs_dirent *de_next_de (struct hpfs_dirent *de)\n{\n  CHKCOND(le16_to_cpu(de->length)>=0x20 && le16_to_cpu(de->length)<0x800,(\"HPFS: de_next_de: de->length = %x\\n\",(unsigned)le16_to_cpu(de->length)));\n  return (void *) de + le16_to_cpu(de->length);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dnode_first_de",
          "args": [
            "d"
          ],
          "line": 16
        },
        "resolved": true,
        "details": {
          "function_name": "dnode_first_de",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "108-111",
          "snippet": "static inline struct hpfs_dirent *dnode_first_de (struct dnode *dnode)\n{\n  return (void *) dnode->dirent;\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_add_dirent(struct inode *, const unsigned char *, unsigned,\n\t\t    struct hpfs_dirent *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_add_dirent(struct inode *, const unsigned char *, unsigned,\n\t\t    struct hpfs_dirent *);\n\nstatic inline struct hpfs_dirent *dnode_first_de (struct dnode *dnode)\n{\n  return (void *) dnode->dirent;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dnode_end_de",
          "args": [
            "d"
          ],
          "line": 14
        },
        "resolved": true,
        "details": {
          "function_name": "dnode_end_de",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "115-119",
          "snippet": "static inline struct hpfs_dirent *dnode_end_de (struct dnode *dnode)\n{\n  CHKCOND(le32_to_cpu(dnode->first_free)>=0x14 && le32_to_cpu(dnode->first_free)<=0xa00,(\"HPFS: dnode_end_de: dnode->first_free = %x\\n\",(unsigned)le32_to_cpu(dnode->first_free)));\n  return (void *) dnode + le32_to_cpu(dnode->first_free);\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_add_dirent(struct inode *, const unsigned char *, unsigned,\n\t\t    struct hpfs_dirent *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_add_dirent(struct inode *, const unsigned char *, unsigned,\n\t\t    struct hpfs_dirent *);\n\nstatic inline struct hpfs_dirent *dnode_end_de (struct dnode *dnode)\n{\n  CHKCOND(le32_to_cpu(dnode->first_free)>=0x14 && le32_to_cpu(dnode->first_free)<=0xa00,(\"HPFS: dnode_end_de: dnode->first_free = %x\\n\",(unsigned)le32_to_cpu(dnode->first_free)));\n  return (void *) dnode + le32_to_cpu(dnode->first_free);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hpfs_fn.h\"\n\nstatic loff_t get_pos(struct dnode *d, struct hpfs_dirent *fde)\n{\n\tstruct hpfs_dirent *de;\n\tstruct hpfs_dirent *de_end = dnode_end_de(d);\n\tint i = 1;\n\tfor (de = dnode_first_de(d); de < de_end; de = de_next_de(de)) {\n\t\tif (de == fde) return ((loff_t) le32_to_cpu(d->self) << 4) | (loff_t)i;\n\t\ti++;\n\t}\n\tpr_info(\"%s(): not_found\\n\", __func__);\n\treturn ((loff_t)le32_to_cpu(d->self) << 4) | (loff_t)1;\n}"
  }
]