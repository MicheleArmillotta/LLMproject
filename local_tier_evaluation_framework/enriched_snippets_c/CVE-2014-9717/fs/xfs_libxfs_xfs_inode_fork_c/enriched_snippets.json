[
  {
    "function_name": "xfs_iext_irec_update_extoffs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_inode_fork.c",
    "lines": "1888-1902",
    "snippet": "void\nxfs_iext_irec_update_extoffs(\n\txfs_ifork_t\t*ifp,\t\t/* inode fork pointer */\n\tint\t\terp_idx,\t/* irec index to update */\n\tint\t\text_diff)\t/* number of new extents */\n{\n\tint\t\ti;\t\t/* loop counter */\n\tint\t\tnlists;\t\t/* number of irec's (ex lists */\n\n\tASSERT(ifp->if_flags & XFS_IFEXTIREC);\n\tnlists = ifp->if_real_bytes / XFS_IEXT_BUFSZ;\n\tfor (i = erp_idx; i < nlists; i++) {\n\t\tifp->if_u1.if_ext_irec[i].er_extoff += ext_diff;\n\t}\n}",
    "includes": [
      "#include \"xfs_attr_sf.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\"",
      "#include <linux/log2.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "ifp->if_flags & XFS_IFEXTIREC"
          ],
          "line": 1897
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_attr_sf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nvoid\nxfs_iext_irec_update_extoffs(\n\txfs_ifork_t\t*ifp,\t\t/* inode fork pointer */\n\tint\t\terp_idx,\t/* irec index to update */\n\tint\t\text_diff)\t/* number of new extents */\n{\n\tint\t\ti;\t\t/* loop counter */\n\tint\t\tnlists;\t\t/* number of irec's (ex lists */\n\n\tASSERT(ifp->if_flags & XFS_IFEXTIREC);\n\tnlists = ifp->if_real_bytes / XFS_IEXT_BUFSZ;\n\tfor (i = erp_idx; i < nlists; i++) {\n\t\tifp->if_u1.if_ext_irec[i].er_extoff += ext_diff;\n\t}\n}"
  },
  {
    "function_name": "xfs_iext_irec_compact_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_inode_fork.c",
    "lines": "1847-1879",
    "snippet": "void\nxfs_iext_irec_compact_pages(\n\txfs_ifork_t\t*ifp)\t\t/* inode fork pointer */\n{\n\txfs_ext_irec_t\t*erp, *erp_next;/* pointers to irec entries */\n\tint\t\terp_idx = 0;\t/* indirection array index */\n\tint\t\tnlists;\t\t/* number of irec's (ex lists) */\n\n\tASSERT(ifp->if_flags & XFS_IFEXTIREC);\n\tnlists = ifp->if_real_bytes / XFS_IEXT_BUFSZ;\n\twhile (erp_idx < nlists - 1) {\n\t\terp = &ifp->if_u1.if_ext_irec[erp_idx];\n\t\terp_next = erp + 1;\n\t\tif (erp_next->er_extcount <=\n\t\t    (XFS_LINEAR_EXTS - erp->er_extcount)) {\n\t\t\tmemcpy(&erp->er_extbuf[erp->er_extcount],\n\t\t\t\terp_next->er_extbuf, erp_next->er_extcount *\n\t\t\t\tsizeof(xfs_bmbt_rec_t));\n\t\t\terp->er_extcount += erp_next->er_extcount;\n\t\t\t/*\n\t\t\t * Free page before removing extent record\n\t\t\t * so er_extoffs don't get modified in\n\t\t\t * xfs_iext_irec_remove.\n\t\t\t */\n\t\t\tkmem_free(erp_next->er_extbuf);\n\t\t\terp_next->er_extbuf = NULL;\n\t\t\txfs_iext_irec_remove(ifp, erp_idx + 1);\n\t\t\tnlists = ifp->if_real_bytes / XFS_IEXT_BUFSZ;\n\t\t} else {\n\t\t\terp_idx++;\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"xfs_attr_sf.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\"",
      "#include <linux/log2.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_iext_irec_remove",
          "args": [
            "ifp",
            "erp_idx + 1"
          ],
          "line": 1873
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_iext_irec_remove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_inode_fork.c",
          "lines": "1772-1808",
          "snippet": "void\nxfs_iext_irec_remove(\n\txfs_ifork_t\t*ifp,\t\t/* inode fork pointer */\n\tint\t\terp_idx)\t/* irec index to remove */\n{\n\txfs_ext_irec_t\t*erp;\t\t/* indirection array pointer */\n\tint\t\ti;\t\t/* loop counter */\n\tint\t\tnlists;\t\t/* number of irec's (ex lists) */\n\n\tASSERT(ifp->if_flags & XFS_IFEXTIREC);\n\tnlists = ifp->if_real_bytes / XFS_IEXT_BUFSZ;\n\terp = &ifp->if_u1.if_ext_irec[erp_idx];\n\tif (erp->er_extbuf) {\n\t\txfs_iext_irec_update_extoffs(ifp, erp_idx + 1,\n\t\t\t-erp->er_extcount);\n\t\tkmem_free(erp->er_extbuf);\n\t}\n\t/* Compact extent records */\n\terp = ifp->if_u1.if_ext_irec;\n\tfor (i = erp_idx; i < nlists - 1; i++) {\n\t\tmemmove(&erp[i], &erp[i+1], sizeof(xfs_ext_irec_t));\n\t}\n\t/*\n\t * Manually free the last extent record from the indirection\n\t * array.  A call to xfs_iext_realloc_indirect() with a size\n\t * of zero would result in a call to xfs_iext_destroy() which\n\t * would in turn call this function again, creating a nasty\n\t * infinite loop.\n\t */\n\tif (--nlists) {\n\t\txfs_iext_realloc_indirect(ifp,\n\t\t\tnlists * sizeof(xfs_ext_irec_t));\n\t} else {\n\t\tkmem_free(ifp->if_u1.if_ext_irec);\n\t}\n\tifp->if_real_bytes = nlists * XFS_IEXT_BUFSZ;\n}",
          "includes": [
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_attr_sf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nvoid\nxfs_iext_irec_remove(\n\txfs_ifork_t\t*ifp,\t\t/* inode fork pointer */\n\tint\t\terp_idx)\t/* irec index to remove */\n{\n\txfs_ext_irec_t\t*erp;\t\t/* indirection array pointer */\n\tint\t\ti;\t\t/* loop counter */\n\tint\t\tnlists;\t\t/* number of irec's (ex lists) */\n\n\tASSERT(ifp->if_flags & XFS_IFEXTIREC);\n\tnlists = ifp->if_real_bytes / XFS_IEXT_BUFSZ;\n\terp = &ifp->if_u1.if_ext_irec[erp_idx];\n\tif (erp->er_extbuf) {\n\t\txfs_iext_irec_update_extoffs(ifp, erp_idx + 1,\n\t\t\t-erp->er_extcount);\n\t\tkmem_free(erp->er_extbuf);\n\t}\n\t/* Compact extent records */\n\terp = ifp->if_u1.if_ext_irec;\n\tfor (i = erp_idx; i < nlists - 1; i++) {\n\t\tmemmove(&erp[i], &erp[i+1], sizeof(xfs_ext_irec_t));\n\t}\n\t/*\n\t * Manually free the last extent record from the indirection\n\t * array.  A call to xfs_iext_realloc_indirect() with a size\n\t * of zero would result in a call to xfs_iext_destroy() which\n\t * would in turn call this function again, creating a nasty\n\t * infinite loop.\n\t */\n\tif (--nlists) {\n\t\txfs_iext_realloc_indirect(ifp,\n\t\t\tnlists * sizeof(xfs_ext_irec_t));\n\t} else {\n\t\tkmem_free(ifp->if_u1.if_ext_irec);\n\t}\n\tifp->if_real_bytes = nlists * XFS_IEXT_BUFSZ;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmem_free",
          "args": [
            "erp_next->er_extbuf"
          ],
          "line": 1871
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/kmem.h",
          "lines": "66-69",
          "snippet": "static inline void  kmem_free(const void *ptr)\n{\n\tkvfree(ptr);\n}",
          "includes": [
            "#include <linux/vmalloc.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n\nstatic inline void  kmem_free(const void *ptr)\n{\n\tkvfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&erp->er_extbuf[erp->er_extcount]",
            "erp_next->er_extbuf",
            "erp_next->er_extcount *\n\t\t\t\tsizeof(xfs_bmbt_rec_t)"
          ],
          "line": 1862
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "ifp->if_flags & XFS_IFEXTIREC"
          ],
          "line": 1855
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_attr_sf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nvoid\nxfs_iext_irec_compact_pages(\n\txfs_ifork_t\t*ifp)\t\t/* inode fork pointer */\n{\n\txfs_ext_irec_t\t*erp, *erp_next;/* pointers to irec entries */\n\tint\t\terp_idx = 0;\t/* indirection array index */\n\tint\t\tnlists;\t\t/* number of irec's (ex lists) */\n\n\tASSERT(ifp->if_flags & XFS_IFEXTIREC);\n\tnlists = ifp->if_real_bytes / XFS_IEXT_BUFSZ;\n\twhile (erp_idx < nlists - 1) {\n\t\terp = &ifp->if_u1.if_ext_irec[erp_idx];\n\t\terp_next = erp + 1;\n\t\tif (erp_next->er_extcount <=\n\t\t    (XFS_LINEAR_EXTS - erp->er_extcount)) {\n\t\t\tmemcpy(&erp->er_extbuf[erp->er_extcount],\n\t\t\t\terp_next->er_extbuf, erp_next->er_extcount *\n\t\t\t\tsizeof(xfs_bmbt_rec_t));\n\t\t\terp->er_extcount += erp_next->er_extcount;\n\t\t\t/*\n\t\t\t * Free page before removing extent record\n\t\t\t * so er_extoffs don't get modified in\n\t\t\t * xfs_iext_irec_remove.\n\t\t\t */\n\t\t\tkmem_free(erp_next->er_extbuf);\n\t\t\terp_next->er_extbuf = NULL;\n\t\t\txfs_iext_irec_remove(ifp, erp_idx + 1);\n\t\t\tnlists = ifp->if_real_bytes / XFS_IEXT_BUFSZ;\n\t\t} else {\n\t\t\terp_idx++;\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "xfs_iext_irec_compact",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_inode_fork.c",
    "lines": "1821-1842",
    "snippet": "void\nxfs_iext_irec_compact(\n\txfs_ifork_t\t*ifp)\t\t/* inode fork pointer */\n{\n\txfs_extnum_t\tnextents;\t/* number of extents in file */\n\tint\t\tnlists;\t\t/* number of irec's (ex lists) */\n\n\tASSERT(ifp->if_flags & XFS_IFEXTIREC);\n\tnlists = ifp->if_real_bytes / XFS_IEXT_BUFSZ;\n\tnextents = ifp->if_bytes / (uint)sizeof(xfs_bmbt_rec_t);\n\n\tif (nextents == 0) {\n\t\txfs_iext_destroy(ifp);\n\t} else if (nextents <= XFS_INLINE_EXTS) {\n\t\txfs_iext_indirect_to_direct(ifp);\n\t\txfs_iext_direct_to_inline(ifp, nextents);\n\t} else if (nextents <= XFS_LINEAR_EXTS) {\n\t\txfs_iext_indirect_to_direct(ifp);\n\t} else if (nextents < (nlists * XFS_LINEAR_EXTS) >> 1) {\n\t\txfs_iext_irec_compact_pages(ifp);\n\t}\n}",
    "includes": [
      "#include \"xfs_attr_sf.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\"",
      "#include <linux/log2.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_iext_irec_compact_pages",
          "args": [
            "ifp"
          ],
          "line": 1840
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_iext_irec_compact_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_inode_fork.c",
          "lines": "1847-1879",
          "snippet": "void\nxfs_iext_irec_compact_pages(\n\txfs_ifork_t\t*ifp)\t\t/* inode fork pointer */\n{\n\txfs_ext_irec_t\t*erp, *erp_next;/* pointers to irec entries */\n\tint\t\terp_idx = 0;\t/* indirection array index */\n\tint\t\tnlists;\t\t/* number of irec's (ex lists) */\n\n\tASSERT(ifp->if_flags & XFS_IFEXTIREC);\n\tnlists = ifp->if_real_bytes / XFS_IEXT_BUFSZ;\n\twhile (erp_idx < nlists - 1) {\n\t\terp = &ifp->if_u1.if_ext_irec[erp_idx];\n\t\terp_next = erp + 1;\n\t\tif (erp_next->er_extcount <=\n\t\t    (XFS_LINEAR_EXTS - erp->er_extcount)) {\n\t\t\tmemcpy(&erp->er_extbuf[erp->er_extcount],\n\t\t\t\terp_next->er_extbuf, erp_next->er_extcount *\n\t\t\t\tsizeof(xfs_bmbt_rec_t));\n\t\t\terp->er_extcount += erp_next->er_extcount;\n\t\t\t/*\n\t\t\t * Free page before removing extent record\n\t\t\t * so er_extoffs don't get modified in\n\t\t\t * xfs_iext_irec_remove.\n\t\t\t */\n\t\t\tkmem_free(erp_next->er_extbuf);\n\t\t\terp_next->er_extbuf = NULL;\n\t\t\txfs_iext_irec_remove(ifp, erp_idx + 1);\n\t\t\tnlists = ifp->if_real_bytes / XFS_IEXT_BUFSZ;\n\t\t} else {\n\t\t\terp_idx++;\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_attr_sf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nvoid\nxfs_iext_irec_compact_pages(\n\txfs_ifork_t\t*ifp)\t\t/* inode fork pointer */\n{\n\txfs_ext_irec_t\t*erp, *erp_next;/* pointers to irec entries */\n\tint\t\terp_idx = 0;\t/* indirection array index */\n\tint\t\tnlists;\t\t/* number of irec's (ex lists) */\n\n\tASSERT(ifp->if_flags & XFS_IFEXTIREC);\n\tnlists = ifp->if_real_bytes / XFS_IEXT_BUFSZ;\n\twhile (erp_idx < nlists - 1) {\n\t\terp = &ifp->if_u1.if_ext_irec[erp_idx];\n\t\terp_next = erp + 1;\n\t\tif (erp_next->er_extcount <=\n\t\t    (XFS_LINEAR_EXTS - erp->er_extcount)) {\n\t\t\tmemcpy(&erp->er_extbuf[erp->er_extcount],\n\t\t\t\terp_next->er_extbuf, erp_next->er_extcount *\n\t\t\t\tsizeof(xfs_bmbt_rec_t));\n\t\t\terp->er_extcount += erp_next->er_extcount;\n\t\t\t/*\n\t\t\t * Free page before removing extent record\n\t\t\t * so er_extoffs don't get modified in\n\t\t\t * xfs_iext_irec_remove.\n\t\t\t */\n\t\t\tkmem_free(erp_next->er_extbuf);\n\t\t\terp_next->er_extbuf = NULL;\n\t\t\txfs_iext_irec_remove(ifp, erp_idx + 1);\n\t\t\tnlists = ifp->if_real_bytes / XFS_IEXT_BUFSZ;\n\t\t} else {\n\t\t\terp_idx++;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_iext_indirect_to_direct",
          "args": [
            "ifp"
          ],
          "line": 1838
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_iext_indirect_to_direct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_inode_fork.c",
          "lines": "1472-1496",
          "snippet": "STATIC void\nxfs_iext_indirect_to_direct(\n\t xfs_ifork_t\t*ifp)\t\t/* inode fork pointer */\n{\n\txfs_bmbt_rec_host_t *ep;\t/* extent record pointer */\n\txfs_extnum_t\tnextents;\t/* number of extents in file */\n\tint\t\tsize;\t\t/* size of file extents */\n\n\tASSERT(ifp->if_flags & XFS_IFEXTIREC);\n\tnextents = ifp->if_bytes / (uint)sizeof(xfs_bmbt_rec_t);\n\tASSERT(nextents <= XFS_LINEAR_EXTS);\n\tsize = nextents * sizeof(xfs_bmbt_rec_t);\n\n\txfs_iext_irec_compact_pages(ifp);\n\tASSERT(ifp->if_real_bytes == XFS_IEXT_BUFSZ);\n\n\tep = ifp->if_u1.if_ext_irec->er_extbuf;\n\tkmem_free(ifp->if_u1.if_ext_irec);\n\tifp->if_flags &= ~XFS_IFEXTIREC;\n\tifp->if_u1.if_extents = ep;\n\tifp->if_bytes = size;\n\tif (nextents < XFS_LINEAR_EXTS) {\n\t\txfs_iext_realloc_direct(ifp, size);\n\t}\n}",
          "includes": [
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_attr_sf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC void\nxfs_iext_indirect_to_direct(\n\t xfs_ifork_t\t*ifp)\t\t/* inode fork pointer */\n{\n\txfs_bmbt_rec_host_t *ep;\t/* extent record pointer */\n\txfs_extnum_t\tnextents;\t/* number of extents in file */\n\tint\t\tsize;\t\t/* size of file extents */\n\n\tASSERT(ifp->if_flags & XFS_IFEXTIREC);\n\tnextents = ifp->if_bytes / (uint)sizeof(xfs_bmbt_rec_t);\n\tASSERT(nextents <= XFS_LINEAR_EXTS);\n\tsize = nextents * sizeof(xfs_bmbt_rec_t);\n\n\txfs_iext_irec_compact_pages(ifp);\n\tASSERT(ifp->if_real_bytes == XFS_IEXT_BUFSZ);\n\n\tep = ifp->if_u1.if_ext_irec->er_extbuf;\n\tkmem_free(ifp->if_u1.if_ext_irec);\n\tifp->if_flags &= ~XFS_IFEXTIREC;\n\tifp->if_u1.if_extents = ep;\n\tifp->if_bytes = size;\n\tif (nextents < XFS_LINEAR_EXTS) {\n\t\txfs_iext_realloc_direct(ifp, size);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_iext_direct_to_inline",
          "args": [
            "ifp",
            "nextents"
          ],
          "line": 1836
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_iext_direct_to_inline",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_inode_fork.c",
          "lines": "1401-1418",
          "snippet": "void\nxfs_iext_direct_to_inline(\n\txfs_ifork_t\t*ifp,\t\t/* inode fork pointer */\n\txfs_extnum_t\tnextents)\t/* number of extents in file */\n{\n\tASSERT(ifp->if_flags & XFS_IFEXTENTS);\n\tASSERT(nextents <= XFS_INLINE_EXTS);\n\t/*\n\t * The inline buffer was zeroed when we switched\n\t * from inline to direct extent allocation mode,\n\t * so we don't need to clear it here.\n\t */\n\tmemcpy(ifp->if_u2.if_inline_ext, ifp->if_u1.if_extents,\n\t\tnextents * sizeof(xfs_bmbt_rec_t));\n\tkmem_free(ifp->if_u1.if_extents);\n\tifp->if_u1.if_extents = ifp->if_u2.if_inline_ext;\n\tifp->if_real_bytes = 0;\n}",
          "includes": [
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_attr_sf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nvoid\nxfs_iext_direct_to_inline(\n\txfs_ifork_t\t*ifp,\t\t/* inode fork pointer */\n\txfs_extnum_t\tnextents)\t/* number of extents in file */\n{\n\tASSERT(ifp->if_flags & XFS_IFEXTENTS);\n\tASSERT(nextents <= XFS_INLINE_EXTS);\n\t/*\n\t * The inline buffer was zeroed when we switched\n\t * from inline to direct extent allocation mode,\n\t * so we don't need to clear it here.\n\t */\n\tmemcpy(ifp->if_u2.if_inline_ext, ifp->if_u1.if_extents,\n\t\tnextents * sizeof(xfs_bmbt_rec_t));\n\tkmem_free(ifp->if_u1.if_extents);\n\tifp->if_u1.if_extents = ifp->if_u2.if_inline_ext;\n\tifp->if_real_bytes = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_iext_destroy",
          "args": [
            "ifp"
          ],
          "line": 1833
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_iext_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_inode_fork.c",
          "lines": "1501-1523",
          "snippet": "void\nxfs_iext_destroy(\n\txfs_ifork_t\t*ifp)\t\t/* inode fork pointer */\n{\n\tif (ifp->if_flags & XFS_IFEXTIREC) {\n\t\tint\terp_idx;\n\t\tint\tnlists;\n\n\t\tnlists = ifp->if_real_bytes / XFS_IEXT_BUFSZ;\n\t\tfor (erp_idx = nlists - 1; erp_idx >= 0 ; erp_idx--) {\n\t\t\txfs_iext_irec_remove(ifp, erp_idx);\n\t\t}\n\t\tifp->if_flags &= ~XFS_IFEXTIREC;\n\t} else if (ifp->if_real_bytes) {\n\t\tkmem_free(ifp->if_u1.if_extents);\n\t} else if (ifp->if_bytes) {\n\t\tmemset(ifp->if_u2.if_inline_ext, 0, XFS_INLINE_EXTS *\n\t\t\tsizeof(xfs_bmbt_rec_t));\n\t}\n\tifp->if_u1.if_extents = NULL;\n\tifp->if_real_bytes = 0;\n\tifp->if_bytes = 0;\n}",
          "includes": [
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_attr_sf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nvoid\nxfs_iext_destroy(\n\txfs_ifork_t\t*ifp)\t\t/* inode fork pointer */\n{\n\tif (ifp->if_flags & XFS_IFEXTIREC) {\n\t\tint\terp_idx;\n\t\tint\tnlists;\n\n\t\tnlists = ifp->if_real_bytes / XFS_IEXT_BUFSZ;\n\t\tfor (erp_idx = nlists - 1; erp_idx >= 0 ; erp_idx--) {\n\t\t\txfs_iext_irec_remove(ifp, erp_idx);\n\t\t}\n\t\tifp->if_flags &= ~XFS_IFEXTIREC;\n\t} else if (ifp->if_real_bytes) {\n\t\tkmem_free(ifp->if_u1.if_extents);\n\t} else if (ifp->if_bytes) {\n\t\tmemset(ifp->if_u2.if_inline_ext, 0, XFS_INLINE_EXTS *\n\t\t\tsizeof(xfs_bmbt_rec_t));\n\t}\n\tifp->if_u1.if_extents = NULL;\n\tifp->if_real_bytes = 0;\n\tifp->if_bytes = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "ifp->if_flags & XFS_IFEXTIREC"
          ],
          "line": 1828
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_attr_sf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nvoid\nxfs_iext_irec_compact(\n\txfs_ifork_t\t*ifp)\t\t/* inode fork pointer */\n{\n\txfs_extnum_t\tnextents;\t/* number of extents in file */\n\tint\t\tnlists;\t\t/* number of irec's (ex lists) */\n\n\tASSERT(ifp->if_flags & XFS_IFEXTIREC);\n\tnlists = ifp->if_real_bytes / XFS_IEXT_BUFSZ;\n\tnextents = ifp->if_bytes / (uint)sizeof(xfs_bmbt_rec_t);\n\n\tif (nextents == 0) {\n\t\txfs_iext_destroy(ifp);\n\t} else if (nextents <= XFS_INLINE_EXTS) {\n\t\txfs_iext_indirect_to_direct(ifp);\n\t\txfs_iext_direct_to_inline(ifp, nextents);\n\t} else if (nextents <= XFS_LINEAR_EXTS) {\n\t\txfs_iext_indirect_to_direct(ifp);\n\t} else if (nextents < (nlists * XFS_LINEAR_EXTS) >> 1) {\n\t\txfs_iext_irec_compact_pages(ifp);\n\t}\n}"
  },
  {
    "function_name": "xfs_iext_irec_remove",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_inode_fork.c",
    "lines": "1772-1808",
    "snippet": "void\nxfs_iext_irec_remove(\n\txfs_ifork_t\t*ifp,\t\t/* inode fork pointer */\n\tint\t\terp_idx)\t/* irec index to remove */\n{\n\txfs_ext_irec_t\t*erp;\t\t/* indirection array pointer */\n\tint\t\ti;\t\t/* loop counter */\n\tint\t\tnlists;\t\t/* number of irec's (ex lists) */\n\n\tASSERT(ifp->if_flags & XFS_IFEXTIREC);\n\tnlists = ifp->if_real_bytes / XFS_IEXT_BUFSZ;\n\terp = &ifp->if_u1.if_ext_irec[erp_idx];\n\tif (erp->er_extbuf) {\n\t\txfs_iext_irec_update_extoffs(ifp, erp_idx + 1,\n\t\t\t-erp->er_extcount);\n\t\tkmem_free(erp->er_extbuf);\n\t}\n\t/* Compact extent records */\n\terp = ifp->if_u1.if_ext_irec;\n\tfor (i = erp_idx; i < nlists - 1; i++) {\n\t\tmemmove(&erp[i], &erp[i+1], sizeof(xfs_ext_irec_t));\n\t}\n\t/*\n\t * Manually free the last extent record from the indirection\n\t * array.  A call to xfs_iext_realloc_indirect() with a size\n\t * of zero would result in a call to xfs_iext_destroy() which\n\t * would in turn call this function again, creating a nasty\n\t * infinite loop.\n\t */\n\tif (--nlists) {\n\t\txfs_iext_realloc_indirect(ifp,\n\t\t\tnlists * sizeof(xfs_ext_irec_t));\n\t} else {\n\t\tkmem_free(ifp->if_u1.if_ext_irec);\n\t}\n\tifp->if_real_bytes = nlists * XFS_IEXT_BUFSZ;\n}",
    "includes": [
      "#include \"xfs_attr_sf.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\"",
      "#include <linux/log2.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_free",
          "args": [
            "ifp->if_u1.if_ext_irec"
          ],
          "line": 1805
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/kmem.h",
          "lines": "66-69",
          "snippet": "static inline void  kmem_free(const void *ptr)\n{\n\tkvfree(ptr);\n}",
          "includes": [
            "#include <linux/vmalloc.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n\nstatic inline void  kmem_free(const void *ptr)\n{\n\tkvfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_iext_realloc_indirect",
          "args": [
            "ifp",
            "nlists * sizeof(xfs_ext_irec_t)"
          ],
          "line": 1802
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_iext_realloc_indirect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_inode_fork.c",
          "lines": "1447-1467",
          "snippet": "STATIC void\nxfs_iext_realloc_indirect(\n\txfs_ifork_t\t*ifp,\t\t/* inode fork pointer */\n\tint\t\tnew_size)\t/* new indirection array size */\n{\n\tint\t\tnlists;\t\t/* number of irec's (ex lists) */\n\tint\t\tsize;\t\t/* current indirection array size */\n\n\tASSERT(ifp->if_flags & XFS_IFEXTIREC);\n\tnlists = ifp->if_real_bytes / XFS_IEXT_BUFSZ;\n\tsize = nlists * sizeof(xfs_ext_irec_t);\n\tASSERT(ifp->if_real_bytes);\n\tASSERT((new_size >= 0) && (new_size != size));\n\tif (new_size == 0) {\n\t\txfs_iext_destroy(ifp);\n\t} else {\n\t\tifp->if_u1.if_ext_irec = (xfs_ext_irec_t *)\n\t\t\tkmem_realloc(ifp->if_u1.if_ext_irec,\n\t\t\t\tnew_size, size, KM_NOFS);\n\t}\n}",
          "includes": [
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_attr_sf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC void\nxfs_iext_realloc_indirect(\n\txfs_ifork_t\t*ifp,\t\t/* inode fork pointer */\n\tint\t\tnew_size)\t/* new indirection array size */\n{\n\tint\t\tnlists;\t\t/* number of irec's (ex lists) */\n\tint\t\tsize;\t\t/* current indirection array size */\n\n\tASSERT(ifp->if_flags & XFS_IFEXTIREC);\n\tnlists = ifp->if_real_bytes / XFS_IEXT_BUFSZ;\n\tsize = nlists * sizeof(xfs_ext_irec_t);\n\tASSERT(ifp->if_real_bytes);\n\tASSERT((new_size >= 0) && (new_size != size));\n\tif (new_size == 0) {\n\t\txfs_iext_destroy(ifp);\n\t} else {\n\t\tifp->if_u1.if_ext_irec = (xfs_ext_irec_t *)\n\t\t\tkmem_realloc(ifp->if_u1.if_ext_irec,\n\t\t\t\tnew_size, size, KM_NOFS);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "&erp[i]",
            "&erp[i+1]",
            "sizeof(xfs_ext_irec_t)"
          ],
          "line": 1792
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_iext_irec_update_extoffs",
          "args": [
            "ifp",
            "erp_idx + 1",
            "-erp->er_extcount"
          ],
          "line": 1785
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_iext_irec_update_extoffs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_inode_fork.c",
          "lines": "1888-1902",
          "snippet": "void\nxfs_iext_irec_update_extoffs(\n\txfs_ifork_t\t*ifp,\t\t/* inode fork pointer */\n\tint\t\terp_idx,\t/* irec index to update */\n\tint\t\text_diff)\t/* number of new extents */\n{\n\tint\t\ti;\t\t/* loop counter */\n\tint\t\tnlists;\t\t/* number of irec's (ex lists */\n\n\tASSERT(ifp->if_flags & XFS_IFEXTIREC);\n\tnlists = ifp->if_real_bytes / XFS_IEXT_BUFSZ;\n\tfor (i = erp_idx; i < nlists; i++) {\n\t\tifp->if_u1.if_ext_irec[i].er_extoff += ext_diff;\n\t}\n}",
          "includes": [
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_attr_sf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nvoid\nxfs_iext_irec_update_extoffs(\n\txfs_ifork_t\t*ifp,\t\t/* inode fork pointer */\n\tint\t\terp_idx,\t/* irec index to update */\n\tint\t\text_diff)\t/* number of new extents */\n{\n\tint\t\ti;\t\t/* loop counter */\n\tint\t\tnlists;\t\t/* number of irec's (ex lists */\n\n\tASSERT(ifp->if_flags & XFS_IFEXTIREC);\n\tnlists = ifp->if_real_bytes / XFS_IEXT_BUFSZ;\n\tfor (i = erp_idx; i < nlists; i++) {\n\t\tifp->if_u1.if_ext_irec[i].er_extoff += ext_diff;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "ifp->if_flags & XFS_IFEXTIREC"
          ],
          "line": 1781
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_attr_sf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nvoid\nxfs_iext_irec_remove(\n\txfs_ifork_t\t*ifp,\t\t/* inode fork pointer */\n\tint\t\terp_idx)\t/* irec index to remove */\n{\n\txfs_ext_irec_t\t*erp;\t\t/* indirection array pointer */\n\tint\t\ti;\t\t/* loop counter */\n\tint\t\tnlists;\t\t/* number of irec's (ex lists) */\n\n\tASSERT(ifp->if_flags & XFS_IFEXTIREC);\n\tnlists = ifp->if_real_bytes / XFS_IEXT_BUFSZ;\n\terp = &ifp->if_u1.if_ext_irec[erp_idx];\n\tif (erp->er_extbuf) {\n\t\txfs_iext_irec_update_extoffs(ifp, erp_idx + 1,\n\t\t\t-erp->er_extcount);\n\t\tkmem_free(erp->er_extbuf);\n\t}\n\t/* Compact extent records */\n\terp = ifp->if_u1.if_ext_irec;\n\tfor (i = erp_idx; i < nlists - 1; i++) {\n\t\tmemmove(&erp[i], &erp[i+1], sizeof(xfs_ext_irec_t));\n\t}\n\t/*\n\t * Manually free the last extent record from the indirection\n\t * array.  A call to xfs_iext_realloc_indirect() with a size\n\t * of zero would result in a call to xfs_iext_destroy() which\n\t * would in turn call this function again, creating a nasty\n\t * infinite loop.\n\t */\n\tif (--nlists) {\n\t\txfs_iext_realloc_indirect(ifp,\n\t\t\tnlists * sizeof(xfs_ext_irec_t));\n\t} else {\n\t\tkmem_free(ifp->if_u1.if_ext_irec);\n\t}\n\tifp->if_real_bytes = nlists * XFS_IEXT_BUFSZ;\n}"
  },
  {
    "function_name": "xfs_iext_irec_new",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_inode_fork.c",
    "lines": "1733-1767",
    "snippet": "xfs_ext_irec_t *\nxfs_iext_irec_new(\n\txfs_ifork_t\t*ifp,\t\t/* inode fork pointer */\n\tint\t\terp_idx)\t/* index for new irec */\n{\n\txfs_ext_irec_t\t*erp;\t\t/* indirection array pointer */\n\tint\t\ti;\t\t/* loop counter */\n\tint\t\tnlists;\t\t/* number of irec's (ex lists) */\n\n\tASSERT(ifp->if_flags & XFS_IFEXTIREC);\n\tnlists = ifp->if_real_bytes / XFS_IEXT_BUFSZ;\n\n\t/* Resize indirection array */\n\txfs_iext_realloc_indirect(ifp, ++nlists *\n\t\t\t\t  sizeof(xfs_ext_irec_t));\n\t/*\n\t * Move records down in the array so the\n\t * new page can use erp_idx.\n\t */\n\terp = ifp->if_u1.if_ext_irec;\n\tfor (i = nlists - 1; i > erp_idx; i--) {\n\t\tmemmove(&erp[i], &erp[i-1], sizeof(xfs_ext_irec_t));\n\t}\n\tASSERT(i == erp_idx);\n\n\t/* Initialize new extent record */\n\terp = ifp->if_u1.if_ext_irec;\n\terp[erp_idx].er_extbuf = kmem_alloc(XFS_IEXT_BUFSZ, KM_NOFS);\n\tifp->if_real_bytes = nlists * XFS_IEXT_BUFSZ;\n\tmemset(erp[erp_idx].er_extbuf, 0, XFS_IEXT_BUFSZ);\n\terp[erp_idx].er_extcount = 0;\n\terp[erp_idx].er_extoff = erp_idx > 0 ?\n\t\terp[erp_idx-1].er_extoff + erp[erp_idx-1].er_extcount : 0;\n\treturn (&erp[erp_idx]);\n}",
    "includes": [
      "#include \"xfs_attr_sf.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\"",
      "#include <linux/log2.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "erp[erp_idx].er_extbuf",
            "0",
            "XFS_IEXT_BUFSZ"
          ],
          "line": 1762
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_alloc",
          "args": [
            "XFS_IEXT_BUFSZ",
            "KM_NOFS"
          ],
          "line": 1760
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/kmem.c",
          "lines": "45-62",
          "snippet": "void *\nkmem_alloc(size_t size, xfs_km_flags_t flags)\n{\n\tint\tretries = 0;\n\tgfp_t\tlflags = kmem_flags_convert(flags);\n\tvoid\t*ptr;\n\n\tdo {\n\t\tptr = kmalloc(size, lflags);\n\t\tif (ptr || (flags & (KM_MAYFAIL|KM_NOSLEEP)))\n\t\t\treturn ptr;\n\t\tif (!(++retries % 100))\n\t\t\txfs_err(NULL,\n\t\t\"possible memory allocation deadlock in %s (mode:0x%x)\",\n\t\t\t\t\t__func__, lflags);\n\t\tcongestion_wait(BLK_RW_ASYNC, HZ/50);\n\t} while (1);\n}",
          "includes": [
            "#include \"xfs_message.h\"",
            "#include \"kmem.h\"",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_message.h\"\n#include \"kmem.h\"\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nvoid *\nkmem_alloc(size_t size, xfs_km_flags_t flags)\n{\n\tint\tretries = 0;\n\tgfp_t\tlflags = kmem_flags_convert(flags);\n\tvoid\t*ptr;\n\n\tdo {\n\t\tptr = kmalloc(size, lflags);\n\t\tif (ptr || (flags & (KM_MAYFAIL|KM_NOSLEEP)))\n\t\t\treturn ptr;\n\t\tif (!(++retries % 100))\n\t\t\txfs_err(NULL,\n\t\t\"possible memory allocation deadlock in %s (mode:0x%x)\",\n\t\t\t\t\t__func__, lflags);\n\t\tcongestion_wait(BLK_RW_ASYNC, HZ/50);\n\t} while (1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "i == erp_idx"
          ],
          "line": 1756
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "&erp[i]",
            "&erp[i-1]",
            "sizeof(xfs_ext_irec_t)"
          ],
          "line": 1754
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_iext_realloc_indirect",
          "args": [
            "ifp",
            "++nlists *\n\t\t\t\t  sizeof(xfs_ext_irec_t)"
          ],
          "line": 1746
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_iext_realloc_indirect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_inode_fork.c",
          "lines": "1447-1467",
          "snippet": "STATIC void\nxfs_iext_realloc_indirect(\n\txfs_ifork_t\t*ifp,\t\t/* inode fork pointer */\n\tint\t\tnew_size)\t/* new indirection array size */\n{\n\tint\t\tnlists;\t\t/* number of irec's (ex lists) */\n\tint\t\tsize;\t\t/* current indirection array size */\n\n\tASSERT(ifp->if_flags & XFS_IFEXTIREC);\n\tnlists = ifp->if_real_bytes / XFS_IEXT_BUFSZ;\n\tsize = nlists * sizeof(xfs_ext_irec_t);\n\tASSERT(ifp->if_real_bytes);\n\tASSERT((new_size >= 0) && (new_size != size));\n\tif (new_size == 0) {\n\t\txfs_iext_destroy(ifp);\n\t} else {\n\t\tifp->if_u1.if_ext_irec = (xfs_ext_irec_t *)\n\t\t\tkmem_realloc(ifp->if_u1.if_ext_irec,\n\t\t\t\tnew_size, size, KM_NOFS);\n\t}\n}",
          "includes": [
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_attr_sf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC void\nxfs_iext_realloc_indirect(\n\txfs_ifork_t\t*ifp,\t\t/* inode fork pointer */\n\tint\t\tnew_size)\t/* new indirection array size */\n{\n\tint\t\tnlists;\t\t/* number of irec's (ex lists) */\n\tint\t\tsize;\t\t/* current indirection array size */\n\n\tASSERT(ifp->if_flags & XFS_IFEXTIREC);\n\tnlists = ifp->if_real_bytes / XFS_IEXT_BUFSZ;\n\tsize = nlists * sizeof(xfs_ext_irec_t);\n\tASSERT(ifp->if_real_bytes);\n\tASSERT((new_size >= 0) && (new_size != size));\n\tif (new_size == 0) {\n\t\txfs_iext_destroy(ifp);\n\t} else {\n\t\tifp->if_u1.if_ext_irec = (xfs_ext_irec_t *)\n\t\t\tkmem_realloc(ifp->if_u1.if_ext_irec,\n\t\t\t\tnew_size, size, KM_NOFS);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "ifp->if_flags & XFS_IFEXTIREC"
          ],
          "line": 1742
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_attr_sf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nxfs_ext_irec_t *\nxfs_iext_irec_new(\n\txfs_ifork_t\t*ifp,\t\t/* inode fork pointer */\n\tint\t\terp_idx)\t/* index for new irec */\n{\n\txfs_ext_irec_t\t*erp;\t\t/* indirection array pointer */\n\tint\t\ti;\t\t/* loop counter */\n\tint\t\tnlists;\t\t/* number of irec's (ex lists) */\n\n\tASSERT(ifp->if_flags & XFS_IFEXTIREC);\n\tnlists = ifp->if_real_bytes / XFS_IEXT_BUFSZ;\n\n\t/* Resize indirection array */\n\txfs_iext_realloc_indirect(ifp, ++nlists *\n\t\t\t\t  sizeof(xfs_ext_irec_t));\n\t/*\n\t * Move records down in the array so the\n\t * new page can use erp_idx.\n\t */\n\terp = ifp->if_u1.if_ext_irec;\n\tfor (i = nlists - 1; i > erp_idx; i--) {\n\t\tmemmove(&erp[i], &erp[i-1], sizeof(xfs_ext_irec_t));\n\t}\n\tASSERT(i == erp_idx);\n\n\t/* Initialize new extent record */\n\terp = ifp->if_u1.if_ext_irec;\n\terp[erp_idx].er_extbuf = kmem_alloc(XFS_IEXT_BUFSZ, KM_NOFS);\n\tifp->if_real_bytes = nlists * XFS_IEXT_BUFSZ;\n\tmemset(erp[erp_idx].er_extbuf, 0, XFS_IEXT_BUFSZ);\n\terp[erp_idx].er_extcount = 0;\n\terp[erp_idx].er_extoff = erp_idx > 0 ?\n\t\terp[erp_idx-1].er_extoff + erp[erp_idx-1].er_extcount : 0;\n\treturn (&erp[erp_idx]);\n}"
  },
  {
    "function_name": "xfs_iext_irec_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_inode_fork.c",
    "lines": "1698-1728",
    "snippet": "void\nxfs_iext_irec_init(\n\txfs_ifork_t\t*ifp)\t\t/* inode fork pointer */\n{\n\txfs_ext_irec_t\t*erp;\t\t/* indirection array pointer */\n\txfs_extnum_t\tnextents;\t/* number of extents in file */\n\n\tASSERT(!(ifp->if_flags & XFS_IFEXTIREC));\n\tnextents = ifp->if_bytes / (uint)sizeof(xfs_bmbt_rec_t);\n\tASSERT(nextents <= XFS_LINEAR_EXTS);\n\n\terp = kmem_alloc(sizeof(xfs_ext_irec_t), KM_NOFS);\n\n\tif (nextents == 0) {\n\t\tifp->if_u1.if_extents = kmem_alloc(XFS_IEXT_BUFSZ, KM_NOFS);\n\t} else if (!ifp->if_real_bytes) {\n\t\txfs_iext_inline_to_direct(ifp, XFS_IEXT_BUFSZ);\n\t} else if (ifp->if_real_bytes < XFS_IEXT_BUFSZ) {\n\t\txfs_iext_realloc_direct(ifp, XFS_IEXT_BUFSZ);\n\t}\n\terp->er_extbuf = ifp->if_u1.if_extents;\n\terp->er_extcount = nextents;\n\terp->er_extoff = 0;\n\n\tifp->if_flags |= XFS_IFEXTIREC;\n\tifp->if_real_bytes = XFS_IEXT_BUFSZ;\n\tifp->if_bytes = nextents * sizeof(xfs_bmbt_rec_t);\n\tifp->if_u1.if_ext_irec = erp;\n\n\treturn;\n}",
    "includes": [
      "#include \"xfs_attr_sf.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\"",
      "#include <linux/log2.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_iext_realloc_direct",
          "args": [
            "ifp",
            "XFS_IEXT_BUFSZ"
          ],
          "line": 1716
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_iext_realloc_direct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_inode_fork.c",
          "lines": "1346-1396",
          "snippet": "void\nxfs_iext_realloc_direct(\n\txfs_ifork_t\t*ifp,\t\t/* inode fork pointer */\n\tint\t\tnew_size)\t/* new size of extents after adding */\n{\n\tint\t\trnew_size;\t/* real new size of extents */\n\n\trnew_size = new_size;\n\n\tASSERT(!(ifp->if_flags & XFS_IFEXTIREC) ||\n\t\t((new_size >= 0) && (new_size <= XFS_IEXT_BUFSZ) &&\n\t\t (new_size != ifp->if_real_bytes)));\n\n\t/* Free extent records */\n\tif (new_size == 0) {\n\t\txfs_iext_destroy(ifp);\n\t}\n\t/* Resize direct extent list and zero any new bytes */\n\telse if (ifp->if_real_bytes) {\n\t\t/* Check if extents will fit inside the inode */\n\t\tif (new_size <= XFS_INLINE_EXTS * sizeof(xfs_bmbt_rec_t)) {\n\t\t\txfs_iext_direct_to_inline(ifp, new_size /\n\t\t\t\t(uint)sizeof(xfs_bmbt_rec_t));\n\t\t\tifp->if_bytes = new_size;\n\t\t\treturn;\n\t\t}\n\t\tif (!is_power_of_2(new_size)){\n\t\t\trnew_size = roundup_pow_of_two(new_size);\n\t\t}\n\t\tif (rnew_size != ifp->if_real_bytes) {\n\t\t\tifp->if_u1.if_extents =\n\t\t\t\tkmem_realloc(ifp->if_u1.if_extents,\n\t\t\t\t\t\trnew_size,\n\t\t\t\t\t\tifp->if_real_bytes, KM_NOFS);\n\t\t}\n\t\tif (rnew_size > ifp->if_real_bytes) {\n\t\t\tmemset(&ifp->if_u1.if_extents[ifp->if_bytes /\n\t\t\t\t(uint)sizeof(xfs_bmbt_rec_t)], 0,\n\t\t\t\trnew_size - ifp->if_real_bytes);\n\t\t}\n\t}\n\t/* Switch from the inline extent buffer to a direct extent list */\n\telse {\n\t\tif (!is_power_of_2(new_size)) {\n\t\t\trnew_size = roundup_pow_of_two(new_size);\n\t\t}\n\t\txfs_iext_inline_to_direct(ifp, rnew_size);\n\t}\n\tifp->if_real_bytes = rnew_size;\n\tifp->if_bytes = new_size;\n}",
          "includes": [
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_attr_sf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nvoid\nxfs_iext_realloc_direct(\n\txfs_ifork_t\t*ifp,\t\t/* inode fork pointer */\n\tint\t\tnew_size)\t/* new size of extents after adding */\n{\n\tint\t\trnew_size;\t/* real new size of extents */\n\n\trnew_size = new_size;\n\n\tASSERT(!(ifp->if_flags & XFS_IFEXTIREC) ||\n\t\t((new_size >= 0) && (new_size <= XFS_IEXT_BUFSZ) &&\n\t\t (new_size != ifp->if_real_bytes)));\n\n\t/* Free extent records */\n\tif (new_size == 0) {\n\t\txfs_iext_destroy(ifp);\n\t}\n\t/* Resize direct extent list and zero any new bytes */\n\telse if (ifp->if_real_bytes) {\n\t\t/* Check if extents will fit inside the inode */\n\t\tif (new_size <= XFS_INLINE_EXTS * sizeof(xfs_bmbt_rec_t)) {\n\t\t\txfs_iext_direct_to_inline(ifp, new_size /\n\t\t\t\t(uint)sizeof(xfs_bmbt_rec_t));\n\t\t\tifp->if_bytes = new_size;\n\t\t\treturn;\n\t\t}\n\t\tif (!is_power_of_2(new_size)){\n\t\t\trnew_size = roundup_pow_of_two(new_size);\n\t\t}\n\t\tif (rnew_size != ifp->if_real_bytes) {\n\t\t\tifp->if_u1.if_extents =\n\t\t\t\tkmem_realloc(ifp->if_u1.if_extents,\n\t\t\t\t\t\trnew_size,\n\t\t\t\t\t\tifp->if_real_bytes, KM_NOFS);\n\t\t}\n\t\tif (rnew_size > ifp->if_real_bytes) {\n\t\t\tmemset(&ifp->if_u1.if_extents[ifp->if_bytes /\n\t\t\t\t(uint)sizeof(xfs_bmbt_rec_t)], 0,\n\t\t\t\trnew_size - ifp->if_real_bytes);\n\t\t}\n\t}\n\t/* Switch from the inline extent buffer to a direct extent list */\n\telse {\n\t\tif (!is_power_of_2(new_size)) {\n\t\t\trnew_size = roundup_pow_of_two(new_size);\n\t\t}\n\t\txfs_iext_inline_to_direct(ifp, rnew_size);\n\t}\n\tifp->if_real_bytes = rnew_size;\n\tifp->if_bytes = new_size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_iext_inline_to_direct",
          "args": [
            "ifp",
            "XFS_IEXT_BUFSZ"
          ],
          "line": 1714
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_iext_inline_to_direct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_inode_fork.c",
          "lines": "1428-1442",
          "snippet": "void\nxfs_iext_inline_to_direct(\n\txfs_ifork_t\t*ifp,\t\t/* inode fork pointer */\n\tint\t\tnew_size)\t/* number of extents in file */\n{\n\tifp->if_u1.if_extents = kmem_alloc(new_size, KM_NOFS);\n\tmemset(ifp->if_u1.if_extents, 0, new_size);\n\tif (ifp->if_bytes) {\n\t\tmemcpy(ifp->if_u1.if_extents, ifp->if_u2.if_inline_ext,\n\t\t\tifp->if_bytes);\n\t\tmemset(ifp->if_u2.if_inline_ext, 0, XFS_INLINE_EXTS *\n\t\t\tsizeof(xfs_bmbt_rec_t));\n\t}\n\tifp->if_real_bytes = new_size;\n}",
          "includes": [
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_attr_sf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nvoid\nxfs_iext_inline_to_direct(\n\txfs_ifork_t\t*ifp,\t\t/* inode fork pointer */\n\tint\t\tnew_size)\t/* number of extents in file */\n{\n\tifp->if_u1.if_extents = kmem_alloc(new_size, KM_NOFS);\n\tmemset(ifp->if_u1.if_extents, 0, new_size);\n\tif (ifp->if_bytes) {\n\t\tmemcpy(ifp->if_u1.if_extents, ifp->if_u2.if_inline_ext,\n\t\t\tifp->if_bytes);\n\t\tmemset(ifp->if_u2.if_inline_ext, 0, XFS_INLINE_EXTS *\n\t\t\tsizeof(xfs_bmbt_rec_t));\n\t}\n\tifp->if_real_bytes = new_size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmem_alloc",
          "args": [
            "XFS_IEXT_BUFSZ",
            "KM_NOFS"
          ],
          "line": 1712
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/kmem.c",
          "lines": "45-62",
          "snippet": "void *\nkmem_alloc(size_t size, xfs_km_flags_t flags)\n{\n\tint\tretries = 0;\n\tgfp_t\tlflags = kmem_flags_convert(flags);\n\tvoid\t*ptr;\n\n\tdo {\n\t\tptr = kmalloc(size, lflags);\n\t\tif (ptr || (flags & (KM_MAYFAIL|KM_NOSLEEP)))\n\t\t\treturn ptr;\n\t\tif (!(++retries % 100))\n\t\t\txfs_err(NULL,\n\t\t\"possible memory allocation deadlock in %s (mode:0x%x)\",\n\t\t\t\t\t__func__, lflags);\n\t\tcongestion_wait(BLK_RW_ASYNC, HZ/50);\n\t} while (1);\n}",
          "includes": [
            "#include \"xfs_message.h\"",
            "#include \"kmem.h\"",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_message.h\"\n#include \"kmem.h\"\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nvoid *\nkmem_alloc(size_t size, xfs_km_flags_t flags)\n{\n\tint\tretries = 0;\n\tgfp_t\tlflags = kmem_flags_convert(flags);\n\tvoid\t*ptr;\n\n\tdo {\n\t\tptr = kmalloc(size, lflags);\n\t\tif (ptr || (flags & (KM_MAYFAIL|KM_NOSLEEP)))\n\t\t\treturn ptr;\n\t\tif (!(++retries % 100))\n\t\t\txfs_err(NULL,\n\t\t\"possible memory allocation deadlock in %s (mode:0x%x)\",\n\t\t\t\t\t__func__, lflags);\n\t\tcongestion_wait(BLK_RW_ASYNC, HZ/50);\n\t} while (1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "nextents <= XFS_LINEAR_EXTS"
          ],
          "line": 1707
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "!(ifp->if_flags & XFS_IFEXTIREC)"
          ],
          "line": 1705
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_attr_sf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nvoid\nxfs_iext_irec_init(\n\txfs_ifork_t\t*ifp)\t\t/* inode fork pointer */\n{\n\txfs_ext_irec_t\t*erp;\t\t/* indirection array pointer */\n\txfs_extnum_t\tnextents;\t/* number of extents in file */\n\n\tASSERT(!(ifp->if_flags & XFS_IFEXTIREC));\n\tnextents = ifp->if_bytes / (uint)sizeof(xfs_bmbt_rec_t);\n\tASSERT(nextents <= XFS_LINEAR_EXTS);\n\n\terp = kmem_alloc(sizeof(xfs_ext_irec_t), KM_NOFS);\n\n\tif (nextents == 0) {\n\t\tifp->if_u1.if_extents = kmem_alloc(XFS_IEXT_BUFSZ, KM_NOFS);\n\t} else if (!ifp->if_real_bytes) {\n\t\txfs_iext_inline_to_direct(ifp, XFS_IEXT_BUFSZ);\n\t} else if (ifp->if_real_bytes < XFS_IEXT_BUFSZ) {\n\t\txfs_iext_realloc_direct(ifp, XFS_IEXT_BUFSZ);\n\t}\n\terp->er_extbuf = ifp->if_u1.if_extents;\n\terp->er_extcount = nextents;\n\terp->er_extoff = 0;\n\n\tifp->if_flags |= XFS_IFEXTIREC;\n\tifp->if_real_bytes = XFS_IEXT_BUFSZ;\n\tifp->if_bytes = nextents * sizeof(xfs_bmbt_rec_t);\n\tifp->if_u1.if_ext_irec = erp;\n\n\treturn;\n}"
  },
  {
    "function_name": "xfs_iext_idx_to_irec",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_inode_fork.c",
    "lines": "1640-1692",
    "snippet": "xfs_ext_irec_t *\nxfs_iext_idx_to_irec(\n\txfs_ifork_t\t*ifp,\t\t/* inode fork pointer */\n\txfs_extnum_t\t*idxp,\t\t/* extent index (file -> page) */\n\tint\t\t*erp_idxp,\t/* pointer to target irec */\n\tint\t\trealloc)\t/* new bytes were just added */\n{\n\txfs_ext_irec_t\t*prev;\t\t/* pointer to previous irec */\n\txfs_ext_irec_t\t*erp = NULL;\t/* pointer to current irec */\n\tint\t\terp_idx;\t/* indirection array index */\n\tint\t\tnlists;\t\t/* number of irec's (ex lists) */\n\tint\t\thigh;\t\t/* binary search upper limit */\n\tint\t\tlow;\t\t/* binary search lower limit */\n\txfs_extnum_t\tpage_idx = *idxp; /* extent index in target list */\n\n\tASSERT(ifp->if_flags & XFS_IFEXTIREC);\n\tASSERT(page_idx >= 0);\n\tASSERT(page_idx <= ifp->if_bytes / sizeof(xfs_bmbt_rec_t));\n\tASSERT(page_idx < ifp->if_bytes / sizeof(xfs_bmbt_rec_t) || realloc);\n\n\tnlists = ifp->if_real_bytes / XFS_IEXT_BUFSZ;\n\terp_idx = 0;\n\tlow = 0;\n\thigh = nlists - 1;\n\n\t/* Binary search extent irec's */\n\twhile (low <= high) {\n\t\terp_idx = (low + high) >> 1;\n\t\terp = &ifp->if_u1.if_ext_irec[erp_idx];\n\t\tprev = erp_idx > 0 ? erp - 1 : NULL;\n\t\tif (page_idx < erp->er_extoff || (page_idx == erp->er_extoff &&\n\t\t     realloc && prev && prev->er_extcount < XFS_LINEAR_EXTS)) {\n\t\t\thigh = erp_idx - 1;\n\t\t} else if (page_idx > erp->er_extoff + erp->er_extcount ||\n\t\t\t   (page_idx == erp->er_extoff + erp->er_extcount &&\n\t\t\t    !realloc)) {\n\t\t\tlow = erp_idx + 1;\n\t\t} else if (page_idx == erp->er_extoff + erp->er_extcount &&\n\t\t\t   erp->er_extcount == XFS_LINEAR_EXTS) {\n\t\t\tASSERT(realloc);\n\t\t\tpage_idx = 0;\n\t\t\terp_idx++;\n\t\t\terp = erp_idx < nlists ? erp + 1 : NULL;\n\t\t\tbreak;\n\t\t} else {\n\t\t\tpage_idx -= erp->er_extoff;\n\t\t\tbreak;\n\t\t}\n\t}\n\t*idxp = page_idx;\n\t*erp_idxp = erp_idx;\n\treturn erp;\n}",
    "includes": [
      "#include \"xfs_attr_sf.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\"",
      "#include <linux/log2.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "realloc"
          ],
          "line": 1679
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "page_idx < ifp->if_bytes / sizeof(xfs_bmbt_rec_t) || realloc"
          ],
          "line": 1658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "page_idx <= ifp->if_bytes / sizeof(xfs_bmbt_rec_t)"
          ],
          "line": 1657
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "page_idx >= 0"
          ],
          "line": 1656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "ifp->if_flags & XFS_IFEXTIREC"
          ],
          "line": 1655
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_attr_sf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nxfs_ext_irec_t *\nxfs_iext_idx_to_irec(\n\txfs_ifork_t\t*ifp,\t\t/* inode fork pointer */\n\txfs_extnum_t\t*idxp,\t\t/* extent index (file -> page) */\n\tint\t\t*erp_idxp,\t/* pointer to target irec */\n\tint\t\trealloc)\t/* new bytes were just added */\n{\n\txfs_ext_irec_t\t*prev;\t\t/* pointer to previous irec */\n\txfs_ext_irec_t\t*erp = NULL;\t/* pointer to current irec */\n\tint\t\terp_idx;\t/* indirection array index */\n\tint\t\tnlists;\t\t/* number of irec's (ex lists) */\n\tint\t\thigh;\t\t/* binary search upper limit */\n\tint\t\tlow;\t\t/* binary search lower limit */\n\txfs_extnum_t\tpage_idx = *idxp; /* extent index in target list */\n\n\tASSERT(ifp->if_flags & XFS_IFEXTIREC);\n\tASSERT(page_idx >= 0);\n\tASSERT(page_idx <= ifp->if_bytes / sizeof(xfs_bmbt_rec_t));\n\tASSERT(page_idx < ifp->if_bytes / sizeof(xfs_bmbt_rec_t) || realloc);\n\n\tnlists = ifp->if_real_bytes / XFS_IEXT_BUFSZ;\n\terp_idx = 0;\n\tlow = 0;\n\thigh = nlists - 1;\n\n\t/* Binary search extent irec's */\n\twhile (low <= high) {\n\t\terp_idx = (low + high) >> 1;\n\t\terp = &ifp->if_u1.if_ext_irec[erp_idx];\n\t\tprev = erp_idx > 0 ? erp - 1 : NULL;\n\t\tif (page_idx < erp->er_extoff || (page_idx == erp->er_extoff &&\n\t\t     realloc && prev && prev->er_extcount < XFS_LINEAR_EXTS)) {\n\t\t\thigh = erp_idx - 1;\n\t\t} else if (page_idx > erp->er_extoff + erp->er_extcount ||\n\t\t\t   (page_idx == erp->er_extoff + erp->er_extcount &&\n\t\t\t    !realloc)) {\n\t\t\tlow = erp_idx + 1;\n\t\t} else if (page_idx == erp->er_extoff + erp->er_extcount &&\n\t\t\t   erp->er_extcount == XFS_LINEAR_EXTS) {\n\t\t\tASSERT(realloc);\n\t\t\tpage_idx = 0;\n\t\t\terp_idx++;\n\t\t\terp = erp_idx < nlists ? erp + 1 : NULL;\n\t\t\tbreak;\n\t\t} else {\n\t\t\tpage_idx -= erp->er_extoff;\n\t\t\tbreak;\n\t\t}\n\t}\n\t*idxp = page_idx;\n\t*erp_idxp = erp_idx;\n\treturn erp;\n}"
  },
  {
    "function_name": "xfs_iext_bno_to_irec",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_inode_fork.c",
    "lines": "1599-1632",
    "snippet": "xfs_ext_irec_t *\t\t\t/* pointer to found extent record */\nxfs_iext_bno_to_irec(\n\txfs_ifork_t\t*ifp,\t\t/* inode fork pointer */\n\txfs_fileoff_t\tbno,\t\t/* block number to search for */\n\tint\t\t*erp_idxp)\t/* irec index of target ext list */\n{\n\txfs_ext_irec_t\t*erp = NULL;\t/* indirection array pointer */\n\txfs_ext_irec_t\t*erp_next;\t/* next indirection array entry */\n\tint\t\terp_idx;\t/* indirection array index */\n\tint\t\tnlists;\t\t/* number of extent irec's (lists) */\n\tint\t\thigh;\t\t/* binary search upper limit */\n\tint\t\tlow;\t\t/* binary search lower limit */\n\n\tASSERT(ifp->if_flags & XFS_IFEXTIREC);\n\tnlists = ifp->if_real_bytes / XFS_IEXT_BUFSZ;\n\terp_idx = 0;\n\tlow = 0;\n\thigh = nlists - 1;\n\twhile (low <= high) {\n\t\terp_idx = (low + high) >> 1;\n\t\terp = &ifp->if_u1.if_ext_irec[erp_idx];\n\t\terp_next = erp_idx < nlists - 1 ? erp + 1 : NULL;\n\t\tif (bno < xfs_bmbt_get_startoff(erp->er_extbuf)) {\n\t\t\thigh = erp_idx - 1;\n\t\t} else if (erp_next && bno >=\n\t\t\t   xfs_bmbt_get_startoff(erp_next->er_extbuf)) {\n\t\t\tlow = erp_idx + 1;\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\t*erp_idxp = erp_idx;\n\treturn erp;\n}",
    "includes": [
      "#include \"xfs_attr_sf.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\"",
      "#include <linux/log2.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_bmbt_get_startoff",
          "args": [
            "erp_next->er_extbuf"
          ],
          "line": 1624
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmbt_get_startoff",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap_btree.c",
          "lines": "155-161",
          "snippet": "xfs_fileoff_t\nxfs_bmbt_get_startoff(\n\txfs_bmbt_rec_host_t\t*r)\n{\n\treturn ((xfs_fileoff_t)r->l0 &\n\t\t xfs_mask64lo(64 - BMBT_EXNTFLAG_BITLEN)) >> 9;\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nxfs_fileoff_t\nxfs_bmbt_get_startoff(\n\txfs_bmbt_rec_host_t\t*r)\n{\n\treturn ((xfs_fileoff_t)r->l0 &\n\t\t xfs_mask64lo(64 - BMBT_EXNTFLAG_BITLEN)) >> 9;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "ifp->if_flags & XFS_IFEXTIREC"
          ],
          "line": 1612
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_attr_sf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nxfs_ext_irec_t *\t\t\t/* pointer to found extent record */\nxfs_iext_bno_to_irec(\n\txfs_ifork_t\t*ifp,\t\t/* inode fork pointer */\n\txfs_fileoff_t\tbno,\t\t/* block number to search for */\n\tint\t\t*erp_idxp)\t/* irec index of target ext list */\n{\n\txfs_ext_irec_t\t*erp = NULL;\t/* indirection array pointer */\n\txfs_ext_irec_t\t*erp_next;\t/* next indirection array entry */\n\tint\t\terp_idx;\t/* indirection array index */\n\tint\t\tnlists;\t\t/* number of extent irec's (lists) */\n\tint\t\thigh;\t\t/* binary search upper limit */\n\tint\t\tlow;\t\t/* binary search lower limit */\n\n\tASSERT(ifp->if_flags & XFS_IFEXTIREC);\n\tnlists = ifp->if_real_bytes / XFS_IEXT_BUFSZ;\n\terp_idx = 0;\n\tlow = 0;\n\thigh = nlists - 1;\n\twhile (low <= high) {\n\t\terp_idx = (low + high) >> 1;\n\t\terp = &ifp->if_u1.if_ext_irec[erp_idx];\n\t\terp_next = erp_idx < nlists - 1 ? erp + 1 : NULL;\n\t\tif (bno < xfs_bmbt_get_startoff(erp->er_extbuf)) {\n\t\t\thigh = erp_idx - 1;\n\t\t} else if (erp_next && bno >=\n\t\t\t   xfs_bmbt_get_startoff(erp_next->er_extbuf)) {\n\t\t\tlow = erp_idx + 1;\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\t*erp_idxp = erp_idx;\n\treturn erp;\n}"
  },
  {
    "function_name": "xfs_iext_bno_to_ext",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_inode_fork.c",
    "lines": "1528-1592",
    "snippet": "xfs_bmbt_rec_host_t *\t\t\t/* pointer to found extent record */\nxfs_iext_bno_to_ext(\n\txfs_ifork_t\t*ifp,\t\t/* inode fork pointer */\n\txfs_fileoff_t\tbno,\t\t/* block number to search for */\n\txfs_extnum_t\t*idxp)\t\t/* index of target extent */\n{\n\txfs_bmbt_rec_host_t *base;\t/* pointer to first extent */\n\txfs_filblks_t\tblockcount = 0;\t/* number of blocks in extent */\n\txfs_bmbt_rec_host_t *ep = NULL;\t/* pointer to target extent */\n\txfs_ext_irec_t\t*erp = NULL;\t/* indirection array pointer */\n\tint\t\thigh;\t\t/* upper boundary in search */\n\txfs_extnum_t\tidx = 0;\t/* index of target extent */\n\tint\t\tlow;\t\t/* lower boundary in search */\n\txfs_extnum_t\tnextents;\t/* number of file extents */\n\txfs_fileoff_t\tstartoff = 0;\t/* start offset of extent */\n\n\tnextents = ifp->if_bytes / (uint)sizeof(xfs_bmbt_rec_t);\n\tif (nextents == 0) {\n\t\t*idxp = 0;\n\t\treturn NULL;\n\t}\n\tlow = 0;\n\tif (ifp->if_flags & XFS_IFEXTIREC) {\n\t\t/* Find target extent list */\n\t\tint\terp_idx = 0;\n\t\terp = xfs_iext_bno_to_irec(ifp, bno, &erp_idx);\n\t\tbase = erp->er_extbuf;\n\t\thigh = erp->er_extcount - 1;\n\t} else {\n\t\tbase = ifp->if_u1.if_extents;\n\t\thigh = nextents - 1;\n\t}\n\t/* Binary search extent records */\n\twhile (low <= high) {\n\t\tidx = (low + high) >> 1;\n\t\tep = base + idx;\n\t\tstartoff = xfs_bmbt_get_startoff(ep);\n\t\tblockcount = xfs_bmbt_get_blockcount(ep);\n\t\tif (bno < startoff) {\n\t\t\thigh = idx - 1;\n\t\t} else if (bno >= startoff + blockcount) {\n\t\t\tlow = idx + 1;\n\t\t} else {\n\t\t\t/* Convert back to file-based extent index */\n\t\t\tif (ifp->if_flags & XFS_IFEXTIREC) {\n\t\t\t\tidx += erp->er_extoff;\n\t\t\t}\n\t\t\t*idxp = idx;\n\t\t\treturn ep;\n\t\t}\n\t}\n\t/* Convert back to file-based extent index */\n\tif (ifp->if_flags & XFS_IFEXTIREC) {\n\t\tidx += erp->er_extoff;\n\t}\n\tif (bno >= startoff + blockcount) {\n\t\tif (++idx == nextents) {\n\t\t\tep = NULL;\n\t\t} else {\n\t\t\tep = xfs_iext_get_ext(ifp, idx);\n\t\t}\n\t}\n\t*idxp = idx;\n\treturn ep;\n}",
    "includes": [
      "#include \"xfs_attr_sf.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\"",
      "#include <linux/log2.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_iext_get_ext",
          "args": [
            "ifp",
            "idx"
          ],
          "line": 1587
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_iext_get_ext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_inode_fork.c",
          "lines": "881-903",
          "snippet": "xfs_bmbt_rec_host_t *\nxfs_iext_get_ext(\n\txfs_ifork_t\t*ifp,\t\t/* inode fork pointer */\n\txfs_extnum_t\tidx)\t\t/* index of target extent */\n{\n\tASSERT(idx >= 0);\n\tASSERT(idx < ifp->if_bytes / sizeof(xfs_bmbt_rec_t));\n\n\tif ((ifp->if_flags & XFS_IFEXTIREC) && (idx == 0)) {\n\t\treturn ifp->if_u1.if_ext_irec->er_extbuf;\n\t} else if (ifp->if_flags & XFS_IFEXTIREC) {\n\t\txfs_ext_irec_t\t*erp;\t\t/* irec pointer */\n\t\tint\t\terp_idx = 0;\t/* irec index */\n\t\txfs_extnum_t\tpage_idx = idx;\t/* ext index in target list */\n\n\t\terp = xfs_iext_idx_to_irec(ifp, &page_idx, &erp_idx, 0);\n\t\treturn &erp->er_extbuf[page_idx];\n\t} else if (ifp->if_bytes) {\n\t\treturn &ifp->if_u1.if_extents[idx];\n\t} else {\n\t\treturn NULL;\n\t}\n}",
          "includes": [
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_attr_sf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nxfs_bmbt_rec_host_t *\nxfs_iext_get_ext(\n\txfs_ifork_t\t*ifp,\t\t/* inode fork pointer */\n\txfs_extnum_t\tidx)\t\t/* index of target extent */\n{\n\tASSERT(idx >= 0);\n\tASSERT(idx < ifp->if_bytes / sizeof(xfs_bmbt_rec_t));\n\n\tif ((ifp->if_flags & XFS_IFEXTIREC) && (idx == 0)) {\n\t\treturn ifp->if_u1.if_ext_irec->er_extbuf;\n\t} else if (ifp->if_flags & XFS_IFEXTIREC) {\n\t\txfs_ext_irec_t\t*erp;\t\t/* irec pointer */\n\t\tint\t\terp_idx = 0;\t/* irec index */\n\t\txfs_extnum_t\tpage_idx = idx;\t/* ext index in target list */\n\n\t\terp = xfs_iext_idx_to_irec(ifp, &page_idx, &erp_idx, 0);\n\t\treturn &erp->er_extbuf[page_idx];\n\t} else if (ifp->if_bytes) {\n\t\treturn &ifp->if_u1.if_extents[idx];\n\t} else {\n\t\treturn NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_bmbt_get_blockcount",
          "args": [
            "ep"
          ],
          "line": 1565
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmbt_get_blockcount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap_btree.c",
          "lines": "134-139",
          "snippet": "xfs_filblks_t\nxfs_bmbt_get_blockcount(\n\txfs_bmbt_rec_host_t\t*r)\n{\n\treturn (xfs_filblks_t)(r->l1 & xfs_mask64lo(21));\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nxfs_filblks_t\nxfs_bmbt_get_blockcount(\n\txfs_bmbt_rec_host_t\t*r)\n{\n\treturn (xfs_filblks_t)(r->l1 & xfs_mask64lo(21));\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_bmbt_get_startoff",
          "args": [
            "ep"
          ],
          "line": 1564
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmbt_get_startoff",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap_btree.c",
          "lines": "155-161",
          "snippet": "xfs_fileoff_t\nxfs_bmbt_get_startoff(\n\txfs_bmbt_rec_host_t\t*r)\n{\n\treturn ((xfs_fileoff_t)r->l0 &\n\t\t xfs_mask64lo(64 - BMBT_EXNTFLAG_BITLEN)) >> 9;\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nxfs_fileoff_t\nxfs_bmbt_get_startoff(\n\txfs_bmbt_rec_host_t\t*r)\n{\n\treturn ((xfs_fileoff_t)r->l0 &\n\t\t xfs_mask64lo(64 - BMBT_EXNTFLAG_BITLEN)) >> 9;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_iext_bno_to_irec",
          "args": [
            "ifp",
            "bno",
            "&erp_idx"
          ],
          "line": 1553
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_iext_bno_to_irec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_inode_fork.c",
          "lines": "1599-1632",
          "snippet": "xfs_ext_irec_t *\t\t\t/* pointer to found extent record */\nxfs_iext_bno_to_irec(\n\txfs_ifork_t\t*ifp,\t\t/* inode fork pointer */\n\txfs_fileoff_t\tbno,\t\t/* block number to search for */\n\tint\t\t*erp_idxp)\t/* irec index of target ext list */\n{\n\txfs_ext_irec_t\t*erp = NULL;\t/* indirection array pointer */\n\txfs_ext_irec_t\t*erp_next;\t/* next indirection array entry */\n\tint\t\terp_idx;\t/* indirection array index */\n\tint\t\tnlists;\t\t/* number of extent irec's (lists) */\n\tint\t\thigh;\t\t/* binary search upper limit */\n\tint\t\tlow;\t\t/* binary search lower limit */\n\n\tASSERT(ifp->if_flags & XFS_IFEXTIREC);\n\tnlists = ifp->if_real_bytes / XFS_IEXT_BUFSZ;\n\terp_idx = 0;\n\tlow = 0;\n\thigh = nlists - 1;\n\twhile (low <= high) {\n\t\terp_idx = (low + high) >> 1;\n\t\terp = &ifp->if_u1.if_ext_irec[erp_idx];\n\t\terp_next = erp_idx < nlists - 1 ? erp + 1 : NULL;\n\t\tif (bno < xfs_bmbt_get_startoff(erp->er_extbuf)) {\n\t\t\thigh = erp_idx - 1;\n\t\t} else if (erp_next && bno >=\n\t\t\t   xfs_bmbt_get_startoff(erp_next->er_extbuf)) {\n\t\t\tlow = erp_idx + 1;\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\t*erp_idxp = erp_idx;\n\treturn erp;\n}",
          "includes": [
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_attr_sf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nxfs_ext_irec_t *\t\t\t/* pointer to found extent record */\nxfs_iext_bno_to_irec(\n\txfs_ifork_t\t*ifp,\t\t/* inode fork pointer */\n\txfs_fileoff_t\tbno,\t\t/* block number to search for */\n\tint\t\t*erp_idxp)\t/* irec index of target ext list */\n{\n\txfs_ext_irec_t\t*erp = NULL;\t/* indirection array pointer */\n\txfs_ext_irec_t\t*erp_next;\t/* next indirection array entry */\n\tint\t\terp_idx;\t/* indirection array index */\n\tint\t\tnlists;\t\t/* number of extent irec's (lists) */\n\tint\t\thigh;\t\t/* binary search upper limit */\n\tint\t\tlow;\t\t/* binary search lower limit */\n\n\tASSERT(ifp->if_flags & XFS_IFEXTIREC);\n\tnlists = ifp->if_real_bytes / XFS_IEXT_BUFSZ;\n\terp_idx = 0;\n\tlow = 0;\n\thigh = nlists - 1;\n\twhile (low <= high) {\n\t\terp_idx = (low + high) >> 1;\n\t\terp = &ifp->if_u1.if_ext_irec[erp_idx];\n\t\terp_next = erp_idx < nlists - 1 ? erp + 1 : NULL;\n\t\tif (bno < xfs_bmbt_get_startoff(erp->er_extbuf)) {\n\t\t\thigh = erp_idx - 1;\n\t\t} else if (erp_next && bno >=\n\t\t\t   xfs_bmbt_get_startoff(erp_next->er_extbuf)) {\n\t\t\tlow = erp_idx + 1;\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\t*erp_idxp = erp_idx;\n\treturn erp;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_attr_sf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nxfs_bmbt_rec_host_t *\t\t\t/* pointer to found extent record */\nxfs_iext_bno_to_ext(\n\txfs_ifork_t\t*ifp,\t\t/* inode fork pointer */\n\txfs_fileoff_t\tbno,\t\t/* block number to search for */\n\txfs_extnum_t\t*idxp)\t\t/* index of target extent */\n{\n\txfs_bmbt_rec_host_t *base;\t/* pointer to first extent */\n\txfs_filblks_t\tblockcount = 0;\t/* number of blocks in extent */\n\txfs_bmbt_rec_host_t *ep = NULL;\t/* pointer to target extent */\n\txfs_ext_irec_t\t*erp = NULL;\t/* indirection array pointer */\n\tint\t\thigh;\t\t/* upper boundary in search */\n\txfs_extnum_t\tidx = 0;\t/* index of target extent */\n\tint\t\tlow;\t\t/* lower boundary in search */\n\txfs_extnum_t\tnextents;\t/* number of file extents */\n\txfs_fileoff_t\tstartoff = 0;\t/* start offset of extent */\n\n\tnextents = ifp->if_bytes / (uint)sizeof(xfs_bmbt_rec_t);\n\tif (nextents == 0) {\n\t\t*idxp = 0;\n\t\treturn NULL;\n\t}\n\tlow = 0;\n\tif (ifp->if_flags & XFS_IFEXTIREC) {\n\t\t/* Find target extent list */\n\t\tint\terp_idx = 0;\n\t\terp = xfs_iext_bno_to_irec(ifp, bno, &erp_idx);\n\t\tbase = erp->er_extbuf;\n\t\thigh = erp->er_extcount - 1;\n\t} else {\n\t\tbase = ifp->if_u1.if_extents;\n\t\thigh = nextents - 1;\n\t}\n\t/* Binary search extent records */\n\twhile (low <= high) {\n\t\tidx = (low + high) >> 1;\n\t\tep = base + idx;\n\t\tstartoff = xfs_bmbt_get_startoff(ep);\n\t\tblockcount = xfs_bmbt_get_blockcount(ep);\n\t\tif (bno < startoff) {\n\t\t\thigh = idx - 1;\n\t\t} else if (bno >= startoff + blockcount) {\n\t\t\tlow = idx + 1;\n\t\t} else {\n\t\t\t/* Convert back to file-based extent index */\n\t\t\tif (ifp->if_flags & XFS_IFEXTIREC) {\n\t\t\t\tidx += erp->er_extoff;\n\t\t\t}\n\t\t\t*idxp = idx;\n\t\t\treturn ep;\n\t\t}\n\t}\n\t/* Convert back to file-based extent index */\n\tif (ifp->if_flags & XFS_IFEXTIREC) {\n\t\tidx += erp->er_extoff;\n\t}\n\tif (bno >= startoff + blockcount) {\n\t\tif (++idx == nextents) {\n\t\t\tep = NULL;\n\t\t} else {\n\t\t\tep = xfs_iext_get_ext(ifp, idx);\n\t\t}\n\t}\n\t*idxp = idx;\n\treturn ep;\n}"
  },
  {
    "function_name": "xfs_iext_destroy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_inode_fork.c",
    "lines": "1501-1523",
    "snippet": "void\nxfs_iext_destroy(\n\txfs_ifork_t\t*ifp)\t\t/* inode fork pointer */\n{\n\tif (ifp->if_flags & XFS_IFEXTIREC) {\n\t\tint\terp_idx;\n\t\tint\tnlists;\n\n\t\tnlists = ifp->if_real_bytes / XFS_IEXT_BUFSZ;\n\t\tfor (erp_idx = nlists - 1; erp_idx >= 0 ; erp_idx--) {\n\t\t\txfs_iext_irec_remove(ifp, erp_idx);\n\t\t}\n\t\tifp->if_flags &= ~XFS_IFEXTIREC;\n\t} else if (ifp->if_real_bytes) {\n\t\tkmem_free(ifp->if_u1.if_extents);\n\t} else if (ifp->if_bytes) {\n\t\tmemset(ifp->if_u2.if_inline_ext, 0, XFS_INLINE_EXTS *\n\t\t\tsizeof(xfs_bmbt_rec_t));\n\t}\n\tifp->if_u1.if_extents = NULL;\n\tifp->if_real_bytes = 0;\n\tifp->if_bytes = 0;\n}",
    "includes": [
      "#include \"xfs_attr_sf.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\"",
      "#include <linux/log2.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "ifp->if_u2.if_inline_ext",
            "0",
            "XFS_INLINE_EXTS *\n\t\t\tsizeof(xfs_bmbt_rec_t)"
          ],
          "line": 1517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_free",
          "args": [
            "ifp->if_u1.if_extents"
          ],
          "line": 1515
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/kmem.h",
          "lines": "66-69",
          "snippet": "static inline void  kmem_free(const void *ptr)\n{\n\tkvfree(ptr);\n}",
          "includes": [
            "#include <linux/vmalloc.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n\nstatic inline void  kmem_free(const void *ptr)\n{\n\tkvfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_iext_irec_remove",
          "args": [
            "ifp",
            "erp_idx"
          ],
          "line": 1511
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_iext_irec_remove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_inode_fork.c",
          "lines": "1772-1808",
          "snippet": "void\nxfs_iext_irec_remove(\n\txfs_ifork_t\t*ifp,\t\t/* inode fork pointer */\n\tint\t\terp_idx)\t/* irec index to remove */\n{\n\txfs_ext_irec_t\t*erp;\t\t/* indirection array pointer */\n\tint\t\ti;\t\t/* loop counter */\n\tint\t\tnlists;\t\t/* number of irec's (ex lists) */\n\n\tASSERT(ifp->if_flags & XFS_IFEXTIREC);\n\tnlists = ifp->if_real_bytes / XFS_IEXT_BUFSZ;\n\terp = &ifp->if_u1.if_ext_irec[erp_idx];\n\tif (erp->er_extbuf) {\n\t\txfs_iext_irec_update_extoffs(ifp, erp_idx + 1,\n\t\t\t-erp->er_extcount);\n\t\tkmem_free(erp->er_extbuf);\n\t}\n\t/* Compact extent records */\n\terp = ifp->if_u1.if_ext_irec;\n\tfor (i = erp_idx; i < nlists - 1; i++) {\n\t\tmemmove(&erp[i], &erp[i+1], sizeof(xfs_ext_irec_t));\n\t}\n\t/*\n\t * Manually free the last extent record from the indirection\n\t * array.  A call to xfs_iext_realloc_indirect() with a size\n\t * of zero would result in a call to xfs_iext_destroy() which\n\t * would in turn call this function again, creating a nasty\n\t * infinite loop.\n\t */\n\tif (--nlists) {\n\t\txfs_iext_realloc_indirect(ifp,\n\t\t\tnlists * sizeof(xfs_ext_irec_t));\n\t} else {\n\t\tkmem_free(ifp->if_u1.if_ext_irec);\n\t}\n\tifp->if_real_bytes = nlists * XFS_IEXT_BUFSZ;\n}",
          "includes": [
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_attr_sf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nvoid\nxfs_iext_irec_remove(\n\txfs_ifork_t\t*ifp,\t\t/* inode fork pointer */\n\tint\t\terp_idx)\t/* irec index to remove */\n{\n\txfs_ext_irec_t\t*erp;\t\t/* indirection array pointer */\n\tint\t\ti;\t\t/* loop counter */\n\tint\t\tnlists;\t\t/* number of irec's (ex lists) */\n\n\tASSERT(ifp->if_flags & XFS_IFEXTIREC);\n\tnlists = ifp->if_real_bytes / XFS_IEXT_BUFSZ;\n\terp = &ifp->if_u1.if_ext_irec[erp_idx];\n\tif (erp->er_extbuf) {\n\t\txfs_iext_irec_update_extoffs(ifp, erp_idx + 1,\n\t\t\t-erp->er_extcount);\n\t\tkmem_free(erp->er_extbuf);\n\t}\n\t/* Compact extent records */\n\terp = ifp->if_u1.if_ext_irec;\n\tfor (i = erp_idx; i < nlists - 1; i++) {\n\t\tmemmove(&erp[i], &erp[i+1], sizeof(xfs_ext_irec_t));\n\t}\n\t/*\n\t * Manually free the last extent record from the indirection\n\t * array.  A call to xfs_iext_realloc_indirect() with a size\n\t * of zero would result in a call to xfs_iext_destroy() which\n\t * would in turn call this function again, creating a nasty\n\t * infinite loop.\n\t */\n\tif (--nlists) {\n\t\txfs_iext_realloc_indirect(ifp,\n\t\t\tnlists * sizeof(xfs_ext_irec_t));\n\t} else {\n\t\tkmem_free(ifp->if_u1.if_ext_irec);\n\t}\n\tifp->if_real_bytes = nlists * XFS_IEXT_BUFSZ;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_attr_sf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nvoid\nxfs_iext_destroy(\n\txfs_ifork_t\t*ifp)\t\t/* inode fork pointer */\n{\n\tif (ifp->if_flags & XFS_IFEXTIREC) {\n\t\tint\terp_idx;\n\t\tint\tnlists;\n\n\t\tnlists = ifp->if_real_bytes / XFS_IEXT_BUFSZ;\n\t\tfor (erp_idx = nlists - 1; erp_idx >= 0 ; erp_idx--) {\n\t\t\txfs_iext_irec_remove(ifp, erp_idx);\n\t\t}\n\t\tifp->if_flags &= ~XFS_IFEXTIREC;\n\t} else if (ifp->if_real_bytes) {\n\t\tkmem_free(ifp->if_u1.if_extents);\n\t} else if (ifp->if_bytes) {\n\t\tmemset(ifp->if_u2.if_inline_ext, 0, XFS_INLINE_EXTS *\n\t\t\tsizeof(xfs_bmbt_rec_t));\n\t}\n\tifp->if_u1.if_extents = NULL;\n\tifp->if_real_bytes = 0;\n\tifp->if_bytes = 0;\n}"
  },
  {
    "function_name": "xfs_iext_indirect_to_direct",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_inode_fork.c",
    "lines": "1472-1496",
    "snippet": "STATIC void\nxfs_iext_indirect_to_direct(\n\t xfs_ifork_t\t*ifp)\t\t/* inode fork pointer */\n{\n\txfs_bmbt_rec_host_t *ep;\t/* extent record pointer */\n\txfs_extnum_t\tnextents;\t/* number of extents in file */\n\tint\t\tsize;\t\t/* size of file extents */\n\n\tASSERT(ifp->if_flags & XFS_IFEXTIREC);\n\tnextents = ifp->if_bytes / (uint)sizeof(xfs_bmbt_rec_t);\n\tASSERT(nextents <= XFS_LINEAR_EXTS);\n\tsize = nextents * sizeof(xfs_bmbt_rec_t);\n\n\txfs_iext_irec_compact_pages(ifp);\n\tASSERT(ifp->if_real_bytes == XFS_IEXT_BUFSZ);\n\n\tep = ifp->if_u1.if_ext_irec->er_extbuf;\n\tkmem_free(ifp->if_u1.if_ext_irec);\n\tifp->if_flags &= ~XFS_IFEXTIREC;\n\tifp->if_u1.if_extents = ep;\n\tifp->if_bytes = size;\n\tif (nextents < XFS_LINEAR_EXTS) {\n\t\txfs_iext_realloc_direct(ifp, size);\n\t}\n}",
    "includes": [
      "#include \"xfs_attr_sf.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\"",
      "#include <linux/log2.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_iext_realloc_direct",
          "args": [
            "ifp",
            "size"
          ],
          "line": 1494
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_iext_realloc_direct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_inode_fork.c",
          "lines": "1346-1396",
          "snippet": "void\nxfs_iext_realloc_direct(\n\txfs_ifork_t\t*ifp,\t\t/* inode fork pointer */\n\tint\t\tnew_size)\t/* new size of extents after adding */\n{\n\tint\t\trnew_size;\t/* real new size of extents */\n\n\trnew_size = new_size;\n\n\tASSERT(!(ifp->if_flags & XFS_IFEXTIREC) ||\n\t\t((new_size >= 0) && (new_size <= XFS_IEXT_BUFSZ) &&\n\t\t (new_size != ifp->if_real_bytes)));\n\n\t/* Free extent records */\n\tif (new_size == 0) {\n\t\txfs_iext_destroy(ifp);\n\t}\n\t/* Resize direct extent list and zero any new bytes */\n\telse if (ifp->if_real_bytes) {\n\t\t/* Check if extents will fit inside the inode */\n\t\tif (new_size <= XFS_INLINE_EXTS * sizeof(xfs_bmbt_rec_t)) {\n\t\t\txfs_iext_direct_to_inline(ifp, new_size /\n\t\t\t\t(uint)sizeof(xfs_bmbt_rec_t));\n\t\t\tifp->if_bytes = new_size;\n\t\t\treturn;\n\t\t}\n\t\tif (!is_power_of_2(new_size)){\n\t\t\trnew_size = roundup_pow_of_two(new_size);\n\t\t}\n\t\tif (rnew_size != ifp->if_real_bytes) {\n\t\t\tifp->if_u1.if_extents =\n\t\t\t\tkmem_realloc(ifp->if_u1.if_extents,\n\t\t\t\t\t\trnew_size,\n\t\t\t\t\t\tifp->if_real_bytes, KM_NOFS);\n\t\t}\n\t\tif (rnew_size > ifp->if_real_bytes) {\n\t\t\tmemset(&ifp->if_u1.if_extents[ifp->if_bytes /\n\t\t\t\t(uint)sizeof(xfs_bmbt_rec_t)], 0,\n\t\t\t\trnew_size - ifp->if_real_bytes);\n\t\t}\n\t}\n\t/* Switch from the inline extent buffer to a direct extent list */\n\telse {\n\t\tif (!is_power_of_2(new_size)) {\n\t\t\trnew_size = roundup_pow_of_two(new_size);\n\t\t}\n\t\txfs_iext_inline_to_direct(ifp, rnew_size);\n\t}\n\tifp->if_real_bytes = rnew_size;\n\tifp->if_bytes = new_size;\n}",
          "includes": [
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_attr_sf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nvoid\nxfs_iext_realloc_direct(\n\txfs_ifork_t\t*ifp,\t\t/* inode fork pointer */\n\tint\t\tnew_size)\t/* new size of extents after adding */\n{\n\tint\t\trnew_size;\t/* real new size of extents */\n\n\trnew_size = new_size;\n\n\tASSERT(!(ifp->if_flags & XFS_IFEXTIREC) ||\n\t\t((new_size >= 0) && (new_size <= XFS_IEXT_BUFSZ) &&\n\t\t (new_size != ifp->if_real_bytes)));\n\n\t/* Free extent records */\n\tif (new_size == 0) {\n\t\txfs_iext_destroy(ifp);\n\t}\n\t/* Resize direct extent list and zero any new bytes */\n\telse if (ifp->if_real_bytes) {\n\t\t/* Check if extents will fit inside the inode */\n\t\tif (new_size <= XFS_INLINE_EXTS * sizeof(xfs_bmbt_rec_t)) {\n\t\t\txfs_iext_direct_to_inline(ifp, new_size /\n\t\t\t\t(uint)sizeof(xfs_bmbt_rec_t));\n\t\t\tifp->if_bytes = new_size;\n\t\t\treturn;\n\t\t}\n\t\tif (!is_power_of_2(new_size)){\n\t\t\trnew_size = roundup_pow_of_two(new_size);\n\t\t}\n\t\tif (rnew_size != ifp->if_real_bytes) {\n\t\t\tifp->if_u1.if_extents =\n\t\t\t\tkmem_realloc(ifp->if_u1.if_extents,\n\t\t\t\t\t\trnew_size,\n\t\t\t\t\t\tifp->if_real_bytes, KM_NOFS);\n\t\t}\n\t\tif (rnew_size > ifp->if_real_bytes) {\n\t\t\tmemset(&ifp->if_u1.if_extents[ifp->if_bytes /\n\t\t\t\t(uint)sizeof(xfs_bmbt_rec_t)], 0,\n\t\t\t\trnew_size - ifp->if_real_bytes);\n\t\t}\n\t}\n\t/* Switch from the inline extent buffer to a direct extent list */\n\telse {\n\t\tif (!is_power_of_2(new_size)) {\n\t\t\trnew_size = roundup_pow_of_two(new_size);\n\t\t}\n\t\txfs_iext_inline_to_direct(ifp, rnew_size);\n\t}\n\tifp->if_real_bytes = rnew_size;\n\tifp->if_bytes = new_size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmem_free",
          "args": [
            "ifp->if_u1.if_ext_irec"
          ],
          "line": 1489
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/kmem.h",
          "lines": "66-69",
          "snippet": "static inline void  kmem_free(const void *ptr)\n{\n\tkvfree(ptr);\n}",
          "includes": [
            "#include <linux/vmalloc.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n\nstatic inline void  kmem_free(const void *ptr)\n{\n\tkvfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "ifp->if_real_bytes == XFS_IEXT_BUFSZ"
          ],
          "line": 1486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_iext_irec_compact_pages",
          "args": [
            "ifp"
          ],
          "line": 1485
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_iext_irec_compact_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_inode_fork.c",
          "lines": "1847-1879",
          "snippet": "void\nxfs_iext_irec_compact_pages(\n\txfs_ifork_t\t*ifp)\t\t/* inode fork pointer */\n{\n\txfs_ext_irec_t\t*erp, *erp_next;/* pointers to irec entries */\n\tint\t\terp_idx = 0;\t/* indirection array index */\n\tint\t\tnlists;\t\t/* number of irec's (ex lists) */\n\n\tASSERT(ifp->if_flags & XFS_IFEXTIREC);\n\tnlists = ifp->if_real_bytes / XFS_IEXT_BUFSZ;\n\twhile (erp_idx < nlists - 1) {\n\t\terp = &ifp->if_u1.if_ext_irec[erp_idx];\n\t\terp_next = erp + 1;\n\t\tif (erp_next->er_extcount <=\n\t\t    (XFS_LINEAR_EXTS - erp->er_extcount)) {\n\t\t\tmemcpy(&erp->er_extbuf[erp->er_extcount],\n\t\t\t\terp_next->er_extbuf, erp_next->er_extcount *\n\t\t\t\tsizeof(xfs_bmbt_rec_t));\n\t\t\terp->er_extcount += erp_next->er_extcount;\n\t\t\t/*\n\t\t\t * Free page before removing extent record\n\t\t\t * so er_extoffs don't get modified in\n\t\t\t * xfs_iext_irec_remove.\n\t\t\t */\n\t\t\tkmem_free(erp_next->er_extbuf);\n\t\t\terp_next->er_extbuf = NULL;\n\t\t\txfs_iext_irec_remove(ifp, erp_idx + 1);\n\t\t\tnlists = ifp->if_real_bytes / XFS_IEXT_BUFSZ;\n\t\t} else {\n\t\t\terp_idx++;\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_attr_sf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nvoid\nxfs_iext_irec_compact_pages(\n\txfs_ifork_t\t*ifp)\t\t/* inode fork pointer */\n{\n\txfs_ext_irec_t\t*erp, *erp_next;/* pointers to irec entries */\n\tint\t\terp_idx = 0;\t/* indirection array index */\n\tint\t\tnlists;\t\t/* number of irec's (ex lists) */\n\n\tASSERT(ifp->if_flags & XFS_IFEXTIREC);\n\tnlists = ifp->if_real_bytes / XFS_IEXT_BUFSZ;\n\twhile (erp_idx < nlists - 1) {\n\t\terp = &ifp->if_u1.if_ext_irec[erp_idx];\n\t\terp_next = erp + 1;\n\t\tif (erp_next->er_extcount <=\n\t\t    (XFS_LINEAR_EXTS - erp->er_extcount)) {\n\t\t\tmemcpy(&erp->er_extbuf[erp->er_extcount],\n\t\t\t\terp_next->er_extbuf, erp_next->er_extcount *\n\t\t\t\tsizeof(xfs_bmbt_rec_t));\n\t\t\terp->er_extcount += erp_next->er_extcount;\n\t\t\t/*\n\t\t\t * Free page before removing extent record\n\t\t\t * so er_extoffs don't get modified in\n\t\t\t * xfs_iext_irec_remove.\n\t\t\t */\n\t\t\tkmem_free(erp_next->er_extbuf);\n\t\t\terp_next->er_extbuf = NULL;\n\t\t\txfs_iext_irec_remove(ifp, erp_idx + 1);\n\t\t\tnlists = ifp->if_real_bytes / XFS_IEXT_BUFSZ;\n\t\t} else {\n\t\t\terp_idx++;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "nextents <= XFS_LINEAR_EXTS"
          ],
          "line": 1482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "ifp->if_flags & XFS_IFEXTIREC"
          ],
          "line": 1480
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_attr_sf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC void\nxfs_iext_indirect_to_direct(\n\t xfs_ifork_t\t*ifp)\t\t/* inode fork pointer */\n{\n\txfs_bmbt_rec_host_t *ep;\t/* extent record pointer */\n\txfs_extnum_t\tnextents;\t/* number of extents in file */\n\tint\t\tsize;\t\t/* size of file extents */\n\n\tASSERT(ifp->if_flags & XFS_IFEXTIREC);\n\tnextents = ifp->if_bytes / (uint)sizeof(xfs_bmbt_rec_t);\n\tASSERT(nextents <= XFS_LINEAR_EXTS);\n\tsize = nextents * sizeof(xfs_bmbt_rec_t);\n\n\txfs_iext_irec_compact_pages(ifp);\n\tASSERT(ifp->if_real_bytes == XFS_IEXT_BUFSZ);\n\n\tep = ifp->if_u1.if_ext_irec->er_extbuf;\n\tkmem_free(ifp->if_u1.if_ext_irec);\n\tifp->if_flags &= ~XFS_IFEXTIREC;\n\tifp->if_u1.if_extents = ep;\n\tifp->if_bytes = size;\n\tif (nextents < XFS_LINEAR_EXTS) {\n\t\txfs_iext_realloc_direct(ifp, size);\n\t}\n}"
  },
  {
    "function_name": "xfs_iext_realloc_indirect",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_inode_fork.c",
    "lines": "1447-1467",
    "snippet": "STATIC void\nxfs_iext_realloc_indirect(\n\txfs_ifork_t\t*ifp,\t\t/* inode fork pointer */\n\tint\t\tnew_size)\t/* new indirection array size */\n{\n\tint\t\tnlists;\t\t/* number of irec's (ex lists) */\n\tint\t\tsize;\t\t/* current indirection array size */\n\n\tASSERT(ifp->if_flags & XFS_IFEXTIREC);\n\tnlists = ifp->if_real_bytes / XFS_IEXT_BUFSZ;\n\tsize = nlists * sizeof(xfs_ext_irec_t);\n\tASSERT(ifp->if_real_bytes);\n\tASSERT((new_size >= 0) && (new_size != size));\n\tif (new_size == 0) {\n\t\txfs_iext_destroy(ifp);\n\t} else {\n\t\tifp->if_u1.if_ext_irec = (xfs_ext_irec_t *)\n\t\t\tkmem_realloc(ifp->if_u1.if_ext_irec,\n\t\t\t\tnew_size, size, KM_NOFS);\n\t}\n}",
    "includes": [
      "#include \"xfs_attr_sf.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\"",
      "#include <linux/log2.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_realloc",
          "args": [
            "ifp->if_u1.if_ext_irec",
            "new_size",
            "size",
            "KM_NOFS"
          ],
          "line": 1464
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_realloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/kmem.c",
          "lines": "94-108",
          "snippet": "void *\nkmem_realloc(const void *ptr, size_t newsize, size_t oldsize,\n\t     xfs_km_flags_t flags)\n{\n\tvoid\t*new;\n\n\tnew = kmem_alloc(newsize, flags);\n\tif (ptr) {\n\t\tif (new)\n\t\t\tmemcpy(new, ptr,\n\t\t\t\t((oldsize < newsize) ? oldsize : newsize));\n\t\tkmem_free(ptr);\n\t}\n\treturn new;\n}",
          "includes": [
            "#include \"xfs_message.h\"",
            "#include \"kmem.h\"",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_message.h\"\n#include \"kmem.h\"\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nvoid *\nkmem_realloc(const void *ptr, size_t newsize, size_t oldsize,\n\t     xfs_km_flags_t flags)\n{\n\tvoid\t*new;\n\n\tnew = kmem_alloc(newsize, flags);\n\tif (ptr) {\n\t\tif (new)\n\t\t\tmemcpy(new, ptr,\n\t\t\t\t((oldsize < newsize) ? oldsize : newsize));\n\t\tkmem_free(ptr);\n\t}\n\treturn new;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_iext_destroy",
          "args": [
            "ifp"
          ],
          "line": 1461
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_iext_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_inode_fork.c",
          "lines": "1501-1523",
          "snippet": "void\nxfs_iext_destroy(\n\txfs_ifork_t\t*ifp)\t\t/* inode fork pointer */\n{\n\tif (ifp->if_flags & XFS_IFEXTIREC) {\n\t\tint\terp_idx;\n\t\tint\tnlists;\n\n\t\tnlists = ifp->if_real_bytes / XFS_IEXT_BUFSZ;\n\t\tfor (erp_idx = nlists - 1; erp_idx >= 0 ; erp_idx--) {\n\t\t\txfs_iext_irec_remove(ifp, erp_idx);\n\t\t}\n\t\tifp->if_flags &= ~XFS_IFEXTIREC;\n\t} else if (ifp->if_real_bytes) {\n\t\tkmem_free(ifp->if_u1.if_extents);\n\t} else if (ifp->if_bytes) {\n\t\tmemset(ifp->if_u2.if_inline_ext, 0, XFS_INLINE_EXTS *\n\t\t\tsizeof(xfs_bmbt_rec_t));\n\t}\n\tifp->if_u1.if_extents = NULL;\n\tifp->if_real_bytes = 0;\n\tifp->if_bytes = 0;\n}",
          "includes": [
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_attr_sf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nvoid\nxfs_iext_destroy(\n\txfs_ifork_t\t*ifp)\t\t/* inode fork pointer */\n{\n\tif (ifp->if_flags & XFS_IFEXTIREC) {\n\t\tint\terp_idx;\n\t\tint\tnlists;\n\n\t\tnlists = ifp->if_real_bytes / XFS_IEXT_BUFSZ;\n\t\tfor (erp_idx = nlists - 1; erp_idx >= 0 ; erp_idx--) {\n\t\t\txfs_iext_irec_remove(ifp, erp_idx);\n\t\t}\n\t\tifp->if_flags &= ~XFS_IFEXTIREC;\n\t} else if (ifp->if_real_bytes) {\n\t\tkmem_free(ifp->if_u1.if_extents);\n\t} else if (ifp->if_bytes) {\n\t\tmemset(ifp->if_u2.if_inline_ext, 0, XFS_INLINE_EXTS *\n\t\t\tsizeof(xfs_bmbt_rec_t));\n\t}\n\tifp->if_u1.if_extents = NULL;\n\tifp->if_real_bytes = 0;\n\tifp->if_bytes = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "(new_size >= 0) && (new_size != size)"
          ],
          "line": 1459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "ifp->if_real_bytes"
          ],
          "line": 1458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "ifp->if_flags & XFS_IFEXTIREC"
          ],
          "line": 1455
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_attr_sf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC void\nxfs_iext_realloc_indirect(\n\txfs_ifork_t\t*ifp,\t\t/* inode fork pointer */\n\tint\t\tnew_size)\t/* new indirection array size */\n{\n\tint\t\tnlists;\t\t/* number of irec's (ex lists) */\n\tint\t\tsize;\t\t/* current indirection array size */\n\n\tASSERT(ifp->if_flags & XFS_IFEXTIREC);\n\tnlists = ifp->if_real_bytes / XFS_IEXT_BUFSZ;\n\tsize = nlists * sizeof(xfs_ext_irec_t);\n\tASSERT(ifp->if_real_bytes);\n\tASSERT((new_size >= 0) && (new_size != size));\n\tif (new_size == 0) {\n\t\txfs_iext_destroy(ifp);\n\t} else {\n\t\tifp->if_u1.if_ext_irec = (xfs_ext_irec_t *)\n\t\t\tkmem_realloc(ifp->if_u1.if_ext_irec,\n\t\t\t\tnew_size, size, KM_NOFS);\n\t}\n}"
  },
  {
    "function_name": "xfs_iext_inline_to_direct",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_inode_fork.c",
    "lines": "1428-1442",
    "snippet": "void\nxfs_iext_inline_to_direct(\n\txfs_ifork_t\t*ifp,\t\t/* inode fork pointer */\n\tint\t\tnew_size)\t/* number of extents in file */\n{\n\tifp->if_u1.if_extents = kmem_alloc(new_size, KM_NOFS);\n\tmemset(ifp->if_u1.if_extents, 0, new_size);\n\tif (ifp->if_bytes) {\n\t\tmemcpy(ifp->if_u1.if_extents, ifp->if_u2.if_inline_ext,\n\t\t\tifp->if_bytes);\n\t\tmemset(ifp->if_u2.if_inline_ext, 0, XFS_INLINE_EXTS *\n\t\t\tsizeof(xfs_bmbt_rec_t));\n\t}\n\tifp->if_real_bytes = new_size;\n}",
    "includes": [
      "#include \"xfs_attr_sf.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\"",
      "#include <linux/log2.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "ifp->if_u2.if_inline_ext",
            "0",
            "XFS_INLINE_EXTS *\n\t\t\tsizeof(xfs_bmbt_rec_t)"
          ],
          "line": 1438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "ifp->if_u1.if_extents",
            "ifp->if_u2.if_inline_ext",
            "ifp->if_bytes"
          ],
          "line": 1436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "ifp->if_u1.if_extents",
            "0",
            "new_size"
          ],
          "line": 1434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_alloc",
          "args": [
            "new_size",
            "KM_NOFS"
          ],
          "line": 1433
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/kmem.c",
          "lines": "45-62",
          "snippet": "void *\nkmem_alloc(size_t size, xfs_km_flags_t flags)\n{\n\tint\tretries = 0;\n\tgfp_t\tlflags = kmem_flags_convert(flags);\n\tvoid\t*ptr;\n\n\tdo {\n\t\tptr = kmalloc(size, lflags);\n\t\tif (ptr || (flags & (KM_MAYFAIL|KM_NOSLEEP)))\n\t\t\treturn ptr;\n\t\tif (!(++retries % 100))\n\t\t\txfs_err(NULL,\n\t\t\"possible memory allocation deadlock in %s (mode:0x%x)\",\n\t\t\t\t\t__func__, lflags);\n\t\tcongestion_wait(BLK_RW_ASYNC, HZ/50);\n\t} while (1);\n}",
          "includes": [
            "#include \"xfs_message.h\"",
            "#include \"kmem.h\"",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_message.h\"\n#include \"kmem.h\"\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nvoid *\nkmem_alloc(size_t size, xfs_km_flags_t flags)\n{\n\tint\tretries = 0;\n\tgfp_t\tlflags = kmem_flags_convert(flags);\n\tvoid\t*ptr;\n\n\tdo {\n\t\tptr = kmalloc(size, lflags);\n\t\tif (ptr || (flags & (KM_MAYFAIL|KM_NOSLEEP)))\n\t\t\treturn ptr;\n\t\tif (!(++retries % 100))\n\t\t\txfs_err(NULL,\n\t\t\"possible memory allocation deadlock in %s (mode:0x%x)\",\n\t\t\t\t\t__func__, lflags);\n\t\tcongestion_wait(BLK_RW_ASYNC, HZ/50);\n\t} while (1);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_attr_sf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nvoid\nxfs_iext_inline_to_direct(\n\txfs_ifork_t\t*ifp,\t\t/* inode fork pointer */\n\tint\t\tnew_size)\t/* number of extents in file */\n{\n\tifp->if_u1.if_extents = kmem_alloc(new_size, KM_NOFS);\n\tmemset(ifp->if_u1.if_extents, 0, new_size);\n\tif (ifp->if_bytes) {\n\t\tmemcpy(ifp->if_u1.if_extents, ifp->if_u2.if_inline_ext,\n\t\t\tifp->if_bytes);\n\t\tmemset(ifp->if_u2.if_inline_ext, 0, XFS_INLINE_EXTS *\n\t\t\tsizeof(xfs_bmbt_rec_t));\n\t}\n\tifp->if_real_bytes = new_size;\n}"
  },
  {
    "function_name": "xfs_iext_direct_to_inline",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_inode_fork.c",
    "lines": "1401-1418",
    "snippet": "void\nxfs_iext_direct_to_inline(\n\txfs_ifork_t\t*ifp,\t\t/* inode fork pointer */\n\txfs_extnum_t\tnextents)\t/* number of extents in file */\n{\n\tASSERT(ifp->if_flags & XFS_IFEXTENTS);\n\tASSERT(nextents <= XFS_INLINE_EXTS);\n\t/*\n\t * The inline buffer was zeroed when we switched\n\t * from inline to direct extent allocation mode,\n\t * so we don't need to clear it here.\n\t */\n\tmemcpy(ifp->if_u2.if_inline_ext, ifp->if_u1.if_extents,\n\t\tnextents * sizeof(xfs_bmbt_rec_t));\n\tkmem_free(ifp->if_u1.if_extents);\n\tifp->if_u1.if_extents = ifp->if_u2.if_inline_ext;\n\tifp->if_real_bytes = 0;\n}",
    "includes": [
      "#include \"xfs_attr_sf.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\"",
      "#include <linux/log2.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_free",
          "args": [
            "ifp->if_u1.if_extents"
          ],
          "line": 1415
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/kmem.h",
          "lines": "66-69",
          "snippet": "static inline void  kmem_free(const void *ptr)\n{\n\tkvfree(ptr);\n}",
          "includes": [
            "#include <linux/vmalloc.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n\nstatic inline void  kmem_free(const void *ptr)\n{\n\tkvfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "ifp->if_u2.if_inline_ext",
            "ifp->if_u1.if_extents",
            "nextents * sizeof(xfs_bmbt_rec_t)"
          ],
          "line": 1413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "nextents <= XFS_INLINE_EXTS"
          ],
          "line": 1407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "ifp->if_flags & XFS_IFEXTENTS"
          ],
          "line": 1406
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_attr_sf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nvoid\nxfs_iext_direct_to_inline(\n\txfs_ifork_t\t*ifp,\t\t/* inode fork pointer */\n\txfs_extnum_t\tnextents)\t/* number of extents in file */\n{\n\tASSERT(ifp->if_flags & XFS_IFEXTENTS);\n\tASSERT(nextents <= XFS_INLINE_EXTS);\n\t/*\n\t * The inline buffer was zeroed when we switched\n\t * from inline to direct extent allocation mode,\n\t * so we don't need to clear it here.\n\t */\n\tmemcpy(ifp->if_u2.if_inline_ext, ifp->if_u1.if_extents,\n\t\tnextents * sizeof(xfs_bmbt_rec_t));\n\tkmem_free(ifp->if_u1.if_extents);\n\tifp->if_u1.if_extents = ifp->if_u2.if_inline_ext;\n\tifp->if_real_bytes = 0;\n}"
  },
  {
    "function_name": "xfs_iext_realloc_direct",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_inode_fork.c",
    "lines": "1346-1396",
    "snippet": "void\nxfs_iext_realloc_direct(\n\txfs_ifork_t\t*ifp,\t\t/* inode fork pointer */\n\tint\t\tnew_size)\t/* new size of extents after adding */\n{\n\tint\t\trnew_size;\t/* real new size of extents */\n\n\trnew_size = new_size;\n\n\tASSERT(!(ifp->if_flags & XFS_IFEXTIREC) ||\n\t\t((new_size >= 0) && (new_size <= XFS_IEXT_BUFSZ) &&\n\t\t (new_size != ifp->if_real_bytes)));\n\n\t/* Free extent records */\n\tif (new_size == 0) {\n\t\txfs_iext_destroy(ifp);\n\t}\n\t/* Resize direct extent list and zero any new bytes */\n\telse if (ifp->if_real_bytes) {\n\t\t/* Check if extents will fit inside the inode */\n\t\tif (new_size <= XFS_INLINE_EXTS * sizeof(xfs_bmbt_rec_t)) {\n\t\t\txfs_iext_direct_to_inline(ifp, new_size /\n\t\t\t\t(uint)sizeof(xfs_bmbt_rec_t));\n\t\t\tifp->if_bytes = new_size;\n\t\t\treturn;\n\t\t}\n\t\tif (!is_power_of_2(new_size)){\n\t\t\trnew_size = roundup_pow_of_two(new_size);\n\t\t}\n\t\tif (rnew_size != ifp->if_real_bytes) {\n\t\t\tifp->if_u1.if_extents =\n\t\t\t\tkmem_realloc(ifp->if_u1.if_extents,\n\t\t\t\t\t\trnew_size,\n\t\t\t\t\t\tifp->if_real_bytes, KM_NOFS);\n\t\t}\n\t\tif (rnew_size > ifp->if_real_bytes) {\n\t\t\tmemset(&ifp->if_u1.if_extents[ifp->if_bytes /\n\t\t\t\t(uint)sizeof(xfs_bmbt_rec_t)], 0,\n\t\t\t\trnew_size - ifp->if_real_bytes);\n\t\t}\n\t}\n\t/* Switch from the inline extent buffer to a direct extent list */\n\telse {\n\t\tif (!is_power_of_2(new_size)) {\n\t\t\trnew_size = roundup_pow_of_two(new_size);\n\t\t}\n\t\txfs_iext_inline_to_direct(ifp, rnew_size);\n\t}\n\tifp->if_real_bytes = rnew_size;\n\tifp->if_bytes = new_size;\n}",
    "includes": [
      "#include \"xfs_attr_sf.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\"",
      "#include <linux/log2.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_iext_inline_to_direct",
          "args": [
            "ifp",
            "rnew_size"
          ],
          "line": 1392
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_iext_inline_to_direct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_inode_fork.c",
          "lines": "1428-1442",
          "snippet": "void\nxfs_iext_inline_to_direct(\n\txfs_ifork_t\t*ifp,\t\t/* inode fork pointer */\n\tint\t\tnew_size)\t/* number of extents in file */\n{\n\tifp->if_u1.if_extents = kmem_alloc(new_size, KM_NOFS);\n\tmemset(ifp->if_u1.if_extents, 0, new_size);\n\tif (ifp->if_bytes) {\n\t\tmemcpy(ifp->if_u1.if_extents, ifp->if_u2.if_inline_ext,\n\t\t\tifp->if_bytes);\n\t\tmemset(ifp->if_u2.if_inline_ext, 0, XFS_INLINE_EXTS *\n\t\t\tsizeof(xfs_bmbt_rec_t));\n\t}\n\tifp->if_real_bytes = new_size;\n}",
          "includes": [
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_attr_sf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nvoid\nxfs_iext_inline_to_direct(\n\txfs_ifork_t\t*ifp,\t\t/* inode fork pointer */\n\tint\t\tnew_size)\t/* number of extents in file */\n{\n\tifp->if_u1.if_extents = kmem_alloc(new_size, KM_NOFS);\n\tmemset(ifp->if_u1.if_extents, 0, new_size);\n\tif (ifp->if_bytes) {\n\t\tmemcpy(ifp->if_u1.if_extents, ifp->if_u2.if_inline_ext,\n\t\t\tifp->if_bytes);\n\t\tmemset(ifp->if_u2.if_inline_ext, 0, XFS_INLINE_EXTS *\n\t\t\tsizeof(xfs_bmbt_rec_t));\n\t}\n\tifp->if_real_bytes = new_size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "roundup_pow_of_two",
          "args": [
            "new_size"
          ],
          "line": 1390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_power_of_2",
          "args": [
            "new_size"
          ],
          "line": 1389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&ifp->if_u1.if_extents[ifp->if_bytes /\n\t\t\t\t(uint)sizeof(xfs_bmbt_rec_t)]",
            "0",
            "rnew_size - ifp->if_real_bytes"
          ],
          "line": 1382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_realloc",
          "args": [
            "ifp->if_u1.if_extents",
            "rnew_size",
            "ifp->if_real_bytes",
            "KM_NOFS"
          ],
          "line": 1377
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_realloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/kmem.c",
          "lines": "94-108",
          "snippet": "void *\nkmem_realloc(const void *ptr, size_t newsize, size_t oldsize,\n\t     xfs_km_flags_t flags)\n{\n\tvoid\t*new;\n\n\tnew = kmem_alloc(newsize, flags);\n\tif (ptr) {\n\t\tif (new)\n\t\t\tmemcpy(new, ptr,\n\t\t\t\t((oldsize < newsize) ? oldsize : newsize));\n\t\tkmem_free(ptr);\n\t}\n\treturn new;\n}",
          "includes": [
            "#include \"xfs_message.h\"",
            "#include \"kmem.h\"",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_message.h\"\n#include \"kmem.h\"\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nvoid *\nkmem_realloc(const void *ptr, size_t newsize, size_t oldsize,\n\t     xfs_km_flags_t flags)\n{\n\tvoid\t*new;\n\n\tnew = kmem_alloc(newsize, flags);\n\tif (ptr) {\n\t\tif (new)\n\t\t\tmemcpy(new, ptr,\n\t\t\t\t((oldsize < newsize) ? oldsize : newsize));\n\t\tkmem_free(ptr);\n\t}\n\treturn new;\n}"
        }
      },
      {
        "call_info": {
          "callee": "roundup_pow_of_two",
          "args": [
            "new_size"
          ],
          "line": 1373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_power_of_2",
          "args": [
            "new_size"
          ],
          "line": 1372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_iext_direct_to_inline",
          "args": [
            "ifp",
            "new_size /\n\t\t\t\t(uint)sizeof(xfs_bmbt_rec_t)"
          ],
          "line": 1367
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_iext_direct_to_inline",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_inode_fork.c",
          "lines": "1401-1418",
          "snippet": "void\nxfs_iext_direct_to_inline(\n\txfs_ifork_t\t*ifp,\t\t/* inode fork pointer */\n\txfs_extnum_t\tnextents)\t/* number of extents in file */\n{\n\tASSERT(ifp->if_flags & XFS_IFEXTENTS);\n\tASSERT(nextents <= XFS_INLINE_EXTS);\n\t/*\n\t * The inline buffer was zeroed when we switched\n\t * from inline to direct extent allocation mode,\n\t * so we don't need to clear it here.\n\t */\n\tmemcpy(ifp->if_u2.if_inline_ext, ifp->if_u1.if_extents,\n\t\tnextents * sizeof(xfs_bmbt_rec_t));\n\tkmem_free(ifp->if_u1.if_extents);\n\tifp->if_u1.if_extents = ifp->if_u2.if_inline_ext;\n\tifp->if_real_bytes = 0;\n}",
          "includes": [
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_attr_sf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nvoid\nxfs_iext_direct_to_inline(\n\txfs_ifork_t\t*ifp,\t\t/* inode fork pointer */\n\txfs_extnum_t\tnextents)\t/* number of extents in file */\n{\n\tASSERT(ifp->if_flags & XFS_IFEXTENTS);\n\tASSERT(nextents <= XFS_INLINE_EXTS);\n\t/*\n\t * The inline buffer was zeroed when we switched\n\t * from inline to direct extent allocation mode,\n\t * so we don't need to clear it here.\n\t */\n\tmemcpy(ifp->if_u2.if_inline_ext, ifp->if_u1.if_extents,\n\t\tnextents * sizeof(xfs_bmbt_rec_t));\n\tkmem_free(ifp->if_u1.if_extents);\n\tifp->if_u1.if_extents = ifp->if_u2.if_inline_ext;\n\tifp->if_real_bytes = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_iext_destroy",
          "args": [
            "ifp"
          ],
          "line": 1361
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_iext_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_inode_fork.c",
          "lines": "1501-1523",
          "snippet": "void\nxfs_iext_destroy(\n\txfs_ifork_t\t*ifp)\t\t/* inode fork pointer */\n{\n\tif (ifp->if_flags & XFS_IFEXTIREC) {\n\t\tint\terp_idx;\n\t\tint\tnlists;\n\n\t\tnlists = ifp->if_real_bytes / XFS_IEXT_BUFSZ;\n\t\tfor (erp_idx = nlists - 1; erp_idx >= 0 ; erp_idx--) {\n\t\t\txfs_iext_irec_remove(ifp, erp_idx);\n\t\t}\n\t\tifp->if_flags &= ~XFS_IFEXTIREC;\n\t} else if (ifp->if_real_bytes) {\n\t\tkmem_free(ifp->if_u1.if_extents);\n\t} else if (ifp->if_bytes) {\n\t\tmemset(ifp->if_u2.if_inline_ext, 0, XFS_INLINE_EXTS *\n\t\t\tsizeof(xfs_bmbt_rec_t));\n\t}\n\tifp->if_u1.if_extents = NULL;\n\tifp->if_real_bytes = 0;\n\tifp->if_bytes = 0;\n}",
          "includes": [
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_attr_sf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nvoid\nxfs_iext_destroy(\n\txfs_ifork_t\t*ifp)\t\t/* inode fork pointer */\n{\n\tif (ifp->if_flags & XFS_IFEXTIREC) {\n\t\tint\terp_idx;\n\t\tint\tnlists;\n\n\t\tnlists = ifp->if_real_bytes / XFS_IEXT_BUFSZ;\n\t\tfor (erp_idx = nlists - 1; erp_idx >= 0 ; erp_idx--) {\n\t\t\txfs_iext_irec_remove(ifp, erp_idx);\n\t\t}\n\t\tifp->if_flags &= ~XFS_IFEXTIREC;\n\t} else if (ifp->if_real_bytes) {\n\t\tkmem_free(ifp->if_u1.if_extents);\n\t} else if (ifp->if_bytes) {\n\t\tmemset(ifp->if_u2.if_inline_ext, 0, XFS_INLINE_EXTS *\n\t\t\tsizeof(xfs_bmbt_rec_t));\n\t}\n\tifp->if_u1.if_extents = NULL;\n\tifp->if_real_bytes = 0;\n\tifp->if_bytes = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "!(ifp->if_flags & XFS_IFEXTIREC) ||\n\t\t((new_size >= 0) && (new_size <= XFS_IEXT_BUFSZ) &&\n\t\t (new_size != ifp->if_real_bytes))"
          ],
          "line": 1355
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_attr_sf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nvoid\nxfs_iext_realloc_direct(\n\txfs_ifork_t\t*ifp,\t\t/* inode fork pointer */\n\tint\t\tnew_size)\t/* new size of extents after adding */\n{\n\tint\t\trnew_size;\t/* real new size of extents */\n\n\trnew_size = new_size;\n\n\tASSERT(!(ifp->if_flags & XFS_IFEXTIREC) ||\n\t\t((new_size >= 0) && (new_size <= XFS_IEXT_BUFSZ) &&\n\t\t (new_size != ifp->if_real_bytes)));\n\n\t/* Free extent records */\n\tif (new_size == 0) {\n\t\txfs_iext_destroy(ifp);\n\t}\n\t/* Resize direct extent list and zero any new bytes */\n\telse if (ifp->if_real_bytes) {\n\t\t/* Check if extents will fit inside the inode */\n\t\tif (new_size <= XFS_INLINE_EXTS * sizeof(xfs_bmbt_rec_t)) {\n\t\t\txfs_iext_direct_to_inline(ifp, new_size /\n\t\t\t\t(uint)sizeof(xfs_bmbt_rec_t));\n\t\t\tifp->if_bytes = new_size;\n\t\t\treturn;\n\t\t}\n\t\tif (!is_power_of_2(new_size)){\n\t\t\trnew_size = roundup_pow_of_two(new_size);\n\t\t}\n\t\tif (rnew_size != ifp->if_real_bytes) {\n\t\t\tifp->if_u1.if_extents =\n\t\t\t\tkmem_realloc(ifp->if_u1.if_extents,\n\t\t\t\t\t\trnew_size,\n\t\t\t\t\t\tifp->if_real_bytes, KM_NOFS);\n\t\t}\n\t\tif (rnew_size > ifp->if_real_bytes) {\n\t\t\tmemset(&ifp->if_u1.if_extents[ifp->if_bytes /\n\t\t\t\t(uint)sizeof(xfs_bmbt_rec_t)], 0,\n\t\t\t\trnew_size - ifp->if_real_bytes);\n\t\t}\n\t}\n\t/* Switch from the inline extent buffer to a direct extent list */\n\telse {\n\t\tif (!is_power_of_2(new_size)) {\n\t\t\trnew_size = roundup_pow_of_two(new_size);\n\t\t}\n\t\txfs_iext_inline_to_direct(ifp, rnew_size);\n\t}\n\tifp->if_real_bytes = rnew_size;\n\tifp->if_bytes = new_size;\n}"
  },
  {
    "function_name": "xfs_iext_remove_indirect",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_inode_fork.c",
    "lines": "1282-1341",
    "snippet": "void\nxfs_iext_remove_indirect(\n\txfs_ifork_t\t*ifp,\t\t/* inode fork pointer */\n\txfs_extnum_t\tidx,\t\t/* index to begin removing extents */\n\tint\t\tcount)\t\t/* number of extents to remove */\n{\n\txfs_ext_irec_t\t*erp;\t\t/* indirection array pointer */\n\tint\t\terp_idx = 0;\t/* indirection array index */\n\txfs_extnum_t\text_cnt;\t/* extents left to remove */\n\txfs_extnum_t\text_diff;\t/* extents to remove in current list */\n\txfs_extnum_t\tnex1;\t\t/* number of extents before idx */\n\txfs_extnum_t\tnex2;\t\t/* extents after idx + count */\n\tint\t\tpage_idx = idx;\t/* index in target extent list */\n\n\tASSERT(ifp->if_flags & XFS_IFEXTIREC);\n\terp = xfs_iext_idx_to_irec(ifp,  &page_idx, &erp_idx, 0);\n\tASSERT(erp != NULL);\n\tnex1 = page_idx;\n\text_cnt = count;\n\twhile (ext_cnt) {\n\t\tnex2 = MAX((erp->er_extcount - (nex1 + ext_cnt)), 0);\n\t\text_diff = MIN(ext_cnt, (erp->er_extcount - nex1));\n\t\t/*\n\t\t * Check for deletion of entire list;\n\t\t * xfs_iext_irec_remove() updates extent offsets.\n\t\t */\n\t\tif (ext_diff == erp->er_extcount) {\n\t\t\txfs_iext_irec_remove(ifp, erp_idx);\n\t\t\text_cnt -= ext_diff;\n\t\t\tnex1 = 0;\n\t\t\tif (ext_cnt) {\n\t\t\t\tASSERT(erp_idx < ifp->if_real_bytes /\n\t\t\t\t\tXFS_IEXT_BUFSZ);\n\t\t\t\terp = &ifp->if_u1.if_ext_irec[erp_idx];\n\t\t\t\tnex1 = 0;\n\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t/* Move extents up (if needed) */\n\t\tif (nex2) {\n\t\t\tmemmove(&erp->er_extbuf[nex1],\n\t\t\t\t&erp->er_extbuf[nex1 + ext_diff],\n\t\t\t\tnex2 * sizeof(xfs_bmbt_rec_t));\n\t\t}\n\t\t/* Zero out rest of page */\n\t\tmemset(&erp->er_extbuf[nex1 + nex2], 0, (XFS_IEXT_BUFSZ -\n\t\t\t((nex1 + nex2) * sizeof(xfs_bmbt_rec_t))));\n\t\t/* Update remaining counters */\n\t\terp->er_extcount -= ext_diff;\n\t\txfs_iext_irec_update_extoffs(ifp, erp_idx + 1, -ext_diff);\n\t\text_cnt -= ext_diff;\n\t\tnex1 = 0;\n\t\terp_idx++;\n\t\terp++;\n\t}\n\tifp->if_bytes -= count * sizeof(xfs_bmbt_rec_t);\n\txfs_iext_irec_compact(ifp);\n}",
    "includes": [
      "#include \"xfs_attr_sf.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\"",
      "#include <linux/log2.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_iext_irec_compact",
          "args": [
            "ifp"
          ],
          "line": 1340
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_iext_irec_compact_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_inode_fork.c",
          "lines": "1847-1879",
          "snippet": "void\nxfs_iext_irec_compact_pages(\n\txfs_ifork_t\t*ifp)\t\t/* inode fork pointer */\n{\n\txfs_ext_irec_t\t*erp, *erp_next;/* pointers to irec entries */\n\tint\t\terp_idx = 0;\t/* indirection array index */\n\tint\t\tnlists;\t\t/* number of irec's (ex lists) */\n\n\tASSERT(ifp->if_flags & XFS_IFEXTIREC);\n\tnlists = ifp->if_real_bytes / XFS_IEXT_BUFSZ;\n\twhile (erp_idx < nlists - 1) {\n\t\terp = &ifp->if_u1.if_ext_irec[erp_idx];\n\t\terp_next = erp + 1;\n\t\tif (erp_next->er_extcount <=\n\t\t    (XFS_LINEAR_EXTS - erp->er_extcount)) {\n\t\t\tmemcpy(&erp->er_extbuf[erp->er_extcount],\n\t\t\t\terp_next->er_extbuf, erp_next->er_extcount *\n\t\t\t\tsizeof(xfs_bmbt_rec_t));\n\t\t\terp->er_extcount += erp_next->er_extcount;\n\t\t\t/*\n\t\t\t * Free page before removing extent record\n\t\t\t * so er_extoffs don't get modified in\n\t\t\t * xfs_iext_irec_remove.\n\t\t\t */\n\t\t\tkmem_free(erp_next->er_extbuf);\n\t\t\terp_next->er_extbuf = NULL;\n\t\t\txfs_iext_irec_remove(ifp, erp_idx + 1);\n\t\t\tnlists = ifp->if_real_bytes / XFS_IEXT_BUFSZ;\n\t\t} else {\n\t\t\terp_idx++;\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_attr_sf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nvoid\nxfs_iext_irec_compact_pages(\n\txfs_ifork_t\t*ifp)\t\t/* inode fork pointer */\n{\n\txfs_ext_irec_t\t*erp, *erp_next;/* pointers to irec entries */\n\tint\t\terp_idx = 0;\t/* indirection array index */\n\tint\t\tnlists;\t\t/* number of irec's (ex lists) */\n\n\tASSERT(ifp->if_flags & XFS_IFEXTIREC);\n\tnlists = ifp->if_real_bytes / XFS_IEXT_BUFSZ;\n\twhile (erp_idx < nlists - 1) {\n\t\terp = &ifp->if_u1.if_ext_irec[erp_idx];\n\t\terp_next = erp + 1;\n\t\tif (erp_next->er_extcount <=\n\t\t    (XFS_LINEAR_EXTS - erp->er_extcount)) {\n\t\t\tmemcpy(&erp->er_extbuf[erp->er_extcount],\n\t\t\t\terp_next->er_extbuf, erp_next->er_extcount *\n\t\t\t\tsizeof(xfs_bmbt_rec_t));\n\t\t\terp->er_extcount += erp_next->er_extcount;\n\t\t\t/*\n\t\t\t * Free page before removing extent record\n\t\t\t * so er_extoffs don't get modified in\n\t\t\t * xfs_iext_irec_remove.\n\t\t\t */\n\t\t\tkmem_free(erp_next->er_extbuf);\n\t\t\terp_next->er_extbuf = NULL;\n\t\t\txfs_iext_irec_remove(ifp, erp_idx + 1);\n\t\t\tnlists = ifp->if_real_bytes / XFS_IEXT_BUFSZ;\n\t\t} else {\n\t\t\terp_idx++;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_iext_irec_update_extoffs",
          "args": [
            "ifp",
            "erp_idx + 1",
            "-ext_diff"
          ],
          "line": 1333
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_iext_irec_update_extoffs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_inode_fork.c",
          "lines": "1888-1902",
          "snippet": "void\nxfs_iext_irec_update_extoffs(\n\txfs_ifork_t\t*ifp,\t\t/* inode fork pointer */\n\tint\t\terp_idx,\t/* irec index to update */\n\tint\t\text_diff)\t/* number of new extents */\n{\n\tint\t\ti;\t\t/* loop counter */\n\tint\t\tnlists;\t\t/* number of irec's (ex lists */\n\n\tASSERT(ifp->if_flags & XFS_IFEXTIREC);\n\tnlists = ifp->if_real_bytes / XFS_IEXT_BUFSZ;\n\tfor (i = erp_idx; i < nlists; i++) {\n\t\tifp->if_u1.if_ext_irec[i].er_extoff += ext_diff;\n\t}\n}",
          "includes": [
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_attr_sf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nvoid\nxfs_iext_irec_update_extoffs(\n\txfs_ifork_t\t*ifp,\t\t/* inode fork pointer */\n\tint\t\terp_idx,\t/* irec index to update */\n\tint\t\text_diff)\t/* number of new extents */\n{\n\tint\t\ti;\t\t/* loop counter */\n\tint\t\tnlists;\t\t/* number of irec's (ex lists */\n\n\tASSERT(ifp->if_flags & XFS_IFEXTIREC);\n\tnlists = ifp->if_real_bytes / XFS_IEXT_BUFSZ;\n\tfor (i = erp_idx; i < nlists; i++) {\n\t\tifp->if_u1.if_ext_irec[i].er_extoff += ext_diff;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&erp->er_extbuf[nex1 + nex2]",
            "0",
            "(XFS_IEXT_BUFSZ -\n\t\t\t((nex1 + nex2) * sizeof(xfs_bmbt_rec_t)))"
          ],
          "line": 1329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "&erp->er_extbuf[nex1]",
            "&erp->er_extbuf[nex1 + ext_diff]",
            "nex2 * sizeof(xfs_bmbt_rec_t)"
          ],
          "line": 1324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "erp_idx < ifp->if_real_bytes /\n\t\t\t\t\tXFS_IEXT_BUFSZ"
          ],
          "line": 1313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_iext_irec_remove",
          "args": [
            "ifp",
            "erp_idx"
          ],
          "line": 1309
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_iext_irec_remove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_inode_fork.c",
          "lines": "1772-1808",
          "snippet": "void\nxfs_iext_irec_remove(\n\txfs_ifork_t\t*ifp,\t\t/* inode fork pointer */\n\tint\t\terp_idx)\t/* irec index to remove */\n{\n\txfs_ext_irec_t\t*erp;\t\t/* indirection array pointer */\n\tint\t\ti;\t\t/* loop counter */\n\tint\t\tnlists;\t\t/* number of irec's (ex lists) */\n\n\tASSERT(ifp->if_flags & XFS_IFEXTIREC);\n\tnlists = ifp->if_real_bytes / XFS_IEXT_BUFSZ;\n\terp = &ifp->if_u1.if_ext_irec[erp_idx];\n\tif (erp->er_extbuf) {\n\t\txfs_iext_irec_update_extoffs(ifp, erp_idx + 1,\n\t\t\t-erp->er_extcount);\n\t\tkmem_free(erp->er_extbuf);\n\t}\n\t/* Compact extent records */\n\terp = ifp->if_u1.if_ext_irec;\n\tfor (i = erp_idx; i < nlists - 1; i++) {\n\t\tmemmove(&erp[i], &erp[i+1], sizeof(xfs_ext_irec_t));\n\t}\n\t/*\n\t * Manually free the last extent record from the indirection\n\t * array.  A call to xfs_iext_realloc_indirect() with a size\n\t * of zero would result in a call to xfs_iext_destroy() which\n\t * would in turn call this function again, creating a nasty\n\t * infinite loop.\n\t */\n\tif (--nlists) {\n\t\txfs_iext_realloc_indirect(ifp,\n\t\t\tnlists * sizeof(xfs_ext_irec_t));\n\t} else {\n\t\tkmem_free(ifp->if_u1.if_ext_irec);\n\t}\n\tifp->if_real_bytes = nlists * XFS_IEXT_BUFSZ;\n}",
          "includes": [
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_attr_sf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nvoid\nxfs_iext_irec_remove(\n\txfs_ifork_t\t*ifp,\t\t/* inode fork pointer */\n\tint\t\terp_idx)\t/* irec index to remove */\n{\n\txfs_ext_irec_t\t*erp;\t\t/* indirection array pointer */\n\tint\t\ti;\t\t/* loop counter */\n\tint\t\tnlists;\t\t/* number of irec's (ex lists) */\n\n\tASSERT(ifp->if_flags & XFS_IFEXTIREC);\n\tnlists = ifp->if_real_bytes / XFS_IEXT_BUFSZ;\n\terp = &ifp->if_u1.if_ext_irec[erp_idx];\n\tif (erp->er_extbuf) {\n\t\txfs_iext_irec_update_extoffs(ifp, erp_idx + 1,\n\t\t\t-erp->er_extcount);\n\t\tkmem_free(erp->er_extbuf);\n\t}\n\t/* Compact extent records */\n\terp = ifp->if_u1.if_ext_irec;\n\tfor (i = erp_idx; i < nlists - 1; i++) {\n\t\tmemmove(&erp[i], &erp[i+1], sizeof(xfs_ext_irec_t));\n\t}\n\t/*\n\t * Manually free the last extent record from the indirection\n\t * array.  A call to xfs_iext_realloc_indirect() with a size\n\t * of zero would result in a call to xfs_iext_destroy() which\n\t * would in turn call this function again, creating a nasty\n\t * infinite loop.\n\t */\n\tif (--nlists) {\n\t\txfs_iext_realloc_indirect(ifp,\n\t\t\tnlists * sizeof(xfs_ext_irec_t));\n\t} else {\n\t\tkmem_free(ifp->if_u1.if_ext_irec);\n\t}\n\tifp->if_real_bytes = nlists * XFS_IEXT_BUFSZ;\n}"
        }
      },
      {
        "call_info": {
          "callee": "MIN",
          "args": [
            "ext_cnt",
            "(erp->er_extcount - nex1)"
          ],
          "line": 1303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAX",
          "args": [
            "(erp->er_extcount - (nex1 + ext_cnt))",
            "0"
          ],
          "line": 1302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "erp != NULL"
          ],
          "line": 1298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_iext_idx_to_irec",
          "args": [
            "ifp",
            "&page_idx",
            "&erp_idx",
            "0"
          ],
          "line": 1297
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_iext_idx_to_irec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_inode_fork.c",
          "lines": "1640-1692",
          "snippet": "xfs_ext_irec_t *\nxfs_iext_idx_to_irec(\n\txfs_ifork_t\t*ifp,\t\t/* inode fork pointer */\n\txfs_extnum_t\t*idxp,\t\t/* extent index (file -> page) */\n\tint\t\t*erp_idxp,\t/* pointer to target irec */\n\tint\t\trealloc)\t/* new bytes were just added */\n{\n\txfs_ext_irec_t\t*prev;\t\t/* pointer to previous irec */\n\txfs_ext_irec_t\t*erp = NULL;\t/* pointer to current irec */\n\tint\t\terp_idx;\t/* indirection array index */\n\tint\t\tnlists;\t\t/* number of irec's (ex lists) */\n\tint\t\thigh;\t\t/* binary search upper limit */\n\tint\t\tlow;\t\t/* binary search lower limit */\n\txfs_extnum_t\tpage_idx = *idxp; /* extent index in target list */\n\n\tASSERT(ifp->if_flags & XFS_IFEXTIREC);\n\tASSERT(page_idx >= 0);\n\tASSERT(page_idx <= ifp->if_bytes / sizeof(xfs_bmbt_rec_t));\n\tASSERT(page_idx < ifp->if_bytes / sizeof(xfs_bmbt_rec_t) || realloc);\n\n\tnlists = ifp->if_real_bytes / XFS_IEXT_BUFSZ;\n\terp_idx = 0;\n\tlow = 0;\n\thigh = nlists - 1;\n\n\t/* Binary search extent irec's */\n\twhile (low <= high) {\n\t\terp_idx = (low + high) >> 1;\n\t\terp = &ifp->if_u1.if_ext_irec[erp_idx];\n\t\tprev = erp_idx > 0 ? erp - 1 : NULL;\n\t\tif (page_idx < erp->er_extoff || (page_idx == erp->er_extoff &&\n\t\t     realloc && prev && prev->er_extcount < XFS_LINEAR_EXTS)) {\n\t\t\thigh = erp_idx - 1;\n\t\t} else if (page_idx > erp->er_extoff + erp->er_extcount ||\n\t\t\t   (page_idx == erp->er_extoff + erp->er_extcount &&\n\t\t\t    !realloc)) {\n\t\t\tlow = erp_idx + 1;\n\t\t} else if (page_idx == erp->er_extoff + erp->er_extcount &&\n\t\t\t   erp->er_extcount == XFS_LINEAR_EXTS) {\n\t\t\tASSERT(realloc);\n\t\t\tpage_idx = 0;\n\t\t\terp_idx++;\n\t\t\terp = erp_idx < nlists ? erp + 1 : NULL;\n\t\t\tbreak;\n\t\t} else {\n\t\t\tpage_idx -= erp->er_extoff;\n\t\t\tbreak;\n\t\t}\n\t}\n\t*idxp = page_idx;\n\t*erp_idxp = erp_idx;\n\treturn erp;\n}",
          "includes": [
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_attr_sf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nxfs_ext_irec_t *\nxfs_iext_idx_to_irec(\n\txfs_ifork_t\t*ifp,\t\t/* inode fork pointer */\n\txfs_extnum_t\t*idxp,\t\t/* extent index (file -> page) */\n\tint\t\t*erp_idxp,\t/* pointer to target irec */\n\tint\t\trealloc)\t/* new bytes were just added */\n{\n\txfs_ext_irec_t\t*prev;\t\t/* pointer to previous irec */\n\txfs_ext_irec_t\t*erp = NULL;\t/* pointer to current irec */\n\tint\t\terp_idx;\t/* indirection array index */\n\tint\t\tnlists;\t\t/* number of irec's (ex lists) */\n\tint\t\thigh;\t\t/* binary search upper limit */\n\tint\t\tlow;\t\t/* binary search lower limit */\n\txfs_extnum_t\tpage_idx = *idxp; /* extent index in target list */\n\n\tASSERT(ifp->if_flags & XFS_IFEXTIREC);\n\tASSERT(page_idx >= 0);\n\tASSERT(page_idx <= ifp->if_bytes / sizeof(xfs_bmbt_rec_t));\n\tASSERT(page_idx < ifp->if_bytes / sizeof(xfs_bmbt_rec_t) || realloc);\n\n\tnlists = ifp->if_real_bytes / XFS_IEXT_BUFSZ;\n\terp_idx = 0;\n\tlow = 0;\n\thigh = nlists - 1;\n\n\t/* Binary search extent irec's */\n\twhile (low <= high) {\n\t\terp_idx = (low + high) >> 1;\n\t\terp = &ifp->if_u1.if_ext_irec[erp_idx];\n\t\tprev = erp_idx > 0 ? erp - 1 : NULL;\n\t\tif (page_idx < erp->er_extoff || (page_idx == erp->er_extoff &&\n\t\t     realloc && prev && prev->er_extcount < XFS_LINEAR_EXTS)) {\n\t\t\thigh = erp_idx - 1;\n\t\t} else if (page_idx > erp->er_extoff + erp->er_extcount ||\n\t\t\t   (page_idx == erp->er_extoff + erp->er_extcount &&\n\t\t\t    !realloc)) {\n\t\t\tlow = erp_idx + 1;\n\t\t} else if (page_idx == erp->er_extoff + erp->er_extcount &&\n\t\t\t   erp->er_extcount == XFS_LINEAR_EXTS) {\n\t\t\tASSERT(realloc);\n\t\t\tpage_idx = 0;\n\t\t\terp_idx++;\n\t\t\terp = erp_idx < nlists ? erp + 1 : NULL;\n\t\t\tbreak;\n\t\t} else {\n\t\t\tpage_idx -= erp->er_extoff;\n\t\t\tbreak;\n\t\t}\n\t}\n\t*idxp = page_idx;\n\t*erp_idxp = erp_idx;\n\treturn erp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "ifp->if_flags & XFS_IFEXTIREC"
          ],
          "line": 1296
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_attr_sf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nvoid\nxfs_iext_remove_indirect(\n\txfs_ifork_t\t*ifp,\t\t/* inode fork pointer */\n\txfs_extnum_t\tidx,\t\t/* index to begin removing extents */\n\tint\t\tcount)\t\t/* number of extents to remove */\n{\n\txfs_ext_irec_t\t*erp;\t\t/* indirection array pointer */\n\tint\t\terp_idx = 0;\t/* indirection array index */\n\txfs_extnum_t\text_cnt;\t/* extents left to remove */\n\txfs_extnum_t\text_diff;\t/* extents to remove in current list */\n\txfs_extnum_t\tnex1;\t\t/* number of extents before idx */\n\txfs_extnum_t\tnex2;\t\t/* extents after idx + count */\n\tint\t\tpage_idx = idx;\t/* index in target extent list */\n\n\tASSERT(ifp->if_flags & XFS_IFEXTIREC);\n\terp = xfs_iext_idx_to_irec(ifp,  &page_idx, &erp_idx, 0);\n\tASSERT(erp != NULL);\n\tnex1 = page_idx;\n\text_cnt = count;\n\twhile (ext_cnt) {\n\t\tnex2 = MAX((erp->er_extcount - (nex1 + ext_cnt)), 0);\n\t\text_diff = MIN(ext_cnt, (erp->er_extcount - nex1));\n\t\t/*\n\t\t * Check for deletion of entire list;\n\t\t * xfs_iext_irec_remove() updates extent offsets.\n\t\t */\n\t\tif (ext_diff == erp->er_extcount) {\n\t\t\txfs_iext_irec_remove(ifp, erp_idx);\n\t\t\text_cnt -= ext_diff;\n\t\t\tnex1 = 0;\n\t\t\tif (ext_cnt) {\n\t\t\t\tASSERT(erp_idx < ifp->if_real_bytes /\n\t\t\t\t\tXFS_IEXT_BUFSZ);\n\t\t\t\terp = &ifp->if_u1.if_ext_irec[erp_idx];\n\t\t\t\tnex1 = 0;\n\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t/* Move extents up (if needed) */\n\t\tif (nex2) {\n\t\t\tmemmove(&erp->er_extbuf[nex1],\n\t\t\t\t&erp->er_extbuf[nex1 + ext_diff],\n\t\t\t\tnex2 * sizeof(xfs_bmbt_rec_t));\n\t\t}\n\t\t/* Zero out rest of page */\n\t\tmemset(&erp->er_extbuf[nex1 + nex2], 0, (XFS_IEXT_BUFSZ -\n\t\t\t((nex1 + nex2) * sizeof(xfs_bmbt_rec_t))));\n\t\t/* Update remaining counters */\n\t\terp->er_extcount -= ext_diff;\n\t\txfs_iext_irec_update_extoffs(ifp, erp_idx + 1, -ext_diff);\n\t\text_cnt -= ext_diff;\n\t\tnex1 = 0;\n\t\terp_idx++;\n\t\terp++;\n\t}\n\tifp->if_bytes -= count * sizeof(xfs_bmbt_rec_t);\n\txfs_iext_irec_compact(ifp);\n}"
  },
  {
    "function_name": "xfs_iext_remove_direct",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_inode_fork.c",
    "lines": "1230-1265",
    "snippet": "void\nxfs_iext_remove_direct(\n\txfs_ifork_t\t*ifp,\t\t/* inode fork pointer */\n\txfs_extnum_t\tidx,\t\t/* index to begin removing exts */\n\tint\t\text_diff)\t/* number of extents to remove */\n{\n\txfs_extnum_t\tnextents;\t/* number of extents in file */\n\tint\t\tnew_size;\t/* size of extents after removal */\n\n\tASSERT(!(ifp->if_flags & XFS_IFEXTIREC));\n\tnew_size = ifp->if_bytes -\n\t\t(ext_diff * sizeof(xfs_bmbt_rec_t));\n\tnextents = ifp->if_bytes / (uint)sizeof(xfs_bmbt_rec_t);\n\n\tif (new_size == 0) {\n\t\txfs_iext_destroy(ifp);\n\t\treturn;\n\t}\n\t/* Move extents up in the list (if needed) */\n\tif (idx + ext_diff < nextents) {\n\t\tmemmove(&ifp->if_u1.if_extents[idx],\n\t\t\t&ifp->if_u1.if_extents[idx + ext_diff],\n\t\t\t(nextents - (idx + ext_diff)) *\n\t\t\t sizeof(xfs_bmbt_rec_t));\n\t}\n\tmemset(&ifp->if_u1.if_extents[nextents - ext_diff],\n\t\t0, ext_diff * sizeof(xfs_bmbt_rec_t));\n\t/*\n\t * Reallocate the direct extent list. If the extents\n\t * will fit inside the inode then xfs_iext_realloc_direct\n\t * will switch from direct to inline extent allocation\n\t * mode for us.\n\t */\n\txfs_iext_realloc_direct(ifp, new_size);\n\tifp->if_bytes = new_size;\n}",
    "includes": [
      "#include \"xfs_attr_sf.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\"",
      "#include <linux/log2.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_iext_realloc_direct",
          "args": [
            "ifp",
            "new_size"
          ],
          "line": 1263
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_iext_realloc_direct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_inode_fork.c",
          "lines": "1346-1396",
          "snippet": "void\nxfs_iext_realloc_direct(\n\txfs_ifork_t\t*ifp,\t\t/* inode fork pointer */\n\tint\t\tnew_size)\t/* new size of extents after adding */\n{\n\tint\t\trnew_size;\t/* real new size of extents */\n\n\trnew_size = new_size;\n\n\tASSERT(!(ifp->if_flags & XFS_IFEXTIREC) ||\n\t\t((new_size >= 0) && (new_size <= XFS_IEXT_BUFSZ) &&\n\t\t (new_size != ifp->if_real_bytes)));\n\n\t/* Free extent records */\n\tif (new_size == 0) {\n\t\txfs_iext_destroy(ifp);\n\t}\n\t/* Resize direct extent list and zero any new bytes */\n\telse if (ifp->if_real_bytes) {\n\t\t/* Check if extents will fit inside the inode */\n\t\tif (new_size <= XFS_INLINE_EXTS * sizeof(xfs_bmbt_rec_t)) {\n\t\t\txfs_iext_direct_to_inline(ifp, new_size /\n\t\t\t\t(uint)sizeof(xfs_bmbt_rec_t));\n\t\t\tifp->if_bytes = new_size;\n\t\t\treturn;\n\t\t}\n\t\tif (!is_power_of_2(new_size)){\n\t\t\trnew_size = roundup_pow_of_two(new_size);\n\t\t}\n\t\tif (rnew_size != ifp->if_real_bytes) {\n\t\t\tifp->if_u1.if_extents =\n\t\t\t\tkmem_realloc(ifp->if_u1.if_extents,\n\t\t\t\t\t\trnew_size,\n\t\t\t\t\t\tifp->if_real_bytes, KM_NOFS);\n\t\t}\n\t\tif (rnew_size > ifp->if_real_bytes) {\n\t\t\tmemset(&ifp->if_u1.if_extents[ifp->if_bytes /\n\t\t\t\t(uint)sizeof(xfs_bmbt_rec_t)], 0,\n\t\t\t\trnew_size - ifp->if_real_bytes);\n\t\t}\n\t}\n\t/* Switch from the inline extent buffer to a direct extent list */\n\telse {\n\t\tif (!is_power_of_2(new_size)) {\n\t\t\trnew_size = roundup_pow_of_two(new_size);\n\t\t}\n\t\txfs_iext_inline_to_direct(ifp, rnew_size);\n\t}\n\tifp->if_real_bytes = rnew_size;\n\tifp->if_bytes = new_size;\n}",
          "includes": [
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_attr_sf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nvoid\nxfs_iext_realloc_direct(\n\txfs_ifork_t\t*ifp,\t\t/* inode fork pointer */\n\tint\t\tnew_size)\t/* new size of extents after adding */\n{\n\tint\t\trnew_size;\t/* real new size of extents */\n\n\trnew_size = new_size;\n\n\tASSERT(!(ifp->if_flags & XFS_IFEXTIREC) ||\n\t\t((new_size >= 0) && (new_size <= XFS_IEXT_BUFSZ) &&\n\t\t (new_size != ifp->if_real_bytes)));\n\n\t/* Free extent records */\n\tif (new_size == 0) {\n\t\txfs_iext_destroy(ifp);\n\t}\n\t/* Resize direct extent list and zero any new bytes */\n\telse if (ifp->if_real_bytes) {\n\t\t/* Check if extents will fit inside the inode */\n\t\tif (new_size <= XFS_INLINE_EXTS * sizeof(xfs_bmbt_rec_t)) {\n\t\t\txfs_iext_direct_to_inline(ifp, new_size /\n\t\t\t\t(uint)sizeof(xfs_bmbt_rec_t));\n\t\t\tifp->if_bytes = new_size;\n\t\t\treturn;\n\t\t}\n\t\tif (!is_power_of_2(new_size)){\n\t\t\trnew_size = roundup_pow_of_two(new_size);\n\t\t}\n\t\tif (rnew_size != ifp->if_real_bytes) {\n\t\t\tifp->if_u1.if_extents =\n\t\t\t\tkmem_realloc(ifp->if_u1.if_extents,\n\t\t\t\t\t\trnew_size,\n\t\t\t\t\t\tifp->if_real_bytes, KM_NOFS);\n\t\t}\n\t\tif (rnew_size > ifp->if_real_bytes) {\n\t\t\tmemset(&ifp->if_u1.if_extents[ifp->if_bytes /\n\t\t\t\t(uint)sizeof(xfs_bmbt_rec_t)], 0,\n\t\t\t\trnew_size - ifp->if_real_bytes);\n\t\t}\n\t}\n\t/* Switch from the inline extent buffer to a direct extent list */\n\telse {\n\t\tif (!is_power_of_2(new_size)) {\n\t\t\trnew_size = roundup_pow_of_two(new_size);\n\t\t}\n\t\txfs_iext_inline_to_direct(ifp, rnew_size);\n\t}\n\tifp->if_real_bytes = rnew_size;\n\tifp->if_bytes = new_size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&ifp->if_u1.if_extents[nextents - ext_diff]",
            "0",
            "ext_diff * sizeof(xfs_bmbt_rec_t)"
          ],
          "line": 1255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "&ifp->if_u1.if_extents[idx]",
            "&ifp->if_u1.if_extents[idx + ext_diff]",
            "(nextents - (idx + ext_diff)) *\n\t\t\t sizeof(xfs_bmbt_rec_t)"
          ],
          "line": 1250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_iext_destroy",
          "args": [
            "ifp"
          ],
          "line": 1245
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_iext_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_inode_fork.c",
          "lines": "1501-1523",
          "snippet": "void\nxfs_iext_destroy(\n\txfs_ifork_t\t*ifp)\t\t/* inode fork pointer */\n{\n\tif (ifp->if_flags & XFS_IFEXTIREC) {\n\t\tint\terp_idx;\n\t\tint\tnlists;\n\n\t\tnlists = ifp->if_real_bytes / XFS_IEXT_BUFSZ;\n\t\tfor (erp_idx = nlists - 1; erp_idx >= 0 ; erp_idx--) {\n\t\t\txfs_iext_irec_remove(ifp, erp_idx);\n\t\t}\n\t\tifp->if_flags &= ~XFS_IFEXTIREC;\n\t} else if (ifp->if_real_bytes) {\n\t\tkmem_free(ifp->if_u1.if_extents);\n\t} else if (ifp->if_bytes) {\n\t\tmemset(ifp->if_u2.if_inline_ext, 0, XFS_INLINE_EXTS *\n\t\t\tsizeof(xfs_bmbt_rec_t));\n\t}\n\tifp->if_u1.if_extents = NULL;\n\tifp->if_real_bytes = 0;\n\tifp->if_bytes = 0;\n}",
          "includes": [
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_attr_sf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nvoid\nxfs_iext_destroy(\n\txfs_ifork_t\t*ifp)\t\t/* inode fork pointer */\n{\n\tif (ifp->if_flags & XFS_IFEXTIREC) {\n\t\tint\terp_idx;\n\t\tint\tnlists;\n\n\t\tnlists = ifp->if_real_bytes / XFS_IEXT_BUFSZ;\n\t\tfor (erp_idx = nlists - 1; erp_idx >= 0 ; erp_idx--) {\n\t\t\txfs_iext_irec_remove(ifp, erp_idx);\n\t\t}\n\t\tifp->if_flags &= ~XFS_IFEXTIREC;\n\t} else if (ifp->if_real_bytes) {\n\t\tkmem_free(ifp->if_u1.if_extents);\n\t} else if (ifp->if_bytes) {\n\t\tmemset(ifp->if_u2.if_inline_ext, 0, XFS_INLINE_EXTS *\n\t\t\tsizeof(xfs_bmbt_rec_t));\n\t}\n\tifp->if_u1.if_extents = NULL;\n\tifp->if_real_bytes = 0;\n\tifp->if_bytes = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "!(ifp->if_flags & XFS_IFEXTIREC)"
          ],
          "line": 1239
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_attr_sf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nvoid\nxfs_iext_remove_direct(\n\txfs_ifork_t\t*ifp,\t\t/* inode fork pointer */\n\txfs_extnum_t\tidx,\t\t/* index to begin removing exts */\n\tint\t\text_diff)\t/* number of extents to remove */\n{\n\txfs_extnum_t\tnextents;\t/* number of extents in file */\n\tint\t\tnew_size;\t/* size of extents after removal */\n\n\tASSERT(!(ifp->if_flags & XFS_IFEXTIREC));\n\tnew_size = ifp->if_bytes -\n\t\t(ext_diff * sizeof(xfs_bmbt_rec_t));\n\tnextents = ifp->if_bytes / (uint)sizeof(xfs_bmbt_rec_t);\n\n\tif (new_size == 0) {\n\t\txfs_iext_destroy(ifp);\n\t\treturn;\n\t}\n\t/* Move extents up in the list (if needed) */\n\tif (idx + ext_diff < nextents) {\n\t\tmemmove(&ifp->if_u1.if_extents[idx],\n\t\t\t&ifp->if_u1.if_extents[idx + ext_diff],\n\t\t\t(nextents - (idx + ext_diff)) *\n\t\t\t sizeof(xfs_bmbt_rec_t));\n\t}\n\tmemset(&ifp->if_u1.if_extents[nextents - ext_diff],\n\t\t0, ext_diff * sizeof(xfs_bmbt_rec_t));\n\t/*\n\t * Reallocate the direct extent list. If the extents\n\t * will fit inside the inode then xfs_iext_realloc_direct\n\t * will switch from direct to inline extent allocation\n\t * mode for us.\n\t */\n\txfs_iext_realloc_direct(ifp, new_size);\n\tifp->if_bytes = new_size;\n}"
  },
  {
    "function_name": "xfs_iext_remove_inline",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_inode_fork.c",
    "lines": "1193-1218",
    "snippet": "void\nxfs_iext_remove_inline(\n\txfs_ifork_t\t*ifp,\t\t/* inode fork pointer */\n\txfs_extnum_t\tidx,\t\t/* index to begin removing exts */\n\tint\t\text_diff)\t/* number of extents to remove */\n{\n\tint\t\tnextents;\t/* number of extents in file */\n\n\tASSERT(!(ifp->if_flags & XFS_IFEXTIREC));\n\tASSERT(idx < XFS_INLINE_EXTS);\n\tnextents = ifp->if_bytes / (uint)sizeof(xfs_bmbt_rec_t);\n\tASSERT(((nextents - ext_diff) > 0) &&\n\t\t(nextents - ext_diff) < XFS_INLINE_EXTS);\n\n\tif (idx + ext_diff < nextents) {\n\t\tmemmove(&ifp->if_u2.if_inline_ext[idx],\n\t\t\t&ifp->if_u2.if_inline_ext[idx + ext_diff],\n\t\t\t(nextents - (idx + ext_diff)) *\n\t\t\t sizeof(xfs_bmbt_rec_t));\n\t\tmemset(&ifp->if_u2.if_inline_ext[nextents - ext_diff],\n\t\t\t0, ext_diff * sizeof(xfs_bmbt_rec_t));\n\t} else {\n\t\tmemset(&ifp->if_u2.if_inline_ext[idx], 0,\n\t\t\text_diff * sizeof(xfs_bmbt_rec_t));\n\t}\n}",
    "includes": [
      "#include \"xfs_attr_sf.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\"",
      "#include <linux/log2.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&ifp->if_u2.if_inline_ext[idx]",
            "0",
            "ext_diff * sizeof(xfs_bmbt_rec_t)"
          ],
          "line": 1215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&ifp->if_u2.if_inline_ext[nextents - ext_diff]",
            "0",
            "ext_diff * sizeof(xfs_bmbt_rec_t)"
          ],
          "line": 1212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "&ifp->if_u2.if_inline_ext[idx]",
            "&ifp->if_u2.if_inline_ext[idx + ext_diff]",
            "(nextents - (idx + ext_diff)) *\n\t\t\t sizeof(xfs_bmbt_rec_t)"
          ],
          "line": 1208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "((nextents - ext_diff) > 0) &&\n\t\t(nextents - ext_diff) < XFS_INLINE_EXTS"
          ],
          "line": 1204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "idx < XFS_INLINE_EXTS"
          ],
          "line": 1202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "!(ifp->if_flags & XFS_IFEXTIREC)"
          ],
          "line": 1201
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_attr_sf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nvoid\nxfs_iext_remove_inline(\n\txfs_ifork_t\t*ifp,\t\t/* inode fork pointer */\n\txfs_extnum_t\tidx,\t\t/* index to begin removing exts */\n\tint\t\text_diff)\t/* number of extents to remove */\n{\n\tint\t\tnextents;\t/* number of extents in file */\n\n\tASSERT(!(ifp->if_flags & XFS_IFEXTIREC));\n\tASSERT(idx < XFS_INLINE_EXTS);\n\tnextents = ifp->if_bytes / (uint)sizeof(xfs_bmbt_rec_t);\n\tASSERT(((nextents - ext_diff) > 0) &&\n\t\t(nextents - ext_diff) < XFS_INLINE_EXTS);\n\n\tif (idx + ext_diff < nextents) {\n\t\tmemmove(&ifp->if_u2.if_inline_ext[idx],\n\t\t\t&ifp->if_u2.if_inline_ext[idx + ext_diff],\n\t\t\t(nextents - (idx + ext_diff)) *\n\t\t\t sizeof(xfs_bmbt_rec_t));\n\t\tmemset(&ifp->if_u2.if_inline_ext[nextents - ext_diff],\n\t\t\t0, ext_diff * sizeof(xfs_bmbt_rec_t));\n\t} else {\n\t\tmemset(&ifp->if_u2.if_inline_ext[idx], 0,\n\t\t\text_diff * sizeof(xfs_bmbt_rec_t));\n\t}\n}"
  },
  {
    "function_name": "xfs_iext_remove",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_inode_fork.c",
    "lines": "1160-1187",
    "snippet": "void\nxfs_iext_remove(\n\txfs_inode_t\t*ip,\t\t/* incore inode pointer */\n\txfs_extnum_t\tidx,\t\t/* index to begin removing exts */\n\tint\t\text_diff,\t/* number of extents to remove */\n\tint\t\tstate)\t\t/* type of extent conversion */\n{\n\txfs_ifork_t\t*ifp = (state & BMAP_ATTRFORK) ? ip->i_afp : &ip->i_df;\n\txfs_extnum_t\tnextents;\t/* number of extents in file */\n\tint\t\tnew_size;\t/* size of extents after removal */\n\n\ttrace_xfs_iext_remove(ip, idx, state, _RET_IP_);\n\n\tASSERT(ext_diff > 0);\n\tnextents = ifp->if_bytes / (uint)sizeof(xfs_bmbt_rec_t);\n\tnew_size = (nextents - ext_diff) * sizeof(xfs_bmbt_rec_t);\n\n\tif (new_size == 0) {\n\t\txfs_iext_destroy(ifp);\n\t} else if (ifp->if_flags & XFS_IFEXTIREC) {\n\t\txfs_iext_remove_indirect(ifp, idx, ext_diff);\n\t} else if (ifp->if_real_bytes) {\n\t\txfs_iext_remove_direct(ifp, idx, ext_diff);\n\t} else {\n\t\txfs_iext_remove_inline(ifp, idx, ext_diff);\n\t}\n\tifp->if_bytes = new_size;\n}",
    "includes": [
      "#include \"xfs_attr_sf.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\"",
      "#include <linux/log2.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_iext_remove_inline",
          "args": [
            "ifp",
            "idx",
            "ext_diff"
          ],
          "line": 1184
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_iext_remove_inline",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_inode_fork.c",
          "lines": "1193-1218",
          "snippet": "void\nxfs_iext_remove_inline(\n\txfs_ifork_t\t*ifp,\t\t/* inode fork pointer */\n\txfs_extnum_t\tidx,\t\t/* index to begin removing exts */\n\tint\t\text_diff)\t/* number of extents to remove */\n{\n\tint\t\tnextents;\t/* number of extents in file */\n\n\tASSERT(!(ifp->if_flags & XFS_IFEXTIREC));\n\tASSERT(idx < XFS_INLINE_EXTS);\n\tnextents = ifp->if_bytes / (uint)sizeof(xfs_bmbt_rec_t);\n\tASSERT(((nextents - ext_diff) > 0) &&\n\t\t(nextents - ext_diff) < XFS_INLINE_EXTS);\n\n\tif (idx + ext_diff < nextents) {\n\t\tmemmove(&ifp->if_u2.if_inline_ext[idx],\n\t\t\t&ifp->if_u2.if_inline_ext[idx + ext_diff],\n\t\t\t(nextents - (idx + ext_diff)) *\n\t\t\t sizeof(xfs_bmbt_rec_t));\n\t\tmemset(&ifp->if_u2.if_inline_ext[nextents - ext_diff],\n\t\t\t0, ext_diff * sizeof(xfs_bmbt_rec_t));\n\t} else {\n\t\tmemset(&ifp->if_u2.if_inline_ext[idx], 0,\n\t\t\text_diff * sizeof(xfs_bmbt_rec_t));\n\t}\n}",
          "includes": [
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_attr_sf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nvoid\nxfs_iext_remove_inline(\n\txfs_ifork_t\t*ifp,\t\t/* inode fork pointer */\n\txfs_extnum_t\tidx,\t\t/* index to begin removing exts */\n\tint\t\text_diff)\t/* number of extents to remove */\n{\n\tint\t\tnextents;\t/* number of extents in file */\n\n\tASSERT(!(ifp->if_flags & XFS_IFEXTIREC));\n\tASSERT(idx < XFS_INLINE_EXTS);\n\tnextents = ifp->if_bytes / (uint)sizeof(xfs_bmbt_rec_t);\n\tASSERT(((nextents - ext_diff) > 0) &&\n\t\t(nextents - ext_diff) < XFS_INLINE_EXTS);\n\n\tif (idx + ext_diff < nextents) {\n\t\tmemmove(&ifp->if_u2.if_inline_ext[idx],\n\t\t\t&ifp->if_u2.if_inline_ext[idx + ext_diff],\n\t\t\t(nextents - (idx + ext_diff)) *\n\t\t\t sizeof(xfs_bmbt_rec_t));\n\t\tmemset(&ifp->if_u2.if_inline_ext[nextents - ext_diff],\n\t\t\t0, ext_diff * sizeof(xfs_bmbt_rec_t));\n\t} else {\n\t\tmemset(&ifp->if_u2.if_inline_ext[idx], 0,\n\t\t\text_diff * sizeof(xfs_bmbt_rec_t));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_iext_remove_direct",
          "args": [
            "ifp",
            "idx",
            "ext_diff"
          ],
          "line": 1182
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_iext_remove_direct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_inode_fork.c",
          "lines": "1230-1265",
          "snippet": "void\nxfs_iext_remove_direct(\n\txfs_ifork_t\t*ifp,\t\t/* inode fork pointer */\n\txfs_extnum_t\tidx,\t\t/* index to begin removing exts */\n\tint\t\text_diff)\t/* number of extents to remove */\n{\n\txfs_extnum_t\tnextents;\t/* number of extents in file */\n\tint\t\tnew_size;\t/* size of extents after removal */\n\n\tASSERT(!(ifp->if_flags & XFS_IFEXTIREC));\n\tnew_size = ifp->if_bytes -\n\t\t(ext_diff * sizeof(xfs_bmbt_rec_t));\n\tnextents = ifp->if_bytes / (uint)sizeof(xfs_bmbt_rec_t);\n\n\tif (new_size == 0) {\n\t\txfs_iext_destroy(ifp);\n\t\treturn;\n\t}\n\t/* Move extents up in the list (if needed) */\n\tif (idx + ext_diff < nextents) {\n\t\tmemmove(&ifp->if_u1.if_extents[idx],\n\t\t\t&ifp->if_u1.if_extents[idx + ext_diff],\n\t\t\t(nextents - (idx + ext_diff)) *\n\t\t\t sizeof(xfs_bmbt_rec_t));\n\t}\n\tmemset(&ifp->if_u1.if_extents[nextents - ext_diff],\n\t\t0, ext_diff * sizeof(xfs_bmbt_rec_t));\n\t/*\n\t * Reallocate the direct extent list. If the extents\n\t * will fit inside the inode then xfs_iext_realloc_direct\n\t * will switch from direct to inline extent allocation\n\t * mode for us.\n\t */\n\txfs_iext_realloc_direct(ifp, new_size);\n\tifp->if_bytes = new_size;\n}",
          "includes": [
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_attr_sf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nvoid\nxfs_iext_remove_direct(\n\txfs_ifork_t\t*ifp,\t\t/* inode fork pointer */\n\txfs_extnum_t\tidx,\t\t/* index to begin removing exts */\n\tint\t\text_diff)\t/* number of extents to remove */\n{\n\txfs_extnum_t\tnextents;\t/* number of extents in file */\n\tint\t\tnew_size;\t/* size of extents after removal */\n\n\tASSERT(!(ifp->if_flags & XFS_IFEXTIREC));\n\tnew_size = ifp->if_bytes -\n\t\t(ext_diff * sizeof(xfs_bmbt_rec_t));\n\tnextents = ifp->if_bytes / (uint)sizeof(xfs_bmbt_rec_t);\n\n\tif (new_size == 0) {\n\t\txfs_iext_destroy(ifp);\n\t\treturn;\n\t}\n\t/* Move extents up in the list (if needed) */\n\tif (idx + ext_diff < nextents) {\n\t\tmemmove(&ifp->if_u1.if_extents[idx],\n\t\t\t&ifp->if_u1.if_extents[idx + ext_diff],\n\t\t\t(nextents - (idx + ext_diff)) *\n\t\t\t sizeof(xfs_bmbt_rec_t));\n\t}\n\tmemset(&ifp->if_u1.if_extents[nextents - ext_diff],\n\t\t0, ext_diff * sizeof(xfs_bmbt_rec_t));\n\t/*\n\t * Reallocate the direct extent list. If the extents\n\t * will fit inside the inode then xfs_iext_realloc_direct\n\t * will switch from direct to inline extent allocation\n\t * mode for us.\n\t */\n\txfs_iext_realloc_direct(ifp, new_size);\n\tifp->if_bytes = new_size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_iext_remove_indirect",
          "args": [
            "ifp",
            "idx",
            "ext_diff"
          ],
          "line": 1180
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_iext_remove_indirect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_inode_fork.c",
          "lines": "1282-1341",
          "snippet": "void\nxfs_iext_remove_indirect(\n\txfs_ifork_t\t*ifp,\t\t/* inode fork pointer */\n\txfs_extnum_t\tidx,\t\t/* index to begin removing extents */\n\tint\t\tcount)\t\t/* number of extents to remove */\n{\n\txfs_ext_irec_t\t*erp;\t\t/* indirection array pointer */\n\tint\t\terp_idx = 0;\t/* indirection array index */\n\txfs_extnum_t\text_cnt;\t/* extents left to remove */\n\txfs_extnum_t\text_diff;\t/* extents to remove in current list */\n\txfs_extnum_t\tnex1;\t\t/* number of extents before idx */\n\txfs_extnum_t\tnex2;\t\t/* extents after idx + count */\n\tint\t\tpage_idx = idx;\t/* index in target extent list */\n\n\tASSERT(ifp->if_flags & XFS_IFEXTIREC);\n\terp = xfs_iext_idx_to_irec(ifp,  &page_idx, &erp_idx, 0);\n\tASSERT(erp != NULL);\n\tnex1 = page_idx;\n\text_cnt = count;\n\twhile (ext_cnt) {\n\t\tnex2 = MAX((erp->er_extcount - (nex1 + ext_cnt)), 0);\n\t\text_diff = MIN(ext_cnt, (erp->er_extcount - nex1));\n\t\t/*\n\t\t * Check for deletion of entire list;\n\t\t * xfs_iext_irec_remove() updates extent offsets.\n\t\t */\n\t\tif (ext_diff == erp->er_extcount) {\n\t\t\txfs_iext_irec_remove(ifp, erp_idx);\n\t\t\text_cnt -= ext_diff;\n\t\t\tnex1 = 0;\n\t\t\tif (ext_cnt) {\n\t\t\t\tASSERT(erp_idx < ifp->if_real_bytes /\n\t\t\t\t\tXFS_IEXT_BUFSZ);\n\t\t\t\terp = &ifp->if_u1.if_ext_irec[erp_idx];\n\t\t\t\tnex1 = 0;\n\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t/* Move extents up (if needed) */\n\t\tif (nex2) {\n\t\t\tmemmove(&erp->er_extbuf[nex1],\n\t\t\t\t&erp->er_extbuf[nex1 + ext_diff],\n\t\t\t\tnex2 * sizeof(xfs_bmbt_rec_t));\n\t\t}\n\t\t/* Zero out rest of page */\n\t\tmemset(&erp->er_extbuf[nex1 + nex2], 0, (XFS_IEXT_BUFSZ -\n\t\t\t((nex1 + nex2) * sizeof(xfs_bmbt_rec_t))));\n\t\t/* Update remaining counters */\n\t\terp->er_extcount -= ext_diff;\n\t\txfs_iext_irec_update_extoffs(ifp, erp_idx + 1, -ext_diff);\n\t\text_cnt -= ext_diff;\n\t\tnex1 = 0;\n\t\terp_idx++;\n\t\terp++;\n\t}\n\tifp->if_bytes -= count * sizeof(xfs_bmbt_rec_t);\n\txfs_iext_irec_compact(ifp);\n}",
          "includes": [
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_attr_sf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nvoid\nxfs_iext_remove_indirect(\n\txfs_ifork_t\t*ifp,\t\t/* inode fork pointer */\n\txfs_extnum_t\tidx,\t\t/* index to begin removing extents */\n\tint\t\tcount)\t\t/* number of extents to remove */\n{\n\txfs_ext_irec_t\t*erp;\t\t/* indirection array pointer */\n\tint\t\terp_idx = 0;\t/* indirection array index */\n\txfs_extnum_t\text_cnt;\t/* extents left to remove */\n\txfs_extnum_t\text_diff;\t/* extents to remove in current list */\n\txfs_extnum_t\tnex1;\t\t/* number of extents before idx */\n\txfs_extnum_t\tnex2;\t\t/* extents after idx + count */\n\tint\t\tpage_idx = idx;\t/* index in target extent list */\n\n\tASSERT(ifp->if_flags & XFS_IFEXTIREC);\n\terp = xfs_iext_idx_to_irec(ifp,  &page_idx, &erp_idx, 0);\n\tASSERT(erp != NULL);\n\tnex1 = page_idx;\n\text_cnt = count;\n\twhile (ext_cnt) {\n\t\tnex2 = MAX((erp->er_extcount - (nex1 + ext_cnt)), 0);\n\t\text_diff = MIN(ext_cnt, (erp->er_extcount - nex1));\n\t\t/*\n\t\t * Check for deletion of entire list;\n\t\t * xfs_iext_irec_remove() updates extent offsets.\n\t\t */\n\t\tif (ext_diff == erp->er_extcount) {\n\t\t\txfs_iext_irec_remove(ifp, erp_idx);\n\t\t\text_cnt -= ext_diff;\n\t\t\tnex1 = 0;\n\t\t\tif (ext_cnt) {\n\t\t\t\tASSERT(erp_idx < ifp->if_real_bytes /\n\t\t\t\t\tXFS_IEXT_BUFSZ);\n\t\t\t\terp = &ifp->if_u1.if_ext_irec[erp_idx];\n\t\t\t\tnex1 = 0;\n\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t/* Move extents up (if needed) */\n\t\tif (nex2) {\n\t\t\tmemmove(&erp->er_extbuf[nex1],\n\t\t\t\t&erp->er_extbuf[nex1 + ext_diff],\n\t\t\t\tnex2 * sizeof(xfs_bmbt_rec_t));\n\t\t}\n\t\t/* Zero out rest of page */\n\t\tmemset(&erp->er_extbuf[nex1 + nex2], 0, (XFS_IEXT_BUFSZ -\n\t\t\t((nex1 + nex2) * sizeof(xfs_bmbt_rec_t))));\n\t\t/* Update remaining counters */\n\t\terp->er_extcount -= ext_diff;\n\t\txfs_iext_irec_update_extoffs(ifp, erp_idx + 1, -ext_diff);\n\t\text_cnt -= ext_diff;\n\t\tnex1 = 0;\n\t\terp_idx++;\n\t\terp++;\n\t}\n\tifp->if_bytes -= count * sizeof(xfs_bmbt_rec_t);\n\txfs_iext_irec_compact(ifp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_iext_destroy",
          "args": [
            "ifp"
          ],
          "line": 1178
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_iext_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_inode_fork.c",
          "lines": "1501-1523",
          "snippet": "void\nxfs_iext_destroy(\n\txfs_ifork_t\t*ifp)\t\t/* inode fork pointer */\n{\n\tif (ifp->if_flags & XFS_IFEXTIREC) {\n\t\tint\terp_idx;\n\t\tint\tnlists;\n\n\t\tnlists = ifp->if_real_bytes / XFS_IEXT_BUFSZ;\n\t\tfor (erp_idx = nlists - 1; erp_idx >= 0 ; erp_idx--) {\n\t\t\txfs_iext_irec_remove(ifp, erp_idx);\n\t\t}\n\t\tifp->if_flags &= ~XFS_IFEXTIREC;\n\t} else if (ifp->if_real_bytes) {\n\t\tkmem_free(ifp->if_u1.if_extents);\n\t} else if (ifp->if_bytes) {\n\t\tmemset(ifp->if_u2.if_inline_ext, 0, XFS_INLINE_EXTS *\n\t\t\tsizeof(xfs_bmbt_rec_t));\n\t}\n\tifp->if_u1.if_extents = NULL;\n\tifp->if_real_bytes = 0;\n\tifp->if_bytes = 0;\n}",
          "includes": [
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_attr_sf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nvoid\nxfs_iext_destroy(\n\txfs_ifork_t\t*ifp)\t\t/* inode fork pointer */\n{\n\tif (ifp->if_flags & XFS_IFEXTIREC) {\n\t\tint\terp_idx;\n\t\tint\tnlists;\n\n\t\tnlists = ifp->if_real_bytes / XFS_IEXT_BUFSZ;\n\t\tfor (erp_idx = nlists - 1; erp_idx >= 0 ; erp_idx--) {\n\t\t\txfs_iext_irec_remove(ifp, erp_idx);\n\t\t}\n\t\tifp->if_flags &= ~XFS_IFEXTIREC;\n\t} else if (ifp->if_real_bytes) {\n\t\tkmem_free(ifp->if_u1.if_extents);\n\t} else if (ifp->if_bytes) {\n\t\tmemset(ifp->if_u2.if_inline_ext, 0, XFS_INLINE_EXTS *\n\t\t\tsizeof(xfs_bmbt_rec_t));\n\t}\n\tifp->if_u1.if_extents = NULL;\n\tifp->if_real_bytes = 0;\n\tifp->if_bytes = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "ext_diff > 0"
          ],
          "line": 1173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_xfs_iext_remove",
          "args": [
            "ip",
            "idx",
            "state",
            "_RET_IP_"
          ],
          "line": 1171
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_attr_sf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nvoid\nxfs_iext_remove(\n\txfs_inode_t\t*ip,\t\t/* incore inode pointer */\n\txfs_extnum_t\tidx,\t\t/* index to begin removing exts */\n\tint\t\text_diff,\t/* number of extents to remove */\n\tint\t\tstate)\t\t/* type of extent conversion */\n{\n\txfs_ifork_t\t*ifp = (state & BMAP_ATTRFORK) ? ip->i_afp : &ip->i_df;\n\txfs_extnum_t\tnextents;\t/* number of extents in file */\n\tint\t\tnew_size;\t/* size of extents after removal */\n\n\ttrace_xfs_iext_remove(ip, idx, state, _RET_IP_);\n\n\tASSERT(ext_diff > 0);\n\tnextents = ifp->if_bytes / (uint)sizeof(xfs_bmbt_rec_t);\n\tnew_size = (nextents - ext_diff) * sizeof(xfs_bmbt_rec_t);\n\n\tif (new_size == 0) {\n\t\txfs_iext_destroy(ifp);\n\t} else if (ifp->if_flags & XFS_IFEXTIREC) {\n\t\txfs_iext_remove_indirect(ifp, idx, ext_diff);\n\t} else if (ifp->if_real_bytes) {\n\t\txfs_iext_remove_direct(ifp, idx, ext_diff);\n\t} else {\n\t\txfs_iext_remove_inline(ifp, idx, ext_diff);\n\t}\n\tifp->if_bytes = new_size;\n}"
  },
  {
    "function_name": "xfs_iext_add_indirect_multi",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_inode_fork.c",
    "lines": "1052-1147",
    "snippet": "void\nxfs_iext_add_indirect_multi(\n\txfs_ifork_t\t*ifp,\t\t\t/* inode fork pointer */\n\tint\t\terp_idx,\t\t/* target extent irec index */\n\txfs_extnum_t\tidx,\t\t\t/* index within target list */\n\tint\t\tcount)\t\t\t/* new extents being added */\n{\n\tint\t\tbyte_diff;\t\t/* new bytes being added */\n\txfs_ext_irec_t\t*erp;\t\t\t/* pointer to irec entry */\n\txfs_extnum_t\text_diff;\t\t/* number of extents to add */\n\txfs_extnum_t\text_cnt;\t\t/* new extents still needed */\n\txfs_extnum_t\tnex2;\t\t\t/* extents after idx + count */\n\txfs_bmbt_rec_t\t*nex2_ep = NULL;\t/* temp list for nex2 extents */\n\tint\t\tnlists;\t\t\t/* number of irec's (lists) */\n\n\tASSERT(ifp->if_flags & XFS_IFEXTIREC);\n\terp = &ifp->if_u1.if_ext_irec[erp_idx];\n\tnex2 = erp->er_extcount - idx;\n\tnlists = ifp->if_real_bytes / XFS_IEXT_BUFSZ;\n\n\t/*\n\t * Save second part of target extent list\n\t * (all extents past */\n\tif (nex2) {\n\t\tbyte_diff = nex2 * sizeof(xfs_bmbt_rec_t);\n\t\tnex2_ep = (xfs_bmbt_rec_t *) kmem_alloc(byte_diff, KM_NOFS);\n\t\tmemmove(nex2_ep, &erp->er_extbuf[idx], byte_diff);\n\t\terp->er_extcount -= nex2;\n\t\txfs_iext_irec_update_extoffs(ifp, erp_idx + 1, -nex2);\n\t\tmemset(&erp->er_extbuf[idx], 0, byte_diff);\n\t}\n\n\t/*\n\t * Add the new extents to the end of the target\n\t * list, then allocate new irec record(s) and\n\t * extent buffer(s) as needed to store the rest\n\t * of the new extents.\n\t */\n\text_cnt = count;\n\text_diff = MIN(ext_cnt, (int)XFS_LINEAR_EXTS - erp->er_extcount);\n\tif (ext_diff) {\n\t\terp->er_extcount += ext_diff;\n\t\txfs_iext_irec_update_extoffs(ifp, erp_idx + 1, ext_diff);\n\t\text_cnt -= ext_diff;\n\t}\n\twhile (ext_cnt) {\n\t\terp_idx++;\n\t\terp = xfs_iext_irec_new(ifp, erp_idx);\n\t\text_diff = MIN(ext_cnt, (int)XFS_LINEAR_EXTS);\n\t\terp->er_extcount = ext_diff;\n\t\txfs_iext_irec_update_extoffs(ifp, erp_idx + 1, ext_diff);\n\t\text_cnt -= ext_diff;\n\t}\n\n\t/* Add nex2 extents back to indirection array */\n\tif (nex2) {\n\t\txfs_extnum_t\text_avail;\n\t\tint\t\ti;\n\n\t\tbyte_diff = nex2 * sizeof(xfs_bmbt_rec_t);\n\t\text_avail = XFS_LINEAR_EXTS - erp->er_extcount;\n\t\ti = 0;\n\t\t/*\n\t\t * If nex2 extents fit in the current page, append\n\t\t * nex2_ep after the new extents.\n\t\t */\n\t\tif (nex2 <= ext_avail) {\n\t\t\ti = erp->er_extcount;\n\t\t}\n\t\t/*\n\t\t * Otherwise, check if space is available in the\n\t\t * next page.\n\t\t */\n\t\telse if ((erp_idx < nlists - 1) &&\n\t\t\t (nex2 <= (ext_avail = XFS_LINEAR_EXTS -\n\t\t\t  ifp->if_u1.if_ext_irec[erp_idx+1].er_extcount))) {\n\t\t\terp_idx++;\n\t\t\terp++;\n\t\t\t/* Create a hole for nex2 extents */\n\t\t\tmemmove(&erp->er_extbuf[nex2], erp->er_extbuf,\n\t\t\t\terp->er_extcount * sizeof(xfs_bmbt_rec_t));\n\t\t}\n\t\t/*\n\t\t * Final choice, create a new extent page for\n\t\t * nex2 extents.\n\t\t */\n\t\telse {\n\t\t\terp_idx++;\n\t\t\terp = xfs_iext_irec_new(ifp, erp_idx);\n\t\t}\n\t\tmemmove(&erp->er_extbuf[i], nex2_ep, byte_diff);\n\t\tkmem_free(nex2_ep);\n\t\terp->er_extcount += nex2;\n\t\txfs_iext_irec_update_extoffs(ifp, erp_idx + 1, nex2);\n\t}\n}",
    "includes": [
      "#include \"xfs_attr_sf.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\"",
      "#include <linux/log2.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_iext_irec_update_extoffs",
          "args": [
            "ifp",
            "erp_idx + 1",
            "nex2"
          ],
          "line": 1145
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_iext_irec_update_extoffs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_inode_fork.c",
          "lines": "1888-1902",
          "snippet": "void\nxfs_iext_irec_update_extoffs(\n\txfs_ifork_t\t*ifp,\t\t/* inode fork pointer */\n\tint\t\terp_idx,\t/* irec index to update */\n\tint\t\text_diff)\t/* number of new extents */\n{\n\tint\t\ti;\t\t/* loop counter */\n\tint\t\tnlists;\t\t/* number of irec's (ex lists */\n\n\tASSERT(ifp->if_flags & XFS_IFEXTIREC);\n\tnlists = ifp->if_real_bytes / XFS_IEXT_BUFSZ;\n\tfor (i = erp_idx; i < nlists; i++) {\n\t\tifp->if_u1.if_ext_irec[i].er_extoff += ext_diff;\n\t}\n}",
          "includes": [
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_attr_sf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nvoid\nxfs_iext_irec_update_extoffs(\n\txfs_ifork_t\t*ifp,\t\t/* inode fork pointer */\n\tint\t\terp_idx,\t/* irec index to update */\n\tint\t\text_diff)\t/* number of new extents */\n{\n\tint\t\ti;\t\t/* loop counter */\n\tint\t\tnlists;\t\t/* number of irec's (ex lists */\n\n\tASSERT(ifp->if_flags & XFS_IFEXTIREC);\n\tnlists = ifp->if_real_bytes / XFS_IEXT_BUFSZ;\n\tfor (i = erp_idx; i < nlists; i++) {\n\t\tifp->if_u1.if_ext_irec[i].er_extoff += ext_diff;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmem_free",
          "args": [
            "nex2_ep"
          ],
          "line": 1143
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/kmem.h",
          "lines": "66-69",
          "snippet": "static inline void  kmem_free(const void *ptr)\n{\n\tkvfree(ptr);\n}",
          "includes": [
            "#include <linux/vmalloc.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n\nstatic inline void  kmem_free(const void *ptr)\n{\n\tkvfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "&erp->er_extbuf[i]",
            "nex2_ep",
            "byte_diff"
          ],
          "line": 1142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_iext_irec_new",
          "args": [
            "ifp",
            "erp_idx"
          ],
          "line": 1140
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_iext_irec_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_inode_fork.c",
          "lines": "1733-1767",
          "snippet": "xfs_ext_irec_t *\nxfs_iext_irec_new(\n\txfs_ifork_t\t*ifp,\t\t/* inode fork pointer */\n\tint\t\terp_idx)\t/* index for new irec */\n{\n\txfs_ext_irec_t\t*erp;\t\t/* indirection array pointer */\n\tint\t\ti;\t\t/* loop counter */\n\tint\t\tnlists;\t\t/* number of irec's (ex lists) */\n\n\tASSERT(ifp->if_flags & XFS_IFEXTIREC);\n\tnlists = ifp->if_real_bytes / XFS_IEXT_BUFSZ;\n\n\t/* Resize indirection array */\n\txfs_iext_realloc_indirect(ifp, ++nlists *\n\t\t\t\t  sizeof(xfs_ext_irec_t));\n\t/*\n\t * Move records down in the array so the\n\t * new page can use erp_idx.\n\t */\n\terp = ifp->if_u1.if_ext_irec;\n\tfor (i = nlists - 1; i > erp_idx; i--) {\n\t\tmemmove(&erp[i], &erp[i-1], sizeof(xfs_ext_irec_t));\n\t}\n\tASSERT(i == erp_idx);\n\n\t/* Initialize new extent record */\n\terp = ifp->if_u1.if_ext_irec;\n\terp[erp_idx].er_extbuf = kmem_alloc(XFS_IEXT_BUFSZ, KM_NOFS);\n\tifp->if_real_bytes = nlists * XFS_IEXT_BUFSZ;\n\tmemset(erp[erp_idx].er_extbuf, 0, XFS_IEXT_BUFSZ);\n\terp[erp_idx].er_extcount = 0;\n\terp[erp_idx].er_extoff = erp_idx > 0 ?\n\t\terp[erp_idx-1].er_extoff + erp[erp_idx-1].er_extcount : 0;\n\treturn (&erp[erp_idx]);\n}",
          "includes": [
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_attr_sf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nxfs_ext_irec_t *\nxfs_iext_irec_new(\n\txfs_ifork_t\t*ifp,\t\t/* inode fork pointer */\n\tint\t\terp_idx)\t/* index for new irec */\n{\n\txfs_ext_irec_t\t*erp;\t\t/* indirection array pointer */\n\tint\t\ti;\t\t/* loop counter */\n\tint\t\tnlists;\t\t/* number of irec's (ex lists) */\n\n\tASSERT(ifp->if_flags & XFS_IFEXTIREC);\n\tnlists = ifp->if_real_bytes / XFS_IEXT_BUFSZ;\n\n\t/* Resize indirection array */\n\txfs_iext_realloc_indirect(ifp, ++nlists *\n\t\t\t\t  sizeof(xfs_ext_irec_t));\n\t/*\n\t * Move records down in the array so the\n\t * new page can use erp_idx.\n\t */\n\terp = ifp->if_u1.if_ext_irec;\n\tfor (i = nlists - 1; i > erp_idx; i--) {\n\t\tmemmove(&erp[i], &erp[i-1], sizeof(xfs_ext_irec_t));\n\t}\n\tASSERT(i == erp_idx);\n\n\t/* Initialize new extent record */\n\terp = ifp->if_u1.if_ext_irec;\n\terp[erp_idx].er_extbuf = kmem_alloc(XFS_IEXT_BUFSZ, KM_NOFS);\n\tifp->if_real_bytes = nlists * XFS_IEXT_BUFSZ;\n\tmemset(erp[erp_idx].er_extbuf, 0, XFS_IEXT_BUFSZ);\n\terp[erp_idx].er_extcount = 0;\n\terp[erp_idx].er_extoff = erp_idx > 0 ?\n\t\terp[erp_idx-1].er_extoff + erp[erp_idx-1].er_extcount : 0;\n\treturn (&erp[erp_idx]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "&erp->er_extbuf[nex2]",
            "erp->er_extbuf",
            "erp->er_extcount * sizeof(xfs_bmbt_rec_t)"
          ],
          "line": 1131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MIN",
          "args": [
            "ext_cnt",
            "(int)XFS_LINEAR_EXTS"
          ],
          "line": 1100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MIN",
          "args": [
            "ext_cnt",
            "(int)XFS_LINEAR_EXTS - erp->er_extcount"
          ],
          "line": 1091
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&erp->er_extbuf[idx]",
            "0",
            "byte_diff"
          ],
          "line": 1081
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "nex2_ep",
            "&erp->er_extbuf[idx]",
            "byte_diff"
          ],
          "line": 1078
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_alloc",
          "args": [
            "byte_diff",
            "KM_NOFS"
          ],
          "line": 1077
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/kmem.c",
          "lines": "45-62",
          "snippet": "void *\nkmem_alloc(size_t size, xfs_km_flags_t flags)\n{\n\tint\tretries = 0;\n\tgfp_t\tlflags = kmem_flags_convert(flags);\n\tvoid\t*ptr;\n\n\tdo {\n\t\tptr = kmalloc(size, lflags);\n\t\tif (ptr || (flags & (KM_MAYFAIL|KM_NOSLEEP)))\n\t\t\treturn ptr;\n\t\tif (!(++retries % 100))\n\t\t\txfs_err(NULL,\n\t\t\"possible memory allocation deadlock in %s (mode:0x%x)\",\n\t\t\t\t\t__func__, lflags);\n\t\tcongestion_wait(BLK_RW_ASYNC, HZ/50);\n\t} while (1);\n}",
          "includes": [
            "#include \"xfs_message.h\"",
            "#include \"kmem.h\"",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_message.h\"\n#include \"kmem.h\"\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nvoid *\nkmem_alloc(size_t size, xfs_km_flags_t flags)\n{\n\tint\tretries = 0;\n\tgfp_t\tlflags = kmem_flags_convert(flags);\n\tvoid\t*ptr;\n\n\tdo {\n\t\tptr = kmalloc(size, lflags);\n\t\tif (ptr || (flags & (KM_MAYFAIL|KM_NOSLEEP)))\n\t\t\treturn ptr;\n\t\tif (!(++retries % 100))\n\t\t\txfs_err(NULL,\n\t\t\"possible memory allocation deadlock in %s (mode:0x%x)\",\n\t\t\t\t\t__func__, lflags);\n\t\tcongestion_wait(BLK_RW_ASYNC, HZ/50);\n\t} while (1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "ifp->if_flags & XFS_IFEXTIREC"
          ],
          "line": 1067
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_attr_sf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nvoid\nxfs_iext_add_indirect_multi(\n\txfs_ifork_t\t*ifp,\t\t\t/* inode fork pointer */\n\tint\t\terp_idx,\t\t/* target extent irec index */\n\txfs_extnum_t\tidx,\t\t\t/* index within target list */\n\tint\t\tcount)\t\t\t/* new extents being added */\n{\n\tint\t\tbyte_diff;\t\t/* new bytes being added */\n\txfs_ext_irec_t\t*erp;\t\t\t/* pointer to irec entry */\n\txfs_extnum_t\text_diff;\t\t/* number of extents to add */\n\txfs_extnum_t\text_cnt;\t\t/* new extents still needed */\n\txfs_extnum_t\tnex2;\t\t\t/* extents after idx + count */\n\txfs_bmbt_rec_t\t*nex2_ep = NULL;\t/* temp list for nex2 extents */\n\tint\t\tnlists;\t\t\t/* number of irec's (lists) */\n\n\tASSERT(ifp->if_flags & XFS_IFEXTIREC);\n\terp = &ifp->if_u1.if_ext_irec[erp_idx];\n\tnex2 = erp->er_extcount - idx;\n\tnlists = ifp->if_real_bytes / XFS_IEXT_BUFSZ;\n\n\t/*\n\t * Save second part of target extent list\n\t * (all extents past */\n\tif (nex2) {\n\t\tbyte_diff = nex2 * sizeof(xfs_bmbt_rec_t);\n\t\tnex2_ep = (xfs_bmbt_rec_t *) kmem_alloc(byte_diff, KM_NOFS);\n\t\tmemmove(nex2_ep, &erp->er_extbuf[idx], byte_diff);\n\t\terp->er_extcount -= nex2;\n\t\txfs_iext_irec_update_extoffs(ifp, erp_idx + 1, -nex2);\n\t\tmemset(&erp->er_extbuf[idx], 0, byte_diff);\n\t}\n\n\t/*\n\t * Add the new extents to the end of the target\n\t * list, then allocate new irec record(s) and\n\t * extent buffer(s) as needed to store the rest\n\t * of the new extents.\n\t */\n\text_cnt = count;\n\text_diff = MIN(ext_cnt, (int)XFS_LINEAR_EXTS - erp->er_extcount);\n\tif (ext_diff) {\n\t\terp->er_extcount += ext_diff;\n\t\txfs_iext_irec_update_extoffs(ifp, erp_idx + 1, ext_diff);\n\t\text_cnt -= ext_diff;\n\t}\n\twhile (ext_cnt) {\n\t\terp_idx++;\n\t\terp = xfs_iext_irec_new(ifp, erp_idx);\n\t\text_diff = MIN(ext_cnt, (int)XFS_LINEAR_EXTS);\n\t\terp->er_extcount = ext_diff;\n\t\txfs_iext_irec_update_extoffs(ifp, erp_idx + 1, ext_diff);\n\t\text_cnt -= ext_diff;\n\t}\n\n\t/* Add nex2 extents back to indirection array */\n\tif (nex2) {\n\t\txfs_extnum_t\text_avail;\n\t\tint\t\ti;\n\n\t\tbyte_diff = nex2 * sizeof(xfs_bmbt_rec_t);\n\t\text_avail = XFS_LINEAR_EXTS - erp->er_extcount;\n\t\ti = 0;\n\t\t/*\n\t\t * If nex2 extents fit in the current page, append\n\t\t * nex2_ep after the new extents.\n\t\t */\n\t\tif (nex2 <= ext_avail) {\n\t\t\ti = erp->er_extcount;\n\t\t}\n\t\t/*\n\t\t * Otherwise, check if space is available in the\n\t\t * next page.\n\t\t */\n\t\telse if ((erp_idx < nlists - 1) &&\n\t\t\t (nex2 <= (ext_avail = XFS_LINEAR_EXTS -\n\t\t\t  ifp->if_u1.if_ext_irec[erp_idx+1].er_extcount))) {\n\t\t\terp_idx++;\n\t\t\terp++;\n\t\t\t/* Create a hole for nex2 extents */\n\t\t\tmemmove(&erp->er_extbuf[nex2], erp->er_extbuf,\n\t\t\t\terp->er_extcount * sizeof(xfs_bmbt_rec_t));\n\t\t}\n\t\t/*\n\t\t * Final choice, create a new extent page for\n\t\t * nex2 extents.\n\t\t */\n\t\telse {\n\t\t\terp_idx++;\n\t\t\terp = xfs_iext_irec_new(ifp, erp_idx);\n\t\t}\n\t\tmemmove(&erp->er_extbuf[i], nex2_ep, byte_diff);\n\t\tkmem_free(nex2_ep);\n\t\terp->er_extcount += nex2;\n\t\txfs_iext_irec_update_extoffs(ifp, erp_idx + 1, nex2);\n\t}\n}"
  },
  {
    "function_name": "xfs_iext_add",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_inode_fork.c",
    "lines": "940-1034",
    "snippet": "void\nxfs_iext_add(\n\txfs_ifork_t\t*ifp,\t\t/* inode fork pointer */\n\txfs_extnum_t\tidx,\t\t/* index to begin adding exts */\n\tint\t\text_diff)\t/* number of extents to add */\n{\n\tint\t\tbyte_diff;\t/* new bytes being added */\n\tint\t\tnew_size;\t/* size of extents after adding */\n\txfs_extnum_t\tnextents;\t/* number of extents in file */\n\n\tnextents = ifp->if_bytes / (uint)sizeof(xfs_bmbt_rec_t);\n\tASSERT((idx >= 0) && (idx <= nextents));\n\tbyte_diff = ext_diff * sizeof(xfs_bmbt_rec_t);\n\tnew_size = ifp->if_bytes + byte_diff;\n\t/*\n\t * If the new number of extents (nextents + ext_diff)\n\t * fits inside the inode, then continue to use the inline\n\t * extent buffer.\n\t */\n\tif (nextents + ext_diff <= XFS_INLINE_EXTS) {\n\t\tif (idx < nextents) {\n\t\t\tmemmove(&ifp->if_u2.if_inline_ext[idx + ext_diff],\n\t\t\t\t&ifp->if_u2.if_inline_ext[idx],\n\t\t\t\t(nextents - idx) * sizeof(xfs_bmbt_rec_t));\n\t\t\tmemset(&ifp->if_u2.if_inline_ext[idx], 0, byte_diff);\n\t\t}\n\t\tifp->if_u1.if_extents = ifp->if_u2.if_inline_ext;\n\t\tifp->if_real_bytes = 0;\n\t}\n\t/*\n\t * Otherwise use a linear (direct) extent list.\n\t * If the extents are currently inside the inode,\n\t * xfs_iext_realloc_direct will switch us from\n\t * inline to direct extent allocation mode.\n\t */\n\telse if (nextents + ext_diff <= XFS_LINEAR_EXTS) {\n\t\txfs_iext_realloc_direct(ifp, new_size);\n\t\tif (idx < nextents) {\n\t\t\tmemmove(&ifp->if_u1.if_extents[idx + ext_diff],\n\t\t\t\t&ifp->if_u1.if_extents[idx],\n\t\t\t\t(nextents - idx) * sizeof(xfs_bmbt_rec_t));\n\t\t\tmemset(&ifp->if_u1.if_extents[idx], 0, byte_diff);\n\t\t}\n\t}\n\t/* Indirection array */\n\telse {\n\t\txfs_ext_irec_t\t*erp;\n\t\tint\t\terp_idx = 0;\n\t\tint\t\tpage_idx = idx;\n\n\t\tASSERT(nextents + ext_diff > XFS_LINEAR_EXTS);\n\t\tif (ifp->if_flags & XFS_IFEXTIREC) {\n\t\t\terp = xfs_iext_idx_to_irec(ifp, &page_idx, &erp_idx, 1);\n\t\t} else {\n\t\t\txfs_iext_irec_init(ifp);\n\t\t\tASSERT(ifp->if_flags & XFS_IFEXTIREC);\n\t\t\terp = ifp->if_u1.if_ext_irec;\n\t\t}\n\t\t/* Extents fit in target extent page */\n\t\tif (erp && erp->er_extcount + ext_diff <= XFS_LINEAR_EXTS) {\n\t\t\tif (page_idx < erp->er_extcount) {\n\t\t\t\tmemmove(&erp->er_extbuf[page_idx + ext_diff],\n\t\t\t\t\t&erp->er_extbuf[page_idx],\n\t\t\t\t\t(erp->er_extcount - page_idx) *\n\t\t\t\t\tsizeof(xfs_bmbt_rec_t));\n\t\t\t\tmemset(&erp->er_extbuf[page_idx], 0, byte_diff);\n\t\t\t}\n\t\t\terp->er_extcount += ext_diff;\n\t\t\txfs_iext_irec_update_extoffs(ifp, erp_idx + 1, ext_diff);\n\t\t}\n\t\t/* Insert a new extent page */\n\t\telse if (erp) {\n\t\t\txfs_iext_add_indirect_multi(ifp,\n\t\t\t\terp_idx, page_idx, ext_diff);\n\t\t}\n\t\t/*\n\t\t * If extent(s) are being appended to the last page in\n\t\t * the indirection array and the new extent(s) don't fit\n\t\t * in the page, then erp is NULL and erp_idx is set to\n\t\t * the next index needed in the indirection array.\n\t\t */\n\t\telse {\n\t\t\tuint\tcount = ext_diff;\n\n\t\t\twhile (count) {\n\t\t\t\terp = xfs_iext_irec_new(ifp, erp_idx);\n\t\t\t\terp->er_extcount = min(count, XFS_LINEAR_EXTS);\n\t\t\t\tcount -= erp->er_extcount;\n\t\t\t\tif (count)\n\t\t\t\t\terp_idx++;\n\t\t\t}\n\t\t}\n\t}\n\tifp->if_bytes = new_size;\n}",
    "includes": [
      "#include \"xfs_attr_sf.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\"",
      "#include <linux/log2.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "min",
          "args": [
            "count",
            "XFS_LINEAR_EXTS"
          ],
          "line": 1026
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_allocbt_get_minrecs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_alloc_btree.c",
          "lines": "189-195",
          "snippet": "STATIC int\nxfs_allocbt_get_minrecs(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\tlevel)\n{\n\treturn cur->bc_mp->m_alloc_mnr[level != 0];\n}",
          "includes": [
            "#include \"xfs_trans.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_alloc_btree.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nSTATIC int\nxfs_allocbt_get_minrecs(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\tlevel)\n{\n\treturn cur->bc_mp->m_alloc_mnr[level != 0];\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_iext_irec_new",
          "args": [
            "ifp",
            "erp_idx"
          ],
          "line": 1025
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_iext_irec_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_inode_fork.c",
          "lines": "1733-1767",
          "snippet": "xfs_ext_irec_t *\nxfs_iext_irec_new(\n\txfs_ifork_t\t*ifp,\t\t/* inode fork pointer */\n\tint\t\terp_idx)\t/* index for new irec */\n{\n\txfs_ext_irec_t\t*erp;\t\t/* indirection array pointer */\n\tint\t\ti;\t\t/* loop counter */\n\tint\t\tnlists;\t\t/* number of irec's (ex lists) */\n\n\tASSERT(ifp->if_flags & XFS_IFEXTIREC);\n\tnlists = ifp->if_real_bytes / XFS_IEXT_BUFSZ;\n\n\t/* Resize indirection array */\n\txfs_iext_realloc_indirect(ifp, ++nlists *\n\t\t\t\t  sizeof(xfs_ext_irec_t));\n\t/*\n\t * Move records down in the array so the\n\t * new page can use erp_idx.\n\t */\n\terp = ifp->if_u1.if_ext_irec;\n\tfor (i = nlists - 1; i > erp_idx; i--) {\n\t\tmemmove(&erp[i], &erp[i-1], sizeof(xfs_ext_irec_t));\n\t}\n\tASSERT(i == erp_idx);\n\n\t/* Initialize new extent record */\n\terp = ifp->if_u1.if_ext_irec;\n\terp[erp_idx].er_extbuf = kmem_alloc(XFS_IEXT_BUFSZ, KM_NOFS);\n\tifp->if_real_bytes = nlists * XFS_IEXT_BUFSZ;\n\tmemset(erp[erp_idx].er_extbuf, 0, XFS_IEXT_BUFSZ);\n\terp[erp_idx].er_extcount = 0;\n\terp[erp_idx].er_extoff = erp_idx > 0 ?\n\t\terp[erp_idx-1].er_extoff + erp[erp_idx-1].er_extcount : 0;\n\treturn (&erp[erp_idx]);\n}",
          "includes": [
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_attr_sf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nxfs_ext_irec_t *\nxfs_iext_irec_new(\n\txfs_ifork_t\t*ifp,\t\t/* inode fork pointer */\n\tint\t\terp_idx)\t/* index for new irec */\n{\n\txfs_ext_irec_t\t*erp;\t\t/* indirection array pointer */\n\tint\t\ti;\t\t/* loop counter */\n\tint\t\tnlists;\t\t/* number of irec's (ex lists) */\n\n\tASSERT(ifp->if_flags & XFS_IFEXTIREC);\n\tnlists = ifp->if_real_bytes / XFS_IEXT_BUFSZ;\n\n\t/* Resize indirection array */\n\txfs_iext_realloc_indirect(ifp, ++nlists *\n\t\t\t\t  sizeof(xfs_ext_irec_t));\n\t/*\n\t * Move records down in the array so the\n\t * new page can use erp_idx.\n\t */\n\terp = ifp->if_u1.if_ext_irec;\n\tfor (i = nlists - 1; i > erp_idx; i--) {\n\t\tmemmove(&erp[i], &erp[i-1], sizeof(xfs_ext_irec_t));\n\t}\n\tASSERT(i == erp_idx);\n\n\t/* Initialize new extent record */\n\terp = ifp->if_u1.if_ext_irec;\n\terp[erp_idx].er_extbuf = kmem_alloc(XFS_IEXT_BUFSZ, KM_NOFS);\n\tifp->if_real_bytes = nlists * XFS_IEXT_BUFSZ;\n\tmemset(erp[erp_idx].er_extbuf, 0, XFS_IEXT_BUFSZ);\n\terp[erp_idx].er_extcount = 0;\n\terp[erp_idx].er_extoff = erp_idx > 0 ?\n\t\terp[erp_idx-1].er_extoff + erp[erp_idx-1].er_extcount : 0;\n\treturn (&erp[erp_idx]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_iext_add_indirect_multi",
          "args": [
            "ifp",
            "erp_idx",
            "page_idx",
            "ext_diff"
          ],
          "line": 1012
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_iext_add_indirect_multi",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_inode_fork.c",
          "lines": "1052-1147",
          "snippet": "void\nxfs_iext_add_indirect_multi(\n\txfs_ifork_t\t*ifp,\t\t\t/* inode fork pointer */\n\tint\t\terp_idx,\t\t/* target extent irec index */\n\txfs_extnum_t\tidx,\t\t\t/* index within target list */\n\tint\t\tcount)\t\t\t/* new extents being added */\n{\n\tint\t\tbyte_diff;\t\t/* new bytes being added */\n\txfs_ext_irec_t\t*erp;\t\t\t/* pointer to irec entry */\n\txfs_extnum_t\text_diff;\t\t/* number of extents to add */\n\txfs_extnum_t\text_cnt;\t\t/* new extents still needed */\n\txfs_extnum_t\tnex2;\t\t\t/* extents after idx + count */\n\txfs_bmbt_rec_t\t*nex2_ep = NULL;\t/* temp list for nex2 extents */\n\tint\t\tnlists;\t\t\t/* number of irec's (lists) */\n\n\tASSERT(ifp->if_flags & XFS_IFEXTIREC);\n\terp = &ifp->if_u1.if_ext_irec[erp_idx];\n\tnex2 = erp->er_extcount - idx;\n\tnlists = ifp->if_real_bytes / XFS_IEXT_BUFSZ;\n\n\t/*\n\t * Save second part of target extent list\n\t * (all extents past */\n\tif (nex2) {\n\t\tbyte_diff = nex2 * sizeof(xfs_bmbt_rec_t);\n\t\tnex2_ep = (xfs_bmbt_rec_t *) kmem_alloc(byte_diff, KM_NOFS);\n\t\tmemmove(nex2_ep, &erp->er_extbuf[idx], byte_diff);\n\t\terp->er_extcount -= nex2;\n\t\txfs_iext_irec_update_extoffs(ifp, erp_idx + 1, -nex2);\n\t\tmemset(&erp->er_extbuf[idx], 0, byte_diff);\n\t}\n\n\t/*\n\t * Add the new extents to the end of the target\n\t * list, then allocate new irec record(s) and\n\t * extent buffer(s) as needed to store the rest\n\t * of the new extents.\n\t */\n\text_cnt = count;\n\text_diff = MIN(ext_cnt, (int)XFS_LINEAR_EXTS - erp->er_extcount);\n\tif (ext_diff) {\n\t\terp->er_extcount += ext_diff;\n\t\txfs_iext_irec_update_extoffs(ifp, erp_idx + 1, ext_diff);\n\t\text_cnt -= ext_diff;\n\t}\n\twhile (ext_cnt) {\n\t\terp_idx++;\n\t\terp = xfs_iext_irec_new(ifp, erp_idx);\n\t\text_diff = MIN(ext_cnt, (int)XFS_LINEAR_EXTS);\n\t\terp->er_extcount = ext_diff;\n\t\txfs_iext_irec_update_extoffs(ifp, erp_idx + 1, ext_diff);\n\t\text_cnt -= ext_diff;\n\t}\n\n\t/* Add nex2 extents back to indirection array */\n\tif (nex2) {\n\t\txfs_extnum_t\text_avail;\n\t\tint\t\ti;\n\n\t\tbyte_diff = nex2 * sizeof(xfs_bmbt_rec_t);\n\t\text_avail = XFS_LINEAR_EXTS - erp->er_extcount;\n\t\ti = 0;\n\t\t/*\n\t\t * If nex2 extents fit in the current page, append\n\t\t * nex2_ep after the new extents.\n\t\t */\n\t\tif (nex2 <= ext_avail) {\n\t\t\ti = erp->er_extcount;\n\t\t}\n\t\t/*\n\t\t * Otherwise, check if space is available in the\n\t\t * next page.\n\t\t */\n\t\telse if ((erp_idx < nlists - 1) &&\n\t\t\t (nex2 <= (ext_avail = XFS_LINEAR_EXTS -\n\t\t\t  ifp->if_u1.if_ext_irec[erp_idx+1].er_extcount))) {\n\t\t\terp_idx++;\n\t\t\terp++;\n\t\t\t/* Create a hole for nex2 extents */\n\t\t\tmemmove(&erp->er_extbuf[nex2], erp->er_extbuf,\n\t\t\t\terp->er_extcount * sizeof(xfs_bmbt_rec_t));\n\t\t}\n\t\t/*\n\t\t * Final choice, create a new extent page for\n\t\t * nex2 extents.\n\t\t */\n\t\telse {\n\t\t\terp_idx++;\n\t\t\terp = xfs_iext_irec_new(ifp, erp_idx);\n\t\t}\n\t\tmemmove(&erp->er_extbuf[i], nex2_ep, byte_diff);\n\t\tkmem_free(nex2_ep);\n\t\terp->er_extcount += nex2;\n\t\txfs_iext_irec_update_extoffs(ifp, erp_idx + 1, nex2);\n\t}\n}",
          "includes": [
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_attr_sf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nvoid\nxfs_iext_add_indirect_multi(\n\txfs_ifork_t\t*ifp,\t\t\t/* inode fork pointer */\n\tint\t\terp_idx,\t\t/* target extent irec index */\n\txfs_extnum_t\tidx,\t\t\t/* index within target list */\n\tint\t\tcount)\t\t\t/* new extents being added */\n{\n\tint\t\tbyte_diff;\t\t/* new bytes being added */\n\txfs_ext_irec_t\t*erp;\t\t\t/* pointer to irec entry */\n\txfs_extnum_t\text_diff;\t\t/* number of extents to add */\n\txfs_extnum_t\text_cnt;\t\t/* new extents still needed */\n\txfs_extnum_t\tnex2;\t\t\t/* extents after idx + count */\n\txfs_bmbt_rec_t\t*nex2_ep = NULL;\t/* temp list for nex2 extents */\n\tint\t\tnlists;\t\t\t/* number of irec's (lists) */\n\n\tASSERT(ifp->if_flags & XFS_IFEXTIREC);\n\terp = &ifp->if_u1.if_ext_irec[erp_idx];\n\tnex2 = erp->er_extcount - idx;\n\tnlists = ifp->if_real_bytes / XFS_IEXT_BUFSZ;\n\n\t/*\n\t * Save second part of target extent list\n\t * (all extents past */\n\tif (nex2) {\n\t\tbyte_diff = nex2 * sizeof(xfs_bmbt_rec_t);\n\t\tnex2_ep = (xfs_bmbt_rec_t *) kmem_alloc(byte_diff, KM_NOFS);\n\t\tmemmove(nex2_ep, &erp->er_extbuf[idx], byte_diff);\n\t\terp->er_extcount -= nex2;\n\t\txfs_iext_irec_update_extoffs(ifp, erp_idx + 1, -nex2);\n\t\tmemset(&erp->er_extbuf[idx], 0, byte_diff);\n\t}\n\n\t/*\n\t * Add the new extents to the end of the target\n\t * list, then allocate new irec record(s) and\n\t * extent buffer(s) as needed to store the rest\n\t * of the new extents.\n\t */\n\text_cnt = count;\n\text_diff = MIN(ext_cnt, (int)XFS_LINEAR_EXTS - erp->er_extcount);\n\tif (ext_diff) {\n\t\terp->er_extcount += ext_diff;\n\t\txfs_iext_irec_update_extoffs(ifp, erp_idx + 1, ext_diff);\n\t\text_cnt -= ext_diff;\n\t}\n\twhile (ext_cnt) {\n\t\terp_idx++;\n\t\terp = xfs_iext_irec_new(ifp, erp_idx);\n\t\text_diff = MIN(ext_cnt, (int)XFS_LINEAR_EXTS);\n\t\terp->er_extcount = ext_diff;\n\t\txfs_iext_irec_update_extoffs(ifp, erp_idx + 1, ext_diff);\n\t\text_cnt -= ext_diff;\n\t}\n\n\t/* Add nex2 extents back to indirection array */\n\tif (nex2) {\n\t\txfs_extnum_t\text_avail;\n\t\tint\t\ti;\n\n\t\tbyte_diff = nex2 * sizeof(xfs_bmbt_rec_t);\n\t\text_avail = XFS_LINEAR_EXTS - erp->er_extcount;\n\t\ti = 0;\n\t\t/*\n\t\t * If nex2 extents fit in the current page, append\n\t\t * nex2_ep after the new extents.\n\t\t */\n\t\tif (nex2 <= ext_avail) {\n\t\t\ti = erp->er_extcount;\n\t\t}\n\t\t/*\n\t\t * Otherwise, check if space is available in the\n\t\t * next page.\n\t\t */\n\t\telse if ((erp_idx < nlists - 1) &&\n\t\t\t (nex2 <= (ext_avail = XFS_LINEAR_EXTS -\n\t\t\t  ifp->if_u1.if_ext_irec[erp_idx+1].er_extcount))) {\n\t\t\terp_idx++;\n\t\t\terp++;\n\t\t\t/* Create a hole for nex2 extents */\n\t\t\tmemmove(&erp->er_extbuf[nex2], erp->er_extbuf,\n\t\t\t\terp->er_extcount * sizeof(xfs_bmbt_rec_t));\n\t\t}\n\t\t/*\n\t\t * Final choice, create a new extent page for\n\t\t * nex2 extents.\n\t\t */\n\t\telse {\n\t\t\terp_idx++;\n\t\t\terp = xfs_iext_irec_new(ifp, erp_idx);\n\t\t}\n\t\tmemmove(&erp->er_extbuf[i], nex2_ep, byte_diff);\n\t\tkmem_free(nex2_ep);\n\t\terp->er_extcount += nex2;\n\t\txfs_iext_irec_update_extoffs(ifp, erp_idx + 1, nex2);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_iext_irec_update_extoffs",
          "args": [
            "ifp",
            "erp_idx + 1",
            "ext_diff"
          ],
          "line": 1008
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_iext_irec_update_extoffs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_inode_fork.c",
          "lines": "1888-1902",
          "snippet": "void\nxfs_iext_irec_update_extoffs(\n\txfs_ifork_t\t*ifp,\t\t/* inode fork pointer */\n\tint\t\terp_idx,\t/* irec index to update */\n\tint\t\text_diff)\t/* number of new extents */\n{\n\tint\t\ti;\t\t/* loop counter */\n\tint\t\tnlists;\t\t/* number of irec's (ex lists */\n\n\tASSERT(ifp->if_flags & XFS_IFEXTIREC);\n\tnlists = ifp->if_real_bytes / XFS_IEXT_BUFSZ;\n\tfor (i = erp_idx; i < nlists; i++) {\n\t\tifp->if_u1.if_ext_irec[i].er_extoff += ext_diff;\n\t}\n}",
          "includes": [
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_attr_sf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nvoid\nxfs_iext_irec_update_extoffs(\n\txfs_ifork_t\t*ifp,\t\t/* inode fork pointer */\n\tint\t\terp_idx,\t/* irec index to update */\n\tint\t\text_diff)\t/* number of new extents */\n{\n\tint\t\ti;\t\t/* loop counter */\n\tint\t\tnlists;\t\t/* number of irec's (ex lists */\n\n\tASSERT(ifp->if_flags & XFS_IFEXTIREC);\n\tnlists = ifp->if_real_bytes / XFS_IEXT_BUFSZ;\n\tfor (i = erp_idx; i < nlists; i++) {\n\t\tifp->if_u1.if_ext_irec[i].er_extoff += ext_diff;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&erp->er_extbuf[page_idx]",
            "0",
            "byte_diff"
          ],
          "line": 1005
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "&erp->er_extbuf[page_idx + ext_diff]",
            "&erp->er_extbuf[page_idx]",
            "(erp->er_extcount - page_idx) *\n\t\t\t\t\tsizeof(xfs_bmbt_rec_t)"
          ],
          "line": 1001
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "ifp->if_flags & XFS_IFEXTIREC"
          ],
          "line": 995
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_iext_irec_init",
          "args": [
            "ifp"
          ],
          "line": 994
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_iext_irec_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_inode_fork.c",
          "lines": "1698-1728",
          "snippet": "void\nxfs_iext_irec_init(\n\txfs_ifork_t\t*ifp)\t\t/* inode fork pointer */\n{\n\txfs_ext_irec_t\t*erp;\t\t/* indirection array pointer */\n\txfs_extnum_t\tnextents;\t/* number of extents in file */\n\n\tASSERT(!(ifp->if_flags & XFS_IFEXTIREC));\n\tnextents = ifp->if_bytes / (uint)sizeof(xfs_bmbt_rec_t);\n\tASSERT(nextents <= XFS_LINEAR_EXTS);\n\n\terp = kmem_alloc(sizeof(xfs_ext_irec_t), KM_NOFS);\n\n\tif (nextents == 0) {\n\t\tifp->if_u1.if_extents = kmem_alloc(XFS_IEXT_BUFSZ, KM_NOFS);\n\t} else if (!ifp->if_real_bytes) {\n\t\txfs_iext_inline_to_direct(ifp, XFS_IEXT_BUFSZ);\n\t} else if (ifp->if_real_bytes < XFS_IEXT_BUFSZ) {\n\t\txfs_iext_realloc_direct(ifp, XFS_IEXT_BUFSZ);\n\t}\n\terp->er_extbuf = ifp->if_u1.if_extents;\n\terp->er_extcount = nextents;\n\terp->er_extoff = 0;\n\n\tifp->if_flags |= XFS_IFEXTIREC;\n\tifp->if_real_bytes = XFS_IEXT_BUFSZ;\n\tifp->if_bytes = nextents * sizeof(xfs_bmbt_rec_t);\n\tifp->if_u1.if_ext_irec = erp;\n\n\treturn;\n}",
          "includes": [
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_attr_sf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nvoid\nxfs_iext_irec_init(\n\txfs_ifork_t\t*ifp)\t\t/* inode fork pointer */\n{\n\txfs_ext_irec_t\t*erp;\t\t/* indirection array pointer */\n\txfs_extnum_t\tnextents;\t/* number of extents in file */\n\n\tASSERT(!(ifp->if_flags & XFS_IFEXTIREC));\n\tnextents = ifp->if_bytes / (uint)sizeof(xfs_bmbt_rec_t);\n\tASSERT(nextents <= XFS_LINEAR_EXTS);\n\n\terp = kmem_alloc(sizeof(xfs_ext_irec_t), KM_NOFS);\n\n\tif (nextents == 0) {\n\t\tifp->if_u1.if_extents = kmem_alloc(XFS_IEXT_BUFSZ, KM_NOFS);\n\t} else if (!ifp->if_real_bytes) {\n\t\txfs_iext_inline_to_direct(ifp, XFS_IEXT_BUFSZ);\n\t} else if (ifp->if_real_bytes < XFS_IEXT_BUFSZ) {\n\t\txfs_iext_realloc_direct(ifp, XFS_IEXT_BUFSZ);\n\t}\n\terp->er_extbuf = ifp->if_u1.if_extents;\n\terp->er_extcount = nextents;\n\terp->er_extoff = 0;\n\n\tifp->if_flags |= XFS_IFEXTIREC;\n\tifp->if_real_bytes = XFS_IEXT_BUFSZ;\n\tifp->if_bytes = nextents * sizeof(xfs_bmbt_rec_t);\n\tifp->if_u1.if_ext_irec = erp;\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_iext_idx_to_irec",
          "args": [
            "ifp",
            "&page_idx",
            "&erp_idx",
            "1"
          ],
          "line": 992
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_iext_idx_to_irec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_inode_fork.c",
          "lines": "1640-1692",
          "snippet": "xfs_ext_irec_t *\nxfs_iext_idx_to_irec(\n\txfs_ifork_t\t*ifp,\t\t/* inode fork pointer */\n\txfs_extnum_t\t*idxp,\t\t/* extent index (file -> page) */\n\tint\t\t*erp_idxp,\t/* pointer to target irec */\n\tint\t\trealloc)\t/* new bytes were just added */\n{\n\txfs_ext_irec_t\t*prev;\t\t/* pointer to previous irec */\n\txfs_ext_irec_t\t*erp = NULL;\t/* pointer to current irec */\n\tint\t\terp_idx;\t/* indirection array index */\n\tint\t\tnlists;\t\t/* number of irec's (ex lists) */\n\tint\t\thigh;\t\t/* binary search upper limit */\n\tint\t\tlow;\t\t/* binary search lower limit */\n\txfs_extnum_t\tpage_idx = *idxp; /* extent index in target list */\n\n\tASSERT(ifp->if_flags & XFS_IFEXTIREC);\n\tASSERT(page_idx >= 0);\n\tASSERT(page_idx <= ifp->if_bytes / sizeof(xfs_bmbt_rec_t));\n\tASSERT(page_idx < ifp->if_bytes / sizeof(xfs_bmbt_rec_t) || realloc);\n\n\tnlists = ifp->if_real_bytes / XFS_IEXT_BUFSZ;\n\terp_idx = 0;\n\tlow = 0;\n\thigh = nlists - 1;\n\n\t/* Binary search extent irec's */\n\twhile (low <= high) {\n\t\terp_idx = (low + high) >> 1;\n\t\terp = &ifp->if_u1.if_ext_irec[erp_idx];\n\t\tprev = erp_idx > 0 ? erp - 1 : NULL;\n\t\tif (page_idx < erp->er_extoff || (page_idx == erp->er_extoff &&\n\t\t     realloc && prev && prev->er_extcount < XFS_LINEAR_EXTS)) {\n\t\t\thigh = erp_idx - 1;\n\t\t} else if (page_idx > erp->er_extoff + erp->er_extcount ||\n\t\t\t   (page_idx == erp->er_extoff + erp->er_extcount &&\n\t\t\t    !realloc)) {\n\t\t\tlow = erp_idx + 1;\n\t\t} else if (page_idx == erp->er_extoff + erp->er_extcount &&\n\t\t\t   erp->er_extcount == XFS_LINEAR_EXTS) {\n\t\t\tASSERT(realloc);\n\t\t\tpage_idx = 0;\n\t\t\terp_idx++;\n\t\t\terp = erp_idx < nlists ? erp + 1 : NULL;\n\t\t\tbreak;\n\t\t} else {\n\t\t\tpage_idx -= erp->er_extoff;\n\t\t\tbreak;\n\t\t}\n\t}\n\t*idxp = page_idx;\n\t*erp_idxp = erp_idx;\n\treturn erp;\n}",
          "includes": [
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_attr_sf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nxfs_ext_irec_t *\nxfs_iext_idx_to_irec(\n\txfs_ifork_t\t*ifp,\t\t/* inode fork pointer */\n\txfs_extnum_t\t*idxp,\t\t/* extent index (file -> page) */\n\tint\t\t*erp_idxp,\t/* pointer to target irec */\n\tint\t\trealloc)\t/* new bytes were just added */\n{\n\txfs_ext_irec_t\t*prev;\t\t/* pointer to previous irec */\n\txfs_ext_irec_t\t*erp = NULL;\t/* pointer to current irec */\n\tint\t\terp_idx;\t/* indirection array index */\n\tint\t\tnlists;\t\t/* number of irec's (ex lists) */\n\tint\t\thigh;\t\t/* binary search upper limit */\n\tint\t\tlow;\t\t/* binary search lower limit */\n\txfs_extnum_t\tpage_idx = *idxp; /* extent index in target list */\n\n\tASSERT(ifp->if_flags & XFS_IFEXTIREC);\n\tASSERT(page_idx >= 0);\n\tASSERT(page_idx <= ifp->if_bytes / sizeof(xfs_bmbt_rec_t));\n\tASSERT(page_idx < ifp->if_bytes / sizeof(xfs_bmbt_rec_t) || realloc);\n\n\tnlists = ifp->if_real_bytes / XFS_IEXT_BUFSZ;\n\terp_idx = 0;\n\tlow = 0;\n\thigh = nlists - 1;\n\n\t/* Binary search extent irec's */\n\twhile (low <= high) {\n\t\terp_idx = (low + high) >> 1;\n\t\terp = &ifp->if_u1.if_ext_irec[erp_idx];\n\t\tprev = erp_idx > 0 ? erp - 1 : NULL;\n\t\tif (page_idx < erp->er_extoff || (page_idx == erp->er_extoff &&\n\t\t     realloc && prev && prev->er_extcount < XFS_LINEAR_EXTS)) {\n\t\t\thigh = erp_idx - 1;\n\t\t} else if (page_idx > erp->er_extoff + erp->er_extcount ||\n\t\t\t   (page_idx == erp->er_extoff + erp->er_extcount &&\n\t\t\t    !realloc)) {\n\t\t\tlow = erp_idx + 1;\n\t\t} else if (page_idx == erp->er_extoff + erp->er_extcount &&\n\t\t\t   erp->er_extcount == XFS_LINEAR_EXTS) {\n\t\t\tASSERT(realloc);\n\t\t\tpage_idx = 0;\n\t\t\terp_idx++;\n\t\t\terp = erp_idx < nlists ? erp + 1 : NULL;\n\t\t\tbreak;\n\t\t} else {\n\t\t\tpage_idx -= erp->er_extoff;\n\t\t\tbreak;\n\t\t}\n\t}\n\t*idxp = page_idx;\n\t*erp_idxp = erp_idx;\n\treturn erp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "nextents + ext_diff > XFS_LINEAR_EXTS"
          ],
          "line": 990
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&ifp->if_u1.if_extents[idx]",
            "0",
            "byte_diff"
          ],
          "line": 981
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "&ifp->if_u1.if_extents[idx + ext_diff]",
            "&ifp->if_u1.if_extents[idx]",
            "(nextents - idx) * sizeof(xfs_bmbt_rec_t)"
          ],
          "line": 978
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_iext_realloc_direct",
          "args": [
            "ifp",
            "new_size"
          ],
          "line": 976
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_iext_realloc_direct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_inode_fork.c",
          "lines": "1346-1396",
          "snippet": "void\nxfs_iext_realloc_direct(\n\txfs_ifork_t\t*ifp,\t\t/* inode fork pointer */\n\tint\t\tnew_size)\t/* new size of extents after adding */\n{\n\tint\t\trnew_size;\t/* real new size of extents */\n\n\trnew_size = new_size;\n\n\tASSERT(!(ifp->if_flags & XFS_IFEXTIREC) ||\n\t\t((new_size >= 0) && (new_size <= XFS_IEXT_BUFSZ) &&\n\t\t (new_size != ifp->if_real_bytes)));\n\n\t/* Free extent records */\n\tif (new_size == 0) {\n\t\txfs_iext_destroy(ifp);\n\t}\n\t/* Resize direct extent list and zero any new bytes */\n\telse if (ifp->if_real_bytes) {\n\t\t/* Check if extents will fit inside the inode */\n\t\tif (new_size <= XFS_INLINE_EXTS * sizeof(xfs_bmbt_rec_t)) {\n\t\t\txfs_iext_direct_to_inline(ifp, new_size /\n\t\t\t\t(uint)sizeof(xfs_bmbt_rec_t));\n\t\t\tifp->if_bytes = new_size;\n\t\t\treturn;\n\t\t}\n\t\tif (!is_power_of_2(new_size)){\n\t\t\trnew_size = roundup_pow_of_two(new_size);\n\t\t}\n\t\tif (rnew_size != ifp->if_real_bytes) {\n\t\t\tifp->if_u1.if_extents =\n\t\t\t\tkmem_realloc(ifp->if_u1.if_extents,\n\t\t\t\t\t\trnew_size,\n\t\t\t\t\t\tifp->if_real_bytes, KM_NOFS);\n\t\t}\n\t\tif (rnew_size > ifp->if_real_bytes) {\n\t\t\tmemset(&ifp->if_u1.if_extents[ifp->if_bytes /\n\t\t\t\t(uint)sizeof(xfs_bmbt_rec_t)], 0,\n\t\t\t\trnew_size - ifp->if_real_bytes);\n\t\t}\n\t}\n\t/* Switch from the inline extent buffer to a direct extent list */\n\telse {\n\t\tif (!is_power_of_2(new_size)) {\n\t\t\trnew_size = roundup_pow_of_two(new_size);\n\t\t}\n\t\txfs_iext_inline_to_direct(ifp, rnew_size);\n\t}\n\tifp->if_real_bytes = rnew_size;\n\tifp->if_bytes = new_size;\n}",
          "includes": [
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_attr_sf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nvoid\nxfs_iext_realloc_direct(\n\txfs_ifork_t\t*ifp,\t\t/* inode fork pointer */\n\tint\t\tnew_size)\t/* new size of extents after adding */\n{\n\tint\t\trnew_size;\t/* real new size of extents */\n\n\trnew_size = new_size;\n\n\tASSERT(!(ifp->if_flags & XFS_IFEXTIREC) ||\n\t\t((new_size >= 0) && (new_size <= XFS_IEXT_BUFSZ) &&\n\t\t (new_size != ifp->if_real_bytes)));\n\n\t/* Free extent records */\n\tif (new_size == 0) {\n\t\txfs_iext_destroy(ifp);\n\t}\n\t/* Resize direct extent list and zero any new bytes */\n\telse if (ifp->if_real_bytes) {\n\t\t/* Check if extents will fit inside the inode */\n\t\tif (new_size <= XFS_INLINE_EXTS * sizeof(xfs_bmbt_rec_t)) {\n\t\t\txfs_iext_direct_to_inline(ifp, new_size /\n\t\t\t\t(uint)sizeof(xfs_bmbt_rec_t));\n\t\t\tifp->if_bytes = new_size;\n\t\t\treturn;\n\t\t}\n\t\tif (!is_power_of_2(new_size)){\n\t\t\trnew_size = roundup_pow_of_two(new_size);\n\t\t}\n\t\tif (rnew_size != ifp->if_real_bytes) {\n\t\t\tifp->if_u1.if_extents =\n\t\t\t\tkmem_realloc(ifp->if_u1.if_extents,\n\t\t\t\t\t\trnew_size,\n\t\t\t\t\t\tifp->if_real_bytes, KM_NOFS);\n\t\t}\n\t\tif (rnew_size > ifp->if_real_bytes) {\n\t\t\tmemset(&ifp->if_u1.if_extents[ifp->if_bytes /\n\t\t\t\t(uint)sizeof(xfs_bmbt_rec_t)], 0,\n\t\t\t\trnew_size - ifp->if_real_bytes);\n\t\t}\n\t}\n\t/* Switch from the inline extent buffer to a direct extent list */\n\telse {\n\t\tif (!is_power_of_2(new_size)) {\n\t\t\trnew_size = roundup_pow_of_two(new_size);\n\t\t}\n\t\txfs_iext_inline_to_direct(ifp, rnew_size);\n\t}\n\tifp->if_real_bytes = rnew_size;\n\tifp->if_bytes = new_size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&ifp->if_u2.if_inline_ext[idx]",
            "0",
            "byte_diff"
          ],
          "line": 964
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "&ifp->if_u2.if_inline_ext[idx + ext_diff]",
            "&ifp->if_u2.if_inline_ext[idx]",
            "(nextents - idx) * sizeof(xfs_bmbt_rec_t)"
          ],
          "line": 961
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "(idx >= 0) && (idx <= nextents)"
          ],
          "line": 951
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_attr_sf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nvoid\nxfs_iext_add(\n\txfs_ifork_t\t*ifp,\t\t/* inode fork pointer */\n\txfs_extnum_t\tidx,\t\t/* index to begin adding exts */\n\tint\t\text_diff)\t/* number of extents to add */\n{\n\tint\t\tbyte_diff;\t/* new bytes being added */\n\tint\t\tnew_size;\t/* size of extents after adding */\n\txfs_extnum_t\tnextents;\t/* number of extents in file */\n\n\tnextents = ifp->if_bytes / (uint)sizeof(xfs_bmbt_rec_t);\n\tASSERT((idx >= 0) && (idx <= nextents));\n\tbyte_diff = ext_diff * sizeof(xfs_bmbt_rec_t);\n\tnew_size = ifp->if_bytes + byte_diff;\n\t/*\n\t * If the new number of extents (nextents + ext_diff)\n\t * fits inside the inode, then continue to use the inline\n\t * extent buffer.\n\t */\n\tif (nextents + ext_diff <= XFS_INLINE_EXTS) {\n\t\tif (idx < nextents) {\n\t\t\tmemmove(&ifp->if_u2.if_inline_ext[idx + ext_diff],\n\t\t\t\t&ifp->if_u2.if_inline_ext[idx],\n\t\t\t\t(nextents - idx) * sizeof(xfs_bmbt_rec_t));\n\t\t\tmemset(&ifp->if_u2.if_inline_ext[idx], 0, byte_diff);\n\t\t}\n\t\tifp->if_u1.if_extents = ifp->if_u2.if_inline_ext;\n\t\tifp->if_real_bytes = 0;\n\t}\n\t/*\n\t * Otherwise use a linear (direct) extent list.\n\t * If the extents are currently inside the inode,\n\t * xfs_iext_realloc_direct will switch us from\n\t * inline to direct extent allocation mode.\n\t */\n\telse if (nextents + ext_diff <= XFS_LINEAR_EXTS) {\n\t\txfs_iext_realloc_direct(ifp, new_size);\n\t\tif (idx < nextents) {\n\t\t\tmemmove(&ifp->if_u1.if_extents[idx + ext_diff],\n\t\t\t\t&ifp->if_u1.if_extents[idx],\n\t\t\t\t(nextents - idx) * sizeof(xfs_bmbt_rec_t));\n\t\t\tmemset(&ifp->if_u1.if_extents[idx], 0, byte_diff);\n\t\t}\n\t}\n\t/* Indirection array */\n\telse {\n\t\txfs_ext_irec_t\t*erp;\n\t\tint\t\terp_idx = 0;\n\t\tint\t\tpage_idx = idx;\n\n\t\tASSERT(nextents + ext_diff > XFS_LINEAR_EXTS);\n\t\tif (ifp->if_flags & XFS_IFEXTIREC) {\n\t\t\terp = xfs_iext_idx_to_irec(ifp, &page_idx, &erp_idx, 1);\n\t\t} else {\n\t\t\txfs_iext_irec_init(ifp);\n\t\t\tASSERT(ifp->if_flags & XFS_IFEXTIREC);\n\t\t\terp = ifp->if_u1.if_ext_irec;\n\t\t}\n\t\t/* Extents fit in target extent page */\n\t\tif (erp && erp->er_extcount + ext_diff <= XFS_LINEAR_EXTS) {\n\t\t\tif (page_idx < erp->er_extcount) {\n\t\t\t\tmemmove(&erp->er_extbuf[page_idx + ext_diff],\n\t\t\t\t\t&erp->er_extbuf[page_idx],\n\t\t\t\t\t(erp->er_extcount - page_idx) *\n\t\t\t\t\tsizeof(xfs_bmbt_rec_t));\n\t\t\t\tmemset(&erp->er_extbuf[page_idx], 0, byte_diff);\n\t\t\t}\n\t\t\terp->er_extcount += ext_diff;\n\t\t\txfs_iext_irec_update_extoffs(ifp, erp_idx + 1, ext_diff);\n\t\t}\n\t\t/* Insert a new extent page */\n\t\telse if (erp) {\n\t\t\txfs_iext_add_indirect_multi(ifp,\n\t\t\t\terp_idx, page_idx, ext_diff);\n\t\t}\n\t\t/*\n\t\t * If extent(s) are being appended to the last page in\n\t\t * the indirection array and the new extent(s) don't fit\n\t\t * in the page, then erp is NULL and erp_idx is set to\n\t\t * the next index needed in the indirection array.\n\t\t */\n\t\telse {\n\t\t\tuint\tcount = ext_diff;\n\n\t\t\twhile (count) {\n\t\t\t\terp = xfs_iext_irec_new(ifp, erp_idx);\n\t\t\t\terp->er_extcount = min(count, XFS_LINEAR_EXTS);\n\t\t\t\tcount -= erp->er_extcount;\n\t\t\t\tif (count)\n\t\t\t\t\terp_idx++;\n\t\t\t}\n\t\t}\n\t}\n\tifp->if_bytes = new_size;\n}"
  },
  {
    "function_name": "xfs_iext_insert",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_inode_fork.c",
    "lines": "909-926",
    "snippet": "void\nxfs_iext_insert(\n\txfs_inode_t\t*ip,\t\t/* incore inode pointer */\n\txfs_extnum_t\tidx,\t\t/* starting index of new items */\n\txfs_extnum_t\tcount,\t\t/* number of inserted items */\n\txfs_bmbt_irec_t\t*new,\t\t/* items to insert */\n\tint\t\tstate)\t\t/* type of extent conversion */\n{\n\txfs_ifork_t\t*ifp = (state & BMAP_ATTRFORK) ? ip->i_afp : &ip->i_df;\n\txfs_extnum_t\ti;\t\t/* extent record index */\n\n\ttrace_xfs_iext_insert(ip, idx, new, state, _RET_IP_);\n\n\tASSERT(ifp->if_flags & XFS_IFEXTENTS);\n\txfs_iext_add(ifp, idx, count);\n\tfor (i = idx; i < idx + count; i++, new++)\n\t\txfs_bmbt_set_all(xfs_iext_get_ext(ifp, i), new);\n}",
    "includes": [
      "#include \"xfs_attr_sf.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\"",
      "#include <linux/log2.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_bmbt_set_all",
          "args": [
            "xfs_iext_get_ext(ifp, i)",
            "new"
          ],
          "line": 925
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmbt_set_all",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap_btree.c",
          "lines": "226-233",
          "snippet": "void\nxfs_bmbt_set_all(\n\txfs_bmbt_rec_host_t *r,\n\txfs_bmbt_irec_t\t*s)\n{\n\txfs_bmbt_set_allf(r, s->br_startoff, s->br_startblock,\n\t\t\t     s->br_blockcount, s->br_state);\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_bmbt_set_all(\n\txfs_bmbt_rec_host_t *r,\n\txfs_bmbt_irec_t\t*s)\n{\n\txfs_bmbt_set_allf(r, s->br_startoff, s->br_startblock,\n\t\t\t     s->br_blockcount, s->br_state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_iext_get_ext",
          "args": [
            "ifp",
            "i"
          ],
          "line": 925
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_iext_get_ext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_inode_fork.c",
          "lines": "881-903",
          "snippet": "xfs_bmbt_rec_host_t *\nxfs_iext_get_ext(\n\txfs_ifork_t\t*ifp,\t\t/* inode fork pointer */\n\txfs_extnum_t\tidx)\t\t/* index of target extent */\n{\n\tASSERT(idx >= 0);\n\tASSERT(idx < ifp->if_bytes / sizeof(xfs_bmbt_rec_t));\n\n\tif ((ifp->if_flags & XFS_IFEXTIREC) && (idx == 0)) {\n\t\treturn ifp->if_u1.if_ext_irec->er_extbuf;\n\t} else if (ifp->if_flags & XFS_IFEXTIREC) {\n\t\txfs_ext_irec_t\t*erp;\t\t/* irec pointer */\n\t\tint\t\terp_idx = 0;\t/* irec index */\n\t\txfs_extnum_t\tpage_idx = idx;\t/* ext index in target list */\n\n\t\terp = xfs_iext_idx_to_irec(ifp, &page_idx, &erp_idx, 0);\n\t\treturn &erp->er_extbuf[page_idx];\n\t} else if (ifp->if_bytes) {\n\t\treturn &ifp->if_u1.if_extents[idx];\n\t} else {\n\t\treturn NULL;\n\t}\n}",
          "includes": [
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_attr_sf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nxfs_bmbt_rec_host_t *\nxfs_iext_get_ext(\n\txfs_ifork_t\t*ifp,\t\t/* inode fork pointer */\n\txfs_extnum_t\tidx)\t\t/* index of target extent */\n{\n\tASSERT(idx >= 0);\n\tASSERT(idx < ifp->if_bytes / sizeof(xfs_bmbt_rec_t));\n\n\tif ((ifp->if_flags & XFS_IFEXTIREC) && (idx == 0)) {\n\t\treturn ifp->if_u1.if_ext_irec->er_extbuf;\n\t} else if (ifp->if_flags & XFS_IFEXTIREC) {\n\t\txfs_ext_irec_t\t*erp;\t\t/* irec pointer */\n\t\tint\t\terp_idx = 0;\t/* irec index */\n\t\txfs_extnum_t\tpage_idx = idx;\t/* ext index in target list */\n\n\t\terp = xfs_iext_idx_to_irec(ifp, &page_idx, &erp_idx, 0);\n\t\treturn &erp->er_extbuf[page_idx];\n\t} else if (ifp->if_bytes) {\n\t\treturn &ifp->if_u1.if_extents[idx];\n\t} else {\n\t\treturn NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_iext_add",
          "args": [
            "ifp",
            "idx",
            "count"
          ],
          "line": 923
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_iext_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_inode_fork.c",
          "lines": "940-1034",
          "snippet": "void\nxfs_iext_add(\n\txfs_ifork_t\t*ifp,\t\t/* inode fork pointer */\n\txfs_extnum_t\tidx,\t\t/* index to begin adding exts */\n\tint\t\text_diff)\t/* number of extents to add */\n{\n\tint\t\tbyte_diff;\t/* new bytes being added */\n\tint\t\tnew_size;\t/* size of extents after adding */\n\txfs_extnum_t\tnextents;\t/* number of extents in file */\n\n\tnextents = ifp->if_bytes / (uint)sizeof(xfs_bmbt_rec_t);\n\tASSERT((idx >= 0) && (idx <= nextents));\n\tbyte_diff = ext_diff * sizeof(xfs_bmbt_rec_t);\n\tnew_size = ifp->if_bytes + byte_diff;\n\t/*\n\t * If the new number of extents (nextents + ext_diff)\n\t * fits inside the inode, then continue to use the inline\n\t * extent buffer.\n\t */\n\tif (nextents + ext_diff <= XFS_INLINE_EXTS) {\n\t\tif (idx < nextents) {\n\t\t\tmemmove(&ifp->if_u2.if_inline_ext[idx + ext_diff],\n\t\t\t\t&ifp->if_u2.if_inline_ext[idx],\n\t\t\t\t(nextents - idx) * sizeof(xfs_bmbt_rec_t));\n\t\t\tmemset(&ifp->if_u2.if_inline_ext[idx], 0, byte_diff);\n\t\t}\n\t\tifp->if_u1.if_extents = ifp->if_u2.if_inline_ext;\n\t\tifp->if_real_bytes = 0;\n\t}\n\t/*\n\t * Otherwise use a linear (direct) extent list.\n\t * If the extents are currently inside the inode,\n\t * xfs_iext_realloc_direct will switch us from\n\t * inline to direct extent allocation mode.\n\t */\n\telse if (nextents + ext_diff <= XFS_LINEAR_EXTS) {\n\t\txfs_iext_realloc_direct(ifp, new_size);\n\t\tif (idx < nextents) {\n\t\t\tmemmove(&ifp->if_u1.if_extents[idx + ext_diff],\n\t\t\t\t&ifp->if_u1.if_extents[idx],\n\t\t\t\t(nextents - idx) * sizeof(xfs_bmbt_rec_t));\n\t\t\tmemset(&ifp->if_u1.if_extents[idx], 0, byte_diff);\n\t\t}\n\t}\n\t/* Indirection array */\n\telse {\n\t\txfs_ext_irec_t\t*erp;\n\t\tint\t\terp_idx = 0;\n\t\tint\t\tpage_idx = idx;\n\n\t\tASSERT(nextents + ext_diff > XFS_LINEAR_EXTS);\n\t\tif (ifp->if_flags & XFS_IFEXTIREC) {\n\t\t\terp = xfs_iext_idx_to_irec(ifp, &page_idx, &erp_idx, 1);\n\t\t} else {\n\t\t\txfs_iext_irec_init(ifp);\n\t\t\tASSERT(ifp->if_flags & XFS_IFEXTIREC);\n\t\t\terp = ifp->if_u1.if_ext_irec;\n\t\t}\n\t\t/* Extents fit in target extent page */\n\t\tif (erp && erp->er_extcount + ext_diff <= XFS_LINEAR_EXTS) {\n\t\t\tif (page_idx < erp->er_extcount) {\n\t\t\t\tmemmove(&erp->er_extbuf[page_idx + ext_diff],\n\t\t\t\t\t&erp->er_extbuf[page_idx],\n\t\t\t\t\t(erp->er_extcount - page_idx) *\n\t\t\t\t\tsizeof(xfs_bmbt_rec_t));\n\t\t\t\tmemset(&erp->er_extbuf[page_idx], 0, byte_diff);\n\t\t\t}\n\t\t\terp->er_extcount += ext_diff;\n\t\t\txfs_iext_irec_update_extoffs(ifp, erp_idx + 1, ext_diff);\n\t\t}\n\t\t/* Insert a new extent page */\n\t\telse if (erp) {\n\t\t\txfs_iext_add_indirect_multi(ifp,\n\t\t\t\terp_idx, page_idx, ext_diff);\n\t\t}\n\t\t/*\n\t\t * If extent(s) are being appended to the last page in\n\t\t * the indirection array and the new extent(s) don't fit\n\t\t * in the page, then erp is NULL and erp_idx is set to\n\t\t * the next index needed in the indirection array.\n\t\t */\n\t\telse {\n\t\t\tuint\tcount = ext_diff;\n\n\t\t\twhile (count) {\n\t\t\t\terp = xfs_iext_irec_new(ifp, erp_idx);\n\t\t\t\terp->er_extcount = min(count, XFS_LINEAR_EXTS);\n\t\t\t\tcount -= erp->er_extcount;\n\t\t\t\tif (count)\n\t\t\t\t\terp_idx++;\n\t\t\t}\n\t\t}\n\t}\n\tifp->if_bytes = new_size;\n}",
          "includes": [
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_attr_sf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nvoid\nxfs_iext_add(\n\txfs_ifork_t\t*ifp,\t\t/* inode fork pointer */\n\txfs_extnum_t\tidx,\t\t/* index to begin adding exts */\n\tint\t\text_diff)\t/* number of extents to add */\n{\n\tint\t\tbyte_diff;\t/* new bytes being added */\n\tint\t\tnew_size;\t/* size of extents after adding */\n\txfs_extnum_t\tnextents;\t/* number of extents in file */\n\n\tnextents = ifp->if_bytes / (uint)sizeof(xfs_bmbt_rec_t);\n\tASSERT((idx >= 0) && (idx <= nextents));\n\tbyte_diff = ext_diff * sizeof(xfs_bmbt_rec_t);\n\tnew_size = ifp->if_bytes + byte_diff;\n\t/*\n\t * If the new number of extents (nextents + ext_diff)\n\t * fits inside the inode, then continue to use the inline\n\t * extent buffer.\n\t */\n\tif (nextents + ext_diff <= XFS_INLINE_EXTS) {\n\t\tif (idx < nextents) {\n\t\t\tmemmove(&ifp->if_u2.if_inline_ext[idx + ext_diff],\n\t\t\t\t&ifp->if_u2.if_inline_ext[idx],\n\t\t\t\t(nextents - idx) * sizeof(xfs_bmbt_rec_t));\n\t\t\tmemset(&ifp->if_u2.if_inline_ext[idx], 0, byte_diff);\n\t\t}\n\t\tifp->if_u1.if_extents = ifp->if_u2.if_inline_ext;\n\t\tifp->if_real_bytes = 0;\n\t}\n\t/*\n\t * Otherwise use a linear (direct) extent list.\n\t * If the extents are currently inside the inode,\n\t * xfs_iext_realloc_direct will switch us from\n\t * inline to direct extent allocation mode.\n\t */\n\telse if (nextents + ext_diff <= XFS_LINEAR_EXTS) {\n\t\txfs_iext_realloc_direct(ifp, new_size);\n\t\tif (idx < nextents) {\n\t\t\tmemmove(&ifp->if_u1.if_extents[idx + ext_diff],\n\t\t\t\t&ifp->if_u1.if_extents[idx],\n\t\t\t\t(nextents - idx) * sizeof(xfs_bmbt_rec_t));\n\t\t\tmemset(&ifp->if_u1.if_extents[idx], 0, byte_diff);\n\t\t}\n\t}\n\t/* Indirection array */\n\telse {\n\t\txfs_ext_irec_t\t*erp;\n\t\tint\t\terp_idx = 0;\n\t\tint\t\tpage_idx = idx;\n\n\t\tASSERT(nextents + ext_diff > XFS_LINEAR_EXTS);\n\t\tif (ifp->if_flags & XFS_IFEXTIREC) {\n\t\t\terp = xfs_iext_idx_to_irec(ifp, &page_idx, &erp_idx, 1);\n\t\t} else {\n\t\t\txfs_iext_irec_init(ifp);\n\t\t\tASSERT(ifp->if_flags & XFS_IFEXTIREC);\n\t\t\terp = ifp->if_u1.if_ext_irec;\n\t\t}\n\t\t/* Extents fit in target extent page */\n\t\tif (erp && erp->er_extcount + ext_diff <= XFS_LINEAR_EXTS) {\n\t\t\tif (page_idx < erp->er_extcount) {\n\t\t\t\tmemmove(&erp->er_extbuf[page_idx + ext_diff],\n\t\t\t\t\t&erp->er_extbuf[page_idx],\n\t\t\t\t\t(erp->er_extcount - page_idx) *\n\t\t\t\t\tsizeof(xfs_bmbt_rec_t));\n\t\t\t\tmemset(&erp->er_extbuf[page_idx], 0, byte_diff);\n\t\t\t}\n\t\t\terp->er_extcount += ext_diff;\n\t\t\txfs_iext_irec_update_extoffs(ifp, erp_idx + 1, ext_diff);\n\t\t}\n\t\t/* Insert a new extent page */\n\t\telse if (erp) {\n\t\t\txfs_iext_add_indirect_multi(ifp,\n\t\t\t\terp_idx, page_idx, ext_diff);\n\t\t}\n\t\t/*\n\t\t * If extent(s) are being appended to the last page in\n\t\t * the indirection array and the new extent(s) don't fit\n\t\t * in the page, then erp is NULL and erp_idx is set to\n\t\t * the next index needed in the indirection array.\n\t\t */\n\t\telse {\n\t\t\tuint\tcount = ext_diff;\n\n\t\t\twhile (count) {\n\t\t\t\terp = xfs_iext_irec_new(ifp, erp_idx);\n\t\t\t\terp->er_extcount = min(count, XFS_LINEAR_EXTS);\n\t\t\t\tcount -= erp->er_extcount;\n\t\t\t\tif (count)\n\t\t\t\t\terp_idx++;\n\t\t\t}\n\t\t}\n\t}\n\tifp->if_bytes = new_size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "ifp->if_flags & XFS_IFEXTENTS"
          ],
          "line": 922
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_xfs_iext_insert",
          "args": [
            "ip",
            "idx",
            "new",
            "state",
            "_RET_IP_"
          ],
          "line": 920
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_attr_sf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nvoid\nxfs_iext_insert(\n\txfs_inode_t\t*ip,\t\t/* incore inode pointer */\n\txfs_extnum_t\tidx,\t\t/* starting index of new items */\n\txfs_extnum_t\tcount,\t\t/* number of inserted items */\n\txfs_bmbt_irec_t\t*new,\t\t/* items to insert */\n\tint\t\tstate)\t\t/* type of extent conversion */\n{\n\txfs_ifork_t\t*ifp = (state & BMAP_ATTRFORK) ? ip->i_afp : &ip->i_df;\n\txfs_extnum_t\ti;\t\t/* extent record index */\n\n\ttrace_xfs_iext_insert(ip, idx, new, state, _RET_IP_);\n\n\tASSERT(ifp->if_flags & XFS_IFEXTENTS);\n\txfs_iext_add(ifp, idx, count);\n\tfor (i = idx; i < idx + count; i++, new++)\n\t\txfs_bmbt_set_all(xfs_iext_get_ext(ifp, i), new);\n}"
  },
  {
    "function_name": "xfs_iext_get_ext",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_inode_fork.c",
    "lines": "881-903",
    "snippet": "xfs_bmbt_rec_host_t *\nxfs_iext_get_ext(\n\txfs_ifork_t\t*ifp,\t\t/* inode fork pointer */\n\txfs_extnum_t\tidx)\t\t/* index of target extent */\n{\n\tASSERT(idx >= 0);\n\tASSERT(idx < ifp->if_bytes / sizeof(xfs_bmbt_rec_t));\n\n\tif ((ifp->if_flags & XFS_IFEXTIREC) && (idx == 0)) {\n\t\treturn ifp->if_u1.if_ext_irec->er_extbuf;\n\t} else if (ifp->if_flags & XFS_IFEXTIREC) {\n\t\txfs_ext_irec_t\t*erp;\t\t/* irec pointer */\n\t\tint\t\terp_idx = 0;\t/* irec index */\n\t\txfs_extnum_t\tpage_idx = idx;\t/* ext index in target list */\n\n\t\terp = xfs_iext_idx_to_irec(ifp, &page_idx, &erp_idx, 0);\n\t\treturn &erp->er_extbuf[page_idx];\n\t} else if (ifp->if_bytes) {\n\t\treturn &ifp->if_u1.if_extents[idx];\n\t} else {\n\t\treturn NULL;\n\t}\n}",
    "includes": [
      "#include \"xfs_attr_sf.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\"",
      "#include <linux/log2.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_iext_idx_to_irec",
          "args": [
            "ifp",
            "&page_idx",
            "&erp_idx",
            "0"
          ],
          "line": 896
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_iext_idx_to_irec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_inode_fork.c",
          "lines": "1640-1692",
          "snippet": "xfs_ext_irec_t *\nxfs_iext_idx_to_irec(\n\txfs_ifork_t\t*ifp,\t\t/* inode fork pointer */\n\txfs_extnum_t\t*idxp,\t\t/* extent index (file -> page) */\n\tint\t\t*erp_idxp,\t/* pointer to target irec */\n\tint\t\trealloc)\t/* new bytes were just added */\n{\n\txfs_ext_irec_t\t*prev;\t\t/* pointer to previous irec */\n\txfs_ext_irec_t\t*erp = NULL;\t/* pointer to current irec */\n\tint\t\terp_idx;\t/* indirection array index */\n\tint\t\tnlists;\t\t/* number of irec's (ex lists) */\n\tint\t\thigh;\t\t/* binary search upper limit */\n\tint\t\tlow;\t\t/* binary search lower limit */\n\txfs_extnum_t\tpage_idx = *idxp; /* extent index in target list */\n\n\tASSERT(ifp->if_flags & XFS_IFEXTIREC);\n\tASSERT(page_idx >= 0);\n\tASSERT(page_idx <= ifp->if_bytes / sizeof(xfs_bmbt_rec_t));\n\tASSERT(page_idx < ifp->if_bytes / sizeof(xfs_bmbt_rec_t) || realloc);\n\n\tnlists = ifp->if_real_bytes / XFS_IEXT_BUFSZ;\n\terp_idx = 0;\n\tlow = 0;\n\thigh = nlists - 1;\n\n\t/* Binary search extent irec's */\n\twhile (low <= high) {\n\t\terp_idx = (low + high) >> 1;\n\t\terp = &ifp->if_u1.if_ext_irec[erp_idx];\n\t\tprev = erp_idx > 0 ? erp - 1 : NULL;\n\t\tif (page_idx < erp->er_extoff || (page_idx == erp->er_extoff &&\n\t\t     realloc && prev && prev->er_extcount < XFS_LINEAR_EXTS)) {\n\t\t\thigh = erp_idx - 1;\n\t\t} else if (page_idx > erp->er_extoff + erp->er_extcount ||\n\t\t\t   (page_idx == erp->er_extoff + erp->er_extcount &&\n\t\t\t    !realloc)) {\n\t\t\tlow = erp_idx + 1;\n\t\t} else if (page_idx == erp->er_extoff + erp->er_extcount &&\n\t\t\t   erp->er_extcount == XFS_LINEAR_EXTS) {\n\t\t\tASSERT(realloc);\n\t\t\tpage_idx = 0;\n\t\t\terp_idx++;\n\t\t\terp = erp_idx < nlists ? erp + 1 : NULL;\n\t\t\tbreak;\n\t\t} else {\n\t\t\tpage_idx -= erp->er_extoff;\n\t\t\tbreak;\n\t\t}\n\t}\n\t*idxp = page_idx;\n\t*erp_idxp = erp_idx;\n\treturn erp;\n}",
          "includes": [
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_attr_sf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nxfs_ext_irec_t *\nxfs_iext_idx_to_irec(\n\txfs_ifork_t\t*ifp,\t\t/* inode fork pointer */\n\txfs_extnum_t\t*idxp,\t\t/* extent index (file -> page) */\n\tint\t\t*erp_idxp,\t/* pointer to target irec */\n\tint\t\trealloc)\t/* new bytes were just added */\n{\n\txfs_ext_irec_t\t*prev;\t\t/* pointer to previous irec */\n\txfs_ext_irec_t\t*erp = NULL;\t/* pointer to current irec */\n\tint\t\terp_idx;\t/* indirection array index */\n\tint\t\tnlists;\t\t/* number of irec's (ex lists) */\n\tint\t\thigh;\t\t/* binary search upper limit */\n\tint\t\tlow;\t\t/* binary search lower limit */\n\txfs_extnum_t\tpage_idx = *idxp; /* extent index in target list */\n\n\tASSERT(ifp->if_flags & XFS_IFEXTIREC);\n\tASSERT(page_idx >= 0);\n\tASSERT(page_idx <= ifp->if_bytes / sizeof(xfs_bmbt_rec_t));\n\tASSERT(page_idx < ifp->if_bytes / sizeof(xfs_bmbt_rec_t) || realloc);\n\n\tnlists = ifp->if_real_bytes / XFS_IEXT_BUFSZ;\n\terp_idx = 0;\n\tlow = 0;\n\thigh = nlists - 1;\n\n\t/* Binary search extent irec's */\n\twhile (low <= high) {\n\t\terp_idx = (low + high) >> 1;\n\t\terp = &ifp->if_u1.if_ext_irec[erp_idx];\n\t\tprev = erp_idx > 0 ? erp - 1 : NULL;\n\t\tif (page_idx < erp->er_extoff || (page_idx == erp->er_extoff &&\n\t\t     realloc && prev && prev->er_extcount < XFS_LINEAR_EXTS)) {\n\t\t\thigh = erp_idx - 1;\n\t\t} else if (page_idx > erp->er_extoff + erp->er_extcount ||\n\t\t\t   (page_idx == erp->er_extoff + erp->er_extcount &&\n\t\t\t    !realloc)) {\n\t\t\tlow = erp_idx + 1;\n\t\t} else if (page_idx == erp->er_extoff + erp->er_extcount &&\n\t\t\t   erp->er_extcount == XFS_LINEAR_EXTS) {\n\t\t\tASSERT(realloc);\n\t\t\tpage_idx = 0;\n\t\t\terp_idx++;\n\t\t\terp = erp_idx < nlists ? erp + 1 : NULL;\n\t\t\tbreak;\n\t\t} else {\n\t\t\tpage_idx -= erp->er_extoff;\n\t\t\tbreak;\n\t\t}\n\t}\n\t*idxp = page_idx;\n\t*erp_idxp = erp_idx;\n\treturn erp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "idx < ifp->if_bytes / sizeof(xfs_bmbt_rec_t)"
          ],
          "line": 887
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "idx >= 0"
          ],
          "line": 886
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_attr_sf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nxfs_bmbt_rec_host_t *\nxfs_iext_get_ext(\n\txfs_ifork_t\t*ifp,\t\t/* inode fork pointer */\n\txfs_extnum_t\tidx)\t\t/* index of target extent */\n{\n\tASSERT(idx >= 0);\n\tASSERT(idx < ifp->if_bytes / sizeof(xfs_bmbt_rec_t));\n\n\tif ((ifp->if_flags & XFS_IFEXTIREC) && (idx == 0)) {\n\t\treturn ifp->if_u1.if_ext_irec->er_extbuf;\n\t} else if (ifp->if_flags & XFS_IFEXTIREC) {\n\t\txfs_ext_irec_t\t*erp;\t\t/* irec pointer */\n\t\tint\t\terp_idx = 0;\t/* irec index */\n\t\txfs_extnum_t\tpage_idx = idx;\t/* ext index in target list */\n\n\t\terp = xfs_iext_idx_to_irec(ifp, &page_idx, &erp_idx, 0);\n\t\treturn &erp->er_extbuf[page_idx];\n\t} else if (ifp->if_bytes) {\n\t\treturn &ifp->if_u1.if_extents[idx];\n\t} else {\n\t\treturn NULL;\n\t}\n}"
  },
  {
    "function_name": "xfs_iflush_fork",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_inode_fork.c",
    "lines": "792-876",
    "snippet": "void\nxfs_iflush_fork(\n\txfs_inode_t\t\t*ip,\n\txfs_dinode_t\t\t*dip,\n\txfs_inode_log_item_t\t*iip,\n\tint\t\t\twhichfork)\n{\n\tchar\t\t\t*cp;\n\txfs_ifork_t\t\t*ifp;\n\txfs_mount_t\t\t*mp;\n\tstatic const short\tbrootflag[2] =\n\t\t{ XFS_ILOG_DBROOT, XFS_ILOG_ABROOT };\n\tstatic const short\tdataflag[2] =\n\t\t{ XFS_ILOG_DDATA, XFS_ILOG_ADATA };\n\tstatic const short\textflag[2] =\n\t\t{ XFS_ILOG_DEXT, XFS_ILOG_AEXT };\n\n\tif (!iip)\n\t\treturn;\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\t/*\n\t * This can happen if we gave up in iformat in an error path,\n\t * for the attribute fork.\n\t */\n\tif (!ifp) {\n\t\tASSERT(whichfork == XFS_ATTR_FORK);\n\t\treturn;\n\t}\n\tcp = XFS_DFORK_PTR(dip, whichfork);\n\tmp = ip->i_mount;\n\tswitch (XFS_IFORK_FORMAT(ip, whichfork)) {\n\tcase XFS_DINODE_FMT_LOCAL:\n\t\tif ((iip->ili_fields & dataflag[whichfork]) &&\n\t\t    (ifp->if_bytes > 0)) {\n\t\t\tASSERT(ifp->if_u1.if_data != NULL);\n\t\t\tASSERT(ifp->if_bytes <= XFS_IFORK_SIZE(ip, whichfork));\n\t\t\tmemcpy(cp, ifp->if_u1.if_data, ifp->if_bytes);\n\t\t}\n\t\tbreak;\n\n\tcase XFS_DINODE_FMT_EXTENTS:\n\t\tASSERT((ifp->if_flags & XFS_IFEXTENTS) ||\n\t\t       !(iip->ili_fields & extflag[whichfork]));\n\t\tif ((iip->ili_fields & extflag[whichfork]) &&\n\t\t    (ifp->if_bytes > 0)) {\n\t\t\tASSERT(xfs_iext_get_ext(ifp, 0));\n\t\t\tASSERT(XFS_IFORK_NEXTENTS(ip, whichfork) > 0);\n\t\t\t(void)xfs_iextents_copy(ip, (xfs_bmbt_rec_t *)cp,\n\t\t\t\twhichfork);\n\t\t}\n\t\tbreak;\n\n\tcase XFS_DINODE_FMT_BTREE:\n\t\tif ((iip->ili_fields & brootflag[whichfork]) &&\n\t\t    (ifp->if_broot_bytes > 0)) {\n\t\t\tASSERT(ifp->if_broot != NULL);\n\t\t\tASSERT(XFS_BMAP_BMDR_SPACE(ifp->if_broot) <=\n\t\t\t        XFS_IFORK_SIZE(ip, whichfork));\n\t\t\txfs_bmbt_to_bmdr(mp, ifp->if_broot, ifp->if_broot_bytes,\n\t\t\t\t(xfs_bmdr_block_t *)cp,\n\t\t\t\tXFS_DFORK_SIZE(dip, mp, whichfork));\n\t\t}\n\t\tbreak;\n\n\tcase XFS_DINODE_FMT_DEV:\n\t\tif (iip->ili_fields & XFS_ILOG_DEV) {\n\t\t\tASSERT(whichfork == XFS_DATA_FORK);\n\t\t\txfs_dinode_put_rdev(dip, ip->i_df.if_u2.if_rdev);\n\t\t}\n\t\tbreak;\n\n\tcase XFS_DINODE_FMT_UUID:\n\t\tif (iip->ili_fields & XFS_ILOG_UUID) {\n\t\t\tASSERT(whichfork == XFS_DATA_FORK);\n\t\t\tmemcpy(XFS_DFORK_DPTR(dip),\n\t\t\t       &ip->i_df.if_u2.if_uuid,\n\t\t\t       sizeof(uuid_t));\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tASSERT(0);\n\t\tbreak;\n\t}\n}",
    "includes": [
      "#include \"xfs_attr_sf.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\"",
      "#include <linux/log2.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC int xfs_iformat_local(xfs_inode_t *, xfs_dinode_t *, int, int);",
      "STATIC int xfs_iformat_extents(xfs_inode_t *, xfs_dinode_t *, int);",
      "STATIC int xfs_iformat_btree(xfs_inode_t *, xfs_dinode_t *, int);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "0"
          ],
          "line": 873
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "XFS_DFORK_DPTR(dip)",
            "&ip->i_df.if_u2.if_uuid",
            "sizeof(uuid_t)"
          ],
          "line": 866
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_DFORK_DPTR",
          "args": [
            "dip"
          ],
          "line": 866
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "whichfork == XFS_DATA_FORK"
          ],
          "line": 865
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dinode_put_rdev",
          "args": [
            "dip",
            "ip->i_df.if_u2.if_rdev"
          ],
          "line": 859
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dinode_put_rdev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_format.h",
          "lines": "1023-1026",
          "snippet": "static inline void xfs_dinode_put_rdev(struct xfs_dinode *dip, xfs_dev_t rdev)\n{\n\t*(__be32 *)XFS_DFORK_DPTR(dip) = cpu_to_be32(rdev);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void xfs_dinode_put_rdev(struct xfs_dinode *dip, xfs_dev_t rdev)\n{\n\t*(__be32 *)XFS_DFORK_DPTR(dip) = cpu_to_be32(rdev);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "whichfork == XFS_DATA_FORK"
          ],
          "line": 858
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_bmbt_to_bmdr",
          "args": [
            "mp",
            "ifp->if_broot",
            "ifp->if_broot_bytes",
            "(xfs_bmdr_block_t *)cp",
            "XFS_DFORK_SIZE(dip, mp, whichfork)"
          ],
          "line": 850
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmbt_to_bmdr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap_btree.c",
          "lines": "336-370",
          "snippet": "void\nxfs_bmbt_to_bmdr(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_btree_block\t*rblock,\n\tint\t\t\trblocklen,\n\txfs_bmdr_block_t\t*dblock,\n\tint\t\t\tdblocklen)\n{\n\tint\t\t\tdmxr;\n\txfs_bmbt_key_t\t\t*fkp;\n\t__be64\t\t\t*fpp;\n\txfs_bmbt_key_t\t\t*tkp;\n\t__be64\t\t\t*tpp;\n\n\tif (xfs_sb_version_hascrc(&mp->m_sb)) {\n\t\tASSERT(rblock->bb_magic == cpu_to_be32(XFS_BMAP_CRC_MAGIC));\n\t\tASSERT(uuid_equal(&rblock->bb_u.l.bb_uuid, &mp->m_sb.sb_uuid));\n\t\tASSERT(rblock->bb_u.l.bb_blkno ==\n\t\t       cpu_to_be64(XFS_BUF_DADDR_NULL));\n\t} else\n\t\tASSERT(rblock->bb_magic == cpu_to_be32(XFS_BMAP_MAGIC));\n\tASSERT(rblock->bb_u.l.bb_leftsib == cpu_to_be64(NULLFSBLOCK));\n\tASSERT(rblock->bb_u.l.bb_rightsib == cpu_to_be64(NULLFSBLOCK));\n\tASSERT(rblock->bb_level != 0);\n\tdblock->bb_level = rblock->bb_level;\n\tdblock->bb_numrecs = rblock->bb_numrecs;\n\tdmxr = xfs_bmdr_maxrecs(dblocklen, 0);\n\tfkp = XFS_BMBT_KEY_ADDR(mp, rblock, 1);\n\ttkp = XFS_BMDR_KEY_ADDR(dblock, 1);\n\tfpp = XFS_BMAP_BROOT_PTR_ADDR(mp, rblock, 1, rblocklen);\n\ttpp = XFS_BMDR_PTR_ADDR(dblock, 1, dmxr);\n\tdmxr = be16_to_cpu(dblock->bb_numrecs);\n\tmemcpy(tkp, fkp, sizeof(*fkp) * dmxr);\n\tmemcpy(tpp, fpp, sizeof(*fpp) * dmxr);\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nvoid\nxfs_bmbt_to_bmdr(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_btree_block\t*rblock,\n\tint\t\t\trblocklen,\n\txfs_bmdr_block_t\t*dblock,\n\tint\t\t\tdblocklen)\n{\n\tint\t\t\tdmxr;\n\txfs_bmbt_key_t\t\t*fkp;\n\t__be64\t\t\t*fpp;\n\txfs_bmbt_key_t\t\t*tkp;\n\t__be64\t\t\t*tpp;\n\n\tif (xfs_sb_version_hascrc(&mp->m_sb)) {\n\t\tASSERT(rblock->bb_magic == cpu_to_be32(XFS_BMAP_CRC_MAGIC));\n\t\tASSERT(uuid_equal(&rblock->bb_u.l.bb_uuid, &mp->m_sb.sb_uuid));\n\t\tASSERT(rblock->bb_u.l.bb_blkno ==\n\t\t       cpu_to_be64(XFS_BUF_DADDR_NULL));\n\t} else\n\t\tASSERT(rblock->bb_magic == cpu_to_be32(XFS_BMAP_MAGIC));\n\tASSERT(rblock->bb_u.l.bb_leftsib == cpu_to_be64(NULLFSBLOCK));\n\tASSERT(rblock->bb_u.l.bb_rightsib == cpu_to_be64(NULLFSBLOCK));\n\tASSERT(rblock->bb_level != 0);\n\tdblock->bb_level = rblock->bb_level;\n\tdblock->bb_numrecs = rblock->bb_numrecs;\n\tdmxr = xfs_bmdr_maxrecs(dblocklen, 0);\n\tfkp = XFS_BMBT_KEY_ADDR(mp, rblock, 1);\n\ttkp = XFS_BMDR_KEY_ADDR(dblock, 1);\n\tfpp = XFS_BMAP_BROOT_PTR_ADDR(mp, rblock, 1, rblocklen);\n\ttpp = XFS_BMDR_PTR_ADDR(dblock, 1, dmxr);\n\tdmxr = be16_to_cpu(dblock->bb_numrecs);\n\tmemcpy(tkp, fkp, sizeof(*fkp) * dmxr);\n\tmemcpy(tpp, fpp, sizeof(*fpp) * dmxr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_DFORK_SIZE",
          "args": [
            "dip",
            "mp",
            "whichfork"
          ],
          "line": 852
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "XFS_BMAP_BMDR_SPACE(ifp->if_broot) <=\n\t\t\t        XFS_IFORK_SIZE(ip, whichfork)"
          ],
          "line": 848
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_IFORK_SIZE",
          "args": [
            "ip",
            "whichfork"
          ],
          "line": 849
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BMAP_BMDR_SPACE",
          "args": [
            "ifp->if_broot"
          ],
          "line": 848
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "ifp->if_broot != NULL"
          ],
          "line": 847
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_iextents_copy",
          "args": [
            "ip",
            "(xfs_bmbt_rec_t *)cp",
            "whichfork"
          ],
          "line": 839
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_iextents_copy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_inode_fork.c",
          "lines": "733-780",
          "snippet": "int\nxfs_iextents_copy(\n\txfs_inode_t\t\t*ip,\n\txfs_bmbt_rec_t\t\t*dp,\n\tint\t\t\twhichfork)\n{\n\tint\t\t\tcopied;\n\tint\t\t\ti;\n\txfs_ifork_t\t\t*ifp;\n\tint\t\t\tnrecs;\n\txfs_fsblock_t\t\tstart_block;\n\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL|XFS_ILOCK_SHARED));\n\tASSERT(ifp->if_bytes > 0);\n\n\tnrecs = ifp->if_bytes / (uint)sizeof(xfs_bmbt_rec_t);\n\tXFS_BMAP_TRACE_EXLIST(ip, nrecs, whichfork);\n\tASSERT(nrecs > 0);\n\n\t/*\n\t * There are some delayed allocation extents in the\n\t * inode, so copy the extents one at a time and skip\n\t * the delayed ones.  There must be at least one\n\t * non-delayed extent.\n\t */\n\tcopied = 0;\n\tfor (i = 0; i < nrecs; i++) {\n\t\txfs_bmbt_rec_host_t *ep = xfs_iext_get_ext(ifp, i);\n\t\tstart_block = xfs_bmbt_get_startblock(ep);\n\t\tif (isnullstartblock(start_block)) {\n\t\t\t/*\n\t\t\t * It's a delayed allocation extent, so skip it.\n\t\t\t */\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Translate to on disk format */\n\t\tput_unaligned_be64(ep->l0, &dp->l0);\n\t\tput_unaligned_be64(ep->l1, &dp->l1);\n\t\tdp++;\n\t\tcopied++;\n\t}\n\tASSERT(copied != 0);\n\txfs_validate_extents(ifp, copied, XFS_EXTFMT_INODE(ip));\n\n\treturn (copied * (uint)sizeof(xfs_bmbt_rec_t));\n}",
          "includes": [
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_attr_sf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nint\nxfs_iextents_copy(\n\txfs_inode_t\t\t*ip,\n\txfs_bmbt_rec_t\t\t*dp,\n\tint\t\t\twhichfork)\n{\n\tint\t\t\tcopied;\n\tint\t\t\ti;\n\txfs_ifork_t\t\t*ifp;\n\tint\t\t\tnrecs;\n\txfs_fsblock_t\t\tstart_block;\n\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL|XFS_ILOCK_SHARED));\n\tASSERT(ifp->if_bytes > 0);\n\n\tnrecs = ifp->if_bytes / (uint)sizeof(xfs_bmbt_rec_t);\n\tXFS_BMAP_TRACE_EXLIST(ip, nrecs, whichfork);\n\tASSERT(nrecs > 0);\n\n\t/*\n\t * There are some delayed allocation extents in the\n\t * inode, so copy the extents one at a time and skip\n\t * the delayed ones.  There must be at least one\n\t * non-delayed extent.\n\t */\n\tcopied = 0;\n\tfor (i = 0; i < nrecs; i++) {\n\t\txfs_bmbt_rec_host_t *ep = xfs_iext_get_ext(ifp, i);\n\t\tstart_block = xfs_bmbt_get_startblock(ep);\n\t\tif (isnullstartblock(start_block)) {\n\t\t\t/*\n\t\t\t * It's a delayed allocation extent, so skip it.\n\t\t\t */\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Translate to on disk format */\n\t\tput_unaligned_be64(ep->l0, &dp->l0);\n\t\tput_unaligned_be64(ep->l1, &dp->l1);\n\t\tdp++;\n\t\tcopied++;\n\t}\n\tASSERT(copied != 0);\n\txfs_validate_extents(ifp, copied, XFS_EXTFMT_INODE(ip));\n\n\treturn (copied * (uint)sizeof(xfs_bmbt_rec_t));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "XFS_IFORK_NEXTENTS(ip, whichfork) > 0"
          ],
          "line": 838
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_IFORK_NEXTENTS",
          "args": [
            "ip",
            "whichfork"
          ],
          "line": 838
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "xfs_iext_get_ext(ifp, 0)"
          ],
          "line": 837
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_iext_get_ext",
          "args": [
            "ifp",
            "0"
          ],
          "line": 837
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_iext_get_ext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_inode_fork.c",
          "lines": "881-903",
          "snippet": "xfs_bmbt_rec_host_t *\nxfs_iext_get_ext(\n\txfs_ifork_t\t*ifp,\t\t/* inode fork pointer */\n\txfs_extnum_t\tidx)\t\t/* index of target extent */\n{\n\tASSERT(idx >= 0);\n\tASSERT(idx < ifp->if_bytes / sizeof(xfs_bmbt_rec_t));\n\n\tif ((ifp->if_flags & XFS_IFEXTIREC) && (idx == 0)) {\n\t\treturn ifp->if_u1.if_ext_irec->er_extbuf;\n\t} else if (ifp->if_flags & XFS_IFEXTIREC) {\n\t\txfs_ext_irec_t\t*erp;\t\t/* irec pointer */\n\t\tint\t\terp_idx = 0;\t/* irec index */\n\t\txfs_extnum_t\tpage_idx = idx;\t/* ext index in target list */\n\n\t\terp = xfs_iext_idx_to_irec(ifp, &page_idx, &erp_idx, 0);\n\t\treturn &erp->er_extbuf[page_idx];\n\t} else if (ifp->if_bytes) {\n\t\treturn &ifp->if_u1.if_extents[idx];\n\t} else {\n\t\treturn NULL;\n\t}\n}",
          "includes": [
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_attr_sf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nxfs_bmbt_rec_host_t *\nxfs_iext_get_ext(\n\txfs_ifork_t\t*ifp,\t\t/* inode fork pointer */\n\txfs_extnum_t\tidx)\t\t/* index of target extent */\n{\n\tASSERT(idx >= 0);\n\tASSERT(idx < ifp->if_bytes / sizeof(xfs_bmbt_rec_t));\n\n\tif ((ifp->if_flags & XFS_IFEXTIREC) && (idx == 0)) {\n\t\treturn ifp->if_u1.if_ext_irec->er_extbuf;\n\t} else if (ifp->if_flags & XFS_IFEXTIREC) {\n\t\txfs_ext_irec_t\t*erp;\t\t/* irec pointer */\n\t\tint\t\terp_idx = 0;\t/* irec index */\n\t\txfs_extnum_t\tpage_idx = idx;\t/* ext index in target list */\n\n\t\terp = xfs_iext_idx_to_irec(ifp, &page_idx, &erp_idx, 0);\n\t\treturn &erp->er_extbuf[page_idx];\n\t} else if (ifp->if_bytes) {\n\t\treturn &ifp->if_u1.if_extents[idx];\n\t} else {\n\t\treturn NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "(ifp->if_flags & XFS_IFEXTENTS) ||\n\t\t       !(iip->ili_fields & extflag[whichfork])"
          ],
          "line": 833
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "cp",
            "ifp->if_u1.if_data",
            "ifp->if_bytes"
          ],
          "line": 828
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "ifp->if_bytes <= XFS_IFORK_SIZE(ip, whichfork)"
          ],
          "line": 827
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_IFORK_SIZE",
          "args": [
            "ip",
            "whichfork"
          ],
          "line": 827
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "ifp->if_u1.if_data != NULL"
          ],
          "line": 826
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_IFORK_FORMAT",
          "args": [
            "ip",
            "whichfork"
          ],
          "line": 822
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_DFORK_PTR",
          "args": [
            "dip",
            "whichfork"
          ],
          "line": 820
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "whichfork == XFS_ATTR_FORK"
          ],
          "line": 817
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_IFORK_PTR",
          "args": [
            "ip",
            "whichfork"
          ],
          "line": 811
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_attr_sf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC int xfs_iformat_local(xfs_inode_t *, xfs_dinode_t *, int, int);\nSTATIC int xfs_iformat_extents(xfs_inode_t *, xfs_dinode_t *, int);\nSTATIC int xfs_iformat_btree(xfs_inode_t *, xfs_dinode_t *, int);\n\nvoid\nxfs_iflush_fork(\n\txfs_inode_t\t\t*ip,\n\txfs_dinode_t\t\t*dip,\n\txfs_inode_log_item_t\t*iip,\n\tint\t\t\twhichfork)\n{\n\tchar\t\t\t*cp;\n\txfs_ifork_t\t\t*ifp;\n\txfs_mount_t\t\t*mp;\n\tstatic const short\tbrootflag[2] =\n\t\t{ XFS_ILOG_DBROOT, XFS_ILOG_ABROOT };\n\tstatic const short\tdataflag[2] =\n\t\t{ XFS_ILOG_DDATA, XFS_ILOG_ADATA };\n\tstatic const short\textflag[2] =\n\t\t{ XFS_ILOG_DEXT, XFS_ILOG_AEXT };\n\n\tif (!iip)\n\t\treturn;\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\t/*\n\t * This can happen if we gave up in iformat in an error path,\n\t * for the attribute fork.\n\t */\n\tif (!ifp) {\n\t\tASSERT(whichfork == XFS_ATTR_FORK);\n\t\treturn;\n\t}\n\tcp = XFS_DFORK_PTR(dip, whichfork);\n\tmp = ip->i_mount;\n\tswitch (XFS_IFORK_FORMAT(ip, whichfork)) {\n\tcase XFS_DINODE_FMT_LOCAL:\n\t\tif ((iip->ili_fields & dataflag[whichfork]) &&\n\t\t    (ifp->if_bytes > 0)) {\n\t\t\tASSERT(ifp->if_u1.if_data != NULL);\n\t\t\tASSERT(ifp->if_bytes <= XFS_IFORK_SIZE(ip, whichfork));\n\t\t\tmemcpy(cp, ifp->if_u1.if_data, ifp->if_bytes);\n\t\t}\n\t\tbreak;\n\n\tcase XFS_DINODE_FMT_EXTENTS:\n\t\tASSERT((ifp->if_flags & XFS_IFEXTENTS) ||\n\t\t       !(iip->ili_fields & extflag[whichfork]));\n\t\tif ((iip->ili_fields & extflag[whichfork]) &&\n\t\t    (ifp->if_bytes > 0)) {\n\t\t\tASSERT(xfs_iext_get_ext(ifp, 0));\n\t\t\tASSERT(XFS_IFORK_NEXTENTS(ip, whichfork) > 0);\n\t\t\t(void)xfs_iextents_copy(ip, (xfs_bmbt_rec_t *)cp,\n\t\t\t\twhichfork);\n\t\t}\n\t\tbreak;\n\n\tcase XFS_DINODE_FMT_BTREE:\n\t\tif ((iip->ili_fields & brootflag[whichfork]) &&\n\t\t    (ifp->if_broot_bytes > 0)) {\n\t\t\tASSERT(ifp->if_broot != NULL);\n\t\t\tASSERT(XFS_BMAP_BMDR_SPACE(ifp->if_broot) <=\n\t\t\t        XFS_IFORK_SIZE(ip, whichfork));\n\t\t\txfs_bmbt_to_bmdr(mp, ifp->if_broot, ifp->if_broot_bytes,\n\t\t\t\t(xfs_bmdr_block_t *)cp,\n\t\t\t\tXFS_DFORK_SIZE(dip, mp, whichfork));\n\t\t}\n\t\tbreak;\n\n\tcase XFS_DINODE_FMT_DEV:\n\t\tif (iip->ili_fields & XFS_ILOG_DEV) {\n\t\t\tASSERT(whichfork == XFS_DATA_FORK);\n\t\t\txfs_dinode_put_rdev(dip, ip->i_df.if_u2.if_rdev);\n\t\t}\n\t\tbreak;\n\n\tcase XFS_DINODE_FMT_UUID:\n\t\tif (iip->ili_fields & XFS_ILOG_UUID) {\n\t\t\tASSERT(whichfork == XFS_DATA_FORK);\n\t\t\tmemcpy(XFS_DFORK_DPTR(dip),\n\t\t\t       &ip->i_df.if_u2.if_uuid,\n\t\t\t       sizeof(uuid_t));\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tASSERT(0);\n\t\tbreak;\n\t}\n}"
  },
  {
    "function_name": "xfs_iextents_copy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_inode_fork.c",
    "lines": "733-780",
    "snippet": "int\nxfs_iextents_copy(\n\txfs_inode_t\t\t*ip,\n\txfs_bmbt_rec_t\t\t*dp,\n\tint\t\t\twhichfork)\n{\n\tint\t\t\tcopied;\n\tint\t\t\ti;\n\txfs_ifork_t\t\t*ifp;\n\tint\t\t\tnrecs;\n\txfs_fsblock_t\t\tstart_block;\n\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL|XFS_ILOCK_SHARED));\n\tASSERT(ifp->if_bytes > 0);\n\n\tnrecs = ifp->if_bytes / (uint)sizeof(xfs_bmbt_rec_t);\n\tXFS_BMAP_TRACE_EXLIST(ip, nrecs, whichfork);\n\tASSERT(nrecs > 0);\n\n\t/*\n\t * There are some delayed allocation extents in the\n\t * inode, so copy the extents one at a time and skip\n\t * the delayed ones.  There must be at least one\n\t * non-delayed extent.\n\t */\n\tcopied = 0;\n\tfor (i = 0; i < nrecs; i++) {\n\t\txfs_bmbt_rec_host_t *ep = xfs_iext_get_ext(ifp, i);\n\t\tstart_block = xfs_bmbt_get_startblock(ep);\n\t\tif (isnullstartblock(start_block)) {\n\t\t\t/*\n\t\t\t * It's a delayed allocation extent, so skip it.\n\t\t\t */\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Translate to on disk format */\n\t\tput_unaligned_be64(ep->l0, &dp->l0);\n\t\tput_unaligned_be64(ep->l1, &dp->l1);\n\t\tdp++;\n\t\tcopied++;\n\t}\n\tASSERT(copied != 0);\n\txfs_validate_extents(ifp, copied, XFS_EXTFMT_INODE(ip));\n\n\treturn (copied * (uint)sizeof(xfs_bmbt_rec_t));\n}",
    "includes": [
      "#include \"xfs_attr_sf.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\"",
      "#include <linux/log2.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_validate_extents",
          "args": [
            "ifp",
            "copied",
            "XFS_EXTFMT_INODE(ip)"
          ],
          "line": 777
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_validate_extents",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_inode_fork.c",
          "lines": "46-64",
          "snippet": "void\nxfs_validate_extents(\n\txfs_ifork_t\t\t*ifp,\n\tint\t\t\tnrecs,\n\txfs_exntfmt_t\t\tfmt)\n{\n\txfs_bmbt_irec_t\t\tirec;\n\txfs_bmbt_rec_host_t\trec;\n\tint\t\t\ti;\n\n\tfor (i = 0; i < nrecs; i++) {\n\t\txfs_bmbt_rec_host_t *ep = xfs_iext_get_ext(ifp, i);\n\t\trec.l0 = get_unaligned(&ep->l0);\n\t\trec.l1 = get_unaligned(&ep->l1);\n\t\txfs_bmbt_get_all(&rec, &irec);\n\t\tif (fmt == XFS_EXTFMT_NOSTATE)\n\t\t\tASSERT(irec.br_state == XFS_EXT_NORM);\n\t}\n}",
          "includes": [
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_attr_sf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nvoid\nxfs_validate_extents(\n\txfs_ifork_t\t\t*ifp,\n\tint\t\t\tnrecs,\n\txfs_exntfmt_t\t\tfmt)\n{\n\txfs_bmbt_irec_t\t\tirec;\n\txfs_bmbt_rec_host_t\trec;\n\tint\t\t\ti;\n\n\tfor (i = 0; i < nrecs; i++) {\n\t\txfs_bmbt_rec_host_t *ep = xfs_iext_get_ext(ifp, i);\n\t\trec.l0 = get_unaligned(&ep->l0);\n\t\trec.l1 = get_unaligned(&ep->l1);\n\t\txfs_bmbt_get_all(&rec, &irec);\n\t\tif (fmt == XFS_EXTFMT_NOSTATE)\n\t\t\tASSERT(irec.br_state == XFS_EXT_NORM);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_EXTFMT_INODE",
          "args": [
            "ip"
          ],
          "line": 777
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "copied != 0"
          ],
          "line": 776
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_unaligned_be64",
          "args": [
            "ep->l1",
            "&dp->l1"
          ],
          "line": 772
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_unaligned_be64",
          "args": [
            "ep->l0",
            "&dp->l0"
          ],
          "line": 771
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isnullstartblock",
          "args": [
            "start_block"
          ],
          "line": 763
        },
        "resolved": true,
        "details": {
          "function_name": "isnullstartblock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_format.h",
          "lines": "1378-1381",
          "snippet": "static inline int isnullstartblock(xfs_fsblock_t x)\n{\n\treturn ((x) & STARTBLOCKMASK) == STARTBLOCKMASK;\n}",
          "includes": [],
          "macros_used": [
            "#define STARTBLOCKMASK\t\t\\\n\t(((((xfs_fsblock_t)1) << STARTBLOCKMASKBITS) - 1) << STARTBLOCKVALBITS)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define STARTBLOCKMASK\t\t\\\n\t(((((xfs_fsblock_t)1) << STARTBLOCKMASKBITS) - 1) << STARTBLOCKVALBITS)\n\nstatic inline int isnullstartblock(xfs_fsblock_t x)\n{\n\treturn ((x) & STARTBLOCKMASK) == STARTBLOCKMASK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_bmbt_get_startblock",
          "args": [
            "ep"
          ],
          "line": 762
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmbt_get_startblock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap_btree.c",
          "lines": "144-150",
          "snippet": "xfs_fsblock_t\nxfs_bmbt_get_startblock(\n\txfs_bmbt_rec_host_t\t*r)\n{\n\treturn (((xfs_fsblock_t)r->l0 & xfs_mask64lo(9)) << 43) |\n\t       (((xfs_fsblock_t)r->l1) >> 21);\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nxfs_fsblock_t\nxfs_bmbt_get_startblock(\n\txfs_bmbt_rec_host_t\t*r)\n{\n\treturn (((xfs_fsblock_t)r->l0 & xfs_mask64lo(9)) << 43) |\n\t       (((xfs_fsblock_t)r->l1) >> 21);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_iext_get_ext",
          "args": [
            "ifp",
            "i"
          ],
          "line": 761
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_iext_get_ext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_inode_fork.c",
          "lines": "881-903",
          "snippet": "xfs_bmbt_rec_host_t *\nxfs_iext_get_ext(\n\txfs_ifork_t\t*ifp,\t\t/* inode fork pointer */\n\txfs_extnum_t\tidx)\t\t/* index of target extent */\n{\n\tASSERT(idx >= 0);\n\tASSERT(idx < ifp->if_bytes / sizeof(xfs_bmbt_rec_t));\n\n\tif ((ifp->if_flags & XFS_IFEXTIREC) && (idx == 0)) {\n\t\treturn ifp->if_u1.if_ext_irec->er_extbuf;\n\t} else if (ifp->if_flags & XFS_IFEXTIREC) {\n\t\txfs_ext_irec_t\t*erp;\t\t/* irec pointer */\n\t\tint\t\terp_idx = 0;\t/* irec index */\n\t\txfs_extnum_t\tpage_idx = idx;\t/* ext index in target list */\n\n\t\terp = xfs_iext_idx_to_irec(ifp, &page_idx, &erp_idx, 0);\n\t\treturn &erp->er_extbuf[page_idx];\n\t} else if (ifp->if_bytes) {\n\t\treturn &ifp->if_u1.if_extents[idx];\n\t} else {\n\t\treturn NULL;\n\t}\n}",
          "includes": [
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_attr_sf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nxfs_bmbt_rec_host_t *\nxfs_iext_get_ext(\n\txfs_ifork_t\t*ifp,\t\t/* inode fork pointer */\n\txfs_extnum_t\tidx)\t\t/* index of target extent */\n{\n\tASSERT(idx >= 0);\n\tASSERT(idx < ifp->if_bytes / sizeof(xfs_bmbt_rec_t));\n\n\tif ((ifp->if_flags & XFS_IFEXTIREC) && (idx == 0)) {\n\t\treturn ifp->if_u1.if_ext_irec->er_extbuf;\n\t} else if (ifp->if_flags & XFS_IFEXTIREC) {\n\t\txfs_ext_irec_t\t*erp;\t\t/* irec pointer */\n\t\tint\t\terp_idx = 0;\t/* irec index */\n\t\txfs_extnum_t\tpage_idx = idx;\t/* ext index in target list */\n\n\t\terp = xfs_iext_idx_to_irec(ifp, &page_idx, &erp_idx, 0);\n\t\treturn &erp->er_extbuf[page_idx];\n\t} else if (ifp->if_bytes) {\n\t\treturn &ifp->if_u1.if_extents[idx];\n\t} else {\n\t\treturn NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "nrecs > 0"
          ],
          "line": 751
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BMAP_TRACE_EXLIST",
          "args": [
            "ip",
            "nrecs",
            "whichfork"
          ],
          "line": 750
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "ifp->if_bytes > 0"
          ],
          "line": 747
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "xfs_isilocked(ip, XFS_ILOCK_EXCL|XFS_ILOCK_SHARED)"
          ],
          "line": 746
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_isilocked",
          "args": [
            "ip",
            "XFS_ILOCK_EXCL|XFS_ILOCK_SHARED"
          ],
          "line": 746
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_isilocked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
          "lines": "286-305",
          "snippet": "int\nxfs_isilocked(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\tif (lock_flags & (XFS_ILOCK_EXCL|XFS_ILOCK_SHARED)) {\n\t\tif (!(lock_flags & XFS_ILOCK_SHARED))\n\t\t\treturn !!ip->i_lock.mr_writer;\n\t\treturn rwsem_is_locked(&ip->i_lock.mr_lock);\n\t}\n\n\tif (lock_flags & (XFS_IOLOCK_EXCL|XFS_IOLOCK_SHARED)) {\n\t\tif (!(lock_flags & XFS_IOLOCK_SHARED))\n\t\t\treturn !!ip->i_iolock.mr_writer;\n\t\treturn rwsem_is_locked(&ip->i_iolock.mr_lock);\n\t}\n\n\tASSERT(0);\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);\n\nint\nxfs_isilocked(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\tif (lock_flags & (XFS_ILOCK_EXCL|XFS_ILOCK_SHARED)) {\n\t\tif (!(lock_flags & XFS_ILOCK_SHARED))\n\t\t\treturn !!ip->i_lock.mr_writer;\n\t\treturn rwsem_is_locked(&ip->i_lock.mr_lock);\n\t}\n\n\tif (lock_flags & (XFS_IOLOCK_EXCL|XFS_IOLOCK_SHARED)) {\n\t\tif (!(lock_flags & XFS_IOLOCK_SHARED))\n\t\t\treturn !!ip->i_iolock.mr_writer;\n\t\treturn rwsem_is_locked(&ip->i_iolock.mr_lock);\n\t}\n\n\tASSERT(0);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_IFORK_PTR",
          "args": [
            "ip",
            "whichfork"
          ],
          "line": 745
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_attr_sf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nint\nxfs_iextents_copy(\n\txfs_inode_t\t\t*ip,\n\txfs_bmbt_rec_t\t\t*dp,\n\tint\t\t\twhichfork)\n{\n\tint\t\t\tcopied;\n\tint\t\t\ti;\n\txfs_ifork_t\t\t*ifp;\n\tint\t\t\tnrecs;\n\txfs_fsblock_t\t\tstart_block;\n\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL|XFS_ILOCK_SHARED));\n\tASSERT(ifp->if_bytes > 0);\n\n\tnrecs = ifp->if_bytes / (uint)sizeof(xfs_bmbt_rec_t);\n\tXFS_BMAP_TRACE_EXLIST(ip, nrecs, whichfork);\n\tASSERT(nrecs > 0);\n\n\t/*\n\t * There are some delayed allocation extents in the\n\t * inode, so copy the extents one at a time and skip\n\t * the delayed ones.  There must be at least one\n\t * non-delayed extent.\n\t */\n\tcopied = 0;\n\tfor (i = 0; i < nrecs; i++) {\n\t\txfs_bmbt_rec_host_t *ep = xfs_iext_get_ext(ifp, i);\n\t\tstart_block = xfs_bmbt_get_startblock(ep);\n\t\tif (isnullstartblock(start_block)) {\n\t\t\t/*\n\t\t\t * It's a delayed allocation extent, so skip it.\n\t\t\t */\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Translate to on disk format */\n\t\tput_unaligned_be64(ep->l0, &dp->l0);\n\t\tput_unaligned_be64(ep->l1, &dp->l1);\n\t\tdp++;\n\t\tcopied++;\n\t}\n\tASSERT(copied != 0);\n\txfs_validate_extents(ifp, copied, XFS_EXTFMT_INODE(ip));\n\n\treturn (copied * (uint)sizeof(xfs_bmbt_rec_t));\n}"
  },
  {
    "function_name": "xfs_idestroy_fork",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_inode_fork.c",
    "lines": "678-719",
    "snippet": "void\nxfs_idestroy_fork(\n\txfs_inode_t\t*ip,\n\tint\t\twhichfork)\n{\n\txfs_ifork_t\t*ifp;\n\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\tif (ifp->if_broot != NULL) {\n\t\tkmem_free(ifp->if_broot);\n\t\tifp->if_broot = NULL;\n\t}\n\n\t/*\n\t * If the format is local, then we can't have an extents\n\t * array so just look for an inline data array.  If we're\n\t * not local then we may or may not have an extents list,\n\t * so check and free it up if we do.\n\t */\n\tif (XFS_IFORK_FORMAT(ip, whichfork) == XFS_DINODE_FMT_LOCAL) {\n\t\tif ((ifp->if_u1.if_data != ifp->if_u2.if_inline_data) &&\n\t\t    (ifp->if_u1.if_data != NULL)) {\n\t\t\tASSERT(ifp->if_real_bytes != 0);\n\t\t\tkmem_free(ifp->if_u1.if_data);\n\t\t\tifp->if_u1.if_data = NULL;\n\t\t\tifp->if_real_bytes = 0;\n\t\t}\n\t} else if ((ifp->if_flags & XFS_IFEXTENTS) &&\n\t\t   ((ifp->if_flags & XFS_IFEXTIREC) ||\n\t\t    ((ifp->if_u1.if_extents != NULL) &&\n\t\t     (ifp->if_u1.if_extents != ifp->if_u2.if_inline_ext)))) {\n\t\tASSERT(ifp->if_real_bytes != 0);\n\t\txfs_iext_destroy(ifp);\n\t}\n\tASSERT(ifp->if_u1.if_extents == NULL ||\n\t       ifp->if_u1.if_extents == ifp->if_u2.if_inline_ext);\n\tASSERT(ifp->if_real_bytes == 0);\n\tif (whichfork == XFS_ATTR_FORK) {\n\t\tkmem_zone_free(xfs_ifork_zone, ip->i_afp);\n\t\tip->i_afp = NULL;\n\t}\n}",
    "includes": [
      "#include \"xfs_attr_sf.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\"",
      "#include <linux/log2.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "kmem_zone_t *xfs_ifork_zone;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_zone_free",
          "args": [
            "xfs_ifork_zone",
            "ip->i_afp"
          ],
          "line": 716
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_zone_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/kmem.h",
          "lines": "104-108",
          "snippet": "static inline void\nkmem_zone_free(kmem_zone_t *zone, void *ptr)\n{\n\tkmem_cache_free(zone, ptr);\n}",
          "includes": [
            "#include <linux/vmalloc.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [
            "#define kmem_zone_t\tstruct kmem_cache"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n\n#define kmem_zone_t\tstruct kmem_cache\n\nstatic inline void\nkmem_zone_free(kmem_zone_t *zone, void *ptr)\n{\n\tkmem_cache_free(zone, ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "ifp->if_real_bytes == 0"
          ],
          "line": 714
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "ifp->if_u1.if_extents == NULL ||\n\t       ifp->if_u1.if_extents == ifp->if_u2.if_inline_ext"
          ],
          "line": 712
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_iext_destroy",
          "args": [
            "ifp"
          ],
          "line": 710
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_iext_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_inode_fork.c",
          "lines": "1501-1523",
          "snippet": "void\nxfs_iext_destroy(\n\txfs_ifork_t\t*ifp)\t\t/* inode fork pointer */\n{\n\tif (ifp->if_flags & XFS_IFEXTIREC) {\n\t\tint\terp_idx;\n\t\tint\tnlists;\n\n\t\tnlists = ifp->if_real_bytes / XFS_IEXT_BUFSZ;\n\t\tfor (erp_idx = nlists - 1; erp_idx >= 0 ; erp_idx--) {\n\t\t\txfs_iext_irec_remove(ifp, erp_idx);\n\t\t}\n\t\tifp->if_flags &= ~XFS_IFEXTIREC;\n\t} else if (ifp->if_real_bytes) {\n\t\tkmem_free(ifp->if_u1.if_extents);\n\t} else if (ifp->if_bytes) {\n\t\tmemset(ifp->if_u2.if_inline_ext, 0, XFS_INLINE_EXTS *\n\t\t\tsizeof(xfs_bmbt_rec_t));\n\t}\n\tifp->if_u1.if_extents = NULL;\n\tifp->if_real_bytes = 0;\n\tifp->if_bytes = 0;\n}",
          "includes": [
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_attr_sf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nvoid\nxfs_iext_destroy(\n\txfs_ifork_t\t*ifp)\t\t/* inode fork pointer */\n{\n\tif (ifp->if_flags & XFS_IFEXTIREC) {\n\t\tint\terp_idx;\n\t\tint\tnlists;\n\n\t\tnlists = ifp->if_real_bytes / XFS_IEXT_BUFSZ;\n\t\tfor (erp_idx = nlists - 1; erp_idx >= 0 ; erp_idx--) {\n\t\t\txfs_iext_irec_remove(ifp, erp_idx);\n\t\t}\n\t\tifp->if_flags &= ~XFS_IFEXTIREC;\n\t} else if (ifp->if_real_bytes) {\n\t\tkmem_free(ifp->if_u1.if_extents);\n\t} else if (ifp->if_bytes) {\n\t\tmemset(ifp->if_u2.if_inline_ext, 0, XFS_INLINE_EXTS *\n\t\t\tsizeof(xfs_bmbt_rec_t));\n\t}\n\tifp->if_u1.if_extents = NULL;\n\tifp->if_real_bytes = 0;\n\tifp->if_bytes = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "ifp->if_real_bytes != 0"
          ],
          "line": 709
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_free",
          "args": [
            "ifp->if_u1.if_data"
          ],
          "line": 701
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/kmem.h",
          "lines": "66-69",
          "snippet": "static inline void  kmem_free(const void *ptr)\n{\n\tkvfree(ptr);\n}",
          "includes": [
            "#include <linux/vmalloc.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n\nstatic inline void  kmem_free(const void *ptr)\n{\n\tkvfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "ifp->if_real_bytes != 0"
          ],
          "line": 700
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_IFORK_FORMAT",
          "args": [
            "ip",
            "whichfork"
          ],
          "line": 697
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_IFORK_PTR",
          "args": [
            "ip",
            "whichfork"
          ],
          "line": 685
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_attr_sf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nkmem_zone_t *xfs_ifork_zone;\n\nvoid\nxfs_idestroy_fork(\n\txfs_inode_t\t*ip,\n\tint\t\twhichfork)\n{\n\txfs_ifork_t\t*ifp;\n\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\tif (ifp->if_broot != NULL) {\n\t\tkmem_free(ifp->if_broot);\n\t\tifp->if_broot = NULL;\n\t}\n\n\t/*\n\t * If the format is local, then we can't have an extents\n\t * array so just look for an inline data array.  If we're\n\t * not local then we may or may not have an extents list,\n\t * so check and free it up if we do.\n\t */\n\tif (XFS_IFORK_FORMAT(ip, whichfork) == XFS_DINODE_FMT_LOCAL) {\n\t\tif ((ifp->if_u1.if_data != ifp->if_u2.if_inline_data) &&\n\t\t    (ifp->if_u1.if_data != NULL)) {\n\t\t\tASSERT(ifp->if_real_bytes != 0);\n\t\t\tkmem_free(ifp->if_u1.if_data);\n\t\t\tifp->if_u1.if_data = NULL;\n\t\t\tifp->if_real_bytes = 0;\n\t\t}\n\t} else if ((ifp->if_flags & XFS_IFEXTENTS) &&\n\t\t   ((ifp->if_flags & XFS_IFEXTIREC) ||\n\t\t    ((ifp->if_u1.if_extents != NULL) &&\n\t\t     (ifp->if_u1.if_extents != ifp->if_u2.if_inline_ext)))) {\n\t\tASSERT(ifp->if_real_bytes != 0);\n\t\txfs_iext_destroy(ifp);\n\t}\n\tASSERT(ifp->if_u1.if_extents == NULL ||\n\t       ifp->if_u1.if_extents == ifp->if_u2.if_inline_ext);\n\tASSERT(ifp->if_real_bytes == 0);\n\tif (whichfork == XFS_ATTR_FORK) {\n\t\tkmem_zone_free(xfs_ifork_zone, ip->i_afp);\n\t\tip->i_afp = NULL;\n\t}\n}"
  },
  {
    "function_name": "xfs_idata_realloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_inode_fork.c",
    "lines": "601-676",
    "snippet": "void\nxfs_idata_realloc(\n\txfs_inode_t\t*ip,\n\tint\t\tbyte_diff,\n\tint\t\twhichfork)\n{\n\txfs_ifork_t\t*ifp;\n\tint\t\tnew_size;\n\tint\t\treal_size;\n\n\tif (byte_diff == 0) {\n\t\treturn;\n\t}\n\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\tnew_size = (int)ifp->if_bytes + byte_diff;\n\tASSERT(new_size >= 0);\n\n\tif (new_size == 0) {\n\t\tif (ifp->if_u1.if_data != ifp->if_u2.if_inline_data) {\n\t\t\tkmem_free(ifp->if_u1.if_data);\n\t\t}\n\t\tifp->if_u1.if_data = NULL;\n\t\treal_size = 0;\n\t} else if (new_size <= sizeof(ifp->if_u2.if_inline_data)) {\n\t\t/*\n\t\t * If the valid extents/data can fit in if_inline_ext/data,\n\t\t * copy them from the malloc'd vector and free it.\n\t\t */\n\t\tif (ifp->if_u1.if_data == NULL) {\n\t\t\tifp->if_u1.if_data = ifp->if_u2.if_inline_data;\n\t\t} else if (ifp->if_u1.if_data != ifp->if_u2.if_inline_data) {\n\t\t\tASSERT(ifp->if_real_bytes != 0);\n\t\t\tmemcpy(ifp->if_u2.if_inline_data, ifp->if_u1.if_data,\n\t\t\t      new_size);\n\t\t\tkmem_free(ifp->if_u1.if_data);\n\t\t\tifp->if_u1.if_data = ifp->if_u2.if_inline_data;\n\t\t}\n\t\treal_size = 0;\n\t} else {\n\t\t/*\n\t\t * Stuck with malloc/realloc.\n\t\t * For inline data, the underlying buffer must be\n\t\t * a multiple of 4 bytes in size so that it can be\n\t\t * logged and stay on word boundaries.  We enforce\n\t\t * that here.\n\t\t */\n\t\treal_size = roundup(new_size, 4);\n\t\tif (ifp->if_u1.if_data == NULL) {\n\t\t\tASSERT(ifp->if_real_bytes == 0);\n\t\t\tifp->if_u1.if_data = kmem_alloc(real_size,\n\t\t\t\t\t\t\tKM_SLEEP | KM_NOFS);\n\t\t} else if (ifp->if_u1.if_data != ifp->if_u2.if_inline_data) {\n\t\t\t/*\n\t\t\t * Only do the realloc if the underlying size\n\t\t\t * is really changing.\n\t\t\t */\n\t\t\tif (ifp->if_real_bytes != real_size) {\n\t\t\t\tifp->if_u1.if_data =\n\t\t\t\t\tkmem_realloc(ifp->if_u1.if_data,\n\t\t\t\t\t\t\treal_size,\n\t\t\t\t\t\t\tifp->if_real_bytes,\n\t\t\t\t\t\t\tKM_SLEEP | KM_NOFS);\n\t\t\t}\n\t\t} else {\n\t\t\tASSERT(ifp->if_real_bytes == 0);\n\t\t\tifp->if_u1.if_data = kmem_alloc(real_size,\n\t\t\t\t\t\t\tKM_SLEEP | KM_NOFS);\n\t\t\tmemcpy(ifp->if_u1.if_data, ifp->if_u2.if_inline_data,\n\t\t\t\tifp->if_bytes);\n\t\t}\n\t}\n\tifp->if_real_bytes = real_size;\n\tifp->if_bytes = new_size;\n\tASSERT(ifp->if_bytes <= XFS_IFORK_SIZE(ip, whichfork));\n}",
    "includes": [
      "#include \"xfs_attr_sf.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\"",
      "#include <linux/log2.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "ifp->if_bytes <= XFS_IFORK_SIZE(ip, whichfork)"
          ],
          "line": 675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_IFORK_SIZE",
          "args": [
            "ip",
            "whichfork"
          ],
          "line": 675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "ifp->if_u1.if_data",
            "ifp->if_u2.if_inline_data",
            "ifp->if_bytes"
          ],
          "line": 669
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_alloc",
          "args": [
            "real_size",
            "KM_SLEEP | KM_NOFS"
          ],
          "line": 667
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/kmem.c",
          "lines": "45-62",
          "snippet": "void *\nkmem_alloc(size_t size, xfs_km_flags_t flags)\n{\n\tint\tretries = 0;\n\tgfp_t\tlflags = kmem_flags_convert(flags);\n\tvoid\t*ptr;\n\n\tdo {\n\t\tptr = kmalloc(size, lflags);\n\t\tif (ptr || (flags & (KM_MAYFAIL|KM_NOSLEEP)))\n\t\t\treturn ptr;\n\t\tif (!(++retries % 100))\n\t\t\txfs_err(NULL,\n\t\t\"possible memory allocation deadlock in %s (mode:0x%x)\",\n\t\t\t\t\t__func__, lflags);\n\t\tcongestion_wait(BLK_RW_ASYNC, HZ/50);\n\t} while (1);\n}",
          "includes": [
            "#include \"xfs_message.h\"",
            "#include \"kmem.h\"",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_message.h\"\n#include \"kmem.h\"\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nvoid *\nkmem_alloc(size_t size, xfs_km_flags_t flags)\n{\n\tint\tretries = 0;\n\tgfp_t\tlflags = kmem_flags_convert(flags);\n\tvoid\t*ptr;\n\n\tdo {\n\t\tptr = kmalloc(size, lflags);\n\t\tif (ptr || (flags & (KM_MAYFAIL|KM_NOSLEEP)))\n\t\t\treturn ptr;\n\t\tif (!(++retries % 100))\n\t\t\txfs_err(NULL,\n\t\t\"possible memory allocation deadlock in %s (mode:0x%x)\",\n\t\t\t\t\t__func__, lflags);\n\t\tcongestion_wait(BLK_RW_ASYNC, HZ/50);\n\t} while (1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "ifp->if_real_bytes == 0"
          ],
          "line": 666
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_realloc",
          "args": [
            "ifp->if_u1.if_data",
            "real_size",
            "ifp->if_real_bytes",
            "KM_SLEEP | KM_NOFS"
          ],
          "line": 660
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_realloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/kmem.c",
          "lines": "94-108",
          "snippet": "void *\nkmem_realloc(const void *ptr, size_t newsize, size_t oldsize,\n\t     xfs_km_flags_t flags)\n{\n\tvoid\t*new;\n\n\tnew = kmem_alloc(newsize, flags);\n\tif (ptr) {\n\t\tif (new)\n\t\t\tmemcpy(new, ptr,\n\t\t\t\t((oldsize < newsize) ? oldsize : newsize));\n\t\tkmem_free(ptr);\n\t}\n\treturn new;\n}",
          "includes": [
            "#include \"xfs_message.h\"",
            "#include \"kmem.h\"",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_message.h\"\n#include \"kmem.h\"\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nvoid *\nkmem_realloc(const void *ptr, size_t newsize, size_t oldsize,\n\t     xfs_km_flags_t flags)\n{\n\tvoid\t*new;\n\n\tnew = kmem_alloc(newsize, flags);\n\tif (ptr) {\n\t\tif (new)\n\t\t\tmemcpy(new, ptr,\n\t\t\t\t((oldsize < newsize) ? oldsize : newsize));\n\t\tkmem_free(ptr);\n\t}\n\treturn new;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "ifp->if_real_bytes == 0"
          ],
          "line": 650
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "roundup",
          "args": [
            "new_size",
            "4"
          ],
          "line": 648
        },
        "resolved": true,
        "details": {
          "function_name": "roundup_64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_linux.h",
          "lines": "333-338",
          "snippet": "static inline __uint64_t roundup_64(__uint64_t x, __uint32_t y)\n{\n\tx += y - 1;\n\tdo_div(x, y);\n\treturn x * y;\n}",
          "includes": [
            "#include \"xfs_message.h\"",
            "#include \"xfs_buf.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_super.h\"",
            "#include \"xfs_aops.h\"",
            "#include \"xfs_iops.h\"",
            "#include \"xfs_sysctl.h\"",
            "#include \"xfs_stats.h\"",
            "#include \"xfs_fs.h\"",
            "#include <asm/unaligned.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/param.h>",
            "#include <asm/div64.h>",
            "#include <asm/page.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/capability.h>",
            "#include <linux/writeback.h>",
            "#include <linux/ctype.h>",
            "#include <linux/random.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/log2.h>",
            "#include <linux/delay.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sort.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/list.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/vfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/major.h>",
            "#include <linux/bitops.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>",
            "#include <linux/swap.h>",
            "#include <linux/file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/crc32c.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mm.h>",
            "#include <linux/semaphore.h>",
            "#include \"uuid.h\"",
            "#include \"mrlock.h\"",
            "#include \"kmem.h\"",
            "#include \"xfs_types.h\"",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_message.h\"\n#include \"xfs_buf.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_super.h\"\n#include \"xfs_aops.h\"\n#include \"xfs_iops.h\"\n#include \"xfs_sysctl.h\"\n#include \"xfs_stats.h\"\n#include \"xfs_fs.h\"\n#include <asm/unaligned.h>\n#include <asm/byteorder.h>\n#include <asm/uaccess.h>\n#include <asm/param.h>\n#include <asm/div64.h>\n#include <asm/page.h>\n#include <linux/ratelimit.h>\n#include <linux/list_sort.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/capability.h>\n#include <linux/writeback.h>\n#include <linux/ctype.h>\n#include <linux/random.h>\n#include <linux/spinlock.h>\n#include <linux/log2.h>\n#include <linux/delay.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/sort.h>\n#include <linux/proc_fs.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/vfs.h>\n#include <linux/pagemap.h>\n#include <linux/major.h>\n#include <linux/bitops.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/swap.h>\n#include <linux/file.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/crc32c.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n#include <linux/mm.h>\n#include <linux/semaphore.h>\n#include \"uuid.h\"\n#include \"mrlock.h\"\n#include \"kmem.h\"\n#include \"xfs_types.h\"\n#include <linux/types.h>\n\nstatic inline __uint64_t roundup_64(__uint64_t x, __uint32_t y)\n{\n\tx += y - 1;\n\tdo_div(x, y);\n\treturn x * y;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmem_free",
          "args": [
            "ifp->if_u1.if_data"
          ],
          "line": 636
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/kmem.h",
          "lines": "66-69",
          "snippet": "static inline void  kmem_free(const void *ptr)\n{\n\tkvfree(ptr);\n}",
          "includes": [
            "#include <linux/vmalloc.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n\nstatic inline void  kmem_free(const void *ptr)\n{\n\tkvfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "ifp->if_u2.if_inline_data",
            "ifp->if_u1.if_data",
            "new_size"
          ],
          "line": 634
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "ifp->if_real_bytes != 0"
          ],
          "line": 633
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "new_size >= 0"
          ],
          "line": 617
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_IFORK_PTR",
          "args": [
            "ip",
            "whichfork"
          ],
          "line": 615
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_attr_sf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nvoid\nxfs_idata_realloc(\n\txfs_inode_t\t*ip,\n\tint\t\tbyte_diff,\n\tint\t\twhichfork)\n{\n\txfs_ifork_t\t*ifp;\n\tint\t\tnew_size;\n\tint\t\treal_size;\n\n\tif (byte_diff == 0) {\n\t\treturn;\n\t}\n\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\tnew_size = (int)ifp->if_bytes + byte_diff;\n\tASSERT(new_size >= 0);\n\n\tif (new_size == 0) {\n\t\tif (ifp->if_u1.if_data != ifp->if_u2.if_inline_data) {\n\t\t\tkmem_free(ifp->if_u1.if_data);\n\t\t}\n\t\tifp->if_u1.if_data = NULL;\n\t\treal_size = 0;\n\t} else if (new_size <= sizeof(ifp->if_u2.if_inline_data)) {\n\t\t/*\n\t\t * If the valid extents/data can fit in if_inline_ext/data,\n\t\t * copy them from the malloc'd vector and free it.\n\t\t */\n\t\tif (ifp->if_u1.if_data == NULL) {\n\t\t\tifp->if_u1.if_data = ifp->if_u2.if_inline_data;\n\t\t} else if (ifp->if_u1.if_data != ifp->if_u2.if_inline_data) {\n\t\t\tASSERT(ifp->if_real_bytes != 0);\n\t\t\tmemcpy(ifp->if_u2.if_inline_data, ifp->if_u1.if_data,\n\t\t\t      new_size);\n\t\t\tkmem_free(ifp->if_u1.if_data);\n\t\t\tifp->if_u1.if_data = ifp->if_u2.if_inline_data;\n\t\t}\n\t\treal_size = 0;\n\t} else {\n\t\t/*\n\t\t * Stuck with malloc/realloc.\n\t\t * For inline data, the underlying buffer must be\n\t\t * a multiple of 4 bytes in size so that it can be\n\t\t * logged and stay on word boundaries.  We enforce\n\t\t * that here.\n\t\t */\n\t\treal_size = roundup(new_size, 4);\n\t\tif (ifp->if_u1.if_data == NULL) {\n\t\t\tASSERT(ifp->if_real_bytes == 0);\n\t\t\tifp->if_u1.if_data = kmem_alloc(real_size,\n\t\t\t\t\t\t\tKM_SLEEP | KM_NOFS);\n\t\t} else if (ifp->if_u1.if_data != ifp->if_u2.if_inline_data) {\n\t\t\t/*\n\t\t\t * Only do the realloc if the underlying size\n\t\t\t * is really changing.\n\t\t\t */\n\t\t\tif (ifp->if_real_bytes != real_size) {\n\t\t\t\tifp->if_u1.if_data =\n\t\t\t\t\tkmem_realloc(ifp->if_u1.if_data,\n\t\t\t\t\t\t\treal_size,\n\t\t\t\t\t\t\tifp->if_real_bytes,\n\t\t\t\t\t\t\tKM_SLEEP | KM_NOFS);\n\t\t\t}\n\t\t} else {\n\t\t\tASSERT(ifp->if_real_bytes == 0);\n\t\t\tifp->if_u1.if_data = kmem_alloc(real_size,\n\t\t\t\t\t\t\tKM_SLEEP | KM_NOFS);\n\t\t\tmemcpy(ifp->if_u1.if_data, ifp->if_u2.if_inline_data,\n\t\t\t\tifp->if_bytes);\n\t\t}\n\t}\n\tifp->if_real_bytes = real_size;\n\tifp->if_bytes = new_size;\n\tASSERT(ifp->if_bytes <= XFS_IFORK_SIZE(ip, whichfork));\n}"
  },
  {
    "function_name": "xfs_iroot_realloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_inode_fork.c",
    "lines": "473-583",
    "snippet": "void\nxfs_iroot_realloc(\n\txfs_inode_t\t\t*ip,\n\tint\t\t\trec_diff,\n\tint\t\t\twhichfork)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tint\t\t\tcur_max;\n\txfs_ifork_t\t\t*ifp;\n\tstruct xfs_btree_block\t*new_broot;\n\tint\t\t\tnew_max;\n\tsize_t\t\t\tnew_size;\n\tchar\t\t\t*np;\n\tchar\t\t\t*op;\n\n\t/*\n\t * Handle the degenerate case quietly.\n\t */\n\tif (rec_diff == 0) {\n\t\treturn;\n\t}\n\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\tif (rec_diff > 0) {\n\t\t/*\n\t\t * If there wasn't any memory allocated before, just\n\t\t * allocate it now and get out.\n\t\t */\n\t\tif (ifp->if_broot_bytes == 0) {\n\t\t\tnew_size = XFS_BMAP_BROOT_SPACE_CALC(mp, rec_diff);\n\t\t\tifp->if_broot = kmem_alloc(new_size, KM_SLEEP | KM_NOFS);\n\t\t\tifp->if_broot_bytes = (int)new_size;\n\t\t\treturn;\n\t\t}\n\n\t\t/*\n\t\t * If there is already an existing if_broot, then we need\n\t\t * to realloc() it and shift the pointers to their new\n\t\t * location.  The records don't change location because\n\t\t * they are kept butted up against the btree block header.\n\t\t */\n\t\tcur_max = xfs_bmbt_maxrecs(mp, ifp->if_broot_bytes, 0);\n\t\tnew_max = cur_max + rec_diff;\n\t\tnew_size = XFS_BMAP_BROOT_SPACE_CALC(mp, new_max);\n\t\tifp->if_broot = kmem_realloc(ifp->if_broot, new_size,\n\t\t\t\tXFS_BMAP_BROOT_SPACE_CALC(mp, cur_max),\n\t\t\t\tKM_SLEEP | KM_NOFS);\n\t\top = (char *)XFS_BMAP_BROOT_PTR_ADDR(mp, ifp->if_broot, 1,\n\t\t\t\t\t\t     ifp->if_broot_bytes);\n\t\tnp = (char *)XFS_BMAP_BROOT_PTR_ADDR(mp, ifp->if_broot, 1,\n\t\t\t\t\t\t     (int)new_size);\n\t\tifp->if_broot_bytes = (int)new_size;\n\t\tASSERT(XFS_BMAP_BMDR_SPACE(ifp->if_broot) <=\n\t\t\tXFS_IFORK_SIZE(ip, whichfork));\n\t\tmemmove(np, op, cur_max * (uint)sizeof(xfs_fsblock_t));\n\t\treturn;\n\t}\n\n\t/*\n\t * rec_diff is less than 0.  In this case, we are shrinking the\n\t * if_broot buffer.  It must already exist.  If we go to zero\n\t * records, just get rid of the root and clear the status bit.\n\t */\n\tASSERT((ifp->if_broot != NULL) && (ifp->if_broot_bytes > 0));\n\tcur_max = xfs_bmbt_maxrecs(mp, ifp->if_broot_bytes, 0);\n\tnew_max = cur_max + rec_diff;\n\tASSERT(new_max >= 0);\n\tif (new_max > 0)\n\t\tnew_size = XFS_BMAP_BROOT_SPACE_CALC(mp, new_max);\n\telse\n\t\tnew_size = 0;\n\tif (new_size > 0) {\n\t\tnew_broot = kmem_alloc(new_size, KM_SLEEP | KM_NOFS);\n\t\t/*\n\t\t * First copy over the btree block header.\n\t\t */\n\t\tmemcpy(new_broot, ifp->if_broot,\n\t\t\tXFS_BMBT_BLOCK_LEN(ip->i_mount));\n\t} else {\n\t\tnew_broot = NULL;\n\t\tifp->if_flags &= ~XFS_IFBROOT;\n\t}\n\n\t/*\n\t * Only copy the records and pointers if there are any.\n\t */\n\tif (new_max > 0) {\n\t\t/*\n\t\t * First copy the records.\n\t\t */\n\t\top = (char *)XFS_BMBT_REC_ADDR(mp, ifp->if_broot, 1);\n\t\tnp = (char *)XFS_BMBT_REC_ADDR(mp, new_broot, 1);\n\t\tmemcpy(np, op, new_max * (uint)sizeof(xfs_bmbt_rec_t));\n\n\t\t/*\n\t\t * Then copy the pointers.\n\t\t */\n\t\top = (char *)XFS_BMAP_BROOT_PTR_ADDR(mp, ifp->if_broot, 1,\n\t\t\t\t\t\t     ifp->if_broot_bytes);\n\t\tnp = (char *)XFS_BMAP_BROOT_PTR_ADDR(mp, new_broot, 1,\n\t\t\t\t\t\t     (int)new_size);\n\t\tmemcpy(np, op, new_max * (uint)sizeof(xfs_fsblock_t));\n\t}\n\tkmem_free(ifp->if_broot);\n\tifp->if_broot = new_broot;\n\tifp->if_broot_bytes = (int)new_size;\n\tif (ifp->if_broot)\n\t\tASSERT(XFS_BMAP_BMDR_SPACE(ifp->if_broot) <=\n\t\t\tXFS_IFORK_SIZE(ip, whichfork));\n\treturn;\n}",
    "includes": [
      "#include \"xfs_attr_sf.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\"",
      "#include <linux/log2.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "XFS_BMAP_BMDR_SPACE(ifp->if_broot) <=\n\t\t\tXFS_IFORK_SIZE(ip, whichfork)"
          ],
          "line": 580
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_IFORK_SIZE",
          "args": [
            "ip",
            "whichfork"
          ],
          "line": 581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BMAP_BMDR_SPACE",
          "args": [
            "ifp->if_broot"
          ],
          "line": 580
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_free",
          "args": [
            "ifp->if_broot"
          ],
          "line": 576
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/kmem.h",
          "lines": "66-69",
          "snippet": "static inline void  kmem_free(const void *ptr)\n{\n\tkvfree(ptr);\n}",
          "includes": [
            "#include <linux/vmalloc.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n\nstatic inline void  kmem_free(const void *ptr)\n{\n\tkvfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "np",
            "op",
            "new_max * (uint)sizeof(xfs_fsblock_t)"
          ],
          "line": 574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BMAP_BROOT_PTR_ADDR",
          "args": [
            "mp",
            "new_broot",
            "1",
            "(int)new_size"
          ],
          "line": 572
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BMAP_BROOT_PTR_ADDR",
          "args": [
            "mp",
            "ifp->if_broot",
            "1",
            "ifp->if_broot_bytes"
          ],
          "line": 570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "np",
            "op",
            "new_max * (uint)sizeof(xfs_bmbt_rec_t)"
          ],
          "line": 565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BMBT_REC_ADDR",
          "args": [
            "mp",
            "new_broot",
            "1"
          ],
          "line": 564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BMBT_REC_ADDR",
          "args": [
            "mp",
            "ifp->if_broot",
            "1"
          ],
          "line": 563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "new_broot",
            "ifp->if_broot",
            "XFS_BMBT_BLOCK_LEN(ip->i_mount)"
          ],
          "line": 549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BMBT_BLOCK_LEN",
          "args": [
            "ip->i_mount"
          ],
          "line": 550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_alloc",
          "args": [
            "new_size",
            "KM_SLEEP | KM_NOFS"
          ],
          "line": 545
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/kmem.c",
          "lines": "45-62",
          "snippet": "void *\nkmem_alloc(size_t size, xfs_km_flags_t flags)\n{\n\tint\tretries = 0;\n\tgfp_t\tlflags = kmem_flags_convert(flags);\n\tvoid\t*ptr;\n\n\tdo {\n\t\tptr = kmalloc(size, lflags);\n\t\tif (ptr || (flags & (KM_MAYFAIL|KM_NOSLEEP)))\n\t\t\treturn ptr;\n\t\tif (!(++retries % 100))\n\t\t\txfs_err(NULL,\n\t\t\"possible memory allocation deadlock in %s (mode:0x%x)\",\n\t\t\t\t\t__func__, lflags);\n\t\tcongestion_wait(BLK_RW_ASYNC, HZ/50);\n\t} while (1);\n}",
          "includes": [
            "#include \"xfs_message.h\"",
            "#include \"kmem.h\"",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_message.h\"\n#include \"kmem.h\"\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nvoid *\nkmem_alloc(size_t size, xfs_km_flags_t flags)\n{\n\tint\tretries = 0;\n\tgfp_t\tlflags = kmem_flags_convert(flags);\n\tvoid\t*ptr;\n\n\tdo {\n\t\tptr = kmalloc(size, lflags);\n\t\tif (ptr || (flags & (KM_MAYFAIL|KM_NOSLEEP)))\n\t\t\treturn ptr;\n\t\tif (!(++retries % 100))\n\t\t\txfs_err(NULL,\n\t\t\"possible memory allocation deadlock in %s (mode:0x%x)\",\n\t\t\t\t\t__func__, lflags);\n\t\tcongestion_wait(BLK_RW_ASYNC, HZ/50);\n\t} while (1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_BMAP_BROOT_SPACE_CALC",
          "args": [
            "mp",
            "new_max"
          ],
          "line": 541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "new_max >= 0"
          ],
          "line": 539
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_bmbt_maxrecs",
          "args": [
            "mp",
            "ifp->if_broot_bytes",
            "0"
          ],
          "line": 537
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmbt_maxrecs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap_btree.c",
          "lines": "813-824",
          "snippet": "int\nxfs_bmbt_maxrecs(\n\tstruct xfs_mount\t*mp,\n\tint\t\t\tblocklen,\n\tint\t\t\tleaf)\n{\n\tblocklen -= XFS_BMBT_BLOCK_LEN(mp);\n\n\tif (leaf)\n\t\treturn blocklen / sizeof(xfs_bmbt_rec_t);\n\treturn blocklen / (sizeof(xfs_bmbt_key_t) + sizeof(xfs_bmbt_ptr_t));\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nint\nxfs_bmbt_maxrecs(\n\tstruct xfs_mount\t*mp,\n\tint\t\t\tblocklen,\n\tint\t\t\tleaf)\n{\n\tblocklen -= XFS_BMBT_BLOCK_LEN(mp);\n\n\tif (leaf)\n\t\treturn blocklen / sizeof(xfs_bmbt_rec_t);\n\treturn blocklen / (sizeof(xfs_bmbt_key_t) + sizeof(xfs_bmbt_ptr_t));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "(ifp->if_broot != NULL) && (ifp->if_broot_bytes > 0)"
          ],
          "line": 536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "np",
            "op",
            "cur_max * (uint)sizeof(xfs_fsblock_t)"
          ],
          "line": 527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "XFS_BMAP_BMDR_SPACE(ifp->if_broot) <=\n\t\t\tXFS_IFORK_SIZE(ip, whichfork)"
          ],
          "line": 525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_IFORK_SIZE",
          "args": [
            "ip",
            "whichfork"
          ],
          "line": 526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BMAP_BMDR_SPACE",
          "args": [
            "ifp->if_broot"
          ],
          "line": 525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BMAP_BROOT_PTR_ADDR",
          "args": [
            "mp",
            "ifp->if_broot",
            "1",
            "(int)new_size"
          ],
          "line": 522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BMAP_BROOT_PTR_ADDR",
          "args": [
            "mp",
            "ifp->if_broot",
            "1",
            "ifp->if_broot_bytes"
          ],
          "line": 520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_realloc",
          "args": [
            "ifp->if_broot",
            "new_size",
            "XFS_BMAP_BROOT_SPACE_CALC(mp, cur_max)",
            "KM_SLEEP | KM_NOFS"
          ],
          "line": 517
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_realloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/kmem.c",
          "lines": "94-108",
          "snippet": "void *\nkmem_realloc(const void *ptr, size_t newsize, size_t oldsize,\n\t     xfs_km_flags_t flags)\n{\n\tvoid\t*new;\n\n\tnew = kmem_alloc(newsize, flags);\n\tif (ptr) {\n\t\tif (new)\n\t\t\tmemcpy(new, ptr,\n\t\t\t\t((oldsize < newsize) ? oldsize : newsize));\n\t\tkmem_free(ptr);\n\t}\n\treturn new;\n}",
          "includes": [
            "#include \"xfs_message.h\"",
            "#include \"kmem.h\"",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_message.h\"\n#include \"kmem.h\"\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nvoid *\nkmem_realloc(const void *ptr, size_t newsize, size_t oldsize,\n\t     xfs_km_flags_t flags)\n{\n\tvoid\t*new;\n\n\tnew = kmem_alloc(newsize, flags);\n\tif (ptr) {\n\t\tif (new)\n\t\t\tmemcpy(new, ptr,\n\t\t\t\t((oldsize < newsize) ? oldsize : newsize));\n\t\tkmem_free(ptr);\n\t}\n\treturn new;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_BMAP_BROOT_SPACE_CALC",
          "args": [
            "mp",
            "cur_max"
          ],
          "line": 518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BMAP_BROOT_SPACE_CALC",
          "args": [
            "mp",
            "new_max"
          ],
          "line": 516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BMAP_BROOT_SPACE_CALC",
          "args": [
            "mp",
            "rec_diff"
          ],
          "line": 502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_IFORK_PTR",
          "args": [
            "ip",
            "whichfork"
          ],
          "line": 495
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_attr_sf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nvoid\nxfs_iroot_realloc(\n\txfs_inode_t\t\t*ip,\n\tint\t\t\trec_diff,\n\tint\t\t\twhichfork)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tint\t\t\tcur_max;\n\txfs_ifork_t\t\t*ifp;\n\tstruct xfs_btree_block\t*new_broot;\n\tint\t\t\tnew_max;\n\tsize_t\t\t\tnew_size;\n\tchar\t\t\t*np;\n\tchar\t\t\t*op;\n\n\t/*\n\t * Handle the degenerate case quietly.\n\t */\n\tif (rec_diff == 0) {\n\t\treturn;\n\t}\n\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\tif (rec_diff > 0) {\n\t\t/*\n\t\t * If there wasn't any memory allocated before, just\n\t\t * allocate it now and get out.\n\t\t */\n\t\tif (ifp->if_broot_bytes == 0) {\n\t\t\tnew_size = XFS_BMAP_BROOT_SPACE_CALC(mp, rec_diff);\n\t\t\tifp->if_broot = kmem_alloc(new_size, KM_SLEEP | KM_NOFS);\n\t\t\tifp->if_broot_bytes = (int)new_size;\n\t\t\treturn;\n\t\t}\n\n\t\t/*\n\t\t * If there is already an existing if_broot, then we need\n\t\t * to realloc() it and shift the pointers to their new\n\t\t * location.  The records don't change location because\n\t\t * they are kept butted up against the btree block header.\n\t\t */\n\t\tcur_max = xfs_bmbt_maxrecs(mp, ifp->if_broot_bytes, 0);\n\t\tnew_max = cur_max + rec_diff;\n\t\tnew_size = XFS_BMAP_BROOT_SPACE_CALC(mp, new_max);\n\t\tifp->if_broot = kmem_realloc(ifp->if_broot, new_size,\n\t\t\t\tXFS_BMAP_BROOT_SPACE_CALC(mp, cur_max),\n\t\t\t\tKM_SLEEP | KM_NOFS);\n\t\top = (char *)XFS_BMAP_BROOT_PTR_ADDR(mp, ifp->if_broot, 1,\n\t\t\t\t\t\t     ifp->if_broot_bytes);\n\t\tnp = (char *)XFS_BMAP_BROOT_PTR_ADDR(mp, ifp->if_broot, 1,\n\t\t\t\t\t\t     (int)new_size);\n\t\tifp->if_broot_bytes = (int)new_size;\n\t\tASSERT(XFS_BMAP_BMDR_SPACE(ifp->if_broot) <=\n\t\t\tXFS_IFORK_SIZE(ip, whichfork));\n\t\tmemmove(np, op, cur_max * (uint)sizeof(xfs_fsblock_t));\n\t\treturn;\n\t}\n\n\t/*\n\t * rec_diff is less than 0.  In this case, we are shrinking the\n\t * if_broot buffer.  It must already exist.  If we go to zero\n\t * records, just get rid of the root and clear the status bit.\n\t */\n\tASSERT((ifp->if_broot != NULL) && (ifp->if_broot_bytes > 0));\n\tcur_max = xfs_bmbt_maxrecs(mp, ifp->if_broot_bytes, 0);\n\tnew_max = cur_max + rec_diff;\n\tASSERT(new_max >= 0);\n\tif (new_max > 0)\n\t\tnew_size = XFS_BMAP_BROOT_SPACE_CALC(mp, new_max);\n\telse\n\t\tnew_size = 0;\n\tif (new_size > 0) {\n\t\tnew_broot = kmem_alloc(new_size, KM_SLEEP | KM_NOFS);\n\t\t/*\n\t\t * First copy over the btree block header.\n\t\t */\n\t\tmemcpy(new_broot, ifp->if_broot,\n\t\t\tXFS_BMBT_BLOCK_LEN(ip->i_mount));\n\t} else {\n\t\tnew_broot = NULL;\n\t\tifp->if_flags &= ~XFS_IFBROOT;\n\t}\n\n\t/*\n\t * Only copy the records and pointers if there are any.\n\t */\n\tif (new_max > 0) {\n\t\t/*\n\t\t * First copy the records.\n\t\t */\n\t\top = (char *)XFS_BMBT_REC_ADDR(mp, ifp->if_broot, 1);\n\t\tnp = (char *)XFS_BMBT_REC_ADDR(mp, new_broot, 1);\n\t\tmemcpy(np, op, new_max * (uint)sizeof(xfs_bmbt_rec_t));\n\n\t\t/*\n\t\t * Then copy the pointers.\n\t\t */\n\t\top = (char *)XFS_BMAP_BROOT_PTR_ADDR(mp, ifp->if_broot, 1,\n\t\t\t\t\t\t     ifp->if_broot_bytes);\n\t\tnp = (char *)XFS_BMAP_BROOT_PTR_ADDR(mp, new_broot, 1,\n\t\t\t\t\t\t     (int)new_size);\n\t\tmemcpy(np, op, new_max * (uint)sizeof(xfs_fsblock_t));\n\t}\n\tkmem_free(ifp->if_broot);\n\tifp->if_broot = new_broot;\n\tifp->if_broot_bytes = (int)new_size;\n\tif (ifp->if_broot)\n\t\tASSERT(XFS_BMAP_BMDR_SPACE(ifp->if_broot) <=\n\t\t\tXFS_IFORK_SIZE(ip, whichfork));\n\treturn;\n}"
  },
  {
    "function_name": "xfs_iread_extents",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_inode_fork.c",
    "lines": "420-454",
    "snippet": "int\nxfs_iread_extents(\n\txfs_trans_t\t*tp,\n\txfs_inode_t\t*ip,\n\tint\t\twhichfork)\n{\n\tint\t\terror;\n\txfs_ifork_t\t*ifp;\n\txfs_extnum_t\tnextents;\n\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\n\tif (unlikely(XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_BTREE)) {\n\t\tXFS_ERROR_REPORT(\"xfs_iread_extents\", XFS_ERRLEVEL_LOW,\n\t\t\t\t ip->i_mount);\n\t\treturn -EFSCORRUPTED;\n\t}\n\tnextents = XFS_IFORK_NEXTENTS(ip, whichfork);\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\n\t/*\n\t * We know that the size is valid (it's checked in iformat_btree)\n\t */\n\tifp->if_bytes = ifp->if_real_bytes = 0;\n\tifp->if_flags |= XFS_IFEXTENTS;\n\txfs_iext_add(ifp, 0, nextents);\n\terror = xfs_bmap_read_extents(tp, ip, whichfork);\n\tif (error) {\n\t\txfs_iext_destroy(ifp);\n\t\tifp->if_flags &= ~XFS_IFEXTENTS;\n\t\treturn error;\n\t}\n\txfs_validate_extents(ifp, nextents, XFS_EXTFMT_INODE(ip));\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_attr_sf.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\"",
      "#include <linux/log2.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_validate_extents",
          "args": [
            "ifp",
            "nextents",
            "XFS_EXTFMT_INODE(ip)"
          ],
          "line": 452
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_validate_extents",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_inode_fork.c",
          "lines": "46-64",
          "snippet": "void\nxfs_validate_extents(\n\txfs_ifork_t\t\t*ifp,\n\tint\t\t\tnrecs,\n\txfs_exntfmt_t\t\tfmt)\n{\n\txfs_bmbt_irec_t\t\tirec;\n\txfs_bmbt_rec_host_t\trec;\n\tint\t\t\ti;\n\n\tfor (i = 0; i < nrecs; i++) {\n\t\txfs_bmbt_rec_host_t *ep = xfs_iext_get_ext(ifp, i);\n\t\trec.l0 = get_unaligned(&ep->l0);\n\t\trec.l1 = get_unaligned(&ep->l1);\n\t\txfs_bmbt_get_all(&rec, &irec);\n\t\tif (fmt == XFS_EXTFMT_NOSTATE)\n\t\t\tASSERT(irec.br_state == XFS_EXT_NORM);\n\t}\n}",
          "includes": [
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_attr_sf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nvoid\nxfs_validate_extents(\n\txfs_ifork_t\t\t*ifp,\n\tint\t\t\tnrecs,\n\txfs_exntfmt_t\t\tfmt)\n{\n\txfs_bmbt_irec_t\t\tirec;\n\txfs_bmbt_rec_host_t\trec;\n\tint\t\t\ti;\n\n\tfor (i = 0; i < nrecs; i++) {\n\t\txfs_bmbt_rec_host_t *ep = xfs_iext_get_ext(ifp, i);\n\t\trec.l0 = get_unaligned(&ep->l0);\n\t\trec.l1 = get_unaligned(&ep->l1);\n\t\txfs_bmbt_get_all(&rec, &irec);\n\t\tif (fmt == XFS_EXTFMT_NOSTATE)\n\t\t\tASSERT(irec.br_state == XFS_EXT_NORM);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_EXTFMT_INODE",
          "args": [
            "ip"
          ],
          "line": 452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_iext_destroy",
          "args": [
            "ifp"
          ],
          "line": 448
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_iext_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_inode_fork.c",
          "lines": "1501-1523",
          "snippet": "void\nxfs_iext_destroy(\n\txfs_ifork_t\t*ifp)\t\t/* inode fork pointer */\n{\n\tif (ifp->if_flags & XFS_IFEXTIREC) {\n\t\tint\terp_idx;\n\t\tint\tnlists;\n\n\t\tnlists = ifp->if_real_bytes / XFS_IEXT_BUFSZ;\n\t\tfor (erp_idx = nlists - 1; erp_idx >= 0 ; erp_idx--) {\n\t\t\txfs_iext_irec_remove(ifp, erp_idx);\n\t\t}\n\t\tifp->if_flags &= ~XFS_IFEXTIREC;\n\t} else if (ifp->if_real_bytes) {\n\t\tkmem_free(ifp->if_u1.if_extents);\n\t} else if (ifp->if_bytes) {\n\t\tmemset(ifp->if_u2.if_inline_ext, 0, XFS_INLINE_EXTS *\n\t\t\tsizeof(xfs_bmbt_rec_t));\n\t}\n\tifp->if_u1.if_extents = NULL;\n\tifp->if_real_bytes = 0;\n\tifp->if_bytes = 0;\n}",
          "includes": [
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_attr_sf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nvoid\nxfs_iext_destroy(\n\txfs_ifork_t\t*ifp)\t\t/* inode fork pointer */\n{\n\tif (ifp->if_flags & XFS_IFEXTIREC) {\n\t\tint\terp_idx;\n\t\tint\tnlists;\n\n\t\tnlists = ifp->if_real_bytes / XFS_IEXT_BUFSZ;\n\t\tfor (erp_idx = nlists - 1; erp_idx >= 0 ; erp_idx--) {\n\t\t\txfs_iext_irec_remove(ifp, erp_idx);\n\t\t}\n\t\tifp->if_flags &= ~XFS_IFEXTIREC;\n\t} else if (ifp->if_real_bytes) {\n\t\tkmem_free(ifp->if_u1.if_extents);\n\t} else if (ifp->if_bytes) {\n\t\tmemset(ifp->if_u2.if_inline_ext, 0, XFS_INLINE_EXTS *\n\t\t\tsizeof(xfs_bmbt_rec_t));\n\t}\n\tifp->if_u1.if_extents = NULL;\n\tifp->if_real_bytes = 0;\n\tifp->if_bytes = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_bmap_read_extents",
          "args": [
            "tp",
            "ip",
            "whichfork"
          ],
          "line": 446
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmap_read_extents",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.c",
          "lines": "1269-1402",
          "snippet": "int\t\t\t\t\t/* error */\nxfs_bmap_read_extents(\n\txfs_trans_t\t\t*tp,\t/* transaction pointer */\n\txfs_inode_t\t\t*ip,\t/* incore inode */\n\tint\t\t\twhichfork) /* data or attr fork */\n{\n\tstruct xfs_btree_block\t*block;\t/* current btree block */\n\txfs_fsblock_t\t\tbno;\t/* block # of \"block\" */\n\txfs_buf_t\t\t*bp;\t/* buffer for \"block\" */\n\tint\t\t\terror;\t/* error return value */\n\txfs_exntfmt_t\t\texntf;\t/* XFS_EXTFMT_NOSTATE, if checking */\n\txfs_extnum_t\t\ti, j;\t/* index into the extents list */\n\txfs_ifork_t\t\t*ifp;\t/* fork structure */\n\tint\t\t\tlevel;\t/* btree level, for checking */\n\txfs_mount_t\t\t*mp;\t/* file system mount structure */\n\t__be64\t\t\t*pp;\t/* pointer to block address */\n\t/* REFERENCED */\n\txfs_extnum_t\t\troom;\t/* number of entries there's room for */\n\n\tbno = NULLFSBLOCK;\n\tmp = ip->i_mount;\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\texntf = (whichfork != XFS_DATA_FORK) ? XFS_EXTFMT_NOSTATE :\n\t\t\t\t\tXFS_EXTFMT_INODE(ip);\n\tblock = ifp->if_broot;\n\t/*\n\t * Root level must use BMAP_BROOT_PTR_ADDR macro to get ptr out.\n\t */\n\tlevel = be16_to_cpu(block->bb_level);\n\tASSERT(level > 0);\n\tpp = XFS_BMAP_BROOT_PTR_ADDR(mp, block, 1, ifp->if_broot_bytes);\n\tbno = be64_to_cpu(*pp);\n\tASSERT(bno != NULLFSBLOCK);\n\tASSERT(XFS_FSB_TO_AGNO(mp, bno) < mp->m_sb.sb_agcount);\n\tASSERT(XFS_FSB_TO_AGBNO(mp, bno) < mp->m_sb.sb_agblocks);\n\t/*\n\t * Go down the tree until leaf level is reached, following the first\n\t * pointer (leftmost) at each level.\n\t */\n\twhile (level-- > 0) {\n\t\terror = xfs_btree_read_bufl(mp, tp, bno, 0, &bp,\n\t\t\t\tXFS_BMAP_BTREE_REF, &xfs_bmbt_buf_ops);\n\t\tif (error)\n\t\t\treturn error;\n\t\tblock = XFS_BUF_TO_BLOCK(bp);\n\t\tXFS_WANT_CORRUPTED_GOTO(\n\t\t\txfs_bmap_sanity_check(mp, bp, level),\n\t\t\terror0);\n\t\tif (level == 0)\n\t\t\tbreak;\n\t\tpp = XFS_BMBT_PTR_ADDR(mp, block, 1, mp->m_bmap_dmxr[1]);\n\t\tbno = be64_to_cpu(*pp);\n\t\tXFS_WANT_CORRUPTED_GOTO(XFS_FSB_SANITY_CHECK(mp, bno), error0);\n\t\txfs_trans_brelse(tp, bp);\n\t}\n\t/*\n\t * Here with bp and block set to the leftmost leaf node in the tree.\n\t */\n\troom = ifp->if_bytes / (uint)sizeof(xfs_bmbt_rec_t);\n\ti = 0;\n\t/*\n\t * Loop over all leaf nodes.  Copy information to the extent records.\n\t */\n\tfor (;;) {\n\t\txfs_bmbt_rec_t\t*frp;\n\t\txfs_fsblock_t\tnextbno;\n\t\txfs_extnum_t\tnum_recs;\n\t\txfs_extnum_t\tstart;\n\n\t\tnum_recs = xfs_btree_get_numrecs(block);\n\t\tif (unlikely(i + num_recs > room)) {\n\t\t\tASSERT(i + num_recs <= room);\n\t\t\txfs_warn(ip->i_mount,\n\t\t\t\t\"corrupt dinode %Lu, (btree extents).\",\n\t\t\t\t(unsigned long long) ip->i_ino);\n\t\t\tXFS_CORRUPTION_ERROR(\"xfs_bmap_read_extents(1)\",\n\t\t\t\tXFS_ERRLEVEL_LOW, ip->i_mount, block);\n\t\t\tgoto error0;\n\t\t}\n\t\tXFS_WANT_CORRUPTED_GOTO(\n\t\t\txfs_bmap_sanity_check(mp, bp, 0),\n\t\t\terror0);\n\t\t/*\n\t\t * Read-ahead the next leaf block, if any.\n\t\t */\n\t\tnextbno = be64_to_cpu(block->bb_u.l.bb_rightsib);\n\t\tif (nextbno != NULLFSBLOCK)\n\t\t\txfs_btree_reada_bufl(mp, nextbno, 1,\n\t\t\t\t\t     &xfs_bmbt_buf_ops);\n\t\t/*\n\t\t * Copy records into the extent records.\n\t\t */\n\t\tfrp = XFS_BMBT_REC_ADDR(mp, block, 1);\n\t\tstart = i;\n\t\tfor (j = 0; j < num_recs; j++, i++, frp++) {\n\t\t\txfs_bmbt_rec_host_t *trp = xfs_iext_get_ext(ifp, i);\n\t\t\ttrp->l0 = be64_to_cpu(frp->l0);\n\t\t\ttrp->l1 = be64_to_cpu(frp->l1);\n\t\t}\n\t\tif (exntf == XFS_EXTFMT_NOSTATE) {\n\t\t\t/*\n\t\t\t * Check all attribute bmap btree records and\n\t\t\t * any \"older\" data bmap btree records for a\n\t\t\t * set bit in the \"extent flag\" position.\n\t\t\t */\n\t\t\tif (unlikely(xfs_check_nostate_extents(ifp,\n\t\t\t\t\tstart, num_recs))) {\n\t\t\t\tXFS_ERROR_REPORT(\"xfs_bmap_read_extents(2)\",\n\t\t\t\t\t\t XFS_ERRLEVEL_LOW,\n\t\t\t\t\t\t ip->i_mount);\n\t\t\t\tgoto error0;\n\t\t\t}\n\t\t}\n\t\txfs_trans_brelse(tp, bp);\n\t\tbno = nextbno;\n\t\t/*\n\t\t * If we've reached the end, stop.\n\t\t */\n\t\tif (bno == NULLFSBLOCK)\n\t\t\tbreak;\n\t\terror = xfs_btree_read_bufl(mp, tp, bno, 0, &bp,\n\t\t\t\tXFS_BMAP_BTREE_REF, &xfs_bmbt_buf_ops);\n\t\tif (error)\n\t\t\treturn error;\n\t\tblock = XFS_BUF_TO_BLOCK(bp);\n\t}\n\tASSERT(i == (ifp->if_bytes / (uint)sizeof(xfs_bmbt_rec_t)));\n\tASSERT(i == XFS_IFORK_NEXTENTS(ip, whichfork));\n\tXFS_BMAP_TRACE_EXLIST(ip, i, whichfork);\n\treturn 0;\nerror0:\n\txfs_trans_brelse(tp, bp);\n\treturn -EFSCORRUPTED;\n}",
          "includes": [
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\t\t\t\t\t/* error */\nxfs_bmap_read_extents(\n\txfs_trans_t\t\t*tp,\t/* transaction pointer */\n\txfs_inode_t\t\t*ip,\t/* incore inode */\n\tint\t\t\twhichfork) /* data or attr fork */\n{\n\tstruct xfs_btree_block\t*block;\t/* current btree block */\n\txfs_fsblock_t\t\tbno;\t/* block # of \"block\" */\n\txfs_buf_t\t\t*bp;\t/* buffer for \"block\" */\n\tint\t\t\terror;\t/* error return value */\n\txfs_exntfmt_t\t\texntf;\t/* XFS_EXTFMT_NOSTATE, if checking */\n\txfs_extnum_t\t\ti, j;\t/* index into the extents list */\n\txfs_ifork_t\t\t*ifp;\t/* fork structure */\n\tint\t\t\tlevel;\t/* btree level, for checking */\n\txfs_mount_t\t\t*mp;\t/* file system mount structure */\n\t__be64\t\t\t*pp;\t/* pointer to block address */\n\t/* REFERENCED */\n\txfs_extnum_t\t\troom;\t/* number of entries there's room for */\n\n\tbno = NULLFSBLOCK;\n\tmp = ip->i_mount;\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\texntf = (whichfork != XFS_DATA_FORK) ? XFS_EXTFMT_NOSTATE :\n\t\t\t\t\tXFS_EXTFMT_INODE(ip);\n\tblock = ifp->if_broot;\n\t/*\n\t * Root level must use BMAP_BROOT_PTR_ADDR macro to get ptr out.\n\t */\n\tlevel = be16_to_cpu(block->bb_level);\n\tASSERT(level > 0);\n\tpp = XFS_BMAP_BROOT_PTR_ADDR(mp, block, 1, ifp->if_broot_bytes);\n\tbno = be64_to_cpu(*pp);\n\tASSERT(bno != NULLFSBLOCK);\n\tASSERT(XFS_FSB_TO_AGNO(mp, bno) < mp->m_sb.sb_agcount);\n\tASSERT(XFS_FSB_TO_AGBNO(mp, bno) < mp->m_sb.sb_agblocks);\n\t/*\n\t * Go down the tree until leaf level is reached, following the first\n\t * pointer (leftmost) at each level.\n\t */\n\twhile (level-- > 0) {\n\t\terror = xfs_btree_read_bufl(mp, tp, bno, 0, &bp,\n\t\t\t\tXFS_BMAP_BTREE_REF, &xfs_bmbt_buf_ops);\n\t\tif (error)\n\t\t\treturn error;\n\t\tblock = XFS_BUF_TO_BLOCK(bp);\n\t\tXFS_WANT_CORRUPTED_GOTO(\n\t\t\txfs_bmap_sanity_check(mp, bp, level),\n\t\t\terror0);\n\t\tif (level == 0)\n\t\t\tbreak;\n\t\tpp = XFS_BMBT_PTR_ADDR(mp, block, 1, mp->m_bmap_dmxr[1]);\n\t\tbno = be64_to_cpu(*pp);\n\t\tXFS_WANT_CORRUPTED_GOTO(XFS_FSB_SANITY_CHECK(mp, bno), error0);\n\t\txfs_trans_brelse(tp, bp);\n\t}\n\t/*\n\t * Here with bp and block set to the leftmost leaf node in the tree.\n\t */\n\troom = ifp->if_bytes / (uint)sizeof(xfs_bmbt_rec_t);\n\ti = 0;\n\t/*\n\t * Loop over all leaf nodes.  Copy information to the extent records.\n\t */\n\tfor (;;) {\n\t\txfs_bmbt_rec_t\t*frp;\n\t\txfs_fsblock_t\tnextbno;\n\t\txfs_extnum_t\tnum_recs;\n\t\txfs_extnum_t\tstart;\n\n\t\tnum_recs = xfs_btree_get_numrecs(block);\n\t\tif (unlikely(i + num_recs > room)) {\n\t\t\tASSERT(i + num_recs <= room);\n\t\t\txfs_warn(ip->i_mount,\n\t\t\t\t\"corrupt dinode %Lu, (btree extents).\",\n\t\t\t\t(unsigned long long) ip->i_ino);\n\t\t\tXFS_CORRUPTION_ERROR(\"xfs_bmap_read_extents(1)\",\n\t\t\t\tXFS_ERRLEVEL_LOW, ip->i_mount, block);\n\t\t\tgoto error0;\n\t\t}\n\t\tXFS_WANT_CORRUPTED_GOTO(\n\t\t\txfs_bmap_sanity_check(mp, bp, 0),\n\t\t\terror0);\n\t\t/*\n\t\t * Read-ahead the next leaf block, if any.\n\t\t */\n\t\tnextbno = be64_to_cpu(block->bb_u.l.bb_rightsib);\n\t\tif (nextbno != NULLFSBLOCK)\n\t\t\txfs_btree_reada_bufl(mp, nextbno, 1,\n\t\t\t\t\t     &xfs_bmbt_buf_ops);\n\t\t/*\n\t\t * Copy records into the extent records.\n\t\t */\n\t\tfrp = XFS_BMBT_REC_ADDR(mp, block, 1);\n\t\tstart = i;\n\t\tfor (j = 0; j < num_recs; j++, i++, frp++) {\n\t\t\txfs_bmbt_rec_host_t *trp = xfs_iext_get_ext(ifp, i);\n\t\t\ttrp->l0 = be64_to_cpu(frp->l0);\n\t\t\ttrp->l1 = be64_to_cpu(frp->l1);\n\t\t}\n\t\tif (exntf == XFS_EXTFMT_NOSTATE) {\n\t\t\t/*\n\t\t\t * Check all attribute bmap btree records and\n\t\t\t * any \"older\" data bmap btree records for a\n\t\t\t * set bit in the \"extent flag\" position.\n\t\t\t */\n\t\t\tif (unlikely(xfs_check_nostate_extents(ifp,\n\t\t\t\t\tstart, num_recs))) {\n\t\t\t\tXFS_ERROR_REPORT(\"xfs_bmap_read_extents(2)\",\n\t\t\t\t\t\t XFS_ERRLEVEL_LOW,\n\t\t\t\t\t\t ip->i_mount);\n\t\t\t\tgoto error0;\n\t\t\t}\n\t\t}\n\t\txfs_trans_brelse(tp, bp);\n\t\tbno = nextbno;\n\t\t/*\n\t\t * If we've reached the end, stop.\n\t\t */\n\t\tif (bno == NULLFSBLOCK)\n\t\t\tbreak;\n\t\terror = xfs_btree_read_bufl(mp, tp, bno, 0, &bp,\n\t\t\t\tXFS_BMAP_BTREE_REF, &xfs_bmbt_buf_ops);\n\t\tif (error)\n\t\t\treturn error;\n\t\tblock = XFS_BUF_TO_BLOCK(bp);\n\t}\n\tASSERT(i == (ifp->if_bytes / (uint)sizeof(xfs_bmbt_rec_t)));\n\tASSERT(i == XFS_IFORK_NEXTENTS(ip, whichfork));\n\tXFS_BMAP_TRACE_EXLIST(ip, i, whichfork);\n\treturn 0;\nerror0:\n\txfs_trans_brelse(tp, bp);\n\treturn -EFSCORRUPTED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_iext_add",
          "args": [
            "ifp",
            "0",
            "nextents"
          ],
          "line": 445
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_iext_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_inode_fork.c",
          "lines": "940-1034",
          "snippet": "void\nxfs_iext_add(\n\txfs_ifork_t\t*ifp,\t\t/* inode fork pointer */\n\txfs_extnum_t\tidx,\t\t/* index to begin adding exts */\n\tint\t\text_diff)\t/* number of extents to add */\n{\n\tint\t\tbyte_diff;\t/* new bytes being added */\n\tint\t\tnew_size;\t/* size of extents after adding */\n\txfs_extnum_t\tnextents;\t/* number of extents in file */\n\n\tnextents = ifp->if_bytes / (uint)sizeof(xfs_bmbt_rec_t);\n\tASSERT((idx >= 0) && (idx <= nextents));\n\tbyte_diff = ext_diff * sizeof(xfs_bmbt_rec_t);\n\tnew_size = ifp->if_bytes + byte_diff;\n\t/*\n\t * If the new number of extents (nextents + ext_diff)\n\t * fits inside the inode, then continue to use the inline\n\t * extent buffer.\n\t */\n\tif (nextents + ext_diff <= XFS_INLINE_EXTS) {\n\t\tif (idx < nextents) {\n\t\t\tmemmove(&ifp->if_u2.if_inline_ext[idx + ext_diff],\n\t\t\t\t&ifp->if_u2.if_inline_ext[idx],\n\t\t\t\t(nextents - idx) * sizeof(xfs_bmbt_rec_t));\n\t\t\tmemset(&ifp->if_u2.if_inline_ext[idx], 0, byte_diff);\n\t\t}\n\t\tifp->if_u1.if_extents = ifp->if_u2.if_inline_ext;\n\t\tifp->if_real_bytes = 0;\n\t}\n\t/*\n\t * Otherwise use a linear (direct) extent list.\n\t * If the extents are currently inside the inode,\n\t * xfs_iext_realloc_direct will switch us from\n\t * inline to direct extent allocation mode.\n\t */\n\telse if (nextents + ext_diff <= XFS_LINEAR_EXTS) {\n\t\txfs_iext_realloc_direct(ifp, new_size);\n\t\tif (idx < nextents) {\n\t\t\tmemmove(&ifp->if_u1.if_extents[idx + ext_diff],\n\t\t\t\t&ifp->if_u1.if_extents[idx],\n\t\t\t\t(nextents - idx) * sizeof(xfs_bmbt_rec_t));\n\t\t\tmemset(&ifp->if_u1.if_extents[idx], 0, byte_diff);\n\t\t}\n\t}\n\t/* Indirection array */\n\telse {\n\t\txfs_ext_irec_t\t*erp;\n\t\tint\t\terp_idx = 0;\n\t\tint\t\tpage_idx = idx;\n\n\t\tASSERT(nextents + ext_diff > XFS_LINEAR_EXTS);\n\t\tif (ifp->if_flags & XFS_IFEXTIREC) {\n\t\t\terp = xfs_iext_idx_to_irec(ifp, &page_idx, &erp_idx, 1);\n\t\t} else {\n\t\t\txfs_iext_irec_init(ifp);\n\t\t\tASSERT(ifp->if_flags & XFS_IFEXTIREC);\n\t\t\terp = ifp->if_u1.if_ext_irec;\n\t\t}\n\t\t/* Extents fit in target extent page */\n\t\tif (erp && erp->er_extcount + ext_diff <= XFS_LINEAR_EXTS) {\n\t\t\tif (page_idx < erp->er_extcount) {\n\t\t\t\tmemmove(&erp->er_extbuf[page_idx + ext_diff],\n\t\t\t\t\t&erp->er_extbuf[page_idx],\n\t\t\t\t\t(erp->er_extcount - page_idx) *\n\t\t\t\t\tsizeof(xfs_bmbt_rec_t));\n\t\t\t\tmemset(&erp->er_extbuf[page_idx], 0, byte_diff);\n\t\t\t}\n\t\t\terp->er_extcount += ext_diff;\n\t\t\txfs_iext_irec_update_extoffs(ifp, erp_idx + 1, ext_diff);\n\t\t}\n\t\t/* Insert a new extent page */\n\t\telse if (erp) {\n\t\t\txfs_iext_add_indirect_multi(ifp,\n\t\t\t\terp_idx, page_idx, ext_diff);\n\t\t}\n\t\t/*\n\t\t * If extent(s) are being appended to the last page in\n\t\t * the indirection array and the new extent(s) don't fit\n\t\t * in the page, then erp is NULL and erp_idx is set to\n\t\t * the next index needed in the indirection array.\n\t\t */\n\t\telse {\n\t\t\tuint\tcount = ext_diff;\n\n\t\t\twhile (count) {\n\t\t\t\terp = xfs_iext_irec_new(ifp, erp_idx);\n\t\t\t\terp->er_extcount = min(count, XFS_LINEAR_EXTS);\n\t\t\t\tcount -= erp->er_extcount;\n\t\t\t\tif (count)\n\t\t\t\t\terp_idx++;\n\t\t\t}\n\t\t}\n\t}\n\tifp->if_bytes = new_size;\n}",
          "includes": [
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_attr_sf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nvoid\nxfs_iext_add(\n\txfs_ifork_t\t*ifp,\t\t/* inode fork pointer */\n\txfs_extnum_t\tidx,\t\t/* index to begin adding exts */\n\tint\t\text_diff)\t/* number of extents to add */\n{\n\tint\t\tbyte_diff;\t/* new bytes being added */\n\tint\t\tnew_size;\t/* size of extents after adding */\n\txfs_extnum_t\tnextents;\t/* number of extents in file */\n\n\tnextents = ifp->if_bytes / (uint)sizeof(xfs_bmbt_rec_t);\n\tASSERT((idx >= 0) && (idx <= nextents));\n\tbyte_diff = ext_diff * sizeof(xfs_bmbt_rec_t);\n\tnew_size = ifp->if_bytes + byte_diff;\n\t/*\n\t * If the new number of extents (nextents + ext_diff)\n\t * fits inside the inode, then continue to use the inline\n\t * extent buffer.\n\t */\n\tif (nextents + ext_diff <= XFS_INLINE_EXTS) {\n\t\tif (idx < nextents) {\n\t\t\tmemmove(&ifp->if_u2.if_inline_ext[idx + ext_diff],\n\t\t\t\t&ifp->if_u2.if_inline_ext[idx],\n\t\t\t\t(nextents - idx) * sizeof(xfs_bmbt_rec_t));\n\t\t\tmemset(&ifp->if_u2.if_inline_ext[idx], 0, byte_diff);\n\t\t}\n\t\tifp->if_u1.if_extents = ifp->if_u2.if_inline_ext;\n\t\tifp->if_real_bytes = 0;\n\t}\n\t/*\n\t * Otherwise use a linear (direct) extent list.\n\t * If the extents are currently inside the inode,\n\t * xfs_iext_realloc_direct will switch us from\n\t * inline to direct extent allocation mode.\n\t */\n\telse if (nextents + ext_diff <= XFS_LINEAR_EXTS) {\n\t\txfs_iext_realloc_direct(ifp, new_size);\n\t\tif (idx < nextents) {\n\t\t\tmemmove(&ifp->if_u1.if_extents[idx + ext_diff],\n\t\t\t\t&ifp->if_u1.if_extents[idx],\n\t\t\t\t(nextents - idx) * sizeof(xfs_bmbt_rec_t));\n\t\t\tmemset(&ifp->if_u1.if_extents[idx], 0, byte_diff);\n\t\t}\n\t}\n\t/* Indirection array */\n\telse {\n\t\txfs_ext_irec_t\t*erp;\n\t\tint\t\terp_idx = 0;\n\t\tint\t\tpage_idx = idx;\n\n\t\tASSERT(nextents + ext_diff > XFS_LINEAR_EXTS);\n\t\tif (ifp->if_flags & XFS_IFEXTIREC) {\n\t\t\terp = xfs_iext_idx_to_irec(ifp, &page_idx, &erp_idx, 1);\n\t\t} else {\n\t\t\txfs_iext_irec_init(ifp);\n\t\t\tASSERT(ifp->if_flags & XFS_IFEXTIREC);\n\t\t\terp = ifp->if_u1.if_ext_irec;\n\t\t}\n\t\t/* Extents fit in target extent page */\n\t\tif (erp && erp->er_extcount + ext_diff <= XFS_LINEAR_EXTS) {\n\t\t\tif (page_idx < erp->er_extcount) {\n\t\t\t\tmemmove(&erp->er_extbuf[page_idx + ext_diff],\n\t\t\t\t\t&erp->er_extbuf[page_idx],\n\t\t\t\t\t(erp->er_extcount - page_idx) *\n\t\t\t\t\tsizeof(xfs_bmbt_rec_t));\n\t\t\t\tmemset(&erp->er_extbuf[page_idx], 0, byte_diff);\n\t\t\t}\n\t\t\terp->er_extcount += ext_diff;\n\t\t\txfs_iext_irec_update_extoffs(ifp, erp_idx + 1, ext_diff);\n\t\t}\n\t\t/* Insert a new extent page */\n\t\telse if (erp) {\n\t\t\txfs_iext_add_indirect_multi(ifp,\n\t\t\t\terp_idx, page_idx, ext_diff);\n\t\t}\n\t\t/*\n\t\t * If extent(s) are being appended to the last page in\n\t\t * the indirection array and the new extent(s) don't fit\n\t\t * in the page, then erp is NULL and erp_idx is set to\n\t\t * the next index needed in the indirection array.\n\t\t */\n\t\telse {\n\t\t\tuint\tcount = ext_diff;\n\n\t\t\twhile (count) {\n\t\t\t\terp = xfs_iext_irec_new(ifp, erp_idx);\n\t\t\t\terp->er_extcount = min(count, XFS_LINEAR_EXTS);\n\t\t\t\tcount -= erp->er_extcount;\n\t\t\t\tif (count)\n\t\t\t\t\terp_idx++;\n\t\t\t}\n\t\t}\n\t}\n\tifp->if_bytes = new_size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_IFORK_PTR",
          "args": [
            "ip",
            "whichfork"
          ],
          "line": 438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_IFORK_NEXTENTS",
          "args": [
            "ip",
            "whichfork"
          ],
          "line": 437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_ERROR_REPORT",
          "args": [
            "\"xfs_iread_extents\"",
            "XFS_ERRLEVEL_LOW",
            "ip->i_mount"
          ],
          "line": 433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_BTREE"
          ],
          "line": 432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_IFORK_FORMAT",
          "args": [
            "ip",
            "whichfork"
          ],
          "line": 432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "xfs_isilocked(ip, XFS_ILOCK_EXCL)"
          ],
          "line": 430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_isilocked",
          "args": [
            "ip",
            "XFS_ILOCK_EXCL"
          ],
          "line": 430
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_isilocked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
          "lines": "286-305",
          "snippet": "int\nxfs_isilocked(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\tif (lock_flags & (XFS_ILOCK_EXCL|XFS_ILOCK_SHARED)) {\n\t\tif (!(lock_flags & XFS_ILOCK_SHARED))\n\t\t\treturn !!ip->i_lock.mr_writer;\n\t\treturn rwsem_is_locked(&ip->i_lock.mr_lock);\n\t}\n\n\tif (lock_flags & (XFS_IOLOCK_EXCL|XFS_IOLOCK_SHARED)) {\n\t\tif (!(lock_flags & XFS_IOLOCK_SHARED))\n\t\t\treturn !!ip->i_iolock.mr_writer;\n\t\treturn rwsem_is_locked(&ip->i_iolock.mr_lock);\n\t}\n\n\tASSERT(0);\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);\n\nint\nxfs_isilocked(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\tif (lock_flags & (XFS_ILOCK_EXCL|XFS_ILOCK_SHARED)) {\n\t\tif (!(lock_flags & XFS_ILOCK_SHARED))\n\t\t\treturn !!ip->i_lock.mr_writer;\n\t\treturn rwsem_is_locked(&ip->i_lock.mr_lock);\n\t}\n\n\tif (lock_flags & (XFS_IOLOCK_EXCL|XFS_IOLOCK_SHARED)) {\n\t\tif (!(lock_flags & XFS_IOLOCK_SHARED))\n\t\t\treturn !!ip->i_iolock.mr_writer;\n\t\treturn rwsem_is_locked(&ip->i_iolock.mr_lock);\n\t}\n\n\tASSERT(0);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_attr_sf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nint\nxfs_iread_extents(\n\txfs_trans_t\t*tp,\n\txfs_inode_t\t*ip,\n\tint\t\twhichfork)\n{\n\tint\t\terror;\n\txfs_ifork_t\t*ifp;\n\txfs_extnum_t\tnextents;\n\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\n\tif (unlikely(XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_BTREE)) {\n\t\tXFS_ERROR_REPORT(\"xfs_iread_extents\", XFS_ERRLEVEL_LOW,\n\t\t\t\t ip->i_mount);\n\t\treturn -EFSCORRUPTED;\n\t}\n\tnextents = XFS_IFORK_NEXTENTS(ip, whichfork);\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\n\t/*\n\t * We know that the size is valid (it's checked in iformat_btree)\n\t */\n\tifp->if_bytes = ifp->if_real_bytes = 0;\n\tifp->if_flags |= XFS_IFEXTENTS;\n\txfs_iext_add(ifp, 0, nextents);\n\terror = xfs_bmap_read_extents(tp, ip, whichfork);\n\tif (error) {\n\t\txfs_iext_destroy(ifp);\n\t\tifp->if_flags &= ~XFS_IFEXTENTS;\n\t\treturn error;\n\t}\n\txfs_validate_extents(ifp, nextents, XFS_EXTFMT_INODE(ip));\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_iformat_btree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_inode_fork.c",
    "lines": "364-414",
    "snippet": "STATIC int\nxfs_iformat_btree(\n\txfs_inode_t\t\t*ip,\n\txfs_dinode_t\t\t*dip,\n\tint\t\t\twhichfork)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\txfs_bmdr_block_t\t*dfp;\n\txfs_ifork_t\t\t*ifp;\n\t/* REFERENCED */\n\tint\t\t\tnrecs;\n\tint\t\t\tsize;\n\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\tdfp = (xfs_bmdr_block_t *)XFS_DFORK_PTR(dip, whichfork);\n\tsize = XFS_BMAP_BROOT_SPACE(mp, dfp);\n\tnrecs = be16_to_cpu(dfp->bb_numrecs);\n\n\t/*\n\t * blow out if -- fork has less extents than can fit in\n\t * fork (fork shouldn't be a btree format), root btree\n\t * block has more records than can fit into the fork,\n\t * or the number of extents is greater than the number of\n\t * blocks.\n\t */\n\tif (unlikely(XFS_IFORK_NEXTENTS(ip, whichfork) <=\n\t\t\t\t\tXFS_IFORK_MAXEXT(ip, whichfork) ||\n\t\t     XFS_BMDR_SPACE_CALC(nrecs) >\n\t\t\t\t\tXFS_DFORK_SIZE(dip, mp, whichfork) ||\n\t\t     XFS_IFORK_NEXTENTS(ip, whichfork) > ip->i_d.di_nblocks)) {\n\t\txfs_warn(mp, \"corrupt inode %Lu (btree).\",\n\t\t\t\t\t(unsigned long long) ip->i_ino);\n\t\tXFS_CORRUPTION_ERROR(\"xfs_iformat_btree\", XFS_ERRLEVEL_LOW,\n\t\t\t\t\t mp, dip);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\tifp->if_broot_bytes = size;\n\tifp->if_broot = kmem_alloc(size, KM_SLEEP | KM_NOFS);\n\tASSERT(ifp->if_broot != NULL);\n\t/*\n\t * Copy and convert from the on-disk structure\n\t * to the in-memory structure.\n\t */\n\txfs_bmdr_to_bmbt(ip, dfp, XFS_DFORK_SIZE(dip, ip->i_mount, whichfork),\n\t\t\t ifp->if_broot, size);\n\tifp->if_flags &= ~XFS_IFEXTENTS;\n\tifp->if_flags |= XFS_IFBROOT;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_attr_sf.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\"",
      "#include <linux/log2.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC int xfs_iformat_local(xfs_inode_t *, xfs_dinode_t *, int, int);",
      "STATIC int xfs_iformat_extents(xfs_inode_t *, xfs_dinode_t *, int);",
      "STATIC int xfs_iformat_btree(xfs_inode_t *, xfs_dinode_t *, int);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_bmdr_to_bmbt",
          "args": [
            "ip",
            "dfp",
            "XFS_DFORK_SIZE(dip, ip->i_mount, whichfork)",
            "ifp->if_broot",
            "size"
          ],
          "line": 408
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmdr_to_bmbt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap_btree.c",
          "lines": "57-92",
          "snippet": "void\nxfs_bmdr_to_bmbt(\n\tstruct xfs_inode\t*ip,\n\txfs_bmdr_block_t\t*dblock,\n\tint\t\t\tdblocklen,\n\tstruct xfs_btree_block\t*rblock,\n\tint\t\t\trblocklen)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tint\t\t\tdmxr;\n\txfs_bmbt_key_t\t\t*fkp;\n\t__be64\t\t\t*fpp;\n\txfs_bmbt_key_t\t\t*tkp;\n\t__be64\t\t\t*tpp;\n\n\tif (xfs_sb_version_hascrc(&mp->m_sb))\n\t\txfs_btree_init_block_int(mp, rblock, XFS_BUF_DADDR_NULL,\n\t\t\t\t XFS_BMAP_CRC_MAGIC, 0, 0, ip->i_ino,\n\t\t\t\t XFS_BTREE_LONG_PTRS | XFS_BTREE_CRC_BLOCKS);\n\telse\n\t\txfs_btree_init_block_int(mp, rblock, XFS_BUF_DADDR_NULL,\n\t\t\t\t XFS_BMAP_MAGIC, 0, 0, ip->i_ino,\n\t\t\t\t XFS_BTREE_LONG_PTRS);\n\n\trblock->bb_level = dblock->bb_level;\n\tASSERT(be16_to_cpu(rblock->bb_level) > 0);\n\trblock->bb_numrecs = dblock->bb_numrecs;\n\tdmxr = xfs_bmdr_maxrecs(dblocklen, 0);\n\tfkp = XFS_BMDR_KEY_ADDR(dblock, 1);\n\ttkp = XFS_BMBT_KEY_ADDR(mp, rblock, 1);\n\tfpp = XFS_BMDR_PTR_ADDR(dblock, 1, dmxr);\n\ttpp = XFS_BMAP_BROOT_PTR_ADDR(mp, rblock, 1, rblocklen);\n\tdmxr = be16_to_cpu(dblock->bb_numrecs);\n\tmemcpy(tkp, fkp, sizeof(*fkp) * dmxr);\n\tmemcpy(tpp, fpp, sizeof(*fpp) * dmxr);\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nvoid\nxfs_bmdr_to_bmbt(\n\tstruct xfs_inode\t*ip,\n\txfs_bmdr_block_t\t*dblock,\n\tint\t\t\tdblocklen,\n\tstruct xfs_btree_block\t*rblock,\n\tint\t\t\trblocklen)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tint\t\t\tdmxr;\n\txfs_bmbt_key_t\t\t*fkp;\n\t__be64\t\t\t*fpp;\n\txfs_bmbt_key_t\t\t*tkp;\n\t__be64\t\t\t*tpp;\n\n\tif (xfs_sb_version_hascrc(&mp->m_sb))\n\t\txfs_btree_init_block_int(mp, rblock, XFS_BUF_DADDR_NULL,\n\t\t\t\t XFS_BMAP_CRC_MAGIC, 0, 0, ip->i_ino,\n\t\t\t\t XFS_BTREE_LONG_PTRS | XFS_BTREE_CRC_BLOCKS);\n\telse\n\t\txfs_btree_init_block_int(mp, rblock, XFS_BUF_DADDR_NULL,\n\t\t\t\t XFS_BMAP_MAGIC, 0, 0, ip->i_ino,\n\t\t\t\t XFS_BTREE_LONG_PTRS);\n\n\trblock->bb_level = dblock->bb_level;\n\tASSERT(be16_to_cpu(rblock->bb_level) > 0);\n\trblock->bb_numrecs = dblock->bb_numrecs;\n\tdmxr = xfs_bmdr_maxrecs(dblocklen, 0);\n\tfkp = XFS_BMDR_KEY_ADDR(dblock, 1);\n\ttkp = XFS_BMBT_KEY_ADDR(mp, rblock, 1);\n\tfpp = XFS_BMDR_PTR_ADDR(dblock, 1, dmxr);\n\ttpp = XFS_BMAP_BROOT_PTR_ADDR(mp, rblock, 1, rblocklen);\n\tdmxr = be16_to_cpu(dblock->bb_numrecs);\n\tmemcpy(tkp, fkp, sizeof(*fkp) * dmxr);\n\tmemcpy(tpp, fpp, sizeof(*fpp) * dmxr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_DFORK_SIZE",
          "args": [
            "dip",
            "ip->i_mount",
            "whichfork"
          ],
          "line": 408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "ifp->if_broot != NULL"
          ],
          "line": 403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_alloc",
          "args": [
            "size",
            "KM_SLEEP | KM_NOFS"
          ],
          "line": 402
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/kmem.c",
          "lines": "45-62",
          "snippet": "void *\nkmem_alloc(size_t size, xfs_km_flags_t flags)\n{\n\tint\tretries = 0;\n\tgfp_t\tlflags = kmem_flags_convert(flags);\n\tvoid\t*ptr;\n\n\tdo {\n\t\tptr = kmalloc(size, lflags);\n\t\tif (ptr || (flags & (KM_MAYFAIL|KM_NOSLEEP)))\n\t\t\treturn ptr;\n\t\tif (!(++retries % 100))\n\t\t\txfs_err(NULL,\n\t\t\"possible memory allocation deadlock in %s (mode:0x%x)\",\n\t\t\t\t\t__func__, lflags);\n\t\tcongestion_wait(BLK_RW_ASYNC, HZ/50);\n\t} while (1);\n}",
          "includes": [
            "#include \"xfs_message.h\"",
            "#include \"kmem.h\"",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_message.h\"\n#include \"kmem.h\"\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nvoid *\nkmem_alloc(size_t size, xfs_km_flags_t flags)\n{\n\tint\tretries = 0;\n\tgfp_t\tlflags = kmem_flags_convert(flags);\n\tvoid\t*ptr;\n\n\tdo {\n\t\tptr = kmalloc(size, lflags);\n\t\tif (ptr || (flags & (KM_MAYFAIL|KM_NOSLEEP)))\n\t\t\treturn ptr;\n\t\tif (!(++retries % 100))\n\t\t\txfs_err(NULL,\n\t\t\"possible memory allocation deadlock in %s (mode:0x%x)\",\n\t\t\t\t\t__func__, lflags);\n\t\tcongestion_wait(BLK_RW_ASYNC, HZ/50);\n\t} while (1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_CORRUPTION_ERROR",
          "args": [
            "\"xfs_iformat_btree\"",
            "XFS_ERRLEVEL_LOW",
            "mp",
            "dip"
          ],
          "line": 396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_warn",
          "args": [
            "mp",
            "\"corrupt inode %Lu (btree).\"",
            "(unsigned long long) ip->i_ino"
          ],
          "line": 394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "XFS_IFORK_NEXTENTS(ip, whichfork) <=\n\t\t\t\t\tXFS_IFORK_MAXEXT(ip, whichfork) ||\n\t\t     XFS_BMDR_SPACE_CALC(nrecs) >\n\t\t\t\t\tXFS_DFORK_SIZE(dip, mp, whichfork) ||\n\t\t     XFS_IFORK_NEXTENTS(ip, whichfork) > ip->i_d.di_nblocks"
          ],
          "line": 389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_IFORK_NEXTENTS",
          "args": [
            "ip",
            "whichfork"
          ],
          "line": 393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_DFORK_SIZE",
          "args": [
            "dip",
            "mp",
            "whichfork"
          ],
          "line": 392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BMDR_SPACE_CALC",
          "args": [
            "nrecs"
          ],
          "line": 391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_IFORK_MAXEXT",
          "args": [
            "ip",
            "whichfork"
          ],
          "line": 390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_IFORK_NEXTENTS",
          "args": [
            "ip",
            "whichfork"
          ],
          "line": 389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "dfp->bb_numrecs"
          ],
          "line": 380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BMAP_BROOT_SPACE",
          "args": [
            "mp",
            "dfp"
          ],
          "line": 379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_DFORK_PTR",
          "args": [
            "dip",
            "whichfork"
          ],
          "line": 378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_IFORK_PTR",
          "args": [
            "ip",
            "whichfork"
          ],
          "line": 377
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_attr_sf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC int xfs_iformat_local(xfs_inode_t *, xfs_dinode_t *, int, int);\nSTATIC int xfs_iformat_extents(xfs_inode_t *, xfs_dinode_t *, int);\nSTATIC int xfs_iformat_btree(xfs_inode_t *, xfs_dinode_t *, int);\n\nSTATIC int\nxfs_iformat_btree(\n\txfs_inode_t\t\t*ip,\n\txfs_dinode_t\t\t*dip,\n\tint\t\t\twhichfork)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\txfs_bmdr_block_t\t*dfp;\n\txfs_ifork_t\t\t*ifp;\n\t/* REFERENCED */\n\tint\t\t\tnrecs;\n\tint\t\t\tsize;\n\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\tdfp = (xfs_bmdr_block_t *)XFS_DFORK_PTR(dip, whichfork);\n\tsize = XFS_BMAP_BROOT_SPACE(mp, dfp);\n\tnrecs = be16_to_cpu(dfp->bb_numrecs);\n\n\t/*\n\t * blow out if -- fork has less extents than can fit in\n\t * fork (fork shouldn't be a btree format), root btree\n\t * block has more records than can fit into the fork,\n\t * or the number of extents is greater than the number of\n\t * blocks.\n\t */\n\tif (unlikely(XFS_IFORK_NEXTENTS(ip, whichfork) <=\n\t\t\t\t\tXFS_IFORK_MAXEXT(ip, whichfork) ||\n\t\t     XFS_BMDR_SPACE_CALC(nrecs) >\n\t\t\t\t\tXFS_DFORK_SIZE(dip, mp, whichfork) ||\n\t\t     XFS_IFORK_NEXTENTS(ip, whichfork) > ip->i_d.di_nblocks)) {\n\t\txfs_warn(mp, \"corrupt inode %Lu (btree).\",\n\t\t\t\t\t(unsigned long long) ip->i_ino);\n\t\tXFS_CORRUPTION_ERROR(\"xfs_iformat_btree\", XFS_ERRLEVEL_LOW,\n\t\t\t\t\t mp, dip);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\tifp->if_broot_bytes = size;\n\tifp->if_broot = kmem_alloc(size, KM_SLEEP | KM_NOFS);\n\tASSERT(ifp->if_broot != NULL);\n\t/*\n\t * Copy and convert from the on-disk structure\n\t * to the in-memory structure.\n\t */\n\txfs_bmdr_to_bmbt(ip, dfp, XFS_DFORK_SIZE(dip, ip->i_mount, whichfork),\n\t\t\t ifp->if_broot, size);\n\tifp->if_flags &= ~XFS_IFEXTENTS;\n\tifp->if_flags |= XFS_IFBROOT;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_iformat_extents",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_inode_fork.c",
    "lines": "295-354",
    "snippet": "STATIC int\nxfs_iformat_extents(\n\txfs_inode_t\t*ip,\n\txfs_dinode_t\t*dip,\n\tint\t\twhichfork)\n{\n\txfs_bmbt_rec_t\t*dp;\n\txfs_ifork_t\t*ifp;\n\tint\t\tnex;\n\tint\t\tsize;\n\tint\t\ti;\n\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\tnex = XFS_DFORK_NEXTENTS(dip, whichfork);\n\tsize = nex * (uint)sizeof(xfs_bmbt_rec_t);\n\n\t/*\n\t * If the number of extents is unreasonable, then something\n\t * is wrong and we just bail out rather than crash in\n\t * kmem_alloc() or memcpy() below.\n\t */\n\tif (unlikely(size < 0 || size > XFS_DFORK_SIZE(dip, ip->i_mount, whichfork))) {\n\t\txfs_warn(ip->i_mount, \"corrupt inode %Lu ((a)extents = %d).\",\n\t\t\t(unsigned long long) ip->i_ino, nex);\n\t\tXFS_CORRUPTION_ERROR(\"xfs_iformat_extents(1)\", XFS_ERRLEVEL_LOW,\n\t\t\t\t     ip->i_mount, dip);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\tifp->if_real_bytes = 0;\n\tif (nex == 0)\n\t\tifp->if_u1.if_extents = NULL;\n\telse if (nex <= XFS_INLINE_EXTS)\n\t\tifp->if_u1.if_extents = ifp->if_u2.if_inline_ext;\n\telse\n\t\txfs_iext_add(ifp, 0, nex);\n\n\tifp->if_bytes = size;\n\tif (size) {\n\t\tdp = (xfs_bmbt_rec_t *) XFS_DFORK_PTR(dip, whichfork);\n\t\txfs_validate_extents(ifp, nex, XFS_EXTFMT_INODE(ip));\n\t\tfor (i = 0; i < nex; i++, dp++) {\n\t\t\txfs_bmbt_rec_host_t *ep = xfs_iext_get_ext(ifp, i);\n\t\t\tep->l0 = get_unaligned_be64(&dp->l0);\n\t\t\tep->l1 = get_unaligned_be64(&dp->l1);\n\t\t}\n\t\tXFS_BMAP_TRACE_EXLIST(ip, nex, whichfork);\n\t\tif (whichfork != XFS_DATA_FORK ||\n\t\t\tXFS_EXTFMT_INODE(ip) == XFS_EXTFMT_NOSTATE)\n\t\t\t\tif (unlikely(xfs_check_nostate_extents(\n\t\t\t\t    ifp, 0, nex))) {\n\t\t\t\t\tXFS_ERROR_REPORT(\"xfs_iformat_extents(2)\",\n\t\t\t\t\t\t\t XFS_ERRLEVEL_LOW,\n\t\t\t\t\t\t\t ip->i_mount);\n\t\t\t\t\treturn -EFSCORRUPTED;\n\t\t\t\t}\n\t}\n\tifp->if_flags |= XFS_IFEXTENTS;\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_attr_sf.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\"",
      "#include <linux/log2.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC int xfs_iformat_local(xfs_inode_t *, xfs_dinode_t *, int, int);",
      "STATIC int xfs_iformat_extents(xfs_inode_t *, xfs_dinode_t *, int);",
      "STATIC int xfs_iformat_btree(xfs_inode_t *, xfs_dinode_t *, int);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "XFS_ERROR_REPORT",
          "args": [
            "\"xfs_iformat_extents(2)\"",
            "XFS_ERRLEVEL_LOW",
            "ip->i_mount"
          ],
          "line": 346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "xfs_check_nostate_extents(\n\t\t\t\t    ifp, 0, nex)"
          ],
          "line": 344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_check_nostate_extents",
          "args": [
            "ifp",
            "0",
            "nex"
          ],
          "line": 344
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_check_nostate_extents",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap_btree.c",
          "lines": "380-395",
          "snippet": "int\nxfs_check_nostate_extents(\n\txfs_ifork_t\t\t*ifp,\n\txfs_extnum_t\t\tidx,\n\txfs_extnum_t\t\tnum)\n{\n\tfor (; num > 0; num--, idx++) {\n\t\txfs_bmbt_rec_host_t *ep = xfs_iext_get_ext(ifp, idx);\n\t\tif ((ep->l0 >>\n\t\t     (64 - BMBT_EXNTFLAG_BITLEN)) != 0) {\n\t\t\tASSERT(0);\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_check_nostate_extents(\n\txfs_ifork_t\t\t*ifp,\n\txfs_extnum_t\t\tidx,\n\txfs_extnum_t\t\tnum)\n{\n\tfor (; num > 0; num--, idx++) {\n\t\txfs_bmbt_rec_host_t *ep = xfs_iext_get_ext(ifp, idx);\n\t\tif ((ep->l0 >>\n\t\t     (64 - BMBT_EXNTFLAG_BITLEN)) != 0) {\n\t\t\tASSERT(0);\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_EXTFMT_INODE",
          "args": [
            "ip"
          ],
          "line": 343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BMAP_TRACE_EXLIST",
          "args": [
            "ip",
            "nex",
            "whichfork"
          ],
          "line": 341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_unaligned_be64",
          "args": [
            "&dp->l1"
          ],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_unaligned_be64",
          "args": [
            "&dp->l0"
          ],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_iext_get_ext",
          "args": [
            "ifp",
            "i"
          ],
          "line": 337
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_iext_get_ext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_inode_fork.c",
          "lines": "881-903",
          "snippet": "xfs_bmbt_rec_host_t *\nxfs_iext_get_ext(\n\txfs_ifork_t\t*ifp,\t\t/* inode fork pointer */\n\txfs_extnum_t\tidx)\t\t/* index of target extent */\n{\n\tASSERT(idx >= 0);\n\tASSERT(idx < ifp->if_bytes / sizeof(xfs_bmbt_rec_t));\n\n\tif ((ifp->if_flags & XFS_IFEXTIREC) && (idx == 0)) {\n\t\treturn ifp->if_u1.if_ext_irec->er_extbuf;\n\t} else if (ifp->if_flags & XFS_IFEXTIREC) {\n\t\txfs_ext_irec_t\t*erp;\t\t/* irec pointer */\n\t\tint\t\terp_idx = 0;\t/* irec index */\n\t\txfs_extnum_t\tpage_idx = idx;\t/* ext index in target list */\n\n\t\terp = xfs_iext_idx_to_irec(ifp, &page_idx, &erp_idx, 0);\n\t\treturn &erp->er_extbuf[page_idx];\n\t} else if (ifp->if_bytes) {\n\t\treturn &ifp->if_u1.if_extents[idx];\n\t} else {\n\t\treturn NULL;\n\t}\n}",
          "includes": [
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_attr_sf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nxfs_bmbt_rec_host_t *\nxfs_iext_get_ext(\n\txfs_ifork_t\t*ifp,\t\t/* inode fork pointer */\n\txfs_extnum_t\tidx)\t\t/* index of target extent */\n{\n\tASSERT(idx >= 0);\n\tASSERT(idx < ifp->if_bytes / sizeof(xfs_bmbt_rec_t));\n\n\tif ((ifp->if_flags & XFS_IFEXTIREC) && (idx == 0)) {\n\t\treturn ifp->if_u1.if_ext_irec->er_extbuf;\n\t} else if (ifp->if_flags & XFS_IFEXTIREC) {\n\t\txfs_ext_irec_t\t*erp;\t\t/* irec pointer */\n\t\tint\t\terp_idx = 0;\t/* irec index */\n\t\txfs_extnum_t\tpage_idx = idx;\t/* ext index in target list */\n\n\t\terp = xfs_iext_idx_to_irec(ifp, &page_idx, &erp_idx, 0);\n\t\treturn &erp->er_extbuf[page_idx];\n\t} else if (ifp->if_bytes) {\n\t\treturn &ifp->if_u1.if_extents[idx];\n\t} else {\n\t\treturn NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_validate_extents",
          "args": [
            "ifp",
            "nex",
            "XFS_EXTFMT_INODE(ip)"
          ],
          "line": 335
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_validate_extents",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_inode_fork.c",
          "lines": "46-64",
          "snippet": "void\nxfs_validate_extents(\n\txfs_ifork_t\t\t*ifp,\n\tint\t\t\tnrecs,\n\txfs_exntfmt_t\t\tfmt)\n{\n\txfs_bmbt_irec_t\t\tirec;\n\txfs_bmbt_rec_host_t\trec;\n\tint\t\t\ti;\n\n\tfor (i = 0; i < nrecs; i++) {\n\t\txfs_bmbt_rec_host_t *ep = xfs_iext_get_ext(ifp, i);\n\t\trec.l0 = get_unaligned(&ep->l0);\n\t\trec.l1 = get_unaligned(&ep->l1);\n\t\txfs_bmbt_get_all(&rec, &irec);\n\t\tif (fmt == XFS_EXTFMT_NOSTATE)\n\t\t\tASSERT(irec.br_state == XFS_EXT_NORM);\n\t}\n}",
          "includes": [
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_attr_sf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nvoid\nxfs_validate_extents(\n\txfs_ifork_t\t\t*ifp,\n\tint\t\t\tnrecs,\n\txfs_exntfmt_t\t\tfmt)\n{\n\txfs_bmbt_irec_t\t\tirec;\n\txfs_bmbt_rec_host_t\trec;\n\tint\t\t\ti;\n\n\tfor (i = 0; i < nrecs; i++) {\n\t\txfs_bmbt_rec_host_t *ep = xfs_iext_get_ext(ifp, i);\n\t\trec.l0 = get_unaligned(&ep->l0);\n\t\trec.l1 = get_unaligned(&ep->l1);\n\t\txfs_bmbt_get_all(&rec, &irec);\n\t\tif (fmt == XFS_EXTFMT_NOSTATE)\n\t\t\tASSERT(irec.br_state == XFS_EXT_NORM);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_EXTFMT_INODE",
          "args": [
            "ip"
          ],
          "line": 335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_DFORK_PTR",
          "args": [
            "dip",
            "whichfork"
          ],
          "line": 334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_iext_add",
          "args": [
            "ifp",
            "0",
            "nex"
          ],
          "line": 330
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_iext_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_inode_fork.c",
          "lines": "940-1034",
          "snippet": "void\nxfs_iext_add(\n\txfs_ifork_t\t*ifp,\t\t/* inode fork pointer */\n\txfs_extnum_t\tidx,\t\t/* index to begin adding exts */\n\tint\t\text_diff)\t/* number of extents to add */\n{\n\tint\t\tbyte_diff;\t/* new bytes being added */\n\tint\t\tnew_size;\t/* size of extents after adding */\n\txfs_extnum_t\tnextents;\t/* number of extents in file */\n\n\tnextents = ifp->if_bytes / (uint)sizeof(xfs_bmbt_rec_t);\n\tASSERT((idx >= 0) && (idx <= nextents));\n\tbyte_diff = ext_diff * sizeof(xfs_bmbt_rec_t);\n\tnew_size = ifp->if_bytes + byte_diff;\n\t/*\n\t * If the new number of extents (nextents + ext_diff)\n\t * fits inside the inode, then continue to use the inline\n\t * extent buffer.\n\t */\n\tif (nextents + ext_diff <= XFS_INLINE_EXTS) {\n\t\tif (idx < nextents) {\n\t\t\tmemmove(&ifp->if_u2.if_inline_ext[idx + ext_diff],\n\t\t\t\t&ifp->if_u2.if_inline_ext[idx],\n\t\t\t\t(nextents - idx) * sizeof(xfs_bmbt_rec_t));\n\t\t\tmemset(&ifp->if_u2.if_inline_ext[idx], 0, byte_diff);\n\t\t}\n\t\tifp->if_u1.if_extents = ifp->if_u2.if_inline_ext;\n\t\tifp->if_real_bytes = 0;\n\t}\n\t/*\n\t * Otherwise use a linear (direct) extent list.\n\t * If the extents are currently inside the inode,\n\t * xfs_iext_realloc_direct will switch us from\n\t * inline to direct extent allocation mode.\n\t */\n\telse if (nextents + ext_diff <= XFS_LINEAR_EXTS) {\n\t\txfs_iext_realloc_direct(ifp, new_size);\n\t\tif (idx < nextents) {\n\t\t\tmemmove(&ifp->if_u1.if_extents[idx + ext_diff],\n\t\t\t\t&ifp->if_u1.if_extents[idx],\n\t\t\t\t(nextents - idx) * sizeof(xfs_bmbt_rec_t));\n\t\t\tmemset(&ifp->if_u1.if_extents[idx], 0, byte_diff);\n\t\t}\n\t}\n\t/* Indirection array */\n\telse {\n\t\txfs_ext_irec_t\t*erp;\n\t\tint\t\terp_idx = 0;\n\t\tint\t\tpage_idx = idx;\n\n\t\tASSERT(nextents + ext_diff > XFS_LINEAR_EXTS);\n\t\tif (ifp->if_flags & XFS_IFEXTIREC) {\n\t\t\terp = xfs_iext_idx_to_irec(ifp, &page_idx, &erp_idx, 1);\n\t\t} else {\n\t\t\txfs_iext_irec_init(ifp);\n\t\t\tASSERT(ifp->if_flags & XFS_IFEXTIREC);\n\t\t\terp = ifp->if_u1.if_ext_irec;\n\t\t}\n\t\t/* Extents fit in target extent page */\n\t\tif (erp && erp->er_extcount + ext_diff <= XFS_LINEAR_EXTS) {\n\t\t\tif (page_idx < erp->er_extcount) {\n\t\t\t\tmemmove(&erp->er_extbuf[page_idx + ext_diff],\n\t\t\t\t\t&erp->er_extbuf[page_idx],\n\t\t\t\t\t(erp->er_extcount - page_idx) *\n\t\t\t\t\tsizeof(xfs_bmbt_rec_t));\n\t\t\t\tmemset(&erp->er_extbuf[page_idx], 0, byte_diff);\n\t\t\t}\n\t\t\terp->er_extcount += ext_diff;\n\t\t\txfs_iext_irec_update_extoffs(ifp, erp_idx + 1, ext_diff);\n\t\t}\n\t\t/* Insert a new extent page */\n\t\telse if (erp) {\n\t\t\txfs_iext_add_indirect_multi(ifp,\n\t\t\t\terp_idx, page_idx, ext_diff);\n\t\t}\n\t\t/*\n\t\t * If extent(s) are being appended to the last page in\n\t\t * the indirection array and the new extent(s) don't fit\n\t\t * in the page, then erp is NULL and erp_idx is set to\n\t\t * the next index needed in the indirection array.\n\t\t */\n\t\telse {\n\t\t\tuint\tcount = ext_diff;\n\n\t\t\twhile (count) {\n\t\t\t\terp = xfs_iext_irec_new(ifp, erp_idx);\n\t\t\t\terp->er_extcount = min(count, XFS_LINEAR_EXTS);\n\t\t\t\tcount -= erp->er_extcount;\n\t\t\t\tif (count)\n\t\t\t\t\terp_idx++;\n\t\t\t}\n\t\t}\n\t}\n\tifp->if_bytes = new_size;\n}",
          "includes": [
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_attr_sf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nvoid\nxfs_iext_add(\n\txfs_ifork_t\t*ifp,\t\t/* inode fork pointer */\n\txfs_extnum_t\tidx,\t\t/* index to begin adding exts */\n\tint\t\text_diff)\t/* number of extents to add */\n{\n\tint\t\tbyte_diff;\t/* new bytes being added */\n\tint\t\tnew_size;\t/* size of extents after adding */\n\txfs_extnum_t\tnextents;\t/* number of extents in file */\n\n\tnextents = ifp->if_bytes / (uint)sizeof(xfs_bmbt_rec_t);\n\tASSERT((idx >= 0) && (idx <= nextents));\n\tbyte_diff = ext_diff * sizeof(xfs_bmbt_rec_t);\n\tnew_size = ifp->if_bytes + byte_diff;\n\t/*\n\t * If the new number of extents (nextents + ext_diff)\n\t * fits inside the inode, then continue to use the inline\n\t * extent buffer.\n\t */\n\tif (nextents + ext_diff <= XFS_INLINE_EXTS) {\n\t\tif (idx < nextents) {\n\t\t\tmemmove(&ifp->if_u2.if_inline_ext[idx + ext_diff],\n\t\t\t\t&ifp->if_u2.if_inline_ext[idx],\n\t\t\t\t(nextents - idx) * sizeof(xfs_bmbt_rec_t));\n\t\t\tmemset(&ifp->if_u2.if_inline_ext[idx], 0, byte_diff);\n\t\t}\n\t\tifp->if_u1.if_extents = ifp->if_u2.if_inline_ext;\n\t\tifp->if_real_bytes = 0;\n\t}\n\t/*\n\t * Otherwise use a linear (direct) extent list.\n\t * If the extents are currently inside the inode,\n\t * xfs_iext_realloc_direct will switch us from\n\t * inline to direct extent allocation mode.\n\t */\n\telse if (nextents + ext_diff <= XFS_LINEAR_EXTS) {\n\t\txfs_iext_realloc_direct(ifp, new_size);\n\t\tif (idx < nextents) {\n\t\t\tmemmove(&ifp->if_u1.if_extents[idx + ext_diff],\n\t\t\t\t&ifp->if_u1.if_extents[idx],\n\t\t\t\t(nextents - idx) * sizeof(xfs_bmbt_rec_t));\n\t\t\tmemset(&ifp->if_u1.if_extents[idx], 0, byte_diff);\n\t\t}\n\t}\n\t/* Indirection array */\n\telse {\n\t\txfs_ext_irec_t\t*erp;\n\t\tint\t\terp_idx = 0;\n\t\tint\t\tpage_idx = idx;\n\n\t\tASSERT(nextents + ext_diff > XFS_LINEAR_EXTS);\n\t\tif (ifp->if_flags & XFS_IFEXTIREC) {\n\t\t\terp = xfs_iext_idx_to_irec(ifp, &page_idx, &erp_idx, 1);\n\t\t} else {\n\t\t\txfs_iext_irec_init(ifp);\n\t\t\tASSERT(ifp->if_flags & XFS_IFEXTIREC);\n\t\t\terp = ifp->if_u1.if_ext_irec;\n\t\t}\n\t\t/* Extents fit in target extent page */\n\t\tif (erp && erp->er_extcount + ext_diff <= XFS_LINEAR_EXTS) {\n\t\t\tif (page_idx < erp->er_extcount) {\n\t\t\t\tmemmove(&erp->er_extbuf[page_idx + ext_diff],\n\t\t\t\t\t&erp->er_extbuf[page_idx],\n\t\t\t\t\t(erp->er_extcount - page_idx) *\n\t\t\t\t\tsizeof(xfs_bmbt_rec_t));\n\t\t\t\tmemset(&erp->er_extbuf[page_idx], 0, byte_diff);\n\t\t\t}\n\t\t\terp->er_extcount += ext_diff;\n\t\t\txfs_iext_irec_update_extoffs(ifp, erp_idx + 1, ext_diff);\n\t\t}\n\t\t/* Insert a new extent page */\n\t\telse if (erp) {\n\t\t\txfs_iext_add_indirect_multi(ifp,\n\t\t\t\terp_idx, page_idx, ext_diff);\n\t\t}\n\t\t/*\n\t\t * If extent(s) are being appended to the last page in\n\t\t * the indirection array and the new extent(s) don't fit\n\t\t * in the page, then erp is NULL and erp_idx is set to\n\t\t * the next index needed in the indirection array.\n\t\t */\n\t\telse {\n\t\t\tuint\tcount = ext_diff;\n\n\t\t\twhile (count) {\n\t\t\t\terp = xfs_iext_irec_new(ifp, erp_idx);\n\t\t\t\terp->er_extcount = min(count, XFS_LINEAR_EXTS);\n\t\t\t\tcount -= erp->er_extcount;\n\t\t\t\tif (count)\n\t\t\t\t\terp_idx++;\n\t\t\t}\n\t\t}\n\t}\n\tifp->if_bytes = new_size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_CORRUPTION_ERROR",
          "args": [
            "\"xfs_iformat_extents(1)\"",
            "XFS_ERRLEVEL_LOW",
            "ip->i_mount",
            "dip"
          ],
          "line": 319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_warn",
          "args": [
            "ip->i_mount",
            "\"corrupt inode %Lu ((a)extents = %d).\"",
            "(unsigned long long) ip->i_ino",
            "nex"
          ],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "size < 0 || size > XFS_DFORK_SIZE(dip, ip->i_mount, whichfork)"
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_DFORK_SIZE",
          "args": [
            "dip",
            "ip->i_mount",
            "whichfork"
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_DFORK_NEXTENTS",
          "args": [
            "dip",
            "whichfork"
          ],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_IFORK_PTR",
          "args": [
            "ip",
            "whichfork"
          ],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_attr_sf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC int xfs_iformat_local(xfs_inode_t *, xfs_dinode_t *, int, int);\nSTATIC int xfs_iformat_extents(xfs_inode_t *, xfs_dinode_t *, int);\nSTATIC int xfs_iformat_btree(xfs_inode_t *, xfs_dinode_t *, int);\n\nSTATIC int\nxfs_iformat_extents(\n\txfs_inode_t\t*ip,\n\txfs_dinode_t\t*dip,\n\tint\t\twhichfork)\n{\n\txfs_bmbt_rec_t\t*dp;\n\txfs_ifork_t\t*ifp;\n\tint\t\tnex;\n\tint\t\tsize;\n\tint\t\ti;\n\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\tnex = XFS_DFORK_NEXTENTS(dip, whichfork);\n\tsize = nex * (uint)sizeof(xfs_bmbt_rec_t);\n\n\t/*\n\t * If the number of extents is unreasonable, then something\n\t * is wrong and we just bail out rather than crash in\n\t * kmem_alloc() or memcpy() below.\n\t */\n\tif (unlikely(size < 0 || size > XFS_DFORK_SIZE(dip, ip->i_mount, whichfork))) {\n\t\txfs_warn(ip->i_mount, \"corrupt inode %Lu ((a)extents = %d).\",\n\t\t\t(unsigned long long) ip->i_ino, nex);\n\t\tXFS_CORRUPTION_ERROR(\"xfs_iformat_extents(1)\", XFS_ERRLEVEL_LOW,\n\t\t\t\t     ip->i_mount, dip);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\tifp->if_real_bytes = 0;\n\tif (nex == 0)\n\t\tifp->if_u1.if_extents = NULL;\n\telse if (nex <= XFS_INLINE_EXTS)\n\t\tifp->if_u1.if_extents = ifp->if_u2.if_inline_ext;\n\telse\n\t\txfs_iext_add(ifp, 0, nex);\n\n\tifp->if_bytes = size;\n\tif (size) {\n\t\tdp = (xfs_bmbt_rec_t *) XFS_DFORK_PTR(dip, whichfork);\n\t\txfs_validate_extents(ifp, nex, XFS_EXTFMT_INODE(ip));\n\t\tfor (i = 0; i < nex; i++, dp++) {\n\t\t\txfs_bmbt_rec_host_t *ep = xfs_iext_get_ext(ifp, i);\n\t\t\tep->l0 = get_unaligned_be64(&dp->l0);\n\t\t\tep->l1 = get_unaligned_be64(&dp->l1);\n\t\t}\n\t\tXFS_BMAP_TRACE_EXLIST(ip, nex, whichfork);\n\t\tif (whichfork != XFS_DATA_FORK ||\n\t\t\tXFS_EXTFMT_INODE(ip) == XFS_EXTFMT_NOSTATE)\n\t\t\t\tif (unlikely(xfs_check_nostate_extents(\n\t\t\t\t    ifp, 0, nex))) {\n\t\t\t\t\tXFS_ERROR_REPORT(\"xfs_iformat_extents(2)\",\n\t\t\t\t\t\t\t XFS_ERRLEVEL_LOW,\n\t\t\t\t\t\t\t ip->i_mount);\n\t\t\t\t\treturn -EFSCORRUPTED;\n\t\t\t\t}\n\t}\n\tifp->if_flags |= XFS_IFEXTENTS;\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_iformat_local",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_inode_fork.c",
    "lines": "243-284",
    "snippet": "STATIC int\nxfs_iformat_local(\n\txfs_inode_t\t*ip,\n\txfs_dinode_t\t*dip,\n\tint\t\twhichfork,\n\tint\t\tsize)\n{\n\txfs_ifork_t\t*ifp;\n\tint\t\treal_size;\n\n\t/*\n\t * If the size is unreasonable, then something\n\t * is wrong and we just bail out rather than crash in\n\t * kmem_alloc() or memcpy() below.\n\t */\n\tif (unlikely(size > XFS_DFORK_SIZE(dip, ip->i_mount, whichfork))) {\n\t\txfs_warn(ip->i_mount,\n\t\"corrupt inode %Lu (bad size %d for local fork, size = %d).\",\n\t\t\t(unsigned long long) ip->i_ino, size,\n\t\t\tXFS_DFORK_SIZE(dip, ip->i_mount, whichfork));\n\t\tXFS_CORRUPTION_ERROR(\"xfs_iformat_local\", XFS_ERRLEVEL_LOW,\n\t\t\t\t     ip->i_mount, dip);\n\t\treturn -EFSCORRUPTED;\n\t}\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\treal_size = 0;\n\tif (size == 0)\n\t\tifp->if_u1.if_data = NULL;\n\telse if (size <= sizeof(ifp->if_u2.if_inline_data))\n\t\tifp->if_u1.if_data = ifp->if_u2.if_inline_data;\n\telse {\n\t\treal_size = roundup(size, 4);\n\t\tifp->if_u1.if_data = kmem_alloc(real_size, KM_SLEEP | KM_NOFS);\n\t}\n\tifp->if_bytes = size;\n\tifp->if_real_bytes = real_size;\n\tif (size)\n\t\tmemcpy(ifp->if_u1.if_data, XFS_DFORK_PTR(dip, whichfork), size);\n\tifp->if_flags &= ~XFS_IFEXTENTS;\n\tifp->if_flags |= XFS_IFINLINE;\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_attr_sf.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\"",
      "#include <linux/log2.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC int xfs_iformat_local(xfs_inode_t *, xfs_dinode_t *, int, int);",
      "STATIC int xfs_iformat_extents(xfs_inode_t *, xfs_dinode_t *, int);",
      "STATIC int xfs_iformat_btree(xfs_inode_t *, xfs_dinode_t *, int);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "ifp->if_u1.if_data",
            "XFS_DFORK_PTR(dip, whichfork)",
            "size"
          ],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_DFORK_PTR",
          "args": [
            "dip",
            "whichfork"
          ],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_alloc",
          "args": [
            "real_size",
            "KM_SLEEP | KM_NOFS"
          ],
          "line": 275
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/kmem.c",
          "lines": "45-62",
          "snippet": "void *\nkmem_alloc(size_t size, xfs_km_flags_t flags)\n{\n\tint\tretries = 0;\n\tgfp_t\tlflags = kmem_flags_convert(flags);\n\tvoid\t*ptr;\n\n\tdo {\n\t\tptr = kmalloc(size, lflags);\n\t\tif (ptr || (flags & (KM_MAYFAIL|KM_NOSLEEP)))\n\t\t\treturn ptr;\n\t\tif (!(++retries % 100))\n\t\t\txfs_err(NULL,\n\t\t\"possible memory allocation deadlock in %s (mode:0x%x)\",\n\t\t\t\t\t__func__, lflags);\n\t\tcongestion_wait(BLK_RW_ASYNC, HZ/50);\n\t} while (1);\n}",
          "includes": [
            "#include \"xfs_message.h\"",
            "#include \"kmem.h\"",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_message.h\"\n#include \"kmem.h\"\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nvoid *\nkmem_alloc(size_t size, xfs_km_flags_t flags)\n{\n\tint\tretries = 0;\n\tgfp_t\tlflags = kmem_flags_convert(flags);\n\tvoid\t*ptr;\n\n\tdo {\n\t\tptr = kmalloc(size, lflags);\n\t\tif (ptr || (flags & (KM_MAYFAIL|KM_NOSLEEP)))\n\t\t\treturn ptr;\n\t\tif (!(++retries % 100))\n\t\t\txfs_err(NULL,\n\t\t\"possible memory allocation deadlock in %s (mode:0x%x)\",\n\t\t\t\t\t__func__, lflags);\n\t\tcongestion_wait(BLK_RW_ASYNC, HZ/50);\n\t} while (1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "roundup",
          "args": [
            "size",
            "4"
          ],
          "line": 274
        },
        "resolved": true,
        "details": {
          "function_name": "roundup_64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_linux.h",
          "lines": "333-338",
          "snippet": "static inline __uint64_t roundup_64(__uint64_t x, __uint32_t y)\n{\n\tx += y - 1;\n\tdo_div(x, y);\n\treturn x * y;\n}",
          "includes": [
            "#include \"xfs_message.h\"",
            "#include \"xfs_buf.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_super.h\"",
            "#include \"xfs_aops.h\"",
            "#include \"xfs_iops.h\"",
            "#include \"xfs_sysctl.h\"",
            "#include \"xfs_stats.h\"",
            "#include \"xfs_fs.h\"",
            "#include <asm/unaligned.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/param.h>",
            "#include <asm/div64.h>",
            "#include <asm/page.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/capability.h>",
            "#include <linux/writeback.h>",
            "#include <linux/ctype.h>",
            "#include <linux/random.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/log2.h>",
            "#include <linux/delay.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sort.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/list.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/vfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/major.h>",
            "#include <linux/bitops.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>",
            "#include <linux/swap.h>",
            "#include <linux/file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/crc32c.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mm.h>",
            "#include <linux/semaphore.h>",
            "#include \"uuid.h\"",
            "#include \"mrlock.h\"",
            "#include \"kmem.h\"",
            "#include \"xfs_types.h\"",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_message.h\"\n#include \"xfs_buf.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_super.h\"\n#include \"xfs_aops.h\"\n#include \"xfs_iops.h\"\n#include \"xfs_sysctl.h\"\n#include \"xfs_stats.h\"\n#include \"xfs_fs.h\"\n#include <asm/unaligned.h>\n#include <asm/byteorder.h>\n#include <asm/uaccess.h>\n#include <asm/param.h>\n#include <asm/div64.h>\n#include <asm/page.h>\n#include <linux/ratelimit.h>\n#include <linux/list_sort.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/capability.h>\n#include <linux/writeback.h>\n#include <linux/ctype.h>\n#include <linux/random.h>\n#include <linux/spinlock.h>\n#include <linux/log2.h>\n#include <linux/delay.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/sort.h>\n#include <linux/proc_fs.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/vfs.h>\n#include <linux/pagemap.h>\n#include <linux/major.h>\n#include <linux/bitops.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/swap.h>\n#include <linux/file.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/crc32c.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n#include <linux/mm.h>\n#include <linux/semaphore.h>\n#include \"uuid.h\"\n#include \"mrlock.h\"\n#include \"kmem.h\"\n#include \"xfs_types.h\"\n#include <linux/types.h>\n\nstatic inline __uint64_t roundup_64(__uint64_t x, __uint32_t y)\n{\n\tx += y - 1;\n\tdo_div(x, y);\n\treturn x * y;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_IFORK_PTR",
          "args": [
            "ip",
            "whichfork"
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_CORRUPTION_ERROR",
          "args": [
            "\"xfs_iformat_local\"",
            "XFS_ERRLEVEL_LOW",
            "ip->i_mount",
            "dip"
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_warn",
          "args": [
            "ip->i_mount",
            "\"corrupt inode %Lu (bad size %d for local fork, size = %d).\"",
            "(unsigned long long) ip->i_ino",
            "size",
            "XFS_DFORK_SIZE(dip, ip->i_mount, whichfork)"
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_DFORK_SIZE",
          "args": [
            "dip",
            "ip->i_mount",
            "whichfork"
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "size > XFS_DFORK_SIZE(dip, ip->i_mount, whichfork)"
          ],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_DFORK_SIZE",
          "args": [
            "dip",
            "ip->i_mount",
            "whichfork"
          ],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_attr_sf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC int xfs_iformat_local(xfs_inode_t *, xfs_dinode_t *, int, int);\nSTATIC int xfs_iformat_extents(xfs_inode_t *, xfs_dinode_t *, int);\nSTATIC int xfs_iformat_btree(xfs_inode_t *, xfs_dinode_t *, int);\n\nSTATIC int\nxfs_iformat_local(\n\txfs_inode_t\t*ip,\n\txfs_dinode_t\t*dip,\n\tint\t\twhichfork,\n\tint\t\tsize)\n{\n\txfs_ifork_t\t*ifp;\n\tint\t\treal_size;\n\n\t/*\n\t * If the size is unreasonable, then something\n\t * is wrong and we just bail out rather than crash in\n\t * kmem_alloc() or memcpy() below.\n\t */\n\tif (unlikely(size > XFS_DFORK_SIZE(dip, ip->i_mount, whichfork))) {\n\t\txfs_warn(ip->i_mount,\n\t\"corrupt inode %Lu (bad size %d for local fork, size = %d).\",\n\t\t\t(unsigned long long) ip->i_ino, size,\n\t\t\tXFS_DFORK_SIZE(dip, ip->i_mount, whichfork));\n\t\tXFS_CORRUPTION_ERROR(\"xfs_iformat_local\", XFS_ERRLEVEL_LOW,\n\t\t\t\t     ip->i_mount, dip);\n\t\treturn -EFSCORRUPTED;\n\t}\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\treal_size = 0;\n\tif (size == 0)\n\t\tifp->if_u1.if_data = NULL;\n\telse if (size <= sizeof(ifp->if_u2.if_inline_data))\n\t\tifp->if_u1.if_data = ifp->if_u2.if_inline_data;\n\telse {\n\t\treal_size = roundup(size, 4);\n\t\tifp->if_u1.if_data = kmem_alloc(real_size, KM_SLEEP | KM_NOFS);\n\t}\n\tifp->if_bytes = size;\n\tifp->if_real_bytes = real_size;\n\tif (size)\n\t\tmemcpy(ifp->if_u1.if_data, XFS_DFORK_PTR(dip, whichfork), size);\n\tifp->if_flags &= ~XFS_IFEXTENTS;\n\tifp->if_flags |= XFS_IFINLINE;\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_iformat_fork",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_inode_fork.c",
    "lines": "79-231",
    "snippet": "int\nxfs_iformat_fork(\n\txfs_inode_t\t\t*ip,\n\txfs_dinode_t\t\t*dip)\n{\n\txfs_attr_shortform_t\t*atp;\n\tint\t\t\tsize;\n\tint\t\t\terror = 0;\n\txfs_fsize_t             di_size;\n\n\tif (unlikely(be32_to_cpu(dip->di_nextents) +\n\t\t     be16_to_cpu(dip->di_anextents) >\n\t\t     be64_to_cpu(dip->di_nblocks))) {\n\t\txfs_warn(ip->i_mount,\n\t\t\t\"corrupt dinode %Lu, extent total = %d, nblocks = %Lu.\",\n\t\t\t(unsigned long long)ip->i_ino,\n\t\t\t(int)(be32_to_cpu(dip->di_nextents) +\n\t\t\t      be16_to_cpu(dip->di_anextents)),\n\t\t\t(unsigned long long)\n\t\t\t\tbe64_to_cpu(dip->di_nblocks));\n\t\tXFS_CORRUPTION_ERROR(\"xfs_iformat(1)\", XFS_ERRLEVEL_LOW,\n\t\t\t\t     ip->i_mount, dip);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\tif (unlikely(dip->di_forkoff > ip->i_mount->m_sb.sb_inodesize)) {\n\t\txfs_warn(ip->i_mount, \"corrupt dinode %Lu, forkoff = 0x%x.\",\n\t\t\t(unsigned long long)ip->i_ino,\n\t\t\tdip->di_forkoff);\n\t\tXFS_CORRUPTION_ERROR(\"xfs_iformat(2)\", XFS_ERRLEVEL_LOW,\n\t\t\t\t     ip->i_mount, dip);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\tif (unlikely((ip->i_d.di_flags & XFS_DIFLAG_REALTIME) &&\n\t\t     !ip->i_mount->m_rtdev_targp)) {\n\t\txfs_warn(ip->i_mount,\n\t\t\t\"corrupt dinode %Lu, has realtime flag set.\",\n\t\t\tip->i_ino);\n\t\tXFS_CORRUPTION_ERROR(\"xfs_iformat(realtime)\",\n\t\t\t\t     XFS_ERRLEVEL_LOW, ip->i_mount, dip);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\tswitch (ip->i_d.di_mode & S_IFMT) {\n\tcase S_IFIFO:\n\tcase S_IFCHR:\n\tcase S_IFBLK:\n\tcase S_IFSOCK:\n\t\tif (unlikely(dip->di_format != XFS_DINODE_FMT_DEV)) {\n\t\t\tXFS_CORRUPTION_ERROR(\"xfs_iformat(3)\", XFS_ERRLEVEL_LOW,\n\t\t\t\t\t      ip->i_mount, dip);\n\t\t\treturn -EFSCORRUPTED;\n\t\t}\n\t\tip->i_d.di_size = 0;\n\t\tip->i_df.if_u2.if_rdev = xfs_dinode_get_rdev(dip);\n\t\tbreak;\n\n\tcase S_IFREG:\n\tcase S_IFLNK:\n\tcase S_IFDIR:\n\t\tswitch (dip->di_format) {\n\t\tcase XFS_DINODE_FMT_LOCAL:\n\t\t\t/*\n\t\t\t * no local regular files yet\n\t\t\t */\n\t\t\tif (unlikely(S_ISREG(be16_to_cpu(dip->di_mode)))) {\n\t\t\t\txfs_warn(ip->i_mount,\n\t\t\t\"corrupt inode %Lu (local format for regular file).\",\n\t\t\t\t\t(unsigned long long) ip->i_ino);\n\t\t\t\tXFS_CORRUPTION_ERROR(\"xfs_iformat(4)\",\n\t\t\t\t\t\t     XFS_ERRLEVEL_LOW,\n\t\t\t\t\t\t     ip->i_mount, dip);\n\t\t\t\treturn -EFSCORRUPTED;\n\t\t\t}\n\n\t\t\tdi_size = be64_to_cpu(dip->di_size);\n\t\t\tif (unlikely(di_size < 0 ||\n\t\t\t\t     di_size > XFS_DFORK_DSIZE(dip, ip->i_mount))) {\n\t\t\t\txfs_warn(ip->i_mount,\n\t\t\t\"corrupt inode %Lu (bad size %Ld for local inode).\",\n\t\t\t\t\t(unsigned long long) ip->i_ino,\n\t\t\t\t\t(long long) di_size);\n\t\t\t\tXFS_CORRUPTION_ERROR(\"xfs_iformat(5)\",\n\t\t\t\t\t\t     XFS_ERRLEVEL_LOW,\n\t\t\t\t\t\t     ip->i_mount, dip);\n\t\t\t\treturn -EFSCORRUPTED;\n\t\t\t}\n\n\t\t\tsize = (int)di_size;\n\t\t\terror = xfs_iformat_local(ip, dip, XFS_DATA_FORK, size);\n\t\t\tbreak;\n\t\tcase XFS_DINODE_FMT_EXTENTS:\n\t\t\terror = xfs_iformat_extents(ip, dip, XFS_DATA_FORK);\n\t\t\tbreak;\n\t\tcase XFS_DINODE_FMT_BTREE:\n\t\t\terror = xfs_iformat_btree(ip, dip, XFS_DATA_FORK);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tXFS_ERROR_REPORT(\"xfs_iformat(6)\", XFS_ERRLEVEL_LOW,\n\t\t\t\t\t ip->i_mount);\n\t\t\treturn -EFSCORRUPTED;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tXFS_ERROR_REPORT(\"xfs_iformat(7)\", XFS_ERRLEVEL_LOW, ip->i_mount);\n\t\treturn -EFSCORRUPTED;\n\t}\n\tif (error) {\n\t\treturn error;\n\t}\n\tif (!XFS_DFORK_Q(dip))\n\t\treturn 0;\n\n\tASSERT(ip->i_afp == NULL);\n\tip->i_afp = kmem_zone_zalloc(xfs_ifork_zone, KM_SLEEP | KM_NOFS);\n\n\tswitch (dip->di_aformat) {\n\tcase XFS_DINODE_FMT_LOCAL:\n\t\tatp = (xfs_attr_shortform_t *)XFS_DFORK_APTR(dip);\n\t\tsize = be16_to_cpu(atp->hdr.totsize);\n\n\t\tif (unlikely(size < sizeof(struct xfs_attr_sf_hdr))) {\n\t\t\txfs_warn(ip->i_mount,\n\t\t\t\t\"corrupt inode %Lu (bad attr fork size %Ld).\",\n\t\t\t\t(unsigned long long) ip->i_ino,\n\t\t\t\t(long long) size);\n\t\t\tXFS_CORRUPTION_ERROR(\"xfs_iformat(8)\",\n\t\t\t\t\t     XFS_ERRLEVEL_LOW,\n\t\t\t\t\t     ip->i_mount, dip);\n\t\t\treturn -EFSCORRUPTED;\n\t\t}\n\n\t\terror = xfs_iformat_local(ip, dip, XFS_ATTR_FORK, size);\n\t\tbreak;\n\tcase XFS_DINODE_FMT_EXTENTS:\n\t\terror = xfs_iformat_extents(ip, dip, XFS_ATTR_FORK);\n\t\tbreak;\n\tcase XFS_DINODE_FMT_BTREE:\n\t\terror = xfs_iformat_btree(ip, dip, XFS_ATTR_FORK);\n\t\tbreak;\n\tdefault:\n\t\terror = -EFSCORRUPTED;\n\t\tbreak;\n\t}\n\tif (error) {\n\t\tkmem_zone_free(xfs_ifork_zone, ip->i_afp);\n\t\tip->i_afp = NULL;\n\t\txfs_idestroy_fork(ip, XFS_DATA_FORK);\n\t}\n\treturn error;\n}",
    "includes": [
      "#include \"xfs_attr_sf.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\"",
      "#include <linux/log2.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "kmem_zone_t *xfs_ifork_zone;",
      "STATIC int xfs_iformat_local(xfs_inode_t *, xfs_dinode_t *, int, int);",
      "STATIC int xfs_iformat_extents(xfs_inode_t *, xfs_dinode_t *, int);",
      "STATIC int xfs_iformat_btree(xfs_inode_t *, xfs_dinode_t *, int);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_idestroy_fork",
          "args": [
            "ip",
            "XFS_DATA_FORK"
          ],
          "line": 228
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_idestroy_fork",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_inode_fork.c",
          "lines": "678-719",
          "snippet": "void\nxfs_idestroy_fork(\n\txfs_inode_t\t*ip,\n\tint\t\twhichfork)\n{\n\txfs_ifork_t\t*ifp;\n\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\tif (ifp->if_broot != NULL) {\n\t\tkmem_free(ifp->if_broot);\n\t\tifp->if_broot = NULL;\n\t}\n\n\t/*\n\t * If the format is local, then we can't have an extents\n\t * array so just look for an inline data array.  If we're\n\t * not local then we may or may not have an extents list,\n\t * so check and free it up if we do.\n\t */\n\tif (XFS_IFORK_FORMAT(ip, whichfork) == XFS_DINODE_FMT_LOCAL) {\n\t\tif ((ifp->if_u1.if_data != ifp->if_u2.if_inline_data) &&\n\t\t    (ifp->if_u1.if_data != NULL)) {\n\t\t\tASSERT(ifp->if_real_bytes != 0);\n\t\t\tkmem_free(ifp->if_u1.if_data);\n\t\t\tifp->if_u1.if_data = NULL;\n\t\t\tifp->if_real_bytes = 0;\n\t\t}\n\t} else if ((ifp->if_flags & XFS_IFEXTENTS) &&\n\t\t   ((ifp->if_flags & XFS_IFEXTIREC) ||\n\t\t    ((ifp->if_u1.if_extents != NULL) &&\n\t\t     (ifp->if_u1.if_extents != ifp->if_u2.if_inline_ext)))) {\n\t\tASSERT(ifp->if_real_bytes != 0);\n\t\txfs_iext_destroy(ifp);\n\t}\n\tASSERT(ifp->if_u1.if_extents == NULL ||\n\t       ifp->if_u1.if_extents == ifp->if_u2.if_inline_ext);\n\tASSERT(ifp->if_real_bytes == 0);\n\tif (whichfork == XFS_ATTR_FORK) {\n\t\tkmem_zone_free(xfs_ifork_zone, ip->i_afp);\n\t\tip->i_afp = NULL;\n\t}\n}",
          "includes": [
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "kmem_zone_t *xfs_ifork_zone;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_attr_sf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nkmem_zone_t *xfs_ifork_zone;\n\nvoid\nxfs_idestroy_fork(\n\txfs_inode_t\t*ip,\n\tint\t\twhichfork)\n{\n\txfs_ifork_t\t*ifp;\n\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\tif (ifp->if_broot != NULL) {\n\t\tkmem_free(ifp->if_broot);\n\t\tifp->if_broot = NULL;\n\t}\n\n\t/*\n\t * If the format is local, then we can't have an extents\n\t * array so just look for an inline data array.  If we're\n\t * not local then we may or may not have an extents list,\n\t * so check and free it up if we do.\n\t */\n\tif (XFS_IFORK_FORMAT(ip, whichfork) == XFS_DINODE_FMT_LOCAL) {\n\t\tif ((ifp->if_u1.if_data != ifp->if_u2.if_inline_data) &&\n\t\t    (ifp->if_u1.if_data != NULL)) {\n\t\t\tASSERT(ifp->if_real_bytes != 0);\n\t\t\tkmem_free(ifp->if_u1.if_data);\n\t\t\tifp->if_u1.if_data = NULL;\n\t\t\tifp->if_real_bytes = 0;\n\t\t}\n\t} else if ((ifp->if_flags & XFS_IFEXTENTS) &&\n\t\t   ((ifp->if_flags & XFS_IFEXTIREC) ||\n\t\t    ((ifp->if_u1.if_extents != NULL) &&\n\t\t     (ifp->if_u1.if_extents != ifp->if_u2.if_inline_ext)))) {\n\t\tASSERT(ifp->if_real_bytes != 0);\n\t\txfs_iext_destroy(ifp);\n\t}\n\tASSERT(ifp->if_u1.if_extents == NULL ||\n\t       ifp->if_u1.if_extents == ifp->if_u2.if_inline_ext);\n\tASSERT(ifp->if_real_bytes == 0);\n\tif (whichfork == XFS_ATTR_FORK) {\n\t\tkmem_zone_free(xfs_ifork_zone, ip->i_afp);\n\t\tip->i_afp = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmem_zone_free",
          "args": [
            "xfs_ifork_zone",
            "ip->i_afp"
          ],
          "line": 226
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_zone_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/kmem.h",
          "lines": "104-108",
          "snippet": "static inline void\nkmem_zone_free(kmem_zone_t *zone, void *ptr)\n{\n\tkmem_cache_free(zone, ptr);\n}",
          "includes": [
            "#include <linux/vmalloc.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [
            "#define kmem_zone_t\tstruct kmem_cache"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n\n#define kmem_zone_t\tstruct kmem_cache\n\nstatic inline void\nkmem_zone_free(kmem_zone_t *zone, void *ptr)\n{\n\tkmem_cache_free(zone, ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_iformat_btree",
          "args": [
            "ip",
            "dip",
            "XFS_ATTR_FORK"
          ],
          "line": 219
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_iformat_btree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_inode_fork.c",
          "lines": "364-414",
          "snippet": "STATIC int\nxfs_iformat_btree(\n\txfs_inode_t\t\t*ip,\n\txfs_dinode_t\t\t*dip,\n\tint\t\t\twhichfork)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\txfs_bmdr_block_t\t*dfp;\n\txfs_ifork_t\t\t*ifp;\n\t/* REFERENCED */\n\tint\t\t\tnrecs;\n\tint\t\t\tsize;\n\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\tdfp = (xfs_bmdr_block_t *)XFS_DFORK_PTR(dip, whichfork);\n\tsize = XFS_BMAP_BROOT_SPACE(mp, dfp);\n\tnrecs = be16_to_cpu(dfp->bb_numrecs);\n\n\t/*\n\t * blow out if -- fork has less extents than can fit in\n\t * fork (fork shouldn't be a btree format), root btree\n\t * block has more records than can fit into the fork,\n\t * or the number of extents is greater than the number of\n\t * blocks.\n\t */\n\tif (unlikely(XFS_IFORK_NEXTENTS(ip, whichfork) <=\n\t\t\t\t\tXFS_IFORK_MAXEXT(ip, whichfork) ||\n\t\t     XFS_BMDR_SPACE_CALC(nrecs) >\n\t\t\t\t\tXFS_DFORK_SIZE(dip, mp, whichfork) ||\n\t\t     XFS_IFORK_NEXTENTS(ip, whichfork) > ip->i_d.di_nblocks)) {\n\t\txfs_warn(mp, \"corrupt inode %Lu (btree).\",\n\t\t\t\t\t(unsigned long long) ip->i_ino);\n\t\tXFS_CORRUPTION_ERROR(\"xfs_iformat_btree\", XFS_ERRLEVEL_LOW,\n\t\t\t\t\t mp, dip);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\tifp->if_broot_bytes = size;\n\tifp->if_broot = kmem_alloc(size, KM_SLEEP | KM_NOFS);\n\tASSERT(ifp->if_broot != NULL);\n\t/*\n\t * Copy and convert from the on-disk structure\n\t * to the in-memory structure.\n\t */\n\txfs_bmdr_to_bmbt(ip, dfp, XFS_DFORK_SIZE(dip, ip->i_mount, whichfork),\n\t\t\t ifp->if_broot, size);\n\tifp->if_flags &= ~XFS_IFEXTENTS;\n\tifp->if_flags |= XFS_IFBROOT;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_iformat_local(xfs_inode_t *, xfs_dinode_t *, int, int);",
            "STATIC int xfs_iformat_extents(xfs_inode_t *, xfs_dinode_t *, int);",
            "STATIC int xfs_iformat_btree(xfs_inode_t *, xfs_dinode_t *, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_attr_sf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC int xfs_iformat_local(xfs_inode_t *, xfs_dinode_t *, int, int);\nSTATIC int xfs_iformat_extents(xfs_inode_t *, xfs_dinode_t *, int);\nSTATIC int xfs_iformat_btree(xfs_inode_t *, xfs_dinode_t *, int);\n\nSTATIC int\nxfs_iformat_btree(\n\txfs_inode_t\t\t*ip,\n\txfs_dinode_t\t\t*dip,\n\tint\t\t\twhichfork)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\txfs_bmdr_block_t\t*dfp;\n\txfs_ifork_t\t\t*ifp;\n\t/* REFERENCED */\n\tint\t\t\tnrecs;\n\tint\t\t\tsize;\n\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\tdfp = (xfs_bmdr_block_t *)XFS_DFORK_PTR(dip, whichfork);\n\tsize = XFS_BMAP_BROOT_SPACE(mp, dfp);\n\tnrecs = be16_to_cpu(dfp->bb_numrecs);\n\n\t/*\n\t * blow out if -- fork has less extents than can fit in\n\t * fork (fork shouldn't be a btree format), root btree\n\t * block has more records than can fit into the fork,\n\t * or the number of extents is greater than the number of\n\t * blocks.\n\t */\n\tif (unlikely(XFS_IFORK_NEXTENTS(ip, whichfork) <=\n\t\t\t\t\tXFS_IFORK_MAXEXT(ip, whichfork) ||\n\t\t     XFS_BMDR_SPACE_CALC(nrecs) >\n\t\t\t\t\tXFS_DFORK_SIZE(dip, mp, whichfork) ||\n\t\t     XFS_IFORK_NEXTENTS(ip, whichfork) > ip->i_d.di_nblocks)) {\n\t\txfs_warn(mp, \"corrupt inode %Lu (btree).\",\n\t\t\t\t\t(unsigned long long) ip->i_ino);\n\t\tXFS_CORRUPTION_ERROR(\"xfs_iformat_btree\", XFS_ERRLEVEL_LOW,\n\t\t\t\t\t mp, dip);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\tifp->if_broot_bytes = size;\n\tifp->if_broot = kmem_alloc(size, KM_SLEEP | KM_NOFS);\n\tASSERT(ifp->if_broot != NULL);\n\t/*\n\t * Copy and convert from the on-disk structure\n\t * to the in-memory structure.\n\t */\n\txfs_bmdr_to_bmbt(ip, dfp, XFS_DFORK_SIZE(dip, ip->i_mount, whichfork),\n\t\t\t ifp->if_broot, size);\n\tifp->if_flags &= ~XFS_IFEXTENTS;\n\tifp->if_flags |= XFS_IFBROOT;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_iformat_extents",
          "args": [
            "ip",
            "dip",
            "XFS_ATTR_FORK"
          ],
          "line": 216
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_iformat_extents",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_inode_fork.c",
          "lines": "295-354",
          "snippet": "STATIC int\nxfs_iformat_extents(\n\txfs_inode_t\t*ip,\n\txfs_dinode_t\t*dip,\n\tint\t\twhichfork)\n{\n\txfs_bmbt_rec_t\t*dp;\n\txfs_ifork_t\t*ifp;\n\tint\t\tnex;\n\tint\t\tsize;\n\tint\t\ti;\n\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\tnex = XFS_DFORK_NEXTENTS(dip, whichfork);\n\tsize = nex * (uint)sizeof(xfs_bmbt_rec_t);\n\n\t/*\n\t * If the number of extents is unreasonable, then something\n\t * is wrong and we just bail out rather than crash in\n\t * kmem_alloc() or memcpy() below.\n\t */\n\tif (unlikely(size < 0 || size > XFS_DFORK_SIZE(dip, ip->i_mount, whichfork))) {\n\t\txfs_warn(ip->i_mount, \"corrupt inode %Lu ((a)extents = %d).\",\n\t\t\t(unsigned long long) ip->i_ino, nex);\n\t\tXFS_CORRUPTION_ERROR(\"xfs_iformat_extents(1)\", XFS_ERRLEVEL_LOW,\n\t\t\t\t     ip->i_mount, dip);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\tifp->if_real_bytes = 0;\n\tif (nex == 0)\n\t\tifp->if_u1.if_extents = NULL;\n\telse if (nex <= XFS_INLINE_EXTS)\n\t\tifp->if_u1.if_extents = ifp->if_u2.if_inline_ext;\n\telse\n\t\txfs_iext_add(ifp, 0, nex);\n\n\tifp->if_bytes = size;\n\tif (size) {\n\t\tdp = (xfs_bmbt_rec_t *) XFS_DFORK_PTR(dip, whichfork);\n\t\txfs_validate_extents(ifp, nex, XFS_EXTFMT_INODE(ip));\n\t\tfor (i = 0; i < nex; i++, dp++) {\n\t\t\txfs_bmbt_rec_host_t *ep = xfs_iext_get_ext(ifp, i);\n\t\t\tep->l0 = get_unaligned_be64(&dp->l0);\n\t\t\tep->l1 = get_unaligned_be64(&dp->l1);\n\t\t}\n\t\tXFS_BMAP_TRACE_EXLIST(ip, nex, whichfork);\n\t\tif (whichfork != XFS_DATA_FORK ||\n\t\t\tXFS_EXTFMT_INODE(ip) == XFS_EXTFMT_NOSTATE)\n\t\t\t\tif (unlikely(xfs_check_nostate_extents(\n\t\t\t\t    ifp, 0, nex))) {\n\t\t\t\t\tXFS_ERROR_REPORT(\"xfs_iformat_extents(2)\",\n\t\t\t\t\t\t\t XFS_ERRLEVEL_LOW,\n\t\t\t\t\t\t\t ip->i_mount);\n\t\t\t\t\treturn -EFSCORRUPTED;\n\t\t\t\t}\n\t}\n\tifp->if_flags |= XFS_IFEXTENTS;\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_iformat_local(xfs_inode_t *, xfs_dinode_t *, int, int);",
            "STATIC int xfs_iformat_extents(xfs_inode_t *, xfs_dinode_t *, int);",
            "STATIC int xfs_iformat_btree(xfs_inode_t *, xfs_dinode_t *, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_attr_sf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC int xfs_iformat_local(xfs_inode_t *, xfs_dinode_t *, int, int);\nSTATIC int xfs_iformat_extents(xfs_inode_t *, xfs_dinode_t *, int);\nSTATIC int xfs_iformat_btree(xfs_inode_t *, xfs_dinode_t *, int);\n\nSTATIC int\nxfs_iformat_extents(\n\txfs_inode_t\t*ip,\n\txfs_dinode_t\t*dip,\n\tint\t\twhichfork)\n{\n\txfs_bmbt_rec_t\t*dp;\n\txfs_ifork_t\t*ifp;\n\tint\t\tnex;\n\tint\t\tsize;\n\tint\t\ti;\n\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\tnex = XFS_DFORK_NEXTENTS(dip, whichfork);\n\tsize = nex * (uint)sizeof(xfs_bmbt_rec_t);\n\n\t/*\n\t * If the number of extents is unreasonable, then something\n\t * is wrong and we just bail out rather than crash in\n\t * kmem_alloc() or memcpy() below.\n\t */\n\tif (unlikely(size < 0 || size > XFS_DFORK_SIZE(dip, ip->i_mount, whichfork))) {\n\t\txfs_warn(ip->i_mount, \"corrupt inode %Lu ((a)extents = %d).\",\n\t\t\t(unsigned long long) ip->i_ino, nex);\n\t\tXFS_CORRUPTION_ERROR(\"xfs_iformat_extents(1)\", XFS_ERRLEVEL_LOW,\n\t\t\t\t     ip->i_mount, dip);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\tifp->if_real_bytes = 0;\n\tif (nex == 0)\n\t\tifp->if_u1.if_extents = NULL;\n\telse if (nex <= XFS_INLINE_EXTS)\n\t\tifp->if_u1.if_extents = ifp->if_u2.if_inline_ext;\n\telse\n\t\txfs_iext_add(ifp, 0, nex);\n\n\tifp->if_bytes = size;\n\tif (size) {\n\t\tdp = (xfs_bmbt_rec_t *) XFS_DFORK_PTR(dip, whichfork);\n\t\txfs_validate_extents(ifp, nex, XFS_EXTFMT_INODE(ip));\n\t\tfor (i = 0; i < nex; i++, dp++) {\n\t\t\txfs_bmbt_rec_host_t *ep = xfs_iext_get_ext(ifp, i);\n\t\t\tep->l0 = get_unaligned_be64(&dp->l0);\n\t\t\tep->l1 = get_unaligned_be64(&dp->l1);\n\t\t}\n\t\tXFS_BMAP_TRACE_EXLIST(ip, nex, whichfork);\n\t\tif (whichfork != XFS_DATA_FORK ||\n\t\t\tXFS_EXTFMT_INODE(ip) == XFS_EXTFMT_NOSTATE)\n\t\t\t\tif (unlikely(xfs_check_nostate_extents(\n\t\t\t\t    ifp, 0, nex))) {\n\t\t\t\t\tXFS_ERROR_REPORT(\"xfs_iformat_extents(2)\",\n\t\t\t\t\t\t\t XFS_ERRLEVEL_LOW,\n\t\t\t\t\t\t\t ip->i_mount);\n\t\t\t\t\treturn -EFSCORRUPTED;\n\t\t\t\t}\n\t}\n\tifp->if_flags |= XFS_IFEXTENTS;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_iformat_local",
          "args": [
            "ip",
            "dip",
            "XFS_ATTR_FORK",
            "size"
          ],
          "line": 213
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_iformat_local",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_inode_fork.c",
          "lines": "243-284",
          "snippet": "STATIC int\nxfs_iformat_local(\n\txfs_inode_t\t*ip,\n\txfs_dinode_t\t*dip,\n\tint\t\twhichfork,\n\tint\t\tsize)\n{\n\txfs_ifork_t\t*ifp;\n\tint\t\treal_size;\n\n\t/*\n\t * If the size is unreasonable, then something\n\t * is wrong and we just bail out rather than crash in\n\t * kmem_alloc() or memcpy() below.\n\t */\n\tif (unlikely(size > XFS_DFORK_SIZE(dip, ip->i_mount, whichfork))) {\n\t\txfs_warn(ip->i_mount,\n\t\"corrupt inode %Lu (bad size %d for local fork, size = %d).\",\n\t\t\t(unsigned long long) ip->i_ino, size,\n\t\t\tXFS_DFORK_SIZE(dip, ip->i_mount, whichfork));\n\t\tXFS_CORRUPTION_ERROR(\"xfs_iformat_local\", XFS_ERRLEVEL_LOW,\n\t\t\t\t     ip->i_mount, dip);\n\t\treturn -EFSCORRUPTED;\n\t}\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\treal_size = 0;\n\tif (size == 0)\n\t\tifp->if_u1.if_data = NULL;\n\telse if (size <= sizeof(ifp->if_u2.if_inline_data))\n\t\tifp->if_u1.if_data = ifp->if_u2.if_inline_data;\n\telse {\n\t\treal_size = roundup(size, 4);\n\t\tifp->if_u1.if_data = kmem_alloc(real_size, KM_SLEEP | KM_NOFS);\n\t}\n\tifp->if_bytes = size;\n\tifp->if_real_bytes = real_size;\n\tif (size)\n\t\tmemcpy(ifp->if_u1.if_data, XFS_DFORK_PTR(dip, whichfork), size);\n\tifp->if_flags &= ~XFS_IFEXTENTS;\n\tifp->if_flags |= XFS_IFINLINE;\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_iformat_local(xfs_inode_t *, xfs_dinode_t *, int, int);",
            "STATIC int xfs_iformat_extents(xfs_inode_t *, xfs_dinode_t *, int);",
            "STATIC int xfs_iformat_btree(xfs_inode_t *, xfs_dinode_t *, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_attr_sf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC int xfs_iformat_local(xfs_inode_t *, xfs_dinode_t *, int, int);\nSTATIC int xfs_iformat_extents(xfs_inode_t *, xfs_dinode_t *, int);\nSTATIC int xfs_iformat_btree(xfs_inode_t *, xfs_dinode_t *, int);\n\nSTATIC int\nxfs_iformat_local(\n\txfs_inode_t\t*ip,\n\txfs_dinode_t\t*dip,\n\tint\t\twhichfork,\n\tint\t\tsize)\n{\n\txfs_ifork_t\t*ifp;\n\tint\t\treal_size;\n\n\t/*\n\t * If the size is unreasonable, then something\n\t * is wrong and we just bail out rather than crash in\n\t * kmem_alloc() or memcpy() below.\n\t */\n\tif (unlikely(size > XFS_DFORK_SIZE(dip, ip->i_mount, whichfork))) {\n\t\txfs_warn(ip->i_mount,\n\t\"corrupt inode %Lu (bad size %d for local fork, size = %d).\",\n\t\t\t(unsigned long long) ip->i_ino, size,\n\t\t\tXFS_DFORK_SIZE(dip, ip->i_mount, whichfork));\n\t\tXFS_CORRUPTION_ERROR(\"xfs_iformat_local\", XFS_ERRLEVEL_LOW,\n\t\t\t\t     ip->i_mount, dip);\n\t\treturn -EFSCORRUPTED;\n\t}\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\treal_size = 0;\n\tif (size == 0)\n\t\tifp->if_u1.if_data = NULL;\n\telse if (size <= sizeof(ifp->if_u2.if_inline_data))\n\t\tifp->if_u1.if_data = ifp->if_u2.if_inline_data;\n\telse {\n\t\treal_size = roundup(size, 4);\n\t\tifp->if_u1.if_data = kmem_alloc(real_size, KM_SLEEP | KM_NOFS);\n\t}\n\tifp->if_bytes = size;\n\tifp->if_real_bytes = real_size;\n\tif (size)\n\t\tmemcpy(ifp->if_u1.if_data, XFS_DFORK_PTR(dip, whichfork), size);\n\tifp->if_flags &= ~XFS_IFEXTENTS;\n\tifp->if_flags |= XFS_IFINLINE;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_CORRUPTION_ERROR",
          "args": [
            "\"xfs_iformat(8)\"",
            "XFS_ERRLEVEL_LOW",
            "ip->i_mount",
            "dip"
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_warn",
          "args": [
            "ip->i_mount",
            "\"corrupt inode %Lu (bad attr fork size %Ld).\"",
            "(unsigned long long) ip->i_ino",
            "(long long) size"
          ],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "size < sizeof(struct xfs_attr_sf_hdr)"
          ],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "atp->hdr.totsize"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_DFORK_APTR",
          "args": [
            "dip"
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_zone_zalloc",
          "args": [
            "xfs_ifork_zone",
            "KM_SLEEP | KM_NOFS"
          ],
          "line": 195
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_zone_zalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/kmem.h",
          "lines": "119-123",
          "snippet": "static inline void *\nkmem_zone_zalloc(kmem_zone_t *zone, xfs_km_flags_t flags)\n{\n\treturn kmem_zone_alloc(zone, flags | KM_ZERO);\n}",
          "includes": [
            "#include <linux/vmalloc.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [
            "#define kmem_zone_t\tstruct kmem_cache",
            "#define KM_ZERO\t\t((__force xfs_km_flags_t)0x0010u)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n\n#define kmem_zone_t\tstruct kmem_cache\n#define KM_ZERO\t\t((__force xfs_km_flags_t)0x0010u)\n\nstatic inline void *\nkmem_zone_zalloc(kmem_zone_t *zone, xfs_km_flags_t flags)\n{\n\treturn kmem_zone_alloc(zone, flags | KM_ZERO);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "ip->i_afp == NULL"
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_DFORK_Q",
          "args": [
            "dip"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_ERROR_REPORT",
          "args": [
            "\"xfs_iformat(7)\"",
            "XFS_ERRLEVEL_LOW",
            "ip->i_mount"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_ERROR_REPORT",
          "args": [
            "\"xfs_iformat(6)\"",
            "XFS_ERRLEVEL_LOW",
            "ip->i_mount"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_CORRUPTION_ERROR",
          "args": [
            "\"xfs_iformat(5)\"",
            "XFS_ERRLEVEL_LOW",
            "ip->i_mount",
            "dip"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_warn",
          "args": [
            "ip->i_mount",
            "\"corrupt inode %Lu (bad size %Ld for local inode).\"",
            "(unsigned long long) ip->i_ino",
            "(long long) di_size"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "di_size < 0 ||\n\t\t\t\t     di_size > XFS_DFORK_DSIZE(dip, ip->i_mount)"
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_DFORK_DSIZE",
          "args": [
            "dip",
            "ip->i_mount"
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "dip->di_size"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_CORRUPTION_ERROR",
          "args": [
            "\"xfs_iformat(4)\"",
            "XFS_ERRLEVEL_LOW",
            "ip->i_mount",
            "dip"
          ],
          "line": 149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_warn",
          "args": [
            "ip->i_mount",
            "\"corrupt inode %Lu (local format for regular file).\"",
            "(unsigned long long) ip->i_ino"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "S_ISREG(be16_to_cpu(dip->di_mode))"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "be16_to_cpu(dip->di_mode)"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "dip->di_mode"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dinode_get_rdev",
          "args": [
            "dip"
          ],
          "line": 134
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dinode_get_rdev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_format.h",
          "lines": "1018-1021",
          "snippet": "static inline xfs_dev_t xfs_dinode_get_rdev(struct xfs_dinode *dip)\n{\n\treturn be32_to_cpu(*(__be32 *)XFS_DFORK_DPTR(dip));\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline xfs_dev_t xfs_dinode_get_rdev(struct xfs_dinode *dip)\n{\n\treturn be32_to_cpu(*(__be32 *)XFS_DFORK_DPTR(dip));\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_CORRUPTION_ERROR",
          "args": [
            "\"xfs_iformat(3)\"",
            "XFS_ERRLEVEL_LOW",
            "ip->i_mount",
            "dip"
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "dip->di_format != XFS_DINODE_FMT_DEV"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_CORRUPTION_ERROR",
          "args": [
            "\"xfs_iformat(realtime)\"",
            "XFS_ERRLEVEL_LOW",
            "ip->i_mount",
            "dip"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_warn",
          "args": [
            "ip->i_mount",
            "\"corrupt dinode %Lu, has realtime flag set.\"",
            "ip->i_ino"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "(ip->i_d.di_flags & XFS_DIFLAG_REALTIME) &&\n\t\t     !ip->i_mount->m_rtdev_targp"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_CORRUPTION_ERROR",
          "args": [
            "\"xfs_iformat(2)\"",
            "XFS_ERRLEVEL_LOW",
            "ip->i_mount",
            "dip"
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_warn",
          "args": [
            "ip->i_mount",
            "\"corrupt dinode %Lu, forkoff = 0x%x.\"",
            "(unsigned long long)ip->i_ino",
            "dip->di_forkoff"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "dip->di_forkoff > ip->i_mount->m_sb.sb_inodesize"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_CORRUPTION_ERROR",
          "args": [
            "\"xfs_iformat(1)\"",
            "XFS_ERRLEVEL_LOW",
            "ip->i_mount",
            "dip"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_warn",
          "args": [
            "ip->i_mount",
            "\"corrupt dinode %Lu, extent total = %d, nblocks = %Lu.\"",
            "(unsigned long long)ip->i_ino",
            "(int)(be32_to_cpu(dip->di_nextents) +\n\t\t\t      be16_to_cpu(dip->di_anextents))",
            "(unsigned long long)\n\t\t\t\tbe64_to_cpu(dip->di_nblocks)"
          ],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "dip->di_nblocks"
          ],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "dip->di_anextents"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "dip->di_nextents"
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "be32_to_cpu(dip->di_nextents) +\n\t\t     be16_to_cpu(dip->di_anextents) >\n\t\t     be64_to_cpu(dip->di_nblocks)"
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "dip->di_nblocks"
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "dip->di_anextents"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "dip->di_nextents"
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_attr_sf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nkmem_zone_t *xfs_ifork_zone;\nSTATIC int xfs_iformat_local(xfs_inode_t *, xfs_dinode_t *, int, int);\nSTATIC int xfs_iformat_extents(xfs_inode_t *, xfs_dinode_t *, int);\nSTATIC int xfs_iformat_btree(xfs_inode_t *, xfs_dinode_t *, int);\n\nint\nxfs_iformat_fork(\n\txfs_inode_t\t\t*ip,\n\txfs_dinode_t\t\t*dip)\n{\n\txfs_attr_shortform_t\t*atp;\n\tint\t\t\tsize;\n\tint\t\t\terror = 0;\n\txfs_fsize_t             di_size;\n\n\tif (unlikely(be32_to_cpu(dip->di_nextents) +\n\t\t     be16_to_cpu(dip->di_anextents) >\n\t\t     be64_to_cpu(dip->di_nblocks))) {\n\t\txfs_warn(ip->i_mount,\n\t\t\t\"corrupt dinode %Lu, extent total = %d, nblocks = %Lu.\",\n\t\t\t(unsigned long long)ip->i_ino,\n\t\t\t(int)(be32_to_cpu(dip->di_nextents) +\n\t\t\t      be16_to_cpu(dip->di_anextents)),\n\t\t\t(unsigned long long)\n\t\t\t\tbe64_to_cpu(dip->di_nblocks));\n\t\tXFS_CORRUPTION_ERROR(\"xfs_iformat(1)\", XFS_ERRLEVEL_LOW,\n\t\t\t\t     ip->i_mount, dip);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\tif (unlikely(dip->di_forkoff > ip->i_mount->m_sb.sb_inodesize)) {\n\t\txfs_warn(ip->i_mount, \"corrupt dinode %Lu, forkoff = 0x%x.\",\n\t\t\t(unsigned long long)ip->i_ino,\n\t\t\tdip->di_forkoff);\n\t\tXFS_CORRUPTION_ERROR(\"xfs_iformat(2)\", XFS_ERRLEVEL_LOW,\n\t\t\t\t     ip->i_mount, dip);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\tif (unlikely((ip->i_d.di_flags & XFS_DIFLAG_REALTIME) &&\n\t\t     !ip->i_mount->m_rtdev_targp)) {\n\t\txfs_warn(ip->i_mount,\n\t\t\t\"corrupt dinode %Lu, has realtime flag set.\",\n\t\t\tip->i_ino);\n\t\tXFS_CORRUPTION_ERROR(\"xfs_iformat(realtime)\",\n\t\t\t\t     XFS_ERRLEVEL_LOW, ip->i_mount, dip);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\tswitch (ip->i_d.di_mode & S_IFMT) {\n\tcase S_IFIFO:\n\tcase S_IFCHR:\n\tcase S_IFBLK:\n\tcase S_IFSOCK:\n\t\tif (unlikely(dip->di_format != XFS_DINODE_FMT_DEV)) {\n\t\t\tXFS_CORRUPTION_ERROR(\"xfs_iformat(3)\", XFS_ERRLEVEL_LOW,\n\t\t\t\t\t      ip->i_mount, dip);\n\t\t\treturn -EFSCORRUPTED;\n\t\t}\n\t\tip->i_d.di_size = 0;\n\t\tip->i_df.if_u2.if_rdev = xfs_dinode_get_rdev(dip);\n\t\tbreak;\n\n\tcase S_IFREG:\n\tcase S_IFLNK:\n\tcase S_IFDIR:\n\t\tswitch (dip->di_format) {\n\t\tcase XFS_DINODE_FMT_LOCAL:\n\t\t\t/*\n\t\t\t * no local regular files yet\n\t\t\t */\n\t\t\tif (unlikely(S_ISREG(be16_to_cpu(dip->di_mode)))) {\n\t\t\t\txfs_warn(ip->i_mount,\n\t\t\t\"corrupt inode %Lu (local format for regular file).\",\n\t\t\t\t\t(unsigned long long) ip->i_ino);\n\t\t\t\tXFS_CORRUPTION_ERROR(\"xfs_iformat(4)\",\n\t\t\t\t\t\t     XFS_ERRLEVEL_LOW,\n\t\t\t\t\t\t     ip->i_mount, dip);\n\t\t\t\treturn -EFSCORRUPTED;\n\t\t\t}\n\n\t\t\tdi_size = be64_to_cpu(dip->di_size);\n\t\t\tif (unlikely(di_size < 0 ||\n\t\t\t\t     di_size > XFS_DFORK_DSIZE(dip, ip->i_mount))) {\n\t\t\t\txfs_warn(ip->i_mount,\n\t\t\t\"corrupt inode %Lu (bad size %Ld for local inode).\",\n\t\t\t\t\t(unsigned long long) ip->i_ino,\n\t\t\t\t\t(long long) di_size);\n\t\t\t\tXFS_CORRUPTION_ERROR(\"xfs_iformat(5)\",\n\t\t\t\t\t\t     XFS_ERRLEVEL_LOW,\n\t\t\t\t\t\t     ip->i_mount, dip);\n\t\t\t\treturn -EFSCORRUPTED;\n\t\t\t}\n\n\t\t\tsize = (int)di_size;\n\t\t\terror = xfs_iformat_local(ip, dip, XFS_DATA_FORK, size);\n\t\t\tbreak;\n\t\tcase XFS_DINODE_FMT_EXTENTS:\n\t\t\terror = xfs_iformat_extents(ip, dip, XFS_DATA_FORK);\n\t\t\tbreak;\n\t\tcase XFS_DINODE_FMT_BTREE:\n\t\t\terror = xfs_iformat_btree(ip, dip, XFS_DATA_FORK);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tXFS_ERROR_REPORT(\"xfs_iformat(6)\", XFS_ERRLEVEL_LOW,\n\t\t\t\t\t ip->i_mount);\n\t\t\treturn -EFSCORRUPTED;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tXFS_ERROR_REPORT(\"xfs_iformat(7)\", XFS_ERRLEVEL_LOW, ip->i_mount);\n\t\treturn -EFSCORRUPTED;\n\t}\n\tif (error) {\n\t\treturn error;\n\t}\n\tif (!XFS_DFORK_Q(dip))\n\t\treturn 0;\n\n\tASSERT(ip->i_afp == NULL);\n\tip->i_afp = kmem_zone_zalloc(xfs_ifork_zone, KM_SLEEP | KM_NOFS);\n\n\tswitch (dip->di_aformat) {\n\tcase XFS_DINODE_FMT_LOCAL:\n\t\tatp = (xfs_attr_shortform_t *)XFS_DFORK_APTR(dip);\n\t\tsize = be16_to_cpu(atp->hdr.totsize);\n\n\t\tif (unlikely(size < sizeof(struct xfs_attr_sf_hdr))) {\n\t\t\txfs_warn(ip->i_mount,\n\t\t\t\t\"corrupt inode %Lu (bad attr fork size %Ld).\",\n\t\t\t\t(unsigned long long) ip->i_ino,\n\t\t\t\t(long long) size);\n\t\t\tXFS_CORRUPTION_ERROR(\"xfs_iformat(8)\",\n\t\t\t\t\t     XFS_ERRLEVEL_LOW,\n\t\t\t\t\t     ip->i_mount, dip);\n\t\t\treturn -EFSCORRUPTED;\n\t\t}\n\n\t\terror = xfs_iformat_local(ip, dip, XFS_ATTR_FORK, size);\n\t\tbreak;\n\tcase XFS_DINODE_FMT_EXTENTS:\n\t\terror = xfs_iformat_extents(ip, dip, XFS_ATTR_FORK);\n\t\tbreak;\n\tcase XFS_DINODE_FMT_BTREE:\n\t\terror = xfs_iformat_btree(ip, dip, XFS_ATTR_FORK);\n\t\tbreak;\n\tdefault:\n\t\terror = -EFSCORRUPTED;\n\t\tbreak;\n\t}\n\tif (error) {\n\t\tkmem_zone_free(xfs_ifork_zone, ip->i_afp);\n\t\tip->i_afp = NULL;\n\t\txfs_idestroy_fork(ip, XFS_DATA_FORK);\n\t}\n\treturn error;\n}"
  },
  {
    "function_name": "xfs_validate_extents",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_inode_fork.c",
    "lines": "46-64",
    "snippet": "void\nxfs_validate_extents(\n\txfs_ifork_t\t\t*ifp,\n\tint\t\t\tnrecs,\n\txfs_exntfmt_t\t\tfmt)\n{\n\txfs_bmbt_irec_t\t\tirec;\n\txfs_bmbt_rec_host_t\trec;\n\tint\t\t\ti;\n\n\tfor (i = 0; i < nrecs; i++) {\n\t\txfs_bmbt_rec_host_t *ep = xfs_iext_get_ext(ifp, i);\n\t\trec.l0 = get_unaligned(&ep->l0);\n\t\trec.l1 = get_unaligned(&ep->l1);\n\t\txfs_bmbt_get_all(&rec, &irec);\n\t\tif (fmt == XFS_EXTFMT_NOSTATE)\n\t\t\tASSERT(irec.br_state == XFS_EXT_NORM);\n\t}\n}",
    "includes": [
      "#include \"xfs_attr_sf.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\"",
      "#include <linux/log2.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "irec.br_state == XFS_EXT_NORM"
          ],
          "line": 62
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_bmbt_get_all",
          "args": [
            "&rec",
            "&irec"
          ],
          "line": 60
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmbt_get_all",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap_btree.c",
          "lines": "123-129",
          "snippet": "void\nxfs_bmbt_get_all(\n\txfs_bmbt_rec_host_t *r,\n\txfs_bmbt_irec_t *s)\n{\n\t__xfs_bmbt_get_all(r->l0, r->l1, s);\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_bmbt_get_all(\n\txfs_bmbt_rec_host_t *r,\n\txfs_bmbt_irec_t *s)\n{\n\t__xfs_bmbt_get_all(r->l0, r->l1, s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_unaligned",
          "args": [
            "&ep->l1"
          ],
          "line": 59
        },
        "resolved": true,
        "details": {
          "function_name": "get_unaligned_le8",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/struct-funcs.c",
          "lines": "24-27",
          "snippet": "static inline u8 get_unaligned_le8(const void *p)\n{\n       return *(u8 *)p;\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/highmem.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/highmem.h>\n\nstatic inline u8 get_unaligned_le8(const void *p)\n{\n       return *(u8 *)p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_iext_get_ext",
          "args": [
            "ifp",
            "i"
          ],
          "line": 57
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_iext_get_ext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_inode_fork.c",
          "lines": "881-903",
          "snippet": "xfs_bmbt_rec_host_t *\nxfs_iext_get_ext(\n\txfs_ifork_t\t*ifp,\t\t/* inode fork pointer */\n\txfs_extnum_t\tidx)\t\t/* index of target extent */\n{\n\tASSERT(idx >= 0);\n\tASSERT(idx < ifp->if_bytes / sizeof(xfs_bmbt_rec_t));\n\n\tif ((ifp->if_flags & XFS_IFEXTIREC) && (idx == 0)) {\n\t\treturn ifp->if_u1.if_ext_irec->er_extbuf;\n\t} else if (ifp->if_flags & XFS_IFEXTIREC) {\n\t\txfs_ext_irec_t\t*erp;\t\t/* irec pointer */\n\t\tint\t\terp_idx = 0;\t/* irec index */\n\t\txfs_extnum_t\tpage_idx = idx;\t/* ext index in target list */\n\n\t\terp = xfs_iext_idx_to_irec(ifp, &page_idx, &erp_idx, 0);\n\t\treturn &erp->er_extbuf[page_idx];\n\t} else if (ifp->if_bytes) {\n\t\treturn &ifp->if_u1.if_extents[idx];\n\t} else {\n\t\treturn NULL;\n\t}\n}",
          "includes": [
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_attr_sf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nxfs_bmbt_rec_host_t *\nxfs_iext_get_ext(\n\txfs_ifork_t\t*ifp,\t\t/* inode fork pointer */\n\txfs_extnum_t\tidx)\t\t/* index of target extent */\n{\n\tASSERT(idx >= 0);\n\tASSERT(idx < ifp->if_bytes / sizeof(xfs_bmbt_rec_t));\n\n\tif ((ifp->if_flags & XFS_IFEXTIREC) && (idx == 0)) {\n\t\treturn ifp->if_u1.if_ext_irec->er_extbuf;\n\t} else if (ifp->if_flags & XFS_IFEXTIREC) {\n\t\txfs_ext_irec_t\t*erp;\t\t/* irec pointer */\n\t\tint\t\terp_idx = 0;\t/* irec index */\n\t\txfs_extnum_t\tpage_idx = idx;\t/* ext index in target list */\n\n\t\terp = xfs_iext_idx_to_irec(ifp, &page_idx, &erp_idx, 0);\n\t\treturn &erp->er_extbuf[page_idx];\n\t} else if (ifp->if_bytes) {\n\t\treturn &ifp->if_u1.if_extents[idx];\n\t} else {\n\t\treturn NULL;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_attr_sf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nvoid\nxfs_validate_extents(\n\txfs_ifork_t\t\t*ifp,\n\tint\t\t\tnrecs,\n\txfs_exntfmt_t\t\tfmt)\n{\n\txfs_bmbt_irec_t\t\tirec;\n\txfs_bmbt_rec_host_t\trec;\n\tint\t\t\ti;\n\n\tfor (i = 0; i < nrecs; i++) {\n\t\txfs_bmbt_rec_host_t *ep = xfs_iext_get_ext(ifp, i);\n\t\trec.l0 = get_unaligned(&ep->l0);\n\t\trec.l1 = get_unaligned(&ep->l1);\n\t\txfs_bmbt_get_all(&rec, &irec);\n\t\tif (fmt == XFS_EXTFMT_NOSTATE)\n\t\t\tASSERT(irec.br_state == XFS_EXT_NORM);\n\t}\n}"
  }
]